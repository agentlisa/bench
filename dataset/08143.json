{
  "Title": "[L-06] Operator: missing check for configParmas\\[0] (cushionFactor) in the constructor",
  "Content": "\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L92-L150>\n*   <https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L516-L524>\n\nThe `Operator::constructor` does not check the condition of the `cushionFactor`. Below is the condition for the `cushionFactor` checked in the `Operator::setCushionFactor`.\n\n```solidity\n// Operator::setCushionFactor\n\n516     function setCushionFactor(uint32 cushionFactor_) external onlyRole(\"operator_policy\") {\n517         /// Confirm factor is within allowed values\n518         if (cushionFactor_ > 10000 || cushionFactor_ < 100) revert Operator_InvalidParams();\n519\n520         /// Set factor\n521         _config.cushionFactor = cushionFactor_;\n522\n523         emit CushionFactorChanged(cushionFactor_);\n524     }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/policies/Operator.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IOperator} from \"policies/interfaces/IOperator.sol\";\nimport {IBondAuctioneer} from \"interfaces/IBondAuctioneer.sol\";\nimport {IBondCallback} from \"interfaces/IBondCallback.sol\";\n\nimport {OlympusTreasury} from \"modules/TRSRY.sol\";\nimport {OlympusMinter} from \"modules/MINTR.sol\";\nimport {OlympusPrice} from \"modules/PRICE.sol\";\nimport {OlympusRange} from \"modules/RANGE.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\n/// @title  Olympus Range Operator\n/// @notice Olympus Range Operator (Policy) Contract\n/// @dev    The Olympus Range Operator performs market operations to enforce OlympusDAO's OHM price range\n///         guidance policies against a specific reserve asset. The Operator is maintained by a keeper-triggered\n///         function on the Olympus Heart contract, which orchestrates state updates in the correct order to ensure\n///         market operations use up to date information. When the price of OHM against the reserve asset exceeds\n///         the cushion spread, the Operator deploys bond markets to support the price. The Operator also offers\n///         zero slippage swaps at prices dictated by the wall spread from the moving average. These market operations\n///         are performed up to a specific capacity before the market must stabilize to regenerate the capacity.\ncontract Operator is IOperator, Policy, ReentrancyGuard {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== ERRORS =========== */\n\n    error Operator_InvalidParams();\n    error Operator_InsufficientCapacity();\n    error Operator_AmountLessThanMinimum(uint256 amountOut, uint256 minAmountOut);\n    error Operator_WallDown();\n    error Operator_AlreadyInitialized();\n    error Operator_NotInitialized();\n    error Operator_Inactive();\n\n    /* ========== EVENTS =========== */\n    event Swap(\n        ERC20 indexed tokenIn_,\n        ERC20 indexed tokenOut_,\n        uint256 amountIn_,\n        uint256 amountOut_\n    );\n    event CushionFactorChanged(uint32 cushionFactor_);\n    event CushionParamsChanged(uint32 duration_, uint32 debtBuffer_, uint32 depositInterval_);\n    event ReserveFactorChanged(uint32 reserveFactor_);\n    event RegenParamsChanged(uint32 wait_, uint32 threshold_, uint32 observe_);\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// Operator variables, defined in the interface on the external getter functions\n    Status internal _status;\n    Config internal _config;\n\n    /// @notice    Whether the Operator has been initialized\n    bool public initialized;\n\n    /// @notice    Whether the Operator is active\n    bool public active;\n\n    /// Modules\n    OlympusPrice internal PRICE;\n    OlympusRange internal RANGE;\n    OlympusTreasury internal TRSRY;\n    OlympusMinter internal MINTR;\n\n    /// External contracts\n    /// @notice     Auctioneer contract used for cushion bond market deployments\n    IBondAuctioneer public auctioneer;\n    /// @notice     Callback contract used for cushion bond market payouts\n    IBondCallback public callback;\n\n    /// Tokens\n    /// @notice     OHM token contract\n    ERC20 public immutable ohm;\n    uint8 public immutable ohmDecimals;\n    /// @notice     Reserve token contract\n    ERC20 public immutable reserve;\n    uint8 public immutable reserveDecimals;\n\n    /// Constants\n    uint32 public constant FACTOR_SCALE = 1e4;\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        Kernel kernel_,\n        IBondAuctioneer auctioneer_,\n        IBondCallback callback_,\n        ERC20[2] memory tokens_, // [ohm, reserve]\n        uint32[8] memory configParams // [cushionFactor, cushionDuration, cushionDebtBuffer, cushionDepositInterval, reserveFactor, regenWait, regenThreshold, regenObserve]\n    ) Policy(kernel_) {\n        /// Check params are valid\n        if (address(auctioneer_) == address(0) || address(callback_) == address(0))\n            revert Operator_InvalidParams();\n\n        if (configParams[1] > uint256(7 days) || configParams[1] < uint256(1 days))\n            revert Operator_InvalidParams();\n\n        if (configParams[2] < uint32(10_000)) revert Operator_InvalidParams();\n\n        if (configParams[3] < uint32(1 hours) || configParams[3] > configParams[1])\n            revert Operator_InvalidParams();\n\n        if (configParams[4] > 10000 || configParams[4] < 100) revert Operator_InvalidParams();\n\n        if (\n            configParams[5] < 1 hours ||\n            configParams[6] > configParams[7] ||\n            configParams[7] == uint32(0)\n        ) revert Operator_InvalidParams();\n\n        auctioneer = auctioneer_;\n        callback = callback_;\n        ohm = tokens_[0];\n        ohmDecimals = tokens_[0].decimals();\n        reserve = tokens_[1];\n        reserveDecimals = tokens_[1].decimals();\n\n        Regen memory regen = Regen({\n            count: uint32(0),\n            lastRegen: uint48(block.timestamp),\n            nextObservation: uint32(0),\n            observations: new bool[](configParams[7])\n        });\n\n        _config = Config({\n            cushionFactor: configParams[0],\n            cushionDuration: configParams[1],\n            cushionDebtBuffer: configParams[2],\n            cushionDepositInterval: configParams[3],\n            reserveFactor: configParams[4],\n            regenWait: configParams[5],\n            regenThreshold: configParams[6],\n            regenObserve: configParams[7]\n        });\n\n        _status = Status({low: regen, high: regen});\n\n        emit CushionFactorChanged(configParams[0]);\n        emit CushionParamsChanged(configParams[1], configParams[2], configParams[3]);\n        emit ReserveFactorChanged(configParams[4]);\n        emit RegenParamsChanged(configParams[5], configParams[6], configParams[7]);\n    }\n\n    /* ========== FRAMEWORK CONFIGURATION ========== */\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](4);\n        dependencies[0] = toKeycode(\"PRICE\");\n        dependencies[1] = toKeycode(\"RANGE\");\n        dependencies[2] = toKeycode(\"TRSRY\");\n        dependencies[3] = toKeycode(\"MINTR\");\n\n        PRICE = OlympusPrice(getModuleAddress(dependencies[0]));\n        RANGE = OlympusRange(getModuleAddress(dependencies[1]));\n        TRSRY = OlympusTreasury(getModuleAddress(dependencies[2]));\n        MINTR = OlympusMinter(getModuleAddress(dependencies[3]));\n\n        /// Approve MINTR for burning OHM (called here so that it is re-approved on updates)\n        ohm.safeApprove(address(MINTR), type(uint256).max);\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions() external view override returns (Permissions[] memory requests) {\n        Keycode RANGE_KEYCODE = RANGE.KEYCODE();\n        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n        Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n\n        requests = new Permissions[](9);\n        requests[0] = Permissions(RANGE_KEYCODE, RANGE.updateCapacity.selector);\n        requests[1] = Permissions(RANGE_KEYCODE, RANGE.updateMarket.selector);\n        requests[2] = Permissions(RANGE_KEYCODE, RANGE.updatePrices.selector);\n        requests[3] = Permissions(RANGE_KEYCODE, RANGE.regenerate.selector);\n        requests[4] = Permissions(RANGE_KEYCODE, RANGE.setSpreads.selector);\n        requests[5] = Permissions(RANGE_KEYCODE, RANGE.setThresholdFactor.selector);\n        requests[6] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n        requests[7] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n        requests[8] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n    }\n\n    modifier onlyWhileActive() {\n        if (!active) revert Operator_Inactive();\n        _;\n    }\n\n    /* ========== HEART FUNCTIONS ========== */\n    /// @inheritdoc IOperator\n    function operate() external override onlyWhileActive onlyRole(\"operator_operate\") {\n        /// Revert if not initialized\n        if (!initialized) revert Operator_NotInitialized();\n\n        /// Update the prices for the range, save new regen observations, and update capacities based on bond market activity\n        _updateRangePrices();\n        _addObservation();\n        _updateCapacity(true, 0);\n        _updateCapacity(false, 0);\n\n        /// Cache config in memory\n        Config memory config_ = _config;\n\n        /// Check if walls can regenerate capacity\n        if (\n            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\n            _status.high.count >= config_.regenThreshold\n        ) {\n            _regenerate(true);\n        }\n        if (\n            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\n            _status.low.count >= config_.regenThreshold\n        ) {\n            _regenerate(false);\n        }\n\n        /// Cache range data after potential regeneration\n        OlympusRange.Range memory range = RANGE.range();\n\n        /// Get latest price\n        /// See note in addObservation() for more details\n        uint256 currentPrice = PRICE.getLastPrice();\n\n        /// Check if the cushion bond markets are active\n        /// if so, determine if it should stay open or close\n        /// if not, check if a new one should be opened\n        if (range.low.active) {\n            if (auctioneer.isLive(range.low.market)) {\n                /// if active, check if the price is back above the cushion\n                /// or if the price is below the wall\n                /// if so, close the market\n                if (currentPrice > range.cushion.low.price || currentPrice < range.wall.low.price) {\n                    _deactivate(false);\n                }\n            } else {\n                /// if not active, check if the price is below the cushion\n                /// if so, open a new bond market\n                if (currentPrice < range.cushion.low.price && currentPrice > range.wall.low.price) {\n                    _activate(false);\n                }\n            }\n        }\n        if (range.high.active) {\n            if (auctioneer.isLive(range.high.market)) {\n                /// if active, check if the price is back under the cushion\n                /// or if the price is above the wall\n                /// if so, close the market\n                if (\n                    currentPrice < range.cushion.high.price || currentPrice > range.wall.high.price\n                ) {\n                    _deactivate(true);\n                }\n            } else {\n                /// if not active, check if the price is above the cushion\n                /// if so, open a new bond market\n                if (\n                    currentPrice > range.cushion.high.price && currentPrice < range.wall.high.price\n                ) {\n                    _activate(true);\n                }\n            }\n        }\n    }\n\n    /* ========== OPEN MARKET OPERATIONS (WALL) ========== */\n    /// @inheritdoc IOperator\n    function swap(\n        ERC20 tokenIn_,\n        uint256 amountIn_,\n        uint256 minAmountOut_\n    ) external override onlyWhileActive nonReentrant returns (uint256 amountOut) {\n        if (tokenIn_ == ohm) {\n            /// Revert if lower wall is inactive\n            if (!RANGE.active(false)) revert Operator_WallDown();\n\n            /// Calculate amount out (checks for sufficient capacity)\n            amountOut = getAmountOut(tokenIn_, amountIn_);\n\n            /// Revert if amount out less than the minimum specified\n            /// @dev even though price is fixed most of the time,\n            /// it is possible that the amount out could change on a sender\n            /// due to the wall prices being updated before their transaction is processed.\n            /// This would be the equivalent of the heart.beat front-running the sender.\n            if (amountOut < minAmountOut_)\n                revert Operator_AmountLessThanMinimum(amountOut, minAmountOut_);\n\n            /// Decrement wall capacity\n            _updateCapacity(false, amountOut);\n\n            /// If wall is down after swap, deactive the cushion as well\n            _checkCushion(false);\n\n            /// Transfer OHM from sender\n            ohm.safeTransferFrom(msg.sender, address(this), amountIn_);\n\n            /// Burn OHM\n            MINTR.burnOhm(address(this), amountIn_);\n\n            /// Withdraw and transfer reserve to sender\n            TRSRY.withdrawReserves(msg.sender, reserve, amountOut);\n\n            emit Swap(ohm, reserve, amountIn_, amountOut);\n        } else if (tokenIn_ == reserve) {\n            /// Revert if upper wall is inactive\n            if (!RANGE.active(true)) revert Operator_WallDown();\n\n            /// Calculate amount out (checks for sufficient capacity)\n            amountOut = getAmountOut(tokenIn_, amountIn_);\n\n            /// Revert if amount out less than the minimum specified\n            /// @dev even though price is fixed most of the time,\n            /// it is possible that the amount out could change on a sender\n            /// due to the wall prices being updated before their transaction is processed.\n            /// This would be the equivalent of the heart.beat front-running the sender.\n            if (amountOut < minAmountOut_)\n                revert Operator_AmountLessThanMinimum(amountOut, minAmountOut_);\n\n            /// Decrement wall capacity\n            _updateCapacity(true, amountOut);\n\n            /// If wall is down after swap, deactive the cushion as well\n            _checkCushion(true);\n\n            /// Transfer reserves to treasury\n            reserve.safeTransferFrom(msg.sender, address(TRSRY), amountIn_);\n\n            /// Mint OHM to sender\n            MINTR.mintOhm(msg.sender, amountOut);\n\n            emit Swap(reserve, ohm, amountIn_, amountOut);\n        } else {\n            revert Operator_InvalidParams();\n        }\n    }\n\n    /* ========== BOND MARKET OPERATIONS (CUSHION) ========== */\n    /// @notice             Records a bond purchase and updates capacity correctly\n    /// @notice             Access restricted (BondCallback)\n    /// @param id_          ID of the bond market\n    /// @param amountOut_   Amount of capacity expended\n    function bondPurchase(uint256 id_, uint256 amountOut_)\n        external\n        onlyWhileActive\n        onlyRole(\"operator_reporter\")\n    {\n        if (id_ == RANGE.market(true)) {\n            _updateCapacity(true, amountOut_);\n            _checkCushion(true);\n        }\n        if (id_ == RANGE.market(false)) {\n            _updateCapacity(false, amountOut_);\n            _checkCushion(false);\n        }\n    }\n\n    /// @notice      Activate a cushion by deploying a bond market\n    /// @param high_ Whether the cushion is for the high or low side of the range (true = high, false = low)\n    function _activate(bool high_) internal {\n        OlympusRange.Range memory range = RANGE.range();\n\n        if (high_) {\n            /// Calculate scaleAdjustment for bond market\n            /// Price decimals are returned from the perspective of the quote token\n            /// so the operations assume payoutPriceDecimal is zero and quotePriceDecimals\n            /// is the priceDecimal value\n            int8 priceDecimals = _getPriceDecimals(range.cushion.high.price);\n            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\n\n            /// Calculate oracle scale and bond scale with scale adjustment and format prices for bond market\n            uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);\n            uint256 bondScale = 10 **\n                uint8(\n                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\n                );\n\n            uint256 initialPrice = range.wall.high.price.mulDiv(bondScale, oracleScale);\n            uint256 minimumPrice = range.cushion.high.price.mulDiv(bondScale, oracleScale);\n\n            /// Cache config struct to avoid multiple SLOADs\n            Config memory config_ = _config;\n\n            /// Calculate market capacity from the cushion factor\n            uint256 marketCapacity = range.high.capacity.mulDiv(\n                config_.cushionFactor,\n                FACTOR_SCALE\n            );\n\n            /// Create new bond market to buy the reserve with OHM\n            IBondAuctioneer.MarketParams memory params = IBondAuctioneer.MarketParams({\n                payoutToken: ohm,\n                quoteToken: reserve,\n                callbackAddr: address(callback),\n                capacityInQuote: false,\n                capacity: marketCapacity,\n                formattedInitialPrice: initialPrice,\n                formattedMinimumPrice: minimumPrice,\n                debtBuffer: config_.cushionDebtBuffer,\n                vesting: uint48(0), // Instant swaps\n                conclusion: uint48(block.timestamp + config_.cushionDuration),\n                depositInterval: config_.cushionDepositInterval,\n                scaleAdjustment: scaleAdjustment\n            });\n\n            uint256 market = auctioneer.createMarket(params);\n\n            /// Whitelist the bond market on the callback\n            callback.whitelist(address(auctioneer.getTeller()), market);\n\n            /// Update the market information on the range module\n            RANGE.updateMarket(true, market, marketCapacity);\n        } else {\n            /// Calculate inverse prices from the oracle feed for the low side\n            uint8 oracleDecimals = PRICE.decimals();\n            uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price;\n            uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price;\n\n            /// Calculate scaleAdjustment for bond market\n            /// Price decimals are returned from the perspective of the quote token\n            /// so the operations assume payoutPriceDecimal is zero and quotePriceDecimals\n            /// is the priceDecimal value\n            int8 priceDecimals = _getPriceDecimals(invCushionPrice);\n            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\n\n            /// Calculate oracle scale and bond scale with scale adjustment and format prices for bond market\n            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\n            uint256 bondScale = 10 **\n                uint8(\n                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\n                );\n\n            uint256 initialPrice = invWallPrice.mulDiv(bondScale, oracleScale);\n            uint256 minimumPrice = invCushionPrice.mulDiv(bondScale, oracleScale);\n\n            /// Cache config struct to avoid multiple SLOADs\n            Config memory config_ = _config;\n\n            /// Calculate market capacity from the cushion factor\n            uint256 marketCapacity = range.low.capacity.mulDiv(config_.cushionFactor, FACTOR_SCALE);\n\n            /// Create new bond market to buy OHM with the reserve\n            IBondAuctioneer.MarketParams memory params = IBondAuctioneer.MarketParams({\n                payoutToken: reserve,\n                quoteToken: ohm,\n                callbackAddr: address(callback),\n                capacityInQuote: false,\n                capacity: marketCapacity,\n                formattedInitialPrice: initialPrice,\n                formattedMinimumPrice: minimumPrice,\n                debtBuffer: config_.cushionDebtBuffer,\n                vesting: uint48(0), // Instant swaps\n                conclusion: uint48(block.timestamp + config_.cushionDuration),\n                depositInterval: config_.cushionDepositInterval,\n                scaleAdjustment: scaleAdjustment\n            });\n\n            uint256 market = auctioneer.createMarket(params);\n\n            /// Whitelist the bond market on the callback\n            callback.whitelist(address(auctioneer.getTeller()), market);\n\n            /// Update the market information on the range module\n            RANGE.updateMarket(false, market, marketCapacity);\n        }\n    }\n\n    /// @notice      Deactivate a cushion by closing a bond market (if it is active)\n    /// @param high_ Whether the cushion is for the high or low side of the range (true = high, false = low)\n    function _deactivate(bool high_) internal {\n        uint256 market = RANGE.market(high_);\n        if (auctioneer.isLive(market)) {\n            auctioneer.closeMarket(market);\n            RANGE.updateMarket(high_, type(uint256).max, 0);\n        }\n    }\n\n    /// @notice         Helper function to calculate number of price decimals based on the value returned from the price feed.\n    /// @param price_   The price to calculate the number of decimals for\n    /// @return         The number of decimals\n    function _getPriceDecimals(uint256 price_) internal view returns (int8) {\n        int8 decimals;\n        while (price_ >= 10) {\n            price_ = price_ / 10;\n            decimals++;\n        }\n\n        /// Subtract the stated decimals from the calculated decimals to get the relative price decimals.\n        /// Required to do it this way vs. normalizing at the beginning since price decimals can be negative.\n        return decimals - int8(PRICE.decimals());\n    }\n\n    /* ========== OPERATOR CONFIGURATION ========== */\n    /// @inheritdoc IOperator\n    function setSpreads(uint256 cushionSpread_, uint256 wallSpread_)\n        external\n        onlyRole(\"operator_policy\")\n    {\n        /// Set spreads on the range module\n        RANGE.setSpreads(cushionSpread_, wallSpread_);\n\n        /// Update range prices (wall and cushion)\n        _updateRangePrices();\n    }\n\n    /// @inheritdoc IOperator\n    function setThresholdFactor(uint256 thresholdFactor_) external onlyRole(\"operator_policy\") {\n        /// Set threshold factor on the range module\n        RANGE.setThresholdFactor(thresholdFactor_);\n    }\n\n    /// @inheritdoc IOperator\n    function setCushionFactor(uint32 cushionFactor_) external onlyRole(\"operator_policy\") {\n        /// Confirm factor is within allowed values\n        if (cushionFactor_ > 10000 || cushionFactor_ < 100) revert Operator_InvalidParams();\n\n        /// Set factor\n        _config.cushionFactor = cushionFactor_;\n\n        emit CushionFactorChanged(cushionFactor_);\n    }\n\n    /// @inheritdoc IOperator\n    function setCushionParams(\n        uint32 duration_,\n        uint32 debtBuffer_,\n        uint32 depositInterval_\n    ) external onlyRole(\"operator_policy\") {\n        /// Confirm values are valid\n        if (duration_ > uint256(7 days) || duration_ < uint256(1 days))\n            revert Operator_InvalidParams();\n        if (debtBuffer_ < uint32(10_000)) revert Operator_InvalidParams();\n        if (depositInterval_ < uint32(1 hours) || depositInterval_ > duration_)\n            revert Operator_InvalidParams();\n\n        /// Update values\n        _config.cushionDuration = duration_;\n        _config.cushionDebtBuffer = debtBuffer_;\n        _config.cushionDepositInterval = depositInterval_;\n\n        emit CushionParamsChanged(duration_, debtBuffer_, depositInterval_);\n    }\n\n    /// @inheritdoc IOperator\n    function setReserveFactor(uint32 reserveFactor_) external onlyRole(\"operator_policy\") {\n        /// Confirm factor is within allowed values\n        if (reserveFactor_ > 10000 || reserveFactor_ < 100) revert Operator_InvalidParams();\n\n        /// Set factor\n        _config.reserveFactor = reserveFactor_;\n\n        emit ReserveFactorChanged(reserveFactor_);\n    }\n\n    /// @inheritdoc IOperator\n    function setRegenParams(\n        uint32 wait_,\n        uint32 threshold_,\n        uint32 observe_\n    ) external onlyRole(\"operator_policy\") {\n        /// Confirm regen parameters are within allowed values\n        if (wait_ < 1 hours || threshold_ > observe_ || observe_ == 0)\n            revert Operator_InvalidParams();\n\n        /// Set regen params\n        _config.regenWait = wait_;\n        _config.regenThreshold = threshold_;\n        _config.regenObserve = observe_;\n\n        /// Re-initialize regen structs with new values (except for last regen)\n        _status.high.count = 0;\n        _status.high.nextObservation = 0;\n        _status.high.observations = new bool[](observe_);\n\n        _status.low.count = 0;\n        _status.low.nextObservation = 0;\n        _status.low.observations = new bool[](observe_);\n\n        emit RegenParamsChanged(wait_, threshold_, observe_);\n    }\n\n    /// @inheritdoc IOperator\n    function setBondContracts(IBondAuctioneer auctioneer_, IBondCallback callback_)\n        external\n        onlyRole(\"operator_admin\")\n    {\n        if (address(auctioneer_) == address(0) || address(callback_) == address(0))\n            revert Operator_InvalidParams();\n        /// Set contracts\n        auctioneer = auctioneer_;\n        callback = callback_;\n    }\n\n    /// @inheritdoc IOperator\n    function initialize() external onlyRole(\"operator_admin\") {\n        /// Can only call once\n        if (initialized) revert Operator_AlreadyInitialized();\n\n        /// Request approval for reserves from TRSRY\n        TRSRY.setApprovalFor(address(this), reserve, type(uint256).max);\n\n        /// Update range prices (wall and cushion)\n        _updateRangePrices();\n\n        /// Regenerate sides\n        _regenerate(true);\n        _regenerate(false);\n\n        /// Set initialized and active flags\n        initialized = true;\n        active = true;\n    }\n\n    /// @inheritdoc IOperator\n    function regenerate(bool high_) external onlyRole(\"operator_admin\") {\n        /// Regenerate side\n        _regenerate(high_);\n    }\n\n    /// @inheritdoc IOperator\n    function toggleActive() external onlyRole(\"operator_admin\") {\n        /// Toggle active state\n        active = !active;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /// @notice          Update the capacity on the RANGE module.\n    /// @param high_     Whether to update the high side or low side capacity (true = high, false = low).\n    /// @param reduceBy_ The amount to reduce the capacity by (OHM tokens for high side, Reserve tokens for low side).\n    function _updateCapacity(bool high_, uint256 reduceBy_) internal {\n        /// Initialize update variables, decrement capacity if a reduceBy amount is provided\n        uint256 capacity = RANGE.capacity(high_) - reduceBy_;\n\n        /// Update capacities on the range module for the wall and market\n        RANGE.updateCapacity(high_, capacity);\n    }\n\n    /// @notice Update the prices on the RANGE module\n    function _updateRangePrices() internal {\n        /// Get latest moving average from the price module\n        uint256 movingAverage = PRICE.getMovingAverage();\n\n        /// Update the prices on the range module\n        RANGE.updatePrices(movingAverage);\n    }\n\n    /// @notice Add an observation to the regeneration status variables for each side\n    function _addObservation() internal {\n        /// Get latest moving average from the price module\n        uint256 movingAverage = PRICE.getMovingAverage();\n\n        /// Get latest price\n        /// TODO determine if this should use the last price from the MA or recalculate the current price, ideally last price is ok since it should have been just updated and should include check against secondary?\n        /// Current price is guaranteed to be up to date, but may be a bad value if not checked?\n        uint256 currentPrice = PRICE.getLastPrice();\n\n        /// Store observations and update counts for regeneration\n\n        /// Update low side regen status with a new observation\n        /// Observation is positive if the current price is greater than the MA\n        uint32 observe = _config.regenObserve;\n        Regen memory regen = _status.low;\n        if (currentPrice >= movingAverage) {\n            if (!regen.observations[regen.nextObservation]) {\n                _status.low.observations[regen.nextObservation] = true;\n                _status.low.count++;\n            }\n        } else {\n            if (regen.observations[regen.nextObservation]) {\n                _status.low.observations[regen.nextObservation] = false;\n                _status.low.count--;\n            }\n        }\n        _status.low.nextObservation = (regen.nextObservation + 1) % observe;\n\n        /// Update high side regen status with a new observation\n        /// Observation is positive if the current price is less than the MA\n        regen = _status.high;\n        if (currentPrice <= movingAverage) {\n            if (!regen.observations[regen.nextObservation]) {\n                _status.high.observations[regen.nextObservation] = true;\n                _status.high.count++;\n            }\n        } else {\n            if (regen.observations[regen.nextObservation]) {\n                _status.high.observations[regen.nextObservation] = false;\n                _status.high.count--;\n            }\n        }\n        _status.high.nextObservation = (regen.nextObservation + 1) % observe;\n    }\n\n    /// @notice      Regenerate the wall for a side\n    /// @param high_ Whether to regenerate the high side or low side (true = high, false = low)\n    function _regenerate(bool high_) internal {\n        /// Deactivate cushion if active on the side being regenerated\n        _deactivate(high_);\n\n        if (high_) {\n            /// Reset the regeneration data for the side\n            _status.high.count = uint32(0);\n            _status.high.observations = new bool[](_config.regenObserve);\n            _status.high.nextObservation = uint32(0);\n            _status.high.lastRegen = uint48(block.timestamp);\n\n            /// Calculate capacity\n            uint256 capacity = fullCapacity(true);\n\n            /// Regenerate the side with the capacity\n            RANGE.regenerate(true, capacity);\n        } else {\n            /// Reset the regeneration data for the side\n            _status.low.count = uint32(0);\n            _status.low.observations = new bool[](_config.regenObserve);\n            _status.low.nextObservation = uint32(0);\n            _status.low.lastRegen = uint48(block.timestamp);\n\n            /// Calculate capacity\n            uint256 capacity = fullCapacity(false);\n\n            /// Regenerate the side with the capacity\n            RANGE.regenerate(false, capacity);\n        }\n    }\n\n    /// @notice      Takes down cushions (if active) when a wall is taken down or if available capacity drops below cushion capacity\n    /// @param high_ Whether to check the high side or low side cushion (true = high, false = low)\n    function _checkCushion(bool high_) internal {\n        /// Check if the wall is down, if so ensure the cushion is also down\n        /// Additionally, if wall is not down, but the wall capacity has dropped below the cushion capacity, take the cushion down\n        bool sideActive = RANGE.active(high_);\n        uint256 market = RANGE.market(high_);\n        if (\n            !sideActive ||\n            (sideActive &&\n                auctioneer.isLive(market) &&\n                RANGE.capacity(high_) < auctioneer.currentCapacity(market))\n        ) {\n            _deactivate(high_);\n        }\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n    /// @inheritdoc IOperator\n    function getAmountOut(ERC20 tokenIn_, uint256 amountIn_) public view returns (uint256) {\n        if (tokenIn_ == ohm) {\n            /// Calculate amount out\n            uint256 amountOut = amountIn_.mulDiv(\n                10**reserveDecimals * RANGE.price(true, false),\n                10**ohmDecimals * 10**PRICE.decimals()\n            );\n\n            /// Revert if amount out exceeds capacity\n            if (amountOut > RANGE.capacity(false)) revert Operator_InsufficientCapacity();\n\n            return amountOut;\n        } else if (tokenIn_ == reserve) {\n            /// Calculate amount out\n            uint256 amountOut = amountIn_.mulDiv(\n                10**ohmDecimals * 10**PRICE.decimals(),\n                10**reserveDecimals * RANGE.price(true, true)\n            );\n\n            /// Revert if amount out exceeds capacity\n            if (amountOut > RANGE.capacity(true)) revert Operator_InsufficientCapacity();\n\n            return amountOut;\n        } else {\n            revert Operator_InvalidParams();\n        }\n    }\n\n    /// @inheritdoc IOperator\n    function fullCapacity(bool high_) public view override returns (uint256) {\n        uint256 reservesInTreasury = TRSRY.getReserveBalance(reserve);\n        uint256 capacity = (reservesInTreasury * _config.reserveFactor) / FACTOR_SCALE;\n        if (high_) {\n            capacity =\n                (capacity.mulDiv(\n                    10**ohmDecimals * 10**PRICE.decimals(),\n                    10**reserveDecimals * RANGE.pric"
    }
  ]
}