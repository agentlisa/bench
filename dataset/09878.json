{
  "Title": "[M-04] settleFunding will exceed block gas with more markets and activity",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L129\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L678\n\n\n# Vulnerability details\n\n## Impact\n\nAs the number of supported markets grow, `settleFunding` will reach a point were it exceeds the block gas limit on Avalanche C-Chain. This will prevent users from calling the function and cause a wide spread Denial of Service.\n\nLooking at transactions for the current testnet deployment, `settleFunding` already reaches almost 10% of the block gas limit. This is due settle funding iteratively looping through each market, with each iteration entering an unbounded `while` loop in `_calcTwap`. The more active the markets are, the more gas intensive `_calcTwap` becomes, as more snapshots need to be traversed. \n\nThe combination of more active markets and an increase in available markets make it very likely that some users will be unable to call `settleFunding` in the long run.\n\n\n## Proof of Concept\n\nExample of transactions on testnet:\n\n| Gas | Limit% | Link |\n|-----|--------|-----|\n| 658428 | 8.2% | https://testnet.snowtrace.io/tx/0x8123a5658a98e694e7428e66c9e5f9d5cbff8af93d543ed51a80cb367bcccd2c |\n| 653810 | 8.1% | https://testnet.snowtrace.io/tx/0xf126eb05245580a73981228d6f0f8d607ad038ca0b68593f0c903e210c1c2c57 | \n\n## Recommended Mitigation Steps\n\nUsers should be allowed to settle funding per market or using an array of markets opposed to all markets at once.\n\n```solidity\nfunction settleFundingForMarkets(IAMM[] markets) override external whenNotPaused {\n     for (uint i = 0; i < markets.length; i++) {\n          markets[i].settleFunding();\n     }\n}\n```\n\nIn this way the gas cost will not increase with the number of markets created over time. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-hubble-contest",
  "Code": [
    {
      "filename": "contracts/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { HubbleBase } from \"./legos/HubbleBase.sol\";\nimport { IAMM, IInsuranceFund, IMarginAccount, IClearingHouse } from \"./Interfaces.sol\";\nimport { VUSD } from \"./VUSD.sol\";\n\ncontract ClearingHouse is IClearingHouse, HubbleBase {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    uint256 constant PRECISION = 1e6;\n\n    int256 override public maintenanceMargin;\n    uint override public tradeFee;\n    uint override public liquidationPenalty;\n    int256 public minAllowableMargin;\n\n    VUSD public vusd;\n    IInsuranceFund public insuranceFund;\n    IMarginAccount public marginAccount;\n    IAMM[] override public amms;\n\n    uint256[50] private __gap;\n\n    event PositionModified(address indexed trader, uint indexed idx, int256 baseAsset, uint quoteAsset, uint256 timestamp);\n    event PositionLiquidated(address indexed trader, uint indexed idx, int256 baseAsset, uint256 quoteAsset, uint256 timestamp);\n    event MarketAdded(uint indexed idx, address indexed amm);\n\n    constructor(address _trustedForwarder) HubbleBase(_trustedForwarder) {}\n\n    function initialize(\n        address _governance,\n        address _insuranceFund,\n        address _marginAccount,\n        address _vusd,\n        int256 _maintenanceMargin,\n        int256 _minAllowableMargin,\n        uint _tradeFee,\n        uint _liquidationPenalty\n    ) external initializer {\n        _setGovernace(_governance);\n\n        insuranceFund = IInsuranceFund(_insuranceFund);\n        marginAccount = IMarginAccount(_marginAccount);\n        vusd = VUSD(_vusd);\n\n        require(_maintenanceMargin > 0, \"_maintenanceMargin < 0\");\n        maintenanceMargin = _maintenanceMargin;\n        minAllowableMargin = _minAllowableMargin;\n        tradeFee = _tradeFee;\n        liquidationPenalty = _liquidationPenalty;\n    }\n\n    /**\n    * @notice Open/Modify/Close Position\n    * @param idx AMM index\n    * @param baseAssetQuantity Quantity of the base asset to Long (baseAssetQuantity > 0) or Short (baseAssetQuantity < 0)\n    * @param quoteAssetLimit Rate at which the trade is executed in the AMM. Used to cap slippage.\n    */\n    function openPosition(uint idx, int256 baseAssetQuantity, uint quoteAssetLimit) override external whenNotPaused {\n        _openPosition(_msgSender(), idx, baseAssetQuantity, quoteAssetLimit);\n    }\n\n    function closePosition(uint idx, uint quoteAssetLimit) override external whenNotPaused {\n        address trader = _msgSender();\n        (int256 size,,) = amms[idx].positions(trader);\n        _openPosition(trader, idx, -size, quoteAssetLimit);\n    }\n\n    function _openPosition(address trader, uint idx, int256 baseAssetQuantity, uint quoteAssetLimit) internal {\n        require(baseAssetQuantity != 0, \"CH: baseAssetQuantity == 0\");\n\n        updatePositions(trader); // adjust funding payments\n\n        (int realizedPnl, uint quoteAsset, bool isPositionIncreased) = amms[idx].openPosition(trader, baseAssetQuantity, quoteAssetLimit);\n        uint _tradeFee = _chargeFeeAndRealizePnL(trader, realizedPnl, quoteAsset, false /* isLiquidation */);\n        marginAccount.transferOutVusd(address(insuranceFund), _tradeFee);\n\n        if (isPositionIncreased) {\n            require(isAboveMinAllowableMargin(trader), \"CH: Below Minimum Allowable Margin\");\n        }\n        emit PositionModified(trader, idx, baseAssetQuantity, quoteAsset, _blockTimestamp());\n    }\n\n    /**\n    * @notice Add liquidity to the amm. The free margin from margin account is utilized for the same\n    *   The liquidity can be provided on leverage.\n    * @param idx Index of the AMM\n    * @param baseAssetQuantity Amount of the asset to add to AMM. Equivalent amount of USD side is automatically added.\n    *   This means that user is actually adding 2 * baseAssetQuantity * markPrice.\n    * @param minDToken Min amount of dTokens to receive. Used to cap slippage.\n    */\n    function addLiquidity(uint idx, uint256 baseAssetQuantity, uint minDToken) override external whenNotPaused {\n        address maker = _msgSender();\n        updatePositions(maker);\n        amms[idx].addLiquidity(maker, baseAssetQuantity, minDToken);\n        require(isAboveMinAllowableMargin(maker), \"CH: Below Minimum Allowable Margin\");\n    }\n\n    /**\n    * @notice Remove liquidity from the amm.\n    * @param idx Index of the AMM\n    * @param dToken Measure of the liquidity to remove.\n    * @param minQuoteValue Min amount of USD to remove.\n    * @param minBaseValue Min amount of base to remove.\n    *   Both the above params enable capping slippage in either direction.\n    */\n    function removeLiquidity(uint idx, uint256 dToken, uint minQuoteValue, uint minBaseValue) override external whenNotPaused {\n        address maker = _msgSender();\n        updatePositions(maker);\n        (int256 realizedPnl,) = amms[idx].removeLiquidity(maker, dToken, minQuoteValue, minBaseValue);\n        marginAccount.realizePnL(maker, realizedPnl);\n    }\n\n    function updatePositions(address trader) override public whenNotPaused {\n        require(address(trader) != address(0), 'CH: 0x0 trader Address');\n        int256 fundingPayment;\n        for (uint i = 0; i < amms.length; i++) {\n            fundingPayment += amms[i].updatePosition(trader);\n        }\n        // -ve fundingPayment means trader should receive funds\n        marginAccount.realizePnL(trader, -fundingPayment);\n    }\n\n    function settleFunding() override external whenNotPaused {\n        for (uint i = 0; i < amms.length; i++) {\n            amms[i].settleFunding();\n        }\n    }\n\n    /* ****************** */\n    /*    Liquidations    */\n    /* ****************** */\n\n    function liquidate(address trader) override external whenNotPaused {\n        updatePositions(trader);\n        if (isMaker(trader)) {\n            _liquidateMaker(trader);\n        } else {\n            _liquidateTaker(trader);\n        }\n    }\n\n    function liquidateMaker(address maker) override public whenNotPaused {\n        updatePositions(maker);\n        _liquidateMaker(maker);\n    }\n\n    function liquidateTaker(address trader) override public whenNotPaused {\n        require(!isMaker(trader), 'CH: Remove Liquidity First');\n        updatePositions(trader);\n        _liquidateTaker(trader);\n    }\n\n    /* ********************* */\n    /* Liquidations Internal */\n    /* ********************* */\n\n    function _liquidateMaker(address maker) internal {\n        require(\n            _calcMarginFraction(maker, false) < maintenanceMargin,\n            \"CH: Above Maintenance Margin\"\n        );\n        int256 realizedPnl;\n        uint quoteAsset;\n        for (uint i = 0; i < amms.length; i++) {\n            (,, uint dToken,,,,) = amms[i].makers(maker);\n            // @todo put checks on slippage\n            (int256 _realizedPnl, uint _quote) = amms[i].removeLiquidity(maker, dToken, 0, 0);\n            realizedPnl += _realizedPnl;\n            quoteAsset += _quote;\n        }\n\n        _disperseLiquidationFee(\n            _chargeFeeAndRealizePnL(\n                maker,\n                realizedPnl,\n                2 * quoteAsset,  // total liquidity value = 2 * quote value\n                true // isLiquidation\n            )\n        );\n    }\n\n    function _liquidateTaker(address trader) internal {\n        require(_calcMarginFraction(trader, false /* check funding payments again */) < maintenanceMargin, \"Above Maintenance Margin\");\n        int realizedPnl;\n        uint quoteAsset;\n        int256 size;\n        IAMM _amm;\n        for (uint i = 0; i < amms.length; i++) { // liquidate all positions\n            _amm = amms[i];\n            (size,,) = _amm.positions(trader);\n            if (size != 0) {\n                (int _realizedPnl, uint _quoteAsset) = _amm.liquidatePosition(trader);\n                realizedPnl += _realizedPnl;\n                quoteAsset += _quoteAsset;\n                emit PositionLiquidated(trader, i, size, _quoteAsset, _blockTimestamp());\n            }\n        }\n\n        _disperseLiquidationFee(\n            _chargeFeeAndRealizePnL(trader, realizedPnl, quoteAsset, true /* isLiquidation */)\n        );\n    }\n\n    function _disperseLiquidationFee(uint liquidationFee) internal {\n        if (liquidationFee > 0) {\n            uint toInsurance = liquidationFee / 2;\n            marginAccount.transferOutVusd(address(insuranceFund), toInsurance);\n            marginAccount.transferOutVusd(_msgSender(), liquidationFee - toInsurance);\n        }\n    }\n\n    function _chargeFeeAndRealizePnL(\n        address trader,\n        int realizedPnl,\n        uint quoteAsset,\n        bool isLiquidation\n    )\n        internal\n        returns (uint fee)\n    {\n        fee = isLiquidation ? _calculateLiquidationPenalty(quoteAsset) : _calculateTradeFee(quoteAsset);\n        int256 marginCharge = realizedPnl - fee.toInt256();\n        if (marginCharge != 0) {\n            marginAccount.realizePnL(trader, marginCharge);\n        }\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    function isAboveMaintenanceMargin(address trader) override external view returns(bool) {\n        return getMarginFraction(trader) >= maintenanceMargin;\n    }\n\n    function isAboveMinAllowableMargin(address trader) override public view returns(bool) {\n        return getMarginFraction(trader) >= minAllowableMargin;\n    }\n\n    function getMarginFraction(address trader) override public view returns(int256) {\n        return _calcMarginFraction(trader, true /* includeFundingPayments */);\n    }\n\n    function isMaker(address trader) override public view returns(bool) {\n        for (uint i = 0; i < amms.length; i++) {\n            (,, uint dToken,,,,) = amms[i].makers(trader);\n            if (dToken > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getTotalFunding(address trader) override public view returns(int256 totalFunding) {\n        int256 takerFundingPayment;\n        int256 makerFundingPayment;\n        for (uint i = 0; i < amms.length; i++) {\n            (takerFundingPayment, makerFundingPayment,,) = amms[i].getPendingFundingPayment(trader);\n            totalFunding += (takerFundingPayment + makerFundingPayment);\n        }\n    }\n\n    function getTotalNotionalPositionAndUnrealizedPnl(address trader)\n        override\n        public\n        view\n        returns(uint256 notionalPosition, int256 unrealizedPnl)\n    {\n        uint256 _notionalPosition;\n        int256 _unrealizedPnl;\n        for (uint i = 0; i < amms.length; i++) {\n            (_notionalPosition, _unrealizedPnl,,) = amms[i].getNotionalPositionAndUnrealizedPnl(trader);\n            notionalPosition += _notionalPosition;\n            unrealizedPnl += _unrealizedPnl;\n        }\n    }\n\n    function getNotionalPositionAndMargin(address trader, bool includeFundingPayments)\n        override\n        public\n        view\n        returns(uint256 notionalPosition, int256 margin)\n    {\n        int256 unrealizedPnl;\n        (notionalPosition, unrealizedPnl) = getTotalNotionalPositionAndUnrealizedPnl(trader);\n        margin = marginAccount.getNormalizedMargin(trader);\n        margin += unrealizedPnl;\n        if (includeFundingPayments) {\n            margin -= getTotalFunding(trader); // -ve fundingPayment means trader should receive funds\n        }\n    }\n\n    function getAmmsLength() override external view returns(uint) {\n        return amms.length;\n    }\n\n    function getAMMs() external view returns (IAMM[] memory) {\n        return amms;\n    }\n\n    /* ****************** */\n    /*   Internal View    */\n    /* ****************** */\n\n    function _calculateTradeFee(uint quoteAsset) internal view returns (uint) {\n        return quoteAsset * tradeFee / PRECISION;\n    }\n\n    function _calculateLiquidationPenalty(uint quoteAsset) internal view returns (uint) {\n        return quoteAsset * liquidationPenalty / PRECISION;\n    }\n\n    function _calcMarginFraction(address trader, bool includeFundingPayments) internal view returns(int256) {\n        (uint256 notionalPosition, int256 margin) = getNotionalPositionAndMargin(trader, includeFundingPayments);\n        return _getMarginFraction(margin, notionalPosition);\n    }\n\n    /* ****************** */\n    /*        Pure        */\n    /* ****************** */\n\n    function _getMarginFraction(int256 accountValue, uint notionalPosition) private pure returns(int256) {\n        if (notionalPosition == 0) {\n            return type(int256).max;\n        }\n        return accountValue * PRECISION.toInt256() / notionalPosition.toInt256();\n    }\n\n    /* ****************** */\n    /*     Governance     */\n    /* ****************** */\n\n    function whitelistAmm(address _amm) external onlyGovernance {\n        emit MarketAdded(amms.length, _amm);\n        amms.push(IAMM(_amm));\n    }\n\n    function setParams(\n        int _maintenanceMargin,\n        int _minAllowableMargin,\n        uint _tradeFee,\n        uint _liquidationPenality\n    ) external onlyGovernance {\n        tradeFee = _tradeFee;\n        liquidationPenalty = _liquidationPenality;\n        maintenanceMargin = _maintenanceMargin;\n        minAllowableMargin = _minAllowableMargin;\n    }\n}"
    },
    {
      "filename": "contracts/AMM.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { Governable } from \"./legos/Governable.sol\";\nimport { ERC20Detailed, IOracle, IRegistry, IVAMM, IAMM } from \"./Interfaces.sol\";\n\ncontract AMM is IAMM, Governable {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    uint256 public constant spotPriceTwapInterval = 1 hours;\n    uint256 public constant fundingPeriod = 1 hours;\n    int256 constant BASE_PRECISION = 1e18;\n\n    // System-wide config\n\n    IOracle public oracle;\n    address public clearingHouse;\n\n    // AMM config\n\n    IVAMM override public vamm;\n    address override public underlyingAsset;\n    string public name;\n\n    uint256 public fundingBufferPeriod;\n    uint256 public nextFundingTime;\n    int256 public fundingRate;\n    int256 public cumulativePremiumFraction;\n    int256 public cumulativePremiumPerDtoken;\n    int256 public posAccumulator;\n\n    uint256 public longOpenInterestNotional;\n    uint256 public shortOpenInterestNotional;\n\n    enum Side { LONG, SHORT }\n    struct Position {\n        int256 size;\n        uint256 openNotional;\n        int256 lastPremiumFraction;\n    }\n    mapping(address => Position) override public positions;\n\n    struct Maker {\n        uint vUSD;\n        uint vAsset;\n        uint dToken;\n        int pos; // position\n        int posAccumulator; // value of global.posAccumulator until which pos has been updated\n        int lastPremiumFraction;\n        int lastPremiumPerDtoken;\n    }\n    mapping(address => Maker) override public makers;\n\n    struct ReserveSnapshot {\n        uint256 lastPrice;\n        uint256 timestamp;\n        uint256 blockNumber;\n    }\n    ReserveSnapshot[] public reserveSnapshots;\n\n    /**\n    * @dev We do not deliberately have a Pause state. There is only a master-level pause at clearingHouse level\n    */\n    enum AMMState { Inactive, Ignition, Active }\n    AMMState public ammState;\n\n    uint256[50] private __gap;\n\n    // Events\n\n    event PositionChanged(address indexed trader, int256 size, uint256 openNotional, int256 realizedPnl);\n    event FundingRateUpdated(int256 premiumFraction, int256 rate, uint256 underlyingPrice, uint256 timestamp, uint256 blockNumber);\n    event FundingPaid(address indexed trader, int256 takerPosSize, int256 takerFundingPayment, int256 makerFundingPayment, int256 latestCumulativePremiumFraction, int256 latestPremiumPerDtoken);\n    event Swap(int256 baseAsset, uint256 quoteAsset, uint256 lastPrice, uint256 openInterestNotional);\n    event LiquidityAdded(address indexed maker, uint dToken, uint baseAsset, uint quoteAsset, uint timestamp);\n    event LiquidityRemoved(address indexed maker, uint dToken, uint baseAsset, uint quoteAsset, uint timestamp, int256 realizedPnl);\n\n    modifier onlyClearingHouse() {\n        require(msg.sender == clearingHouse, \"Only clearingHouse\");\n        _;\n    }\n\n    modifier onlyVamm() {\n        require(msg.sender == address(vamm), \"Only VAMM\");\n        _;\n    }\n\n    function initialize(\n        address _registry,\n        address _underlyingAsset,\n        string memory _name,\n        address _vamm,\n        address _governance\n    ) external initializer {\n        _setGovernace(_governance);\n\n        vamm = IVAMM(_vamm);\n        underlyingAsset = _underlyingAsset;\n        name = _name;\n        fundingBufferPeriod = 15 minutes;\n\n        syncDeps(_registry);\n    }\n\n    /**\n    * @dev baseAssetQuantity != 0 has been validated in clearingHouse._openPosition()\n    */\n    function openPosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit)\n        override\n        external\n        onlyClearingHouse\n        returns (int realizedPnl, uint quoteAsset, bool isPositionIncreased)\n    {\n        require(ammState == AMMState.Active, \"AMM.openPosition.not_active\");\n        Position memory position = positions[trader];\n        bool isNewPosition = position.size == 0 ? true : false;\n        Side side = baseAssetQuantity > 0 ? Side.LONG : Side.SHORT;\n        if (isNewPosition || (position.size > 0 ? Side.LONG : Side.SHORT) == side) {\n            // realizedPnl = 0;\n            quoteAsset = _increasePosition(trader, baseAssetQuantity, quoteAssetLimit);\n            isPositionIncreased = true;\n        } else {\n            (realizedPnl, quoteAsset, isPositionIncreased) = _openReversePosition(trader, baseAssetQuantity, quoteAssetLimit);\n        }\n        _emitPositionChanged(trader, realizedPnl);\n    }\n\n    function liquidatePosition(address trader)\n        override\n        external\n        onlyClearingHouse\n        returns (int realizedPnl, uint quoteAsset)\n    {\n        // don't need an ammState check because there should be no active positions\n        Position memory position = positions[trader];\n        bool isLongPosition = position.size > 0 ? true : false;\n        // sending market orders can fk the trader. @todo put some safe guards around price of liquidations\n        if (isLongPosition) {\n            (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, 0);\n        } else {\n            (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, type(uint).max);\n        }\n        _emitPositionChanged(trader, realizedPnl);\n    }\n\n    function updatePosition(address trader)\n        override\n        external\n        onlyClearingHouse\n        returns(int256 fundingPayment)\n    {\n        if (ammState != AMMState.Active) return 0;\n        (\n            int256 takerFundingPayment,\n            int256 makerFundingPayment,\n            int256 latestCumulativePremiumFraction,\n            int256 latestPremiumPerDtoken\n        ) = getPendingFundingPayment(trader);\n\n        Position storage position = positions[trader];\n        position.lastPremiumFraction = latestCumulativePremiumFraction;\n\n        Maker storage maker = makers[trader];\n        maker.lastPremiumFraction = latestCumulativePremiumFraction;\n        maker.lastPremiumPerDtoken = latestPremiumPerDtoken;\n\n        emit FundingPaid(trader, position.size, takerFundingPayment, makerFundingPayment, latestCumulativePremiumFraction, latestPremiumPerDtoken);\n\n        // +: trader paid, -: trader received\n        fundingPayment = takerFundingPayment + makerFundingPayment;\n        if (fundingPayment < 0) {\n            fundingPayment -= fundingPayment / 1e3; // receivers charged 0.1% to account for rounding-offs\n        }\n    }\n\n    function addLiquidity(address maker, uint baseAssetQuantity, uint minDToken)\n        override\n        external\n        onlyClearingHouse\n    {\n        require(ammState != AMMState.Inactive, \"AMM.addLiquidity.amm_inactive\");\n        uint quoteAsset;\n        uint baseAssetBal = vamm.balances(1);\n        if (baseAssetBal == 0) {\n            quoteAsset = baseAssetQuantity * vamm.price_scale() / 1e30;\n        } else {\n            quoteAsset = baseAssetQuantity * vamm.balances(0) / baseAssetBal;\n        }\n\n        uint _dToken = vamm.add_liquidity([quoteAsset, baseAssetQuantity], minDToken);\n\n        // updates\n        Maker storage _maker = makers[maker];\n        if (_maker.dToken > 0) { // Maker only accumulates position when they had non-zero liquidity\n            _maker.pos += (posAccumulator - _maker.posAccumulator) * _maker.dToken.toInt256() / 1e18;\n        }\n        _maker.vUSD += quoteAsset;\n        _maker.vAsset += baseAssetQuantity;\n        _maker.dToken += _dToken;\n        _maker.posAccumulator = posAccumulator;\n        emit LiquidityAdded(maker, _dToken, baseAssetQuantity, quoteAsset, _blockTimestamp());\n    }\n\n    function removeLiquidity(address maker, uint amount, uint minQuote, uint minBase)\n        override\n        external\n        onlyClearingHouse\n        returns (int256 /* realizedPnl */, uint /* quoteAsset */)\n    {\n        Maker memory _maker = makers[maker];\n        if (_maker.dToken == 0) {\n            return (0,0);\n        }\n\n        Position memory _taker = positions[maker];\n        // amount <= _maker.dToken will be asserted when updating maker.dToken\n        (\n            int256 makerPosition,\n            uint256 totalOpenNotional,\n            int256 feeAdjustedPnl,\n            uint[2] memory dBalances\n        ) = vamm.remove_liquidity(\n            amount,\n            [minQuote /* minimum QuoteAsset amount */, minBase /* minimum BaseAsset amount */],\n            _maker.vUSD,\n            _maker.vAsset,\n            _maker.dToken,\n            _taker.size,\n            _taker.openNotional\n        );\n\n        {\n            // update maker info\n            Maker storage __maker = makers[maker];\n            uint diff = _maker.dToken - amount;\n\n            if (diff == 0) {\n                __maker.pos = 0;\n                __maker.vAsset = 0;\n                __maker.vUSD = 0;\n                __maker.dToken = 0;\n            } else {\n                // muitiply by diff because a taker position will also be opened while removing liquidity and its funding payment is calculated seperately\n                __maker.pos = _maker.pos + (posAccumulator - _maker.posAccumulator) * diff.toInt256() / 1e18;\n                __maker.vAsset = _maker.vAsset * diff / _maker.dToken;\n                __maker.vUSD = _maker.vUSD * diff / _maker.dToken;\n                __maker.dToken = diff;\n            }\n            __maker.posAccumulator = posAccumulator;\n        }\n\n        int256 realizedPnl = feeAdjustedPnl;\n        {\n            if (makerPosition != 0) {\n                // translate impermanent position to a permanent one\n                Position storage position = positions[maker];\n                if (makerPosition * position.size < 0) { // reducing or reversing position\n                    uint newNotional = getCloseQuote(position.size + makerPosition);\n                    int256 reducePositionPnl = _getPnlWhileReducingPosition(position.size, position.openNotional, makerPosition, newNotional);\n                    realizedPnl += reducePositionPnl;\n                }\n                position.openNotional = totalOpenNotional;\n                position.size += makerPosition;\n\n                // update long and short open interest notional\n                if (makerPosition > 0) {\n                    longOpenInterestNotional += makerPosition.toUint256();\n                } else {\n                    shortOpenInterestNotional += (-makerPosition).toUint256();\n                }\n            }\n        }\n\n        emit LiquidityRemoved(maker, amount, dBalances[1] /** baseAsset */,\n            dBalances[0] /** quoteAsset */, _blockTimestamp(), realizedPnl);\n        return (realizedPnl, dBalances[0]);\n    }\n\n\n    function getOpenNotionalWhileReducingPosition(\n        int256 positionSize,\n        uint256 newNotionalPosition,\n        int256 unrealizedPnl,\n        int256 baseAssetQuantity\n    )\n        override\n        public\n        pure\n        returns(uint256 remainOpenNotional, int realizedPnl)\n    {\n        require(abs(positionSize) >= abs(baseAssetQuantity), \"AMM.ONLY_REDUCE_POS\");\n        bool isLongPosition = positionSize > 0 ? true : false;\n\n        realizedPnl = unrealizedPnl * abs(baseAssetQuantity) / abs(positionSize);\n        int256 unrealizedPnlAfter = unrealizedPnl - realizedPnl;\n\n        /**\n        * We need to determine the openNotional value of the reduced position now.\n        * We know notionalPosition and unrealizedPnlAfter (unrealizedPnl times the ratio of open position)\n        * notionalPosition = notionalPosition - quoteAsset (exchangedQuoteAssetAmount)\n        * calculate openNotional (it's different depends on long or short side)\n        * long: unrealizedPnl = notionalPosition - openNotional => openNotional = notionalPosition - unrealizedPnl\n        * short: unrealizedPnl = openNotional - notionalPosition => openNotional = notionalPosition + unrealizedPnl\n        */\n        if (isLongPosition) {\n            /**\n            * Let baseAssetQuantity = Q, position.size = size, by definition of _reducePosition, abs(size) >= abs(Q)\n            * quoteAsset = notionalPosition * Q / size\n            * unrealizedPnlAfter = unrealizedPnl - realizedPnl = unrealizedPnl - unrealizedPnl * Q / size\n            * remainOpenNotional = notionalPosition - notionalPosition * Q / size - unrealizedPnl + unrealizedPnl * Q / size\n            * => remainOpenNotional = notionalPosition(size-Q)/size - unrealizedPnl(size-Q)/size\n            * => remainOpenNotional = (notionalPosition - unrealizedPnl) * (size-Q)/size\n            * Since notionalPosition includes the PnL component, notionalPosition >= unrealizedPnl and size >= Q\n            * Hence remainOpenNotional >= 0\n            */\n            remainOpenNotional = (newNotionalPosition.toInt256() - unrealizedPnlAfter).toUint256();  // will assert that remainOpenNotional >= 0\n        } else {\n            /**\n            * Let baseAssetQuantity = Q, position.size = size, by definition of _reducePosition, abs(size) >= abs(Q)\n            * quoteAsset = notionalPosition * Q / size\n            * unrealizedPnlAfter = unrealizedPnl - realizedPnl = unrealizedPnl - unrealizedPnl * Q / size\n            * remainOpenNotional = notionalPosition - notionalPosition * Q / size + unrealizedPnl - unrealizedPnl * Q / size\n            * => remainOpenNotional = notionalPosition(size-Q)/size + unrealizedPnl(size-Q)/size\n            * => remainOpenNotional = (notionalPosition + unrealizedPnl) * (size-Q)/size\n            * => In AMM.sol, unrealizedPnl = position.openNotional - notionalPosition\n            * => notionalPosition + unrealizedPnl >= 0\n            * Hence remainOpenNotional >= 0\n            */\n            remainOpenNotional = (newNotionalPosition.toInt256() + unrealizedPnlAfter).toUint256();  // will assert that remainOpenNotional >= 0\n        }\n    }\n\n    /**\n     * @notice update funding rate\n     * @dev only allow to update while reaching `nextFundingTime`\n     */\n    function settleFunding()\n        override\n        external\n        onlyClearingHouse\n    {\n        if (ammState != AMMState.Active) return;\n        require(_blockTimestamp() >= nextFundingTime, \"settle funding too early\");\n\n        // premium = twapMarketPrice - twapIndexPrice\n        // timeFraction = fundingPeriod(1 hour) / 1 day\n        // premiumFraction = premium * timeFraction\n        int256 underlyingPrice = getUnderlyingTwapPrice(spotPriceTwapInterval);\n        int256 premium = getTwapPrice(spotPriceTwapInterval) - underlyingPrice;\n        int256 premiumFraction = (premium * int256(fundingPeriod)) / 1 days;\n\n        // update funding rate = premiumFraction / twapIndexPrice\n        _updateFundingRate(premiumFraction, underlyingPrice);\n\n        int256 premiumPerDtoken = posAccumulator * premiumFraction;\n\n        // makers pay slightly more to account for rounding off\n        premiumPerDtoken = (premiumPerDtoken / BASE_PRECISION) + 1;\n\n        cumulativePremiumFraction += premiumFraction;\n        cumulativePremiumPerDtoken += premiumPerDtoken;\n\n        // Updates for next funding event\n        // in order to prevent multiple funding settlement during very short time after network congestion\n        uint256 minNextValidFundingTime = _blockTimestamp() + fundingBufferPeriod;\n\n        // floor((nextFundingTime + fundingPeriod) / 3600) * 3600\n        uint256 nextFundingTimeOnHourStart = ((nextFundingTime + fundingPeriod) / 1 hours) * 1 hours;\n\n        // max(nextFundingTimeOnHourStart, minNextValidFundingTime)\n        nextFundingTime = nextFundingTimeOnHourStart > minNextValidFundingTime\n            ? nextFundingTimeOnHourStart\n            : minNextValidFundingTime;\n    }\n\n    // View\n\n    function getSnapshotLen() external view returns (uint256) {\n        return reserveSnapshots.length;\n    }\n\n    function getUnderlyingTwapPrice(uint256 _intervalInSeconds) public view returns (int256) {\n        return oracle.getUnderlyingTwapPrice(underlyingAsset, _intervalInSeconds);\n    }\n\n    function getTwapPrice(uint256 _intervalInSeconds) public view returns (int256) {\n        return int256(_calcTwap(_intervalInSeconds));\n    }\n\n    function getNotionalPositionAndUnrealizedPnl(address trader)\n        override\n        external\n        view\n        returns(uint256 notionalPosition, int256 unrealizedPnl, int256 size, uint256 openNotional)\n    {\n        Position memory _taker = positions[trader];\n        Maker memory _maker = makers[trader];\n\n        (notionalPosition, size, unrealizedPnl, openNotional) = vamm.get_notional(\n            _maker.dToken,\n            _maker.vUSD,\n            _maker.vAsset,\n            _taker.size,\n            _taker.openNotional\n        );\n    }\n\n    function getPendingFundingPayment(address trader)\n        override\n        public\n        view\n        returns(\n            int256 takerFundingPayment,\n            int256 makerFundingPayment,\n            int256 latestCumulativePremiumFraction,\n            int256 latestPremiumPerDtoken\n        )\n    {\n        latestCumulativePremiumFraction = cumulativePremiumFraction;\n        Position memory taker = positions[trader];\n\n        takerFundingPayment = (latestCumulativePremiumFraction - taker.lastPremiumFraction)\n            * taker.size\n            / BASE_PRECISION;\n\n        // Maker funding payment\n        latestPremiumPerDtoken = cumulativePremiumPerDtoken;\n\n        Maker memory maker = makers[trader];\n        int256 dToken = maker.dToken.toInt256();\n        if (dToken > 0) {\n            int256 cpf = latestCumulativePremiumFraction - maker.lastPremiumFraction;\n            makerFundingPayment = (\n                maker.pos * cpf +\n                (\n                    latestPremiumPerDtoken\n                    - maker.lastPremiumPerDtoken\n                    - maker.posAccumulator * cpf / BASE_PRECISION\n                ) * dToken\n            ) / BASE_PRECISION;\n        }\n    }\n\n    function getCloseQuote(int256 baseAssetQuantity) override public view returns(uint256 quoteAssetQuantity) {\n        if (baseAssetQuantity > 0) {\n            return vamm.get_dy(1, 0, baseAssetQuantity.toUint256());\n        } else if (baseAssetQuantity < 0) {\n            return vamm.get_dx(0, 1, (-baseAssetQuantity).toUint256());\n        }\n        return 0;\n    }\n\n    function getTakerNotionalPositionAndUnrealizedPnl(address trader) override public view returns(uint takerNotionalPosition, int256 unrealizedPnl) {\n        Position memory position = positions[trader];\n        if (position.size > 0) {\n            takerNotionalPosition = vamm.get_dy(1, 0, position.size.toUint256());\n            unrealizedPnl = takerNotionalPosition.toInt256() - position.openNotional.toInt256();\n        } else if (position.size < 0) {\n            takerNotionalPosition = vamm.get_dx(0, 1, (-position.size).toUint256());\n            unrealizedPnl = position.openNotional.toInt256() - takerNotionalPosition.toInt256();\n        }\n    }\n\n    function lastPrice() external view returns(uint256) {\n        return vamm.last_prices() / 1e12;\n    }\n\n    function openInterestNotional() public view returns (uint256) {\n        return longOpenInterestNotional + shortOpenInterestNotional;\n    }\n\n    // internal\n\n    /**\n    * @dev Go long on an asset\n    * @param baseAssetQuantity Exact base asset quantity to go long\n    * @param max_dx Maximum amount of quote asset to be used while longing baseAssetQuantity. Lower means longing at a lower price (desirable).\n    * @return quoteAssetQuantity quote asset utilised. quoteAssetQuantity / baseAssetQuantity was the average rate.\n      quoteAssetQuantity <= max_d"
    }
  ]
}