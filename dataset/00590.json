{
  "Title": "Magic values",
  "Content": "##### Description\nSome code fragments use magic values to determine a trove status. It degrades the readability of the code:\n- https://github.com/Threshold-USD/dev/blob/800c6c19e44628dfda3cecaea6eedcb498bf0bf3/packages/contracts/contracts/BorrowerOperations.sol#L508\n- https://github.com/Threshold-USD/dev/blob/800c6c19e44628dfda3cecaea6eedcb498bf0bf3/packages/contracts/contracts/BorrowerOperations.sol#L513\n- https://github.com/Threshold-USD/dev/blob/800c6c19e44628dfda3cecaea6eedcb498bf0bf3/packages/contracts/contracts/StabilityPool.sol#L651.\n\n##### Recommendation\nIn favor of the code readability, it is recommended to use named constants instead of magic values.\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/contracts/contracts/BorrowerOperations.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/ITHUSDToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/IPCV.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\nimport \"./Dependencies/SendCollateral.sol\";\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, SendCollateral, IBorrowerOperations {\n\n    string constant public NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    ITroveManager public troveManager;\n\n    address public collateralAddress;\n    address public gasPoolAddress;\n    address public pcvAddress;\n    address public stabilityPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    IPCV public pcv;\n\n    ITHUSDToken public thusdToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n    struct LocalVariables_adjustTrove {\n        uint256 price;\n        uint256 collChange;\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 debt;\n        uint256 coll;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 THUSDFee;\n        uint256 newDebt;\n        uint256 newColl;\n        uint256 stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint256 price;\n        uint256 THUSDFee;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 NICR;\n        uint256 stake;\n        uint256 arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ITHUSDToken thusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 stake, BorrowerOperation operation);\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _thusdTokenAddress,\n        address _pcvAddress,\n        address _collateralAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn THUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_thusdTokenAddress);\n        checkContract(_pcvAddress);\n        if (_collateralAddress != address(0)) {\n            checkContract(_collateralAddress);\n        }\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed = IPriceFeed(_priceFeedAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        thusdToken = ITHUSDToken(_thusdTokenAddress);\n        pcvAddress = _pcvAddress;\n        pcv = IPCV(_pcvAddress);\n        collateralAddress = _collateralAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit PriceFeedAddressChanged(_priceFeedAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit THUSDTokenAddressChanged(_thusdTokenAddress);\n        emit PCVAddressChanged(_pcvAddress);\n        emit CollateralAddressChanged(_collateralAddress);\n\n        _renounceOwnership();\n    }\n\n    /// Calls on PCV behalf\n    function mintBootstrapLoanFromPCV(uint256 _thusdToMint) external {\n        require(msg.sender == address(pcv), \"BorrowerOperations: caller must be PCV\");\n        thusdToken.mint(address(pcv), _thusdToMint);\n    }\n\n    function burnDebtFromPCV(uint256 _thusdToBurn) external {\n        require(msg.sender == address(pcv), \"BorrowerOperations: caller must be PCV\");\n        thusdToken.burn(address(pcv), _thusdToBurn);\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(uint256 _maxFeePercentage, uint256 _THUSDAmount, uint256 _assetAmount, address _upperHint, address _lowerHint) external payable override {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, thusdToken);\n        LocalVariables_openTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, msg.sender);\n\n        vars.THUSDFee;\n        vars.netDebt = _THUSDAmount;\n\n        if (!isRecoveryMode) {\n            vars.THUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.thusdToken, _THUSDAmount, _maxFeePercentage);\n            vars.netDebt += vars.THUSDFee;\n        }\n\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested THUSD amount + THUSD borrowing fee + THUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        assert(vars.compositeDebt > 0);\n\n        // if ETH overwrite the asset value\n        _assetAmount = getAssetAmount(_assetAmount);\n        vars.ICR = LiquityMath._computeCR(_assetAmount, vars.compositeDebt, vars.price);\n        vars.NICR = LiquityMath._computeNominalCR(_assetAmount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            uint256 newTCR = _getNewTCRFromTroveChange(_assetAmount, true, vars.compositeDebt, true, vars.price);  // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(msg.sender, 1);\n        contractsCache.troveManager.increaseTroveColl(msg.sender, _assetAmount);\n        contractsCache.troveManager.increaseTroveDebt(msg.sender, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(msg.sender);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        sortedTroves.insert(msg.sender, vars.NICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(msg.sender);\n        emit TroveCreated(msg.sender, vars.arrayIndex);\n\n        /*\n         * Move the collateral to the Active Pool, and mint the THUSDAmount to the borrower\n         * If the user has insuffient tokens to do the transfer to the Active Pool an error will cause the transaction to revert.\n         */\n        _activePoolAddColl(contractsCache.activePool, _assetAmount);\n        _withdrawTHUSD(contractsCache.activePool, contractsCache.thusdToken, msg.sender, _THUSDAmount, vars.netDebt);\n        // Move the THUSD gas compensation to the Gas Pool\n        _withdrawTHUSD(contractsCache.activePool, contractsCache.thusdToken, gasPoolAddress, THUSD_GAS_COMPENSATION, THUSD_GAS_COMPENSATION);\n\n        emit TroveUpdated(msg.sender, vars.compositeDebt, _assetAmount, vars.stake, BorrowerOperation.openTrove);\n        emit THUSDBorrowingFeePaid(msg.sender, vars.THUSDFee);\n    }\n\n    // Send collateral to a trove\n    function addColl(uint256 _assetAmount, address _upperHint, address _lowerHint) external payable override {\n        _assetAmount = getAssetAmount(_assetAmount);\n        _adjustTrove(msg.sender, 0, 0, false, _assetAmount, _upperHint, _lowerHint, 0);\n    }\n\n    // Send collateral to a trove. Called by only the Stability Pool.\n    function moveCollateralGainToTrove(address _borrower, uint256 _assetAmount, address _upperHint, address _lowerHint) external payable override {\n        _requireCallerIsStabilityPool();\n        _assetAmount = getAssetAmount(_assetAmount);\n        _adjustTrove(_borrower, 0, 0, false, _assetAmount, _upperHint, _lowerHint, 0);\n    }\n\n    function getAssetAmount(uint256 _assetAmount) internal view returns (uint256) {\n        if (collateralAddress == address(0)) {\n            return msg.value;\n        }\n\n        require(msg.value == 0, \"BorrowerOperations: collateral must be ERC20 token\");\n        return _assetAmount;\n    }\n\n    // Withdraw collateral from a trove\n    function withdrawColl(uint256 _collWithdrawal, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, _collWithdrawal, 0, false, 0, _upperHint, _lowerHint, 0);\n    }\n\n    // Withdraw THUSD tokens from a trove: mint new THUSD tokens to the owner, and increase the trove's debt accordingly\n    function withdrawTHUSD(uint256 _maxFeePercentage, uint256 _THUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _THUSDAmount, true, 0, _upperHint, _lowerHint, _maxFeePercentage);\n    }\n\n    // Repay THUSD tokens to a Trove: Burn the repaid THUSD tokens, and reduce the trove's debt accordingly\n    function repayTHUSD(uint256 _THUSDAmount, address _upperHint, address _lowerHint) external override {\n        _adjustTrove(msg.sender, 0, _THUSDAmount, false, 0, _upperHint, _lowerHint, 0);\n    }\n\n    function adjustTrove(uint256 _maxFeePercentage, uint256 _collWithdrawal, uint256 _THUSDChange, bool _isDebtIncrease, uint256 _assetAmount, address _upperHint, address _lowerHint) external payable override {\n        _assetAmount = getAssetAmount(_assetAmount);\n        _adjustTrove(msg.sender, _collWithdrawal, _THUSDChange, _isDebtIncrease, _assetAmount, _upperHint, _lowerHint, _maxFeePercentage);\n    }\n\n    /*\n    * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n    *\n    * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.\n    *\n    * If both are positive, it will revert.\n    */\n    function _adjustTrove(address _borrower, uint256 _collWithdrawal, uint256 _THUSDChange, bool _isDebtIncrease, uint256 _assetAmount, address _upperHint, address _lowerHint, uint256 _maxFeePercentage) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, thusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        vars.price = priceFeed.fetchPrice();\n        bool isRecoveryMode = _checkRecoveryMode(vars.price);\n\n        if (_isDebtIncrease) {\n            _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(_THUSDChange);\n        }\n        _requireSingularCollChange(_collWithdrawal, _assetAmount);\n        _requireNonZeroAdjustment(_collWithdrawal, _THUSDChange, _assetAmount);\n        _requireTroveisActive(contractsCache.troveManager, _borrower);\n\n        // Confirm the operation is either a borrower adjusting their own trove, or a pure collateral transfer from the Stability Pool to a trove\n        assert(msg.sender == _borrower || (msg.sender == stabilityPoolAddress && _assetAmount > 0 && _THUSDChange == 0));\n\n        contractsCache.troveManager.applyPendingRewards(_borrower);\n\n        // Get the collChange based on whether or not collateral was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(_assetAmount, _collWithdrawal);\n\n        vars.netDebtChange = _THUSDChange;\n\n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (_isDebtIncrease && !isRecoveryMode) {\n            vars.THUSDFee = _triggerBorrowingFee(contractsCache.troveManager, contractsCache.thusdToken, _THUSDChange, _maxFeePercentage);\n            vars.netDebtChange += vars.THUSDFee; // The raw debt change includes the fee\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(_borrower);\n        vars.coll = contractsCache.troveManager.getTroveColl(_borrower);\n\n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.coll, vars.debt, vars.price);\n        vars.newICR = _getNewICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease, vars.price);\n        assert(_collWithdrawal <= vars.coll);\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(isRecoveryMode, _collWithdrawal, _isDebtIncrease, vars);\n\n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough THUSD\n        if (!_isDebtIncrease && _THUSDChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt) - vars.netDebtChange);\n            _requireValidTHUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientTHUSDBalance(contractsCache.thusdToken, _borrower, vars.netDebtChange);\n        }\n\n        (vars.newColl, vars.newDebt) = _updateTroveFromAdjustment(contractsCache.troveManager, _borrower, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        vars.stake = contractsCache.troveManager.updateStakeAndTotalStakes(_borrower);\n\n        // Re-insert trove in to the sorted list\n        uint256 newNICR = _getNewNominalICRFromTroveChange(vars.coll, vars.debt, vars.collChange, vars.isCollIncrease, vars.netDebtChange, _isDebtIncrease);\n        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);\n\n        emit TroveUpdated(_borrower, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n        emit THUSDBorrowingFeePaid(msg.sender,  vars.THUSDFee);\n\n        // Use the unmodified _THUSDChange here, as we don't send the fee to the user\n        _moveTokensAndCollateralfromAdjustment(\n            contractsCache.activePool,\n            contractsCache.thusdToken,\n            msg.sender,\n            vars.collChange,\n            vars.isCollIncrease,\n            _THUSDChange,\n            _isDebtIncrease,\n            vars.netDebtChange\n        );\n    }\n\n    function closeTrove() external override {\n        ITroveManager troveManagerCached = troveManager;\n        IActivePool activePoolCached = activePool;\n        ITHUSDToken thusdTokenCached = thusdToken;\n        bool canMint = thusdTokenCached.mintList(address(this));\n\n        _requireTroveisActive(troveManagerCached, msg.sender);\n        uint256 price = priceFeed.fetchPrice();\n        if (canMint) {\n            _requireNotInRecoveryMode(price);\n        }\n\n        troveManagerCached.applyPendingRewards(msg.sender);\n\n        uint256 coll = troveManagerCached.getTroveColl(msg.sender);\n        uint256 debt = troveManagerCached.getTroveDebt(msg.sender);\n\n        _requireSufficientTHUSDBalance(thusdTokenCached, msg.sender, debt - THUSD_GAS_COMPENSATION);\n        if (canMint) {\n            uint256 newTCR = _getNewTCRFromTroveChange(coll, false, debt, false, price);\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n\n        troveManagerCached.removeStake(msg.sender);\n        troveManagerCached.closeTrove(msg.sender);\n\n        emit TroveUpdated(msg.sender, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid THUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayTHUSD(activePoolCached, thusdTokenCached, msg.sender, debt - THUSD_GAS_COMPENSATION);\n        _repayTHUSD(activePoolCached, thusdTokenCached, gasPoolAddress, THUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        activePoolCached.sendCollateral(msg.sender, coll);\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     */\n    function claimCollateral() external override {\n        // send collateral from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(ITroveManager _troveManager, ITHUSDToken _thusdToken, uint256 _THUSDAmount, uint256 _maxFeePercentage) internal returns (uint) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint256 THUSDFee = _troveManager.getBorrowingFee(_THUSDAmount);\n\n        _requireUserAcceptsFee(THUSDFee, _THUSDAmount, _maxFeePercentage);\n\n        // Send fee to PCV contract\n        _thusdToken.mint(pcvAddress, THUSDFee);\n        return THUSDFee;\n    }\n\n    function _getUSDValue(uint256 _coll, uint256 _price) internal pure returns (uint) {\n        uint256 usdValue = _price * _coll / DECIMAL_PRECISION;\n\n        return usdValue;\n    }\n\n    function _getCollChange(\n        uint256 _collReceived,\n        uint256 _requestedCollWithdrawal\n    )\n        internal\n        pure\n        returns(uint256 collChange, bool isCollIncrease)\n    {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment\n    (\n        ITroveManager _troveManager,\n        address _borrower,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        returns (uint, uint)\n    {\n        uint256 newColl = (_isCollIncrease) ? _troveManager.increaseTroveColl(_borrower, _collChange)\n                                        : _troveManager.decreaseTroveColl(_borrower, _collChange);\n        uint256 newDebt = (_isDebtIncrease) ? _troveManager.increaseTroveDebt(_borrower, _debtChange)\n                                        : _troveManager.decreaseTroveDebt(_borrower, _debtChange);\n\n        return (newColl, newDebt);\n    }\n\n    function _moveTokensAndCollateralfromAdjustment\n    (\n        IActivePool _activePool,\n        ITHUSDToken _thusdToken,\n        address _borrower,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _THUSDChange,\n        bool _isDebtIncrease,\n        uint256 _netDebtChange\n    )\n        internal\n    {\n        if (_isDebtIncrease) {\n            _withdrawTHUSD(_activePool, _thusdToken, _borrower, _THUSDChange, _netDebtChange);\n        } else {\n            _repayTHUSD(_activePool, _thusdToken, _borrower, _THUSDChange);\n        }\n\n        if (_isCollIncrease) {\n            _activePoolAddColl(_activePool, _collChange);\n        } else {\n            _activePool.sendCollateral(_borrower, _collChange);\n        }\n    }\n\n    // Send collateral to Active Pool and increase its recorded collateral balance\n    function _activePoolAddColl(IActivePool _activePool, uint256 _amount) internal {\n        sendCollateralFrom(IERC20(collateralAddress), msg.sender, address(_activePool), _amount);\n\n        if (collateralAddress == address(0)) {\n            return;\n        }\n        _activePool.updateCollateralBalance(_amount);\n    }\n\n    // Issue the specified amount of THUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a THUSDFee)\n    function _withdrawTHUSD(IActivePool _activePool, ITHUSDToken _thusdToken, address _account, uint256 _THUSDAmount, uint256 _netDebtIncrease) internal {\n        _activePool.increaseTHUSDDebt(_netDebtIncrease);\n        _thusdToken.mint(_account, _THUSDAmount);\n    }\n\n    // Burn the specified amount of THUSD from _account and decreases the total active debt\n    function _repayTHUSD(IActivePool _activePool, ITHUSDToken _thusdToken, address _account, uint256 _THUSD) internal {\n        _activePool.decreaseTHUSDDebt(_THUSD);\n        _thusdToken.burn(_account, _THUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    function _requireSingularCollChange(uint256 _collWithdrawal, uint256 _assetAmount) internal pure {\n        require(_assetAmount == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n    }\n\n    function _requireCallerIsBorrower(address _borrower) internal view {\n        require(msg.sender == _borrower, \"BorrowerOps: Caller must be the borrower for a withdrawal\");\n    }\n\n    function _requireNonZeroAdjustment(uint256 _collWithdrawal, uint256 _THUSDChange, uint256 _assetAmount) internal pure {\n        require(_assetAmount != 0 || _collWithdrawal != 0 || _THUSDChange != 0, \"BorrowerOps: There must be either a collateral change or a debt change\");\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint256 status = _troveManager.getTroveStatus(_borrower);\n        require(status == 1, \"BorrowerOps: Trove does not exist or is closed\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        uint256 status = _troveManager.getTroveStatus(_borrower);\n        require(status != 1, \"BorrowerOps: Trove is active\");\n    }\n\n    function _requireNonZeroDebtChange(uint256 _THUSDChange) internal pure {\n        require(_THUSDChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n    }\n\n    function _requireNotInRecoveryMode(uint256 _price) internal view {\n        require(!_checkRecoveryMode(_price), \"BorrowerOps: Operation not permitted during Recovery Mode\");\n    }\n\n    function _requireNoCollWithdrawal(uint256 _collWithdrawal) internal pure {\n        require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode\n    (\n        bool _isRecoveryMode,\n        uint256 _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    )\n        internal\n        view\n    {\n        /*\n         * If contract has been removed from the thUSD mintlist remove the adjustment restrictions\n         */\n        if (!thusdToken.mintList(address(this))) {\n            return;\n        }\n\n        /*\n         *In Recovery Mode, only allow:\n         *\n         * - Pure collateral top-up\n         * - Pure debt repayment\n         * - Collateral top-up with debt repayment\n         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n         *\n         * In Normal Mode, ensure:\n         *\n         * - The new ICR is above MCR\n         * - The adjustment won't pull the TCR below CCR\n         */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }\n        } else { // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(_vars.collChange, _vars.isCollIncrease, _vars.netDebtChange, _isDebtIncrease, _vars.price);\n            _requireNewTCRisAboveCCR(_vars.newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint256 _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {\n        require (_netDebt >= MIN_NET_DEBT, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidTHUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {\n        require(_debtRepayment <= _currentDebt - THUSD_GAS_COMPENSATION, \"BorrowerOps: Amount repaid must not be larger than the Trove's debt\");\n    }\n\n    function _requireCallerIsStabilityPool() internal view {\n        require(msg.sender == stabilityPoolAddress, \"BorrowerOps: Caller is not Stability Pool\");\n    }\n\n     function _requireSufficientTHUSDBalance(ITHUSDToken _thusdToken, address _borrower, uint256 _debtRepayment) internal view {\n        require(_thusdToken.balanceOf(_borrower) >= _debtRepayment, \"BorrowerOps: Caller doesnt have enough THUSD to make repayment\");\n    }\n\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode) internal pure {\n        if (_isRecoveryMode) {\n            require(_maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must less than or equal to 100%\");\n        } else {\n            require(_maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,\n                \"Max fee percentage must be between 0.5% and 100%\");\n        }\n    }\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewNominalICRFromTroveChange\n    (\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint256 newColl, uint256 newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint256 newNICR = LiquityMath._computeNominalCR(newColl, newDebt);\n        return newNICR;\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange\n    (\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        uint256 _price\n    )\n        pure\n        internal\n        returns (uint)\n    {\n        (uint256 newColl, uint256 newDebt) = _getNewTroveAmounts(_coll, _debt, _collChange, _isCollIncrease, _debtChange, _isDebtIncrease);\n\n        uint256 newICR = LiquityMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    )\n        internal\n        pure\n        returns (uint, uint)\n    {\n        uint256 newColl = _coll;\n        uint256 newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll + _collChange :  _coll - _collChange;\n        newDebt = _isDebtIncrease ? _debt + _debtChange : _debt - _debtChange;\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange\n    (\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        uint256 _price\n    )\n        internal\n        view\n        returns (uint)\n    {\n        uint256 totalColl = getEntireSystemColl();\n        uint256 totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl + _collChange : totalColl - _collChange;\n        totalDebt = _isDebtIncrease ? totalDebt + _debtChange : totalDebt - _debtChange;\n\n        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt, _price);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint256 _debt) external pure override returns (uint) {\n        return _getCompositeDebt(_debt);\n    }\n}"
    },
    {
      "filename": "packages/contracts/contracts/BorrowerOperations.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/ITHUSDToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/IPCV.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\nimport \"./Dependencies/SendCollateral.sol\";\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, SendCollateral, IBorrowerOperations {\n\n    string constant public NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    ITroveManager public troveManager;\n\n    address public collateralAddress;\n    address public gasPoolAddress;\n    address public pcvAddress;\n    address public stabilityPoolAddress;\n\n    ICollSurplusPool collSurplusPool;\n\n    IPCV public pcv;\n\n    ITHUSDToken public thusdToken;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves public sortedTroves;\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\n    struct LocalVariables_adjustTrove {\n        uint256 price;\n        uint256 collChange;\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 debt;\n        uint256 coll;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 THUSDFee;\n        uint256 newDebt;\n        uint256 newColl;\n        uint256 stake;\n    }\n\n    struct LocalVariables_openTrove {\n        uint256 price;\n        uint256 THUSDFee;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 NICR;\n        uint256 stake;\n        uint256 arrayIndex;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        ITHUSDToken thusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 stake, BorrowerOperation operation);\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _priceFeedAddress,\n        address _sortedTrovesAddress,\n        address _thusdTokenAddress,\n        address _pcvAddress,\n        address _collateralAddress\n    )\n        external\n        override\n        onlyOwner\n    {\n        // This makes impossible to open a trove with zero withdrawn THUSD\n        assert(MIN_NET_DEBT > 0);\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_priceFeedAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_thusdTokenAddress);\n        checkContract(_pcvAddress);\n        if (_collateralAddress != address(0)) {\n            checkContract(_collateralAddress);\n        }\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        priceFeed ="
    }
  ]
}