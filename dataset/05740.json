{
  "Title": "[G-14] Do not assign `offset` in the last call of `UnsafeBytes.readUint256` in `L1ERC20Bridge.sol`",
  "Content": "\nA simple test in Remix IDE has been created, to compare gas usage of assigning more than one value from function call:\n\n```\n  function getUints() public pure returns (uint, uint) {return (1, 2);}\n   function getAll() public view {\n    uint a; uint b; \n    (a, b) = getUints();\n    uint g = gasleft();\n    (a, b) = getUints();\n    console.log(g - gasleft());\n   }\n    function getOne() public view {\n    uint a; uint b; \n    (a, b) = getUints();\n    uint g = gasleft();\n    (a, ) = getUints();\n    console.log(g - gasleft());\n   }\n```\n\n`getOne()` costs 74 gas, while `getAll()` costs 82 gas. This implies, that we shouldn't assign every parameter from function call if it's not needed.\n\nIn the last call of `UnsafeBytes.readUint256(_l2ToL1message, offset)` (line 336):\n\n[File: ethereum/contracts/bridge/L1ERC20Bridge.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L336)\n\n```\n(amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n```\n\nWe won't need `offset` anymore, thus we can change line 336 to: `(amount, ) = UnsafeBytes.readUint256(_l2ToL1message, offset);`.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IL1BridgeLegacy.sol\";\nimport \"./interfaces/IL1Bridge.sol\";\nimport \"./interfaces/IL2Bridge.sol\";\nimport \"./interfaces/IL2ERC20Bridge.sol\";\n\nimport \"./libraries/BridgeInitializationHelper.sol\";\n\nimport \"../zksync/interfaces/IZkSync.sol\";\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"../common/AllowListed.sol\";\nimport \"../common/libraries/UnsafeBytes.sol\";\nimport \"../common/libraries/L2ContractHelper.sol\";\nimport \"../common/ReentrancyGuard.sol\";\nimport \"../vendor/AddressAliasHelper.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Smart contract that allows depositing ERC20 tokens from Ethereum to zkSync Era\n/// @dev It is standard implementation of ERC20 Bridge that can be used as a reference\n/// for any other custom token bridges.\ncontract L1ERC20Bridge is IL1Bridge, IL1BridgeLegacy, AllowListed, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList internal immutable allowList;\n\n    /// @dev zkSync smart contract that is used to operate with L2 via asynchronous L2 <-> L1 communication\n    IZkSync internal immutable zkSync;\n\n    /// @dev A mapping L2 batch number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 => mapping(uint256 => bool)) public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address => mapping(address => mapping(bytes32 => uint256))) internal depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev The address that acts as a beacon for L2 tokens\n    address public l2TokenBeacon;\n\n    /// @dev The bytecode hash of the L2 token contract\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    mapping(address => uint256) public __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev A mapping L1 token address => the accumulated withdrawn amount during the withdrawal limit window\n    mapping(address => uint256) public __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev The accumulated deposited amount per user.\n    /// @dev A mapping L1 token address => user address => the total deposited amount by the user\n    mapping(address => mapping(address => uint256)) public totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IZkSync _zkSync, IAllowList _allowList) reentrancyGuardInitializer {\n        zkSync = _zkSync;\n        allowList = _allowList;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy\n    /// @dev During initialization deploys L2 bridge counterpart as well as provides some factory deps for it\n    /// @param _factoryDeps A list of raw bytecodes that are needed for deployment of the L2 bridge\n    /// @notice _factoryDeps[0] == a raw bytecode of L2 bridge implementation\n    /// @notice _factoryDeps[1] == a raw bytecode of proxy that is used as L2 bridge\n    /// @notice _factoryDeps[2] == a raw bytecode of token proxy\n    /// @param _l2TokenBeacon Pre-calculated address of the L2 token upgradeable beacon\n    /// @notice At the time of the function call, it is not yet deployed in L2, but knowledge of its address\n    /// @notice is necessary for determining L2 token address by L1 address, see `l2TokenAddress(address)` function\n    /// @param _governor Address which can change L2 token implementation and upgrade the bridge\n    /// @param _deployBridgeImplementationFee How much of the sent value should be allocated to deploying the L2 bridge\n    /// implementation\n    /// @param _deployBridgeProxyFee How much of the sent value should be allocated to deploying the L2 bridge proxy\n    function initialize(\n        bytes[] calldata _factoryDeps,\n        address _l2TokenBeacon,\n        address _governor,\n        uint256 _deployBridgeImplementationFee,\n        uint256 _deployBridgeProxyFee\n    ) external payable reentrancyGuardInitializer {\n        require(_l2TokenBeacon != address(0), \"nf\");\n        require(_governor != address(0), \"nh\");\n        // We are expecting to see the exact three bytecodes that are needed to initialize the bridge\n        require(_factoryDeps.length == 3, \"mk\");\n        // The caller miscalculated deploy transactions fees\n        require(msg.value == _deployBridgeImplementationFee + _deployBridgeProxyFee, \"fee\");\n        l2TokenProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[2]);\n        l2TokenBeacon = _l2TokenBeacon;\n\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[0]);\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[1]);\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            \"\", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n        // Prepare the proxy constructor data\n        bytes memory l2BridgeProxyConstructorData;\n        {\n            // Data to be used in delegate call to initialize the proxy\n            bytes memory proxyInitializationParams = abi.encodeCall(\n                IL2ERC20Bridge.initialize,\n                (address(this), l2TokenProxyBytecodeHash, _governor)\n            );\n            l2BridgeProxyConstructorData = abi.encode(bridgeImplementationAddr, _governor, proxyInitializationParams);\n        }\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n    }\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn't use `nonreentrant` and `senderCanCallFunction` modifiers, because the inner\n    /// method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant senderCanCallFunction(allowList) returns (bytes32 l2TxHash) {\n        require(_amount != 0, \"2T\"); // empty deposit amount\n        uint256 amount = _depositFunds(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, \"1T\"); // The token has non-standard transfer logic\n        // verify the deposit amount is allowed\n        _verifyDepositLimit(_l1Token, msg.sender, _amount, false);\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _l1Token, amount);\n        // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n        // Otherwise, the refund will be sent to the specified address.\n        // If the recipient is a contract on L1, the address alias will be applied.\n        address refundRecipient = _refundRecipient;\n        if (_refundRecipient == address(0)) {\n            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n        }\n        l2TxHash = zkSync.requestL2Transaction{value: msg.value}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            new bytes[](0),\n            refundRecipient\n        );\n\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositAmount[msg.sender][_l1Token][l2TxHash] = amount;\n\n        emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, amount);\n    }\n\n    /// @dev Transfers tokens from the depositor address to the smart contract address\n    /// @return The difference between the contract balance before and after the transferring of funds\n    function _depositFunds(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _token.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Generate a calldata for calling the deposit finalization on the L2 bridge contract\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) internal view returns (bytes memory txCalldata) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n\n        txCalldata = abi.encodeCall(\n            IL2Bridge.finalizeDeposit,\n            (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData)\n        );\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory data) {\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        data = abi.encode(data1, data2, data3);\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant senderCanCallFunction(allowList) {\n        bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, \"yn\");\n\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount > 0, \"y1\");\n\n        // Change the total deposited amount by the user\n        _verifyDepositLimit(_l1Token, _depositSender, amount, true);\n\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n        // Withdraw funds\n        IERC20(_l1Token).safeTransfer(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant senderCanCallFunction(allowList) {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], \"pw\");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBatch: _l2TxNumberInBatch,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, address l1Token, uint256 amount) = _parseL2WithdrawalMessage(l2ToL1Message.data);\n        // Preventing the stack too deep error\n        {\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, \"nq\");\n        }\n\n        isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex] = true;\n        // Withdraw funds\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(\n        bytes memory _l2ToL1message\n    ) internal pure returns (address l1Receiver, address l1Token, uint256 amount) {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n        // 76 (bytes).\n        require(_l2ToL1message.length == 76, \"kk\");\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector, \"nt\");\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n    }\n\n    /// @dev Verify the deposit limit is reached to its cap or not\n    function _verifyDepositLimit(address _l1Token, address _depositor, uint256 _amount, bool _claiming) internal {\n        IAllowList.Deposit memory limitData = IAllowList(allowList).getTokenDepositLimitData(_l1Token);\n        if (!limitData.depositLimitation) return; // no deposit limitation is placed for this token\n\n        if (_claiming) {\n            totalDepositedAmountPerUser[_l1Token][_depositor] -= _amount;\n        } else {\n            require(totalDepositedAmountPerUser[_l1Token][_depositor] + _amount <= limitData.depositCap, \"d1\");\n            totalDepositedAmountPerUser[_l1Token][_depositor] += _amount;\n        }\n    }\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token\n    function l2TokenAddress(address _l1Token) public view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenBeacon), \"\"));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n}"
    }
  ]
}