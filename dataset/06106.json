{
  "Title": "[N-04] Else block not required",
  "Content": "- Severity: Non-Critical\n- Confidence: High\n\n### Description\nThis detector identifies unnecessary else blocks in the code. When an if-statement block ends with a return statement, any subsequent else block becomes superfluous and can be eliminated to reduce code complexity. \n\nNote that this check also applies to single-line else conditions. For instance, in 'return a > b ? a : b', the else condition is not needed.\n\n<details>\n\n<summary>\nThere are 7 instances of this issue:\n\n</summary>\n\n###\n- File: solidity/contracts/core/AMPHClaimer.sol\n```\n \nLine: 182          if (_amphBalance >= _amphByCrv) {\n      // contract has the full amount\n      _cvxAmountToSend = _cvxRewardsFeeToExchange;\n      _crvAmountToSend = _crvRewardsFeeToExchange;\n      _claimableAmph = _amphByCrv;\n    } else {\n      // contract doesnt have the full amount\n      return (0, 0, 0);\n    }\n```\nNo need to declare else block.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/AMPHClaimer.sol#L182-L190](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/AMPHClaimer.sol#L182-L190)\n\n- File: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 475          if (_proposal.executed) return ProposalState.Executed;\n    else if (block.timestamp >= (_proposal.eta + GRACE_PERIOD)) return ProposalState.Expired\n```\nNo need to declare else block.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L475-L476](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L475-L476)\n\n- File: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 474          if (_proposal.eta == 0) return ProposalState.Succeeded;\n    else if (_proposal.executed) return ProposalState.Executed;\n    else if (block.timestamp >= (_proposal.eta + GRACE_PERIOD)) return ProposalState.Expired\n```\nNo need to declare else block.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L474-L476](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L474-L476)\n\n- File: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 469          if (\n      (_whitelisted && _proposal.againstVotes > _proposal.quorumVotes)\n        || (!_whitelisted && _proposal.forVotes <= _proposal.againstVotes)\n        || (!_whitelisted && _proposal.forVotes < _proposal.quorumVotes)\n    ) return ProposalState.Defeated;\n    else if (_proposal.eta == 0) return ProposalState.Succeeded;\n    else if (_proposal.executed) return ProposalState.Executed;\n    else if (block.timestamp >= (_proposal.eta + GRACE_PERIOD)) return ProposalState.Expired\n```\nNo need to declare else block.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L469-L476](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L469-L476)\n\n- File: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 468          if (block.number <= _proposal.endBlock) return ProposalState.Active;\n    else if (\n      (_whitelisted && _proposal.againstVotes > _proposal.quorumVotes)\n        || (!_whitelisted && _proposal.forVotes <= _proposal.againstVotes)\n        || (!_whitelisted && _proposal.forVotes < _proposal.quorumVotes)\n    ) return ProposalState.Defeated;\n    else if (_proposal.eta == 0) return ProposalState.Succeeded;\n    else if (_proposal.executed) return ProposalState.Executed;\n    else if (block.timestamp >= (_proposal.eta + GRACE_PERIOD)) return ProposalState.Expired\n```\nNo need to declare else block.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L468-L476](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L468-L476)\n\n- File: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 467          if (block.number <= _proposal.startBlock) return ProposalState.Pending;\n    else if (block.number <= _proposal.endBlock) return ProposalState.Active;\n    else if (\n      (_whitelisted && _proposal.againstVotes > _proposal.quorumVotes)\n        || (!_whitelisted && _proposal.forVotes <= _proposal.againstVotes)\n        || (!_whitelisted && _proposal.forVotes < _proposal.quorumVotes)\n    ) return ProposalState.Defeated;\n    else if (_proposal.eta == 0) return ProposalState.Succeeded;\n    else if (_proposal.executed) return ProposalState.Executed;\n    else if (block.timestamp >= (_proposal.eta + GRACE_PERIOD)) return ProposalState.Expired\n```\nNo need to declare else block.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L467-L476](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L467-L476)\n\n- File: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 466          if (_proposal.canceled) return ProposalState.Canceled;\n    else if (block.number <= _proposal.startBlock) return ProposalState.Pending;\n    else if (block.number <= _proposal.endBlock) return ProposalState.Active;\n    else if (\n      (_whitelisted && _proposal.againstVotes > _proposal.quorumVotes)\n        || (!_whitelisted && _proposal.forVotes <= _proposal.againstVotes)\n        || (!_whitelisted && _proposal.forVotes < _proposal.quorumVotes)\n    ) return ProposalState.Defeated;\n    else if (_proposal.eta == 0) return ProposalState.Succeeded;\n    else if (_proposal.executed) return ProposalState.Executed;\n    else if (block.timestamp >= (_proposal.eta + GRACE_PERIOD)) return ProposalState.Expired\n```\nNo need to declare else block.<br>\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L466-L476](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L466-L476)\n\n</details>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-amphora",
  "Code": [
    {
      "filename": "core/solidity/contracts/core/AMPHClaimer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\nimport {IAMPHClaimer} from '@interfaces/core/IAMPHClaimer.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {SafeERC20, IERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\nimport {IVault} from '@interfaces/core/IVault.sol';\n\n/// @notice AMPHClaimer contract, used to exchange CVX and CRV at a fixed rate for AMPH\ncontract AMPHClaimer is IAMPHClaimer, Ownable {\n  using SafeERC20 for IERC20;\n\n  uint256 internal constant _BASE = 1 ether;\n\n  /// @dev Constant used in the formula\n  uint256 internal constant _FIFTY_MILLIONS = 50_000_000 * 1e6;\n\n  /// @dev Constant used in the formula\n  uint256 internal constant _TWENTY_FIVE_THOUSANDS = 25_000 * 1e6;\n\n  /// @dev Constant used in the formula\n  uint256 internal constant _FIFTY = 50 * 1e6;\n\n  /// @dev The base supply of AMPH per cliff, denominated in 1e6\n  uint256 public constant BASE_SUPPLY_PER_CLIFF = 8_000_000 * 1e6;\n\n  /// @dev The total number of cliffs (for both tokens)\n  uint256 public constant TOTAL_CLIFFS = 1000;\n\n  /// @dev The CVX token\n  IERC20 public immutable CVX;\n\n  /// @dev The CRV token\n  IERC20 public immutable CRV;\n\n  /// @dev The AMPH token\n  IERC20 public immutable AMPH;\n\n  /// @dev The total amount of AMPH minted for rewards in CRV, denominated in 1e6\n  uint256 public distributedAmph;\n\n  /// @dev Percentage of rewards taken in CVX (1e18 == 100%)\n  uint256 public cvxRewardFee;\n\n  /// @dev Percentage of rewards taken in CRV (1e18 == 100%)\n  uint256 public crvRewardFee;\n\n  /// @dev The vault controller\n  IVaultController public vaultController;\n\n  constructor(\n    address _vaultController,\n    IERC20 _amph,\n    IERC20 _cvx,\n    IERC20 _crv,\n    uint256 _cvxRewardFee,\n    uint256 _crvRewardFee\n  ) {\n    vaultController = IVaultController(_vaultController);\n    CVX = _cvx;\n    CRV = _crv;\n    AMPH = _amph;\n\n    cvxRewardFee = _cvxRewardFee;\n    crvRewardFee = _crvRewardFee;\n  }\n\n  /// @notice Claims an amount of AMPH given a CVX and CRV quantity\n  /// @param _vaultId The vault id that is claiming\n  /// @param _cvxTotalRewards The max CVX amount to exchange from the sender\n  /// @param _crvTotalRewards The max CVR amount to exchange from the sender\n  /// @param _beneficiary The receiver of the AMPH rewards\n  /// @return _cvxAmountToSend The amount of CVX that the treasury got\n  /// @return _crvAmountToSend The amount of CRV that the treasury got\n  /// @return _claimedAmph The amount of AMPH received by the beneficiary\n  function claimAmph(\n    uint96 _vaultId,\n    uint256 _cvxTotalRewards,\n    uint256 _crvTotalRewards,\n    address _beneficiary\n  ) external override returns (uint256 _cvxAmountToSend, uint256 _crvAmountToSend, uint256 _claimedAmph) {\n    (_cvxAmountToSend, _crvAmountToSend, _claimedAmph) =\n      _claimable(msg.sender, _vaultId, _cvxTotalRewards, _crvTotalRewards);\n\n    /// Update the state\n    if (_crvAmountToSend != 0 && _claimedAmph != 0) distributedAmph += (_claimedAmph / 1e12); // scale back to 1e6\n\n    CVX.safeTransferFrom(msg.sender, owner(), _cvxAmountToSend);\n    CRV.safeTransferFrom(msg.sender, owner(), _crvAmountToSend);\n\n    // transfer AMPH token to minter\n    AMPH.safeTransfer(_beneficiary, _claimedAmph);\n\n    emit ClaimedAmph(msg.sender, _cvxAmountToSend, _crvAmountToSend, _claimedAmph);\n  }\n\n  /// @notice Returns the claimable amount of AMPH given a CVX and CRV quantity\n  /// @param _sender The address of the account claiming\n  /// @param _vaultId The vault id that is claiming\n  /// @param _cvxTotalRewards The max CVX amount to exchange from the sender\n  /// @param _crvTotalRewards The max CVR amount to exchange from the sender\n  /// @return _cvxAmountToSend The amount of CVX the user will have to send\n  /// @return _crvAmountToSend The amount of CRV the user will have to send\n  /// @return _claimableAmph The amount of AMPH that would be received by the beneficiary\n  function claimable(\n    address _sender,\n    uint96 _vaultId,\n    uint256 _cvxTotalRewards,\n    uint256 _crvTotalRewards\n  ) external view override returns (uint256 _cvxAmountToSend, uint256 _crvAmountToSend, uint256 _claimableAmph) {\n    (_cvxAmountToSend, _crvAmountToSend, _claimableAmph) =\n      _claimable(_sender, _vaultId, _cvxTotalRewards, _crvTotalRewards);\n  }\n\n  /// @notice Used by governance to change the vault controller\n  /// @param _newVaultController The new vault controller\n  function changeVaultController(address _newVaultController) external override onlyOwner {\n    vaultController = IVaultController(_newVaultController);\n\n    emit ChangedVaultController(_newVaultController);\n  }\n\n  /// @notice Used by governance to recover tokens from the contract\n  /// @param _token The token to recover\n  /// @param _amount The amount to recover\n  function recoverDust(address _token, uint256 _amount) external override onlyOwner {\n    IERC20(_token).transfer(owner(), _amount);\n\n    emit RecoveredDust(_token, owner(), _amount);\n  }\n\n  /// @notice Used by governance to change the fee taken from the CVX reward\n  /// @param _newFee The new reward fee\n  function changeCvxRewardFee(uint256 _newFee) external override onlyOwner {\n    cvxRewardFee = _newFee;\n\n    emit ChangedCvxRewardFee(_newFee);\n  }\n\n  /// @notice Used by governance to change the fee taken from the CRV reward\n  /// @param _newFee The new reward fee\n  function changeCrvRewardFee(uint256 _newFee) external override onlyOwner {\n    crvRewardFee = _newFee;\n\n    emit ChangedCrvRewardFee(_newFee);\n  }\n\n  /// @dev Receives a total and a percentage, returns the amount equivalent of the percentage\n  function _totalToFraction(uint256 _total, uint256 _fraction) internal pure returns (uint256 _amount) {\n    if (_total == 0) return 0;\n    _amount = (_total * _fraction) / _BASE;\n  }\n\n  /// @dev Doesn't revert but returns 0 so the vault contract doesn't revert on calling the claim function\n  /// @dev Returns the claimable amount of AMPH, also the CVX and CRV the contract will take from the user\n  function _claimable(\n    address _sender,\n    uint96 _vaultId,\n    uint256 _cvxTotalRewards,\n    uint256 _crvTotalRewards\n  ) internal view returns (uint256 _cvxAmountToSend, uint256 _crvAmountToSend, uint256 _claimableAmph) {\n    if (_sender != vaultController.vaultIdVaultAddress(_vaultId)) return (0, 0, 0);\n\n    uint256 _amphBalance = AMPH.balanceOf(address(this));\n\n    // if amounts are zero, or AMPH balance is zero simply return all zeros\n    if (_crvTotalRewards == 0 || _amphBalance == 0) return (0, 0, 0);\n\n    uint256 _cvxRewardsFeeToExchange = _totalToFraction(_cvxTotalRewards, cvxRewardFee);\n    uint256 _crvRewardsFeeToExchange = _totalToFraction(_crvTotalRewards, crvRewardFee);\n\n    uint256 _amphByCrv = _calculate(_crvRewardsFeeToExchange);\n\n    // Check if all cliffs consumed\n    if (_getCliff((_amphByCrv / 1e12) + distributedAmph) >= TOTAL_CLIFFS) return (0, 0, 0);\n\n    // check for rounding errors\n    if (_amphByCrv == 0) return (0, 0, 0);\n\n    if (_amphBalance >= _amphByCrv) {\n      // contract has the full amount\n      _cvxAmountToSend = _cvxRewardsFeeToExchange;\n      _crvAmountToSend = _crvRewardsFeeToExchange;\n      _claimableAmph = _amphByCrv;\n    } else {\n      // contract doesnt have the full amount\n      return (0, 0, 0);\n    }\n  }\n\n  /// @dev Returns the rate of the token, denominated in 1e6\n  function _getRate(uint256 _distributedAmph) internal pure returns (uint256 _rate) {\n    uint256 _foo = (_TWENTY_FIVE_THOUSANDS * BASE_SUPPLY_PER_CLIFF) / Math.max(_distributedAmph, _FIFTY_MILLIONS);\n    uint256 _bar = (_distributedAmph * 1e12) / (BASE_SUPPLY_PER_CLIFF * _FIFTY);\n\n    _rate = 1e6 + (_foo - _bar);\n  }\n\n  /// @dev Returns how much AMPH would be minted given a token amount\n  function _calculate(uint256 _tokenAmountToSend) internal view returns (uint256 _amphAmount) {\n    if (_tokenAmountToSend == 0) return 0;\n\n    uint256 _tempAmountReceived = _tokenAmountToSend; // CRV, 1e18\n    uint256 _amphToMint; // 1e18\n\n    uint256 _distributedAmph = distributedAmph;\n\n    while (_tempAmountReceived > 0) {\n      uint256 _amphForThisTurn;\n\n      // all cliffs start when a certain amount of CRV is accumulated and finish when a certain amount is reached, this is the start of the current cliff\n      uint256 _bottomLastCliff = _getCliff(_distributedAmph) * BASE_SUPPLY_PER_CLIFF;\n\n      // get rate\n      uint256 _rate = _getRate(_distributedAmph); // 1e6\n\n      // calculate how many AMPH to mint given that rate.\n      // transform the CRV amount to 1e6 and multiply.\n      // perform the mul first to avoid rounding errors.\n      _amphForThisTurn = ((_rate * _tempAmountReceived) / 1e12) / 1e6; // 1e6\n\n      // calculate the amph available for this cliff\n      uint256 _amphAvailableForThisCliff = (_bottomLastCliff + BASE_SUPPLY_PER_CLIFF) - _distributedAmph; // 1e6\n\n      // check if the amount of amph to mint surpasses the cliff\n      if (_amphAvailableForThisCliff < _amphForThisTurn) {\n        /// surpassing the cliff\n        _amphForThisTurn = _amphAvailableForThisCliff;\n        // calculate how many CRV are entering this cliff\n        uint256 _amountTokenToEnter = (_amphAvailableForThisCliff * 1e18) / _rate;\n        _tempAmountReceived -= _amountTokenToEnter;\n      } else {\n        /// within the cliff\n        _tempAmountReceived = 0;\n      }\n\n      _distributedAmph += _amphForThisTurn; // 1e6\n\n      _amphToMint += (_amphForThisTurn * 1e12); // 1e18\n    }\n\n    // return\n    _amphAmount = _amphToMint;\n  }\n\n  /// @dev Returns the current cliff, it will round down but is on purpose\n  function _getCliff(uint256 _distributedAmph) internal pure returns (uint256 _cliff) {\n    _cliff = _distributedAmph / BASE_SUPPLY_PER_CLIFF;\n  }\n}"
    },
    {
      "filename": "core/solidity/contracts/governance/GovernorCharlie.sol",
      "content": "// solhint-disable max-states-count\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\nimport {IAMPH} from '@interfaces/governance/IAMPH.sol';\nimport {IGovernorCharlie} from '@interfaces/governance/IGovernorCharlie.sol';\n\nimport {Receipt, ProposalState, Proposal} from '@contracts/utils/GovernanceStructs.sol';\n\ncontract GovernorCharlie is IGovernorCharlie {\n  /// @notice The name of this contract\n  string public constant NAME = 'Amphora Protocol Governor';\n\n  /// @notice The maximum number of actions that can be included in a proposal\n  uint256 public constant PROPOSAL_MAX_OPERATIONS = 10;\n\n  /// @notice The EIP-712 typehash for the contract's domain\n  bytes32 public constant DOMAIN_TYPEHASH =\n    keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n  /// @notice The EIP-712 typehash for the ballot struct used by the contract\n  bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n  /// @notice The time for a proposal to be executed after passing\n  uint256 public constant GRACE_PERIOD = 14 days;\n\n  /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n  uint256 public quorumVotes;\n\n  /// @notice The number of votes in support of a proposal required in order for an emergency quorum to be reached and for a vote to succeed\n  uint256 public emergencyQuorumVotes;\n\n  /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\n  uint256 public votingDelay;\n\n  /// @notice The duration of voting on a proposal, in blocks\n  uint256 public votingPeriod;\n\n  /// @notice The number of votes required in order for a voter to become a proposer\n  uint256 public proposalThreshold;\n\n  /// @notice Initial proposal id set at become\n  uint256 public initialProposalId;\n\n  /// @notice The total number of proposals\n  uint256 public proposalCount;\n\n  /// @notice The address of the Amphora Protocol governance token\n  IAMPH public amph;\n\n  /// @notice The official record of all proposals ever proposed\n  mapping(uint256 => Proposal) public proposals;\n\n  /// @notice The latest proposal for each proposer\n  mapping(address => uint256) public latestProposalIds;\n\n  /// @notice The mapping that saves queued transactions\n  mapping(bytes32 => bool) public queuedTransactions;\n\n  /// @notice The proposal holding period\n  uint256 public proposalTimelockDelay;\n\n  /// @notice Stores the expiration of account whitelist status as a timestamp\n  mapping(address => uint256) public whitelistAccountExpirations;\n\n  /// @notice Address which manages whitelisted proposals and whitelist accounts\n  address public whitelistGuardian;\n\n  /// @notice The duration of the voting on a emergency proposal, in blocks\n  uint256 public emergencyVotingPeriod;\n\n  /// @notice The emergency proposal holding period\n  uint256 public emergencyTimelockDelay;\n\n  /// @notice all receipts for proposal\n  mapping(uint256 => mapping(address => Receipt)) public proposalReceipts;\n\n  /// @notice The number of votes to reject an optimistic proposal\n  uint256 public optimisticQuorumVotes;\n\n  /// @notice The delay period before voting begins\n  uint256 public optimisticVotingDelay;\n\n  /// @notice The maximum number of seconds an address can be whitelisted for\n  uint256 public maxWhitelistPeriod;\n\n  constructor(address _amph) {\n    amph = IAMPH(_amph);\n    votingPeriod = 40_320;\n    votingDelay = 13_140;\n    proposalThreshold = 1_000_000_000_000_000_000_000_000;\n    proposalTimelockDelay = 172_800;\n    proposalCount = 0;\n    quorumVotes = 10_000_000_000_000_000_000_000_000;\n    emergencyQuorumVotes = 40_000_000_000_000_000_000_000_000;\n    emergencyVotingPeriod = 6570;\n    emergencyTimelockDelay = 43_200;\n\n    optimisticQuorumVotes = 2_000_000_000_000_000_000_000_000;\n    optimisticVotingDelay = 25_600;\n    maxWhitelistPeriod = 31_536_000;\n  }\n\n  /// @notice any function with this modifier can only be called by governance\n  modifier onlyGov() {\n    if (msg.sender != address(this)) revert GovernorCharlie_NotGovernorCharlie();\n    _;\n  }\n\n  /**\n   * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n   * @param _targets Target addresses for proposal calls\n   * @param _values Eth values for proposal calls\n   * @param _signatures Function signatures for proposal calls\n   * @param _calldatas Calldatas for proposal calls\n   * @param _description String description of the proposal\n   * @return _proposalId Proposal id of new proposal\n   */\n  function propose(\n    address[] memory _targets,\n    uint256[] memory _values,\n    string[] memory _signatures,\n    bytes[] memory _calldatas,\n    string memory _description\n  ) public override returns (uint256 _proposalId) {\n    _proposalId = _propose(_targets, _values, _signatures, _calldatas, _description, false);\n  }\n\n  /**\n   * @notice Function used to propose a new emergency proposal. Sender must have delegates above the proposal threshold\n   * @param _targets Target addresses for proposal calls\n   * @param _values Eth values for proposal calls\n   * @param _signatures Function signatures for proposal calls\n   * @param _calldatas Calldatas for proposal calls\n   * @param _description String description of the proposal\n   * @return _proposalId Proposal id of new proposal\n   */\n  function proposeEmergency(\n    address[] memory _targets,\n    uint256[] memory _values,\n    string[] memory _signatures,\n    bytes[] memory _calldatas,\n    string memory _description\n  ) public override returns (uint256 _proposalId) {\n    _proposalId = _propose(_targets, _values, _signatures, _calldatas, _description, true);\n  }\n\n  /**\n   * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n   * @param _targets Target addresses for proposal calls\n   * @param _values Eth values for proposal calls\n   * @param _signatures Function signatures for proposal calls\n   * @param _calldatas Calldatas for proposal calls\n   * @param _description String description of the proposal\n   * @param _emergency Bool to determine if proposal an emergency proposal\n   * @return _proposalId Proposal id of new proposal\n   */\n  function _propose(\n    address[] memory _targets,\n    uint256[] memory _values,\n    string[] memory _signatures,\n    bytes[] memory _calldatas,\n    string memory _description,\n    bool _emergency\n  ) internal returns (uint256 _proposalId) {\n    // Reject proposals before initiating as Governor\n    if (quorumVotes == 0) revert GovernorCharlie_NotActive();\n    // Allow addresses above proposal threshold and whitelisted addresses to propose\n    if (amph.getPriorVotes(msg.sender, (block.number - 1)) < proposalThreshold && !isWhitelisted(msg.sender)) {\n      revert GovernorCharlie_VotesBelowThreshold();\n    }\n    if (\n      _targets.length != _values.length || _targets.length != _signatures.length || _targets.length != _calldatas.length\n    ) revert GovernorCharlie_ArityMismatch();\n    if (_targets.length == 0) revert GovernorCharlie_NoActions();\n    if (_targets.length > PROPOSAL_MAX_OPERATIONS) revert GovernorCharlie_TooManyActions();\n\n    uint256 _latestProposalId = latestProposalIds[msg.sender];\n    if (_latestProposalId != 0) {\n      ProposalState _proposersLatestProposalState = state(_latestProposalId);\n      if (_proposersLatestProposalState == ProposalState.Active) revert GovernorCharlie_MultipleActiveProposals();\n      if (_proposersLatestProposalState == ProposalState.Pending) revert GovernorCharlie_MultiplePendingProposals();\n    }\n\n    proposalCount++;\n    Proposal memory _newProposal = Proposal({\n      id: proposalCount,\n      proposer: msg.sender,\n      eta: 0,\n      targets: _targets,\n      values: _values,\n      signatures: _signatures,\n      calldatas: _calldatas,\n      startBlock: block.number + votingDelay,\n      endBlock: block.number + votingDelay + votingPeriod,\n      forVotes: 0,\n      againstVotes: 0,\n      abstainVotes: 0,\n      canceled: false,\n      executed: false,\n      emergency: _emergency,\n      quorumVotes: quorumVotes,\n      delay: proposalTimelockDelay\n    });\n\n    //whitelist can't make emergency\n    if (_emergency && !isWhitelisted(msg.sender)) {\n      _newProposal.startBlock = block.number;\n      _newProposal.endBlock = block.number + emergencyVotingPeriod;\n      _newProposal.quorumVotes = emergencyQuorumVotes;\n      _newProposal.delay = emergencyTimelockDelay;\n    }\n\n    //whitelist can only make optimistic proposals\n    if (isWhitelisted(msg.sender)) {\n      _newProposal.quorumVotes = optimisticQuorumVotes;\n      _newProposal.startBlock = block.number + optimisticVotingDelay;\n      _newProposal.endBlock = block.number + optimisticVotingDelay + votingPeriod;\n    }\n\n    proposals[_newProposal.id] = _newProposal;\n    latestProposalIds[_newProposal.proposer] = _newProposal.id;\n\n    emit ProposalCreatedIndexed(\n      _newProposal.id,\n      msg.sender,\n      _targets,\n      _values,\n      _signatures,\n      _calldatas,\n      _newProposal.startBlock,\n      _newProposal.endBlock,\n      _description\n    );\n\n    emit ProposalCreated(\n      _newProposal.id,\n      msg.sender,\n      _targets,\n      _values,\n      _signatures,\n      _calldatas,\n      _newProposal.startBlock,\n      _newProposal.endBlock,\n      _description\n    );\n    _proposalId = _newProposal.id;\n  }\n\n  /**\n   * @notice Queues a proposal of state succeeded\n   * @param _proposalId The id of the proposal to queue\n   */\n  function queue(uint256 _proposalId) external override {\n    if (state(_proposalId) != ProposalState.Succeeded) revert GovernorCharlie_ProposalNotSucceeded();\n    Proposal storage _proposal = proposals[_proposalId];\n    uint256 _eta = block.timestamp + _proposal.delay;\n    for (uint256 _i = 0; _i < _proposal.targets.length; _i++) {\n      if (\n        queuedTransactions[keccak256(\n          abi.encode(\n            _proposal.targets[_i], _proposal.values[_i], _proposal.signatures[_i], _proposal.calldatas[_i], _eta\n          )\n        )]\n      ) revert GovernorCharlie_ProposalAlreadyQueued();\n      _queueTransaction(\n        _proposal.targets[_i],\n        _proposal.values[_i],\n        _proposal.signatures[_i],\n        _proposal.calldatas[_i],\n        _eta,\n        _proposal.delay\n      );\n    }\n    _proposal.eta = _eta;\n    emit ProposalQueuedIndexed(_proposalId, _eta);\n    emit ProposalQueued(_proposalId, _eta);\n  }\n\n  /// @notice Queues a transaction\n  /// @param _target Target address for transaction\n  /// @param _value Eth value for transaction\n  /// @param _signature Function signature for transaction\n  /// @param _data Calldata for transaction\n  /// @param _eta Timestamp for transaction\n  /// @param _delay Delay for transaction\n  /// @return _txHash Transaction hash\n  function _queueTransaction(\n    address _target,\n    uint256 _value,\n    string memory _signature,\n    bytes memory _data,\n    uint256 _eta,\n    uint256 _delay\n  ) internal returns (bytes32 _txHash) {\n    if (_eta < (_getBlockTimestamp() + _delay)) revert GovernorCharlie_DelayNotReached();\n\n    _txHash = keccak256(abi.encode(_target, _value, _signature, _data, _eta));\n    queuedTransactions[_txHash] = true;\n\n    emit QueueTransaction(_txHash, _target, _value, _signature, _data, _eta);\n  }\n\n  /**\n   * @notice Executes a queued proposal if eta has passed\n   * @param _proposalId The id of the proposal to execute\n   */\n  function execute(uint256 _proposalId) external payable override {\n    if (state(_proposalId) != ProposalState.Queued) revert GovernorCharlie_ProposalNotQueued();\n    Proposal storage _proposal = proposals[_proposalId];\n    _proposal.executed = true;\n    for (uint256 _i = 0; _i < _proposal.targets.length; _i++) {\n      this.executeTransaction{value: _proposal.values[_i]}(\n        _proposal.targets[_i], _proposal.values[_i], _proposal.signatures[_i], _proposal.calldatas[_i], _proposal.eta\n      );\n    }\n    emit ProposalExecutedIndexed(_proposalId);\n    emit ProposalExecuted(_proposalId);\n  }\n\n  /// @notice Executes a transaction\n  /// @param _target Target address for transaction\n  /// @param _value Eth value for transaction\n  /// @param _signature Function signature for transaction\n  /// @param _data Calldata for transaction\n  /// @param _eta Timestamp for transaction\n  function executeTransaction(\n    address _target,\n    uint256 _value,\n    string memory _signature,\n    bytes memory _data,\n    uint256 _eta\n  ) external payable override {\n    if (msg.sender != address(this)) revert GovernorCharlie_NotGovernorCharlie();\n\n    bytes32 _txHash = keccak256(abi.encode(_target, _value, _signature, _data, _eta));\n    if (!queuedTransactions[_txHash]) revert GovernorCharlie_ProposalNotQueued();\n    if (_getBlockTimestamp() < _eta) revert GovernorCharlie_TimelockNotReached();\n    if (_getBlockTimestamp() > _eta + GRACE_PERIOD) revert GovernorCharlie_TransactionStale();\n\n    queuedTransactions[_txHash] = false;\n\n    bytes memory _callData;\n\n    if (bytes(_signature).length == 0) _callData = _data;\n    else _callData = abi.encodePacked(bytes4(keccak256(bytes(_signature))), _data);\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool _success, /*bytes memory returnData*/ ) = _target.call{value: _value}(_callData);\n    if (!_success) revert GovernorCharlie_TransactionReverted();\n\n    emit ExecuteTransaction(_txHash, _target, _value, _signature, _data, _eta);\n  }\n\n  /**\n   * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n   * @notice whitelistGuardian can cancel proposals from whitelisted addresses\n   * @param _proposalId The id of the proposal to cancel\n   */\n  function cancel(uint256 _proposalId) external override {\n    if (state(_proposalId) == ProposalState.Executed) revert GovernorCharlie_ProposalAlreadyExecuted();\n\n    Proposal storage _proposal = proposals[_proposalId];\n\n    // Proposer can cancel\n    if (msg.sender != _proposal.proposer) {\n      // Whitelisted proposers can't be canceled for falling below proposal threshold\n      if (isWhitelisted(_proposal.proposer)) {\n        if (\n          (amph.getPriorVotes(_proposal.proposer, (block.number - 1)) >= proposalThreshold)\n            || msg.sender != whitelistGuardian\n        ) revert GovernorCharlie_WhitelistedProposer();\n      } else {\n        if ((amph.getPriorVotes(_proposal.proposer, (block.number - 1)) >= proposalThreshold)) {\n          revert GovernorCharlie_ProposalAboveThreshold();\n        }\n      }\n    }\n\n    _proposal.canceled = true;\n    for (uint256 _i = 0; _i < _proposal.targets.length; _i++) {\n      _cancelTransaction(\n        _proposal.targets[_i], _proposal.values[_i], _proposal.signatures[_i], _proposal.calldatas[_i], _proposal.eta\n      );\n    }\n\n    emit ProposalCanceledIndexed(_proposalId);\n    emit ProposalCanceled(_proposalId);\n  }\n\n  /// @notice Cancels a transaction\n  /// @param _target Target address for transaction\n  /// @param _value Eth value for transaction\n  /// @param _signature Function signature for transaction\n  /// @param _data Calldata for transaction\n  /// @param _eta Timestamp for transaction\n  function _cancelTransaction(\n    address _target,\n    uint256 _value,\n    string memory _signature,\n    bytes memory _data,\n    uint256 _eta\n  ) internal {\n    bytes32 _txHash = keccak256(abi.encode(_target, _value, _signature, _data, _eta));\n    queuedTransactions[_txHash] = false;\n\n    emit CancelTransaction(_txHash, _target, _value, _signature, _data, _eta);\n  }\n\n  /**\n   * @notice Gets actions of a proposal\n   * @param _proposalId The id of the proposal\n   * @return _targets The proposal targets\n   * @return _values The proposal values\n   * @return _signatures The proposal signatures\n   * @return _calldatas The proposal calldata\n   */\n  function getActions(uint256 _proposalId)\n    external\n    view\n    override\n    returns (\n      address[] memory _targets,\n      uint256[] memory _values,\n      string[] memory _signatures,\n      bytes[] memory _calldatas\n    )\n  {\n    Proposal storage _proposal = proposals[_proposalId];\n    return (_proposal.targets, _proposal.values, _proposal.signatures, _proposal.calldatas);\n  }\n\n  /**\n   * @notice Returns the proposal\n   * @param _proposalId The id of proposal\n   * @return _proposal The proposal\n   */\n  function getProposal(uint256 _proposalId) external view returns (Proposal memory _proposal) {\n    _proposal = proposals[_proposalId];\n  }\n\n  /**\n   * @notice Gets the receipt for a voter on a given proposal\n   * @param _proposalId The id of proposal\n   * @param _voter The address of the voter\n   * @return _votingReceipt The voting receipt\n   */\n  function getReceipt(\n    uint256 _proposalId,\n    address _voter\n  ) external view override returns (Receipt memory _votingReceipt) {\n    _votingReceipt = proposalReceipts[_proposalId][_voter];\n  }\n\n  /**\n   * @notice Gets the state of a proposal\n   * @param _proposalId The id of the proposal\n   * @return _state Proposal state\n   */\n  // solhint-disable-next-line code-complexity\n  function state(uint256 _proposalId) public view override returns (ProposalState _state) {\n    if (proposalCount < _proposalId || _proposalId <= initialProposalId) revert GovernorCharlie_InvalidProposalId();\n    Proposal storage _proposal = proposals[_proposalId];\n    bool _whitelisted = isWhitelisted(_proposal.proposer);\n    if (_proposal.canceled) return ProposalState.Canceled;\n    else if (block.number <= _proposal.startBlock) return ProposalState.Pending;\n    else if (block.number <= _proposal.endBlock) return ProposalState.Active;\n    else if (\n      (_whitelisted && _proposal.againstVotes > _proposal.quorumVotes)\n        || (!_whitelisted && _proposal.forVotes <= _proposal.againstVotes)\n        || (!_whitelisted && _proposal.forVotes < _proposal.quorumVotes)\n    ) return ProposalState.Defeated;\n    else if (_proposal.eta == 0) return ProposalState.Succeeded;\n    else if (_proposal.executed) return ProposalState.Executed;\n    else if (block.timestamp >= (_proposal.eta + GRACE_PERIOD)) return ProposalState.Expired;\n    _state = ProposalState.Queued;\n  }\n\n  /**\n   * @notice Cast a vote for a proposal\n   * @param _proposalId The id of the proposal to vote on\n   * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n   */\n  function castVote(uint256 _proposalId, uint8 _support) external override {\n    uint96 _numberOfVotes = _castVoteInternal(msg.sender, _proposalId, _support);\n    emit VoteCastIndexed(msg.sender, _proposalId, _support, _numberOfVotes, '');\n    emit VoteCast(msg.sender, _proposalId, _support, _numberOfVotes, '');\n  }\n\n  /**\n   * @notice Cast a vote for a proposal with a reason\n   * @param _proposalId The id of the proposal to vote on\n   * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n   * @param _reason The reason given for the vote by the voter\n   */\n  function castVoteWithReason(uint256 _proposalId, uint8 _support, string calldata _reason) external override {\n    uint96 _numberOfVotes = _castVoteInternal(msg.sender, _proposalId, _support);\n    emit VoteCastIndexed(msg.sender, _proposalId, _support, _numberOfVotes, _reason);\n    emit VoteCast(msg.sender, _proposalId, _support, _numberOfVotes, _reason);\n  }\n\n  /**\n   * @notice Cast a vote for a proposal by signature\n   * @dev External override function that accepts EIP-712 signatures for voting on proposals.\n   */\n  function castVoteBySig(uint256 _proposalId, uint8 _support, uint8 _v, bytes32 _r, bytes32 _s) external override {\n    bytes32 _domainSeparator =\n      keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), _getChainIdInternal(), address(this)));\n    bytes32 _structHash = keccak256(abi.encode(BALLOT_TYPEHASH, _proposalId, _support));\n\n    bytes32 _digest = keccak256(abi.encodePacked('\\x19\\x01', _domainSeparator, _structHash));\n\n    if (uint256(_s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      revert GovernorCharlie_InvalidSignature();\n    }\n    address _signatory = ecrecover(_digest, _v, _r, _s);\n    if (_signatory == address(0)) revert GovernorCharlie_InvalidSignature();\n    uint96 _numberOfVotes = _castVoteInternal(_signatory, _proposalId, _support);\n    emit VoteCastIndexed(_signatory, _proposalId, _support, _numberOfVotes, '');\n    emit VoteCast(_signatory, _proposalId, _support, _numberOfVotes, '');\n  }\n\n  /**\n   * @notice Internal function that caries out voting logic\n   * @param _voter The voter that is casting their vote\n   * @param _proposalId The id of the proposal to vote on\n   * @param _support The support value for the vote. 0=against, 1=for, 2=abstain\n   * @return _numberOfVotes The number of votes cast\n   */\n  function _castVoteInternal(\n    address _voter,\n    uint256 _proposalId,\n    uint8 _support\n  ) internal returns (uint96 _numberOfVotes) {\n    if (state(_proposalId) != ProposalState.Active) revert GovernorCharlie_VotingClosed();\n    if (_support > 2) revert GovernorCharlie_InvalidVoteType();\n    Proposal storage _proposal = proposals[_proposalId];\n    Receipt storage _receipt = proposalReceipts[_proposalId][_voter];\n    if (_receipt.hasVoted) revert GovernorCharlie_AlreadyVoted();\n    uint96 _votes = amph.getPriorVotes(_voter, _proposal.startBlock);\n\n    if (_support == 0) _proposal.againstVotes = _proposal.againstVotes + _votes;\n    else if (_support == 1) _proposal.forVotes = _proposal.forVotes + _votes;\n    else if (_support == 2) _proposal.abstainVotes = _proposal.abstainVotes + _votes;\n\n    _receipt.hasVoted = true;\n    _receipt.support = _support;\n    _receipt.votes = _votes;\n\n    _numberOfVotes = _votes;\n  }\n\n  /**\n   * @notice View function which returns if an account is whitelisted\n   * @param _account Account to check white list status of\n   * @return _isWhitelisted If the account is whitelisted\n   */\n  function isWhitelisted(address _account) public view override returns (bool _isWhitelisted) {\n    return (whitelistAccountExpirations[_account] > block.timestamp);\n  }\n\n  /**\n   * @notice Governance function for setting the governance token\n   * @param  _token The new token address\n   */\n  function setNewToken(address _token) external onlyGov {\n    amph = IAMPH(_token);\n  }\n\n  /**\n   * @notice Governance function for setting the max whitelist period\n   * @param  _second How many seconds to whitelist for\n   */\n  function setMaxWhitelistPeriod(uint256 _second) external onlyGov {\n    maxWhitelistPeriod = _second;\n  }\n\n  /**\n   * @notice Used to update the timelock period\n   * @param _proposalTimelockDelay The proposal holding period\n   */\n  function setDelay(uint256 _proposalTimelockDelay) public override onlyGov {\n    uint256 _oldTimelockDelay = proposalTimelockDelay;\n    proposalTimelockDelay = _proposalTimelockDelay;\n\n    emit NewDelay(_old"
    }
  ]
}