{
  "Title": "[01] User can possibly transfer no `token0` or `token1` to `TimeswapV2Option` contract if corresponding `token0` OR `token1` is a rebasing token",
  "Content": "\nWhen calling the following `TimeswapV2Option.mint` function, `msg.sender` uses the `ITimeswapV2OptionMintCallback.timeswapV2OptionMintCallback` function to transfer the relevant `token0` and/or `token1` to the `TimeswapV2Option` contract. Similarly, when calling the `TimeswapV2Option.swap` function below, `msg.sender` uses the `ITimeswapV2OptionSwapCallback.timeswapV2OptionSwapCallback` function to transfer the relevant `token0` or `token1` to the `TimeswapV2Option` contract. When `token0` or `token1` is a rebasing token, it is possible that the user uses these callback functions to trigger such token's rebasing event that increases its balance owned by the `TimeswapV2Option` contract.\n\nThen, when the `TimeswapV2Option.mint` and `TimeswapV2Option.swap` functions call `Error.checkEnough`, the rebasing token's balance owned by the `TimeswapV2Option` contract can possibly exceed the corresponding balance target. As a result, the user is able to mint or swap option positions without sending any of such rebasing token to the `TimeswapV2Option` contract.\n\nAs a mitigation, this protocol can behave like other protocols that do not support rebasing tokens and use a blocklist to block such tokens from being used as `token0` or `token1` for any options.\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L109-L154\n\n```solidity\n    function mint(\n        TimeswapV2OptionMintParam calldata param\n    ) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, uint256 shortAmount, bytes memory data) {\n        ...\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main mint logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount, shortAmount) = option.mint(param.strike, param.long0To, param.long1To, param.shortTo, param.transaction, param.amount0, param.amount1);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, true, true);\n\n        // add a new process\n        // stores the token0 and token1 balance target required from the msg.sender to achieve.\n        Process storage currentProcess = (processing.push() = Process(\n            param.strike,\n            param.maturity,\n            IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n            IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount\n        ));\n\n        // ask the msg.sender to transfer token0 and/or token1 to this contract.\n        data = ITimeswapV2OptionMintCallback(msg.sender).timeswapV2OptionMintCallback(\n            TimeswapV2OptionMintCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                token0AndLong0Amount: token0AndLong0Amount,\n                token1AndLong1Amount: token1AndLong1Amount,\n                shortAmount: shortAmount,\n                data: param.data\n            })\n        );\n\n        // check if the token0 balance target is achieved.\n        if (token0AndLong0Amount != 0) Error.checkEnough(IERC20(token0).balanceOf(address(this)), currentProcess.balance0Target);\n\n        // check if the token1 balance target is achieved.\n        if (token1AndLong1Amount != 0) Error.checkEnough(IERC20(token1).balanceOf(address(this)), currentProcess.balance1Target);\n\n        ...\n    }\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/TimeswapV2Option.sol#L198-L244\n\n```solidity\n    function swap(TimeswapV2OptionSwapParam calldata param) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, bytes memory data) {\n        ...\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main swap logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount) = option.swap(param.strike, param.longTo, param.isLong0ToLong1, param.transaction, param.amount);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, !param.isLong0ToLong1, param.isLong0ToLong1);\n\n        // add a new process\n        // stores the token0 and token1 balance target required from the msg.sender to achieve.\n        Process storage currentProcess = (processing.push() = Process(\n            param.strike,\n            param.maturity,\n            param.isLong0ToLong1 ? IERC20(token0).balanceOf(address(this)) - token0AndLong0Amount : IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n            param.isLong0ToLong1 ? IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount : IERC20(token1).balanceOf(address(this)) - token1AndLong1Amount\n        ));\n\n        // transfer token to recipient.\n        IERC20(param.isLong0ToLong1 ? token0 : token1).safeTransfer(param.tokenTo, param.isLong0ToLong1 ? token0AndLong0Amount : token1AndLong1Amount);\n\n        // ask the msg.sender to transfer token0 or token1 to this contract.\n        data = ITimeswapV2OptionSwapCallback(msg.sender).timeswapV2OptionSwapCallback(\n            TimeswapV2OptionSwapCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                isLong0ToLong1: param.isLong0ToLong1,\n                token0AndLong0Amount: token0AndLong0Amount,\n                token1AndLong1Amount: token1AndLong1Amount,\n                data: param.data\n            })\n        );\n\n        // check if the token0 or token1 balance target is achieved.\n        Error.checkEnough(IERC20(param.isLong0ToLong1 ? token1 : token0).balanceOf(address(this)), param.isLong0ToLong1 ? currentProcess.balance1Target : currentProcess.balance0Target);\n\n        ...\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-option/src/TimeswapV2Option.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {Math} from \"@timeswap-labs/v2-library/src/Math.sol\";\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\n\nimport {ITimeswapV2Option} from \"./interfaces/ITimeswapV2Option.sol\";\nimport {ITimeswapV2OptionDeployer} from \"./interfaces/ITimeswapV2OptionDeployer.sol\";\nimport {ITimeswapV2OptionMintCallback} from \"./interfaces/callbacks/ITimeswapV2OptionMintCallback.sol\";\nimport {ITimeswapV2OptionBurnCallback} from \"./interfaces/callbacks/ITimeswapV2OptionBurnCallback.sol\";\nimport {ITimeswapV2OptionSwapCallback} from \"./interfaces/callbacks/ITimeswapV2OptionSwapCallback.sol\";\nimport {ITimeswapV2OptionCollectCallback} from \"./interfaces/callbacks/ITimeswapV2OptionCollectCallback.sol\";\n\nimport {Option, OptionLibrary} from \"./structs/Option.sol\";\nimport {Process, ProcessLibrary} from \"./structs/Process.sol\";\nimport {StrikeAndMaturity} from \"./structs/StrikeAndMaturity.sol\";\n\nimport {TimeswapV2OptionPosition, PositionLibrary} from \"./enums/Position.sol\";\nimport {TimeswapV2OptionMint, TimeswapV2OptionBurn, TimeswapV2OptionSwap, TimeswapV2OptionCollect, TransactionLibrary} from \"./enums/Transaction.sol\";\n\nimport {TimeswapV2OptionMintParam, TimeswapV2OptionBurnParam, TimeswapV2OptionSwapParam, TimeswapV2OptionCollectParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2OptionMintCallbackParam, TimeswapV2OptionBurnCallbackParam, TimeswapV2OptionSwapCallbackParam, TimeswapV2OptionCollectCallbackParam} from \"./structs/CallbackParam.sol\";\n\n/// @title Timeswap V2 Options for a given pair\n/// @author Timeswap Labs\n/// @notice Holds the option of all strikes and maturies.\ncontract TimeswapV2Option is ITimeswapV2Option, NoDelegateCall {\n    using OptionLibrary for Option;\n    using ProcessLibrary for Process[];\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override optionFactory;\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override token0;\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override token1;\n\n    /// @dev mapping of all option state for all strikes and maturies.\n    mapping(uint256 => mapping(uint256 => Option)) private options;\n    /// @dev Always start and end as an empty array for every transaction.\n    /// Process the token requirement for every option interaction call.\n    Process[] private processing;\n\n    mapping(uint256 => mapping(uint256 => bool)) private hasInteracted;\n    StrikeAndMaturity[] private listOfOptions;\n\n    function addOptionEnumerationIfNecessary(uint256 strike, uint256 maturity) private {\n        if (!hasInteracted[strike][maturity]) {\n            hasInteracted[strike][maturity] = true;\n            listOfOptions.push(StrikeAndMaturity({strike: strike, maturity: maturity}));\n        }\n    }\n\n    /* ===== INIT ===== */\n\n    constructor() NoDelegateCall() {\n        (optionFactory, token0, token1) = ITimeswapV2OptionDeployer(msg.sender).parameter();\n    }\n\n    // Can be overidden for testing purposes.\n    function blockTimestamp() internal view virtual returns (uint96) {\n        return uint96(block.timestamp); // truncation is desired\n    }\n\n    /* ===== VIEW ===== */\n\n    function getByIndex(uint256 id) external view override returns (StrikeAndMaturity memory) {\n        return listOfOptions[id];\n    }\n\n    function numberOfOptions() external view override returns (uint256) {\n        return listOfOptions.length;\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function totalPosition(uint256 strike, uint256 maturity, TimeswapV2OptionPosition position) external view override returns (uint256) {\n        return options[strike][maturity].totalPosition(strike, position);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function positionOf(uint256 strike, uint256 maturity, address owner, TimeswapV2OptionPosition position) external view override returns (uint256) {\n        return options[strike][maturity].positionOf(owner, position);\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc ITimeswapV2Option\n    function transferPosition(uint256 strike, uint256 maturity, address to, TimeswapV2OptionPosition position, uint256 amount) external override {\n        if (!hasInteracted[strike][maturity]) Error.inactiveOptionChoice(strike, maturity);\n        if (to == address(0)) Error.zeroAddress();\n        if (amount == 0) Error.zeroInput();\n        PositionLibrary.check(position);\n\n        options[strike][maturity].transferPosition(to, position, amount);\n\n        emit TransferPosition(strike, maturity, msg.sender, to, position, amount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function mint(\n        TimeswapV2OptionMintParam calldata param\n    ) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, uint256 shortAmount, bytes memory data) {\n        ParamLibrary.check(param, blockTimestamp());\n        addOptionEnumerationIfNecessary(param.strike, param.maturity);\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main mint logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount, shortAmount) = option.mint(param.strike, param.long0To, param.long1To, param.shortTo, param.transaction, param.amount0, param.amount1);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, true, true);\n\n        // add a new process\n        // stores the token0 and token1 balance target required from the msg.sender to achieve.\n        Process storage currentProcess = (processing.push() = Process(\n            param.strike,\n            param.maturity,\n            IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n            IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount\n        ));\n\n        // ask the msg.sender to transfer token0 and/or token1 to this contract.\n        data = ITimeswapV2OptionMintCallback(msg.sender).timeswapV2OptionMintCallback(\n            TimeswapV2OptionMintCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                token0AndLong0Amount: token0AndLong0Amount,\n                token1AndLong1Amount: token1AndLong1Amount,\n                shortAmount: shortAmount,\n                data: param.data\n            })\n        );\n\n        // check if the token0 balance target is achieved.\n        if (token0AndLong0Amount != 0) Error.checkEnough(IERC20(token0).balanceOf(address(this)), currentProcess.balance0Target);\n\n        // check if the token1 balance target is achieved.\n        if (token1AndLong1Amount != 0) Error.checkEnough(IERC20(token1).balanceOf(address(this)), currentProcess.balance1Target);\n\n        // finish the process.\n        processing.pop();\n\n        emit Mint(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, token0AndLong0Amount, token1AndLong1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function burn(\n        TimeswapV2OptionBurnParam calldata param\n    ) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, uint256 shortAmount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main burn logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount, shortAmount) = option.burn(param.strike, param.transaction, param.amount0, param.amount1);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, false, false);\n\n        // transfer token0 amount to recipient.\n        if (token0AndLong0Amount != 0) IERC20(token0).safeTransfer(param.token0To, token0AndLong0Amount);\n\n        // transfer token1 amount to recipient.\n        if (token1AndLong1Amount != 0) IERC20(token1).safeTransfer(param.token1To, token1AndLong1Amount);\n\n        // skip callback if there is no data.\n        if (param.data.length != 0)\n            data = ITimeswapV2OptionBurnCallback(msg.sender).timeswapV2OptionBurnCallback(\n                TimeswapV2OptionBurnCallbackParam({\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    token0AndLong0Amount: token0AndLong0Amount,\n                    token1AndLong1Amount: token1AndLong1Amount,\n                    shortAmount: shortAmount,\n                    data: param.data\n                })\n            );\n\n        option.long0[msg.sender] -= token0AndLong0Amount;\n        option.long1[msg.sender] -= token1AndLong1Amount;\n        option.short[msg.sender] -= shortAmount;\n\n        emit Burn(param.strike, param.maturity, msg.sender, param.token0To, param.token1To, token0AndLong0Amount, token1AndLong1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function swap(TimeswapV2OptionSwapParam calldata param) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main swap logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount) = option.swap(param.strike, param.longTo, param.isLong0ToLong1, param.transaction, param.amount);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, !param.isLong0ToLong1, param.isLong0ToLong1);\n\n        // add a new process\n        // stores the token0 and token1 balance target required from the msg.sender to achieve.\n        Process storage currentProcess = (processing.push() = Process(\n            param.strike,\n            param.maturity,\n            param.isLong0ToLong1 ? IERC20(token0).balanceOf(address(this)) - token0AndLong0Amount : IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n            param.isLong0ToLong1 ? IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount : IERC20(token1).balanceOf(address(this)) - token1AndLong1Amount\n        ));\n\n        // transfer token to recipient.\n        IERC20(param.isLong0ToLong1 ? token0 : token1).safeTransfer(param.tokenTo, param.isLong0ToLong1 ? token0AndLong0Amount : token1AndLong1Amount);\n\n        // ask the msg.sender to transfer token0 or token1 to this contract.\n        data = ITimeswapV2OptionSwapCallback(msg.sender).timeswapV2OptionSwapCallback(\n            TimeswapV2OptionSwapCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                isLong0ToLong1: param.isLong0ToLong1,\n                token0AndLong0Amount: token0AndLong0Amount,\n                token1AndLong1Amount: token1AndLong1Amount,\n                data: param.data\n            })\n        );\n\n        // check if the token0 or token1 balance target is achieved.\n        Error.checkEnough(IERC20(param.isLong0ToLong1 ? token1 : token0).balanceOf(address(this)), param.isLong0ToLong1 ? currentProcess.balance1Target : currentProcess.balance0Target);\n\n        if (param.isLong0ToLong1) option.long0[msg.sender] -= token0AndLong0Amount;\n        else option.long1[msg.sender] -= token1AndLong1Amount;\n\n        // finish the process.\n        processing.pop();\n\n        emit Swap(param.strike, param.maturity, msg.sender, param.tokenTo, param.longTo, param.isLong0ToLong1, token0AndLong0Amount, token1AndLong1Amount);\n    }\n\n    function collect(TimeswapV2OptionCollectParam calldata param) external override noDelegateCall returns (uint256 token0Amount, uint256 token1Amount, uint256 shortAmount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main collect logic calculation\n        (token0Amount, token1Amount, shortAmount) = option.collect(param.strike, param.transaction, param.amount);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0Amount, token1Amount, false, false);\n\n        // transfer token0 amount to recipient.\n        if (token0Amount != 0) IERC20(token0).safeTransfer(param.token0To, token0Amount);\n\n        // transfer token1 amount to recipient.\n        if (token1Amount != 0) IERC20(token1).safeTransfer(param.token1To, token1Amount);\n\n        // skip callback if there is no data.\n        if (param.data.length != 0)\n            data = ITimeswapV2OptionCollectCallback(msg.sender).timeswapV2OptionCollectCallback(\n                TimeswapV2OptionCollectCallbackParam({\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    token0Amount: token0Amount,\n                    token1Amount: token1Amount,\n                    shortAmount: shortAmount,\n                    data: param.data\n                })\n            );\n\n        option.short[msg.sender] -= shortAmount;\n\n        emit Collect(param.strike, param.maturity, msg.sender, param.token0To, param.token1To, token0Amount, token1Amount, shortAmount);\n    }\n}"
    },
    {
      "filename": "packages/v2-option/src/TimeswapV2Option.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {Math} from \"@timeswap-labs/v2-library/src/Math.sol\";\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\n\nimport {ITimeswapV2Option} from \"./interfaces/ITimeswapV2Option.sol\";\nimport {ITimeswapV2OptionDeployer} from \"./interfaces/ITimeswapV2OptionDeployer.sol\";\nimport {ITimeswapV2OptionMintCallback} from \"./interfaces/callbacks/ITimeswapV2OptionMintCallback.sol\";\nimport {ITimeswapV2OptionBurnCallback} from \"./interfaces/callbacks/ITimeswapV2OptionBurnCallback.sol\";\nimport {ITimeswapV2OptionSwapCallback} from \"./interfaces/callbacks/ITimeswapV2OptionSwapCallback.sol\";\nimport {ITimeswapV2OptionCollectCallback} from \"./interfaces/callbacks/ITimeswapV2OptionCollectCallback.sol\";\n\nimport {Option, OptionLibrary} from \"./structs/Option.sol\";\nimport {Process, ProcessLibrary} from \"./structs/Process.sol\";\nimport {StrikeAndMaturity} from \"./structs/StrikeAndMaturity.sol\";\n\nimport {TimeswapV2OptionPosition, PositionLibrary} from \"./enums/Position.sol\";\nimport {TimeswapV2OptionMint, TimeswapV2OptionBurn, TimeswapV2OptionSwap, TimeswapV2OptionCollect, TransactionLibrary} from \"./enums/Transaction.sol\";\n\nimport {TimeswapV2OptionMintParam, TimeswapV2OptionBurnParam, TimeswapV2OptionSwapParam, TimeswapV2OptionCollectParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2OptionMintCallbackParam, TimeswapV2OptionBurnCallbackParam, TimeswapV2OptionSwapCallbackParam, TimeswapV2OptionCollectCallbackParam} from \"./structs/CallbackParam.sol\";\n\n/// @title Timeswap V2 Options for a given pair\n/// @author Timeswap Labs\n/// @notice Holds the option of all strikes and maturies.\ncontract TimeswapV2Option is ITimeswapV2Option, NoDelegateCall {\n    using OptionLibrary for Option;\n    using ProcessLibrary for Process[];\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override optionFactory;\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override token0;\n    /// @inheritdoc ITimeswapV2Option\n    address public immutable override token1;\n\n    /// @dev mapping of all option state for all strikes and maturies.\n    mapping(uint256 => mapping(uint256 => Option)) private options;\n    /// @dev Always start and end as an empty array for every transaction.\n    /// Process the token requirement for every option interaction call.\n    Process[] private processing;\n\n    mapping(uint256 => mapping(uint256 => bool)) private hasInteracted;\n    StrikeAndMaturity[] private listOfOptions;\n\n    function addOptionEnumerationIfNecessary(uint256 strike, uint256 maturity) private {\n        if (!hasInteracted[strike][maturity]) {\n            hasInteracted[strike][maturity] = true;\n            listOfOptions.push(StrikeAndMaturity({strike: strike, maturity: maturity}));\n        }\n    }\n\n    /* ===== INIT ===== */\n\n    constructor() NoDelegateCall() {\n        (optionFactory, token0, token1) = ITimeswapV2OptionDeployer(msg.sender).parameter();\n    }\n\n    // Can be overidden for testing purposes.\n    function blockTimestamp() internal view virtual returns (uint96) {\n        return uint96(block.timestamp); // truncation is desired\n    }\n\n    /* ===== VIEW ===== */\n\n    function getByIndex(uint256 id) external view override returns (StrikeAndMaturity memory) {\n        return listOfOptions[id];\n    }\n\n    function numberOfOptions() external view override returns (uint256) {\n        return listOfOptions.length;\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function totalPosition(uint256 strike, uint256 maturity, TimeswapV2OptionPosition position) external view override returns (uint256) {\n        return options[strike][maturity].totalPosition(strike, position);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function positionOf(uint256 strike, uint256 maturity, address owner, TimeswapV2OptionPosition position) external view override returns (uint256) {\n        return options[strike][maturity].positionOf(owner, position);\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc ITimeswapV2Option\n    function transferPosition(uint256 strike, uint256 maturity, address to, TimeswapV2OptionPosition position, uint256 amount) external override {\n        if (!hasInteracted[strike][maturity]) Error.inactiveOptionChoice(strike, maturity);\n        if (to == address(0)) Error.zeroAddress();\n        if (amount == 0) Error.zeroInput();\n        PositionLibrary.check(position);\n\n        options[strike][maturity].transferPosition(to, position, amount);\n\n        emit TransferPosition(strike, maturity, msg.sender, to, position, amount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function mint(\n        TimeswapV2OptionMintParam calldata param\n    ) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, uint256 shortAmount, bytes memory data) {\n        ParamLibrary.check(param, blockTimestamp());\n        addOptionEnumerationIfNecessary(param.strike, param.maturity);\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main mint logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount, shortAmount) = option.mint(param.strike, param.long0To, param.long1To, param.shortTo, param.transaction, param.amount0, param.amount1);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, true, true);\n\n        // add a new process\n        // stores the token0 and token1 balance target required from the msg.sender to achieve.\n        Process storage currentProcess = (processing.push() = Process(\n            param.strike,\n            param.maturity,\n            IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n            IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount\n        ));\n\n        // ask the msg.sender to transfer token0 and/or token1 to this contract.\n        data = ITimeswapV2OptionMintCallback(msg.sender).timeswapV2OptionMintCallback(\n            TimeswapV2OptionMintCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                token0AndLong0Amount: token0AndLong0Amount,\n                token1AndLong1Amount: token1AndLong1Amount,\n                shortAmount: shortAmount,\n                data: param.data\n            })\n        );\n\n        // check if the token0 balance target is achieved.\n        if (token0AndLong0Amount != 0) Error.checkEnough(IERC20(token0).balanceOf(address(this)), currentProcess.balance0Target);\n\n        // check if the token1 balance target is achieved.\n        if (token1AndLong1Amount != 0) Error.checkEnough(IERC20(token1).balanceOf(address(this)), currentProcess.balance1Target);\n\n        // finish the process.\n        processing.pop();\n\n        emit Mint(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, token0AndLong0Amount, token1AndLong1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function burn(\n        TimeswapV2OptionBurnParam calldata param\n    ) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, uint256 shortAmount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main burn logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount, shortAmount) = option.burn(param.strike, param.transaction, param.amount0, param.amount1);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, false, false);\n\n        // transfer token0 amount to recipient.\n        if (token0AndLong0Amount != 0) IERC20(token0).safeTransfer(param.token0To, token0AndLong0Amount);\n\n        // transfer token1 amount to recipient.\n        if (token1AndLong1Amount != 0) IERC20(token1).safeTransfer(param.token1To, token1AndLong1Amount);\n\n        // skip callback if there is no data.\n        if (param.data.length != 0)\n            data = ITimeswapV2OptionBurnCallback(msg.sender).timeswapV2OptionBurnCallback(\n                TimeswapV2OptionBurnCallbackParam({\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    token0AndLong0Amount: token0AndLong0Amount,\n                    token1AndLong1Amount: token1AndLong1Amount,\n                    shortAmount: shortAmount,\n                    data: param.data\n                })\n            );\n\n        option.long0[msg.sender] -= token0AndLong0Amount;\n        option.long1[msg.sender] -= token1AndLong1Amount;\n        option.short[msg.sender] -= shortAmount;\n\n        emit Burn(param.strike, param.maturity, msg.sender, param.token0To, param.token1To, token0AndLong0Amount, token1AndLong1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Option\n    function swap(TimeswapV2OptionSwapParam calldata param) external override noDelegateCall returns (uint256 token0AndLong0Amount, uint256 token1AndLong1Amount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main swap logic calculation\n        (token0AndLong0Amount, token1AndLong1Amount) = option.swap(param.strike, param.longTo, param.isLong0ToLong1, param.transaction, param.amount);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0AndLong0Amount, token1AndLong1Amount, !param.isLong0ToLong1, param.isLong0ToLong1);\n\n        // add a new process\n        // stores the token0 and token1 balance target required from the msg.sender to achieve.\n        Process storage currentProcess = (processing.push() = Process(\n            param.strike,\n            param.maturity,\n            param.isLong0ToLong1 ? IERC20(token0).balanceOf(address(this)) - token0AndLong0Amount : IERC20(token0).balanceOf(address(this)) + token0AndLong0Amount,\n            param.isLong0ToLong1 ? IERC20(token1).balanceOf(address(this)) + token1AndLong1Amount : IERC20(token1).balanceOf(address(this)) - token1AndLong1Amount\n        ));\n\n        // transfer token to recipient.\n        IERC20(param.isLong0ToLong1 ? token0 : token1).safeTransfer(param.tokenTo, param.isLong0ToLong1 ? token0AndLong0Amount : token1AndLong1Amount);\n\n        // ask the msg.sender to transfer token0 or token1 to this contract.\n        data = ITimeswapV2OptionSwapCallback(msg.sender).timeswapV2OptionSwapCallback(\n            TimeswapV2OptionSwapCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                isLong0ToLong1: param.isLong0ToLong1,\n                token0AndLong0Amount: token0AndLong0Amount,\n                token1AndLong1Amount: token1AndLong1Amount,\n                data: param.data\n            })\n        );\n\n        // check if the token0 or token1 balance target is achieved.\n        Error.checkEnough(IERC20(param.isLong0ToLong1 ? token1 : token0).balanceOf(address(this)), param.isLong0ToLong1 ? currentProcess.balance1Target : currentProcess.balance0Target);\n\n        if (param.isLong0ToLong1) option.long0[msg.sender] -= token0AndLong0Amount;\n        else option.long1[msg.sender] -= token1AndLong1Amount;\n\n        // finish the process.\n        processing.pop();\n\n        emit Swap(param.strike, param.maturity, msg.sender, param.tokenTo, param.longTo, param.isLong0ToLong1, token0AndLong0Amount, token1AndLong1Amount);\n    }\n\n    function collect(TimeswapV2OptionCollectParam calldata param) external override noDelegateCall returns (uint256 token0Amount, uint256 token1Amount, uint256 shortAmount, bytes memory data) {\n        if (!hasInteracted[param.strike][param.maturity]) Error.inactiveOptionChoice(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp());\n\n        Option storage option = options[param.strike][param.maturity];\n\n        // does main collect logic calculation\n        (token0Amount, token1Amount, shortAmount) = option.collect(param.strike, param.transaction, param.amount);\n\n        // update token0 and token1 balance target for any previous concurrent option transactions.\n        processing.updateProcess(token0Amount, token1Amount, false, false);\n\n        // transfer token0 amount to recipient.\n        if (token0Amount != 0) IERC20(token0).safeTransfer(param.token0To, token0Amount);\n\n        // transfer token1 amount to recipient.\n        if (token1Amount != 0) IERC20(token1).safeTransfer(param.token1To, token1Amount);\n\n        // skip callback if there is no data.\n        if (param.data.length != 0)\n            data = ITimeswapV2OptionCollectCallback(msg.sender).timeswapV2OptionCollectCallback(\n                TimeswapV2OptionCollectCallbackParam({\n                    strike: param.strike,\n                    maturity: param.maturity,\n                    token0Amount: token0Amount,\n                    token1Amount: token1Amount,\n                    shortAmount: shortAmount,\n                    data: param.data\n                })\n            );\n\n        option.short[msg.sender] -= shortAmount;\n\n        emit Collect(param.strike, param.maturity, msg.sender, param.token0To, param.token1To, token0Amount, token1Amount, shortAmount);\n    }\n}"
    }
  ]
}