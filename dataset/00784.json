{
  "Title": "H-3: CouncilMember:burn renders the contract inoperable after the first execution",
  "Content": "# Issue H-3: CouncilMember:burn renders the contract inoperable after the first execution \n\nSource: https://github.com/sherlock-audit/2024-01-telcoin-judging/issues/199 \n\n## Found by \n0xAsen, 0xLogos, 0xadrii, 0xlamide, 0xmystery, 0xpep7, Aamirusmani1552, Arz, BAICE, Bauer, DenTonylifer, HonorLt, Ignite, IvanFitro, Jaraxxus, Kow, Krace, VAD37, alexbabits, almurhasan, araj, bitsurfer, dipp, fibonacci, ggg\\_ttt\\_hhh, gqrp, grearlake, jah, m4ttm, mstpr-brainbot, popeye, psb01, r0ck3tz, ravikiran.web3, sakshamguruji, sobieski, sonny2k, tives, ubl4nk, vvv, ydlee, zhuying, zzykxx\n## Summary\nThe CouncilMember contract suffers from a critical vulnerability that misaligns the balances array after a successful burn, rendering the contract inoperable.\n\n## Vulnerability Detail\n\nThe root cause of the vulnerability is that the `burn` function incorrectly manages the `balances` array, shortening it by one each time an ERC721 token is burned while the latest minted NFT still withholds its unique `tokenId` which maps to the previous value of `balances.length`.\n```solidity\n// File: telcoin-audit/contracts/sablier/core/CouncilMember.sol\n210:    function burn(\n        ...\n220:        balances.pop(); // <= FOUND: balances.length decreases, while latest minted nft withold its unique tokenId\n221:        _burn(tokenId);\n222:    }\n```\n\nThis misalignment between existing `tokenIds` and the `balances` array results in several critical impacts:\n\n1. Holders with tokenId greater than the length of balances cannot claim.\n2. Subsequent burns of tokenId greater than balances length will revert.\n3. Subsequent mint operations will revert due to tokenId collision. As `totalSupply` now collides with the existing `tokenId`.\n```solidity\n// File: telcoin-audit/contracts/sablier/core/CouncilMember.sol\n173:    function mint(\n        ...\n179:\n180:        balances.push(0);\n181:        _mint(newMember, totalSupply());// <= FOUND\n182:    }\n```\n\nThis mismanagement creates a cascading effect, collectively rendering the contract inoperable. Following POC will demonstrate the issue more clearly in codes.\n\n### POC\n\nRun `git apply` on the following patch then run `npx hardhat test` to run the POC.\n```patch\ndiff --git a/telcoin-audit/test/sablier/CouncilMember.test.ts b/telcoin-audit/test/sablier/CouncilMember.test.ts\nindex 675b89d..ab96b08 100644\n--- a/telcoin-audit/test/sablier/CouncilMember.test.ts\n+++ b/telcoin-audit/test/sablier/CouncilMember.test.ts\n@@ -1,13 +1,14 @@\n import { expect } from \"chai\";\n import { ethers } from \"hardhat\";\n import { SignerWithAddress } from \"@nomicfoundation/hardhat-ethers/signers\";\n-import { CouncilMember, TestTelcoin, TestStream } from \"../../typechain-types\";\n+import { CouncilMember, TestTelcoin, TestStream, ERC721Upgradeable__factory } from \"../../typechain-types\";\n \n describe(\"CouncilMember\", () => {\n     let admin: SignerWithAddress;\n     let support: SignerWithAddress;\n     let member: SignerWithAddress;\n     let holder: SignerWithAddress;\n+    let lastCouncilMember: SignerWithAddress;\n     let councilMember: CouncilMember;\n     let telcoin: TestTelcoin;\n     let stream: TestStream;\n@@ -18,7 +19,7 @@ describe(\"CouncilMember\", () => {\n     let supportRole: string = ethers.keccak256(ethers.toUtf8Bytes(\"SUPPORT_ROLE\"));\n \n     beforeEach(async () => {\n-        [admin, support, member, holder, target] = await ethers.getSigners();\n+        [admin, support, member, holder, target, lastCouncilMember] = await ethers.getSigners();\n \n         const TestTelcoinFactory = await ethers.getContractFactory(\"TestTelcoin\", admin);\n         telcoin = await TestTelcoinFactory.deploy(admin.address);\n@@ -182,6 +183,22 @@ describe(\"CouncilMember\", () => {\n                 it(\"the correct removal is made\", async () => {\n                     await expect(councilMember.burn(1, support.address)).emit(councilMember, \"Transfer\");\n                 });\n+                it.only(\"inoperable contract after burn\", async () => {\n+                    await expect(councilMember.mint(lastCouncilMember.address)).to.not.reverted;\n+\n+                    // This 1st burn will cause contract inoperable due to tokenId & balances misalignment\n+                    await expect(councilMember.burn(1, support.address)).emit(councilMember, \"Transfer\");\n+\n+                    // Impact 1. holder with tokenId > balances length cannot claim\n+                    await expect(councilMember.connect(lastCouncilMember).claim(3, 1)).to.revertedWithPanic(\"0x32\"); // @audit-info 0x32: Array accessed at an out-of-bounds or negative index\n+\n+                    // Impact 2. subsequent burns of tokenId > balances length will revert\n+                    await expect(councilMember.burn(3, lastCouncilMember.address)).to.revertedWithPanic(\"0x32\"); \n+\n+                    // Impact 3. subsequent mint will revert due to tokenId collision\n+                    await expect(councilMember.mint(lastCouncilMember.address)).to.revertedWithCustomError(councilMember, \"ERC721InvalidSender\");\n+\n+                });\n             });\n         });\n \n\n```\n\n### Result \n>   CouncilMember\n>     mutative\n>       burn\n>         Success\n>           âœ” inoperable contract after burn (90ms)\n>   1 passing (888ms)\n\nThe Passing execution of the POC confirmed that operations such as `claim`, `burn` & `mint` were all reverted which make the contract inoperable.\n\n## Impact\nThe severity of the vulnerability is high due to the high likelihood of occurence and the critical impacts on the contract's operability and token holders' ability to interact with their assets. \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-01-telcoin/blob/main/telcoin-audit/contracts/sablier/core/CouncilMember.sol#L220\n\n## Tool used\nVsCode\n\n## Recommendation\nIt is recommended to avoid popping out balances to keep alignment with uniquely minted tokenId. Alternatively, consider migrating to ERC1155, which inherently manages a built-in balance for each NFT.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { this is a valid findings because the watson explain how again the burn function will break a functionality just like the previous issue thus making it a dupp of 109}\n\n\n\n**nevillehuang**\n\nSee comments [here](https://github.com/sherlock-audit/2024-01-telcoin-judging/issues/32) for duplication reasons.\n\n**amshirif**\n\nhttps://github.com/telcoin/telcoin-audit/pull/31\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/156",
  "Code": [
    {
      "filename": "telcoin-audit/contracts/sablier/core/CouncilMember.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/extensions/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"../interfaces/ISablierV2ProxyTarget.sol\";\nimport \"../interfaces/IPRBProxy.sol\";\n\n/**\n * @title CouncilMember\n * @author Amir M. Shirif\n * @notice A Telcoin Laboratories Contract\n * @notice A contract to signify ownership council membership\n * @dev Relies on OpenZeppelin's open source smart contracts\n */\ncontract CouncilMember is\n    ERC721EnumerableUpgradeable,\n    AccessControlEnumerableUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    /* ========== EVENTS ========== */\n    // Event fired when the stream is updated\n    event StreamUpdated(IPRBProxy newStream);\n    // Event fired when the target address is updated\n    event TargetUpdated(address newTarget);\n    // Event fired when the ID is updated\n    event IDUpdated(uint256 newID);\n\n    /* ========== STATE VARIABLES ========== */\n    // The main token of this ecosystem\n    IERC20 public TELCOIN;\n    // Stream proxy address for this contract\n    IPRBProxy public _stream;\n    // here is the implentation address\n    address public _target;\n    // the id associated with the sablier NFT\n    uint256 public _id;\n    // balance left over from last rebalancing\n    uint256 private runningBalance;\n    // current uncliamed members balances\n    uint256[] public balances;\n    // Mapping of who can send each NFT index\n    mapping(uint256 => address) private _tokenApproval;\n\n    /* ========== ROLES ========== */\n    // Role assigned for the governance council\n    bytes32 public constant GOVERNANCE_COUNCIL_ROLE =\n        keccak256(\"GOVERNANCE_COUNCIL_ROLE\");\n    // Support role for additional functionality\n    bytes32 public constant SUPPORT_ROLE = keccak256(\"SUPPORT_ROLE\");\n\n    /* ========== INITIALIZER ========== */\n    function initialize(\n        IERC20 telcoin,\n        string memory name_,\n        string memory symbol_,\n        IPRBProxy stream_,\n        address target_,\n        uint256 id_\n    ) external initializer {\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        __ERC721_init(name_, symbol_);\n        TELCOIN = telcoin;\n        _stream = stream_;\n        _target = target_;\n        _id = id_;\n    }\n\n    /************************************************\n     *   external functions\n     ************************************************/\n\n    /**\n     * @notice Allows authorized personnel to retrieve and distribute TELCOIN to council members\n     * @dev The main logic behind the TELCOIN distribution is encapsulated in this function.\n     * @dev This function should be called before any significant state changes to ensure accurate distribution.\n     * @dev Only the owner council members can call this function\n     */\n    function retrieve() external OnlyAuthorized {\n        _retrieve();\n    }\n\n    /**\n     * @notice Allows council members to claim their allocated amounts of TELCOIN\n     * @dev Checks if the caller is the owner of the provided tokenId and if the requested amount is available.\n     * @param tokenId The NFT index associated with a council member.\n     * @param amount Amount of TELCOIN the council member wants to withdraw.\n     */\n    function claim(uint256 tokenId, uint256 amount) external {\n        // Ensure the function caller is the owner of the token (council member) they're trying to claim for\n        require(\n            _msgSender() == ownerOf(tokenId),\n            \"CouncilMember: caller is not council member holding this NFT index\"\n        );\n        // Retrieve and distribute any pending TELCOIN for all council members\n        _retrieve();\n\n        // Ensure the requested amount doesn't exceed the balance of the council member\n        require(\n            amount <= balances[tokenId],\n            \"CouncilMember: withdrawal amount is higher than balance\"\n        );\n\n        // Deduct the claimed amount from the token's balance\n        balances[tokenId] -= amount;\n        // Safely transfer the claimed amount of TELCOIN to the function caller\n        TELCOIN.safeTransfer(_msgSender(), amount);\n    }\n\n    /**\n     * @notice Replace an existing council member with a new one and withdraws the old member's TELCOIN allocation\n     * @dev This function is restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @dev Allows TEL reward to be sent to a different address\n     * @param from Address of the current council member to be replaced.\n     * @param to Address of the new council member.\n     * @param tokenId Token ID of the council member NFT.\n     * @param rewardRecipient Address where the old member's TELCOIN will be sent.\n     */\n    function removeFromOffice(\n        address from,\n        address to,\n        uint256 tokenId,\n        address rewardRecipient\n    ) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n        // Retrieve and distribute any pending TELCOIN for all council members\n        _retrieve();\n        // Withdraw all the TELCOIN rewards for the specified token to the rewardRecipient\n        _withdrawAll(rewardRecipient, tokenId);\n        // Transfer the token (representing the council membership) from one address to another\n        _transfer(from, to, tokenId);\n    }\n\n    /************************************************\n     *   view functions\n     ************************************************/\n\n    /**\n     * @notice Check if the contract supports a specific interface\n     * @dev Overrides the supportsInterface function from OpenZeppelin.\n     * @param interfaceId ID of the interface to check for support.\n     * @return True if the contract supports the interface, false otherwise.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        pure\n        override(\n            AccessControlEnumerableUpgradeable,\n            ERC721EnumerableUpgradeable\n        )\n        returns (bool)\n    {\n        return\n            interfaceId ==\n            type(AccessControlEnumerableUpgradeable).interfaceId ||\n            interfaceId == type(ERC721EnumerableUpgradeable).interfaceId;\n    }\n\n    /************************************************\n     *   mutative functions\n     ************************************************/\n\n    /**\n     * @notice Mint new council member NFTs\n     * @dev This function also retrieves and distributes TELCOIN.\n     * @dev Restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @param newMember Address of the new council member.\n     */\n    function mint(\n        address newMember\n    ) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n        if (totalSupply() != 0) {\n            _retrieve();\n        }\n\n        balances.push(0);\n        _mint(newMember, totalSupply());\n    }\n\n    /**\n     * @notice Approve a specific address for a specific NFT\n     * @dev Overrides the approve function from ERC721.\n     * @dev Restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @param to Address to be approved.\n     * @param tokenId Token ID of the NFT to be approved.\n     */\n    function approve(\n        address to,\n        uint256 tokenId\n    )\n        public\n        override(ERC721Upgradeable, IERC721)\n        onlyRole(GOVERNANCE_COUNCIL_ROLE)\n    {\n        _tokenApproval[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @notice Burn a council member NFT\n     * @dev The function retrieves and distributes TELCOIN before burning the NFT.\n     * @dev Restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @param tokenId Token ID of the council member NFT to be burned.\n     * @param recipient Address to receive the burned NFT holder's TELCOIN allocation.\n     */\n    function burn(\n        uint256 tokenId,\n        address recipient\n    ) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n        require(totalSupply() > 1, \"CouncilMember: must maintain council\");\n        _retrieve();\n        _withdrawAll(recipient, tokenId);\n\n        uint256 balance = balances[balances.length - 1];\n        balances[tokenId] = balance;\n        balances.pop();\n        _burn(tokenId);\n    }\n\n    /**\n     * @notice Update the stream proxy address\n     * @dev Restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @param stream_ New stream proxy address.\n     */\n    function updateStream(\n        IPRBProxy stream_\n    ) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n        _stream = stream_;\n        emit StreamUpdated(_stream);\n    }\n\n    /**\n     * @notice Update the target address\n     * @dev Restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @param target_ New target address.\n     */\n    function updateTarget(\n        address target_\n    ) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n        _target = target_;\n        emit TargetUpdated(_target);\n    }\n\n    /**\n     * @notice Update the ID for a council member\n     * @dev Restricted to the GOVERNANCE_COUNCIL_ROLE.\n     * @param id_ New ID for the council member.\n     */\n    function updateID(uint256 id_) external onlyRole(GOVERNANCE_COUNCIL_ROLE) {\n        _id = id_;\n        emit IDUpdated(_id);\n    }\n\n    /************************************************\n     *   internal functions\n     ************************************************/\n\n    /**\n     * @notice Retrieve and distribute TELCOIN to council members based on the stream from _target\n     * @dev This function fetches the maximum possible TELCOIN and distributes it equally among all council members.\n     * @dev It also updates the running balance to ensure accurate distribution during subsequent calls.\n     */\n    function _retrieve() internal {\n        // Get the initial TELCOIN balance of the contract\n        uint256 initialBalance = TELCOIN.balanceOf(address(this));\n        // Execute the withdrawal from the _target, which might be a Sablier stream or another protocol\n        _stream.execute(\n            _target,\n            abi.encodeWithSelector(\n                ISablierV2ProxyTarget.withdrawMax.selector,\n                _target,\n                _id,\n                address(this)\n            )\n        );\n\n        // Get the new balance after the withdrawal\n        uint256 currentBalance = TELCOIN.balanceOf(address(this));\n        // Calculate the amount of TELCOIN that was withdrawn during this operation\n        uint256 finalBalance = (currentBalance - initialBalance) +\n            runningBalance;\n        // Distribute the TELCOIN equally among all council members\n        uint256 individualBalance = finalBalance / totalSupply();\n        // Update the running balance which keeps track of any TELCOIN that can't be evenly distributed\n        runningBalance = finalBalance % totalSupply();\n\n        // Add the individual balance to each council member's balance\n        for (uint i = 0; i < balances.length; i++) {\n            balances[i] += individualBalance;\n        }\n    }\n\n    /**\n     * @notice Determines if an address is approved or is the owner for a specific token ID\n     * @dev This function checks if the spender has GOVERNANCE_COUNCIL_ROLE or is the approved address for the token.\n     * @param spender Address to check approval or ownership for.\n     * @param tokenId Token ID to check against.\n     * @return True if the address is approved or is the owner, false otherwise.\n     */\n    function _isAuthorized(\n        address,\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        return (hasRole(GOVERNANCE_COUNCIL_ROLE, spender) ||\n            _tokenApproval[tokenId] == spender);\n    }\n\n    /**\n     * @notice Handle operations to be performed before transferring a token\n     * @dev This function retrieves and distributes TELCOIN before the token transfer.\n     * @dev It is an override of the _beforeTokenTransfer from OpenZeppelin's ERC721.\n     * @param to Address from which the token is being transferred.\n     * @param tokenId Token ID that's being transferred.\n     * @param auth Token ID that's being transferred.\n     */\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    ) internal override returns (address) {\n        if (totalSupply() != 0) {\n            _retrieve();\n        }\n\n        return super._update(to, tokenId, auth);\n    }\n\n    /**\n     * @notice Withdraws all allocated TELCOIN for a council member\n     * @dev This function safely transfers the TELCOIN to the given address and resets their balance.\n     * @param from Address to which the TELCOIN will be sent.\n     * @param tokenId Token ID of the council member to withdraw the TELCOIN for.\n     */\n    function _withdrawAll(address from, uint256 tokenId) internal {\n        TELCOIN.safeTransfer(from, balances[tokenId]);\n        balances[tokenId] = 0;\n    }\n\n    /************************************************\n     *   helper functions\n     ************************************************/\n\n    /**\n     * @notice Rescues any ERC20 token sent accidentally to the contract\n     * @dev Only addresses with the SUPPORT_ROLE can call this function.\n     * @param token ERC20 token address which needs to be rescued.\n     * @param destination Address where the tokens will be sent.\n     * @param amount Amount of tokens to be transferred.\n     */\n    function erc20Rescue(\n        IERC20 token,\n        address destination,\n        uint256 amount\n    ) external onlyRole(SUPPORT_ROLE) {\n        token.safeTransfer(destination, amount);\n    }\n\n    /************************************************\n     *   modifiers\n     ************************************************/\n\n    /**\n     * @notice Checks if the caller is authorized either by being a council member or having the GOVERNANCE_COUNCIL_ROLE\n     * @dev This modifier is used to restrict certain operations to council members or governance personnel.\n     */\n    modifier OnlyAuthorized() {\n        require(\n            hasRole(GOVERNANCE_COUNCIL_ROLE, _msgSender()) ||\n                ERC721Upgradeable.balanceOf(_msgSender()) >= 1,\n            \"CouncilMember: caller is not council member or owner\"\n        );\n        _;\n    }\n}"
    }
  ]
}