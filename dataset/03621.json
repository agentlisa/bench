{
  "Title": "Non-consistent number formatting",
  "Content": "##### Description\nIn `verifyAsm` for 256 and 128 bit versions keccak argument is written in decimal format:\nhttps://github.com/1inch/cumulative-merkle-drop/blob/96fb63d0cbfea73603e7500961c71e8ab1fb8c10/contracts/CumulativeMerkleDrop.sol#L78\nhttps://github.com/1inch/cumulative-merkle-drop/blob/96fb63d0cbfea73603e7500961c71e8ab1fb8c10/contracts/CumulativeMerkleDrop128.sol#L92\nbut in 160 bit - in hex format\nhttps://github.com/1inch/cumulative-merkle-drop/blob/96fb63d0cbfea73603e7500961c71e8ab1fb8c10/contracts/CumulativeMerkleDrop160.sol#L92\nThis fact may confuse readers of this code.\n##### Recommendation\nWe recommend to use single format.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/CumulativeMerkleDrop.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"./interfaces/ICumulativeMerkleDrop.sol\";\n\n\ncontract CumulativeMerkleDrop is Ownable, ICumulativeMerkleDrop {\n    using SafeERC20 for IERC20;\n    using MerkleProof for bytes32[];\n\n    address public immutable override token;\n\n    bytes32 public override merkleRoot;\n    mapping(address => uint256) public cumulativeClaimed;\n\n    constructor(address token_) {\n        token = token_;\n    }\n\n    function setMerkleRoot(bytes32 merkleRoot_) external override onlyOwner {\n        emit MerkelRootUpdated(merkleRoot, merkleRoot_);\n        merkleRoot = merkleRoot_;\n    }\n\n    function claim(\n        address account,\n        uint256 cumulativeAmount,\n        bytes32 expectedMerkleRoot,\n        bytes32[] calldata merkleProof\n    ) external override {\n        require(merkleRoot == expectedMerkleRoot, \"CMD: Merkle root was updated\");\n\n        // Verify the merkle proof\n        bytes32 leaf = keccak256(abi.encodePacked(account, cumulativeAmount));\n        require(verifyAsm(merkleProof, expectedMerkleRoot, leaf), \"CMD: Invalid proof\");\n\n        // Mark it claimed\n        uint256 preclaimed = cumulativeClaimed[account];\n        require(preclaimed < cumulativeAmount, \"CMD: Nothing to claim\");\n        cumulativeClaimed[account] = cumulativeAmount;\n\n        // Send the token\n        uint256 amount = cumulativeAmount - preclaimed;\n        IERC20(token).safeTransfer(account, amount);\n        emit Claimed(account, amount);\n    }\n\n    // function verify(bytes32[] calldata merkleProof, bytes32 root, bytes32 leaf) public pure returns (bool) {\n    //     return merkleProof.verify(root, leaf);\n    // }\n\n    // Experimental assembly optimization\n    function verifyAsm(bytes32[] calldata proof, bytes32 root, bytes32 leaf) public pure returns (bool valid) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let mem1 := mload(0x40)\n            let mem2 := add(mem1, 0x20)\n            let ptr := proof.offset\n\n            for { let end := add(ptr, mul(0x20, proof.length)) } lt(ptr, end) { ptr := add(ptr, 0x20) } {\n                let node := calldataload(ptr)\n\n                switch lt(leaf, node)\n                case 1 {\n                    mstore(mem1, leaf)\n                    mstore(mem2, node)\n                }\n                default {\n                    mstore(mem1, node)\n                    mstore(mem2, leaf)\n                }\n\n                leaf := keccak256(mem1, 64)\n            }\n\n            valid := eq(root, leaf)\n        }\n    }\n}"
    },
    {
      "filename": "contracts/CumulativeMerkleDrop128.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"./interfaces/ICumulativeMerkleDrop128.sol\";\n\n\ncontract CumulativeMerkleDrop128 is Ownable, ICumulativeMerkleDrop128 {\n    using SafeERC20 for IERC20;\n\n    address public immutable override token;\n\n    bytes16 public override merkleRoot;\n    mapping(address => uint256) public cumulativeClaimed;\n\n    constructor(address token_) {\n        token = token_;\n    }\n\n    function setMerkleRoot(bytes16 merkleRoot_) external override onlyOwner {\n        emit MerkelRootUpdated(merkleRoot, merkleRoot_);\n        merkleRoot = merkleRoot_;\n    }\n\n    function claim(\n        address account,\n        uint256 cumulativeAmount,\n        bytes16 expectedMerkleRoot,\n        bytes calldata merkleProof\n    ) external override {\n        require(merkleRoot == expectedMerkleRoot, \"CMD: Merkle root was updated\");\n\n        // Verify the merkle proof\n        bytes16 leaf = _keccak128(abi.encodePacked(account, cumulativeAmount));\n        require(verifyAsm(merkleProof, expectedMerkleRoot, leaf), \"CMD: Invalid proof\");\n\n        // Mark it claimed\n        uint256 preclaimed = cumulativeClaimed[account];\n        require(preclaimed < cumulativeAmount, \"CMD: Nothing to claim\");\n        cumulativeClaimed[account] = cumulativeAmount;\n\n        // Send the token\n        uint256 amount = cumulativeAmount - preclaimed;\n        IERC20(token).safeTransfer(account, amount);\n        emit Claimed(account, amount);\n    }\n\n    // function verify(bytes calldata proof, bytes16 root, bytes16 leaf) public pure returns (bool) {\n    //     for (uint256 i = 0; i < proof.length / 16; i++) {\n    //         bytes16 node = _getBytes16(proof[i*16:(i+1)*16]);\n    //         if (leaf < node) {\n    //             leaf = _keccak128(abi.encodePacked(leaf, node));\n    //         } else {\n    //             leaf = _keccak128(abi.encodePacked(node, leaf));\n    //         }\n    //     }\n    //     return leaf == root;\n    // }\n    //\n    // function _getBytes16(bytes calldata input) internal pure returns(bytes16 res) {\n    //     // solhint-disable-next-line no-inline-assembly\n    //     assembly {\n    //         res := calldataload(input.offset)\n    //     }\n    // }\n\n    // Experimental assembly optimization\n    function verifyAsm(bytes calldata proof, bytes16 root, bytes16 leaf) public pure returns (bool valid) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let mem1 := mload(0x40)\n            let mem2 := add(mem1, 0x10)\n            let ptr := proof.offset\n\n            for { let end := add(ptr, proof.length) } lt(ptr, end) { ptr := add(ptr, 0x10) } {\n                let node := calldataload(ptr)\n\n                switch lt(leaf, node)\n                case 1 {\n                    mstore(mem1, leaf)\n                    mstore(mem2, node)\n                }\n                default {\n                    mstore(mem1, node)\n                    mstore(mem2, leaf)\n                }\n\n                leaf := keccak256(mem1, 32)\n            }\n\n            valid := iszero(shr(128, xor(root, leaf)))\n        }\n    }\n\n    function _keccak128(bytes memory input) internal pure returns(bytes16) {\n        return bytes16(keccak256(input));\n    }\n}"
    },
    {
      "filename": "contracts/CumulativeMerkleDrop160.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"./interfaces/ICumulativeMerkleDrop160.sol\";\n\n\ncontract CumulativeMerkleDrop160 is Ownable, ICumulativeMerkleDrop160 {\n    using SafeERC20 for IERC20;\n\n    address public immutable override token;\n\n    bytes20 public override merkleRoot;\n    mapping(address => uint256) public cumulativeClaimed;\n\n    constructor(address token_) {\n        token = token_;\n    }\n\n    function setMerkleRoot(bytes20 merkleRoot_) external override onlyOwner {\n        emit MerkelRootUpdated(merkleRoot, merkleRoot_);\n        merkleRoot = merkleRoot_;\n    }\n\n    function claim(\n        address account,\n        uint256 cumulativeAmount,\n        bytes20 expectedMerkleRoot,\n        bytes calldata merkleProof\n    ) external override {\n        require(merkleRoot == expectedMerkleRoot, \"CMD: Merkle root was updated\");\n\n        // Verify the merkle proof\n        bytes20 leaf = _keccak160(abi.encodePacked(account, cumulativeAmount));\n        require(verifyAsm(merkleProof, expectedMerkleRoot, leaf), \"CMD: Invalid proof\");\n\n        // Mark it claimed\n        uint256 preclaimed = cumulativeClaimed[account];\n        require(preclaimed < cumulativeAmount, \"CMD: Nothing to claim\");\n        cumulativeClaimed[account] = cumulativeAmount;\n\n        // Send the token\n        uint256 amount = cumulativeAmount - preclaimed;\n        IERC20(token).safeTransfer(account, amount);\n        emit Claimed(account, amount);\n    }\n\n    // function verify(bytes calldata proof, bytes20 root, bytes20 leaf) public pure returns (bool) {\n    //     for (uint256 i = 0; i < proof.length / 20; i++) {\n    //         bytes20 node = _getBytes20(proof[i*20:(i+1)*20]);\n    //         if (leaf < node) {\n    //             leaf = _keccak160(abi.encodePacked(leaf, node));\n    //         } else {\n    //             leaf = _keccak160(abi.encodePacked(node, leaf));\n    //         }\n    //     }\n    //     return leaf == root;\n    // }\n    //\n    // function _getBytes20(bytes calldata input) internal pure returns(bytes20 res) {\n    //     // solhint-disable-next-line no-inline-assembly\n    //     assembly {\n    //         res := calldataload(input.offset)\n    //     }\n    // }\n\n    // Experimental assembly optimization\n    function verifyAsm(bytes calldata proof, bytes20 root, bytes20 leaf) public pure returns (bool valid) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let mem1 := mload(0x40)\n            let mem2 := add(mem1, 0x14)\n            let ptr := proof.offset\n\n            for { let end := add(ptr, proof.length) } lt(ptr, end) { ptr := add(ptr, 0x14) } {\n                let node := calldataload(ptr)\n\n                switch lt(leaf, node)\n                case 1 {\n                    mstore(mem1, leaf)\n                    mstore(mem2, node)\n                }\n                default {\n                    mstore(mem1, node)\n                    mstore(mem2, leaf)\n                }\n\n                leaf := keccak256(mem1, 0x28)\n            }\n\n            valid := iszero(shr(96, xor(root, leaf)))\n        }\n    }\n\n    function _keccak160(bytes memory input) internal pure returns(bytes20) {\n        return bytes20(keccak256(input));\n    }\n}"
    }
  ]
}