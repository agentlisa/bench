{
  "Title": "[G-16] Upgrade Solidity compiler version",
  "Content": "\n0.8.10 removes contract existence checks if the external call has a return value - `700` gas\n\n### Proof of Concept\n\nInstances:\n\n#### ERC20Gauges.sol\n\n[pragma solidity ^0.8.4](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Creator/ZcToken.sol#L2)\n\n### Recommended Mitigation Steps\n\nUpgrade `ZcToken.sol` compiler version.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-07-swivel-v3-contest",
  "Code": [
    {
      "filename": "Creator/ZcToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Erc20.sol\";\nimport \"./Compounding.sol\";\nimport \"./IERC5095.sol\";  \nimport \"./IRedeemer.sol\";\n\n// Utilizing an external custody contract to allow for backwards compatability with some projects.\n// Assumes interest generated post maturity using an internal Compounding library.\ncontract ZcToken is Erc20, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public override immutable maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public override immutable underlying;\n    /// @dev uint8 associated with a given protocol in Swivel\n    uint8 public immutable protocol;\n    \n    /////////////OPTIONAL///////////////// (Allows the calculation and distribution of yield post maturity)\n    /// @dev address of a cToken\n    address public immutable cToken;\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    IRedeemer public immutable redeemer;\n\n    error Maturity(uint256 timestamp);  \n\n    error Approvals(uint256 approved, uint256 amount);\n\n    error Authorized(address owner);\n\n    constructor(uint8 _protocol, address _underlying, uint256 _maturity, address _cToken, address _redeemer, string memory _name, string memory _symbol, uint8 _decimals) \n    Erc20( _name, _symbol, _decimals) {\n        protocol = _protocol;\n        underlying = _underlying;\n        maturity = _maturity;\n        cToken = _cToken;\n        redeemer = IRedeemer(_redeemer);\n    }\n\n    /// @notice Post maturity converts an amount of principal tokens to an amount of underlying that would be returned. Returns 0 pre-maturity.\n    /// @param principalAmount The amount of principal tokens to convert\n    /// @return underlyingAmount The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount * IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);\n    }\n    /// @notice Post maturity converts a desired amount of underlying tokens returned to principal tokens needed. Returns 0 pre-maturity.\n    /// @param underlyingAmount The amount of underlying tokens to convert\n    /// @return principalAmount The amount of principal tokens returned by the conversion\n    function convertToPrincipal(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount * IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate / IRedeemer(redeemer).getExchangeRate(protocol, cToken));\n    }\n    /// @notice Post maturity calculates the amount of principal tokens that `owner` can redeem. Returns 0 pre-maturity.\n    /// @param owner The address of the owner for which redemption is calculated\n    /// @return maxPrincipalAmount The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address owner) external override view returns (uint256 maxPrincipalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (balanceOf[owner]);\n    }\n    /// @notice Post maturity simulates the effects of redeemption at the current block. Returns 0 pre-maturity.\n    /// @param principalAmount the amount of principal tokens redeemed in the simulation\n    /// @return underlyingAmount The maximum amount of underlying returned by `principalAmount` of PT redemption\n    function previewRedeem(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount * IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);\n    }\n    /// @notice Post maturity calculates the amount of underlying tokens that `owner` can withdraw. Returns 0 pre-maturity.\n    /// @param  owner The address of the owner for which withdrawal is calculated\n    /// @return maxUnderlyingAmount The maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address owner) external override view returns (uint256 maxUnderlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (balanceOf[owner] * IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);\n    }\n    /// @notice Post maturity simulates the effects of withdrawal at the current block. Returns 0 pre-maturity.\n    /// @param underlyingAmount the amount of underlying tokens withdrawn in the simulation\n    /// @return principalAmount The amount of principal tokens required for the withdrawal of `underlyingAmount`\n    function previewWithdraw(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount * IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate / IRedeemer(redeemer).getExchangeRate(protocol, cToken));\n    }\n    /// @notice At or after maturity, Burns principalAmount from `owner` and sends exactly `underlyingAmount` of underlying tokens to `receiver`.\n    /// @param underlyingAmount The amount of underlying tokens withdrawn\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return principalAmount The amount of principal tokens burnt by the withdrawal\n    function withdraw(uint256 underlyingAmount, address receiver, address holder) external override returns (uint256 principalAmount){\n        uint256 previewAmount = this.previewWithdraw(underlyingAmount);\n        // If maturity is not yet reached\n        if (block.timestamp < maturity) {\n            revert Maturity(maturity);\n        }\n        // Transfer logic\n        // If holder is msg.sender, skip approval check\n        if (holder == msg.sender) {\n            redeemer.authRedeem(protocol, underlying, maturity, msg.sender, receiver, previewAmount);\n            return previewAmount;\n        }\n        else {\n            uint256 allowed = allowance[holder][msg.sender];\n            if (allowed >= previewAmount) {\n                revert Approvals(allowed, previewAmount);\n            }\n            allowance[holder][msg.sender] -= previewAmount;\n            redeemer.authRedeem(protocol, underlying, maturity, holder, receiver, previewAmount); \n            return previewAmount;\n        }\n    }\n    /// @notice At or after maturity, burns exactly `principalAmount` of Principal Tokens from `owner` and sends underlyingAmount of underlying tokens to `receiver`.\n    /// @param principalAmount The amount of principal tokens being redeemed\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return underlyingAmount The amount of underlying tokens distributed by the redemption\n    function redeem(uint256 principalAmount, address receiver, address holder) external override returns (uint256 underlyingAmount){\n        // If maturity is not yet reached\n        if (block.timestamp < maturity) { revert Maturity(maturity); }\n        // some 5095 tokens may have custody of underlying and can can just burn PTs and transfer underlying out, while others rely on external custody\n        if (holder == msg.sender) {\n            return redeemer.authRedeem(protocol, underlying, maturity, msg.sender, receiver, principalAmount);\n        }\n        else {\n            uint256 allowed = allowance[holder][msg.sender];\n            if (allowed >= principalAmount) { revert Approvals(allowed, principalAmount); }\n            allowance[holder][msg.sender] -= principalAmount;  \n            return redeemer.authRedeem(protocol, underlying, maturity, holder, receiver, principalAmount);\n        }\n    }\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    function burn(address f, uint256 a) external onlyAdmin(address(redeemer)) returns (bool) {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    function mint(address t, uint256 a) external onlyAdmin(address(redeemer)) returns (bool) {\n        _mint(t, a);\n        return true;\n    }\n\n    modifier onlyAdmin(address a) {\n    if (msg.sender != a) { revert Authorized(a); }\n    _;\n  }\n}"
    }
  ]
}