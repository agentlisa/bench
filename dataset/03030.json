{
  "Title": "H-7: Tokens received from Curve's `remove_liquidity()` should be added to the assets list even if `_min_amounts` are set to `0`",
  "Content": "# Issue H-7: Tokens received from Curve's `remove_liquidity()` should be added to the assets list even if `_min_amounts` are set to `0` \nSource: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/267-H \n## Found by \nWATCHPUG\n\n## Summary\n\nCurve controller's `canRemoveLiquidity()` should return all the underlying tokens as `tokensIn` rather than only the tokens with `minAmount > 0`.\n\n## Vulnerability Detail\n\nhttps://github.com/sentimentxyz/controller/blob/a2ddbcc00f361f733352d9c51457b4ebb999c8ae/src/curve/StableSwap2PoolController.sol#L129-L152\n\n```solidity\nfunction canRemoveLiquidity(address target, bytes calldata data)\n    internal\n    view\n    returns (bool, address[] memory, address[] memory)\n{\n    (,uint256[2] memory amounts) = abi.decode(\n        data[4:],\n        (uint256, uint256[2])\n    );\n\n    address[] memory tokensOut = new address[](1);\n    tokensOut[0] = target;\n\n    uint i; uint j;\n    address[] memory tokensIn = new address[](2);\n    while(i < 2) {\n        if(amounts[i] > 0)\n            tokensIn[j++] = IStableSwapPool(target).coins(i);\n        unchecked { ++i; }\n    }\n    assembly { mstore(tokensIn, j) }\n\n    return (true, tokensIn, tokensOut);\n}\n```\n\nThe `amounts` in Curve controller's `canRemoveLiquidity()` represent the \"Minimum amounts of underlying coins to receive\", which is used for slippage control.\n\nAt L144-149, only the tokens that specified a minAmount > 0 will be added to the `tokensIn` list, which will later be added to the account's assets list.\n\nWe believe this is wrong as regardless of the minAmount `remove_liquidity()` will always receive all the underlying tokens.\n\nTherefore, it should not check and only add the token when it's minAmount > 0.\n\n## Impact\n\nWhen the user set `_min_amounts` = `0` while removing liquidity from `Curve` and the withdrawn tokens are not in the account's assets list already, the user may get liquidated sooner than expected as `RiskEngine.sol#_getBalance()` only counts in the assets in the assets list.\n\n## Code Snippet\n\nhttps://arbiscan.io/address/0x7f90122bf0700f9e7e1f688fe926940e8839f353#code\n\n```vyper\n@external\n@nonreentrant('lock')\ndef remove_liquidity(\n    _burn_amount: uint256,\n    _min_amounts: uint256[N_COINS],\n    _receiver: address = msg.sender\n) -> uint256[N_COINS]:\n    \"\"\"\n    @notice Withdraw coins from the pool\n    @dev Withdrawal amounts are based on current deposit ratios\n    @param _burn_amount Quantity of LP tokens to burn in the withdrawal\n    @param _min_amounts Minimum amounts of underlying coins to receive\n    @param _receiver Address that receives the withdrawn coins\n    @return List of amounts of coins that were withdrawn\n    \"\"\"\n    total_supply: uint256 = self.totalSupply\n    amounts: uint256[N_COINS] = empty(uint256[N_COINS])\n\n    for i in range(N_COINS):\n        old_balance: uint256 = self.balances[i]\n        value: uint256 = old_balance * _burn_amount / total_supply\n        assert value >= _min_amounts[i], \"Withdrawal resulted in fewer coins than expected\"\n        self.balances[i] = old_balance - value\n        amounts[i] = value\n        ERC20(self.coins[i]).transfer(_receiver, value)\n\n    total_supply -= _burn_amount\n    self.balanceOf[msg.sender] -= _burn_amount\n    self.totalSupply = total_supply\n    log Transfer(msg.sender, ZERO_ADDRESS, _burn_amount)\n\n    log RemoveLiquidity(msg.sender, amounts, empty(uint256[N_COINS]), total_supply)\n\n    return amounts\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`canRemoveLiquidity()` can be changed to:\n\n```solidity\nfunction canRemoveLiquidity(address target, bytes calldata data)\n    internal\n    view\n    returns (bool, address[] memory, address[] memory)\n{\n    address[] memory tokensOut = new address[](1);\n    tokensOut[0] = target;\n\n    address[] memory tokensIn = new address[](2);\n    tokensIn[0] = IStableSwapPool(target).coins(0);\n    tokensIn[1] = IStableSwapPool(target).coins(1);\n    return (true, tokensIn, tokensOut);\n}\n```\n## Sentiment Team\nFixed as recommended. PR [here](https://github.com/sentimentxyz/controller/pull/39).\n\n## Lead Senior Watson\nConfirmed fix. \n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/1",
  "Code": [
    {
      "filename": "src/curve/StableSwap2PoolController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IController} from \"../core/IController.sol\";\nimport {IStableSwapPool} from \"./IStableSwapPool.sol\";\n\n/**\n    @title Curve stable Swap Controller\n    @notice Controller for curve stable swap 2 pool interaction\n    arbi:0x7f90122BF0700F9E7e1F688fe926940E8839F353\n*/\ncontract StableSwap2PoolController is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                             CONSTANT VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice exchange(int128,int128,uint256,uint256)\tfunction signature\n    bytes4 public constant EXCHANGE = 0x3df02124;\n\n    /// @notice add_liquidity(uint256[2],uint256) function signature\n    bytes4 public constant ADD_LIQUIDITY = 0x0b4c7e4d;\n\n    /// @notice remove_liquidity(uint256,uint256[2]) function signature\n    bytes4 public constant REMOVE_LIQUIDITY = 0x5b36389c;\n\n    /// @notice remove_liquidity_one_coin(uint256,int128,uint256) function signature\n    bytes4 public constant REMOVE_LIQUIDITY_ONE_COIN = 0x1a4d01d2;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address target, bool, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == ADD_LIQUIDITY) return canAddLiquidity(target, data);\n        if (sig == REMOVE_LIQUIDITY_ONE_COIN)\n            return canRemoveLiquidityOneCoin(target, data);\n        if (sig == REMOVE_LIQUIDITY) return canRemoveLiquidity(target, data);\n        if (sig == EXCHANGE) return canExchange(target, data);\n\n        return (false, new address[](0), new address[](0));\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Evaluates whether protocol can add liquidity to the target contract\n        @param target External protocol address\n        @param data calldata of the interaction with the target address\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function canAddLiquidity(address target, bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        address[] memory tokensIn = new address[](1);\n        tokensIn[0] = target;\n\n        uint i; uint j;\n        (uint[2] memory amounts) = abi.decode(data[4:], (uint[2]));\n        address[] memory tokensOut = new address[](2);\n        while(i < 2) {\n            if(amounts[i] > 0)\n                tokensOut[j++] = IStableSwapPool(target).coins(i);\n            unchecked { ++i; }\n        }\n        assembly { mstore(tokensOut, j) }\n\n        return (true, tokensIn, tokensOut);\n    }\n\n\n    /**\n        @notice Evaluates whether protocol can remove liquidity from the target contract\n        @param target External protocol address\n        @param data calldata of the interaction with the target address\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function canRemoveLiquidityOneCoin(address target, bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (,int128 i, uint256 min_amount) = abi.decode(\n            data[4:],\n            (uint256, int128, uint256)\n        );\n\n        if (min_amount == 0)\n            return (false, new address[](0), new address[](0));\n\n        address[] memory tokensIn = new address[](1);\n        address[] memory tokensOut = new address[](1);\n\n        tokensIn[0] = IStableSwapPool(target).coins(uint128(i));\n        tokensOut[0] = target;\n\n        return (true, tokensIn, tokensOut);\n    }\n\n    /**\n        @notice Evaluates whether protocol can remove liquidity from the target contract\n        @param target External protocol address\n        @param data calldata of the interaction with the target address\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function canRemoveLiquidity(address target, bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (,uint256[2] memory amounts) = abi.decode(\n            data[4:],\n            (uint256, uint256[2])\n        );\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = target;\n\n        uint i; uint j;\n        address[] memory tokensIn = new address[](2);\n        while(i < 2) {\n            if(amounts[i] > 0)\n                tokensIn[j++] = IStableSwapPool(target).coins(i);\n            unchecked { ++i; }\n        }\n        assembly { mstore(tokensIn, j) }\n\n        return (true, tokensIn, tokensOut);\n    }\n\n    /**\n        @notice Evaluates whether protocol can perform a swap using the target contract\n        @param target External protocol address\n        @param data calldata of the interaction with the target address\n        @return canCall Specifies if the interaction is accepted\n        @return tokensIn List of tokens that the account will receive after the\n        interactions\n        @return tokensOut List of tokens that will be removed from the account\n        after the interaction\n    */\n    function canExchange(address target, bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (int128 i, int128 j,,) = abi.decode(\n            data[4:],\n            (int128, int128, uint256, uint256)\n        );\n\n        address[] memory tokensIn = new address[](1);\n        address[] memory tokensOut = new address[](1);\n        tokensIn[0] = IStableSwapPool(target).coins(uint128(j));\n        tokensOut[0] = IStableSwapPool(target).coins(uint128(i));\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n}"
    }
  ]
}