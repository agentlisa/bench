{
  "Title": "[M-01] TokenHandler.sol, L174 - `.transfer` is bad practice",
  "Content": "_Submitted by JMukesh, also found by tensors_\n\nThe use of `.transfer` in [`TokenHandler.sol` L174](https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/balances/TokenHandler.sol#L174) to send ether is now considered bad practice as gas costs can change which would break the code.\n\nSee [stop using soliditys transfer now](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/), and [istanbul hardfork eips increasing gas costs and more](https://chainsecurity.com/istanbul-hardfork-eips-increasing-gas-costs-and-more/).\n\nRecommend using `call` instead, and make sure to check for reentrancy.\n\n**[jeffywu (Notional) commented](https://github.com/code-423n4/2021-08-notional-findings/issues/38#issuecomment-917446532):**\n > This should be `0 (Non critical)`. ETH transfers still work as of today. This is a best practice recommendation. In the case that there is a hard fork that breaks ETH transfers the protocol can be upgraded to support the use of `call()`\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-08-notional-findings/issues/38#issuecomment-920428460):**\n > I aline with warden on this one. `.transfer` will not work if the account is a smart contract. Keeping as is.\n\n_**EDITORS NOTE:** Additional conversation regarding this vulnerability can be found [here](https://github.com/code-423n4/2021-08-notional-findings/issues/38)_\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-08-notional",
  "Code": [
    {
      "filename": "contracts/internal/balances/TokenHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../math/SafeInt256.sol\";\nimport \"../../global/Types.sol\";\nimport \"../../global/Constants.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport \"interfaces/compound/CEtherInterface.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice Handles all external token transfers and events\nlibrary TokenHandler {\n    using SafeInt256 for int256;\n    using SafeMath for uint256;\n\n    function _getSlot(uint256 currencyId, bool underlying) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    currencyId,\n                    keccak256(abi.encode(underlying, Constants.TOKEN_STORAGE_OFFSET))\n                )\n            );\n    }\n\n    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns\n    /// the underlying token. (These may not always exist)\n    function getToken(uint256 currencyId, bool underlying) internal view returns (Token memory) {\n        bytes32 slot = _getSlot(currencyId, underlying);\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n        address tokenAddress = address(bytes20(data << 96));\n        bool tokenHasTransferFee = bytes1(data << 88) != Constants.BOOL_FALSE;\n        uint8 tokenDecimalPlaces = uint8(bytes1(data << 80));\n        TokenType tokenType = TokenType(uint8(bytes1(data << 72)));\n\n        return\n            Token({\n                tokenAddress: tokenAddress,\n                hasTransferFee: tokenHasTransferFee,\n                decimals: int256(10**tokenDecimalPlaces),\n                tokenType: tokenType\n            });\n    }\n\n    /// @notice Sets a token for a currency id.\n    function setToken(\n        uint256 currencyId,\n        bool underlying,\n        TokenStorage memory tokenStorage\n    ) internal {\n        bytes32 slot = _getSlot(currencyId, underlying);\n\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\n            // Specific storage for Ether token type\n            bytes32 etherData =\n                ((bytes32(bytes20(address(0))) >> 96) |\n                    (bytes32(bytes1(Constants.BOOL_FALSE)) >> 88) |\n                    bytes32(uint256(18) << 168) |\n                    bytes32(uint256(TokenType.Ether) << 176));\n\n            assembly {\n                sstore(slot, etherData)\n            }\n\n            return;\n        }\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\n        require(tokenStorage.tokenAddress != address(0), \"TH: address is zero\");\n\n        uint8 decimalPlaces = ERC20(tokenStorage.tokenAddress).decimals();\n        require(decimalPlaces != 0, \"TH: decimals is zero\");\n\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\n        // then we should explicitly upgrade this method to allow for a token to be changed.\n        Token memory token = getToken(currencyId, underlying);\n        require(\n            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),\n            \"TH: token cannot be reset\"\n        );\n\n        if (tokenStorage.tokenType == TokenType.cToken) {\n            // Set the approval for the underlying so that we can mint cTokens\n            Token memory underlyingToken = getToken(currencyId, true);\n            ERC20(underlyingToken.tokenAddress).approve(\n                tokenStorage.tokenAddress,\n                type(uint256).max\n            );\n        }\n\n        bytes1 transferFee =\n            tokenStorage.hasTransferFee ? Constants.BOOL_TRUE : Constants.BOOL_FALSE;\n\n        bytes32 data =\n            ((bytes32(bytes20(tokenStorage.tokenAddress)) >> 96) |\n                (bytes32(bytes1(transferFee)) >> 88) |\n                bytes32(uint256(decimalPlaces) << 168) |\n                bytes32(uint256(tokenStorage.tokenType) << 176));\n\n        assembly {\n            sstore(slot, data)\n        }\n    }\n\n    /// @notice This method only works with cTokens, it's unclear how we can make this more generic\n    function mint(Token memory token, uint256 underlyingAmountExternal) internal returns (int256) {\n        uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n        uint256 success;\n        if (token.tokenType == TokenType.cToken) {\n            success = CErc20Interface(token.tokenAddress).mint(underlyingAmountExternal);\n        } else if (token.tokenType == TokenType.cETH) {\n            // Reverts on error\n            CEtherInterface(token.tokenAddress).mint{value: msg.value}();\n        } else {\n            revert(); // dev: non mintable token\n        }\n\n        require(success == 0, \"Mint fail\");\n        uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n        // This is the starting and ending balance in external precision\n        return int256(endingBalance.sub(startingBalance));\n    }\n\n    function redeem(\n        Token memory assetToken,\n        Token memory underlyingToken,\n        uint256 assetAmountExternal\n    ) internal returns (int256) {\n        uint256 startingBalance;\n        if (assetToken.tokenType == TokenType.cETH) {\n            startingBalance = address(this).balance;\n        } else if (assetToken.tokenType == TokenType.cToken) {\n            startingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\n        } else {\n            revert(); // dev: non redeemable failure\n        }\n\n        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);\n        require(success == 0, \"Redeem fail\");\n\n        uint256 endingBalance;\n        if (assetToken.tokenType == TokenType.cETH) {\n            endingBalance = address(this).balance;\n        } else {\n            endingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\n        }\n\n        // Underlying token external precision\n        return int256(endingBalance.sub(startingBalance));\n    }\n\n    /// @notice Handles transfers into and out of the system denominated in the external token decimal\n    /// precision.\n    function transfer(\n        Token memory token,\n        address account,\n        int256 netTransferExternal\n    ) internal returns (int256) {\n        if (netTransferExternal > 0) {\n            // Deposits must account for transfer fees.\n            netTransferExternal = _deposit(token, account, uint256(netTransferExternal));\n        } else if (token.tokenType == TokenType.Ether) {\n            require(netTransferExternal < 0); // dev: cannot transfer ether\n            address payable accountPayable = payable(account);\n            // This does not work with contracts, but is reentrancy safe. If contracts want to withdraw underlying\n            // ETH they will have to withdraw the cETH token and then redeem it manually.\n            accountPayable.transfer(uint256(netTransferExternal.neg()));\n        } else {\n            safeTransferOut(\n                IERC20(token.tokenAddress),\n                account,\n                uint256(netTransferExternal.neg())\n            );\n        }\n\n        return netTransferExternal;\n    }\n\n    /// @notice Handles token deposits into Notional. If there is a transfer fee then we must\n    /// calculate the net balance after transfer. Amounts are denominated in the destination token's\n    /// precision.\n    function _deposit(\n        Token memory token,\n        address account,\n        uint256 amount\n    ) private returns (int256) {\n        if (token.hasTransferFee) {\n            // Must deposit from the token and calculate the net transfer\n            uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n            safeTransferIn(IERC20(token.tokenAddress), account, amount);\n            uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\n\n            return int256(endingBalance.sub(startingBalance));\n        }\n\n        safeTransferIn(IERC20(token.tokenAddress), account, amount);\n        return int256(amount);\n    }\n\n    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);\n    }\n\n    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);\n    }\n\n    function transferIncentive(address account, uint256 tokensToTransfer) internal {\n        safeTransferOut(IERC20(Constants.NOTE_TOKEN_ADDRESS), account, tokensToTransfer);\n    }\n\n    function safeTransferOut(\n        IERC20 token,\n        address account,\n        uint256 amount\n    ) private {\n        token.transfer(account, amount);\n        checkReturnCode();\n    }\n\n    function safeTransferIn(\n        IERC20 token,\n        address account,\n        uint256 amount\n    ) private {\n        token.transferFrom(account, address(this), amount);\n        checkReturnCode();\n    }\n\n    function checkReturnCode() private pure {\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {\n                    // This is a non-standard ERC-20\n                    success := not(0) // set success to true\n                }\n                case 32 {\n                    // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0) // Set `success = returndata` of external call\n                }\n                default {\n                    // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n\n        require(success, \"Transfer Failed\");\n    }\n}"
    }
  ]
}