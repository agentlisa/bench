{
  "Title": "[M-10] sfrxETH: The volatile result of previewMint() may prevent mintWithSignature from working",
  "Content": "_Submitted by cccz, also found by rotcivegaf, Trust, and wagmi_\n\nIn sfrxETH contracts, the result of `previewMint()` changes with the state of the contract, which causes the value of amount to be volatile in the mintWithSignature function when approveMax is false.\n\nAnd when using the mintWithSignature function, which requires the user to sign for an accurate amount value, when the amount used differs from the result of previewMint(), mintWithSignature will not work.\n\nConsider the following scenarios.\n\nUser A signs using amount = 1000 and calls the mintWithSignature function.\n\nDuring execution, the previous transaction in the same block changes the state of the contract so that previewMint(shares) == 1001, so the transaction is reverted due to a signature check failure.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-09-frax/blob/55ea6b1ef3857a277e2f47d42029bc0f3d6f9173/src/sfrxETH.sol#L75-L87>\n\n<https://github.com/transmissions11/solmate/blob/bff24e835192470ed38bf15dbed6084c2d723ace/src/mixins/ERC4626.sol#L140-L144>\n\n### Recommended Mitigation Steps\n\nConsider that in the mintWithSignature function, the user provides a maxAmount, and then requires maxAmount >= previewMint(shares) and uses maxAmount to verify the signature.\n\n**[FortisFortuna (Frax) acknowledged and commented](https://github.com/code-423n4/2022-09-frax-findings/issues/35#issuecomment-1257310689):**\n > Technically correct, though in practice, we will allow user-defined slippage on the UI.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-09-frax-findings/issues/35#issuecomment-1276247147):**\n > I don't believe the UI will be able to assist with this issue unless modifications are made to the smart contracts. The signature will become invalidated due to the return value of `previewMint()` changing while the transaction is waiting to be included in a block.  \n\n\n\n***\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-09-frax",
  "Code": [
    {
      "filename": "src/sfrxETH.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ============================== sfrxETH =============================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author(s)\n// Jack Corddry: https://github.com/corddry\n// Nader Ghazvini: https://github.com/amirnader-ghazvini \n\n// Reviewer(s) / Contributor(s)\n// Sam Kazemian: https://github.com/samkazemian\n// Dennett: https://github.com/denett\n// Travis Moore: https://github.com/FortisFortuna\n// Jamie Turley: https://github.com/jyturley\n\nimport { ERC20, ERC4626, xERC4626 } from \"ERC4626/xERC4626.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\n/// @title Vault token for staked frxETH\n/// @notice Is a vault that takes frxETH and gives you sfrxETH erc20 tokens\n/** @dev Exchange rate between frxETH and sfrxETH floats, you can convert your sfrxETH for more frxETH over time.\n    Exchange rate increases as the frax msig mints new frxETH corresponding to the staking yield and drops it into the vault (sfrxETH contract).\n    There is a short time period, “cycles” which the exchange rate increases linearly over. This is to prevent gaming the exchange rate (MEV).\n    The cycles are constant length, but calling syncRewards slightly into a would-be cycle keeps the same would-be endpoint (so cycle ends are every X seconds).\n    Someone must call syncRewards, which queues any new frxETH in the contract to be added to the redeemable amount.\n    sfrxETH adheres to ERC-4626 vault specs \n    Mint vs Deposit\n    mint() - deposit targeting a specific number of sfrxETH out\n    deposit() - deposit knowing a specific number of frxETH in */\ncontract sfrxETH is xERC4626, ReentrancyGuard {\n    /* ========== CONSTRUCTOR ========== */\n    constructor(ERC20 _underlying, uint32 _rewardsCycleLength)\n        ERC4626(_underlying, \"Staked Frax Ether\", \"sfrxETH\")\n        xERC4626(_rewardsCycleLength)\n    {}\n\n    /// @notice Syncs rewards if applicable beforehand. Noop if otherwise \n    function beforeWithdraw(uint256 assets, uint256 shares) internal override {\n        super.beforeWithdraw(assets, shares); // call xERC4626's beforeWithdraw first\n        if (block.timestamp >= rewardsCycleEnd) { syncRewards(); } \n    }\n\n    /// @notice How much frxETH is 1E18 sfrxETH worth. Price is in ETH, not USD\n    function pricePerShare() public view returns (uint256) {\n        return convertToAssets(1e18);\n    }\n\n    /// @notice Approve and deposit() in one transaction\n    function depositWithSignature(\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant returns (uint256 shares) {\n        uint256 amount = approveMax ? type(uint256).max : assets;\n        asset.permit(msg.sender, address(this), amount, deadline, v, r, s);\n        return (deposit(assets, receiver));\n    }\n\n    /// @notice Approve and mint() in one transaction\n    /// @dev Similar to the deposit method, but you give it the number of shares you want instead.\n    function mintWithSignature(\n        uint256 shares,\n        address receiver,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant returns (uint256 assets) {\n        uint256 amount = approveMax ? type(uint256).max : previewMint(shares);\n        asset.permit(msg.sender, address(this), amount, deadline, v, r, s);\n        return (mint(shares, receiver));\n    }\n\n}"
    },
    {
      "filename": "src/mixins/ERC4626.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}"
    }
  ]
}