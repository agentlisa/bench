{
  "Title": "Potential custodial asset collateral incorrect signatures",
  "Content": "##### Description\nThis warning is about absent signature correctness checks in Proof data structure in RealAssetDepositaryBalanceView in here: https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/depositary/RealAssetDepositaryBalanceView.sol#L88.\n\nWhat kind of signatures are these? How do they get formed? Were they formed correctly and how to check that?\n\n##### Recommendation\nIt is recommended to implement additional signature correctness checks, append comments about the nature of those signatures.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/depositary/RealAssetDepositaryBalanceView.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../utils/AccessControl.sol\";\nimport \"./IDepositaryBalanceView.sol\";\n\ncontract RealAssetDepositaryBalanceView is IDepositaryBalanceView, AccessControl {\n    using SafeMath for uint256;\n\n    /// @notice Signed data of asset information.\n    struct Proof {\n        string data;\n        string signature;\n    }\n\n    /// @notice Asset information.\n    struct Asset {\n        string id;\n        uint256 amount;\n        uint256 price;\n    }\n\n    /// @notice The number of assets in depositary.\n    uint256 public maxSize;\n\n    /// @notice Decimals balance.\n    uint256 public override decimals = 6;\n\n    /// @notice Assets list.\n    Asset[] public portfolio;\n\n    /// @dev Assets list index.\n    mapping(string => uint256) internal portfolioIndex;\n\n    /// @notice An event thats emitted when asset updated in portfolio.\n    event AssetUpdated(string id, uint256 updatedAt, Proof proof);\n\n    /// @notice An event thats emitted when asset removed from portfolio.\n    event AssetRemoved(string id);\n\n    /**\n     * @param _decimals Decimals balance.\n     * @param _maxSize Max number assets in depositary.\n     */\n    constructor(uint256 _decimals, uint256 _maxSize) public {\n        decimals = _decimals;\n        maxSize = _maxSize;\n    }\n\n    /**\n     * @return Assets count of depositary.\n     */\n    function size() public view returns (uint256) {\n        return portfolio.length;\n    }\n\n    /**\n     * @return Assets list.\n     */\n    function assets() external view returns (Asset[] memory) {\n        Asset[] memory result = new Asset[](size());\n\n        for (uint256 i = 0; i < size(); i++) {\n            result[i] = portfolio[i];\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Update information of asset.\n     * @param id Asset identificator.\n     * @param amount Amount of asset.\n     * @param price Cost of one asset in base currency.\n     * @param updatedAt Timestamp of updated.\n     * @param proofData Signed data.\n     * @param proofSignature Data signature.\n     */\n    function put(\n        string calldata id,\n        uint256 amount,\n        uint256 price,\n        uint256 updatedAt,\n        string calldata proofData,\n        string calldata proofSignature\n    ) external onlyAllowed {\n        require(size() < maxSize, \"RealAssetDepositaryBalanceView::put: too many assets\");\n\n        uint256 valueIndex = portfolioIndex[id];\n        if (valueIndex != 0) {\n            portfolio[valueIndex.sub(1)] = Asset(id, amount, price);\n        } else {\n            portfolio.push(Asset(id, amount, price));\n            portfolioIndex[id] = size();\n        }\n        emit AssetUpdated(id, updatedAt, Proof(proofData, proofSignature));\n    }\n\n    /**\n     * @notice Remove information of asset.\n     * @param id Asset identificator.\n     */\n    function remove(string calldata id) external onlyAllowed {\n        uint256 valueIndex = portfolioIndex[id];\n        require(valueIndex != 0, \"RealAssetDepositaryBalanceView::remove: asset already removed\");\n\n        uint256 toDeleteIndex = valueIndex.sub(1);\n        uint256 lastIndex = size().sub(1);\n        Asset memory lastValue = portfolio[lastIndex];\n        portfolio[toDeleteIndex] = lastValue;\n        portfolioIndex[lastValue.id] = toDeleteIndex.add(1);\n        portfolio.pop();\n        delete portfolioIndex[id];\n\n        emit AssetRemoved(id);\n    }\n\n    function balance() external view override returns (uint256) {\n        uint256 result;\n\n        for (uint256 i = 0; i < size(); i++) {\n            result = result.add(portfolio[i].amount.mul(portfolio[i].price));\n        }\n\n        return result;\n    }\n}"
    }
  ]
}