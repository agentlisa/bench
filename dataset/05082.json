{
  "Title": "[G-10] Cache function result into stack var first instead of state variables if need to read them twice",
  "Content": "\n`_getCurrentPTandIBTRates` function result can be cached into stack var. instead of  `ptRate` and `ibtRate` state variables when state var. read just after that than better will be to read from stack var. again and assigning those stack var. into state var.  also and emit those stack var. also. which saves 2 SLOAD (~200 gas)\n\n### GAS SAVED 2 SLOAD (~200 GAS)\n\n```solidity\nFile : src/tokens/PrincipalToken.sol\n\n414:   // PT rate not rounded up here\n415:   (ptRate, ibtRate) = _getCurrentPTandIBTRates(false);\n416:   emit RatesStoredAtExpiry(ibtRate, ptRate); //@audit avoid this read from state var. use stack var. instead\n\n```\n[PrincipalToken.sol#L414-L416](https://github.com/code-423n4/2024-02-spectra/blob/b35bbf78ad9d0e74e9c8450a0c5c6d35b68f7228/src/tokens/PrincipalToken.sol#L414-L416)\n\n**Recommended Mitigation Steps:**\n\n```diff\nFile : src/tokens/PrincipalToken.sol\n+     uint256 _ptRate;\n+     uint256 _ibtRate;\n\n-415:   (ptRate, ibtRate) = _getCurrentPTandIBTRates(false);\n-416:   emit RatesStoredAtExpiry(ibtRate, ptRate);\n+415:   (_ptRate, _ibtRate) = _getCurrentPTandIBTRates(false);\n+       ptRate = _ptRate;\n+       ibtRate = _ibtRate;\n+416:   emit RatesStoredAtExpiry(_ibtRate, _ptRate); //read from stack var saved 2 SLOAD\n\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-spectra",
  "Code": [
    {
      "filename": "src/tokens/PrincipalToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts-upgradeable/access/manager/AccessManagedUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"openzeppelin-math/Math.sol\";\nimport \"openzeppelin-erc20-extensions/ERC20PermitUpgradeable.sol\";\nimport \"openzeppelin-contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"openzeppelin-contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"openzeppelin-contracts/interfaces/IERC4626.sol\";\n\nimport \"../libraries/PrincipalTokenUtil.sol\";\nimport \"../libraries/NamingUtil.sol\";\nimport \"../libraries/RayMath.sol\";\nimport \"../interfaces/IRegistry.sol\";\nimport \"../interfaces/IPrincipalToken.sol\";\nimport \"../interfaces/IYieldToken.sol\";\nimport \"../interfaces/IRewardsProxy.sol\";\n\n/**\n * @title PrincipalToken contract\n * @notice A PrincipalToken (PT) is an ERC5095 vault that allows user to tokenize their yield in a permissionless manner.\n * The shares of the vaults are composed by PT/YT pairs. These are always minted at same times and amounts upon deposits.\n * Until expiry burning shares necessitates to burn both tokens. At expiry, burning PTs is sufficient.\n */\ncontract PrincipalToken is\n    ERC20PermitUpgradeable,\n    AccessManagedUpgradeable,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable,\n    IPrincipalToken\n{\n    using SafeERC20 for IERC20;\n    using RayMath for uint256;\n    using Math for uint256;\n\n    uint256 private constant MIN_DECIMALS = 6;\n    uint256 private constant MAX_DECIMALS = 18;\n    bytes32 private constant ON_FLASH_LOAN = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    address private immutable registry;\n\n    address private rewardsProxy;\n    bool private ratesAtExpiryStored;\n    address private ibt; // address of the Interest Bearing Token 4626 held by this PT vault\n    address private _asset; // the asset of this PT vault (which is also the asset of the IBT 4626)\n    address private yt; // YT corresponding to this PT, deployed at initialization\n    uint256 private ibtUnit; // equal to one unit of the IBT held by this PT vault (10^decimals)\n    uint256 private _ibtDecimals;\n    uint256 private _assetDecimals;\n\n    uint256 private ptRate; // or PT price in asset (in Ray)\n    uint256 private ibtRate; // or IBT price in asset (in Ray)\n    uint256 private unclaimedFeesInIBT; // unclaimed fees\n    uint256 private totalFeesInIBT; // total fees\n    uint256 private expiry; // date of maturity (set at initialization)\n    uint256 private duration; // duration to maturity\n\n    mapping(address => uint256) private ibtRateOfUser; // stores each user's IBT rate (in Ray)\n    mapping(address => uint256) private ptRateOfUser; // stores each user's PT rate (in Ray)\n    mapping(address => uint256) private yieldOfUserInIBT; // stores each user's yield generated from YTs\n\n    /* EVENTS\n     *****************************************************************************************************************/\n    event Redeem(address indexed from, address indexed to, uint256 amount);\n    event Mint(address indexed from, address indexed to, uint256 amount);\n    event YTDeployed(address indexed yt);\n    event YieldUpdated(address indexed user, uint256 indexed yieldInIBT);\n    event YieldClaimed(address indexed owner, address indexed receiver, uint256 indexed yieldInIBT);\n    event FeeClaimed(\n        address indexed user,\n        uint256 indexed redeemedIbts,\n        uint256 indexed receivedAssets\n    );\n    event RatesStoredAtExpiry(uint256 indexed ibtRate, uint256 indexed ptRate);\n    event RewardsProxyChange(address indexed oldRewardsProxy, address indexed newRewardsProxy);\n\n    /* MODIFIERS\n     *****************************************************************************************************************/\n\n    /// @notice Ensures the current block timestamp is before expiry\n    modifier notExpired() virtual {\n        if (block.timestamp >= expiry) {\n            revert PTExpired();\n        }\n        _;\n    }\n\n    /// @notice Ensures the current block timestamp is at or after expiry\n    modifier afterExpiry() virtual {\n        if (block.timestamp < expiry) {\n            revert PTNotExpired();\n        }\n        _;\n    }\n\n    /* CONSTRUCTOR\n     *****************************************************************************************************************/\n    constructor(address _registry) {\n        if (_registry == address(0)) {\n            revert AddressError();\n        }\n        registry = _registry;\n        _disableInitializers(); // using this so that the deployed logic contract cannot later be initialized\n    }\n\n    /* INITIALIZER\n     *****************************************************************************************************************/\n\n    /**\n     * @dev First function called after deployment of the contract\n     * it deploys yt and intializes values of required variables\n     * @param _ibt The token which PT contract holds\n     * @param _duration The duration (in s) to expiry/maturity of the PT contract\n     * @param _initialAuthority The initial authority of the PT contract\n     */\n    function initialize(\n        address _ibt,\n        uint256 _duration,\n        address _initialAuthority\n    ) external initializer {\n        if (_ibt == address(0) || _initialAuthority == address(0)) {\n            revert AddressError();\n        }\n        if (IERC4626(_ibt).totalAssets() == 0) {\n            revert RateError();\n        }\n        _asset = IERC4626(_ibt).asset();\n        duration = _duration;\n        expiry = _duration + block.timestamp;\n        string memory _ibtSymbol = IERC4626(_ibt).symbol();\n        string memory name = NamingUtil.genPTName(_ibtSymbol, expiry);\n        __ERC20_init(name, NamingUtil.genPTSymbol(_ibtSymbol, expiry));\n        __ERC20Permit_init(name);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __AccessManaged_init(_initialAuthority);\n        _ibtDecimals = IERC4626(_ibt).decimals();\n        _assetDecimals = PrincipalTokenUtil._tryGetTokenDecimals(_asset);\n        if (\n            _assetDecimals < MIN_DECIMALS ||\n            _assetDecimals > _ibtDecimals ||\n            _ibtDecimals > MAX_DECIMALS\n        ) {\n            revert InvalidDecimals();\n        }\n        ibt = _ibt;\n        ibtUnit = 10 ** _ibtDecimals;\n        ibtRate = IERC4626(ibt).previewRedeem(ibtUnit).toRay(_assetDecimals);\n        ptRate = RayMath.RAY_UNIT;\n        yt = _deployYT(\n            NamingUtil.genYTName(_ibtSymbol, expiry),\n            NamingUtil.genYTSymbol(_ibtSymbol, expiry)\n        );\n    }\n\n    /** @dev See {PausableUpgradeable-_pause}. */\n    function pause() external override restricted {\n        _pause();\n    }\n\n    /** @dev See {PausableUpgradeable-_unPause}. */\n    function unPause() external override restricted {\n        _unpause();\n    }\n\n    /** @dev See {IPrincipalToken-deposit}. */\n    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {\n        shares = deposit(assets, receiver, receiver);\n    }\n\n    /** @dev See {IPrincipalToken-deposit}. */\n    function deposit(\n        uint256 assets,\n        address ptReceiver,\n        address ytReceiver\n    ) public override returns (uint256 shares) {\n        IERC20(_asset).safeTransferFrom(msg.sender, address(this), assets);\n        IERC20(_asset).safeIncreaseAllowance(ibt, assets);\n        uint256 ibts = IERC4626(ibt).deposit(assets, address(this));\n        shares = _depositIBT(ibts, ptReceiver, ytReceiver);\n    }\n\n    /** @dev See {IPrincipalToken-deposit}. */\n    function deposit(\n        uint256 assets,\n        address ptReceiver,\n        address ytReceiver,\n        uint256 minShares\n    ) external override returns (uint256 shares) {\n        shares = deposit(assets, ptReceiver, ytReceiver);\n        if (shares < minShares) {\n            revert ERC5143SlippageProtectionFailed();\n        }\n    }\n\n    /** @dev See {IPrincipalToken-depositIBT}. */\n    function depositIBT(uint256 ibts, address receiver) external override returns (uint256 shares) {\n        shares = depositIBT(ibts, receiver, receiver);\n    }\n\n    /** @dev See {IPrincipalToken-depositIBT}. */\n    function depositIBT(\n        uint256 ibts,\n        address ptReceiver,\n        address ytReceiver\n    ) public override returns (uint256 shares) {\n        IERC20(ibt).safeTransferFrom(msg.sender, address(this), ibts);\n        shares = _depositIBT(ibts, ptReceiver, ytReceiver);\n    }\n\n    /** @dev See {IPrincipalToken-depositIBT}. */\n    function depositIBT(\n        uint256 ibts,\n        address ptReceiver,\n        address ytReceiver,\n        uint256 minShares\n    ) external override returns (uint256 shares) {\n        shares = depositIBT(ibts, ptReceiver, ytReceiver);\n        if (shares < minShares) {\n            revert ERC5143SlippageProtectionFailed();\n        }\n    }\n\n    /** @dev See {IPrincipalToken-redeem}. */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        _beforeRedeem(shares, owner);\n        assets = IERC4626(ibt).redeem(_convertSharesToIBTs(shares, false), receiver, address(this));\n        emit Redeem(owner, receiver, shares);\n    }\n\n    /** @dev See {IPrincipalToken-redeem}. */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint256 minAssets\n    ) external override returns (uint256 assets) {\n        assets = redeem(shares, receiver, owner);\n        if (assets < minAssets) {\n            revert ERC5143SlippageProtectionFailed();\n        }\n    }\n\n    /** @dev See {IPrincipalToken-redeemForIBT}. */\n    function redeemForIBT(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 ibts) {\n        _beforeRedeem(shares, owner);\n        ibts = _convertSharesToIBTs(shares, false);\n        IERC20(ibt).safeTransfer(receiver, ibts);\n        emit Redeem(owner, receiver, shares);\n    }\n\n    /** @dev See {IPrincipalToken-redeemForIBT}. */\n    function redeemForIBT(\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint256 minIbts\n    ) external override returns (uint256 ibts) {\n        ibts = redeemForIBT(shares, receiver, owner);\n        if (ibts < minIbts) {\n            revert ERC5143SlippageProtectionFailed();\n        }\n    }\n\n    /** @dev See {IPrincipalToken-withdraw}. */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        _beforeWithdraw(assets, owner);\n        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);\n        uint256 ibts = IERC4626(ibt).withdraw(assets, receiver, address(this));\n        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);\n    }\n\n    /** @dev See {IPrincipalToken-withdraw}. */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner,\n        uint256 maxShares\n    ) external override returns (uint256 shares) {\n        shares = withdraw(assets, receiver, owner);\n        if (shares > maxShares) {\n            revert ERC5143SlippageProtectionFailed();\n        }\n    }\n\n    /** @dev See {IPrincipalToken-withdrawIBT}. */\n    function withdrawIBT(\n        uint256 ibts,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        _beforeWithdraw(IERC4626(ibt).previewRedeem(ibts), owner);\n        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);\n        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);\n        // send IBTs from this contract to receiver\n        IERC20(ibt).safeTransfer(receiver, ibts);\n    }\n\n    /** @dev See {IPrincipalToken-withdrawIBT}. */\n    function withdrawIBT(\n        uint256 ibts,\n        address receiver,\n        address owner,\n        uint256 maxShares\n    ) external override returns (uint256 shares) {\n        shares = withdrawIBT(ibts, receiver, owner);\n        if (shares > maxShares) {\n            revert ERC5143SlippageProtectionFailed();\n        }\n    }\n\n    /** @dev See {IPrincipalToken-claimFees}. */\n    function claimFees() external override returns (uint256 assets) {\n        if (msg.sender != IRegistry(registry).getFeeCollector()) {\n            revert UnauthorizedCaller();\n        }\n        uint256 ibts = unclaimedFeesInIBT;\n        unclaimedFeesInIBT = 0;\n        assets = IERC4626(ibt).redeem(ibts, msg.sender, address(this));\n        emit FeeClaimed(msg.sender, ibts, assets);\n    }\n\n    /** @dev See {IPrincipalToken-updateYield}. */\n    function updateYield(address _user) public override returns (uint256 updatedUserYieldInIBT) {\n        (uint256 _ptRate, uint256 _ibtRate) = _updatePTandIBTRates();\n\n        uint256 _oldIBTRateUser = ibtRateOfUser[_user];\n        if (_oldIBTRateUser != _ibtRate) {\n            ibtRateOfUser[_user] = _ibtRate;\n        }\n        uint256 _oldPTRateUser = ptRateOfUser[_user];\n        if (_oldPTRateUser != _ptRate) {\n            ptRateOfUser[_user] = _ptRate;\n        }\n\n        // Check for skipping yield update when the user deposits for the first time or rates decreased to 0.\n        if (_oldIBTRateUser != 0) {\n            updatedUserYieldInIBT = PrincipalTokenUtil._computeYield(\n                _user,\n                yieldOfUserInIBT[_user],\n                _oldIBTRateUser,\n                _ibtRate,\n                _oldPTRateUser,\n                _ptRate,\n                yt\n            );\n            yieldOfUserInIBT[_user] = updatedUserYieldInIBT;\n            emit YieldUpdated(_user, updatedUserYieldInIBT);\n        }\n    }\n\n    /** @dev See {IPrincipalToken-claimYield}. */\n    function claimYield(address _receiver) public override returns (uint256 yieldInAsset) {\n        uint256 yieldInIBT = _claimYield();\n        if (yieldInIBT != 0) {\n            yieldInAsset = IERC4626(ibt).redeem(yieldInIBT, _receiver, address(this));\n        }\n    }\n\n    /** @dev See {IPrincipalToken-claimYieldInIBT}. */\n    function claimYieldInIBT(address _receiver) public override returns (uint256 yieldInIBT) {\n        yieldInIBT = _claimYield();\n        if (yieldInIBT != 0) {\n            IERC20(ibt).safeTransfer(_receiver, yieldInIBT);\n        }\n    }\n\n    /** @dev See {IPrincipalToken-beforeYtTransfer}. */\n    function beforeYtTransfer(address _from, address _to) external override {\n        if (msg.sender != yt) {\n            revert UnauthorizedCaller();\n        }\n        updateYield(_from);\n        updateYield(_to);\n    }\n\n    /** @dev See {IPrincipalToken-claimRewards}. */\n    function claimRewards(bytes memory _data) external restricted {\n        if (rewardsProxy == address(0)) {\n            revert NoRewardsProxySet();\n        }\n        _data = abi.encodeWithSelector(IRewardsProxy(rewardsProxy).claimRewards.selector, _data);\n        (bool success, ) = rewardsProxy.delegatecall(_data);\n        if (!success) {\n            revert ClaimRewardsFailed();\n        }\n    }\n\n    /* SETTERS\n     *****************************************************************************************************************/\n\n    /** @dev See {IPrincipalToken-storeRatesAtExpiry}. */\n    function storeRatesAtExpiry() public override afterExpiry {\n        if (ratesAtExpiryStored) {\n            revert RatesAtExpiryAlreadyStored();\n        }\n        ratesAtExpiryStored = true;\n        // PT rate not rounded up here\n        (ptRate, ibtRate) = _getCurrentPTandIBTRates(false);\n        emit RatesStoredAtExpiry(ibtRate, ptRate);\n    }\n\n    /** @dev See {IPrincipalToken-setRewardsProxy}. */\n    function setRewardsProxy(address _rewardsProxy) external restricted {\n        // Note: address zero is allowed in order to disable the claim proxy\n        emit RewardsProxyChange(rewardsProxy, _rewardsProxy);\n        rewardsProxy = _rewardsProxy;\n    }\n\n    /* GETTERS\n     *****************************************************************************************************************/\n\n    /** @dev See {IPrincipalToken-previewDeposit}. */\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        uint256 ibts = IERC4626(ibt).previewDeposit(assets);\n        return _previewDepositIBT(ibts);\n    }\n\n    /** @dev See {IPrincipalToken-previewDepositIBT}. */\n    function previewDepositIBT(uint256 ibts) external view override returns (uint256) {\n        return _previewDepositIBT(ibts);\n    }\n\n    /** @dev See {IPrincipalToken-maxDeposit}. */\n    function maxDeposit(address) external pure override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IPrincipalToken-previewWithdraw}. */\n    function previewWithdraw(\n        uint256 assets\n    ) external view override whenNotPaused returns (uint256) {\n        uint256 ibts = IERC4626(ibt).previewWithdraw(assets);\n        return previewWithdrawIBT(ibts);\n    }\n\n    /** @dev See {IPrincipalToken-previewWithdrawIBT}. */\n    function previewWithdrawIBT(uint256 ibts) public view override whenNotPaused returns (uint256) {\n        return _convertIBTsToShares(ibts, true);\n    }\n\n    /** @dev See {IPrincipalToken-maxWithdraw}.\n     */\n    function maxWithdraw(address owner) public view override whenNotPaused returns (uint256) {\n        return convertToUnderlying(_maxBurnable(owner));\n    }\n\n    /** @dev See {IPrincipalToken-maxWithdrawIBT}.\n     */\n    function maxWithdrawIBT(address owner) public view override whenNotPaused returns (uint256) {\n        return _convertSharesToIBTs(_maxBurnable(owner), false);\n    }\n\n    /** @dev See {IPrincipalToken-previewRedeem}. */\n    function previewRedeem(uint256 shares) public view override returns (uint256) {\n        return IERC4626(ibt).previewRedeem(previewRedeemForIBT(shares));\n    }\n\n    /** @dev See {IPrincipalToken-previewRedeemForIBT}. */\n    function previewRedeemForIBT(\n        uint256 shares\n    ) public view override whenNotPaused returns (uint256) {\n        return _convertSharesToIBTs(shares, false);\n    }\n\n    /** @dev See {IPrincipalToken-maxRedeem}. */\n    function maxRedeem(address owner) public view override returns (uint256) {\n        return _maxBurnable(owner);\n    }\n\n    /** @dev See {IPrincipalToken-convertToPrincipal}. */\n    function convertToPrincipal(uint256 underlyingAmount) external view override returns (uint256) {\n        return _convertIBTsToShares(IERC4626(ibt).previewDeposit(underlyingAmount), false);\n    }\n\n    /** @dev See {IPrincipalToken-convertToUnderlying}. */\n    function convertToUnderlying(uint256 principalAmount) public view override returns (uint256) {\n        return IERC4626(ibt).previewRedeem(_convertSharesToIBTs(principalAmount, false));\n    }\n\n    /** @dev See {IPrincipalToken-totalAssets}. */\n    function totalAssets() public view override returns (uint256) {\n        return IERC4626(ibt).previewRedeem(IERC4626(ibt).balanceOf(address(this)));\n    }\n\n    /** @dev See {IERC20Metadata-decimals} */\n    function decimals() public view override(IERC20Metadata, ERC20Upgradeable) returns (uint8) {\n        return IERC4626(ibt).decimals();\n    }\n\n    /** @dev See {IPrincipalToken-underlying}. */\n    function underlying() external view override returns (address) {\n        return _asset;\n    }\n\n    /** @dev See {IPrincipalToken-maturity}. */\n    function maturity() external view override returns (uint256) {\n        return expiry;\n    }\n\n    /** @dev See {IPrincipalToken-getDuration}. */\n    function getDuration() external view override returns (uint256) {\n        return duration;\n    }\n\n    /** @dev See {IPrincipalToken-getIBT}. */\n    function getIBT() external view override returns (address) {\n        return ibt;\n    }\n\n    /** @dev See {IPrincipalToken-getYT}. */\n    function getYT() external view override returns (address) {\n        return yt;\n    }\n\n    /** @dev See {IPrincipalToken-getIBTRate}. */\n    function getIBTRate() external view override returns (uint256) {\n        (, uint256 _ibtRate) = _getPTandIBTRates(false);\n        return _ibtRate;\n    }\n\n    /** @dev See {IPrincipalToken-getPTRate}. */\n    function getPTRate() external view override returns (uint256) {\n        (uint256 _ptRate, ) = _getPTandIBTRates(false);\n        return _ptRate;\n    }\n\n    /** @dev See {IPrincipalToken-getIBTUnit}. */\n    function getIBTUnit() external view override returns (uint256) {\n        return ibtUnit;\n    }\n\n    /** @dev See {IPrincipalToken-getUnclaimedFeesInIBT}. */\n    function getUnclaimedFeesInIBT() external view override returns (uint256) {\n        return unclaimedFeesInIBT;\n    }\n\n    /** @dev See {IPrincipalToken-getTotalFeesInIBT}. */\n    function getTotalFeesInIBT() external view override returns (uint256) {\n        return totalFeesInIBT;\n    }\n\n    /** @dev See {IPrincipalToken-getCurrentYieldOfUserInIBT}. */\n    function getCurrentYieldOfUserInIBT(\n        address _user\n    ) external view override returns (uint256 _yieldOfUserInIBT) {\n        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);\n        uint256 _oldIBTRate = ibtRateOfUser[_user];\n        uint256 _oldPTRate = ptRateOfUser[_user];\n        if (_oldIBTRate != 0) {\n            _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(\n                _user,\n                yieldOfUserInIBT[_user],\n                _oldIBTRate,\n                _ibtRate,\n                _oldPTRate,\n                _ptRate,\n                yt\n            );\n            _yieldOfUserInIBT -= PrincipalTokenUtil._computeYieldFee(_yieldOfUserInIBT, registry);\n        }\n    }\n\n    /**\n     * @dev See {IERC3156FlashLender-maxFlashLoan}.\n     */\n    function maxFlashLoan(address _token) public view override returns (uint256) {\n        if (_token != ibt) {\n            return 0;\n        }\n        // Entire IBT balance of the contract can be borrowed\n        return IERC4626(ibt).balanceOf(address(this));\n    }\n\n    /**\n     * @dev See {IERC3156FlashLender-flashFee}.\n     */\n    function flashFee(address _token, uint256 _amount) public view override returns (uint256) {\n        if (_token != ibt) revert AddressError();\n        return PrincipalTokenUtil._computeFlashloanFee(_amount, registry);\n    }\n\n    /**\n     * @dev See {IPrincipalToken-tokenizationFee}.\n     */\n    function getTokenizationFee() public view override returns (uint256) {\n        return IRegistry(registry).getTokenizationFee();\n    }\n\n    /**\n     * @dev See {IERC3156FlashLender-flashLoan}.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override returns (bool) {\n        if (_amount > maxFlashLoan(_token)) revert FlashLoanExceedsMaxAmount();\n\n        uint256 fee = flashFee(_token, _amount);\n        _updateFees(fee);\n\n        // Initiate the flash loan by lending the requested IBT amount\n        IERC20(ibt).safeTransfer(address(_receiver), _amount);\n\n        // Execute the flash loan\n        if (_receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) != ON_FLASH_LOAN)\n            revert FlashLoanCallbackFailed();\n\n        // Repay the debt + fee\n        IERC20(ibt).safeTransferFrom(address(_receiver), address(this), _amount + fee);\n\n        return true;\n    }\n\n    /* INTERNAL FUNCTIONS\n     *****************************************************************************************************************/\n\n    /**\n     * @dev Preview the amount of shares that would be minted for a given amount (ibts) of IBT. This method is used both to preview a deposit with assets and a deposit with IBTs.\n     * @param _ibts The amount of IBT to deposit\n     * @return The amount of shares that would be minted\n     */\n    function _previewDepositIBT(\n        uint256 _ibts\n    ) internal view notExpired whenNotPaused returns (uint256) {\n        uint256 tokenizationFee = PrincipalTokenUtil._computeTokenizationFee(\n            _ibts,\n            address(this),\n            registry\n        );\n\n        return _convertIBTsToSharesPreview(_ibts - tokenizationFee);\n    }\n\n    /**\n     * @dev Converts amount of PT shares to amount of IBT with current rates\n     * @param _shares amount of shares to convert to IBTs\n     * @param _roundUp true if result should be rounded up\n     * @return ibts resulting amount of IBT\n     */\n    function _convertSharesToIBTs(\n        uint256 _shares,\n        bool _roundUp\n    ) internal view returns (uint256 ibts) {\n        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);\n        if (_ibtRate == 0) {\n            revert RateError();\n        }\n        ibts = _shares.mulDiv(\n            _ptRate,\n            _ibtRate,\n            _roundUp ? Math.Rounding.Ceil : Math.Rounding.Floor\n        );\n    }\n\n    /**\n     * @dev Converts amount of IBT to amount of PT shares with current rates\n     * @param _ibts amount of IBT to convert to shares\n     * @param _roundUp true if result should be rounded up\n     * @return shares resulting amount of shares\n     */\n    function _convertIBTsToShares(\n        uint256 _ibts,\n        bool _roundUp\n    ) internal view returns (uint256 shares) {\n        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);\n        if (_ptRate == 0) {\n            revert RateError();\n        }\n        shares = _ibts.mulDiv(\n            _ibtRate,\n            _ptRate,\n            _roundUp ? Math.Rounding.Ceil : Math.Rounding.Floor\n        );\n    }\n\n    /**\n     * @dev Converts amount of IBT to amount of PT shares with current rates.\n     * This method also rounds the result of the new PTRate computation in case of negative rate\n     * @param ibts amount of IBT to convert to shares\n     * @return shares resulting amount of shares\n     */\n    function _convertIBTsToSharesPreview(uint256 ibts) internal view returns (uint256 shares) {\n        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(true); // to round up the shares, the PT rate must round down\n        if (_ptRate == 0) {\n            revert RateError();\n        }\n        shares = ibts.mulDiv(_ibtRate, _ptRate);\n    }\n\n    /**\n     * @dev Updates unclaimed fees and total fees upon tokenization and yield claiming\n     * @param _feesInIBT The fees in IBT currently being paid\n     */\n    function _updateFees(uint256 _feesInIBT) internal {\n        unclaimedFeesInIBT += _feesInIBT;\n        totalFeesInIBT += _feesInIBT;\n    }\n\n    /**\n     * @dev Deploys a yt for this pt, called while initializing.\n     * @param _name Name of the yt.\n     * @param _symbol Symbol of the yt.\n     * @return _yt The address of deployed yt.\n     */\n    function _deployYT(string memory _name, string memory _symbol) internal returns (address _yt) {\n        address ytBeacon = IRegistry(registry).getYTBeacon();\n        if (ytBeacon == address(0)) {\n            revert BeaconNotSet();\n        }\n        _yt = address(\n            new BeaconProxy(\n                ytBeacon,\n                abi.encodeWithSelector(\n                    IYieldToken(address(0)).initialize.selector,\n                    _name,\n                    _symbol,\n                    address(this)\n                )\n            )\n        );\n        emit YTDeployed(_yt);\n    }\n\n    /**\n     * @dev Internal function for minting pt & yt to depositing user. Also updates yield before minting.\n     * @param _ibts The amount of IBT being deposited by the user\n     * @param _ptReceiver The address of the PT receiver\n     * @param _ytReceiver The address of the YT receiver\n     * @return shares The amount of shares being minted to the receiver\n     */\n    function _depositIBT(\n        uint256 _ibts,\n        address _ptReceiver,\n        address _ytReceiver\n    ) internal notExpired nonReentrant whenNotPaused returns (uint256 shares) {\n        updateYield(_ytReceiver);\n        uint256 tokenizationFee = PrincipalTokenUtil._computeTokenizationFee(\n            _ibts,\n            address(this),\n            registry\n        );\n        _updateFees(tokenizationFee);\n        shares = _convertIBTsToShares(_ibts - tokenizationFee, false);\n        if (shares == 0) {\n            revert RateError();\n        }\n        _mint(_ptReceiver, shares);\n        emit Mint(msg.sender, _ptReceiver, shares);\n        IYieldToken(yt).mint(_ytReceiver, shares);\n    }\n\n    /**\n     * @dev Internal function for burning PT and YT. Also updates yield before burning\n     * @param _ibts The amount of IBT that are withdrawn for burning shares\n     * @param _receiver The addresss of the receiver of the assets\n     * @param _owner The address of the owner of the shares\n     * @param _ptRate The PT rate (expressed in Ray) to be used\n     * @param _ibtRate The IBT rate (expressed in Ray) to be used\n     * @return shares The amount of owner's shares being burned\n     */\n    function _withdrawShares(\n        uint256 _ibts,\n        address _receiver,\n        address _owner,\n        uint256 _ptRate,\n        uint256 _ibtRate\n    ) internal returns (uint256 shares) {\n        if (_ptRate == 0) {\n            revert RateError();\n        }\n        // convert ibts to shares using provided rates\n        shares = _ibts.mulDiv(_ibtRate, _ptRate, Math.Rounding.Ceil);\n        // burn owner's shares (YT and PT)\n        if (block.timestamp < expiry) {\n            IYieldToken(yt).burnWithoutUpdate(_owner, shares);\n        }\n        _burn(_owner, shares);\n        emit Redeem(_owner, _receiver, shares);\n    }\n\n    /**\n     * @dev Internal function for preparing redeems\n     * @param _shares The amount of shares being redeemed\n     * @param _owner The address of shares' owner\n     */\n    function _beforeRedeem(uint256 _shares, address _owner) internal nonReentrant whenNotPaused {\n        if (_owner != msg.sender) {\n            revert UnauthorizedCaller();\n        }\n        if (_shares > _maxBurnable(_owner)) {\n            revert UnsufficientBalance();\n        }\n        if (block.timestamp >= expiry) {\n            if (!ratesAtExpiryStored) {\n                storeRatesAtExpiry();\n            }\n        } else {\n            updateYield(_owner);\n            IYieldToken(yt).burnWithoutUpdate(_owner, _shares);\n        }\n        _burn(_owner, _shares);\n    }\n\n    /**\n     * @dev Internal function for preparing withdraw\n     * @param _assets The amount of assets to withdraw\n     * @param _owner The address of shares' owner\n     */\n    function _beforeWithdraw(uint256 _assets, address _owner) internal whenNotPaused nonReentrant {\n        if (_owner != msg.sender) {\n            revert UnauthorizedCaller();\n        }\n        if (block.timestamp >= expiry) {\n            if (!ratesAtExpiryStored) {\n                storeRatesAtExpiry();\n            }\n        } else {\n            updateYield(_owner);\n        }\n        if (maxWithdraw(_owner) < _assets) {\n            revert UnsufficientBalance();\n        }\n    }\n\n    /**\n     * @dev Internal function for handling the claims of caller's unclaimed yield\n     * @return yieldInIBT The unclaimed yield in IBT that is about to be claimed\n     */\n    function _claimYield() internal returns (uint256 yieldInIBT) {\n        yieldInIBT = updateYield(msg.sender);\n        if (yieldInIBT == 0) {\n            return 0;\n        } else {\n            yieldOfUserInIBT[msg.sender] = 0;\n            uint256 yieldFeeInIBT = PrincipalTokenUtil._computeYieldFee(yieldInIBT, registry);\n            _updateFees(yieldFeeInIBT);\n            yieldInIBT -= yieldFeeInIBT;\n            emit YieldClaimed(msg.sender, msg.sender, yieldInIBT);\n        }\n    }\n\n    /**\n     * @notice Computes the maximum amount of burnable shares for a user\n     * @param _user The address of the user\n     * @return maxBurnable The maximum amount of burnable shares\n     */\n    function _maxBurnable(address _user) internal view returns (uint256 maxBurnable) {\n        if (block.timestamp >= expiry) {\n            maxBurnable = balanceOf(_user);\n        } else {\n            uint256 ptBalance = balanceOf(_user);\n            uint256 ytBalance = IYieldToken(yt).balanceOf(_user);\n            maxBurnable = (ptBalance > ytBalance) ? ytBalance : ptBalance;\n        }\n    }\n\n    /**\n     * @dev Internal function for updating PT and IBT rates i.e. depegging PT if negative yield happened\n     */\n    function _updatePTandIBTRates() internal returns (uint256 _ptRate, uint256 _ibtRate) {\n        if (block.timestamp >= expiry) {\n            if (!ratesAtExpiryStored) {\n                storeRatesAtExpiry();\n            }\n        }\n        (_ptRate, _ibtRate) = _getPTandIBTRates(false);\n        if (block.timestamp < expiry) {\n            if (_ibtRate != ibtRate) {\n                ibtRate = _ibtRate;\n            }\n            if (_ptRate != ptRate) {"
    }
  ]
}