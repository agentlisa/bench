{
  "Title": "M-1: Corruptible Upgradability Pattern",
  "Content": "# Issue M-1: Corruptible Upgradability Pattern \n\nSource: https://github.com/sherlock-audit/2024-05-midas-judging/issues/109 \n\n## Found by \n0xb0k0, 0xjarix, Kalogerone, PNS, ZdravkoHr., charles\\_\\_cheerful, meltedblocks, nfmelendez, pkqs90, tpiliposian, yovchev\\_yoan\n\n## Summary\n\nStorage of DepositVault/RedemptionVault/mTBILL contracts might be corrupted during an upgrade.\n\n## Vulnerability Detail\n\nFollowing are the inheritance of the DepositVault/RedemptionVault/mTBILL contracts.\n\nNote: The contracts highlighted in Orange mean that there are no gap slots defined. The contracts highlighted in Green mean that gap slots have been defined\n\n```mermaid\ngraph BT;\n    classDef nogap fill:#f96;\n    classDef hasgap fill:#99cc00;\n    DepositVault:::hasgap-->ManageableVault:::nogap\n    RedemptionVault:::hasgap-->ManageableVault:::nogap\n    ManageableVault:::nogap-->Pausable:::nogap\n    ManageableVault:::nogap-->Greenlistable:::nogap\n    Greenlistable:::nogap-->WithMidasAccessControl:::nogap\n```\n\n```mermaid\ngraph BT;\n    classDef nogap fill:#f96;\n    classDef hasgap fill:#99cc00;\n    mTBILL:::hasgap-->ERC20PausableUpgradeable:::hasgap\n    mTBILL:::hasgap-->Blacklistable:::nogap\n    Blacklistable:::nogap-->WithMidasAccessControl:::nogap\n```\n\nThe DepositVault/RedemptionVault/mTBILL contracts are meant to be upgradeable. However, it inherits contracts that are not upgrade-safe.\n\nThe gap storage has been implemented on the DepositVault/RedemptionVault/mTBILL/ERC20PausableUpgradeable.\n\nHowever, no gap storage is implemented on ManageableVault/Pausable/Greenlistable/Blacklistable/WithMidasAccessControl. Among these contracts, ManageableVault and WithMidasAccessControl are contracts with defined variables (non pure-function), and they should have gaps as well.\n\nWithout gaps, adding new storage variables to any of these contracts can potentially overwrite the beginning of the storage layout of the child contract, causing critical misbehaviors in the system.\n\n## Impact\n\nStorage of DepositVault/RedemptionVault/mTBILL contracts might be corrupted during upgrading.\n\n## Code Snippet\n\n- https://github.com/sherlock-audit/2024-05-midas/blob/main/midas-contracts/contracts/abstract/ManageableVault.sol#L24\n- https://github.com/sherlock-audit/2024-05-midas/blob/main/midas-contracts/contracts/access/WithMidasAccessControl.sol#L12\n\n## Tool used\n\nManual review\n\n## Recommendation\n\nAdd gaps for non pure-function contracts: ManageableVault and WithMidasAccessControl.\n\n\n\n## Discussion\n\n**0xhsp**\n\nEscalate\nThis issue is at best low severity, gap storage is not a must to have, no gap storage in ManageableVault / WithMidasAccessControl indicates sponsor won't add new variables to these contracts, even if they have to, they can add new variables in the child contracts.\n\n**sherlock-admin3**\n\n> Escalate\n> This issue is at best low severity, gap storage is not a must to have, no gap storage in ManageableVault / WithMidasAccessControl indicates sponsor won't add new variables to these contracts, even if they have to, they can add new variables in the child contracts.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**MxAxM**\n\n> Escalate This issue is at best low severity, gap storage is not a must to have, no gap storage in ManageableVault / WithMidasAccessControl indicates sponsor won't add new variables to these contracts, even if they have to, they can add new variables in the child contracts.\n\nThis contract is supposed to be upgradeable which means storage gap is required \nAlso this issue is considered valid at previous sherlock contests, refer to : https://github.com/sherlock-audit/2022-09-notional-judging/issues/64\n\naccording to sherlock docs : if the protocol design has a highly complex and branched set of contract inheritance with storage gaps inconsistently applied throughout and the submission clearly describes the necessity of storage gaps it can be considered a valid medium.\n\n**serial-coder**\n\n> This contract is supposed to be upgradeable which means storage gap is required Also this issue is considered valid at previous sherlock contests, refer to : [sherlock-audit/2022-09-notional-judging#64](https://github.com/sherlock-audit/2022-09-notional-judging/issues/64)\n\nBut why my issue (https://github.com/sherlock-audit/2023-06-dinari-judging/issues/110) was rejected in the Dinari contest?\n\nThis issue is too subjective, IMO. Would like to see the sponsor's perspective.\n\n**MxAxM**\n\n> > This contract is supposed to be upgradeable which means storage gap is required Also this issue is considered valid at previous sherlock contests, refer to : [sherlock-audit/2022-09-notional-judging#64](https://github.com/sherlock-audit/2022-09-notional-judging/issues/64)\n> \n> But why my issue ([sherlock-audit/2023-06-dinari-judging#110](https://github.com/sherlock-audit/2023-06-dinari-judging/issues/110)) was rejected in the Dinari contest?\n> \n> This issue is too subjective, IMO. Would like to see the sponsor's perspective.\n\nIt's an issue if sponsor wants to upgrade the protocol, it's valid since sponsor didn't list this as a known issue \n\naccording to sherlock docs : if the protocol design has a highly complex and branched set of contract inheritance with storage gaps inconsistently applied throughout and the submission clearly describes the necessity of storage gaps it can be considered a valid medium.\n\n**pronobis4**\n\nThis may look planned, but there is no linear/simple inheritance here, just a more convoluted tree where many children inherit from the same contracts, so it will be difficult to make changes if the underlying contracts are not prepared properly.\nMEDIUM\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/RedDuck-Software/midas-contracts/pull/47\n\n\n**WangSecurity**\n\nI agree with the Lead Judge here. Let's look at the complete rule:\n\n> Use of Storage gaps: Simple contracts with one of the parent contract not implementing storage gaps are considered low/informational.\nException: However, if the protocol design has a highly complex and branched set of contract inheritance with storage gaps inconsistently applied throughout and the submission clearly describes the necessity of storage gaps it can be considered a valid medium. [Example](https://github.com/sherlock-audit/2022-09-notional-judging/issues/64)\n\nAs we see it's not one of the parent contract not implementing storage gaps and the submission clearly explained the necessity of storage gaps here. But, I understand the rule is quite vague, we'll work on it.\n\nPlanning to reject the escalation and leave the issue as it is.\n\n**WangSecurity**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xhsp](https://github.com/sherlock-audit/2024-05-midas-judging/issues/109/#issuecomment-2155883984): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/332",
  "Code": [
    {
      "filename": "midas-contracts/contracts/abstract/ManageableVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IERC20MetadataUpgradeable as IERC20Metadata} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {EnumerableSetUpgradeable as EnumerableSet} from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../interfaces/IManageableVault.sol\";\nimport \"../interfaces/IMTbill.sol\";\nimport \"../interfaces/IDataFeed.sol\";\n\nimport \"../access/Greenlistable.sol\";\n\nimport \"../libraries/DecimalsCorrectionLibrary.sol\";\nimport \"../access/Pausable.sol\";\n\n/**\n * @title ManageableVault\n * @author RedDuck Software\n * @notice Contract with base Vault methods\n */\nabstract contract ManageableVault is Greenlistable, Pausable, IManageableVault {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using DecimalsCorrectionLibrary for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice address that represents off-chain USD bank transfer\n     */\n    address public constant MANUAL_FULLFILMENT_TOKEN = address(0x0);\n\n    /**\n     * @notice 100 percent with base 100\n     * @dev for example, 10% will be (10 * 100)%\n     */\n    uint256 public constant ONE_HUNDRED_PERCENT = 100 * 100;\n    /**\n     * @notice mTBILL token\n     */\n    IMTbill public mTBILL;\n\n    /**\n     * @notice address to which USD and mTokens will be sent\n     */\n    address public tokensReceiver;\n\n    /**\n     * @dev tokens that can be used as USD representation\n     */\n    EnumerableSet.AddressSet internal _paymentTokens;\n\n    /**\n     * @dev checks that msg.sender do have a vaultRole() role\n     */\n    modifier onlyVaultAdmin() {\n        _onlyRole(vaultRole(), msg.sender);\n        _;\n    }\n\n    /**\n     * @dev upgradeable pattern contract`s initializer\n     * @param _ac address of MidasAccessControll contract\n     * @param _mTBILL address of mTBILL token\n     * @param _tokensReceiver address to which USD and mTokens will be sent\n     */\n    // solhint-disable func-name-mixedcase\n    function __ManageableVault_init(\n        address _ac,\n        address _mTBILL,\n        address _tokensReceiver\n    ) internal onlyInitializing {\n        require(_mTBILL != address(0), \"zero address\");\n        require(_tokensReceiver != address(0), \"zero address\");\n        require(_tokensReceiver != address(this), \"invalid address\");\n\n        mTBILL = IMTbill(_mTBILL);\n        __Greenlistable_init(_ac);\n        __Pausable_init(_ac);\n\n        tokensReceiver = _tokensReceiver;\n    }\n\n    /**\n     * @notice withdraws `amount` of a given `token` from the contract.\n     * can be called only from permissioned actor.\n     * @param token token address\n     * @param amount token amount\n     * @param withdrawTo withdraw destination address\n     */\n    function withdrawToken(\n        address token,\n        uint256 amount,\n        address withdrawTo\n    ) external onlyVaultAdmin {\n        IERC20(token).safeTransfer(withdrawTo, amount);\n\n        emit WithdrawToken(msg.sender, token, withdrawTo, amount);\n    }\n\n    /**\n     * @inheritdoc IManageableVault\n     * @dev reverts if token is already added\n     */\n    function addPaymentToken(address token) external onlyVaultAdmin {\n        require(_paymentTokens.add(token), \"MV: already added\");\n        emit AddPaymentToken(token, msg.sender);\n    }\n\n    /**\n     * @inheritdoc IManageableVault\n     * @dev reverts if token is not presented\n     */\n    function removePaymentToken(address token) external onlyVaultAdmin {\n        require(_paymentTokens.remove(token), \"MV: not exists\");\n        emit RemovePaymentToken(token, msg.sender);\n    }\n\n    /**\n     * @notice returns array of stablecoins supported by the vault\n     * can be called only from permissioned actor.\n     * @return paymentTokens array of payment tokens\n     */\n    function getPaymentTokens() external view returns (address[] memory) {\n        return _paymentTokens.values();\n    }\n\n    /**\n     * @notice AC role of vault administrator\n     * @return role bytes32 role\n     */\n    function vaultRole() public view virtual returns (bytes32);\n\n    /**\n     * @notice AC role of vault`s pauser\n     * @return role bytes32 role\n     */\n    function pauseAdminRole() public view override returns (bytes32) {\n        return vaultRole();\n    }\n\n    /**\n     * @dev do safeTransferFrom on a given token\n     * and converts `amount` from base18\n     * to amount with a correct precision. Sends tokens\n     * from `msg.sender` to `tokensReceiver`\n     * @param token address of token\n     * @param amount amount of `token` to transfer from `user`\n     */\n    function _tokenTransferFromUser(address token, uint256 amount) internal {\n        IERC20(token).safeTransferFrom(\n            msg.sender,\n            tokensReceiver,\n            amount.convertFromBase18(_tokenDecimals(token))\n        );\n    }\n\n    /**\n     * @dev retreives decimals of a given `token`\n     * @param token address of token\n     * @return decimals decinmals value of a given `token`\n     */\n    function _tokenDecimals(address token) internal view returns (uint8) {\n        return IERC20Metadata(token).decimals();\n    }\n\n    /**\n     * @dev checks that `token` is presented in `_paymentTokens`\n     * @param token address of token\n     */\n    function _requireTokenExists(address token) internal view virtual {\n        require(_paymentTokens.contains(token), \"MV: token not exists\");\n    }\n}"
    },
    {
      "filename": "midas-contracts/contracts/access/WithMidasAccessControl.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./MidasAccessControl.sol\";\nimport \"../abstract/MidasInitializable.sol\";\n\n/**\n * @title WithMidasAccessControl\n * @notice Base contract that consumes MidasAccessControl\n * @author RedDuck Software\n */\nabstract contract WithMidasAccessControl is\n    MidasInitializable,\n    MidasAccessControlRoles\n{\n    /**\n     * @notice admin role\n     */\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @notice MidasAccessControl contract address\n     */\n    MidasAccessControl public accessControl;\n\n    /**\n     * @dev checks that given `address` have `role`\n     */\n    modifier onlyRole(bytes32 role, address account) {\n        _onlyRole(role, account);\n        _;\n    }\n\n    /**\n     * @dev checks that given `address` do not have `role`\n     */\n    modifier onlyNotRole(bytes32 role, address account) {\n        _onlyNotRole(role, account);\n        _;\n    }\n\n    /**\n     * @dev upgradeable pattern contract`s initializer\n     */\n    // solhint-disable func-name-mixedcase\n    function __WithMidasAccessControl_init(address _accessControl)\n        internal\n        onlyInitializing\n    {\n        require(_accessControl != address(0), \"zero address\");\n        accessControl = MidasAccessControl(_accessControl);\n    }\n\n    /**\n     * @dev checks that given `address` have `role`\n     */\n    function _onlyRole(bytes32 role, address account) internal view {\n        require(accessControl.hasRole(role, account), \"WMAC: hasnt role\");\n    }\n\n    /**\n     * @dev checks that given `address` do not have `role`\n     */\n    function _onlyNotRole(bytes32 role, address account) internal view {\n        require(!accessControl.hasRole(role, account), \"WMAC: has role\");\n    }\n}"
    }
  ]
}