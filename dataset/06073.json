{
  "Title": "[M-11] Incorrect address is set as Wormhole Bridge, which breaks deploy",
  "Content": "\nWormhole Bridge will have incorrect address, which disables whole TemporalGovernance contract and therefore administration of Moonbeam. But during deployment markets are initialized with initial token amounts to prevent exploits, therefore TemporalGovernance must own this initial tokens. But because of incorrect bridge address TemporalGovernance can't perform any action and these tokens are brick.\nProtocol needs redeployment and loses initial tokens.\n\n### Proof of Concept\n\nTo grab this report easily I divided it into 3 parts\n\n1.  Why `WORMHOLE_CORE` set incorrectly\n\nThere is no config for Base Mainnet, however this comment states for used parameters: <br><https://github.com/code-423n4/2023-07-moonwell/blob/fced18035107a345c31c9a9497d0da09105df4df/test/proposals/mips/mip00.sol#L55-L61>\n\n```solidity\n    /// --------------------------------------------------------------------------------------------------///\n    /// Chain Name\t       Wormhole Chain ID   Network ID\tAddress                                      |///\n    ///  Ethereum (Goerli)   \t  2\t                5\t    0x706abc4E45D419950511e474C7B9Ed348A4a716c   |///\n    ///  Ethereum (Sepolia)\t  10002          11155111\t    0x4a8bc80Ed5a4067f1CCf107057b8270E0cC11A78   |///\n    ///  Base\t                 30    \t        84531\t    0xA31aa3FDb7aF7Db93d18DDA4e19F811342EDF780   |///\n    ///  Moonbeam\t             16\t             1284 \t    0xC8e2b0cD52Cf01b0Ce87d389Daa3d414d4cE29f3   |///\n    /// --------------------------------------------------------------------------------------------------///\n```\n\nWhy to treat this comment? Other parameters are correct except Base Network ID. But Base Network ID has reflection in code, described in #114.\n0xA31aa3FDb7aF7Db93d18DDA4e19F811342EDF780 is address of Wormhole Token Bridge on Base Testnet [according to docs](https://docs.wormhole.com/wormhole/supported-environments/evm#base) and this address has no code [in Base Mainnet](https://basescan.org/address/0xA31aa3FDb7aF7Db93d18DDA4e19F811342EDF780).\n\n2.  Why governor can't execute proposals with incorrect address of Wormhole Bridge\n\nProposal execution will revert here because address `wormholeBridge` doesn't contain code: <br><https://github.com/code-423n4/2023-07-moonwell/blob/fced18035107a345c31c9a9497d0da09105df4df/src/core/Governance/TemporalGovernor.sol#L344-L350>\n\n```solidity\n    function _executeProposal(bytes memory VAA, bool overrideDelay) private {\n        // This call accepts single VAAs and headless VAAs\n        (\n            IWormhole.VM memory vm,\n            bool valid,\n            string memory reason\n        ) = wormholeBridge.parseAndVerifyVM(VAA);\n        ...\n    }\n```\n\n3.  Impact of inability to execute proposals in TemporalGovernor.sol\n\nHere you can see that deployer should provide initial amounts of tokens to initialize markets:\n\n```solidity\n    /// @notice the deployer should have both USDC, WETH and any other assets that will be started as\n    /// listed to be able to deploy on base. This allows the deployer to be able to initialize the\n    /// markets with a balance to avoid exploits\n    function deploy(Addresses addresses, address) public {\n    ...\n    }\n```\n\nAnd here governor approves underlying token to MToken and mints initial mTokens. It means that governor has tokens on balance.\n\n```solidity\n    function build(Addresses addresses) public {\n        /// Unitroller configuration\n        _pushCrossChainAction(\n            addresses.getAddress(\"UNITROLLER\"),\n            abi.encodeWithSignature(\"_acceptAdmin()\"),\n            \"Temporal governor accepts admin on Unitroller\"\n        );\n\n        ...\n\n        /// set mint unpaused for all of the deployed MTokens\n        unchecked {\n            for (uint256 i = 0; i < cTokenConfigs.length; i++) {\n                Configs.CTokenConfiguration memory config = cTokenConfigs[i];\n\n                address cTokenAddress = addresses.getAddress(\n                    config.addressesString\n                );\n\n                _pushCrossChainAction(\n                    unitrollerAddress,\n                    abi.encodeWithSignature(\n                        \"_setMintPaused(address,bool)\",\n                        cTokenAddress,\n                        false\n                    ),\n                    \"Unpause MToken market\"\n                );\n\n                /// Approvals\n                _pushCrossChainAction(\n                    config.tokenAddress,\n                    abi.encodeWithSignature(\n                        \"approve(address,uint256)\",\n                        cTokenAddress,\n                        initialMintAmount\n                    ),\n                    \"Approve underlying token to be spent by market\"\n                );\n\n                /// Initialize markets\n                _pushCrossChainAction(\n                    cTokenAddress,\n                    abi.encodeWithSignature(\"mint(uint256)\", initialMintAmount),\n                    \"Initialize token market to prevent exploit\"\n                );\n\n                ...\n            }\n        }\n\n        ...\n    }\n```\n\nTo conclude, there is no way to return the tokens from the TemporalGovernor intended for market initialization\n\n### Recommended Mitigation Steps\n\nChange `WORMHOLE_CORE` to 0xbebdb6C8ddC678FfA9f8748f85C815C556Dd8ac6 [according to docs](https://docs.wormhole.com/wormhole/supported-environments/evm#base)\n\n**[ElliotFriedman (Moonwell) disputed and commented](https://github.com/code-423n4/2023-07-moonwell-findings/issues/118#issuecomment-1664491379):**\n > This is correct on base goerli, however we have not added base mainnet contract yet as it has not been deployed. \n\n > This can't be a high or even medium risk bug because this is an issue in our testnet deploy configuration.\n\n**[alcueca (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-07-moonwell-findings/issues/118#issuecomment-1687098362):**\n > Upon discussion with the sponsor about differences between this issue and #114, and actual impact of this issue, I'm instating Medium severity.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-moonwell",
  "Code": [
    {
      "filename": "test/proposals/mips/mip00.sol",
      "content": "//SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@forge-std/Test.sol\";\n\nimport {TransparentUpgradeableProxy, ITransparentUpgradeableProxy} from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport {TimelockController} from \"@openzeppelin/contracts/governance/TimelockController.sol\";\nimport {ProxyAdmin} from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport {IVotes} from \"@openzeppelin/contracts/governance/extensions/GovernorVotes.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport {Proposal} from \"@test/proposals/proposalTypes/Proposal.sol\";\nimport {Addresses} from \"@test/proposals/Addresses.sol\";\nimport {TimelockProposal} from \"@test/proposals/proposalTypes/TimelockProposal.sol\";\n\nimport {Comptroller, ComptrollerInterface} from \"@protocol/core/Comptroller.sol\";\nimport {MErc20Delegate} from \"@protocol/core/MErc20Delegate.sol\";\nimport {MErc20Delegator} from \"@protocol/core/MErc20Delegator.sol\";\n\nimport {PriceOracle} from \"@protocol/core/Oracles/PriceOracle.sol\";\nimport {ChainlinkOracle} from \"@protocol/core/Oracles/ChainlinkOracle.sol\";\nimport {JumpRateModel, InterestRateModel} from \"@protocol/core/IRModels/JumpRateModel.sol\";\nimport {TemporalGovernor} from \"@protocol/core/Governance/TemporalGovernor.sol\";\nimport {IWormhole} from \"@protocol/core/Governance/IWormhole.sol\";\nimport {Unitroller} from \"@protocol/core/Unitroller.sol\";\nimport {MErc20} from \"@protocol/core/MErc20.sol\";\n\nimport {MultiRewardDistributor} from \"@protocol/core/MultiRewardDistributor/MultiRewardDistributor.sol\";\nimport {MultiRewardDistributorCommon} from \"@protocol/core/MultiRewardDistributor/MultiRewardDistributorCommon.sol\";\nimport {WETH9} from \"@protocol/core/router/IWETH.sol\";\n\nimport {FaucetTokenWithPermit} from \"@test/helper/FaucetToken.sol\";\nimport {MockWeth} from \"@test/mock/MockWeth.sol\";\nimport {WETHRouter} from \"@protocol/core/router/WETHRouter.sol\";\nimport {MToken} from \"@protocol/core/MToken.sol\";\nimport {ChainIds} from \"@test/utils/ChainIds.sol\";\n\nimport {Configs} from \"@test/proposals/Configs.sol\";\n\nimport {CrossChainProposal} from \"@test/proposals/proposalTypes/CrossChainProposal.sol\";\n\ncontract mip00 is Proposal, CrossChainProposal, ChainIds, Configs {\n    string public constant name = \"MIP00\";\n    uint256 public constant liquidationIncentive = 1.1e18; /// liquidation incentive is 110%\n    uint256 public constant closeFactor = 5e17; /// close factor is 50%, i.e. seize share\n    uint8 public constant mTokenDecimals = 8; /// all mTokens have 8 decimals\n\n    /// @notice proposal delay time\n    uint256 public constant proposalDelay = 5 minutes;\n\n    /// @notice time before anyone can unpause the contract after a guardian pause\n    uint256 public constant permissionlessUnpauseTime = 30 days;\n\n    /// --------------------------------------------------------------------------------------------------///\n    /// Chain Name\t       Wormhole Chain ID   Network ID\tAddress                                      |///\n    ///  Ethereum (Goerli)   \t  2\t                5\t    0x706abc4E45D419950511e474C7B9Ed348A4a716c   |///\n    ///  Ethereum (Sepolia)\t  10002          11155111\t    0x4a8bc80Ed5a4067f1CCf107057b8270E0cC11A78   |///\n    ///  Base\t                 30    \t        84531\t    0xA31aa3FDb7aF7Db93d18DDA4e19F811342EDF780   |///\n    ///  Moonbeam\t             16\t             1284 \t    0xC8e2b0cD52Cf01b0Ce87d389Daa3d414d4cE29f3   |///\n    /// --------------------------------------------------------------------------------------------------///\n\n    constructor() {\n        _setNonce(2);\n    }\n\n    struct CTokenAddresses {\n        address mTokenImpl;\n        address irModel;\n        address temporalGov;\n        address unitroller;\n    }\n\n    /// @notice the deployer should have both USDC, WETH and any other assets that will be started as\n    /// listed to be able to deploy on base. This allows the deployer to be able to initialize the\n    /// markets with a balance to avoid exploits\n    function deploy(Addresses addresses, address) public {\n        /// ------- TemporalGovernor -------\n\n        console.log(\n            \"deploying governor with wormhole chain id: \",\n            chainIdToWormHoleId[block.chainid],\n            \" as owner\"\n        );\n        console.log(\n            \"governor owner: \",\n            addresses.getAddress(\"MOONBEAM_TIMELOCK\")\n        );\n\n        localInit(addresses);\n\n        {\n            TemporalGovernor.TrustedSender[]\n                memory trustedSenders = new TemporalGovernor.TrustedSender[](1);\n            trustedSenders[0].chainId = chainIdToWormHoleId[block.chainid];\n            trustedSenders[0].addr = addresses.getAddress(\"MOONBEAM_TIMELOCK\");\n\n            require(\n                addresses.getAddress(\"WORMHOLE_CORE\") != address(0),\n                \"MIP00: WORMHOLE_CORE not set\"\n            );\n\n            /// this will be the governor for all the contracts\n            TemporalGovernor governor = new TemporalGovernor(\n                addresses.getAddress(\"WORMHOLE_CORE\"),\n                proposalDelay,\n                permissionlessUnpauseTime,\n                trustedSenders\n            );\n\n            addresses.addAddress(\"TEMPORAL_GOVERNOR\", address(governor));\n        }\n\n        deployAndMint(addresses);\n        init(addresses);\n\n        /// ------- Reward Distributor -------\n\n        {\n            MultiRewardDistributor distributor = new MultiRewardDistributor();\n            addresses.addAddress(\n                \"MULTI_REWARD_DISTRIBUTOR\",\n                address(distributor)\n            );\n        }\n\n        {\n            /// ------- Unitroller/Comptroller -------\n\n            Unitroller unitroller = new Unitroller();\n            Comptroller comptroller = new Comptroller();\n\n            unitroller._setPendingImplementation(address(comptroller));\n            comptroller._become(unitroller);\n\n            addresses.addAddress(\"COMPTROLLER\", address(comptroller));\n            addresses.addAddress(\"UNITROLLER\", address(unitroller));\n\n            ProxyAdmin proxyAdmin = new ProxyAdmin();\n\n            bytes memory initData = abi.encodeWithSignature(\n                \"initialize(address,address)\",\n                address(unitroller),\n                addresses.getAddress(\"GUARDIAN\") /// TODO figure out what the pause guardian is on Base, then replace it\n            );\n\n            TransparentUpgradeableProxy mrdProxy = new TransparentUpgradeableProxy(\n                    addresses.getAddress(\"MULTI_REWARD_DISTRIBUTOR\"),\n                    address(proxyAdmin),\n                    initData\n                );\n\n            addresses.addAddress(\"MRD_PROXY\", address(mrdProxy));\n            addresses.addAddress(\"MRD_PROXY_ADMIN\", address(proxyAdmin));\n        }\n\n        /// ------ MTOKENS -------\n\n        {\n            MErc20Delegate mTokenLogic = new MErc20Delegate();\n            addresses.addAddress(\"MTOKEN_IMPLEMENTATION\", address(mTokenLogic));\n        }\n\n        Configs.CTokenConfiguration[]\n            memory cTokenConfigs = getCTokenConfigurations(block.chainid);\n\n        uint256 cTokenConfigsLength = cTokenConfigs.length;\n        //// create all of the CTokens according to the configuration in Config.sol\n        unchecked {\n            for (uint256 i = 0; i < cTokenConfigsLength; i++) {\n                Configs.CTokenConfiguration memory config = cTokenConfigs[i];\n\n                /// ----- Jump Rate IRM -------\n                {\n                    address irModel = address(\n                        new JumpRateModel(\n                            config.jrm.baseRatePerYear,\n                            config.jrm.multiplierPerYear,\n                            config.jrm.jumpMultiplierPerYear,\n                            config.jrm.kink\n                        )\n                    );\n\n                    addresses.addAddress(\n                        string(\n                            abi.encodePacked(\n                                \"JUMP_RATE_IRM_\",\n                                config.addressesString\n                            )\n                        ),\n                        address(irModel)\n                    );\n                }\n\n                /// stack isn't too deep\n                CTokenAddresses memory addr = CTokenAddresses({\n                    mTokenImpl: addresses.getAddress(\"MTOKEN_IMPLEMENTATION\"),\n                    irModel: addresses.getAddress(\n                        string(\n                            abi.encodePacked(\n                                \"JUMP_RATE_IRM_\",\n                                config.addressesString\n                            )\n                        )\n                    ),\n                    temporalGov: addresses.getAddress(\"TEMPORAL_GOVERNOR\"),\n                    unitroller: addresses.getAddress(\"UNITROLLER\")\n                });\n\n                /// TODO calculate initial exchange rate\n                /// BigNumber.from(\"10\").pow(token.decimals + 8).mul(\"2\");\n                /// (10 ** (18 + 8)) * 2 // 18 decimals example\n                ///    = 2e26\n                /// (10 ** (6 + 8)) * 2 // 6 decimals example\n                ///    = 2e14\n                uint256 initialExchangeRate = (10 **\n                    (ERC20(config.tokenAddress).decimals() + 8)) * 2;\n\n                MErc20Delegator mToken = new MErc20Delegator(\n                    config.tokenAddress,\n                    ComptrollerInterface(addr.unitroller),\n                    InterestRateModel(addr.irModel),\n                    initialExchangeRate,\n                    config.name,\n                    config.symbol,\n                    mTokenDecimals,\n                    payable(addr.temporalGov),\n                    addr.mTokenImpl,\n                    \"\"\n                );\n\n                addresses.addAddress(config.addressesString, address(mToken));\n            }\n        }\n\n        initEmissions(addresses);\n\n        WETHRouter router = new WETHRouter(\n            WETH9(addresses.getAddress(\"WETH\")),\n            MErc20(addresses.getAddress(\"MOONWELL_ETH\"))\n        );\n        addresses.addAddress(\"WETH_ROUTER\", address(router));\n\n        /// deploy oracle, set price oracle\n        ChainlinkOracle oracle = new ChainlinkOracle(\"null_asset\");\n        addresses.addAddress(\"CHAINLINK_ORACLE\", address(oracle));\n    }\n\n    function afterDeploy(Addresses addresses, address) public {\n        ProxyAdmin proxyAdmin = ProxyAdmin(\n            addresses.getAddress(\"MRD_PROXY_ADMIN\")\n        );\n        Unitroller unitroller = Unitroller(addresses.getAddress(\"UNITROLLER\"));\n        address governor = addresses.getAddress(\"TEMPORAL_GOVERNOR\");\n        ChainlinkOracle oracle = ChainlinkOracle(\n            addresses.getAddress(\"CHAINLINK_ORACLE\")\n        );\n\n        /// set proxy admin as the owner of the temporal governor\n        proxyAdmin.transferOwnership(governor);\n\n        Comptroller(address(unitroller))._setPriceOracle(\n            PriceOracle(address(oracle))\n        );\n\n        /// set chainlink oracle on the comptroller implementation contract\n\n        Configs.CTokenConfiguration[]\n            memory cTokenConfigs = getCTokenConfigurations(block.chainid);\n        MToken[] memory mTokens = new MToken[](cTokenConfigs.length);\n        uint256[] memory supplyCaps = new uint256[](cTokenConfigs.length);\n        uint256[] memory borrowCaps = new uint256[](cTokenConfigs.length);\n        //// set mint paused for all of the deployed MTokens\n        unchecked {\n            for (uint256 i = 0; i < cTokenConfigs.length; i++) {\n                Configs.CTokenConfiguration memory config = cTokenConfigs[i];\n                supplyCaps[i] = config.supplyCap;\n                borrowCaps[i] = config.borrowCap;\n\n                oracle.setFeed(\n                    ERC20(config.tokenAddress).symbol(),\n                    config.priceFeed\n                );\n\n                /// list both mUSDC and mETH in the comptroller\n                Comptroller(address(unitroller))._supportMarket(\n                    MToken(addresses.getAddress(config.addressesString))\n                );\n\n                /// set mint paused for all MTokens\n                Comptroller(address(unitroller))._setMintPaused(\n                    MToken(addresses.getAddress(config.addressesString)),\n                    true\n                );\n\n                /// get the mToken\n                mTokens[i] = MToken(\n                    addresses.getAddress(config.addressesString)\n                );\n            }\n        }\n\n        Comptroller(address(unitroller))._setMarketSupplyCaps(\n            mTokens,\n            supplyCaps\n        );\n        Comptroller(address(unitroller))._setMarketBorrowCaps(\n            mTokens,\n            borrowCaps\n        );\n\n        /// set temporal governor as the pending admin\n        unitroller._setPendingAdmin(governor);\n\n        /// set temporal governor as the admin of the chainlink feed\n        oracle.setAdmin(governor);\n    }\n\n    function build(Addresses addresses) public {\n        /// Unitroller configuration\n        _pushCrossChainAction(\n            addresses.getAddress(\"UNITROLLER\"),\n            abi.encodeWithSignature(\"_acceptAdmin()\"),\n            \"Temporal governor accepts admin on Unitroller\"\n        );\n\n        Configs.CTokenConfiguration[]\n            memory cTokenConfigs = getCTokenConfigurations(block.chainid);\n\n        address unitrollerAddress = addresses.getAddress(\"UNITROLLER\");\n\n        /// set mint unpaused for all of the deployed MTokens\n        unchecked {\n            for (uint256 i = 0; i < cTokenConfigs.length; i++) {\n                Configs.CTokenConfiguration memory config = cTokenConfigs[i];\n\n                address cTokenAddress = addresses.getAddress(\n                    config.addressesString\n                );\n\n                _pushCrossChainAction(\n                    unitrollerAddress,\n                    abi.encodeWithSignature(\n                        \"_setMintPaused(address,bool)\",\n                        cTokenAddress,\n                        false\n                    ),\n                    \"Unpause MToken market\"\n                );\n\n                /// Approvals\n                _pushCrossChainAction(\n                    config.tokenAddress,\n                    abi.encodeWithSignature(\n                        \"approve(address,uint256)\",\n                        cTokenAddress,\n                        initialMintAmount\n                    ),\n                    \"Approve underlying token to be spent by market\"\n                );\n\n                /// Initialize markets\n                _pushCrossChainAction(\n                    cTokenAddress,\n                    abi.encodeWithSignature(\"mint(uint256)\", initialMintAmount),\n                    \"Initialize token market to prevent exploit\"\n                );\n\n                /// _setCollateralFactor\n                _pushCrossChainAction(\n                    unitrollerAddress,\n                    abi.encodeWithSignature(\n                        \"_setCollateralFactor(address,uint256)\",\n                        cTokenAddress,\n                        config.collateralFactor\n                    ),\n                    \"Set CF on CToken\"\n                );\n            }\n        }\n\n        _pushCrossChainAction(\n            unitrollerAddress,\n            abi.encodeWithSignature(\n                \"_setLiquidationIncentive(uint256)\",\n                liquidationIncentive\n            ),\n            \"Set CF on CToken\"\n        );\n\n        _pushCrossChainAction(\n            unitrollerAddress,\n            abi.encodeWithSignature(\n                \"_setCloseFactor(uint256)\",\n                closeFactor\n            ),\n            \"Set Close Factor on CToken\"\n        );\n\n        _pushCrossChainAction(\n            addresses.getAddress(\"UNITROLLER\"),\n            abi.encodeWithSignature(\n                \"_setRewardDistributor(address)\",\n                addresses.getAddress(\"MRD_PROXY\")\n            ),\n            \"Set reward distributor on comptroller\"\n        );\n\n        _pushCrossChainAction(\n            addresses.getAddress(\"UNITROLLER\"),\n            abi.encodeWithSignature(\n                \"_setSupplyCapGuardian(address)\",\n                addresses.getAddress(\"GUARDIAN\")\n            ),\n            \"Set supply cap guardian\"\n        );\n\n        _pushCrossChainAction(\n            addresses.getAddress(\"UNITROLLER\"),\n            abi.encodeWithSignature(\n                \"_setBorrowCapGuardian(address)\",\n                addresses.getAddress(\"GUARDIAN\")\n            ),\n            \"Set borrow cap guardian\"\n        );\n\n        _pushCrossChainAction(\n            addresses.getAddress(\"UNITROLLER\"),\n            abi.encodeWithSignature(\n                \"_setPauseGuardian(address)\",\n                addresses.getAddress(\"GUARDIAN\")\n            ),\n            \"Set pause guardian\"\n        );\n\n        /// -------------- EMISSION CONFIGURATION --------------\n\n        EmissionConfig[] memory emissionConfig = getEmissionConfigurations(\n            block.chainid\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < emissionConfig.length; i++) {\n                EmissionConfig memory config = emissionConfig[i];\n                _pushCrossChainAction(\n                    addresses.getAddress(\"MRD_PROXY\"),\n                    abi.encodeWithSignature(\n                        \"_addEmissionConfig(address,address,address,uint256,uint256,uint256)\",\n                        config.mToken,\n                        config.owner,\n                        config.emissionToken,\n                        config.supplyEmissionPerSec,\n                        config.borrowEmissionsPerSec,\n                        config.endTime\n                    ),\n                    \"Add emission configuration\"\n                );\n            }\n        }\n    }\n\n    function run(Addresses addresses, address) public {\n        _simulateCrossChainActions(addresses.getAddress(\"TEMPORAL_GOVERNOR\"));\n    }\n\n    function printCalldata(Addresses addresses) public {\n        printActions(\n            addresses.getAddress(\"TEMPORAL_GOVERNOR\"),\n            addresses.getAddress(\"WORMHOLE_CORE\")\n        );\n    }\n\n    function teardown(Addresses addresses, address) public pure {}\n\n    function validate(Addresses addresses, address deployer) public {\n        TemporalGovernor governor = TemporalGovernor(\n            addresses.getAddress(\"TEMPORAL_GOVERNOR\")\n        );\n\n        /// assert comptroller and unitroller are wired together properly\n        {\n            Unitroller unitroller = Unitroller(\n                addresses.getAddress(\"UNITROLLER\")\n            );\n            Comptroller comptroller = Comptroller(\n                addresses.getAddress(\"COMPTROLLER\")\n            );\n\n            assertEq(comptroller.admin(), deployer);\n            assertEq(comptroller.pendingAdmin(), address(0));\n            assertEq(comptroller.pauseGuardian(), address(0));\n            assertEq(comptroller.borrowCapGuardian(), address(0));\n            assertEq(comptroller.supplyCapGuardian(), address(0));\n            assertEq(address(comptroller.rewardDistributor()), address(0));\n\n            assertEq(\n                Comptroller(address(unitroller)).admin(),\n                addresses.getAddress(\"TEMPORAL_GOVERNOR\")\n            );\n            assertEq(\n                Comptroller(address(unitroller)).pendingAdmin(),\n                address(0)\n            );\n            assertEq(\n                Comptroller(address(unitroller)).pauseGuardian(),\n                addresses.getAddress(\"GUARDIAN\")\n            );\n            assertEq(\n                Comptroller(address(unitroller)).borrowCapGuardian(),\n                addresses.getAddress(\"GUARDIAN\")\n            );\n            assertEq(\n                Comptroller(address(unitroller)).supplyCapGuardian(),\n                addresses.getAddress(\"GUARDIAN\")\n            );\n            assertEq(\n                address(Comptroller(address(unitroller)).rewardDistributor()),\n                addresses.getAddress(\"MRD_PROXY\")\n            );\n\n            assertEq(\n                address(unitroller.comptrollerImplementation()),\n                address(comptroller)\n            );\n            assertEq(\n                address(unitroller.pendingComptrollerImplementation()),\n                address(0)\n            );\n        }\n        /// assert comptroller is owned by deployer as there is no way to change admin\n        {\n            Comptroller comptroller = Comptroller(\n                addresses.getAddress(\"COMPTROLLER\")\n            );\n\n            assertEq(address(comptroller.admin()), deployer);\n        }\n        {\n            MErc20 mEth = MErc20(addresses.getAddress(\"MOONWELL_ETH\"));\n            MErc20 mUsdc = MErc20(addresses.getAddress(\"MOONWELL_USDC\"));\n\n            /// assert initial mToken balances are correct\n            assertTrue(mUsdc.balanceOf(address(governor)) > 0);\n            assertTrue(mEth.balanceOf(address(governor)) > 0);\n\n            /// assert cToken admin is the temporal governor\n            assertEq(address(mUsdc.admin()), address(governor));\n            assertEq(address(mEth.admin()), address(governor));\n\n            /// assert cToken comptroller is correct\n            assertEq(\n                address(mUsdc.comptroller()),\n                addresses.getAddress(\"UNITROLLER\")\n            );\n            assertEq(\n                address(mEth.comptroller()),\n                addresses.getAddress(\"UNITROLLER\")\n            );\n\n            /// assert cToken underlying is correct\n            assertEq(address(mUsdc.underlying()), addresses.getAddress(\"USDC\"));\n            assertEq(address(mEth.underlying()), addresses.getAddress(\"WETH\"));\n\n            /// assert cToken delegate is all uniform\n            assertEq(\n                address(\n                    MErc20Delegator(payable(address(mUsdc))).implementation()\n                ),\n                addresses.getAddress(\"MTOKEN_IMPLEMENTATION\")\n            );\n            assertEq(\n                address(\n                    MErc20Delegator(payable(address(mEth))).implementation()\n                ),\n                addresses.getAddress(\"MTOKEN_IMPLEMENTATION\")\n            );\n\n            uint256 initialExchangeRateUsdc = (10 ** (6 + 8)) * 2;\n            uint256 initialExchangeRateEth = (10 ** (18 + 8)) * 2;\n\n            /// assert cToken initial exchange rate is correct\n            assertEq(mUsdc.exchangeRateCurrent(), initialExchangeRateUsdc);\n            assertEq(mEth.exchangeRateCurrent(), initialExchangeRateEth);\n\n            /// assert cToken name and symbol are correct\n            assertEq(mUsdc.name(), \"Moonwell USDC\");\n            assertEq(mEth.name(), \"Moonwell ETH\");\n            assertEq(mUsdc.symbol(), \"mUSDC\");\n            assertEq(mEth.symbol(), \"mETH\");\n\n            assertEq(mUsdc.decimals(), mTokenDecimals);\n            assertEq(mEth.decimals(), mTokenDecimals);\n\n            /// assert admin of implementation contract is address 0 so it cannot be initialized\n            assertEq(\n                MErc20Delegate(addresses.getAddress(\"MTOKEN_IMPLEMENTATION\"))\n                    .admin(),\n                address(0)\n            );\n        }\n\n        /// assert WETH router is properly wired into the system\n        {\n            WETHRouter router = WETHRouter(\n                payable(addresses.getAddress(\"WETH_ROUTER\"))\n            );\n            assertEq(address(router.weth()), addresses.getAddress(\"WETH\"));\n            assertEq(\n                address(router.mToken()),\n                addresses.getAddress(\"MOONWELL_ETH\")\n            );\n        }\n\n        /// assert multi reward distributor proxy is wired into unitroller correctly\n        {\n            MultiRewardDistributor distributor = MultiRewardDistributor(\n                addresses.getAddress(\"MRD_PROXY\")\n            );\n            assertEq(\n                address(distributor.comptroller()),\n                addresses.getAddress(\"UNITROLLER\")\n            );\n            assertEq(\n                address(distributor.pauseGuardian()),\n                addresses.getAddress(\"GUARDIAN\")\n            );\n            assertEq(distributor.emissionCap(), 100e18);\n            assertEq(distributor.initialIndexConstant(), 1e36);\n        }\n\n        /// assert multi reward distributor comptroller and guardian are unset\n        {\n            MultiRewardDistributor distributor = MultiRewardDistributor(\n                addresses.getAddress(\"MULTI_REWARD_DISTRIBUTOR\")\n            );\n            assertEq(address(distributor.comptroller()), address(0));\n            assertEq(address(distributor.pauseGuardian()), address(0));\n        }\n\n        /// assert proxy admin is owned by temporal governor\n        {\n            ProxyAdmin proxyAdmin = ProxyAdmin(\n                addresses.getAddress(\"MRD_PROXY_ADMIN\")\n            );\n            assertEq(proxyAdmin.owner(), address(governor));\n        }\n\n        /// admin is owned by proxy admin\n        {\n            bytes32 _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n            bytes32 data = vm.load(\n                addresses.getAddress(\"MRD_PROXY\"),\n                _ADMIN_SLOT\n            );\n            assertEq(\n                bytes32(\n                    uint256(uint160(addresses.getAddress(\"MRD_PROXY_ADMIN\")))\n                ),\n                data\n            );\n\n            bytes32 _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n            data = vm.load(\n                addresses.getAddress(\"MRD_PROXY\"),\n                _IMPLEMENTATION_SLOT\n            );\n            assertEq(\n                bytes32(\n                    uint256(\n                        uint160(\n                            addresses.getAddress(\"MULTI_REWARD_DISTRIBUTOR\")\n                        )\n                    )\n                ),\n                data\n            );\n        }\n\n        assertEq(\n            address(governor.wormholeBridge()),\n            addresses.getAddress(\"WORMHOLE_CORE\")\n        );\n\n        assertTrue(\n            governor.isTrustedSender(\n                chainIdToWormHoleId[block.chainid],\n                governor.addressToBytes(\n                    addresses.getAddress(\"MOONBEAM_TIMELOCK\")\n                )\n            )\n        );\n        {\n            Comptroller comptroller = Comptroller(\n                addresses.getAddress(\"UNITROLLER\")\n            );\n\n            assertEq(comptroller.closeFactorMantissa(), closeFactor);\n            assertEq(comptroller.liquidationIncentiveMantissa(), liquidationIncentive);\n\n            Configs.CTokenConfiguration[]\n                memory cTokenConfigs = getCTokenConfigurations(block.chainid);\n\n            unchecked {\n                for (uint256 i = 0; i < cTokenConfigs.length; i++) {\n                    Configs.CTokenConfiguration memory config = cTokenConfigs[\n                        i\n                    ];\n\n                    /// CToken Assertions\n                    assertFalse(\n                        comptroller.mintGuardianPaused(\n                            addresses.getAddress(config.addressesString)\n                        )\n                    );\n                    assertEq(\n                        comptroller.borrowCaps(\n                            addresses.getAddress(config.addressesString)\n                        ),\n                        config.borrowCap\n                    );\n                    assertEq(\n                        comptroller.supplyCaps(\n                            addresses.getAddress(config.addressesString)\n                        ),\n                        config.supplyCap\n                    );\n                    assertEq(\n                        comptroller.supplyCaps(\n                            addresses.getAddress(config.addressesString)\n                        ),\n                        config.supplyCap\n                    );\n\n                    /// assert cToken irModel is correct\n\n                    assertEq(\n                        address(\n                            MToken(addresses.getAddress(config.addressesString))\n                                .interestRateModel()\n                        ),\n                        addresses.getAddress(\n                            string(\n                                abi.encodePacked(\n                                    \"JUMP_RATE_IRM_\",\n                                    config.addressesString\n                                )\n                            )\n                        )\n                    );\n\n                    /// Jump Rate Model Assertions\n                    {\n                        JumpRateModel jrm = JumpRateModel(\n                            addresses.getAddress(\n                                string(\n                                    abi.encodePacked(\n                                        \"JUMP_RATE_IRM_\",\n                                        config.addressesString\n                                    )\n                                )\n                            )\n                        );\n\n                        assertEq(\n                            jrm.baseRatePerTimestamp(),\n                            (config.jrm.baseRatePerYear * 1e18) /\n                                jrm.timestampsPerYear() /\n                                1e18\n                        );\n                        assertEq(\n                            jrm.multiplierPerTimestamp(),\n                            (config.jrm.multiplierPerYear * 1e18) /\n                                jrm.timestampsPerYear() /\n                                1e18\n                        );\n                        assertEq(\n                            jrm.jumpMultiplierPerTimestamp(),\n                            (config.jrm.jumpMultiplierPerYear * 1e18) /\n                                jrm.timestampsPerYear() /\n                                1e18\n                        );\n                        assertEq(jrm.kink(), config.jrm.kink);\n                    }\n                }\n            }\n        }\n\n        {\n            EmissionConfig[] memory emissionConfig = getEmissionConfigurations(\n                block.chainid\n            );\n            MultiRewardDistributor distributor = MultiRewardDistributor(\n                addresses.getAddress(\"MRD_PROXY\")\n            );\n\n            unchecked {\n                for (uint256 i = 0; i < emissionConfig.length; i++) {\n                    EmissionConfig memory config = emissionConfig[i];\n                    MultiRewardDistributorCommon.MarketConfig\n                        memory marketConfig = distributor.getConfigForMarket(\n                            MToken(config.mToken),\n                            config.emissionToken\n                        );\n\n                    assertEq(marketConfig.owner, config.owner);\n                    assertEq(marketConfig.emissionToken, config.emissionToken);\n                    assertEq(marketConfig.endTime, config.endTime);\n                    assertEq(\n                        marketConfig.supplyEmissionsPerSec,\n                        config.supplyEmissionPerSec\n                    );\n                    assertEq(\n                        marketConfig.borrowEmissionsPerSec,\n                        config.borrowEmissionsPerSec\n                    );\n                    assertEq(marketConfig.supplyGlobalIndex, 1e36);\n                    assertEq(marketConfig.borrowGlobalIndex, 1e36);\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/core/Governance/TemporalGovernor.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IWormhole} from \"@protocol/core/Governance/IWormhole.sol\";\n\nimport {ITemporalGovernor} from \"@protocol/core/Governance/ITemporalGovernor.sol\";\n\n/// @notice contract that governs the Base deployment of moonwell leveraging the wormhole bridge\n/// as the source of truth. Wormhole will be fed in actions from the moonbeam chain and this contract\n/// will execute them on base.\n/// There are a few assumptions that are made in this contract:\n/// 1. Wormhole is secure and will not send malicious messages or be deactivated.\n/// 2. Moonbeam is secure.\n/// 3. Governance on Moonbeam cannot be compromised.\n/// if 1. is untrue and wormhole is deactivated, then this contract will be unable to upgrade the base instance\n/// if 1. is untrue and wormhole sends malicious messages"
    }
  ]
}