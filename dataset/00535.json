{
  "Title": "H-3: LP Tokens always valued at 3 PTs",
  "Content": "# Issue H-3: LP Tokens always valued at 3 PTs \n\nSource: https://github.com/sherlock-audit/2024-01-napier-judging/issues/90 \n\n## Found by \nxiaoming90\n## Summary\n\nLP Tokens are always valued at 3 PTs. As a result, users of the AMM pool might receive fewer assets/PTs than expected. The AMM pool might be unfairly arbitraged, resulting in a loss for the pool's LPs.\n\n## Vulnerability Detail\n\nThe Napier AMM pool facilitates trade between underlying assets and PTs. The PTs in the pool are represented by the Curve's Base LP Token of the Curve's pool that holds the PTs. The Napier AMM pool and Router math assumes that the Base LP Token is equivalent to 3 times the amount of PTs, as shown below. When the pool is initially deployed, it is correct that the LP token is equivalent to 3 times the amount of PT.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/v1-pool/src/libs/PoolMath.sol#L106\n\n\n```solidity\nFile: PoolMath.sol\n83:     int256 internal constant N_COINS = 3;\n..SNIP..\n96:     function swapExactBaseLpTokenForUnderlying(PoolState memory pool, uint256 exactBaseLptIn)\n97:         internal\n..SNIP..\n105:             // Note: Here we are multiplying by N_COINS because the swap formula is defined in terms of the amount of PT being swapped.\n106:             // BaseLpt is equivalent to 3 times the amount of PT due to the initial deposit of 1:1:1:1=pt1:pt2:pt3:Lp share in Curve pool.\n107:             exactBaseLptIn.neg() * N_COINS\n..SNIP..\n120:     function swapUnderlyingForExactBaseLpToken(PoolState memory pool, uint256 exactBaseLptOut)\n..SNIP..\n125:         (int256 _netUnderlyingToAccount18, int256 _netUnderlyingFee18, int256 _netUnderlyingToProtocol18) = executeSwap(\n126:             pool,\n127:             // Note: sign is defined from the perspective of the swapper.\n128:             // positive because the swapper is buying pt\n129:             exactBaseLptOut.toInt256() * N_COINS\n```\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/v1-pool/src/NapierPool.sol#L48\n\n```solidity\nFile: NapierPool.sol\n47:     /// @dev Number of coins in the BasePool\n48:     uint256 internal constant N_COINS = 3;\n..SNIP..\n226:                     totalBaseLptTimesN: baseLptUsed * N_COINS,\n..SNIP..\n584:             totalBaseLptTimesN: totalBaseLpt * N_COINS,\n```\n\nIn Curve, LP tokens are generally priced by computing the underlying tokens per share, hence dividing the total underlying token amounts by the total supply of the LP token. Given that the underlying assets in Curve’s stable swap are pegged to each other, the invariant’s $D$ value can be computed to estimate the total value of the underlying tokens.\n\nCurve itself provides a function `get_virtual_price` that computes the price of the LP token by dividing $D$ with the total supply. \n\nNote that for LP tokens, the ratio of the total underlying value and the total supply will grow (fee mechanism) over time. Thus, the virtual price’s value will increase over time.\n\nThis means the LP token will be worth more than 3 PTs in the Curve Pool over time. However, the Naiper AMM pool still values its LP token at a constant value of 3 PTs. This discrepancy between the value of the LP tokens in the Napier AMM pool and Curve pool might result in various issues, such as the following:\n\n- Investors brought LP tokens at the price of 3.X PT from the market. The LP tokens are deposited into or swap into the Napier AMM pool. The Naiper Pool will always assume that the price of the LP token is 3 PTs, thus shortchanging the number of assets or PTs returned to users.\n- Potential arbitrage opportunity where malicious users obtain the LP token from the Naiper AMM pool at a value of 3 PT and redeem the LP token at a value higher than 3 PTs, pocketing the differences.\n\n## Impact\n\nUsers of the AMM pool might receive fewer assets/PTs than expected. The AMM pool might be unfairly arbitraged, resulting in a loss for the pool's LPs.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/v1-pool/src/libs/PoolMath.sol#L106\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/v1-pool/src/NapierPool.sol#L48\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nNaiper and Pendle share the same core math for their AMM pool.\n\nIn Pendle, the AMM stores the PTs and SY (Standard Yield Token). When performing any operation (e.g., deposit, swap), the SY will be converted to the underlying assets based on SY's current rate before performing any math operation. If it is a SY (wstETH), the SY's rate will be the [current exchange rate](https://github.com/pendle-finance/pendle-core-v2-public/blob/39f3a613e2ec55dc38a7d3c562529d67844a263a/contracts/core/StandardizedYield/implementations/PendleWstEthSY.sol#L88) for wstETH to stETH/ETH. One could also think the AMM's reserve is PTs and Underlying Assets under the hood.\n\nIn Napier, the AMM stores the PTs and Curve's LP tokens. When performing any operation, the math will always convert the LP token to underlying assets using a static exchange rate of 3. However, this is incorrect, as the value of an LP token will grow over time. The AMM should value the LP tokens based on their current value. The virtual price of the LP token and other information can be leveraged to derive the current value of the LP tokens to facilitate the math operation within the pool.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid; high(9)\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/napierfi/v1-pool/pull/159.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/171",
  "Code": [
    {
      "filename": "v1-pool/src/libs/PoolMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\n/// @notice This library contains the math used in NapierPool.\n/// @dev Taken and modified from Pendle V2: https://github.com/pendle-finance/pendle-core-v2-public/blob/163783b09014e515b645b83936fec32c5731d092/contracts/core/Market/MarketMathCore.sol\n/// @dev Taken and modified from Notional : https://github.com/notional-finance/contracts-v2/blob/1845605ab0d9eec9b5dd374cf7c246957b534f85/contracts/internal/markets/Market.sol\n/// @dev Naming convention:\n/// - `pt` => baseLpt: BasePool LP token\n/// - `asset` => `underlying`: underlying asset\n/// - `totalPt` => `totalBaseLptTimesN`: total BasePool LP token reserve in the pool multiplied by the number of BasePool assets (N)\n/// See NapierPool.sol for more details.\n/// - `totalAsset` => `totalUnderlying`: total underlying asset reserve in the pool\n/// - `executeTradeCore` function =>  `executeSwap` function\n/// - `calculateTrade` function => `calculateSwap` function\n/// - `getMarketPreCompute` function => `computeAmmParameters` function\n/// - `setNewMarketStateTrade` function => `_setPostPoolState` function\n/// @dev All functions in this library are view functions.\n/// @dev Changes:\n///  1) Math library dependency from LogExpMath to PRBMath etc.\n///  2) Swap functions multiply the parameter `exactPtToAccount` by N(=3) to make it equivalent to the amount of PT being swapped.\n///  3) Swap functions divide the computed underlying swap result by N.\n///  3) Remove some redundant checks (e.g. check for maturity)\n///  4) Remove some redundant variables (e.g. `totalAsset` in `MarketPreCompute`)\n///  5) Remove some redundant functions (`addLiquidity` and `removeLiquidity`)\n\n// libraries\nimport {Math} from \"@openzeppelin/contracts@4.9.3/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {FixedPointMathLib} from \"./FixedPointMathLib.sol\";\nimport {SignedMath} from \"./SignedMath.sol\";\nimport {sd, ln, intoInt256} from \"@prb/math/SD59x18.sol\"; // used for logarithm operation\nimport {ud, exp, intoUint256} from \"@prb/math/UD60x18.sol\"; // used for exp operation\nimport {Errors} from \"./Errors.sol\";\n\n/// @param totalBaseLptTimesN - Reserve Curve v2 Tricrypto 3PrincipalToken Pool LP token x times N(=# of Curve v2 Pool assets) in 18 decimals\n/// @param totalUnderlying18 - Reserve underlying asset in 18 decimals\n/// @param scalarRoot - Scalar root for NapierPool (See whitepaper)\n/// @param maturity - Expiry of NapierPool (Unix timestamp)\n/// @param lnFeeRateRoot - Logarithmic fee rate root\n/// @param protocolFeePercent - Protocol fee percent (base 100)\n/// @param lastLnImpliedRate - Last ln implied rate\nstruct PoolState {\n    uint256 totalBaseLptTimesN;\n    uint256 totalUnderlying18;\n    /// immutable variables ///\n    uint256 scalarRoot;\n    uint256 maturity;\n    /// fee data ///\n    uint256 lnFeeRateRoot;\n    uint256 protocolFeePercent; // 100=100%\n    /// last trade data ///\n    uint256 lastLnImpliedRate;\n}\n\n/// @notice Variables that are used to compute the swap result\n/// @dev params that are expensive to compute, therefore we pre-compute them\nstruct PoolPreCompute {\n    int256 rateScalar;\n    int256 rateAnchor;\n    int256 feeRate;\n}\n\n/// @title PoolMath - library for calculating swaps\n/// @notice Taken and modified from Pendle V2: https://github.com/pendle-finance/pendle-core-v2-public/blob/163783b09014e515b645b83936fec32c5731d092/contracts/core/Market/MarketMathCore.sol\n/// @dev Swaps take place between the BasePool LP token and the underlying asset.\n/// The BasePool LP token is basket of 3 principal tokens.\n/// @dev The AMM formula is defined in terms of the amount of PT being swapped.\n/// @dev The math assumes two tokens (pt and underlying) have same decimals. Need to convert if they have different decimals.\n/// @dev All functions in this library are view functions.\nlibrary PoolMath {\n    /// @notice Minimum liquidity in the pool\n    uint256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n    /// @notice Percentage base (100=100%)\n    int256 internal constant FULL_PERCENTAGE = 100;\n    /// @notice Day in seconds in Unix timestamp\n    uint256 internal constant DAY = 86400;\n    /// @notice Year in seconds in Unix timestamp\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    /// @notice Max proportion of BasePool LP token / (BasePool LP token + underlying asset) in the pool\n    uint256 internal constant MAX_POOL_PROPORTION = 0.96 * 1e18; // 96%\n\n    int256 internal constant N_COINS = 3;\n\n    using FixedPointMathLib for uint256;\n    using SignedMath for int256;\n    using SignedMath for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    /// @param pool State - pool state of the pool\n    /// @param exactBaseLptIn - exact amount of Base Pool LP tokens to be swapped in\n    /// @return underlyingOut18 - underlying tokens to be swapped out (18 decimals)\n    /// @return swapFee18 - swap fee in underlying (18 decimals)\n    /// @return protocolFee18 - protocol fee in underlying (18 decimals)\n    function swapExactBaseLpTokenForUnderlying(PoolState memory pool, uint256 exactBaseLptIn)\n        internal\n        view\n        returns (uint256 underlyingOut18, uint256 swapFee18, uint256 protocolFee18)\n    {\n        (int256 _netUnderlyingToAccount18, int256 _netUnderlyingFee18, int256 _netUnderlyingToProtocol18) = executeSwap(\n            pool,\n            // Note: sign is defined from the perspective of the swapper.\n            // negative because the swapper is selling pt\n            // Note: Here we are multiplying by N_COINS because the swap formula is defined in terms of the amount of PT being swapped.\n            // BaseLpt is equivalent to 3 times the amount of PT due to the initial deposit of 1:1:1:1=pt1:pt2:pt3:Lp share in Curve pool.\n            exactBaseLptIn.neg() * N_COINS\n        );\n\n        underlyingOut18 = _netUnderlyingToAccount18.toUint256();\n        swapFee18 = _netUnderlyingFee18.toUint256();\n        protocolFee18 = _netUnderlyingToProtocol18.toUint256();\n    }\n\n    /// @param pool State - pool state of the pool\n    /// @param exactBaseLptOut exact amount of Base Pool LP tokens to be swapped out\n    /// @return underlyingIn18 - underlying tokens to be swapped in (18 decimals)\n    /// @return swapFee18 - swap fee in underlying (18 decimals)\n    /// @return protocolFee18 - protocol fee in underlying (18 decimals)\n    function swapUnderlyingForExactBaseLpToken(PoolState memory pool, uint256 exactBaseLptOut)\n        internal\n        view\n        returns (uint256 underlyingIn18, uint256 swapFee18, uint256 protocolFee18)\n    {\n        (int256 _netUnderlyingToAccount18, int256 _netUnderlyingFee18, int256 _netUnderlyingToProtocol18) = executeSwap(\n            pool,\n            // Note: sign is defined from the perspective of the swapper.\n            // positive because the swapper is buying pt\n            exactBaseLptOut.toInt256() * N_COINS\n        );\n\n        underlyingIn18 = _netUnderlyingToAccount18.neg().toUint256();\n        swapFee18 = _netUnderlyingFee18.toUint256();\n        protocolFee18 = _netUnderlyingToProtocol18.toUint256();\n    }\n\n    /// @notice Compute swap result given the amount of base pool LP tokens to be swapped in.\n    /// @dev This function is used to compute the swap result before the swap is executed.\n    /// @param pool State - pool state of the pool\n    /// @param netBaseLptToAccount (int256) amount of base pool LP tokens to be swapped in (negative if selling pt) multiplied by the number of BasePool assets\n    /// Note: sign is defined from the perspective of the swapper. positive if the swapper is buying pt.\n    /// @return netUnderlyingToAccount18 (int256) amount of underlying tokens to be swapped out\n    /// @return netUnderlyingFee18 (int256) total fee. including protocol fee.\n    /// `netUnderlyingFee18 - netUnderlyingToProtocol` will be distributed to LP holders.\n    /// @return netUnderlyingToProtocol18 (int256) Protocol fee\n    function executeSwap(PoolState memory pool, int256 netBaseLptToAccount)\n        internal\n        view\n        returns (int256 netUnderlyingToAccount18, int256 netUnderlyingFee18, int256 netUnderlyingToProtocol18)\n    {\n        if (pool.totalBaseLptTimesN.toInt256() <= netBaseLptToAccount) {\n            revert Errors.PoolInsufficientBaseLptForTrade();\n        }\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        PoolPreCompute memory comp = computeAmmParameters(pool);\n\n        (netUnderlyingToAccount18, netUnderlyingFee18, netUnderlyingToProtocol18) =\n            calculateSwap(pool, comp, netBaseLptToAccount);\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setPostPoolState(pool, comp, netBaseLptToAccount, netUnderlyingToAccount18, netUnderlyingToProtocol18);\n    }\n\n    /// @notice Compute the pseudo invariant of the pool.\n    /// @dev The pseudo invariant is computed every swap before the swap is executed.\n    /// @param pool State - pool state of the pool\n    function computeAmmParameters(PoolState memory pool) internal view returns (PoolPreCompute memory cache) {\n        uint256 timeToExpiry = pool.maturity - block.timestamp;\n\n        cache.rateScalar = _getRateScalar(pool, timeToExpiry);\n        cache.rateAnchor = _getRateAnchor(\n            pool.totalBaseLptTimesN, pool.lastLnImpliedRate, pool.totalUnderlying18, cache.rateScalar, timeToExpiry\n        );\n        cache.feeRate = _getExchangeRateFromImpliedRate(pool.lnFeeRateRoot, timeToExpiry);\n    }\n\n    /// @notice Calculate the new `RateAnchor(t)` based on the pre-trade implied rate, `lastImpliedRate`, before the swap.\n    /// To ensure interest rate continuity, we adjust the `rateAnchor(t)` such that the pre-trade implied rate at t* remains the same as `lastImpliedRate`.\n    ///\n    /// Formulas for `rateAnchor(t)`:\n    /// ----------------------------\n    /// yearsToExpiry(t) = timeToExpiry / 365 days\n    ///\n    /// portion(t*) = totalBaseLptTimesN / (totalBaseLptTimesN + totalUnderlying18)\n    ///\n    /// extRate(t*) = lastImpliedRate^(yearsToExpiry(t))\n    ///              = e^(ln(lastImpliedRate) * yearsToExpiry(t))\n    ///\n    /// rateAnchor(t) = extRate(t*) - ln(portion(t*)) / rateScalar(t)\n    /// ----------------------------\n    /// Where `portion(t*)` represents the portion of the pool that is BasePool LP token at t* and `extRate(t*)` is the exchange rate at t*.\n    ///\n    /// @param totalBaseLptTimesN total Base Lp token in the pool\n    /// @param lastLnImpliedRate the implied rate for the last trade that occurred at t_last.\n    /// @param totalUnderlying18 total underlying in the pool\n    /// @param rateScalar a parameter of swap formula. Calculated as  `scalarRoot` divided by `yearsToExpiry`\n    /// @param timeToExpiry time to maturity in seconds\n    /// @return rateAnchor the new rate anchor\n    function _getRateAnchor(\n        uint256 totalBaseLptTimesN,\n        uint256 lastLnImpliedRate,\n        uint256 totalUnderlying18,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        // `extRate(t*) = e^(lastLnImpliedRate * yearsToExpiry(t))`\n        // Get pre-trade exchange rate with zero-fee\n        int256 preTradeExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n        // exchangeRate should not be below 1.\n        // But it is mathematically almost impossible to happen because `exp(x) < 1` is satisfied for all `x < 0`.\n        // Here x = lastLnImpliedRate * yearsToExpiry(t), which is very unlikely to be negative.(or\n        // more accurately the natural log rounds down to zero). `lastLnImpliedRate` is guaranteed to be positive when it is set\n        // and `yearsToExpiry(t)` is guaranteed to be positive because swap can only happen before maturity.\n        // We still check for this case to be safe.\n        require(preTradeExchangeRate > SignedMath.WAD);\n        uint256 proportion = totalBaseLptTimesN.divWadDown(totalBaseLptTimesN + totalUnderlying18);\n        int256 lnProportion = _logProportion(proportion);\n\n        // Compute `rateAnchor(t) = extRate(t*) - ln(portion(t*)) / rateScalar(t)`\n        rateAnchor = preTradeExchangeRate - lnProportion.divWadDown(rateScalar);\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to maturity. The\n    /// @dev Formula: `E = e^rt`\n    /// @return exchangeRate the price of underlying token in Base LP token. Guaranteed to be positive or zero.\n    function _getExchangeRateFromImpliedRate(uint256 lnImpliedRate, uint256 timeToExpiry)\n        internal\n        pure\n        returns (int256 exchangeRate)\n    {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n        exchangeRate = exp(ud(rt)).intoUint256().toInt256();\n    }\n\n    /// @notice Compute swap result given the delta of baseLpt an swapper wants to swap.\n    /// @param pool State - pool state of the pool\n    /// @param comp PreCompute - pre-computed values of the pool\n    /// @param netBaseLptToAccount the delta of baseLpt the swapper wants to swap.\n    /// @dev Note: Ensure that abs(`netBaseLptToAccount`) is not greater than `totalBaseLptTimesN`.\n    /// @return netUnderlyingToAccount18 the amount of underlying the swapper will receive\n    /// negative if the swapper is selling BaseLpt and positive if the swapper is buying BaseLpt.\n    /// @return underlyingFee18 the amount of underlying charged as swap fee\n    /// this includes `underlyingToProtocol18`\n    /// @return underlyingToProtocol18 the amount of underlying the Pool fee recipient will receive as fee\n    /// Protocol accrues fee in underlying.\n    function calculateSwap(\n        PoolState memory pool,\n        PoolPreCompute memory comp,\n        int256 netBaseLptToAccount // d_pt\n    ) internal pure returns (int256, int256, int256) {\n        // Calculates the exchange rate from underlying to baseLpt before any fees are applied\n        // Note: The exchange rate is int type but it must be always strictly gt 1.\n        // Note: `netBaseLptToAccount` should be checked prior to calling this function\n        int256 preFeeExchangeRate = _getExchangeRate(\n            pool.totalBaseLptTimesN, pool.totalUnderlying18, comp.rateScalar, comp.rateAnchor, netBaseLptToAccount\n        ).toInt256();\n\n        // Basically swap formula is:\n        //                                 netBaseLptToAccount\n        // netUnderlyingToAccount18 = -1 * ────────────────────────\n        //                                       extRate\n        // where `netBaseLptToAccount` is the delta of baseLpt (`d_pt`) and `netUnderlyingToAccount18` is the delta of underlying (`d_u`).\n        // because if `d_pt > 0`, then `d_u < 0` and vice versa.\n        // fees can be applied to the `extRate`.\n        // `postFeeExchangeRate = preFeeExchangeRate / feeRate` if `netBaseLptToAccount > 0` else `postFeeExchangeRate = preFeeExchangeRate * feeRate`\n        int256 netUnderlying18 = netBaseLptToAccount.divWadDown(preFeeExchangeRate).neg();\n\n        // See whitepaper for the formula:\n        // fee is calculated as the difference between the underlying amount before and after the fee is applied:\n        // fee = underlyingNoFee - underlyingWithFee\n        // where `underlyingNoFee = - (ptToAccount / preFeeExchangeRate)`\n        // and `underlyingWithFee = - (ptToAccount / postFeeExchangeRate)`\n        //\n        // Therefore:\n        // fee = - (ptToAccount / preFeeExchangeRate) + (ptToAccount / postFeeExchangeRate)\n        int256 underlyingFee18;\n        if (netBaseLptToAccount > 0) {\n            // User swap underlying for baseLpt\n            // Exchange rate after fee is applied is:\n            //  `postFeeExchangeRate := preFeeExchangeRate / feeRate`\n            //  `postFeeExchangeRate` must be strictly gt 1.\n            // It's possible that the fee pushes the implied rate into negative territory. This is not allowed.\n            int256 postFeeExchangeRate = preFeeExchangeRate.divWadDown(comp.feeRate);\n            if (postFeeExchangeRate < SignedMath.WAD) revert Errors.PoolExchangeRateBelowOne(postFeeExchangeRate);\n\n            // fee = - (ptToAccount / preFeeExchangeRate) + (ptToAccount / postFeeExchangeRate)\n            //     = (ptToAccount / preFeeExchangeRate) * (feeRate - 1)\n            //     = netUnderlying18 * (feeRate - 1)\n            underlyingFee18 = netUnderlying18.mulWadDown(SignedMath.WAD - comp.feeRate);\n        } else {\n            // User swap baseLpt for underlying\n            // Exchange rate after fee is applied is:\n            //  `postFeeExchangeRate := preFeeExchangeRate * feeRate`\n            // In this case, `postFeeExchangeRate` can't be below 1 unlike the case above.\n\n            // fee = - (ptToAccount / preFeeExchangeRate) + (ptToAccount / postFeeExchangeRate)\n            //     = - (ptToAccount / preFeeExchangeRate) + (ptToAccount / (preFeeExchangeRate * feeRate))\n            //     = - (ptToAccount / preFeeExchangeRate) * (1 - 1 / feeRate)\n            //     = - (ptToAccount / preFeeExchangeRate) * (feeRate - 1) / feeRate\n            // Note: ptToAccount is negative in this branch so we negate it to ensure that fee is a positive number\n            underlyingFee18 = ((netUnderlying18 * (SignedMath.WAD - comp.feeRate)) / comp.feeRate).neg();\n        }\n\n        // Subtract swap fee\n        // underlyingWithFee = underlyingNoFee - fee\n        int256 netUnderlyingToAccount18 = netUnderlying18 - underlyingFee18;\n        // Charge protocol fee on swap fee\n        // This underlying will be removed from the pool reserve\n        int256 underlyingToProtocol18 = (underlyingFee18 * pool.protocolFeePercent.toInt256()) / FULL_PERCENTAGE;\n\n        return (netUnderlyingToAccount18, underlyingFee18, underlyingToProtocol18);\n    }\n\n    /// @notice Update pool state cache after swap is executed\n    /// @param pool pool state of the pool\n    /// @param comp swap formula pre-computed values\n    /// @param netBaseLptToAccount net Base Lpt to account. negative if the swapper is selling BaseLpt\n    /// @param netUnderlyingToAccount18 net underlying to account. positive if the swapper is selling BaseLpt.\n    /// @param netUnderlyingToProtocol18 should be removed from the pool reserve `totalUnderlying18`. must be positive\n    function _setPostPoolState(\n        PoolState memory pool,\n        PoolPreCompute memory comp,\n        int256 netBaseLptToAccount,\n        int256 netUnderlyingToAccount18,\n        int256 netUnderlyingToProtocol18\n    ) internal view {\n        // update pool state\n        // Note safe because pre-trade check ensures totalBaseLptTimesN >= netBaseLptToAccount\n        pool.totalBaseLptTimesN = (pool.totalBaseLptTimesN.toInt256() - netBaseLptToAccount).toUint256();\n        pool.totalUnderlying18 = (pool.totalUnderlying18).toInt256().subNoNeg(\n            netUnderlyingToAccount18 + netUnderlyingToProtocol18\n        ).toUint256();\n        // compute post-trade implied rate\n        // this will be used to compute the new rateAnchor for the next trade\n        uint256 timeToExpiry = pool.maturity - block.timestamp;\n        pool.lastLnImpliedRate = _getLnImpliedRate(\n            pool.totalBaseLptTimesN, pool.totalUnderlying18, comp.rateScalar, comp.rateAnchor, timeToExpiry\n        );\n        // It's technically unlikely that the implied rate is actually exactly zero but we will still fail\n        // in this case.\n        if (pool.lastLnImpliedRate == 0) revert Errors.PoolZeroLnImpliedRate();\n    }\n\n    /// @notice Get rate scalar given the pool state and time to maturity.\n    /// @dev Formula: `scalarRoot * ONE_YEAR / yearsToExpiry`\n    function _getRateScalar(PoolState memory pool, uint256 timeToExpiry) internal pure returns (int256) {\n        uint256 rateScalar = (pool.scalarRoot * IMPLIED_RATE_TIME) / timeToExpiry;\n        if (rateScalar == 0) revert Errors.PoolRateScalarZero();\n        return rateScalar.toInt256();\n    }\n\n    /// @notice Calculates the current pool implied rate.\n    /// ln(extRate) * ONE_YEAR / timeToExpiry\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        uint256 totalBaseLptTimesN,\n        uint256 totalUnderlying18,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This should ensure that exchange rate < FixedPointMathLib.WAD\n        int256 exchangeRate =\n            _getExchangeRate(totalBaseLptTimesN, totalUnderlying18, rateScalar, rateAnchor, 0).toInt256();\n\n        // exchangeRate >= 1 so its ln(extRate) >= 0\n        int256 lnRate = ln(sd(exchangeRate)).intoInt256();\n\n        lnImpliedRate = (uint256(lnRate) * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Calculates exchange rate given the total baseLpt and total underlying.\n    ///     (1 / rateScalar) * ln(proportion / (1 - proportion)) + rateAnchor\n    /// where:\n    ///     proportion = totalPt / (totalPt + totalUnderlying)\n    ///\n    /// @dev Revert if the exchange rate is below 1. Prevent users from swapping when 1 baseLpt is worth more than 1 underlying.\n    /// @dev Revert if the proportion of baseLpt to total is greater than MAX_POOL_PROPORTION.\n    /// @param totalBaseLptTimesN the total baseLpt in the pool\n    /// @param totalUnderlying18 the total underlying in the pool\n    /// @param rateScalar the scalar used to compute the exchange rate\n    /// @param rateAnchor the anchor used to compute the exchange rate\n    /// @param netBaseLptToAccount the net baseLpt to the account (negative if account is swapping baseLpt for underlying)\n    /// @return exchangeRate the price of underlying token in terms of Base LP token\n    function _getExchangeRate(\n        uint256 totalBaseLptTimesN,\n        uint256 totalUnderlying18,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netBaseLptToAccount\n    ) internal pure returns (uint256) {\n        // Revert if there is not enough baseLpt to support this swap.\n        // Note: Ensure that abs(`netBaseLptToAccount`) is not greater than `totalBaseLptTimesN` before calling this function\n        uint256 numerator = (totalBaseLptTimesN.toInt256() - netBaseLptToAccount).toUint256();\n        uint256 proportion = numerator.divWadDown(totalBaseLptTimesN + totalUnderlying18);\n\n        if (proportion > MAX_POOL_PROPORTION) {\n            revert Errors.PoolProportionTooHigh();\n        }\n\n        int256 lnProportion = _logProportion(proportion);\n\n        int256 exchangeRate = lnProportion.divWadDown(rateScalar) + rateAnchor;\n        if (exchangeRate < int256(FixedPointMathLib.WAD)) revert Errors.PoolExchangeRateBelowOne(exchangeRate);\n        return exchangeRate.toUint256();\n    }\n\n    /// @notice Compute Logit function (log(p/(1-p)) given a proportion `p`.\n    /// @param proportion the proportion of baseLpt to (baseLpt + underlying) (0 <= proportion <= 1e18)\n    function _logProportion(uint256 proportion) internal pure returns (int256 logitP) {\n        if (proportion == FixedPointMathLib.WAD) revert Errors.PoolProportionMustNotEqualOne();\n\n        // input = p/(1-p)\n        int256 input = proportion.divWadDown(FixedPointMathLib.WAD - proportion).toInt256();\n        // logit(p) = log(input) = ln(p/(1-p))\n        logitP = ln(sd(input)).intoInt256();\n    }\n\n    /// @notice Compute the initial implied rate of the pool.\n    /// @dev This function is expected to be called only once when initial liquidity is added.\n    /// @param pool pool state of the pool\n    /// @param initialAnchor initial anchor of the pool\n    /// @return initialLnImpliedRate the initial implied rate\n    function computeInitialLnImpliedRate(PoolState memory pool, int256 initialAnchor) internal view returns (uint256) {\n        uint256 timeToExpiry = pool.maturity - block.timestamp;\n        int256 rateScalar = _getRateScalar(pool, timeToExpiry);\n\n        return\n            _getLnImpliedRate(pool.totalBaseLptTimesN, pool.totalUnderlying18, rateScalar, initialAnchor, timeToExpiry);\n    }\n}"
    },
    {
      "filename": "v1-pool/src/NapierPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\n// interfaces\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\nimport {CurveTricryptoOptimizedWETH} from \"./interfaces/external/CurveTricryptoOptimizedWETH.sol\";\nimport {ITranche} from \"@napier/napier-v1/src/interfaces/ITranche.sol\";\n\nimport {INapierPool} from \"./interfaces/INapierPool.sol\";\nimport {INapierSwapCallback} from \"./interfaces/INapierSwapCallback.sol\";\nimport {INapierMintCallback} from \"./interfaces/INapierMintCallback.sol\";\nimport {IPoolFactory} from \"./interfaces/IPoolFactory.sol\";\n// libs\nimport {PoolMath, PoolState} from \"./libs/PoolMath.sol\";\nimport {Math} from \"@openzeppelin/contracts@4.9.3/utils/math/Math.sol\";\nimport {SignedMath} from \"./libs/SignedMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts@4.9.3/utils/math/SafeCast.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/utils/SafeERC20.sol\";\nimport {DecimalConversion} from \"./libs/DecimalConversion.sol\";\nimport {MAX_LN_FEE_RATE_ROOT, MAX_PROTOCOL_FEE_PERCENT} from \"./libs/Constants.sol\";\nimport {Errors} from \"./libs/Errors.sol\";\n// inherits\nimport {ERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts@4.9.3/token/ERC20/extensions/ERC20Permit.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\n\n/// @dev NapierPool is a pool that allows users to trade between a BasePool LP token and an underlying asset.\n/// BasePool LP token is a token that represents a share of basket of 3 Principal Tokens Curve V2 pool.\n///\n/// Note: This pool and its math assumes the following regarding BasePool:\n/// 1. The BasePool assets are 3 Napier Principal Tokens (PT) of the same maturity and same underlying asset.\n///    We can consider BasePool LP token as something like ETF of 3 PTs.\n/// 2. BasePool LP token is approximately three times more valuable than 1 PT because the initial deposit on Curve pool issues 1:1:1:1=pt1:pt2:pt3:share.\n/// e.g. When the initial price of PT1, PT2 and PT3 is 1,`1` BasePool LP token is convertible to `1` PT1 + `1` PT2 + `1` PT3 instead of `1/3` for each PT.\n/// We need to adjust the balance of BasePool LP token by multiplying 3 to make it comparable to underlying asset.\n/// Economically at maturity 1/3 BaseLP token is expected to be convertible to approximately 1 underlying asset.\n/// 3. BasePool LP token has 18 decimals.\n/// 4. PTs have the same decimals as underlying asset.\ncontract NapierPool is INapierPool, ReentrancyGuard, ERC20Permit {\n    using PoolMath for PoolState;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for CurveTricryptoOptimizedWETH;\n    using SignedMath for uint256;\n    using SafeCast for uint256;\n    using DecimalConversion for uint256;\n\n    /// @dev Number of coins in the BasePool\n    uint256 internal constant N_COINS = 3;\n\n    /// @notice The factory that deployed this pool.\n    IPoolFactory public immutable factory;\n\n    /// @notice BasePool LP token i.e. Curve v2 3assets pool\n    CurveTricryptoOptimizedWETH public immutable tricrypto;\n\n    /// @notice Underlying asset (e.g. DAI, WETH)\n    IERC20 public immutable underlying;\n    uint8 internal immutable uDecimals;\n\n    /// @notice Napier Principal Tokens\n    /// @dev We don't use static size array here because Solidity doesn't support immutable static size array.\n    /// @dev This would significantly reduce gas cost by avoiding SLOAD. About 2000 gas per reading principal token. (cold)\n    /// @dev pt_i is the i-th asset of the BasePool coins. i.e pt[i] = CurveV2Pool.coins(i)\n    IERC20 internal immutable pt1;\n    IERC20 internal immutable pt2;\n    IERC20 internal immutable pt3;\n\n    /// @notice Maturity of the pool in unix timestamp\n    /// @notice At or after maturity, the pool will no longer accept any liquidity provision or swap. Removing liquidity is still allowed.\n    /// @dev Users can still swap, add or remove liquidity even after maturity on Curve pool.\n    /// @dev expiry of the pool. This is the maturity of all principal tokens in the pool.\n    uint256 public immutable maturity;\n\n    /// @notice AMM parameter: Scalar root of the pool\n    /// @dev adjust the capital efficiency of the market.\n    uint256 public immutable scalarRoot;\n\n    /// @notice AMM parameter: Initial anchor of the pool\n    /// @dev initial rate anchor to anchor the market’s formula to be more capital efficient around a certain interest rate.\n    int256 public immutable initialAnchor;\n\n    /// @notice Recipient of the protocol fee\n    address public immutable feeRecipient;\n\n    /// @notice AMM parameter: Logarithmic fee rate root of the pool\n    /// @dev Fees rate in terms of interest rate\n    uint80 internal lnFeeRateRoot;\n\n    /// @notice AMM parameter: Fee Napier charges for swaps in percentage (100=100%)\n    uint8 internal protocolFeePercent;\n\n    /// @notice AMM parameter: Last logarithmic implied rate of the pool\n    uint256 public lastLnImpliedRate;\n\n    /// @notice Total amount of BaseLpt in the pool (Reserve)\n    uint128 public totalBaseLpt;\n\n    /// @notice Total amount of underlying in the pool (Reserve)\n    uint128 public totalUnderlying;\n\n    /// @dev Revert if maturity is reached\n    modifier notExpired() {\n        if (maturity <= block.timestamp) revert Errors.PoolExpired();\n        _;\n    }\n\n    constructor() payable ERC20(\"Napier Pool LP Token\", \"NapierPool LPT\") ERC20Permit(\"Napier Pool LP Token\") {\n        factory = IPoolFactory(msg.sender);\n        IPoolFactory.InitArgs memory args = factory.args();\n        // Set mutable variables\n        protocolFeePercent = args.configs.protocolFeePercent;\n        // Set immutable variables\n        scalarRoot = args.configs.scalarRoot;\n        initialAnchor = args.configs.initialAnchor;\n        lnFeeRateRoot = args.configs.lnFeeRateRoot;\n        feeRecipient = args.configs.feeRecipient;\n\n        address basePool = args.assets.basePool;\n        tricrypto = CurveTricryptoOptimizedWETH(basePool);\n\n        ERC20 _underlying = ERC20(args.assets.underlying);\n        underlying = _underlying;\n        uDecimals = _underlying.decimals();\n\n        // hack: we don't use static size array here to save gas cost\n        ITranche _pt1 = ITranche(args.assets.principalTokens[0]);\n        ITranche _pt2 = ITranche(args.assets.principalTokens[1]);\n        ITranche _pt3 = ITranche(args.assets.principalTokens[2]);\n\n        pt1 = _pt1;\n        pt2 = _pt2;\n        pt3 = _pt3;\n        // Assume that the maturity of all principal tokens are the same\n        maturity = _pt1.maturity();\n\n        // Approve Curve pool to transfer PTs\n        _pt1.approve(basePool, type(uint256).max); // dev: Principal token will revert if failed to approve\n        _pt2.approve(basePool, type(uint256).max);\n        _pt3.approve(basePool, type(uint256).max);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Mutative functions\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /// @inheritdoc INapierPool\n    /// @notice Provide BasePoolLpToken (BaseLpt) and underlying in exchange for Lp token, which will grant LP holders more exchange fee over time\n    /// @dev Mint as much LP token as possible.\n    /// @dev BaseLpt and Underlying should be transferred to this contract prior to calling\n    /// @dev Revert if maturity is reached\n    /// @dev Revert if deposited assets are too small to mint more than minimum liquidity\n    /// @dev Revert if deposited assets are too small to compute ln implied rate\n    /// @dev Revert if computed initial exchange rate in base LP token is below one. (deposited base LP token is much less than deposited underlying)\n    /// @dev Revert if proportion of deposited base LP token is higher than the maximum proportion. (deposited base LP token is too large compared to deposited underlying)\n    /// @dev Revert if minted LP token is zero\n    /// @param recipient recipient of the minted LP token\n    /// @return liquidity amount of LP token minted\n    function addLiquidity(uint256 underlyingInDesired, uint256 baseLptInDesired, address recipient, bytes memory data)\n        external\n        override\n        nonReentrant\n        notExpired\n        returns (uint256)\n    {\n        // Cache state variables\n        (uint256 _totalUnderlying, uint256 _totalBaseLpt) = (totalUnderlying, totalBaseLpt);\n\n        uint256 bBalance = _balance(tricrypto);"
    }
  ]
}