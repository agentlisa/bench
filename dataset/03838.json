{
  "Title": "Not optimal data type",
  "Content": "##### Description\nAt the line https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L42 uses an array. But with the use of structure, the code will become clearer.\n\n##### Recommendation\nIt is recommended to make a structure.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/RCFactory.sol",
      "content": "pragma solidity 0.5.13;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"hardhat/console.sol\";\nimport './lib/CloneFactory.sol';\nimport \"./interfaces/ITreasury.sol\";\nimport './interfaces/IRCMarket.sol';\nimport './interfaces/IRCProxyXdai.sol';\nimport './interfaces/IRCNftHubXdai.sol';\nimport './lib/NativeMetaTransaction.sol';\n\n/// @title Reality Cards Factory\n/// @author Andrew Stanger\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCFactory is Ownable, CloneFactory, NativeMetaTransaction {\n\n    using SafeMath for uint256;\n    using SafeMath for uint32;\n\n    ////////////////////////////////////\n    //////// VARIABLES /////////////////\n    ////////////////////////////////////\n\n    ///// CONTRACT VARIABLES /////\n    ITreasury public treasury;\n    IRCProxyXdai public proxy;\n    IRCNftHubXdai public nfthub;\n\n    ///// CONTRACT ADDRESSES /////\n    /// @dev reference contract\n    address public referenceContractAddress; \n    /// @dev increments each time a new reference contract is added\n    uint256 public referenceContractVersion;\n    /// @dev market addresses, mode // address\n    /// @dev these are not used for anything, just an easy way to get markets\n    mapping(uint256 => address[]) public marketAddresses;\n    mapping(address => bool) public mappingOfMarkets; \n\n    ///// GOVERNANCE VARIABLES- OWNER /////\n    /// @dev artist / winner / market creator / affiliate / card affiliate\n    uint256[5] public potDistribution;\n    /// @dev minimum xDai that must be sent when creating market which forms iniital pot\n    uint256 public sponsorshipRequired;\n    /// @dev adjust required price increase (in %)\n    uint256 public minimumPriceIncrease;\n    /// @dev market opening time must be at least this many seconds in the future\n    uint32 public advancedWarning;\n    /// @dev market closing time must be no more than this many seconds in the future\n    uint32 public maximumDuration;\n    /// @dev if hot potato mode, how much rent new owner must pay current owner (1 week divisor: i.e. 7 = 1 day's rent, 14 = 12 hours's rent)\n    uint256 public hotPotatoDivisor;\n    /// @dev list of governors\n    mapping(address => bool) public governors;\n    /// @dev if false, anyone can create markets\n    bool public marketCreationGovernorsOnly = true;\n    /// @dev if true, cards are burnt at the end of events for hidden markets to enforce scarcity\n    bool public trapIfUnapproved = true;\n    /// @dev high level owner who can change the factory address\n    address public uberOwner;\n\n    ///// GOVERNANCE VARIABLES- GOVERNORS /////\n    /// @dev unapproved markets hidden from the interface\n    mapping(address => bool) public isMarketApproved;\n    /// @dev allows artist to receive cut of total rent\n    mapping(address => bool) public isArtistApproved;\n    /// @dev allows affiliate to receive cut of total rent\n    mapping(address => bool) public isAffiliateApproved;\n    /// @dev allows card affiliate to receive cut of total rent\n    mapping(address => bool) public isCardAffiliateApproved;\n    \n    ///// OTHER /////\n    /// @dev counts the total NFTs minted across all events\n    /// @dev ... so the appropriate token id is used when upgrading to mainnet\n    uint256 public totalNftMintCount;\n\n    ////////////////////////////////////\n    //////// EVENTS ////////////////////\n    ////////////////////////////////////\n\n    event LogMarketCreated1(address contractAddress, address treasuryAddress, address nftHubAddress, uint256 referenceContractVersion);\n    event LogMarketCreated2(address contractAddress, uint32 mode, string[] tokenURIs, string ipfsHash, uint32[] timestamps, uint256 totalNftMintCount);\n    event LogMarketApproved(address market, bool hidden);\n    event LogAdvancedWarning(uint256 _newAdvancedWarning);\n    event LogMaximumDuration(uint256 _newMaximumDuration);\n\n    ////////////////////////////////////\n    //////// CONSTRUCTOR ///////////////\n    ////////////////////////////////////\n\n    /// @dev Treasury must be deployed before Factory\n    constructor(ITreasury _treasuryAddress) public\n    {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsFactory\",\"1\");\n\n        // at initiation, uberOwner and owner will be the same\n        uberOwner = msg.sender;\n\n        // initialise contract variable\n        treasury = _treasuryAddress;\n\n        // initialise adjustable parameters\n        // artist // winner // creator // affiliate // card affiliates\n        setPotDistribution(20,0,0,20,100); // 2% artist, 2% affiliate, 10% card affiliate\n        setMinimumPriceIncrease(10); // 10% \n        setHotPotatoPayment(7); // one day's rent\n    }\n\n    ////////////////////////////////////\n    ///////// VIEW FUNCTIONS ///////////\n    ////////////////////////////////////\n\n    function getMostRecentMarket(uint256 _mode) public view returns (address) {\n        return marketAddresses[_mode][marketAddresses[_mode].length-1];\n    }\n\n    function getAllMarkets(uint256 _mode) public view returns (address[] memory) {\n        return marketAddresses[_mode];\n    }\n\n    function getPotDistribution() public view returns (uint256[5] memory) {\n        return potDistribution;\n    }\n\n    ////////////////////////////////////\n    //////////// MODIFERS //////////////\n    ////////////////////////////////////\n\n    modifier onlyGovernors() {\n        require(governors[msgSender()] || owner() == msgSender(), \"Not approved\");\n        _;\n    }\n\n    ////////////////////////////////////\n    ///// GOVERNANCE- OWNER (SETUP) ////\n    ////////////////////////////////////\n    /// @dev all functions should have onlyOwner modifier\n\n    /// @notice address of the xDai Proxy contract\n    function setProxyXdaiAddress(IRCProxyXdai _newAddress) external onlyOwner {\n        proxy = _newAddress;\n    }\n\n    /// @notice where the NFTs live\n    /// @dev nftMintCount will probably need to be reset to zero if new nft contract, but \n    /// @dev ... keeping flexible in case returning to previous contract\n    function setNftHubAddress(IRCNftHubXdai _newAddress, uint256 _newNftMintCount) external onlyOwner {\n        nfthub = _newAddress;\n        totalNftMintCount = _newNftMintCount;\n    }\n\n    ////////////////////////////////////\n    /////// GOVERNANCE- OWNER //////////\n    ////////////////////////////////////\n    /// @dev all functions should have onlyOwner modifier\n    // Min price increase, pot distribution & hot potato events emitted by Market. \n    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.\n\n    /// CALLED WITHIN CONSTRUCTOR (public)\n\n    /// @notice update stakeholder payouts \n    /// @dev in 10s of basis points (so 1000 = 100%)\n    function setPotDistribution(uint256 _artistCut, uint256 _winnerCut, uint256 _creatorCut, uint256 _affiliateCut, uint256 _cardAffiliateCut) public onlyOwner {\n        require(_artistCut.add(_affiliateCut).add(_creatorCut).add(_winnerCut).add(_affiliateCut).add(_cardAffiliateCut) <= 1000, \"Cuts too big\");\n        potDistribution[0] = _artistCut;\n        potDistribution[1] = _winnerCut;\n        potDistribution[2] = _creatorCut;\n        potDistribution[3] = _affiliateCut;\n        potDistribution[4] = _cardAffiliateCut;\n    }\n\n    /// @notice how much above the current price a user must bid, in %\n    function setMinimumPriceIncrease(uint256 _percentIncrease) public onlyOwner {\n        minimumPriceIncrease = _percentIncrease;\n    }\n\n     /// @dev if hot potato mode, how much rent new owner must pay current owner (1 week divisor: i.e. 7 = 1 day, 14 = 12 hours)\n    function setHotPotatoPayment(uint256 _newDivisor) public onlyOwner {\n        hotPotatoDivisor = _newDivisor;\n    }\n\n    /// NOT CALLED WITHIN CONSTRUCTOR (external)\n\n    /// @notice whether or not only governors can create the market\n    function setMarketCreationGovernorsOnly() external onlyOwner {\n        marketCreationGovernorsOnly = marketCreationGovernorsOnly ? false : true;\n    }\n\n    /// @notice how much xdai must be sent in the createMarket tx which forms the initial pot\n    function setSponsorshipRequired(uint256 _dai) external onlyOwner {\n        sponsorshipRequired = _dai;\n    }\n\n    /// @notice if true, Cards in unapproved markets can't be upgraded\n    function setTrapCardsIfUnapproved() onlyOwner external {\n        trapIfUnapproved = trapIfUnapproved ? false : true;\n    }\n\n    /// @notice market opening time must be at least this many seconds in the future\n    function setAdvancedWarning(uint32 _newAdvancedWarning) onlyOwner external {\n        advancedWarning = _newAdvancedWarning;\n        emit LogAdvancedWarning(_newAdvancedWarning);\n    }\n\n    /// @notice market closing time must be no more than this many seconds in the future\n    function setMaximumDuration(uint32 _newMaximumDuration) onlyOwner external {\n        maximumDuration = _newMaximumDuration;\n        emit LogMaximumDuration(_newMaximumDuration);\n    }\n\n    // EDIT GOVERNORS\n\n    /// @notice add or remove an address from market creator whitelist\n    function addOrRemoveGovernor(address _governor) external onlyOwner {\n        governors[_governor] = governors[_governor] ? false : true;\n    }\n\n    ////////////////////////////////////\n    ///// GOVERNANCE- GOVERNORS ////////\n    ////////////////////////////////////\n    /// @dev all functions should have onlyGovernors modifier\n\n    /// @notice markets are default hidden from the interface, this reveals them\n    function approveOrUnapproveMarket(address _market) external onlyGovernors {\n        isMarketApproved[_market] = isMarketApproved[_market] ? false : true;\n        emit LogMarketApproved(_market, isMarketApproved[_market]);\n    }\n\n    /// @notice artistAddress, passed in createMarket, must be approved\n    function addOrRemoveArtist(address _artist) external onlyGovernors {\n        isArtistApproved[_artist] = isArtistApproved[_artist] ? false : true;\n    }\n\n    /// @notice affiliateAddress, passed in createMarket, must be approved\n    function addOrRemoveAffiliate(address _affiliate) external onlyGovernors {\n        isAffiliateApproved[_affiliate] = isAffiliateApproved[_affiliate] ? false : true;\n    }\n\n    /// @notice cardAffiliateAddress, passed in createMarket, must be approved\n    function addOrRemoveCardAffiliate(address _affiliate) external onlyGovernors {\n        isCardAffiliateApproved[_affiliate] = isCardAffiliateApproved[_affiliate] ? false : true;\n    }\n\n    ////////////////////////////////////\n    ////// GOVERNANCE- UBER OWNER //////\n    ////////////////////////////////////\n    //// ******** DANGER ZONE ******** ////\n    /// @dev uber owner required for upgrades\n    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governanace functions\n\n    /// @notice change the reference contract for the contract logic\n    function setReferenceContractAddress(address _newAddress) external {\n        require(msg.sender == uberOwner, \"Extremely Verboten\");\n        // check it's an RC contract\n        IRCMarket newContractVariable = IRCMarket(_newAddress);\n        assert(newContractVariable.isMarket());\n        // set \n        referenceContractAddress = _newAddress;\n        // increment version\n        referenceContractVersion = referenceContractVersion.add(1);\n    }\n\n    function changeUberOwner(address _newUberOwner) external {\n        require(msg.sender == uberOwner, \"Extremely Verboten\");\n        uberOwner = _newUberOwner;\n    }\n\n    ////////////////////////////////////\n    //////// MARKET CREATION ///////////\n    ////////////////////////////////////\n\n    /// @param _mode 0 = normal, 1 = winner takes all, 2 = hot potato\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _tokenURIs location of NFT metadata\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliate's cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any\n    /// @param _realitioQuestion the details of the event to send to the oracle\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        uint32[] memory _timestamps, \n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string memory _realitioQuestion\n    ) public payable returns (address)  {\n        // check sponsorship\n        require(msg.value >= sponsorshipRequired, \"Insufficient sponsorship\");\n\n        // check stakeholder addresses\n        // artist\n        require(isArtistApproved[_artistAddress] || _artistAddress == address(0), \"Artist not approved\");\n        // affiliate\n        require(isAffiliateApproved[_affiliateAddress] || _affiliateAddress == address(0), \"Affiliate not approved\");\n        // card affiliates\n        for (uint i = 0; i < _cardAffiliateAddresses.length; i++) { \n            require(isCardAffiliateApproved[_cardAffiliateAddresses[i]] || _cardAffiliateAddresses[i] == address(0), \"Card affiliate not approved\");\n        }\n\n        // check market creator is approved\n        if (marketCreationGovernorsOnly) {\n            require(governors[msgSender()] || owner() == msgSender(), \"Not approved\");\n        }\n\n        // check timestamps\n        // check market opening time\n        if (advancedWarning != 0) {\n            require(_timestamps[0] >= now, \"Market opening time not set\"); \n            require(_timestamps[0].sub(advancedWarning) > now, \"Market opens too soon\" );\n        }\n        // check market locking time\n        if (maximumDuration != 0) {\n            require(_timestamps[1] < now.add(maximumDuration), \"Market locks too late\");\n        }\n        // check oracle resolution time (no more than 1 week after market locking to get result)\n        require(_timestamps[1].add(1 weeks) > _timestamps[2] && _timestamps[1] <= _timestamps[2], \"Oracle resolution time error\" );\n\n        uint256 _numberOfTokens = _tokenURIs.length;\n\n        // create the market and emit the appropriate events\n        // two events to avoid stack too deep error\n        address _newAddress = createClone(referenceContractAddress);\n        emit LogMarketCreated1(_newAddress, address(treasury), address(nfthub), referenceContractVersion);\n        emit LogMarketCreated2(_newAddress, _mode, _tokenURIs, _ipfsHash, _timestamps, totalNftMintCount);\n        IRCMarket(_newAddress).initialize({\n            _mode: _mode,\n            _timestamps: _timestamps,\n            _numberOfTokens: _numberOfTokens,\n            _totalNftMintCount: totalNftMintCount,\n            _artistAddress: _artistAddress,\n            _affiliateAddress: _affiliateAddress,\n            _cardAffiliateAddresses: _cardAffiliateAddresses,\n            _marketCreatorAddress: msgSender()\n        });\n\n        // create the NFTs\n        require(address(nfthub) != address(0), \"Nfthub not set\");\n        for (uint i = 0; i < _numberOfTokens; i++) { \n            uint256 _tokenId = i.add(totalNftMintCount);\n            assert(nfthub.mintNft(_newAddress, _tokenId, _tokenURIs[i]));\n        }\n\n        // increment totalNftMintCount\n        totalNftMintCount = totalNftMintCount.add(_numberOfTokens);\n\n        // post question to Oracle\n        require(address(proxy) != address(0), \"xDai proxy not set\");\n        proxy.saveQuestion(_newAddress, _realitioQuestion, _timestamps[2]);\n\n        // tell Treasury, Proxy, and NFT hub about new market\n        assert(treasury.addMarket(_newAddress));\n        assert(proxy.addMarket(_newAddress));\n        assert(nfthub.addMarket(_newAddress));\n\n        // update internals\n        marketAddresses[_mode].push(_newAddress);\n        mappingOfMarkets[_newAddress] = true;\n\n        // pay sponsorship, if applicable\n        if (msg.value > 0) {\n            IRCMarket(_newAddress).sponsor.value(msg.value)();\n        }\n\n        return _newAddress;\n    }\n\n}"
    }
  ]
}