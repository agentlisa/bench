{
  "Title": "[23] Typos",
  "Content": "\n[SystemContractHelper, line 347](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/libraries/SystemContractHelper.sol#L347) - `2-bit IS set`, `not 2-bit it set`.\n\n```diff\n-        // When the system call is passed, the 2-bit it set to 1\n+        // When the system call is passed, the 2-bit is set to 1\n```\n\n[KnownCodesStorage, lines 16 to 17](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/KnownCodesStorage.sol#L16C117-L17C10) - repeated `words`.\n\n```diff\n- * the second byte denotes whether the contract is constructed, and the next two bytes denote the length in 32-byte words.\n- * words. And then the next 28 bytes is the truncated hash.\n+ * the second byte denotes whether the contract is constructed, the next two bytes denote the length in 32-byte words\n+ * and then the next 28 bytes is the truncated hash.\n```\n\n[SystemContext, line 22](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/SystemContext.sol#L22C32-L22C48) - `blocks' hashes`, not `blocks's hashes`.\n\n```diff\n-    /// - Store the latest 257 blocks's hashes.\n+    /// - Store the latest 257 blocks' hashes.\n```\n\n[bootloader, line 38](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L38C20-L38C60) - `That means the operator controls ...`, not `That it means that the operator controls ...`.\n\n```diff\n-                // That it means that the operator controls\n+                // That means the operator controls\n```\n\n[bootloader, line 652](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L652C57-L652C84) - `... make sure the operator ...`, not `... make sure that the operator`.\n\n```diff\n-             /// @dev The purpose of this function is to make sure that the operator\n+             /// @dev The purpose of this function is to make sure the operator\n```\n\n[bootloader, line 672](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L672C32-L672C35) - remove `for`.\n\n```diff\n-                     // Calling for the `payForTransaction` method of the account.\n+                     // Calling the `payForTransaction` method of the account.\n```\n\n[bootloader, line 3164](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L3164C22-L3164C39) - `Accepts an uint64`, not `Accepts an uint32`.\n\n```diff\n-            /// @dev Accepts an uint32 and returns whether or not it is\n+            /// @dev Accepts an uint64 and returns whether or not it is\n```\n\n[bootloader, lines 3170 to 3171](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L3170C22-L3171C31) - `Accepts an uint128 and returns wether or not it is a valid uint128`, not `Accepts an uint32 and returns wether or not it is a valid uint64`.\n\n```diff\n-            /// @dev Accepts an uint32 and returns whether or not it is\n-            /// a valid uint64\n+            /// @dev Accepts an uint128 and returns whether or not it is\n+            /// a valid uint128\n```\n\n[keccak256_round_function/mod.rs, lines 87](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/era-zkevm_circuits/src/keccak256_round_function/mod.rs#L87), [88](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/era-zkevm_circuits/src/keccak256_round_function/mod.rs#L88) and [93](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/era-zkevm_circuits/src/keccak256_round_function/mod.rs#L93) - `MEMORY_QUERIES_PER_CYCLE`, not `MEMORY_EQURIES_PER_CYCLE`.\n\n```diff\n- pub const MEMORY_EQURIES_PER_CYCLE: usize = 5; // we need to read as much as possible to use a round function every cycle\n+ pub const MEMORY_QUERIES_PER_CYCLE: usize = 5; // we need to read as much as possible to use a round function every cycle\n- pub const NUM_U64_WORDS_PER_CYCLE: usize = 4 * MEMORY_EQURIES_PER_CYCLE;\n+ pub const NUM_U64_WORDS_PER_CYCLE: usize = 4 * MEMORY_QUERIES_PER_CYCLE;\npub const NEW_BYTES_PER_CYCLE: usize = 8 * NUM_U64_WORDS_PER_CYCLE;\n// we absorb 136 elements per cycle, and add 160 elements per cycle, so we need to skip memory reads\n// sometimes and do absorbs instead\npub const BUFFER_SIZE_IN_U64_WORDS: usize =\n-    MEMORY_EQURIES_PER_CYCLE * 4 + KECCAK256_RATE_IN_U64_WORDS - 1;\n+    MEMORY_QUERIES_PER_CYCLE * 4 + KECCAK256_RATE_IN_U64_WORDS - 1;\n```\n\n[Governance, line 83](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/contracts/ethereum/contracts/governance/Governance.sol#L83) - `both` is for two elements, not three.\n\n```diff\n-    /// includes both Waiting, Ready, and Done operations.\n+    /// includes Waiting, Ready, and Done operations.\n```\n\n[NonceHolder, line 18](https://github.com/code-423n4/2023-10-zksync/blob/c3ff020df5d11fe91209bd99d7fb0ec1272dc387/code/system-contracts/contracts/NonceHolder.sol#L18C29-L18C31) - it is `mark`, not `either marked` as it is a sentence without a replica.\n\n```diff\n- * The users can either marked a range of nonces by increasing the `minNonce`. This way all the nonces\n+ * The users can mark a range of nonces by increasing the `minNonce`. This way all the nonces\n```\n\n[NonceHolder, line 29](https://github.com/code-423n4/2023-10-zksync/blob/c3ff020df5d11fe91209bd99d7fb0ec1272dc387/code/system-contracts/contracts/NonceHolder.sol#L29C42-L29C44) - remove the first `at`.\n\n```diff\n-    /// The minNonce can be increased by at 2^32 at a time to prevent it from\n+    /// The minNonce can be increased by 2^32 at a time to prevent it from\n```\n\n[uma.rs, line 222](https://github.com/code-423n4/2023-10-zksync/blob/c3ff020df5d11fe91209bd99d7fb0ec1272dc387/code/era-zkevm_circuits/src/main_vm/opcodes/uma.rs#L222C12-L222C20) - `Ethereum`, not `Etherium`.\n\n```diff\n-    // NB: Etherium virtual machine is big endian;\n+    // NB: Ethereum virtual machine is big endian;\n```\n\n[cycle.rs, line 504](https://github.com/code-423n4/2023-10-zksync/blob/c3ff020df5d11fe91209bd99d7fb0ec1272dc387/code/era-zkevm_circuits/src/main_vm/cycle.rs#L504C8-L504C11) - `Aux`, not `aux`.\n\n```diff\n-    // Axu heap limit\n+    // Aux heap limit\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/libraries/SystemContractHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {MAX_SYSTEM_CONTRACT_ADDRESS} from \"../Constants.sol\";\n\nimport {\n    SystemContractsCaller,\n    CalldataForwardingMode,\n    CALLFLAGS_CALL_ADDRESS,\n    CODE_ADDRESS_CALL_ADDRESS,\n    EVENT_WRITE_ADDRESS,\n    EVENT_INITIALIZE_ADDRESS,\n    GET_EXTRA_ABI_DATA_ADDRESS,\n    LOAD_CALLDATA_INTO_ACTIVE_PTR_CALL_ADDRESS,\n    META_CODE_SHARD_ID_OFFSET,\n    META_CALLER_SHARD_ID_OFFSET,\n    META_SHARD_ID_OFFSET,\n    META_AUX_HEAP_SIZE_OFFSET,\n    META_HEAP_SIZE_OFFSET,\n    META_GAS_PER_PUBDATA_BYTE_OFFSET,\n    MIMIC_CALL_BY_REF_CALL_ADDRESS,\n    META_CALL_ADDRESS,\n    MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT,\n    PTR_CALLDATA_CALL_ADDRESS,\n    PTR_ADD_INTO_ACTIVE_CALL_ADDRESS,\n    PTR_SHRINK_INTO_ACTIVE_CALL_ADDRESS,\n    PTR_PACK_INTO_ACTIVE_CALL_ADDRESS,\n    RAW_FAR_CALL_BY_REF_CALL_ADDRESS,\n    PRECOMPILE_CALL_ADDRESS,\n    SET_CONTEXT_VALUE_CALL_ADDRESS,\n    SYSTEM_CALL_BY_REF_CALL_ADDRESS,\n    TO_L1_CALL_ADDRESS\n} from \"./SystemContractsCaller.sol\";\n\nuint256 constant UINT32_MASK = 0xffffffff;\nuint256 constant UINT128_MASK = 0xffffffffffffffffffffffffffffffff;\n/// @dev The mask that is used to convert any uint256 to a proper address.\n/// It needs to be padded with `00` to be treated as uint256 by Solidity\nuint256 constant ADDRESS_MASK = 0x00ffffffffffffffffffffffffffffffffffffffff;\n\nstruct ZkSyncMeta {\n    uint32 gasPerPubdataByte;\n    uint32 heapSize;\n    uint32 auxHeapSize;\n    uint8 shardId;\n    uint8 callerShardId;\n    uint8 codeShardId;\n}\n\nenum Global {\n    CalldataPtr,\n    CallFlags,\n    ExtraABIData1,\n    ExtraABIData2,\n    ReturndataPtr\n}\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Library used for accessing zkEVM-specific opcodes, needed for the development\n * of system contracts.\n * @dev While this library will be eventually available to public, some of the provided\n * methods won't work for non-system contracts. We will not recommend this library\n * for external use.\n */\nlibrary SystemContractHelper {\n    /// @notice Send an L2Log to L1.\n    /// @param _isService The `isService` flag.\n    /// @param _key The `key` part of the L2Log.\n    /// @param _value The `value` part of the L2Log.\n    /// @dev The meaning of all these parameters is context-dependent, but they\n    /// have no intrinsic meaning per se.\n    function toL1(bool _isService, bytes32 _key, bytes32 _value) internal {\n        address callAddr = TO_L1_CALL_ADDRESS;\n        assembly {\n            // Ensuring that the type is bool\n            _isService := and(_isService, 1)\n            // This `success` is always 0, but the method always succeeds\n            // (except for the cases when there is not enough gas)\n            let success := call(_isService, callAddr, _key, _value, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Get address of the currently executed code.\n    /// @dev This allows differentiating between `call` and `delegatecall`.\n    /// During the former `this` and `codeAddress` are the same, while\n    /// during the latter they are not.\n    function getCodeAddress() internal view returns (address addr) {\n        address callAddr = CODE_ADDRESS_CALL_ADDRESS;\n        assembly {\n            addr := staticcall(0, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Provide a compiler hint, by placing calldata fat pointer into virtual `ACTIVE_PTR`,\n    /// that can be manipulated by `ptr.add`/`ptr.sub`/`ptr.pack`/`ptr.shrink` later.\n    /// @dev This allows making a call by forwarding calldata pointer to the child call.\n    /// It is a much more efficient way to forward calldata, than standard EVM bytes copying.\n    function loadCalldataIntoActivePtr() internal view {\n        address callAddr = LOAD_CALLDATA_INTO_ACTIVE_PTR_CALL_ADDRESS;\n        assembly {\n            pop(staticcall(0, callAddr, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice Compiler simulation of the `ptr.pack` opcode for the virtual `ACTIVE_PTR` pointer.\n    /// @dev Do the concatenation between lowest part of `ACTIVE_PTR` and highest part of `_farCallAbi`\n    /// forming packed fat pointer for a far call or ret ABI when necessary.\n    /// Note: Panics if the lowest 128 bits of `_farCallAbi` are not zeroes.\n    function ptrPackIntoActivePtr(uint256 _farCallAbi) internal view {\n        address callAddr = PTR_PACK_INTO_ACTIVE_CALL_ADDRESS;\n        assembly {\n            pop(staticcall(_farCallAbi, callAddr, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice Compiler simulation of the `ptr.add` opcode for the virtual `ACTIVE_PTR` pointer.\n    /// @dev Transforms `ACTIVE_PTR.offset` into `ACTIVE_PTR.offset + u32(_value)`. If overflow happens then it panics.\n    function ptrAddIntoActive(uint32 _value) internal view {\n        address callAddr = PTR_ADD_INTO_ACTIVE_CALL_ADDRESS;\n        uint256 cleanupMask = UINT32_MASK;\n        assembly {\n            // Clearing input params as they are not cleaned by Solidity by default\n            _value := and(_value, cleanupMask)\n            pop(staticcall(_value, callAddr, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice Compiler simulation of the `ptr.shrink` opcode for the virtual `ACTIVE_PTR` pointer.\n    /// @dev Transforms `ACTIVE_PTR.length` into `ACTIVE_PTR.length - u32(_shrink)`. If underflow happens then it panics.\n    function ptrShrinkIntoActive(uint32 _shrink) internal view {\n        address callAddr = PTR_SHRINK_INTO_ACTIVE_CALL_ADDRESS;\n        uint256 cleanupMask = UINT32_MASK;\n        assembly {\n            // Clearing input params as they are not cleaned by Solidity by default\n            _shrink := and(_shrink, cleanupMask)\n            pop(staticcall(_shrink, callAddr, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice packs precompile parameters into one word\n    /// @param _inputMemoryOffset The memory offset in 32-byte words for the input data for calling the precompile.\n    /// @param _inputMemoryLength The length of the input data in words.\n    /// @param _outputMemoryOffset The memory offset in 32-byte words for the output data.\n    /// @param _outputMemoryLength The length of the output data in words.\n    /// @param _perPrecompileInterpreted The constant, the meaning of which is defined separately for\n    /// each precompile. For information, please read the documentation of the precompilecall log in\n    /// the VM.\n    function packPrecompileParams(\n        uint32 _inputMemoryOffset,\n        uint32 _inputMemoryLength,\n        uint32 _outputMemoryOffset,\n        uint32 _outputMemoryLength,\n        uint64 _perPrecompileInterpreted\n    ) internal pure returns (uint256 rawParams) {\n        rawParams = _inputMemoryOffset;\n        rawParams |= uint256(_inputMemoryLength) << 32;\n        rawParams |= uint256(_outputMemoryOffset) << 64;\n        rawParams |= uint256(_outputMemoryLength) << 96;\n        rawParams |= uint256(_perPrecompileInterpreted) << 192;\n    }\n\n    /// @notice Call precompile with given parameters.\n    /// @param _rawParams The packed precompile params. They can be retrieved by\n    /// the `packPrecompileParams` method.\n    /// @param _gasToBurn The number of gas to burn during this call.\n    /// @return success Whether the call was successful.\n    /// @dev The list of currently available precompiles sha256, keccak256, ecrecover.\n    /// NOTE: The precompile type depends on `this` which calls precompile, which means that only\n    /// system contracts corresponding to the list of precompiles above can do `precompileCall`.\n    /// @dev If used not in the `sha256`, `keccak256` or `ecrecover` contracts, it will just burn the gas provided.\n    /// @dev This method is `unsafe` because it does not check whether there is enough gas to burn.\n    function unsafePrecompileCall(uint256 _rawParams, uint32 _gasToBurn) internal view returns (bool success) {\n        address callAddr = PRECOMPILE_CALL_ADDRESS;\n\n        uint256 cleanupMask = UINT32_MASK;\n        assembly {\n            // Clearing input params as they are not cleaned by Solidity by default\n            _gasToBurn := and(_gasToBurn, cleanupMask)\n            success := staticcall(_rawParams, callAddr, _gasToBurn, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Set `msg.value` to next far call.\n    /// @param _value The msg.value that will be used for the *next* call.\n    /// @dev If called not in kernel mode, it will result in a revert (enforced by the VM)\n    function setValueForNextFarCall(uint128 _value) internal returns (bool success) {\n        uint256 cleanupMask = UINT128_MASK;\n        address callAddr = SET_CONTEXT_VALUE_CALL_ADDRESS;\n        assembly {\n            // Clearing input params as they are not cleaned by Solidity by default\n            _value := and(_value, cleanupMask)\n            success := call(0, callAddr, _value, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Initialize a new event.\n    /// @param initializer The event initializing value.\n    /// @param value1 The first topic or data chunk.\n    function eventInitialize(uint256 initializer, uint256 value1) internal {\n        address callAddr = EVENT_INITIALIZE_ADDRESS;\n        assembly {\n            pop(call(initializer, callAddr, value1, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice Continue writing the previously initialized event.\n    /// @param value1 The first topic or data chunk.\n    /// @param value2 The second topic or data chunk.\n    function eventWrite(uint256 value1, uint256 value2) internal {\n        address callAddr = EVENT_WRITE_ADDRESS;\n        assembly {\n            pop(call(value1, callAddr, value2, 0, 0xFFFF, 0, 0))\n        }\n    }\n\n    /// @notice Get the packed representation of the `ZkSyncMeta` from the current context.\n    /// @return meta The packed representation of the ZkSyncMeta.\n    /// @dev The fields in ZkSyncMeta are NOT tightly packed, i.e. there is a special rule on how\n    /// they are packed. For more information, please read the documentation on ZkSyncMeta.\n    function getZkSyncMetaBytes() internal view returns (uint256 meta) {\n        address callAddr = META_CALL_ADDRESS;\n        assembly {\n            meta := staticcall(0, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Returns the bits [offset..offset+size-1] of the meta.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @param offset The offset of the bits.\n    /// @param size The size of the extracted number in bits.\n    /// @return result The extracted number.\n    function extractNumberFromMeta(uint256 meta, uint256 offset, uint256 size) internal pure returns (uint256 result) {\n        // Firstly, we delete all the bits after the field\n        uint256 shifted = (meta << (256 - size - offset));\n        // Then we shift everything back\n        result = (shifted >> (256 - size));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the number of gas\n    /// that a single byte sent to L1 as pubdata costs.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return gasPerPubdataByte The current price in gas per pubdata byte.\n    function getGasPerPubdataByteFromMeta(uint256 meta) internal pure returns (uint32 gasPerPubdataByte) {\n        gasPerPubdataByte = uint32(extractNumberFromMeta(meta, META_GAS_PER_PUBDATA_BYTE_OFFSET, 32));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the number of the current size\n    /// of the heap in bytes.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return heapSize The size of the memory in bytes byte.\n    /// @dev The following expression: getHeapSizeFromMeta(getZkSyncMetaBytes()) is\n    /// equivalent to the MSIZE in Solidity.\n    function getHeapSizeFromMeta(uint256 meta) internal pure returns (uint32 heapSize) {\n        heapSize = uint32(extractNumberFromMeta(meta, META_HEAP_SIZE_OFFSET, 32));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the number of the current size\n    /// of the auxilary heap in bytes.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return auxHeapSize The size of the auxilary memory in bytes byte.\n    /// @dev You can read more on auxilary memory in the VM1.2 documentation.\n    function getAuxHeapSizeFromMeta(uint256 meta) internal pure returns (uint32 auxHeapSize) {\n        auxHeapSize = uint32(extractNumberFromMeta(meta, META_AUX_HEAP_SIZE_OFFSET, 32));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the shardId of `this`.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return shardId The shardId of `this`.\n    /// @dev Currently only shard 0 (zkRollup) is supported.\n    function getShardIdFromMeta(uint256 meta) internal pure returns (uint8 shardId) {\n        shardId = uint8(extractNumberFromMeta(meta, META_SHARD_ID_OFFSET, 8));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the shardId of\n    /// the msg.sender.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return callerShardId The shardId of the msg.sender.\n    /// @dev Currently only shard 0 (zkRollup) is supported.\n    function getCallerShardIdFromMeta(uint256 meta) internal pure returns (uint8 callerShardId) {\n        callerShardId = uint8(extractNumberFromMeta(meta, META_CALLER_SHARD_ID_OFFSET, 8));\n    }\n\n    /// @notice Given the packed representation of `ZkSyncMeta`, retrieves the shardId of\n    /// the currently executed code.\n    /// @param meta Packed representation of the ZkSyncMeta.\n    /// @return codeShardId The shardId of the currently executed code.\n    /// @dev Currently only shard 0 (zkRollup) is supported.\n    function getCodeShardIdFromMeta(uint256 meta) internal pure returns (uint8 codeShardId) {\n        codeShardId = uint8(extractNumberFromMeta(meta, META_CODE_SHARD_ID_OFFSET, 8));\n    }\n\n    /// @notice Retrieves the ZkSyncMeta structure.\n    /// @return meta The ZkSyncMeta execution context parameters.\n    function getZkSyncMeta() internal view returns (ZkSyncMeta memory meta) {\n        uint256 metaPacked = getZkSyncMetaBytes();\n        meta.gasPerPubdataByte = getGasPerPubdataByteFromMeta(metaPacked);\n        meta.shardId = getShardIdFromMeta(metaPacked);\n        meta.callerShardId = getCallerShardIdFromMeta(metaPacked);\n        meta.codeShardId = getCodeShardIdFromMeta(metaPacked);\n    }\n\n    /// @notice Returns the call flags for the current call.\n    /// @return callFlags The bitmask of the callflags.\n    /// @dev Call flags is the value of the first register\n    /// at the start of the call.\n    /// @dev The zero bit of the callFlags indicates whether the call is\n    /// a constructor call. The first bit of the callFlags indicates whether\n    /// the call is a system one.\n    function getCallFlags() internal view returns (uint256 callFlags) {\n        address callAddr = CALLFLAGS_CALL_ADDRESS;\n        assembly {\n            callFlags := staticcall(0, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Returns the current calldata pointer.\n    /// @return ptr The current calldata pointer.\n    /// @dev NOTE: This file is just an integer and it cannot be used\n    /// to forward the calldata to the next calls in any way.\n    function getCalldataPtr() internal view returns (uint256 ptr) {\n        address callAddr = PTR_CALLDATA_CALL_ADDRESS;\n        assembly {\n            ptr := staticcall(0, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Returns the N-th extraAbiParam for the current call.\n    /// @return extraAbiData The value of the N-th extraAbiParam for this call.\n    /// @dev It is equal to the value of the (N+2)-th register\n    /// at the start of the call.\n    function getExtraAbiData(uint256 index) internal view returns (uint256 extraAbiData) {\n        require(index < 10, \"There are only 10 accessible registers\");\n\n        address callAddr = GET_EXTRA_ABI_DATA_ADDRESS;\n        assembly {\n            extraAbiData := staticcall(index, callAddr, 0, 0xFFFF, 0, 0)\n        }\n    }\n\n    /// @notice Retuns whether the current call is a system call.\n    /// @return `true` or `false` based on whether the current call is a system call.\n    function isSystemCall() internal view returns (bool) {\n        uint256 callFlags = getCallFlags();\n        // When the system call is passed, the 2-bit it set to 1\n        return (callFlags & 2) != 0;\n    }\n\n    /// @notice Returns whether the address is a system contract.\n    /// @param _address The address to test\n    /// @return `true` or `false` based on whether the `_address` is a system contract.\n    function isSystemContract(address _address) internal pure returns (bool) {\n        return uint160(_address) <= uint160(MAX_SYSTEM_CONTRACT_ADDRESS);\n    }\n\n    /// @notice Method used for burning a certain amount of gas.\n    /// @param _gasToPay The number of gas to burn.\n    function burnGas(uint32 _gasToPay) internal view {\n        bool precompileCallSuccess = unsafePrecompileCall(\n            0, // The precompile parameters are formal ones. We only need the precompile call to burn gas.\n            _gasToPay\n        );\n        require(precompileCallSuccess, \"Failed to charge gas\");\n    }\n}"
    },
    {
      "filename": "code/system-contracts/contracts/KnownCodesStorage.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IKnownCodesStorage} from \"./interfaces/IKnownCodesStorage.sol\";\nimport {ISystemContract} from \"./interfaces/ISystemContract.sol\";\nimport {Utils} from \"./libraries/Utils.sol\";\nimport {SystemContractHelper} from \"./libraries/SystemContractHelper.sol\";\nimport {COMPRESSOR_CONTRACT, L1_MESSENGER_CONTRACT} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice The storage of this contract will basically serve as a mapping for the known code hashes.\n * @dev Code hash is not strictly a hash, it's a structure where the first byte denotes the version of the hash,\n * the second byte denotes whether the contract is constructed, and the next two bytes denote the length in 32-byte words.\n * words. And then the next 28 bytes is the truncated hash.\n */\ncontract KnownCodesStorage is IKnownCodesStorage, ISystemContract {\n    modifier onlyCompressor() {\n        require(msg.sender == address(COMPRESSOR_CONTRACT), \"Callable only by the compressor\");\n        _;\n    }\n\n    /// @notice The method that is used by the bootloader to mark several bytecode hashes as known.\n    /// @param _shouldSendToL1 Whether the bytecode should be sent on L1.\n    /// @param _hashes Hashes of the bytecodes to be marked as known.\n    function markFactoryDeps(bool _shouldSendToL1, bytes32[] calldata _hashes) external onlyCallFromBootloader {\n        unchecked {\n            uint256 hashesLen = _hashes.length;\n            for (uint256 i = 0; i < hashesLen; ++i) {\n                _markBytecodeAsPublished(_hashes[i], _shouldSendToL1);\n            }\n        }\n    }\n\n    /// @notice The method used to mark a single bytecode hash as known.\n    /// @dev Only trusted contacts can call this method, currently only the bytecode compressor.\n    /// @param _bytecodeHash The hash of the bytecode that is marked as known.\n    function markBytecodeAsPublished(bytes32 _bytecodeHash) external onlyCompressor {\n        _markBytecodeAsPublished(_bytecodeHash, false);\n    }\n\n    /// @notice The method used to mark a single bytecode hash as known\n    /// @param _bytecodeHash The hash of the bytecode that is marked as known\n    /// @param _shouldSendToL1 Whether the bytecode should be sent on L1\n    function _markBytecodeAsPublished(bytes32 _bytecodeHash, bool _shouldSendToL1) internal {\n        if (getMarker(_bytecodeHash) == 0) {\n            _validateBytecode(_bytecodeHash);\n\n            if (_shouldSendToL1) {\n                L1_MESSENGER_CONTRACT.requestBytecodeL1Publication(_bytecodeHash);\n            }\n\n            // Save as known, to not resend the log to L1\n            assembly {\n                sstore(_bytecodeHash, 1)\n            }\n\n            emit MarkedAsKnown(_bytecodeHash, _shouldSendToL1);\n        }\n    }\n\n    /// @notice Returns the marker stored for a bytecode hash. 1 means that the bytecode hash is known\n    /// and can be used for deploying contracts. 0 otherwise.\n    function getMarker(bytes32 _hash) public view override returns (uint256 marker) {\n        assembly {\n            marker := sload(_hash)\n        }\n    }\n\n    /// @notice Validates the format of bytecodehash\n    /// @dev zk-circuit accepts & handles only valid format of bytecode hash, other input has undefined behavior\n    /// That's why we need to validate it\n    function _validateBytecode(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), \"Incorrectly formatted bytecodeHash\");\n\n        require(Utils.bytecodeLenInWords(_bytecodeHash) % 2 == 1, \"Code length in words must be odd\");\n    }\n}"
    },
    {
      "filename": "code/system-contracts/contracts/SystemContext.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ISystemContext} from \"./interfaces/ISystemContext.sol\";\nimport {ISystemContract} from \"./interfaces/ISystemContract.sol\";\nimport {ISystemContextDeprecated} from \"./interfaces/ISystemContextDeprecated.sol\";\nimport {SystemContractHelper} from \"./libraries/SystemContractHelper.sol\";\nimport {BOOTLOADER_FORMAL_ADDRESS, SystemLogKey} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Contract that stores some of the context variables, that may be either\n * block-scoped, tx-scoped or system-wide.\n */\ncontract SystemContext is ISystemContext, ISystemContextDeprecated, ISystemContract {\n    /// @notice The number of latest L2 blocks to store.\n    /// @dev EVM requires us to be able to query the hashes of previous 256 blocks.\n    /// We could either:\n    /// - Store the latest 256 hashes (and strictly rely that we do not accidentally override the hash of the block 256 blocks ago)\n    /// - Store the latest 257 blocks's hashes.\n    uint256 internal constant MINIBLOCK_HASHES_TO_STORE = 257;\n\n    /// @notice The chainId of the network. It is set at the genesis.\n    uint256 public chainId;\n\n    /// @notice The `tx.origin` in the current transaction.\n    /// @dev It is updated before each transaction by the bootloader\n    address public origin;\n\n    /// @notice The `tx.gasPrice` in the current transaction.\n    /// @dev It is updated before each transaction by the bootloader\n    uint256 public gasPrice;\n\n    /// @notice The current block's gasLimit.\n    uint256 public blockGasLimit = type(uint32).max;\n\n    /// @notice The `block.coinbase` in the current transaction.\n    /// @dev For the support of coinbase, we will use the bootloader formal address for now\n    address public coinbase = BOOTLOADER_FORMAL_ADDRESS;\n\n    /// @notice Formal `block.difficulty` parameter.\n    uint256 public difficulty = 2500000000000000;\n\n    /// @notice The `block.basefee`.\n    /// @dev It is currently a constant.\n    uint256 public baseFee;\n\n    /// @notice The number and the timestamp of the current L1 batch stored packed.\n    BlockInfo internal currentBatchInfo;\n\n    /// @notice The hashes of batches.\n    /// @dev It stores batch hashes for all previous batches.\n    mapping(uint256 => bytes32) internal batchHash;\n\n    /// @notice The number and the timestamp of the current L2 block.\n    BlockInfo internal currentL2BlockInfo;\n\n    /// @notice The rolling hash of the transactions in the current L2 block.\n    bytes32 internal currentL2BlockTxsRollingHash;\n\n    /// @notice The hashes of L2 blocks.\n    /// @dev It stores block hashes for previous L2 blocks. Note, in order to make publishing the hashes\n    /// of the miniblocks cheaper, we only store the previous MINIBLOCK_HASHES_TO_STORE ones. Since whenever we need to publish a state\n    /// diff, a pair of <key, value> is published and for cached keys only 8-byte id is used instead of 32 bytes.\n    /// By having this data in a cyclic array of MINIBLOCK_HASHES_TO_STORE blocks, we bring the costs down by 40% (i.e. 40 bytes per miniblock instead of 64 bytes).\n    /// @dev The hash of a miniblock with number N would be stored under slot N%MINIBLOCK_HASHES_TO_STORE.\n    /// @dev Hashes of the blocks older than the ones which are stored here can be calculated as _calculateLegacyL2BlockHash(blockNumber).\n    bytes32[MINIBLOCK_HASHES_TO_STORE] internal l2BlockHash;\n\n    /// @notice To make migration to L2 blocks smoother, we introduce a temporary concept of virtual L2 blocks, the data\n    /// about which will be returned by the EVM-like methods: block.number/block.timestamp/blockhash.\n    /// - Their number will start from being equal to the number of the batch and it will increase until it reaches the L2 block number.\n    /// - Their timestamp is updated each time a new virtual block is created.\n    /// - Their hash is calculated as `keccak256(uint256(number))`\n    BlockInfo internal currentVirtualL2BlockInfo;\n\n    /// @notice The information about the virtual blocks upgrade, which tracks when the migration to the L2 blocks has started and finished.\n    VirtualBlockUpgradeInfo internal virtualBlockUpgradeInfo;\n\n    /// @notice Number of current transaction in block.\n    uint16 public txNumberInBlock;\n\n    /// @notice Set the current tx origin.\n    /// @param _newOrigin The new tx origin.\n    function setTxOrigin(address _newOrigin) external onlyCallFromBootloader {\n        origin = _newOrigin;\n    }\n\n    /// @notice Set the the current gas price.\n    /// @param _gasPrice The new tx gasPrice.\n    function setGasPrice(uint256 _gasPrice) external onlyCallFromBootloader {\n        gasPrice = _gasPrice;\n    }\n\n    /// @notice The method that emulates `blockhash` opcode in EVM.\n    /// @dev Just like the blockhash in the EVM, it returns bytes32(0),\n    /// when queried about hashes that are older than 256 blocks ago.\n    /// @dev Since zksolc compiler calls this method to emulate `blockhash`,\n    /// its signature can not be changed to `getL2BlockHashEVM`.\n    /// @return hash The blockhash of the block with the given number.\n    function getBlockHashEVM(uint256 _block) external view returns (bytes32 hash) {\n        uint128 blockNumber = currentVirtualL2BlockInfo.number;\n\n        VirtualBlockUpgradeInfo memory currentVirtualBlockUpgradeInfo = virtualBlockUpgradeInfo;\n\n        // Due to virtual blocks upgrade, we'll have to use the following logic for retreiving the blockhash:\n        // 1. If the block number is out of the 256-block supported range, return 0.\n        // 2. If the block was created before the upgrade for the virtual blocks (i.e. there we used to use hashes of the batches),\n        // we return the hash of the batch.\n        // 3. If the block was created after the day when the virtual blocks have caught up with the L2 blocks, i.e.\n        // all the information which is returned for users should be for L2 blocks, we return the hash of the corresponding L2 block.\n        // 4. If the block queried is a virtual blocks, calculate it on the fly.\n        if (blockNumber <= _block || blockNumber - _block > 256) {\n            hash = bytes32(0);\n        } else if (_block < currentVirtualBlockUpgradeInfo.virtualBlockStartBatch) {\n            // Note, that we will get into this branch only for a brief moment of time, right after the upgrade\n            // for virtual blocks before 256 virtual blocks are produced.\n            hash = batchHash[_block];\n        } else if (\n            _block >= currentVirtualBlockUpgradeInfo.virtualBlockFinishL2Block &&\n            currentVirtualBlockUpgradeInfo.virtualBlockFinishL2Block > 0\n        ) {\n            hash = _getLatest257L2blockHash(_block);\n        } else {\n            // Important: we do not want this number to ever collide with the L2 block hash (either new or old one) and so\n            // that's why the legacy L2 blocks' hashes are keccak256(abi.encodePacked(uint32(_block))), while these are equivalent to\n            // keccak256(abi.encodePacked(_block))\n            hash = keccak256(abi.encode(_block));\n        }\n    }\n\n    /// @notice Returns the hash of the given batch.\n    /// @param _batchNumber The number of the batch.\n    /// @return hash The hash of the batch.\n    function getBatchHash(uint256 _batchNumber) external view returns (bytes32 hash) {\n        hash = batchHash[_batchNumber];\n    }\n\n    /// @notice Returns the current batch's number and timestamp.\n    /// @return batchNumber and batchTimestamp tuple of the current batch's number and the current batch's timestamp\n    function getBatchNumberAndTimestamp() public view returns (uint128 batchNumber, uint128 batchTimestamp) {\n        BlockInfo memory batchInfo = currentBatchInfo;\n        batchNumber = batchInfo.number;\n        batchTimestamp = batchInfo.timestamp;\n    }\n\n    /// @notice Returns the current block's number and timestamp.\n    /// @return blockNumber and blockTimestamp tuple of the current L2 block's number and the current block's timestamp\n    function getL2BlockNumberAndTimestamp() public view returns (uint128 blockNumber, uint128 blockTimestamp) {\n        BlockInfo memory blockInfo = currentL2BlockInfo;\n        blockNumber = blockInfo.number;\n        blockTimestamp = blockInfo.timestamp;\n    }\n\n    /// @notice Returns the current L2 block's number.\n    /// @dev Since zksolc compiler calls this method to emulate `block.number`,\n    /// its signature can not be changed to `getL2BlockNumber`.\n    /// @return blockNumber The current L2 block's number.\n    function getBlockNumber() public view returns (uint128) {\n        return currentVirtualL2BlockInfo.number;\n    }\n\n    /// @notice Returns the current L2 block's timestamp.\n    /// @dev Since zksolc compiler calls this method to emulate `block.timestamp`,\n    /// its signature can not be changed to `getL2BlockTimestamp`.\n    /// @return timestamp The current L2 block's timestamp.\n    function getBlockTimestamp() public view returns (uint128) {\n        return currentVirtualL2BlockInfo.timestamp;\n    }\n\n    /// @notice Assuming that block is one of the last MINIBLOCK_HASHES_TO_STORE ones, returns its hash.\n    /// @param _block The number of the block.\n    /// @return hash The hash of the block.\n    function _getLatest257L2blockHash(uint256 _block) internal view returns (bytes32) {\n        return l2BlockHash[_block % MINIBLOCK_HASHES_TO_STORE];\n    }\n\n    /// @notice Assuming that the block is one of the last MINIBLOCK_HASHES_TO_STORE ones, sets its hash.\n    /// @param _block The number of the block.\n    /// @param _hash The hash of the block.\n    function _setL2BlockHash(uint256 _block, bytes32 _hash) internal {\n        l2BlockHash[_block % MINIBLOCK_HASHES_TO_STORE] = _hash;\n    }\n\n    /// @notice Calculates the hash of an L2 block.\n    /// @param _blockNumber The number of the L2 block.\n    /// @param _blockTimestamp The timestamp of the L2 block.\n    /// @param _prevL2BlockHash The hash of the previous L2 block.\n    /// @param _blockTxsRollingHash The rolling hash of the transactions in the L2 block.\n    function _calculateL2BlockHash(\n        uint128 _blockNumber,\n        uint128 _blockTimestamp,\n        bytes32 _prevL2BlockHash,\n        bytes32 _blockTxsRollingHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_blockNumber, _blockTimestamp, _prevL2BlockHash, _blockTxsRollingHash));\n    }\n\n    /// @notice Calculates the legacy block hash of L2 block, which were used before the upgrade where\n    /// the advanced block hashes were introduced.\n    /// @param _blockNumber The number of the L2 block.\n    function _calculateLegacyL2BlockHash(uint128 _blockNumber) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(uint32(_blockNumber)));\n    }\n\n    /// @notice Performs the upgrade where we transition to the L2 blocks.\n    /// @param _l2BlockNumber The number of the new L2 block.\n    /// @param _expectedPrevL2BlockHash The expected hash of the previous L2 block.\n    /// @param _isFirstInBatch Whether this method is called for the first time in the batch.\n    function _upgradeL2Blocks(uint128 _l2BlockNumber, bytes32 _expectedPrevL2BlockHash, bool _isFirstInBatch) internal {\n        require(_isFirstInBatch, \"Upgrade transaction must be first\");\n\n        // This is how it will be commonly done in practice, but it will simplify some logic later\n        require(_l2BlockNumber > 0, \"L2 block number is never expected to be zero\");\n\n        unchecked {\n            bytes32 correctPrevBlockHash = _calculateLegacyL2BlockHash(uint128(_l2BlockNumber - 1));\n            require(correctPrevBlockHash == _expectedPrevL2BlockHash, \"The previous L2 block hash is incorrect\");"
    }
  ]
}