{
  "Title": "[L04] Missing ancillary data stamp",
  "Content": "When requesting a price on the `OracleSpoke` contract, the provided ancillary data [is stamped](https://github.com/UMAprotocol/protocol/blob/0c4cea3c3d5e48da6f8984b8ba3afdfea4ce47cc/packages/core/contracts/cross-chain-oracle/OracleSpoke.sol#L66) with the child chain identifier. However, the [`hasPrice`](https://github.com/UMAprotocol/protocol/blob/0c4cea3c3d5e48da6f8984b8ba3afdfea4ce47cc/packages/core/contracts/cross-chain-oracle/OracleSpoke.sol#L107) and [`getPrice`](https://github.com/UMAprotocol/protocol/blob/11c3782a4d4ccc126c70231ad713490ebd476466/packages/core/contracts/cross-chain-oracle/OracleSpoke.sol#L139) functions donâ€™t stamp the ancillary data when identifying the price request. This forces calling contracts to apply the stamp themselves, which causes an inconsistency between the price request and price retrieval mechanisms. Consider applying the stamp in the `hasPrice` and `getPrice` functions.\n\n\n**Update:** *Fixed as of commit [`fdb845d`](https://github.com/UMAprotocol/protocol/pull/3668/commits/fdb845dba5549815bf7b4a7072623b6a6540559f) in [PR3668](https://github.com/UMAprotocol/protocol/pull/3668).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/cross-chain-oracle/OracleSpoke.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"../oracle/interfaces/OracleAncillaryInterface.sol\";\nimport \"../oracle/interfaces/OracleInterface.sol\";\nimport \"../oracle/interfaces/RegistryInterface.sol\";\nimport \"./OracleBase.sol\";\nimport \"../common/implementation/AncillaryData.sol\";\nimport \"../common/implementation/Lockable.sol\";\nimport \"./interfaces/ChildMessengerInterface.sol\";\nimport \"./interfaces/ChildMessengerConsumerInterface.sol\";\n\n/**\n * @title Cross-chain Oracle L2 Oracle Spoke.\n * @notice This contract is primarily intended to receive messages on the child chain from a parent chain and allow\n * contracts deployed on the child chain to interact with this contract as an Oracle. Moreover, this contract gives\n * child chain contracts the ability to trigger cross-chain price requests to the mainnet DVM. This Spoke knows how\n * to communicate with the parent chain via a \"ChildMessenger\" contract which directly communicates with the\n * \"ParentMessenger\" on mainnet.\n * @dev The intended client of this contract is an OptimisticOracle on sidechain that needs price\n * resolution secured by the DVM on mainnet.\n */\ncontract OracleSpoke is\n    OracleBase,\n    OracleAncillaryInterface,\n    OracleInterface,\n    ChildMessengerConsumerInterface,\n    Lockable\n{\n    ChildMessengerInterface public messenger;\n\n    event SetChildMessenger(address indexed childMessenger);\n\n    constructor(address _finderAddress, ChildMessengerInterface _messengerAddress) OracleBase(_finderAddress) {\n        messenger = _messengerAddress;\n        emit SetChildMessenger(address(messenger));\n    }\n\n    // This assumes that the local network has a Registry that resembles the mainnet registry.\n    modifier onlyRegisteredContract() {\n        RegistryInterface registry = RegistryInterface(finder.getImplementationAddress(OracleInterfaces.Registry));\n        require(registry.isContractRegistered(msg.sender), \"Caller must be registered\");\n        _;\n    }\n\n    modifier onlyMessenger() {\n        require(msg.sender == address(messenger), \"Caller must be messenger\");\n        _;\n    }\n\n    /**\n     * @notice This is called to bridge a price request to mainnet. This method will enqueue a new price request\n     * or return silently if already requested. Price requests are relayed to mainnet (the \"Parent\" chain) via\n     * the ChildMessenger contract.\n     * @dev Can be called only by a registered contract that is allowed to make DVM price requests. Will mark this\n     * price request as Requested, and therefore able to receive the price resolution data from mainnet.\n     * @param identifier Identifier of price request.\n     * @param time Timestamp of price request.\n     * @param ancillaryData extra data of price request.\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public override nonReentrant() onlyRegisteredContract() {\n        bool newPriceRequested = _requestPrice(identifier, time, _stampAncillaryData(ancillaryData));\n        if (newPriceRequested) {\n            messenger.sendMessageToParent(abi.encode(identifier, time, _stampAncillaryData(ancillaryData)));\n        }\n    }\n\n    /**\n     * @notice Overloaded function to provide backwards compatibility for legacy financial contracts that do not use\n     * ancillary data.\n     */\n    function requestPrice(bytes32 identifier, uint256 time) public override nonReentrant() onlyRegisteredContract() {\n        bool newPriceRequested = _requestPrice(identifier, time, _stampAncillaryData(\"\"));\n        if (newPriceRequested) {\n            messenger.sendMessageToParent(abi.encode(identifier, time, _stampAncillaryData(\"\")));\n        }\n    }\n\n    /**\n     * @notice Resolves a price request originating from a message sent by the DVM on the parent chain. This method\n     * must be called by the ChildMessenger contract which is designed to communicate only with the ParentMessenger\n     * contract on Mainnet.\n     * @param data ABI encoded params with which to call `_publishPrice`.\n     */\n    function processMessageFromParent(bytes memory data) public override nonReentrant() onlyMessenger() {\n        (bytes32 identifier, uint256 time, bytes memory ancillaryData, int256 price) =\n            abi.decode(data, (bytes32, uint256, bytes, int256));\n        _publishPrice(identifier, time, ancillaryData, price);\n    }\n\n    /**\n     * @notice Returns whether a price has resolved for the request. This method will not revert.\n     * @param identifier Identifier of price request.\n     * @param time Timestamp of price request\n     * @param ancillaryData extra data of price request.\n     * @return True if a price is available, False otherwise. If true, then getPrice will succeed for the request.\n     */\n    function hasPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override nonReentrantView() onlyRegisteredContract() returns (bool) {\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, ancillaryData);\n        return prices[priceRequestId].state == RequestState.Resolved;\n    }\n\n    /**\n     * @notice Overloaded function to provide backwards compatibility for legacy financial contracts that do not use\n     * ancillary data.\n     */\n    function hasPrice(bytes32 identifier, uint256 time)\n        public\n        view\n        override\n        nonReentrantView()\n        onlyRegisteredContract()\n        returns (bool)\n    {\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, _stampAncillaryData(\"\"));\n        return prices[priceRequestId].state == RequestState.Resolved;\n    }\n\n    /**\n     * @notice Returns resolved price for the request. Reverts if price is not available.\n     * @param identifier Identifier of price request.\n     * @param time Timestamp of price request\n     * @param ancillaryData extra data of price request.\n     * @return int256 Price, or reverts if no resolved price for any reason.\n     */\n    function getPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override nonReentrantView() onlyRegisteredContract() returns (int256) {\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, ancillaryData);\n        Price storage lookup = prices[priceRequestId];\n        require(lookup.state == RequestState.Resolved, \"Price has not been resolved\");\n        return lookup.price;\n    }\n\n    /**\n     * @notice Overloaded function to provide backwards compatibility for legacy financial contracts that do not use\n     * ancillary data.\n     */\n    function getPrice(bytes32 identifier, uint256 time)\n        public\n        view\n        override\n        nonReentrantView()\n        onlyRegisteredContract()\n        returns (int256)\n    {\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, _stampAncillaryData(\"\"));\n        Price storage lookup = prices[priceRequestId];\n        require(lookup.state == RequestState.Resolved, \"Price has not been resolved\");\n        return lookup.price;\n    }\n\n    /**\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return the stamped ancillary bytes.\n     */\n    function stampAncillaryData(bytes memory ancillaryData) public view nonReentrantView() returns (bytes memory) {\n        return _stampAncillaryData(ancillaryData);\n    }\n\n    /**\n     * @dev We don't handle specifically the case where `ancillaryData` is not already readily translatable in utf8.\n     * For those cases, we assume that the client will be able to strip out the utf8-translatable part of the\n     * ancillary data that this contract stamps.\n     */\n    function _stampAncillaryData(bytes memory ancillaryData) internal view returns (bytes memory) {\n        // This contract should stamp the child network's ID so that voters on the parent network can\n        // deterministically track unique price requests back to this contract.\n        return AncillaryData.appendKeyValueUint(ancillaryData, \"childChainId\", block.chainid);\n    }\n}"
    }
  ]
}