{
  "Title": "[M-08] Auction bonder can steal user funds if bond block is high enough",
  "Content": "_Submitted by kenzo_.\n\nAfter an auction has started, as time passes and according to the `bondBlock`, `newRatio` (which starts at 2\\*ibRatio) gets smaller and smaller and therefore less and less tokens need to remain in the basket.\nThis is not capped, and after a while, `newRatio` can become smaller than current `ibRatio`.\n\n#### Impact\n\nIf for some reason nobody has bonded and settled an auction and the publisher didn't stop it, a malicious user can wait until `newRatio` < `ibRatio`, or even until `newRatio` \\~= 0 (for an initial `ibRatio` of \\~1e18 this happens after less than 3.5 days after auction started), and then bond and settle and steal user funds.\n\n#### Proof of Concept\n\nThese are the vulnerable lines:\n<https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Auction.sol#L95:#L105>\n\n```solidity\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\nuint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();\nuint256 newRatio = a - b;\n\n(address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();\nIERC20 basketAsERC20 = IERC20(address(basket));\n\nfor (uint256 i = 0; i < pendingWeights.length; i++) {\nuint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\nrequire(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n}\n```\n\nThe function verifies that `pendingTokens[i].balanceOf(basket) >= basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE`. This is the formula that will be used later to mint/burn/withdraw user funds.\nAs bondBlock increases, newRatio will get smaller, and there is no check on this.\nAfter a while we'll arrive at a point where `newRatio ~= 0`, so `tokensNeeded = newRatio*(...) ~= 0`, so the attacker could withdraw nearly all the tokens using outputTokens and outputWeights, and leave just scraps in the basket.\n\n#### Tools Used\n\nManual analysis, hardhat.\n\n#### Recommended Mitigation Steps\n\nYour needed condition/math might be different, and you might also choose to burn the bond while you're at it, but I think at the minimum you should add a sanity check in `settleAuction`:\n```solidity\nrequire (newRatio > basket.ibRatio());\n```\n\nMaybe you would require `newRatio` to be > BASE but not sure.\n\n**[frank-beard (Kuiper) confirmed](https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/51)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/51#issuecomment-997466418):**\n> Would need to confirm with sponsor:\n> Isn't the point of `settleAuction` to be incentivized by offering a discount over time?\n> If you're offering a discount, then by definition `newRatio` will be less than `basket.ibRatio`\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/51#issuecomment-999134839):**\n> Have yet to hear back from the sponsor.\n>\n> The more I think about it, the more this is a property of the discounted auction, the basket token can be bought for less, and that creates MEV opportunities. This is the economic incentive for bonding and settling the auction (else why do it?)\n>\n> On the other hand there may be situation where the price decay is so aggressive, and the bonding gives a 24hrs privilege for settling which could create a situation where the bonder is incentivized to wait.\n>\n> Locking the discount at the time of bonding, or forcing to bond and settle at the same time may mitigate this (creating effectively a dutch auction for the discounted basket tokens).\n>\n> Given what I understand about the system, I would argue that:\n> - Given a specific `auctionDecrement` and a basket big enough, the bonder has a 24 hour window to maximize the value they can extract, which can end up being too much from what the developer / users may expect.\n>\n> What do you think @frank-beard ?\n\n**[frank-beard (Kuiper) commented](https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/51#issuecomment-999259347):**\n> Agree with @Alex the Entreprenerd. The purpose of the auction is to create an opportunity for participants to rebalance a basket if it is in their interest. However the warden is correct that there can be issues if the `ibRatio` drops too low, or even to 0, which would effectively allow someone to steal funds. We plan to mitigate this by having the auction have a minimum `ibRatio` at which it can be settled.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/51#issuecomment-1001265064):**\n> The vulnerability is reliant on `auctionDecrement` being impactful enough on a 24 hr window (time in which bonder has privileged ability to settle or just stall)\n>\n> If `auctionDecrement` gives a steep enough discount then it can creates scenarios where the bonder can get access to the underlying at no price. This can be taken to the extreme of rebalancing the entire basket (taking all funds)\n>\n> Because of the openness of the protocol am inclined to rate this a medium severity, however, the sponsor needs to be aware that every single time this scenario shows itself it will be abused against the protocol users.\n>\n> Mitigation can happen by either setting a minimum `ibRatio` or by allowing multiple entities to bond and settle at the same, creating a \"prisoners dilemma\" dutch auction that effectively motivates actors to rebalance as early as economically feasible\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-10-defiProtocol",
  "Code": [
    {
      "filename": "contracts/contracts/Auction.sol",
      "content": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IFactory.sol';\nimport './interfaces/IBasket.sol';\nimport \"./interfaces/IAuction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Auction is IAuction, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n    uint256 private constant ONE_DAY = 4 * 60 * 24; // one day in blocks\n    \n    bool public override auctionOngoing;\n    uint256 public override auctionStart;\n    bool public override hasBonded;\n    uint256 public override bondAmount;\n    uint256 public override bondBlock;\n\n    IBasket public override basket;\n    IFactory public override factory;\n    address public override auctionBonder;\n\n    Bounty[] private _bounties;\n\n    bool public override initialized;\n\n    modifier onlyBasket() {\n        require(msg.sender == address(basket), 'not basket');\n        _;\n    }\n\n    function startAuction() onlyBasket public override {\n        require(auctionOngoing == false, 'ongoing auction');\n\n        auctionOngoing = true;\n        auctionStart = block.number;\n\n        emit AuctionStarted();\n    }\n\n    function killAuction() onlyBasket public override {\n        auctionOngoing = false;\n    }\n\n    function initialize(address basket_, address factory_) public override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        basket = IBasket(basket_);\n        factory = IFactory(factory_);\n        initialized = true;\n    }\n\n    function bondForRebalance() public override {\n        require(auctionOngoing);\n        require(!hasBonded);\n\n        bondBlock = block.number;\n\n        IERC20 basketToken = IERC20(address(basket));\n        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        hasBonded = true;\n        auctionBonder = msg.sender;\n\n        emit Bonded(msg.sender, bondAmount);\n    }\n\n    function settleAuction(\n        uint256[] memory bountyIDs,\n        address[] memory inputTokens,\n        uint256[] memory inputWeights,\n        address[] memory outputTokens,\n        uint256[] memory outputWeights\n    ) public nonReentrant override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondBlock + ONE_DAY > block.number);\n        require(msg.sender == auctionBonder);\n        require(inputTokens.length == inputWeights.length);\n        require(outputTokens.length == outputWeights.length);\n\n        for (uint256 i = 0; i < inputTokens.length; i++) {\n            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);\n        }\n\n        for (uint256 i = 0; i < outputTokens.length; i++) {\n            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n        }\n\n        //TODO: name a and b or further split up\n        uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n        uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();\n        uint256 newRatio = a - b;\n\n        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();\n        IERC20 basketAsERC20 = IERC20(address(basket));\n\n        for (uint256 i = 0; i < pendingWeights.length; i++) {\n            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n        }\n\n        basket.setNewWeights();\n        basket.updateIBRatio(newRatio);\n        auctionOngoing = false;\n        hasBonded = false;\n\n        basketAsERC20.safeTransfer(msg.sender, bondAmount);\n        withdrawBounty(bountyIDs);\n\n        emit AuctionSettled(msg.sender);\n    }\n\n    function bondBurn() external override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondBlock + ONE_DAY <= block.number);\n\n        basket.auctionBurn(bondAmount);\n        hasBonded = false;\n        auctionOngoing = false;\n        basket.deleteNewIndex();\n\n        emit BondBurned(msg.sender, auctionBonder, bondAmount);\n\n        auctionBonder = address(0);\n    }\n\n    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n        // add bounty to basket\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _bounties.push(Bounty({\n            token: address(token),\n            amount: amount,\n            active: true\n        }));\n\n        uint256 id = _bounties.length - 1;\n        emit BountyAdded(token, amount, id);\n        return id;\n    }\n\n    function withdrawBounty(uint256[] memory bountyIds) internal {\n        // withdraw bounties\n        for (uint256 i = 0; i < bountyIds.length; i++) {\n            Bounty storage bounty = _bounties[bountyIds[i]];\n            require(bounty.active);\n\n            IERC20(bounty.token).safeTransfer(msg.sender, bounty.amount);\n            bounty.active = false;\n\n            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n        }\n    }\n }"
    }
  ]
}