{
  "Title": "[M-11] Approvals not cleared when transferring profile",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-aave-lens/blob/aaf6c116345f3647e11a35010f28e3b90e7b4862/contracts/core/modules/follow/ApprovalFollowModule.sol#L32\n\n\n# Vulnerability details\n\n## Impact\nThe `ApprovalFollowModule.approve` function is indexed by both (`owner = IERC721(HUB).ownerOf(profileId)`, `profileId`) in case the profileId NFT is transferred.\nHowever, upon transfer, the old approvals are not cleared.\n\nThis can lead to similar issues as OpenSea not cancelling their sale offers upon NFT transfer.\nWhen the NFT is at some point transferred back to the original owner, all the old approvals are still intact which might not be expected by the owner.\n\n## Recommended Mitigation Steps\nConsider resetting all approvals upon transfer.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-aave-lens-contest",
  "Code": [
    {
      "filename": "contracts/core/modules/follow/ApprovalFollowModule.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {IFollowModule} from '../../../interfaces/IFollowModule.sol';\nimport {Errors} from '../../../libraries/Errors.sol';\nimport {Events} from '../../../libraries/Events.sol';\nimport {ModuleBase} from '../ModuleBase.sol';\nimport {FollowValidatorFollowModuleBase} from './FollowValidatorFollowModuleBase.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/**\n * @title ApprovalFollowModule\n * @author Lens Protocol\n *\n * @notice This follow module only allows addresses that are approved for a profile by the profile owner to follow.\n */\ncontract ApprovalFollowModule is IFollowModule, FollowValidatorFollowModuleBase {\n    // We use a triple nested mapping so that, on profile transfer, the previous approved address list is invalid;\n    mapping(address => mapping(uint256 => mapping(address => bool)))\n        internal _approvedByProfileByOwner;\n\n    constructor(address hub) ModuleBase(hub) {}\n\n    /**\n     * @notice A custom function that allows profile owners to customize approved addresses.\n     *\n     * @param profileId The profile ID to approve/disapprove follower addresses for.\n     * @param addresses The addresses to approve/disapprove for following the profile.\n     * @param toApprove Whether to approve or disapprove the addresses for following the profile.\n     */\n    function approve(\n        uint256 profileId,\n        address[] calldata addresses,\n        bool[] calldata toApprove\n    ) external {\n        if (addresses.length != toApprove.length) revert Errors.InitParamsInvalid();\n        address owner = IERC721(HUB).ownerOf(profileId);\n        if (msg.sender != owner) revert Errors.NotProfileOwner();\n\n        for (uint256 i = 0; i < addresses.length; ++i) {\n            _approvedByProfileByOwner[owner][profileId][addresses[i]] = toApprove[i];\n        }\n\n        emit Events.FollowsApproved(owner, profileId, addresses, toApprove, block.timestamp);\n    }\n\n    /**\n     * @notice This follow module works on custom profile owner approvals.\n     *\n     * @param data The arbitrary data parameter, decoded into:\n     *      address[] addresses: The array of addresses to approve initially.\n     *\n     * @return An abi encoded bytes parameter, which is the same as the passed data parameter.\n     */\n    function initializeFollowModule(uint256 profileId, bytes calldata data)\n        external\n        override\n        onlyHub\n        returns (bytes memory)\n    {\n        address owner = IERC721(HUB).ownerOf(profileId);\n\n        if (data.length > 0) {\n            address[] memory addresses = abi.decode(data, (address[]));\n            for (uint256 i = 0; i < addresses.length; ++i) {\n                _approvedByProfileByOwner[owner][profileId][addresses[i]] = true;\n            }\n        }\n        return data;\n    }\n\n    /**\n     * @dev Processes a follow by:\n     *  1. Validating that the follower has been approved for that profile by the profile owner\n     */\n    function processFollow(\n        address follower,\n        uint256 profileId,\n        bytes calldata data\n    ) external override onlyHub {\n        address owner = IERC721(HUB).ownerOf(profileId);\n        if (!_approvedByProfileByOwner[owner][profileId][follower])\n            revert Errors.FollowNotApproved();\n        _approvedByProfileByOwner[owner][profileId][follower] = false; // prevents repeat follows\n    }\n\n    /**\n     * @dev We don't need to execute any additional logic on transfers in this follow module.\n     */\n    function followModuleTransferHook(\n        uint256 profileId,\n        address from,\n        address to,\n        uint256 followNFTTokenId\n    ) external override {}\n\n    /**\n     * @notice Returns whether the given address is approved for the profile owned by a given address.\n     *\n     * @param profileOwner The profile owner of the profile to query the approval with.\n     * @param profileId The token ID of the profile to query approval with.\n     * @param toCheck The address to query approval for.\n     *\n     * @return\n     */\n    function isApproved(\n        address profileOwner,\n        uint256 profileId,\n        address toCheck\n    ) external view returns (bool) {\n        return _approvedByProfileByOwner[profileOwner][profileId][toCheck];\n    }\n\n    /**\n     * @notice Returns whether the given addresses are approved for the profile owned by a given address.\n     *\n     * @param profileOwner The profile owner of the profile to query the approvals with.\n     * @param profileId The token ID of the profile to query approvals with.\n     * @param toCheck The address array to query approvals for.\n     */\n    function isApprovedArray(\n        address profileOwner,\n        uint256 profileId,\n        address[] calldata toCheck\n    ) external view returns (bool[] memory) {\n        bool[] memory approved = new bool[](toCheck.length);\n        for (uint256 i = 0; i < toCheck.length; ++i) {\n            approved[i] = _approvedByProfileByOwner[profileOwner][profileId][toCheck[i]];\n        }\n        return approved;\n    }\n}"
    }
  ]
}