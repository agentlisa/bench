{
  "Title": "[L-04] Potential accidental inclusion of ERC20Burnable in xETH token",
  "Content": "\nhttps://github.com/code-423n4/2023-05-xeth/blob/main/src/xETH.sol#L9\n\nThe xETH token inherits from ERC20Burnable, which defines public methods to allow burning of tokens.\n\nPresumably, this was added accidentally as a mistake in order to implement the `burnShares()` function in xETH. The internal function `_burn` is already provided in the base implementation of ERC20 (OpenZepplin library), and doesn't need any extra implementation, which may increase the attack surface of the protocol.\n\nThe recommendation is to remove ERC20Burnable from the inheritance list of xETH.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-xeth",
  "Code": [
    {
      "filename": "src/xETH.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin-contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin-contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin-contracts/security/Pausable.sol\";\nimport \"@openzeppelin-contracts/access/AccessControl.sol\";\n\ncontract xETH is ERC20, ERC20Burnable, Pausable, AccessControl {\n    /* --------------------------------- Errors --------------------------------- */\n    error AddressZeroProvided();\n    error AmountZeroProvided();\n\n    /* -------------------------- Constants and Storage ------------------------- */\n    /// @dev authentication role for pausing and unpausing the contract\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    /// @dev authentication role for minting and burning tokens\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    /// @dev address of the AMO contract that controls the supply of xETH\n    address public curveAMO;\n\n    /* ------------------------------- Constructor ------------------------------ */\n    constructor() ERC20(\"xEther\", \"xETH\") {\n        /// @dev grant the DEFAULT_ADMIN_ROLE to the contract deployer\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        /// @dev grant the PAUSER_ROLE to the contract deployer\n        _grantRole(PAUSER_ROLE, msg.sender);\n    }\n\n    /* --------------------------- External functions --------------------------- */\n\n    /// @dev setAMO allows for initialising the AMO address and granting it the MINTER_ROLE\n    /// @notice this function can also be used to update the AMO address\n    /// @notice this function can only be called by the DEFAULT_ADMIN_ROLE\n    /// @param newAMO address of the new curveAMO contract\n    function setAMO(address newAMO) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        /// @dev if the new AMO is address(0), revert\n        if (newAMO == address(0)) {\n            revert AddressZeroProvided();\n        }\n\n        /// @dev if there was a previous AMO, revoke it's powers\n        if (curveAMO != address(0)) {\n            _revokeRole(MINTER_ROLE, curveAMO);\n        }\n\n        // @todo call marker method to check if amo is responding\n\n        /// @dev set the new AMO\n        curveAMO = newAMO;\n\n        /// @dev grant it the MINTER_ROLE\n        grantRole(MINTER_ROLE, curveAMO);\n    }\n\n    /// @dev mintShares allows for minting new xETH tokens\n    /// @notice this function can only mint tokens if the contract is not paused\n    /// @notice this function can only be called by the MINTER_ROLE\n    /// @param amount amount of xETH to be minted, it cannot be 0\n    function mintShares(\n        uint256 amount\n    ) public onlyRole(MINTER_ROLE) whenNotPaused {\n        /// @dev if the amount to be minted is 0, revert.\n        if (amount == 0) revert AmountZeroProvided();\n        _mint(msg.sender, amount);\n    }\n\n    /// @dev burnShares allows for burning xETH tokens\n    /// @dev this function can only burn tokens if the contract is not paused\n    /// @dev this function can only be called by the MINTER_ROLE\n    /// @param amount amount of xETH to be burned, it cannot be 0\n    function burnShares(\n        uint256 amount\n    ) public onlyRole(MINTER_ROLE) whenNotPaused {\n        /// @dev if the amount to be burned is 0, revert.\n        if (amount == 0) revert AmountZeroProvided();\n        _burn(msg.sender, amount);\n    }\n\n    /* ---------------------------- Utility functions --------------------------- */\n\n    /// @dev pause allows for pausing the contract\n    /// @notice this function can only be called by the PAUSER_ROLE\n    /// @notice this function can only be called if the contract is not paused\n    function pause() external whenNotPaused onlyRole(PAUSER_ROLE) {\n        _pause();\n    }\n\n    /// @dev unpause allows for unpausing the contract\n    /// @notice this function can only be called by the PAUSER_ROLE\n    /// @notice this function can only be called if the contract is paused\n    function unpause() external whenPaused onlyRole(PAUSER_ROLE) {\n        _unpause();\n    }\n\n    /* ---------------------------- Overridden functions --------------------------- */\n\n    /// @dev overrides the default ERC20 _beforeTokenTransfer hook\n    /// @dev so that transfers can only happen if the contract is not paused\n    /// @param from address of the sender\n    /// @param to address of the recipient\n    /// @param amount amount of tokens to be transferred\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override whenNotPaused {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}"
    }
  ]
}