{
  "Title": "[H-02] All swapping functions lack checks for returned tokens",
  "Content": "_Submitted by 0xDjango, also found by GeekyLumberjack and pmerkleplant_\n\n[GenericSwapFacet.sol#L23-L30](https://github.com/code-423n4/2022-03-lifinance/blob/699c2305fcfb6fe8862b75b26d1d8a2f46a551e6/src/Facets/GenericSwapFacet.sol#L23-L30)<br>\n[LibSwap.sol#L48](https://github.com/code-423n4/2022-03-lifinance/blob/699c2305fcfb6fe8862b75b26d1d8a2f46a551e6/src/Libraries/LibSwap.sol#L48)<br>\n\nEvery function that stems from the `GenericSwapFacet` lacks checks to ensure that some tokens have been returned via the swaps. In `LibSwap.sol` in the `swap()` function, the swap call is sent to the target DEX. A return of success is required, otherwise the operation will revert.\n\nEach \"inner\" swap via `LibSwap.sol` lacks output checks and also the \"outer\" `swapTokensGeneric()` via `GenericSwapFacet.sol` lacks a final check as well.\n\nThere is a possibility that the calldata is accidently populated with a function in the target router that is not actually performing any swapping functionality, `getAmountsOut()` for example. The function will return true, but no new returned tokens will be present in the contract. Meanwhile, the contract has already received the user's `fromTokens` directly.\n\n### Recommended Mitigation Steps\n\nThis would be a potential use case of using function signature whitelists as opposed to contract address whitelists, as noted as a possibility by the LiFi team.\n\nOtherwise, the following `require` statement in `swapTokensGeneric()` would ensure that at least a single token was received:\n\n`require(LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount) > 0, \"No tokens received\")`\n\n**[H3xept (Li.Fi) resolved and commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/76#issuecomment-1094953222):**\n > Fixed in lifinance/lifi-contracts@3a42484dda8bafcfd122c8aa3b61d3766d545bf9\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/76#issuecomment-1100703542):**\n > Sponsor confirmed with fix.\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-03-lifinance",
  "Code": [
    {
      "filename": "src/Facets/GenericSwapFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Generic Swap Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for swapping through ANY DEX\n * @dev Uses calldata to execute arbitrary methods on DEXs\n */\ncontract GenericSwapFacet is ILiFi, Swapper {\n    /* ========== Public Functions ========== */\n\n    /**\n     * @notice Performs a swap and that's it\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     */\n    function swapTokensGeneric(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) public payable {\n        uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;\n\n        LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n}"
    },
    {
      "filename": "src/Libraries/LibSwap.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { LibAsset, IERC20 } from \"./LibAsset.sol\";\nimport { LibUtil } from \"./LibUtil.sol\";\n\nlibrary LibSwap {\n    uint256 private constant MAX_INT = 2**256 - 1;\n\n    struct SwapData {\n        address callTo;\n        address approveTo;\n        address sendingAssetId;\n        address receivingAssetId;\n        uint256 fromAmount;\n        bytes callData;\n    }\n\n    event AssetSwapped(\n        bytes32 transactionId,\n        address dex,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount,\n        uint256 timestamp\n    );\n\n    function swap(bytes32 transactionId, SwapData calldata _swapData) internal {\n        uint256 fromAmount = _swapData.fromAmount;\n        uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);\n        address fromAssetId = _swapData.sendingAssetId;\n        if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {\n            LibAsset.transferFromERC20(fromAssetId, msg.sender, address(this), fromAmount);\n        }\n\n        if (!LibAsset.isNativeAsset(fromAssetId)) {\n            LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);\n        if (!success) {\n            string memory reason = LibUtil.getRevertMsg(res);\n            revert(reason);\n        }\n\n        toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;\n        emit AssetSwapped(\n            transactionId,\n            _swapData.callTo,\n            _swapData.sendingAssetId,\n            _swapData.receivingAssetId,\n            fromAmount,\n            toAmount,\n            block.timestamp\n        );\n    }\n}"
    }
  ]
}