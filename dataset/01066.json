{
  "Title": "H-4: IV Can be Decreased for Free",
  "Content": "# Issue H-4: IV Can be Decreased for Free \n\nSource: https://github.com/sherlock-audit/2023-10-aloe-judging/issues/63 \n\n## Found by \nBandit, mstpr-brainbot, roguereddwarf\n\nThe liquidity parameter used to calculate IV costs nothing to massively manipulate upwards and doesn't require a massive amount of capital. This makes IV easy to manipulate downwards.\n\n## Vulnerability Detail\n\nThe liquidity at a single `tickSpacing` is used to calcualte the `IV`. The more liquidity is in this tick spacing, the lower the `IV`, as demonstarated by the `tickTvl` dividing the return value of the `estimate` function:\n\n```solidity\n            return SoladyMath.sqrt((4e24 * volumeGamma0Gamma1 * scale) / (b.timestamp - a.timestamp) / tickTvl);\n```\n\nSince this is using data only from the block that the function is called, the liuquidyt can easily be increased by: \n\n1. depositing a large amount liquidity into the `tickSpacing`\n2. calling update\n3. removing the liquidity\n\nNote that only a small portion of the total liquidity is in the entire pool is in the active liquidity tick. Therefore, the capital cost required to massively increase the liquidity is low. Additionally, the manipulation has zero cost (aside from gas fees), as no trading is done through the pool. Contract this with a pool price manipulation, which costs a significant amount of trading fees to trade through a large amount of the liquidity of the pool.\n\nSince this manipulation costs nothing except gas, the `IV_CHANGE_PER_UPDATE` which limits of the amount that IV can be manipulated per update does not sufficiently disincentivise manipulation, it just extends the time period required to manipulate.\n\nDecreasing the IV increases the LTV, and due to the free cost, its reasonable to increase the LTV to the max LTV of 90% even for very volatile assets. Aloe uses the IV to estimate the probability of insolvency of loans. With the delay inherent in TWAP oracle and the liquidation delay by the `warn`-then-liquidate process, this manipulation can turn price change based insolvency from a 5 sigma event (as designed by the protocol) to a likely event.\n\n## Impact\n\n- Decreasing IV can be done at zero cost aside from gas fees. \n- This can be used to borrow assets at far more leverage than the proper LTV\n- Borrowers can use this to avoid liquidation\n- This also breaks the insolvency estimation based on IV for riskiness of price-change caused insolvency.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-aloe/blob/main/aloe-ii/core/src/libraries/Volatility.sol#L44-L81\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the time weighted average liquidity of in-range ticks of the recent past, so that single block + single tickSpacing liquidity deposits cannot manipulate IV significantly.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**MohammedRizwan** commented:\n>  valid\n\n\n\n**panprog**\n\nEscalate\n\nThis should be medium, not high. While the volatility can really be decreased and allows more risky positions to be healthy, this will not cause any immediate loss of funds. Liquidations will still happen normally even with 90% LTV. In order to actually cause some loss of funds - a large and quick change of price is required, when liquidators can not liquidate in time. And this is not very likely event, so medium is more appropriate.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This should be medium, not high. While the volatility can really be decreased and allows more risky positions to be healthy, this will not cause any immediate loss of funds. Liquidations will still happen normally even with 90% LTV. In order to actually cause some loss of funds - a large and quick change of price is required, when liquidators can not liquidate in time. And this is not very likely event, so medium is more appropriate.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**roguereddwarf**\n\nConsidering that IV and dynamic LTV is the main security mechanism to deal with sudden price movements and one of Aloe's main selling points is the robustness against sudden price movements, I think this can be considered a High.\n\nWe have seen in crypto many times how a pair can move 10% within minutes which is enough to cause bad debt and a loss to lenders.\n\nIf the manipulation wasn't possible, the LTV would be much lower for such a pair.\n\n**haydenshively**\n\nFixed in https://github.com/aloelabs/aloe-ii/pull/214\n\n**cvetanovv**\n\n[haydenshively](https://github.com/haydenshively) Do you think it should stay High or be downgraded to Medium?\n\n**haydenshively**\n\nI think High makes sense because of how important IV is to the protocol\n\n**Czar102**\n\nThis issue presents a bypass of protocol's risk management, hence I think High severity is accurate. Planning to reject the escalation and leave the issue as is.\n\n**Czar102**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [panprog](https://github.com/sherlock-audit/2023-10-aloe-judging/issues/63/#issuecomment-1802559030): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/120",
  "Code": [
    {
      "filename": "aloe-ii/core/src/libraries/Volatility.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Math} from \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport {FixedPointMathLib as SoladyMath} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {square, mulDiv96, mulDiv128, mulDiv224} from \"./MulDiv.sol\";\nimport {Oracle} from \"./Oracle.sol\";\nimport {TickMath} from \"./TickMath.sol\";\n\n/// @title Volatility\n/// @notice Provides functions that use Uniswap v3 to compute price volatility\n/// @author Aloe Labs, Inc.\nlibrary Volatility {\n    struct PoolMetadata {\n        // the overall fee minus the protocol fee for token0, times 1e6\n        uint24 gamma0;\n        // the overall fee minus the protocol fee for token1, times 1e6\n        uint24 gamma1;\n        // the pool tick spacing\n        int24 tickSpacing;\n    }\n\n    struct FeeGrowthGlobals {\n        // the fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n        uint256 feeGrowthGlobal0X128;\n        // the fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n        uint256 feeGrowthGlobal1X128;\n        // the block timestamp at which feeGrowthGlobal0X128 and feeGrowthGlobal1X128 were last updated\n        uint32 timestamp;\n    }\n\n    /**\n     * @notice Estimates implied volatility using\n     * [this math](https://lambert-guillaume.medium.com/on-chain-volatility-and-uniswap-v3-d031b98143d1).\n     * @dev The return value can fit in uint128 if necessary\n     * @param metadata The pool's metadata (may be cached)\n     * @param data A summary of the pool's state from `pool.slot0` `pool.observe` and `pool.liquidity`\n     * @param a The pool's cumulative feeGrowthGlobals some time in the past\n     * @param b The pool's cumulative feeGrowthGlobals as of the current block\n     * @param scale The timescale (in seconds) in which IV should be reported, e.g. hourly, daily, annualized\n     * @return An estimate of the implied volatility scaled by 1e12\n     */\n    function estimate(\n        PoolMetadata memory metadata,\n        Oracle.PoolData memory data,\n        FeeGrowthGlobals memory a,\n        FeeGrowthGlobals memory b,\n        uint32 scale\n    ) internal pure returns (uint256) {\n        uint256 tickTvl = computeTickTvl(metadata.tickSpacing, data.currentTick, data.sqrtPriceX96, data.tickLiquidity);\n\n        // Return early to avoid division by 0\n        if (data.secondsPerLiquidityX128 == 0 || b.timestamp - a.timestamp == 0 || tickTvl == 0) return 0;\n\n        uint256 revenue0Gamma1 = computeRevenueGamma(\n            a.feeGrowthGlobal0X128,\n            b.feeGrowthGlobal0X128,\n            data.secondsPerLiquidityX128,\n            data.oracleLookback,\n            metadata.gamma1\n        );\n        uint256 revenue1Gamma0 = computeRevenueGamma(\n            a.feeGrowthGlobal1X128,\n            b.feeGrowthGlobal1X128,\n            data.secondsPerLiquidityX128,\n            data.oracleLookback,\n            metadata.gamma0\n        );\n        // This is an approximation. Ideally the fees earned during each swap would be multiplied by the price\n        // *at that swap*. But for prices simulated with GBM and swap sizes either normally or uniformly distributed,\n        // the error you get from using geometric mean price is <1% even with high drift and volatility.\n        uint256 volumeGamma0Gamma1 = revenue1Gamma0 + amount0ToAmount1(revenue0Gamma1, data.sqrtMeanPriceX96);\n        // Clamp to prevent overflow later on\n        if (volumeGamma0Gamma1 > (1 << 128)) volumeGamma0Gamma1 = (1 << 128);\n\n        unchecked {\n            // Scale volume to the target time frame, divide by `tickTvl`, and sqrt for final result\n            return SoladyMath.sqrt((4e24 * volumeGamma0Gamma1 * scale) / (b.timestamp - a.timestamp) / tickTvl);\n        }\n    }\n\n    /**\n     * @notice Computes an `amount1` that (at `tick`) is equivalent in worth to the provided `amount0`\n     * @param amount0 The amount of token0 to convert\n     * @param sqrtPriceX96 The sqrt(price) at which the conversion should hold true\n     * @return amount1 An equivalent amount of token1\n     */\n    function amount0ToAmount1(uint256 amount0, uint160 sqrtPriceX96) internal pure returns (uint256 amount1) {\n        uint256 priceX128 = square(sqrtPriceX96);\n        amount1 = mulDiv128(amount0, priceX128);\n    }\n\n    /**\n     * @notice Computes pool revenue using feeGrowthGlobal accumulators, then scales it down by a factor of gamma\n     * @param feeGrowthGlobalAX128 The value of feeGrowthGlobal (either 0 or 1) at time A\n     * @param feeGrowthGlobalBX128 The value of feeGrowthGlobal (either 0 or 1, but matching) at time B (B > A)\n     * @param secondsPerLiquidityX128 The difference in the secondsPerLiquidity accumulator from `secondsAgo` seconds ago until now\n     * @param secondsAgo The oracle lookback period that was used to find `secondsPerLiquidityX128`\n     * @param gamma The fee factor to scale by\n     * @return Revenue over the period from `block.timestamp - secondsAgo` to `block.timestamp`, scaled down by a factor of gamma\n     */\n    function computeRevenueGamma(\n        uint256 feeGrowthGlobalAX128,\n        uint256 feeGrowthGlobalBX128,\n        uint160 secondsPerLiquidityX128,\n        uint32 secondsAgo,\n        uint24 gamma\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 delta;\n\n            if (feeGrowthGlobalBX128 >= feeGrowthGlobalAX128) {\n                // feeGrowthGlobal has increased from time A to time B\n                delta = feeGrowthGlobalBX128 - feeGrowthGlobalAX128;\n            } else {\n                // feeGrowthGlobal has overflowed between time A and time B\n                delta = type(uint256).max - feeGrowthGlobalAX128 + feeGrowthGlobalBX128;\n            }\n\n            return Math.mulDiv(delta, secondsAgo * uint256(gamma), secondsPerLiquidityX128 * uint256(1e6));\n        }\n    }\n\n    /**\n     * @notice Computes the value of liquidity available at the current tick, denominated in token1\n     * @param tickSpacing The pool tick spacing (from pool.tickSpacing())\n     * @param tick The current tick (from pool.slot0())\n     * @param sqrtPriceX96 The current price (from pool.slot0())\n     * @param liquidity The liquidity depth at currentTick (from pool.liquidity())\n     */\n    function computeTickTvl(\n        int24 tickSpacing,\n        int24 tick,\n        uint160 sqrtPriceX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 tickTvl) {\n        unchecked {\n            tick = TickMath.floor(tick, tickSpacing);\n\n            tickTvl = _getValueOfLiquidity(\n                sqrtPriceX96,\n                TickMath.getSqrtRatioAtTick(tick),\n                TickMath.getSqrtRatioAtTick(tick + tickSpacing),\n                liquidity\n            );\n        }\n    }\n\n    /**\n     * @notice Computes the value of the liquidity in terms of token1\n     * @dev The return value can fit in uint193 if necessary\n     * @param sqrtRatioX96 A sqrt price representing the current pool prices\n     * @param sqrtRatioAX96 A sqrt price representing the lower tick boundary\n     * @param sqrtRatioBX96 A sqrt price representing the upper tick boundary\n     * @param liquidity The liquidity being valued\n     * @return value The total value of `liquidity`, in terms of token1\n     */\n    function _getValueOfLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) private pure returns (uint256 value) {\n        assert(sqrtRatioAX96 <= sqrtRatioX96 && sqrtRatioX96 <= sqrtRatioBX96);\n\n        unchecked {\n            uint256 numerator = Math.mulDiv(uint256(liquidity) << 128, sqrtRatioX96, sqrtRatioBX96);\n\n            value =\n                mulDiv224(numerator, sqrtRatioBX96 - sqrtRatioX96) +\n                mulDiv96(liquidity, sqrtRatioX96 - sqrtRatioAX96);\n        }\n    }\n}"
    }
  ]
}