{
  "Title": "Missing Docstrings",
  "Content": "Although many functions in the [codebase](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/) are well-documented and the code is generally self-explanatory, the codebase could benefit from more complete [NatSpec comments](https://solidity.readthedocs.io/en/develop/natspec-format.html) for all `public` and `external` functions. For instance:\n\n\n* [`getAssetsIn`](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/facets/MarketFacet.sol#L23-L24) in [MarketFacet.sol](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/facets/MarketFacet.sol)\n* [`_setLiquidatorContract`](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/facets/SetterFacet.sol#L186-L187) in [SetterFacet.sol](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/facets/SetterFacet.sol)\n* [`_setVAIMintRate`](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/facets/SetterFacet.sol#L312-L313) in [SetterFacet.sol](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/facets/SetterFacet.sol)\n* [`_setTreasuryData`](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/facets/SetterFacet.sol#L341-L346) in [SetterFacet.sol](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/facets/SetterFacet.sol)\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well.\n\n\n***Update:** Resolved in [pull request #312](https://github.com/VenusProtocol/venus-protocol/pull/312) at commit [3909ff7](https://github.com/VenusProtocol/venus-protocol/pull/224/commits/3909ff70220671bebbb49e62f00d640168fca894).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Comptroller/Diamond/facets/MarketFacet.sol",
      "content": "pragma solidity 0.5.16;\n\nimport \"./FacetBase.sol\";\nimport \"../../../Tokens/VTokens/VToken.sol\";\n\n/**\n * @dev This facet contains all the methods related to the market's management in the pool\n */\ncontract MarketFacet is ComptrollerErrorReporter, ExponentialNoError, FacetBase {\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(VToken vToken);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(VToken vToken, address account);\n\n    /// @notice Emitted when the borrowing delegate rights are updated for an account\n    event DelegateUpdated(address borrower, address delegate, bool allowDelegatedBorrows);\n\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\n    function isComptroller() public pure returns (bool) {\n        return true;\n    }\n\n    function getAssetsIn(address account) external view returns (VToken[] memory) {\n        return accountAssets[account];\n    }\n\n    /**\n     * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market.\n     * @return The list of market addresses\n     */\n    function getAllMarkets() external view returns (VToken[] memory) {\n        return allMarkets;\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\n     * @param vTokenBorrowed The address of the borrowed vToken\n     * @param vTokenCollateral The address of the collateral vToken\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateCalculateSeizeTokens(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint) {\n        (uint err, uint seizeTokens) = comptrollerLens.liquidateCalculateSeizeTokens(\n            address(this),\n            vTokenBorrowed,\n            vTokenCollateral,\n            actualRepayAmount\n        );\n        return (err, seizeTokens);\n    }\n\n    /**\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in vToken.liquidateBorrowFresh)\n     * @param vTokenCollateral The address of the collateral vToken\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to convert into vTokenCollateral tokens\n     * @return (errorCode, number of vTokenCollateral tokens to be seized in a liquidation)\n     */\n    function liquidateVAICalculateSeizeTokens(\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint) {\n        (uint err, uint seizeTokens) = comptrollerLens.liquidateVAICalculateSeizeTokens(\n            address(this),\n            vTokenCollateral,\n            actualRepayAmount\n        );\n        return (err, seizeTokens);\n    }\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param vToken The vToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n    function checkMembership(address account, VToken vToken) external view returns (bool) {\n        return markets[address(vToken)].accountMembership[account];\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param vTokens The list of addresses of the vToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(address[] calldata vTokens) external returns (uint[] memory) {\n        uint len = vTokens.length;\n\n        uint[] memory results = new uint[](len);\n        for (uint i; i < len; ++i) {\n            addToMarketInternal(VToken(vTokens[i]), msg.sender);\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing necessary collateral for an outstanding borrow.\n     * @param vTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n    function exitMarket(address vTokenAddress) external returns (uint) {\n        checkActionPauseState(vTokenAddress, Action.EXIT_MARKET);\n\n        VToken vToken = VToken(vTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = vToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint allowed = redeemAllowedInternal(vTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) {\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n        }\n\n        Market storage marketToExit = markets[address(vToken)];\n\n        /* Return true if the sender is not already ‘in’ the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Set vToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete vToken from the account’s list of assets */\n        // In order to delete vToken, copy last item in list to location of item to be removed, reduce length by 1\n        VToken[] storage userAssetList = accountAssets[msg.sender];\n        uint len = userAssetList.length;\n        uint i;\n        for (; i < len; ++i) {\n            if (userAssetList[i] == vToken) {\n                userAssetList[i] = userAssetList[len - 1];\n                userAssetList.length--;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(i < len);\n\n        emit MarketExited(vToken, msg.sender);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Add the market to the markets mapping and set it as listed\n     * @dev Admin function to set isListed and add support for the market\n     * @param vToken The address of the market (token) to list\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _supportMarket(VToken vToken) external returns (uint) {\n        ensureAllowed(\"_supportMarket(address)\");\n\n        if (markets[address(vToken)].isListed) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        vToken.isVToken(); // Sanity check to make sure its really a VToken\n\n        // Note that isVenus is not in active use anymore\n        Market storage newMarket = markets[address(vToken)];\n        newMarket.isListed = true;\n        newMarket.isVenus = false;\n        newMarket.collateralFactorMantissa = 0;\n\n        _addMarketInternal(vToken);\n        _initializeMarket(address(vToken));\n\n        emit MarketListed(vToken);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Grants or revokes the borrowing delegate rights to / from an account.\n     *  If allowed, the delegate will be able to borrow funds on behalf of the sender.\n     *  Upon a delegated borrow, the delegate will receive the funds, and the borrower\n     *  will see the debt on their account.\n     * @param delegate The address to update the rights for\n     * @param allowBorrows Whether to grant (true) or revoke (false) the rights\n     */\n    function updateDelegate(address delegate, bool allowBorrows) external {\n        _updateDelegate(msg.sender, delegate, allowBorrows);\n    }\n\n    function _updateDelegate(address borrower, address delegate, bool allowBorrows) internal {\n        approvedDelegates[borrower][delegate] = allowBorrows;\n        emit DelegateUpdated(borrower, delegate, allowBorrows);\n    }\n\n    function _addMarketInternal(VToken vToken) internal {\n        for (uint i; i < allMarkets.length; ++i) {\n            require(allMarkets[i] != vToken, \"market already added\");\n        }\n        allMarkets.push(vToken);\n    }\n\n    function _initializeMarket(address vToken) internal {\n        VenusMarketState storage supplyState = venusSupplyState[vToken];\n        VenusMarketState storage borrowState = venusBorrowState[vToken];\n\n        /*\n         * Update market state indices\n         */\n        if (supplyState.index == 0) {\n            // Initialize supply state index with default value\n            supplyState.index = venusInitialIndex;\n        }\n\n        if (borrowState.index == 0) {\n            // Initialize borrow state index with default value\n            borrowState.index = venusInitialIndex;\n        }\n\n        /*\n         * Update market state block numbers\n         */\n        supplyState.block = borrowState.block = uint32(getBlockNumber());\n    }\n}"
    },
    {
      "filename": "contracts/Comptroller/Diamond/facets/SetterFacet.sol",
      "content": "pragma solidity 0.5.16;\n\nimport \"../../../Oracle/PriceOracle.sol\";\nimport \"../../../Tokens/VTokens/VToken.sol\";\nimport \"../../../Utils/ErrorReporter.sol\";\nimport \"./FacetBase.sol\";\n\n/**\n * @dev This facet contains all the setters for the states\n */\ncontract SetterFacet is ComptrollerErrorReporter, ExponentialNoError, FacetBase {\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(VToken vToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when borrow cap for a vToken is changed\n    event NewBorrowCap(VToken indexed vToken, uint newBorrowCap);\n\n    /// @notice Emitted when VAIController is changed\n    event NewVAIController(VAIControllerInterface oldVAIController, VAIControllerInterface newVAIController);\n\n    /// @notice Emitted when VAI mint rate is changed by admin\n    event NewVAIMintRate(uint oldVAIMintRate, uint newVAIMintRate);\n\n    /// @notice Emitted when protocol state is changed by admin\n    event ActionProtocolPaused(bool state);\n\n    /// @notice Emitted when treasury guardian is changed\n    event NewTreasuryGuardian(address oldTreasuryGuardian, address newTreasuryGuardian);\n\n    /// @notice Emitted when treasury address is changed\n    event NewTreasuryAddress(address oldTreasuryAddress, address newTreasuryAddress);\n\n    /// @notice Emitted when treasury percent is changed\n    event NewTreasuryPercent(uint oldTreasuryPercent, uint newTreasuryPercent);\n\n    /// @notice Emitted when liquidator adress is changed\n    event NewLiquidatorContract(address oldLiquidatorContract, address newLiquidatorContract);\n\n    /// @notice Emitted when ComptrollerLens address is changed\n    event NewComptrollerLens(address oldComptrollerLens, address newComptrollerLens);\n\n    /// @notice Emitted when supply cap for a vToken is changed\n    event NewSupplyCap(VToken indexed vToken, uint newSupplyCap);\n\n    /// @notice Emitted when access control address is changed by admin\n    event NewAccessControl(address oldAccessControlAddress, address newAccessControlAddress);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPausedMarket(VToken indexed vToken, Action indexed action, bool pauseState);\n\n    /// @notice Emitted when VAI Vault info is changed\n    event NewVAIVaultInfo(address vault_, uint releaseStartBlock_, uint releaseInterval_);\n\n    /// @notice Emitted when Venus VAI Vault rate is changed\n    event NewVenusVAIVaultRate(uint oldVenusVAIVaultRate, uint newVenusVAIVaultRate);\n\n    /**\n     * @notice Sets a new price oracle for the comptroller\n     * @dev Admin function to set a new price oracle\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPriceOracle(PriceOracle newOracle) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(newOracle));\n\n        // Track the old oracle for the comptroller\n        PriceOracle oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the closeFactor used when liquidating borrows\n     * @dev Admin function to set closeFactor\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint 0=success, otherwise will revert\n     */\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the address of the access control of this contract\n     * @dev Admin function to set the access control address\n     * @param newAccessControlAddress New address for the access control\n     * @return uint 0=success, otherwise will revert\n     */\n    function _setAccessControl(address newAccessControlAddress) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(newAccessControlAddress);\n\n        address oldAccessControlAddress = accessControl;\n        accessControl = newAccessControlAddress;\n        emit NewAccessControl(oldAccessControlAddress, newAccessControlAddress);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the collateralFactor for a market\n     * @dev Restricted function to set per-market collateralFactor\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCollateralFactor(VToken vToken, uint newCollateralFactorMantissa) external returns (uint) {\n        // Check caller is allowed by access control manager\n        ensureAllowed(\"_setCollateralFactor(address,uint256)\");\n        ensureNonzeroAddress(address(vToken));\n\n        // Verify market is listed\n        Market storage market = markets[address(vToken)];\n        ensureListed(market);\n\n        Exp memory newCollateralFactorExp = Exp({ mantissa: newCollateralFactorMantissa });\n\n        //-- Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({ mantissa: collateralFactorMaxMantissa });\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(vToken) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(vToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets liquidationIncentive\n     * @dev Admin function to set liquidationIncentive\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n        ensureAllowed(\"_setLiquidationIncentive(uint256)\");\n\n        require(newLiquidationIncentiveMantissa >= 1e18, \"incentive must be over 1e18\");\n\n        // Save current value for use in log\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function _setLiquidatorContract(address newLiquidatorContract_) external {\n        // Check caller is admin\n        ensureAdmin();\n        address oldLiquidatorContract = liquidatorContract;\n        liquidatorContract = newLiquidatorContract_;\n        emit NewLiquidatorContract(oldLiquidatorContract, newLiquidatorContract_);\n    }\n\n    /**\n     * @notice Admin function to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n    function _setPauseGuardian(address newPauseGuardian) external returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(newPauseGuardian);\n\n        // Save current value for inclusion in log\n        address oldPauseGuardian = pauseGuardian;\n        // Store pauseGuardian with value newPauseGuardian\n        pauseGuardian = newPauseGuardian;\n\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n        emit NewPauseGuardian(oldPauseGuardian, newPauseGuardian);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the given borrow caps for the given vToken market Borrowing that brings total borrows to or above borrow cap will revert.\n     * @dev Access is controled by ACM. A borrow cap of 0 corresponds to unlimited borrowing.\n     * @param vTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n     */\n    function _setMarketBorrowCaps(VToken[] calldata vTokens, uint[] calldata newBorrowCaps) external {\n        ensureAllowed(\"_setMarketBorrowCaps(address[],uint256[])\");\n\n        uint numMarkets = vTokens.length;\n        uint numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for (uint i; i < numMarkets; ++i) {\n            borrowCaps[address(vTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(vTokens[i], newBorrowCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Set the given supply caps for the given vToken market Supply that brings total Supply to or above supply cap will revert.\n     * @dev Admin function to set the supply cap A supply cap of 0 corresponds to Minting NotAllowed.\n     * @param vTokens The addresses of the markets (tokens) to change the supply caps for\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to Minting NotAllowed.\n     */\n    function _setMarketSupplyCaps(VToken[] calldata vTokens, uint256[] calldata newSupplyCaps) external {\n        ensureAllowed(\"_setMarketSupplyCaps(address[],uint256[])\");\n\n        uint numMarkets = vTokens.length;\n        uint numSupplyCaps = newSupplyCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\n\n        for (uint i; i < numMarkets; ++i) {\n            supplyCaps[address(vTokens[i])] = newSupplyCaps[i];\n            emit NewSupplyCap(vTokens[i], newSupplyCaps[i]);\n        }\n    }\n\n    /**\n     * @notice Set whole protocol pause/unpause state\n     */\n    function _setProtocolPaused(bool state) external returns (bool) {\n        ensureAllowed(\"_setProtocolPaused(bool)\");\n\n        protocolPaused = state;\n        emit ActionProtocolPaused(state);\n        return state;\n    }\n\n    /**\n     * @notice Pause/unpause certain actions\n     * @param markets_ Markets to pause/unpause the actions on\n     * @param actions_ List of action ids to pause/unpause\n     * @param paused_ The new paused state (true=paused, false=unpaused)\n     */\n    function _setActionsPaused(address[] calldata markets_, Action[] calldata actions_, bool paused_) external {\n        ensureAllowed(\"_setActionsPaused(address[],uint256[],bool)\");\n\n        uint256 numMarkets = markets_.length;\n        uint256 numActions = actions_.length;\n        for (uint marketIdx; marketIdx < numMarkets; ++marketIdx) {\n            for (uint actionIdx; actionIdx < numActions; ++actionIdx) {\n                setActionPausedInternal(markets_[marketIdx], actions_[actionIdx], paused_);\n            }\n        }\n    }\n\n    /**\n     * @dev Pause/unpause an action on a market\n     * @param market Market to pause/unpause the action on\n     * @param action Action id to pause/unpause\n     * @param paused The new paused state (true=paused, false=unpaused)\n     */\n    function setActionPausedInternal(address market, Action action, bool paused) internal {\n        ensureListed(markets[market]);\n        _actionPaused[market][uint(action)] = paused;\n        emit ActionPausedMarket(VToken(market), action, paused);\n    }\n\n    /**\n     * @notice Sets a new VAI controller\n     * @dev Admin function to set a new VAI controller\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setVAIController(VAIControllerInterface vaiController_) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(vaiController_));\n\n        VAIControllerInterface oldVaiController = vaiController;\n        vaiController = vaiController_;\n        emit NewVAIController(oldVaiController, vaiController_);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function _setVAIMintRate(uint newVAIMintRate) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        uint oldVAIMintRate = vaiMintRate;\n        vaiMintRate = newVAIMintRate;\n        emit NewVAIMintRate(oldVAIMintRate, newVAIMintRate);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the minted VAI amount of the `owner`\n     * @param owner The address of the account to set\n     * @param amount The amount of VAI to set to the account\n     * @return The number of minted VAI by `owner`\n     */\n    function setMintedVAIOf(address owner, uint amount) external returns (uint) {\n        checkProtocolPauseState();\n\n        // Pausing is a very serious situation - we revert to sound the alarms\n        require(!mintVAIGuardianPaused && !repayVAIGuardianPaused, \"VAI is paused\");\n        // Check caller is vaiController\n        if (msg.sender != address(vaiController)) {\n            return fail(Error.REJECTION, FailureInfo.SET_MINTED_VAI_REJECTION);\n        }\n        mintedVAIs[owner] = amount;\n        return uint(Error.NO_ERROR);\n    }\n\n    function _setTreasuryData(\n        address newTreasuryGuardian,\n        address newTreasuryAddress,\n        uint newTreasuryPercent\n    ) external returns (uint) {\n        // Check caller is admin\n        ensureAdminOr(treasuryGuardian);\n\n        require(newTreasuryPercent < 1e18, \"treasury percent cap overflow\");\n        ensureNonzeroAddress(newTreasuryGuardian);\n        ensureNonzeroAddress(newTreasuryAddress);\n\n        address oldTreasuryGuardian = treasuryGuardian;\n        address oldTreasuryAddress = treasuryAddress;\n        uint oldTreasuryPercent = treasuryPercent;\n\n        treasuryGuardian = newTreasuryGuardian;\n        treasuryAddress = newTreasuryAddress;\n        treasuryPercent = newTreasuryPercent;\n\n        emit NewTreasuryGuardian(oldTreasuryGuardian, newTreasuryGuardian);\n        emit NewTreasuryAddress(oldTreasuryAddress, newTreasuryAddress);\n        emit NewTreasuryPercent(oldTreasuryPercent, newTreasuryPercent);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /*** Venus Distribution ***/\n\n    /**\n     * @dev Set ComptrollerLens contract address\n     */\n    function _setComptrollerLens(ComptrollerLensInterface comptrollerLens_) external returns (uint) {\n        ensureAdmin();\n        ensureNonzeroAddress(address(comptrollerLens_));\n        address oldComptrollerLens = address(comptrollerLens);\n        comptrollerLens = comptrollerLens_;\n        emit NewComptrollerLens(oldComptrollerLens, address(comptrollerLens));\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set the amount of XVS distributed per block to VAI Vault\n     * @param venusVAIVaultRate_ The amount of XVS wei per block to distribute to VAI Vault\n     */\n    function _setVenusVAIVaultRate(uint venusVAIVaultRate_) external {\n        ensureAdmin();\n        if (vaiVaultAddress != address(0)) {\n            releaseToVault();\n        }\n        uint oldVenusVAIVaultRate = venusVAIVaultRate;\n        venusVAIVaultRate = venusVAIVaultRate_;\n        emit NewVenusVAIVaultRate(oldVenusVAIVaultRate, venusVAIVaultRate_);\n    }\n\n    /**\n     * @notice Set the VAI Vault infos\n     * @param vault_ The address of the VAI Vault\n     * @param releaseStartBlock_ The start block of release to VAI Vault\n     * @param minReleaseAmount_ The minimum release amount to VAI Vault\n     */\n    function _setVAIVaultInfo(address vault_, uint256 releaseStartBlock_, uint256 minReleaseAmount_) external {\n        ensureAdmin();\n        ensureNonzeroAddress(vault_);\n        if (vaiVaultAddress != address(0)) {\n            releaseToVault();\n        }\n\n        vaiVaultAddress = vault_;\n        releaseStartBlock = releaseStartBlock_;\n        minReleaseAmount = minReleaseAmount_;\n        emit NewVAIVaultInfo(vault_, releaseStartBlock_, minReleaseAmount_);\n    }\n}"
    },
    {
      "filename": "contracts/Comptroller/Diamond/facets/SetterFacet.sol",
      "content": "pragma solidity 0.5.16;\n\nimport \"../../../Oracle/PriceOracle.sol\";\nimport \"../../../Tokens/VTokens/VToken.sol\";\nimport \"../../../Utils/ErrorReporter.sol\";\nimport \"./FacetBase.sol\";\n\n/**\n * @dev This facet contains all the setters for the states\n */\ncontract SetterFacet is ComptrollerErrorReporter, ExponentialNoError, FacetBase {\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(VToken vToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when borrow cap for a vToken is changed\n    event NewBorrowCap(VToken indexed vToken, uint newBorrowCap);\n\n    /// @notice Emitted when VAIController is changed\n    event NewVAIController(VAIControllerInterface oldVAIController, VAIControllerInterface newVAIController);\n\n    /// @notice Emitted when VAI mint rate is changed by admin\n    event NewVAIMintRate(uint oldVAIMintRate, uint newVAIMintRate);\n\n    /// @notice Emitted when protocol state is changed by admin\n    event ActionProtocolPaused(bool state);\n\n    /// @notice Emitted when treasury guardian is changed\n    event NewTreasuryGuardian(address oldTreasuryGuardian, address newTreasuryGuardian);\n\n    /// @notice Emitted when treasury address is changed\n    event NewTreasuryAddress(address oldTreasuryAddress, address newTreasuryAddress);\n\n    /// @notice Emitted when treasury percent is changed\n    event NewTreasuryPercent(uint oldTreasuryPercent, uint newTreasuryPercent);\n\n    /// @notice Emitted when liquidator adress is changed\n    event NewLiquidatorContract(address oldLiquidatorContract, address newLiquidatorContract);\n\n    /// @notice Emitted when ComptrollerLens address is changed\n    event NewComptrollerLens(address oldComptrollerLens, address newComptrollerLens);\n\n    /// @notice Emitted when supply cap for a vToken is changed\n    event NewSupplyCap(VToken indexed vToken, uint newSupplyCap);\n\n    /// @notice Emitted when access control address is changed by admin\n    event NewAccessControl(address oldAccessControlAddress, address newAccessControlAddress);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPausedMarket(VToken indexed vToken, Action indexed action, bool pauseState);\n\n    /// @notice Emitted when VAI Vault info is changed\n    event NewVAIVaultInfo(address vault_, uint releaseStartBlock_, uint releaseInterval_);\n\n    /// @notice Emitted when Venus VAI Vault rate is changed\n    event NewVenusVAIVaultRate(uint oldVenusVAIVaultRate, uint newVenusVAIVaultRate);\n\n    /**\n     * @notice Sets a new price oracle for the comptroller\n     * @dev Admin function to set a new price oracle\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPriceOracle(PriceOracle newOracle) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(address(newOracle));\n\n        // Track the old oracle for the comptroller\n        PriceOracle oldOracle = oracle;\n\n        // Set comptroller's oracle to newOracle\n        oracle = newOracle;\n\n        // Emit NewPriceOracle(oldOracle, newOracle)\n        emit NewPriceOracle(oldOracle, newOracle);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the closeFactor used when liquidating borrows\n     * @dev Admin function to set closeFactor\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @return uint 0=success, otherwise will revert\n     */\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the address of the access control of this contract\n     * @dev Admin function to set the access control address\n     * @param newAccessControlAddress New address for the access control\n     * @return uint 0=success, otherwise will revert\n     */\n    function _setAccessControl(address newAccessControlAddress) external returns (uint) {\n        // Check caller is admin\n        ensureAdmin();\n        ensureNonzeroAddress(newAccessControlAddress);\n\n        address oldAccessControlAddress = accessControl;\n        accessControl = newAccessControlAddress;\n        emit NewAccessControl(oldAccessControlAddress, newAccessControlAddress);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the collateralFactor for a market\n     * @dev Restricted function to set per-market collateralFactor\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n     */\n    function _setCollateralFactor(VToken vToken, uint newCollateralFactorMantissa) external returns (uint) {\n        // Check caller is allowed by access control manager\n        ensureAllowed(\"_setCollateralFactor(address,uint256)\");\n        ensureNonzeroAddress(address(vToken));\n\n        // Verify market is listed\n        Market storage market = markets[address(vToken)];\n        ensureListed(market);\n\n        Exp memory newCollateralFactorExp = Exp({ mantissa: n"
    }
  ]
}