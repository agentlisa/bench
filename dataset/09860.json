{
  "Title": "[M-02] When transferring tokens native on SKALE to Ethereum with `TokenManagerERC20.exitToMainERC20()`, the tokens on the schain will be frozen on `TokenManagerERC20`, but they will not receive tokens on Ethereum",
  "Content": "_Submitted by WatchPug_\n\nIn the current implementation of `TokenManagerERC20`, it allows `exitToMainERC20(tokenOnSchain, amount)`.\n\nAt L277 of `TokenManagerERC20.sol` in `exitToMainERC20()`, if `tokenOnSchain` is minted on SKALE schain natively, there are no such require statement that prevents the target chain being mainnet, eg: `require(chainHash != MAINNET_HASH, \"...\")`\n\nTherefore, a user can set mainnet as the target chain, and at L298 of `TokenManagerERC20.sol`, the tokens will be transferred to the contract, and at L308,  send message to Ethereum mainnet.\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/TokenManagers/TokenManagerERC20.sol#L95-L104>\n\n```solidity\n    function exitToMainERC20(\n        address contractOnMainnet,\n        uint256 amount\n    )\n        external\n        override\n    {\n        communityLocker.checkAllowedToSendMessage(msg.sender);\n        _exit(MAINNET_HASH, depositBox, contractOnMainnet, msg.sender, amount);\n    }\n```\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/TokenManagers/TokenManagerERC20.sol#L264-L313>\n\n```solidity\n    function _exit(\n        bytes32 chainHash,\n        address messageReceiver,\n        address contractOnMainChain,\n        address to,\n        uint256 amount\n    )\n        private\n    {\n        bool isMainChainToken;\n        ERC20BurnableUpgradeable contractOnSchain = clonesErc20[chainHash][contractOnMainChain];\n        if (address(contractOnSchain) == address(0)) {\n            contractOnSchain = ERC20BurnableUpgradeable(contractOnMainChain);\n            isMainChainToken = true;\n        }\n        require(address(contractOnSchain).isContract(), \"No token clone on schain\");\n        require(contractOnSchain.balanceOf(msg.sender) >= amount, \"Insufficient funds\");\n        require(\n            contractOnSchain.allowance(\n                msg.sender,\n                address(this)\n            ) >= amount,\n            \"Transfer is not approved by token holder\"\n        );\n        bytes memory data = Messages.encodeTransferErc20Message(address(contractOnMainChain), to, amount);\n        if (isMainChainToken) {\n            data = _receiveERC20(\n                chainHash,\n                address(contractOnSchain),\n                msg.sender,\n                amount\n            );\n            _saveTransferredAmount(chainHash, address(contractOnSchain), amount);\n            require(\n                contractOnSchain.transferFrom(msg.sender, address(this), amount),\n                \"Transfer was failed\"\n            );\n        } else {\n            require(\n                contractOnSchain.transferFrom(msg.sender, address(this), amount),\n                \"Transfer was failed\"\n            );\n            contractOnSchain.burn(amount);\n        }\n        messageProxy.postOutgoingMessage(\n            chainHash,\n            messageReceiver,\n            data\n        );\n    }\n```\n\nHowever, the `DepositBoxERC20` contract on Ethereum mainnet does not support such message from `TokenManagerERC20` on the schain:\n\nThe type of the message from schain `TokenManagerERC20` is `TRANSFER_ERC20_AND_TOKEN_INFO` (see L354 of TokenManagerERC20.sol) or `TRANSFER_ERC20_AND_TOTAL_SUPPLY` (see L362 of TokenManagerERC20.sol).\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/schain/TokenManagers/TokenManagerERC20.sol#L339-L370>\n\n```solidity\n    function _receiveERC20(\n        bytes32 chainHash,\n        address erc20OnMainChain,\n        address to,\n        uint256 amount\n    )\n        private\n        returns (bytes memory data)\n    {\n        ERC20BurnableUpgradeable erc20 = ERC20BurnableUpgradeable(erc20OnMainChain);\n        uint256 totalSupply = erc20.totalSupply();\n        require(amount <= totalSupply, \"Amount is incorrect\");\n        bool isERC20AddedToSchain = _schainToERC20[chainHash].contains(erc20OnMainChain);\n        if (!isERC20AddedToSchain) {\n            _addERC20ForSchain(chainHash, erc20OnMainChain);\n            data = Messages.encodeTransferErc20AndTokenInfoMessage(\n                erc20OnMainChain,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20),\n                _getErc20TokenInfo(erc20)\n            );\n        } else {\n            data = Messages.encodeTransferErc20AndTotalSupplyMessage(\n                erc20OnMainChain,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20)\n            );\n        }\n        emit ERC20TokenReady(chainHash, erc20OnMainChain, amount);\n    }\n```\n\n`DepositBoxERC20` on Ethereum MAINNET can only process `TRANSFER_ERC20`. (see DepositBoxERC20.sol L155 and Messages.sol L270)\n\nWhen getting a message with the type of `TRANSFER_ERC20_AND_TOKEN_INFO` or `TRANSFER_ERC20_AND_TOTAL_SUPPLY` from schain `TokenManagerERC20`, it will revert at L270 of Messages.sol.\n\nAs a result, the schain tokens will be frozen on TokenManagerERC20, but they will not receive tokens on Ethereum.\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/mainnet/DepositBoxes/DepositBoxERC20.sol#L143-L164>\n\n```solidity\n    function postMessage(\n        bytes32 schainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n        whenNotKilled(schainHash)\n        checkReceiverChain(schainHash, sender)\n        returns (address)\n    {\n        Messages.TransferErc20Message memory message = Messages.decodeTransferErc20Message(data);\n        require(message.token.isContract(), \"Given address is not a contract\");\n        require(ERC20Upgradeable(message.token).balanceOf(address(this)) >= message.amount, \"Not enough money\");\n        _removeTransferredAmount(schainHash, message.token, message.amount);\n        require(\n            ERC20Upgradeable(message.token).transfer(message.receiver, message.amount),\n            \"Transfer was failed\"\n        );\n        return message.receiver;\n    }\n```\n\n<https://github.com/skalenetwork/ima-c4-audit/blob/11d6a6ae5bf16af552edd75183791375e501915f/contracts/Messages.sol#L267-L272>\n\n```solidity\n    function decodeTransferErc20Message(\n        bytes calldata data\n    ) internal pure returns (TransferErc20Message memory) {\n        require(getMessageType(data) == MessageType.TRANSFER_ERC20, \"Message type is not ERC20 transfer\");\n        return abi.decode(data, (TransferErc20Message));\n    }\n```\n\n### Recommendation\n\nConsider preventing moving schain native tokens to Ethereum MAINNET, for example: Add `require(chainHash != MAINNET_HASH, \"...\")` near L277 of TokenManagerERC20.sol.\n\n\n**[cstrangedk (SKALE) disagreed with severity and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/58#issuecomment-1061027228):**\n > Valid issue, however disagree with severity as issue relates to `function incorrect as to spec`.  Suggest `low severity`.\n\n**[GalloDaSballo (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-skale-findings/issues/58#issuecomment-1143798216):**\n > Let me reason through the finding:\n> -> The warden has shown a way for funds to be lost as long as a user uses a sChainNativeToken and burns them to bridge to mainnet (Potentially High)\n> \n> -> This is contingent on the configuration of the depositBoxErc20 (Potentially Med)\n> \n> I disagree with the sponsor argument in that while the code may not be as to spec, the functionality impaired as a medium to high impact.\n> \n> At this time I can rationalize the severity either as:\n> -> It should be High because the given codebase \"default\" functionality has this flaw\n> -> it should be Med because this is contingent on a configuration parameter\n> \n> Given the pre-context that the sChain could be set up by the admin to allow the misconfiguration to happen, at this time, I believe Medium Severity to be more appropriate as the impact is solely dependent upon the configuration of the chain which as explained in the readmes is mostly dependent on the admin.\n\n**[cstrangedk (SKALE) commented](https://github.com/code-423n4/2022-02-skale-findings/issues/58#issuecomment-1195585103):**\n > Mitigated in [skalenetwork/IMA#1031](https://github.com/skalenetwork/IMA/pull/1031).\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-skale-contest",
  "Code": [
    {
      "filename": "contracts/schain/TokenManagers/TokenManagerERC20.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TokenManager.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/TokenManagers/ITokenManagerERC20.sol\";\n\nimport \"../../Messages.sol\";\nimport \"../tokens/ERC20OnChain.sol\";\nimport \"../TokenManager.sol\";\n\n\n/**\n * @title TokenManagerERC20\n * @dev Runs on SKALE Chains,\n * accepts messages from mainnet,\n * and creates ERC20 clones.\n * TokenManagerERC20 mints tokens. When a user exits a SKALE chain, it burns them.\n */\ncontract TokenManagerERC20 is TokenManager, ITokenManagerERC20 {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    // address of ERC20 on Mainnet => ERC20 on Schain\n    mapping(address => ERC20OnChain) public deprecatedClonesErc20;\n    \n    // address of clone on schain => totalSupplyOnMainnet\n    mapping(IERC20Upgradeable => uint) public totalSupplyOnMainnet;\n\n    // address clone on schain => added or not\n    mapping(ERC20OnChain => bool) public addedClones;\n\n    mapping(bytes32 => mapping(address => ERC20OnChain)) public clonesErc20;\n\n    mapping(bytes32 => mapping(address => uint256)) public transferredAmount;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _schainToERC20;\n\n    /**\n     * @dev Emitted when schain owner register new ERC20 clone.\n     */\n    event ERC20TokenAdded(bytes32 indexed chainHash, address indexed erc20OnMainChain, address indexed erc20OnSchain);\n\n    /**\n     * @dev Emitted when TokenManagerERC20 automatically deploys new ERC20 clone.\n     */\n    event ERC20TokenCreated(\n        bytes32 indexed chainHash,\n        address indexed erc20OnMainChain,\n        address indexed erc20OnSchain\n    );\n\n    /**\n     * @dev Emitted when someone sends tokens from mainnet to schain.\n     */\n    event ERC20TokenReceived(\n        bytes32 indexed chainHash,\n        address indexed erc20OnMainChain,\n        address indexed erc20OnSchain,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted when token is received by TokenManager and is ready to be cloned\n     * or transferred on SKALE chain.\n     */\n    event ERC20TokenReady(bytes32 indexed chainHash, address indexed contractOnMainnet, uint256 amount);\n\n    /**\n     * @dev Move tokens from schain to mainnet.\n     * \n     * {contractOnMainnet} tokens are burned on schain and unlocked on mainnet for {msg.sender} address.\n     */\n    function exitToMainERC20(\n        address contractOnMainnet,\n        uint256 amount\n    )\n        external\n        override\n    {\n        communityLocker.checkAllowedToSendMessage(msg.sender);\n        _exit(MAINNET_HASH, depositBox, contractOnMainnet, msg.sender, amount);\n    }\n\n    /**\n     * @dev Move tokens from schain to schain.\n     * \n     * {contractOnMainnet} tokens are burned on origin schain\n     * and are minted on {targetSchainName} schain for {msg.sender} address.\n     */\n    function transferToSchainERC20(\n        string calldata targetSchainName,\n        address contractOnMainnet,\n        uint256 amount\n    )\n        external\n        override\n        rightTransaction(targetSchainName, msg.sender)\n    {\n        bytes32 targetSchainHash = keccak256(abi.encodePacked(targetSchainName));\n        _exit(targetSchainHash, tokenManagers[targetSchainHash], contractOnMainnet, msg.sender, amount);\n    }\n\n    /**\n     * @dev Allows MessageProxy to post operational message from mainnet\n     * or SKALE chains.\n     *\n     * Requirements:\n     * \n     * - MessageProxy must be the sender.\n     * - `fromChainHash` must exist in TokenManager addresses.\n     */\n    function postMessage(\n        bytes32 fromChainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n        checkReceiverChain(fromChainHash, sender)\n        returns (address)\n    {\n        Messages.MessageType operation = Messages.getMessageType(data);\n        address receiver = address(0);\n        if (\n            operation == Messages.MessageType.TRANSFER_ERC20 ||\n            operation == Messages.MessageType.TRANSFER_ERC20_AND_TOKEN_INFO ||\n            operation == Messages.MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY\n        ) {\n            receiver = _sendERC20(fromChainHash, data);\n        } else {\n            revert(\"MessageType is unknown\");\n        }\n        return receiver;\n    }\n\n    /**\n     * @dev Allows Schain owner to register an ERC20 token clone in the TokenManager.\n     */\n    function addERC20TokenByOwner(\n        string calldata targetChainName,\n        address erc20OnMainChain,\n        address erc20OnSchain\n     )\n        external\n        override\n        onlyTokenRegistrar\n    {\n        require(messageProxy.isConnectedChain(targetChainName), \"Chain is not connected\");\n        require(erc20OnSchain.isContract(), \"Given address is not a contract\");\n        require(ERC20OnChain(erc20OnSchain).totalSupply() == 0, \"TotalSupply is not zero\");\n        bytes32 targetChainHash = keccak256(abi.encodePacked(targetChainName));\n        require(address(clonesErc20[targetChainHash][erc20OnMainChain]) == address(0), \"Could not relink clone\");\n        require(!addedClones[ERC20OnChain(erc20OnSchain)], \"Clone was already added\");\n        clonesErc20[targetChainHash][erc20OnMainChain] = ERC20OnChain(erc20OnSchain);\n        addedClones[ERC20OnChain(erc20OnSchain)] = true;\n        emit ERC20TokenAdded(targetChainHash, erc20OnMainChain, erc20OnSchain);\n    }\n\n    /**\n     * @dev Is called once during contract deployment.\n     */\n    function initialize(\n        string memory newChainName,\n        IMessageProxyForSchain newMessageProxy,\n        ITokenManagerLinker newIMALinker,\n        ICommunityLocker newCommunityLocker,\n        address newDepositBox\n    )\n        external\n        override        \n    {\n        TokenManager.initializeTokenManager(\n            newChainName,\n            newMessageProxy,\n            newIMALinker,\n            newCommunityLocker,\n            newDepositBox\n        );\n    }\n\n    // private\n\n    /**\n     * @dev Allows TokenManager to send ERC20 tokens.\n     *  \n     * Emits a {ERC20TokenCreated} event if token did not exist and was automatically deployed.\n     * Emits a {ERC20TokenReceived} event on success.\n     */\n    function _sendERC20(bytes32 fromChainHash, bytes calldata data) private returns (address) {        \n        Messages.MessageType messageType = Messages.getMessageType(data);\n        (address receiver, address token, uint256 amount) = _decodeErc20Message(data);\n        ERC20OnChain contractOnSchain;\n        if (messageType != Messages.MessageType.TRANSFER_ERC20) {\n            uint256 totalSupply;\n            if (messageType == Messages.MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY) {\n                Messages.TransferErc20AndTotalSupplyMessage memory message =\n                    Messages.decodeTransferErc20AndTotalSupplyMessage(data);\n                totalSupply = message.totalSupply;\n                contractOnSchain = clonesErc20[fromChainHash][token];\n            } else {\n                Messages.TransferErc20AndTokenInfoMessage memory message =\n                    Messages.decodeTransferErc20AndTokenInfoMessage(data);\n                totalSupply = message.totalSupply;\n                contractOnSchain = clonesErc20[fromChainHash][token];\n\n                if (address(contractOnSchain) == address(0)) {\n                    require(automaticDeploy, \"Automatic deploy is disabled\");\n                    contractOnSchain = new ERC20OnChain(message.tokenInfo.name, message.tokenInfo.symbol);\n                    clonesErc20[fromChainHash][token] = contractOnSchain;\n                    addedClones[contractOnSchain] = true;\n                    emit ERC20TokenCreated(fromChainHash, token, address(contractOnSchain));\n                }\n            }\n            if (totalSupply != totalSupplyOnMainnet[contractOnSchain]) {\n                totalSupplyOnMainnet[contractOnSchain] = totalSupply;\n            }\n            bool noOverflow;\n            uint updatedTotalSupply;\n            (noOverflow, updatedTotalSupply) = SafeMathUpgradeable.tryAdd(contractOnSchain.totalSupply(), amount);\n            require(\n                noOverflow && updatedTotalSupply <= totalSupplyOnMainnet[contractOnSchain],\n                \"Total supply exceeded\"\n            );\n            contractOnSchain.mint(receiver, amount);\n        } else {\n            require(token.isContract() && _schainToERC20[fromChainHash].contains(token), \"Incorrect main chain token\");\n            require(ERC20Upgradeable(token).balanceOf(address(this)) >= amount, \"Not enough money\");\n            _removeTransferredAmount(fromChainHash, token, amount);\n            require(\n                ERC20Upgradeable(token).transfer(receiver, amount),\n                \"Transfer was failed\"\n            );\n        }\n        emit ERC20TokenReceived(fromChainHash, token, address(contractOnSchain), amount);\n        return receiver;\n    }\n\n    /**\n     * @dev Burn tokens on schain and send message to unlock them on target chain.\n     */\n    function _exit(\n        bytes32 chainHash,\n        address messageReceiver,\n        address contractOnMainChain,\n        address to,\n        uint256 amount\n    )\n        private\n    {\n        bool isMainChainToken;\n        ERC20BurnableUpgradeable contractOnSchain = clonesErc20[chainHash][contractOnMainChain];\n        if (address(contractOnSchain) == address(0)) {\n            contractOnSchain = ERC20BurnableUpgradeable(contractOnMainChain);\n            isMainChainToken = true;\n        }\n        require(address(contractOnSchain).isContract(), \"No token clone on schain\");\n        require(contractOnSchain.balanceOf(msg.sender) >= amount, \"Insufficient funds\");\n        require(\n            contractOnSchain.allowance(\n                msg.sender,\n                address(this)\n            ) >= amount,\n            \"Transfer is not approved by token holder\"\n        );\n        bytes memory data = Messages.encodeTransferErc20Message(address(contractOnMainChain), to, amount);\n        if (isMainChainToken) {\n            data = _receiveERC20(\n                chainHash,\n                address(contractOnSchain),\n                msg.sender,\n                amount\n            );\n            _saveTransferredAmount(chainHash, address(contractOnSchain), amount);\n            require(\n                contractOnSchain.transferFrom(msg.sender, address(this), amount),\n                \"Transfer was failed\"\n            );\n        } else {\n            require(\n                contractOnSchain.transferFrom(msg.sender, address(this), amount),\n                \"Transfer was failed\"\n            );\n            contractOnSchain.burn(amount);\n        }\n        messageProxy.postOutgoingMessage(\n            chainHash,\n            messageReceiver,\n            data\n        );\n    }\n\n    /**\n     * @dev Saves amount of tokens that was transferred to schain.\n     */\n    function _saveTransferredAmount(bytes32 chainHash, address erc20Token, uint256 amount) private {\n        transferredAmount[chainHash][erc20Token] += amount;\n    }\n\n    /**\n     * @dev Removes amount of tokens that was transferred from schain.\n     */\n    function _removeTransferredAmount(bytes32 chainHash, address erc20Token, uint256 amount) private {\n        transferredAmount[chainHash][erc20Token] -= amount;\n    }\n\n    /**\n     * @dev Allows DepositBoxERC20 to receive ERC20 tokens.\n     * \n     * Emits an {ERC20TokenReady} event.\n     * \n     * Requirements:\n     * \n     * - Amount must be less than or equal to the total supply of the ERC20 contract.\n     * - Whitelist should be turned off for auto adding tokens to DepositBoxERC20.\n     */\n    function _receiveERC20(\n        bytes32 chainHash,\n        address erc20OnMainChain,\n        address to,\n        uint256 amount\n    )\n        private\n        returns (bytes memory data)\n    {\n        ERC20BurnableUpgradeable erc20 = ERC20BurnableUpgradeable(erc20OnMainChain);\n        uint256 totalSupply = erc20.totalSupply();\n        require(amount <= totalSupply, \"Amount is incorrect\");\n        bool isERC20AddedToSchain = _schainToERC20[chainHash].contains(erc20OnMainChain);\n        if (!isERC20AddedToSchain) {\n            _addERC20ForSchain(chainHash, erc20OnMainChain);\n            data = Messages.encodeTransferErc20AndTokenInfoMessage(\n                erc20OnMainChain,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20),\n                _getErc20TokenInfo(erc20)\n            );\n        } else {\n            data = Messages.encodeTransferErc20AndTotalSupplyMessage(\n                erc20OnMainChain,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20)\n            );\n        }\n        emit ERC20TokenReady(chainHash, erc20OnMainChain, amount);\n    }\n\n    /**\n     * @dev Adds an ERC20 token to DepositBoxERC20.\n     * \n     * Emits an {ERC20TokenAdded} event.\n     * \n     * Requirements:\n     * \n     * - Given address should be contract.\n     */\n    function _addERC20ForSchain(bytes32 chainHash, address erc20OnMainChain) private {\n        require(erc20OnMainChain.isContract(), \"Given address is not a contract\");\n        require(!_schainToERC20[chainHash].contains(erc20OnMainChain), \"ERC20 Token was already added\");\n        _schainToERC20[chainHash].add(erc20OnMainChain);\n        emit ERC20TokenAdded(chainHash, erc20OnMainChain, address(0));\n    }\n\n    /**\n     * @dev Returns total supply of ERC20 token.\n     */\n    function _getErc20TotalSupply(ERC20Upgradeable erc20Token) private view returns (uint256) {\n        return erc20Token.totalSupply();\n    }\n\n    /**\n     * @dev Returns info about ERC20 token such as token name, decimals, symbol.\n     */\n    function _getErc20TokenInfo(ERC20Upgradeable erc20Token) private view returns (Messages.Erc20TokenInfo memory) {\n        return Messages.Erc20TokenInfo({\n            name: erc20Token.name(),\n            decimals: erc20Token.decimals(),\n            symbol: erc20Token.symbol()\n        });\n    }\n\n    /**\n     * @dev Decodes ERC20 transfer message depending on type of message.\n     */\n    function _decodeErc20Message(bytes calldata data)\n        private\n        pure\n        returns (address, address, uint256)\n    {\n        Messages.MessageType messageType = Messages.getMessageType(data);\n        if (messageType == Messages.MessageType.TRANSFER_ERC20) {\n            Messages.TransferErc20Message memory message =\n                Messages.decodeTransferErc20Message(data);\n            return (\n                message.receiver,\n                message.token,\n                message.amount\n            );\n        } else if (messageType == Messages.MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY) {\n            Messages.TransferErc20AndTotalSupplyMessage memory messageTotalSupply =\n                Messages.decodeTransferErc20AndTotalSupplyMessage(data);\n            return (\n                messageTotalSupply.baseErc20transfer.receiver,\n                messageTotalSupply.baseErc20transfer.token,\n                messageTotalSupply.baseErc20transfer.amount\n            );\n        } else {\n            Messages.TransferErc20AndTokenInfoMessage memory messageTokenInfo =\n                Messages.decodeTransferErc20AndTokenInfoMessage(data);\n            return (\n                messageTokenInfo.baseErc20transfer.receiver,\n                messageTokenInfo.baseErc20transfer.token,\n                messageTokenInfo.baseErc20transfer.amount\n            );\n        }\n    }\n}"
    },
    {
      "filename": "contracts/schain/TokenManagers/TokenManagerERC20.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/**\n *   TokenManager.sol - SKALE Interchain Messaging Agent\n *   Copyright (C) 2019-Present SKALE Labs\n *   @author Artem Payvin\n *\n *   SKALE IMA is free software: you can redistribute it and/or modify\n *   it under the terms of the GNU Affero General Public License as published\n *   by the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   SKALE IMA is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Affero General Public License for more details.\n *\n *   You should have received a copy of the GNU Affero General Public License\n *   along with SKALE IMA.  If not, see <https://www.gnu.org/licenses/>.\n */\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\nimport \"@skalenetwork/ima-interfaces/schain/TokenManagers/ITokenManagerERC20.sol\";\n\nimport \"../../Messages.sol\";\nimport \"../tokens/ERC20OnChain.sol\";\nimport \"../TokenManager.sol\";\n\n\n/**\n * @title TokenManagerERC20\n * @dev Runs on SKALE Chains,\n * accepts messages from mainnet,\n * and creates ERC20 clones.\n * TokenManagerERC20 mints tokens. When a user exits a SKALE chain, it burns them.\n */\ncontract TokenManagerERC20 is TokenManager, ITokenManagerERC20 {\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    // address of ERC20 on Mainnet => ERC20 on Schain\n    mapping(address => ERC20OnChain) public deprecatedClonesErc20;\n    \n    // address of clone on schain => totalSupplyOnMainnet\n    mapping(IERC20Upgradeable => uint) public totalSupplyOnMainnet;\n\n    // address clone on schain => added or not\n    mapping(ERC20OnChain => bool) public addedClones;\n\n    mapping(bytes32 => mapping(address => ERC20OnChain)) public clonesErc20;\n\n    mapping(bytes32 => mapping(address => uint256)) public transferredAmount;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _schainToERC20;\n\n    /**\n     * @dev Emitted when schain owner register new ERC20 clone.\n     */\n    event ERC20TokenAdded(bytes32 indexed chainHash, address indexed erc20OnMainChain, address indexed erc20OnSchain);\n\n    /**\n     * @dev Emitted when TokenManagerERC20 automatically deploys new ERC20 clone.\n     */\n    event ERC20TokenCreated(\n        bytes32 indexed chainHash,\n        address indexed erc20OnMainChain,\n        address indexed erc20OnSchain\n    );\n\n    /**\n     * @dev Emitted when someone sends tokens from mainnet to schain.\n     */\n    event ERC20TokenReceived(\n        bytes32 indexed chainHash,\n        address indexed erc20OnMainChain,\n        address indexed erc20OnSchain,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted when token is received by TokenManager and is ready to be cloned\n     * or transferred on SKALE chain.\n     */\n    event ERC20TokenReady(bytes32 indexed chainHash, address indexed contractOnMainnet, uint256 amount);\n\n    /**\n     * @dev Move tokens from schain to mainnet.\n     * \n     * {contractOnMainnet} tokens are burned on schain and unlocked on mainnet for {msg.sender} address.\n     */\n    function exitToMainERC20(\n        address contractOnMainnet,\n        uint256 amount\n    )\n        external\n        override\n    {\n        communityLocker.checkAllowedToSendMessage(msg.sender);\n        _exit(MAINNET_HASH, depositBox, contractOnMainnet, msg.sender, amount);\n    }\n\n    /**\n     * @dev Move tokens from schain to schain.\n     * \n     * {contractOnMainnet} tokens are burned on origin schain\n     * and are minted on {targetSchainName} schain for {msg.sender} address.\n     */\n    function transferToSchainERC20(\n        string calldata targetSchainName,\n        address contractOnMainnet,\n        uint256 amount\n    )\n        external\n        override\n        rightTransaction(targetSchainName, msg.sender)\n    {\n        bytes32 targetSchainHash = keccak256(abi.encodePacked(targetSchainName));\n        _exit(targetSchainHash, tokenManagers[targetSchainHash], contractOnMainnet, msg.sender, amount);\n    }\n\n    /**\n     * @dev Allows MessageProxy to post operational message from mainnet\n     * or SKALE chains.\n     *\n     * Requirements:\n     * \n     * - MessageProxy must be the sender.\n     * - `fromChainHash` must exist in TokenManager addresses.\n     */\n    function postMessage(\n        bytes32 fromChainHash,\n        address sender,\n        bytes calldata data\n    )\n        external\n        override\n        onlyMessageProxy\n        checkReceiverChain(fromChainHash, sender)\n        returns (address)\n    {\n        Messages.MessageType operation = Messages.getMessageType(data);\n        address receiver = address(0);\n        if (\n            operation == Messages.MessageType.TRANSFER_ERC20 ||\n            operation == Messages.MessageType.TRANSFER_ERC20_AND_TOKEN_INFO ||\n            operation == Messages.MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY\n        ) {\n            receiver = _sendERC20(fromChainHash, data);\n        } else {\n            revert(\"MessageType is unknown\");\n        }\n        return receiver;\n    }\n\n    /**\n     * @dev Allows Schain owner to register an ERC20 token clone in the TokenManager.\n     */\n    function addERC20TokenByOwner(\n        string calldata targetChainName,\n        address erc20OnMainChain,\n        address erc20OnSchain\n     )\n        external\n        override\n        onlyTokenRegistrar\n    {\n        require(messageProxy.isConnectedChain(targetChainName), \"Chain is not connected\");\n        require(erc20OnSchain.isContract(), \"Given address is not a contract\");\n        require(ERC20OnChain(erc20OnSchain).totalSupply() == 0, \"TotalSupply is not zero\");\n        bytes32 targetChainHash = keccak256(abi.encodePacked(targetChainName));\n        require(address(clonesErc20[targetChainHash][erc20OnMainChain]) == address(0), \"Could not relink clone\");\n        require(!addedClones[ERC20OnChain(erc20OnSchain)], \"Clone was already added\");\n        clonesErc20[targetChainHash][erc20OnMainChain] = ERC20OnChain(erc20OnSchain);\n        addedClones[ERC20OnChain(erc20OnSchain)] = true;\n        emit ERC20TokenAdded(targetChainHash, erc20OnMainChain, erc20OnSchain);\n    }\n\n    /**\n     * @dev Is called once during contract deployment.\n     */\n    function initialize(\n        string memory newChainName,\n        IMessageProxyForSchain newMessageProxy,\n        ITokenManagerLinker newIMALinker,\n        ICommunityLocker newCommunityLocker,\n        address newDepositBox\n    )\n        external\n        override        \n    {\n        TokenManager.initializeTokenManager(\n            newChainName,\n            newMessageProxy,\n            newIMALinker,\n            newCommunityLocker,\n            newDepositBox\n        );\n    }\n\n    // private\n\n    /**\n     * @dev Allows TokenManager to send ERC20 tokens.\n     *  \n     * Emits a {ERC20TokenCreated} event if token did not exist and was automatically deployed.\n     * Emits a {ERC20TokenReceived} event on success.\n     */\n    function _sendERC20(bytes32 fromChainHash, bytes calldata data) private returns (address) {        \n        Messages.MessageType messageType = Messages.getMessageType(data);\n        (address receiver, address token, uint256 amount) = _decodeErc20Message(data);\n        ERC20OnChain contractOnSchain;\n        if (messageType != Messages.MessageType.TRANSFER_ERC20) {\n            uint256 totalSupply;\n            if (messageType == Messages.MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY) {\n                Messages.TransferErc20AndTotalSupplyMessage memory message =\n                    Messages.decodeTransferErc20AndTotalSupplyMessage(data);\n                totalSupply = message.totalSupply;\n                contractOnSchain = clonesErc20[fromChainHash][token];\n            } else {\n                Messages.TransferErc20AndTokenInfoMessage memory message =\n                    Messages.decodeTransferErc20AndTokenInfoMessage(data);\n                totalSupply = message.totalSupply;\n                contractOnSchain = clonesErc20[fromChainHash][token];\n\n                if (address(contractOnSchain) == address(0)) {\n                    require(automaticDeploy, \"Automatic deploy is disabled\");\n                    contractOnSchain = new ERC20OnChain(message.tokenInfo.name, message.tokenInfo.symbol);\n                    clonesErc20[fromChainHash][token] = contractOnSchain;\n                    addedClones[contractOnSchain] = true;\n                    emit ERC20TokenCreated(fromChainHash, token, address(contractOnSchain));\n                }\n            }\n            if (totalSupply != totalSupplyOnMainnet[contractOnSchain]) {\n                totalSupplyOnMainnet[contractOnSchain] = totalSupply;\n            }\n            bool noOverflow;\n            uint updatedTotalSupply;\n            (noOverflow, updatedTotalSupply) = SafeMathUpgradeable.tryAdd(contractOnSchain.totalSupply(), amount);\n            require(\n                noOverflow && updatedTotalSupply <= totalSupplyOnMainnet[contractOnSchain],\n                \"Total supply exceeded\"\n            );\n            contractOnSchain.mint(receiver, amount);\n        } else {\n            require(token.isContract() && _schainToERC20[fromChainHash].contains(token), \"Incorrect main chain token\");\n            require(ERC20Upgradeable(token).balanceOf(address(this)) >= amount, \"Not enough money\");\n            _removeTransferredAmount(fromChainHash, token, amount);\n            require(\n                ERC20Upgradeable(token).transfer(receiver, amount),\n                \"Transfer was failed\"\n            );\n        }\n        emit ERC20TokenReceived(fromChainHash, token, address(contractOnSchain), amount);\n        return receiver;\n    }\n\n    /**\n     * @dev Burn tokens on schain and send message to unlock them on target chain.\n     */\n    function _exit(\n        bytes32 chainHash,\n        address messageReceiver,\n        address contractOnMainChain,\n        address to,\n        uint256 amount\n    )\n        private\n    {\n        bool isMainChainToken;\n        ERC20BurnableUpgradeable contractOnSchain = clonesErc20[chainHash][contractOnMainChain];\n        if (address(contractOnSchain) == address(0)) {\n            contractOnSchain = ERC20BurnableUpgradeable(contractOnMainChain);\n            isMainChainToken = true;\n        }\n        require(address(contractOnSchain).isContract(), \"No token clone on schain\");\n        require(contractOnSchain.balanceOf(msg.sender) >= amount, \"Insufficient funds\");\n        require(\n            contractOnSchain.allowance(\n                msg.sender,\n                address(this)\n            ) >= amount,\n            \"Transfer is not approved by token holder\"\n        );\n        bytes memory data = Messages.encodeTransferErc20Message(address(contractOnMainChain), to, amount);\n        if (isMainChainToken) {\n            data = _receiveERC20(\n                chainHash,\n                address(contractOnSchain),\n                msg.sender,\n                amount\n            );\n            _saveTransferredAmount(chainHash, address(contractOnSchain), amount);\n            require(\n                contractOnSchain.transferFrom(msg.sender, address(this), amount),\n                \"Transfer was failed\"\n            );\n        } else {\n            require(\n                contractOnSchain.transferFrom(msg.sender, address(this), amount),\n                \"Transfer was failed\"\n            );\n            contractOnSchain.burn(amount);\n        }\n        messageProxy.postOutgoingMessage(\n            chainHash,\n            messageReceiver,\n            data\n        );\n    }\n\n    /**\n     * @dev Saves amount of tokens that was transferred to schain.\n     */\n    function _saveTransferredAmount(bytes32 chainHash, address erc20Token, uint256 amount) private {\n        transferredAmount[chainHash][erc20Token] += amount;\n    }\n\n    /**\n     * @dev Removes amount of tokens that was transferred from schain.\n     */\n    function _removeTransferredAmount(bytes32 chainHash, address erc20Token, uint256 amount) private {\n        transferredAmount[chainHash][erc20Token] -= amount;\n    }\n\n    /**\n     * @dev Allows DepositBoxERC20 to receive ERC20 tokens.\n     * \n     * Emits an {ERC20TokenReady} event.\n     * \n     * Requirements:\n     * \n     * - Amount must be less than or equal to the total supply of the ERC20 contract.\n     * - Whitelist should be turned off for auto adding tokens to DepositBoxERC20.\n     */\n    function _receiveERC20(\n        bytes32 chainHash,\n        address erc20OnMainChain,\n        address to,\n        uint256 amount\n    )\n        private\n        returns (bytes memory data)\n    {\n        ERC20BurnableUpgradeable erc20 = ERC20BurnableUpgradeable(erc20OnMainChain);\n        uint256 totalSupply = erc20.totalSupply();\n        require(amount <= totalSupply, \"Amount is incorrect\");\n        bool isERC20AddedToSchain = _schainToERC20[chainHash].contains(erc20OnMainChain);\n        if (!isERC20AddedToSchain) {\n            _addERC20ForSchain(chainHash, erc20OnMainChain);\n            data = Messages.encodeTransferErc20AndTokenInfoMessage(\n                erc20OnMainChain,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20),\n                _getErc20TokenInfo(erc20)\n            );\n        } else {\n            data = Messages.encodeTransferErc20AndTotalSupplyMessage(\n                erc20OnMainChain,\n                to,\n                amount,\n                _getErc20TotalSupply(erc20)\n            );\n        }\n        emit ERC20TokenReady(chainHash, erc20OnMainChain, amount);\n    }\n\n    /**\n     * @dev Adds an ERC20 token to DepositBoxERC20.\n     * \n     * Emits an {ERC20TokenAdded} event.\n     * \n     * Requirements:\n     * \n     * - Given address should be contract.\n     */\n    function _addERC20ForSchain(bytes32 chainHash, address erc20OnMainChain) private {\n        require(erc20OnMainChain.isContract(), \"Given address is not a contract\");\n        require(!_schainToERC20[chainHash].contains(erc20OnMainChain), \"ERC20 Token was already added\");\n        _schainToERC20[chainHash].add(erc20OnMainChain);\n        emit ERC20TokenAdded(chainHash, erc20OnMainChain, address(0));\n    }\n\n    /**\n     * @dev Returns total supply of ERC20 token.\n     */\n    function _getErc20TotalSupply(ERC20Upgradeable erc20Token) private view returns (uint256) {\n        return erc20Token.totalSupply();\n    }\n\n    /**\n     * @dev Returns info about ERC20 token such as token name, decimals, symbol.\n     */\n    function _getErc20TokenInfo(ERC20Upgradeable erc20Token) private view returns (Messages.Erc20TokenInfo memory) {\n        return Messages.Erc20TokenInfo({\n            name: erc20Token.name(),\n            decimals: erc20Token.decimals(),\n            symbol: erc20Token.symbol()\n        });\n    }\n\n    /**\n     * @dev Decodes ERC20 transfer message depending on type of message.\n     */\n    function _decodeErc20Message(bytes calldata data)\n        private\n        pure\n        returns (address, address, uint256)\n    {\n        Messages.MessageType messageType = Messages.getMessageType(data);\n        if (messageType == Messages.MessageType.TRANSFER_ERC20) {\n            Messages.TransferErc20Message memory message =\n                Messages.decodeTransferErc20Message(data);\n            return (\n                message.receiver,\n                message.token,\n                message.amount\n            );\n        } else if (messageType == Messages.MessageType.TRANSFER_ERC20_AND_TOTAL_SUPPLY) {\n            Messages.TransferErc20AndTotalSupplyMessage memory messageTotalSupply =\n                Messages.decodeTransferErc20AndTotalSupplyMessage(data);\n            return (\n                messageTotalSupply.baseErc20transfer.receiver,\n                messageTotalSupply.baseErc20transfer.token,\n                messageTotalSupply.baseErc20transfer.amount\n            );\n        }"
    }
  ]
}