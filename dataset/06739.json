{
  "Title": "[G-01]  IF's/require() statements that check input arguments should be at the top of the function",
  "Content": "\nChecks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (2100 gas) in a function that may ultimately revert in the unhappy case.\n\nhttps://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Equity.sol#L290-L297\n### Cheaper to check the function parameter before making an external function call\n```solidity\nFile: /contracts/Equity.sol\n290:    function calculateProceeds(uint256 shares) public view returns (uint256) {\n291:        uint256 totalShares = totalSupply();\n292:        uint256 capital = zchf.equity();\n293:        require(shares + ONE_DEC18 < totalShares, \"too many shares\"); // make sure there is always at least one share\n294:        uint256 newTotalShares = totalShares - shares;\n295:        uint256 newCapital = _mulD18(capital, _power3(_divD18(newTotalShares, totalShares)));\n296:        return capital - newCapital;\n297:    }\n```\nAs we have a require statement verifying a functional parameter, it would be cheaper to run this check first before making an external function call.\n```diff\ndiff --git a/contracts/Equity.sol b/contracts/Equity.sol\nindex 7057ed6..817e37a 100644\n--- a/contracts/Equity.sol\n+++ b/contracts/Equity.sol\n@@ -289,8 +289,8 @@ contract Equity is ERC20PermitLight, MathUtil, IReserve {\n      */\n     function calculateProceeds(uint256 shares) public view returns (uint256) {\n         uint256 totalShares = totalSupply();\n-        uint256 capital = zchf.equity();\n         require(shares + ONE_DEC18 < totalShares, \"too many shares\"); // make sure there is always at least one share\n+        uint256 capital = zchf.equity();\n         uint256 newTotalShares = totalShares - shares;\n         uint256 newCapital = _mulD18(capital, _power3(_divD18(newTotalShares, totalShares)));\n         return capital - newCapital;\n```\n\nhttps://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/MintingHub.sol#L88-L113\n### Move the require statement at the beginning of the function\n```solidity\nFile: /contracts/MintingHub.sol\n88:    function openPosition(\n89:        address _collateralAddress, uint256 _minCollateral, uint256 _initialCollateral,\n90:        uint256 _mintingMaximum, uint256 _initPeriodSeconds, uint256 _expirationSeconds, uint256 _challengeSeconds,\n91:        uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reservePPM) public returns (address) {\n//@audit: truncated some chunk here\n107:        zchf.registerPosition(address(pos));\n108:        zchf.transferFrom(msg.sender, address(zchf.reserve()), OPENING_FEE);\n109:        require(_initialCollateral >= _minCollateral, \"must start with min col\");\n```\nWe have a require statement that validates some functional parameters. As we would end up reverting if this parameters don't meet the requirements, it's better to check them at the beggining of the function before performing other operations that would just waste gas in case we end up reverting\n\n```diff\ndiff --git a/contracts/MintingHub.sol b/contracts/MintingHub.sol\nindex 663b205..0739259 100644\n--- a/contracts/MintingHub.sol\n+++ b/contracts/MintingHub.sol\n@@ -89,6 +89,8 @@ contract MintingHub {\n         address _collateralAddress, uint256 _minCollateral, uint256 _initialCollateral,\n         uint256 _mintingMaximum, uint256 _initPeriodSeconds, uint256 _expirationSeconds, uint256 _challengeSeconds,\n         uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reservePPM) public returns (address) {\n+        require(_initialCollateral >= _minCollateral, \"must start with min col\");\n+\n         IPosition pos = IPosition(\n             POSITION_FACTORY.createNewPosition(\n                 msg.sender,\n@@ -106,7 +108,6 @@ contract MintingHub {\n         );\n         zchf.registerPosition(address(pos));\n         zchf.transferFrom(msg.sender, address(zchf.reserve()), OPENING_FEE);\n-        require(_initialCollateral >= _minCollateral, \"must start with min col\");\n         IERC20(_collateralAddress).transferFrom(msg.sender, address(pos), _initialCollateral);\n\n         return address(pos);\n```\n\nhttps://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L76-L86\n### Move the if check condition above the function call\n```solidity\nFile: /contracts/Position.sol\n76:    function initializeClone(address owner, uint256 _price, uint256 _limit, uint256 _coll, uint256 _mint) external onlyHub {\n77:        if(_coll < minimumCollateral) revert InsufficientCollateral();\n78:        setOwner(owner);\n        \n80:        price = _mint * ONE_DEC18 / _coll;\n81:        if (price > _price) revert InsufficientCollateral();\n```\nWe have an internal function call that simply sets a new owner. We also have a check of `price > _price` that would revert in case that check fails. As this is not dependent on the internal function call, we can do the check first so that incase of a revert on the `if (price > _price) revert InsufficientCollateral();` we wouldn't waste gas doing the internal function call\n\n```diff\ndiff --git a/contracts/Position.sol b/contracts/Position.sol\nindex 3e18534..88ecfe5 100644\n--- a/contracts/Position.sol\n+++ b/contracts/Position.sol\n@@ -75,10 +75,11 @@ contract Position is Ownable, IPosition, MathUtil {\n      */\n     function initializeClone(address owner, uint256 _price, uint256 _limit, uint256 _coll, uint256 _mint) external onlyHub {\n         if(_coll < minimumCollateral) revert InsufficientCollateral();\n-        setOwner(owner);\n-\n         price = _mint * ONE_DEC18 / _coll;\n         if (price > _price) revert InsufficientCollateral();\n+        setOwner(owner);\n```\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-04-frankencoin",
  "Code": [
    {
      "filename": "contracts/Equity.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./Frankencoin.sol\";\nimport \"./IERC677Receiver.sol\";\nimport \"./ERC20PermitLight.sol\";\nimport \"./MathUtil.sol\";\nimport \"./IReserve.sol\";\n\n/** \n * If the Frankencoin system was a bank, this contract would represent the equity on its balance sheet.\n * Like with a corporation, the owners of the equity capital are the shareholders, or in this case the holders\n * of Frankencoin Pool Shares (FPS) tokens. Anyone can mint additional FPS tokens by adding Frankencoins to the\n * reserve pool. Also, FPS tokens can be redeemed for Frankencoins again after a minimum holding period.\n * Furthermore, the FPS shares come with some voting power. Anyone that held at least 3% of the holding-period-\n * weighted reserve pool shares gains veto power and can veto new proposals.\n */\ncontract Equity is ERC20PermitLight, MathUtil, IReserve {\n\n    /**\n     * The VALUATION_FACTOR determines the market cap of the reserve pool shares relative to the equity reserves.\n     * The following always holds: Market Cap = Valuation Factor * Equity Reserve = Price * Supply\n     *\n     * In the absence of profits and losses, the variables grow as follows when FPS tokens are minted:\n     *\n     * |   Reserve     |   Market Cap  |     Price     |     Supply   |\n     * |          1000 |          3000 |             3 |         1000 |\n     * |       1000000 |       3000000 |           300 |        10000 |\n     * |    1000000000 |    3000000000 |         30000 |       100000 |\n     * | 1000000000000 | 3000000000000 |       3000000 |      1000000 |\n     *\n     * I.e., the supply is proporational to the cubic root of the reserve and the price is proportional to the\n     * squared cubic root. When profits accumulate or losses materialize, the reserve, the market cap,\n     * and the price are adjusted proportionally, with the supply staying constant. In the absence of an extreme\n     * inflation of the Swiss franc, it is unlikely that there will ever be more than ten million FPS.\n     */\n    uint32 public constant VALUATION_FACTOR = 3;\n\n    uint256 private constant MINIMUM_EQUITY = 1000 * ONE_DEC18;\n\n    /**\n     * The quorum in basis points. 100 is 1%.\n     */\n    uint32 private constant QUORUM = 300;\n\n    /**\n     * The number of digits to store the average holding time of share tokens.\n     */\n    uint8 private constant BLOCK_TIME_RESOLUTION_BITS = 24;\n\n    /**\n     * The minimum holding duration in blocks. You are not allowed to redeem your pool shares if you held them\n     * for less than the minimum holding duration at average. For example, if you have two pool shares on your\n     * address, one acquired 5 days ago and one acquired 105 days ago, you cannot redeem them as the average\n     * holding duration of your shares is only 55 days < 90 days.\n     */\n    uint256 public constant MIN_HOLDING_DURATION = 90*7200 << BLOCK_TIME_RESOLUTION_BITS; // Set to 5 for local testing\n\n    Frankencoin immutable public zchf;\n\n    /**\n     * To track the total number of votes we need to know the number of votes at the anchor time and when the\n     * anchor time was. This is (hopefully) stored in one 256 bit slot, with the anchor time taking 64 Bits and\n     * the total vote count 192 Bits. Given the sub-block time resolution of 24 Bits, the implicit assumption is\n     * that the block number can always be stored in 40 Bits (i.e. it does not exceed a trillion). Further,\n     * given 18 decimals (about 60 Bits), this implies that the total supply cannot exceed \n     *   192 - 60 - 40 - 24 = 68 Bits\n     * Here, we are also save, as 68 Bits would imply more than a trillion outstanding shares. In fact, when\n     * minting, a limit of about 2**30 shares (that's 2**90 Bits when taking into account the decimals) is imposed\n     * when minting. This means that the maximum supply is about a billion shares, which is reached at a market\n     * cap of 3,000,000,000,000,000,000 CHF. This limit could in theory be reached in times of hyper inflaction. \n     */\n    uint192 private totalVotesAtAnchor;  // Total number of votes at the anchor time, see comment on the um\n    uint64 private totalVotesAnchorTime; // 40 Bit for the block number, 24 Bit sub-block time resolution\n\n    /**\n     * Keeping track on who delegated votes to whom.\n     * Note that delegation does not mean you cannot vote / veto any more, it just means that the delegate can\n     * benefit from your votes when invoking a veto. Circular delegations are valid, do not help when voting.\n     */\n    mapping (address => address) public delegates;\n\n    /**\n     * A block number in the past such that: votes = balance * (time passed since anchor was set)\n     */\n    mapping (address => uint64) private voteAnchor; // 40 Bit for the block number, 24 Bit sub-block time resolution\n\n    event Delegation(address indexed from, address indexed to); // indicates a delegation\n    event Trade(address who, int amount, uint totPrice, uint newprice); // amount pos or neg for mint or redemption\n\n    constructor(Frankencoin zchf_) ERC20(18) {\n        zchf = zchf_;\n    }\n\n    function name() override external pure returns (string memory) {\n        return \"Frankencoin Pool Share\";\n    }\n\n    function symbol() override external pure returns (string memory) {\n        return \"FPS\";\n    }\n\n    /**\n     * Returns the price of one FPS in ZCHF with 18 decimals precision.\n     */\n    function price() public view returns (uint256){\n        return VALUATION_FACTOR * zchf.equity() * ONE_DEC18 / totalSupply();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) override internal {\n        super._beforeTokenTransfer(from, to, amount);\n        if (amount > 0){\n            // No need to adjust the sender votes. When they send out 10% of their shares, they also lose 10% of\n            // their votes so everything falls nicely into place.\n            // Recipient votes should stay the same, but grow faster in the future, requiring an adjustment of the anchor.\n            uint256 roundingLoss = adjustRecipientVoteAnchor(to, amount);\n            // The total also must be adjusted and kept accurate by taking into account the rounding error.\n            adjustTotalVotes(from, amount, roundingLoss);\n        }\n    }\n\n    /**\n     * Returns whether the sender address is allowed to redeem FPS.\n     */\n    function canRedeem() external view returns (bool){\n        return canRedeem(msg.sender);\n    }\n\n    /**\n     * Returns whether the given address is allowed to redeem FPS, which is the\n     * case after their average holding duration is larger than the required minimum.\n     */\n    function canRedeem(address owner) public view returns (bool) {\n        return anchorTime() - voteAnchor[owner] >= MIN_HOLDING_DURATION;\n    }\n\n     /**\n     * @notice Decrease the total votes anchor when tokens lose their voting power due to being moved\n     * @param from      sender\n     * @param amount    amount to be sent\n     */\n    function adjustTotalVotes(address from, uint256 amount, uint256 roundingLoss) internal {\n        uint256 lostVotes = from == address(0x0) ? 0 : (anchorTime() - voteAnchor[from]) * amount;\n        totalVotesAtAnchor = uint192(totalVotes() - roundingLoss - lostVotes);\n        totalVotesAnchorTime = anchorTime();\n    }\n\n    /**\n     * @notice the vote anchor of the recipient is moved forward such that the number of calculated\n     * votes does not change despite the higher balance.\n     * @param to        receiver address\n     * @param amount    amount to be received\n     * @return the number of votes lost due to rounding errors\n     */\n    function adjustRecipientVoteAnchor(address to, uint256 amount) internal returns (uint256){\n        if (to != address(0x0)) {\n            uint256 recipientVotes = votes(to); // for example 21 if 7 shares were held for 3 blocks\n            uint256 newbalance = balanceOf(to) + amount; // for example 11 if 4 shares are added\n            voteAnchor[to] = uint64(anchorTime() - recipientVotes / newbalance); // new example anchor is only 21 / 11 = 1 block in the past\n            return recipientVotes % newbalance; // we have lost 21 % 11 = 10 votes\n        } else {\n            // optimization for burn, vote anchor of null address does not matter\n            return 0;\n        }\n    }\n\n    /**\n     * Block number with some additional Bits for higher resolution.\n     */\n    function anchorTime() internal view returns (uint64){\n        return uint64(block.number << BLOCK_TIME_RESOLUTION_BITS);\n    }\n\n    /**\n     * The votes of the holder, excluding votes from delegates.\n     */\n    function votes(address holder) public view returns (uint256) {\n        return balanceOf(holder) * (anchorTime() - voteAnchor[holder]);\n    }\n\n    /**\n     * Total number of votes in the system.\n     */\n    function totalVotes() public view returns (uint256) {\n        return totalVotesAtAnchor + totalSupply() * (anchorTime() - totalVotesAnchorTime);\n    }\n\n    function votes(address sender, address[] calldata helpers) public view returns (uint256) {\n        uint256 _votes = votes(sender);\n        for (uint i=0; i<helpers.length; i++){\n            address current = helpers[i];\n            require(current != sender);\n            require(canVoteFor(sender, current));\n            for (uint j=i+1; j<helpers.length; j++){\n                require(current != helpers[j]); // ensure helper unique\n            }\n            _votes += votes(current);\n        }\n        return _votes;\n    }\n\n    /**\n     * Checks whether the sender address is qualified given a list of helpers that delegated their votes\n     * directly or indirectly to the sender. It is the responsiblity of the caller to figure out whether\n     * helpes are necessary and to identify them by scanning the blockchain for Delegation events. \n     */\n    function checkQualified(address sender, address[] calldata helpers) public override view {\n        uint256 _votes = votes(sender, helpers);\n        if (_votes * 10000 < QUORUM * totalVotes()) revert NotQualified();\n    }\n\n    error NotQualified();\n\n    /**\n     * Increases the voting power of the delegate by your number of votes without taking away any voting power\n     * from the sender.\n     */\n    function delegateVoteTo(address delegate) external {\n        delegates[msg.sender] = delegate;\n        emit Delegation(msg.sender, delegate);\n    }\n\n    function canVoteFor(address delegate, address owner) internal view returns (bool) {\n        if (owner == delegate){\n            return true;\n        } else if (owner == address(0x0)){\n            return false;\n        } else {\n            return canVoteFor(delegate, delegates[owner]);\n        }\n    }\n\n    /**\n     * In order to mint new FPS tokens, one needs to send ZCHF to this contract using the transferAndCall function\n     * in the ZCHF contract.\n     *\n     * If equity is close to zero or negative, you need to send enough ZCHF to bring equity back to 1000 ZCHF.\n     */\n    function onTokenTransfer(address from, uint256 amount, bytes calldata) external returns (bool) {\n        require(msg.sender == address(zchf), \"caller must be zchf\");\n        uint256 equity = zchf.equity();\n        require(equity >= MINIMUM_EQUITY, \"insuf equity\"); // ensures that the initial deposit is at least 1000 ZCHF\n\n        // Assign 1000 FPS for the initial deposit, calculate the amount otherwise\n        uint256 shares = equity <= amount ? 1000 * ONE_DEC18 : calculateSharesInternal(equity - amount, amount);\n        _mint(from, shares);\n        emit Trade(msg.sender, int(shares), amount, price());\n\n        // limit the total supply to a reasonable amount to guard against overflows with price and vote calculations\n        // the 128 bits are 68 bits for magnitude and 60 bits for precision, as calculated in an above comment\n        require(totalSupply() < 2**128, \"total supply exceeded\");\n        return true;\n    }\n\n    /**\n     * @notice Calculate shares received when depositing ZCHF\n     * @param investment ZCHF invested\n     * @return amount of shares received for the ZCHF invested\n     */\n    function calculateShares(uint256 investment) public view returns (uint256) {\n        return calculateSharesInternal(zchf.equity(), investment);\n    }\n\n    function calculateSharesInternal(uint256 capitalBefore, uint256 investment) internal view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        uint256 newTotalShares = totalShares < 1000 * ONE_DEC18 ? 1000 * ONE_DEC18 : _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investment, capitalBefore)));\n        return newTotalShares - totalShares;\n    }\n\n    /**\n     * Redeem the given amount of shares owned by the sender and transfer the proceeds to the target.\n     */\n    function redeem(address target, uint256 shares) public returns (uint256) {\n        require(canRedeem(msg.sender));\n        uint256 proceeds = calculateProceeds(shares);\n        _burn(msg.sender, shares);\n        zchf.transfer(target, proceeds);\n        emit Trade(msg.sender, -int(shares), proceeds, price());\n        return proceeds;\n    }\n\n    /**\n     * @notice Calculate ZCHF received when depositing shares\n     * @param shares number of shares we want to exchange for ZCHF,\n     *               in dec18 format\n     * @return amount of ZCHF received for the shares\n     */\n    function calculateProceeds(uint256 shares) public view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        uint256 capital = zchf.equity();\n        require(shares + ONE_DEC18 < totalShares, \"too many shares\"); // make sure there is always at least one share\n        uint256 newTotalShares = totalShares - shares;\n        uint256 newCapital = _mulD18(capital, _power3(_divD18(newTotalShares, totalShares)));\n        return capital - newCapital;\n    }\n\n    /**\n     * If there is less than 1000 ZCHF in equity left (maybe even negative), the system is at risk\n     * and we should allow qualified FPS holders to restructure the system.\n     *\n     * Example: there was a devastating loss and equity stands at -1'000'000. Most shareholders have lost hope in the\n     * Frankencoin system except for a group of small FPS holders who still believes in it and is willing to provide\n     * 2'000'000 ZCHF to save it. These brave souls are essentially donating 1'000'000 to the minter reserve and it\n     * would be wrong to force them to share the other million with the passive FPS holders. Instead, they will get\n     * the possibility to bootstrap the system again owning 100% of all FPS shares.\n     */\n    function restructureCapTable(address[] calldata helpers, address[] calldata addressesToWipe) public {\n        require(zchf.equity() < MINIMUM_EQUITY);\n        checkQualified(msg.sender, helpers);\n        for (uint256 i = 0; i<addressesToWipe.length; i++){\n            address current = addressesToWipe[0];\n            _burn(current, balanceOf(current));\n        }\n    }\n\n}"
    },
    {
      "filename": "contracts/MintingHub.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\nimport \"./Ownable.sol\";\nimport \"./IPosition.sol\";\n\n/**\n * The central hub for creating, cloning and challenging collateralized Frankencoin positions.\n * Only one instance of this contract is required, whereas every new position comes with a new position\n * contract. Pending challenges are stored as structs in an array.\n */\ncontract MintingHub {\n\n    /**\n     * Irrevocable fee in ZCHF when proposing a new position (but not when cloning an existing one).\n     */\n    uint256 public constant OPENING_FEE = 1000 * 10**18;\n\n    /**\n     * The challenger reward in parts per million (ppm) relative to the challenged amount, whereas\n     * challenged amount if defined as the challenged collateral amount times the liquidation price.\n     */\n    uint32 public constant CHALLENGER_REWARD = 20000; // 2%\n\n    IPositionFactory private immutable POSITION_FACTORY; // position contract to clone\n\n    IFrankencoin public immutable zchf; // currency\n    Challenge[] public challenges; // list of open challenges\n\n    /**\n     * Map to remember pending postponed collateral returns.\n     * It maps collateral => beneficiary => amount.\n     */\n    mapping (address /** col */ => mapping (address => uint256)) public pendingReturns;\n\n    struct Challenge {\n        address challenger; // the address from which the challenge was initiated\n        IPosition position; // the position that was challenged\n        uint256 size;       // how much collateral the challenger provided\n        uint256 end;        // the deadline of the challenge (block.timestamp)\n        address bidder;     // the address from which the highest bid was made, if any\n        uint256 bid;        // the highest bid in ZCHF (total amount, not price per unit)\n    }\n\n    event ChallengeStarted(address indexed challenger, address indexed position, uint256 size, uint256 number);\n    event ChallengeAverted(address indexed position, uint256 number);\n    event ChallengeSucceeded(address indexed position, uint256 bid, uint256 number);\n    event NewBid(uint256 challengedId, uint256 bidAmount, address bidder);\n    event PostPonedReturn(address collateral, address indexed beneficiary, uint256 amount);\n\n    constructor(address _zchf, address factory) {\n        zchf = IFrankencoin(_zchf);\n        POSITION_FACTORY = IPositionFactory(factory);\n    }\n\n    function openPosition(\n        address _collateralAddress, uint256 _minCollateral, uint256 _initialCollateral,\n        uint256 _mintingMaximum, uint256 _expirationSeconds, uint256 _challengeSeconds,\n        uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reservePPM) public returns (address) {\n            return openPosition(_collateralAddress, _minCollateral, _initialCollateral, _mintingMaximum,\n            7 days, _expirationSeconds, _challengeSeconds, _mintingFeePPM, _liqPrice, _reservePPM);\n    }\n\n    /**\n     * Open a collateralized loan position. See also https://docs.frankencoin.com/positions/open .\n     * For a successful call, you must set allowances for both ZCHF and the collateral token, allowing\n     * the minting hub to transfer the initial collateral amount to the newly created position and to\n     * withdraw the fees.\n     *\n     * Together, the expiration and the minting fee imply an interest rate.\n     * TODO: in future versions, it might be better to fix the interest and not the fee\n     *\n     * @param _collateralAddress        address of collateral token\n     * @param _minCollateral     minimum collateral required to prevent dust amounts\n     * @param _initialCollateral amount of initial collateral to be deposited\n     * @param _mintingMaximum    maximal amount of ZCHF that can be minted by the position owner\n     * @param _expirationSeconds position tenor in unit of timestamp (seconds) from 'now'\n     * @param _challengeSeconds  challenge period. Longer for less liquid collateral.\n     * @param _mintingFeePPM     ppm of minted amount that is paid as fee to the equity contract\n     * @param _liqPrice          Liquidation price with (36 - token decimals) decimals,\n     *                           e.g. 18 decimals for an 18 decimal collateral, 36 decimals for a 0 decimal collateral.\n     * @param _reservePPM        ppm of minted amount that is locked as borrower's reserve, e.g. 20%\n     * @return address           address of created position\n     */\n    function openPosition(\n        address _collateralAddress, uint256 _minCollateral, uint256 _initialCollateral,\n        uint256 _mintingMaximum, uint256 _initPeriodSeconds, uint256 _expirationSeconds, uint256 _challengeSeconds,\n        uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reservePPM) public returns (address) {\n        IPosition pos = IPosition(\n            POSITION_FACTORY.createNewPosition(\n                msg.sender,\n                address(zchf),\n                _collateralAddress,\n                _minCollateral,\n                _mintingMaximum,\n                _initPeriodSeconds,\n                _expirationSeconds,\n                _challengeSeconds,\n                _mintingFeePPM,\n                _liqPrice,\n                _reservePPM\n            )\n        );\n        zchf.registerPosition(address(pos));\n        zchf.transferFrom(msg.sender, address(zchf.reserve()), OPENING_FEE);\n        require(_initialCollateral >= _minCollateral, \"must start with min col\");\n        IERC20(_collateralAddress).transferFrom(msg.sender, address(pos), _initialCollateral);\n\n        return address(pos);\n    }\n\n    modifier validPos(address position) {\n        require(zchf.isPosition(position) == address(this), \"not our pos\");\n        _;\n    }\n\n    /**\n     * Clones an existing position and immediately tries to mint the specified amount using the given amount of collateral.\n     * This requires an allowance to be set on the collateral contract such that the minting hub can withdraw the collateral.\n     */\n    function clonePosition(address position, uint256 _initialCollateral, uint256 _initialMint) public validPos(position) returns (address) {\n        IPosition existing = IPosition(position);\n        uint256 limit = existing.reduceLimitForClone(_initialMint);\n        address pos = POSITION_FACTORY.clonePosition(position);\n        zchf.registerPosition(pos);\n        existing.collateral().transferFrom(msg.sender, address(pos), _initialCollateral);\n        IPosition(pos).initializeClone(msg.sender, existing.price(), limit, _initialCollateral, _initialMint);\n        return address(pos);\n    }\n\n    /**\n     * Launch a challenge on a position\n     * @param _positionAddr      address of the position we want to challenge\n     * @param _collateralAmount  size of the collateral we want to challenge (dec 18)\n     * @return index of the challenge in challenge-array\n     */\n    function launchChallenge(address _positionAddr, uint256 _collateralAmount) external validPos(_positionAddr) returns (uint256) {\n        IPosition position = IPosition(_positionAddr);\n        IERC20(position.collateral()).transferFrom(msg.sender, address(this), _collateralAmount);\n        uint256 pos = challenges.length;\n        challenges.push(Challenge(msg.sender, position, _collateralAmount, block.timestamp + position.challengePeriod(), address(0x0), 0));\n        position.notifyChallengeStarted(_collateralAmount);\n        emit ChallengeStarted(msg.sender, address(position), _collateralAmount, pos);\n        return pos;\n    }\n\n    /**\n     * Splits a challenge into two smaller challenges.\n     * This can be useful to guard an attack, where a challenger launches a challenge so big that most bidders do not\n     * have the liquidity available to bid a sufficient amount. With this function, the can split of smaller slices of\n     * the challenge and avert it piece by piece.\n     */\n    function splitChallenge(uint256 _challengeNumber, uint256 splitOffAmount) external returns (uint256) {\n        Challenge storage challenge = challenges[_challengeNumber];\n        require(challenge.challenger != address(0x0));\n        Challenge memory copy = Challenge(\n            challenge.challenger,\n            challenge.position,\n            splitOffAmount,\n            challenge.end,\n            challenge.bidder,\n            (challenge.bid * splitOffAmount) / challenge.size\n        );\n        challenge.bid -= copy.bid;\n        challenge.size -= copy.size;\n\n        uint256 min = IPosition(challenge.position).minimumCollateral();\n        require(challenge.size >= min);\n        require(copy.size >= min);\n\n        uint256 pos = challenges.length;\n        challenges.push(copy);\n        emit ChallengeStarted(challenge.challenger, address(challenge.position), challenge.size, _challengeNumber);\n        emit ChallengeStarted(copy.challenger, address(copy.position), copy.size, pos);\n        return pos;\n    }\n\n    function minBid(uint256 challenge) public view returns (uint256) {\n        return minBid(challenges[challenge]);\n    }\n\n    /**\n     * The minimum bid size for the next bid. It must be 0.5% higher than the previous bid.\n     */\n    function minBid(Challenge storage challenge) internal view returns (uint256) {\n        return (challenge.bid * 1005) / 1000;\n    }\n\n    /**\n     * Post a bid in ZCHF given an open challenge. Requires a ZCHF allowance from the caller to the minting hub.\n     *\n     * @param _challengeNumber   index of the challenge as broadcast in the event\n     * @param _bidAmountZCHF     how much to bid for the collateral of this challenge (dec 18)\n     * @param expectedSize       size verification to guard against frontrunners doing a split-challenge-attack\n     */\n    function bid(uint256 _challengeNumber, uint256 _bidAmountZCHF, uint256 expectedSize) external {\n        Challenge storage challenge = challenges[_challengeNumber];\n        if (block.timestamp >= challenge.end) revert TooLate();\n        if (expectedSize != challenge.size) revert UnexpectedSize();\n        if (challenge.bid > 0) {\n            zchf.transfer(challenge.bidder, challenge.bid); // return old bid\n        }\n        emit NewBid(_challengeNumber, _bidAmountZCHF, msg.sender);\n        // ask position if the bid was high enough to avert the challenge\n        if (challenge.position.tryAvertChallenge(challenge.size, _bidAmountZCHF)) {\n            // bid was high enough, let bidder buy collateral from challenger\n            zchf.transferFrom(msg.sender, challenge.challenger, _bidAmountZCHF);\n            challenge.position.collateral().transfer(msg.sender, challenge.size);\n            emit ChallengeAverted(address(challenge.position), _challengeNumber);\n            delete challenges[_challengeNumber];\n        } else {\n            // challenge is not averted, update bid\n            if (_bidAmountZCHF < minBid(challenge)) revert BidTooLow(_bidAmountZCHF, minBid(challenge));\n            uint256 earliestEnd = block.timestamp + 30 minutes;\n            if (earliestEnd >= challenge.end) {\n                // bump remaining time like ebay does when last minute bids come in\n                // An attacker trying to postpone the challenge forever must increase the bid by 0.5%\n                // every 30 minutes, or double it every three days, making the attack hard to sustain\n                // for a prolonged period of time.\n                challenge.end = earliestEnd;\n            }\n            zchf.transferFrom(msg.sender, address(this), _bidAmountZCHF);\n            challenge.bid = _bidAmountZCHF;\n            challenge.bidder = msg.sender;\n        }\n    }\n\n    error TooLate();\n    error UnexpectedSize();\n    error BidTooLow(uint256 bid, uint256 min);\n\n    function end(uint256 _challengeNumber) external {\n        end(_challengeNumber, false);\n    }\n\n    function isChallengeOpen(uint256 _challengeNumber) external view returns (bool) {\n        return challenges[_challengeNumber].end > block.timestamp;\n    }\n\n    /**\n     * Ends a challenge successfully after the auction period ended, whereas successfully means that the challenger\n     * could show that the price of the collateral is too low to make the position well-collateralized.\n     *\n     * In case that the collateral cannot be transfered back to the challenger (i.e. because the collateral token has a blacklist and the\n     * challenger is on it), it is possible to postpone the return of the collateral.\n     *\n     * @param postponeCollateralReturn Can be used to postpone the return of the collateral to the challenger. Usually false. \n     */\n    function end(uint256 _challengeNumber, bool postponeCollateralReturn) public {\n        Challenge storage challenge = challenges[_challengeNumber];\n        require(challenge.challenger != address(0x0));\n        require(block.timestamp >= challenge.end, \"period has not ended\");\n        // challenge must have been successful, because otherwise it would have immediately ended on placing the winning bid\n        returnCollateral(challenge, postponeCollateralReturn);\n        // notify the position that will send the collateral to the bidder. If there is no bid, send the collateral to msg.sender\n        address recipient = challenge.bidder == address(0x0) ? msg.sender : challenge.bidder;\n        (address owner, uint256 effectiveBid, uint256 volume, uint256 repayment, uint32 reservePPM) = challenge.position.notifyChallengeSucceeded(recipient, challenge.bid, challenge.size);\n        if (effectiveBid < challenge.bid) {\n            // overbid, return excess amount\n            IERC20(zchf).transfer(challenge.bidder, challenge.bid - effectiveBid);\n        }\n        uint256 reward = (volume * CHALLENGER_REWARD) / 1000_000;\n        uint256 fundsNeeded = reward + repayment;\n        if (effectiveBid > fundsNeeded){\n            zchf.transfer(owner, effectiveBid - fundsNeeded);\n        } else if (effectiveBid < fundsNeeded){\n            zchf.notifyLoss(fundsNeeded - effectiveBid); // ensure we have enough to pay everything\n        }\n        zchf.transfer(challenge.challenger, reward); // pay out the challenger reward\n        zchf.burn(repayment, reservePPM); // Repay the challenged part\n        emit ChallengeSucceeded(address(challenge.position), challenge.bid, _challengeNumber);\n        delete challenges[_challengeNumber];\n    }\n\n    /**\n     * Challengers can call this method to withdraw collateral whose return was postponed.\n     */\n    function returnPostponedCollateral(address collateral, address target) external {\n        uint256 amount = pendingReturns[collateral][msg.sender];\n        delete pendingReturns[collateral][msg.sender];\n        IERC20(collateral).transfer(target, amount);\n    }\n\n    function returnCollateral(Challenge storage challenge, bool postpone) internal {\n        if (postpone){\n            // Postponing helps in case the challenger was blacklisted on the collateral token or otherwise cannot receive it at the moment.\n            address collateral = address(challenge.position.collateral());\n            pendingReturns[collateral][challenge.challenger] += challenge.size;\n            emit PostPonedReturn(collateral, challenge.challenger, challenge.size);\n        } else {\n            challenge.position.collateral().transfer(challenge.challenger, challenge.size); // return the challenger's collateral\n        }\n    }\n}\n\ninterface IPositionFactory {\n    function createNewPosition(\n        address _owner,\n        address _zchf,\n        address _collateral,\n        uint256 _minCollateral,\n        uint256 _initialLimit,\n        uint256 _initPeriodSeconds,\n        uint256 _duration,\n        uint256 _challengePeriod,\n        uint32 _mintingFeePPM,\n        uint256 _liqPrice,\n        uint32 _reserve\n    ) external returns (address);\n\n    function clonePosition(address _existing) external returns (address);\n}"
    },
    {
      "filename": "contracts/Position.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IPosition.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\nimport \"./Ownable.sol\";\nimport \"./MathUtil.sol\";\n\n/**\n * A collateralized minting position.\n */\ncontract Position is Ownable, IPosition, MathUtil {\n\n    /**\n     * Note that this contract is intended to be cloned. All clones will share the same values for\n     * the constant and immutable fields, but have their own values for the other fields.\n     */\n\n    uint256 public price; // the zchf price per unit of the collateral below which challenges succeed, (36 - collateral.decimals) decimals\n    uint256 public minted; // net minted amount, including reserve\n    uint256 public challengedAmount; // amount of the collateral that is currently under a challenge\n    uint256 public immutable challengePeriod; // challenge period in seconds\n\n    uint256 public cooldown; // timestamp of the end of the latest cooldown\n    uint256 public limit; // the minted amount must never exceed the limit\n\n    uint256 public immutable start; // timestamp when minting can start\n    uint256 public immutable expiration; // timestamp at which the position expires\n\n    address public immutable original; // originals point to themselves, clone to their origin\n    address public immutable hub; // the hub this position was created by\n    IFrankencoin public immutable zchf; // currency\n    IERC20 public override immutable collateral; // collateral\n    uint256 public override immutable minimumCollateral; // prevent dust amounts\n\n    uint32 public immutable mintingFeePPM;\n    uint32 public immutable reserveContribution; // in ppm\n\n    event PositionOpened(address indexed owner, address original, address zchf, address collateral, uint256 price);\n    event MintingUpdate(uint256 collateral, uint256 price, uint256 minted, uint256 limit);\n    event PositionDenied(address indexed sender, string message); // emitted if closed by"
    }
  ]
}