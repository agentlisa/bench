{
  "Title": "[H-03]  Wrong implementation of EIP712MetaTransaction",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114\n\n\n# Vulnerability details\n\n1. `EIP712MetaTransaction` is a utils contract that intended to be inherited by concrete (actual) contracts, therefore. it's initializer function should not use the `initializer` modifier, instead, it should use `onlyInitializing` modifier. See the implementation of [openzeppelin `EIP712Upgradeable` initializer function](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L48-L57).\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114\n\n```solidity\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment and every upgrade.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function initializeEIP712(string memory _name, string memory _version)\n        public\n        initializer\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n```\n\nOtherwise, when the concrete contract's initializer function (with a `initializer` modifier) is calling EIP712MetaTransaction's initializer function, it will be mistok as reentered and so that it will be reverted (unless in the context of a constructor, e.g. Using @openzeppelin/hardhat-upgrades `deployProxy()` to initialize).\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/proxy/utils/Initializable.sol#L50-L53\n\n```solidity\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n```\n\nSee also: https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/releases/tag/v4.4.1\n\n\n2. `initializer` can only be called once, it can not be \"called once after every upgrade\".\n\nhttps://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114\n\n```solidity\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment and every upgrade.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function initializeEIP712(string memory _name, string memory _version)\n        public\n        initializer\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n```\n\n\n3. A utils contract that is not expected to be deployed as a standalone contract should be declared as `abstract`. It's `initializer` function should be `internal`.\n\nSee the implementation of [openzeppelin `EIP712Upgradeable`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L28).\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L28\n\n```solidity\nabstract contract EIP712Upgradeable is Initializable {\n    // ...\n}\n```\n\n### Recommendation\n\nChange to:\n\n```solidity\nabstract contract EIP712MetaTransaction is EIP712Upgradeable {\n    // ...\n}\n```\n\n```solidity\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function __EIP712MetaTransaction_init(string memory _name, string memory _version)\n        internal\n        onlyInitializing\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n```\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-03-rolla-contest",
  "Code": [
    {
      "filename": "quant-protocol/contracts/utils/EIP712MetaTransaction.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../interfaces/IEIP712MetaTransaction.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../libraries/Actions.sol\";\nimport {ActionArgs} from \"../libraries/Actions.sol\";\n\n/// @title Contract to be inherited by contracts that want to support meta transactions.\n/// @author Rolla\ncontract EIP712MetaTransaction is EIP712Upgradeable {\n    using ECDSA for bytes32;\n\n    struct MetaAction {\n        uint256 nonce;\n        uint256 deadline;\n        address from;\n        ActionArgs[] actions;\n    }\n\n    bytes32 private constant _META_ACTION_TYPEHASH =\n        keccak256(\n            // solhint-disable-next-line max-line-length\n            \"MetaAction(uint256 nonce,uint256 deadline,address from,ActionArgs[] actions)ActionArgs(uint8 actionType,address qToken,address secondaryAddress,address receiver,uint256 amount,uint256 collateralTokenId,bytes data)\"\n        );\n    bytes32 private constant _ACTION_TYPEHASH =\n        keccak256(\n            // solhint-disable-next-line max-line-length\n            \"ActionArgs(uint8 actionType,address qToken,address secondaryAddress,address receiver,uint256 amount,uint256 collateralTokenId,bytes data)\"\n        );\n\n    mapping(address => uint256) private _nonces;\n\n    /// @notice user readable name of signing domain for EIP712 (the protocol name)\n    string public name;\n\n    /// @notice the current major version of the signing domain for EIP712\n    string public version;\n\n    /// @notice emitted when a meta transaction is executed\n    event MetaTransactionExecuted(\n        address indexed userAddress,\n        address payable indexed relayerAddress,\n        uint256 nonce\n    );\n\n    /// @notice Given an encoded action and a signature, executes the action on behalf of the signer.\n    /// @param metaAction The encoded action to be executed.\n    /// @param r The r-value of the signature.\n    /// @param s The s-value of the signature.\n    /// @param v The v-value of the signature.\n    /// @return The returned data from the low-level call.\n    function executeMetaTransaction(\n        MetaAction memory metaAction,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) external payable returns (bytes memory) {\n        require(\n            _verify(metaAction.from, metaAction, r, s, v),\n            \"signer and signature don't match\"\n        );\n\n        uint256 currentNonce = _nonces[metaAction.from];\n\n        // intentionally allow this to overflow to save gas,\n        // and it's impossible for someone to do 2 ^ 256 - 1 meta txs\n        unchecked {\n            _nonces[metaAction.from] = currentNonce + 1;\n        }\n\n        // Append the metaAction.from at the end so that it can be extracted later\n        // from the calling context (see _msgSender() below)\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(\n                abi.encodeWithSelector(\n                    IController(address(this)).operate.selector,\n                    metaAction.actions\n                ),\n                metaAction.from\n            )\n        );\n\n        require(success, \"unsuccessful function call\");\n        emit MetaTransactionExecuted(\n            metaAction.from,\n            payable(msg.sender),\n            currentNonce\n        );\n        return returnData;\n    }\n\n    /// @notice Returns the current nonce for a user.\n    /// @param user the address of the user to get the nonce for.\n    /// @return nonce the current nonce for the user.\n    function getNonce(address user) external view returns (uint256 nonce) {\n        nonce = _nonces[user];\n    }\n\n    /// @notice initialize method for EIP712Upgradeable\n    /// @dev called once after initial deployment and every upgrade.\n    /// @param _name the user readable name of the signing domain for EIP712\n    /// @param _version the current major version of the signing domain for EIP712\n    function initializeEIP712(string memory _name, string memory _version)\n        public\n        initializer\n    {\n        name = _name;\n        version = _version;\n\n        __EIP712_init(_name, _version);\n    }\n\n    /// @notice Returns the address of the signer when called from this contract,\n    /// otherwise returns the msg.sender\n    /// @return sender the address of the signer or msg.sender\n    function _msgSender() internal view returns (address sender) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender := and(\n                    mload(add(array, index)),\n                    0xffffffffffffffffffffffffffffffffffffffff\n                )\n            }\n        } else {\n            sender = msg.sender;\n        }\n        return sender;\n    }\n\n    /// @notice Verifies that the signature is valid for a given user and action.\n    /// @param user the address to check as the signer.\n    /// @param metaAction the action struct to check.\n    /// @param r the r-value of the signature.\n    /// @param s the s-value of the signature.\n    /// @param v the v-value of the signature.\n    function _verify(\n        address user,\n        MetaAction memory metaAction,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) internal view returns (bool) {\n        require(metaAction.nonce == _nonces[user], \"invalid nonce\");\n\n        require(metaAction.deadline >= block.timestamp, \"expired deadline\");\n\n        address signer = _hashTypedDataV4(_hashMetaAction(metaAction)).recover(\n            v,\n            r,\n            s\n        );\n\n        return signer == user;\n    }\n\n    /// @notice Hashes a given ActionArgs struct to be used with EIP712.\n    /// @param action the ActionArgs struct to hash.\n    /// @return the hash of the ActionArgs struct.\n    function _hashAction(ActionArgs memory action)\n        private\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    _ACTION_TYPEHASH,\n                    action.actionType,\n                    action.qToken,\n                    action.secondaryAddress,\n                    action.receiver,\n                    action.amount,\n                    action.collateralTokenId,\n                    keccak256(action.data)\n                )\n            );\n    }\n\n    /// @notice Hashes an array of ActionArgs structs to be used with EIP712.\n    /// @param actions the array of ActionArgs structs to hash.\n    /// @return the array of hashes for the ActionArgs structs.\n    function _hashActions(ActionArgs[] memory actions)\n        private\n        pure\n        returns (bytes32[] memory)\n    {\n        bytes32[] memory hashedActions = new bytes32[](actions.length);\n        uint256 length = actions.length;\n        for (uint256 i = 0; i < length; ) {\n            hashedActions[i] = _hashAction(actions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        return hashedActions;\n    }\n\n    /// @notice Hashes a MetaAction struct to be used with EIP712.\n    /// @param metaAction the MetaAction struct to hash.\n    /// @return the hash of the MetaAction struct.\n    function _hashMetaAction(MetaAction memory metaAction)\n        private\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    _META_ACTION_TYPEHASH,\n                    metaAction.nonce,\n                    metaAction.deadline,\n                    metaAction.from,\n                    keccak256(\n                        abi.encodePacked(_hashActions(metaAction.actions))\n                    )\n                )\n            );\n    }\n}"
    }
  ]
}