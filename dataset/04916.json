{
  "Title": "[L-11] onMessageInvocation checks in _invokeMessageCall() can be bypassed to call arbitrary function from Bridge contract",
  "Content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L490)\n\nThe if block requires the data to be greater than equal to 4 bytes, equal to the onMessageInvocation selector and last but not the least for the target address to be a contract.\n\nWhat an attacker could do to bypass this expected spec is to pre-compute an address for the destination chain and pass it in `_message.to`. He can pass gasLimit = 0 from source to only allow him to process the message on the destination. \n\nOn the destination chain, the attacker can deploy his pre-computed contract address and call processMessage() with it from the constructor. For a chain (L2s/L3s) with no invocation delays, the proving + executing of the message data would go through in one single call.\n\nWhen we arrive at the isContract check below on the `_message.to` address, we evaluate to false since the size of the contract during construction is 0. Due to this, the attacker can validly bypass the onMessageInvocation selector that is a requirement/single source of tx origination by the protocol for all transactions occurring from the bridge contract. This breaks a core invariant of the protocol.\n```solidity\nFile: Bridge.sol\n513:         if (\n514:             _message.data.length >= 4 && // msg can be empty\n515:             bytes4(_message.data) !=\n516:             IMessageInvocable.onMessageInvocation.selector &&\n517:             _message.to.isContract()\n518:         ) {\n519:             success_ = false; \n520:         } else {\n521:             (success_, ) = ExcessivelySafeCall.excessivelySafeCall(\n522:                 _message.to,\n523:                 _gasLimit,\n524:                 _message.value,\n525:                 64, // return max 64 bytes\n526:                 _message.data\n527:             );\n528:         }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/bridge/Bridge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../common/EssentialContract.sol\";\nimport \"../libs/LibAddress.sol\";\nimport \"../signal/ISignalService.sol\";\nimport \"../thirdparty/nomad-xyz/ExcessivelySafeCall.sol\";\nimport \"./IBridge.sol\";\n\n/// @title Bridge\n/// @notice See the documentation for {IBridge}.\n/// @dev Labeled in AddressResolver as \"bridge\". Additionally, the code hash for the same address on\n/// L1 and L2 may be different.\n/// @custom:security-contact security@taiko.xyz\ncontract Bridge is EssentialContract, IBridge {\n    using Address for address;\n    using LibAddress for address;\n    using LibAddress for address payable;\n\n    /// @dev The slot in transient storage of the call context. This is the keccak256 hash\n    /// of \"bridge.ctx_slot\"\n    bytes32 private constant _CTX_SLOT =\n        0xe4ece82196de19aabe639620d7f716c433d1348f96ce727c9989a982dbadc2b9;\n\n    /// @dev Place holder value when not using transient storage\n    uint256 internal constant PLACEHOLDER = type(uint256).max;\n\n    /// @notice The next message ID.\n    /// @dev Slot 1.\n    uint128 public nextMessageId;\n\n    /// @notice Mapping to store the status of a message from its hash.\n    /// @dev Slot 2.\n    mapping(bytes32 msgHash => Status status) public messageStatus;\n\n    /// @dev Slots 3, 4, and 5.\n    Context private __ctx;\n\n    /// @notice Mapping to store banned addresses.\n    /// @dev Slot 6.\n    mapping(address addr => bool banned) public addressBanned;\n\n    /// @notice Mapping to store the proof receipt of a message from its hash.\n    /// @dev Slot 7.\n    mapping(bytes32 msgHash => ProofReceipt receipt) public proofReceipt;\n\n    uint256[43] private __gap;\n\n    error B_INVALID_CHAINID();\n    error B_INVALID_CONTEXT();\n    error B_INVALID_GAS_LIMIT();\n    error B_INVALID_STATUS();\n    error B_INVALID_USER();\n    error B_INVALID_VALUE();\n    error B_MESSAGE_NOT_SENT();\n    error B_NON_RETRIABLE();\n    error B_NOT_FAILED();\n    error B_NOT_RECEIVED();\n    error B_PERMISSION_DENIED();\n    error B_STATUS_MISMATCH();\n    error B_INVOCATION_TOO_EARLY();\n\n    modifier sameChain(uint64 _chainId) {\n        if (_chainId != block.chainid) revert B_INVALID_CHAINID();\n        _;\n    }\n\n    /// @notice Function to receive Ether.\n    receive() external payable { }\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    function init(address _owner, address _addressManager) external initializer {\n        __Essential_init(_owner, _addressManager);\n    }\n\n    /// @notice Suspend or unsuspend invocation for a list of messages.\n    /// @param _msgHashes The array of msgHashes to be suspended.\n    /// @param _suspend True if suspend, false if unsuspend.\n    function suspendMessages(\n        bytes32[] calldata _msgHashes,\n        bool _suspend\n    )\n        external\n        onlyFromOwnerOrNamed(\"bridge_watchdog\")\n    {\n        uint64 _timestamp = _suspend ? type(uint64).max : uint64(block.timestamp);\n        for (uint256 i; i < _msgHashes.length; ++i) {\n            bytes32 msgHash = _msgHashes[i];\n            proofReceipt[msgHash].receivedAt = _timestamp;\n            emit MessageSuspended(msgHash, _suspend);\n        }\n    }\n\n    /// @notice Ban or unban an address. A banned addresses will not be invoked upon\n    /// with message calls.\n    /// @param _addr The address to ban or unban.\n    /// @param _ban True if ban, false if unban.\n    function banAddress(\n        address _addr,\n        bool _ban\n    )\n        external\n        onlyFromOwnerOrNamed(\"bridge_watchdog\")\n        nonReentrant\n    {\n        if (addressBanned[_addr] == _ban) revert B_INVALID_STATUS();\n        addressBanned[_addr] = _ban;\n        emit AddressBanned(_addr, _ban);\n    }\n\n    /// @inheritdoc IBridge\n    function sendMessage(Message calldata _message)\n        external\n        payable\n        override\n        nonReentrant\n        whenNotPaused\n        returns (bytes32 msgHash_, Message memory message_)\n    {\n        // Ensure the message owner is not null.\n        if (_message.srcOwner == address(0) || _message.destOwner == address(0)) {\n            revert B_INVALID_USER();\n        }\n\n        // Check if the destination chain is enabled.\n        (bool destChainEnabled,) = isDestChainEnabled(_message.destChainId);\n\n        // Verify destination chain and to address.\n        if (!destChainEnabled) revert B_INVALID_CHAINID();\n        if (_message.destChainId == block.chainid) {\n            revert B_INVALID_CHAINID();\n        }\n\n        // Ensure the sent value matches the expected amount.\n        uint256 expectedAmount = _message.value + _message.fee;\n        if (expectedAmount != msg.value) revert B_INVALID_VALUE();\n\n        message_ = _message;\n\n        // Configure message details and send signal to indicate message sending.\n        message_.id = nextMessageId++;\n        message_.from = msg.sender;\n        message_.srcChainId = uint64(block.chainid);\n\n        msgHash_ = hashMessage(message_);\n\n        ISignalService(resolve(\"signal_service\", false)).sendSignal(msgHash_);\n        emit MessageSent(msgHash_, message_);\n    }\n\n    /// @inheritdoc IBridge\n    function recallMessage(\n        Message calldata _message,\n        bytes calldata _proof\n    )\n        external\n        nonReentrant\n        whenNotPaused\n        sameChain(_message.srcChainId)\n    {\n        bytes32 msgHash = hashMessage(_message);\n\n        if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH();\n\n        uint64 receivedAt = proofReceipt[msgHash].receivedAt;\n        bool isMessageProven = receivedAt != 0;\n\n        if (!isMessageProven) {\n            address signalService = resolve(\"signal_service\", false);\n\n            if (!ISignalService(signalService).isSignalSent(address(this), msgHash)) {\n                revert B_MESSAGE_NOT_SENT();\n            }\n\n            bytes32 failureSignal = signalForFailedMessage(msgHash);\n            if (!_proveSignalReceived(signalService, failureSignal, _message.destChainId, _proof)) {\n                revert B_NOT_FAILED();\n            }\n\n            receivedAt = uint64(block.timestamp);\n            proofReceipt[msgHash].receivedAt = receivedAt;\n        }\n\n        (uint256 invocationDelay,) = getInvocationDelays();\n\n        if (block.timestamp >= invocationDelay + receivedAt) {\n            delete proofReceipt[msgHash];\n            messageStatus[msgHash] = Status.RECALLED;\n\n            // Execute the recall logic based on the contract's support for the\n            // IRecallableSender interface\n            if (_message.from.supportsInterface(type(IRecallableSender).interfaceId)) {\n                _storeContext(msgHash, address(this), _message.srcChainId);\n\n                // Perform recall\n                IRecallableSender(_message.from).onMessageRecalled{ value: _message.value }(\n                    _message, msgHash\n                );\n\n                // Must reset the context after the message call\n                _resetContext();\n            } else {\n                _message.srcOwner.sendEther(_message.value);\n            }\n            emit MessageRecalled(msgHash);\n        } else if (!isMessageProven) {\n            emit MessageReceived(msgHash, _message, true);\n        } else {\n            revert B_INVOCATION_TOO_EARLY();\n        }\n    }\n\n    /// @inheritdoc IBridge\n    function processMessage(\n        Message calldata _message,\n        bytes calldata _proof\n    )\n        external\n        nonReentrant\n        whenNotPaused\n        sameChain(_message.destChainId)\n    {\n        bytes32 msgHash = hashMessage(_message);\n        if (messageStatus[msgHash] != Status.NEW) revert B_STATUS_MISMATCH();\n\n        address signalService = resolve(\"signal_service\", false);\n        uint64 receivedAt = proofReceipt[msgHash].receivedAt;\n        bool isMessageProven = receivedAt != 0;\n\n        (uint256 invocationDelay, uint256 invocationExtraDelay) = getInvocationDelays();\n\n        if (!isMessageProven) {\n            if (!_proveSignalReceived(signalService, msgHash, _message.srcChainId, _proof)) {\n                revert B_NOT_RECEIVED();\n            }\n\n            receivedAt = uint64(block.timestamp);\n\n            if (invocationDelay != 0) {\n                proofReceipt[msgHash] = ProofReceipt({\n                    receivedAt: receivedAt,\n                    preferredExecutor: _message.gasLimit == 0 ? _message.destOwner : msg.sender\n                });\n            }\n        }\n\n        if (invocationDelay != 0 && msg.sender != proofReceipt[msgHash].preferredExecutor) {\n            // If msg.sender is not the one that proved the message, then there\n            // is an extra delay.\n            unchecked {\n                invocationDelay += invocationExtraDelay;\n            }\n        }\n\n        if (block.timestamp >= invocationDelay + receivedAt) {\n            // If the gas limit is set to zero, only the owner can process the message.\n            if (_message.gasLimit == 0 && msg.sender != _message.destOwner) {\n                revert B_PERMISSION_DENIED();\n            }\n\n            delete proofReceipt[msgHash];\n\n            uint256 refundAmount;\n\n            // Process message differently based on the target address\n            if (\n                _message.to == address(0) || _message.to == address(this)\n                    || _message.to == signalService || addressBanned[_message.to]\n            ) {\n                // Handle special addresses that don't require actual invocation but\n                // mark message as DONE\n                refundAmount = _message.value;\n                _updateMessageStatus(msgHash, Status.DONE);\n            } else {\n                // Use the specified message gas limit if called by the owner, else\n                // use remaining gas\n                uint256 gasLimit = msg.sender == _message.destOwner ? gasleft() : _message.gasLimit;\n\n                if (_invokeMessageCall(_message, msgHash, gasLimit)) {\n                    _updateMessageStatus(msgHash, Status.DONE);\n                } else {\n                    _updateMessageStatus(msgHash, Status.RETRIABLE);\n                }\n            }\n\n            // Determine the refund recipient\n            address refundTo =\n                _message.refundTo == address(0) ? _message.destOwner : _message.refundTo;\n\n            // Refund the processing fee\n            if (msg.sender == refundTo) {\n                refundTo.sendEther(_message.fee + refundAmount);\n            } else {\n                // If sender is another address, reward it and refund the rest\n                msg.sender.sendEther(_message.fee);\n                refundTo.sendEther(refundAmount);\n            }\n            emit MessageExecuted(msgHash);\n        } else if (!isMessageProven) {\n            emit MessageReceived(msgHash, _message, false);\n        } else {\n            revert B_INVOCATION_TOO_EARLY();\n        }\n    }\n\n    /// @inheritdoc IBridge\n    function retryMessage(\n        Message calldata _message,\n        bool _isLastAttempt\n    )\n        external\n        nonReentrant\n        whenNotPaused\n        sameChain(_message.destChainId)\n    {\n        // If the gasLimit is set to 0 or isLastAttempt is true, the caller must\n        // be the message.destOwner.\n        if (_message.gasLimit == 0 || _isLastAttempt) {\n            if (msg.sender != _message.destOwner) revert B_PERMISSION_DENIED();\n        }\n\n        bytes32 msgHash = hashMessage(_message);\n        if (messageStatus[msgHash] != Status.RETRIABLE) {\n            revert B_NON_RETRIABLE();\n        }\n\n        // Attempt to invoke the messageCall.\n        if (_invokeMessageCall(_message, msgHash, gasleft())) {\n            _updateMessageStatus(msgHash, Status.DONE);\n        } else if (_isLastAttempt) {\n            _updateMessageStatus(msgHash, Status.FAILED);\n        }\n        emit MessageRetried(msgHash);\n    }\n\n    /// @inheritdoc IBridge\n    function isMessageSent(Message calldata _message) public view returns (bool) {\n        if (_message.srcChainId != block.chainid) return false;\n        return ISignalService(resolve(\"signal_service\", false)).isSignalSent({\n            _app: address(this),\n            _signal: hashMessage(_message)\n        });\n    }\n\n    /// @notice Checks if a msgHash has failed on its destination chain.\n    /// @param _message The message.\n    /// @param _proof The merkle inclusion proof.\n    /// @return true if the message has failed, false otherwise.\n    function proveMessageFailed(\n        Message calldata _message,\n        bytes calldata _proof\n    )\n        public\n        view\n        returns (bool)\n    {\n        if (_message.srcChainId != block.chainid) return false;\n\n        return _proveSignalReceived(\n            resolve(\"signal_service\", false),\n            signalForFailedMessage(hashMessage(_message)),\n            _message.destChainId,\n            _proof\n        );\n    }\n\n    /// @notice Checks if a msgHash has failed on its destination chain.\n    /// @param _message The message.\n    /// @param _proof The merkle inclusion proof.\n    /// @return true if the message has failed, false otherwise.\n    function proveMessageReceived(\n        Message calldata _message,\n        bytes calldata _proof\n    )\n        public\n        view\n        returns (bool)\n    {\n        if (_message.destChainId != block.chainid) return false;\n        return _proveSignalReceived(\n            resolve(\"signal_service\", false), hashMessage(_message), _message.srcChainId, _proof\n        );\n    }\n\n    /// @notice Checks if the destination chain is enabled.\n    /// @param _chainId The destination chain ID.\n    /// @return enabled_ True if the destination chain is enabled.\n    /// @return destBridge_ The bridge of the destination chain.\n    function isDestChainEnabled(uint64 _chainId)\n        public\n        view\n        returns (bool enabled_, address destBridge_)\n    {\n        destBridge_ = resolve(_chainId, \"bridge\", true);\n        enabled_ = destBridge_ != address(0);\n    }\n\n    /// @notice Gets the current context.\n    /// @inheritdoc IBridge\n    function context() public view returns (Context memory ctx_) {\n        ctx_ = _loadContext();\n        if (ctx_.msgHash == 0 || ctx_.msgHash == bytes32(PLACEHOLDER)) {\n            revert B_INVALID_CONTEXT();\n        }\n    }\n\n    /// @notice Returns invocation delay values.\n    /// @dev Bridge contract deployed on L1 shall use a non-zero value for better\n    /// security.\n    /// @return invocationDelay_ The minimal delay in second before a message can be executed since\n    /// and the time it was received on the this chain.\n    /// @return invocationExtraDelay_ The extra delay in second (to be added to invocationDelay) if\n    /// the transactor is not the preferredExecutor who proved this message.\n    function getInvocationDelays()\n        public\n        view\n        virtual\n        returns (uint256 invocationDelay_, uint256 invocationExtraDelay_)\n    {\n        if (\n            block.chainid == 1 // Ethereum mainnet\n        ) {\n            // For Taiko mainnet\n            // 384 seconds = 6.4 minutes = one ethereum epoch\n            return (1 hours, 384 seconds);\n        } else if (\n            block.chainid == 2 // Ropsten\n                || block.chainid == 4 // Rinkeby\n                || block.chainid == 5 // Goerli\n                || block.chainid == 42 // Kovan\n                || block.chainid == 17_000 // Holesky\n                || block.chainid == 11_155_111 // Sepolia\n        ) {\n            // For all Taiko public testnets\n            return (30 minutes, 384 seconds);\n        } else if (block.chainid >= 32_300 && block.chainid <= 32_400) {\n            // For all Taiko internal devnets\n            return (5 minutes, 384 seconds);\n        } else {\n            // This is a Taiko L2 chain where no deleys are applied.\n            return (0, 0);\n        }\n    }\n\n    /// @inheritdoc IBridge\n    function hashMessage(Message memory _message) public pure returns (bytes32) {\n        return keccak256(abi.encode(\"TAIKO_MESSAGE\", _message));\n    }\n\n    /// @notice Returns a signal representing a failed/recalled message.\n    /// @param _msgHash The message hash.\n    /// @return The failed representation of it as bytes32.\n    function signalForFailedMessage(bytes32 _msgHash) public pure returns (bytes32) {\n        return _msgHash ^ bytes32(uint256(Status.FAILED));\n    }\n\n    /// @notice Checks if the given address can pause and unpause the bridge.\n    function _authorizePause(address)\n        internal\n        view\n        virtual\n        override\n        onlyFromOwnerOrNamed(\"bridge_pauser\")\n    { }\n\n    /// @notice Invokes a call message on the Bridge.\n    /// @param _message The call message to be invoked.\n    /// @param _msgHash The hash of the message.\n    /// @param _gasLimit The gas limit for the message call.\n    /// @return success_ A boolean value indicating whether the message call was\n    /// successful.\n    /// @dev This function updates the context in the state before and after the\n    /// message call.\n    function _invokeMessageCall(\n        Message calldata _message,\n        bytes32 _msgHash,\n        uint256 _gasLimit\n    )\n        private\n        returns (bool success_)\n    {\n        if (_gasLimit == 0) revert B_INVALID_GAS_LIMIT();\n        assert(_message.from != address(this));\n\n        _storeContext(_msgHash, _message.from, _message.srcChainId);\n\n        if (\n            _message.data.length >= 4 // msg can be empty\n                && bytes4(_message.data) != IMessageInvocable.onMessageInvocation.selector\n                && _message.to.isContract()\n        ) {\n            success_ = false;\n        } else {\n            (success_,) = ExcessivelySafeCall.excessivelySafeCall(\n                _message.to,\n                _gasLimit,\n                _message.value,\n                64, // return max 64 bytes\n                _message.data\n            );\n        }\n\n        // Must reset the context after the message call\n        _resetContext();\n    }\n\n    /// @notice Updates the status of a bridge message.\n    /// @dev If the new status is different from the current status in the\n    /// mapping, the status is updated and an event is emitted.\n    /// @param _msgHash The hash of the message.\n    /// @param _status The new status of the message.\n    function _updateMessageStatus(bytes32 _msgHash, Status _status) private {\n        if (messageStatus[_msgHash] == _status) return;\n\n        messageStatus[_msgHash] = _status;\n        emit MessageStatusChanged(_msgHash, _status);\n\n        if (_status == Status.FAILED) {\n            ISignalService(resolve(\"signal_service\", false)).sendSignal(\n                signalForFailedMessage(_msgHash)\n            );\n        }\n    }\n\n    /// @notice Resets the call context\n    function _resetContext() private {\n        if (block.chainid == 1) {\n            _storeContext(bytes32(0), address(0), uint64(0));\n        } else {\n            _storeContext(bytes32(PLACEHOLDER), address(uint160(PLACEHOLDER)), uint64(PLACEHOLDER));\n        }\n    }\n\n    /// @notice Stores the call context\n    /// @param _msgHash The message hash.\n    /// @param _from The sender's address.\n    /// @param _srcChainId The source chain ID.\n    function _storeContext(bytes32 _msgHash, address _from, uint64 _srcChainId) private {\n        if (block.chainid == 1) {\n            assembly {\n                tstore(_CTX_SLOT, _msgHash)\n                tstore(add(_CTX_SLOT, 1), _from)\n                tstore(add(_CTX_SLOT, 2), _srcChainId)\n            }\n        } else {\n            __ctx = Context(_msgHash, _from, _srcChainId);\n        }\n    }\n\n    /// @notice Loads and returns the call context.\n    /// @return ctx_ The call context.\n    function _loadContext() private view returns (Context memory) {\n        if (block.chainid == 1) {\n            bytes32 msgHash;\n            address from;\n            uint64 srcChainId;\n            assembly {\n                msgHash := tload(_CTX_SLOT)\n                from := tload(add(_CTX_SLOT, 1))\n                srcChainId := tload(add(_CTX_SLOT, 2))\n            }\n            return Context(msgHash, from, srcChainId);\n        } else {\n            return __ctx;\n        }\n    }\n\n    /// @notice Checks if the signal was received.\n    /// @param _signalService The signal service address.\n    /// @param _signal The signal.\n    /// @param _chainId The ID of the chain the signal is stored on.\n    /// @param _proof The merkle inclusion proof.\n    /// @return success_ True if the message was received.\n    function _proveSignalReceived(\n        address _signalService,\n        bytes32 _signal,\n        uint64 _chainId,\n        bytes calldata _proof\n    )\n        private\n        view\n        returns (bool success_)\n    {\n        bytes memory data = abi.encodeCall(\n            ISignalService.proveSignalReceived,\n            (_chainId, resolve(_chainId, \"bridge\", false), _signal, _proof)\n        );\n        (success_,) = _signalService.staticcall(data);\n    }\n}"
    }
  ]
}