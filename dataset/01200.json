{
  "Title": "The Caller of release Will Pay Gas Fees for All Payees",
  "Content": "\n\n\n\n\n\nThe [release](https://github.com/oceanprotocol/vw-cli/blob/0397c74da60ae50db5c6414307849120b899af6e/contracts/Splitter.sol#L108) function of the `Splitter` contract iterates over the array of payees in order to disperse payments to each payee. This creates a fairness issue in the scenario where a `payee` is intended to call `release`.  \n  \nConsider allowing each payee to release their own payment.  \n\n\n\n\n\n\n\n\n\n***Update:** Acknowledged, not resolved. The Ocean Protocol team stated:*\n\n\n\n> *OPF is going to trigger reward distribution, this is fine.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Splitter.sol",
      "content": "// BigchainDB GmbH and Ocean Protocol contributors\n// SPDX-License-Identifier: (Apache-2.0 AND MIT)\n\npragma solidity ^0.8.19;\n\nimport \"OpenZeppelin/openzeppelin-contracts@4.7.0/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.7.0/contracts/access/Ownable.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.7.0/contracts/security/ReentrancyGuard.sol\";\n\n// @title Splitter\n// @notice A contract that facilitates splitting payments among multiple payees based on their respective shares.\ncontract Splitter is Ownable, ReentrancyGuard {\n    // total shares held by all payees\n    uint256 private _totalShares;\n\n    // mapping of token addresses to total released\n    mapping(address => uint256) private _totalReleased;\n\n    // emitted when a new payee is added\n    event PayeeAdded(address account, uint256 shares);\n\n    // emitted when tokens are released to payees\n    event PaymentReleased(IERC20 indexed token, uint256 amount);\n    event PayeePaid(IERC20 indexed token, address indexed account, uint256 amount);\n\n    // emitted when a payee is removed\n    event PayeeRemoved(address account, uint256 shares);\n\n    // emitted when a payee's share is adjusted\n    event PayeeShareAdjusted(address account, uint256 shares, uint256 oldShares);\n\n    // mapping of payee addresses to their shares\n    mapping(address => uint256) private _shares;\n\n    // mapping of payee addresses to a mapping of token addresses to released amount\n    mapping(address => mapping(address => uint256)) private _released;\n\n    // list of payee addresses\n    address[] private _payees;\n\n    /**\n     * @dev Constructor function initializes the payees and their shares.\n     * @param payees The addresses of the payees.\n     * @param shares_ The number of shares held by each payee.\n     */\n    constructor(address[] memory payees, uint256[] memory shares_) payable {\n        require(payees.length == shares_.length, \"Splitter: payees and shares length mismatch\");\n        require(payees.length > 0, \"Splitter: no payees\");\n\n        for (uint256 i = 0; i < payees.length; i++) {\n            _addPayee(payees[i], shares_[i]);\n        }\n    }\n\n    // ---------------------------- getters ----------------------------\n    \n    /**\n     * @notice Gets payees.\n     * @return Array of addresses\n     */\n    function getPayees() public view returns (address[] memory) {\n        return _payees;\n    }\n\n\n    /**\n     * @notice Gets the number of shares held by a payee.\n     * @param account The address of the payee.\n     * @return The number of shares held by the payee.\n     */\n    function shares(address account) public view returns (uint256) {\n        return _shares[account];\n    }\n\n    /**\n     * @notice Gets the total number of tokens released to a payee.\n     * @param account The address of the payee.\n     * @param token The address of the token.\n     * @return The number of tokens released to the payee.\n     */\n    function released(address account, address token) public view returns (uint256) {\n        return _released[token][account];\n    }\n\n    /**\n     * @notice Gets the total number of shares held by all payees.\n     * @return The total number of shares held by all payees.\n     */\n    function totalShares() public view returns (uint256) {\n        return _totalShares;\n    }\n\n    /**\n     * @notice Gets the total number of tokens released to all payees.\n     * @param token The address of the token.\n     * @return The total number of tokens released to all payees.\n     */\n    function totalReleased(address token) public view returns (uint256) {\n        return _totalReleased[token];\n    }\n\n    // ---------------------------- external functions ----------------------------\n\n    /**\n    * @notice Release tokens to payees based on their shares.\n    * @param token Address of the token to distribute.\n    */\n    function release(IERC20 token) external nonReentrant {\n        require(_totalShares > 0, \"Splitter: no shares\");\n        uint256 balance = token.balanceOf(address(this));\n        if(balance<1) return;\n        balance = balance - 1; //keep 1 wei in the contract\n        uint256 total = 0;\n        for(uint256 i = 0; i < _payees.length; i++) {\n            address payee = _payees[i];\n            uint256 payment;\n            if (i == _payees.length - 1){\n                payment = balance - total;\n            } else {\n                payment = balance * _shares[payee] / _totalShares;\n            }\n            if (payment > 0) {\n                _released[payee][address(token)] = _released[payee][address(token)] + payment;\n                emit PayeePaid(token, payee, payment);\n                SafeERC20.safeTransfer(token, payee, payment);\n                total += payment;\n            }\n        }\n        _totalReleased[address(token)] = _totalReleased[address(token)] + total;\n        emit PaymentReleased(token, total);\n    }\n\n    /**\n     * @notice Adds a new payee with the given shares\n     * @param account The address of the new payee\n     * @param shares_ The number of shares the new payee will hold\n     */\n    function addPayee(address account, uint256 shares_) external onlyOwner {\n        _addPayee(account, shares_);\n    }\n\n    /**\n     * @notice Removes a payee\n     * @param account The address of the payee to remove\n     */\n    function removePayee(address account) external onlyOwner {\n        _removePayee(account);\n    }\n\n    /**\n     * @notice Adjusts the share of a payee\n     * @param account The address of the payee to adjust the share of\n     * @param shares_ The new number of shares for the payee\n     */\n    function adjustShare(address account, uint256 shares_) external onlyOwner {\n        _adjustShare(account, shares_);\n    }\n\n\n    \n    // ---------------------------- private functions ----------------------------\n\n    /**\n     * @dev Adds a new payee with the specified number of shares.\n     * @param account The address of the payee to add.\n     * @param shares_ The number of shares owned by the payee.\n     */\n    function _addPayee(address account, uint256 shares_) private {\n        require(account != address(0), \"Splitter: zero address\");\n        require(shares_ > 0, \"Splitter: shares are 0\");\n        require(_shares[account] == 0, \"Splitter: account already has shares\");\n\n        _payees.push(account);\n        _shares[account] = shares_;\n        _totalShares = _totalShares + shares_;\n        emit PayeeAdded(account, shares_);\n    }\n\n    /**\n     * @dev Removes an existing payee.\n     * @param account The address of the payee to remove.\n     */\n    function _removePayee(address account) private {\n        require(account != address(0), \"Splitter: zero address\");\n        require(_shares[account] > 0, \"Splitter: account has no shares\");\n\n        for (uint256 i = 0; i < _payees.length; i++) {\n            if (_payees[i] == account) {\n                _payees[i] = _payees[_payees.length - 1];\n                _totalShares = _totalShares - _shares[account];\n                emit PayeeRemoved(account, _shares[account]);\n                _shares[account] = 0;\n                _payees.pop();\n                break;\n            }\n        }\n    }\n\n    /**\n     * @dev Adjusts the number of shares owned by a payee.\n     * @param account The address of the payee to adjust.\n     * @param shares_ The new number of shares.\n     */\n    function _adjustShare(address account, uint256 shares_) private {\n        require(account != address(0), \"Splitter: zero address\");\n        require(shares_ > 0, \"Splitter: shares are 0\");\n        require(_shares[account] > 0, \"Splitter: account has no shares\");\n\n        uint256 oldShares = _shares[account];\n        _shares[account] = shares_;\n        _totalShares = _totalShares - oldShares + shares_;\n        emit PayeeShareAdjusted(account, shares_, oldShares);\n    }\n\n\n    //---------------------------- fallback ----------------------------\n   \n    receive() external payable virtual {\n        revert(\"Splitter: cannot receive ether\");\n    }\n}"
    }
  ]
}