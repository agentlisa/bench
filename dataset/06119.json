{
  "Title": "[G-08] Using Storage Instead of Memory for structs/arrays Saves Gas",
  "Content": "- Severity: Gas Optimization\n- Confidence: Medium\n- Total Gas Saved: 37800\n\n### Note \nI reported issue that was overlooked by the winning bot.\n\n### Description\nWhen fetching data from a storage location, assigning the data to a memory variable causes all fields of the struct / array to be read from storage. This incurs a Gcoldsload (2100 gas) for each field of the struct / array. If the fields are read from the new memory variable, they incur an additional MLOAD, which is more expensive than a simple stack read.\n\nInstead of declaring the variable with the memory keyword, a more cost-effective approach is to declare the variable with the storage keyword. In this case, you can cache any fields that need to be re-read in stack variables. This approach significantly reduces gas costs, as you only incur the Gcoldsload for the fields actually read.\n\nThe only scenario where it makes sense to read the whole struct / array into a memory variable is if the full struct / array is being returned by the function or passed to a function that requires memory. Additionally, if the array / struct is being read from another memory array / struct, using a memory variable may be appropriate.\n\nBy carefully considering the storage and memory usage in your contract, you can optimize gas costs and improve the efficiency of your smart contract operations.\n\n<details>\n\n<summary>\nThere are 5 instances of this issue:\n\n</summary>\n\n###\n- File: solidity/contracts/core/Vault.sol\n```\n \nLine: 170          IVaultController.CollateralInfo memory _collateralInfo = CONTROLLER.tokenCollateralInfo(_tokenAddresses[_i])\n```\n should be declared as `storage` \n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/Vault.sol#L170](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/Vault.sol#L170)\n\n- File: solidity/contracts/core/VaultController.sol\n```\n \nLine: 729          CollateralInfo memory _collateral = tokenAddressCollateralInfo[_assetAddress]\n```\n should be declared as `storage` \n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L729](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L729)\n\n- File: solidity/contracts/core/VaultController.sol\n```\n \nLine: 751          CollateralInfo memory _collateral = tokenAddressCollateralInfo[_assetAddress]\n```\n should be declared as `storage` \n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L751](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L751)\n\n- File: solidity/contracts/core/VaultController.sol\n```\n \nLine: 996          uint256[] memory _tokenBalances = new uint256[](enabledTokens.length)\n```\n should be declared as `storage` \n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L996](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L996)\n\n- File: solidity/contracts/governance/GovernorCharlie.sol\n```\n \nLine: 187          Proposal memory _newProposal = Proposal({\n      id: proposalCount,\n      proposer: msg.sender,\n      eta: 0,\n      targets: _targets,\n      values: _values,\n      signatures: _signatures,\n      calldatas: _calldatas,\n      startBlock: block.number + votingDelay,\n      endBlock: block.number + votingDelay + votingPeriod,\n      forVotes: 0,\n      againstVotes: 0,\n      abstainVotes: 0,\n      canceled: false,\n      executed: false,\n      emergency: _emergency,\n      quorumVotes: quorumVotes,\n      delay: proposalTimelockDelay\n    })\n```\n should be declared as `storage` \n\n[https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L187-L205](https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/governance/GovernorCharlie.sol#L187-L205)\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-amphora",
  "Code": [
    {
      "filename": "core/solidity/contracts/core/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\nimport {IVault} from '@interfaces/core/IVault.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\nimport {IAMPHClaimer} from '@interfaces/core/IAMPHClaimer.sol';\nimport {IBooster} from '@interfaces/utils/IBooster.sol';\nimport {IBaseRewardPool} from '@interfaces/utils/IBaseRewardPool.sol';\nimport {IVirtualBalanceRewardPool} from '@interfaces/utils/IVirtualBalanceRewardPool.sol';\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {SafeERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport {ICVX} from '@interfaces/utils/ICVX.sol';\n\n/// @notice Vault contract, our implementation of maker-vault like vault\n/// @dev Major differences:\n/// 1. multi-collateral\n/// 2. generate interest in USDA\ncontract Vault is IVault, Context {\n  using SafeERC20Upgradeable for IERC20;\n\n  /// @dev The CVX token\n  ICVX public immutable CVX;\n\n  /// @dev The CRV token\n  IERC20 public immutable CRV;\n\n  /// @dev The vault controller\n  IVaultController public immutable CONTROLLER;\n\n  /// @dev Metadata of vault, aka the id & the minter's address\n  VaultInfo public vaultInfo;\n\n  /// @dev This is the unscaled liability of the vault.\n  /// The number is meaningless on its own, and must be combined with the factor taken from\n  /// the vaultController in order to find the true liabilitiy\n  uint256 public baseLiability;\n\n  /// @dev Keeps track of the accounting of the collateral deposited\n  mapping(address => uint256) public balances;\n\n  /// @dev Keeps track of the tokens that are staked on convex\n  mapping(address => bool) public isTokenStaked;\n\n  /// @notice Checks if _msgSender is the controller of the vault\n  modifier onlyVaultController() {\n    if (_msgSender() != address(CONTROLLER)) revert Vault_NotVaultController();\n    _;\n  }\n\n  /// @notice Checks if _msgSender is the minter of the vault\n  modifier onlyMinter() {\n    if (_msgSender() != vaultInfo.minter) revert Vault_NotMinter();\n    _;\n  }\n\n  /// @dev Must be called by VaultController, else it will not be registered as a vault in system\n  /// @param _id Unique id of the vault, ever increasing and tracked by VaultController\n  /// @param _minter Address of the person who created this vault\n  /// @param _controllerAddress Address of the VaultController\n  /// @param _cvx Address of CVX token\n  /// @param _crv Address of CRV token\n  constructor(uint96 _id, address _minter, address _controllerAddress, IERC20 _cvx, IERC20 _crv) {\n    vaultInfo = VaultInfo(_id, _minter);\n    CONTROLLER = IVaultController(_controllerAddress);\n    CVX = ICVX(address(_cvx));\n    CRV = _crv;\n  }\n\n  /// @notice Returns the minter of the vault\n  /// @return _minter The address of minter\n  function minter() external view override returns (address _minter) {\n    _minter = vaultInfo.minter;\n  }\n\n  /// @notice Returns the id of the vault\n  /// @return _id The id of the vault\n  function id() external view override returns (uint96 _id) {\n    _id = vaultInfo.id;\n  }\n\n  /// @notice Used to deposit a token to the vault\n  /// @dev    Deposits and stakes on convex if token is of type CurveLPStakedOnConvex\n  /// @param _token The address of the token to deposit\n  /// @param _amount The amount of the token to deposit\n  function depositERC20(address _token, uint256 _amount) external override onlyMinter {\n    if (CONTROLLER.tokenId(_token) == 0) revert Vault_TokenNotRegistered();\n    if (_amount == 0) revert Vault_AmountZero();\n    SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(this), _amount);\n    if (CONTROLLER.tokenCollateralType(_token) == IVaultController.CollateralType.CurveLPStakedOnConvex) {\n      uint256 _poolId = CONTROLLER.tokenPoolId(_token);\n      /// If it's type CurveLPStakedOnConvex then pool id can't be 0\n      IBooster _booster = CONTROLLER.BOOSTER();\n      if (isTokenStaked[_token]) {\n        /// In this case the user's balance is already staked so we only stake the newly deposited amount\n        _depositAndStakeOnConvex(_token, _booster, _amount, _poolId);\n      } else {\n        /// In this case the user's balance isn't staked so we stake the amount + his balance for the specific tokenv\n        isTokenStaked[_token] = true;\n        _depositAndStakeOnConvex(_token, _booster, balances[_token] + _amount, _poolId);\n      }\n    }\n    balances[_token] += _amount;\n    CONTROLLER.modifyTotalDeposited(vaultInfo.id, _amount, _token, true);\n    emit Deposit(_token, _amount);\n  }\n\n  /// @notice Withdraws an erc20 token from the vault\n  /// @dev    This can only be called by the minter\n  ///         The withdraw will be denied if ones vault would become insolvent\n  ///         If the withdraw token is of CurveLPStakedOnConvex then unstake and withdraw directly to user\n  /// @param _tokenAddress The address of erc20 token\n  /// @param _amount The amount of erc20 token to withdraw\n  function withdrawERC20(address _tokenAddress, uint256 _amount) external override onlyMinter {\n    if (CONTROLLER.tokenId(_tokenAddress) == 0) revert Vault_TokenNotRegistered();\n    if (isTokenStaked[_tokenAddress]) {\n      if (!CONTROLLER.tokenCrvRewardsContract(_tokenAddress).withdrawAndUnwrap(_amount, false)) {\n        revert Vault_WithdrawAndUnstakeOnConvexFailed();\n      }\n    }\n    // reduce balance\n    balances[_tokenAddress] -= _amount;\n    // check if the account is solvent\n    if (!CONTROLLER.checkVault(vaultInfo.id)) revert Vault_OverWithdrawal();\n    // transfer the token to the owner\n    SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(_tokenAddress), _msgSender(), _amount);\n    // modify total deposited\n    CONTROLLER.modifyTotalDeposited(vaultInfo.id, _amount, _tokenAddress, false);\n    emit Withdraw(_tokenAddress, _amount);\n  }\n\n  /// @notice Let's the user manually stake their crvLP\n  /// @dev    This can be called if the convex pool didn't exist when the token was registered\n  ///         and was later updated\n  /// @param _tokenAddress The address of erc20 crvLP token\n  function stakeCrvLPCollateral(address _tokenAddress) external override onlyMinter {\n    uint256 _poolId = CONTROLLER.tokenPoolId(_tokenAddress);\n    if (_poolId == 0) revert Vault_TokenCanNotBeStaked();\n    if (balances[_tokenAddress] == 0) revert Vault_TokenZeroBalance();\n    if (isTokenStaked[_tokenAddress]) revert Vault_TokenAlreadyStaked();\n\n    isTokenStaked[_tokenAddress] = true;\n\n    IBooster _booster = CONTROLLER.BOOSTER();\n    _depositAndStakeOnConvex(_tokenAddress, _booster, balances[_tokenAddress], _poolId);\n\n    emit Staked(_tokenAddress, balances[_tokenAddress]);\n  }\n\n  /// @notice Returns true when user can manually stake their token balance\n  /// @param _token The address of the token to check\n  /// @return _canStake Returns true if the token can be staked manually\n  function canStake(address _token) external view override returns (bool _canStake) {\n    uint256 _poolId = CONTROLLER.tokenPoolId(_token);\n    if (_poolId != 0 && balances[_token] != 0 && !isTokenStaked[_token]) _canStake = true;\n  }\n\n  /// @notice Claims available rewards from multiple tokens\n  /// @dev    Transfers a percentage of the crv and cvx rewards to claim AMPH tokens\n  /// @param _tokenAddresses The addresses of the erc20 tokens\n  function claimRewards(address[] memory _tokenAddresses) external override onlyMinter {\n    uint256 _totalCrvReward;\n    uint256 _totalCvxReward;\n\n    IAMPHClaimer _amphClaimer = CONTROLLER.claimerContract();\n    for (uint256 _i; _i < _tokenAddresses.length;) {\n      IVaultController.CollateralInfo memory _collateralInfo = CONTROLLER.tokenCollateralInfo(_tokenAddresses[_i]);\n      if (_collateralInfo.tokenId == 0) revert Vault_TokenNotRegistered();\n      if (_collateralInfo.collateralType != IVaultController.CollateralType.CurveLPStakedOnConvex) {\n        revert Vault_TokenNotCurveLP();\n      }\n\n      IBaseRewardPool _rewardsContract = _collateralInfo.crvRewardsContract;\n      uint256 _crvReward = _rewardsContract.earned(address(this));\n\n      if (_crvReward != 0) {\n        // Claim the CRV reward\n        _totalCrvReward += _crvReward;\n        _rewardsContract.getReward(address(this), false);\n        _totalCvxReward += _calculateCVXReward(_crvReward);\n      }\n\n      // Loop and claim all virtual rewards\n      uint256 _extraRewards = _rewardsContract.extraRewardsLength();\n      for (uint256 _j; _j < _extraRewards;) {\n        IVirtualBalanceRewardPool _virtualReward = _rewardsContract.extraRewards(_j);\n        IERC20 _rewardToken = _virtualReward.rewardToken();\n        uint256 _earnedReward = _virtualReward.earned(address(this));\n        if (_earnedReward != 0) {\n          _virtualReward.getReward();\n          _rewardToken.transfer(_msgSender(), _earnedReward);\n          emit ClaimedReward(address(_rewardToken), _earnedReward);\n        }\n        unchecked {\n          ++_j;\n        }\n      }\n      unchecked {\n        ++_i;\n      }\n    }\n\n    if (_totalCrvReward > 0 || _totalCvxReward > 0) {\n      if (address(_amphClaimer) != address(0)) {\n        // Approve amounts for it to be taken\n        (uint256 _takenCVX, uint256 _takenCRV, uint256 _claimableAmph) =\n          _amphClaimer.claimable(address(this), this.id(), _totalCvxReward, _totalCrvReward);\n        if (_claimableAmph != 0) {\n          CRV.approve(address(_amphClaimer), _takenCRV);\n          CVX.approve(address(_amphClaimer), _takenCVX);\n\n          // Claim AMPH tokens depending on how much CRV and CVX was claimed\n          _amphClaimer.claimAmph(this.id(), _totalCvxReward, _totalCrvReward, _msgSender());\n\n          _totalCvxReward -= _takenCVX;\n          _totalCrvReward -= _takenCRV;\n        }\n      }\n\n      if (_totalCvxReward > 0) CVX.transfer(_msgSender(), _totalCvxReward);\n      if (_totalCrvReward > 0) CRV.transfer(_msgSender(), _totalCrvReward);\n\n      emit ClaimedReward(address(CRV), _totalCrvReward);\n      emit ClaimedReward(address(CVX), _totalCvxReward);\n    }\n  }\n\n  /// @notice Returns an array of all the available rewards the user can claim\n  /// @param _tokenAddress The address of the token collateral to check rewards for\n  /// @return _rewards The array of all the available rewards\n  function claimableRewards(address _tokenAddress) external view override returns (Reward[] memory _rewards) {\n    if (CONTROLLER.tokenId(_tokenAddress) == 0) revert Vault_TokenNotRegistered();\n    if (CONTROLLER.tokenCollateralType(_tokenAddress) != IVaultController.CollateralType.CurveLPStakedOnConvex) {\n      revert Vault_TokenNotCurveLP();\n    }\n\n    IBaseRewardPool _rewardsContract = CONTROLLER.tokenCrvRewardsContract(_tokenAddress);\n    IAMPHClaimer _amphClaimer = CONTROLLER.claimerContract();\n\n    uint256 _rewardsAmount = _rewardsContract.extraRewardsLength();\n\n    uint256 _crvReward = _rewardsContract.earned(address(this));\n    uint256 _cvxReward = _calculateCVXReward(_crvReward);\n\n    // +3 for CRV, CVX and AMPH\n    _rewards = new Reward[](_rewardsAmount+3);\n    _rewards[0] = Reward(CRV, _crvReward);\n    _rewards[1] = Reward(CVX, _cvxReward);\n\n    uint256 _i;\n    for (_i; _i < _rewardsAmount;) {\n      IVirtualBalanceRewardPool _virtualReward = _rewardsContract.extraRewards(_i);\n      IERC20 _rewardToken = _virtualReward.rewardToken();\n      uint256 _earnedReward = _virtualReward.earned(address(this));\n      _rewards[_i + 2] = Reward(_rewardToken, _earnedReward);\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    uint256 _takenCVX;\n    uint256 _takenCRV;\n    uint256 _claimableAmph;\n    // if claimer is not set, nothing will happen (and variables are already in zero)\n    if (address(_amphClaimer) != address(0)) {\n      // claimer is set, proceed\n      (_takenCVX, _takenCRV, _claimableAmph) = _amphClaimer.claimable(address(this), this.id(), _cvxReward, _crvReward);\n      _rewards[_i + 2] = Reward(_amphClaimer.AMPH(), _claimableAmph);\n    }\n\n    _rewards[0].amount = _crvReward - _takenCRV;\n    if (_cvxReward > 0) _rewards[1].amount = _cvxReward - _takenCVX;\n  }\n\n  /// @notice Function used by the VaultController to transfer tokens\n  /// @dev Callable by the VaultController only\n  /// @param _token The token to transfer\n  /// @param _to The address to send the tokens to\n  /// @param _amount The amount of tokens to move\n  function controllerTransfer(address _token, address _to, uint256 _amount) external override onlyVaultController {\n    SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(_token), _to, _amount);\n    balances[_token] -= _amount;\n  }\n\n  /// @notice Function used by the VaultController to withdraw from convex\n  /// @dev Callable by the VaultController only\n  /// @param _rewardPool The pool to withdraw\n  /// @param _amount The amount of tokens to withdraw\n  function controllerWithdrawAndUnwrap(\n    IBaseRewardPool _rewardPool,\n    uint256 _amount\n  ) external override onlyVaultController {\n    if (!_rewardPool.withdrawAndUnwrap(_amount, false)) revert Vault_WithdrawAndUnstakeOnConvexFailed();\n  }\n\n  /// @notice Function used by the VaultController to reduce a vault's liability\n  /// @dev Callable by the VaultController only\n  /// @param _increase True to increase, false to decrease\n  /// @param _baseAmount The change in base liability\n  /// @return _newLiability The new liability\n  function modifyLiability(\n    bool _increase,\n    uint256 _baseAmount\n  ) external override onlyVaultController returns (uint256 _newLiability) {\n    if (_increase) {\n      baseLiability += _baseAmount;\n    } else {\n      // require statement only valid for repayment\n      if (baseLiability < _baseAmount) revert Vault_RepayTooMuch();\n      baseLiability -= _baseAmount;\n    }\n    _newLiability = baseLiability;\n  }\n\n  /// @dev Internal function for depositing and staking on convex\n  function _depositAndStakeOnConvex(address _token, IBooster _booster, uint256 _amount, uint256 _poolId) internal {\n    IERC20(_token).approve(address(_booster), _amount);\n    if (!_booster.deposit(_poolId, _amount, true)) revert Vault_DepositAndStakeOnConvexFailed();\n  }\n\n  /// @notice Used to calculate the CVX reward for a given CRV amount\n  /// @dev This is copied from the CVX mint function\n  /// @param _crv The amount of CRV to calculate the CVX reward for\n  /// @return _cvxAmount The amount of CVX to get\n  function _calculateCVXReward(uint256 _crv) internal view returns (uint256 _cvxAmount) {\n    uint256 _supply = CVX.totalSupply();\n    uint256 _totalCliffs = CVX.totalCliffs();\n\n    //use current supply to gauge cliff\n    //this will cause a bit of overflow into the next cliff range\n    //but should be within reasonable levels.\n    //requires a max supply check though\n    uint256 _cliff = _supply / CVX.reductionPerCliff();\n    //mint if below total cliffs\n    if (_cliff < _totalCliffs) {\n      //for reduction% take inverse of current cliff\n      uint256 _reduction = _totalCliffs - _cliff;\n      //reduce\n      _cvxAmount = (_crv * _reduction) / _totalCliffs;\n\n      //supply cap check\n      uint256 _amtTillMax = CVX.maxSupply() - _supply;\n      if (_cvxAmount > _amtTillMax) _cvxAmount = _amtTillMax;\n    }\n  }\n}"
    },
    {
      "filename": "core/solidity/contracts/core/VaultController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ExponentialNoError} from '@contracts/utils/ExponentialNoError.sol';\nimport {CurveMaster} from '@contracts/periphery/CurveMaster.sol';\n\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\nimport {IVault} from '@interfaces/core/IVault.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\nimport {IOracleRelay} from '@interfaces/periphery/IOracleRelay.sol';\nimport {IBooster} from '@interfaces/utils/IBooster.sol';\nimport {IBaseRewardPool} from '@interfaces/utils/IBaseRewardPool.sol';\nimport {IAMPHClaimer} from '@interfaces/core/IAMPHClaimer.sol';\nimport {IVaultDeployer} from '@interfaces/core/IVaultDeployer.sol';\n\nimport {IERC20, IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\n\n/// @notice Controller of all vaults in the USDA borrow/lend system\n///         VaultController contains all business logic for borrowing and lending through the protocol.\n///         It is also in charge of accruing interest.\ncontract VaultController is Pausable, IVaultController, ExponentialNoError, Ownable {\n  /// @dev The max decimals allowed for a listed token\n  uint8 public constant MAX_DECIMALS = 18;\n\n  /// @dev The max allowed to be set as borrowing fee\n  uint192 public constant MAX_INIT_BORROWING_FEE = 0.05e18;\n\n  /// @dev The convex booster interface\n  IBooster public immutable BOOSTER;\n\n  /// @dev The vault deployer interface\n  IVaultDeployer public immutable VAULT_DEPLOYER;\n\n  /// @dev Mapping of vault id to vault address\n  mapping(uint96 => address) public vaultIdVaultAddress;\n\n  /// @dev Mapping of wallet address to vault IDs arrays\n  mapping(address => uint96[]) public walletVaultIDs;\n\n  /// @dev Mapping of token address to collateral info\n  mapping(address => CollateralInfo) public tokenAddressCollateralInfo;\n\n  /// @dev Array of enabled tokens addresses\n  address[] public enabledTokens;\n\n  /// @dev The curve master contract\n  CurveMaster public curveMaster;\n\n  /// @dev The interest contract\n  Interest public interest;\n\n  /// @dev The usda interface\n  IUSDA public usda;\n\n  /// @dev The amphora claimer interface\n  IAMPHClaimer public claimerContract;\n\n  /// @dev Total number of minted vaults\n  uint96 public vaultsMinted;\n  /// @dev Total number of tokens registered\n  uint256 public tokensRegistered;\n  /// @dev Total base liability\n  uint192 public totalBaseLiability;\n  /// @dev The protocol's fee\n  uint192 public protocolFee;\n  /// @dev The initial borrowing fee (1e18 == 100%)\n  uint192 public initialBorrowingFee;\n  /// @dev The fee taken from the liquidator profit (1e18 == 100%)\n  uint192 public liquidationFee;\n\n  /// @notice Any function with this modifier will call the _payInterest() function before\n  modifier paysInterest() {\n    _payInterest();\n    _;\n  }\n\n  ///@notice Any function with this modifier can be paused or unpaused by USDA._pauser() in the case of an emergency\n  modifier onlyPauser() {\n    if (_msgSender() != usda.pauser()) revert VaultController_OnlyPauser();\n    _;\n  }\n\n  /// @notice Can initialize collaterals from an older vault controller\n  /// @param _oldVaultController The old vault controller\n  /// @param _tokenAddresses The addresses of the collateral we want to take information for\n  /// @param _claimerContract The claimer contract\n  /// @param _vaultDeployer The deployer contract\n  /// @param _initialBorrowingFee The initial borrowing fee\n  /// @param _booster The convex booster address\n  /// @param _liquidationFee The liquidation fee\n  constructor(\n    IVaultController _oldVaultController,\n    address[] memory _tokenAddresses,\n    IAMPHClaimer _claimerContract,\n    IVaultDeployer _vaultDeployer,\n    uint192 _initialBorrowingFee,\n    address _booster,\n    uint192 _liquidationFee\n  ) {\n    VAULT_DEPLOYER = _vaultDeployer;\n    interest = Interest(uint64(block.timestamp), 1 ether);\n    protocolFee = 1e14;\n    initialBorrowingFee = _initialBorrowingFee;\n    liquidationFee = _liquidationFee;\n\n    claimerContract = _claimerContract;\n\n    BOOSTER = IBooster(_booster);\n\n    if (address(_oldVaultController) != address(0)) _migrateCollateralsFrom(_oldVaultController, _tokenAddresses);\n  }\n\n  /// @notice Returns the latest interest factor\n  /// @return _interestFactor The latest interest factor\n  function interestFactor() external view override returns (uint192 _interestFactor) {\n    _interestFactor = interest.factor;\n  }\n\n  /// @notice Returns the block timestamp when pay interest was last called\n  /// @return _lastInterestTime The block timestamp when pay interest was last called\n  function lastInterestTime() external view override returns (uint64 _lastInterestTime) {\n    _lastInterestTime = interest.lastTime;\n  }\n\n  /// @notice Returns an array of all the vault ids a specific wallet has\n  /// @param _wallet The address of the wallet to target\n  /// @return _vaultIDs The ids of the vaults the wallet has\n  function vaultIDs(address _wallet) external view override returns (uint96[] memory _vaultIDs) {\n    _vaultIDs = walletVaultIDs[_wallet];\n  }\n\n  /// @notice Returns an array of all enabled tokens\n  /// @return _enabledTokens The array containing the token addresses\n  function getEnabledTokens() external view override returns (address[] memory _enabledTokens) {\n    _enabledTokens = enabledTokens;\n  }\n\n  /// @notice Returns the token id given a token's address\n  /// @param _tokenAddress The address of the token to target\n  /// @return _tokenId The id of the token\n  function tokenId(address _tokenAddress) external view override returns (uint256 _tokenId) {\n    _tokenId = tokenAddressCollateralInfo[_tokenAddress].tokenId;\n  }\n\n  /// @notice Returns the oracle given a token's address\n  /// @param _tokenAddress The id of the token\n  /// @return _oracle The address of the token's oracle\n  function tokensOracle(address _tokenAddress) external view override returns (IOracleRelay _oracle) {\n    _oracle = tokenAddressCollateralInfo[_tokenAddress].oracle;\n  }\n\n  /// @notice Returns the ltv of a given token address\n  /// @param _tokenAddress The address of the token\n  /// @return _ltv The loan-to-value of a token\n  function tokenLTV(address _tokenAddress) external view override returns (uint256 _ltv) {\n    _ltv = tokenAddressCollateralInfo[_tokenAddress].ltv;\n  }\n\n  /// @notice Returns the liquidation incentive of an accepted token collateral\n  /// @param _tokenAddress The address of the token\n  /// @return _liquidationIncentive The liquidation incentive of the token\n  function tokenLiquidationIncentive(address _tokenAddress)\n    external\n    view\n    override\n    returns (uint256 _liquidationIncentive)\n  {\n    _liquidationIncentive = tokenAddressCollateralInfo[_tokenAddress].liquidationIncentive;\n  }\n\n  /// @notice Returns the cap of a given token address\n  /// @param _tokenAddress The address of the token\n  /// @return _cap The cap of the token\n  function tokenCap(address _tokenAddress) external view override returns (uint256 _cap) {\n    _cap = tokenAddressCollateralInfo[_tokenAddress].cap;\n  }\n\n  /// @notice Returns the total deposited of a given token address\n  /// @param _tokenAddress The address of the token\n  /// @return _totalDeposited The total deposited of a token\n  function tokenTotalDeposited(address _tokenAddress) external view override returns (uint256 _totalDeposited) {\n    _totalDeposited = tokenAddressCollateralInfo[_tokenAddress].totalDeposited;\n  }\n\n  /// @notice Returns the collateral type of a token\n  /// @param _tokenAddress The address of the token\n  /// @return _type The collateral type of a token\n  function tokenCollateralType(address _tokenAddress) external view override returns (CollateralType _type) {\n    _type = tokenAddressCollateralInfo[_tokenAddress].collateralType;\n  }\n\n  /// @notice Returns the address of the crvRewards contract\n  /// @param _tokenAddress The address of the token\n  /// @return _crvRewardsContract The address of the crvRewards contract\n  function tokenCrvRewardsContract(address _tokenAddress)\n    external\n    view\n    override\n    returns (IBaseRewardPool _crvRewardsContract)\n  {\n    _crvRewardsContract = tokenAddressCollateralInfo[_tokenAddress].crvRewardsContract;\n  }\n\n  /// @notice Returns the pool id of a curve LP type token\n  /// @dev    If the token is not of type CurveLPStakedOnConvex then it returns 0\n  /// @param _tokenAddress The address of the token\n  /// @return _poolId The pool id of a curve LP type token\n  function tokenPoolId(address _tokenAddress) external view override returns (uint256 _poolId) {\n    _poolId = tokenAddressCollateralInfo[_tokenAddress].poolId;\n  }\n\n  /// @notice Returns the collateral info of a given token address\n  /// @param _tokenAddress The address of the token\n  /// @return _collateralInfo The complete collateral info of the token\n  function tokenCollateralInfo(address _tokenAddress)\n    external\n    view\n    override\n    returns (CollateralInfo memory _collateralInfo)\n  {\n    _collateralInfo = tokenAddressCollateralInfo[_tokenAddress];\n  }\n\n  /// @notice Returns the selected collaterals info. Will iterate from `_start` (included) until `_end` (not included)\n  /// @param _start The start number to loop on the array\n  /// @param _end The end number to loop on the array\n  /// @return _collateralsInfo The array containing all the collateral info\n  function getCollateralsInfo(\n    uint256 _start,\n    uint256 _end\n  ) external view override returns (CollateralInfo[] memory _collateralsInfo) {\n    // check if `_end` is bigger than the tokens length\n    uint256 _enabledTokensLength = enabledTokens.length;\n    _end = _enabledTokensLength < _end ? _enabledTokensLength : _end;\n\n    _collateralsInfo = new CollateralInfo[](_end - _start);\n\n    for (uint256 _i = _start; _i < _end;) {\n      _collateralsInfo[_i - _start] = tokenAddressCollateralInfo[enabledTokens[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /// @notice Migrates all collateral information from previous vault controller\n  /// @param _oldVaultController The address of the vault controller to take the information from\n  /// @param _tokenAddresses The addresses of the tokens we want to target\n  function _migrateCollateralsFrom(IVaultController _oldVaultController, address[] memory _tokenAddresses) internal {\n    uint256 _tokenId;\n    uint256 _tokensRegistered;\n    for (uint256 _i; _i < _tokenAddresses.length;) {\n      _tokenId = _oldVaultController.tokenId(_tokenAddresses[_i]);\n      if (_tokenId == 0) revert VaultController_WrongCollateralAddress();\n      _tokensRegistered++;\n\n      CollateralInfo memory _collateral = _oldVaultController.tokenCollateralInfo(_tokenAddresses[_i]);\n      _collateral.tokenId = _tokensRegistered;\n      _collateral.totalDeposited = 0;\n\n      enabledTokens.push(_tokenAddresses[_i]);\n      tokenAddressCollateralInfo[_tokenAddresses[_i]] = _collateral;\n\n      unchecked {\n        ++_i;\n      }\n    }\n    tokensRegistered += _tokensRegistered;\n\n    emit CollateralsMigratedFrom(_oldVaultController, _tokenAddresses);\n  }\n\n  /// @notice Creates a new vault and returns it's address\n  /// @return _vaultAddress The address of the newly created vault\n  function mintVault() public override whenNotPaused returns (address _vaultAddress) {\n    // increment  minted vaults\n    vaultsMinted += 1;\n    // mint the vault itself, deploying the contract\n    _vaultAddress = _createVault(vaultsMinted, _msgSender());\n    // add the vault to our system\n    vaultIdVaultAddress[vaultsMinted] = _vaultAddress;\n\n    //push new vault ID onto mapping\n    walletVaultIDs[_msgSender()].push(vaultsMinted);\n\n    // emit the event\n    emit NewVault(_vaultAddress, vaultsMinted, _msgSender());\n  }\n\n  /// @notice Pauses the functionality of the contract\n  function pause() external override onlyPauser {\n    _pause();\n  }\n\n  /// @notice Unpauses the functionality of the contract\n  function unpause() external override onlyPauser {\n    _unpause();\n  }\n\n  /// @notice Registers the USDA contract\n  /// @param _usdaAddress The address to register as USDA\n  function registerUSDA(address _usdaAddress) external override onlyOwner {\n    usda = IUSDA(_usdaAddress);\n    emit RegisterUSDA(_usdaAddress);\n  }\n\n  /// @notice Emited when the owner registers a curve master\n  /// @param _masterCurveAddress The address of the curve master\n  function registerCurveMaster(address _masterCurveAddress) external override onlyOwner {\n    curveMaster = CurveMaster(_masterCurveAddress);\n    emit RegisterCurveMaster(_masterCurveAddress);\n  }\n\n  /// @notice Updates the protocol fee\n  /// @param _newProtocolFee The new protocol fee in terms of 1e18=100%\n  function changeProtocolFee(uint192 _newProtocolFee) external override onlyOwner {\n    if (_newProtocolFee >= 1e18) revert VaultController_FeeTooLarge();\n    protocolFee = _newProtocolFee;\n    emit NewProtocolFee(_newProtocolFee);\n  }\n\n  /// @notice Register a new token to be used as collateral\n  /// @param _tokenAddress The address of the token to register\n  /// @param _ltv The ltv of the token, 1e18=100%\n  /// @param _oracleAddress The address of oracle to fetch the price of the token\n  /// @param _liquidationIncentive The liquidation penalty for the token, 1e18=100%\n  /// @param _cap The maximum amount to be deposited\n  function registerErc20(\n    address _tokenAddress,\n    uint256 _ltv,\n    address _oracleAddress,\n    uint256 _liquidationIncentive,\n    uint256 _cap,\n    uint256 _poolId\n  ) external override onlyOwner {\n    CollateralInfo storage _collateral = tokenAddressCollateralInfo[_tokenAddress];\n    if (_collateral.tokenId != 0) revert VaultController_TokenAlreadyRegistered();\n    uint8 _tokenDecimals = IERC20Metadata(_tokenAddress).decimals();\n    if (_tokenDecimals > MAX_DECIMALS) revert VaultController_TooManyDecimals();\n    if (_poolId != 0) {\n      (address _lpToken,,, address _crvRewards,,) = BOOSTER.poolInfo(_poolId);\n      if (_lpToken != _tokenAddress) revert VaultController_TokenAddressDoesNotMatchLpAddress();\n      _collateral.collateralType = CollateralType.CurveLPStakedOnConvex;\n      _collateral.crvRewardsContract = IBaseRewardPool(_crvRewards);\n      _collateral.poolId = _poolId;\n    } else {\n      _collateral.collateralType = CollateralType.Single;\n      _collateral.crvRewardsContract = IBaseRewardPool(address(0));\n      _collateral.poolId = 0;\n    }\n    // ltv must be compatible with liquidation incentive\n    if (_ltv >= (EXP_SCALE - _liquidationIncentive)) revert VaultController_LTVIncompatible();\n    // increment the amount of registered token\n    tokensRegistered = tokensRegistered + 1;\n    // set & give the token an id\n    _collateral.tokenId = tokensRegistered;\n    // set the token's oracle\n    _collateral.oracle = IOracleRelay(_oracleAddress);\n    // set the token's ltv\n    _collateral.ltv = _ltv;\n    // set the token's liquidation incentive\n    _collateral.liquidationIncentive = _liquidationIncentive;\n    // set the cap\n    _collateral.cap = _cap;\n    // save the decimals\n    _collateral.decimals = _tokenDecimals;\n    // finally, add the token to the array of enabled tokens\n    enabledTokens.push(_tokenAddress);\n\n    emit RegisteredErc20(_tokenAddress, _ltv, _oracleAddress, _liquidationIncentive, _cap);\n  }\n\n  /// @notice Updates an existing collateral with new collateral parameters\n  /// @param _tokenAddress The address of the token to modify\n  /// @param _ltv The new loan-to-value of the token, 1e18=100%\n  /// @param _oracleAddress The address of oracle to modify for the price of the token\n  /// @param _liquidationIncentive The new liquidation penalty for the token, 1e18=100%\n  /// @param _cap The maximum amount to be deposited\n  /// @param _poolId The convex pool id of a crv lp token\n  function updateRegisteredErc20(\n    address _tokenAddress,\n    uint256 _ltv,\n    address _oracleAddress,\n    uint256 _liquidationIncentive,\n    uint256 _cap,\n    uint256 _poolId\n  ) external override onlyOwner {\n    CollateralInfo storage _collateral = tokenAddressCollateralInfo[_tokenAddress];\n    if (_collateral.tokenId == 0) revert VaultController_TokenNotRegistered();\n    // _ltv must be compatible with liquidation incentive\n    if (_ltv >= (EXP_SCALE - _liquidationIncentive)) revert VaultController_LTVIncompatible();\n    if (_poolId != 0) {\n      (address _lpToken,,, address _crvRewards,,) = BOOSTER.poolInfo(_poolId);\n      if (_lpToken != _tokenAddress) revert VaultController_TokenAddressDoesNotMatchLpAddress();\n      _collateral.collateralType = CollateralType.CurveLPStakedOnConvex;\n      _collateral.crvRewardsContract = IBaseRewardPool(_crvRewards);\n      _collateral.poolId = _poolId;\n    }\n    // set the oracle of the token\n    _collateral.oracle = IOracleRelay(_oracleAddress);\n    // set the ltv of the token\n    _collateral.ltv = _ltv;\n    // set the liquidation incentive of the token\n    _collateral.liquidationIncentive = _liquidationIncentive;\n    // set the cap\n    _collateral.cap = _cap;\n\n    emit UpdateRegisteredErc20(_tokenAddress, _ltv, _oracleAddress, _liquidationIncentive, _cap, _poolId);\n  }\n\n  /// @notice Change the claimer contract, used to exchange a fee from curve lp rewards for AMPH tokens\n  /// @param _newClaimerContract The new claimer contract\n  function changeClaimerContract(IAMP"
    }
  ]
}