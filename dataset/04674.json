{
  "Title": "Remove unnecessary code",
  "Content": "* [convert function](https://github.com/ether-camp/virtual-accelerator/blob/6d4097a08669c2520e0d5bab317b60f1d13df44e/contracts/DSTContract.sol#L688-L696) could be replaced by simply casting strings to bytes32.\n* The two separate transfers in [the buy function of VirtualExchange.sol](https://github.com/ether-camp/virtual-accelerator/blob/6d4097a08669c2520e0d5bab317b60f1d13df44e/contracts/VirtualExchange.sol#L101-L105) could be replaced by a single call of `hackerGold.transferFrom(msg.sender, dstContract.getAddress())`Â . Same idea can be applied to [these lines](https://github.com/ether-camp/virtual-accelerator/blob/6d4097a08669c2520e0d5bab317b60f1d13df44e/contracts/DSTContract.sol#L250-L252) in DSTContract.sol.\n* selfAddress in [line 33](https://github.com/ether-camp/virtual-accelerator/blob/6d4097a08669c2520e0d5bab317b60f1d13df44e/contracts/DSTContract.sol#L33) of DSTContract is unnecessary. Use `this`.\n* [Some constant getter functions](https://github.com/ether-camp/virtual-accelerator/blob/6d4097a08669c2520e0d5bab317b60f1d13df44e/contracts/DSTContract.sol#L627-L686) can be removed if variables are made public.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/DSTContract.sol",
      "content": "import \"StandardToken.sol\";\nimport \"EventInfo.sol\";\nimport \"HackerGold.sol\";\n\npragma solidity ^0.4.2;\n\n/*\n * DSTContract - DST stands for decentralized startup team.\n *               the contract ensures funding for a decentralized\n *               team in 2 phases: \n *\n *                +. Funding by HKG during the hackathon event. \n *                +. Funding by Ether after the event is over. \n *\n *               After the funds been collected there is a governence\n *               mechanism managed by proposition to withdraw funds\n *               for development usage. \n *\n *               The DST ensures that backers of the projects keeps\n *               some influence on the project by ability to reject\n *               propositions they find as non effective. \n *\n *               In very radical occasions the backers may loose \n *               the trust in the team completelly, in that case \n *               there is an option to propose impeachment process\n *               completelly removing the execute and assigning new\n *               person to manage the funds. \n *\n */\ncontract DSTContract is StandardToken{\n\n\n    address   selfAddress;\n    address   executive; \n        \n    EventInfo eventInfo;\n    \n    // Indicateds where the DST is threaded\n    address virtualExchangeAddress;\n    \n    HackerGold hackerGold;\n        \n    mapping (address => uint256) votingRights;\n\n\n    // 1 - HKG => DST qty; tokens for 1 HKG\n    uint hkgPrice;\n    \n    // 1 - Ether => DST qty; tokens for 1 Ether\n    uint etherPrice;\n    \n    string public name = \"...\";                   \n    uint8  public decimals = 3;                 \n    string public symbol = \"...\";\n    \n    bool ableToIssueTokens = true; \n    \n    uint preferedQtySold;\n\n    uint collectedHKG; \n    uint collectedEther;    \n    \n    // Proposal of the funds spending\n    mapping (bytes32 => Proposal) proposals;\n\n    enum ProposalCurrency { HKG, ETHER }\n    ProposalCurrency enumDeclaration;\n                  \n       \n    struct Proposal{\n        \n        bytes32 id;\n        uint value;\n\n        string urlDetails;\n\n        uint votindEndTS;\n                \n        uint votesObjecting;\n        \n        address submitter;\n        bool redeemed;\n\n        ProposalCurrency proposalCurrency;\n        \n        mapping (address => bool) voted;\n    }\n    uint counterProposals;\n    uint timeOfLastProposal;\n    \n    Proposal[] listProposals;\n    \n\n    /**\n     * Impeachment process proposals\n     */    \n    struct ImpeachmentProposal{\n        \n        string urlDetails;\n        \n        address newExecutive;\n\n        uint votindEndTS;        \n        uint votesSupporting;\n        \n        mapping (address => bool) voted;        \n    }\n    \n    ImpeachmentProposal lastImpeachmentProposal;\n\n        \n    /*\n     * \n     *  Set date for early adapters\n     *\n     */ \n    function DSTContract(EventInfo eventInfoAddr, HackerGold hackerGoldAddr, string dstName, string dstSymbol){\n    \n      selfAddress = this; \n      executive   = msg.sender;  \n      name        = dstName;\n      symbol      = dstSymbol;\n\n      hackerGold = HackerGold(hackerGoldAddr);\n      eventInfo  = EventInfo(eventInfoAddr);\n    }\n    \n\n    function() payable {\n                \n        // If the hack event is not over return \n        // sent ether.\n        if (now < eventInfo.getEventEnd()) {\n            throw;\n        }\n        \n        // there is tokens left from hackathon \n        if (etherPrice == 0) throw;\n        \n        uint tokens = msg.value / (1 finney) * etherPrice;\n        \n        // check if demand of tokens is \n        // overflow the suply \n        if (balances[this] < tokens){\n            \n            tokens = balances[this];\n            uint retEther = msg.value - tokens / etherPrice * (1 finney);\n        \n            // return left ether \n            if (!msg.sender.send(retEther)) throw;\n        }\n        \n        \n        // do transfer\n        balances[msg.sender] += tokens;\n        balances[this] -= tokens;\n        \n        // count collected ether \n        collectedEther += msg.value; \n        \n        // todo: ... event for transfer\n        \n    }\n\n    \n    \n    /**\n     * \n     * qtyForOneHKG - \n     * \n     */    \n     function setHKGPrice(uint qtyForOneHKG) onlyExecutive {\n         \n         hkgPrice = qtyForOneHKG;\n         PriceHKGChange(qtyForOneHKG);\n     }\n     \n     \n    \n    /**\n     * \n     * issuePreferedTokens - prefered tokens issued on the hackathon event\n     *                       tain special rights\n     * \n     */\n    function issuePreferedTokens(uint qtyForOneHKG, \n                                 uint qtyToEmit) onlyExecutive \n                                                 onlyIfAbleToIssueTokens\n                                                 onlyBeforeEnd\n                                                 onlyAfterTradingStart {\n        \n        // the issuer of the token disabled futer issuance                                                        \n        if (!ableToIssueTokens) {\n            throw;\n        }                \n                \n        // no issuence is allowed before enlisted on the\n        // exchange \n        if (virtualExchangeAddress == 0x0) throw;\n            \n        totalSupply    += qtyToEmit;\n        balances[this] += qtyToEmit;\n        hkgPrice = qtyForOneHKG;\n        \n        \n        // now spender can use balance in \n        // ammount of value from owner balance\n        allowed[this][virtualExchangeAddress] = qtyToEmit;\n        \n        // rise event about the transaction\n        Approval(this, virtualExchangeAddress, qtyToEmit);\n        \n        \n        // ...todo... emit event for new tokens + price\n        // DstTokensIssued(indexed uint qtyForOneEther, indexed uint qtyToEmit, indexed uint totalSupply)\n    }\n\n    \n    \n    \n    /**\n     * \n     * buyForHackerGold - on the hack event this function is available \n     *                    the buyer for hacker gold will gain votes to \n     *                    influence future proposals on the DST\n     *    \n     *  @param hkgValue - qty of this DST tokens for 1 HKG     \n     * \n     */\n    function buyForHackerGold(uint hkgValue) onlyBeforeEnd \n                                             returns (bool success) {\n    \n\n      // Validate that the caller is official accelerator HKG Exchange\n      if (msg.sender != virtualExchangeAddress) throw;\n      \n    \n      // Transfer token \n      address sender = tx.origin;\n      \n      uint tokensQty = hkgValue * hkgPrice;\n\n\n      // Gain voting rights\n      votingRights[sender] +=tokensQty;\n      preferedQtySold += tokensQty;\n      collectedHKG += hkgValue;\n      \n                  \n      transferFrom(this, \n                   virtualExchangeAddress, tokensQty);\n      transfer(sender, tokensQty);        \n            \n      BuyForHKGTransaction(tokensQty, hkgPrice, balances[this], tokensQty);\n        \n      return true;\n    }\n        \n    \n    /**\n     * \n     * issueTokens - function will issue tokens after the \n     *               event\n     * \n     * @param qtyForOneEther - ...\n     * @param qtyToEmit      - ...     \n     *\n     */\n    function issueTokens(uint qtyForOneEther, \n                         uint qtyToEmit) onlyAfterEnd \n                                         onlyExecutive {\n         \n        // If the user already declared end \n        // of issuence\n        if (!ableToIssueTokens) {\n            throw;\n        }\n         \n         balances[this] += qtyToEmit;\n         etherPrice = qtyForOneEther;\n         totalSupply    += qtyToEmit;\n         \n         // todo: event for this \n    }\n     \n    \n    /**\n     * setEtherPrice - \n     *\n     */     \n    function setEtherPrice(uint qtyForOneEther) onlyAfterEnd\n                                                onlyExecutive {\n         etherPrice = qtyForOneEther; \n\n         // todo: event for this \n    }    \n    \n\n    /**\n     *  disableTokenIssuance - function will disable any \n     *                         option for future issuence\n     *\n     *\n     */\n    function disableTokenIssuance() onlyExecutive {\n        ableToIssueTokens = false;\n        \n        DisableTokenIssuance();\n    }\n\n    \n    /**\n     *  burnRemainToken -  \n     *                    \n     *\n     *\n     */\n    function burnRemainToken() onlyExecutive {\n    \n        balances[this] = 0;\n        \n        // todo: event for this\n    }\n    \n    /**\n     *  submitEtherProposal - \n     *\n     *   @param requestValue - \n     *   @param url - \n     */ \n    function submitEtherProposal(uint requestValue, string url) onlyAfterEnd \n                                                                onlyExecutive returns (bytes32 resultId, bool resultSucces) {       \n    \n        // ensure there is no more issuence available \n        if (ableToIssueTokens) throw;\n            \n        // ensure there is no more tokens available \n        if (balanceOf(this) > 0) throw;\n\n        // Possible to submit a proposal once 2 weeks \n        if (now < (timeOfLastProposal + 2 weeks)) throw;\n            \n        uint percent = collectedEther / 100;\n            \n        if (requestValue > 20 * percent) throw;\n\n        // if remained value is less than requested gain all.\n        if (requestValue > this.balance) \n            requestValue = this.balance;    \n            \n        // set id of the proposal\n        // submit proposal to the map\n        bytes32 id = sha3(msg.data, now);\n        uint timeEnds = now + 10 days; \n            \n        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.ETHER);\n        proposals[id] = newProposal;\n        listProposals.push(newProposal);\n            \n        timeOfLastProposal = now;                        \n        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\n        \n        return (id, true);\n    }\n    \n    \n     \n    /**\n     * \n     * submitHKGProposal - \n     * \n     *  @param requestValue - \n     *  @param url - \n     */\n    function submitHKGProposal(uint requestValue, string url) onlyAfterEnd\n                                                              onlyExecutive returns (bytes32 resultId, bool resultSucces){\n        \n\n        // If there is no 2 months over since the last event.\n        // There is no posible to get any HKG. After 2 months\n        // all the HKG is available. \n        if (now < (eventInfo.getEventEnd() + 8 weeks)) {\n            throw;\n        }\n\n        // Possible to submit a proposal once 2 weeks \n        if (now < (timeOfLastProposal + 2 weeks)) throw;\n\n        uint percent = preferedQtySold / 100;\n        \n        // validate the ammount is legit\n        // first 5 proposals should be less than 20% \n        if (counterProposals <= 5 && \n            requestValue     >  20 * percent) throw;\n                \n        // if remained value is less than requested \n        // gain all.\n        if (requestValue > getHKGOwned()) \n            requestValue = getHKGOwned();\n        \n        \n        // set id of the proposal\n        // submit proposal to the map\n        bytes32 id = sha3(msg.data, now);\n        uint timeEnds = now + 10 days; \n        \n        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.HKG);\n        proposals[id] = newProposal;\n        listProposals.push(newProposal);\n        \n        ++counterProposals;\n        timeOfLastProposal = now;                \n                \n        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\n        \n        return (id, true);        \n    }  \n    \n    \n    \n    /**\n     * objectProposal - \n     * \n     *  @param id \n     */\n     function objectProposal(bytes32 id){\n         \n        Proposal memory proposal = proposals[id];\n         \n        // check proposal exist \n        if (proposals[id].id == 0) throw;\n\n        // check already redeemed\n        if (proposals[id].redeemed) throw;\n         \n        // ensure objection time\n        if (now >= proposals[id].votindEndTS) throw;\n         \n        // ensure not voted  \n        if (proposals[id].voted[msg.sender]) throw;\n         \n         // submit votes\n         uint votes = votingRights[msg.sender];\n         proposals[id].votesObjecting += votes;\n         \n         // mark voted \n         proposals[id].voted[msg.sender] = true; \n         \n         uint idx = getIndexByProposalId(id);\n         listProposals[idx] = proposals[id];   \n\n         ObjectedVote(id, msg.sender, votes);         \n     }\n     \n     \n     function getIndexByProposalId(bytes32 id) returns (uint result){\n         \n         for (uint i = 0; i < listProposals.length; ++i){\n             if (id == listProposals[i].id) return i;\n         }\n     }\n    \n    \n   \n    /**\n     * redeemProposalFunds - \n     * \n     * @param id bytes32: the id of the proposal to redeem\n     */\n    function redeemProposalFunds(bytes32 id) onlyExecutive {\n\n        if (proposals[id].id == 0) throw;\n        if (proposals[id].submitter != msg.sender) throw;\n\n        // ensure objection time\n        if (now < proposals[id].votindEndTS) throw;\n                           \n    \n            // check already redeemed\n        if (proposals[id].redeemed) throw;\n\n        // check votes objection => 55% of total votes\n        uint objectionThreshold = preferedQtySold / 100 * 55;\n        if (proposals[id].votesObjecting  > objectionThreshold) throw;\n    \n    \n        if (proposals[id].proposalCurrency == ProposalCurrency.HKG){\n            \n            // send hacker gold \n            hackerGold.transfer(proposals[id].submitter, proposals[id].value);      \n                        \n        } else {\n                        \n           // send ether              \n           bool success = proposals[id].submitter.send(proposals[id].value); \n\n           // rise event\n           EtherRedeemAccepted(proposals[id].submitter, proposals[id].value);                              \n        }\n        \n        // execute the proposal \n        proposals[id].redeemed = true; \n    }\n    \n    \n    /**\n     *  getAllTheFunds\n     * \n     * \n     */             \n    function getAllTheFunds() onlyExecutive {\n        \n        // If there is a deadlock in voting participates\n        // the funds can be redeemed completelly in 6 months\n        if (now < (eventInfo.getEventEnd() + 24 weeks)) {\n            throw;\n        }  \n        \n        // all the Ether\n        bool success = msg.sender.send(this.balance);        \n        \n        // all the HKG\n        hackerGold.transfer(msg.sender, getHKGOwned());              \n    }\n    \n    \n    /**\n     * submitImpeachmentProposal - \n     * \n     *  @param urlDetails  -\n     *  @param newExecutive - \n     * \n     */             \n     function submitImpeachmentProposal(string urlDetails, address newExecutive){\n         \n        // to offer impeachment you should have \n        // voting rights\n        if (votingRights[msg.sender] == 0) throw;\n         \n        // the submission of the first impeachment \n        // proposal is possible only after 3 months\n        // since the hackathon is over\n        if (now < (eventInfo.getEventEnd() + 12 weeks)) throw;\n        \n                \n        // check there is 1 months over since last one\n        if (lastImpeachmentProposal.votindEndTS != 0 && \n            lastImpeachmentProposal.votindEndTS +  2 weeks > now) throw;\n\n\n        // submit impeachment proposal\n        // add the votes of the submitter \n        // to the proposal right away\n        lastImpeachmentProposal = ImpeachmentProposal(urlDetails, newExecutive, now + 2 weeks, votingRights[msg.sender]);\n        lastImpeachmentProposal.voted[msg.sender] = true;\n         \n        // rise event\n        ImpeachmentProposed(msg.sender, urlDetails, now + 2 weeks, newExecutive);\n     }\n    \n    \n    /**\n     * supportImpeachment - vote for impeachment proposal \n     *                      that is currently in progress\n     *\n     */\n    function supportImpeachment(){\n\n        // ensure that support is for exist proposal \n        if (lastImpeachmentProposal.newExecutive == 0x0) throw;\n    \n        // to offer impeachment you should have \n        // voting rights\n        if (votingRights[msg.sender] == 0) throw;\n        \n        // check if not voted already \n        if (lastImpeachmentProposal.voted[msg.sender]) throw;\n        \n        // check if not finished the 2 weeks of voting \n        if (lastImpeachmentProposal.votindEndTS + 2 weeks <= now) throw;\n                \n        // support the impeachment\n        lastImpeachmentProposal.voted[msg.sender] = true;\n        lastImpeachmentProposal.votesSupporting += votingRights[msg.sender];\n\n        // rise impeachment suppporting event\n        ImpeachmentSupport(msg.sender, votingRights[msg.sender]);\n        \n        // if the vote is over 70% execute the switch \n        uint percent = preferedQtySold / 100; \n        \n        if (lastImpeachmentProposal.votesSupporting >= 70 * percent){\n            executive = lastImpeachmentProposal.newExecutive;\n            \n            // impeachment event\n            ImpeachmentAccepted(executive);\n        }\n        \n    } \n    \n      \n    \n    // **************************** //\n    // *     Constant Getters     * //\n    // **************************** //    \n    \n    function votingRightsOf(address _owner) constant returns (uint256 result) {\n        result = votingRights[_owner];\n    }\n    \n    function getPreferedQtySold() constant returns (uint result){\n        return preferedQtySold;\n    }\n    \n    function setVirtualExchange(address virtualExchangeAddr){\n        virtualExchangeAddress = virtualExchangeAddr;\n    }\n\n    function getHKGOwned() constant returns (uint result){\n        return hackerGold.balanceOf(this);\n    }\n    \n    function getEtherValue() constant returns (uint result){\n        return this.balance;\n    }\n    \n    function getExecutive() constant returns (address result){\n        return executive;\n    }\n    \n    function getHKGPrice() constant returns (uint result){\n        return hkgPrice;\n    }\n\n    function getEtherPrice() constant returns (uint result){\n        return etherPrice;\n    }\n    \n    function getDSTName() constant returns(string result){\n        return name;\n    }    \n    \n    function getDSTNameBytes() constant returns(bytes32 result){\n        return convert(name);\n    }    \n\n    function getDSTSymbol() constant returns(string result){\n        return symbol;\n    }    \n    \n    function getDSTSymbolBytes() constant returns(bytes32 result){\n        return convert(symbol);\n    }    \n\n    function getAddress() constant returns (address result) {\n        return selfAddress;\n    }\n    \n    function getTotalSupply() constant returns (uint result) {\n        return totalSupply;\n    } \n        \n    function getCollectedEther() constant returns (uint results) {        \n        return collectedEther;\n    }\n    \n    function getCounterProposals() constant returns (uint result){\n        return counterProposals;\n    }\n        \n    function getProposalIdByIndex(uint i) constant returns (bytes32 result){\n        return listProposals[i].id;\n    }    \n\n    function getProposalObjectionByIndex(uint i) constant returns (uint result){\n        return listProposals[i].votesObjecting;\n    }    \n    \n    function getCurrentImpeachmentUrlDetails() constant returns (string result){\n        return lastImpeachmentProposal.urlDetails;\n    }\n    \n    \n    function getCurrentImpeachmentVotesSupporting() constant returns (uint result){\n        return lastImpeachmentProposal.votesSupporting;\n    }\n    \n    function convert(string key) returns (bytes32 ret) {\n            if (bytes(key).length > 32) {\n                throw;\n            }      \n\n            assembly {\n                ret := mload(add(key, 32))\n            }\n    }    \n    \n    \n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //    \n \n    modifier onlyBeforeEnd() { if (now  >=  eventInfo.getEventEnd()) throw; _; }\n    modifier onlyAfterEnd()  { if (now  <   eventInfo.getEventEnd()) throw; _; }\n    \n    modifier onlyAfterTradingStart()  { if (now  < eventInfo.getTradingStart()) throw; _; }\n    \n    modifier onlyExecutive()     { if (msg.sender != executive) throw; _; }\n                                       \n    modifier onlyIfAbleToIssueTokens()  { if (!ableToIssueTokens) throw; _; } \n    \n\n    // ****************** //\n    // *     Events     * //\n    // ****************** //        \n\n    \n    event PriceHKGChange(uint qtyForOneHKG);\n    event BuyForHKGTransaction(uint tokensAmount, uint qtyForOneHKG, uint tokensAvailable, uint tokensSold);\n    \n    event ProposalRequestSubmitted(bytes32 id, uint value, uint timeEnds, string url, address sender);\n    \n    event EtherRedeemAccepted(address sender, uint value);\n    \n    event ObjectedVote(bytes32 id, address voter, uint votes);\n    \n    event ImpeachmentProposed(address submitter, string urlDetails, uint votindEndTS, address newExecutive);\n    event ImpeachmentSupport(address supportter, uint votes);\n    \n    event ImpeachmentAccepted(address newExecutive);\n\n    event DisableTokenIssuance();\n    \n}"
    },
    {
      "filename": "contracts/VirtualExchange.sol",
      "content": "import \"HackerGold.sol\";\nimport \"EventInfo.sol\";\nimport \"DSTContract.sol\";\n\npragma solidity ^0.4.2;\n\n/**\n *  VirtualExchange -  The exchange is a trading system used\n *                     on hack.ether.camp hackathon event to \n *                     support trading a DST tokens for HKG. \n *                    \n */\ncontract VirtualExchange{\n\n    address owner;  \n    EventInfo eventInfo;\n \n    mapping (bytes32 => address) dstListed;\n    \n    HackerGold hackerGold;\n    \n    function VirtualExchange(address hackerGoldAddr, address eventInfoAddr){\n    \n        owner = msg.sender;\n        hackerGold = HackerGold(hackerGoldAddr);\n        eventInfo  = EventInfo(eventInfoAddr);\n    }\n    \n    \n    /**\n     * enlist - enlisting one decentralized startup team to \n     *          the hack event virtual exchange, making the \n     *          DST initated tokens available for aquasition.\n     * \n     *  @param dstAddress - address of the DSTContract \n     * \n     */ \n    function enlist(address dstAddress) onlyBeforeEnd {\n\n        DSTContract dstContract = DSTContract(dstAddress);\n\n        /* Don't enlist 2 with the same name */\n        if (isExistByBytes(dstContract.getDSTSymbolBytes())) throw;\n\n        // Only owner of the DST can deploy the DST \n        if (dstContract.getExecutive() != msg.sender) throw;\n\n        // All good enlist the company\n        bytes32 nameBytes = dstContract.getDSTSymbolBytes();\n        dstListed[nameBytes] = dstAddress;\n        \n        // Indicate to DST which Virtual Exchange is enlisted\n        dstContract.setVirtualExchange(address(this));\n        \n        // rise Enlisted event\n        Enlisted(dstAddress);\n    }\n    \n   \n\n    /**\n     *\n     * buy - on the hackathon timeframe that is the function \n     *       that will be the way to buy speciphic tokens for \n     *       startup.\n     * \n     * @param companyName - the company that is enlisted on the exchange \n     *                      and the tokens are available\n     * \n     * @param hkg - the ammount of hkg to spend for aquastion \n     *\n     */\n    function buy(string companyName, uint hkg) onlyBeforeEnd\n                                               returns (bool success) {\n\n    \n        bytes32 companyNameBytes = convert(companyName);\n\n        // check DST exist \n        if (!isExistByString(companyName)) throw;\n\n        // validate availability  \n        DSTContract dstContract = DSTContract(dstListed[companyNameBytes]);\n        uint tokensQty = hkg * dstContract.getHKGPrice();\n\n        address veAddress = address(this);        \n        \n        // ensure that there is HKG balance\n        uint valueHKGOwned = hackerGold.balanceOf(msg.sender);        \n        if (valueHKGOwned < hkg) throw;        \n        \n        // ensure that there is HKG token allowed to be spend\n        uint valueAvailbeOnExchange = hackerGold.allowance(msg.sender, veAddress);\n        if (valueAvailbeOnExchange < hkg) throw;\n\n        // ensure there is DST tokens for sale\n        uint dstTokens = dstContract.allowance(dstContract, veAddress);\n        if (dstTokens < hkg * dstContract.getHKGPrice()) throw;    \n                        \n        // Transfer HKG to Virtual Exchange account  \n        hackerGold.transferFrom(msg.sender, veAddress, hkg);\n\n        // Transfer to dstCotract ownership\n        hackerGold.transfer(dstContract.getAddress(), hkg);         \n        \n        // Call DST to transfer tokens \n        dstContract.buyForHackerGold(hkg);            \n    }\n    \n    \n    function convert(string key) returns (bytes32 ret) {\n            if (bytes(key).length > 32) {\n                throw;\n            }      \n\n            assembly {\n                ret := mload(add(key, 32))\n            }\n    }    \n    \n\n    // **************************** //\n    // *     Constant Getters     * //\n    // **************************** //        \n    \n\n    function isExistByBytes(bytes32 companyNameBytes) constant returns (bool result) {\n            \n        if (dstListed[companyNameBytes] == 0x0) \n            return false;\n        else \n            return true;                  \n    }\n\n    function isExistByString(string companyName) constant returns (bool result) {\n        \n        bytes32 companyNameBytes = convert(companyName);\n    \n        if (dstListed[companyNameBytes] == 0x0) \n            return false;\n        else \n            return true;                  \n    }\n    \n    function getEventStart() constant eventInfoSet returns (uint result){\n        return eventInfo.getEventStart();\n    }\n\n    function getEventEnd() constant eventInfoSet returns (uint result){\n        return eventInfo.getEventEnd();\n    }\n    \n    function getNow() constant returns (uint result){\n        return now;\n    }\n    \n\n\n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //        \n    \n\n    modifier onlyOwner()    { if (msg.sender != owner)        throw; _; }\n    modifier eventInfoSet() { if (eventInfo  == address(0))   throw; _; }\n    \n    modifier onlyBeforeEnd() { if (now  >= eventInfo.getEventEnd()) throw; _; }\n    modifier onlyAfterEnd()  { if (now  <  eventInfo.getEventEnd()) throw; _; }\n    \n\n    // ****************** //\n    // *     Events     * //\n    // ****************** //        \n    \n    event Enlisted(address indexed dstContract);\n    \n    \n}"
    },
    {
      "filename": "contracts/DSTContract.sol",
      "content": "import \"StandardToken.sol\";\nimport \"EventInfo.sol\";\nimport \"HackerGold.sol\";\n\npragma solidity ^0.4.2;\n\n/*\n * DSTContract - DST stands for decentralized startup team.\n *               the contract ensures funding for a decentralized\n *               team in 2 phases: \n *\n *                +. Funding by HKG during the hackathon event. \n *                +. Funding by Ether after the event is over. \n *\n *               After the funds been collected there is a governence\n *               mechanism managed by proposition to withdraw funds\n *               for development usage. \n *\n *               The DST ensures that backers of the projects keeps\n *               some influence on the project by ability to reject\n *               propositions they find as non effective. \n *\n *               In very radical occasions the backers may loose \n *               the trust in the team completelly, in that case \n *               there is an option to propose impeachment process\n *               completelly removing the execute and assigning new\n *               person to manage the funds. \n *\n */\ncontract DSTContract is StandardToken{\n\n\n    address   selfAddress;\n    address   executive; \n        \n    EventInfo eventInfo;\n    \n    // Indicateds where the DST is threaded\n    address virtualExchangeAddress;\n    \n    HackerGold hackerGold;\n        \n    mapping (address => uint256) votingRights;\n\n\n    // 1 - HKG => DST qty; tokens for 1 HKG\n    uint hkgPrice;\n    \n    // 1 - Ether => DST qty; tokens for 1 Ether\n    uint etherPrice;\n    \n    string public name = \"...\";                   \n    uint8  public decimals = 3;                 \n    string public symbol = \"...\";\n    \n    bool ableToIssueTokens = true; \n    \n    uint preferedQtySold;\n\n    uint collectedHKG; \n    uint collectedEther;    \n    \n    // Proposal of the funds spending\n    mapping (bytes32 => Proposal) proposals;\n\n    enum ProposalCurrency { HKG, ETHER }\n    ProposalCurrency enumDeclaration;\n                  \n       \n    struct Proposal{\n        \n        bytes32 id;\n        uint value;\n\n        string urlDetails;\n\n        uint votindEndTS;\n                \n        uint votesObjecting;\n        \n        address submitter;\n        bool redeemed;\n\n        ProposalCurrency proposalCurrency;\n        \n        mapping (address => bool) voted;\n    }\n    uint counterProposals;\n    uint timeOfLastProposal;\n    \n    Proposal[] listProposals;\n    \n\n    /**\n     * Impeachment process proposals\n     */    \n    struct ImpeachmentProposal{\n        \n        string urlDetails;\n        \n        address newExecutive;\n\n        uint votindEndTS;        \n        uint votesSupporting;\n        \n        mapping (address => bool) voted;        \n    }\n    \n    ImpeachmentProposal lastImpeachmentProposal;\n\n        \n    /*\n     * \n     *  Set date for early adapters\n     *\n     */ \n    function DSTContract(EventInfo eventInfoAddr, HackerGold hackerGoldAddr, string dstName, string dstSymbol){\n    \n      selfAddress = this; \n      executive   = msg.sender;  \n      name        = dstName;\n      symbol      = dstSymbol;\n\n      hackerGold = HackerGold(hackerGoldAddr);\n      eventInfo  = EventInfo(eventInfoAddr);\n    }\n    \n\n    function() payable {\n                \n        // If the hack event is not over return \n        // sent ether.\n        if (now < eventInfo.getEventEnd()) {\n            throw;\n        }\n        \n        // there is tokens left from hackathon \n        if (etherPrice == 0) throw;\n        \n        uint tokens = msg.value / (1 finney) * etherPrice;\n        \n        // check if demand of tokens is \n        // overflow the suply \n        if (balances[this] < tokens){\n            \n            tokens = balances[this];\n            uint retEther = msg.value - tokens / etherPrice * (1 finney);\n        \n            // return left ether \n            if (!msg.sender.send(retEther)) throw;\n        }\n        \n        \n        // do transfer\n        balances[msg.sender] += tokens;\n        balances[this] -= tokens;\n        \n        // count collected ether \n        collectedEther += msg.value; \n        \n        // todo: ... event for transfer\n        \n    }\n\n    \n    \n    /**\n     * \n     * qtyForOneHKG - \n     * \n     */    \n     function setHKGPrice(uint qtyForOneHKG) onlyExecutive {\n         \n         hkgPrice = qtyForOneHKG;\n         PriceHKGChange(qtyForOneHKG);\n     }\n     \n     \n    \n    /**\n     * \n     * issuePreferedTokens - prefered tokens issued on the hackathon event\n     *                       tain special rights\n     * \n     */\n    function issuePreferedTokens(uint qtyForOneHKG, \n                                 uint qtyToEmit) onlyExecutive \n                                                 onlyIfAbleToIssueTokens\n                                                 onlyBeforeEnd\n                                                 onlyAfterTradingStart {\n        \n        // the issuer of the token disabled futer issuance                                                        \n        if (!ableToIssueTokens) {\n            throw;\n        }                \n                \n        // no issuence is allowed before enlisted on the\n        // exchange \n        if (virtualExchangeAddress == 0x0) throw;\n            \n        totalSupply    += qtyToEmit;\n        balances[this] += qtyToEmit;\n        hkgPrice = qtyForOneHKG;\n        \n        \n        // now spender can use balance in \n        // ammount of value from owner balance\n        allowed[this][virtualExchangeAddress] = qtyToEmit;\n        \n        // rise event about the transaction\n        Approval(this, virtualExchangeAddress, qtyToEmit);\n        \n        \n        // ...todo... emit event for new tokens + price\n        // DstTokensIssued(indexed uint qtyForOneEther, indexed uint qtyToEmit, indexed uint totalSupply)\n    }\n\n    \n    \n    \n    /**\n     * \n     * buyForHackerGold - on the hack event this function is available \n     *                    the buyer for hacker gold will gain votes to \n     *                    influence future proposals on the DST\n     *    \n     *  @param hkgValue - qty of this DST tokens for 1 HKG     \n     * \n     */\n    functio"
    }
  ]
}