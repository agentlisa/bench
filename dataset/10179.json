{
  "Title": "[M-11] Claim liquidation escrow",
  "Content": "_Submitted by gpersoon_\n\nA liquidator can always claim the liquidation escrow in the following way:\n- create a second account\n- setup a complimentary trade in that second account, which will result in a large slippage when executed\n- call `executeTrade` (which everyone can call), to execute a trade between his own two accounts with a large slippage\n- the slippage doesn't hurt because the liquidator owns both accounts\n- call `claimReceipt` with the receiptId of the executed order, within the required period (e.g. 15 minutes)\n\n[L67](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L67)\n```solidity\nfunction executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) external override {\n```\n[L394](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L394)\n```solidity\nfunction claimReceipt( uint256 receiptId, Perpetuals.Order[] memory orders, address traderContract) external override {\n```\n\nRecommend to perhaps limit who can call `executeTrade`.\n\n**[raymogg (Tracer) acknowledged and confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/2#issuecomment-873774429):**\n > Valid issue which would allow someone to get reimbursed for slippage against themselves.\n>\n> The Trader contract will have whitelisted relayers added to prevent issues like this (similar to #119)\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-06-tracer",
  "Code": [
    {
      "filename": "src/contracts/Trader.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/Types.sol\";\nimport \"./Interfaces/ITrader.sol\";\nimport \"./lib/LibPerpetuals.sol\";\nimport \"./lib/LibBalances.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/**\n * The Trader contract is used to validate and execute off chain signed and matched orders\n */\ncontract Trader is ITrader {\n    // EIP712 Constants\n    // https://eips.ethereum.org/EIPS/eip-712\n    string private constant EIP712_DOMAIN_NAME = \"Tracer Protocol\";\n    string private constant EIP712_DOMAIN_VERSION = \"1.0\";\n    bytes32 private constant EIP712_DOMAIN_SEPERATOR =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // EIP712 Types\n    bytes32 private constant ORDER_TYPE =\n        keccak256(\n            \"Order(address maker,address market,uint256 price,uint256 amount,uint256 side,uint256 expires,uint256 created)\"\n        );\n\n    uint256 public constant override chainId = 1337; // Changes per chain\n    bytes32 public immutable override EIP712_DOMAIN;\n\n    // order hash to memory\n    mapping(bytes32 => Perpetuals.Order) public orders;\n    // maps an order hash to its signed order if seen before\n    mapping(bytes32 => Types.SignedLimitOrder) public orderToSig;\n    // order hash to amount filled\n    mapping(bytes32 => uint256) public override filled;\n    // order hash to average execution price thus far\n    mapping(bytes32 => uint256) public override averageExecutionPrice;\n\n    constructor() {\n        // Construct the EIP712 Domain\n        EIP712_DOMAIN = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_SEPERATOR,\n                keccak256(bytes(EIP712_DOMAIN_NAME)),\n                keccak256(bytes(EIP712_DOMAIN_VERSION)),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function filledAmount(Perpetuals.Order memory order) external view override returns (uint256) {\n        return filled[Perpetuals.orderId(order)];\n    }\n\n    function getAverageExecutionPrice(Perpetuals.Order memory order) external view override returns (uint256) {\n        return averageExecutionPrice[Perpetuals.orderId(order)];\n    }\n\n    /**\n     * @notice Batch executes maker and taker orders against a given market. Currently matching works\n     *         by matching orders 1 to 1\n     * @param makers An array of signed make orders\n     * @param takers An array of signed take orders\n     */\n    function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers)\n        external\n        override\n    {\n        require(makers.length == takers.length, \"TDR: Lengths differ\");\n\n        // safe as we've already bounds checked the array lengths\n        uint256 n = makers.length;\n\n        require(n > 0, \"TDR: Received empty arrays\");\n\n        for (uint256 i = 0; i < n; i++) {\n            // verify each order individually and together\n            if (\n                !isValidSignature(makers[i].order.maker, makers[i]) ||\n                !isValidSignature(takers[i].order.maker, takers[i]) ||\n                !isValidPair(takers[i], makers[i])\n            ) {\n                // skip if either order is invalid\n                continue;\n            }\n\n            // retrieve orders\n            // if the order does not exist, it is created here\n            Perpetuals.Order memory makeOrder = grabOrder(makers, i);\n            Perpetuals.Order memory takeOrder = grabOrder(takers, i);\n\n            bytes32 makerOrderId = Perpetuals.orderId(makeOrder);\n            bytes32 takerOrderId = Perpetuals.orderId(takeOrder);\n\n            uint256 makeOrderFilled = filled[makerOrderId];\n            uint256 takeOrderFilled = filled[takerOrderId];\n\n            uint256 fillAmount = Balances.fillAmount(makeOrder, makeOrderFilled, takeOrder, takeOrderFilled);\n\n            uint256 executionPrice = Perpetuals.getExecutionPrice(makeOrder, takeOrder);\n            uint256 newMakeAverage = Perpetuals.calculateAverageExecutionPrice(\n                makeOrderFilled,\n                averageExecutionPrice[makerOrderId],\n                fillAmount,\n                executionPrice\n            );\n            uint256 newTakeAverage = Perpetuals.calculateAverageExecutionPrice(\n                takeOrderFilled,\n                averageExecutionPrice[takerOrderId],\n                fillAmount,\n                executionPrice\n            );\n\n            // match orders\n            // referencing makeOrder.market is safe due to above require\n            // make low level call to catch revert\n            // todo this could be succeptible to re-entrancy as\n            // market is never verified\n            (bool success, ) = makeOrder.market.call(\n                abi.encodePacked(\n                    ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,\n                    abi.encode(makeOrder, takeOrder, fillAmount)\n                )\n            );\n\n            // ignore orders that cannot be executed\n            if (!success) continue;\n\n            // update order state\n            filled[makerOrderId] = makeOrderFilled + fillAmount;\n            filled[takerOrderId] = takeOrderFilled + fillAmount;\n            averageExecutionPrice[makerOrderId] = newMakeAverage;\n            averageExecutionPrice[takerOrderId] = newTakeAverage;\n        }\n    }\n\n    /**\n     * @notice Retrieves and validates an order from an order array\n     * @param signedOrders an array of signed orders\n     * @param index the index into the array where the desired order is\n     * @return the specified order\n     * @dev Should only be called with a verified signedOrder and with index\n     *      < signedOrders.length\n     */\n    function grabOrder(Types.SignedLimitOrder[] memory signedOrders, uint256 index)\n        internal\n        returns (Perpetuals.Order memory)\n    {\n        Perpetuals.Order memory rawOrder = signedOrders[index].order;\n\n        bytes32 orderHash = Perpetuals.orderId(rawOrder);\n        // check if order exists on chain, if not, create it\n        if (orders[orderHash].maker == address(0)) {\n            // store this order to keep track of state\n            orders[orderHash] = rawOrder;\n            // map the order hash to the signed order\n            orderToSig[orderHash] = signedOrders[index];\n        }\n\n        return orders[orderHash];\n    }\n\n    /**\n     * @notice hashes a limit order type in order to verify signatures, per EIP712\n     * @param order the limit order being hashed\n     * @return an EIP712 compliant hash (with headers) of the limit order\n     */\n    function hashOrder(Perpetuals.Order memory order) public view override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    EIP712_DOMAIN,\n                    keccak256(\n                        abi.encode(\n                            ORDER_TYPE,\n                            order.maker,\n                            order.market,\n                            order.price,\n                            order.amount,\n                            uint256(order.side),\n                            order.expires,\n                            order.created\n                        )\n                    )\n                )\n            );\n    }\n\n    /**\n     * @notice Gets the EIP712 domain hash of the contract\n     */\n    function getDomain() external view override returns (bytes32) {\n        return EIP712_DOMAIN;\n    }\n\n    /**\n     * @notice Verifies a given limit order has been signed by a given signer and has a correct nonce\n     * @param signer The signer who is being verified against the order\n     * @param signedOrder The signed order to verify the signature of\n     * @return if an order has a valid signature and a valid nonce\n     * @dev does not throw if the signature is invalid.\n     */\n    function isValidSignature(address signer, Types.SignedLimitOrder memory signedOrder) internal view returns (bool) {\n        return verifySignature(signer, signedOrder);\n    }\n\n    /**\n     * @notice Validates a given pair of signed orders against each other\n     * @param signedOrder1 the first signed order\n     * @param signedOrder2 the second signed order\n     * @return if signedOrder1 is compatible with signedOrder2\n     * @dev does not throw if pairs are invalid\n     */\n    function isValidPair(Types.SignedLimitOrder memory signedOrder1, Types.SignedLimitOrder memory signedOrder2)\n        internal\n        pure\n        returns (bool)\n    {\n        return (signedOrder1.order.market == signedOrder2.order.market);\n    }\n\n    /**\n     * @notice Verifies the signature component of a signed order\n     * @param signer The signer who is being verified against the order\n     * @param signedOrder The unsigned order to verify the signature of\n     * @return true is signer has signed the order, else false\n     */\n    function verifySignature(address signer, Types.SignedLimitOrder memory signedOrder)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            signer == ECDSA.recover(hashOrder(signedOrder.order), signedOrder.sigV, signedOrder.sigR, signedOrder.sigS);\n    }\n\n    /**\n     * @return An order that has been previously created in contract, given a user-supplied order\n     * @dev Useful for checking to see if a supplied order has actually been created\n     */\n    function getOrder(Perpetuals.Order calldata order) external view override returns (Perpetuals.Order memory) {\n        bytes32 orderId = Perpetuals.orderId(order);\n        return orders[orderId];\n    }\n}"
    },
    {
      "filename": "src/contracts/Liquidation.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./lib/LibMath.sol\";\nimport \"./lib/LibLiquidation.sol\";\nimport \"./lib/LibBalances.sol\";\nimport \"./lib/LibPerpetuals.sol\";\nimport \"./Interfaces/ILiquidation.sol\";\nimport \"./Interfaces/ITrader.sol\";\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/ITracerPerpetualsFactory.sol\";\nimport \"./Interfaces/IOracle.sol\";\nimport \"./Interfaces/IPricing.sol\";\nimport \"./Interfaces/IInsurance.sol\";\n\n/**\n * Each call enforces that the contract calling the account is only updating the balance\n * of the account for that contract.\n */\ncontract Liquidation is ILiquidation, Ownable {\n    using LibMath for uint256;\n    using LibMath for int256;\n\n    uint256 public override currentLiquidationId;\n    uint256 public override maxSlippage;\n    uint256 public override releaseTime = 15 minutes;\n    uint256 public override minimumLeftoverGasCostMultiplier = 10;\n    IPricing public pricing;\n    ITracerPerpetualSwaps public tracer;\n    address public insuranceContract;\n    address public fastGasOracle;\n\n    // Receipt ID => LiquidationReceipt\n    mapping(uint256 => LibLiquidation.LiquidationReceipt) public liquidationReceipts;\n\n    event ClaimedReceipts(address indexed liquidator, address indexed market, uint256 indexed receiptId);\n    event ClaimedEscrow(address indexed liquidatee, address indexed market, uint256 indexed id);\n    event Liquidate(\n        address indexed account,\n        address indexed liquidator,\n        int256 liquidationAmount,\n        Perpetuals.Side side,\n        address indexed market,\n        uint256 liquidationId\n    );\n    event InvalidClaimOrder(uint256 indexed receiptId);\n\n    /**\n     * @param _pricing Pricing.sol contract address\n     * @param _tracer TracerPerpetualSwaps.sol contract address\n     * @param _insuranceContract Insurance.sol contract address\n     * @param _fastGasOracle Address of the contract that implements the IOracle.sol interface\n     * @param _maxSlippage The maximum slippage percentage that is allowed on selling a\n                           liquidated position. Given as a decimal WAD. e.g 5% = 0.05*10^18\n     */\n    constructor(\n        address _pricing,\n        address _tracer,\n        address _insuranceContract,\n        address _fastGasOracle,\n        uint256 _maxSlippage\n    ) Ownable() {\n        pricing = IPricing(_pricing);\n        tracer = ITracerPerpetualSwaps(_tracer);\n        insuranceContract = _insuranceContract;\n        fastGasOracle = _fastGasOracle;\n        maxSlippage = _maxSlippage;\n    }\n\n    /**\n     * @notice Creates a liquidation receipt for a given trader\n     * @param liquidator the account executing the liquidation\n     * @param liquidatee the account being liquidated\n     * @param price the price at which this liquidation event occurred\n     * @param escrowedAmount the amount of funds required to be locked into escrow\n     *                       by the liquidator\n     * @param amountLiquidated the amount of positions that were liquidated\n     * @param liquidationSide the side of the positions being liquidated. true for long\n     *                        false for short.\n     */\n    function submitLiquidation(\n        address liquidator,\n        address liquidatee,\n        uint256 price,\n        uint256 escrowedAmount,\n        int256 amountLiquidated,\n        Perpetuals.Side liquidationSide\n    ) internal {\n        liquidationReceipts[currentLiquidationId] = LibLiquidation.LiquidationReceipt({\n            tracer: address(tracer),\n            liquidator: liquidator,\n            liquidatee: liquidatee,\n            price: price,\n            time: block.timestamp,\n            escrowedAmount: escrowedAmount,\n            releaseTime: block.timestamp + releaseTime,\n            amountLiquidated: amountLiquidated,\n            escrowClaimed: false,\n            liquidationSide: liquidationSide,\n            liquidatorRefundClaimed: false\n        });\n        currentLiquidationId += 1;\n    }\n\n    /**\n     * @notice Allows a trader to claim escrowed funds after the escrow period has expired\n     * @param receiptId The ID number of the insurance receipt from which funds are being claimed from\n     */\n    function claimEscrow(uint256 receiptId) public override {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        require(!receipt.escrowClaimed, \"LIQ: Escrow claimed\");\n        require(block.timestamp > receipt.releaseTime, \"LIQ: Not released\");\n\n        // Mark as claimed\n        liquidationReceipts[receiptId].escrowClaimed = true;\n\n        // Update balance\n        int256 amountToReturn = receipt.escrowedAmount.toInt256();\n        emit ClaimedEscrow(receipt.liquidatee, receipt.tracer, receiptId);\n        tracer.updateAccountsOnClaim(address(0), 0, receipt.liquidatee, amountToReturn, 0);\n    }\n\n    /**\n     * @notice Returns liquidation receipt data for a given receipt id.\n     * @param id the receipt id to get data for\n     */\n    function getLiquidationReceipt(uint256 id)\n        external\n        view\n        override\n        returns (LibLiquidation.LiquidationReceipt memory)\n    {\n        return liquidationReceipts[id];\n    }\n\n    /**\n     * @notice Verify that a Liquidation is valid; submits liquidation receipt if it is\n     * @dev Reverts if the liquidation is invalid\n     * @param base Amount of base in the account to be liquidated (denominated in base tokens)\n     * @param price Fair price of the asset (denominated in quote/base)\n     * @param quote Amount of quote in the account to be liquidated (denominated in quote tokens)\n     * @param amount Amount of tokens to be liquidated\n     * @param gasPrice Current gas price, denominated in gwei\n     * @param account Account to be liquidated\n     * @return Amount to be escrowed for the liquidation\n     */\n    function verifyAndSubmitLiquidation(\n        int256 base,\n        uint256 price,\n        int256 quote,\n        int256 amount,\n        uint256 gasPrice,\n        address account\n    ) internal returns (uint256) {\n        require(amount > 0, \"LIQ: Liquidation amount <= 0\");\n        require(tx.gasprice <= IOracle(fastGasOracle).latestAnswer(), \"LIQ: GasPrice > FGasPrice\");\n\n        Balances.Position memory pos = Balances.Position(quote, base);\n        uint256 gasCost = gasPrice * tracer.LIQUIDATION_GAS_COST();\n\n        int256 currentMargin = Balances.margin(pos, price);\n        require(\n            currentMargin <= 0 ||\n                uint256(currentMargin) < Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),\n            \"LIQ: Account above margin\"\n        );\n        require(amount <= base.abs(), \"LIQ: Liquidate Amount > Position\");\n\n        // calc funds to liquidate and move to Escrow\n        uint256 amountToEscrow = LibLiquidation.calcEscrowLiquidationAmount(\n            Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),\n            currentMargin,\n            amount,\n            base\n        );\n\n        // create a liquidation receipt\n        Perpetuals.Side side = base < 0 ? Perpetuals.Side.Short : Perpetuals.Side.Long;\n        submitLiquidation(msg.sender, account, price, amountToEscrow, amount, side);\n        return amountToEscrow;\n    }\n\n    /**\n     * @return true if the margin is greater than 10x liquidation gas cost (in quote tokens)\n     * @param updatedPosition The agent's position after being liquidated\n     * @param lastUpdatedGasPrice The last updated gas price of the account to be liquidated\n     */\n    function checkPartialLiquidation(Balances.Position memory updatedPosition, uint256 lastUpdatedGasPrice)\n        public\n        view\n        returns (bool)\n    {\n        uint256 liquidationGasCost = tracer.LIQUIDATION_GAS_COST();\n        uint256 price = pricing.fairPrice();\n\n        return\n            LibLiquidation.partialLiquidationIsValid(\n                updatedPosition,\n                lastUpdatedGasPrice,\n                liquidationGasCost,\n                price,\n                minimumLeftoverGasCostMultiplier\n            );\n    }\n\n    /**\n     * @notice Liquidates the margin account of a particular user. A deposit is needed from the liquidator.\n     *         Generates a liquidation receipt for the liquidator to use should they need a refund.\n     * @param amount The amount of tokens to be liquidated\n     * @param account The account that is to be liquidated.\n     */\n    function liquidate(int256 amount, address account) external override {\n        /* Liquidated account's balance */\n        Balances.Account memory liquidatedBalance = tracer.getBalance(account);\n\n        uint256 amountToEscrow = verifyAndSubmitLiquidation(\n            liquidatedBalance.position.base,\n            pricing.fairPrice(),\n            liquidatedBalance.position.quote,\n            amount,\n            liquidatedBalance.lastUpdatedGasPrice,\n            account\n        );\n\n        (\n            int256 liquidatorQuoteChange,\n            int256 liquidatorBaseChange,\n            int256 liquidateeQuoteChange,\n            int256 liquidateeBaseChange\n        ) = LibLiquidation.liquidationBalanceChanges(\n            liquidatedBalance.position.base,\n            liquidatedBalance.position.quote,\n            amount\n        );\n\n        Balances.Position memory updatedPosition = Balances.Position(\n            liquidatedBalance.position.quote + liquidateeQuoteChange,\n            liquidatedBalance.position.base + liquidateeBaseChange\n        );\n\n        require(\n            checkPartialLiquidation(updatedPosition, liquidatedBalance.lastUpdatedGasPrice),\n            \"LIQ: leaves too little left over\"\n        );\n\n        tracer.updateAccountsOnLiquidation(\n            msg.sender,\n            account,\n            liquidatorQuoteChange,\n            liquidatorBaseChange,\n            liquidateeQuoteChange,\n            liquidateeBaseChange,\n            amountToEscrow\n        );\n\n        emit Liquidate(\n            account,\n            msg.sender,\n            amount,\n            (liquidatedBalance.position.base < 0 ? Perpetuals.Side.Short : Perpetuals.Side.Long),\n            address(tracer),\n            currentLiquidationId - 1\n        );\n    }\n\n    /**\n     * @notice Calculates the number of units sold and the average price of those units by a trader\n     *         given multiple order\n     * @param orders a list of orders for which the units sold is being calculated from\n     * @param traderContract The trader contract with which the orders were made\n     * @param receiptId the id of the liquidation receipt the orders are being claimed against\n     */\n    function calcUnitsSold(\n        Perpetuals.Order[] memory orders,\n        address traderContract,\n        uint256 receiptId\n    ) public override returns (uint256, uint256) {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        uint256 unitsSold;\n        uint256 avgPrice;\n        for (uint256 i; i < orders.length; i++) {\n            Perpetuals.Order memory order = ITrader(traderContract).getOrder(orders[i]);\n\n            if (\n                order.created < receipt.time || // Order made before receipt\n                order.maker != receipt.liquidator || // Order made by someone who isn't liquidator\n                order.side == receipt.liquidationSide // Order is in same direction as liquidation\n                /* Order should be the opposite to the position acquired on liquidation */\n            ) {\n                emit InvalidClaimOrder(receiptId);\n                continue;\n            }\n            if (\n                (receipt.liquidationSide == Perpetuals.Side.Long && order.price >= receipt.price) ||\n                (receipt.liquidationSide == Perpetuals.Side.Short && order.price <= receipt.price)\n            ) {\n                // Liquidation position was long\n                // Price went up, so not a slippage order\n                // or\n                // Liquidation position was short\n                // Price went down, so not a slippage order\n                emit InvalidClaimOrder(receiptId);\n                continue;\n            }\n            uint256 orderFilled = ITrader(traderContract).filledAmount(order);\n            uint256 averageExecutionPrice = ITrader(traderContract).getAverageExecutionPrice(order);\n\n            /* order.created >= receipt.time\n             * && order.maker == receipt.liquidator\n             * && order.side != receipt.liquidationSide */\n            unitsSold = unitsSold + orderFilled;\n            avgPrice = avgPrice + (averageExecutionPrice * orderFilled);\n        }\n\n        // Avoid divide by 0 if no orders sold\n        if (unitsSold == 0) {\n            return (0, 0);\n        }\n        return (unitsSold, avgPrice / unitsSold);\n    }\n\n    /**\n     * @notice Marks receipts as claimed and returns the refund amount\n     * @param escrowId the id of the receipt created during the liquidation event\n     * @param orders the orders that sell the liquidated positions\n     * @param traderContract the address of the trader contract the selling orders were made by\n     */\n    function calcAmountToReturn(\n        uint256 escrowId,\n        Perpetuals.Order[] memory orders,\n        address traderContract\n    ) public override returns (uint256) {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[escrowId];\n        // Validate the escrowed order was fully sold\n        (uint256 unitsSold, uint256 avgPrice) = calcUnitsSold(orders, traderContract, escrowId);\n        require(unitsSold <= uint256(receipt.amountLiquidated.abs()), \"LIQ: Unit mismatch\");\n\n        uint256 amountToReturn = LibLiquidation.calculateSlippage(unitsSold, maxSlippage, avgPrice, receipt);\n        return amountToReturn;\n    }\n\n    /**\n     * @notice Drains a certain amount from insurance pool to cover excess slippage not covered by escrow\n     * @param amountWantedFromInsurance How much we want to drain\n     * @param receipt The liquidation receipt for which we are calling on the insurance pool to cover\n     */\n    function drainInsurancePoolOnLiquidation(\n        uint256 amountWantedFromInsurance,\n        LibLiquidation.LiquidationReceipt memory receipt\n    ) internal returns (uint256 _amountTakenFromInsurance, uint256 _amountToGiveToClaimant) {\n        /*\n         * If there was not enough escrowed, we want to call the insurance pool to help out.\n         * First, check the margin of the insurance Account. If this is enough, just drain from there.\n         * If this is not enough, call Insurance.drainPool to get some tokens from the insurance pool.\n         * If drainPool is able to drain enough, drain from the new margin.\n         * If the margin still does not have enough after calling drainPool, we are not able to fully\n         * claim the receipt, only up to the amount the insurance pool allows for.\n         */\n\n        Balances.Account memory insuranceBalance = tracer.getBalance(insuranceContract);\n        if (insuranceBalance.position.quote >= amountWantedFromInsurance.toInt256()) {\n            // We don't need to drain insurance contract. The balance is already in the market contract\n            _amountTakenFromInsurance = amountWantedFromInsurance;\n        } else {\n            // insuranceBalance.quote < amountWantedFromInsurance\n            if (insuranceBalance.position.quote <= 0) {\n                // attempt to drain entire balance that is needed from the pool\n                IInsurance(insuranceContract).drainPool(amountWantedFromInsurance);\n            } else {\n                // attempt to drain the required balance taking into account the insurance balance in the account contract\n                IInsurance(insuranceContract).drainPool(\n                    amountWantedFromInsurance - uint256(insuranceBalance.position.quote)\n                );\n            }\n            Balances.Account memory updatedInsuranceBalance = tracer.getBalance(insuranceContract);\n            if (updatedInsuranceBalance.position.quote < amountWantedFromInsurance.toInt256()) {\n                // Still not enough\n                _amountTakenFromInsurance = uint256(updatedInsuranceBalance.position.quote);\n            } else {\n                _amountTakenFromInsurance = amountWantedFromInsurance;\n            }\n        }\n\n        _amountToGiveToClaimant = receipt.escrowedAmount + _amountTakenFromInsurance;\n        // Don't add any to liquidatee\n    }\n\n    /**\n     * @notice Allows a liquidator to submit a single liquidation receipt and multiple order ids. If the\n     *         liquidator experienced slippage, will refund them a proportional amount of their deposit.\n     * @param receiptId Used to identify the receipt that will be claimed\n     * @param orders The orders that sold the liquidated position\n     */\n    function claimReceipt(\n        uint256 receiptId,\n        Perpetuals.Order[] memory orders,\n        address traderContract\n    ) external override {\n        // Claim the receipts from the escrow system, get back amount to return\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        require(receipt.liquidator == msg.sender, \"LIQ: Liquidator mismatch\");\n        // Mark refund as claimed\n        require(!receipt.liquidatorRefundClaimed, \"LIQ: Already claimed\");\n        liquidationReceipts[receiptId].liquidatorRefundClaimed = true;\n        liquidationReceipts[receiptId].escrowClaimed = true;\n        require(block.timestamp < receipt.releaseTime, \"LIQ: claim time passed\");\n        require(tracer.tradingWhitelist(traderContract), \"LIQ: Trader is not whitelisted\");\n\n        uint256 amountToReturn = calcAmountToReturn(receiptId, orders, traderContract);\n\n        if (amountToReturn > receipt.escrowedAmount) {\n            liquidationReceipts[receiptId].escrowedAmount = 0;\n        } else {\n            liquidationReceipts[receiptId].escrowedAmount = receipt.escrowedAmount - amountToReturn;\n        }\n\n        // Keep track of how much was actually taken out of insurance\n        uint256 amountTakenFromInsurance;\n        uint256 amountToGiveToClaimant;\n        uint256 amountToGiveToLiquidatee;\n\n        if (amountToReturn > receipt.escrowedAmount) {\n            // Need to cover some loses with the insurance contract\n            // Whatever is the remainder that can't be covered from escrow\n            uint256 amountWantedFromInsurance = amountToReturn - receipt.escrowedAmount;\n            (amountTakenFromInsurance, amountToGiveToClaimant) = drainInsurancePoolOnLiquidation(\n                amountWantedFromInsurance,\n                receipt\n            );\n        } else {\n            amountToGiveToClaimant = amountToReturn;\n            amountToGiveToLiquidatee = receipt.escrowedAmount - amountToReturn;\n        }\n\n        tracer.updateAccountsOnClaim(\n            receipt.liquidator,\n            amountToGiveToClaimant.toInt256(),\n            receipt.liquidatee,\n            amountToGiveToLiquidatee.toInt256(),\n            amountTakenFromInsurance.toInt256()\n        );\n        emit ClaimedReceipts(msg.sender, address(tracer), receiptId);\n    }\n\n    function transferOwnership(address newOwner) public override(Ownable, ILiquidation) onlyOwner {\n        super.transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice Modifies the release time\n     * @param _releaseTime new release time\n     */\n    function setReleaseTime(uint256 _releaseTime) external onlyOwner() {\n        releaseTime = _releaseTime;\n    }\n\n    /**\n     * @notice Modifies the value to multiply the liquidation cost by in determining\n     *         the minimum leftover margin on partial liquidation\n     * @param _minimumLeftoverGasCostMultiplier The new multiplier\n     */\n    function setMinimumLeftoverGasCostMultiplier(uint256 _minimumLeftoverGasCostMultiplier) external onlyOwner() {\n        minimumLeftoverGasCostMultiplier = _minimumLeftoverGasCostMultiplier;\n    }\n\n    /**\n     * @notice Modifies the max slippage\n     * @param _maxSlippage new max slippage\n     */\n    function setMaxSlippage(uint256 _maxSlippage) public override onlyOwner() {\n        maxSlippage = _maxSlippage;\n    }\n}"
    }
  ]
}