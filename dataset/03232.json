{
  "Title": "[L03] Lack of input validation",
  "Content": "The `public` [`getReturn`](https://github.com/1inch/fixed-rate-swap/blob/b1600f61b77b6051388e6fb2cb0be776c5bcf2d1/contracts/FixedRateSwap.sol#L89) function is lacking some input validation. Specifically:\n\n\n* It does not validate that the `tokenFrom` and `tokenTo` addresses are the tokens that comprise the pool.\n* It does not validate that the `inputAmount` parameter is non-zero.\n* It does not validate that the `fromBalance + toBalance` value is non-zero.\n\n\nAdditionally, neither the [`withdrawFor`](https://github.com/1inch/fixed-rate-swap/blob/b1600f61b77b6051388e6fb2cb0be776c5bcf2d1/contracts/FixedRateSwap.sol#L162) nor the [`withdrawForWithRatio`](https://github.com/1inch/fixed-rate-swap/blob/b1600f61b77b6051388e6fb2cb0be776c5bcf2d1/contracts/FixedRateSwap.sol#L204) functions calculate if a user has enough shares to withdraw their requested amount. In either case, a withdrawal will revert if the condition is not satisfied, but the error messages are unclear and emitted only after consuming unnecessary gas.\n\n\nLastly, the [`withdrawForWithRatio`](https://github.com/1inch/fixed-rate-swap/blob/b1600f61b77b6051388e6fb2cb0be776c5bcf2d1/contracts/FixedRateSwap.sol#L204) function neglects to ensure that the values used for virtual balance calculations are less than or equal to the actual balances of the contract. Such a scenario would lead to a cryptic arithmetic revert [when calculating `balanceX` and `balanceY` for the `_getRealAmountsForWithdrawImpl` function](https://github.com/1inch/fixed-rate-swap/blob/b1600f61b77b6051388e6fb2cb0be776c5bcf2d1/contracts/FixedRateSwap.sol#L294-L296).\n\n\nA lack of validation on user-controlled parameters may result in erroneous or failing transactions that are difficult to debug. To avoid this, consider improving the clarity of error messages and adding input validation to address the concerns raised above.\n\n\n***Update:** Partially fixed in [commit `63b6a95`](https://github.com/1inch/fixed-rate-swap/commit/63b6a95e2f0ec3a6714ac646d4ab4b97f0def311) and [commit `7c0ade7`](https://github.com/1inch/fixed-rate-swap/commit/7c0ade7c300b37f3a003fe463bd8af245737b927). It has only been validated if the `inputAmount` value is zero and it has been moved the order of operations to fail early when burning LP tokens to reduce the gas cost. 1inch teamâ€™s statement for this issue:*\n\n\n\n> tokenFrom and tokenTo validation is not mandatory as in swap method they are substituted from constants\n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/FixedRateSwap.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\n/**\n  * @dev AMM that is designed for assets with stable price to each other e.g. USDC and USDT.\n  * It utilizes constant sum price curve x + y = const but fee is variable depending on the token balances.\n  * In most cases fee is equal to 1 bip. But when balances are at extreme ends it either lowers to 0\n  * or increases to 20 bip.\n  * Fee calculations are explained in more details in `getReturn` method.\n  * Note that AMM does not support token with fees.\n */\ncontract FixedRateSwap is ERC20 {\n    using SafeERC20 for IERC20;\n\n    event Swap(\n        address indexed trader,\n        int256 token0Amount,\n        int256 token1Amount\n    );\n\n    event Deposit(\n        address indexed user,\n        uint256 token0Amount,\n        uint256 token1Amount,\n        uint256 share\n    );\n\n    event Withdrawal(\n        address indexed user,\n        uint256 token0Amount,\n        uint256 token1Amount,\n        uint256 share\n    );\n\n    IERC20 immutable public token0;\n    IERC20 immutable public token1;\n\n    uint8 immutable private _decimals;\n\n    uint256 constant private _ONE = 1e18;\n    uint256 constant private _C1 = 0.9999e18;\n    uint256 constant private _C2 = 3.382712334998325432e18;\n    uint256 constant private _C3 = 0.456807350974663119e18;\n    uint256 constant private _THRESHOLD = 1;\n\n    constructor(\n        IERC20 _token0,\n        IERC20 _token1,\n        string memory name,\n        string memory symbol,\n        uint8 decimals_\n    )\n        ERC20(name, symbol)\n    {\n        token0 = _token0;\n        token1 = _token1;\n        _decimals = decimals_;\n        require(IERC20Metadata(address(_token0)).decimals() == decimals_, \"FRS: token0 decimals mismatch\");\n        require(IERC20Metadata(address(_token1)).decimals() == decimals_, \"FRS: token1 decimals mismatch\");\n    }\n\n    function decimals() public view virtual override returns(uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @notice estimates return value of the swap\n     * @param tokenFrom token that user wants to sell\n     * @param tokenTo token that user wants to buy\n     * @param inputAmount amount of `tokenFrom` that user wants to sell\n     * @return outputAmount amount of `tokenTo` that user will receive after the trade\n     *\n     * @dev\n     * `getReturn` at point `x = inputBalance / (inputBalance + outputBalance)`:\n     * `getReturn(x) = 0.9999 + (0.5817091329374359 - x * 1.2734233188154198)^17`\n     * When balance is changed from `inputBalance` to `inputBalance + amount` we should take\n     * integral of getReturn to calculate proper amount:\n     * `getReturn(x0, x1) = (integral (0.9999 + (0.5817091329374359 - x * 1.2734233188154198)^17) dx from x=x0 to x=x1) / (x1 - x0)`\n     * `getReturn(x0, x1) = (0.9999 * x - 3.3827123349983306 * (x - 0.4568073509746632) ** 18 from x=x0 to x=x1) / (x1 - x0)`\n     * `getReturn(x0, x1) = (0.9999 * (x1 - x0) + 3.3827123349983306 * ((x0 - 0.4568073509746632) ** 18 - (x1 - 0.4568073509746632) ** 18)) / (x1 - x0)`\n     */\n    function getReturn(IERC20 tokenFrom, IERC20 tokenTo, uint256 inputAmount) public view returns(uint256 outputAmount) {\n        uint256 fromBalance = tokenFrom.balanceOf(address(this));\n        uint256 toBalance = tokenTo.balanceOf(address(this));\n        require(inputAmount <= toBalance, \"input amount is too big\");\n        outputAmount = _getReturn(fromBalance, toBalance, inputAmount);\n    }\n\n    /**\n     * @notice makes a deposit of both tokens to the AMM\n     * @param token0Amount amount of token0 to deposit\n     * @param token1Amount amount of token1 to deposit\n     * @return share amount of LP tokens received\n     */\n    function deposit(uint256 token0Amount, uint256 token1Amount) external returns(uint256 share) {\n        share = depositFor(token0Amount, token1Amount, msg.sender);\n    }\n\n    /**\n     * @notice makes a deposit of both tokens to the AMM and transfers LP tokens to the specified address\n     * @param token0Amount amount of token0 to deposit\n     * @param token1Amount amount of token1 to deposit\n     * @param to address that will receive tokens\n     * @return share amount of LP tokens received\n     *\n     * @dev fully balanced deposit happens when ratio of amounts of deposit matches ratio of balances.\n     * To make a fair deposit when ratios do not match the contract finds the amount that is needed to swap to\n     * equalize ratios and makes that swap virtually to capture the swap fees. Then final share is calculated from\n     * fair deposit of virtual amounts.\n     */\n    function depositFor(uint256 token0Amount, uint256 token1Amount, address to) public returns(uint256 share) {\n        (uint256 token0VirtualAmount, uint256 token1VirtualAmount) = _getVirtualAmountsForDeposit(token0Amount, token1Amount);\n\n        uint256 inputAmount = token0VirtualAmount + token1VirtualAmount;\n        require(inputAmount > 0, \"Empty deposit is not allowed\");\n        require(to != address(this), \"Deposit to this is forbidden\");\n        // _mint also checks require(to != address(0))\n\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply > 0) {\n            uint256 totalBalance = token0.balanceOf(address(this)) + token1.balanceOf(address(this)) +\n                                   token0Amount + token1Amount - inputAmount;\n            share = inputAmount * _totalSupply / totalBalance;\n        } else {\n            share = inputAmount;\n        }\n\n        if (token0Amount > 0) {\n            token0.safeTransferFrom(msg.sender, address(this), token0Amount);\n        }\n        if (token1Amount > 0) {\n            token1.safeTransferFrom(msg.sender, address(this), token1Amount);\n        }\n        _mint(to, share);\n        emit Deposit(to, token0Amount, token1Amount, share);\n    }\n\n    /**\n     * @notice makes a proportional withdrawal of both tokens\n     * @param amount amount of LP tokens to burn\n     * @return token0Amount amount of token0 received\n     * @return token1Amount amount of token1 received\n     */\n    function withdraw(uint256 amount) external returns(uint256 token0Amount, uint256 token1Amount) {\n        (token0Amount, token1Amount) = withdrawFor(amount, msg.sender);\n    }\n\n    /**\n     * @notice makes a proportional withdrawal of both tokens and transfers them to the specified address\n     * @param amount amount of LP tokens to burn\n     * @param to address that will receive tokens\n     * @return token0Amount amount of token0 received\n     * @return token1Amount amount of token1 received\n     */\n    function withdrawFor(uint256 amount, address to) public returns(uint256 token0Amount, uint256 token1Amount) {\n        require(amount > 0, \"Empty withdrawal is not allowed\");\n        require(to != address(this), \"Withdrawal to this is forbidden\");\n        require(to != address(0), \"Withdrawal to zero is forbidden\");\n\n        uint256 _totalSupply = totalSupply();\n        token0Amount = token0.balanceOf(address(this)) * amount / _totalSupply;\n        token1Amount = token1.balanceOf(address(this)) * amount / _totalSupply;\n\n        _burn(msg.sender, amount);\n        emit Withdrawal(msg.sender, token0Amount, token1Amount, amount);\n        if (token0Amount > 0) {\n            token0.safeTransfer(to, token0Amount);\n        }\n        if (token1Amount > 0) {\n            token1.safeTransfer(to, token1Amount);\n        }\n    }\n\n    /**\n     * @notice makes a withdrawal with custom ratio\n     * @param amount amount of LP tokens to burn\n     * @param firstTokenShare percentage of token0 to receive with 100% equals to 1e18\n     * @return token0Amount amount of token0 received\n     * @return token1Amount amount of token1 received\n     */\n    function withdrawWithRatio(uint256 amount, uint256 firstTokenShare) public returns(uint256 token0Amount, uint256 token1Amount) {\n        return withdrawForWithRatio(amount, msg.sender, firstTokenShare);\n    }\n\n    /**\n     * @notice makes a withdrawal with custom ratio and transfers tokens to the specified address\n     * @param amount amount of LP tokens to burn\n     * @param to address that will receive tokens\n     * @param firstTokenShare percentage of token0 to receive with 100% equals to 1e18\n     * @return token0Amount amount of token0 received\n     * @return token1Amount amount of token1 received\n     *\n     * @dev withdrawal with custom ratio is semantically equal to proportional withdrawal with extra swap afterwards to\n     * get to the specified ratio. The contract does exactly this by making virtual proportional withdrawal and then\n     * finds the amount needed for an extra virtual swap to achieve specified ratio.\n     */\n    function withdrawForWithRatio(uint256 amount, address to, uint256 firstTokenShare) public returns(uint256 token0Amount, uint256 token1Amount) {\n        require(amount > 0, \"Empty withdrawal is not allowed\");\n        require(to != address(this), \"Withdrawal to this is forbidden\");\n        require(to != address(0), \"Withdrawal to zero is forbidden\");\n        require(firstTokenShare <= _ONE, \"Ratio should be in [0, 1]\");\n\n        (token0Amount, token1Amount) = _getRealAmountsForWithdraw(amount, firstTokenShare);\n\n        _burn(msg.sender, amount);\n        emit Withdrawal(msg.sender, token0Amount, token1Amount, amount);\n\n        if (token0Amount > 0) {\n            token0.safeTransfer(to, token0Amount);\n        }\n        if (token1Amount > 0) {\n            token1.safeTransfer(to, token1Amount);\n        }\n    }\n\n    /**\n     * @notice swaps token0 for token1\n     * @param inputAmount amount of token0 to sell\n     * @return outputAmount amount of token1 bought\n     */\n    function swap0To1(uint256 inputAmount) external returns(uint256 outputAmount) {\n        outputAmount = _swap(token0, token1, inputAmount, msg.sender);\n        emit Swap(msg.sender, int256(inputAmount), -int256(outputAmount));\n    }\n\n    /**\n     * @notice swaps token1 for token0\n     * @param inputAmount amount of token1 to sell\n     * @return outputAmount amount of token0 bought\n     */\n    function swap1To0(uint256 inputAmount) external returns(uint256 outputAmount) {\n        outputAmount = _swap(token1, token0, inputAmount, msg.sender);\n        emit Swap(msg.sender, -int256(outputAmount), int256(inputAmount));\n    }\n\n    /**\n     * @notice swaps token0 for token1 and transfers them to specified receiver address\n     * @param inputAmount amount of token0 to sell\n     * @param to address that will receive tokens\n     * @return outputAmount amount of token1 bought\n     */\n    function swap0To1For(uint256 inputAmount, address to) external returns(uint256 outputAmount) {\n        require(to != address(this), \"Swap to this is forbidden\");\n        require(to != address(0), \"Swap to zero is forbidden\");\n\n        outputAmount = _swap(token0, token1, inputAmount, to);\n        emit Swap(msg.sender, int256(inputAmount), -int256(outputAmount));\n    }\n\n    /**\n     * @notice swaps token1 for token0 and transfers them to specified receiver address\n     * @param inputAmount amount of token1 to sell\n     * @param to address that will receive tokens\n     * @return outputAmount amount of token0 bought\n     */\n    function swap1To0For(uint256 inputAmount, address to) external returns(uint256 outputAmount) {\n        require(to != address(this), \"Swap to this is forbidden\");\n        require(to != address(0), \"Swap to zero is forbidden\");\n\n        outputAmount = _swap(token1, token0, inputAmount, to);\n        emit Swap(msg.sender, -int256(outputAmount), int256(inputAmount));\n    }\n\n    function _getVirtualAmountsForDeposit(uint256 token0Amount, uint256 token1Amount) private view returns(uint256 token0VirtualAmount, uint256 token1VirtualAmount) {\n        uint256 token0Balance = token0.balanceOf(address(this));\n        uint256 token1Balance = token1.balanceOf(address(this));\n\n        int256 shift = _checkVirtualAmountsFormula(token0Amount, token1Amount, token0Balance, token1Balance);\n        if (shift > 0) {\n            (token0VirtualAmount, token1VirtualAmount) = _getVirtualAmountsForDepositImpl(token0Amount, token1Amount, token0Balance, token1Balance);\n        } else if (shift < 0) {\n            (token1VirtualAmount, token0VirtualAmount) = _getVirtualAmountsForDepositImpl(token1Amount, token0Amount, token1Balance, token0Balance);\n        } else {\n            (token0VirtualAmount, token1VirtualAmount) = (token0Amount, token1Amount);\n        }\n    }\n\n    function _getRealAmountsForWithdraw(uint256 amount, uint256 firstTokenShare) private view returns(uint256 token0RealAmount, uint256 token1RealAmount) {\n        uint256 _totalSupply = totalSupply();\n        uint256 token0Balance = token0.balanceOf(address(this));\n        uint256 token1Balance = token1.balanceOf(address(this));\n        uint256 token0VirtualAmount = token0Balance * amount / _totalSupply;\n        uint256 token1VirtualAmount = token1Balance * amount / _totalSupply;\n\n        uint256 currentToken0Share = token0VirtualAmount * _ONE / (token0VirtualAmount + token1VirtualAmount);\n        if (firstTokenShare < currentToken0Share) {\n            (token0RealAmount, token1RealAmount) = _getRealAmountsForWithdrawImpl(token0VirtualAmount, token1VirtualAmount, token0Balance - token0VirtualAmount, token1Balance - token1VirtualAmount, firstTokenShare);\n        } else if (firstTokenShare > currentToken0Share) {\n            (token1RealAmount, token0RealAmount) = _getRealAmountsForWithdrawImpl(token1VirtualAmount, token0VirtualAmount, token1Balance - token1VirtualAmount, token0Balance - token0VirtualAmount, _ONE - firstTokenShare);\n        } else {\n            (token0RealAmount, token1RealAmount) = (token0VirtualAmount, token1VirtualAmount);\n        }\n    }\n\n    function _getReturn(uint256 fromBalance, uint256 toBalance, uint256 inputAmount) private pure returns(uint256 outputAmount) {\n        unchecked {\n            uint256 totalBalance = fromBalance + toBalance;\n            uint256 x0 = _ONE * fromBalance / totalBalance;\n            uint256 x1 = _ONE * (fromBalance + inputAmount) / totalBalance;\n            uint256 scaledInputAmount = _ONE * inputAmount;\n            uint256 amountMultiplier = (\n                _C1 * scaledInputAmount / totalBalance +\n                _C2 * _powerHelper(x0) -\n                _C2 * _powerHelper(x1)\n            ) * totalBalance / scaledInputAmount;\n            outputAmount = inputAmount * Math.min(amountMultiplier, _ONE) / _ONE;\n        }\n    }\n\n    function _swap(IERC20 tokenFrom, IERC20 tokenTo, uint256 inputAmount, address to) private returns(uint256 outputAmount) {\n        require(inputAmount > 0, \"Input amount should be > 0\");\n        outputAmount = getReturn(tokenFrom, tokenTo, inputAmount);\n        require(outputAmount > 0, \"Empty swap is not allowed\");\n        tokenFrom.safeTransferFrom(msg.sender, address(this), inputAmount);\n        tokenTo.safeTransfer(to, outputAmount);\n    }\n\n    /**\n     * @dev We utilize binary search to find proper to swap\n     *\n     * Inital approximation of dx is taken from the same equation by assuming dx ~ dy\n     *\n     * x - dx     xBalance + dx\n     * ------  =  ------------\n     * y + dx     yBalance - dx\n     *\n     * dx = (x * yBalance - xBalance * y) / (xBalance + yBalance + x + y)\n     */\n    function _getVirtualAmountsForDepositImpl(uint256 x, uint256 y, uint256 xBalance, uint256 yBalance) private pure returns(uint256, uint256) {\n        uint256 dx = (x * yBalance - y * xBalance) / (xBalance + yBalance + x + y);\n        if (dx == 0) {\n            return (x, y);\n        }\n        uint256 left = dx * 998 / 1000;\n        uint256 right = Math.min(dx * 1002 / 1000, yBalance);\n        uint256 dy = _getReturn(xBalance, yBalance, dx);\n        int256 shift = _checkVirtualAmountsFormula(x - dx, y + dy, xBalance + dx, yBalance - dy);\n\n        while (left + _THRESHOLD < right) {\n            if (shift > 0) {\n                left = dx;\n                dx = (dx + right) / 2;\n            } else if (shift < 0) {\n                right = dx;\n                dx = (left + dx) / 2;\n            } else {\n                break;\n            }\n            dy = _getReturn(xBalance, yBalance, dx);\n            shift = _checkVirtualAmountsFormula(x - dx, y + dy, xBalance + dx, yBalance - dy);\n        }\n\n        return (x - dx, y + dy);\n    }\n\n    /**\n     * @dev We utilize binary search to find proper amount to swap\n     *\n     * Inital approximation of dx is taken from the same equation by assuming dx ~ dy\n     *\n     * x - dx        firstTokenShare\n     * ------  =  ----------------------\n     * y + dx     _ONE - firstTokenShare\n     *\n     * dx = (x * (_ONE - firstTokenShare) - y * firstTokenShare) / _ONE\n     */\n    function _getRealAmountsForWithdrawImpl(uint256 virtualX, uint256 virtualY, uint256 balanceX, uint256 balanceY, uint256 firstTokenShare) private pure returns(uint256, uint256) {\n        require(balanceX != 0 || balanceY != 0, \"Amount exceeds total balance\");\n        if (firstTokenShare == 0) {\n            return (0, virtualY + _getReturn(balanceX, balanceY, virtualX));\n        }\n\n        uint256 secondTokenShare = _ONE - firstTokenShare;\n        uint256 dx = (virtualX * (_ONE - firstTokenShare) - virtualY * firstTokenShare) / _ONE;\n        uint256 left = dx * 998 / 1000;\n        uint256 right = Math.min(dx * 1002 / 1000, virtualX);\n        uint256 dy = _getReturn(balanceX, balanceY, dx);\n\n        int256 shift = _checkVirtualAmountsFormula(virtualX - dx, virtualY + dy, firstTokenShare, secondTokenShare);\n\n        while (left + _THRESHOLD < right) {\n            if (shift > 0) {\n                left = dx;\n                dx = (dx + right) / 2;\n            } else if (shift < 0) {\n                right = dx;\n                dx = (left + dx) / 2;\n            } else {\n                break;\n            }\n            dy = _getReturn(balanceX, balanceY, dx);\n            shift = _checkVirtualAmountsFormula(virtualX - dx, virtualY + dy, firstTokenShare, secondTokenShare);\n        }\n\n        return (virtualX - dx, virtualY + dy);\n    }\n\n    /**\n     * @dev\n     *\n     * Equilibrium is when ratio of amounts equals to ratio of balances\n     *\n     *  x      xBalance\n     * --- == ----------\n     *  y      yBalance\n     *\n     */\n    function _checkVirtualAmountsFormula(uint256 x, uint256 y, uint256 xBalance, uint256 yBalance) private pure returns(int256) {\n        unchecked {\n            return int256(x * yBalance - y * xBalance);\n        }\n    }\n\n    function _powerHelper(uint256 x) private pure returns(uint256 p) {\n        unchecked {\n            if (x > _C3) {\n                p = x - _C3;\n            } else {\n                p = _C3 - x;\n            }\n            p = p * p / _ONE;  // p ^ 2\n            uint256 pp = p * p / _ONE;  // p ^ 4\n            pp = pp * pp / _ONE;  // p ^ 8\n            pp = pp * pp / _ONE;  // p ^ 16\n            p = p * pp / _ONE;  // p ^ 18\n        }\n    }\n}"
    },
    {
      "filename": "contracts/FixedRateSwap.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\n/**\n  * @dev AMM that is designed for assets with stable price to each other e.g. USDC and USDT.\n  * It utilizes constant sum price curve x + y = const but fee is variable depending on the token balances.\n  * In most cases fee is equal to 1 bip. But when balances are at extreme ends it either lowers to 0\n  * or increases to 20 bip.\n  * Fee calculations are explained in more details in `getReturn` method.\n  * Note that AMM does not support token with fees.\n */\ncontract FixedRateSwap is ERC20 {\n    using SafeERC20 for IERC20;\n\n    event Swap(\n        address indexed trader,\n        int256 token0Amount,\n        int256 token1Amount\n    );\n\n    event Deposit(\n        address indexed user,\n        uint256 token0Amount,\n        uint256 token1Amount,\n        uint256 share\n    );\n\n    event Withdrawal(\n        address indexed user,\n        uint256 token0Amount,\n        uint256 token1Amount,\n        uint256 share\n    );\n\n    IERC20 immutable public token0;\n    IERC20 immutable public token1;\n\n    uint8 immutable private _decimals;\n\n    uint256 constant private _ONE = 1e18;\n    uint256 constant private _C1 = 0.9999e18;\n    uint256 constant private _C2 = 3.382712334998325432e18;\n    uint256 constant private _C3 = 0.456807350974663119e18;\n    uint256 constant private _THRESHOLD = 1;\n\n    constructor(\n        IERC20 _token0,\n        IERC20 _token1,\n        string memory name,\n        string memory symbol,\n        uint8 decimals_\n    )\n        ERC20(name, symbol)\n    {\n        token0 = _token0;\n        token1 = _token1;\n        _decimals = decimals_;\n        require(IERC20Metadata(address(_token0)).decimals() == decimals_, \"FRS: token0 decimals mismatch\");\n        require(IERC20Metadata(address(_token1)).decimals() == decimals_, \"FRS: token1 decimals mismatch\");\n    }\n\n    function decimals() public view virtual override returns(uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @notice estimates return value of the swap\n     * @param tokenFrom token that user wants to sell\n     * @param tokenTo token that user wants to buy\n     * @param inputAmount amount of `tokenFrom` that user wants to sell\n     * @return outputAmount amount of `tokenTo` that user will receive after the trade\n     *\n     * @dev\n     * `getReturn` at point `x = inputBalance / (inputBalance + outputBalance)`:\n     * `getReturn(x) = 0.9999 + (0.5817091329374359 - x * 1.2734233188154198)^17`\n     * When balance is changed from `inputBalance` to `inputBalance + amount` we should take\n     * integral of getReturn to calculate proper amount:\n     * `getReturn(x0, x1) = (integral (0.9999 + (0.5817091329374359 - x * 1.2734233188154198)^17) dx from x=x0 to x=x1) / (x1 - x0)`\n     * `getReturn(x0, x1) = (0.9999 * x - 3.3827123349983306 * (x - 0.4568073509746632) ** 18 from x=x0 to x=x1) / (x1 - x0)`\n     * `getReturn(x0, x1) = (0.9999 * (x1 - x0) + 3.3827123349983306 * ((x0 - 0.4568073509746632) ** 18 - (x1 - 0.4568073509746632) ** 18)) / (x1 - x0)`\n     */\n    function getReturn(IERC20 tokenFrom, IERC20 tokenTo, uint256 inputAmount) public view returns(uint256 outputAmount) {\n        uint256 fromBalance = tokenFrom.balanceOf(address(this));\n        uint256 toBalance = tokenTo.balanceOf(address(this));\n        require(inputAmount <= toBalance, \"input amount is too big\");\n        outputAmount = _getReturn(fromBalance, toBalance, inputAmount);\n    }\n\n    /**\n     * @notice makes a deposit of both tokens to the AMM\n     * @param token0Amount amount of token0 to deposit\n     * @param token1Amount amount of token1 to deposit\n     * @return share amount of LP tokens received\n     */\n    function deposit(uint256 token0Amount, uint256 token1Amount) external returns(uint256 share) {\n        share = depositFor(token0Amount, token1Amount, msg.sender);\n    }\n\n    /**\n     * @notice makes a deposit of both tokens to the AMM and transfers LP tokens to the specified address\n     * @param token0Amount amount of token0 to deposit\n     * @param token1Amount amount of token1 to deposit\n     * @param to address that will receive tokens\n     * @return share amount of LP tokens received\n     *\n     * @dev fully balanced deposit happens when ratio of amounts of deposit matches ratio of balances.\n     * To make a fair deposit when ratios do not match the contract finds the amount that is needed to swap to\n     * equalize ratios and makes that swap virtually to capture the swap fees. Then final share is calculated from\n     * fair deposit of virtual amounts.\n     */\n    function depositFor(uint256 token0Amount, uint256 token1Amount, address to) public returns(uint256 share) {\n        (uint256 token0VirtualAmount, uint256 token1VirtualAmount) = _getVirtualAmountsForDeposit(token0Amount, token1Amount);\n\n        uint256 inputAmount = token0VirtualAmount + token1VirtualAmount;\n        require(inputAmount > 0, \"Empty deposit is not allowed\");\n        require(to != address(this), \"Deposit to this is forbidden\");\n        // _mint also checks require(to != address(0))\n\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply > 0) {\n            uint256 totalBalance = token0.balanceOf(address(this)) + token1.balanceOf(address(this)) +\n                                   token0Amount + token1Amount - inputAmount;\n            share = inputAmount * _totalSupply / totalBalance;\n        } else {\n            share = inputAmount;\n        }\n\n        if (token0Amount > 0) {\n            token0.safeTransferFrom(msg.sender, address(this), token0Amount);\n        }\n        if (token1Amount > 0) {\n            token1.safeTransferFrom(msg.sender, address(this), token1Amount);\n        }\n        _mint(to, share);\n        emit Deposit(to, token0Amount, token1Amount, share);\n    }\n\n    /**\n     * @notice makes a proportional withdrawal of both tokens\n     * @param amount amount of LP tokens to burn\n     * @return token0Amount amount of token0 received\n     * @return token1Amount amount of token1 received\n     */\n    function withdraw(uint256 amount) external returns(uint256 token0Amount, uint256 token1Amount) {\n        (token0Amount, token1Amount) = withdrawFor(amount, msg.sender);\n    }\n\n    /**\n     * @notice makes a proportional withdrawal of both tokens and transfers them to the specified address\n     * @param amount amount of LP tokens to burn\n     * @param to address that will receive tokens\n     * @return token0Amount amount of token0 received\n     * @return token1Amount amount of token1 received\n     */\n    function withdrawFor(uint256 amount, address to) public returns(uint256 token0Amount, uint256 token1Amount) {\n        require(amount > 0, \"Empty withdrawal is not allowed\");\n        require(to != address(this), \"Withdrawal to this is forbidden\");\n        require(to != address(0), \"Withdrawal to zero is forbidden\");\n\n        uint256 _totalSupply = totalSupply();\n        token0Amount = token0.balanceOf(address(this)) * amount / _totalSupply;\n        token1Amount = token1.balanceOf(address(this)) * amount / _totalSupply;\n\n        _burn(msg.sender, amount);\n        emit Withdrawal(msg.sender, token0Amount, token1Amount, amount);\n        if (token0Amount > 0) {\n            token0.safeTransfer(to, token0Amount);\n        }\n        if (token1Amount > 0) {\n            token1.safeTransfer(to, token1Amount);\n        }\n    }\n\n    /**\n     * @notice makes a withdrawal with custom ratio\n     * @param amount amount of LP tokens to burn\n     * @param firstTokenShare percentage of token0 to receive with 100% equals to 1e18\n     * @return token0Amount amount of token0 received\n     * @return token1Amount amount of token1 received\n     */\n    function withdrawWithRatio(uint256 amount, uint256 firstTokenShare) public returns(uint256 token0Amount, uint256 token1Amount) {\n        return withdrawForWithRatio(amount, msg.sender, firstTokenShare);\n    }\n\n    /**\n     * @notice makes a withdrawal with custom ratio and transfers tokens to the specified address\n     * @param amount amount of LP tokens to burn\n     * @param to address that will receive tokens\n     * @param firstTokenShare percentage of token0 to receive with 100% equals to 1e18\n     * @return token0Amount amount of token0 received\n     * @return token1Amount amount of token1 received\n     *\n     * @dev withdrawal with custom ratio is semantically equal to proportional withdrawal with extra swap afterwards to\n     * get to the specified ratio. The contract does exactly this by making virtual proportional withdrawal and then\n     * finds the amount needed for an extra virtual swap to achieve specified ratio.\n     */\n    function withdrawForWithRatio(uint256 amount, address to, uint256 firstTokenShare) public returns(uint256 token0Amount, uint256 token1Amount) {\n        require(amount > 0, \"Empty withdrawal is not allowed\");\n        require(to != address(this), \"Withdrawal to this is forbidden\");\n        require(to != address(0), \"Withdrawal to zero is forbidden\");\n        require(firstTokenShare <= _ONE, \"Ratio should be in [0, 1]\");\n\n        (token0Amount, token1Amount) = _getRealAmountsForWithdraw(amount, firstTokenShare);\n\n        _burn(msg.sender, amount);\n        emit Withdrawal(msg.sender, token0Amount, token1Amount, amount);\n\n        if (token0Amount > 0) {\n            token0.safeTransfer(to, token0Amount);\n        }\n        if (token1Amount > 0) {\n            token1.safeTransfer(to, token1Amount);\n        }\n    }\n\n    /**\n     * @notice swaps token0 for token1\n     * @param inputAmount amount of token0 to sell\n     * @return outputAmount amount of token1 bought\n     */\n    function swap0To1(uint256 inputAmount) external returns(uint256 outputAmount) {\n        outputAmount = _swap(token0, token1, inputAmount, msg.sender);\n        emit Swap(msg.sender, int256(inputAmount), -int256(outputAmount));\n    }\n\n    /**\n     * @notice swaps token1 for token0\n     * @param inputAmount amount of token1 to sell\n     * @return outputAmount amount of token0 bought\n     */\n    function swap1To0(uint256 inputAmount) external returns(uint256 outputAmount) {\n        outputAmount = _swap(token1, token0, inputAmount, msg.sender);\n        emit Swap(msg.sender, -int256(outputAmount), int256(inputAmount));\n    }\n\n    /**\n     * @notice swaps token0 for token1 and transfers them to specified receiver address\n     * @param inputAmount amount of token0 to sell\n     * @param to address that will receive tokens\n     * @return outputAmount amount of token1 bought\n     */\n    function swap0To1For(uint256 inputAmount, address to) external returns(uint256 outputAmount) {\n        require(to != address(this), \"Swap to this is forbidden\");\n        require(to != address(0), \"Swap to zero is forbidden\");\n\n        outputAmount = _swap(token0, token1, inputAmount, to);\n        emit Swap(msg.sender, int256(inputAmount), -int256(outputAmount));\n    }\n\n    /**\n     * @notice swaps token1 for token0 and transfers them to specified receiver address\n     * @param inputAmount amount of token1 to sell\n     * @param to address that will receive tokens\n     * @return outputAmount amount of token0 bought\n     */\n    function swap1To0For(uint256 inputAmount, address to) external returns(uint256 outputAmount) {\n        require(to != address(this), \"Swap to this is forbidden\");\n        require(to != address(0), \"Swap to zero is forbidden\");\n\n        outputAmount = _swap(token1, token0, inputAmount, to);\n        emit Swap(msg.sender, -int256(outputAmount), int256(inputAmount));\n    }\n\n    function _getVirtualAmountsForDeposit(uint256 token0Amount, uint256 token1Amount) private view returns(uint256 token0VirtualAmount, uint256 token1VirtualAmount) {\n        uint256 token0Balance = token0.balanceOf(address(this));\n        uint256 token1Balance = token1.balanceOf(address(this));\n\n        int256 shift = _checkVirtualAmountsFormula(token0Amount, token1Amount, token0Balance, token1Balance);\n        if (shift > 0) {\n            (token0VirtualAmount, token1VirtualAmount) = _getVirtualAmountsForDepositImpl(token0Amount, token1Amount, token0Balance, token1Balance);\n        } else if (shift < 0) {\n            (token1VirtualAmount, token0VirtualAmount) = _getVirtualAmountsForDepositImpl(token1Amount, token0Amount, token1Balance, token0Balance);\n        } else {\n            (token0VirtualAmount, token1VirtualAmount) = (token0Amount, token1Amount);\n        }\n    }\n\n    function _getRealAmountsForWithdraw(uint256 amount, uint256 firstTokenShare) private view returns(uint256 token0RealAmount, uint256 token1RealAmount) {\n        uint256 _totalSupply = totalSupply();\n        uint256 token0Balance = token0.balanceOf(address(this));\n        uint256 token1Balance = token1.balanceOf(address(this));\n        uint256 token0VirtualAmount = token0Balance * amount / _totalSupply;\n        uint256 token1VirtualAmount = token1Balance * amount / _totalSupply;\n\n        uint256 currentToken0Share = token0VirtualAmount * _ONE / (token0VirtualAmount + token1VirtualAmount);\n        if (firstTokenShare < currentToken0Share) {\n            (token0RealAmount, token1RealAmount) = _getRealAmountsForWithdrawImpl(token0VirtualAmount, token1VirtualAmount, token0Balance - token0VirtualAmount, token1Balance - token1VirtualAmount, firstTokenShare);\n        } else if (firstTokenShare > currentToken0Share) {\n            (token1RealAmount, token0RealAmount) = _getRealAmountsForWithdrawImpl(token1VirtualAmou"
    }
  ]
}