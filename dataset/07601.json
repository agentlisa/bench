{
  "Title": "[H-04] User's Accrued Rewards Will Be Lost",
  "Content": "\nIf the user deposits too little GMX compared to other users (or total supply of pxGMX), the user will not be able to receive rewards after calling the `PirexRewards.claim` function. Subsequently, their accrued rewards will be cleared out (set to zero), and they will lose their rewards.\n\nThe amount of reward tokens that are claimable by a user is computed in Line 403 of the `PirexRewards.claim` function.\n\nIf the balance of pxGMX of a user is too small compared to other users (or total supply of pxGMX), the code below will always return zero due to rounding issues within solidity.\n\n```solidity\nuint256 amount = (rewardState * userRewards) / globalRewards;\n```\n\nSince the user's accrued rewards is cleared at Line 391 within the `PirexRewards.claim` function (`p.userStates[user].rewards = 0;`), the user's accrued rewards will be lost.\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexRewards.sol#L373>\n\n```solidity\nFile: PirexRewards.sol\n368:     /**\n369:         @notice Claim rewards\n370:         @param  producerToken  ERC20    Producer token contract\n371:         @param  user           address  User\n372:     */\n373:     function claim(ERC20 producerToken, address user) external {\n374:         if (address(producerToken) == address(0)) revert ZeroAddress();\n375:         if (user == address(0)) revert ZeroAddress();\n376: \n377:         harvest();\n378:         userAccrue(producerToken, user);\n379: \n380:         ProducerToken storage p = producerTokens[producerToken];\n381:         uint256 globalRewards = p.globalState.rewards;\n382:         uint256 userRewards = p.userStates[user].rewards;\n383: \n384:         // Claim should be skipped and not reverted on zero global/user reward\n385:         if (globalRewards != 0 && userRewards != 0) {\n386:             ERC20[] memory rewardTokens = p.rewardTokens;\n387:             uint256 rLen = rewardTokens.length;\n388: \n389:             // Update global and user reward states to reflect the claim\n390:             p.globalState.rewards = globalRewards - userRewards;\n391:             p.userStates[user].rewards = 0;\n392: \n393:             emit Claim(producerToken, user);\n394: \n395:             // Transfer the proportionate reward token amounts to the recipient\n396:             for (uint256 i; i < rLen; ++i) {\n397:                 ERC20 rewardToken = rewardTokens[i];\n398:                 address rewardRecipient = p.rewardRecipients[user][rewardToken];\n399:                 address recipient = rewardRecipient != address(0)\n400:                     ? rewardRecipient\n401:                     : user;\n402:                 uint256 rewardState = p.rewardStates[rewardToken];\n403:                 uint256 amount = (rewardState * userRewards) / globalRewards;\n404: \n405:                 if (amount != 0) {\n406:                     // Update reward state (i.e. amount) to reflect reward tokens transferred out\n407:                     p.rewardStates[rewardToken] = rewardState - amount;\n408: \n409:                     producer.claimUserReward(\n410:                         address(rewardToken),\n411:                         amount,\n412:                         recipient\n413:                     );\n414:                 }\n415:             }\n416:         }\n417:     }\n```\n\nThe graph below represents the amount of GMX tokens Alice and Bob staked in `PirexGmx` for each second during the period. Note that the graph is not drawn proportionally.\n\nGreen = Number of GMX tokens staked by Alice\n\nBlue = Number of GMX tokens staked by Bob\n\n![](https://user-images.githubusercontent.com/102820284/204132852-f76c8959-5040-46bf-9529-edd0d4a98e41.png)\n\nBased on the above graph:\n\n*   Alice staked 1 GMX token for 4 seconds (From T80 to T85)\n*   Bob staked 99999 GMX tokens for 4 seconds (From T80 to T85)\n\nAssume that the emission rate is 0.1 esGMX per 1 GMX staked per second.\n\nIn this case, the state variable will be as follows at the end of T83, assuming both the global and all user states have been updated and rewards have been harvested.\n\n*   rewardState = 60,000 esGMX tokens (600,000 \\* 0.1)\n*   globalRewards = 600,000 (100,000 \\* 6)\n*   Accrued `userRewards` of Alice = 6\n*   Accrued `userRewards` of Bob = 599,994 (99,999 \\* 6)\n\nFollowing is the description of `rewardState` for reference:\n\n> The `rewardState` represents the total number of a specific ERC20 reward token (e.g. WETH or esGMX) held by a producer (e.g. pxGMX or pxGPL).\n>\n> The `rewardState` of each reward token (e.g. WETH or esGMX) will increase whenever the rewards are harvested by the producer (e.g. `PirexRewards.harvest` is called). On the other hand, the `rewardState` will decrease if the users claim the rewards.\n\nAt the end of T85, Alice should be entitled to 1.2 esGMX tokens (0.2/sec \\* 6).\n\nFollowing is the formula used in the `PirexRewards` contract to compute the number of reward tokens a user is entitled to.\n\n```solidity\namount = (rewardState * userRewards) / globalRewards;\n```\n\nIf Alice claims the rewards at the end of T85, she will get zero esGMX tokens instead of 1.2 esGMX tokens.\n\n```solidity\namount = (rewardState * userRewards) / globalRewards;\n60,000 * 6 / 600,000\n360,000/600,000 = 0.6 = 0\n```\n\nSince Alice's accrued rewards are cleared at Line 391 within the `PirexRewards.claim` function (`p.userStates[user].rewards = 0;`), Alice's accrued rewards will be lost. Alice will have to start accruing the rewards from zero after calling the `PirexRewards.claim` function.\n\nAnother side effect is that since the 1.2 esGMX tokens that belong to Alice are still in the contract, they will be claimed by other users.\n\n### Impact\n\nUsers who deposit too little GMX compared to other users (or total supply of pxGMX), the user will not be able to receive rewards after calling the `PirexRewards.claim` function. Also, their accrued rewards will be cleared out (set to zero). Loss of reward tokens for the users.\n\nAdditionally, the `PirexRewards.claim` function is permissionless, and anyone can trigger the claim on behalf of any user. A malicious user could call the `PirexRewards.claim` function on behalf of a victim at the right time when the victim's accrued reward is small enough to cause a rounding error or precision loss, thus causing the victim accrued reward to be cleared out (set to zero).\n\n### Recommended Mitigation Steps\n\nFollowing are some of the possible remediation actions:\n\n#### 1. Use ` RewardPerToken  ` approach\n\nAvoid calculating the rewards that the users are entitled based on the ratio of `userRewards` and `globalRewards`.\n\nInstead, consider implementing the RewardPerToken for users and global, as seen in many of the well-established reward contracts below, which are not vulnerable to this issue:\n\n*   <https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb81a3dc2e46536bb8af9c2bdc585f63425e/src/FlywheelCore.sol#L226>\n*   <https://github.com/Synthetixio/synthetix/blob/2cb4b23fe409af526de67dfbb84aae84b2b13747/contracts/StakingRewards.sol#L61>\n\n#### 2. Fallback logic if`amount ==  0`\n\nIf the `amount` is zero, revert the transaction. Alternatively, if the `amount` is zero, do not clear out the user's accrued reward state variable since the user did not receive anything yet.\n\n```diff\nfunction claim(ERC20 producerToken, address user) external {\n..SNIP..\n\t\t\tuint256 amount = (rewardState * userRewards) / globalRewards;\n\n\t\t\tif (amount != 0) {\n\t\t\t\t// Update reward state (i.e. amount) to reflect reward tokens transferred out\n\t\t\t\tp.rewardStates[rewardToken] = rewardState - amount;\n\n\t\t\t\tproducer.claimUserReward(\n\t\t\t\t\taddress(rewardToken),\n\t\t\t\t\tamount,\n\t\t\t\t\trecipient\n\t\t\t\t);\n-\t\t\t}\n+\t\t\t} else {\n+\t\t\t\trevert ZeroRewardTokens();\n+\t\t\t}\n..SNIP..\n}\n```\n\n**[kphed (Redacted Cartel) confirmed](https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/184)** \n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-redacted-cartel-contest",
  "Code": [
    {
      "filename": "src/PirexRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {OwnableUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {IProducer} from \"src/interfaces/IProducer.sol\";\nimport {GlobalState, UserState} from \"src/Common.sol\";\n\n/**\n    Originally inspired by Flywheel V2 (thank you Tribe team):\n    https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb8/src/FlywheelCore.sol\n*/\ncontract PirexRewards is OwnableUpgradeable {\n    using SafeTransferLib for ERC20;\n    using SafeCastLib for uint256;\n\n    struct ProducerToken {\n        ERC20[] rewardTokens;\n        GlobalState globalState;\n        mapping(address => UserState) userStates;\n        mapping(ERC20 => uint256) rewardStates;\n        mapping(address => mapping(ERC20 => address)) rewardRecipients;\n    }\n\n    // Pirex contract which produces rewards\n    IProducer public producer;\n\n    // Producer tokens mapped to their data\n    mapping(ERC20 => ProducerToken) public producerTokens;\n\n    event SetProducer(address producer);\n    event SetRewardRecipient(\n        address indexed user,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken,\n        address recipient\n    );\n    event UnsetRewardRecipient(\n        address indexed user,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n    event AddRewardToken(\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n    event RemoveRewardToken(ERC20 indexed producerToken, uint256 removalIndex);\n    event GlobalAccrue(\n        ERC20 indexed producerToken,\n        uint256 lastUpdate,\n        uint256 lastSupply,\n        uint256 rewards\n    );\n    event UserAccrue(\n        ERC20 indexed producerToken,\n        address indexed user,\n        uint256 lastUpdate,\n        uint256 lastBalance,\n        uint256 rewards\n    );\n    event Harvest(\n        ERC20[] producerTokens,\n        ERC20[] rewardTokens,\n        uint256[] rewardAmounts\n    );\n    event Claim(ERC20 indexed producerToken, address indexed user);\n    event SetRewardRecipientPrivileged(\n        address indexed lpContract,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken,\n        address recipient\n    );\n    event UnsetRewardRecipientPrivileged(\n        address indexed lpContract,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n\n    error ZeroAddress();\n    error NotContract();\n    error TokenAlreadyAdded();\n\n    function initialize() public initializer {\n        __Ownable_init();\n    }\n\n    /**\n        @notice Set producer\n        @param  _producer  address  Producer contract address\n     */\n    function setProducer(address _producer) external onlyOwner {\n        if (_producer == address(0)) revert ZeroAddress();\n\n        producer = IProducer(_producer);\n\n        emit SetProducer(_producer);\n    }\n\n    /**\n        @notice Set reward recipient for a reward token\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @param  recipient      address  Rewards recipient\n    */\n    function setRewardRecipient(\n        ERC20 producerToken,\n        ERC20 rewardToken,\n        address recipient\n    ) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n        if (recipient == address(0)) revert ZeroAddress();\n\n        producerTokens[producerToken].rewardRecipients[msg.sender][\n            rewardToken\n        ] = recipient;\n\n        emit SetRewardRecipient(\n            msg.sender,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Unset reward recipient for a reward token\n        @param  producerToken  ERC20  Producer token contract\n        @param  rewardToken    ERC20  Reward token contract\n    */\n    function unsetRewardRecipient(ERC20 producerToken, ERC20 rewardToken)\n        external\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        delete producerTokens[producerToken].rewardRecipients[msg.sender][\n            rewardToken\n        ];\n\n        emit UnsetRewardRecipient(msg.sender, producerToken, rewardToken);\n    }\n\n    /**\n        @notice Add a reward token to a producer token's rewardTokens array\n        @param  producerToken  ERC20  Producer token contract\n        @param  rewardToken    ERC20  Reward token contract\n    */\n    function addRewardToken(ERC20 producerToken, ERC20 rewardToken)\n        external\n        onlyOwner\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        // Check if the token has been added previously for the specified producer\n        ProducerToken storage p = producerTokens[producerToken];\n        ERC20[] memory rewardTokens = p.rewardTokens;\n        uint256 len = rewardTokens.length;\n\n        for (uint256 i; i < len; ++i) {\n            if (address(rewardTokens[i]) == address(rewardToken)) {\n                revert TokenAlreadyAdded();\n            }\n        }\n\n        p.rewardTokens.push(rewardToken);\n\n        emit AddRewardToken(producerToken, rewardToken);\n    }\n\n    /**\n        @notice Remove a reward token from a producer token's rewardTokens array\n        @param  producerToken  ERC20    Producer token contract\n        @param  removalIndex   uint256  Index of the element to be removed\n    */\n    function removeRewardToken(ERC20 producerToken, uint256 removalIndex)\n        external\n        onlyOwner\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n\n        ERC20[] storage rewardTokens = producerTokens[producerToken]\n            .rewardTokens;\n        uint256 lastIndex = rewardTokens.length - 1;\n\n        if (removalIndex != lastIndex) {\n            // Set the element at removalIndex to the last element\n            rewardTokens[removalIndex] = rewardTokens[lastIndex];\n        }\n\n        rewardTokens.pop();\n\n        emit RemoveRewardToken(producerToken, removalIndex);\n    }\n\n    /**\n        @notice Getter for a producer token's UserState struct member values\n        @param  producerToken  ERC20    Producer token contract\n        @param  user           address  User\n        @return lastUpdate     uint256  Last update\n        @return lastBalance    uint256  Last balance\n        @return rewards        uint256  Rewards\n    */\n    function getUserState(ERC20 producerToken, address user)\n        external\n        view\n        returns (\n            uint256 lastUpdate,\n            uint256 lastBalance,\n            uint256 rewards\n        )\n    {\n        UserState memory userState = producerTokens[producerToken].userStates[\n            user\n        ];\n\n        return (userState.lastUpdate, userState.lastBalance, userState.rewards);\n    }\n\n    /**\n        @notice Getter for a producer token's accrued amount for a reward token\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @return                uint256  Reward state\n    */\n    function getRewardState(ERC20 producerToken, ERC20 rewardToken)\n        external\n        view\n        returns (uint256)\n    {\n        return producerTokens[producerToken].rewardStates[rewardToken];\n    }\n\n    /**\n        @notice Getter for a producer token's reward tokens\n        @param  producerToken  ERC20    Producer token contract\n        @return                ERC20[]  Reward token contracts\n    */\n    function getRewardTokens(ERC20 producerToken)\n        external\n        view\n        returns (ERC20[] memory)\n    {\n        return producerTokens[producerToken].rewardTokens;\n    }\n\n    /**\n        @notice Get the reward recipient for a user by producer and reward token\n        @param  user           address  User\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @return                address  Reward recipient\n    */\n    function getRewardRecipient(\n        address user,\n        ERC20 producerToken,\n        ERC20 rewardToken\n    ) external view returns (address) {\n        return\n            producerTokens[producerToken].rewardRecipients[user][rewardToken];\n    }\n\n    /**\n        @notice Update global rewards accrual state\n        @param  producerToken  ERC20  Rewards-producing token\n    */\n    function globalAccrue(ERC20 producerToken) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n\n        _globalAccrue(producerTokens[producerToken].globalState, producerToken);\n    }\n\n    /**\n        @notice Update user rewards accrual state\n        @param  producerToken  ERC20    Rewards-producing token\n        @param  user           address  User address\n    */\n    function userAccrue(ERC20 producerToken, address user) public {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (user == address(0)) revert ZeroAddress();\n\n        UserState storage u = producerTokens[producerToken].userStates[user];\n        uint256 balance = producerToken.balanceOf(user);\n\n        // Calculate the amount of rewards accrued by the user up to this call\n        uint256 rewards = u.rewards +\n            u.lastBalance *\n            (block.timestamp - u.lastUpdate);\n\n        u.lastUpdate = block.timestamp.safeCastTo32();\n        u.lastBalance = balance.safeCastTo224();\n        u.rewards = rewards;\n\n        emit UserAccrue(producerToken, user, block.timestamp, balance, rewards);\n    }\n\n    /**\n        @notice Update global accrual state\n        @param  globalState    GlobalState  Global state of the producer token\n        @param  producerToken  ERC20        Producer token contract\n    */\n    function _globalAccrue(GlobalState storage globalState, ERC20 producerToken)\n        internal\n    {\n        uint256 totalSupply = producerToken.totalSupply();\n        uint256 lastUpdate = globalState.lastUpdate;\n        uint256 lastSupply = globalState.lastSupply;\n\n        // Calculate rewards, the product of seconds elapsed and last supply\n        // Only calculate and update states when needed\n        if (block.timestamp != lastUpdate || totalSupply != lastSupply) {\n            uint256 rewards = globalState.rewards +\n                (block.timestamp - lastUpdate) *\n                lastSupply;\n\n            globalState.lastUpdate = block.timestamp.safeCastTo32();\n            globalState.lastSupply = totalSupply.safeCastTo224();\n            globalState.rewards = rewards;\n\n            emit GlobalAccrue(\n                producerToken,\n                block.timestamp,\n                totalSupply,\n                rewards\n            );\n        }\n    }\n\n    /**\n        @notice Harvest rewards\n        @return _producerTokens  ERC20[]  Producer token contracts\n        @return rewardTokens     ERC20[]  Reward token contracts\n        @return rewardAmounts    ERC20[]  Reward token amounts\n    */\n    function harvest()\n        public\n        returns (\n            ERC20[] memory _producerTokens,\n            ERC20[] memory rewardTokens,\n            uint256[] memory rewardAmounts\n        )\n    {\n        (_producerTokens, rewardTokens, rewardAmounts) = producer\n            .claimRewards();\n        uint256 pLen = _producerTokens.length;\n\n        // Iterate over the producer tokens and update reward state\n        for (uint256 i; i < pLen; ++i) {\n            ERC20 p = _producerTokens[i];\n            uint256 r = rewardAmounts[i];\n\n            // Update global reward accrual state and associate with the update of reward state\n            ProducerToken storage producerState = producerTokens[p];\n\n            _globalAccrue(producerState.globalState, p);\n\n            if (r != 0) {\n                producerState.rewardStates[rewardTokens[i]] += r;\n            }\n        }\n\n        emit Harvest(_producerTokens, rewardTokens, rewardAmounts);\n    }\n\n    /**\n        @notice Claim rewards\n        @param  producerToken  ERC20    Producer token contract\n        @param  user           address  User\n    */\n    function claim(ERC20 producerToken, address user) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (user == address(0)) revert ZeroAddress();\n\n        harvest();\n        userAccrue(producerToken, user);\n\n        ProducerToken storage p = producerTokens[producerToken];\n        uint256 globalRewards = p.globalState.rewards;\n        uint256 userRewards = p.userStates[user].rewards;\n\n        // Claim should be skipped and not reverted on zero global/user reward\n        if (globalRewards != 0 && userRewards != 0) {\n            ERC20[] memory rewardTokens = p.rewardTokens;\n            uint256 rLen = rewardTokens.length;\n\n            // Update global and user reward states to reflect the claim\n            p.globalState.rewards = globalRewards - userRewards;\n            p.userStates[user].rewards = 0;\n\n            emit Claim(producerToken, user);\n\n            // Transfer the proportionate reward token amounts to the recipient\n            for (uint256 i; i < rLen; ++i) {\n                ERC20 rewardToken = rewardTokens[i];\n                address rewardRecipient = p.rewardRecipients[user][rewardToken];\n                address recipient = rewardRecipient != address(0)\n                    ? rewardRecipient\n                    : user;\n                uint256 rewardState = p.rewardStates[rewardToken];\n                uint256 amount = (rewardState * userRewards) / globalRewards;\n\n                if (amount != 0) {\n                    // Update reward state (i.e. amount) to reflect reward tokens transferred out\n                    p.rewardStates[rewardToken] = rewardState - amount;\n\n                    producer.claimUserReward(\n                        address(rewardToken),\n                        amount,\n                        recipient\n                    );\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    ⚠️ NOTABLE PRIVILEGED METHODS ⚠️\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Privileged method for setting the reward recipient of a contract\n        @notice This should ONLY be used to forward rewards for Pirex-GMX LP contracts\n        @notice In production, we will have a 2nd multisig which reduces risk of abuse\n        @param  lpContract     address  Pirex-GMX LP contract\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @param  recipient      address  Rewards recipient\n    */\n    function setRewardRecipientPrivileged(\n        address lpContract,\n        ERC20 producerToken,\n        ERC20 rewardToken,\n        address recipient\n    ) external onlyOwner {\n        if (lpContract.code.length == 0) revert NotContract();\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n        if (recipient == address(0)) revert ZeroAddress();\n\n        producerTokens[producerToken].rewardRecipients[lpContract][\n            rewardToken\n        ] = recipient;\n\n        emit SetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Privileged method for unsetting the reward recipient of a contract\n        @param  lpContract     address  Pirex-GMX LP contract\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n    */\n    function unsetRewardRecipientPrivileged(\n        address lpContract,\n        ERC20 producerToken,\n        ERC20 rewardToken\n    ) external onlyOwner {\n        if (lpContract.code.length == 0) revert NotContract();\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        delete producerTokens[producerToken].rewardRecipients[lpContract][\n            rewardToken\n        ];\n\n        emit UnsetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken\n        );\n    }\n}"
    },
    {
      "filename": "src/FlywheelCore.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\n\nimport {IFlywheelRewards} from \"./interfaces/IFlywheelRewards.sol\";\nimport {IFlywheelBooster} from \"./interfaces/IFlywheelBooster.sol\";\n\n/**\n @title Flywheel Core Incentives Manager\n @notice Flywheel is a general framework for managing token incentives.\n         It takes reward streams to various *strategies* such as staking LP tokens and divides them among *users* of those strategies.\n\n         The Core contract maintaings three important pieces of state:\n         * the rewards index which determines how many rewards are owed per token per strategy. User indexes track how far behind the strategy they are to lazily calculate all catch-up rewards.\n         * the accrued (unclaimed) rewards per user.\n         * references to the booster and rewards module described below.\n\n         Core does not manage any tokens directly. The rewards module maintains token balances, and approves core to pull transfer them to users when they claim.\n\n         SECURITY NOTE: For maximum accuracy and to avoid exploits, rewards accrual should be notified atomically through the accrue hook. \n         Accrue should be called any time tokens are transferred, minted, or burned.\n */\ncontract FlywheelCore is Auth {\n    using SafeTransferLib for ERC20;\n    using SafeCastLib for uint256;\n\n    /// @notice The token to reward\n    ERC20 public immutable rewardToken;\n\n    /// @notice append-only list of strategies added\n    ERC20[] public allStrategies;\n\n    /// @notice the rewards contract for managing streams\n    IFlywheelRewards public flywheelRewards;\n\n    /// @notice optional booster module for calculating virtual balances on strategies\n    IFlywheelBooster public flywheelBooster;\n\n    constructor(\n        ERC20 _rewardToken,\n        IFlywheelRewards _flywheelRewards,\n        IFlywheelBooster _flywheelBooster,\n        address _owner,\n        Authority _authority\n    ) Auth(_owner, _authority) {\n        rewardToken = _rewardToken;\n        flywheelRewards = _flywheelRewards;\n        flywheelBooster = _flywheelBooster;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ACCRUE/CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /** \n      @notice Emitted when a user's rewards accrue to a given strategy.\n      @param strategy the updated rewards strategy\n      @param user the user of the rewards\n      @param rewardsDelta how many new rewards accrued to the user\n      @param rewardsIndex the market index for rewards per token accrued\n    */\n    event AccrueRewards(ERC20 indexed strategy, address indexed user, uint256 rewardsDelta, uint256 rewardsIndex);\n\n    /** \n      @notice Emitted when a user claims accrued rewards.\n      @param user the user of the rewards\n      @param amount the amount of rewards claimed\n    */\n    event ClaimRewards(address indexed user, uint256 amount);\n\n    /// @notice The accrued but not yet transferred rewards for each user\n    mapping(address => uint256) public rewardsAccrued;\n\n    /** \n      @notice accrue rewards for a single user on a strategy\n      @param strategy the strategy to accrue a user's rewards on\n      @param user the user to be accrued\n      @return the cumulative amount of rewards accrued to user (including prior)\n    */\n    function accrue(ERC20 strategy, address user) public returns (uint256) {\n        RewardsState memory state = strategyState[strategy];\n\n        if (state.index == 0) return 0;\n\n        state = accrueStrategy(strategy, state);\n        return accrueUser(strategy, user, state);\n    }\n\n    /** \n      @notice accrue rewards for a two users on a strategy\n      @param strategy the strategy to accrue a user's rewards on\n      @param user the first user to be accrued\n      @param user the second user to be accrued\n      @return the cumulative amount of rewards accrued to the first user (including prior)\n      @return the cumulative amount of rewards accrued to the second user (including prior)\n    */\n    function accrue(\n        ERC20 strategy,\n        address user,\n        address secondUser\n    ) public returns (uint256, uint256) {\n        RewardsState memory state = strategyState[strategy];\n\n        if (state.index == 0) return (0, 0);\n\n        state = accrueStrategy(strategy, state);\n        return (accrueUser(strategy, user, state), accrueUser(strategy, secondUser, state));\n    }\n\n    /** \n      @notice claim rewards for a given user\n      @param user the user claiming rewards\n      @dev this function is public, and all rewards transfer to the user\n    */\n    function claimRewards(address user) external {\n        uint256 accrued = rewardsAccrued[user];\n\n        if (accrued != 0) {\n            rewardsAccrued[user] = 0;\n\n            rewardToken.safeTransferFrom(address(flywheelRewards), user, accrued);\n\n            emit ClaimRewards(user, accrued);\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                          ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /** \n      @notice Emitted when a new strategy is added to flywheel by the admin\n      @param newStrategy the new added strategy\n    */\n    event AddStrategy(address indexed newStrategy);\n\n    /// @notice initialize a new strategy\n    function addStrategyForRewards(ERC20 strategy) external requiresAuth {\n        _addStrategyForRewards(strategy);\n    }\n\n    function _addStrategyForRewards(ERC20 strategy) internal {\n        require(strategyState[strategy].index == 0, \"strategy\");\n        strategyState[strategy] = RewardsState({index: ONE, lastUpdatedTimestamp: block.timestamp.safeCastTo32()});\n\n        allStrategies.push(strategy);\n        emit AddStrategy(address(strategy));\n    }\n\n    function getAllStrategies() external view returns (ERC20[] memory) {\n        return allStrategies;\n    }\n\n    /** \n      @notice Emitted when the rewards module changes\n      @param newFlywheelRewards the new rewards module\n    */\n    event FlywheelRewardsUpdate(address indexed newFlywheelRewards);\n\n    /// @notice swap out the flywheel rewards contract\n    function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external requiresAuth {\n        uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));\n        if (oldRewardBalance > 0) {\n            rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);\n        }\n\n        flywheelRewards = newFlywheelRewards;\n\n        emit FlywheelRewardsUpdate(address(newFlywheelRewards));\n    }\n\n    /** \n      @notice Emitted when the booster module changes\n      @param newBooster the new booster module\n    */\n    event FlywheelBoosterUpdate(address indexed newBooster);\n\n    /// @notice swap out the flywheel booster contract\n    function setBooster(IFlywheelBooster newBooster) external requiresAuth {\n        flywheelBooster = newBooster;\n\n        emit FlywheelBoosterUpdate(address(newBooster));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INTERNAL ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    struct RewardsState {\n        /// @notice The strategy's last updated index\n        uint224 index;\n        /// @notice The timestamp the index was last updated at\n        uint32 lastUpdatedTimestamp;\n    }\n\n    /// @notice the fixed point factor of flywheel\n    uint224 public constant ONE = 1e18;\n\n    /// @notice The strategy index and last updated per strategy\n    mapping(ERC20 => RewardsState) public strategyState;\n\n    /// @notice user index per strategy\n    mapping(ERC20 => mapping(address => uint224)) public userIndex;\n\n    /// @notice accumulate global rewards on a strategy\n    function accrueStrategy(ERC20 strategy, RewardsState memory state)\n        private\n        returns (RewardsState memory rewardsState)\n    {\n        // calculate accrued rewards through module\n        uint256 strategyRewardsAccrued = flywheelRewards.getAccruedRewards(strategy, state.lastUpdatedTimestamp);\n\n        rewardsState = state;\n        if (strategyRewardsAccrued > 0) {\n            // use the booster or token supply to calculate reward index denominator\n            uint256 supplyTokens = address(flywheelBooster) != address(0)\n                ? flywheelBooster.boostedTotalSupply(strategy)\n                : strategy.totalSupply();\n\n            uint224 deltaIndex;\n\n            if (supplyTokens != 0) deltaIndex = ((strategyRewardsAccrued * ONE) / supplyTokens).safeCastTo224();\n\n            // accumulate rewards per token onto the index, multiplied by fixed-point factor\n            rewardsState = RewardsState({\n                index: state.index + deltaIndex,\n                lastUpdatedTimestamp: block.timestamp.safeCastTo32()\n            });\n            strategyState[strategy] = rewardsState;\n        }\n    }\n\n    /// @notice accumulate rewards on a strategy for a specific user\n    function accrueUser(\n        ERC20 strategy,\n        address user,\n        RewardsState memory state\n    ) private returns (uint256) {\n        // load indices\n        uint224 strategyIndex = state.index;\n        uint224 supplierIndex = userIndex[strategy][user];\n\n        // sync user index to global\n        userIndex[strategy][user] = strategyIndex;\n\n        // if user hasn't yet accrued rewards, grant them interest from the strategy beginning if they have a balance\n        // zero balances will have no effect other than syncing to global index\n        if (supplierIndex == 0) {\n            supplierIndex = ONE;\n        }\n\n        uint224 deltaIndex = strategyIndex - supplierIndex;\n        // use the booster or token balance to calculate reward balance multiplier\n        uint256 supplierTokens = address(flywheelBooster) != address(0)\n            ? flywheelBooster.boostedBalanceOf(strategy, user)\n            : strategy.balanceOf(user);\n\n        // accumulate rewards by multiplying user tokens by rewardsPerToken index and adding on unclaimed\n        uint256 supplierDelta = (supplierTokens * deltaIndex) / ONE;\n        uint256 supplierAccrued = rewardsAccrued[user] + supplierDelta;\n\n        rewardsAccrued[user] = supplierAccrued;\n\n        emit AccrueRewards(strategy, user, supplierDelta, strategyIndex);\n\n        return supplierAccrued;\n    }\n}"
    },
    {
      "filename": "contracts/StakingRewards.sol",
      "content": "pragma solidity ^0.5.16;\n\nimport \"openzeppelin-solidity-2.3.0/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity-2.3.0/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"openzeppelin-solidity-2.3.0/contracts/token/ERC20/SafeERC20.sol\";\nimport \"openzeppelin-solidity-2.3.0/contracts/utils/ReentrancyGuard.sol\";\n\n// Inheritance\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./RewardsDistributionRecipient.sol\";\nimport \"./Pausable.sol\";\n\n// https://docs.synthetix.io/contracts/source/contracts/stakingrewards\ncontract StakingRewards is IStakingRewards, RewardsDistributionRecipient, ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC20 public rewardsToken;\n    IERC20 public stakingToken;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 7 days;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        address _rewardsDistribution,\n        address _rewardsToken,\n        address _stakingToken\n    ) public Owned(_owner) {\n        rewardsToken = IERC20(_rewardsToken);\n        stakingToken = IERC20(_stakingToken);\n        rewardsDistribution = _rewardsDistribution;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n    }\n\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function stake(uint256 amount) external nonReentrant notPaused updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) public nonReentrant updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution updateReward(address(0)) {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint balance = rewardsToken.balanceOf(address(this));\n        require(rewardRate <= balance.div(rewardsDuration), \"Provided reward too high\");\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(rewardsDuration);\n        emit RewardAdded(reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        require(tokenAddress != address(stakingToken), \"Cannot withdraw the staking token\");\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(\n            block.timestamp > periodFinish,"
    }
  ]
}