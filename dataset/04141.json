{
  "Title": "[M06] Unsafe casting",
  "Content": "In [line 554 of the `TaxCollector`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/TaxCollector.sol#L554) contract, the value of [`coinBalance(receiver)` is an `uint`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/SAFEEngine.sol#L103). This is cast to an `int` and then negated. However, since `uint` can store higher values than `int`, it is possible that casting from `uint` to `int` may create an overflow.\n\n\nConsider verifying that the value of `coinBalance(receiver)` is within the acceptable range for negative `int` values before casting and negating. Consider using OpenZeppelinâ€™s [`SafeCast`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.2.0/contracts/utils/SafeCast.sol) contract, which provides functions for safely casting between types.\n\n\n***Update:** Fixed in [pull request #76.](https://github.com/reflexer-labs/geb/pull/76/commits/3bd01713bc0497e77741b13694199529639a2d59)*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/TaxCollector.sol",
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nimport \"./LinkedList.sol\";\n\nabstract contract SAFEEngineLike {\n    function collateralTypes(bytes32) virtual public view returns (\n        uint256 debtAmount,       // [wad]\n        uint256 accumulatedRate   // [ray]\n    );\n    function updateAccumulatedRate(bytes32,address,int) virtual external;\n    function coinBalance(address) virtual public view returns (uint);\n}\n\ncontract TaxCollector {\n    using LinkedList for LinkedList.List;\n\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"TaxCollector/account-not-authorized\");\n        _;\n    }\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event InitializeCollateralType(bytes32 collateralType);\n    event ModifyParameters(\n      bytes32 collateralType,\n      bytes32 parameter,\n      uint data\n    );\n    event ModifyParameters(bytes32 parameter, uint data);\n    event ModifyParameters(bytes32 parameter, address data);\n    event ModifyParameters(\n      bytes32 collateralType,\n      uint256 position,\n      uint256 val\n    );\n    event ModifyParameters(\n      bytes32 collateralType,\n      uint256 position,\n      uint256 taxPercentage,\n      address receiverAccount\n    );\n    event AddSecondaryReceiver(\n      bytes32 collateralType,\n      uint secondaryReceiverNonce,\n      uint latestSecondaryReceiver,\n      uint secondaryReceiverAllotedTax,\n      uint secondaryReceiverRevenueSources\n    );\n    event ModifySecondaryReceiver(\n      bytes32 collateralType,\n      uint secondaryReceiverNonce,\n      uint latestSecondaryReceiver,\n      uint secondaryReceiverAllotedTax,\n      uint secondaryReceiverRevenueSources\n    );\n    event CollectTax(bytes32 collateralType, uint latestAccumulatedRate, int deltaRate);\n    event DistributeTax(bytes32 collateralType, address target, int taxCut);\n\n    // --- Data ---\n    struct CollateralType {\n        // Per second borrow rate for this specific collateral type\n        uint256 stabilityFee;\n        // When SF was last collected for this collateral type\n        uint256 updateTime;\n    }\n    // SF receiver\n    struct TaxReceiver {\n        // Whether this receiver can accept a negative rate (taking SF from it)\n        uint256 canTakeBackTax;                                                 // [bool]\n        // Percentage of SF allocated to this receiver\n        uint256 taxPercentage;                                                  // [ray%]\n    }\n\n    // Data about each collateral type\n    mapping (bytes32 => CollateralType)                  public collateralTypes;\n    // Percentage of each collateral's SF that goes to other addresses apart from the primary receiver\n    mapping (bytes32 => uint)                            public secondaryReceiverAllotedTax;              // [%ray]\n    // Whether an address is already used for a tax receiver\n    mapping (address => uint256)                         public usedSecondaryReceiver;                    // [bool]\n    // Address associated to each tax receiver index\n    mapping (uint256 => address)                         public secondaryReceiverAccounts;\n    // How many collateral types send SF to a specific tax receiver\n    mapping (address => uint256)                         public secondaryReceiverRevenueSources;\n    // Tax receiver data\n    mapping (bytes32 => mapping(uint256 => TaxReceiver)) public secondaryTaxReceivers;\n\n    address    public primaryTaxReceiver;\n    // Base stability fee charged to all collateral types\n    uint256    public globalStabilityFee;                                                                 // [ray%]\n    // Number of secondary tax receivers ever added\n    uint256    public secondaryReceiverNonce;\n    // Max number of secondarytax receivers a collateral type can have\n    uint256    public maxSecondaryReceivers;\n    // Latest secondary tax receiver that still has at least one revenue source\n    uint256    public latestSecondaryReceiver;\n\n    // All collateral types\n    bytes32[]        public   collateralList;\n    // Linked list with tax receiver data\n    LinkedList.List  internal secondaryReceiverList;\n\n    SAFEEngineLike public safeEngine;\n\n    // --- Init ---\n    constructor(address safeEngine_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine = SAFEEngineLike(safeEngine_);\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function rpow(uint x, uint n, uint b) internal pure returns (uint z) {\n      assembly {\n        switch x case 0 {switch n case 0 {z := b} default {z := 0}}\n        default {\n          switch mod(n, 2) case 0 { z := b } default { z := x }\n          let half := div(b, 2)  // for rounding.\n          for { n := div(n, 2) } n { n := div(n,2) } {\n            let xx := mul(x, x)\n            if iszero(eq(div(xx, x), x)) { revert(0,0) }\n            let xxRound := add(xx, half)\n            if lt(xxRound, xx) { revert(0,0) }\n            x := div(xxRound, b)\n            if mod(n,2) {\n              let zx := mul(z, x)\n              if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n              let zxRound := add(zx, half)\n              if lt(zxRound, zx) { revert(0,0) }\n              z := div(zxRound, b)\n            }\n          }\n        }\n      }\n    }\n    uint256 constant RAY     = 10 ** 27;\n    uint256 constant HUNDRED = 10 ** 29;\n    uint256 constant ONE     = 1;\n\n    function addition(uint x, uint y) internal pure returns (uint z) {\n        z = x + y;\n        require(z >= x);\n    }\n    function addition(int x, int y) internal pure returns (int z) {\n        z = x + y;\n        if (y <= 0) require(z <= x);\n        if (y  > 0) require(z > x);\n    }\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function subtract(int x, int y) internal pure returns (int z) {\n        z = x - y;\n        require(y <= 0 || z <= x);\n        require(y >= 0 || z >= x);\n    }\n    function deduct(uint x, uint y) internal pure returns (int z) {\n        z = int(x) - int(y);\n        require(int(x) >= 0 && int(y) >= 0);\n    }\n    function multiply(uint x, int y) internal pure returns (int z) {\n        z = int(x) * y;\n        require(int(x) >= 0);\n        require(y == 0 || z / y == int(x));\n    }\n    function multiply(int x, int y) internal pure returns (int z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function rmultiply(uint x, uint y) internal pure returns (uint z) {\n        z = x * y;\n        require(y == 0 || z / y == x);\n        z = z / RAY;\n    }\n\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n\n    // --- Administration ---\n    /**\n     * @notice Initialize a brand new collateral type\n     * @param collateralType Collateral type name (e.g ETH-A, TBTC-B)\n     */\n    function initializeCollateralType(bytes32 collateralType) external isAuthorized {\n        CollateralType storage collateralType_ = collateralTypes[collateralType];\n        require(collateralType_.stabilityFee == 0, \"TaxCollector/collateral-type-already-init\");\n        collateralType_.stabilityFee = RAY;\n        collateralType_.updateTime   = now;\n        collateralList.push(collateralType);\n        emit InitializeCollateralType(collateralType);\n    }\n    /**\n     * @notice Modify collateral specific uint params\n     * @param collateralType Collateral type who's parameter is modified\n     * @param parameter The name of the parameter modified\n     * @param data New value for the parameter\n     */\n    function modifyParameters(\n        bytes32 collateralType,\n        bytes32 parameter,\n        uint data\n    ) external isAuthorized {\n        require(now == collateralTypes[collateralType].updateTime, \"TaxCollector/update-time-not-now\");\n        if (parameter == \"stabilityFee\") collateralTypes[collateralType].stabilityFee = data;\n        else revert(\"TaxCollector/modify-unrecognized-param\");\n        emit ModifyParameters(\n          collateralType,\n          parameter,\n          data\n        );\n    }\n    /**\n     * @notice Modify general uint params\n     * @param parameter The name of the parameter modified\n     * @param data New value for the parameter\n     */\n    function modifyParameters(bytes32 parameter, uint data) external isAuthorized {\n        if (parameter == \"globalStabilityFee\") globalStabilityFee = data;\n        else if (parameter == \"maxSecondaryReceivers\") maxSecondaryReceivers = data;\n        else revert(\"TaxCollector/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /**\n     * @notice Modify general address params\n     * @param parameter The name of the parameter modified\n     * @param data New value for the parameter\n     */\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        require(data != address(0), \"TaxCollector/null-data\");\n        if (parameter == \"primaryTaxReceiver\") primaryTaxReceiver = data;\n        else revert(\"TaxCollector/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /**\n     * @notice Set whether a tax receiver can incur negative fees\n     * @param collateralType Collateral type giving fees to the tax receiver\n     * @param position Receiver position in the list\n     * @param val Value that specifies whether a tax receiver can incur negative rates\n     */\n    function modifyParameters(\n        bytes32 collateralType,\n        uint256 position,\n        uint256 val\n    ) external isAuthorized {\n        if (both(secondaryReceiverList.isNode(position), secondaryTaxReceivers[collateralType][position].taxPercentage > 0)) {\n            secondaryTaxReceivers[collateralType][position].canTakeBackTax = val;\n        }\n        else revert(\"TaxCollector/unknown-tax-receiver\");\n        emit ModifyParameters(\n          collateralType,\n          position,\n          val\n        );\n    }\n    /**\n     * @notice Create or modify a secondary tax receiver's data\n     * @param collateralType Collateral type that will give SF to the tax receiver\n     * @param position Receiver position in the list. Used to determine whether a new tax receiver is\n              created or an existing one is edited\n     * @param taxPercentage Percentage of SF offered to the tax receiver\n     * @param receiverAccount Receiver address\n     */\n    function modifyParameters(\n      bytes32 collateralType,\n      uint256 position,\n      uint256 taxPercentage,\n      address receiverAccount\n    ) external isAuthorized {\n        (!secondaryReceiverList.isNode(position)) ?\n          addSecondaryReceiver(collateralType, taxPercentage, receiverAccount) :\n          modifySecondaryReceiver(collateralType, position, taxPercentage);\n        emit ModifyParameters(\n          collateralType,\n          position,\n          taxPercentage,\n          receiverAccount\n        );\n    }\n\n    // --- Tax Receiver Utils ---\n    /**\n     * @notice Add a new secondary tax receiver\n     * @param collateralType Collateral type that will give SF to the tax receiver\n     * @param taxPercentage Percentage of SF offered to the tax receiver\n     * @param receiverAccount Tax receiver address\n     */\n    function addSecondaryReceiver(bytes32 collateralType, uint256 taxPercentage, address receiverAccount) internal {\n        require(receiverAccount != address(0), \"TaxCollector/null-account\");\n        require(receiverAccount != primaryTaxReceiver, \"TaxCollector/primary-receiver-cannot-be-secondary\");\n        require(taxPercentage > 0, \"TaxCollector/null-sf\");\n        require(usedSecondaryReceiver[receiverAccount] == 0, \"TaxCollector/account-already-used\");\n        require(addition(secondaryReceiversAmount(), ONE) <= maxSecondaryReceivers, \"TaxCollector/exceeds-max-receiver-limit\");\n        require(addition(secondaryReceiverAllotedTax[collateralType], taxPercentage) < HUNDRED, \"TaxCollector/tax-cut-exceeds-hundred\");\n        secondaryReceiverNonce                                                       = addition(secondaryReceiverNonce, 1);\n        latestSecondaryReceiver                                                      = secondaryReceiverNonce;\n        usedSecondaryReceiver[receiverAccount]                                       = ONE;\n        secondaryReceiverAllotedTax[collateralType]                                  = addition(secondaryReceiverAllotedTax[collateralType], taxPercentage);\n        secondaryTaxReceivers[collateralType][latestSecondaryReceiver].taxPercentage = taxPercentage;\n        secondaryReceiverAccounts[latestSecondaryReceiver]                           = receiverAccount;\n        secondaryReceiverRevenueSources[receiverAccount]                             = ONE;\n        secondaryReceiverList.push(latestSecondaryReceiver, false);\n        emit AddSecondaryReceiver(\n          collateralType,\n          secondaryReceiverNonce,\n          latestSecondaryReceiver,\n          secondaryReceiverAllotedTax[collateralType],\n          secondaryReceiverRevenueSources[receiverAccount]\n        );\n    }\n    /**\n     * @notice Update a secondary tax receiver's data (add a new SF source or modify % of SF taken from a collateral type)\n     * @param collateralType Collateral type that will give SF to the tax receiver\n     * @param position Receiver's position in the tax receiver list\n     * @param taxPercentage Percentage of SF offered to the tax receiver (ray%)\n     */\n    function modifySecondaryReceiver(bytes32 collateralType, uint256 position, uint256 taxPercentage) internal {\n        if (taxPercentage == 0) {\n          secondaryReceiverAllotedTax[collateralType] = subtract(\n            secondaryReceiverAllotedTax[collateralType],\n            secondaryTaxReceivers[collateralType][position].taxPercentage\n          );\n\n          if (secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]] == 1) {\n            if (position == latestSecondaryReceiver) {\n              (, uint256 prevReceiver) = secondaryReceiverList.prev(latestSecondaryReceiver);\n              latestSecondaryReceiver = prevReceiver;\n            }\n            secondaryReceiverList.del(position);\n            delete(usedSecondaryReceiver[secondaryReceiverAccounts[position]]);\n            delete(secondaryTaxReceivers[collateralType][position]);\n            delete(secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]]);\n            delete(secondaryReceiverAccounts[position]);\n          } else if (secondaryTaxReceivers[collateralType][position].taxPercentage > 0) {\n            secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]] = subtract(secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]], 1);\n            delete(secondaryTaxReceivers[collateralType][position]);\n          }\n        } else {\n          uint256 secondaryReceiverAllotedTax_ = addition(\n            subtract(secondaryReceiverAllotedTax[collateralType], secondaryTaxReceivers[collateralType][position].taxPercentage),\n            taxPercentage\n          );\n          require(secondaryReceiverAllotedTax_ < HUNDRED, \"TaxCollector/tax-cut-too-big\");\n          if (secondaryTaxReceivers[collateralType][position].taxPercentage == 0) {\n            secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]] = addition(\n              secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]],\n              1\n            );\n          }\n          secondaryReceiverAllotedTax[collateralType]                   = secondaryReceiverAllotedTax_;\n          secondaryTaxReceivers[collateralType][position].taxPercentage = taxPercentage;\n        }\n        emit ModifySecondaryReceiver(\n          collateralType,\n          secondaryReceiverNonce,\n          latestSecondaryReceiver,\n          secondaryReceiverAllotedTax[collateralType],\n          secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]]\n        );\n    }\n\n    // --- Tax Collection Utils ---\n    /**\n     * @notice Check if multiple collateral types are up to date with taxation\n     */\n    function collectedManyTax(uint start, uint end) public view returns (bool ok) {\n        require(both(start <= end, end < collateralList.length), \"TaxCollector/invalid-indexes\");\n        for (uint i = start; i <= end; i++) {\n          if (now > collateralTypes[collateralList[i]].updateTime) {\n            ok = false;\n            return ok;\n          }\n        }\n        ok = true;\n    }\n    /**\n     * @notice Check how much SF will be charged (to collateral types between indexes 'start' and 'end'\n     *         in the collateralList) during the next taxation\n     * @param start Index in collateralList from which to start looping and calculating the tax outcome\n     * @param end Index in collateralList at which we stop looping and calculating the tax outcome\n     */\n    function taxManyOutcome(uint start, uint end) public view returns (bool ok, int rad) {\n        require(both(start <= end, end < collateralList.length), \"TaxCollector/invalid-indexes\");\n        int  primaryReceiverBalance = -int(safeEngine.coinBalance(primaryTaxReceiver));\n        int  deltaRate;\n        uint debtAmount;\n        for (uint i = start; i <= end; i++) {\n          if (now > collateralTypes[collateralList[i]].updateTime) {\n            (debtAmount, ) = safeEngine.collateralTypes(collateralList[i]);\n            (, deltaRate)  = taxSingleOutcome(collateralList[i]);\n            rad = addition(rad, multiply(debtAmount, deltaRate));\n          }\n        }\n        if (rad < 0) {\n          ok = (rad < primaryReceiverBalance) ? false : true;\n        } else {\n          ok = true;\n        }\n    }\n    /**\n     * @notice Get how much SF will be distributed after taxing a specific collateral type\n     * @param collateralType Collateral type to compute the taxation outcome for\n     */\n    function taxSingleOutcome(bytes32 collateralType) public view returns (uint, int) {\n        (, uint lastAccumulatedRate) = safeEngine.collateralTypes(collateralType);\n        uint newlyAccumulatedRate =\n          rmultiply(\n            rpow(\n              addition(\n                globalStabilityFee,\n                collateralTypes[collateralType].stabilityFee\n              ),\n              subtract(\n                now,\n                collateralTypes[collateralType].updateTime\n              ),\n            RAY),\n          lastAccumulatedRate);\n        return (newlyAccumulatedRate, deduct(newlyAccumulatedRate, lastAccumulatedRate));\n    }\n\n    // --- Tax Receiver Utils ---\n    /**\n     * @notice Get the secondary tax receiver list length\n     */\n    function secondaryReceiversAmount() public view returns (uint) {\n        return secondaryReceiverList.range();\n    }\n    /**\n     * @notice Get the collateralList length\n     */\n    function collateralListLength() public view returns (uint) {\n        return collateralList.length;\n    }\n    /**\n     * @notice Check if a tax receiver is at a certain position in the list\n     */\n    function isSecondaryReceiver(uint256 _receiver) public view returns (bool) {\n        if (_receiver == 0) return false;\n        return secondaryReceiverList.isNode(_receiver);\n    }\n\n    // --- Tax (Stability Fee) Collection ---\n    /**\n     * @notice Collect tax from multiple collateral types at once\n     * @param start Index in collateralList from which to start looping and calculating the tax outcome\n     * @param end Index in collateralList at which we stop looping and calculating the tax outcome\n     */\n    function taxMany(uint start, uint end) external {\n        require(both(start <= end, end < collateralList.length), \"TaxCollector/invalid-indexes\");\n        for (uint i = start; i <= end; i++) {\n            taxSingle(collateralList[i]);\n        }\n    }\n    /**\n     * @notice Collect tax from a single collateral type\n     * @param collateralType Collateral type to tax\n     */\n    function taxSingle(bytes32 collateralType) public returns (uint) {\n        uint latestAccumulatedRate;\n        if (now <= collateralTypes[collateralType].updateTime) {\n          (, latestAccumulatedRate) = safeEngine.collateralTypes(collateralType);\n          return latestAccumulatedRate;\n        }\n        (, int deltaRate) = taxSingleOutcome(collateralType);\n        // Check how much debt has been generated for collateralType\n        (uint debtAmount, ) = safeEngine.collateralTypes(collateralType);\n        splitTaxIncome(collateralType, debtAmount, deltaRate);\n        (, latestAccumulatedRate) = safeEngine.collateralTypes(collateralType);\n        collateralTypes[collateralType].updateTime = now;\n        emit CollectTax(collateralType, latestAccumulatedRate, deltaRate);\n        return latestAccumulatedRate;\n    }\n    /**\n     * @notice Split SF between all tax receivers\n     * @param collateralType Collateral type to distribute SF for\n     * @param deltaRate Difference between the last and the latest accumulate rates for the collateralType\n     */\n    function splitTaxIncome(bytes32 collateralType, uint debtAmount, int deltaRate) internal {\n        // Start looping from the latest tax receiver\n        uint256 currentSecondaryReceiver = latestSecondaryReceiver;\n        // While we still haven't gone through the entire tax receiver list\n        while (currentSecondaryReceiver > 0) {\n          // If the current tax receiver should receive SF from collateralType\n          if (secondaryTaxReceivers[collateralType][currentSecondaryReceiver].taxPercentage > 0) {\n            distributeTax(\n              collateralType,\n              secondaryReceiverAccounts[currentSecondaryReceiver],\n              currentSecondaryReceiver,\n              debtAmount,\n              deltaRate\n            );\n          }\n          // Continue looping\n          (, currentSecondaryReceiver) = secondaryReceiverList.prev(currentSecondaryReceiver);\n        }\n        // Distribute to primary receiver\n        distributeTax(collateralType, primaryTaxReceiver, uint(-1), debtAmount, deltaRate);\n    }\n\n    /**\n     * @notice Give/withdraw SF from a tax receiver\n     * @param collateralType Collateral type to distribute SF for\n     * @param receiver Tax receiver address\n     * @param receiverListPosition Position of receiver in the secondaryReceiverList (if the receiver is secondary)\n     * @param debtAmount Total debt currently issued\n     * @param deltaRate Difference between the latest and the last accumulated rates for the collateralType\n     */\n    function distributeTax(\n        bytes32 collateralType,\n        address receiver,\n        uint256 receiverListPosition,\n        uint256 debtAmount,\n        int256 deltaRate\n    ) internal {\n        // Check how many coins the receiver has and negate the value\n        int256 coinBalance   = -int(safeEngine.coinBalance(receiver));\n        // Compute the % out of SF that should be allocated to the receiver\n        int256 currentTaxCut = (receiver == primaryTaxReceiver) ?\n          multiply(subtract(HUNDRED, secondaryReceiverAllotedTax[collateralType]), deltaRate) / int(HUNDRED) :\n          multiply(int(secondaryTaxReceivers[collateralType][receiverListPosition].taxPercentage), deltaRate) / int(HUNDRED);\n        /**\n            If SF is negative and a tax receiver doesn't have enough coins to absorb the loss,\n            compute a new tax cut that can be absorbed\n        **/\n        currentTaxCut  = (\n          both(multiply(debtAmount, currentTaxCut) < 0, coinBalance > multiply(debtAmount, currentTaxCut))\n        ) ? coinBalance / int(debtAmount) : currentTaxCut;\n        /**\n          If the tax receiver's tax cut is not null and if the receiver accepts negative SF\n          offer/take SF to/from them\n        **/\n        if (currentTaxCut != 0) {\n          if (\n            either(\n              receiver == primaryTaxReceiver,\n              either(\n                deltaRate >= 0,\n                both(currentTaxCut < 0, secondaryTaxReceivers[collateralType][receiverListPosition].canTakeBackTax > 0)\n              )\n            )\n          ) {\n            safeEngine.updateAccumulatedRate(collateralType, receiver, currentTaxCut);\n            emit DistributeTax(collateralType, receiver, currentTaxCut);\n          }\n       }\n    }\n}"
    }
  ]
}