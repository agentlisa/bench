{
  "Title": "[M-13] Less base tokens are transferred when selling quote tokens due to the precision loss that occurred in `_GeneralIntegrate()`",
  "Content": "\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/main/src/mimswap/libraries/Math.sol#L51-L65> \n\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/main/src/mimswap/MagicLP.sol#L180-L191> \n\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/main/src/mimswap/libraries/PMMPricing.sol#L76-L100>\n\nSolidity rounds down the result of an integer division, and because of that, it is always recommended to multiply before dividing to avoid that precision loss.\nIn the case of a prior division over multiplication, the final result may face serious precision loss as the first answer would face truncated precision and then multiplied to another integer.\n\nThe problem lies in the magicLP's quote token querying part. The function `querySellQuote()` is responsible for querying the price of the quote token. This function calls the `sellQuoteToken()` function of the contract PMMPricing which uses a curve integral at its heart. To be precise, for the cases where the parameter `R` is not equal to `1`, the function `sellQuoteToken()` calls the two functions `_RAboveSellBaseToken()`, `_RBelowSellQuoteToken()` for the cases `R > 1` and `R < 1` respectively. These two functions calculate the base token amounts using the `_GeneralIntegrate()` function.\n\nIf we look deeply at the function `_GeneralIntegrate()` we can see the numerical integration procedure is presented as:\n\n```Solidity\n    /*\n        Integrate dodo curve from V1 to V2\n        require V0>=V1>=V2>0\n        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\n        let V1-V2=delta\n        res = i*delta*(1-k+k(V0^2/V1/V2))\n\n        i is the price of V-res trading pair\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _GeneralIntegrate(uint256 V0, uint256 V1, uint256 V2, uint256 i, uint256 k) internal pure returns (uint256) {\n        if (V0 == 0) {\n            revert ErrIsZero();\n        }\n\n        uint256 fairAmount = i * (V1 - V2); // i*delta\n\n        if (k == 0) {\n            return fairAmount / DecimalMath.ONE;\n        }\n\n        uint256 V0V0V1V2 = DecimalMath.divFloor((V0 * V0) / V1, V2);\n        uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)\n        return (((DecimalMath.ONE - k) + penalty) * fairAmount) / DecimalMath.ONE2;\n    }\n```\n\nwe can see there is a hidden division before a multiplication that makes round down the whole expression. The parameter `V0V0V1V2` is calculated in such a way that the `V0 * V0` is divided by `V1`, then the answer is divided by `V2`. After these divisions, the `penalty` variable is defined by the multiplication of `V0V0V1V2` by the `k` variable.\nThis writing method is bad as the precision loss can be significant, leading to the magic pool selling fewer base tokens than actual.\n\nAt the Proof of Concept part, we can check this behavior precisely.\n\n### Proof of Concept\n\nIf we rearrange the code in a way that the precision loss is reduced, we can see the difference:\n\n```Solidity\n    function _GeneralIntegratePrecise(uint256 V0, uint256 V1, uint256 V2, uint256 i, uint256 k) public pure returns (uint256) {\n        if (V0 == 0) {\n            revert ErrIsZero();\n        }\n\n        uint256 fairAmount = i * (V1 - V2); // i*delta\n\n        if (k == 0) {\n            return fairAmount / 1e18;\n        }\n\n        uint256 V0V0V1V2 = (V0 * V0);\n        uint256 penalty = (k * V0V0V1V2) / (V1 * V2); // k(V0^2/V1/V2)\n        return (((1e18 - k) + penalty) * fairAmount) / 1e36;\n    }\n```\n\nFor the variables:\n\n```Solidity\n    V0 = 87461235449999999000\n    V1 = 131454658215568436100\n    V2 = 45632153140140545000\n    i  = 200\n    k  = 1000000000000000000\n```\n\nWe can get these numbers:\n\n         Current Implementation  17164\n         Precise Implementation  21888\n\nThe error between these two numbers is **% 27.5**. Thus, we can see that the actual implementation calculates fewer base token amounts than the precise method.\n\n### Recommended Mitigation Steps\n\nConsider modifying the numerical integral calculation to prevent such precision loss and prioritize multiplication over division:\n\n```Solidity\n    function _GeneralIntegrate(uint256 V0, uint256 V1, uint256 V2, uint256 i, uint256 k) public pure returns (uint256) {\n        if (V0 == 0) {\n            revert ErrIsZero();\n        }\n\n        uint256 fairAmount = i * (V1 - V2); // i*delta\n\n        if (k == 0) {\n            return fairAmount / 1e18;\n        }\n\n        uint256 V0V0V1V2 = (V0 * V0);\n        uint256 penalty = (k * V0V0V1V2) / (V1 * V2); // k(V0^2/V1/V2)\n        return (((1e18 - k) + penalty) * fairAmount) / 1e36;\n    }\n```\n**[0xCalibur (Abracadabra) acknowledged](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/71#issuecomment-2025716294)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-abracadabra-money",
  "Code": [
    {
      "filename": "src/mimswap/libraries/Math.sol",
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity >=0.8.0;\n\nimport {DecimalMath} from \"/mimswap/libraries/DecimalMath.sol\";\n\n/**\n * @author Adapted from https://github.com/DODOEX/contractV2/blob/main/contracts/lib/Math.sol\n * @notice Functions for complex calculating. Including ONE Integration and TWO Quadratic solutions\n */\nlibrary Math {\n    error ErrIsZero();\n\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 quotient = a / b;\n        uint256 remainder = a - quotient * b;\n        if (remainder > 0) {\n            return quotient + 1;\n        } else {\n            return quotient;\n        }\n    }\n\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = x / 2 + 1;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n\n    /*\n        Integrate dodo curve from V1 to V2\n        require V0>=V1>=V2>0\n        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\n        let V1-V2=delta\n        res = i*delta*(1-k+k(V0^2/V1/V2))\n\n        i is the price of V-res trading pair\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _GeneralIntegrate(uint256 V0, uint256 V1, uint256 V2, uint256 i, uint256 k) internal pure returns (uint256) {\n        if (V0 == 0) {\n            revert ErrIsZero();\n        }\n\n        uint256 fairAmount = i * (V1 - V2); // i*delta\n\n        if (k == 0) {\n            return fairAmount / DecimalMath.ONE;\n        }\n\n        uint256 V0V0V1V2 = DecimalMath.divFloor((V0 * V0) / V1, V2);\n        uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)\n        return (((DecimalMath.ONE - k) + penalty) * fairAmount) / DecimalMath.ONE2;\n    }\n\n    /*\n        Follow the integration function above\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\n\n        i is the price of delta-V trading pair\n        give out target of V\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _SolveQuadraticFunctionForTarget(uint256 V1, uint256 delta, uint256 i, uint256 k) internal pure returns (uint256) {\n        if (k == 0) {\n            return V1 + DecimalMath.mulFloor(i, delta);\n        }\n\n        // V0 = V1*(1+(sqrt-1)/2k)\n        // sqrt = √(1+4kidelta/V1)\n        // premium = 1+(sqrt-1)/2k\n        // uint256 sqrt = (4 * k).mul(i).mul(delta).div(V1).add(DecimalMath.ONE2).sqrt();\n\n        if (V1 == 0) {\n            return 0;\n        }\n        uint256 _sqrt;\n        uint256 ki = (4 * k) * i;\n        if (ki == 0) {\n            _sqrt = DecimalMath.ONE;\n        } else if ((ki * delta) / ki == delta) {\n            _sqrt = sqrt(((ki * delta) / V1) + DecimalMath.ONE2);\n        } else {\n            _sqrt = sqrt(((ki / V1) * delta) + DecimalMath.ONE2);\n        }\n        uint256 premium = DecimalMath.divFloor(_sqrt - DecimalMath.ONE, k * 2) + DecimalMath.ONE;\n        // V0 is greater than or equal to V1 according to the solution\n        return DecimalMath.mulFloor(V1, premium);\n    }\n\n    /*\n        Follow the integration expression above, we have:\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Given Q1 and deltaB, solve Q2\n        This is a quadratic function and the standard version is\n        aQ2^2 + bQ2 + c = 0, where\n        a=1-k\n        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\n        c=-kQ0^2 \n        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\n        note: another root is negative, abondan\n\n        if deltaBSig=true, then Q2>Q1, user sell Q and receive B\n        if deltaBSig=false, then Q2<Q1, user sell B and receive Q\n        return |Q1-Q2|\n\n        as we only support sell amount as delta, the deltaB is always negative\n        the input ideltaB is actually -ideltaB in the equation\n\n        i is the price of delta-V trading pair\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _SolveQuadraticFunctionForTrade(uint256 V0, uint256 V1, uint256 delta, uint256 i, uint256 k) internal pure returns (uint256) {\n        if (V0 == 0) {\n            revert ErrIsZero();\n        }\n\n        if (delta == 0) {\n            return 0;\n        }\n\n        if (k == 0) {\n            return DecimalMath.mulFloor(i, delta) > V1 ? V1 : DecimalMath.mulFloor(i, delta);\n        }\n\n        if (k == DecimalMath.ONE) {\n            // if k==1\n            // Q2=Q1/(1+ideltaBQ1/Q0/Q0)\n            // temp = ideltaBQ1/Q0/Q0\n            // Q2 = Q1/(1+temp)\n            // Q1-Q2 = Q1*(1-1/(1+temp)) = Q1*(temp/(1+temp))\n            // uint256 temp = i.mul(delta).mul(V1).div(V0.mul(V0));\n            uint256 temp;\n            uint256 idelta = i * delta;\n            if (idelta == 0) {\n                temp = 0;\n            } else if ((idelta * V1) / idelta == V1) {\n                temp = (idelta * V1) / (V0 * V0);\n            } else {\n                temp = (((delta * V1) / V0) * i) / V0;\n            }\n            return (V1 * temp) / (temp + DecimalMath.ONE);\n        }\n\n        // calculate -b value and sig\n        // b = kQ0^2/Q1-i*deltaB-(1-k)Q1\n        // part1 = (1-k)Q1 >=0\n        // part2 = kQ0^2/Q1-i*deltaB >=0\n        // bAbs = abs(part1-part2)\n        // if part1>part2 => b is negative => bSig is false\n        // if part2>part1 => b is positive => bSig is true\n        uint256 part2 = (((k * V0) / V1) * V0) + (i * delta); // kQ0^2/Q1-i*deltaB\n        uint256 bAbs = (DecimalMath.ONE - k) * V1; // (1-k)Q1\n\n        bool bSig;\n        if (bAbs >= part2) {\n            bAbs = bAbs - part2;\n            bSig = false;\n        } else {\n            bAbs = part2 - bAbs;\n            bSig = true;\n        }\n        bAbs = bAbs / DecimalMath.ONE;\n\n        // calculate sqrt\n        uint256 squareRoot = DecimalMath.mulFloor((DecimalMath.ONE - k) * 4, DecimalMath.mulFloor(k, V0) * V0); // 4(1-k)kQ0^2\n        squareRoot = sqrt((bAbs * bAbs) + squareRoot); // sqrt(b*b+4(1-k)kQ0*Q0)\n\n        // final res\n        uint256 denominator = (DecimalMath.ONE - k) * 2; // 2(1-k)\n        uint256 numerator;\n        if (bSig) {\n            numerator = squareRoot - bAbs;\n            if (numerator == 0) {\n                revert ErrIsZero();\n            }\n        } else {\n            numerator = bAbs + squareRoot;\n        }\n\n        uint256 V2 = DecimalMath.divCeil(numerator, denominator);\n        if (V2 > V1) {\n            return 0;\n        } else {\n            return V1 - V2;\n        }\n    }\n}"
    },
    {
      "filename": "src/mimswap/MagicLP.sol",
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity >=0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {IERC20Metadata} from \"openzeppelin-contracts/interfaces/IERC20Metadata.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solady/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solady/tokens/ERC20.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {DecimalMath} from \"/mimswap/libraries/DecimalMath.sol\";\nimport {Math} from \"/mimswap/libraries/Math.sol\";\nimport {PMMPricing} from \"/mimswap/libraries/PMMPricing.sol\";\nimport {ICallee} from \"/mimswap/interfaces/ICallee.sol\";\nimport {IFeeRateModel} from \"/mimswap/interfaces/IFeeRateModel.sol\";\nimport {IWETH} from \"interfaces/IWETH.sol\";\n\n/// @title MIMSwap MagicLP\n/// @author Adapted from DODOEX DSP https://github.com/DODOEX/contractV2/tree/main/contracts/DODOStablePool\ncontract MagicLP is ERC20, ReentrancyGuard, Owned {\n    using Math for uint256;\n    using SafeCastLib for uint256;\n    using SafeTransferLib for address;\n\n    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);\n    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);\n    event Swap(address fromToken, address toToken, uint256 fromAmount, uint256 toAmount, address trader, address receiver);\n    event FlashLoan(address borrower, address assetTo, uint256 baseAmount, uint256 quoteAmount);\n    event RChange(PMMPricing.RState newRState);\n    event TokenRescue(address indexed token, address to, uint256 amount);\n    event ParametersChanged(uint256 newLpFeeRate, uint256 newI, uint256 newK, uint256 newBaseReserve, uint256 newQuoteReserve);\n\n    error ErrInitialized();\n    error ErrBaseQuoteSame();\n    error ErrInvalidI();\n    error ErrInvalidK();\n    error ErrExpired();\n    error ErrInvalidSignature();\n    error ErrFlashLoanFailed();\n    error ErrNoBaseInput();\n    error ErrZeroAddress();\n    error ErrZeroQuoteAmount();\n    error ErrZeroQuoteTarget();\n    error ErrMintAmountNotEnough();\n    error ErrNotEnough();\n    error ErrWithdrawNotEnough();\n    error ErrSellBackNotAllowed();\n    error ErrInvalidLPFeeRate();\n    error ErrNotImplementationOwner();\n    error ErrNotImplementation();\n    error ErrNotClone();\n    error ErrNotAllowed();\n    error ErrReserveAmountNotEnough();\n    error ErrOverflow();\n\n    MagicLP public immutable implementation;\n\n    uint256 public constant MAX_I = 10 ** 36;\n    uint256 public constant MAX_K = 10 ** 18;\n    uint256 public constant MIN_LP_FEE_RATE = 1e14; // 0.01%\n    uint256 public constant MAX_LP_FEE_RATE = 1e16; // 1%\n\n    bool internal _INITIALIZED_;\n\n    address public _BASE_TOKEN_;\n    address public _QUOTE_TOKEN_;\n    uint112 public _BASE_RESERVE_;\n    uint112 public _QUOTE_RESERVE_;\n    uint32 public _BLOCK_TIMESTAMP_LAST_;\n    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;\n    uint112 public _BASE_TARGET_;\n    uint112 public _QUOTE_TARGET_;\n    uint32 public _RState_;\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\n    uint256 public _LP_FEE_RATE_;\n    uint256 public _K_;\n    uint256 public _I_;\n\n    constructor(address owner_) Owned(owner_) {\n        implementation = this;\n\n        // prevents the implementation contract initialization\n        _INITIALIZED_ = true;\n    }\n\n    function init(\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 i,\n        uint256 k\n    ) external {\n        if (_INITIALIZED_) {\n            revert ErrInitialized();\n        }\n        if (mtFeeRateModel == address(0) || baseTokenAddress == address(0) || quoteTokenAddress == address(0)) {\n            revert ErrZeroAddress();\n        }\n        if (baseTokenAddress == quoteTokenAddress) {\n            revert ErrBaseQuoteSame();\n        }\n        if (i == 0 || i > MAX_I) {\n            revert ErrInvalidI();\n        }\n        if (k > MAX_K) {\n            revert ErrInvalidK();\n        }\n        if (lpFeeRate < MIN_LP_FEE_RATE || lpFeeRate > MAX_LP_FEE_RATE) {\n            revert ErrInvalidLPFeeRate();\n        }\n\n        _INITIALIZED_ = true;\n        _BASE_TOKEN_ = baseTokenAddress;\n        _QUOTE_TOKEN_ = quoteTokenAddress;\n        _I_ = i;\n        _K_ = k;\n        _LP_FEE_RATE_ = lpFeeRate;\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\n        _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2 ** 32);\n\n        _afterInitialized();\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PUBLIC\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function sync() external nonReentrant {\n        _sync();\n    }\n\n    function correctRState() external {\n        if (_RState_ == uint32(PMMPricing.RState.BELOW_ONE) && _BASE_RESERVE_ < _BASE_TARGET_) {\n            _RState_ = uint32(PMMPricing.RState.ONE);\n            _BASE_TARGET_ = _BASE_RESERVE_;\n            _QUOTE_TARGET_ = _QUOTE_RESERVE_;\n        }\n        if (_RState_ == uint32(PMMPricing.RState.ABOVE_ONE) && _QUOTE_RESERVE_ < _QUOTE_TARGET_) {\n            _RState_ = uint32(PMMPricing.RState.ONE);\n            _BASE_TARGET_ = _BASE_RESERVE_;\n            _QUOTE_TARGET_ = _QUOTE_RESERVE_;\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// VIEWS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function name() public view override returns (string memory) {\n        return string(abi.encodePacked(\"MagicLP \", IERC20Metadata(_BASE_TOKEN_).symbol(), \"/\", IERC20Metadata(_QUOTE_TOKEN_).symbol()));\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return \"MagicLP\";\n    }\n\n    function decimals() public view override returns (uint8) {\n        return IERC20Metadata(_BASE_TOKEN_).decimals();\n    }\n\n    function querySellBase(\n        address trader,\n        uint256 payBaseAmount\n    ) public view returns (uint256 receiveQuoteAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newBaseTarget) {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount);\n\n        (uint256 lpFeeRate, uint256 mtFeeRate) = _MT_FEE_RATE_MODEL_.getFeeRate(trader, _LP_FEE_RATE_);\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\n        receiveQuoteAmount = receiveQuoteAmount - DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate) - mtFee;\n        newBaseTarget = state.B0;\n    }\n\n    function querySellQuote(\n        address trader,\n        uint256 payQuoteAmount\n    ) public view returns (uint256 receiveBaseAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newQuoteTarget) {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveBaseAmount, newRState) = PMMPricing.sellQuoteToken(state, payQuoteAmount);\n\n        (uint256 lpFeeRate, uint256 mtFeeRate) = _MT_FEE_RATE_MODEL_.getFeeRate(trader, _LP_FEE_RATE_);\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\n        receiveBaseAmount = receiveBaseAmount - DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate) - mtFee;\n        newQuoteTarget = state.Q0;\n    }\n\n    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\n        state.i = _I_;\n        state.K = _K_;\n        state.B = _BASE_RESERVE_;\n        state.Q = _QUOTE_RESERVE_;\n        state.B0 = _BASE_TARGET_; // will be calculated in adjustedTarget\n        state.Q0 = _QUOTE_TARGET_;\n        state.R = PMMPricing.RState(_RState_);\n        PMMPricing.adjustedTarget(state);\n    }\n\n    function getPMMStateForCall() external view returns (uint256 i, uint256 K, uint256 B, uint256 Q, uint256 B0, uint256 Q0, uint256 R) {\n        PMMPricing.PMMState memory state = getPMMState();\n        i = state.i;\n        K = state.K;\n        B = state.B;\n        Q = state.Q;\n        B0 = state.B0;\n        Q0 = state.Q0;\n        R = uint256(state.R);\n    }\n\n    function getMidPrice() public view returns (uint256 midPrice) {\n        return PMMPricing.getMidPrice(getPMMState());\n    }\n\n    function getReserves() external view returns (uint256 baseReserve, uint256 quoteReserve) {\n        baseReserve = _BASE_RESERVE_;\n        quoteReserve = _QUOTE_RESERVE_;\n    }\n\n    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate) {\n        return _MT_FEE_RATE_MODEL_.getFeeRate(user, _LP_FEE_RATE_);\n    }\n\n    function getBaseInput() public view returns (uint256 input) {\n        return _BASE_TOKEN_.balanceOf(address(this)) - uint256(_BASE_RESERVE_);\n    }\n\n    function getQuoteInput() public view returns (uint256 input) {\n        return _QUOTE_TOKEN_.balanceOf(address(this)) - uint256(_QUOTE_RESERVE_);\n    }\n\n    function version() external pure virtual returns (string memory) {\n        return \"MagicLP 1.0.0\";\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// TRADE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function sellBase(address to) external nonReentrant returns (uint256 receiveQuoteAmount) {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);\n        uint256 mtFee;\n        uint256 newBaseTarget;\n        PMMPricing.RState newRState;\n        (receiveQuoteAmount, mtFee, newRState, newBaseTarget) = querySellBase(tx.origin, baseInput);\n\n        _transferQuoteOut(to, receiveQuoteAmount);\n        _transferQuoteOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            _BASE_TARGET_ = newBaseTarget.toUint112();\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));\n\n        emit Swap(address(_BASE_TOKEN_), address(_QUOTE_TOKEN_), baseInput, receiveQuoteAmount, msg.sender, to);\n    }\n\n    function sellQuote(address to) external nonReentrant returns (uint256 receiveBaseAmount) {\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 quoteInput = quoteBalance - uint256(_QUOTE_RESERVE_);\n        uint256 mtFee;\n        uint256 newQuoteTarget;\n        PMMPricing.RState newRState;\n        (receiveBaseAmount, mtFee, newRState, newQuoteTarget) = querySellQuote(tx.origin, quoteInput);\n\n        _transferBaseOut(to, receiveBaseAmount);\n        _transferBaseOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            _QUOTE_TARGET_ = newQuoteTarget.toUint112();\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);\n\n        emit Swap(address(_QUOTE_TOKEN_), address(_BASE_TOKEN_), quoteInput, receiveBaseAmount, msg.sender, to);\n    }\n\n    function flashLoan(uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes calldata data) external nonReentrant {\n        _transferBaseOut(assetTo, baseAmount);\n        _transferQuoteOut(assetTo, quoteAmount);\n\n        if (data.length > 0) {\n            ICallee(assetTo).FlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\n        }\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        // no input -> pure loss\n        if (baseBalance < _BASE_RESERVE_ && quoteBalance < _QUOTE_RESERVE_) {\n            revert ErrFlashLoanFailed();\n        }\n\n        // sell quote case\n        // quote input + base output\n        if (baseBalance < _BASE_RESERVE_) {\n            uint256 quoteInput = quoteBalance - uint256(_QUOTE_RESERVE_);\n            (uint256 receiveBaseAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newQuoteTarget) = querySellQuote(\n                tx.origin,\n                quoteInput\n            );\n\n            if (uint256(_BASE_RESERVE_) - baseBalance > receiveBaseAmount) {\n                revert ErrFlashLoanFailed();\n            }\n\n            _transferBaseOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);\n            if (_RState_ != uint32(newRState)) {\n                _QUOTE_TARGET_ = newQuoteTarget.toUint112();\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit Swap(address(_QUOTE_TOKEN_), address(_BASE_TOKEN_), quoteInput, receiveBaseAmount, msg.sender, assetTo);\n        }\n\n        // sell base case\n        // base input + quote output\n        if (quoteBalance < _QUOTE_RESERVE_) {\n            uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);\n            (uint256 receiveQuoteAmount, uint256 mtFee, PMMPricing.RState newRState, uint256 newBaseTarget) = querySellBase(\n                tx.origin,\n                baseInput\n            );\n\n            if (uint256(_QUOTE_RESERVE_) - quoteBalance > receiveQuoteAmount) {\n                revert ErrFlashLoanFailed();\n            }\n\n            _transferQuoteOut(_MT_FEE_RATE_MODEL_.maintainer(), mtFee);\n            if (_RState_ != uint32(newRState)) {\n                _BASE_TARGET_ = newBaseTarget.toUint112();\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit Swap(address(_BASE_TOKEN_), address(_QUOTE_TOKEN_), baseInput, receiveQuoteAmount, msg.sender, assetTo);\n        }\n\n        _sync();\n\n        emit FlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// BUY & SELL SHARES\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    // buy shares [round down]\n    function buyShares(address to) external nonReentrant returns (uint256 shares, uint256 baseInput, uint256 quoteInput) {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 baseReserve = _BASE_RESERVE_;\n        uint256 quoteReserve = _QUOTE_RESERVE_;\n\n        baseInput = baseBalance - baseReserve;\n        quoteInput = quoteBalance - quoteReserve;\n\n        if (baseInput == 0) {\n            revert ErrNoBaseInput();\n        }\n\n        // Round down when withdrawing. Therefore, never be a situation occurring balance is 0 but totalsupply is not 0\n        // But May Happen，reserve >0 But totalSupply = 0\n        if (totalSupply() == 0) {\n            // case 1. initial supply\n            if (quoteBalance == 0) {\n                revert ErrZeroQuoteAmount();\n            }\n\n            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_) ? DecimalMath.divFloor(quoteBalance, _I_) : baseBalance;\n            _BASE_TARGET_ = shares.toUint112();\n            _QUOTE_TARGET_ = DecimalMath.mulFloor(shares, _I_).toUint112();\n\n            if (_QUOTE_TARGET_ == 0) {\n                revert ErrZeroQuoteTarget();\n            }\n\n            if (shares <= 2001) {\n                revert ErrMintAmountNotEnough();\n            }\n\n            _mint(address(0), 1001);\n            shares -= 1001;\n        } else if (baseReserve > 0 && quoteReserve > 0) {\n            // case 2. normal case\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\n            uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;\n            shares = DecimalMath.mulFloor(totalSupply(), mintRatio);\n\n            _BASE_TARGET_ = (uint256(_BASE_TARGET_) + DecimalMath.mulFloor(uint256(_BASE_TARGET_), mintRatio)).toUint112();\n            _QUOTE_TARGET_ = (uint256(_QUOTE_TARGET_) + DecimalMath.mulFloor(uint256(_QUOTE_TARGET_), mintRatio)).toUint112();\n        }\n\n        _mint(to, shares);\n        _setReserve(baseBalance, quoteBalance);\n\n        emit BuyShares(to, shares, balanceOf(to));\n    }\n\n    // sell shares [round down]\n    function sellShares(\n        uint256 shareAmount,\n        address to,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        bytes calldata data,\n        uint256 deadline\n    ) external nonReentrant returns (uint256 baseAmount, uint256 quoteAmount) {\n        if (deadline < block.timestamp) {\n            revert ErrExpired();\n        }\n        if (shareAmount > balanceOf(msg.sender)) {\n            revert ErrNotEnough();\n        }\n        if (to == address(this)) {\n            revert ErrSellBackNotAllowed();\n        }\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 totalShares = totalSupply();\n\n        baseAmount = (baseBalance * shareAmount) / totalShares;\n        quoteAmount = (quoteBalance * shareAmount) / totalShares;\n\n        _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_) - (uint256(_BASE_TARGET_) * shareAmount).divCeil(totalShares));\n        _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_) - (uint256(_QUOTE_TARGET_) * shareAmount).divCeil(totalShares));\n\n        if (baseAmount < baseMinAmount || quoteAmount < quoteMinAmount) {\n            revert ErrWithdrawNotEnough();\n        }\n\n        _burn(msg.sender, shareAmount);\n        _transferBaseOut(to, baseAmount);\n        _transferQuoteOut(to, quoteAmount);\n        _sync();\n\n        if (data.length > 0) {\n            ICallee(to).SellShareCall(msg.sender, shareAmount, baseAmount, quoteAmount, data);\n        }\n\n        emit SellShares(msg.sender, to, shareAmount, balanceOf(msg.sender));\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// ADMIN\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function rescue(address token, address to, uint256 amount) external onlyImplementationOwner {\n        if (token == _BASE_TOKEN_ || token == _QUOTE_TOKEN_) {\n            revert ErrNotAllowed();\n        }\n\n        token.safeTransfer(to, amount);\n        emit TokenRescue(token, to, amount);\n    }\n\n    function setParameters(\n        address assetTo,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) public nonReentrant onlyImplementationOwner {\n        if (_BASE_RESERVE_ < minBaseReserve || _QUOTE_RESERVE_ < minQuoteReserve) {\n            revert ErrReserveAmountNotEnough();\n        }\n        if (newI == 0 || newI > MAX_I) {\n            revert ErrInvalidI();\n        }\n        if (newK > MAX_K) {\n            revert ErrInvalidK();\n        }\n        if (newLpFeeRate < MIN_LP_FEE_RATE || newLpFeeRate > MAX_LP_FEE_RATE) {\n            revert ErrInvalidLPFeeRate();\n        }\n\n        _LP_FEE_RATE_ = uint64(newLpFeeRate);\n        _K_ = uint64(newK);\n        _I_ = uint128(newI);\n\n        _transferBaseOut(assetTo, baseOutAmount);\n        _transferQuoteOut(assetTo, quoteOutAmount);\n        (uint256 newBaseBalance, uint256 newQuoteBalance) = _resetTargetAndReserve();\n\n        emit ParametersChanged(newLpFeeRate, newI, newK, newBaseBalance, newQuoteBalance);\n    }\n\n    function ratioSync() external nonReentrant onlyImplementationOwner {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        if (baseBalance > type(uint112).max || quoteBalance > type(uint112).max) {\n            revert ErrOverflow();\n        }\n\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_TARGET_ = uint112((uint256(_BASE_TARGET_) * baseBalance) / uint256(_BASE_RESERVE_));\n            _BASE_RESERVE_ = uint112(baseBalance);\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_TARGET_ = uint112((uint256(_QUOTE_TARGET_) * quoteBalance) / uint256(_QUOTE_RESERVE_));\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\n        }\n\n        _twapUpdate();\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// INTERNALS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _resetTargetAndReserve() internal returns (uint256 baseBalance, uint256 quoteBalance) {\n        baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        if (baseBalance > type(uint112).max || quoteBalance > type(uint112).max) {\n            revert ErrOverflow();\n        }\n\n        _BASE_RESERVE_ = uint112(baseBalance);\n        _QUOTE_RESERVE_ = uint112(quoteBalance);\n        _BASE_TARGET_ = uint112(baseBalance);\n        _QUOTE_TARGET_ = uint112(quoteBalance);\n        _RState_ = uint32(PMMPricing.RState.ONE);\n\n        _twapUpdate();\n    }\n\n    function _twapUpdate() internal {\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n        uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;\n\n        if (timeElapsed > 0 && _BASE_RESERVE_ != 0 && _QUOTE_RESERVE_ != 0) {\n            /// @dev It is desired and expected for this value to\n            /// overflow once it has hit the max of `type.uint256`.\n            unchecked {\n                _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;\n            }\n        }\n\n        _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;\n    }\n\n    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\n        _BASE_RESERVE_ = baseReserve.toUint112();\n        _QUOTE_RESERVE_ = quoteReserve.toUint112();\n\n        _twapUpdate();\n    }\n\n    function _sync() internal {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_RESERVE_ = baseBalance.toUint112();\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_RESERVE_ = quoteBalance.toUint112();\n        }\n\n        _twapUpdate();\n    }\n\n    function _transferBaseOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _BASE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function _transferQuoteOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function _mint(address to, uint256 amount) internal override {\n        if (amount <= 1000) {\n            revert ErrMintAmountNotEnough();\n        }\n\n        super._mint(to, amount);\n    }\n\n    function _afterInitialized() internal virtual {}\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// MODIFIERS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    modifier onlyImplementationOwner() {\n        if (msg.sender != implementation.owner()) {\n            revert ErrNotImplementationOwner();\n        }\n        _;\n    }\n\n    modifier onlyClones() {\n        if (address(this) == address(implementation)) {\n            revert ErrNotClone();\n        }\n        _;\n    }\n\n    modifier onlyImplementation() {\n        if (address(this) != address(implementation)) {\n            revert ErrNotImplementation();\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/mimswap/libraries/PMMPricing.sol",
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity >=0.8.0;\n\nimport {DecimalMath} from \"/mimswap/libraries/DecimalMath.sol\";\nimport {Math} from \"/mimswap/libraries/Math.sol\";\n\n/**\n * @title Pricing\n * @author DODO Breeder\n *\n * @notice DODO Pricing model\n */\n\nlibrary PMMPricing {\n    enum RState {\n        ONE,\n        ABOVE_ONE,\n        BELOW_ONE\n    }\n\n    struct PMMState {\n        uint256 i;\n        uint256 K;\n        uint256 B;\n        uint256 Q;\n        uint256 B0;\n        uint256 Q0;\n        RState R;\n    }\n\n    // ============ buy & sell ============\n\n    function sellBaseToken(PMMState memory state, uint256 payBaseAmount) internal pure returns (uint256 receiveQuoteAmount, RState newR) {\n        if (state.R == RState.ONE) {\n            // case 1: R=1\n            // R falls below one\n            receiveQuoteAmount = _ROneSellBaseToken(state, payBaseAmount);\n            newR = RState.BELOW_ONE;\n        } else if (state.R == RState.ABOVE_ONE) {\n            uint256 backToOnePayBase = state.B0 - state.B;\n            uint256 backToOneReceiveQuote = state.Q - state.Q0;\n            // case 2: R>1\n            // complex case, R status depends on trading amount\n            if (payBaseAmount < backToOnePayBase) {\n                // case 2.1: R status do not change\n                receiveQuoteAmount = _RAboveSellBaseToken(state, payBaseAmount);\n                newR = RState.ABOVE_ONE;\n                if (receiveQuoteAmount > backToOneReceiveQuote) {\n                    // [Important corner case!] may enter this branch when some precision problem happens. And consequently contribute to negative spare quote amount\n                    // to make sure spare quote>=0, mannually set receiveQuote=backToOneReceiveQuote\n                    receiveQuoteAmount = backToOneReceiveQuote;\n                }\n            } else if (payBaseAmount == backToOnePayBase) {\n                // case 2.2: R status changes to ONE\n                receiveQuoteAmount = backToOneReceiveQuote;\n                newR = RState.ONE;\n            } else {\n                // case 2.3: R status changes to BELOW_ONE\n                receiveQuoteAmount = backToOneReceiveQuote + _ROneSellBaseToken(state, payBaseAmount - backToOnePayBase);\n                newR = RState.BELOW_ONE;\n            }\n        } else {\n            // state.R == RState.BELOW_ONE\n            // case 3: R<1\n            receiveQuoteAmount = _RBelowSellBaseToken(state, payBaseAmount);\n            newR = RState.BELOW_ONE;\n        }\n    }\n\n    function sellQuoteToken(PMMState memory state, uint256 payQuoteAmount) internal pure returns (uint256 receiveBaseAmount, RState newR) {\n        if (state.R == RState.ON"
    }
  ]
}