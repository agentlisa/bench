{
  "Title": "[M-01] `vcon` address change not persistent across protocol components",
  "Content": "_Submitted by rayn_\n\n[Core.sol#L27](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/core/Core.sol#L27)<br>\n[CoreRef.sol#L22](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/refs/CoreRef.sol#L22)<br>\n[CoreRef.sol#L199](https://github.com/code-423n4/2022-03-volt/blob/main/contracts/refs/CoreRef.sol#L199)<br>\n\n`vcon` address is allowed to be updated by `GOVERNOR` in `Core`, however, this change will not be reflected in `CoreRef._vcon`. Moreover, since `CoreRef._vcon` cannot be updated due to contract design, it is also impossible to fix this manually.\nWe are not yet sure how `vcon` will be used throughout the volt protocol, since details have not yet been made clear and code does not include related implementations. Consequently, it is impossible to estimate the exact impact. However, this desync between contracts seem dangerous enough to raise our attention, hence this report to inform the volt team about it.\n\n### Proof of Concept\n\nIn `Core`, `vcon` is allowed to be updated by GOVERNORs\n\n        function setVcon(IERC20 _vcon) external onlyGovernor {\n            vcon = _vcon;\n\n            emit VconUpdate(_vcon);\n        }\n\nBut in `CoreRef`, a contract inherited by several other ones including `NonCustodialPSM`, `GlobalRateLimitedMinter`, `ERC20CompountPCVDeposit` and `Volt`, `_vcon` is fixed upon initialization and cannot be further updated\n\n        IERC20 private immutable _vcon;\n        ...\n        constructor(address coreAddress) {\n            ...\n            _vcon = ICore(coreAddress).vcon();\n            ...\n        }\n\nThus if `GOVERNORS` ever updated `vcon` in `Core`, the state between `Core` and all other Volt protocol components will mismatch.\n\nCurrently `_vcon` is not used in any place within the Volt protocol, but judging from the description in whitepapaer, future governance will be based on it, thus any potential desync will be devastating.\n\n### Tools Used\n\nvim, ganache-cli\n\n### Recommended Mitigation Steps\n\nThere are several possible solutions.\n\nThe first is to dynamically fetch `vcon` from the `Core` whenever `CoreRef` uses it, and avoid storing a static copy locally.\n\n        function vcon() public view override returns (IERC20) {\n            return _volt.vcon();\n        }\n\nThe second is to expose a public API to update `_vcon` in `CoreRef`, however, this approach might not be especially favorable since many components will require updates at once, and it is highly possible that future GOVERNORs miss some of them while doing updates.\n\n**[ElliotFriedman (Volt) disagreed with High severity and commented](https://github.com/code-423n4/2022-03-volt-findings/issues/60#issuecomment-1092212216):**\n > Agreed this is an issue; however, if the VCON address is updated, contracts that need to reference the new value will need to be redeployed to cache this new address when CoreRef is instantiated.\n\n**[Jack the Pug (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-03-volt-findings/issues/60#issuecomment-1100818437):**\n > Based on the severity of the impact, I'm downgrading this to `Medium`.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-volt-protocol-contest",
  "Code": [
    {
      "filename": "contracts/core/Core.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {Vcon} from \"../vcon/Vcon.sol\";\nimport {IVolt, Volt, IERC20} from \"../volt/Volt.sol\";\nimport {ICore} from \"./ICore.sol\";\nimport {Permissions} from \"./Permissions.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/// @title Source of truth for VOLT Protocol\n/// @author Fei Protocol\n/// @notice maintains roles, access control, Volt, Vcon, and the Vcon treasury\ncontract Core is ICore, Permissions, Initializable {\n    /// @notice the address of the FEI contract\n    IVolt public override volt;\n\n    /// @notice the address of the Vcon contract\n    IERC20 public override vcon;\n\n    function init() external initializer {\n        volt = new Volt(address(this));\n        /// msg.sender already has the VOLT Minting abilities, so grant them governor as well\n        _setupGovernor(msg.sender);\n    }\n\n    /// @notice governor only function to set the VCON token\n    function setVcon(IERC20 _vcon) external onlyGovernor {\n        vcon = _vcon;\n\n        emit VconUpdate(_vcon);\n    }\n}"
    },
    {
      "filename": "contracts/refs/CoreRef.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./ICoreRef.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\n/// @title A Reference to Core\n/// @author Fei Protocol\n/// @notice defines some modifiers and utilities around interacting with Core\nabstract contract CoreRef is ICoreRef, Pausable {\n    ICore private immutable _core;\n    IVolt private immutable _volt;\n    IERC20 private immutable _vcon;\n\n    /// @notice a role used with a subset of governor permissions for this contract only\n    bytes32 public override CONTRACT_ADMIN_ROLE;\n\n    constructor(address coreAddress) {\n        _core = ICore(coreAddress);\n\n        _volt = ICore(coreAddress).volt();\n        _vcon = ICore(coreAddress).vcon();\n\n        _setContractAdminRole(ICore(coreAddress).GOVERN_ROLE());\n    }\n\n    function _initialize() internal {} // no-op for backward compatibility\n\n    modifier ifMinterSelf() {\n        if (_core.isMinter(address(this))) {\n            _;\n        }\n    }\n\n    modifier onlyMinter() {\n        require(_core.isMinter(msg.sender), \"CoreRef: Caller is not a minter\");\n        _;\n    }\n\n    modifier onlyBurner() {\n        require(_core.isBurner(msg.sender), \"CoreRef: Caller is not a burner\");\n        _;\n    }\n\n    modifier onlyPCVController() {\n        require(\n            _core.isPCVController(msg.sender),\n            \"CoreRef: Caller is not a PCV controller\"\n        );\n        _;\n    }\n\n    modifier onlyGovernorOrAdmin() {\n        require(\n            _core.isGovernor(msg.sender) || isContractAdmin(msg.sender),\n            \"CoreRef: Caller is not a governor or contract admin\"\n        );\n        _;\n    }\n\n    modifier onlyGovernor() {\n        require(\n            _core.isGovernor(msg.sender),\n            \"CoreRef: Caller is not a governor\"\n        );\n        _;\n    }\n\n    modifier onlyGuardianOrGovernor() {\n        require(\n            _core.isGovernor(msg.sender) || _core.isGuardian(msg.sender),\n            \"CoreRef: Caller is not a guardian or governor\"\n        );\n        _;\n    }\n\n    modifier onlyGovernorOrGuardianOrAdmin() {\n        require(\n            _core.isGovernor(msg.sender) ||\n                _core.isGuardian(msg.sender) ||\n                isContractAdmin(msg.sender),\n            \"CoreRef: Caller is not governor or guardian or admin\"\n        );\n        _;\n    }\n\n    // Named onlyTribeRole to prevent collision with OZ onlyRole modifier\n    modifier onlyTribeRole(bytes32 role) {\n        require(_core.hasRole(role, msg.sender), \"UNAUTHORIZED\");\n        _;\n    }\n\n    // Modifiers to allow any combination of roles\n    modifier hasAnyOfTwoRoles(bytes32 role1, bytes32 role2) {\n        require(\n            _core.hasRole(role1, msg.sender) ||\n                _core.hasRole(role2, msg.sender),\n            \"UNAUTHORIZED\"\n        );\n        _;\n    }\n\n    modifier hasAnyOfThreeRoles(\n        bytes32 role1,\n        bytes32 role2,\n        bytes32 role3\n    ) {\n        require(\n            _core.hasRole(role1, msg.sender) ||\n                _core.hasRole(role2, msg.sender) ||\n                _core.hasRole(role3, msg.sender),\n            \"UNAUTHORIZED\"\n        );\n        _;\n    }\n\n    modifier hasAnyOfFourRoles(\n        bytes32 role1,\n        bytes32 role2,\n        bytes32 role3,\n        bytes32 role4\n    ) {\n        require(\n            _core.hasRole(role1, msg.sender) ||\n                _core.hasRole(role2, msg.sender) ||\n                _core.hasRole(role3, msg.sender) ||\n                _core.hasRole(role4, msg.sender),\n            \"UNAUTHORIZED\"\n        );\n        _;\n    }\n\n    modifier hasAnyOfFiveRoles(\n        bytes32 role1,\n        bytes32 role2,\n        bytes32 role3,\n        bytes32 role4,\n        bytes32 role5\n    ) {\n        require(\n            _core.hasRole(role1, msg.sender) ||\n                _core.hasRole(role2, msg.sender) ||\n                _core.hasRole(role3, msg.sender) ||\n                _core.hasRole(role4, msg.sender) ||\n                _core.hasRole(role5, msg.sender),\n            \"UNAUTHORIZED\"\n        );\n        _;\n    }\n\n    modifier onlyVolt() {\n        require(msg.sender == address(_volt), \"CoreRef: Caller is not VOLT\");\n        _;\n    }\n\n    /// @notice sets a new admin role for this contract\n    function setContractAdminRole(bytes32 newContractAdminRole)\n        external\n        override\n        onlyGovernor\n    {\n        _setContractAdminRole(newContractAdminRole);\n    }\n\n    /// @notice returns whether a given address has the admin role for this contract\n    function isContractAdmin(address _admin)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _core.hasRole(CONTRACT_ADMIN_ROLE, _admin);\n    }\n\n    /// @notice set pausable methods to paused\n    function pause() public override onlyGuardianOrGovernor {\n        _pause();\n    }\n\n    /// @notice set pausable methods to unpaused\n    function unpause() public override onlyGuardianOrGovernor {\n        _unpause();\n    }\n\n    /// @notice address of the Core contract referenced\n    /// @return ICore implementation address\n    function core() public view override returns (ICore) {\n        return _core;\n    }\n\n    /// @notice address of the Fei contract referenced by Core\n    /// @return IFei implementation address\n    function volt() public view override returns (IVolt) {\n        return _volt;\n    }\n\n    /// @notice address of the Tribe contract referenced by Core\n    /// @return IERC20 implementation address\n    function vcon() public view override returns (IERC20) {\n        return _vcon;\n    }\n\n    /// @notice volt balance of contract\n    /// @return volt amount held\n    function voltBalance() public view override returns (uint256) {\n        return _volt.balanceOf(address(this));\n    }\n\n    /// @notice vcon balance of contract\n    /// @return vcon amount held\n    function vconBalance() public view override returns (uint256) {\n        return _vcon.balanceOf(address(this));\n    }\n\n    function _burnVoltHeld() internal {\n        _volt.burn(voltBalance());\n    }\n\n    function _mintVolt(address to, uint256 amount) internal virtual {\n        if (amount != 0) {\n            _volt.mint(to, amount);\n        }\n    }\n\n    function _setContractAdminRole(bytes32 newContractAdminRole) internal {\n        bytes32 oldContractAdminRole = CONTRACT_ADMIN_ROLE;\n        CONTRACT_ADMIN_ROLE = newContractAdminRole;\n        emit ContractAdminRoleUpdate(\n            oldContractAdminRole,\n            newContractAdminRole\n        );\n    }\n}"
    },
    {
      "filename": "contracts/refs/CoreRef.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./ICoreRef.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\n/// @title A Reference to Core\n/// @author Fei Protocol\n/// @notice defines some modifiers and utilities around interacting with Core\nabstract contract CoreRef is ICoreRef, Pausable {\n    ICore private immutable _core;\n    IVolt private immutable _volt;\n    IERC20 private immutable _vcon;\n\n    /// @notice a role used with a subset of governor permissions for this contract only\n    bytes32 public override CONTRACT_ADMIN_ROLE;\n\n    constructor(address coreAddress) {\n        _core = ICore(coreAddress);\n\n        _volt = ICore(coreAddress).volt();\n        _vcon = ICore(coreAddress).vcon();\n\n        _setContractAdminRole(ICore(coreAddress).GOVERN_ROLE());\n    }\n\n    function _initialize() internal {} // no-op for backward compatibility\n\n    modifier ifMinterSelf() {\n        if (_core.isMinter(address(this))) {\n            _;\n        }\n    }\n\n    modifier onlyMinter() {\n        require(_core.isMinter(msg.sender), \"CoreRef: Caller is not a minter\");\n        _;\n    }\n\n    modifier onlyBurner() {\n        require(_core.isBurner(msg.sender), \"CoreRef: Caller is not a burner\");\n        _;\n    }\n\n    modifier onlyPCVController() {\n        require(\n            _core.isPCVController(msg.sender),\n            \"CoreRef: Caller is not a PCV controller\"\n        );\n        _;\n    }\n\n    modifier onlyGovernorOrAdmin() {\n        require(\n            _core.isGovernor(msg.sender) || isContractAdmin(msg.sender),\n            \"CoreRef: Caller is not a governor or contract admin\"\n        );\n        _;\n    }\n\n    modifier onlyGovernor() {\n        require(\n            _core.isGovernor(msg.sender),\n            \"CoreRef: Caller is not a governor\"\n        );\n        _;\n    }\n\n    modifier onlyGuardianOrGovernor() {\n        require(\n            _core.isGovernor(msg.sender) || _core.isGuardian(msg.sender),\n            \"CoreRef: Caller is not a guardian or governor\"\n        );\n        _;\n    }\n\n    modifier onlyGovernorOrGuardianOrAdmin() {\n        require(\n            _core.isGovernor(msg.sender) ||\n                _core.isGuardian(msg.sender) ||\n                isContractAdmin(msg.sender),\n            \"CoreRef: Caller is not governor or guardian or admin\"\n        );\n        _;\n    }\n\n    // Named onlyTribeRole to prevent collision with OZ onlyRole modifier\n    modifier onlyTribeRole(bytes32 role) {\n        require(_core.hasRole(role, msg.sender), \"UNAUTHORIZED\");\n        _;\n    }\n\n    // Modifiers to allow any combination of roles\n    modifier hasAnyOfTwoRoles(bytes32 role1, bytes32 role2) {\n        require(\n            _core.hasRole(role1, msg.sender) ||\n                _core.hasRole(role2, msg.sender),\n            \"UNAUTHORIZED\"\n        );\n        _;\n    }\n\n    modifier hasAnyOfThreeRoles(\n        bytes32 role1,\n        bytes32 role2,\n        bytes32 role3\n    ) {\n        require(\n            _core.hasRole(role1, msg.sender) ||\n                _core.hasRole(role2, msg.sender) ||\n                _core.hasRole(role3, msg.sender),\n            \"UNAUTHORIZED\"\n        );\n        _;\n    }\n\n    modifier hasAnyOfFourRoles(\n        bytes32 role1,\n        bytes32 role2,\n        bytes32 role3,\n        bytes32 role4\n    ) {\n        require(\n            _core.hasRole(role1, msg.sender) ||\n                _core.hasRole(role2, msg.sender) ||\n                _core.hasRole(role3, msg.sender) ||\n                _core.hasRole(role4, msg.sender),\n            \"UNAUTHORIZED\"\n        );\n        _;\n    }\n\n    modifier hasAnyOfFiveRoles(\n        bytes32 role1,\n        bytes32 role2,\n        bytes32 role3,\n        bytes32 role4,\n        bytes32 role5\n    ) {\n        require(\n            _core.hasRole(role1, msg.sender) ||\n                _core.hasRole(role2, msg.sender) ||\n                _core.hasRole(role3, msg.sender) ||\n                _core.hasRole(role4, msg.sender) ||\n                _core.hasRole(role5, msg.sender),\n            \"UNAUTHORIZED\"\n        );\n        _;\n    }\n\n    modifier onlyVolt() {\n        require(msg.sender == address(_volt), \"CoreRef: Caller is not VOLT\");\n        _;\n    }\n\n    /// @notice sets a new admin role for this contract\n    function setContractAdminRole(bytes32 newContractAdminRole)\n        external\n        override\n        onlyGovernor\n    {\n        _setContractAdminRole(newContractAdminRole);\n    }\n\n    /// @notice returns whether a given address has the admin role for this contract\n    function isContractAdmin(address _admin)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _core.hasRole(CONTRACT_ADMIN_ROLE, _admin);\n    }\n\n    /// @notice set pausable methods to paused\n    function pause() public override onlyGuardianOrGovernor {\n        _pause();\n    }\n\n    /// @notice set pausable methods to unpaused\n    function unpause() public override onlyGuardianOrGovernor {\n        _unpause();\n    }\n\n    /// @notice address of the Core contract referenced\n    /// @return ICore implementation address\n    function core() public view override returns (ICore) {\n        return _core;\n    }\n\n    /// @notice address of the Fei contract referenced by Core\n    /// @return IFei implementation address\n    function volt() public view override returns (IVolt) {\n        return _volt;\n    }\n\n    /// @notice address of the Tribe contract referenced by Core\n    /// @return IERC20 implementation address\n    function vcon() public view override returns (IERC20) {\n        return _vcon;\n    }\n\n    /// @notice volt balance of contract\n    /// @return volt amount held\n    function voltBalance() public view override returns (uint256) {\n        return _volt.balanceOf(address(this));\n    }\n\n    /// @notice vcon balance of contract\n    /// @return vcon amount held\n    function vconBalance() public view override returns (uint256) {\n        return _vcon.balanceOf(address(this));\n    }\n\n    function _burnVoltHeld() internal {\n        _volt.burn(voltBalance());\n    }\n\n    function _mintVolt(address to, uint256 amount) internal virtual {\n        if (amount != 0) {\n            _volt.mint(to, amount);\n        }\n    }\n\n    function _setContractAdminRole(bytes32 newContractAdminRole) internal {\n        bytes32 oldContractAdminRole = CONTRACT_ADMIN_ROLE;\n        CONTRACT_ADMIN_ROLE = newContractAdminRole;\n        emit ContractAdminRoleUpdate(\n            oldContractAdminRole,\n            newContractAdminRole\n        );\n    }\n}"
    }
  ]
}