{
  "Title": "[G-08] Making constant variables private will save gas during deployment",
  "Content": "\nWhen constants are marked public, extra getter functions are created, increasing the deployment cost. Marking these functions private will decrease gas cost. One can still read these variables through the source code. If they need to be accessed by an external contract, a separate single getter function can be used to return all constants as a tuple. There [are four instances of public constants](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L25-L30).\n\n```solidity\nsrc/LBFactory.sol:25:    uint256 public constant override MAX_FEE = 0.1e18; // 10%\nsrc/LBFactory.sol:27:    uint256 public constant override MIN_BIN_STEP = 1; // 0.01%\nsrc/LBFactory.sol:28:    uint256 public constant override MAX_BIN_STEP = 100; // 1%, can't be greater than 247 for indexing reasons\nsrc/LBFactory.sol:30:    uint256 public constant override MAX_PROTOCOL_SHARE = 2_500; // 25%\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-10-trader-joe-v2-contest",
  "Code": [
    {
      "filename": "src/LBFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin/proxy/Clones.sol\";\nimport \"openzeppelin/utils/structs/EnumerableSet.sol\";\n\nimport \"./LBErrors.sol\";\nimport \"./libraries/Constants.sol\";\nimport \"./libraries/Decoder.sol\";\nimport \"./libraries/PendingOwnable.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./interfaces/ILBFactory.sol\";\n\n/// @title Liquidity Book Factory\n/// @author Trader Joe\n/// @notice Contract used to deploy and register new LBPairs.\n/// Enables setting fee parameters, flashloan fees and LBPair implementation.\n/// Unless the `creationUnlocked` is `true`, only the owner of the factory can create pairs.\ncontract LBFactory is PendingOwnable, ILBFactory {\n    using SafeCast for uint256;\n    using Decoder for bytes32;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public constant override MAX_FEE = 0.1e18; // 10%\n\n    uint256 public constant override MIN_BIN_STEP = 1; // 0.01%\n    uint256 public constant override MAX_BIN_STEP = 100; // 1%, can't be greater than 247 for indexing reasons\n\n    uint256 public constant override MAX_PROTOCOL_SHARE = 2_500; // 25%\n\n    address public override LBPairImplementation;\n\n    address public override feeRecipient;\n\n    uint256 public override flashLoanFee;\n\n    /// @notice Whether the createLBPair function is unlocked and can be called by anyone (true) or only by owner (false)\n    bool public override creationUnlocked;\n\n    ILBPair[] public override allLBPairs;\n\n    /// @dev Mapping from a (tokenA, tokenB, binStep) to a LBPair. The tokens are ordered to save gas, but they can be\n    /// in the reverse order in the actual pair. Always query one of the 2 tokens of the pair to assert the order of the 2 tokens\n    mapping(IERC20 => mapping(IERC20 => mapping(uint256 => LBPairInformation))) private _LBPairsInfo;\n\n    // Whether a preset was set or not, if the bit at `index` is 1, it means that the binStep `index` was set\n    // The max binStep set is 247. We use this method instead of an array to keep it ordered and to reduce gas\n    bytes32 private _availablePresets;\n\n    // The parameters presets\n    mapping(uint256 => bytes32) private _presets;\n\n    EnumerableSet.AddressSet private _quoteAssetWhitelist;\n\n    // Whether a LBPair was created with a bin step, if the bit at `index` is 1, it means that the LBPair with binStep `index` exists\n    // The max binStep set is 247. We use this method instead of an array to keep it ordered and to reduce gas\n    mapping(IERC20 => mapping(IERC20 => bytes32)) private _availableLBPairBinSteps;\n\n    /// @notice Constructor\n    /// @param _feeRecipient The address of the fee recipient\n    /// @param _flashLoanFee The value of the fee for flash loan\n    constructor(address _feeRecipient, uint256 _flashLoanFee) {\n        _setFeeRecipient(_feeRecipient);\n\n        flashLoanFee = _flashLoanFee;\n        emit FlashLoanFeeSet(0, _flashLoanFee);\n    }\n\n    /// @notice View function to return the number of LBPairs created\n    /// @return The number of LBPair\n    function getNumberOfLBPairs() external view override returns (uint256) {\n        return allLBPairs.length;\n    }\n\n    /// @notice View function to return the number of quote assets whitelisted\n    /// @return The number of quote assets\n    function getNumberOfQuoteAssets() external view override returns (uint256) {\n        return _quoteAssetWhitelist.length();\n    }\n\n    /// @notice View function to return the quote asset whitelisted at index `index`\n    /// @param _index The index\n    /// @return The address of the _quoteAsset at index `index`\n    function getQuoteAsset(uint256 _index) external view override returns (IERC20) {\n        return IERC20(_quoteAssetWhitelist.at(_index));\n    }\n\n    /// @notice View function to return whether a token is a quotedAsset (true) or not (false)\n    /// @param _token The address of the asset\n    /// @return Whether the token is a quote asset or not\n    function isQuoteAsset(IERC20 _token) external view override returns (bool) {\n        return _quoteAssetWhitelist.contains(address(_token));\n    }\n\n    /// @notice Returns the LBPairInformation if it exists,\n    /// if not, then the address 0 is returned. The order doesn't matter\n    /// @param _tokenA The address of the first token of the pair\n    /// @param _tokenB The address of the second token of the pair\n    /// @param _binStep The bin step of the LBPair\n    /// @return The LBPairInformation\n    function getLBPairInformation(\n        IERC20 _tokenA,\n        IERC20 _tokenB,\n        uint256 _binStep\n    ) external view override returns (LBPairInformation memory) {\n        return _getLBPairInformation(_tokenA, _tokenB, _binStep);\n    }\n\n    /// @notice View function to return the different parameters of the preset\n    /// @param _binStep The bin step of the preset\n    /// @return baseFactor The base factor\n    /// @return filterPeriod The filter period of the preset\n    /// @return decayPeriod The decay period of the preset\n    /// @return reductionFactor The reduction factor of the preset\n    /// @return variableFeeControl The variable fee control of the preset\n    /// @return protocolShare The protocol share of the preset\n    /// @return maxVolatilityAccumulated The max volatility accumulated of the preset\n    /// @return sampleLifetime The sample lifetime of the preset\n    function getPreset(uint16 _binStep)\n        external\n        view\n        override\n        returns (\n            uint256 baseFactor,\n            uint256 filterPeriod,\n            uint256 decayPeriod,\n            uint256 reductionFactor,\n            uint256 variableFeeControl,\n            uint256 protocolShare,\n            uint256 maxVolatilityAccumulated,\n            uint256 sampleLifetime\n        )\n    {\n        bytes32 _preset = _presets[_binStep];\n        if (_preset == bytes32(0)) revert LBFactory__BinStepHasNoPreset(_binStep);\n\n        uint256 _shift;\n\n        // Safety check\n        assert(_binStep == _preset.decode(type(uint16).max, _shift));\n\n        baseFactor = _preset.decode(type(uint16).max, _shift += 16);\n        filterPeriod = _preset.decode(type(uint16).max, _shift += 16);\n        decayPeriod = _preset.decode(type(uint16).max, _shift += 16);\n        reductionFactor = _preset.decode(type(uint16).max, _shift += 16);\n        variableFeeControl = _preset.decode(type(uint24).max, _shift += 16);\n        protocolShare = _preset.decode(type(uint16).max, _shift += 24);\n        maxVolatilityAccumulated = _preset.decode(type(uint24).max, _shift += 16);\n\n        sampleLifetime = _preset.decode(type(uint16).max, 240);\n    }\n\n    /// @notice View function to return the list of available binStep with a preset\n    /// @return presetsBinStep The list of binStep\n    function getAllBinSteps() external view override returns (uint256[] memory presetsBinStep) {\n        unchecked {\n            bytes32 _avPresets = _availablePresets;\n            uint256 _nbPresets = _avPresets.decode(type(uint8).max, 248);\n\n            if (_nbPresets > 0) {\n                presetsBinStep = new uint256[](_nbPresets);\n\n                uint256 _index;\n                for (uint256 i = MIN_BIN_STEP; i <= MAX_BIN_STEP; ++i) {\n                    if (_avPresets.decode(1, i) == 1) {\n                        presetsBinStep[_index] = i;\n                        if (++_index == _nbPresets) break;\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice View function to return all the LBPair of a pair of tokens\n    /// @param _tokenX The first token of the pair\n    /// @param _tokenY The second token of the pair\n    /// @return LBPairsAvailable The list of available LBPairs\n    function getAllLBPairs(IERC20 _tokenX, IERC20 _tokenY)\n        external\n        view\n        override\n        returns (LBPairInformation[] memory LBPairsAvailable)\n    {\n        unchecked {\n            (IERC20 _tokenA, IERC20 _tokenB) = _sortTokens(_tokenX, _tokenY);\n\n            bytes32 _avLBPairBinSteps = _availableLBPairBinSteps[_tokenA][_tokenB];\n            uint256 _nbAvailable = _avLBPairBinSteps.decode(type(uint8).max, 248);\n\n            if (_nbAvailable > 0) {\n                LBPairsAvailable = new LBPairInformation[](_nbAvailable);\n\n                uint256 _index;\n                for (uint256 i = MIN_BIN_STEP; i <= MAX_BIN_STEP; ++i) {\n                    if (_avLBPairBinSteps.decode(1, i) == 1) {\n                        LBPairInformation memory _LBPairInformation = _LBPairsInfo[_tokenA][_tokenB][i];\n\n                        LBPairsAvailable[_index] = LBPairInformation({\n                            binStep: i.safe24(),\n                            LBPair: _LBPairInformation.LBPair,\n                            createdByOwner: _LBPairInformation.createdByOwner,\n                            ignoredForRouting: _LBPairInformation.ignoredForRouting\n                        });\n                        if (++_index == _nbAvailable) break;\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice Set the LBPair implementation address\n    /// @dev Needs to be called by the owner\n    /// @param _LBPairImplementation The address of the implementation\n    function setLBPairImplementation(address _LBPairImplementation) external override onlyOwner {\n        if (ILBPair(_LBPairImplementation).factory() != this)\n            revert LBFactory__LBPairSafetyCheckFailed(_LBPairImplementation);\n\n        address _oldLBPairImplementation = LBPairImplementation;\n        if (_oldLBPairImplementation == _LBPairImplementation)\n            revert LBFactory__SameImplementation(_LBPairImplementation);\n\n        LBPairImplementation = _LBPairImplementation;\n\n        emit LBPairImplementationSet(_oldLBPairImplementation, _LBPairImplementation);\n    }\n\n    /// @notice Create a liquidity bin LBPair for _tokenX and _tokenY\n    /// @param _tokenX The address of the first token\n    /// @param _tokenY The address of the second token\n    /// @param _activeId The active id of the pair\n    /// @param _binStep The bin step in basis point, used to calculate log(1 + binStep)\n    /// @return _LBPair The address of the newly created LBPair\n    function createLBPair(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint24 _activeId,\n        uint16 _binStep\n    ) external override returns (ILBPair _LBPair) {\n        address _owner = owner();\n        if (!creationUnlocked && msg.sender != _owner) revert LBFactory__FunctionIsLockedForUsers(msg.sender);\n\n        address _LBPairImplementation = LBPairImplementation;\n\n        if (_LBPairImplementation == address(0)) revert LBFactory__ImplementationNotSet();\n\n        if (!_quoteAssetWhitelist.contains(address(_tokenY))) revert LBFactory__QuoteAssetNotWhitelisted(_tokenY);\n\n        if (_tokenX == _tokenY) revert LBFactory__IdenticalAddresses(_tokenX);\n\n        // We sort token for storage efficiency, only one input needs to be stored\n        (IERC20 _tokenA, IERC20 _tokenB) = _sortTokens(_tokenX, _tokenY);\n        // single check is sufficient\n        if (address(_tokenA) == address(0)) revert LBFactory__AddressZero();\n        if (address(_LBPairsInfo[_tokenA][_tokenB][_binStep].LBPair) != address(0))\n            revert LBFactory__LBPairAlreadyExists(_tokenX, _tokenY, _binStep);\n\n        bytes32 _preset = _presets[_binStep];\n        if (_preset == bytes32(0)) revert LBFactory__BinStepHasNoPreset(_binStep);\n\n        uint256 _sampleLifetime = _preset.decode(type(uint16).max, 240);\n        // We remove the bits that are not part of the feeParameters\n        _preset &= bytes32(uint256(type(uint144).max));\n\n        bytes32 _salt = keccak256(abi.encode(_tokenA, _tokenB, _binStep));\n        _LBPair = ILBPair(Clones.cloneDeterministic(_LBPairImplementation, _salt));\n\n        _LBPair.initialize(_tokenX, _tokenY, _activeId, uint16(_sampleLifetime), _preset);\n\n        _LBPairsInfo[_tokenA][_tokenB][_binStep] = LBPairInformation({\n            binStep: _binStep,\n            LBPair: _LBPair,\n            createdByOwner: msg.sender == _owner,\n            ignoredForRouting: false\n        });\n\n        allLBPairs.push(_LBPair);\n\n        {\n            bytes32 _avLBPairBinSteps = _availableLBPairBinSteps[_tokenA][_tokenB];\n            // We add a 1 at bit `_binStep` as this binStep is now set\n            _avLBPairBinSteps = bytes32(uint256(_avLBPairBinSteps) | (1 << _binStep));\n\n            // Increase the number of lb pairs by 1\n            _avLBPairBinSteps = bytes32(uint256(_avLBPairBinSteps) + (1 << 248));\n\n            // Save the changes\n            _availableLBPairBinSteps[_tokenA][_tokenB] = _avLBPairBinSteps;\n        }\n\n        emit LBPairCreated(_tokenX, _tokenY, _binStep, _LBPair, allLBPairs.length - 1);\n\n        emit FeeParametersSet(\n            msg.sender,\n            _LBPair,\n            _binStep,\n            _preset.decode(type(uint16).max, 16),\n            _preset.decode(type(uint16).max, 32),\n            _preset.decode(type(uint16).max, 48),\n            _preset.decode(type(uint16).max, 64),\n            _preset.decode(type(uint24).max, 80),\n            _preset.decode(type(uint16).max, 104),\n            _preset.decode(type(uint24).max, 120)\n        );\n    }\n\n    /// @notice Function to set whether the pair is ignored or not for routing, it will make the pair unusable by the router\n    /// @param _tokenX The address of the first token of the pair\n    /// @param _tokenY The address of the second token of the pair\n    /// @param _binStep The bin step in basis point of the pair\n    /// @param _ignored Whether to ignore (true) or not (false) the pair for routing\n    function setLBPairIgnored(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint256 _binStep,\n        bool _ignored\n    ) external override onlyOwner {\n        (IERC20 _tokenA, IERC20 _tokenB) = _sortTokens(_tokenX, _tokenY);\n\n        LBPairInformation memory _LBPairInformation = _LBPairsInfo[_tokenA][_tokenB][_binStep];\n        if (address(_LBPairInformation.LBPair) == address(0)) revert LBFactory__AddressZero();\n\n        if (_LBPairInformation.ignoredForRouting == _ignored) revert LBFactory__LBPairIgnoredIsAlreadyInTheSameState();\n\n        _LBPairsInfo[_tokenA][_tokenB][_binStep].ignoredForRouting = _ignored;\n\n        emit LBPairIgnoredStateChanged(_LBPairInformation.LBPair, _ignored);\n    }\n\n    /// @notice Sets the preset parameters of a bin step\n    /// @param _binStep The bin step in basis point, used to calculate log(1 + binStep)\n    /// @param _baseFactor The base factor, used to calculate the base fee, baseFee = baseFactor * binStep\n    /// @param _filterPeriod The period where the accumulator value is untouched, prevent spam\n    /// @param _decayPeriod The period where the accumulator value is halved\n    /// @param _reductionFactor The reduction factor, used to calculate the reduction of the accumulator\n    /// @param _variableFeeControl The variable fee control, used to control the variable fee, can be 0 to disable them\n    /// @param _protocolShare The share of the fees received by the protocol\n    /// @param _maxVolatilityAccumulated The max value of the volatility accumulated\n    /// @param _sampleLifetime The lifetime of an oracle's sample\n    function setPreset(\n        uint16 _binStep,\n        uint16 _baseFactor,\n        uint16 _filterPeriod,\n        uint16 _decayPeriod,\n        uint16 _reductionFactor,\n        uint24 _variableFeeControl,\n        uint16 _protocolShare,\n        uint24 _maxVolatilityAccumulated,\n        uint16 _sampleLifetime\n    ) external override onlyOwner {\n        bytes32 _packedFeeParameters = _getPackedFeeParameters(\n            _binStep,\n            _baseFactor,\n            _filterPeriod,\n            _decayPeriod,\n            _reductionFactor,\n            _variableFeeControl,\n            _protocolShare,\n            _maxVolatilityAccumulated\n        );\n\n        // The last 16 bits are reserved for sampleLifetime\n        bytes32 _preset = bytes32(\n            (uint256(_packedFeeParameters) & type(uint144).max) | (uint256(_sampleLifetime) << 240)\n        );\n\n        _presets[_binStep] = _preset;\n\n        bytes32 _avPresets = _availablePresets;\n        if (_avPresets.decode(1, _binStep) == 0) {\n            // We add a 1 at bit `_binStep` as this binStep is now set\n            _avPresets = bytes32(uint256(_avPresets) | (1 << _binStep));\n\n            // Increase the number of preset by 1\n            _avPresets = bytes32(uint256(_avPresets) + (1 << 248));\n\n            // Save the changes\n            _availablePresets = _avPresets;\n        }\n\n        emit PresetSet(\n            _binStep,\n            _baseFactor,\n            _filterPeriod,\n            _decayPeriod,\n            _reductionFactor,\n            _variableFeeControl,\n            _protocolShare,\n            _maxVolatilityAccumulated,\n            _sampleLifetime\n        );\n    }\n\n    /// @notice Remove the preset linked to a binStep\n    /// @param _binStep The bin step to remove\n    function removePreset(uint16 _binStep) external override onlyOwner {\n        if (_presets[_binStep] == bytes32(0)) revert LBFactory__BinStepHasNoPreset(_binStep);\n\n        // Set the bit `_binStep` to 0\n        bytes32 _avPresets = _availablePresets;\n\n        _avPresets &= bytes32(type(uint256).max - (1 << _binStep));\n        _avPresets = bytes32(uint256(_avPresets) - (1 << 248));\n\n        // Save the changes\n        _availablePresets = _avPresets;\n        delete _presets[_binStep];\n\n        emit PresetRemoved(_binStep);\n    }\n\n    /// @notice Function to set the fee parameter of a LBPair\n    /// @param _tokenX The address of the first token\n    /// @param _tokenY The address of the second token\n    /// @param _binStep The bin step in basis point, used to calculate log(1 + binStep)\n    /// @param _baseFactor The base factor, used to calculate the base fee, baseFee = baseFactor * binStep\n    /// @param _filterPeriod The period where the accumulator value is untouched, prevent spam\n    /// @param _decayPeriod The period where the accumulator value is halved\n    /// @param _reductionFactor The reduction factor, used to calculate the reduction of the accumulator\n    /// @param _variableFeeControl The variable fee control, used to control the variable fee, can be 0 to disable them\n    /// @param _protocolShare The share of the fees received by the protocol\n    /// @param _maxVolatilityAccumulated The max value of volatility accumulated\n    function setFeesParametersOnPair(\n        IERC20 _tokenX,\n        IERC20 _tokenY,\n        uint16 _binStep,\n        uint16 _baseFactor,\n        uint16 _filterPeriod,\n        uint16 _decayPeriod,\n        uint16 _reductionFactor,\n        uint24 _variableFeeControl,\n        uint16 _protocolShare,\n        uint24 _maxVolatilityAccumulated\n    ) external override onlyOwner {\n        ILBPair _LBPair = _getLBPairInformation(_tokenX, _tokenY, _binStep).LBPair;\n\n        if (address(_LBPair) == address(0)) revert LBFactory__LBPairNotCreated(_tokenX, _tokenY, _binStep);\n\n        bytes32 _packedFeeParameters = _getPackedFeeParameters(\n            _binStep,\n            _baseFactor,\n            _filterPeriod,\n            _decayPeriod,\n            _reductionFactor,\n            _variableFeeControl,\n            _protocolShare,\n            _maxVolatilityAccumulated\n        );\n\n        _LBPair.setFeesParameters(_packedFeeParameters);\n\n        emit FeeParametersSet(\n            msg.sender,\n            _LBPair,\n            _binStep,\n            _baseFactor,\n            _filterPeriod,\n            _decayPeriod,\n            _reductionFactor,\n            _variableFeeControl,\n            _protocolShare,\n            _maxVolatilityAccumulated\n        );\n    }\n\n    /// @notice Function to set the recipient of the fees. This address needs to be able to receive ERC20s\n    /// @param _feeRecipient The address of the recipient\n    function setFeeRecipient(address _feeRecipient) external override onlyOwner {\n        _setFeeRecipient(_feeRecipient);\n    }\n\n    /// @notice Function to set the flash loan fee\n    /// @param _flashLoanFee The value of the fee for flash loan\n    function setFlashLoanFee(uint256 _flashLoanFee) external override onlyOwner {\n        uint256 _oldFlashLoanFee = flashLoanFee;\n\n        if (_oldFlashLoanFee == _flashLoanFee) revert LBFactory__SameFlashLoanFee(_flashLoanFee);\n\n        flashLoanFee = _flashLoanFee;\n        emit FlashLoanFeeSet(_oldFlashLoanFee, _flashLoanFee);\n    }\n\n    /// @notice Function to set the creation restriction of the Factory\n    /// @param _locked If the creation is restricted (true) or not (false)\n    function setFactoryLockedState(bool _locked) external override onlyOwner {\n        if (creationUnlocked != _locked) revert LBFactory__FactoryLockIsAlreadyInTheSameState();\n        creationUnlocked = !_locked;\n        emit FactoryLockedStatusUpdated(_locked);\n    }\n\n    /// @notice Function to add an asset to the whitelist of quote assets\n    /// @param _quoteAsset The quote asset (e.g: AVAX, USDC...)\n    function addQuoteAsset(IERC20 _quoteAsset) external override onlyOwner {\n        if (!_quoteAssetWhitelist.add(address(_quoteAsset)))\n            revert LBFactory__QuoteAssetAlreadyWhitelisted(_quoteAsset);\n\n        emit QuoteAssetAdded(_quoteAsset);\n    }\n\n    /// @notice Function to remove an asset to the whitelist of quote assets\n    /// @param _quoteAsset The quote asset (e.g: AVAX, USDC...)\n    function removeQuoteAsset(IERC20 _quoteAsset) external override onlyOwner {\n        if (!_quoteAssetWhitelist.remove(address(_quoteAsset))) revert LBFactory__QuoteAssetNotWhitelisted(_quoteAsset);\n\n        emit QuoteAssetRemoved(_quoteAsset);\n    }\n\n    /// @notice Internal function to set the recipient of the fee\n    /// @param _feeRecipient The address of the recipient\n    function _setFeeRecipient(address _feeRecipient) internal {\n        if (_feeRecipient == address(0)) revert LBFactory__AddressZero();\n\n        address _oldFeeRecipient = feeRecipient;\n        if (_oldFeeRecipient == _feeRecipient) revert LBFactory__SameFeeRecipient(_feeRecipient);\n\n        feeRecipient = _feeRecipient;\n        emit FeeRecipientSet(_oldFeeRecipient, _feeRecipient);\n    }\n\n    function forceDecay(ILBPair _LBPair) external override onlyOwner {\n        _LBPair.forceDecay();\n    }\n\n    /// @notice Internal function to set the fee parameter of a LBPair\n    /// @param _binStep The bin step in basis point, used to calculate log(1 + binStep)\n    /// @param _baseFactor The base factor, used to calculate the base fee, baseFee = baseFactor * binStep\n    /// @param _filterPeriod The period where the accumulator value is untouched, prevent spam\n    /// @param _decayPeriod The period where the accumulator value is halved\n    /// @param _reductionFactor The reduction factor, used to calculate the reduction of the accumulator\n    /// @param _variableFeeControl The variable fee control, used to control the variable fee, can be 0 to disable them\n    /// @param _protocolShare The share of the fees received by the protocol\n    /// @param _maxVolatilityAccumulated The max value of volatility accumulated\n    function _getPackedFeeParameters(\n        uint16 _binStep,\n        uint16 _baseFactor,\n        uint16 _filterPeriod,\n        uint16 _decayPeriod,\n        uint16 _reductionFactor,\n        uint24 _variableFeeControl,\n        uint16 _protocolShare,\n        uint24 _maxVolatilityAccumulated\n    ) private pure returns (bytes32) {\n        if (_binStep < MIN_BIN_STEP || _binStep > MAX_BIN_STEP)\n            revert LBFactory__BinStepRequirementsBreached(MIN_BIN_STEP, _binStep, MAX_BIN_STEP);\n\n        if (_baseFactor > Constants.BASIS_POINT_MAX)\n            revert LBFactory__BaseFactorOverflows(_baseFactor, Constants.BASIS_POINT_MAX);\n\n        if (_filterPeriod >= _decayPeriod) revert LBFactory__DecreasingPeriods(_filterPeriod, _decayPeriod);\n\n        if (_reductionFactor > Constants.BASIS_POINT_MAX)\n            revert LBFactory__ReductionFactorOverflows(_reductionFactor, Constants.BASIS_POINT_MAX);\n\n        if (_protocolShare > MAX_PROTOCOL_SHARE)\n            revert LBFactory__ProtocolShareOverflows(_protocolShare, MAX_PROTOCOL_SHARE);\n\n        {\n            uint256 _baseFee = (uint256(_baseFactor) * _binStep) * 1e10;\n\n            // Can't overflow as the max value is `max(uint24) * (max(uint24) * max(uint16)) ** 2 < max(uint104)`\n            // It returns 18 decimals as:\n            // decimals(variableFeeControl * (volatilityAccumulated * binStep)**2 / 100) = 4 + (4 + 4) * 2 - 2 = 18\n            uint256 _prod = uint256(_maxVolatilityAccumulated) * _binStep;\n            uint256 _maxVariableFee = (_prod * _prod * _variableFeeControl) / 100;\n\n            if (_baseFee + _maxVariableFee > MAX_FEE)\n                revert LBFactory__FeesAboveMax(_baseFee + _maxVariableFee, MAX_FEE);\n        }\n\n        /// @dev It's very important that the sum of the sizes of those values is exactly 256 bits\n        /// here, (112 + 24) + 16 + 24 + 16 + 16 + 16 + 16 + 16 = 256\n        return\n            bytes32(\n                abi.encodePacked(\n                    uint136(_maxVolatilityAccumulated), // The first 112 bits are reserved for the dynamic parameters\n                    _protocolShare,\n                    _variableFeeControl,\n                    _reductionFactor,\n                    _decayPeriod,\n                    _filterPeriod,\n                    _baseFactor,\n                    _binStep\n                )\n            );\n    }\n\n    /// @notice Returns the LBPairInformation if it exists,\n    /// if not, then the address 0 is returned. The order doesn't matter\n    /// @param _tokenA The address of the first token of the pair\n    /// @param _tokenB The address of the second token of the pair\n    /// @param _binStep The bin step of the LBPair\n    /// @return The LBPairInformation\n    function _getLBPairInformation(\n        IERC20 _tokenA,\n        IERC20 _tokenB,\n        uint256 _binStep\n    ) private view returns (LBPairInformation memory) {\n        (_tokenA, _tokenB) = _sortTokens(_tokenA, _tokenB);\n        return _LBPairsInfo[_tokenA][_tokenB][_binStep];\n    }\n\n    /// @notice Private view function to sort 2 tokens in ascending order\n    /// @param _tokenA The first token\n    /// @param _tokenB The second token\n    /// @return The sorted first token\n    /// @return The sorted second token\n    function _sortTokens(IERC20 _tokenA, IERC20 _tokenB) private pure returns (IERC20, IERC20) {\n        if (_tokenA > _tokenB) (_tokenA, _tokenB) = (_tokenB, _tokenA);\n        return (_tokenA, _tokenB);\n    }\n}"
    }
  ]
}