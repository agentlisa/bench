{
  "Title": "Overwriting ERC-20 Metadata Can Cause Unexpected Behaviors",
  "Content": "The `L2StandardERC20` contract is the default contract that is deployed when any ERC-20 token is bridged for the first time. This contract has been extended with a [`reinitializeToken` function](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/zksync/contracts/bridge/L2StandardERC20.sol#L104) that allows the Beacon owner to overwrite the `symbol`, `name`, and `decimals` state variables. This feature is particularly beneficial when token developers aim to deploy an official custom contract on the L2, enabling differentiation between the official and default token by altering the symbol and the name. While the rationale for updating the token symbol and name is valid, modifying the decimal value could result in unpredictable behavior and thus introduce significant risk. Furthermore, note that by [setting a new name](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/zksync/contracts/bridge/L2StandardERC20.sol#L117) in the `EIP712Upgradeable` contract through the `ERC20PermitUpgradeable` contract, previously signed permits will become invalid.\n\n\nTo mitigate these risks, consider removing the option of overwriting the `decimals` value in the `reinitializeToken` function. Moreover, consider issuing clear warnings regarding any changes in the token's name in order to ensure that users are fully aware of the potential invalidation of their previously signed permits.\n\n\n***Update:** Resolved in [pull request #139](https://github.com/matter-labs/era-contracts/pull/139) at commit [a6ceba0](https://github.com/matter-labs/era-contracts/pull/139/commits/a6ceba003ae6db85d5bea097b286763864bf4263). The `decimals` overwrite was removed from the function.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "zksync/contracts/bridge/L2StandardERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\";\n\nimport \"./interfaces/IL2StandardToken.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice The ERC20 token implementation, that is used in the \"default\" ERC20 bridge\ncontract L2StandardERC20 is ERC20PermitUpgradeable, IL2StandardToken, ERC1967Upgrade {\n    /// @dev Describes whether there is a specific getter in the token.\n    /// @notice Used to explicitly separate which getters the token has and which it does not.\n    /// @notice Different tokens in L1 can implement or not implement getter function as `name`/`symbol`/`decimals`,\n    /// @notice Our goal is to store all the getters that L1 token implements, and for others, we keep it as an unimplemented method.\n    struct ERC20Getters {\n        bool ignoreName;\n        bool ignoreSymbol;\n        bool ignoreDecimals;\n    }\n\n    ERC20Getters availableGetters;\n\n    /// @dev The decimals of the token, that are used as a value for `decimals` getter function.\n    /// @notice A private variable is used only for decimals, but not for `name` and `symbol`, because standard\n    /// @notice OpenZeppelin token represents `name` and `symbol` as storage variables and `decimals` as constant.\n    uint8 private decimals_;\n\n    /// @dev Address of the L2 bridge that is used as trustee who can mint/burn tokens\n    address public override l2Bridge;\n\n    /// @dev Address of the L1 token that can be deposited to mint this L2 token\n    address public override l1Address;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    constructor() {\n        // Disable initialization to prevent Parity hack.\n        _disableInitializers();\n    }\n\n    /// @notice Initializes a contract token for later use. Expected to be used in the proxy.\n    /// @dev Stores the L1 address of the bridge and set `name`/`symbol`/`decimals` getters that L1 token has.\n    /// @param _l1Address Address of the L1 token that can be deposited to mint this L2 token\n    /// @param _data The additional data that the L1 bridge provide for initialization.\n    /// In this case, it is packed `name`/`symbol`/`decimals` of the L1 token.\n    function bridgeInitialize(address _l1Address, bytes memory _data) external initializer {\n        require(_l1Address != address(0), \"in6\"); // Should be non-zero address\n        l1Address = _l1Address;\n\n        l2Bridge = msg.sender;\n\n        // We parse the data exactly as they were created on the L1 bridge\n        (bytes memory nameBytes, bytes memory symbolBytes, bytes memory decimalsBytes) = abi.decode(\n            _data,\n            (bytes, bytes, bytes)\n        );\n\n        ERC20Getters memory getters;\n        string memory decodedName;\n        string memory decodedSymbol;\n\n        // L1 bridge didn't check if the L1 token return values with proper types for `name`/`symbol`/`decimals`\n        // That's why we need to try to decode them, and if it works out, set the values as getters.\n\n        // NOTE: Solidity doesn't have a convenient way to try to decode a value:\n        // - Decode them manually, i.e. write a function that will validate that data in the correct format\n        // and return decoded value and a boolean value - whether it was possible to decode.\n        // - Use the standard abi.decode method, but wrap it into an external call in which error can be handled.\n        // We use the second option here.\n\n        try this.decodeString(nameBytes) returns (string memory nameString) {\n            decodedName = nameString;\n        } catch {\n            getters.ignoreName = true;\n        }\n\n        try this.decodeString(symbolBytes) returns (string memory symbolString) {\n            decodedSymbol = symbolString;\n        } catch {\n            getters.ignoreSymbol = true;\n        }\n\n        // Set decoded values for name and symbol.\n        __ERC20_init_unchained(decodedName, decodedSymbol);\n\n        // Set the name for EIP-712 signature.\n        __ERC20Permit_init(decodedName);\n\n        try this.decodeUint8(decimalsBytes) returns (uint8 decimalsUint8) {\n            // Set decoded value for decimals.\n            decimals_ = decimalsUint8;\n        } catch {\n            getters.ignoreDecimals = true;\n        }\n\n        availableGetters = getters;\n        emit BridgeInitialize(_l1Address, decodedName, decodedSymbol, decimals_);\n    }\n\n    // Method which is to be used by bridge if a token needs to change its name, symbol or decimals.\n    function reinitializeToken(\n        ERC20Getters calldata _availableGetters,\n        string memory _newName,\n        string memory _newSymbol,\n        uint8 _newDecimals,\n        uint8 _version\n    ) external onlyNextVersion(_version) reinitializer(_version) {\n        // It is expected that this token is deployed as a beacon proxy, so we'll\n        // allow the governor of the beacon to reinitialize the token.\n        address beaconAddress = _getBeacon();\n        require(msg.sender == UpgradeableBeacon(beaconAddress).owner(), \"tt\");\n\n        __ERC20_init_unchained(_newName, _newSymbol);\n        __ERC20Permit_init(_newName);\n        decimals_ = _newDecimals;\n        availableGetters = _availableGetters;\n\n        emit BridgeInitialize(l1Address, _newName, _newSymbol, _newDecimals);\n    }\n\n    modifier onlyBridge() {\n        require(msg.sender == l2Bridge, \"xnt\"); // Only L2 bridge can call this method\n        _;\n    }\n\n    modifier onlyNextVersion(uint8 _version) {\n        // The version should be incremented by 1. Otherwise, the governor risks disabling\n        // future reinitialization of the token by providing too large a version.\n        require(_version == _getInitializedVersion() + 1, \"v\");\n        _;\n    }\n\n    /// @dev Mint tokens to a given account.\n    /// @param _to The account that will receive the created tokens.\n    /// @param _amount The amount that will be created.\n    /// @notice Should be called by bridge after depositing tokens from L1.\n    function bridgeMint(address _to, uint256 _amount) external override onlyBridge {\n        _mint(_to, _amount);\n        emit BridgeMint(_to, _amount);\n    }\n\n    /// @dev Burn tokens from a given account.\n    /// @param _from The account from which tokens will be burned.\n    /// @param _amount The amount that will be burned.\n    /// @notice Should be called by bridge before withdrawing tokens to L1.\n    function bridgeBurn(address _from, uint256 _amount) external override onlyBridge {\n        _burn(_from, _amount);\n        emit BridgeBurn(_from, _amount);\n    }\n\n    function name() public view override returns (string memory) {\n        // If method is not available, behave like a token that does not implement this method - revert on call.\n        if (availableGetters.ignoreName) revert();\n        return super.name();\n    }\n\n    function symbol() public view override returns (string memory) {\n        // If method is not available, behave like a token that does not implement this method - revert on call.\n        if (availableGetters.ignoreSymbol) revert();\n        return super.symbol();\n    }\n\n    function decimals() public view override returns (uint8) {\n        // If method is not available, behave like a token that does not implement this method - revert on call.\n        if (availableGetters.ignoreDecimals) revert();\n        return decimals_;\n    }\n\n    /// @dev External function to decode a string from bytes.\n    function decodeString(bytes memory _input) external pure returns (string memory result) {\n        (result) = abi.decode(_input, (string));\n    }\n\n    /// @dev External function to decode a uint8 from bytes.\n    function decodeUint8(bytes memory _input) external pure returns (uint8 result) {\n        (result) = abi.decode(_input, (uint8));\n    }\n}"
    }
  ]
}