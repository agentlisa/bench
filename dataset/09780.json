{
  "Title": "[M-09] Improper Upper Bound Definition on the Fee",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/token/TokenManager.sol#L51\nhttps://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/token/TokenManager.sol#L52\n\n\n# Vulnerability details\n\n## Impact\n\nThe **equilibriumFee** and **maxFee** does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions or the LP user will lost all funds when paying the fee.\n\n## Proof of Concept\n\n1. Navigate to the following contract.\n\nhttps://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/token/TokenManager.sol#L52\n\n2. Owner can identify fee amount. That directly affect to LP management. (https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityPool.sol#L352)\n\n3. Here you can see there is no upper bound has been defined. \n\n```\n    function changeFee(\n        address tokenAddress,\n        uint256 _equilibriumFee,\n        uint256 _maxFee\n    ) external override onlyOwner whenNotPaused {\n        require(_equilibriumFee != 0, \"Equilibrium Fee cannot be 0\");\n        require(_maxFee != 0, \"Max Fee cannot be 0\");\n        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;\n        tokensInfo[tokenAddress].maxFee = _maxFee;\n        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);\n    }\n\n```\n\n## Tools Used\n\nCode Review\n\n## Recommended Mitigation Steps\n\nConsider defining upper and lower bounds on the **equilibriumFee** and **maxFee**.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-biconomy-hyphen-20-contest",
  "Code": [
    {
      "filename": "contracts/hyphen/token/TokenManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"../metatx/ERC2771Context.sol\";\nimport \"../interfaces/ITokenManager.sol\";\n\ncontract TokenManager is ITokenManager, ERC2771Context, Ownable, Pausable {\n    mapping(address => TokenInfo) public tokensInfo;\n\n    event FeeChanged(address indexed tokenAddress, uint256 indexed equilibriumFee, uint256 indexed maxFee);\n\n    modifier tokenChecks(address tokenAddress) {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(tokensInfo[tokenAddress].supportedToken, \"Token not supported\");\n\n        _;\n    }\n\n    /**\n     * First key is toChainId and second key is token address being deposited on current chain\n     */\n    mapping(uint256 => mapping(address => TokenConfig)) public depositConfig;\n\n    /**\n     * Store min/max amount of token to transfer based on token address\n     */\n    mapping(address => TokenConfig) public transferConfig;\n\n    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {\n        // Empty Constructor\n    }\n\n    function getEquilibriumFee(address tokenAddress) public view override returns (uint256) {\n        return tokensInfo[tokenAddress].equilibriumFee;\n    }\n\n    function getMaxFee(address tokenAddress) public view override returns (uint256) {\n        return tokensInfo[tokenAddress].maxFee;\n    }\n\n    function changeFee(\n        address tokenAddress,\n        uint256 _equilibriumFee,\n        uint256 _maxFee\n    ) external override onlyOwner whenNotPaused {\n        require(_equilibriumFee != 0, \"Equilibrium Fee cannot be 0\");\n        require(_maxFee != 0, \"Max Fee cannot be 0\");\n        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;\n        tokensInfo[tokenAddress].maxFee = _maxFee;\n        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);\n    }\n\n    function setTokenTransferOverhead(address tokenAddress, uint256 gasOverhead)\n        external\n        tokenChecks(tokenAddress)\n        onlyOwner\n    {\n        tokensInfo[tokenAddress].transferOverhead = gasOverhead;\n    }\n\n    /**\n     * Set DepositConfig for the given combination of toChainId, tokenAddress.\n     * This is used while depositing token in Liquidity Pool. Based on the destination chainid\n     * min and max deposit amount is checked.\n     */\n    function setDepositConfig(\n        uint256[] memory toChainId,\n        address[] memory tokenAddresses,\n        TokenConfig[] memory tokenConfig\n    ) external onlyOwner {\n        require(\n            (toChainId.length == tokenAddresses.length) && (tokenAddresses.length == tokenConfig.length),\n            \" ERR_ARRAY_LENGTH_MISMATCH\"\n        );\n        for (uint256 index = 0; index < tokenConfig.length; ++index) {\n            depositConfig[toChainId[index]][tokenAddresses[index]].min = tokenConfig[index].min;\n            depositConfig[toChainId[index]][tokenAddresses[index]].max = tokenConfig[index].max;\n        }\n    }\n\n    function addSupportedToken(\n        address tokenAddress,\n        uint256 minCapLimit,\n        uint256 maxCapLimit,\n        uint256 equilibriumFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(maxCapLimit > minCapLimit, \"maxCapLimit > minCapLimit\");\n        tokensInfo[tokenAddress].supportedToken = true;\n        transferConfig[tokenAddress].min = minCapLimit;\n        transferConfig[tokenAddress].max = maxCapLimit;\n        tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];\n        tokensInfo[tokenAddress].equilibriumFee = equilibriumFee;\n        tokensInfo[tokenAddress].maxFee = maxFee;\n    }\n\n    function removeSupportedToken(address tokenAddress) external tokenChecks(tokenAddress) onlyOwner {\n        tokensInfo[tokenAddress].supportedToken = false;\n    }\n\n    function updateTokenCap(\n        address tokenAddress,\n        uint256 minCapLimit,\n        uint256 maxCapLimit\n    ) external tokenChecks(tokenAddress) onlyOwner {\n        require(maxCapLimit > minCapLimit, \"maxCapLimit > minCapLimit\");\n        transferConfig[tokenAddress].min = minCapLimit;\n        transferConfig[tokenAddress].max = maxCapLimit;\n    }\n\n    function getTokensInfo(address tokenAddress) public view override returns (TokenInfo memory) {\n        TokenInfo memory tokenInfo = TokenInfo(\n            tokensInfo[tokenAddress].transferOverhead,\n            tokensInfo[tokenAddress].supportedToken,\n            tokensInfo[tokenAddress].equilibriumFee,\n            tokensInfo[tokenAddress].maxFee,\n            transferConfig[tokenAddress]\n        );\n        return tokenInfo;\n    }\n\n    function getDepositConfig(uint256 toChainId, address tokenAddress)\n        public\n        view\n        override\n        returns (TokenConfig memory)\n    {\n        return depositConfig[toChainId][tokenAddress];\n    }\n\n    function getTransferConfig(address tokenAddress) public view override returns (TokenConfig memory) {\n        return transferConfig[tokenAddress];\n    }\n\n    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address sender) {\n        return ERC2771Context._msgSender();\n    }\n\n    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n}"
    },
    {
      "filename": "contracts/hyphen/token/TokenManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"../metatx/ERC2771Context.sol\";\nimport \"../interfaces/ITokenManager.sol\";\n\ncontract TokenManager is ITokenManager, ERC2771Context, Ownable, Pausable {\n    mapping(address => TokenInfo) public tokensInfo;\n\n    event FeeChanged(address indexed tokenAddress, uint256 indexed equilibriumFee, uint256 indexed maxFee);\n\n    modifier tokenChecks(address tokenAddress) {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(tokensInfo[tokenAddress].supportedToken, \"Token not supported\");\n\n        _;\n    }\n\n    /**\n     * First key is toChainId and second key is token address being deposited on current chain\n     */\n    mapping(uint256 => mapping(address => TokenConfig)) public depositConfig;\n\n    /**\n     * Store min/max amount of token to transfer based on token address\n     */\n    mapping(address => TokenConfig) public transferConfig;\n\n    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {\n        // Empty Constructor\n    }\n\n    function getEquilibriumFee(address tokenAddress) public view override returns (uint256) {\n        return tokensInfo[tokenAddress].equilibriumFee;\n    }\n\n    function getMaxFee(address tokenAddress) public view override returns (uint256) {\n        return tokensInfo[tokenAddress].maxFee;\n    }\n\n    function changeFee(\n        address tokenAddress,\n        uint256 _equilibriumFee,\n        uint256 _maxFee\n    ) external override onlyOwner whenNotPaused {\n        require(_equilibriumFee != 0, \"Equilibrium Fee cannot be 0\");\n        require(_maxFee != 0, \"Max Fee cannot be 0\");\n        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;\n        tokensInfo[tokenAddress].maxFee = _maxFee;\n        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);\n    }\n\n    function setTokenTransferOverhead(address tokenAddress, uint256 gasOverhead)\n        external\n        tokenChecks(tokenAddress)\n        onlyOwner\n    {\n        tokensInfo[tokenAddress].transferOverhead = gasOverhead;\n    }\n\n    /**\n     * Set DepositConfig for the given combination of toChainId, tokenAddress.\n     * This is used while depositing token in Liquidity Pool. Based on the destination chainid\n     * min and max deposit amount is checked.\n     */\n    function setDepositConfig(\n        uint256[] memory toChainId,\n        address[] memory tokenAddresses,\n        TokenConfig[] memory tokenConfig\n    ) external onlyOwner {\n        require(\n            (toChainId.length == tokenAddresses.length) && (tokenAddresses.length == tokenConfig.length),\n            \" ERR_ARRAY_LENGTH_MISMATCH\"\n        );\n        for (uint256 index = 0; index < tokenConfig.length; ++index) {\n            depositConfig[toChainId[index]][tokenAddresses[index]].min = tokenConfig[index].min;\n            depositConfig[toChainId[index]][tokenAddresses[index]].max = tokenConfig[index].max;\n        }\n    }\n\n    function addSupportedToken(\n        address tokenAddress,\n        uint256 minCapLimit,\n        uint256 maxCapLimit,\n        uint256 equilibriumFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(maxCapLimit > minCapLimit, \"maxCapLimit > minCapLimit\");\n        tokensInfo[tokenAddress].supportedToken = true;\n        transferConfig[tokenAddress].min = minCapLimit;\n        transferConfig[tokenAddress].max = maxCapLimit;\n        tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];\n        tokensInfo[tokenAddress].equilibriumFee = equilibriumFee;\n        tokensInfo[tokenAddress].maxFee = maxFee;\n    }\n\n    function removeSupportedToken(address tokenAddress) external tokenChecks(tokenAddress) onlyOwner {\n        tokensInfo[tokenAddress].supportedToken = false;\n    }\n\n    function updateTokenCap(\n        address tokenAddress,\n        uint256 minCapLimit,\n        uint256 maxCapLimit\n    ) external tokenChecks(tokenAddress) onlyOwner {\n        require(maxCapLimit > minCapLimit, \"maxCapLimit > minCapLimit\");\n        transferConfig[tokenAddress].min = minCapLimit;\n        transferConfig[tokenAddress].max = maxCapLimit;\n    }\n\n    function getTokensInfo(address tokenAddress) public view override returns (TokenInfo memory) {\n        TokenInfo memory tokenInfo = TokenInfo(\n            tokensInfo[tokenAddress].transferOverhead,\n            tokensInfo[tokenAddress].supportedToken,\n            tokensInfo[tokenAddress].equilibriumFee,\n            tokensInfo[tokenAddress].maxFee,\n            transferConfig[tokenAddress]\n        );\n        return tokenInfo;\n    }\n\n    function getDepositConfig(uint256 toChainId, address tokenAddress)\n        public\n        view\n        override\n        returns (TokenConfig memory)\n    {\n        return depositConfig[toChainId][tokenAddress];\n    }\n\n    function getTransferConfig(address tokenAddress) public view override returns (TokenConfig memory) {\n        return transferConfig[tokenAddress];\n    }\n\n    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address sender) {\n        return ERC2771Context._msgSender();\n    }\n\n    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n}"
    }
  ]
}