{
  "Title": "M-4: Lender can front-run `rollLoan` and call `provideNewTermsForRoll` with unfavorable terms",
  "Content": "# Issue M-4: Lender can front-run `rollLoan` and call `provideNewTermsForRoll` with unfavorable terms \n\nSource: https://github.com/sherlock-audit/2023-08-cooler-judging/issues/243 \n\n## Found by \n0xbepresent, Breeje, banditx0x, cats, deadrxsezzz, detectiveking, evilakela, harisnabeel, james\\_wu, pep7siup, radevauditor, sandy, ubl4nk\nLender can front-run `rollLoan` and result in borrower accepting unfavorable terms.\n\n## Vulnerability Detail\nAfter a loan is created, the lender can provide new loan terms via `provideNewTermsForRoll`. If they are reasonable, the user can then accept them. However this opens up a risky scenario: \n1. User A borrows from lender B \n2. Lender B proposes new suitable terms \n3. User A sees them and calls `rollLoan` to accept them\n4. Lender B is waiting for this and sees the pending transaction in the mempool\n5. Lender B front-runs user A's transaction and makes a new call to `provideNewTermsForRoll` will an extremely high interest rate\n6. User A's transaction now executes and they've accepted unfavorable terms with extremely high interest rate\n\n## Impact\nUser may get mislead in to accepting unfavorable terms and overpaying interest \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-08-cooler/blob/main/Cooler/src/Cooler.sol#L192\nhttps://github.com/sherlock-audit/2023-08-cooler/blob/main/Cooler/src/Cooler.sol#L282\n\n## Tool used\n\nManual Review\n\n## Recommendation\nWhen calling `rollLoan` let the user pass a parameter consisting of the max interest rate they are willing to accept to prevent from such incidents.\n\n\n\n\n\n## Discussion\n\n**0xRusowsky**\n\n- https://github.com/ohmzeus/Cooler/pull/63\n\n**jkoppel**\n\nThis is moot because rollLoan no longer exists.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/107",
  "Code": [
    {
      "filename": "Cooler/src/Cooler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Clone} from \"clones/Clone.sol\";\n\nimport {IDelegate} from \"interfaces/IDelegate.sol\";\nimport {CoolerFactory} from \"src/CoolerFactory.sol\";\nimport {CoolerCallback} from \"src/CoolerCallback.sol\";\n\n/// @title  Cooler Loans.\n/// @notice A Cooler is a smart contract escrow that facilitates fixed-duration, peer-to-peer\n///         loans for a user-defined debt-collateral pair.\n/// @dev    This contract uses Clones (https://github.com/wighawag/clones-with-immutable-args)\n///         to save gas on deployment.\ncontract Cooler is Clone {\n    using SafeTransferLib for ERC20;\n\n    // --- ERRORS ----------------------------------------------------\n\n    error OnlyApproved();\n    error Deactivated();\n    error Default();\n    error NoDefault();\n    error NotRollable();\n    error ZeroCollateralReturned();\n    error NotCoolerCallback();\n\n    // --- DATA STRUCTURES -------------------------------------------\n\n    /// @notice A loan begins with a borrow request.\n    struct Request {\n        uint256 amount;             // Amount to be borrowed.\n        uint256 interest;           // Annualized percentage to be paid as interest.\n        uint256 loanToCollateral;   // Requested loan-to-collateral ratio.\n        uint256 duration;           // Time to repay the loan before it defaults.\n        bool active;                // Any lender can clear an active loan request.\n    }\n\n    /// @notice A request is converted to a loan when a lender clears it.\n    struct Loan {\n        Request request;        // Loan terms specified in the request.\n        uint256 amount;         // Amount of debt owed to the lender.\n        uint256 unclaimed;      // Amount of debt tokens repaid but unclaimed.\n        uint256 collateral;     // Amount of collateral pledged.\n        uint256 expiry;         // Time when the loan defaults.\n        address lender;         // Lender's address.\n        bool repayDirect;       // If this is false, repaid tokens must be claimed by lender.\n        bool callback;          // If this is true, the lender must inherit CoolerCallback.\n    }\n\n    // --- IMMUTABLES ------------------------------------------------\n\n    // This makes the code look prettier.\n    uint256 private constant DECIMALS_INTEREST = 1e18;\n\n    /// @notice This address owns the collateral in escrow.\n    function owner() public pure returns (address _owner) {\n        return _getArgAddress(0x0);\n    }\n\n    /// @notice This token is borrowed against.\n    function collateral() public pure returns (ERC20 _collateral) {\n        return ERC20(_getArgAddress(0x14));\n    }\n\n    /// @notice This token is lent.\n    function debt() public pure returns (ERC20 _debt) {\n        return ERC20(_getArgAddress(0x28));\n    }\n    \n    /// @notice This contract created the Cooler\n    function factory() public pure returns (CoolerFactory _factory) {\n        return CoolerFactory(_getArgAddress(0x3c));\n    }\n\n    // --- STATE VARIABLES -------------------------------------------\n\n    /// @notice Arrays stores all the loan requests.\n    Request[] public requests;\n\n    /// @notice Arrays stores all the granted loans.\n    Loan[] public loans;\n\n    /// @notice Facilitates transfer of lender ownership to new addresses\n    mapping(uint256 => address) public approvals;\n\n    // --- BORROWER --------------------------------------------------\n\n    /// @notice Request a loan with given parameters.\n    ///         Collateral is taken at time of request.\n    /// @param  amount_ of debt tokens to borrow.\n    /// @param  interest_ to pay (annualized % of 'amount_'). Expressed in DECIMALS_INTEREST.\n    /// @param  loanToCollateral_ debt tokens per collateral token pledged. Expressed in 10**debt().decimals().\n    /// @param  duration_ of loan tenure in seconds.\n    /// @return reqID of the created request. Equivalent to the index of request in requests[].\n    function requestLoan(\n        uint256 amount_,\n        uint256 interest_,\n        uint256 loanToCollateral_,\n        uint256 duration_\n    ) external returns (uint256 reqID) {\n        reqID = requests.length;\n        requests.push(\n            Request({\n                amount: amount_,\n                interest: interest_,\n                loanToCollateral: loanToCollateral_,\n                duration: duration_,\n                active: true\n            })\n        );\n\n        // The collateral is taken upfront. Will be escrowed\n        // until the loan is repaid or defaulted.\n        collateral().safeTransferFrom(\n            msg.sender,\n            address(this),\n            collateralFor(amount_, loanToCollateral_)\n        );\n\n        // Log the event.\n        factory().newEvent(reqID, CoolerFactory.Events.RequestLoan, 0);\n    }\n\n    /// @notice Cancel a loan request and get the collateral back.\n    /// @param  reqID_ index of request in requests[].\n    function rescindRequest(uint256 reqID_) external {\n        if (msg.sender != owner()) revert OnlyApproved();\n\n        Request storage req = requests[reqID_];\n\n        if (!req.active) revert Deactivated();\n\n        // Update storage and send collateral back to the owner.\n        req.active = false;\n        collateral().safeTransfer(owner(), collateralFor(req.amount, req.loanToCollateral));\n\n        // Log the event.\n        factory().newEvent(reqID_, CoolerFactory.Events.RescindRequest, 0);\n    }\n\n    /// @notice Repay a loan to get the collateral back.\n    /// @dev    Despite a malicious lender could reenter with the callback, the\n    ///         usage of `msg.sender` prevents any economical benefit to the\n    ///         attacker, since they would be repaying the loan themselves.\n    /// @param  loanID_ index of loan in loans[]\n    /// @param  repaid_ debt tokens to be repaid.\n    /// @return collateral given back to the borrower.\n    function repayLoan(uint256 loanID_, uint256 repaid_) external returns (uint256) {\n        Loan memory loan = loans[loanID_];\n\n        if (block.timestamp > loan.expiry) revert Default();\n\n        if (repaid_ > loan.amount) repaid_ = loan.amount;\n\n        uint256 decollateralized = (loan.collateral * repaid_) / loan.amount;\n        if (decollateralized == 0) revert ZeroCollateralReturned();\n\n        // Update loan memory.\n        loan.amount -= repaid_;\n        loan.collateral -= decollateralized;\n\n        address repayTo;\n        // Check whether repayment needs to be manually claimed or not.\n        if (loan.repayDirect) {\n            repayTo = loan.lender;\n        } else {\n            repayTo = address(this);\n            loan.unclaimed += repaid_;\n        }\n\n        // Save updated loan info in storage.\n        loans[loanID_] = loan;\n\n        // Transfer repaid debt back to the lender and (de)collateral back to the owner.\n        debt().safeTransferFrom(msg.sender, repayTo, repaid_);\n        collateral().safeTransfer(owner(), decollateralized);\n\n        // Log the event.\n        factory().newEvent(loanID_, CoolerFactory.Events.RepayLoan, repaid_);\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onRepay(loanID_, repaid_);\n        return decollateralized;\n    }\n\n    /// @notice Roll a loan over with new terms.\n    ///         provideNewTermsForRoll must have been called beforehand by the lender.\n    /// @param  loanID_ index of loan in loans[].\n    function rollLoan(uint256 loanID_) external {\n        Loan memory loan = loans[loanID_];\n\n        if (block.timestamp > loan.expiry) revert Default();\n        if (!loan.request.active) revert NotRollable();\n\n        // Check whether rolling the loan requires pledging more collateral or not (if there was a previous repayment).\n        uint256 newCollateral = newCollateralFor(loanID_);\n        uint256 newDebt = interestFor(loan.amount, loan.request.interest, loan.request.duration);\n\n        // Update memory accordingly.\n        loan.amount += newDebt;\n        loan.collateral += newCollateral;\n        loan.expiry += loan.request.duration;\n        loan.request.active = false;\n\n        // Save updated loan info in storage.\n        loans[loanID_] = loan;\n\n        if (newCollateral > 0) {\n            collateral().safeTransferFrom(msg.sender, address(this), newCollateral);\n        }\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onRoll(loanID_, newDebt, newCollateral);\n    }\n\n    /// @notice Delegate voting power on collateral.\n    /// @param  to_ address to delegate.\n    function delegateVoting(address to_) external {\n        if (msg.sender != owner()) revert OnlyApproved();\n        IDelegate(address(collateral())).delegate(to_);\n    }\n\n    // --- LENDER ----------------------------------------------------\n\n    /// @notice Fill a requested loan as a lender.\n    /// @param  reqID_ index of request in requests[].\n    /// @param  repayDirect_ lender should input false if concerned about debt token blacklisting.\n    /// @param  isCallback_ true if the lender implements the CoolerCallback abstract. False otherwise.\n    /// @return loanID of the granted loan. Equivalent to the index of loan in loans[].\n    function clearRequest(\n        uint256 reqID_,\n        bool repayDirect_,\n        bool isCallback_\n    ) external returns (uint256 loanID) {\n        Request memory req = requests[reqID_];\n\n        // If necessary, ensure lender implements the CoolerCallback abstract.\n        if (isCallback_ && !CoolerCallback(msg.sender).isCoolerCallback()) revert NotCoolerCallback();\n\n        // Ensure loan request is active. \n        if (!req.active) revert Deactivated();\n\n        // Clear the loan request in memory.\n        req.active = false;\n\n        // Calculate and store loan terms.\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n        uint256 expiration = block.timestamp + req.duration;\n        loanID = loans.length;\n        loans.push(\n            Loan({\n                request: req,\n                amount: req.amount + interest,\n                unclaimed: 0,\n                collateral: collat,\n                expiry: expiration,\n                lender: msg.sender,\n                repayDirect: repayDirect_,\n                callback: isCallback_\n            })\n        );\n\n        // Clear the loan request storage.\n        requests[reqID_].active = false;\n\n        // Transfer debt tokens to the owner of the request.\n        debt().safeTransferFrom(msg.sender, owner(), req.amount);\n\n        // Log the event.\n        factory().newEvent(reqID_, CoolerFactory.Events.ClearRequest, 0);\n    }\n\n    /// @notice Provide new terms for loan to be rolled over.\n    /// @param  loanID_ index of loan in loans[].\n    /// @param  interest_ to pay (annualized % of 'amount_'). Expressed in DECIMALS_INTEREST.\n    /// @param  loanToCollateral_ debt tokens per collateral token pledged. Expressed in 10**debt().decimals().\n    /// @param  duration_ of loan tenure in seconds.\n    function provideNewTermsForRoll(\n        uint256 loanID_,\n        uint256 interest_,\n        uint256 loanToCollateral_,\n        uint256 duration_\n    ) external {\n        Loan storage loan = loans[loanID_];\n\n        if (msg.sender != loan.lender) revert OnlyApproved();\n\n        loan.request =\n            Request(\n                loan.amount,\n                interest_,\n                loanToCollateral_,\n                duration_,\n                true\n            );\n    }\n\n    /// @notice Claim debt tokens if repayDirect was false.\n    /// @param  loanID_ index of loan in loans[].\n    function claimRepaid(uint256 loanID_) external {\n        Loan memory loan = loans[loanID_];\n\n        // Update storage.\n        uint256 claim = loan.unclaimed;\n        delete loans[loanID_].unclaimed;\n\n        // Transfer repaid debt back to the lender.\n        debt().safeTransfer(loan.lender, claim);\n    }\n\n    /// @notice Claim collateral upon loan default.\n    /// @param loanID_ index of loan in loans[]\n    /// @return defaulted debt by the borrower, collateral kept by the lender, elapsed time since expiry.\n    function claimDefaulted(uint256 loanID_) external returns (uint256, uint256, uint256) {\n        Loan memory loan = loans[loanID_];\n        delete loans[loanID_];\n\n        if (block.timestamp <= loan.expiry) revert NoDefault();\n\n        // Transfer defaulted collateral to the lender.\n        collateral().safeTransfer(loan.lender, loan.collateral);\n\n        // Log the event.\n        factory().newEvent(loanID_, CoolerFactory.Events.DefaultLoan, 0);\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onDefault(loanID_, loan.amount, loan.collateral);\n        return (loan.amount, loan.collateral, block.timestamp - loan.expiry);\n    }\n\n    /// @notice Approve transfer of loan ownership rights to a new address.\n    /// @param  to_ address to be approved.\n    /// @param  loanID_ index of loan in loans[].\n    function approveTransfer(address to_, uint256 loanID_) external {\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\n\n        // Update transfer approvals.\n        approvals[loanID_] = to_;\n    }\n\n    /// @notice Execute loan ownership transfer. Must be previously approved by the lender.\n    /// @param  loanID_ index of loan in loans[].\n    function transferOwnership(uint256 loanID_) external {\n        if (msg.sender != approvals[loanID_]) revert OnlyApproved();\n\n        // Update the load lender.\n        loans[loanID_].lender = msg.sender;\n        // Clear transfer approvals.\n        approvals[loanID_] = address(0);\n    }\n\n    /// @notice Set direct repayment of a given loan.\n    /// @param  loanID_ of lender's loan.\n    /// @param  direct_ true if a direct repayment is desired. False otherwise.\n    function setDirectRepay(uint256 loanID_, bool direct_) external {\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\n\n        // Update the repayment method.\n        loans[loanID_].repayDirect = direct_;\n    }\n\n    // --- AUX FUNCTIONS ---------------------------------------------\n\n    /// @notice Compute collateral needed for loan amount at given loan to collateral ratio.\n    /// @param  amount_ of collateral tokens.\n    /// @param  loanToCollateral_ ratio for loan.\n    function collateralFor(uint256 amount_, uint256 loanToCollateral_) public view returns (uint256) {\n        return (amount_ * (10 ** collateral().decimals())) / loanToCollateral_;\n    }\n\n    /// @notice compute collateral needed to roll loan.\n    /// @param  loanID_ of loan to roll.\n    function newCollateralFor(uint256 loanID_) public view returns (uint256) {\n        Loan memory loan = loans[loanID_];\n        // Accounts for all outstanding debt (borrowed amount + interest).\n        uint256 neededCollateral = collateralFor(\n            loan.amount,\n            loan.request.loanToCollateral\n        );\n\n        return\n            neededCollateral > loan.collateral ?\n            neededCollateral - loan.collateral :\n            0;\n    }\n\n    /// @notice Compute interest cost on amount for duration at given annualized rate.\n    /// @param  amount_ of debt tokens.\n    /// @param  rate_ of interest (annualized).\n    /// @param  duration_ of loan in seconds.\n    /// @return Interest in debt token terms.\n    function interestFor(uint256 amount_, uint256 rate_, uint256 duration_) public pure returns (uint256) {\n        uint256 interest = (rate_ * duration_) / 365 days;\n        return (amount_ * interest) / DECIMALS_INTEREST;\n    }\n\n    /// @notice Check if given loan is in default.\n    /// @param  loanID_ index of loan in loans[].\n    /// @return Defaulted status.\n    function isDefaulted(uint256 loanID_) external view returns (bool) {\n        return block.timestamp > loans[loanID_].expiry;\n    }\n\n    /// @notice Check if a given request is active.\n    /// @param  reqID_ index of request in requests[].\n    /// @return Active status.\n    function isActive(uint256 reqID_) external view returns (bool) {\n        return requests[reqID_].active;\n    }\n\n    /// @notice Getter for Request data as a struct.\n    /// @param  reqID_ index of request in requests[].\n    /// @return Request struct.\n    function getRequest(uint256 reqID_) external view returns (Request memory) {\n        return requests[reqID_];\n    }\n\n    /// @notice Getter for Loan data as a struct.\n    /// @param loanID_ index of loan in loans[].\n    /// @return Loan struct.\n    function getLoan(uint256 loanID_) external view returns (Loan memory) {\n        return loans[loanID_];\n    }\n}"
    },
    {
      "filename": "Cooler/src/Cooler.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Clone} from \"clones/Clone.sol\";\n\nimport {IDelegate} from \"interfaces/IDelegate.sol\";\nimport {CoolerFactory} from \"src/CoolerFactory.sol\";\nimport {CoolerCallback} from \"src/CoolerCallback.sol\";\n\n/// @title  Cooler Loans.\n/// @notice A Cooler is a smart contract escrow that facilitates fixed-duration, peer-to-peer\n///         loans for a user-defined debt-collateral pair.\n/// @dev    This contract uses Clones (https://github.com/wighawag/clones-with-immutable-args)\n///         to save gas on deployment.\ncontract Cooler is Clone {\n    using SafeTransferLib for ERC20;\n\n    // --- ERRORS ----------------------------------------------------\n\n    error OnlyApproved();\n    error Deactivated();\n    error Default();\n    error NoDefault();\n    error NotRollable();\n    error ZeroCollateralReturned();\n    error NotCoolerCallback();\n\n    // --- DATA STRUCTURES -------------------------------------------\n\n    /// @notice A loan begins with a borrow request.\n    struct Request {\n        uint256 amount;             // Amount to be borrowed.\n        uint256 interest;           // Annualized percentage to be paid as interest.\n        uint256 loanToCollateral;   // Requested loan-to-collateral ratio.\n        uint256 duration;           // Time to repay the loan before it defaults.\n        bool active;                // Any lender can clear an active loan request.\n    }\n\n    /// @notice A request is converted to a loan when a lender clears it.\n    struct Loan {\n        Request request;        // Loan terms specified in the request.\n        uint256 amount;         // Amount of debt owed to the lender.\n        uint256 unclaimed;      // Amount of debt tokens repaid but unclaimed.\n        uint256 collateral;     // Amount of collateral pledged.\n        uint256 expiry;         // Time when the loan defaults.\n        address lender;         // Lender's address.\n        bool repayDirect;       // If this is false, repaid tokens must be claimed by lender.\n        bool callback;          // If this is true, the lender must inherit CoolerCallback.\n    }\n\n    // --- IMMUTABLES ------------------------------------------------\n\n    // This makes the code look prettier.\n    uint256 private constant DECIMALS_INTEREST = 1e18;\n\n    /// @notice This address owns the collateral in escrow.\n    function owner() public pure returns (address _owner) {\n        return _getArgAddress(0x0);\n    }\n\n    /// @notice This token is borrowed against.\n    function collateral() public pure returns (ERC20 _collateral) {\n        return ERC20(_getArgAddress(0x14));\n    }\n\n    /// @notice This token is lent.\n    function debt() public pure returns (ERC20 _debt) {\n        return ERC20(_getArgAddress(0x28));\n    }\n    \n    /// @notice This contract created the Cooler\n    function factory() public pure returns (CoolerFactory _factory) {\n        return CoolerFactory(_getArgAddress(0x3c));\n    }\n\n    // --- STATE VARIABLES -------------------------------------------\n\n    /// @notice Arrays stores all the loan requests.\n    Request[] public requests;\n\n    /// @notice Arrays stores all the granted loans.\n    Loan[] public loans;\n\n    /// @notice Facilitates transfer of lender ownership to new addresses\n    mapping(uint256 => address) public approvals;\n\n    // --- BORROWER --------------------------------------------------\n\n    /// @notice Request a loan with given parameters.\n    ///         Collateral is taken at time of request.\n    /// @param  amount_ of debt tokens to borrow.\n    /// @param  interest_ to pay (annualized % of 'amount_'). Expressed in DECIMALS_INTEREST.\n    /// @param  loanToCollateral_ debt tokens per collateral token pledged. Expressed in 10**debt().decimals().\n    /// @param  duration_ of loan tenure in seconds.\n    /// @return reqID of the created request. Equivalent to the index of request in requests[].\n    function requestLoan(\n        uint256 amount_,\n        uint256 interest_,\n        uint256 loanToCollateral_,\n        uint256 duration_\n    ) external returns (uint256 reqID) {\n        reqID = requests.length;\n        requests.push(\n            Request({\n                amount: amount_,\n                interest: interest_,\n                loanToCollateral: loanToCollateral_,\n                duration: duration_,\n                active: true\n            })\n        );\n\n        // The collateral is taken upfront. Will be escrowed\n        // until the loan is repaid or defaulted.\n        collateral().safeTransferFrom(\n            msg.sender,\n            address(this),\n            collateralFor(amount_, loanToCollateral_)\n        );\n\n        // Log the event.\n        factory().newEvent(reqID, CoolerFactory.Events.RequestLoan, 0);\n    }\n\n    /// @notice Cancel a loan request and get the collateral back.\n    /// @param  reqID_ index of request in requests[].\n    function rescindRequest(uint256 reqID_) external {\n        if (msg.sender != owner()) revert OnlyApproved();\n\n        Request storage req = requests[reqID_];\n\n        if (!req.active) revert Deactivated();\n\n        // Update storage and send collateral back to the owner.\n        req.active = false;\n        collateral().safeTransfer(owner(), collateralFor(req.amount, req.loanToCollateral));\n\n        // Log the event.\n        factory().newEvent(reqID_, CoolerFactory.Events.RescindRequest, 0);\n    }\n\n    /// @notice Repay a loan to get the collateral back.\n    /// @dev    Despite a malicious lender could reenter with the callback, the\n    ///         usage of `msg.sender` prevents any economical benefit to the\n    ///         attacker, since they would be repaying the loan themselves.\n    /// @param  loanID_ index of loan in loans[]\n    /// @param  repaid_ debt tokens to be repaid.\n    /// @return collateral given back to the borrower.\n    function repayLoan(uint256 loanID_, uint256 repaid_) external returns (uint256) {\n        Loan memory loan = loans[loanID_];\n\n        if (block.timestamp > loan.expiry) revert Default();\n\n        if (repaid_ > loan.amount) repaid_ = loan.amount;\n\n        uint256 decollateralized = (loan.collateral * repaid_) / loan.amount;\n        if (decollateralized == 0) revert ZeroCollateralReturned();\n\n        // Update loan memory.\n        loan.amount -= repaid_;\n        loan.collateral -= decollateralized;\n\n        address repayTo;\n        // Check whether repayment needs to be manually claimed or not.\n        if (loan.repayDirect) {\n            repayTo = loan.lender;\n        } else {\n            repayTo = address(this);\n            loan.unclaimed += repaid_;\n        }\n\n        // Save updated loan info in storage.\n        loans[loanID_] = loan;\n\n        // Transfer repaid debt back to the lender and (de)collateral back to the owner.\n        debt().safeTransferFrom(msg.sender, repayTo, repaid_);\n        collateral().safeTransfer(owner(), decollateralized);\n\n        // Log the event.\n        factory().newEvent(loanID_, CoolerFactory.Events.RepayLoan, repaid_);\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onRepay(loanID_, repaid_);\n        return decollateralized;\n    }\n\n    /// @notice Roll a loan over with new terms.\n    ///         provideNewTermsForRoll must have been called beforehand by the lender.\n    /// @param  loanID_ index of loan in loans[].\n    function rollLoan(uint256 loanID_) external {\n        Loan memory loan = loans[loanID_];\n\n        if (block.timestamp > loan.expiry) revert Default();\n        if (!loan.request.active) revert NotRollable();\n\n        // Check whether rolling the loan requires pledging more collateral or not (if there was a previous repayment).\n        uint256 newCollateral = newCollateralFor(loanID_);\n        uint256 newDebt = interestFor(loan.amount, loan.request.interest, loan.request.duration);\n\n        // Update memory accordingly.\n        loan.amount += newDebt;\n        loan.collateral += newCollateral;\n        loan.expiry += loan.request.duration;\n        loan.request.active = false;\n\n        // Save updated loan info in storage.\n        loans[loanID_] = loan;\n\n        if (newCollateral > 0) {\n            collateral().safeTransferFrom(msg.sender, address(this), newCollateral);\n        }\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onRoll(loanID_, newDebt, newCollateral);\n    }\n\n    /// @notice Delegate voting power on collateral.\n    /// @param  to_ address to delegate.\n    function delegateVoting(address to_) external {\n        if (msg.sender != owner()) revert OnlyApproved();\n        IDelegate(address(collateral())).delegate(to_);\n    }\n\n    // --- LENDER ----------------------------------------------------\n\n    /// @notice Fill a requested loan as a lender.\n    /// @param  reqID_ index of request in requests[].\n    /// @param  repayDirect_ lender should input false if concerned about debt token blacklisting.\n    /// @param  isCallback_ true if the lender implements the CoolerCallback abstract. False otherwise.\n    /// @return loanID of the granted loan. Equivalent to the index of loan in loans[].\n    function clearRequest(\n        uint256 reqID_,\n        bool repayDirect_,\n        bool isCallback_\n    ) external returns (uint256 loanID) {\n        Request memory req = requests[reqID_];\n\n        // If necessary, ensure lender implements the CoolerCallback abstract.\n        if (isCallback_ && !CoolerCallback(msg.sender).isCoolerCallback()) revert NotCoolerCallback();\n\n        // Ensure loan request is active. \n        if (!req.active) revert Deactivated();\n\n        // Clear the loan request in memory.\n        req.active = false;\n\n        // Calculate and store loan terms.\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n        uint256 expiration = block.timestamp + req.duration;\n        loanID = loans.length;\n        loans.push(\n            Loan({\n                request: req,\n                amount: req.amount + interest,\n                unclaimed: 0,\n                collateral: collat,\n                expiry: expiration,\n                lender: msg.sender,\n                repayDirect: repayDirect_,\n                callback: isCallback_\n            })\n        );\n\n        // Clear the loan request storage.\n        requests[reqID_].active = false;\n\n        // Transfer debt tokens to the owner of the request.\n        debt().safeTransferFrom(msg.sender, owner(), req.amount);\n\n        // Log the event.\n        factory().newEvent(reqID_, CoolerFactory.Events.ClearRequest, 0);\n    }\n\n    /// @notice Provide new terms for loan to be rolled over.\n    /// @param  loanID_ index of loan in loans[].\n    /// @param  interest_ to pay (annualized % of 'amount_'). Expressed in DECIMALS_INTEREST.\n    /// @param  loanToCollateral_ debt tokens per collateral token pledged. Expressed in 10**debt().decimals().\n    /// @param  duration_ of loan tenure in seconds.\n    function provideNewTermsForRoll(\n        uint256 loanID_,\n        uint256 interest_,\n        uint256 loanToCollateral_,\n        uint256 duration_\n    ) external {\n        Loan storage loan = loans[loanID_];\n\n        if (msg.sender != loan.lender) revert OnlyApproved();\n\n        loan.request =\n            Request(\n                loan.amount,\n                interest_,\n                loanToCollateral_,\n                duration_,\n                true\n            );\n    }\n\n    /// @notice Claim debt tokens if repayDirect was false.\n    /// @param  loanID_ index of loan in loans[].\n    function claimRepaid(uint256 loanID_) external {\n        Loan memory loan = loans[loanID_];\n\n        // Update storage.\n        uint256 claim = loan.unclaimed;\n        delete loans[loanID_].unclaimed;\n\n        // Transfer repaid debt back to the lender.\n        debt().safeTransfer(loan.lender, claim);\n    }\n\n    /// @notice Claim collateral upon loan default.\n    /// @param loanID_ index of loan in loans[]\n    /// @return defaulted debt by the borrower, collateral kept by the lender, elapsed time since expiry.\n    function claimDefaulted(uint256 loanID_) external returns (uint256, uint256, uint256) {\n        Loan memory loan = loans[loanID_];\n        delete loans[loanID_];\n\n        if (block.timestamp <= loan.expiry) revert NoDefault();\n\n        // Transfer defaulted collateral to the lender.\n        collateral().safeTransfer(loan.lender, loan.collateral);\n\n        // Log the event.\n        factory().newEvent(loanID_, CoolerFactory.Events.DefaultLoan, 0);\n\n        // If necessary, trigger lender callback.\n        if (loan.callback) CoolerCallback(loan.lender).onDefault(loanID_, loan.amount, loan.collateral);\n        return (loan.amount, loan.collateral, block.timestamp - loan.expiry);\n    }\n\n    /// @notice Approve transfer of loan ownership rights to a new address.\n    /// @param  to_ address to be approved.\n    /// @param  loanID_ index of loan in loans[].\n    function approveTransfer(address to_, uint256 loanID_) external {\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\n\n        // Update transfer approvals.\n        approvals[loanID_] = to_;\n    }\n\n    /// @notice Execute loan ownership transfer. Must be previously approved by the lender.\n    /// @param  loanID_ index of loan in loans[].\n    function transferOwnership(uint256 loanID_) external {\n        if (msg.sender != approvals[loanID_]) revert OnlyApproved();\n\n        // Update the load lender.\n        loans[loanID_].lender = msg.sender;\n        // Clear transfer approvals.\n        approvals[loanID_] = address(0);\n    }\n\n    /// @notice Set direct repayment of a given loan.\n    /// @param  loanID_ of lender's loan.\n    /// @param  direct_ true if a direct repayment is desired. False otherwise.\n    function setDirectRepay(uint256 loanID_, bool direct_) external {\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\n\n        // Update the repayment method.\n        loans[loanID_].repayDirect = direct_;\n    }\n\n    // --- AUX FUNCTIONS ---------------------------------------------\n\n    /// @notice Compute collateral needed for loan amount at given loan to collateral ratio.\n    /// @param  amount_ of collateral tokens.\n    /// @param  loanToCollateral_ ratio for loan.\n    function collateralFor(uint256 amount_, uint256 loanToCollateral_) public view returns (uint256) {\n        return (amount_ * (10 ** collateral().decimals())) / loanToCollateral_;\n    }\n\n    /// @notice compute collateral needed to roll loan.\n    /// @param  loanID_ of loan to roll.\n    function newCollateralFor(uint256 loanID_) public view returns (uint256) {\n        Loan memory loan = loans[loanID_];\n        // Accounts for all outstanding debt (borrowed amount + interest).\n        uint256 neededCollateral = collateralFor(\n            loan.amount,\n            loan.request.loanToCollateral\n        );\n\n        return\n            neededCollateral > loan.collateral ?\n            neededCollateral - loan.collateral :\n            0;\n    }\n\n    /// @notice Compute interest cost on amount for duration at given annualized rate.\n    /// @param  amount_ of debt tokens.\n    /// @param  rate_ of interest (annualized).\n    /// @param  duration_ of loan in seconds.\n    /// @return Interest in debt token terms.\n    function interestFor(uint256 amount_, uint256 rate_, uint256 duration_) public pure returns (uint256) {\n        uint256 interest = (rate_ * duration_) / 365 days;\n        return (amount_ * interest) / DECIMALS_INTEREST;\n    }\n\n    /// @notice Check if given loan is in default.\n    /// @param  loanID_ index of loan in loans[].\n    /// @return Defaulted status.\n    function isDefaulted(uint256 loanID_) external view returns (bool) {\n        return block.timestamp > loans[loanID_].expiry;\n    }\n\n    /// @notice Check if a given request is a"
    }
  ]
}