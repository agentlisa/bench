{
  "Title": "[M-07] Auction winner can prevent payments via `safeTransferFrom` callback",
  "Content": "\nAn auction winner can decide to conditionally revert the `claimAuction()` execution.\n\nThis leads to the following impacts:\n\n- Other bidders can't get their funds back\n- The protocol doesn't receive the funds from the winning bid\n\nThis can lead to permanent loss of funds if the adversary decides to. As a drawback, they can't get the NFT.\n\nBut nevertheless, they can use their control over the function to ask for a ransom, as the sum of other bids, plus the protocol earnings can be higher than the maximum bid itself and the damaged public image of the protocol for losing users funds.\n\nIt also breaks one of the [main invariants of the protocol](https://github.com/code-423n4/2023-10-nextgen#main-invariants):\n\n> Properties that should NEVER be broken under any circumstance:\n>\n> - The highest bidder will receive the token after an auction finishes, **the owner of the token will receive the funds** and **all other participants will get refunded**.\n\nEvaluated as Medium, as despite of the possibility of permanent assets lost, and breaking a main invariant, the adversary will have to take a loss as well; or persuade the participants via a ransom.\n\n### Proof of Concept\n\n`claimAuction()` transfers the NFT using `safeTransferFrom()`:\n\n```solidity\n    function claimAuction(uint256 _tokenid) public WinnerOrAdminRequired(_tokenid,this.claimAuction.selector){\n        /// ...\n        for (uint256 i=0; i< auctionInfoData[_tokenid].length; i ++) {\n            if (auctionInfoData[_tokenid][i].bidder == highestBidder && auctionInfoData[_tokenid][i].bid == highestBid && auctionInfoData[_tokenid][i].status == true) {\n->              IERC721(gencore).safeTransferFrom(ownerOfToken, highestBidder, _tokenid); // @audit adversary can make it revert\n->              (bool success, ) = payable(owner()).call{value: highestBid}(\"\"); // @audit funds not transferred\n                emit ClaimAuction(owner(), _tokenid, success, highestBid);\n            } else if (auctionInfoData[_tokenid][i].status == true) {\n->                (bool success, ) = payable(auctionInfoData[_tokenid][i].bidder).call{value: auctionInfoData[_tokenid][i].bid}(\"\"); // @audit funds not transferred\n                emit Refund(auctionInfoData[_tokenid][i].bidder, _tokenid, success, highestBid);\n            } else {}\n        }\n    }\n```\n\n`safeTransferFrom()` [calls back the receiver](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/ERC721.sol#L407) if it is a contract.\n\nAn adversary that won the auction can conditionally `revert` the execution of the transaction, upon the `onERC721Received()` callback.\n\nThis will revert the whole transaction, making it impossible to transfer any funds.\n\nBidders can't cancel their bids either via `cancelBid()` or `cancelAllBids()`, due to they only allow it to do so if the auction was not ended: [AuctionDemo.sol#L125](https://github.com/code-423n4/2023-10-nextgen/blob/main/smart-contracts/AuctionDemo.sol#L125)\n\nThe protocol, nor the previous token owner have a way to claim the earnings from the auction.\n\n### Recommended Mitigation Steps\n\nMove the logic to transfer the NFT to its own separated function.\n\n### Assessed type\n\nDoS\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/739#issuecomment-1839426119):**\n > The Warden specifies that the winning bidder may not implement a proper EIP-721 receive hook either deliberately or by accident.\n> \n> I consider this to be an exhibit validly categorized as a medium given that its impact is sabotage (i.e. loss-of-funds for other users) at the expense of a single high bid and it can also be used as extortion.\n> \n> This submission was selected as the best given that it cites the voidance of a main invariant of the protocol, articulates that the funds are irrecoverable, and mentions that it should be marked as a medium given that the attacker would also lose their bid.\n\n**[btk (warden) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/739#issuecomment-1848428010):**\n > @0xsomeone, while #739 could be critical, the high cost makes it unlikely. To execute the attack, the malicious actor must win an auction, risking their funds to lock others' funds, which is impractical in real-world scenarios. You can check [#1508](https://github.com/code-423n4/2023-10-nextgen-findings/issues/1508) where I discussed the issue without providing a PoC, as it is QA at max, here:\n> \n> > Attackers can exploit this using `onERC721Received` too, but it's costlier since they need to be the highest bidder to claim the NFT.\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2023-10-nextgen-findings/issues/739#issuecomment-1848585215):**\n > @btk, thanks for your contribution! I believe you are misjudging why this was selected as a medium-risk vulnerability while [#734](https://github.com/code-423n4/2023-10-nextgen-findings/issues/734) is a high-risk vulnerability.\n> \n> Yes, the would-be attacker would need to be the winning bidder but they would acquire an NFT regardless that would offset the cost of the attack. Additionally, any bidder can simply \"choose\" to carry this attack or simply acquire the NFT. Specifying that the attack would be impractical is identical to saying users would not participate in auctions and win. \n> \n> The likelihood might be low, but the impact is high rendering this an aptly graded medium-risk vulnerability. #734 has a lower bar of entry and has been marked as high-risk as such. This was already elaborated [in the relevant comment of this submission](https://github.com/code-423n4/2023-10-nextgen-findings/issues/739#issuecomment-1839426119).\n\n**[a2rocket (NextGen) confirmed](https://github.com/code-423n4/2023-10-nextgen-findings/issues/739#issuecomment-1876732920)**\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-10-nextgen-findings/issues/739).*\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-nextgen",
  "Code": [
    {
      "filename": "smart-contracts/ERC721.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\n\nimport \"./Context.sol\";\nimport \"./ERC165.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./Address.sol\";\nimport \"./Strings.sol\";\nimport \"./IERC721Receiver.sol\";\n\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}"
    },
    {
      "filename": "smart-contracts/AuctionDemo.sol",
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *\n *  @title: Auction Demo Contract\n *  @date: 26-October-2023 \n *  @version: 1.2\n *  @author: 6529 team\n */\n\npragma solidity ^0.8.19;\n\nimport \"./IMinterContract.sol\";\nimport \"./IERC721.sol\";\nimport \"./Ownable.sol\";\nimport \"./INextGenAdmins.sol\";\n\ncontract auctionDemo is Ownable {\n\n    //events \n\n    event ClaimAuction(address indexed _add, uint256 indexed tokenid, bool status, uint256 indexed funds);\n    event Refund(address indexed _add, uint256 indexed tokenid, bool status, uint256 indexed funds);\n    event CancelBid(address indexed _add, uint256 indexed tokenid, uint256 index, bool status, uint256 indexed funds);\n\n    IMinterContract public minter;\n    INextGenAdmins public adminsContract;\n    address gencore;\n\n    // certain functions can only be called by auction winner or admin\n    modifier WinnerOrAdminRequired(uint256 _tokenId, bytes4 _selector) {\n      require(msg.sender == returnHighestBidder(_tokenId) || adminsContract.retrieveFunctionAdmin(msg.sender, _selector) == true || adminsContract.retrieveGlobalAdmin(msg.sender) == true, \"Not allowed\");\n      _;\n    }\n\n    constructor (address _minter, address _gencore, address _adminsContract) public {\n        minter = IMinterContract(_minter);\n        gencore = _gencore;\n        adminsContract = INextGenAdmins(_adminsContract);\n    }\n\n    // auction Bidders\n    struct auctionInfoStru {\n        address bidder;\n        uint256 bid;\n        bool status;\n    }\n\n    // mapping of collectionSecondaryAddresses struct\n    mapping (uint256 => auctionInfoStru[]) public auctionInfoData;\n\n    // claim auctioned\n    mapping (uint256 => bool) public auctionClaim;\n\n    // participate to auction\n\n    function participateToAuction(uint256 _tokenid) public payable {\n        require(msg.value > returnHighestBid(_tokenid) && block.timestamp <= minter.getAuctionEndTime(_tokenid) && minter.getAuctionStatus(_tokenid) == true);\n        auctionInfoStru memory newBid = auctionInfoStru(msg.sender, msg.value, true);\n        auctionInfoData[_tokenid].push(newBid);\n    }\n\n    // get highest bid\n\n    function returnHighestBid(uint256 _tokenid) public view returns (uint256) {\n        uint256 index;\n        if (auctionInfoData[_tokenid].length > 0) {\n            uint256 highBid = 0;\n            for (uint256 i=0; i< auctionInfoData[_tokenid].length; i++) {\n                if (auctionInfoData[_tokenid][i].bid > highBid && auctionInfoData[_tokenid][i].status == true) {\n                    highBid = auctionInfoData[_tokenid][i].bid;\n                    index = i;\n                }\n            }\n            if (auctionInfoData[_tokenid][index].status == true) {\n                return highBid;\n            } else {\n                return 0;\n            }\n        } else {\n            return 0;\n        }\n    }\n\n    // get highest bidder\n\n    function returnHighestBidder(uint256 _tokenid) public view returns (address) {\n        uint256 highBid = 0;\n        uint256 index;\n        for (uint256 i=0; i< auctionInfoData[_tokenid].length; i++) {\n            if (auctionInfoData[_tokenid][i].bid > highBid && auctionInfoData[_tokenid][i].status == true) {\n                index = i;\n            }\n        }\n        if (auctionInfoData[_tokenid][index].status == true) {\n                return auctionInfoData[_tokenid][index].bidder;\n            } else {\n                revert(\"No Active Bidder\");\n        }\n    }\n\n    // claim Token After Auction\n\n    function claimAuction(uint256 _tokenid) public WinnerOrAdminRequired(_tokenid,this.claimAuction.selector){\n        require(block.timestamp >= minter.getAuctionEndTime(_tokenid) && auctionClaim[_tokenid] == false && minter.getAuctionStatus(_tokenid) == true);\n        auctionClaim[_tokenid] = true;\n        uint256 highestBid = returnHighestBid(_tokenid);\n        address ownerOfToken = IERC721(gencore).ownerOf(_tokenid);\n        address highestBidder = returnHighestBidder(_tokenid);\n        for (uint256 i=0; i< auctionInfoData[_tokenid].length; i ++) {\n            if (auctionInfoData[_tokenid][i].bidder == highestBidder && auctionInfoData[_tokenid][i].bid == highestBid && auctionInfoData[_tokenid][i].status == true) {\n                IERC721(gencore).safeTransferFrom(ownerOfToken, highestBidder, _tokenid);\n                (bool success, ) = payable(owner()).call{value: highestBid}(\"\");\n                emit ClaimAuction(owner(), _tokenid, success, highestBid);\n            } else if (auctionInfoData[_tokenid][i].status == true) {\n                (bool success, ) = payable(auctionInfoData[_tokenid][i].bidder).call{value: auctionInfoData[_tokenid][i].bid}(\"\");\n                emit Refund(auctionInfoData[_tokenid][i].bidder, _tokenid, success, highestBid);\n            } else {}\n        }\n    }\n\n    // cancel a single Bid\n\n    function cancelBid(uint256 _tokenid, uint256 index) public {\n        require(block.timestamp <= minter.getAuctionEndTime(_tokenid), \"Auction ended\");\n        require(auctionInfoData[_tokenid][index].bidder == msg.sender && auctionInfoData[_tokenid][index].status == true);\n        auctionInfoData[_tokenid][index].status = false;\n        (bool success, ) = payable(auctionInfoData[_tokenid][index].bidder).call{value: auctionInfoData[_tokenid][index].bid}(\"\");\n        emit CancelBid(msg.sender, _tokenid, index, success, auctionInfoData[_tokenid][index].bid);\n    }\n\n    // cancel All Bids\n\n    function cancelAllBids(uint256 _tokenid) public {\n        require(block.timestamp <= minter.getAuctionEndTime(_tokenid), \"Auction ended\");\n        for (uint256 i=0; i<auctionInfoData[_tokenid].length; i++) {\n            if (auctionInfoData[_tokenid][i].bidder == msg.sender && auctionInfoData[_tokenid][i].status == true) {\n                auctionInfoData[_tokenid][i].status = false;\n                (bool success, ) = payable(auctionInfoData[_tokenid][i].bidder).call{value: auctionInfoData[_tokenid][i].bid}(\"\");\n                emit CancelBid(msg.sender, _tokenid, i, success, auctionInfoData[_tokenid][i].bid);\n            } else {}\n        }\n    }\n\n    // return Bids\n\n    function returnBids(uint256 _tokenid) public view returns(auctionInfoStru[] memory) {\n        return auctionInfoData[_tokenid];\n    }\n\n}"
    }
  ]
}