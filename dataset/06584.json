{
  "Title": "[L-11] `rebalanceUpCap` and `rebalanceDownCap` operate on different types of value",
  "Content": "\nCaps operate on different types of value. `rebalanceUpCap` is checked against LP tokens:\n\nhttps://github.com/code-423n4/2023-05-xeth/blob/main/src/AMO2.sol#L252\n\n```solidity\nif (quote.lpBurn > rebalanceUpCap) revert RebalanceUpCapExceeded();\n```\n\nWhile `rebalanceDownCap` is checked against xETH tokens:\n\nhttps://github.com/code-423n4/2023-05-xeth/blob/main/src/AMO2.sol#L299\n\n```solidity\nif (quote.xETHAmount > rebalanceDownCap)\n    revert RebalanceDownCapExceeded();\n```\n\n## Informational Issue Summary\n\n| |Issue|\n|-|:-|\n| [INFO-01] | Type of Curve pool is an important and sensible parameter |\n| [INFO-02] | Several centralization risks introduce multiple points of failure |\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-xeth",
  "Code": [
    {
      "filename": "src/AMO2.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\nimport \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin-contracts/access/AccessControl.sol\";\nimport \"./interfaces/ICurvePool.sol\";\nimport {IXETH} from \"./interfaces/IXETH.sol\";\nimport {CVXStaker} from \"./CVXStaker.sol\";\n\ncontract xETH_AMO is AccessControl {\n    using SafeERC20 for IERC20;\n\n    /// @notice Thrown when the xETH-stETH LP balance of the AMO is too low for the rebalancing operation.\n    error LpBalanceTooLow();\n\n    /// @notice Thrown when either the stETH or xETH balance in the pool is zero, which would prevent rebalancing.\n    error ZeroBalancePool();\n\n    /// @notice Thrown when a zero address is provided as an input, which is not allowed.\n    error ZeroAddressProvided();\n\n    /// @notice Thrown when a function is called with a zero value, which is not allowed.\n    error ZeroValueProvided();\n\n    /// @notice Thrown when an invalid slippage value is provided, outside the allowed range.\n    error InvalidSlippageBPS();\n\n    /// @notice Thrown when a rebalance attempt is made before the cooldown period has finished.\n    error CooldownNotFinished();\n\n    /// @notice Thrown when a rebalance attempt is made, but the current pool ratios do not require rebalancing.\n    error RebalanceNotRequired();\n\n    /// @notice Thrown when a rebalanceUp operation is not allowed based on the current pool ratios.\n    error RebalanceUpNotAllowed();\n\n    /// @notice Thrown when a rebalanceDown operation is not allowed based on the current pool ratios.\n    error RebalanceDownNotAllowed();\n\n    /// @notice Thrown when the requested rebalanceUp operation exceeds the allowed rebalanceUpCap.\n    error RebalanceUpCapExceeded();\n\n    /// @notice Thrown when the requested rebalanceDown operation exceeds the allowed rebalanceDownCap.\n    error RebalanceDownCapExceeded();\n\n    /// @notice Emitted when a rebalanceUp operation is performed.\n    /// @param quote The chosen quote for rebalancing.\n    /// @param xETHamountReceived The actual amount of xETH received after burning LP tokens.\n    event RebalanceUpFinished(\n        RebalanceUpQuote quote,\n        uint256 xETHamountReceived\n    );\n\n    /// @notice Emitted when a rebalanceDown operation is performed.\n    /// @param quote The chosen quote for rebalancing.\n    /// @param lpAmountReceived The actual amount of xETH-stETH LP tokens received after minting xETH.\n    event RebalanceDownFinished(\n        RebalanceDownQuote quote,\n        uint256 lpAmountReceived\n    );\n\n    /// @notice Emitted when the defender address is updated.\n    /// @param oldDefender The previous defender address.\n    /// @param newDefender The new defender address.\n    event DefenderUpdated(address oldDefender, address newDefender);\n\n    /// @notice Emitted when the maxSlippageBPS is updated.\n    /// @param oldMaxSlippageBPS The previous max slippage value.\n    /// @param newMaxSlippageBPS The new max slippage value.\n    event MaxSlippageBPSUpdated(\n        uint256 oldMaxSlippageBPS,\n        uint256 newMaxSlippageBPS\n    );\n\n    /// @notice Emitted when the rebalanceUpCap is updated.\n    /// @param oldRebalanceUpCap The previous rebalanceUpCap value.\n    /// @param newRebalanceUpCap The new rebalanceUpCap value.\n    event RebalanceUpCapUpdated(\n        uint256 oldRebalanceUpCap,\n        uint256 newRebalanceUpCap\n    );\n\n    /// @notice Emitted when the rebalanceDownCap is updated.\n    /// @param oldRebalanceDownCap The previous rebalanceDownCap value.\n    /// @param newRebalanceDownCap The new rebalanceDownCap value.\n    event RebalanceDownCapUpdated(\n        uint256 oldRebalanceDownCap,\n        uint256 newRebalanceDownCap\n    );\n\n    /// @notice Emitted when the cooldownBlocks is updated.\n    /// @param oldCooldownBlocks The previous cooldownBlocks value.\n    /// @param newCooldownBlocks The new cooldownBlocks value.\n    event CooldownBlocksUpdated(\n        uint256 oldCooldownBlocks,\n        uint256 newCooldownBlocks\n    );\n\n    /// @notice Emitted when the CVXStaker address is updated.\n    /// @param oldCVXStaker The previous CVXStaker address.\n    /// @param newCVXStaker The new CVXStaker address.\n    event CVXStakerUpdated(address oldCVXStaker, address newCVXStaker);\n\n    /// @notice Emitted when the rebalance up threshold is set.\n    /// @param oldThreshold The old rebalance up threshold.\n    /// @param newThreshold The new rebalance up threshold.\n    event SetRebalanceUpThreshold(uint256 oldThreshold, uint256 newThreshold);\n\n    /// @notice Emitted when the rebalance down threshold is set.\n    /// @param oldThreshold The old rebalance down threshold.\n    /// @param newThreshold The new rebalance down threshold.\n    event SetRebalanceDownThreshold(uint256 oldThreshold, uint256 newThreshold);\n\n    /// @dev REBALANCE_DEFENDER_ROLE is the role that allows the defender to call rebalance()\n    bytes32 public constant REBALANCE_DEFENDER_ROLE =\n        keccak256(\"REBALANCE_DEFENDER_ROLE\");\n\n    /// @dev BASE_UNIT is the base unit used for calculations (1E18)\n    uint256 public constant BASE_UNIT = 1E18;\n\n    /// @dev xETHIndex is the index of xETH in the Curve pool\n    uint256 public immutable xETHIndex;\n\n    /// @dev stETHIndex is the index of stETH in the Curve pool\n    uint256 public immutable stETHIndex;\n\n    /// @dev xETH is the xETH token contract\n    IXETH public immutable xETH;\n\n    /// @dev stETH is the stETH token contract\n    IERC20 public immutable stETH;\n\n    /// @dev curvePool is the Curve pool contract\n    ICurvePool public immutable curvePool;\n\n    /// @dev maxSlippageBPS is the maximum slippage allowed when rebalancing\n    /// @notice 1E14 = 1 BPS\n    uint256 public maxSlippageBPS = 100 * 1E14;\n\n    /// @dev rebalanceUpCap is the maximum amount of xETH-stETH LP that can be burnt in a single rebalance\n    uint256 public rebalanceUpCap;\n\n    /// @dev rebalanceDownCap is the maximum amount of xETH that can be minted in a single rebalance\n    uint256 public rebalanceDownCap;\n\n    /// @dev lastRebalanceBlock is the block number of the last rebalance\n    uint256 public lastRebalanceBlock;\n\n    /// @dev cooldownBlocks is the number of blocks that must pass between rebalances\n    uint256 public cooldownBlocks = 1800; /// (6 * 60 * 60) / 12\n\n    /// @dev REBALANCE_UP_THRESHOLD is the upper threshold for the xETH-stETH LP ratio\n    /// @notice if the ratio is above this value, rebalanceUp() will be called\n    uint256 public REBALANCE_UP_THRESHOLD = 0.75E18;\n\n    /// @dev REBALANCE_DOWN_THRESHOLD is the lower threshold for the xETH-stETH LP ratio\n    /// @notice if the ratio is below this value, rebalanceDown() will be called\n    uint256 public REBALANCE_DOWN_THRESHOLD = 0.68E18;\n\n    /// @dev defender is the whitelisted bot that can call rebalance()\n    address public defender;\n\n    /// @dev cvxStaker is the CVX staking contract\n    CVXStaker public cvxStaker;\n\n    /// @dev afterCooldownPeriod is a modifier that checks if the cooldown period has passed\n    modifier afterCooldownPeriod() {\n        if (lastRebalanceBlock + cooldownBlocks >= block.number)\n            revert CooldownNotFinished();\n        _;\n        lastRebalanceBlock = block.number;\n    }\n\n    constructor(\n        address _xETH,\n        address _stETH,\n        address _curvePool,\n        address _cvxStaker,\n        bool isXETHToken0\n    ) {\n        if (\n            _xETH == address(0) ||\n            _stETH == address(0) ||\n            _curvePool == address(0) ||\n            _cvxStaker == address(0)\n        ) {\n            revert ZeroAddressProvided();\n        }\n\n        xETH = IXETH(_xETH);\n        stETH = IERC20(_stETH);\n        curvePool = ICurvePool(_curvePool);\n        cvxStaker = CVXStaker(_cvxStaker);\n\n        xETHIndex = isXETHToken0 ? 0 : 1;\n        stETHIndex = isXETHToken0 ? 1 : 0;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @dev preRebalanceCheck checks if a rebalance is even allowed based on pool ratios\n    function preRebalanceCheck() internal view returns (bool isRebalanceUp) {\n        uint256 stETHBal = curvePool.balances(stETHIndex);\n        uint256 xETHBal = curvePool.balances(xETHIndex);\n\n        /// @notice if either token balance is 0, the pool shall not be rebalanced\n        if (stETHBal == 0 || xETHBal == 0) revert ZeroBalancePool();\n\n        uint256 xEthPct = (xETHBal * BASE_UNIT) / (stETHBal + xETHBal);\n\n        /// @notice if the ratio is above the upper threshold, rebalanceUp() will be called\n        if (xEthPct > REBALANCE_UP_THRESHOLD) {\n            isRebalanceUp = true;\n        }\n        /// @notice if the ratio is below the lower threshold, rebalanceDown() will be called\n        /// @notice possible gas optimization here.\n        else if (xEthPct < REBALANCE_DOWN_THRESHOLD) {\n            isRebalanceUp = false;\n        }\n        /// @notice if the ratio is within the thresholds, the pool shall not be rebalanced\n        else {\n            revert RebalanceNotRequired();\n        }\n    }\n\n    struct RebalanceUpQuote {\n        uint256 lpBurn;\n        uint256 min_xETHReceived;\n    }\n\n    /**\n     * @dev Executes a rebalance up operation, which burns xETH-stETH LP to receive xETH.\n     * @param quote The quote for the rebalance operation provided by the rebalance defender.\n     * @return xETHReceived The amount of xETH received from the rebalance operation.\n     * @notice Only the rebalance defender can call this function.\n     * @notice The rebalance operation can only be performed after the cooldown period has elapsed.\n     */\n    function rebalanceUp(\n        RebalanceUpQuote memory quote\n    )\n        external\n        onlyRole(REBALANCE_DEFENDER_ROLE)\n        afterCooldownPeriod\n        returns (uint256 xETHReceived)\n    {\n        if (quote.lpBurn == 0) revert ZeroValueProvided();\n\n        bool isRebalanceUp = preRebalanceCheck();\n        if (!isRebalanceUp) revert RebalanceUpNotAllowed();\n\n        if (quote.lpBurn > rebalanceUpCap) revert RebalanceUpCapExceeded();\n\n        quote = bestRebalanceUpQuote(quote);\n\n        uint256 amoLpBal = cvxStaker.stakedBalance();\n\n        // if (amoLpBal == 0 || quote.lpBurn > amoLpBal) revert LpBalanceTooLow();\n        if (quote.lpBurn > amoLpBal) revert LpBalanceTooLow();\n\n        cvxStaker.withdrawAndUnwrap(quote.lpBurn, false, address(this));\n\n        xETHReceived = curvePool.remove_liquidity_one_coin(\n            quote.lpBurn,\n            int128(int(xETHIndex)),\n            quote.min_xETHReceived\n        );\n\n        xETH.burnShares(xETHReceived);\n\n        emit RebalanceUpFinished(quote, xETHReceived);\n    }\n\n    struct RebalanceDownQuote {\n        uint256 xETHAmount;\n        uint256 minLpReceived;\n    }\n\n    /**\n     * @dev Executes a rebalance down operation, which mints xETH and deposits into the Curve pool.\n     * @param quote The quote for the rebalance operation provided by the rebalance defender.\n     * @return lpAmountOut The amount of LP tokens received from the rebalance operation.\n     * @notice Only the rebalance defender can call this function.\n     * @notice The rebalance operation can only be performed after the cooldown period has elapsed.\n     */\n    function rebalanceDown(\n        RebalanceDownQuote memory quote\n    )\n        external\n        onlyRole(REBALANCE_DEFENDER_ROLE)\n        afterCooldownPeriod\n        returns (uint256 lpAmountOut)\n    {\n        if (quote.xETHAmount == 0) revert ZeroValueProvided();\n\n        bool isRebalanceUp = preRebalanceCheck();\n        if (isRebalanceUp) revert RebalanceDownNotAllowed();\n\n        if (quote.xETHAmount > rebalanceDownCap)\n            revert RebalanceDownCapExceeded();\n\n        quote = bestRebalanceDownQuote(quote);\n\n        xETH.mintShares(quote.xETHAmount);\n\n        uint256[2] memory amounts;\n        amounts[xETHIndex] = quote.xETHAmount;\n\n        IERC20(address(xETH)).approve(address(curvePool), quote.xETHAmount);\n\n        lpAmountOut = curvePool.add_liquidity(amounts, quote.minLpReceived);\n\n        IERC20(address(curvePool)).safeTransfer(\n            address(cvxStaker),\n            lpAmountOut\n        );\n        cvxStaker.depositAndStake(lpAmountOut);\n\n        emit RebalanceDownFinished(quote, lpAmountOut);\n    }\n\n    /// @dev applySlippage applies the maxSlippageBPS to the amount provided\n    function applySlippage(uint256 amount) internal view returns (uint256) {\n        return (amount * (BASE_UNIT - maxSlippageBPS)) / BASE_UNIT;\n    }\n\n    /**\n     * @dev Finds the best quote for rebalancing upwards.\n     * @param defenderQuote The quote provided by the rebalance defender.\n     * @return The best quote for rebalancing upwards.\n     * @notice This function is internal and cannot be called outside of the contract.\n     * @notice the defenderQuote should ideally be better than the contractQuote\n     * @notice if its not, the contractQuote gets executed as a safeguard, reducing the risk of a large sandwich\n     */\n    function bestRebalanceUpQuote(\n        RebalanceUpQuote memory defenderQuote\n    ) internal view returns (RebalanceUpQuote memory) {\n        RebalanceUpQuote memory bestQuote;\n        uint256 vp = curvePool.get_virtual_price();\n\n        /// @dev first lets fill the bestQuote with the contractQuote\n        bestQuote.lpBurn = defenderQuote.lpBurn;\n        bestQuote.min_xETHReceived = applySlippage(\n            (vp * defenderQuote.lpBurn) / BASE_UNIT\n        );\n\n        if (defenderQuote.min_xETHReceived > bestQuote.min_xETHReceived)\n            bestQuote.min_xETHReceived = defenderQuote.min_xETHReceived;\n\n        return bestQuote;\n    }\n\n    /**\n     * @dev Finds the best quote for rebalancing downwards.\n     * @param defenderQuote The quote provided by the rebalance defender.\n     * @return The best quote for rebalancing downwards.\n     * @notice the defenderQuote should ideally be better than the contractQuote\n     * @notice if its not, the contractQuote gets executed as a safeguard, reducing the risk of a large sandwich\n     */\n    function bestRebalanceDownQuote(\n        RebalanceDownQuote memory defenderQuote\n    ) internal view returns (RebalanceDownQuote memory) {\n        RebalanceDownQuote memory bestQuote;\n        uint256 vp = curvePool.get_virtual_price();\n\n        /// @dev first lets fill the bestQuote with the contractQuote\n        bestQuote.xETHAmount = defenderQuote.xETHAmount;\n        bestQuote.minLpReceived = applySlippage(\n            (BASE_UNIT * defenderQuote.xETHAmount) / vp\n        );\n\n        if (defenderQuote.minLpReceived > bestQuote.minLpReceived)\n            bestQuote.minLpReceived = defenderQuote.minLpReceived;\n\n        return bestQuote;\n    }\n\n    /**\n     * @dev Sets the address of the rebalance defender.\n     * @param newDefender The new rebalance defender address to be set.\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     * @notice The new rebalance defender address cannot be set to the zero address.\n     * @notice If a previous defender was set, their `REBALANCE_DEFENDER_ROLE` is revoked and transferred to the new defender.\n     * @notice Emits a `DefenderUpdated` event.\n     */\n    function setRebalanceDefender(\n        address newDefender\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (newDefender == address(0)) revert ZeroAddressProvided();\n\n        if (defender != address(0)) {\n            _revokeRole(REBALANCE_DEFENDER_ROLE, defender);\n        }\n\n        emit DefenderUpdated(defender, newDefender);\n\n        defender = newDefender;\n        _grantRole(REBALANCE_DEFENDER_ROLE, newDefender);\n    }\n\n    /**\n     * @dev Sets the maximum allowable slippage in basis points for trading.\n     * @param newMaxSlippageBPS The new maximum slippage in basis points to be set.\n     * @notice 1 BPS = 1E14\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     * @notice The new maximum slippage must be between 0.06% and 15% (in basis points).\n     * @notice Emits a `MaxSlippageBPSUpdated` event.\n     */\n    function setMaxSlippageBPS(\n        uint256 newMaxSlippageBPS\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        /// @dev the allowed minimum slippage is 0.06% and the maximum slippage is 15%\n        if (newMaxSlippageBPS < 6E14 || newMaxSlippageBPS > 1500E14) {\n            revert InvalidSlippageBPS();\n        }\n\n        emit MaxSlippageBPSUpdated(maxSlippageBPS, newMaxSlippageBPS);\n\n        maxSlippageBPS = newMaxSlippageBPS;\n    }\n\n    /**\n     * @dev Sets the maximum burning cap (rebalanceUp) in a single transaction.\n     * @param newRebalanceUpCap The new rebalance up cap to be set.\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     * @notice The new rebalance up cap cannot be set to zero.\n     * @notice Emits a `RebalanceUpCapUpdated` event.\n     */\n    function setRebalanceUpCap(\n        uint256 newRebalanceUpCap\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (newRebalanceUpCap == 0) revert ZeroValueProvided();\n\n        emit RebalanceUpCapUpdated(rebalanceUpCap, newRebalanceUpCap);\n\n        rebalanceUpCap = newRebalanceUpCap;\n    }\n\n    /**\n     * @dev Sets the maximum minting cap (rebalanceDown) in a single transaction.\n     * @param newRebalanceDownCap The new rebalance down cap to be set.\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     * @notice The new rebalance down cap cannot be set to zero.\n     * @notice Emits a `RebalanceDownCapUpdated` event.\n     */\n    function setRebalanceDownCap(\n        uint256 newRebalanceDownCap\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (newRebalanceDownCap == 0) revert ZeroValueProvided();\n\n        emit RebalanceDownCapUpdated(rebalanceDownCap, newRebalanceDownCap);\n\n        rebalanceDownCap = newRebalanceDownCap;\n    }\n\n    /**\n     * @dev Sets the number of blocks for the unstake cooldown period\n     * @param newCooldownBlocks The new number of blocks for the unstake cooldown period\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     * @notice Emits a CooldownBlocksUpdated event with the old and new cooldown block values\n     */\n    function setCooldownBlocks(\n        uint256 newCooldownBlocks\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (newCooldownBlocks == 0) revert ZeroValueProvided();\n\n        emit CooldownBlocksUpdated(cooldownBlocks, newCooldownBlocks);\n\n        cooldownBlocks = newCooldownBlocks;\n    }\n\n    /**\n     * @dev Sets the CVX staking contract address\n     * @param _cvxStaker The address of the CVX staking contract\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     * @notice The new CVX staker contract address cannot be set to the zero address.\n     * @notice Emits a `CVXStakerUpdated` event.\n     */\n    function setCvxStaker(\n        address _cvxStaker\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        if (_cvxStaker == address(0)) revert ZeroAddressProvided();\n\n        emit CVXStakerUpdated(address(cvxStaker), _cvxStaker);\n\n        cvxStaker = CVXStaker(_cvxStaker);\n    }\n\n    /**\n     * @dev Sets the threshold for triggering a `rebalanceUp` operation.\n     * @param newRebalanceUpThreshold The new threshold to be set.\n     * @notice Emits a `SetRebalanceUpThreshold` event with the old and new thresholds.\n     * @notice Requires the caller to have the `DEFAULT_ADMIN_ROLE`.\n     */\n    function setRebalanceUpThreshold(\n        uint256 newRebalanceUpThreshold\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        emit SetRebalanceUpThreshold(\n            REBALANCE_UP_THRESHOLD,\n            newRebalanceUpThreshold\n        );\n\n        REBALANCE_UP_THRESHOLD = newRebalanceUpThreshold;\n    }\n\n    /**\n     * @dev Sets the threshold for triggering a `rebalanceDown` operation.\n     * @param newRebalanceDownThreshold The new threshold to be set.\n     * @notice Emits a `SetRebalanceDownThreshold` event with the old and new thresholds.\n     * @notice Requires the caller to have the `DEFAULT_ADMIN_ROLE`.\n     */\n    function setRebalanceDownThreshold(\n        uint256 newRebalanceDownThreshold\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        emit SetRebalanceDownThreshold(\n            REBALANCE_DOWN_THRESHOLD,\n            newRebalanceDownThreshold\n        );\n\n        REBALANCE_DOWN_THRESHOLD = newRebalanceDownThreshold;\n    }\n\n    /**\n     * @dev Adds liquidity to the Curve pool using both xETH and stETH and stakes the resulting LP tokens in the CVX staking contract\n     * @param stETHAmount The amount of stETH to be deposited\n     * @param xETHAmount The amount of xETH to be deposited\n     * @param minLpOut The minimum amount of LP tokens to receive from the Curve pool\n     * @notice Transfers stETH and xETH from the caller to this contract, adds liquidity to the Curve pool, and stakes the resulting LP tokens in the CVX staking contract.\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     * @return lpOut The amount of LP tokens received from the Curve pool\n     */\n    function addLiquidity(\n        uint256 stETHAmount,\n        uint256 xETHAmount,\n        uint256 minLpOut\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256 lpOut) {\n        stETH.safeTransferFrom(msg.sender, address(this), stETHAmount);\n        xETH.mintShares(xETHAmount);\n\n        uint256[2] memory amounts;\n\n        amounts[xETHIndex] = xETHAmount;\n        amounts[stETHIndex] = stETHAmount;\n\n        IERC20(address(xETH)).safeApprove(address(curvePool), xETHAmount);\n        stETH.safeApprove(address(curvePool), stETHAmount);\n\n        lpOut = curvePool.add_liquidity(amounts, minLpOut);\n\n        /// @notice no need for safeApprove, direct transfer + deposit\n        IERC20(address(curvePool)).safeTransfer(address(cvxStaker), lpOut);\n        cvxStaker.depositAndStake(lpOut);\n    }\n\n    /**\n     * @notice Adds liquidity only with stETH and stakes the resulting LP tokens in the cvxCRV staking contract.\n     * @param stETHAmount The amount of stETH to add as liquidity.\n     * @param minLpOut The minimum expected amount of LP tokens to receive.\n     * @return lpOut The actual amount of LP tokens received.\n     */\n    function addLiquidityOnlyStETH(\n        uint256 stETHAmount,\n        uint256 minLpOut\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (uint256 lpOut) {\n        stETH.safeTransferFrom(msg.sender, address(this), stETHAmount);\n\n        uint256[2] memory amounts;\n\n        amounts[stETHIndex] = stETHAmount;\n\n        stETH.safeApprove(address(curvePool), stETHAmount);\n\n        lpOut = curvePool.add_liquidity(amounts, minLpOut);\n\n        /// @notice no need for safeApprove, direct transfer + deposit\n        IERC20(address(curvePool)).safeTransfer(address(cvxStaker), lpOut);\n        cvxStaker.depositAndStake(lpOut);\n    }\n\n    /**\n     * @dev Removes liquidity from the Curve pool using both xETH and stETH and transfers the resulting tokens to the caller\n     * @param lpAmount The amount of LP tokens to be burned\n     * @param minStETHOut The minimum amount of stETH to receive from the Curve pool\n     * @param minXETHOut The minimum amount of xETH to receive from the Curve pool\n     * @notice Checks if the AMO owns enough LP tokens, withdraws and unwraps them, and removes liquidity from the Curve pool.\n     *      The resulting xETH and stETH are then transferred to the caller.\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     * @return outputs An array containing the resulting amounts of xETH and stETH received from the Curve pool\n     */\n    function removeLiquidity(\n        uint256 lpAmount,\n        uint256 minStETHOut,\n        uint256 minXETHOut\n    )\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n        returns (uint256[2] memory outputs)\n    {\n        /// @dev check if AMO owns enough LP\n        uint256 amoBalance = cvxStaker.stakedBalance();\n\n        if (lpAmount > amoBalance) {\n            revert LpBalanceTooLow();\n        }\n\n        cvxStaker.withdrawAndUnwrap(lpAmount, false, address(this));\n\n        uint256[2] memory minAmounts;\n\n        minAmounts[xETHIndex] = minXETHOut;\n        minAmounts[stETHIndex] = minStETHOut;\n\n        outputs = curvePool.remove_liquidity(lpAmount, minAmounts);\n\n        xETH.burnShares(outputs[xETHIndex]);\n        stETH.safeTransfer(msg.sender, outputs[stETHIndex]);\n    }\n\n    /**\n     * @dev Removes liquidity from the Curve pool using only stETH and transfers the resulting stETH to the caller\n     * @param lpAmount The amount of LP tokens to be burned\n     * @param minStETHOut The minimum amount of stETH to receive from the Curve pool\n     * @notice Checks if the AMO owns enough LP tokens, withdraws and unwraps them, and removes liquidity from the Curve pool.\n     *      The resulting stETH is then transferred to the caller.\n     * @notice Only callable by a user with the DEFAULT_ADMIN_ROLE\n     */\n    function removeLiquidityOnlyStETH(\n        uint256 lpAmount,\n        uint256 minStETHOut\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        /// @dev check if AMO owns enough LP\n        uint256 amoBalance = cvxStaker.stakedBalance();\n\n        if (lpAmount > amoBalance) {\n            revert LpBalanceTooLow();\n        }\n\n        cvxStaker.withdrawAndUnwrap(lpAmount, false, address(this));\n\n        uint256[2] memory minAmounts;\n\n        minAmounts[stETHIndex] = minStETHOut;\n\n        uint256 output = curvePool.remove_liquidity_one_coin(\n            lpAmount,\n            int128(int(stETHIndex)),\n            minStETHOut\n        );\n\n        stETH.safeTransfer(msg.sender, output);\n    }\n}"
    },
    {
      "filename": "src/AMO2.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\nimport \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin-contracts/access/AccessControl.sol\";\nimport \"./interfaces/ICurvePool.sol\";\nimport {IXETH} from \"./interfaces/IXETH.sol\";\nimport {CVXStaker} from \"./CVXStaker.sol\";\n\ncontract xETH_AMO is AccessControl {\n    using SafeERC20 for IERC20;\n\n    /// @notice Thrown when the xETH-stETH LP balance of the AMO is too low for the rebalancing operation.\n    error LpBalanceTooLow();\n\n    /// @notice Thrown when either the stETH or xETH balance in the pool is zero, which would prevent rebalancing.\n    error ZeroBalancePool();\n\n    /// @notice Thrown when a zero address is provided as an input, which is not allowed.\n    error ZeroAddressProvided();\n\n    /// @notice Thrown when a function is called with a zero value, which is not allowed.\n    error ZeroValueProvided();\n\n    /// @notice Thrown when an invalid slippage value is provided, outside the allowed range.\n    error InvalidSlippageBPS();\n\n    /// @notice Thrown when a rebalance attempt is made before the cooldown period has finished.\n    error CooldownNotFinished();\n\n    /// @notice Thrown when a rebalance attempt is made, but the current pool ratios do not require rebalancing.\n    error RebalanceNotRequired();\n\n    /// @notice Thrown when a rebalanceUp operation is not allowed based on the current pool ratios.\n    error RebalanceUpNotAllowed();\n\n    /// @notice Thrown when a rebalanceDown operation is not allowed based on the current pool ratios.\n    error RebalanceDownNotAllowed();\n\n    /// @notice Thrown when the requested rebalanceUp operation exceeds the allowed rebalanceUpCap.\n    error RebalanceUpCapExceeded();\n\n    /// @notice Thrown when the requested rebalanceDown operation exceeds the allowed rebalanceDownCap.\n    error RebalanceDownCapExceeded();\n\n    /// @notice Emitted when a rebalanceUp operation is performed.\n    /// @param quote The chosen quote for rebalancing.\n    /// @param xETHamountReceived The actual amount of xETH received after burning LP tokens.\n    event RebalanceUpFinished(\n        RebalanceUpQuote quote,\n        uint256 xETHamountReceived\n    );\n\n    /// @notice Emitted when a rebalanceDown operation is performed.\n    /// @param quote The chosen quote for rebalancing.\n    /// @param lpAmountReceived The actual amount of xETH-stETH LP tokens received after minting xETH.\n    event RebalanceDownFinished(\n        RebalanceDownQuote quote,\n        uint256 lpAmountReceived\n    );\n\n    /// @notice Emitted when the defender address is updated.\n    /// @param oldDefender The previous defender address.\n    /// @param newDefender The new defender address.\n    event DefenderUpdated(address oldDefender, address newDefender);\n\n    /// @notice Emitted when the maxSlippageBPS is updated.\n    /// @param oldMaxSlippageBPS The previous max slippage value.\n    /// @param newMaxSlippageBPS The new max slippage value.\n    event MaxSlippageBPSUpdated(\n        uint256 oldMaxSlippageBPS,\n        uint256 newMaxSlippageBPS\n    );\n\n    /// @notice Emitted when the rebalanceUpCap is updated.\n    /// @param oldRebalanceUpCap The previous rebalanceUpCap value.\n    /// @param newRebalanceUpCap The new rebalanceUpCap value.\n    event RebalanceUpCapUpdated(\n        uint256 oldRebalanceUpCap,\n        uint256 newRebalanceUpCap\n    );\n\n    /// @notice Emitted when the rebalanceDownCap is updated.\n    /// @param oldRebalanceDownCap The previous rebalanceDownCap value.\n    /// @param newRebalanceDownCap The new rebalanceDownCap value.\n    event RebalanceDownCapUpdated(\n        uint256 oldRebalanceDownCap,\n        uint256 newRebalanceDownCap\n    );\n\n    /// @notice Emitted when the cooldownBlocks is updated.\n    /// @param oldCooldownBlocks The previous cooldownBlocks value.\n    /// @param newCooldownBlocks The new cooldownBlocks value.\n    event CooldownBlocksUpdated(\n        uint256 oldCooldownBlocks,\n        uint256 newCooldownBlocks\n    );\n\n    /// @notice Emitted when the CVXStaker address is updated.\n    /// @param oldCVXStaker The previous CVXStaker address.\n    /// @param newCVXStaker The new CVXStaker address.\n    event CVXStakerUpdated(address oldCVXStaker, address newCVXStaker);\n\n    /// @notice Emitted when the rebalance up threshold is set.\n    /// @param oldThreshold The old rebalance up threshold.\n    /// @param newThreshold The new rebalance up threshold.\n    event SetRebalanceUpThreshold(uint256 oldThreshold, uint256 newThreshold);\n\n    /// @notice Emitted when the rebalance down threshold is set.\n    /// @param oldThreshold The old rebalance down threshold.\n    /// @param newThreshold The new rebalance down threshold.\n    event SetRebalanceDownThreshold(uint256 oldThreshold, uint256 newThreshold);\n\n    /// @dev REBALANCE_DEFENDER_ROLE is the role that allows the defender to call rebalance()\n    bytes32 public constant REBALANCE_DEFENDER_ROLE =\n        keccak256(\"REBALANCE_DEFENDER_ROLE\");\n\n    /// @dev BASE_UNIT is the base unit used for calculations (1E18)\n    uint256 public constant BASE_UNIT = 1E18;\n\n    /// @dev xETHIndex is the index of xETH in the Curve pool\n    uint256 public immutable xETHIndex;\n\n    /// @dev stETHIndex is the index of stETH in the Curve pool\n    uint256 public immutable stETHIndex;\n\n    /// @dev xETH is the xETH token contract\n    IXETH public immutable xETH;\n\n    /// @dev stETH is the stETH token contract\n    IERC20 public immutable stETH;\n\n    /// @dev curvePool is the Curve pool contract\n    ICurvePool public immutable curvePool;\n\n    /// @dev maxSlippageBPS is the maximum slippage allowed when rebalancing\n    /// @notice 1E14 = 1 BPS\n    uint256 public maxSlippageBPS = 100 * 1E14;\n\n    /// @dev rebalanceUpCap is the maximum amount of xETH-stETH LP that can be burnt in a single rebalance\n    uint256 public rebalanceUpCap;\n\n    /// @dev rebalanceDownCap is the maximum amount of xETH that can be minted in a single rebalance\n    uint256 public rebalanceDownCap;\n\n    /// @dev lastRebalanceBlock is the block number of the last rebalance\n    uint256 public lastRebalanceBlock;\n\n    /// @dev cooldownBlocks is the number of blocks that must pass between rebalances\n    uint256 public cooldownBlocks = 1800; /// (6 * 60 * 60) / 12\n\n    /// @dev REBALANCE_UP_THRESHOLD is the upper threshold for the xETH-stETH LP ratio\n    /// @notice if the ratio is above this value, rebalanceUp() will be called\n    uint256 public REBALANCE_UP_THRESHOLD = 0.75E18;\n\n    /// @dev REBALANCE_DOWN_THRESHOLD is the lower threshold for the xETH-stETH LP ratio\n    /// @notice if the ratio is below this value, rebalanceDown() will be called\n    uint256 public REBALANCE_DOWN_THRESHOLD = 0.68E18;\n\n    /// @dev defender is the whitelisted bot that can call rebalance()\n    address public defender;\n\n    /// @dev cvxStaker is the CVX staking contract\n    CVXStaker public cvxStaker;\n\n    /// @dev afterCooldownPeriod is a modifier that checks if the cooldown period has passed\n    modifier afterCooldownPeriod() {\n        if (lastRebalanceBlock + cooldownBlocks >= block.number)\n            revert CooldownNotFinished();\n        _;\n        lastRebalanceBlock = block.number;\n    }\n\n    constructor(\n        ad"
    }
  ]
}