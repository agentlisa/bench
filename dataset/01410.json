{
  "Title": "H-13: Incorrect pricing for CurveV2 LP Token",
  "Content": "# Issue H-13: Incorrect pricing for CurveV2 LP Token \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/621 \n\n## Found by \nxiaoming90\n\nThe price of the CurveV2 LP Tokens is incorrect as the incorrect quote currency is being used when computing the value, resulting in a loss of assets due to the overvaluing or undervaluing of the assets.\n\n## Vulnerability Detail\n\nUsing the Curve rETH/frxETH pool (0xe7c6e0a739021cdba7aac21b4b728779eef974d9) to illustrate the issue:\n\nThe price of the LP token of Curve rETH/frxETH pool can be obtained via the following `lp_price` function:\n\nhttps://etherscan.io/address/0xe7c6e0a739021cdba7aac21b4b728779eef974d9#code#L1308\n\n```python\ndef lp_price() -> uint256:\n    \"\"\"\n    Approximate LP token price\n    \"\"\"\n    return 2 * self.virtual_price * self.sqrt_int(self.internal_price_oracle()) / 10**18\n```\n\nThus, the formula to obtain the price of the LP token is as follows:\n\n$$\nprice_{LP} = 2 \\times virtualPrice \\times \\sqrt{internalPriceOracle}\n$$\n\nInformation about the $internalPriceOracle$ can be obtained from the `pool.price_oracle()` function or from the Curve's Pool page (https://curve.fi/#/ethereum/pools/factory-crypto-218/swap). Refer to the Price Data's Price Oracle section.\n\nhttps://etherscan.io/address/0xe7c6e0a739021cdba7aac21b4b728779eef974d9#code#L1341\n\n```python\ndef price_oracle() -> uint256:\n    return self.internal_price_oracle()\n```\n\nThe $internalPriceOracle$ is the price of `coins[1]`(frxETH) with `coins[0]`(rETH) as the quote currency, which means how many rETH (quote) are needed to purchase one frxETH (base).\n\n$$\nbase/quote \\\\\nfrxETH/rETH\n$$\n\nDuring pool registration, the `poolInfo.tokenToPrice` is always set to the second coin (`coins[1]`) as per Line 131 below. In this example, `poolInfo.tokenToPrice` will be set to frxETH token address (`coins[1]`).\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/CurveV2CryptoEthOracle.sol#L107\n\n```solidity\nFile: CurveV2CryptoEthOracle.sol\n107:     function registerPool(address curvePool, address curveLpToken, bool checkReentrancy) external onlyOwner {\n..SNIP..\n125:         /**\n126:          * Curve V2 pools always price second token in `coins` array in first token in `coins` array.  This means that\n127:          *    if `coins[0]` is Weth, and `coins[1]` is rEth, the price will be rEth as base and weth as quote.  Hence\n128:          *    to get lp price we will always want to use the second token in the array, priced in eth.\n129:          */\n130:         lpTokenToPool[lpToken] =\n131:             PoolData({ pool: curvePool, checkReentrancy: checkReentrancy ? 1 : 0, tokenToPrice: tokens[1] });\n```\n\nNote that `assetPrice` variable below is equivalent to $internalPriceOracle$ in the above formula.\n\nWhen fetching the price of the LP token, Line 166 computes the price of frxETH with ETH as the quote currency ($frxETH/ETH$) via the `getPriceInEth` function, and assigns to the `assetPrice` variable.\n\nHowever, the $internalPriceOracle$ or `assetPrice` should be $frxETH/rETH$ instead of $frxETH/ETH$. Thus, the price of the LP token computed will be incorrect.\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/CurveV2CryptoEthOracle.sol#L151\n\n```solidity\nFile: CurveV2CryptoEthOracle.sol\n151:     function getPriceInEth(address token) external returns (uint256 price) {\n152:         Errors.verifyNotZero(token, \"token\");\n153: \n154:         PoolData memory poolInfo = lpTokenToPool[token];\n155:         if (poolInfo.pool == address(0)) revert NotRegistered(token);\n156: \n157:         ICryptoSwapPool cryptoPool = ICryptoSwapPool(poolInfo.pool);\n158: \n159:         // Checking for read only reentrancy scenario.\n160:         if (poolInfo.checkReentrancy == 1) {\n161:             // This will fail in a reentrancy situation.\n162:             cryptoPool.claim_admin_fees();\n163:         }\n164: \n165:         uint256 virtualPrice = cryptoPool.get_virtual_price();\n166:         uint256 assetPrice = systemRegistry.rootPriceOracle().getPriceInEth(poolInfo.tokenToPrice);\n167: \n168:         return (2 * virtualPrice * sqrt(assetPrice)) / 10 ** 18;\n169:     }\n```\n\n## Impact\n\nThe protocol relies on the oracle to provide accurate pricing for many critical operations, such as determining the debt values of DV, calculators/stats used during the rebalancing process, NAV/shares of the LMPVault, and determining how much assets the users should receive during withdrawal. \n\nIncorrect pricing of LP tokens would result in many implications that lead to a loss of assets, such as users withdrawing more or fewer assets than expected due to over/undervalued vaults or strategy allowing an unprofitable rebalance to be executed.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/oracles/providers/CurveV2CryptoEthOracle.sol#L151\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate the `getPriceInEth` function to ensure that the $internalPriceOracle$ or `assetPrice` return the price of `coins[1]` with `coins[0]` as the quote currency.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/CurveV2CryptoEthOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { IPriceOracle } from \"src/interfaces/oracles/IPriceOracle.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { ICurveResolver } from \"src/interfaces/utils/ICurveResolver.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { ICryptoSwapPool } from \"src/interfaces/external/curve/ICryptoSwapPool.sol\";\n\ncontract CurveV2CryptoEthOracle is SystemComponent, SecurityBase, IPriceOracle {\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    ICurveResolver public immutable curveResolver;\n\n    /**\n     * @notice Struct for neccessary information for single Curve pool.\n     * @param pool The address of the curve pool.\n     * @param checkReentrancy uint8 representing a boolean.  0 for false, 1 for true.\n     * @param tokentoPrice Address of the token being priced in the Curve pool.\n     */\n    struct PoolData {\n        address pool;\n        uint8 checkReentrancy;\n        address tokenToPrice;\n    }\n\n    /**\n     * @notice Emitted when token Curve pool is registered.\n     * @param lpToken Lp token that has been registered.\n     */\n    event TokenRegistered(address lpToken);\n\n    /**\n     * @notice Emitted when a Curve pool registration is removed.\n     * @param lpToken Lp token that has been unregistered.\n     */\n    event TokenUnregistered(address lpToken);\n\n    /**\n     * @notice Thrown when pool returned is not a v2 curve pool.\n     * @param curvePool Address of the pool that was attempted to be registered.\n     */\n    error NotCryptoPool(address curvePool);\n\n    /**\n     * @notice Thrown when wrong lp token is returned from CurveResolver.sol.\n     * @param providedLP Address of lp token provided in function call.\n     * @param queriedLP Address of lp tokens returned from resolver.\n     */\n    error ResolverMismatch(address providedLP, address queriedLP);\n\n    /**\n     * @notice Thrown when a Curve V2 Lp token is already registered.\n     * @param curveLpToken The address of the token attempted to be deployed.\n     */\n    error AlreadyRegistered(address curveLpToken);\n\n    /**\n     * @notice Thrown when lp token is not registered.\n     * @param curveLpToken Address of token expected to be registered.\n     */\n    error NotRegistered(address curveLpToken);\n\n    /**\n     * @notice Thrown when a pool with an invalid number of tokens is attempted to be registered.\n     * @param numTokens The number of tokens in the pool attempted to be registered.\n     */\n    error InvalidNumTokens(uint256 numTokens);\n\n    /**\n     * @notice Thrown when a pool that does not have native Eth as a token in the pair is registered\n     *      for a read only reentrancy check.\n     */\n    error MustHaveEthForReentrancy();\n\n    /**\n     * @notice Thrown when y and z values do not converge during square root calculation.\n     */\n    error SqrtError();\n\n    /// @notice Reverse mapping of LP token to pool info.\n    mapping(address => PoolData) public lpTokenToPool;\n\n    /**\n     * @param _systemRegistry Instance of system registry for this version of the system.\n     * @param _curveResolver Instance of Curve Resolver.\n     */\n    constructor(\n        ISystemRegistry _systemRegistry,\n        ICurveResolver _curveResolver\n    ) SystemComponent(_systemRegistry) SecurityBase(address(_systemRegistry.accessController())) {\n        Errors.verifyNotZero(address(_systemRegistry.rootPriceOracle()), \"rootPriceOracle\");\n        Errors.verifyNotZero(address(_curveResolver), \"_curveResolver\");\n\n        curveResolver = _curveResolver;\n    }\n\n    /**\n     * @notice Allows owner of system to register a pool.\n     * @param curvePool Address of CurveV2 pool.\n     * @param curveLpToken Address of LP token associated with v2 pool.\n     * @param checkReentrancy Whether to check read-only reentrancy on pool.\n     */\n    function registerPool(address curvePool, address curveLpToken, bool checkReentrancy) external onlyOwner {\n        Errors.verifyNotZero(curvePool, \"curvePool\");\n        Errors.verifyNotZero(curveLpToken, \"curveLpToken\");\n        if (lpTokenToPool[curveLpToken].pool != address(0)) revert AlreadyRegistered(curveLpToken);\n\n        (address[8] memory tokens, uint256 numTokens, address lpToken, bool isStableSwap) =\n            curveResolver.resolveWithLpToken(curvePool);\n\n        // Only two token pools compatible with this contract.\n        if (numTokens != 2) revert InvalidNumTokens(numTokens);\n        if (isStableSwap) revert NotCryptoPool(curvePool);\n        if (lpToken != curveLpToken) revert ResolverMismatch(curveLpToken, lpToken);\n\n        // Only need ability to check for read-only reentrancy for pools containing native Eth.\n        if (checkReentrancy) {\n            if (tokens[0] != ETH && tokens[1] != ETH) revert MustHaveEthForReentrancy();\n        }\n\n        /**\n         * Curve V2 pools always price second token in `coins` array in first token in `coins` array.  This means that\n         *    if `coins[0]` is Weth, and `coins[1]` is rEth, the price will be rEth as base and weth as quote.  Hence\n         *    to get lp price we will always want to use the second token in the array, priced in eth.\n         */\n        lpTokenToPool[lpToken] =\n            PoolData({ pool: curvePool, checkReentrancy: checkReentrancy ? 1 : 0, tokenToPrice: tokens[1] });\n\n        emit TokenRegistered(lpToken);\n    }\n\n    /**\n     * @notice Allows owner of system to unregister curve pool.\n     * @param curveLpToken Address of CurveV2 lp token to unregister.\n     */\n    function unregister(address curveLpToken) external onlyOwner {\n        Errors.verifyNotZero(curveLpToken, \"curveLpToken\");\n\n        if (lpTokenToPool[curveLpToken].pool == address(0)) revert NotRegistered(curveLpToken);\n\n        delete lpTokenToPool[curveLpToken];\n\n        emit TokenUnregistered(curveLpToken);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function getPriceInEth(address token) external returns (uint256 price) {\n        Errors.verifyNotZero(token, \"token\");\n\n        PoolData memory poolInfo = lpTokenToPool[token];\n        if (poolInfo.pool == address(0)) revert NotRegistered(token);\n\n        ICryptoSwapPool cryptoPool = ICryptoSwapPool(poolInfo.pool);\n\n        // Checking for read only reentrancy scenario.\n        if (poolInfo.checkReentrancy == 1) {\n            // This will fail in a reentrancy situation.\n            cryptoPool.claim_admin_fees();\n        }\n\n        uint256 virtualPrice = cryptoPool.get_virtual_price();\n        uint256 assetPrice = systemRegistry.rootPriceOracle().getPriceInEth(poolInfo.tokenToPrice);\n\n        return (2 * virtualPrice * sqrt(assetPrice)) / 10 ** 18;\n    }\n\n    // solhint-disable max-line-length\n    // Adapted from CurveV2 pools, see here:\n    // https://github.com/curvefi/curve-crypto-contract/blob/d7d04cd9ae038970e40be850df99de8c1ff7241b/contracts/two/CurveCryptoSwap2.vy#L1330\n    function sqrt(uint256 x) private pure returns (uint256) {\n        if (x == 0) return 0;\n\n        uint256 z = (x + 10 ** 18) / 2;\n        uint256 y = x;\n\n        for (uint256 i = 0; i < 256;) {\n            if (z == y) {\n                return y;\n            }\n            y = z;\n            z = (x * 10 ** 18 / z + z) / 2;\n\n            unchecked {\n                ++i;\n            }\n        }\n        revert SqrtError();\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/CurveV2CryptoEthOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { IPriceOracle } from \"src/interfaces/oracles/IPriceOracle.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { ICurveResolver } from \"src/interfaces/utils/ICurveResolver.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { ICryptoSwapPool } from \"src/interfaces/external/curve/ICryptoSwapPool.sol\";\n\ncontract CurveV2CryptoEthOracle is SystemComponent, SecurityBase, IPriceOracle {\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    ICurveResolver public immutable curveResolver;\n\n    /**\n     * @notice Struct for neccessary information for single Curve pool.\n     * @param pool The address of the curve pool.\n     * @param checkReentrancy uint8 representing a boolean.  0 for false, 1 for true.\n     * @param tokentoPrice Address of the token being priced in the Curve pool.\n     */\n    struct PoolData {\n        address pool;\n        uint8 checkReentrancy;\n        address tokenToPrice;\n    }\n\n    /**\n     * @notice Emitted when token Curve pool is registered.\n     * @param lpToken Lp token that has been registered.\n     */\n    event TokenRegistered(address lpToken);\n\n    /**\n     * @notice Emitted when a Curve pool registration is removed.\n     * @param lpToken Lp token that has been unregistered.\n     */\n    event TokenUnregistered(address lpToken);\n\n    /**\n     * @notice Thrown when pool returned is not a v2 curve pool.\n     * @param curvePool Address of the pool that was attempted to be registered.\n     */\n    error NotCryptoPool(address curvePool);\n\n    /**\n     * @notice Thrown when wrong lp token is returned from CurveResolver.sol.\n     * @param providedLP Address of lp token provided in function call.\n     * @param queriedLP Address of lp tokens returned from resolver.\n     */\n    error ResolverMismatch(address providedLP, address queriedLP);\n\n    /**\n     * @notice Thrown when a Curve V2 Lp token is already registered.\n     * @param curveLpToken The address of the token attempted to be deployed.\n     */\n    error AlreadyRegistered(address curveLpToken);\n\n    /**\n     * @notice Thrown when lp token is not registered.\n     * @param curveLpToken Address of token expected to be registered.\n     */\n    error NotRegistered(address curveLpToken);\n\n    /**\n     * @notice Thrown when a pool with an invalid number of tokens is attempted to be registered.\n     * @param numTokens The number of tokens in the pool attempted to be registered.\n     */\n    error InvalidNumTokens(uint256 numTokens);\n\n    /**\n     * @notice Thrown when a pool that does not have native Eth as a token in the pair is registered\n     *      for a read only reentrancy check.\n     */\n    error MustHaveEthForReentrancy();\n\n    /**\n     * @notice Thrown when y and z values do not converge during square root calculation.\n     */\n    error SqrtError();\n\n    /// @notice Reverse mapping of LP token to pool info.\n    mapping(address => PoolData) public lpTokenToPool;\n\n    /**\n     * @param _systemRegistry Instance of system registry for this version of the system.\n     * @param _curveResolver Instance of Curve Resolver.\n     */\n    constructor(\n        ISystemRegistry _systemRegistry,\n        ICurveResolver _curveResolver\n    ) SystemComponent(_systemRegistry) SecurityBase(address(_systemRegistry.accessController())) {\n        Errors.verifyNotZero(address(_systemRegistry.rootPriceOracle()), \"rootPriceOracle\");\n        Errors.verifyNotZero(address(_curveResolver), \"_curveResolver\");\n\n        curveResolver = _curveResolver;\n    }\n\n    /**\n     * @notice Allows owner of system to register a pool.\n     * @param curvePool Address of CurveV2 pool.\n     * @param curveLpToken Address of LP token associated with v2 pool.\n     * @param checkReentrancy Whether to check read-only reentrancy on pool.\n     */\n    function registerPool(address curvePool, address curveLpToken, bool checkReentrancy) external onlyOwner {\n        Errors.verifyNotZero(curvePool, \"curvePool\");\n        Errors.verifyNotZero(curveLpToken, \"curveLpToken\");\n        if (lpTokenToPool[curveLpToken].pool != address(0)) revert AlreadyRegistered(curveLpToken);\n\n        (address[8] memory tokens, uint256 numTokens, address lpToken, bool isStableSwap) =\n            curveResolver.resolveWithLpToken(curvePool);\n\n        // Only two token pools compatible with this contract.\n        if (numTokens != 2) revert InvalidNumTokens(numTokens);\n        if (isStableSwap) revert NotCryptoPool(curvePool);\n        if (lpToken != curveLpToken) revert ResolverMismatch(curveLpToken, lpToken);\n\n        // Only need ability to check for read-only reentrancy for pools containing native Eth.\n        if (checkReentrancy) {\n            if (tokens[0] != ETH && tokens[1] != ETH) revert MustHaveEthForReentrancy();\n        }\n\n        /**\n         * Curve V2 pools always price second token in `coins` array in first token in `coins` array.  This means that\n         *    if `coins[0]` is Weth, and `coins[1]` is rEth, the price will be rEth as base and weth as quote.  Hence\n         *    to get lp price we will always want to use the second token in the array, priced in eth.\n         */\n        lpTokenToPool[lpToken] =\n            PoolData({ pool: curvePool, checkReentrancy: checkReentrancy ? 1 : 0, tokenToPrice: tokens[1] });\n\n        emit TokenRegistered(lpToken);\n    }\n\n    /**\n     * @notice Allows owner of system to unregister curve pool.\n     * @param curveLpToken Address of CurveV2 lp token to unregister.\n     */\n    function unregister(address curveLpToken) external onlyOwner {\n        Errors.verifyNotZero(curveLpToken, \"curveLpToken\");\n\n        if (lpTokenToPool[curveLpToken].pool == address(0)) revert NotRegistered(curveLpToken);\n\n        delete lpTokenToPool[curveLpToken];\n\n        emit TokenUnregistered(curveLpToken);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function getPriceInEth(address token) external returns (uint256 price) {\n        Errors.verifyNotZero(token, \"token\");\n\n        PoolData memory poolInfo = lpTokenToPool[token];\n        if (poolInfo.pool == address(0)) revert NotRegistered(token);\n\n        ICryptoSwapPool cryptoPool = ICryptoSwapPool(poolInfo.pool);\n\n        // Checking for read only reentrancy scenario.\n        if (poolInfo.checkReentrancy == 1) {\n            // This will fail in a reentrancy situation.\n            cryptoPool.claim_admin_fees();\n        }\n\n        uint256 virtualPrice = cryptoPool.get_virtual_price();\n        uint256 assetPrice = systemRegistry.rootPriceOracle().getPriceInEth(poolInfo.tokenToPrice);\n\n        return (2 * virtualPrice * sqrt(assetPrice)) / 10 ** 18;\n    }\n\n    // solhint-disable max-line-length\n    // Adapted from CurveV2 pools, see here:\n    // https://github.com/curvefi/curve-crypto-contract/blob/d7d04cd9ae038970e40be850df99de8c1ff7241b/contracts/two/CurveCryptoSwap2.vy#L1330\n    function sqrt(uint256 x) private pure returns (uint256) {\n        if (x == 0) return 0;\n\n        uint256 z = (x + 10 ** 18) / 2;\n        uint256 y = x;\n\n        for (uint256 i = 0; i < 256;) {\n            if (z == y) {\n                return y;\n            }\n            y = z;\n            z = (x * 10 ** 18 / z + z) / 2;\n\n            unchecked {\n                ++i;\n            }\n        }\n        revert SqrtError();\n    }\n}"
    },
    {
      "filename": "v2-core-audit-2023-07-14/src/oracles/providers/CurveV2CryptoEthOracle.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\n\npragma solidity 0.8.17;\n\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { IPriceOracle } from \"src/interfaces/oracles/IPriceOracle.sol\";\nimport { SystemComponent } from \"src/SystemComponent.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { ICurveResolver } from \"src/interfaces/utils/ICurveResolver.sol\";\nimport { Errors } from \"src/utils/Errors.sol\";\nimport { ICryptoSwapPool } from \"src/interfaces/external/curve/ICryptoSwapPool.sol\";\n\ncontract CurveV2CryptoEthOracle is SystemComponent, SecurityBase, IPriceOracle {\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    ICurveResolver public immutable curveResolver;\n\n    /**\n     * @notice Struct for neccessary information for single Curve pool.\n     * @param pool The address of the curve pool.\n     * @param checkReentrancy uint8 representing a boolean.  0 for false, 1 for true.\n     * @param tokentoPrice Address of the token being priced in the Curve pool.\n     */\n    struct PoolData {\n        address pool;\n        uint8 checkReentrancy;\n        address tokenToPrice;\n    }\n\n    /**\n     * @notice Emitted when token Curve pool is registered.\n     * @param lpToken Lp token that has been registered.\n     */\n    event TokenRegistered(address lpToken);\n\n    /**\n     * @notice Emitted when a Curve pool registration is removed.\n     * @param lpToken Lp token that has been unregistered.\n     */\n    event TokenUnregistered(address lpToken);\n\n    /**\n     * @notice Thrown when pool returned is not a v2 curve pool.\n     * @param curvePool Address of the pool that was attempted to be registered.\n     */\n    error NotCryptoPool(address curvePool);\n\n    /**\n     * @notice Thrown when wrong lp token is returned from CurveResolver.sol.\n     * @param providedLP Address of lp token provided in function call.\n     * @param queriedLP Address of lp tokens returned from resolver.\n     */\n    error ResolverMismatch(address providedLP, address queriedLP);\n\n    /**\n     * @notice Thrown when a Curve V2 Lp token is already registered.\n     * @param curveLpToken The address of the token attempted to be deployed.\n     */\n    error AlreadyRegistered(address curveLpToken);\n\n    /**\n     * @notice Thrown when lp token is not registered.\n     * @param curveLpToken Address of token expected to be registered.\n     */\n    error NotRegistered(address curveLpToken);\n\n    /**\n     * @notice Thrown when a pool with an invalid number of tokens is attempted to be registered.\n     * @param numTokens The number of tokens in the pool attempted to be registered.\n     */\n    error InvalidNumTokens(uint256 numTokens);\n\n    /**\n     * @notice Thrown when a pool that does not have native Eth as a token in the pair is registered\n     *      for a read only reentrancy check.\n     */\n    error MustHaveEthForReentrancy();\n\n    /**\n     * @notice Thrown when y and z values do not converge during square root calculation.\n     */\n    error SqrtError();\n\n    /// @notice Reverse mapping of LP token to pool info.\n    mapping(address => PoolData) public lpTokenToPool;\n\n    /**\n     * @param _systemRegistry Instance of system registry for this version of the system.\n     * @param _curveResolver Instance of Curve Resolver.\n     */\n    constructor(\n        ISystemRegistry _systemRegistry,\n        ICurveResolver _curveResolver\n    ) SystemComponent(_systemRegistry) SecurityBase(address(_systemRegistry.accessController())) {\n        Errors.verifyNotZero(address(_systemRegistry.rootPriceOracle()), \"rootPriceOracle\");\n        Errors.verifyNotZero(address(_curveResolver), \"_curveResolver\");\n\n        curveResolver = _curveResolver;\n    }\n\n    /**\n     * @notice Allows owner of system to register a pool.\n     * @param curvePool Address of CurveV2 pool.\n     * @param curveLpToken Address of LP token associated with v2 pool.\n     * @param checkReentrancy Whether to check read-only reentrancy on pool.\n     */\n    function registerPool(address curvePool, address curveLpToken, bool checkReentrancy) external onlyOwner {\n        Errors.verifyNotZero(curvePool, \"curvePool\");\n        Errors.verifyNotZero(curveLpToken, \"curveLpToken\");\n        if (lpTokenToPool[curveLpToken].pool != address(0)) revert AlreadyRegistered(curveLpToken);\n\n        (address[8] memory tokens, uint256 numTokens, address lpToken, bool isStableSwap) =\n            curveResolver.resolveWithLpToken(curvePool);\n\n        // Only two token pools compatible with this contract.\n        if (numTokens != 2) revert InvalidNumTokens(numTokens);\n        if (isStableSwap) revert NotCryptoPool(curvePool);\n        if (lpToken != curveLpToken) revert ResolverMismatch(curveLpToken, lpToken);\n\n        // Only need ability to check for read-only reentrancy for pools containing native Eth.\n        if (checkReentrancy) {\n            if (tokens[0] != ETH && tokens[1] != ETH) revert MustHaveEthForReentrancy();\n        }\n\n        /**\n         * Curve V2 pools always price second token in `coins` array in first token in `coins` array.  This means that\n         *    if `coins[0]` is Weth, and `coins[1]` is rEth, the price will be rEth as base and weth as quote.  Hence\n         *    to get lp price we will always want to use the second token in the array, priced in eth.\n         */\n        lpTokenToPool[lpToken] =\n            PoolData({ pool: curvePool, checkReentrancy: checkReentrancy ? 1 : 0, tokenToPrice: tokens[1] });\n\n        emit TokenRegistered(lpToken);\n    }\n\n    /**\n     * @notice Allows owner of system to unregister curve pool.\n     * @param curveLpToken Address of CurveV2 lp token to unregister.\n     */\n    function unregister(address curveLpToken) external onlyOwner {\n        Errors.verifyNotZero(curveLpToken, \"curveLpToken\");\n\n        if (lpTokenToPool[curveLpToken].pool == address(0)) revert NotRegistered(curveLpToken);\n\n        delete lpTokenToPool[curveLpToken];\n\n        emit TokenUnregistered(curveLpToken);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function getPriceInEth(address token) external returns (uint256 price) {\n        Errors.verifyNotZero(token, \"token\");\n\n        PoolData memory poolInfo = lpTokenToPool[token];\n        if (poolInfo.pool == address(0)) revert NotRegistered(token);\n\n        ICryptoSwapPool cryptoPool = ICryptoSwapPool(poolInfo.pool);\n\n        // Checking for read only reentrancy scenario.\n        if (poolInfo.checkReentrancy == 1) {\n            // This will fail in a reentrancy situation.\n            cryptoPool.claim_admin_fees();\n        }\n\n        uint256 virtualPrice = cryptoPool.get_virtual_price();\n        uint256 assetPrice = systemRegistry.rootPriceOracle().getPriceInEth(poolInfo.tokenToPrice);\n\n        return (2 * virtualPrice * sqrt(assetPrice)) / 10 ** 18;\n    }\n\n    // solhint-disable max-line-length\n    // Adapted from CurveV2 pools, see here:\n    // https://github.com/curvefi/curve-crypto-contract/blob/d7d04cd9ae038970e40be850df99de8c1ff7241b/contracts/two/CurveCryptoSwap2.vy#L1330\n    function sqrt(uint256 x) private pure returns (uint256) {\n        if (x == 0) return 0;\n\n        uint256 z = (x + 10 ** 18) / 2;\n        uint256 y = x;\n\n        for (uint256 i = 0; i < 256;) {\n            if (z == y) {\n                return y;\n            }\n            y = z;\n            z = (x * 10 ** 18 / z + z) / 2;\n\n            unchecked {\n                ++i;\n            }\n        }\n        revert SqrtError();\n    }\n}"
    }
  ]
}