{
  "Title": "[M-04] VotiumStrategy withdrawal queue fails to consider available unlocked tokens causing different issues in the withdraw process",
  "Content": "\nWithdrawals in VotiumStrategy are executed in queue since CVX tokens are potentially locked in Convex. However, the implementation fails to consider the case where unlocked assets are already enough to cover the withdrawal, leading to different issues.\n\n### Impact\n\nVotiumStrategy withdrawals are executed in queue since the underlying CVX tokens may be locked in the Convex platform. Depositors must request a withdrawal and wait in queue until the epoch associated with their withdrawal is reached in order to exit their position. The core of this logic is present in the function `requestWithdraw()`:\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategy.sol#L54-L103>\n\n```solidity\n054:     function requestWithdraw(\n055:         uint256 _amount\n056:     ) public override returns (uint256 withdrawId) {\n057:         latestWithdrawId++;\n058:         uint256 _priceInCvx = cvxPerVotium();\n059: \n060:         _burn(msg.sender, _amount);\n061: \n062:         uint256 currentEpoch = ILockedCvx(VLCVX_ADDRESS).findEpochId(\n063:             block.timestamp\n064:         );\n065:         (\n066:             ,\n067:             uint256 unlockable,\n068:             ,\n069:             ILockedCvx.LockedBalance[] memory lockedBalances\n070:         ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(address(this));\n071:         uint256 cvxAmount = (_amount * _priceInCvx) / 1e18;\n072:         cvxUnlockObligations += cvxAmount;\n073: \n074:         uint256 totalLockedBalancePlusUnlockable = unlockable +\n075:             IERC20(CVX_ADDRESS).balanceOf(address(this));\n076: \n077:         for (uint256 i = 0; i < lockedBalances.length; i++) {\n078:             totalLockedBalancePlusUnlockable += lockedBalances[i].amount;\n079:             // we found the epoch at which there is enough to unlock this position\n080:             if (totalLockedBalancePlusUnlockable >= cvxUnlockObligations) {\n081:                 (, uint32 currentEpochStartingTime) = ILockedCvx(VLCVX_ADDRESS)\n082:                     .epochs(currentEpoch);\n083:                 uint256 timeDifference = lockedBalances[i].unlockTime -\n084:                     currentEpochStartingTime;\n085:                 uint256 epochOffset = timeDifference /\n086:                     ILockedCvx(VLCVX_ADDRESS).rewardsDuration();\n087:                 uint256 withdrawEpoch = currentEpoch + epochOffset;\n088:                 withdrawIdToWithdrawRequestInfo[\n089:                     latestWithdrawId\n090:                 ] = WithdrawRequestInfo({\n091:                     cvxOwed: cvxAmount,\n092:                     withdrawn: false,\n093:                     epoch: withdrawEpoch,\n094:                     owner: msg.sender\n095:                 });\n096: \n097:                 emit WithdrawRequest(msg.sender, cvxAmount, latestWithdrawId);\n098:                 return latestWithdrawId;\n099:             }\n100:         }\n101:         // should never get here\n102:         revert InvalidLockedAmount();\n103:     }\n```\n\nThe implementation first considers available tokens that should be ready to be withdrawn. Line 74-75 sets `totalLockedBalancePlusUnlockable` to the amount of unlockable tokens (expired tokens in Convex that can be withdrawn) plus any available CVX balance in the contract.\n\nHowever, the implementation fails to consider that **this available balance may be already enough to cover the withdrawal**, and proceeds to search within the locked balances by epoch. This will lead to different issues:\n\n*   A user that requests a withdrawal of an amount such that there is enough available balance to cover for it, will still need to wait until the end of the next locked cycle. The implementation will start searching the locked balances array and stop at the first match, and set the withdrawal epoch as the end of the matched period. Even if there are enough tokens to cover for the withdrawal, the user is forced into an unnecessary delay.\n*   If there are none locked balances, meaning everything is already in an unlockable state, the implementation will **cause a denial of service**. The for loop in line 77 won't be executed and the execution will be reverted due to the revert in line 102.\n\n### Proof of Concept\n\nLet's illustrate the denial of service case. We assume all deposits in VotiumStrategy were done before the 16 weeks period, which means all vlCVX should be in an unlocked state.\n\n1.  User calls `requestWithdraw(amount)`.\n2.  The implementation fetches current position from vlCVX contract using `ILockedCvx.lockedBalances()`. This will return the entire position as `unlockable` and an empty array for `lockedBalances`.\n3.  The function sets `totalLockedBalancePlusUnlockable` as `unlockable + IERC20(CVX_ADDRESS).balanceOf(address(this))`. This should be enough to cover the requested amount by the user.\n4.  The implementation continues to search through the `lockedBalances`, but since this array is empty the for loop is never executed.\n5.  The function reaches the end and is reverted with a `InvalidLockedAmount()` error.\n\n### Recommendation\n\nBefore searching through the `lockedBalances` array, check if there available unlocked tokens are enough to cover the withdrawal. If so, the withdrawal can be set for the current epoch. This will fix the unnecessary delay and the potential denial of service.\n\n```diff\n    function requestWithdraw(\n        uint256 _amount\n    ) public override returns (uint256 withdrawId) {\n        latestWithdrawId++;\n        uint256 _priceInCvx = cvxPerVotium();\n\n        _burn(msg.sender, _amount);\n\n        uint256 currentEpoch = ILockedCvx(VLCVX_ADDRESS).findEpochId(\n            block.timestamp\n        );\n        (\n            ,\n            uint256 unlockable,\n            ,\n            ILockedCvx.LockedBalance[] memory lockedBalances\n        ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(address(this));\n        uint256 cvxAmount = (_amount * _priceInCvx) / 1e18;\n        cvxUnlockObligations += cvxAmount;\n\n        uint256 totalLockedBalancePlusUnlockable = unlockable +\n            IERC20(CVX_ADDRESS).balanceOf(address(this));\n        \n+       if (totalLockedBalancePlusUnlockable >= amount) {\n+           withdrawIdToWithdrawRequestInfo[\n+               latestWithdrawId\n+           ] = WithdrawRequestInfo({\n+               cvxOwed: cvxAmount,\n+               withdrawn: false,\n+               epoch: currentEpoch,\n+               owner: msg.sender\n+           });\n+           emit WithdrawRequest(msg.sender, cvxAmount, latestWithdrawId);\n+           return latestWithdrawId;\n+       }\n\n        for (uint256 i = 0; i < lockedBalances.length; i++) {\n            totalLockedBalancePlusUnlockable += lockedBalances[i].amount;\n            // we found the epoch at which there is enough to unlock this position\n            if (totalLockedBalancePlusUnlockable >= cvxUnlockObligations) {\n                (, uint32 currentEpochStartingTime) = ILockedCvx(VLCVX_ADDRESS)\n                    .epochs(currentEpoch);\n                uint256 timeDifference = lockedBalances[i].unlockTime -\n                    currentEpochStartingTime;\n                uint256 epochOffset = timeDifference /\n                    ILockedCvx(VLCVX_ADDRESS).rewardsDuration();\n                uint256 withdrawEpoch = currentEpoch + epochOffset;\n                withdrawIdToWithdrawRequestInfo[\n                    latestWithdrawId\n                ] = WithdrawRequestInfo({\n                    cvxOwed: cvxAmount,\n                    withdrawn: false,\n                    epoch: withdrawEpoch,\n                    owner: msg.sender\n                });\n\n                emit WithdrawRequest(msg.sender, cvxAmount, latestWithdrawId);\n                return latestWithdrawId;\n            }\n        }\n        // should never get here\n        revert InvalidLockedAmount();\n    }\n```\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/49#issuecomment-1746416854):**\n > It seems pretty severe that `requestWithdraw()` would fail when the `lockedBalances` array is empty right?\n\n**[elmutt (Asymmetry) confirmed and commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/49#issuecomment-1749259495):**\n > @0xleastwood - Absolutely agree. We are working on a fix to address this issue.\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/49#issuecomment-1752018144):**\n > I think this DoS is recoverable. If all locks are unlocked/expired, then it will not be possible to request a withdrawal. However, if `relock()` is called, then additional requests to withdraw can be processed and the final impact is that the request is delayed more than it needs to be.\n>\n> It's not possible to prevent withdrawal finalisation by calling `relock()` first either because `cvxUnlockObligations` is used to reserve cvx that is owed to existing withdrawal requests.\n>\n> I think I will leave it as-is unless there is a way to brick funds by preventing users from finalising their withdrawals.\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-10-asymmetry-mitigation#mitigations-to-be-reviewed):**\n >\tCheck if available amount to withdraw is already in contract.\n\n**Status**: Mitigation confirmed. Full details in reports from [adriro](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/37) and [d3e4](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/19).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-asymmetry",
  "Code": [
    {
      "filename": "contracts/strategies/votium/VotiumStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"../AbstractStrategy.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./VotiumStrategyCore.sol\";\n\n/// @title Votium Strategy Token\n/// @author Asymmetry Finance\ncontract VotiumStrategy is VotiumStrategyCore, AbstractStrategy {\n    event WithdrawRequest(\n        address indexed user,\n        uint256 amount,\n        uint256 withdrawId\n    );\n\n    struct WithdrawRequestInfo {\n        uint256 cvxOwed;\n        bool withdrawn;\n        uint256 epoch;\n        address owner;\n    }\n\n    mapping(uint256 => WithdrawRequestInfo)\n        public withdrawIdToWithdrawRequestInfo;\n\n    /**\n     * @notice Gets price in eth\n     * @return Price of token in eth\n     */\n    function price() external view override returns (uint256) {\n        return (cvxPerVotium() * ethPerCvx(false)) / 1e18;\n    }\n\n    /**\n     * @notice Deposit eth to mint this token at current price\n     * @return mintAmount Amount of tokens minted\n     */\n    function deposit() public payable override returns (uint256 mintAmount) {\n        uint256 priceBefore = cvxPerVotium();\n        uint256 cvxAmount = buyCvx(msg.value);\n        IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmount);\n        ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmount, 0);\n        mintAmount = ((cvxAmount * 1e18) / priceBefore);\n        _mint(msg.sender, mintAmount);\n    }\n\n    /**\n     * @notice Request to withdraw from strategy emits event with eligible withdraw epoch\n     * @notice Burns afEth tokens and determines equivilent amount of cvx to start unlocking\n     * @param _amount Amount to request withdraw\n     * @return withdrawId Id of withdraw request\n     */\n    function requestWithdraw(\n        uint256 _amount\n    ) public override returns (uint256 withdrawId) {\n        latestWithdrawId++;\n        uint256 _priceInCvx = cvxPerVotium();\n\n        _burn(msg.sender, _amount);\n\n        uint256 currentEpoch = ILockedCvx(VLCVX_ADDRESS).findEpochId(\n            block.timestamp\n        );\n        (\n            ,\n            uint256 unlockable,\n            ,\n            ILockedCvx.LockedBalance[] memory lockedBalances\n        ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(address(this));\n        uint256 cvxAmount = (_amount * _priceInCvx) / 1e18;\n        cvxUnlockObligations += cvxAmount;\n\n        uint256 totalLockedBalancePlusUnlockable = unlockable +\n            IERC20(CVX_ADDRESS).balanceOf(address(this));\n\n        for (uint256 i = 0; i < lockedBalances.length; i++) {\n            totalLockedBalancePlusUnlockable += lockedBalances[i].amount;\n            // we found the epoch at which there is enough to unlock this position\n            if (totalLockedBalancePlusUnlockable >= cvxUnlockObligations) {\n                (, uint32 currentEpochStartingTime) = ILockedCvx(VLCVX_ADDRESS)\n                    .epochs(currentEpoch);\n                uint256 timeDifference = lockedBalances[i].unlockTime -\n                    currentEpochStartingTime;\n                uint256 epochOffset = timeDifference /\n                    ILockedCvx(VLCVX_ADDRESS).rewardsDuration();\n                uint256 withdrawEpoch = currentEpoch + epochOffset;\n                withdrawIdToWithdrawRequestInfo[\n                    latestWithdrawId\n                ] = WithdrawRequestInfo({\n                    cvxOwed: cvxAmount,\n                    withdrawn: false,\n                    epoch: withdrawEpoch,\n                    owner: msg.sender\n                });\n\n                emit WithdrawRequest(msg.sender, cvxAmount, latestWithdrawId);\n                return latestWithdrawId;\n            }\n        }\n        // should never get here\n        revert InvalidLockedAmount();\n    }\n\n    /**\n     * @notice Withdraws from requested withdraw if eligible epoch has passed\n     * @param _withdrawId Id of withdraw request\n     */\n    function withdraw(uint256 _withdrawId) external override {\n        if (withdrawIdToWithdrawRequestInfo[_withdrawId].owner != msg.sender)\n            revert NotOwner();\n        if (!this.canWithdraw(_withdrawId)) revert WithdrawNotReady();\n\n        if (withdrawIdToWithdrawRequestInfo[_withdrawId].withdrawn)\n            revert AlreadyWithdrawn();\n\n        relock();\n\n        uint256 cvxWithdrawAmount = withdrawIdToWithdrawRequestInfo[_withdrawId]\n            .cvxOwed;\n\n        uint256 ethReceived = sellCvx(cvxWithdrawAmount);\n        cvxUnlockObligations -= cvxWithdrawAmount;\n        withdrawIdToWithdrawRequestInfo[_withdrawId].withdrawn = true;\n\n        // solhint-disable-next-line\n        (bool sent, ) = msg.sender.call{value: ethReceived}(\"\");\n        if (!sent) revert FailedToSend();\n    }\n\n    /**\n     * @notice Relocks cvx while ensuring there is enough to cover all withdraw requests\n     * @dev This happens automatically on withdraw but will need to be manually called if no withdraws happen in an epoch where locks are expiring\n     */\n    function relock() public {\n        (, uint256 unlockable, , ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(\n            address(this)\n        );\n        if (unlockable > 0)\n            ILockedCvx(VLCVX_ADDRESS).processExpiredLocks(false);\n        uint256 cvxBalance = IERC20(CVX_ADDRESS).balanceOf(address(this));\n        uint256 cvxAmountToRelock = cvxBalance > cvxUnlockObligations\n            ? cvxBalance - cvxUnlockObligations\n            : 0;\n        if (cvxAmountToRelock > 0) {\n            IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmountToRelock);\n            ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmountToRelock, 0);\n        }\n    }\n\n    /**\n     * @notice Checks if withdraw request is eligible to be withdrawn\n     * @param _withdrawId Id of withdraw request\n     */\n    function canWithdraw(\n        uint256 _withdrawId\n    ) external view virtual override returns (bool) {\n        uint256 currentEpoch = ILockedCvx(VLCVX_ADDRESS).findEpochId(\n            block.timestamp\n        );\n        return\n            withdrawIdToWithdrawRequestInfo[_withdrawId].epoch <= currentEpoch;\n    }\n\n    /**\n     * @notice Checks how long it will take to withdraw a given amount\n     * @param _amount Amount of afEth to check how long it will take to withdraw\n     * @return When it would be withdrawable based on the amount\n     */\n    function withdrawTime(\n        uint256 _amount\n    ) external view virtual override returns (uint256) {\n        uint256 _priceInCvx = cvxPerVotium();\n        (\n            ,\n            uint256 unlockable,\n            ,\n            ILockedCvx.LockedBalance[] memory lockedBalances\n        ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(address(this));\n        uint256 cvxAmount = (_amount * _priceInCvx) / 1e18;\n        uint256 totalLockedBalancePlusUnlockable = unlockable +\n            IERC20(CVX_ADDRESS).balanceOf(address(this));\n\n        for (uint256 i = 0; i < lockedBalances.length; i++) {\n            totalLockedBalancePlusUnlockable += lockedBalances[i].amount;\n            // we found the epoch at which there is enough to unlock this position\n            if (\n                totalLockedBalancePlusUnlockable >=\n                cvxUnlockObligations + cvxAmount\n            ) {\n                return lockedBalances[i].unlockTime;\n            }\n        }\n        revert InvalidLockedAmount();\n    }\n}"
    }
  ]
}