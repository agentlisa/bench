{
  "Title": "Faucet.withdrawAll() does not change active status",
  "Content": "##### Description\n\n`Faucet.active` is `false` if the native balance is below `CLAIM_AMOUNT`.\n- https://github.com/KintoXYZ/kinto-core/blob/f7dd98f66b9dfba1f73758703b808051196e740b/src/Faucet.sol#L78-L79\n\nBut when `withdrawAll()` is called, it does not change the status:\n- https://github.com/KintoXYZ/kinto-core/blob/f7dd98f66b9dfba1f73758703b808051196e740b/src/Faucet.sol#L54-L56.\n\n##### Recommendation\n\nWe recommend setting `active` as `false` in `withdrawAll()`.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/Faucet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport {IFaucet} from './interfaces/IFaucet.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\nimport {SignatureChecker} from '@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol';\n\n/**\n * @title Faucet\n * @dev The Kinto Faucet gives a bit of ETH to users to pay for gas fees\n */\ncontract Faucet is Ownable, IFaucet{\n    using ECDSA for bytes32;\n    using SignatureChecker for address;\n\n    /* ============ Events ============ */\n    event Claim(address indexed _to, uint256 _timestamp);\n\n    /* ============ Constants ============ */\n    uint public constant CLAIM_AMOUNT = 1 ether / 200;\n    uint public constant FAUCET_AMOUNT = 1 ether;\n\n    /* ============ State Variables ============ */\n    mapping(address => bool) public override claimed;\n    bool public active;\n\n    /// @dev We include a nonce in every hashed message, and increment the nonce as part of a\n    /// state-changing operation, so as to prevent replay attacks, i.e. the reuse of a signature.\n    mapping(address => uint256) public override nonces;\n\n    constructor(){}\n\n    /**\n    * @dev Allows users to claim KintoETH from the smart contract's faucet once per account\n    */\n    function claimKintoETH() external override {\n        _privateClaim(msg.sender);\n    }\n\n    /**\n     * @dev Claim via meta tx on behalf of a new account by the owner\n     * @param _signatureData Signature data\n    */\n    function claimOnBehalf(IFaucet.SignatureData calldata _signatureData) external\n      onlyOwner onlySignerVerified(_signatureData) {\n       _privateClaim(_signatureData.account);\n       nonces[_signatureData.account]++;\n    }\n\n    /**\n    * @dev Function to withdraw all eth by owner\n    */\n    function withdrawAll() external override onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    /**\n    * @dev Function to start the faucet\n    */\n    function startFaucet() payable external override onlyOwner {\n        require(msg.value >= FAUCET_AMOUNT, 'Not enough ETH to start faucet');\n        active = true;\n    }\n\n    /**\n    * @dev Allows the contract to receive Ether\n    */\n    receive() external payable {}\n\n    /* ============ Private functions ============ */\n\n    function _privateClaim(address _receiver) private {\n        require(active, 'Faucet is not active');\n        require(!claimed[_receiver], 'You have already claimed your KintoETH');\n        claimed[_receiver] = true;\n        payable(_receiver).transfer(CLAIM_AMOUNT);\n        if (address(this).balance < CLAIM_AMOUNT) {\n            active = false;\n        }\n        emit Claim(_receiver, block.timestamp);\n    }\n\n    /* ============ Signature Recovery ============ */\n\n    /**\n     * @dev Check that the signature is valid and the address has not claimed yet.\n     * @param _signature signature to be recovered.\n     */\n    modifier onlySignerVerified(\n      IFaucet.SignatureData calldata _signature\n    ) {\n        require(block.timestamp < _signature.expiresAt, 'Signature has expired');\n        require(nonces[_signature.signer] == _signature.nonce, 'Invalid Nonce');\n        require(owner() == msg.sender, 'Invalid Sender');\n        bytes32 hash = keccak256(\n          abi.encodePacked(\n            '\\x19\\x01',   // EIP-191 header\n            keccak256(abi.encode(\n                _signature.signer,\n                address(this),\n                _signature.account,\n                _signature.expiresAt,\n                nonces[_signature.signer],\n                bytes32(block.chainid)\n            ))\n          )\n        ).toEthSignedMessageHash();\n\n        require(\n          _signature.signer.isValidSignatureNow(hash, _signature.signature),\n          'Invalid Signer'\n        );\n        _;\n    }\n}"
    },
    {
      "filename": "src/Faucet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport {IFaucet} from './interfaces/IFaucet.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\nimport {SignatureChecker} from '@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol';\n\n/**\n * @title Faucet\n * @dev The Kinto Faucet gives a bit of ETH to users to pay for gas fees\n */\ncontract Faucet is Ownable, IFaucet{\n    using ECDSA for bytes32;\n    using SignatureChecker for address;\n\n    /* ============ Events ============ */\n    event Claim(address indexed _to, uint256 _timestamp);\n\n    /* ============ Constants ============ */\n    uint public constant CLAIM_AMOUNT = 1 ether / 200;\n    uint public constant FAUCET_AMOUNT = 1 ether;\n\n    /* ============ State Variables ============ */\n    mapping(address => bool) public override claimed;\n    bool public active;\n\n    /// @dev We include a nonce in every hashed message, and increment the nonce as part of a\n    /// state-changing operation, so as to prevent replay attacks, i.e. the reuse of a signature.\n    mapping(address => uint256) public override nonces;\n\n    constructor(){}\n\n    /**\n    * @dev Allows users to claim KintoETH from the smart contract's faucet once per account\n    */\n    function claimKintoETH() external override {\n        _privateClaim(msg.sender);\n    }\n\n    /**\n     * @dev Claim via meta tx on behalf of a new account by the owner\n     * @param _signatureData Signature data\n    */\n    function claimOnBehalf(IFaucet.SignatureData calldata _signatureData) external\n      onlyOwner onlySignerVerified(_signatureData) {\n       _privateClaim(_signatureData.account);\n       nonces[_signatureData.account]++;\n    }\n\n    /**\n    * @dev Function to withdraw all eth by owner\n    */\n    function withdrawAll() external override onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    /**\n    * @dev Function to start the faucet\n    */\n    function startFaucet() payable external override onlyOwner {\n        require(msg.value >= FAUCET_AMOUNT, 'Not enough ETH to start faucet');\n        active = true;\n    }\n\n    /**\n    * @dev Allows the contract to receive Ether\n    */\n    receive() external payable {}\n\n    /* ============ Private functions ============ */\n\n    function _privateClaim(address _receiver) private {\n        require(active, 'Faucet is not active');\n        require(!claimed[_receiver], 'You have already claimed your KintoETH');\n        claimed[_receiver] = true;\n        payable(_receiver).transfer(CLAIM_AMOUNT);\n        if (address(this).balance < CLAIM_AMOUNT) {\n            active = false;\n        }\n        emit Claim(_receiver, block.timestamp);\n    }\n\n    /* ============ Signature Recovery ============ */\n\n    /**\n     * @dev Check that the signature is valid and the address has not claimed yet.\n     * @param _signature signature to be recovered.\n     */\n    modifier onlySignerVerified(\n      IFaucet.SignatureData calldata _signature\n    ) {\n        require(block.timestamp < _signature.expiresAt, 'Signature has expired');\n        require(nonces[_signature.signer] == _signature.nonce, 'Invalid Nonce');\n        require(owner() == msg.sender, 'Invalid Sender');\n        bytes32 hash = keccak256(\n          abi.encodePacked(\n            '\\x19\\x01',   // EIP-191 header\n            keccak256(abi.encode(\n                _signature.signer,\n                address(this),\n                _signature.account,\n                _signature.expiresAt,\n                nonces[_signature.signer],\n                bytes32(block.chainid)\n            ))\n          )\n        ).toEthSignedMessageHash();\n\n        require(\n          _signature.signer.isValidSignatureNow(hash, _signature.signature),\n          'Invalid Signer'\n        );\n        _;\n    }\n}"
    }
  ]
}