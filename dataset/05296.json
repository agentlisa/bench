{
  "Title": "[H-04] Incorrect `gnosis_safe_disable_module_offset` constant leads to removing the rental safe's `module` without verification",
  "Content": "\nThe `gnosis_safe_disable_module_offset` constant was incorrectly specified to point at an incorrect function parameter of the `disableModule(address prevModule, address module)`.\n\nSpecifically, the offset constant will point at the `prevModule` (1st param) instead of the `module` (2nd param).\n\n### Impact\n\nWhen a safe transaction initiated from a rental safe containing a call to the safe's `disableModule()` is invoked, the `Guard::checkTransaction()` cannot verify the `module` expected to be removed.\n\nIf the `prevModule` was a non-whitelisted extension, the safe transaction will be reverted.\n\nHowever, if the `prevModule` was a whitelisted extension, the `module` will be removed without verification. Removing the rental safe's `module` without verification can lead to other issues or attacks since the removed `module` can be a critical component (e.g., removing the protocol's `Stop` policy contract).\n\n### Proof of Concept\n\nThe snippet below presents some of the Gnosis Safe configurations of the `reNFT protocol`. The [`gnosis_safe_disable_module_selector`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/libraries/RentalConstants.sol#L58) constant contains the function selector (`0xe009cfde`) of the rental safe's `ModuleManager::disableModule(address prevModule, address module)`.\n\nMeanwhile, the [`gnosis_safe_disable_module_offset`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/libraries/RentalConstants.sol#L62) constant contains a memory offset (`0x24`) intended to point at the `module` param of the `disableModule()`.\n\n```solidity\n    // FILE: https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/libraries/RentalConstants.sol\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                  Gnosis Safe Function Selectors And Offsets                 //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    ...\n\n    // bytes4(keccak256(\"disableModule(address,address)\"));\n@1  bytes4 constant gnosis_safe_disable_module_selector = 0xe009cfde; //@audit -- The declaration of function selector: ModuleManager::disableModule(address prevModule, address module)\n\n    ...\n\n@2  uint256 constant gnosis_safe_disable_module_offset = 0x24; //@audit -- The memory offset intended to point at the 'module' param of the disableModule() was incorrectly specified to the 'prevModule' param instead\n```\n\n*   `@1 -- The declaration of function selector: ModuleManager::disableModule(address prevModule, address module)`: <https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/libraries/RentalConstants.sol#L58>\n*   `@2 -- The memory offset intended to point at the 'module' param of the disableModule() was incorrectly specified to the 'prevModule' param instead`: <https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/libraries/RentalConstants.sol#L62>\n\nThe below snippet shows the function signature of the rental safe's [`ModuleManager::disableModule()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/interfaces/ISafe.sol#L98-L101):\n`function disableModule(address prevModule, address module) external`\n\nLet's break down the value of the `gnosis_safe_disable_module_offset` constant (`0x24`):\n0x24 == 36 == 32 (the calldata's array length) + 4 (the function selector)\n\nAs you can see, the `gnosis_safe_disable_module_offset` was incorrectly specified to point at the `prevModule` param (1st param) instead of the `module` param (2nd param) that refers to the `module` expected to be removed.\n\n```solidity\n    // FILE: https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/interfaces/ISafe.sol\n    /**\n     * @notice Disables the module `module` for the Safe.\n     *\n     * @dev This can only be done via a Safe transaction.\n     *\n@3   * @param prevModule Previous module in the modules linked list.\n@3   * @param module     Module to be removed.\n     */\n@3  function disableModule(address prevModule, address module) external; //@audit -- The memory offset must point at the second param because it would be the module to be removed\n```\n\n*   `@3 -- The memory offset must point at the second param because it would be the module to be removed`: <https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/interfaces/ISafe.sol#L98-L101>\n\nWith the incorrect `gnosis_safe_disable_module_offset` constant, once the `Guard::_checkTransaction()` is triggered to verify the safe transaction containing a [call to the safe's `disableModule()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L255), the address of the [`prevModule` contract](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L260) will be extracted and assigned to the `extension` variable instead of the `module` contract's.\n\nConsequently, the address of the [`prevModule` contract](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L266) will be verified for the whitelist by the `Guard::_revertNonWhitelistedExtension()` instead of the expected `module` contract address.\n\n<details>\n\n```solidity\n    // FILE: https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol\n    function _checkTransaction(address from, address to, bytes memory data) private view {\n        bytes4 selector;\n\n        // Load in the function selector.\n        assembly {\n            selector := mload(add(data, 0x20))\n        }\n\n        ... // some if-else cases\n        \n@4      } else if (selector == gnosis_safe_disable_module_selector) { //@audit -- Check for calls to the disableModule() initiated from Safe contracts\n            // Load the extension address from calldata.\n            address extension = address(\n                uint160(\n                    uint256(\n@5                      _loadValueFromCalldata(data, gnosis_safe_disable_module_offset) //@audit -- Since the gnosis_safe_disable_module_offset constant points at the incorrect param (i.e., prevModule), the extension variable will contain an address of the prevModule\n                    )\n                )\n            );\n\n            // Check if the extension is whitelisted.\n@6          _revertNonWhitelistedExtension(extension); //@audit -- The address of the prevModule will be checked for the whitelist instead of the expected module to be removed\n        } \n\n        ... // else case\n    }\n```\n</details>\n\n\n*   `@4 -- Check for calls to the disableModule() initiated from Safe contracts`: <https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L255>\n*   `@5 -- Since the gnosis_safe_disable_module_offset constant points at the incorrect param (i.e., prevModule), the extension variable will contain an address of the prevModule`: <https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L260>\n*   `@6 -- The address of the prevModule will be checked for the whitelist instead of the expected module to be removed`: <https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L266>\n\nBesides, I also noticed that the developer also assumed that the `disableModule()` would have one function parameter while writing the test functions: [`test_Success_CheckTransaction_Gnosis_DisableModule()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/test/unit/Guard/CheckTransaction.t.sol#L369) and [`test_Reverts_CheckTransaction_Gnosis_DisableModule()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/test/unit/Guard/CheckTransaction.t.sol#L557).\n\nThat can confirm why the test functions cannot catch up with the mistake.\n\n<details>\n\n```solidity\n    // FILE: https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/test/unit/Guard/CheckTransaction.t.sol\n    function test_Success_CheckTransaction_Gnosis_DisableModule() public {\n        // impersonate the admin policy admin\n        vm.prank(deployer.addr);\n\n        // enable this address to be added as a module by rental safes\n        admin.toggleWhitelistExtension(address(mockTarget), true);\n\n        // Build up the `disableModule(address)` calldata\n        bytes memory disableModuleCalldata = abi.encodeWithSelector(\n            gnosis_safe_disable_module_selector,\n@7          address(mockTarget) //@audit -- In the test function: test_Success_CheckTransaction_Gnosis_DisableModule(), the developer assumed that the disableModule() would have one param (incorrect!!)\n        );\n\n        // Check the transaction\n        _checkTransaction(address(this), address(mockTarget), disableModuleCalldata);\n    }\n\n    ...\n\n    function test_Reverts_CheckTransaction_Gnosis_DisableModule() public {\n        // Build up the `disableModule(address)` calldata\n        bytes memory disableModuleCalldata = abi.encodeWithSelector(\n            gnosis_safe_disable_module_selector,\n@8          address(mockTarget) //@audit -- Also in the test function: test_Reverts_CheckTransaction_Gnosis_DisableModule(), the developer assumed that the disableModule() would have one param (incorrect!!)\n        );\n\n        // Expect revert because of an unauthorized extension\n        _checkTransactionRevertUnauthorizedExtension(\n            address(this),\n            address(mockTarget),\n            disableModuleCalldata\n        );\n    }\n```\n\n</details>\n\n*   `@7 -- In the test function: test_Success_CheckTransaction_Gnosis_DisableModule(), the developer assumed that the disableModule() would have one param (incorrect!!)`: <https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/test/unit/Guard/CheckTransaction.t.sol#L369>\n*   `@8 -- Also in the test function: test_Reverts_CheckTransaction_Gnosis_DisableModule(), the developer assumed that the disableModule() would have one param (incorrect!!)`: <https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/test/unit/Guard/CheckTransaction.t.sol#L557>\n\n### Recommended Mitigation Steps\n\nTo point the memory offset at the `module` param (2nd param), the `gnosis_safe_disable_module_offset` constant must be set to `0x44` (0x44 == 68 == 32 (the calldata's array length) + 4 (the function selector) + 32 (1st param)).\n\n```diff\n    // FILE: https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/libraries/RentalConstants.sol\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                  Gnosis Safe Function Selectors And Offsets                 //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    ...\n\n    // bytes4(keccak256(\"disableModule(address,address)\"));\n    bytes4 constant gnosis_safe_disable_module_selector = 0xe009cfde;\n\n    ...\n\n-   uint256 constant gnosis_safe_disable_module_offset = 0x24;\n+   uint256 constant gnosis_safe_disable_module_offset = 0x44;\n```\n\n**[Alec1017 (reNFT) confirmed and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/565#issuecomment-1910732014):**\n > PoC confirmed!\n\n_Note: To see full discussion, see [here](https://github.com/code-423n4/2024-01-renft-findings/issues/565)._\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/1) - Fixes offset value so that the proper address is checked when disabling a gnosis module from a safe.\n\n**Status:** Mitigation confirmed. Full details in reports from [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/5), [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/44) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/33).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-01-renft",
  "Code": [
    {
      "filename": "src/libraries/RentalConstants.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/////////////////////////////////////////////////////////////////////////////////\n//                           Shared Function Selectors                         //\n/////////////////////////////////////////////////////////////////////////////////\n\n// bytes4(keccak256(\"setApprovalForAll(address,bool)\"));\nbytes4 constant shared_set_approval_for_all_selector = 0xa22cb465;\n\n/////////////////////////////////////////////////////////////////////////////////\n//                    ERC-721 Function Selectors And Offsets                   //\n/////////////////////////////////////////////////////////////////////////////////\n\n// bytes4(keccak256(\"approve(address,uint256)\"));\nbytes4 constant e721_approve_selector = 0x095ea7b3;\n\n// bytes4(keccak256(\"safeTransferFrom(address,address,uint256)\"));\nbytes4 constant e721_safe_transfer_from_1_selector = 0x42842e0e;\n\n// bytes4(keccak256(\"safeTransferFrom(address,address,uint256,bytes)\"));\nbytes4 constant e721_safe_transfer_from_2_selector = 0xb88d4fde;\n\n// bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\nbytes4 constant e721_transfer_from_selector = 0x23b872dd;\n\n// Token ID offsets for ERC-721\nuint256 constant e721_approve_token_id_offset = 0x44;\nuint256 constant e721_safe_transfer_from_1_token_id_offset = 0x64;\nuint256 constant e721_safe_transfer_from_2_token_id_offset = 0x64;\nuint256 constant e721_transfer_from_token_id_offset = 0x64;\n\n/////////////////////////////////////////////////////////////////////////////////\n//                    ERC-1155 Function Selectors And Offsets                  //\n/////////////////////////////////////////////////////////////////////////////////\n\n// bytes4(keccak256(\"safeTransferFrom(address,address,uint256,uint256,bytes)\"))\nbytes4 constant e1155_safe_transfer_from_selector = 0xf242432a;\n\n// bytes4(keccak256(\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\"))\nbytes4 constant e1155_safe_batch_transfer_from_selector = 0x2eb2c2d6;\n\n// Token ID offsets for ERC-1155\nuint256 constant e1155_safe_transfer_from_token_id_offset = 0x64;\nuint256 constant e1155_safe_batch_transfer_from_token_id_offset = 0x64;\n\n/////////////////////////////////////////////////////////////////////////////////\n//                  Gnosis Safe Function Selectors And Offsets                 //\n/////////////////////////////////////////////////////////////////////////////////\n\n// bytes4(keccak256(\"setGuard(address)\"));\nbytes4 constant gnosis_safe_set_guard_selector = 0xe19a9dd9;\n\n// bytes4(keccak256(\"enableModule(address)\"));\nbytes4 constant gnosis_safe_enable_module_selector = 0x610b5925;\n\n// bytes4(keccak256(\"disableModule(address,address)\"));\nbytes4 constant gnosis_safe_disable_module_selector = 0xe009cfde;\n\n// Module offsets for gnosis safe\nuint256 constant gnosis_safe_enable_module_offset = 0x24;\nuint256 constant gnosis_safe_disable_module_offset = 0x24;"
    },
    {
      "filename": "src/libraries/RentalConstants.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/////////////////////////////////////////////////////////////////////////////////\n//                           Shared Function Selectors                         //\n/////////////////////////////////////////////////////////////////////////////////\n\n// bytes4(keccak256(\"setApprovalForAll(address,bool)\"));\nbytes4 constant shared_set_approval_for_all_selector = 0xa22cb465;\n\n/////////////////////////////////////////////////////////////////////////////////\n//                    ERC-721 Function Selectors And Offsets                   //\n/////////////////////////////////////////////////////////////////////////////////\n\n// bytes4(keccak256(\"approve(address,uint256)\"));\nbytes4 constant e721_approve_selector = 0x095ea7b3;\n\n// bytes4(keccak256(\"safeTransferFrom(address,address,uint256)\"));\nbytes4 constant e721_safe_transfer_from_1_selector = 0x42842e0e;\n\n// bytes4(keccak256(\"safeTransferFrom(address,address,uint256,bytes)\"));\nbytes4 constant e721_safe_transfer_from_2_selector = 0xb88d4fde;\n\n// bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\nbytes4 constant e721_transfer_from_selector = 0x23b872dd;\n\n// Token ID offsets for ERC-721\nuint256 constant e721_approve_token_id_offset = 0x44;\nuint256 constant e721_safe_transfer_from_1_token_id_offset = 0x64;\nuint256 constant e721_safe_transfer_from_2_token_id_offset = 0x64;\nuint256 constant e721_transfer_from_token_id_offset = 0x64;\n\n/////////////////////////////////////////////////////////////////////////////////\n//                    ERC-1155 Function Selectors And Offsets                  //\n/////////////////////////////////////////////////////////////////////////////////\n\n// bytes4(keccak256(\"safeTransferFrom(address,address,uint256,uint256,bytes)\"))\nbytes4 constant e1155_safe_transfer_from_selector = 0xf242432a;\n\n// bytes4(keccak256(\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\"))\nbytes4 constant e1155_safe_batch_transfer_from_selector = 0x2eb2c2d6;\n\n// Token ID offsets for ERC-1155\nuint256 constant e1155_safe_transfer_from_token_id_offset = 0x64;\nuint256 constant e1155_safe_batch_transfer_from_token_id_offset = 0x64;\n\n/////////////////////////////////////////////////////////////////////////////////\n//                  Gnosis Safe Function Selectors And Offsets                 //\n/////////////////////////////////////////////////////////////////////////////////\n\n// bytes4(keccak256(\"setGuard(address)\"));\nbytes4 constant gnosis_safe_set_guard_selector = 0xe19a9dd9;\n\n// bytes4(keccak256(\"enableModule(address)\"));\nbytes4 constant gnosis_safe_enable_module_selector = 0x610b5925;\n\n// bytes4(keccak256(\"disableModule(address,address)\"));\nbytes4 constant gnosis_safe_disable_module_selector = 0xe009cfde;\n\n// Module offsets for gnosis safe\nuint256 constant gnosis_safe_enable_module_offset = 0x24;\nuint256 constant gnosis_safe_disable_module_offset = 0x24;"
    },
    {
      "filename": "src/libraries/RentalConstants.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/////////////////////////////////////////////////////////////////////////////////\n//                           Shared Function Selectors                         //\n/////////////////////////////////////////////////////////////////////////////////\n\n// bytes4(keccak256(\"setApprovalForAll(address,bool)\"));\nbytes4 constant shared_set_approval_for_all_selector = 0xa22cb465;\n\n/////////////////////////////////////////////////////////////////////////////////\n//                    ERC-721 Function Selectors And Offsets                   //\n/////////////////////////////////////////////////////////////////////////////////\n\n// bytes4(keccak256(\"approve(address,uint256)\"));\nbytes4 constant e721_approve_selector = 0x095ea7b3;\n\n// bytes4(keccak256(\"safeTransferFrom(address,address,uint256)\"));\nbytes4 constant e721_safe_transfer_from_1_selector = 0x42842e0e;\n\n// bytes4(keccak256(\"safeTransferFrom(address,address,uint256,bytes)\"));\nbytes4 constant e721_safe_transfer_from_2_selector = 0xb88d4fde;\n\n// bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\nbytes4 constant e721_transfer_from_selector = 0x23b872dd;\n\n// Token ID offsets for ERC-721\nuint256 constant e721_approve_token_id_offset = 0x44;\nuint256 constant e721_safe_transfer_from_1_token_id_offset = 0x64;\nuint256 constant e721_safe_transfer_from_2_token_id_offset = 0x64;\nuint256 constant e721_transfer_from_token_id_offset = 0x64;\n\n/////////////////////////////////////////////////////////////////////////////////\n//                    ERC-1155 Function Selectors And Offsets                  //\n/////////////////////////////////////////////////////////////////////////////////\n\n// bytes4(keccak256(\"safeTransferFrom(address,address,uint256,uint256,bytes)\"))\nbytes4 constant e1155_safe_transfer_from_selector = 0xf242432a;\n\n// bytes4(keccak256(\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\"))\nbytes4 constant e1155_safe_batch_transfer_from_selector = 0x2eb2c2d6;\n\n// Token ID offsets for ERC-1155\nuint256 constant e1155_safe_transfer_from_token_id_offset = 0x64;\nuint256 constant e1155_safe_batch_transfer_from_token_id_offset = 0x64;\n\n/////////////////////////////////////////////////////////////////////////////////\n//                  Gnosis Safe Function Selectors And Offsets                 //\n/////////////////////////////////////////////////////////////////////////////////\n\n// bytes4(keccak256(\"setGuard(address)\"));\nbytes4 constant gnosis_safe_set_guard_selector = 0xe19a9dd9;\n\n// bytes4(keccak256(\"enableModule(address)\"));\nbytes4 constant gnosis_safe_enable_module_selector = 0x610b5925;\n\n// bytes4(keccak256(\"disableModule(address,address)\"));\nbytes4 constant gnosis_safe_disable_module_selector = 0xe009cfde;\n\n// Module offsets for gnosis safe\nuint256 constant gnosis_safe_enable_module_offset = 0x24;\nuint256 constant gnosis_safe_disable_module_offset = 0x24;"
    },
    {
      "filename": "src/libraries/RentalConstants.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/////////////////////////////////////////////////////////////////////////////////\n//                           Shared Function Selectors                         //\n/////////////////////////////////////////////////////////////////////////////////\n\n// bytes4(keccak256(\"setApprovalForAll(address,bool)\"));\nbytes4 constant shared_set_approval_for_all_selector = 0xa22cb465;\n\n/////////////////////////////////////////////////////////////////////////////////\n//                    ERC-721 Function Selectors And Offsets                   //\n/////////////////////////////////////////////////////////////////////////////////\n\n// bytes4(keccak256(\"approve(address,uint256)\"));\nbytes4 constant e721_approve_selector = 0x095ea7b3;\n\n// bytes4(keccak256(\"safeTransferFrom(address,address,uint256)\"));\nbytes4 constant e721_safe_transfer_from_1_selector = 0x42842e0e;\n\n// bytes4(keccak256(\"safeTransferFrom(address,address,uint256,bytes)\"));\nbytes4 constant e721_safe_transfer_from_2_selector = 0xb88d4fde;\n\n// bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\nbytes4 constant e721_transfer_from_selector = 0x23b872dd;\n\n// Token ID offsets for ERC-721\nuint256 constant e721_approve_token_id_offset = 0x44;\nuint256 constant e721_safe_transfer_from_1_token_id_offset = 0x64;\nuint256 constant e721_safe_transfer_from_2_token_id_offset = 0x64;\nuint256 constant e721_transfer_from_token_id_offset = 0x64;\n\n/////////////////////////////////////////////////////////////////////////////////\n//                    ERC-1155 Function Selectors And Offsets                  //\n/////////////////////////////////////////////////////////////////////////////////\n\n// bytes4(keccak256(\"safeTransferFrom(address,address,uint256,uint256,bytes)\"))\nbytes4 constant e1155_safe_transfer_from_selector = 0xf242432a;\n\n// bytes4(keccak256(\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\"))\nbytes4 constant e1155_safe_batch_transfer_from_selector = 0x2eb2c2d6;\n\n// Token ID offsets for ERC-1155\nuint256 constant e1155_safe_transfer_from_token_id_offset = 0x64;\nuint256 constant e1155_safe_batch_transfer_from_token_id_offset = 0x64;\n\n/////////////////////////////////////////////////////////////////////////////////\n//                  Gnosis Safe Function Selectors And Offsets                 //\n/////////////////////////////////////////////////////////////////////////////////\n\n// bytes4(keccak256(\"setGuard(address)\"));\nbytes4 constant gnosis_safe_set_guard_selector = 0xe19a9dd9;\n\n// bytes4(keccak256(\"enableModule(address)\"));\nbytes4 constant gnosis_safe_enable_module_selector = 0x610b5925;\n\n// bytes4(keccak256(\"disableModule(address,address)\"));\nbytes4 constant gnosis_safe_disable_module_selector = 0xe009cfde;\n\n// Module offsets for gnosis safe\nuint256 constant gnosis_safe_enable_module_offset = 0x24;\nuint256 constant gnosis_safe_disable_module_offset = 0x24;"
    },
    {
      "filename": "src/interfaces/ISafe.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Enum} from \"@safe-contracts/common/Enum.sol\";\n\n/**\n * @title ISafe\n * @notice Interface for a multisignature wallet with support for confirmations using\n *         signed messages based on EIP-712.\n */\ninterface ISafe {\n    /** @notice Executes a `operation` {0: Call, 1: DelegateCall}} transaction to `to`\n     *          with `value` (Native Currency) and pays `gasPrice` * `gasLimit` in\n     *          `gasToken` token to `refundReceiver`.\n     *\n     * @dev The fees are always transferred, even if the user transaction fails.\n     *      This method doesn't perform any sanity check of the transaction, such as:\n     *      - if the contract at `to` address has code or not\n     *      - if the `gasToken` is a contract or not\n     *      It is the responsibility of the caller to perform such checks.\n     *\n     * @param to             Destination address of Safe transaction.\n     * @param value          Ether value of Safe transaction.\n     * @param data           Data payload of Safe transaction.\n     * @param operation      Operation type of Safe transaction.\n     * @param safeTxGas      Gas that should be used for the Safe transaction.\n     * @param baseGas        Gas costs that are independent of the transaction\n     *                       execution(e.g. base transaction fee, signature check,\n     *                       payment of the refund).\n     * @param gasPrice       Gas price that should be used for the payment calculation.\n     * @param gasToken       Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param signatures     Signature data that should be verified. Can be packed ECDSA\n     *                       signature ({bytes32 r}{bytes32 s}{uint8 v}), contract\n     *                       signature (EIP-1271) or approved hash.\n     *\n     * @return success Boolean indicating transaction's success.\n     */\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) external payable returns (bool success);\n\n    /**\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value`\n     *         (Native Token).\n     *\n     * @dev Function is virtual to allow overriding for L2 singleton to emit an event for\n     *      indexing.\n     *\n     * @param to        Destination address of module transaction.\n     * @param value     Ether value of module transaction.\n     * @param data      Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     *\n     * @return success  Boolean flag indicating if the call succeeded.\n     */\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (bool success);\n\n    /**\n     * @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\n     *\n     * @dev This can only be done via a Safe transaction.\n     *\n     * @param prevOwner Owner that pointed to the owner to be replaced in the linked list\n     * @param oldOwner  Owner address to be replaced.\n     * @param newOwner  New owner address.\n     */\n    function swapOwner(address prevOwner, address oldOwner, address newOwner) external;\n\n    /**\n     * @notice Enables the module `module` for the Safe.\n     *\n     * @dev This can only be done via a Safe transaction.\n     *\n     * @param module Module to be whitelisted.\n     */\n    function enableModule(address module) external;\n\n    /**\n     * @notice Disables the module `module` for the Safe.\n     *\n     * @dev This can only be done via a Safe transaction.\n     *\n     * @param prevModule Previous module in the modules linked list.\n     * @param module     Module to be removed.\n     */\n    function disableModule(address prevModule, address module) external;\n\n    /**\n     * @notice Set Transaction Guard `guard` for the Safe. Make sure you trust the guard.\n     *\n     * @dev Set a guard that checks transactions before execution\n     *      This can only be done via a Safe transaction.\n     *      ⚠️ IMPORTANT: Since a guard has full power to block Safe transaction execution,\n     *        a broken guard can cause a denial of service for the Safe. Make sure to\n     *        carefully audit the guard code and design recovery mechanisms.\n     *\n     * @param guard The address of the guard to be used or the 0 address to disable the\n     *              guard.\n     */\n    function setGuard(address guard) external;\n\n    /**\n     * @notice Sets an initial storage of the Safe contract.\n     *\n     * @dev This method can only be called once. If a proxy was created without setting\n     *      up, anyone can call setup and claim the proxy.\n     *\n     * @param _owners         List of Safe owners.\n     * @param _threshold      Number of required confirmations for a Safe transaction.\n     * @param to              Contract address for optional delegate call.\n     * @param data            Data payload for optional delegate call.\n     * @param fallbackHandler Handler for fallback calls to this contract.\n     * @param paymentToken    Token that should be used for the payment (0 is ETH).\n     * @param payment         Value that should be paid.\n     * @param paymentReceiver Address that should receive the payment (or 0 if tx.origin).\n     */\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external;\n\n    /**\n     * @notice Returns if `owner` is an owner of the Safe.\n     *\n     * @return Boolean if owner is an owner of the Safe.\n     */\n    function isOwner(address owner) external view returns (bool);\n\n    /**\n     * @notice Returns transaction hash to be signed by owners.\n     *\n     * @param to             Destination address.\n     * @param value          Ether value.\n     * @param data           Data payload.\n     * @param operation      Operation type.\n     * @param safeTxGas      Fas that should be used for the safe transaction.\n     * @param baseGas        Gas costs for data used to trigger the safe transaction.\n     * @param gasPrice       Maximum gas price that should be used for this transaction.\n     * @param gasToken       Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param _nonce         Transaction nonce.\n     *\n     * @return transactionHash Transaction hash to be signed by owners.\n     */\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) external view returns (bytes32 transactionHash);\n\n    /**\n     * @notice Returns the nonce of the current transaction\n     *\n     * @return nonce The nonce of the current transaction\n     */\n    function nonce() external view returns (uint256 nonce);\n}"
    },
    {
      "filename": "src/interfaces/ISafe.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Enum} from \"@safe-contracts/common/Enum.sol\";\n\n/**\n * @title ISafe\n * @notice Interface for a multisignature wallet with support for confirmations using\n *         signed messages based on EIP-712.\n */\ninterface ISafe {\n    /** @notice Executes a `operation` {0: Call, 1: DelegateCall}} transaction to `to`\n     *          with `value` (Native Currency) and pays `gasPrice` * `gasLimit` in\n     *          `gasToken` token to `refundReceiver`.\n     *\n     * @dev The fees are always transferred, even if the user transaction fails.\n     *      This method doesn't perform any sanity check of the transaction, such as:\n     *      - if the contract at `to` address has code or not\n     *      - if the `gasToken` is a contract or not\n     *      It is the responsibility of the caller to perform such checks.\n     *\n     * @param to             Destination address of Safe transaction.\n     * @param value          Ether value of Safe transaction.\n     * @param data           Data payload of Safe transaction.\n     * @param operation      Operation type of Safe transaction.\n     * @param safeTxGas      Gas that should be used for the Safe transaction.\n     * @param baseGas        Gas costs that are independent of the transaction\n     *                       execution(e.g. base transaction fee, signature check,\n     *                       payment of the refund).\n     * @param gasPrice       Gas price that should be used for the payment calculation.\n     * @param gasToken       Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param signatures     Signature data that should be verified. Can be packed ECDSA\n     *                       signature ({bytes32 r}{bytes32 s}{uint8 v}), contract\n     *                       signature (EIP-1271) or approved hash.\n     *\n     * @return success Boolean indicating transaction's success.\n     */\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) external payable returns (bool success);\n\n    /**\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value`\n     *         (Native Token).\n     *\n     * @dev Function is virtual to allow overriding for L2 singleton to emit an event for\n     *      indexing.\n     *\n     * @param to        Destination address of module transaction.\n     * @param value     Ether value of module transaction.\n     * @param data      Data payload of module transaction.\n     * @param operation Operation type of module transaction.\n     *\n     * @return success  Boolean flag indicating if the call succeeded.\n     */\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (bool success);\n\n    /**\n     * @notice Replaces the owner `oldOwner` in the Safe with `newOwner`.\n     *\n     * @dev This can only be done via a Safe transaction.\n     *\n     * @param prevOwner Owner that pointed to the owner to be replaced in the linked list\n     * @param oldOwner  Owner address to be replaced.\n     * @param newOwner  New owner address.\n     */\n    function swapOwner(address prevOwner, address oldOwner, address newOwner) external;\n\n    /**\n     * @notice Enables the module `module` for the Safe.\n     *\n     * @dev This can only be done via a Safe transaction.\n     *\n     * @param module Module to be whitelisted.\n     */\n    function enableModule(address module) external;\n\n    /**\n     * @notice Disables the module `module` for the Safe.\n     *\n     * @dev This can only be done via a Safe transaction.\n     *\n     * @param prevModule Previous module in the modules linked list.\n     * @param module     Module to be removed.\n     */\n    function disableModule(address prevModule, address module) external;\n\n    /**\n     * @notice Set Transaction Guard `guard` for the Safe. Make sure you trust the guard.\n     *\n     * @dev Set a guard that checks transactions before execution\n     *      This can only be done via a Safe transaction.\n     *      ⚠️ IMPORTANT: Since a guard has full power to block Safe transaction execution,\n     *        a broken guard can cause a denial of service for the Safe. Make sure to\n     *        carefully audit the guard code and design recovery mechanisms.\n     *\n     * @param guard The address of the guard to be used or the 0 address to disable the\n     *              guard.\n     */\n    function setGuard(address guard) external;\n\n    /**\n     * @notice Sets an initial storage of the Safe contract.\n     *\n     * @dev This method can only be called once. If a proxy was created without setting\n     *      up, anyone can call setup and claim the proxy.\n     *\n     * @param _owners         List of Safe owners.\n     * @param _threshold      Number of required confirmations for a Safe transaction.\n     * @param to              Contract address for optional delegate call.\n     * @param data            Data payload for optional delegate call.\n     * @param fallbackHandler Handler for fallback calls to this contract.\n     * @param paymentToken    Token that should be used for the payment (0 is ETH).\n     * @param payment         Value that should be paid.\n     * @param paymentReceiver Address that should receive the payment (or 0 if tx.origin).\n     */\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external;\n\n    /**\n     * @notice Returns if `owner` is an owner of the Safe.\n     *\n     * @return Boolean if owner is an owner of the Safe.\n     */\n    function isOwner(address owner) external view returns (bool);\n\n    /**\n     * @notice Returns transaction hash to be signed by owners.\n     *\n     * @param to             Destination address.\n     * @param value          Ether value.\n     * @param data           Data payload.\n     * @param operation      Operation type.\n     * @param safeTxGas      Fas that should be used for the safe transaction.\n     * @param baseGas        Gas costs for data used to trigger the safe transaction.\n     * @param gasPrice       Maximum gas price that should be used for this transaction.\n     * @param gasToken       Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param _nonce         Transaction nonce.\n     *\n     * @return transactionHash Transaction hash to be signed by owners.\n     */\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) external view returns (bytes32 transactionHash);\n\n    /**\n     * @notice Returns the nonce of the current transaction\n     *\n     * @return nonce The nonce of the current transaction\n     */\n    function nonce() external view returns (uint256 nonce);\n}"
    },
    {
      "filename": "src/policies/Guard.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {BaseGuard} from \"@safe-contracts/base/GuardManager.sol\";\nimport {Enum} from \"@safe-contracts/common/Enum.sol\";\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {IHook} from \"@src/interfaces/IHook.sol\";\nimport {Kernel, Policy, Permissions, Keycode} from \"@src/Kernel.sol\";\nimport {toKeycode} from \"@src/libraries/KernelUtils.sol\";\nimport {Storage} from \"@src/modules/Storage.sol\";\nimport {\n    shared_set_approval_for_all_selector,\n    e721_approve_selector,\n    e721_safe_transfer_from_1_selector,\n    e721_safe_transfer_from_2_selector,\n    e721_transfer_from_selector,\n    e721_approve_token_id_offset,\n    e721_safe_transfer_from_1_token_id_offset,\n    e721_safe_transfer_from_2_token_id_offset,\n    e721_transfer_from_token_id_offset,\n    e1155_safe_transfer_from_selector,\n    e1155_safe_batch_transfer_from_selector,\n    e1155_safe_transfer_from_token_id_offset,\n    e1155_safe_batch_transfer_from_token_id_offset,\n    gnosis_safe_set_guard_selector,\n    gnosis_safe_enable_module_selector,\n    gnosis_safe_disable_module_selector,\n    gnosis_safe_enable_module_offset,\n    gnosis_safe_disable_module_offset\n} from \"@src/libraries/RentalConstants.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\n/**\n * @title Guard\n * @notice Acts as an interface for all behavior related to guarding transactions\n *         that originate from a rental wallet.\n */\ncontract Guard is Policy, BaseGuard {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    // Modules that the policy depends on.\n    Storage public STORE;\n\n    /**\n     * @dev Instantiate this contract as a policy.\n     *\n     * @param kernel_ Address of the kernel contract.\n     */\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /**\n     * @notice Upon policy activation, configures the modules that the policy depends on.\n     *         If a module is ever upgraded that this policy depends on, the kernel will\n     *         call this function again to ensure this policy has the current address\n     *         of the module.\n     *\n     * @return dependencies Array of keycodes which represent modules that\n     *                      this policy depends on.\n     */\n    function configureDependencies()\n        external\n        override\n        onlyKernel\n        returns (Keycode[] memory dependencies)\n    {\n        dependencies = new Keycode[](1);\n\n        dependencies[0] = toKeycode(\"STORE\");\n        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n    }\n\n    /**\n     * @notice Upon policy activation, permissions are requested from the kernel to access\n     *         particular keycode <> function selector pairs. Once these permissions are\n     *         granted, they do not change and can only be revoked when the policy is\n     *         deactivated by the kernel.\n     *\n     * @return requests Array of keycode <> function selector pairs which represent\n     *                  permissions for the policy.\n     */\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.updateHookPath.selector);\n        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.updateHookStatus.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                            Internal Functions                               //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Loads a `bytes32` value from calldata.\n     *\n     * @param data   Calldata of the transaction to execute.\n     * @param offset Byte offset where the value starts.\n     *\n     * @return value The value retrieved from the data.\n     */\n    function _loadValueFromCalldata(\n        bytes memory data,\n        uint256 offset\n    ) private pure returns (bytes32 value) {\n        // Load the `uint256` from calldata at the offset.\n        assembly {\n            value := mload(add(data, offset))\n        }\n    }\n\n    /**\n     * @dev Reverts if the token is actively rented.\n     *\n     * @param selector Function selector which cannot be called\n     * @param safe     Address of the safe that originated the call\n     * @param token    Address of the token which is actively rented.\n     * @param tokenId  ID of the token which is actively rented.\n     */\n    function _revertSelectorOnActiveRental(\n        bytes4 selector,\n        address safe,\n        address token,\n        uint256 tokenId\n    ) private view {\n        // Check if the selector is allowed.\n        if (STORE.isRentedOut(safe, token, tokenId)) {\n            revert Errors.GuardPolicy_UnauthorizedSelector(selector);\n        }\n    }\n\n    /**\n     * @dev Reverts if the extension is not whitelisted.\n     *\n     * @param extension Address of the extension.\n     */\n    function _revertNonWhitelistedExtension(address extension) private view {\n        // Check if the extension is whitelisted.\n        if (!STORE.whitelistedExtensions(extension)) {\n            revert Errors.GuardPolicy_UnauthorizedExtension(extension);\n        }\n    }\n\n    /**\n     * @dev Forwards a gnosis safe call to a hook contract for further processing.\n     *\n     * @param hook  Address of the hook contract.\n     * @param safe  Address of the rental wallet that originated the call.\n     * @param to    Address that the call is directed to.\n     * @param value Value of e"
    }
  ]
}