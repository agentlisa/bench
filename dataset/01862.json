{
  "Title": "Unused variables",
  "Content": "##### Description\nSeveral storage variables can be removed:\nhttps://github.com/cryptoalgebra/Algebra/blob/7290fad656bfa89db3743c52af631154f6a8a2d5/src/tokenomics/contracts/FarmingCenter.sol#L21\nhttps://github.com/cryptoalgebra/Algebra/blob/7290fad656bfa89db3743c52af631154f6a8a2d5/src/tokenomics/contracts/libraries/VirtualTickManagement.sol#L23\nhttps://github.com/cryptoalgebra/Algebra/blob/7290fad656bfa89db3743c52af631154f6a8a2d5/src/tokenomics/contracts/farmings/EternalVirtualPool.sol#L18.\n\n##### Recommendation\nWe recommend removing these variables from storage.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/tokenomics/contracts/FarmingCenter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.17;\n\nimport './interfaces/IFarmingCenter.sol';\n\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraPool.sol';\nimport '@cryptoalgebra/core/contracts/interfaces/IERC20Minimal.sol';\nimport '@cryptoalgebra/periphery/contracts/interfaces/IPositionFollower.sol';\nimport '@cryptoalgebra/periphery/contracts/interfaces/INonfungiblePositionManager.sol';\nimport '@cryptoalgebra/periphery/contracts/base/Multicall.sol';\n\nimport './libraries/IncentiveId.sol';\n\n/// @title Algebra main farming contract\n/// @dev Manages farmings and performs entry, exit and other actions.\ncontract FarmingCenter is IFarmingCenter, IPositionFollower, Multicall {\n  IAlgebraEternalFarming public immutable override eternalFarming;\n  INonfungiblePositionManager public immutable override nonfungiblePositionManager;\n\n  /// @dev saves addresses of virtual pools for pool\n  mapping(address => address) public override virtualPoolAddresses;\n\n  /// @dev deposits[tokenId] => incentiveId\n  mapping(uint256 => bytes32) public override deposits;\n  mapping(bytes32 => IncentiveKey) public incentiveKeys;\n\n  constructor(IAlgebraEternalFarming _eternalFarming, INonfungiblePositionManager _nonfungiblePositionManager) {\n    eternalFarming = _eternalFarming;\n    nonfungiblePositionManager = _nonfungiblePositionManager;\n  }\n\n  modifier isOwner(uint256 tokenId) {\n    require(nonfungiblePositionManager.ownerOf(tokenId) == msg.sender, 'not owner of token');\n    _;\n  }\n\n  /// @inheritdoc IFarmingCenter\n  function enterFarming(IncentiveKey memory key, uint256 tokenId) external override isOwner(tokenId) {\n    bytes32 incentiveId = IncentiveId.compute(key);\n    if (address(incentiveKeys[incentiveId].pool) == address(0)) incentiveKeys[incentiveId] = key;\n\n    require(deposits[tokenId] == bytes32(0), 'token already farmed');\n    deposits[tokenId] = incentiveId;\n    nonfungiblePositionManager.switchFarmingStatus(tokenId, true);\n\n    IAlgebraEternalFarming(eternalFarming).enterFarming(key, tokenId);\n  }\n\n  /// @inheritdoc IFarmingCenter\n  function exitFarming(IncentiveKey memory key, uint256 tokenId) external override isOwner(tokenId) {\n    _exitFarming(key, tokenId, msg.sender);\n  }\n\n  function _exitFarming(IncentiveKey memory key, uint256 tokenId, address tokenOwner) private {\n    require(deposits[tokenId] == IncentiveId.compute(key), 'invalid incentiveId');\n    deposits[tokenId] = bytes32(0);\n    nonfungiblePositionManager.switchFarmingStatus(tokenId, false);\n\n    IAlgebraEternalFarming(eternalFarming).exitFarming(key, tokenId, tokenOwner);\n  }\n\n  /// @inheritdoc IPositionFollower\n  function applyLiquidityDelta(uint256 tokenId, int256 liquidityDelta) external override {\n    liquidityDelta; // reserved for future versions\n    _updatePosition(tokenId);\n  }\n\n  // function for compatibility with older versions of NonfungiblePositionManager\n  function increaseLiquidity(uint256 tokenId, uint256 liquidityDelta) external {\n    liquidityDelta; // reserved for future versions\n    _updatePosition(tokenId);\n  }\n\n  // function for compatibility with older versions of NonfungiblePositionManager\n  function decreaseLiquidity(uint256 tokenId, uint256 liquidityDelta) external returns (bool success) {\n    liquidityDelta; // reserved for future versions\n    _updatePosition(tokenId);\n    return true;\n  }\n\n  function _updatePosition(uint256 tokenId) private {\n    require(msg.sender == address(nonfungiblePositionManager), 'only nonfungiblePosManager');\n\n    bytes32 _eternalIncentiveId = deposits[tokenId];\n    if (_eternalIncentiveId != bytes32(0)) {\n      address tokenOwner = nonfungiblePositionManager.ownerOf(tokenId);\n      (, , , , , , uint128 liquidity, , , , ) = nonfungiblePositionManager.positions(tokenId);\n\n      IncentiveKey memory key = incentiveKeys[_eternalIncentiveId];\n\n      if (liquidity == 0) {\n        _exitFarming(key, tokenId, tokenOwner);\n      } else {\n        IAlgebraEternalFarming(eternalFarming).exitFarming(key, tokenId, tokenOwner);\n        IAlgebraEternalFarming(eternalFarming).enterFarming(key, tokenId); // enter with new liquidity value\n      }\n    }\n  }\n\n  /// @inheritdoc IPositionFollower\n  function burnPosition(uint256 tokenId) external override returns (bool success) {\n    require(msg.sender == address(nonfungiblePositionManager), 'only nonfungiblePosManager');\n    bytes32 _eternalIncentiveId = deposits[tokenId];\n\n    if (_eternalIncentiveId != bytes32(0)) {\n      IncentiveKey memory key = incentiveKeys[_eternalIncentiveId];\n      _exitFarming(key, tokenId, nonfungiblePositionManager.ownerOf(tokenId));\n    }\n    return true;\n  }\n\n  /// @inheritdoc IFarmingCenter\n  function collectRewards(IncentiveKey memory key, uint256 tokenId) external override isOwner(tokenId) returns (uint256 reward, uint256 bonusReward) {\n    (reward, bonusReward) = eternalFarming.collectRewards(key, tokenId, msg.sender);\n  }\n\n  /// @inheritdoc IFarmingCenter\n  function claimReward(IERC20Minimal rewardToken, address to, uint256 amountRequested) external override returns (uint256 reward) {\n    unchecked {\n      if (amountRequested != 0) reward += eternalFarming.claimRewardFrom(rewardToken, msg.sender, to, amountRequested);\n    }\n  }\n\n  /// @inheritdoc IFarmingCenter\n  function connectVirtualPool(IAlgebraPool pool, address newVirtualPool) external override {\n    require(msg.sender == address(eternalFarming), 'only farming can call this');\n    pool.setIncentive(newVirtualPool);\n    virtualPoolAddresses[address(pool)] = newVirtualPool;\n  }\n}"
    },
    {
      "filename": "src/tokenomics/contracts/libraries/VirtualTickManagement.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.17;\n\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraPoolErrors.sol';\n\nimport '@cryptoalgebra/core/contracts/libraries/TickMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/LiquidityMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/Constants.sol';\n\n/// @title VirtualTickManagement\n/// @notice Contains functions for managing tick processes and relevant calculations\nlibrary VirtualTickManagement {\n  // info stored for each initialized individual tick\n  struct Tick {\n    uint128 liquidityTotal; // the total position liquidity that references this tick\n    int128 liquidityDelta; // amount of net liquidity added (subtracted) when tick is crossed left-right (right-left),\n    // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // only has relative meaning, not absolute â€” the value depends on when the tick is initialized\n    uint256 outerFeeGrowth0Token;\n    uint256 outerFeeGrowth1Token;\n    int24 prevTick;\n    int24 nextTick;\n    uint160 outerSecondsPerLiquidity; // the seconds per unit of liquidity on the _other_ side of current tick, (relative meaning)\n  }\n\n  /// @notice Retrieves fee growth data\n  /// @param self The mapping containing all tick information for initialized ticks\n  /// @param bottomTick The lower tick boundary of the position\n  /// @param topTick The upper tick boundary of the position\n  /// @param currentTick The current tick\n  /// @param totalFeeGrowth0Token The all-time global fee growth, per unit of liquidity, in token0\n  /// @param totalFeeGrowth1Token The all-time global fee growth, per unit of liquidity, in token1\n  /// @return innerFeeGrowth0Token The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n  /// @return innerFeeGrowth1Token The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n  function getInnerFeeGrowth(\n    mapping(int24 => Tick) storage self,\n    int24 bottomTick,\n    int24 topTick,\n    int24 currentTick,\n    uint256 totalFeeGrowth0Token,\n    uint256 totalFeeGrowth1Token\n  ) internal view returns (uint256 innerFeeGrowth0Token, uint256 innerFeeGrowth1Token) {\n    Tick storage lower = self[bottomTick];\n    Tick storage upper = self[topTick];\n\n    unchecked {\n      if (currentTick < topTick) {\n        if (currentTick >= bottomTick) {\n          innerFeeGrowth0Token = totalFeeGrowth0Token - lower.outerFeeGrowth0Token;\n          innerFeeGrowth1Token = totalFeeGrowth1Token - lower.outerFeeGrowth1Token;\n        } else {\n          innerFeeGrowth0Token = lower.outerFeeGrowth0Token;\n          innerFeeGrowth1Token = lower.outerFeeGrowth1Token;\n        }\n        innerFeeGrowth0Token -= upper.outerFeeGrowth0Token;\n        innerFeeGrowth1Token -= upper.outerFeeGrowth1Token;\n      } else {\n        innerFeeGrowth0Token = upper.outerFeeGrowth0Token - lower.outerFeeGrowth0Token;\n        innerFeeGrowth1Token = upper.outerFeeGrowth1Token - lower.outerFeeGrowth1Token;\n      }\n    }\n  }\n\n  /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa\n  /// @param self The mapping containing all tick information for initialized ticks\n  /// @param tick The tick that will be updated\n  /// @param currentTick The current tick\n  /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)\n  /// @param totalFeeGrowth0Token The all-time global fee growth, per unit of liquidity, in token0\n  /// @param totalFeeGrowth1Token The all-time global fee growth, per unit of liquidity, in token1\n  /// @param secondsPerLiquidityCumulative The all-time seconds per max(1, liquidity) of the pool\n  /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick\n  /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\n  function update(\n    mapping(int24 => Tick) storage self,\n    int24 tick,\n    int24 currentTick,\n    int128 liquidityDelta,\n    uint256 totalFeeGrowth0Token,\n    uint256 totalFeeGrowth1Token,\n    uint160 secondsPerLiquidityCumulative,\n    bool upper\n  ) internal returns (bool flipped) {\n    Tick storage data = self[tick];\n\n    int128 liquidityDeltaBefore = data.liquidityDelta;\n    uint128 liquidityTotalBefore = data.liquidityTotal;\n\n    uint128 liquidityTotalAfter = LiquidityMath.addDelta(liquidityTotalBefore, liquidityDelta);\n    if (liquidityTotalAfter > Constants.MAX_LIQUIDITY_PER_TICK) revert IAlgebraPoolErrors.liquidityOverflow();\n\n    // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)\n    data.liquidityDelta = upper ? int128(int256(liquidityDeltaBefore) - liquidityDelta) : int128(int256(liquidityDeltaBefore) + liquidityDelta);\n\n    data.liquidityTotal = liquidityTotalAfter;\n\n    flipped = (liquidityTotalAfter == 0);\n    if (liquidityTotalBefore == 0) {\n      flipped = !flipped;\n      // by convention, we assume that all growth before a tick was initialized happened _below_ the tick\n      if (tick <= currentTick) {\n        data.outerFeeGrowth0Token = totalFeeGrowth0Token;\n        data.outerFeeGrowth1Token = totalFeeGrowth1Token;\n        data.outerSecondsPerLiquidity = secondsPerLiquidityCumulative;\n      }\n    }\n  }\n\n  /// @notice Transitions to next tick as needed by price movement\n  /// @param self The mapping containing all tick information for initialized ticks\n  /// @param tick The destination tick of the transition\n  /// @param totalFeeGrowth0Token The all-time global fee growth, per unit of liquidity, in token0\n  /// @param totalFeeGrowth1Token The all-time global fee growth, per unit of liquidity, in token1\n  /// @param secondsPerLiquidityCumulative The current seconds per liquidity\n  /// @return liquidityDelta The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)\n  function cross(\n    mapping(int24 => Tick) storage self,\n    int24 tick,\n    uint256 totalFeeGrowth0Token,\n    uint256 totalFeeGrowth1Token,\n    uint160 secondsPerLiquidityCumulative\n  ) internal returns (int128 liquidityDelta) {\n    Tick storage data = self[tick];\n\n    unchecked {\n      data.outerSecondsPerLiquidity = secondsPerLiquidityCumulative - data.outerSecondsPerLiquidity;\n\n      data.outerFeeGrowth1Token = totalFeeGrowth1Token - data.outerFeeGrowth1Token;\n      data.outerFeeGrowth0Token = totalFeeGrowth0Token - data.outerFeeGrowth0Token;\n    }\n    return data.liquidityDelta;\n  }\n\n  /// @notice Used for initial setup if ticks list\n  /// @param self The mapping containing all tick information for initialized ticks\n  function initTickState(mapping(int24 => Tick) storage self) internal {\n    (self[TickMath.MIN_TICK].prevTick, self[TickMath.MIN_TICK].nextTick) = (TickMath.MIN_TICK, TickMath.MAX_TICK);\n    (self[TickMath.MAX_TICK].prevTick, self[TickMath.MAX_TICK].nextTick) = (TickMath.MIN_TICK, TickMath.MAX_TICK);\n  }\n\n  /// @notice Removes tick from linked list\n  /// @param self The mapping containing all tick information for initialized ticks\n  /// @param tick The tick that will be removed\n  /// @return prevTick\n  function removeTick(mapping(int24 => Tick) storage self, int24 tick) internal returns (int24) {\n    (int24 prevTick, int24 nextTick) = (self[tick].prevTick, self[tick].nextTick);\n    delete self[tick];\n\n    if (tick == TickMath.MIN_TICK || tick == TickMath.MAX_TICK) {\n      // MIN_TICK and MAX_TICK cannot be removed from tick list\n      (self[tick].prevTick, self[tick].nextTick) = (prevTick, nextTick);\n      return prevTick;\n    } else {\n      if (prevTick == nextTick) revert IAlgebraPoolErrors.tickIsNotInitialized();\n      self[prevTick].nextTick = nextTick;\n      self[nextTick].prevTick = prevTick;\n      return prevTick;\n    }\n  }\n\n  /// @notice Adds tick to linked list\n  /// @param self The mapping containing all tick information for initialized ticks\n  /// @param tick The tick that will be inserted\n  /// @param prevTick The previous active tick\n  /// @param nextTick The next active tick\n  function insertTick(mapping(int24 => Tick) storage self, int24 tick, int24 prevTick, int24 nextTick) internal {\n    if (tick == TickMath.MIN_TICK || tick == TickMath.MAX_TICK) return;\n    if (prevTick >= tick || nextTick <= tick) revert IAlgebraPoolErrors.tickInvalidLinks();\n    (self[tick].prevTick, self[tick].nextTick) = (prevTick, nextTick);\n\n    self[prevTick].nextTick = tick;\n    self[nextTick].prevTick = tick;\n  }\n}"
    },
    {
      "filename": "src/tokenomics/contracts/farmings/EternalVirtualPool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.17;\n\nimport '@cryptoalgebra/core/contracts/libraries/FullMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/Constants.sol';\nimport '@cryptoalgebra/core/contracts/libraries/TickMath.sol';\nimport '@cryptoalgebra/core/contracts/libraries/LiquidityMath.sol';\n\nimport '../libraries/VirtualTickManagement.sol';\n\nimport '../base/VirtualTickStructure.sol';\n\n/// @title Algebra eternal virtual pool\n/// @notice used to track active liquidity in farming and distribute rewards\ncontract EternalVirtualPool is VirtualTickStructure {\n  using VirtualTickManagement for mapping(int24 => VirtualTickManagement.Tick);\n\n  address public immutable farmingCenterAddress;\n  address public immutable farmingAddress;\n  address public immutable pool;\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  uint128 public override currentLiquidity;\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  int24 public override globalTick;\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  uint32 public override prevTimestamp;\n\n  int24 internal globalPrevInitializedTick;\n\n  uint128 internal rewardRate0;\n  uint128 internal rewardRate1;\n\n  uint128 internal rewardReserve0;\n  uint128 internal rewardReserve1;\n\n  uint256 public totalRewardGrowth0 = 1;\n  uint256 public totalRewardGrowth1 = 1;\n\n  modifier onlyFromFarming() {\n    _checkIsFromFarming();\n    _;\n  }\n\n  constructor(address _farmingCenterAddress, address _farmingAddress, address _pool) {\n    globalPrevInitializedTick = TickMath.MIN_TICK;\n    farmingCenterAddress = _farmingCenterAddress;\n    farmingAddress = _farmingAddress;\n    pool = _pool;\n    prevTimestamp = uint32(block.timestamp);\n  }\n\n  // @inheritdoc IAlgebraEternalVirtualPool\n  function rewardReserves() external view override returns (uint128 reserve0, uint128 reserve1) {\n    return (rewardReserve0, rewardReserve1);\n  }\n\n  // @inheritdoc IAlgebraEternalVirtualPool\n  function rewardRates() external view override returns (uint128 rate0, uint128 rate1) {\n    return (rewardRate0, rewardRate1);\n  }\n\n  // @inheritdoc IAlgebraEternalVirtualPool\n  function getInnerRewardsGrowth(\n    int24 bottomTick,\n    int24 topTick\n  ) external view override returns (uint256 rewardGrowthInside0, uint256 rewardGrowthInside1) {\n    unchecked {\n      uint32 timeDelta = uint32(block.timestamp) - prevTimestamp;\n      (uint256 _totalRewardGrowth0, uint256 _totalRewardGrowth1) = (totalRewardGrowth0, totalRewardGrowth1);\n\n      if (timeDelta > 0) {\n        // update rewards\n        uint128 _currentLiquidity = currentLiquidity;\n        if (_currentLiquidity > 0) {\n          (uint256 reward0, uint256 reward1) = (rewardRate0 * timeDelta, rewardRate1 * timeDelta);\n          (uint256 _rewardReserve0, uint256 _rewardReserve1) = (rewardReserve0, rewardReserve1);\n\n          if (reward0 > _rewardReserve0) reward0 = _rewardReserve0;\n          if (reward1 > _rewardReserve1) reward1 = _rewardReserve1;\n\n          if (reward0 > 0) _totalRewardGrowth0 += FullMath.mulDiv(reward0, Constants.Q128, _currentLiquidity);\n          if (reward1 > 0) _totalRewardGrowth1 += FullMath.mulDiv(reward1, Constants.Q128, _currentLiquidity);\n        }\n      }\n\n      return ticks.getInnerFeeGrowth(bottomTick, topTick, globalTick, _totalRewardGrowth0, _totalRewardGrowth1);\n    }\n  }\n\n  // @inheritdoc IAlgebraEternalVirtualPool\n  function addRewards(uint128 token0Amount, uint128 token1Amount) external override onlyFromFarming {\n    _applyRewardsDelta(true, token0Amount, token1Amount);\n  }\n\n  // @inheritdoc IAlgebraEternalVirtualPool\n  function decreaseRewards(uint128 token0Amount, uint128 token1Amount) external override onlyFromFarming {\n    _applyRewardsDelta(false, token0Amount, token1Amount);\n  }\n\n  /// @inheritdoc IAlgebraVirtualPool\n  function crossTo(int24 targetTick, bool zeroToOne) external override returns (bool) {\n    if (msg.sender != farmingCenterAddress && msg.sender != pool) revert onlyPool();\n    _distributeRewards(uint32(block.timestamp));\n\n    int24 previousTick = globalPrevInitializedTick;\n    uint128 _currentLiquidity = currentLiquidity;\n    int24 _globalTick = globalTick;\n\n    (uint256 rewardGrowth0, uint256 rewardGrowth1) = (totalRewardGrowth0, totalRewardGrowth1);\n    // The set of active ticks in the virtual pool must be a subset of the active ticks in the real pool\n    // so this loop will cross no more ticks than the real pool\n    if (zeroToOne) {\n      while (_globalTick != TickMath.MIN_TICK) {\n        if (targetTick >= previousTick) break;\n        unchecked {\n          _currentLiquidity = LiquidityMath.addDelta(_currentLiquidity, -ticks.cross(previousTick, rewardGrowth0, rewardGrowth1, 0));\n          _globalTick = previousTick - 1; // safe since tick index range is narrower than the data type\n          previousTick = ticks[previousTick].prevTick;\n          if (_globalTick < TickMath.MIN_TICK) _globalTick = TickMath.MIN_TICK;\n        }\n      }\n    } else {\n      while (_globalTick != TickMath.MAX_TICK - 1) {\n        int24 nextTick = ticks[previousTick].nextTick;\n        if (targetTick < nextTick) break;\n\n        _currentLiquidity = LiquidityMath.addDelta(_currentLiquidity, ticks.cross(nextTick, rewardGrowth0, rewardGrowth1, 0));\n        (_globalTick, previousTick) = (nextTick, nextTick);\n      }\n    }\n\n    globalTick = targetTick;\n    currentLiquidity = _currentLiquidity;\n    globalPrevInitializedTick = previousTick;\n    return true;\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function distributeRewards(uint32 currentTimestamp) external override onlyFromFarming {\n    _distributeRewards(currentTimestamp);\n  }\n\n  /// @inheritdoc IAlgebraEternalVirtualPool\n  function applyLiquidityDeltaToPosition(\n    uint32 currentTimestamp,\n    int24 bottomTick,\n    int24 topTick,\n    int128 liquidityDelta,\n    int24 currentTick\n  ) external override onlyFromFarming {\n    globalTick = currentTick;\n\n    if (currentTimestamp > prevTimestamp) {\n      _distributeRewards(currentTimestamp);\n    }\n\n    if (liquidityDelta != 0) {\n      // if we need to update the ticks, do it\n      bool flippedBottom;\n      bool flippedTop;\n\n      if (_updateTick(bottomTick, currentTick, liquidityDelta, false)) {\n        flippedBottom = true;\n      }\n\n      if (_updateTick(topTick, currentTick, liquidityDelta, true)) {\n        flippedTop = true;\n      }\n\n      if (currentTick >= bottomTick && currentTick < topTick) {\n        currentLiquidity = LiquidityMath.addDelta(currentLiquidity, liquidityDelta);\n      }\n\n      if (flippedBottom || flippedTop) {\n        int24 previousTick = globalPrevInitializedTick;\n        if (flippedBottom) {\n          previousTick = _insertOrRemoveTick(bottomTick, currentTick, previousTick, liquidityDelta < 0);\n        }\n        if (flippedTop) {\n          previousTick = _insertOrRemoveTick(topTick, currentTick, previousTick, liquidityDelta < 0);\n        }\n        globalPrevInitializedTick = previousTick;\n      }\n    }\n  }\n\n  // @inheritdoc IAlgebraEternalVirtualPool\n  function setRates(uint128 rate0, uint128 rate1) external override onlyFromFarming {\n    _distributeRewards(uint32(block.timestamp));\n    (rewardRate0, rewardRate1) = (rate0, rate1);\n  }\n\n  function _checkIsFromFarming() internal view {\n    if (msg.sender != farmingAddress) revert onlyFarming();\n  }\n\n  function _applyRewardsDelta(bool add, uint128 token0Delta, uint128 token1Delta) private {\n    _distributeRewards(uint32(block.timestamp));\n    if (token0Delta | token1Delta != 0) {\n      (uint128 _rewardReserve0, uint128 _rewardReserve1) = (rewardReserve0, rewardReserve1);\n      _rewardReserve0 = add ? _rewardReserve0 + token0Delta : _rewardReserve0 - token0Delta;\n      _rewardReserve1 = add ? _rewardReserve1 + token1Delta : _rewardReserve1 - token1Delta;\n      (rewardReserve0, rewardReserve1) = (_rewardReserve0, _rewardReserve1);\n    }\n  }\n\n  function _distributeRewards(uint32 currentTimestamp) internal {\n    unchecked {\n      uint256 timeDelta = currentTimestamp - prevTimestamp; // safe until timedelta > 136 years\n      if (timeDelta == 0) return; // only once per block\n\n      uint256 _currentLiquidity = currentLiquidity; // currentLiquidity is uint128\n      if (_currentLiquidity > 0) {\n        (uint256 reward0, uint256 reward1) = (rewardRate0 * timeDelta, rewardRate1 * timeDelta);\n        (uint128 _rewardReserve0, uint128 _rewardReserve1) = (rewardReserve0, rewardReserve1);\n\n        if (reward0 > _rewardReserve0) reward0 = _rewardReserve0;\n        if (reward1 > _rewardReserve1) reward1 = _rewardReserve1;\n\n        if (reward0 | reward1 != 0) {\n          _rewardReserve0 = uint128(_rewardReserve0 - reward0);\n          _rewardReserve1 = uint128(_rewardReserve1 - reward1);\n\n          if (reward0 > 0) totalRewardGrowth0 += FullMath.mulDiv(reward0, Constants.Q128, _currentLiquidity);\n          if (reward1 > 0) totalRewardGrowth1 += FullMath.mulDiv(reward1, Constants.Q128, _currentLiquidity);\n\n          (rewardReserve0, rewardReserve1) = (_rewardReserve0, _rewardReserve1);\n        }\n      }\n    }\n\n    prevTimestamp = currentTimestamp;\n    return;\n  }\n\n  function _updateTick(int24 tick, int24 currentTick, int128 liquidityDelta, bool isTopTick) internal returns (bool updated) {\n    return ticks.update(tick, currentTick, liquidityDelta, totalRewardGrowth0, totalRewardGrowth1, 0, isTopTick);\n  }\n}"
    }
  ]
}