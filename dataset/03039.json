{
  "Title": "M-4: Accounts with ETH loans can not be liquidated if LEther's underlying is set to `address(0)`",
  "Content": "# Issue M-4: Accounts with ETH loans can not be liquidated if LEther's underlying is set to `address(0)` \nSource: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/034-M \n## Found by \nLambda, WATCHPUG, hansfriese, rbserver, HonorLt, 0xc0ffEE\n\n## Summary\n\nSetting `address(0)` as LEther's `underlying` is allowed, and the logic in `AccountManager#settle()` and `RiskEngine#_valueInWei()` handles `address(0)` specially, which implies that `address(0)` can be an asset.\n\nHowever, if LEther's underlying is set to `address(0)`, the accounts with ETH loans will become unable to be liquidated.\n\n## Vulnerability Detail\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/core/AccountManager.sol#L318-L326\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/core/RiskEngine.sol#L178-L188\n\nGiven that at `AccountManager.sol#L100` in `settle()` and `RiskEngine.sol#L186` in `_valueInWei()`, they both handled the case that the `asset == address(0)`, and in `Registry.sol#setLToken()`, `underlying == address(0)` is allowed:\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/core/Registry.sol#L95-L105\n\nWe assume that `address(0)` can be set as the `underlying` of `LEther`.\n\nIn that case, when the user borrows native tokens, `address(0)` will be added to the user's assets and borrows list.\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/core/AccountManager.sol#L203-L217\n\n```solidity\nfunction borrow(address account, address token, uint amt)\n    external\n    whenNotPaused\n    onlyOwner(account)\n{\n    if (registry.LTokenFor(token) == address(0))\n        revert Errors.LTokenUnavailable();\n    if (!riskEngine.isBorrowAllowed(account, token, amt))\n        revert Errors.RiskThresholdBreached();\n    if (IAccount(account).hasAsset(token) == false)\n        IAccount(account).addAsset(token);\n    if (ILToken(registry.LTokenFor(token)).lendTo(account, amt))\n        IAccount(account).addBorrow(token);\n    emit Borrow(account, msg.sender, token, amt);\n}\n```\n\nThis will later prevent the user from being liquidated because in `riskEngine.isAccountHealthy()`, it calls `_getBalance()` in the for loop of all the assets, which assumes all the assets complies with `IERC20`. Thus, the transaction will revert at L157 when calling `IERC20(address(0)).balanceOf(account)`.\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/core/AccountManager.sol#L250-L255\n\n```solidity\nfunction liquidate(address account) external {\n    if (riskEngine.isAccountHealthy(account))\n        revert Errors.AccountNotLiquidatable();\n    _liquidate(account);\n    emit AccountLiquidated(account, registry.ownerFor(account));\n}\n```\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/src/core/RiskEngine.sol#L150-L161\n\n```solidity\nfunction _getBalance(address account) internal view returns (uint) {\n    address[] memory assets = IAccount(account).getAssets();\n    uint assetsLen = assets.length;\n    uint totalBalance;\n    for(uint i; i < assetsLen; ++i) {\n        totalBalance += _valueInWei(\n            assets[i],\n            IERC20(assets[i]).balanceOf(account)\n        );\n    }\n    return totalBalance + account.balance;\n}\n```\n\n## Impact\n\nWe noticed that in the deployment documentation, LEther is set to init with WETH as the `underlying`. Therefore, this should not be an issue if the system is being deployed correctly.\n\nhttps://github.com/sentimentxyz/protocol/blob/4e45871e4540df0f189f6c89deb8d34f24930120/protocol/deployments/ArbiDeploymentFlow.md#L47-L53\n\n```markdown=47\n1. ETH\n   1. Deploy LEther implementation\n   2. Deploy Proxy(LEther)\n   3. call init(WETH), \"LEther\", \"LEth\", IRegistry, reserveFactor)\n   4. call Registry.setLToken(WETH, Proxy)\n   5. call accountManager.toggleCollateralStatus(token)\n   6. call Proxy.initDep()\n```\n\nBut considering that setting `address(0)` as LEther's `underlying` is still plausible and the potential damage to the whole protocol is high (all the accounts with ETH loans can not be liquidated), we believe that this should be a medium severity issue.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n1. Consider removing the misleading logic in `AccountManager#settle()` and `RiskEngine#_valueInWei()` that handles `address(0)` as an asset;\n2. Consider disallowing adding `address(0)` as `underlying` in `setLToken()`.\n\n## Sentiment Team\nFixed as recommended. PR [here](https://github.com/sentimentxyz/protocol/pull/228).\n\n## Lead Senior Watson\nConfirmed fix. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/1",
  "Code": [
    {
      "filename": "src/core/AccountManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Helpers} from \"../utils/Helpers.sol\";\nimport {Pausable} from \"../utils/Pausable.sol\";\nimport {IERC20} from \"../interface/tokens/IERC20.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\nimport {IAccount} from \"../interface/core/IAccount.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRiskEngine} from \"../interface/core/IRiskEngine.sol\";\nimport {IAccountFactory} from \"../interface/core/IAccountFactory.sol\";\nimport {IAccountManager} from \"../interface/core/IAccountManager.sol\";\nimport {IControllerFacade} from \"controller/core/IControllerFacade.sol\";\n\n/**\n    @title Account Manager\n    @notice Sentiment Account Manager,\n        All account interactions go via the account manager\n*/\ncontract AccountManager is Pausable, IAccountManager {\n    using Helpers for address;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE_VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice Registry\n    IRegistry public registry;\n\n    /// @notice Risk Engine\n    IRiskEngine public riskEngine;\n\n    /// @notice Controller Facade\n    IControllerFacade public controller;\n\n    /// @notice Account Factory\n    IAccountFactory public accountFactory;\n\n    /// @notice List of inactive accounts per user\n    mapping(address => address[]) public inactiveAccountsOf;\n\n    /// @notice Mapping of collateral enabled tokens\n    mapping(address => bool) public isCollateralAllowed;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier onlyOwner(address account) {\n        if (registry.ownerFor(account) != msg.sender)\n            revert Errors.AccountOwnerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Initializes contract\n        @dev Can only be invoked once\n        @param _registry Address of Registry\n    */\n    function init(IRegistry _registry) external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n        initialized = true;\n        initPausable(msg.sender);\n        registry = _registry;\n    }\n\n    /// @notice Initializes external dependencies\n    function initDep() external adminOnly {\n        riskEngine = IRiskEngine(registry.getAddress('RISK_ENGINE'));\n        controller = IControllerFacade(registry.getAddress('CONTROLLER'));\n        accountFactory =\n            IAccountFactory(registry.getAddress('ACCOUNT_FACTORY'));\n    }\n\n    /**\n        @notice Opens a new account for a user\n        @dev Creates a new account if there are no inactive accounts otherwise\n            reuses an already inactive account\n            Emits AccountAssigned(account, owner) event\n        @param owner Owner of the newly opened account\n    */\n    function openAccount(address owner) external whenNotPaused {\n        if (owner == address(0)) revert Errors.ZeroAddress();\n        address account;\n        uint length = inactiveAccountsOf[owner].length;\n        if (length == 0) {\n            account = accountFactory.create(address(this));\n            IAccount(account).init(address(this));\n            registry.addAccount(account, owner);\n        } else {\n            account = inactiveAccountsOf[owner][length - 1];\n            inactiveAccountsOf[owner].pop();\n            registry.updateAccount(account, owner);\n        }\n        IAccount(account).activate();\n        emit AccountAssigned(account, owner);\n    }\n\n    /**\n        @notice Closes a specified account for a user\n        @dev Account can only be closed when the account has no debt\n            Emits AccountClosed(account, owner) event\n        @param _account Address of account to be closed\n    */\n    function closeAccount(address _account) public onlyOwner(_account) {\n        IAccount account = IAccount(_account);\n        if (account.activationBlock() == block.number)\n            revert Errors.AccountDeactivationFailure();\n        if (!account.hasNoDebt()) revert Errors.OutstandingDebt();\n        account.deactivate();\n        registry.closeAccount(_account);\n        inactiveAccountsOf[msg.sender].push(_account);\n        account.sweepTo(msg.sender);\n        emit AccountClosed(_account, msg.sender);\n    }\n\n    /**\n        @notice Transfers Eth from owner to account\n        @param account Address of account\n    */\n    function depositEth(address account)\n        external\n        payable\n        whenNotPaused\n        onlyOwner(account)\n    {\n        account.safeTransferEth(msg.value);\n    }\n\n    /**\n        @notice Transfers Eth from the account to owner\n        @dev Eth can only be withdrawn if the account remains healthy\n            after withdrawal\n        @param account Address of account\n        @param amt Amount of Eth to withdraw\n    */\n    function withdrawEth(address account, uint amt)\n        external\n        onlyOwner(account)\n    {\n        if(!riskEngine.isWithdrawAllowed(account, address(0), amt))\n            revert Errors.RiskThresholdBreached();\n        account.withdrawEth(msg.sender, amt);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the owner\n            to the account\n        @dev Token must be accepted as collateral by the protocol\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to deposit\n    */\n    function deposit(address account, address token, uint amt)\n        external\n        whenNotPaused\n        onlyOwner(account)\n    {\n        if (!isCollateralAllowed[token])\n            revert Errors.CollateralTypeRestricted();\n        if (IAccount(account).hasAsset(token) == false)\n            IAccount(account).addAsset(token);\n        token.safeTransferFrom(msg.sender, account, amt);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the account\n            to the owner of the account\n        @dev Amount of token can only be withdrawn if the account remains healthy\n            after withdrawal\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to withdraw\n    */\n    function withdraw(address account, address token, uint amt)\n        external\n        onlyOwner(account)\n    {\n        if (!riskEngine.isWithdrawAllowed(account, token, amt))\n            revert Errors.RiskThresholdBreached();\n        account.withdraw(msg.sender, token, amt);\n        if (token.balanceOf(account) == 0)\n            IAccount(account).removeAsset(token);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the LP to the account\n        @dev Specified token must have a LP\n            Account must remain healthy after the borrow, otherwise tx is reverted\n            Emits Borrow(account, msg.sender, token, amount) event\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to borrow\n    */\n    function borrow(address account, address token, uint amt)\n        external\n        whenNotPaused\n        onlyOwner(account)\n    {\n        if (registry.LTokenFor(token) == address(0))\n            revert Errors.LTokenUnavailable();\n        if (!riskEngine.isBorrowAllowed(account, token, amt))\n            revert Errors.RiskThresholdBreached();\n        if (IAccount(account).hasAsset(token) == false)\n            IAccount(account).addAsset(token);\n        if (ILToken(registry.LTokenFor(token)).lendTo(account, amt))\n            IAccount(account).addBorrow(token);\n        emit Borrow(account, msg.sender, token, amt);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the account to the LP\n        @dev Specified token must have a LP\n            Emits Repay(account, msg.sender, token, amount) event\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to borrow\n    */\n    function repay(address account, address token, uint amt)\n        public\n        onlyOwner(account)\n    {\n        ILToken LToken = ILToken(registry.LTokenFor(token));\n        if (address(LToken) == address(0))\n            revert Errors.LTokenUnavailable();\n        LToken.updateState();\n        if (amt == type(uint256).max) amt = LToken.getBorrowBalance(account);\n        account.withdraw(address(LToken), token, amt);\n        if (LToken.collectFrom(account, amt))\n            IAccount(account).removeBorrow(token);\n        if (IERC20(token).balanceOf(account) == 0)\n            IAccount(account).removeAsset(token);\n        emit Repay(account, msg.sender, token, amt);\n    }\n\n    /**\n        @notice Liquidates an account\n        @dev Account can only be liquidated when it's unhealthy\n            Emits AccountLiquidated(account, owner) event\n        @param account Address of account\n    */\n    function liquidate(address account) external {\n        if (riskEngine.isAccountHealthy(account))\n            revert Errors.AccountNotLiquidatable();\n        _liquidate(account);\n        emit AccountLiquidated(account, registry.ownerFor(account));\n    }\n\n    /**\n        @notice Gives a spender approval to spend a given amount of token from\n            the account\n        @dev Spender must have a controller in controller facade\n        @param account Address of account\n        @param token Address of token\n        @param spender Address of spender\n        @param amt Amount of token\n    */\n    function approve(\n        address account,\n        address token,\n        address spender,\n        uint amt\n    )\n        external\n        onlyOwner(account)\n    {\n        if(address(controller.controllerFor(spender)) == address(0))\n            revert Errors.FunctionCallRestricted();\n        account.safeApprove(token, spender, amt);\n    }\n\n    /**\n        @notice A general function that allows the owner to perform specific interactions\n            with external protocols for their account\n        @dev Target must have a controller in controller facade\n        @param account Address of account\n        @param target Address of contract to transact with\n        @param amt Amount of Eth to send to the target contract\n        @param data Encoded sig + params of the function to transact with in the\n            target contract\n    */\n    function exec(\n        address account,\n        address target,\n        uint amt,\n        bytes calldata data\n    )\n        external\n        onlyOwner(account)\n    {\n        bool isAllowed;\n        address[] memory tokensIn;\n        address[] memory tokensOut;\n        (isAllowed, tokensIn, tokensOut) =\n            controller.canCall(target, (amt > 0), data);\n        if (!isAllowed) revert Errors.FunctionCallRestricted();\n        _updateTokensIn(account, tokensIn);\n        (bool success,) = IAccount(account).exec(target, amt, data);\n        if (!success)\n            revert Errors.AccountInteractionFailure(account, target, amt, data);\n        _updateTokensOut(account, tokensOut);\n        if (!riskEngine.isAccountHealthy(account))\n            revert Errors.RiskThresholdBreached();\n    }\n\n    /**\n        @notice Settles an account by repaying all the loans\n        @param account Address of account\n    */\n    function settle(address account) external onlyOwner(account) {\n        address[] memory borrows = IAccount(account).getBorrows();\n        for (uint i; i < borrows.length; i++) {\n            uint balance;\n            if (borrows[i] == address(0)) balance = account.balance;\n            else balance = borrows[i].balanceOf(account);\n            if ( balance > 0 ) repay(account, borrows[i], type(uint).max);\n        }\n    }\n\n    /**\n        @notice Fetches inactive accounts of a user\n        @param user Address of user\n        @return address[] List of inactive accounts\n    */\n    function getInactiveAccountsOf(\n        address user\n    )\n        external\n        view\n        returns (address[] memory)\n    {\n        return inactiveAccountsOf[user];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             Internal Functions                             */\n    /* -------------------------------------------------------------------------- */\n\n    function _updateTokensIn(address account, address[] memory tokensIn)\n        internal\n    {\n        uint tokensInLen = tokensIn.length;\n        for(uint i; i < tokensInLen; ++i) {\n            if (IAccount(account).hasAsset(tokensIn[i]) == false)\n                IAccount(account).addAsset(tokensIn[i]);\n        }\n    }\n\n    function _updateTokensOut(address account, address[] memory tokensOut)\n        internal\n    {\n        uint tokensOutLen = tokensOut.length;\n        for(uint i; i < tokensOutLen; ++i) {\n            if (tokensOut[i].balanceOf(account) == 0)\n                IAccount(account).removeAsset(tokensOut[i]);\n        }\n    }\n\n    function _liquidate(address _account) internal {\n        IAccount account = IAccount(_account);\n        address[] memory accountBorrows = account.getBorrows();\n        uint borrowLen = accountBorrows.length;\n\n        ILToken LToken;\n        uint amt;\n\n        for(uint i; i < borrowLen; ++i) {\n            address token = accountBorrows[i];\n            LToken = ILToken(registry.LTokenFor(token));\n            LToken.updateState();\n            amt = LToken.getBorrowBalance(_account);\n            token.safeTransferFrom(msg.sender, address(LToken), amt);\n            LToken.collectFrom(_account, amt);\n            account.removeBorrow(token);\n        }\n        account.sweepTo(msg.sender);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               ADMIN FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Toggle collateral status of a token\n        @param token Address of token\n    */\n    function toggleCollateralStatus(address token) external adminOnly {\n        isCollateralAllowed[token] = !isCollateralAllowed[token];\n    }\n}"
    },
    {
      "filename": "src/core/RiskEngine.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Ownable} from \"../utils/Ownable.sol\";\nimport {IOracle} from \"oracle/core/IOracle.sol\";\nimport {IERC20} from \"../interface/tokens/IERC20.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\nimport {IAccount} from \"../interface/core/IAccount.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRiskEngine} from \"../interface/core/IRiskEngine.sol\";\nimport {IAccountManager} from \"../interface/core/IAccountManager.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\n/**\n    @title Risk Engine\n    @notice Risk engine is a sentiment utility contract used by the protocol to\n    analyze the health factor of a given account.\n*/\ncontract RiskEngine is Ownable, IRiskEngine {\n    using FixedPointMathLib for uint;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Registry\n    IRegistry public immutable registry;\n\n    /// @notice Oracle Facade\n    IOracle public oracle;\n\n    /// @notice Account Manager\n    IAccountManager public accountManager;\n\n    /// @notice Balance:Borrow, Default = 1.2\n    uint public constant balanceToBorrowThreshold = 1.2e18;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract constructor\n        @param _registry Address of registry contract\n    */\n    constructor(IRegistry _registry) {\n        initOwnable(msg.sender);\n        registry = _registry;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Initializes external dependencies\n    function initDep() external adminOnly {\n        oracle = IOracle(registry.getAddress('ORACLE'));\n        accountManager = IAccountManager(registry.getAddress('ACCOUNT_MANAGER'));\n    }\n\n    /**\n        @notice Utility function to determine if an account can borrow a\n        specified amount of a token\n            isBorrowAllowed = (currentAccountBalance + borrowValue) /\n                (currentAccountBorrows + borrowValue) > balanceToBorrowThreshold\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to borrow\n        @return isBorrowAllowed Returns whether a borrow is allowed or not\n    */\n    function isBorrowAllowed(\n        address account,\n        address token,\n        uint amt\n    )\n        external\n        view\n        returns (bool)\n    {\n        uint borrowValue = _valueInWei(token, amt);\n        return _isAccountHealthy(\n            _getBalance(account) + borrowValue,\n            _getBorrows(account) + borrowValue\n        );\n    }\n\n    /**\n        @notice Utility function to determine if an account can withdraw a\n        specified amount of a token\n            isWithdrawAllowed = (currentAccountBalance - withdrawValue) /\n                currentAccountBorrows > balanceToBorrowThreshold\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to withdraw\n        @return isWithdrawAllowed Returns whether a withdraw is allowed or not\n    */\n    function isWithdrawAllowed(\n        address account,\n        address token,\n        uint amt\n    )\n        external\n        view\n        returns (bool)\n    {\n        if (IAccount(account).hasNoDebt()) return true;\n        return _isAccountHealthy(\n            _getBalance(account) - _valueInWei(token, amt),\n            _getBorrows(account)\n        );\n    }\n\n    /**\n        @notice Utility function to determine if an account is healthy or not\n            isAccountHealthy = currentAccountBalance / currentAccountBorrows >\n                balanceToBorrowThreshold\n         @param account Address of account\n        @return isAccountHealthy Returns whether an account is healthy or not.\n    */\n    function isAccountHealthy(address account) external view returns (bool) {\n        return _isAccountHealthy(\n            _getBalance(account),\n            _getBorrows(account)\n        );\n    }\n\n    /**\n        @notice Returns total account Balance\n        @param account Address of account\n        @return balance Total account balance\n    */\n    function getBalance(address account) external view returns (uint) {\n        return _getBalance(account);\n    }\n\n    /**\n        @notice Returns total account Borrows\n        @param account Address of account\n        @return borrows Total account borrows\n    */\n    function getBorrows(address account) external view returns (uint) {\n        return _getBorrows(account);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             Internal Functions                             */\n    /* -------------------------------------------------------------------------- */\n\n    function _getBalance(address account) internal view returns (uint) {\n        address[] memory assets = IAccount(account).getAssets();\n        uint assetsLen = assets.length;\n        uint totalBalance;\n        for(uint i; i < assetsLen; ++i) {\n            totalBalance += _valueInWei(\n                assets[i],\n                IERC20(assets[i]).balanceOf(account)\n            );\n        }\n        return totalBalance + account.balance;\n    }\n\n    function _getBorrows(address account) internal view returns (uint) {\n        if (IAccount(account).hasNoDebt()) return 0;\n        address[] memory borrows = IAccount(account).getBorrows();\n        uint borrowsLen = borrows.length;\n        uint totalBorrows;\n        for(uint i; i < borrowsLen; ++i) {\n            address LTokenAddr = registry.LTokenFor(borrows[i]);\n            totalBorrows += _valueInWei(\n                borrows[i],\n                ILToken(LTokenAddr).getBorrowBalance(account)\n            );\n        }\n        return totalBorrows;\n    }\n\n    function _valueInWei(address token, uint amt)\n        internal\n        view\n        returns (uint)\n    {\n        return oracle.getPrice(token)\n        .mulDivDown(\n            amt,\n            10 ** ((token == address(0)) ? 18 : IERC20(token).decimals())\n        );\n    }\n\n    function _isAccountHealthy(uint accountBalance, uint accountBorrows)\n        internal\n        pure\n        returns (bool)\n    {\n        return (accountBorrows == 0) ? true :\n            (accountBalance.divWadDown(accountBorrows) > balanceToBorrowThreshold);\n    }\n}"
    },
    {
      "filename": "src/core/Registry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Ownable} from \"../utils/Ownable.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\n\n/**\n    @title Registry Contract\n    @notice This contract stores:\n        1. Address of all accounts as well their owners\n        2. Active LToken addresses and Token->LToken mapping\n        3. Address of all deployed protocol contracts\n*/\ncontract Registry is Ownable, IRegistry {\n\n    /* -------------------------------------------------------------------------- */\n    /*                              STATE VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice List of contracts\n    /// @dev Contract Name should be separated by _ and in all caps Ex. (REGISTRY, RATE_MODEL)\n    string[] public keys;\n\n    /// @notice List of accounts\n    address[] public accounts;\n\n    /// @notice List of active lTokens\n    address[] public lTokens;\n\n    /// @notice Account address to owner mapping (account => owner)\n    mapping(address => address) public ownerFor;\n\n    /// @notice Token to LToken mapping (token => LToken)\n    mapping(address => address) public LTokenFor;\n\n    /// @notice Contract name to contract address mapping (contractName => contract)\n    mapping(string => address) public addressFor;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier accountManagerOnly() {\n        if (msg.sender != addressFor['ACCOUNT_MANAGER'])\n            revert Errors.AccountManagerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract Initialization function\n        @dev Can only be invoked once\n    */\n    function init() external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n        initialized = true;\n        initOwnable(msg.sender);\n    }\n\n    /**\n        @notice Sets contract address for a given contract id\n        @dev If address is 0x0 it removes the address from keys.\n        If addressFor[id] returns 0x0 then the contract id is added to keys\n        @param id Contract name, format (REGISTRY, RATE_MODEL)\n        @param _address Address of the contract\n    */\n    function setAddress(string calldata id, address _address)\n        external\n        adminOnly\n    {\n        if (addressFor[id] == address(0)) {\n            if (_address == address(0)) revert Errors.ZeroAddress();\n            keys.push(id);\n        }\n        else if (_address == address(0)) removeKey(id);\n\n        addressFor[id] = _address;\n    }\n\n    /**\n        @notice Sets LToken address for a specified token\n        @dev If underlying token is 0x0 LToken is removed from lTokens\n        if the mapping doesn't exist LToken is pushed to lTokens\n        if the mapping exist LToken is updated in lTokens\n        @param underlying Address of token\n        @param lToken Address of LToken\n    */\n    function setLToken(address underlying, address lToken) external adminOnly {\n        if (LTokenFor[underlying] == address(0)) {\n            if (lToken == address(0)) revert Errors.ZeroAddress();\n            lTokens.push(lToken);\n        }\n        else if (lToken == address(0)) removeLToken(LTokenFor[underlying]);\n        else updateLToken(LTokenFor[underlying], lToken);\n\n        LTokenFor[underlying] = lToken;\n    }\n\n    /**\n        @notice Adds account and sets owner of the account\n        @dev Adds account to accounts and stores owner for the account.\n        Event AccountCreated(account, owner) is emitted\n        @param account Address of account\n        @param owner Address of owner of the account\n    */\n    function addAccount(address account, address owner)\n        external\n        accountManagerOnly\n    {\n        ownerFor[account] = owner;\n        accounts.push(account);\n        emit AccountCreated(account, owner);\n    }\n\n    /**\n        @notice Updates owner of account\n        @param account Address of account\n        @param owner Address of owner of account\n    */\n    function updateAccount(address account, address owner)\n        external\n        accountManagerOnly\n    {\n        ownerFor[account] = owner;\n    }\n\n    /**\n        @notice Closes account\n        @dev Sets address of owner for the account to 0x0\n        @param account Address of account to close\n    */\n    function closeAccount(address account) external accountManagerOnly {\n        ownerFor[account] = address(0);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               VIEW FUNCTIONS                               */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Returns all contract names in registry\n        @return keys List of contract names\n    */\n    function getAllKeys() external view returns(string[] memory) {\n        return keys;\n    }\n\n    /**\n        @notice Returns all accounts in registry\n        @return accounts List of accounts\n    */\n    function getAllAccounts() external view returns (address[] memory) {\n        return accounts;\n    }\n\n    /**\n        @notice Returns all active LTokens in registry\n        @return lTokens List of lTokens\n    */\n    function getAllLTokens() external view returns(address[] memory) {\n        return lTokens;\n    }\n\n    /**\n        @notice Returns all accounts owned by a specific user\n        @param user Address of user\n        @return userAccounts List of accounts\n    */\n    function accountsOwnedBy(address user)\n        external\n        view\n        returns (address[] memory userAccounts)\n    {\n        userAccounts = new address[](accounts.length);\n        uint index;\n        for (uint i; i < accounts.length; i++) {\n            if (ownerFor[accounts[i]] == user) {\n                userAccounts[index] = accounts[i];\n                index++;\n            }\n        }\n        assembly { mstore(userAccounts, index) }\n    }\n\n    /**\n        @notice Returns address of a specified contract deployed by the protocol\n        @dev Reverts if there is no contract deployed\n        @param id Name of the contract, Eg: ACCOUNT_MANAGER\n        @return value Address of deployed contract\n    */\n    function getAddress(string calldata id)\n        external\n        view\n        returns (address value)\n    {\n        if ((value = addressFor[id]) == address(0))\n            revert Errors.ZeroAddress();\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              HELPER FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    function updateLToken(address lToken, address newLToken) internal {\n        uint len = lTokens.length;\n        for(uint i; i < len; ++i) {\n            if(lTokens[i] == lToken) {\n                lTokens[i] = newLToken;\n                break;\n            }\n        }\n    }\n\n    function removeLToken(address underlying) internal {\n        uint len = lTokens.length;\n        for(uint i; i < len; ++i) {\n            if (underlying == lTokens[i]) {\n                lTokens[i] = lTokens[len - 1];\n                lTokens.pop();\n                break;\n            }\n        }\n    }\n\n    function removeKey(string calldata id) internal {\n        uint len = keys.length;\n        bytes32 keyHash = keccak256(abi.encodePacked(id));\n        for(uint i; i < len; ++i) {\n            if (keyHash == keccak256(abi.encodePacked((keys[i])))) {\n                keys[i] = keys[len - 1];\n                keys.pop();\n                break;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/core/AccountManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Helpers} from \"../utils/Helpers.sol\";\nimport {Pausable} from \"../utils/Pausable.sol\";\nimport {IERC20} from \"../interface/tokens/IERC20.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\nimport {IAccount} from \"../interface/core/IAccount.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRiskEngine} from \"../interface/core/IRiskEngine.sol\";\nimport {IAccountFactory} from \"../interface/core/IAccountFactory.sol\";\nimport {IAccountManager} from \"../interface/core/IAccountManager.sol\";\nimport {IControllerFacade} from \"controller/core/IControllerFacade.sol\";\n\n/**\n    @title Account Manager\n    @notice Sentiment Account Manager,\n        All account interactions go via the account manager\n*/\ncontract AccountManager is Pausable, IAccountManager {\n    using Helpers for address;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE_VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice Registry\n    IRegistry public registry;\n\n    /// @notice Risk Engine\n    IRiskEngine public riskEngine;\n\n    /// @notice Controller Facade\n    IControllerFacade public controller;\n\n    /// @notice Account Factory\n    IAccountFactory public accountFactory;\n\n    /// @notice List of inactive accounts per user\n    mapping(address => address[]) public inactiveAccountsOf;\n\n    /// @notice Mapping of collateral enabled tokens\n    mapping(address => bool) public isCollateralAllowed;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier onlyOwner(address account) {\n        if (registry.ownerFor(account) != msg.sender)\n            revert Errors.AccountOwnerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Initializes contract\n        @dev Can only be invoked once\n        @param _registry Address of Registry\n    */\n    function init(IRegistry _registry) external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n        initialized = true;\n        initPausable(msg.sender);\n        registry = _registry;\n    }\n\n    /// @notice Initializes external dependencies"
    }
  ]
}