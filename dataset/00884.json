{
  "Title": "H-7: Different spot prices used during the comparison",
  "Content": "# Issue H-7: Different spot prices used during the comparison \n\nSource: https://github.com/sherlock-audit/2023-10-notional-judging/issues/85 \n\n## Found by \nxiaoming90\n## Summary\n\nThe spot prices used during the comparison are different, which might result in the trade proceeding even if the pool is manipulated, leading to a loss of assets.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/BalancerComposableAuraVault.sol#L90\n\n```solidity\nFile: BalancerComposableAuraVault.sol\n090:     function _checkPriceAndCalculateValue() internal view override returns (uint256) {\n091:         (uint256[] memory balances, uint256[] memory spotPrices) = SPOT_PRICE.getComposableSpotPrices(\n092:             BALANCER_POOL_ID,\n093:             address(BALANCER_POOL_TOKEN),\n094:             PRIMARY_INDEX()\n095:         );\n096: \n097:         // Spot prices are returned in native decimals, convert them all to POOL_PRECISION\n098:         // as required in the _calculateLPTokenValue method.\n099:         (/* */, uint8[] memory decimals) = TOKENS();\n100:         for (uint256 i; i < spotPrices.length; i++) {\n101:             spotPrices[i] = spotPrices[i] * POOL_PRECISION() / 10 ** decimals[i];\n102:         }\n103: \n104:         return _calculateLPTokenValue(balances, spotPrices);\n105:     }\n```\n\nLine 91 above calls the `SPOT_PRICE.getComposableSpotPrices` function to fetch the spot prices. Within the function, it relies on the `StableMath._calcSpotPrice` function to compute the spot price. Per the comments of this function, `spot price of token Y in token X` and `spot price Y/X` means that the Y (base) / X (quote). Thus, secondary (base) / primary (quote).\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/math/StableMath.sol#L90\n\n```solidity\nFile: StableMath.sol\n087:     /**\n088:      * @dev Calculates the spot price of token Y in token X.\n089:      */\n090:     function _calcSpotPrice(\n091:         uint256 amplificationParameter,\n092:         uint256 invariant, \n093:         uint256 balanceX,\n094:         uint256 balanceY\n095:     ) internal pure returns (uint256) {\n096:         /**************************************************************************************************************\n097:         //                                                                                                           //\n098:         //                             2.a.x.y + a.y^2 + b.y                                                         //\n099:         // spot price Y/X = - dx/dy = -----------------------                                                        //\n100:         //                             2.a.x.y + a.x^2 + b.x                                                         //\n101:         //                                                                                                           //\n102:         // n = 2                                                                                                     //\n103:         // a = amp param * n                                                                                         //\n104:         // b = D + a.(S - D)                                                                                         //\n105:         // D = invariant                                                                                             //\n106:         // S = sum of balances but x,y = 0 since x  and y are the only tokens                                        //\n107:         **************************************************************************************************************/\n108: \n109:         unchecked {\n110:             uint256 a = (amplificationParameter * 2) / _AMP_PRECISION;\n```\n\nThe above spot price will be used within the `_calculateLPTokenValue` function to compare with the oracle price to detect any potential pool manipulation. However, the oracle price returned is in primary (base) / secondary (quote) format. As such, the comparison between the spot price (secondary-base/primary-quote) and oracle price (primary-base/secondary-quote) will be incorrect.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol#L355\n\n```solidity\nFile: SingleSidedLPVaultBase.sol\n333:     function _calculateLPTokenValue(\n..SNIP..\n351:                 uint256 price = _getOraclePairPrice(primaryToken, address(tokens[i]));\n352: \n353:                 // Check that the spot price and the oracle price are near each other. If this is\n354:                 // not true then we assume that the LP pool is being manipulated.\n355:                 uint256 lowerLimit = price * (Constants.VAULT_PERCENT_BASIS - limit) / Constants.VAULT_PERCENT_BASIS;\n356:                 uint256 upperLimit = price * (Constants.VAULT_PERCENT_BASIS + limit) / Constants.VAULT_PERCENT_BASIS;\n357:                 if (spotPrices[i] < lowerLimit || upperLimit < spotPrices[i]) {\n358:                     revert Errors.InvalidPrice(price, spotPrices[i]);\n359:                 }\n```\n\n## Impact\n\nIf the spot price is incorrect, it might potentially fail to detect the pool has been manipulated or result in unintended reverts due to false positives. In the worst-case scenario, the trade proceeds to execute against the manipulated pool, leading to a loss of assets.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/BalancerComposableAuraVault.sol#L90\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/math/StableMath.sol#L90\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol#L355\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider verifying if the comment of the `StableMath._calcSpotPrice` function is aligned with its implementation with the Balancer team. \n\nIn addition, the `StableMath._calcSpotPrice` function is no longer used or found within the current version of Balancer's composable pool. Thus, there is no guarantee that the math within the `StableMath._calcSpotPrice` works with the current implementation. It is recommended to use the existing method in the current Composable Pool's StableMath, such as `_calcOutGivenIn` (ensure the fee is excluded) to compute the spot price.\n\n\n\n## Discussion\n\n**jeffywu**\n\nThis fix is included in this PR: https://github.com/notional-finance/leveraged-vaults/pull/63\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/119",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/BalancerComposableAuraVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {BalancerSpotPrice} from \"./balancer/BalancerSpotPrice.sol\";\nimport {\n    AuraStakingMixin,\n    AuraVaultDeploymentParams,\n    DeploymentParams\n} from \"./balancer/mixins/AuraStakingMixin.sol\";\nimport {IComposablePool} from \"../../interfaces/balancer/IBalancerPool.sol\";\nimport {IBalancerVault} from \"../../interfaces/balancer/IBalancerVault.sol\";\n\ncontract BalancerComposableAuraVault is AuraStakingMixin {\n    /// @notice Helper singleton function to calculate spot prices\n    BalancerSpotPrice immutable SPOT_PRICE;\n\n    constructor(\n        NotionalProxy notional_,\n        AuraVaultDeploymentParams memory params,\n        BalancerSpotPrice _spotPrice\n    ) AuraStakingMixin(notional_, params) {\n        // BPT_INDEX must be defined for a composable pool\n        require(BPT_INDEX != NOT_FOUND);\n        SPOT_PRICE = _spotPrice;\n    }\n\n    /// @notice strategy identifier\n    function strategy() external override pure returns (bytes4) {\n        return bytes4(keccak256(\"BalancerComposableAuraVault\"));\n    }\n\n    function _joinPoolAndStake(\n        uint256[] memory amounts, uint256 minPoolClaim\n    ) internal override returns (uint256 lpTokens) {\n        // Composable pool custom data does not include the BPT token amount so \n        // we loop here to remove it from the customData\n        uint256[] memory amountsWithoutBpt = new uint256[](amounts.length - 1);\n        uint256 j;\n        for (uint256 i; i < amounts.length; i++) {\n            if (i == BPT_INDEX) continue;\n            amountsWithoutBpt[j] = amounts[i];\n            j++;\n        }\n\n        bytes memory customData = abi.encode(\n            IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            amountsWithoutBpt,\n            minPoolClaim\n        );\n\n        lpTokens = _joinPoolExactTokensIn(amounts, customData);\n\n        // Transfer token to Aura protocol for boosted staking\n        bool success = AURA_BOOSTER.deposit(AURA_POOL_ID, lpTokens, true);\n        require(success);\n    }\n\n    function _unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory minAmounts, bool isSingleSided\n    ) internal override returns (uint256[] memory exitBalances) {\n        bool success = AURA_REWARD_POOL.withdrawAndUnwrap(poolClaim, false); // claimRewards = false\n        require(success);\n\n        bytes memory customData;\n        if (isSingleSided) {\n            // See this line here:\n            // https://github.com/balancer/balancer-v2-monorepo/blob/c7d4abbea39834e7778f9ff7999aaceb4e8aa048/pkg/pool-stable/contracts/ComposableStablePool.sol#L927\n            // While \"assets\" sent to the vault include the BPT token the tokenIndex passed in by this\n            // function does not include the BPT. primaryIndex in this code is inclusive of the BPT token in\n            // the assets array. Therefore, if primaryIndex > bptIndex subtract one to ensure that the primaryIndex\n            // does not include the BPT token here.\n            uint256 primaryIndex = PRIMARY_INDEX();\n            customData = abi.encode(\n                IBalancerVault.ComposableExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n                poolClaim,\n                primaryIndex < BPT_INDEX ?  primaryIndex : primaryIndex - 1\n            );\n        } else {\n            customData = abi.encode(\n                IBalancerVault.ComposableExitKind.EXACT_BPT_IN_FOR_ALL_TOKENS_OUT,\n                poolClaim\n            );\n        }\n\n        exitBalances = _exitPoolExactBPTIn(minAmounts, customData);\n    }\n \n    function _checkPriceAndCalculateValue() internal view override returns (uint256) {\n        (uint256[] memory balances, uint256[] memory spotPrices) = SPOT_PRICE.getComposableSpotPrices(\n            BALANCER_POOL_ID,\n            address(BALANCER_POOL_TOKEN),\n            PRIMARY_INDEX()\n        );\n\n        // Spot prices are returned in native decimals, convert them all to POOL_PRECISION\n        // as required in the _calculateLPTokenValue method.\n        (/* */, uint8[] memory decimals) = TOKENS();\n        for (uint256 i; i < spotPrices.length; i++) {\n            spotPrices[i] = spotPrices[i] * POOL_PRECISION() / 10 ** decimals[i];\n        }\n\n        return _calculateLPTokenValue(balances, spotPrices);\n    }\n\n    /// @notice Composable pools have a different method to get the total supply\n    function _totalPoolSupply() internal view override returns (uint256) {\n        return IComposablePool(address(BALANCER_POOL_TOKEN)).getActualSupply();\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/math/StableMath.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Math} from \"./Math.sol\";\nimport {FixedPoint} from \"./FixedPoint.sol\";\n\nlibrary StableMath {\n    using FixedPoint for uint256;\n    \n    uint256 internal constant _AMP_PRECISION = 1e3;\n\n    error CalculationDidNotConverge();\n\n    // Note on unchecked arithmetic:\n    // This contract performs a large number of additions, subtractions, multiplications and divisions, often inside\n    // loops. Since many of these operations are gas-sensitive (as they happen e.g. during a swap), it is important to\n    // not make any unnecessary checks. We rely on a set of invariants to avoid having to use checked arithmetic (the\n    // Math library), including:\n    //  - the number of tokens is bounded by _MAX_STABLE_TOKENS\n    //  - the amplification parameter is bounded by _MAX_AMP * _AMP_PRECISION, which fits in 23 bits\n    //  - the token balances are bounded by 2^112 (guaranteed by the Vault) times 1e18 (the maximum scaling factor),\n    //    which fits in 172 bits\n    //\n    // This means e.g. we can safely multiply a balance by the amplification parameter without worrying about overflow.\n\n    // Computes the invariant given the current balances, using the Newton-Raphson approximation.\n    // The amplification parameter equals: A n^(n-1)\n    function _calculateInvariant(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        bool roundUp\n    ) internal pure returns (uint256) {\n        /**********************************************************************************************\n        // invariant                                                                                 //\n        // D = invariant                                                  D^(n+1)                    //\n        // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\n        // S = sum of balances                                             n^n P                     //\n        // P = product of balances                                                                   //\n        // n = number of tokens                                                                      //\n        *********x************************************************************************************/\n\n        unchecked {\n            // We support rounding up or down.\n            uint256 sum = 0;\n            uint256 numTokens = balances.length;\n            for (uint256 i = 0; i < numTokens; i++) {\n                sum = sum.add(balances[i]);\n            }\n            if (sum == 0) {\n                return 0;\n            }\n\n            uint256 prevInvariant = 0;\n            uint256 invariant = sum;\n            uint256 ampTimesTotal = amplificationParameter * numTokens;\n\n            for (uint256 i = 0; i < 255; i++) {\n                uint256 P_D = balances[0] * numTokens;\n                for (uint256 j = 1; j < numTokens; j++) {\n                    P_D = Math.div(Math.mul(Math.mul(P_D, balances[j]), numTokens), invariant, roundUp);\n                }\n                prevInvariant = invariant;\n                invariant = Math.div(\n                    Math.mul(Math.mul(numTokens, invariant), invariant).add(\n                        Math.div(Math.mul(Math.mul(ampTimesTotal, sum), P_D), _AMP_PRECISION, roundUp)\n                    ),\n                    Math.mul(numTokens + 1, invariant).add(\n                        // No need to use checked arithmetic for the amp precision, the amp is guaranteed to be at least 1\n                        Math.div(Math.mul(ampTimesTotal - _AMP_PRECISION, P_D), _AMP_PRECISION, !roundUp)\n                    ),\n                    roundUp\n                );\n\n                if (invariant > prevInvariant) {\n                    if (invariant - prevInvariant <= 1) {\n                        return invariant;\n                    }\n                } else if (prevInvariant - invariant <= 1) {\n                    return invariant;\n                }\n            }\n        }\n\n        revert CalculationDidNotConverge();\n    }\n\n    /**\n     * @dev Calculates the spot price of token Y in token X.\n     */\n    function _calcSpotPrice(\n        uint256 amplificationParameter,\n        uint256 invariant, \n        uint256 balanceX,\n        uint256 balanceY\n    ) internal pure returns (uint256) {\n        /**************************************************************************************************************\n        //                                                                                                           //\n        //                             2.a.x.y + a.y^2 + b.y                                                         //\n        // spot price Y/X = - dx/dy = -----------------------                                                        //\n        //                             2.a.x.y + a.x^2 + b.x                                                         //\n        //                                                                                                           //\n        // n = 2                                                                                                     //\n        // a = amp param * n                                                                                         //\n        // b = D + a.(S - D)                                                                                         //\n        // D = invariant                                                                                             //\n        // S = sum of balances but x,y = 0 since x  and y are the only tokens                                        //\n        **************************************************************************************************************/\n\n        unchecked {\n            uint256 a = (amplificationParameter * 2) / _AMP_PRECISION;\n            uint256 b = Math.mul(invariant, a).sub(invariant);\n\n            uint256 axy2 = Math.mul(a * 2, balanceX).mulDown(balanceY); // n = 2\n\n            // dx = a.x.y.2 + a.y^2 - b.y\n            uint256 derivativeX = axy2.add(Math.mul(a, balanceY).mulDown(balanceY)).sub(b.mulDown(balanceY));\n\n            // dy = a.x.y.2 + a.x^2 - b.x\n            uint256 derivativeY = axy2.add(Math.mul(a, balanceX).mulDown(balanceX)).sub(b.mulDown(balanceX));\n\n            // The rounding direction is irrelevant as we're about to introduce a much larger error when converting to log\n            // space. We use `divUp` as it prevents the result from being zero, which would make the logarithm revert. A\n            // result of zero is therefore only possible with zero balances, which are prevented via other means.\n            return derivativeX.divUp(derivativeY);\n        }\n    }\n\n    function _balances(uint256 balanceX, uint256 balanceY) internal pure returns (uint256[] memory balances) {\n        balances = new uint256[](2);\n        balances[0] = balanceX;\n        balances[1] = balanceY;\n    }\n\n    // This function calculates the balance of a given token (tokenIndex)\n    // given all the other balances and the invariant\n    function _getTokenBalanceGivenInvariantAndAllOtherBalances(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 invariant,\n        uint256 tokenIndex\n    ) internal pure returns (uint256) {\n        // Rounds result up overall\n        unchecked {\n            uint256 ampTimesTotal = amplificationParameter * balances.length;\n            uint256 sum = balances[0];\n            uint256 P_D = balances[0] * balances.length;\n            for (uint256 j = 1; j < balances.length; j++) {\n                P_D = Math.divDown(Math.mul(Math.mul(P_D, balances[j]), balances.length), invariant);\n                sum = sum.add(balances[j]);\n            }\n            // No need to use safe math, based on the loop above `sum` is greater than or equal to `balances[tokenIndex]`\n            sum = sum - balances[tokenIndex];\n\n            uint256 inv2 = Math.mul(invariant, invariant);\n            // We remove the balance fromm c by multiplying it\n            uint256 c = Math.mul(\n                Math.mul(Math.divUp(inv2, Math.mul(ampTimesTotal, P_D)), _AMP_PRECISION),\n                balances[tokenIndex]\n            );\n            uint256 b = sum.add(Math.mul(Math.divDown(invariant, ampTimesTotal), _AMP_PRECISION));\n\n            // We iterate to find the balance\n            uint256 prevTokenBalance = 0;\n            // We multiply the first iteration outside the loop with the invariant to set the value of the\n            // initial approximation.\n            uint256 tokenBalance = Math.divUp(inv2.add(c), invariant.add(b));\n\n            for (uint256 i = 0; i < 255; i++) {\n                prevTokenBalance = tokenBalance;\n\n                tokenBalance = Math.divUp(\n                    Math.mul(tokenBalance, tokenBalance).add(c),\n                    Math.mul(tokenBalance, 2).add(b).sub(invariant)\n                );\n\n                if (tokenBalance > prevTokenBalance) {\n                    if (tokenBalance - prevTokenBalance <= 1) {\n                        return tokenBalance;\n                    }\n                } else if (prevTokenBalance - tokenBalance <= 1) {\n                    return tokenBalance;\n                }\n            }\n        }\n\n        revert CalculationDidNotConverge();\n    }\n\n    function _calcTokenOutGivenExactBptIn(\n        uint256 amp,\n        uint256[] memory balances,\n        uint256 tokenIndex,\n        uint256 bptAmountIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage,\n        uint256 currentInvariant\n    ) internal pure returns (uint256) {\n        // Token out, so we round down overall.\n\n        unchecked {\n            uint256 newInvariant = bptTotalSupply.sub(bptAmountIn).divUp(bptTotalSupply).mulUp(currentInvariant);\n\n            // Calculate amount out without fee\n            uint256 newBalanceTokenIndex = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n                amp,\n                balances,\n                newInvariant,\n                tokenIndex\n            );\n            uint256 amountOutWithoutFee = balances[tokenIndex].sub(newBalanceTokenIndex);\n\n            // First calculate the sum of all token balances, which will be used to calculate\n            // the current weight of each token\n            uint256 sumBalances = 0;\n            for (uint256 i = 0; i < balances.length; i++) {\n                sumBalances = sumBalances.add(balances[i]);\n            }\n\n            // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n            // in swap fees.\n            uint256 currentWeight = balances[tokenIndex].divDown(sumBalances);\n            uint256 taxablePercentage = currentWeight.complement();\n\n            // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n            // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n            uint256 taxableAmount = amountOutWithoutFee.mulUp(taxablePercentage);\n            uint256 nonTaxableAmount = amountOutWithoutFee.sub(taxableAmount);\n\n            // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n            return nonTaxableAmount.add(taxableAmount.mulDown(FixedPoint.ONE - swapFeePercentage));\n        }\n    }\n\n    // Computes how many tokens can be taken out of a pool if `tokenAmountIn` are sent, given the current balances.\n    // The amplification parameter equals: A n^(n-1)\n    function _calcOutGivenIn(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 tokenIndexIn,\n        uint256 tokenIndexOut,\n        uint256 tokenAmountIn,\n        uint256 invariant\n    ) internal pure returns (uint256) {\n        /**************************************************************************************************************\n        // outGivenIn token x for y - polynomial equation to solve                                                   //\n        // ay = amount out to calculate                                                                              //\n        // by = balance token out                                                                                    //\n        // y = by - ay (finalBalanceOut)                                                                             //\n        // D = invariant                                               D                     D^(n+1)                 //\n        // A = amplification coefficient               y^2 + ( S - ----------  - D) * y -  ------------- = 0         //\n        // n = number of tokens                                    (A * n^n)               A * n^2n * P              //\n        // S = sum of final balances but y                                                                           //\n        // P = product of final balances but y                                                                       //\n        **************************************************************************************************************/\n\n        // Amount out, so we round down overall.\n        unchecked {\n            balances[tokenIndexIn] = balances[tokenIndexIn].add(tokenAmountIn);\n\n            uint256 finalBalanceOut = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n                amplificationParameter,\n                balances,\n                invariant,\n                tokenIndexOut\n            );\n\n            // No need to use checked arithmetic since `tokenAmountIn` was actually added to the same balance right before\n            // calling `_getTokenBalanceGivenInvariantAndAllOtherBalances` which doesn't alter the balances array.\n            balances[tokenIndexIn] = balances[tokenIndexIn] - tokenAmountIn;\n\n            return balances[tokenIndexOut].sub(finalBalanceOut).sub(1);\n        }\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {BaseStrategyVault} from \"./BaseStrategyVault.sol\";\nimport {Errors} from \"../../global/Errors.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {TypeConvert} from \"../../global/TypeConvert.sol\";\nimport {TokenUtils} from \"../../utils/TokenUtils.sol\";\nimport {StrategyUtils} from \"./StrategyUtils.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\n\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {\n    ISingleSidedLPStrategyVault,\n    StrategyVaultSettings,\n    InitParams,\n    StrategyVaultState,\n    SingleSidedRewardTradeParams,\n    DepositParams,\n    DepositTradeParams,\n    RedeemParams,\n    TradeParams\n} from \"../../../interfaces/notional/ISingleSidedLPStrategyVault.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule, DexId} from \"../../../interfaces/trading/ITradingModule.sol\";\n\n/**\n * @notice Base contract for the SingleSidedLP strategy. This strategy deposits into an LP\n * pool given a single borrowed currency. Allows for users to trade via external exchanges\n * during entry and exit, but the general expected behavior is single sided entries and\n * exits. Inheriting contracts will fill in the implementation details for integration with\n * the external DEX pool.\n */\nabstract contract SingleSidedLPVaultBase is BaseStrategyVault, UUPSUpgradeable, ISingleSidedLPStrategyVault {\n    using TypeConvert for uint256;\n    using VaultStorage for StrategyVaultState;\n\n    uint256 internal constant MAX_TOKENS = 5;\n    uint8 internal constant NOT_FOUND = type(uint8).max;\n    /// @notice Bit mask for the 'LOCKED\" flag big\n    uint32 internal constant FLAG_LOCKED = 1 << 0;\n\n    /************************************************************************\n     * VIRTUAL FUNCTIONS                                                    *\n     * These virtual functions are used to isolate implementation specific  *\n     * behavior.                                                            *\n     ************************************************************************/\n\n    /// @notice Total number of tokens held by the LP token\n    function NUM_TOKENS() internal view virtual returns (uint256);\n\n    /// @notice Addresses of tokens held and decimal places of each token. ETH will always be\n    /// recorded in this array as Deployments.ETH_Address\n    function TOKENS() internal view virtual returns (IERC20[] memory, uint8[] memory decimals);\n\n    /// @notice Address of the LP token\n    function POOL_TOKEN() internal view virtual returns (IERC20);\n\n    /// @notice Index of the TOKENS() array that refers to the primary borrowed currency by the\n    /// leveraged vault. All valuations are done in terms of this currency.\n    function PRIMARY_INDEX() internal view virtual returns (uint256);\n\n    /// @notice Precision (i.e. 10 ** decimals) of the LP token.\n    function POOL_PRECISION() internal view virtual returns (uint256);\n\n    /// @notice Returns the value of one LP token in terms of the primary borrowed currency by this\n    /// strategy. Will revert if the spot price on the pool is not within some deviation tolerance of\n    /// the implied oracle price. This is intended to prevent any pool manipulation.\n    /// The value of the LP token is calculated as the value of the token if all the balance claims are\n    /// withdrawn proportionally and then converted to the primary currency at the oracle price. Slippage\n    /// from selling the tokens is not considered, any slippage effects will be captured by the maximum\n    /// leverage ratio allowed before liquidation.\n    function _checkPriceAndCalculateValue() internal view virtual returns (uint256 oneLPValueInPrimary);\n\n    /// @notice Called once during initialization to set the initial token approvals.\n    function _initialApproveTokens() internal virtual;\n\n    /// @notice Called to claim reward tokens\n    function _claimRewardTokens() internal virtual;\n\n    /// @notice Called during reward reinvestment to validate that the token being sold is not one\n    /// of the tokens that is required for the vault to function properly (i.e. one of the pool tokens\n    /// or any of the reward booster tokens).\n    function _isInvalidRewardToken(address token) internal view virtual returns (bool);\n\n    /// @notice Implementation specific wrapper for joining a pool with the given amounts. Will also\n    /// stake on the relevant booster protocol.\n    function _joinPoolAndStake(\n        uint256[] memory amounts, uint256 minPoolClaim\n    ) internal virtual returns (uint256 lpTokens);\n\n    /// @notice Implementation specific wrapper for unstaking from the booster protocol and withdrawing\n    /// funds from the LP pool\n    function _unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory minAmounts, bool isSingleSided\n    ) internal virtual returns (uint256[] memory exitBalances);\n\n    /// @notice Returns the total supply of the pool token. Is a virtual function because\n    /// ComposableStablePools use a \"virtual supply\" and a different method must be called\n    /// to get the actual total supply.\n    function _totalPoolSupply() internal view virtual returns (uint256) {\n        return POOL_TOKEN().totalSupply();\n    }\n\n    /************************************************************************\n     * CLASS FUNCTIONS                                                      *\n     * Below are class functions that represent the base implementation     *\n     * of the Single Sided LP strategy.                                     *\n     ************************************************************************/\n\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_)\n        BaseStrategyVault(notional_, tradingModule_) {}\n\n    /************************************************************************\n     * EXTERNAL VIEW FUNCTIONS                                              *\n     ************************************************************************/\n\n    /// @notice Returns basic information about the vault for use in the user interface.\n    function getStrategyVaultInfo() external view override returns (SingleSidedLPStrategyVaultInfo memory) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        return SingleSidedLPStrategyVaultInfo({\n            pool: address(POOL_TOKEN()),\n            singleSidedTokenIndex: uint8(PRIMARY_INDEX()),\n            totalLPTokens: state.totalPoolClaim,\n            totalVaultShares: state.totalVaultSharesGlobal\n        });\n    }\n\n    /// @notice Returns the current locked status of the vault\n    function isLocked() public view returns (bool) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        return _hasFlag(state.flags, FLAG_LOCKED);\n    }\n\n    /// @notice Returns the current price of a vault share, even when there are no vault shares\n    /// in the strategy. Used by the user interface to collect historical valuation information.\n    function getExchangeRate(uint256 /* maturity */) external view override returns (int256) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        uint256 oneLPValueInPrimary = _checkPriceAndCalculateValue();\n        // If inside an emergency exit, just report the one LP value in primary since the total\n        // pool claim will be 0\n        if (state.totalVaultSharesGlobal == 0 || isLocked()) {\n            return oneLPValueInPrimary.toInt();\n        } else {\n            uint256 lpTokensPerVaultShare = (uint256(Constants.INTERNAL_TOKEN_PRECISION) * state.totalPoolClaim)\n                / state.totalVaultSharesGlobal;\n            return (oneLPValueInPrimary * lpTokensPerVaultShare / POOL_PRECISION()).toInt();\n        }\n    }\n\n    /************************************************************************\n     * ADMIN FUNCTIONS                                                      *\n     * Administrative functions to set settings and initialize the vault.   *\n     * These methods are only callable by the Notional owner.               *\n     ************************************************************************/\n\n    /// @notice Allow Notional owner to upgrade the contract\n    function _authorizeUpgrade(\n        address /* newImplementation */\n    ) internal override onlyNotionalOwner {}\n\n    /// @notice Updates the vault settings include the maximum oracle deviation limit and the\n    /// maximum percent of the LP pool that the vault can hold.\n    function setStrategyVaultSettings(StrategyVaultSettings calldata settings) external onlyNotionalOwner {\n        // Validation occurs inside this method\n        VaultStorage.setStrategyVaultSettings(settings);\n    }\n\n    /// @notice Called to initialize the vault and set the initial approvals. All of the other vault\n    /// parameters are set via immutable parameters already.\n    function initialize(InitParams calldata params) external override initializer onlyNotionalOwner {\n        // Initialize the base vault\n        __INIT_VAULT(params.name, params.borrowCurrencyId);\n\n        // Settings are validated in setStrategyVaultSettings\n        VaultStorage.setStrategyVaultSettings(params.settings);\n\n        _initialApproveTokens();\n    }\n\n    /************************************************************************\n     * USER FUNCTIONS                                                       *\n     * These functions are called during normal usage of the vault.         *\n     * They allow for deposits and redemptions from the vault as well as a  *\n     * valuation check that is used by Notional to determine if the user is *\n     * properly collateralized.                                             *\n     ************************************************************************/\n\n    /// @notice This is a virtual function called by BaseStrategyVault which ensures that\n    /// this method is only called by Notional after an initial borrow has been made and\n    /// the deposit amount has been transferred to this vault. Will join the LP pool with\n    /// the funds given and then return the total vault shares minted.\n    function _depositFromNotional(\n        address /* account */, uint256 deposit, uint256 /* maturity */, bytes calldata data\n    ) internal override whenNotLocked returns (uint256 vaultSharesMinted) {\n        // Short circuit any zero deposit amounts\n        if (deposit == 0) return 0;\n\n        DepositParams memory params = abi.decode(data, (DepositParams));\n        uint256[] memory amounts = new uint256[](NUM_TOKENS());\n        amounts[PRIMARY_INDEX()] = deposit;\n\n        // If depositTrades are specified, then parts of the initial deposit are traded\n        // for corresponding amounts of the other pool tokens via external exchanges. If\n        // these amounts are not specified then the pool will just be joined single sided.\n        // Deposit trades are not automatically enabled on vaults since the trading module\n        // requires explicit permission for every token that can be sold by an address.\n        if (params.depositTrades.length > 0) {\n            (IERC20[] memory tokens, /* */) = TOKENS();\n            // This is an external library call so the memory location of amounts is\n            // different before and after the call.\n            amounts = StrategyUtils.executeDepositTrades(\n                tokens,\n                amounts,\n                params.depositTrades,\n                PRIMARY_INDEX()\n            );\n        }\n\n        uint256 lpTokens = _joinPoolAndStake(amounts, params.minPoolClaim);\n        return _mintVaultShares(lpTokens);\n    }\n\n    /// @notice Given a number of LP tokens minted, issues vault shares back to the holder. Vault\n    /// shares are claim on the LP tokens held by the vault. As rewards are reinvested, one vault\n    /// share is a claim on an increasing amount of LP tokens.\n    function _mintVaultShares(uint256 lpTokens) internal returns (uint256 vaultShares) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        if (state.totalPoolClaim == 0) {\n            // Vault Shares are in 8 decimal precision\n            vaultShares = (lpTokens * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / POOL_PRECISION();\n        } else {\n            vaultShares = (lpTokens * state.totalVaultSharesGlobal) / state.totalPoolClaim;\n        }\n\n        // Updates internal storage here\n        state.totalPoolClaim += lpTokens;\n        state.totalVaultSharesGlobal += vaultShares.toUint80();\n        state.setStrategyVaultState();\n\n        // Checks that the vault does not own too large of a portion of the pool. If this is the case,\n        // single sided exits may have a detrimental effect on the liquidity.\n        uint256 maxPoolShare = VaultStorage.getStrategyVaultSettings().maxPoolShare;\n        uint256 maxSupplyThreshold = (_totalPoolSupply() * maxPoolShare) / Constants.VAULT_PERCENT_BASIS;\n        if (maxSupplyThreshold < state.totalPoolClaim)\n            revert Errors.PoolShareTooHigh(state.totalPoolClaim, maxSupplyThreshold);\n    }\n\n    /// @notice This is a virtual function called by BaseStrategyVault which ensures that\n    /// this method is only called by Notional after an initial position has been made. Will\n    /// withdraw the LP tokens from the pool, either single sided or proportionally. On a\n    /// proportional exit, will trade all the tokens back to the primary in order to exit the pool.\n    /// @return finalPrimaryBalance which is the amount of funds that the vault will transfer back\n    /// to Notional and the account to repay debts and withdraw profits.\n    function _redeemFromNotional(\n        address /* account */, uint256 vaultShares, uint256 /* maturity */, bytes calldata data\n    ) internal override whenNotLocked returns (uint256 finalPrimaryBalance) {\n        // Sh"
    }
  ]
}