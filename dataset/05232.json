{
  "Title": "[H-01] Development Team might receive less SALT because there is no access control on `VestingWallet#release()`",
  "Content": "\nThe Development Team could potentially incur a loss on their SALT distribution reward due to the absence of access control on `VestingWallet#release()`.\n\n### Proof of Concept\n\nWhen Salty exchange is actived, 10M SALT will be transferred to `teamVestingWallet` by calling [`InitialDistribution#distributionApproved()`](https://github.com/code-423n4/2024-01-salty/blob/main/src/launch/InitialDistribution.sol#L50-L74):\n\n```solidity\n62: \tsalt.safeTransfer( address(teamVestingWallet), 10 * MILLION_ETHER );\n```\n\n`teamVestingWallet` is responsible for distributing 10M SALT linely over 10 years ([Deployment.sol#L100](https://github.com/code-423n4/2024-01-salty/blob/main/src/dev/Deployment.sol#L100)):\n\n```solidity\n    teamVestingWallet = new VestingWallet( address(upkeep), uint64(block.timestamp), 60 * 60 * 24 * 365 * 10 );\n```\n\nFrom the above code we can see that the beneficiary of `teamVestingWallet` is `Upkeep`.\n\nEach time [`Upkeep#performUpkeep()`](https://github.com/code-423n4/2024-01-salty/blob/main/src/Upkeep.sol#L244-L279) is called, `teamVestingWallet` will release a certain amount of SALT to `Upkeep`, the beneficiary, and then the relased SALT will be transferred to `mainWallet` of `managedTeamWallet`:\n\n```solidity\n  function step11() public onlySameContract\n  {\n    uint256 releaseableAmount = VestingWallet(payable(exchangeConfig.teamVestingWallet())).releasable(address(salt));\n    \n    // teamVestingWallet actually sends the vested SALT to this contract - which will then need to be sent to the active teamWallet\n    VestingWallet(payable(exchangeConfig.teamVestingWallet())).release(address(salt));\n    \n    salt.safeTransfer( exchangeConfig.managedTeamWallet().mainWallet(), releaseableAmount );\n  }\n```\n\nHowever, there is no access control on `teamVestingWallet.release()`. Any one can call `release()` to distribute SALT without informing `upkeep`. `upkeep` doesn't know how many SALT has been distributed in advance, it has no way to transfer it to the development team, and the distributed SALT by directly calling `teamVestingWallet.release()` will be locked in `upkeep` forever.\n\nCopy below codes to [DAO.t.sol](https://github.com/code-423n4/2024-01-salty/blob/main/src/dao/tests/DAO.t.sol) and run `COVERAGE=\"yes\" NETWORK=\"sep\" forge test -vv --rpc-url RPC_URL --match-test testTeamRewardIsLockedInUpkeep`\n\n```solidity\n  function testTeamRewardIsLockedInUpkeep() public {\n    uint releasableAmount = teamVestingWallet.releasable(address(salt));\n    uint upKeepBalance = salt.balanceOf(address(upkeep));\n    uint mainWalletBalance = salt.balanceOf(address(managedTeamWallet.mainWallet()));\n    //@audit-info a certain amount of SALT is releasable\n    assertTrue(releasableAmount != 0);\n    //@audit-info there is no SALT in upkeep\n    assertEq(upKeepBalance, 0);\n    //@audit-info there is no SALT in mainWallet\n    assertEq(mainWalletBalance, 0);\n    //@audit-info call release() before performUpkeep()\n    teamVestingWallet.release(address(salt));\n    upkeep.performUpkeep();\n    \n    upKeepBalance = salt.balanceOf(address(upkeep));\n    mainWalletBalance = salt.balanceOf(address(managedTeamWallet.mainWallet()));\n    //@audit-info all released SALT is locked in upKeep\n    assertEq(upKeepBalance, releasableAmount);\n    //@audit-info development team receive nothing\n    assertEq(mainWalletBalance, 0);\n  }\n```\n\n### Recommended Mitigation Steps\n\n*   Since `exchangeConfig.managedTeamWallet` is immutable, it is reasonable to config `managedTeamWallet` as the beneficiary when [deploying `teamVestingWallet`](https://github.com/code-423n4/2024-01-salty/blob/main/src/dev/Deployment.sol#L100):\n\n```diff\n-   teamVestingWallet = new VestingWallet( address(upkeep), uint64(block.timestamp), 60 * 60 * 24 * 365 * 10 );\n+   teamVestingWallet = new VestingWallet( address(managedTeamWallet), uint64(block.timestamp), 60 * 60 * 24 * 365 * 10 );\n```\n\n*   Introduce a new function in `managedTeamWallet` to transfer all SALT balance to `mainWallet`:\n\n```solidity\n  function release(address token) external {\n    uint balance = IERC20(token).balanceOf(address(this));\n    if (balance != 0) {\n      IERC20(token).safeTransfer(mainWallet, balance);\n    }\n  }\n```\n\n*   Call `managedTeamWallet#release()` in `Upkeep#performUpkeep()`:\n\n```diff\n  function step11() public onlySameContract\n  {\n-   uint256 releaseableAmount = VestingWallet(payable(exchangeConfig.teamVestingWallet())).releasable(address(salt));\n    \n-   // teamVestingWallet actually sends the vested SALT to this contract - which will then need to be sent to the active teamWallet\n    VestingWallet(payable(exchangeConfig.teamVestingWallet())).release(address(salt));\n    \n-   salt.safeTransfer( exchangeConfig.managedTeamWallet().mainWallet(), releaseableAmount );\n+   exchangeConfig.managedTeamWallet().release(address(salt));\n  }\n```\n**[othernet-global (Salty.IO) confirmed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/712#issuecomment-1945532417):**\n > The ManagedWallet now the recipient of teamVestingWalletRewards to prevent the issue of DOS of the team rewards.\n> \n> https://github.com/othernet-global/salty-io/commit/534d04a40c9b5821ad4e196095df70c0021d15ab\n\n > ManagedWallet has been removed.\n> \n> https://github.com/othernet-global/salty-io/commit/5766592880737a5e682bb694a3a79e12926d48a5\n\n**[Picodes (Judge) commented](https://github.com/code-423n4/2024-01-salty-findings/issues/712#issuecomment-1967449721):**\n > My initial view on this is that the issue is within `Upkeep` as it integrates poorly with the vesting wallet. It forgets that there is no access control, so I tend to see this as in scope.\n\n > The issue is not strictly in the deployment scripts, not strictly in the vesting wallet either because it makes sense to have no access control on `release`, so it must be in `Upkeep`.\n\n_Note: For full discussion, see [here](https://github.com/code-423n4/2024-01-salty-findings/issues/712)._\n\n**Status:** Mitigation confirmed. Full details in reports from [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/61), [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/41), and [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/33).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/launch/InitialDistribution.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/finance/VestingWallet.sol\";\nimport \"../rewards/interfaces/ISaltRewards.sol\";\nimport \"../rewards/interfaces/IEmissions.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"./interfaces/IInitialDistribution.sol\";\nimport \"./interfaces/IBootstrapBallot.sol\";\nimport \"./interfaces/IAirdrop.sol\";\nimport \"../interfaces/ISalt.sol\";\n\n\ncontract InitialDistribution is IInitialDistribution\n    {\n\tusing SafeERC20 for ISalt;\n\n\tuint256 constant public MILLION_ETHER = 1000000 ether;\n\n\n   \tISalt immutable public salt;\n\tIPoolsConfig immutable public poolsConfig;\n   \tIEmissions immutable public emissions;\n   \tIBootstrapBallot immutable public bootstrapBallot;\n\tIDAO immutable public dao;\n\tVestingWallet immutable public daoVestingWallet;\n\tVestingWallet immutable public teamVestingWallet;\n\tIAirdrop immutable public airdrop;\n\tISaltRewards immutable public saltRewards;\n\tICollateralAndLiquidity immutable public collateralAndLiquidity;\n\n\n\tconstructor( ISalt _salt, IPoolsConfig _poolsConfig, IEmissions _emissions, IBootstrapBallot _bootstrapBallot, IDAO _dao, VestingWallet _daoVestingWallet, VestingWallet _teamVestingWallet, IAirdrop _airdrop, ISaltRewards _saltRewards, ICollateralAndLiquidity _collateralAndLiquidity  )\n\t\t{\n\t\tsalt = _salt;\n\t\tpoolsConfig = _poolsConfig;\n\t\temissions = _emissions;\n\t\tbootstrapBallot = _bootstrapBallot;\n\t\tdao = _dao;\n\t\tdaoVestingWallet = _daoVestingWallet;\n\t\tteamVestingWallet = _teamVestingWallet;\n\t\tairdrop = _airdrop;\n\t\tsaltRewards = _saltRewards;\n\t\tcollateralAndLiquidity = _collateralAndLiquidity;\n        }\n\n\n    // Called when the BootstrapBallot is approved by the initial airdrop recipients.\n    function distributionApproved() external\n    \t{\n    \trequire( msg.sender == address(bootstrapBallot), \"InitialDistribution.distributionApproved can only be called from the BootstrapBallot contract\" );\n\t\trequire( salt.balanceOf(address(this)) == 100 * MILLION_ETHER, \"SALT has already been sent from the contract\" );\n\n    \t// 52 million\t\tEmissions\n\t\tsalt.safeTransfer( address(emissions), 52 * MILLION_ETHER );\n\n\t    // 25 million\t\tDAO Reserve Vesting Wallet\n\t\tsalt.safeTransfer( address(daoVestingWallet), 25 * MILLION_ETHER );\n\n\t    // 10 million\t\tInitial Development Team Vesting Wallet\n\t\tsalt.safeTransfer( address(teamVestingWallet), 10 * MILLION_ETHER );\n\n\t    // 5 million\t\tAirdrop Participants\n\t\tsalt.safeTransfer( address(airdrop), 5 * MILLION_ETHER );\n\t\tairdrop.allowClaiming();\n\n\t\tbytes32[] memory poolIDs = poolsConfig.whitelistedPools();\n\n\t    // 5 million\t\tLiquidity Bootstrapping\n\t    // 3 million\t\tStaking Bootstrapping\n\t\tsalt.safeTransfer( address(saltRewards), 8 * MILLION_ETHER );\n\t\tsaltRewards.sendInitialSaltRewards(5 * MILLION_ETHER, poolIDs );\n    \t}\n\t}"
    },
    {
      "filename": "src/dev/Deployment.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"forge-std/Test.sol\";\nimport \"../pools/interfaces/IPools.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"../stable/USDS.sol\";\nimport \"../stable/interfaces/IStableConfig.sol\";\nimport \"../price_feed/interfaces/IPriceAggregator.sol\";\nimport \"../staking/interfaces/IStakingConfig.sol\";\nimport \"../staking/interfaces/IStaking.sol\";\nimport \"../staking/Staking.sol\";\nimport \"../rewards/interfaces/IRewardsEmitter.sol\";\nimport \"../rewards/Emissions.sol\";\nimport \"../dao/interfaces/IDAOConfig.sol\";\nimport \"../dao/interfaces/IDAO.sol\";\nimport \"../dao/interfaces/IProposals.sol\";\nimport \"../price_feed/tests/IForcedPriceFeed.sol\";\nimport \"../launch/interfaces/IBootstrapBallot.sol\";\nimport \"openzeppelin-contracts/contracts/finance/VestingWallet.sol\";\nimport \"../launch/interfaces/IAirdrop.sol\";\nimport \"../dao/Proposals.sol\";\nimport \"../dao/DAO.sol\";\nimport \"../AccessManager.sol\";\nimport \"../rewards/SaltRewards.sol\";\nimport \"../launch/InitialDistribution.sol\";\nimport \"../pools/PoolsConfig.sol\";\nimport \"../ExchangeConfig.sol\";\nimport \"../price_feed/PriceAggregator.sol\";\nimport \"../pools/Pools.sol\";\nimport \"../staking/Liquidity.sol\";\nimport \"../stable/CollateralAndLiquidity.sol\";\nimport \"../rewards/RewardsEmitter.sol\";\nimport \"../root_tests/TestERC20.sol\";\nimport \"../launch/Airdrop.sol\";\nimport \"../launch/BootstrapBallot.sol\";\nimport \"../stable/interfaces/ILiquidizer.sol\";\nimport \"../stable/Liquidizer.sol\";\nimport \"../stable/StableConfig.sol\";\nimport \"../Salt.sol\";\nimport \"../ManagedWallet.sol\";\nimport \"../dao/DAOConfig.sol\";\n\n// Stores the contract addresses for the various parts of the exchange and allows the unit tests to be run on them.\n\ncontract Deployment is Test\n    {\n    bool public DEBUG = true;\n\taddress constant public DEPLOYER = 0x73107dA86708c2DAd0D91388fB057EeE3E2581aF;\n\n\t// Test addresses on Sepolia for the Price Feeds\n\taddress public CHAINLINK_BTC_USD = 0x65EC417a4C95d6FE6FB11EBFa86FAFEaE2B3bE2F;\n\taddress public CHAINLINK_ETH_USD = 0x694AA1769357215DE4FAC081bf1f309aDC325306;\n\taddress public UNISWAP_V3_BTC_ETH = 0xFb9785B2CA67AF31087945BCCd02D00768208e38;\n\taddress public UNISWAP_V3_USDC_ETH = 0x3EcF4D43d1C7EC1A609d554BAb2565b223831349;\n\tIERC20 public _testBTC = IERC20(0xd4C3cc58E46C99fbA0c4e4d93C82AE32000cc4D4);\n\tIERC20 public _testETH = IERC20(0x14edfAb9FAE5fe2396565903763Cb29E0d7be7d9);\n\tIERC20 public _testUSDC = IERC20(0x9C65b1773A95d607f41fa205511cd3327cc39D9D);\n\tIForcedPriceFeed public forcedPriceFeed = IForcedPriceFeed(address(0x3B0Eb37f26b502bAe83df4eCc54afBDfb90B5d3a));\n\n\t// The DAO contract can provide us with all other contract addresses in the protocol\n\tIDAO public dao = IDAO(address(0x112223db8E32d056170da32FD3Dba90adCa50159));\n\n\tIExchangeConfig public exchangeConfig = IExchangeConfig(getContract(address(dao), \"exchangeConfig()\" ));\n\tIPoolsConfig public poolsConfig = IPoolsConfig(getContract(address(dao), \"poolsConfig()\" ));\n\tIStakingConfig public stakingConfig = IStakingConfig(getContract(address(dao), \"stakingConfig()\" ));\n\tIStableConfig public stableConfig = IStableConfig(getContract(address(dao), \"stableConfig()\" ));\n\tIRewardsConfig public rewardsConfig = IRewardsConfig(getContract(address(dao), \"rewardsConfig()\" ));\n\tIDAOConfig public daoConfig = IDAOConfig(getContract(address(dao), \"daoConfig()\" ));\n\tIPriceAggregator public priceAggregator = IPriceAggregator(getContract(address(dao), \"priceAggregator()\" ));\n\n\tIManagedWallet public managedTeamWallet = exchangeConfig.managedTeamWallet();\n\taddress public teamWallet = managedTeamWallet.mainWallet();\n\taddress public teamConfirmationWallet = managedTeamWallet.confirmationWallet();\n\n\tIUpkeep public upkeep = exchangeConfig.upkeep();\n\tIEmissions public emissions = IEmissions(getContract(address(upkeep), \"emissions()\" ));\n\n\tISalt public salt = exchangeConfig.salt();\n    IERC20 public wbtc = exchangeConfig.wbtc();\n    IERC20 public weth = exchangeConfig.weth();\n    IERC20 public dai = exchangeConfig.dai();\n    USDS public usds = USDS(address(exchangeConfig.usds()));\n\n\tISaltRewards public saltRewards = ISaltRewards(getContract(address(upkeep), \"saltRewards()\" ));\n\tIRewardsEmitter public stakingRewardsEmitter = IRewardsEmitter(getContract(address(saltRewards), \"stakingRewardsEmitter()\" ));\n\tIRewardsEmitter public liquidityRewardsEmitter = IRewardsEmitter(getContract(address(saltRewards), \"liquidityRewardsEmitter()\" ));\n\n\tIStaking public staking = IStaking(getContract(address(stakingRewardsEmitter), \"stakingRewards()\" ));\n\tICollateralAndLiquidity public collateralAndLiquidity = ICollateralAndLiquidity(getContract(address(usds), \"collateralAndLiquidity()\" ));\n\tILiquidizer  public liquidizer = ILiquidizer( getContract(address(collateralAndLiquidity), \"liquidizer()\" ));\n\tIPools public pools = IPools(getContract(address(collateralAndLiquidity), \"pools()\" ));\n\n\tIProposals public proposals = IProposals(getContract(address(dao), \"proposals()\" ));\n\n\tIAccessManager public accessManager = exchangeConfig.accessManager();\n\n\tVestingWallet public daoVestingWallet = VestingWallet(payable(exchangeConfig.daoVestingWallet()));\n\tVestingWallet public teamVestingWallet = VestingWallet(payable(exchangeConfig.teamVestingWallet()));\n\n\tIInitialDistribution public initialDistribution = exchangeConfig.initialDistribution();\n\tIAirdrop public airdrop = IAirdrop(getContract(address(initialDistribution), \"airdrop()\" ));\n\tIBootstrapBallot public bootstrapBallot = IBootstrapBallot(getContract(address(initialDistribution), \"bootstrapBallot()\" ));\n\n\t// Access signatures\n\tbytes aliceAccessSignature = hex\"a34525874e8d962ca56353ee341719744ce31cb7558e2fbcfe25edb82924bf93460bf47d787dd6ca17382424919cdfa2a525f762ad8eac7292f56be6053c461d1b\";\n\tbytes bobAccessSignature = hex\"8df147d8434c21eec85c39a7372de1c49c4d9a031089d74034aa6baeed9c5b9e0d8234d966956bc92cba35e9e527f97ddd952e3125bf48da306fdc800349480f1b\";\n\tbytes charlieAccessSignature = hex\"8e2f4b7ee253a53ae9167de5182f612cd3b3b76566c34a448d6544d1bbeda6c574e5c98da44df387766a6c936e041d813ced8af26cff2ead588d13466d3217951c\";\n\tbytes deployerAccessSignature = hex\"94b8d45a45a9e6c48a1f110a1371c6f36e8638b8faaa0785af1254c52e51db656c4367ef191327b59334a228db8cbaaa892d4ee7c332fcd59378082a640190211c\";\n\tbytes defaultAccessSignature = hex\"c05e8d92e0cc66ddce0c88a1b49335866a2af521add73bbf904cd76db9a7934a0ee49f6f60f4ba90cf8fe44564b8fc3a1314625639518d3ba82317dc3d8363f11c\";\n\tbytes teamAccessSignature = hex\"a6980de89b6a0696affae222317f5317438b5c3823ce18cace5d9078bbf7b17c45a71cc823149a1c478d6503ed869dd4d6f6c33acd6d08a9518e12a7f82e781b1b\";\n\tbytes oneTwoThreeFourAccessSignature = hex\"1c4f137653c4d06e5e0230b4e741667037b44bc944d9165884f914163a0da6d6480705db5584bbbf28e42e783ec2cbfbb4e3602c4f7eb55cce68184b114818121c\";\n\n\tbytes aliceAccessSignature1 = hex\"4fbe3e8f1daba07f674f831ccfae103f2b172b547f51826e1b4673962d8ca2e14170e1fb2793ca5ef12a067db6a99ae1891cb8e1e7f7c70872bb442ce6df6b051c\";\n\tbytes bobAccessSignature1 = hex\"6cd08533c08306735cb435c8b3ef43f3307b8083f679e0b60728e3a8de243e7f3af8b5e81fd156a726702a5c9e232fb027420b2ccdb848a1d7fd0ede4ae1e47c1c\";\n\tbytes charlieAccessSignature1 = hex\"4c0901d584be8b570a8a03a2c4bdd60ac3339c4bef4b27d9bc292d1eaeaed02b30b65c69f42ec2404dd420c1bf9cb16bf44875258e385c004dd67eecc726e8811b\";\n\n\t// Voting signatures\n\tbytes aliceVotingSignature = hex\"291f777bcf554105b4067f14d2bb3da27f778af49fe2f008e718328a91cae2f81eceb0b4ed1d65c546bf0603c6c35567a69c8cb371cf4880a2964df8f6d1c0601c\";\n\tbytes bobVotingSignature = hex\"a08a0612b60d9c911d357664de578cd8e17c5f0ee10b82b829e35a999fa3f5e11a33e5f3d06c6b2b6f3ef3066cee3b47285a57cfc85f2c3e166f831a285aebcd1c\";\n\tbytes charlieVotingSignature = hex\"7fec06ab9da26790e4520b4476b7043ef8444178ec10cdf37942a229290ec70d01c7dced0a6e22080239df6fdc3983f515f52d06a32c03d5d6a0077f31fd9f841c\";\n\n\n\tfunction getContract( address _contract, string memory _functionName ) public returns (address result) {\n\t\tbytes4 FUNC_SELECTOR = bytes4(keccak256( bytes(_functionName) ));\n\n\t\tbytes memory data = abi.encodeWithSelector(FUNC_SELECTOR );\n\n\t\tuint256 remainingGas = gasleft();\n\n\t\tbool success;\n\t\tbytes memory output = new bytes(32);  // Initialize an output buffer\n\n\t\tassembly {\n\t\t\tsuccess := call(\n\t\t\t\tremainingGas,            // gas remaining\n\t\t\t\t_contract,               // destination address\n\t\t\t\t0,                       // no ether\n\t\t\t\tadd(data, 32),           // input buffer (starts after the first 32 bytes in the `data` array)\n\t\t\t\tmload(data),             // input length (loaded from the first 32 bytes in the `data` array)\n\t\t\t\tadd(output, 32),         // output buffer\n\t\t\t\t32                       // output length is 32 bytes because address is 20 bytes\n\t\t\t)\n\t\t}\n\n\t\trequire(success, \"External call failed\");\n\n\t\t// Cast bytes to address\n\t\tresult = abi.decode(output, (address));\n\t\t}\n\n\n\tfunction initializeContracts() public\n\t\t{\n//\t\tconsole.log( \"DEFAULT: \", address(this) );\n\n\t\tvm.startPrank(DEPLOYER);\n\t\tdai = new TestERC20(\"DAI\", 18);\n\t\tweth = new TestERC20(\"WETH\", 18);\n\t\twbtc = new TestERC20(\"WBTC\", 8);\n\t\tsalt = new Salt();\n\t\tvm.stopPrank();\n\n\t\tvm.startPrank(DEPLOYER);\n\n\t\tdaoConfig = new DAOConfig();\n\t\tpoolsConfig = new PoolsConfig();\n\t\tusds = new USDS();\n\n\t\tmanagedTeamWallet = new ManagedWallet(teamWallet, teamConfirmationWallet);\n\t\texchangeConfig = new ExchangeConfig(salt, wbtc, weth, dai, usds, managedTeamWallet );\n\n\t\tpriceAggregator = new PriceAggregator();\n\t\tpriceAggregator.setInitialFeeds( IPriceFeed(address(forcedPriceFeed)), IPriceFeed(address(forcedPriceFeed)), IPriceFeed(address(forcedPriceFeed)) );\n\n\t\tliquidizer = new Liquidizer(exchangeConfig, poolsConfig);\n\n\t\tpools = new Pools(exchangeConfig, poolsConfig);\n\t\tstaking = new Staking( exchangeConfig, poolsConfig, stakingConfig );\n\t\tcollateralAndLiquidity = new CollateralAndLiquidity(pools, exchangeConfig, poolsConfig, stakingConfig, stableConfig, priceAggregator, liquidizer);\n\n\t\tstakingRewardsEmitter = new RewardsEmitter( staking, exchangeConfig, poolsConfig, rewardsConfig, false );\n\t\tliquidityRewardsEmitter = new RewardsEmitter( collateralAndLiquidity, exchangeConfig, poolsConfig, rewardsConfig, true );\n\n\t\tsaltRewards = new SaltRewards(stakingRewardsEmitter, liquidityRewardsEmitter, exchangeConfig, rewardsConfig);\n\t\temissions = new Emissions( saltRewards, exchangeConfig, rewardsConfig );\n\n\t\tpoolsConfig.whitelistPool( pools,  salt, wbtc);\n\t\tpoolsConfig.whitelistPool( pools,  salt, weth);\n\t\tpoolsConfig.whitelistPool( pools,  salt, usds);\n\t\tpoolsConfig.whitelistPool( pools,  wbtc, usds);\n\t\tpoolsConfig.whitelistPool( pools,  weth, usds);\n\t\tpoolsConfig.whitelistPool( pools,  wbtc, dai);\n\t\tpoolsConfig.whitelistPool( pools,  weth, dai);\n\t\tpoolsConfig.whitelistPool( pools,  usds, dai);\n\t\tpoolsConfig.whitelistPool( pools,  wbtc, weth);\n\n\t\tproposals = new Proposals( staking, exchangeConfig, poolsConfig, daoConfig );\n\n\t\taddress oldDAO = address(dao);\n\t\tdao = new DAO( pools, proposals, exchangeConfig, poolsConfig, stakingConfig, rewardsConfig, stableConfig, daoConfig, priceAggregator, liquidityRewardsEmitter, collateralAndLiquidity);\n\n\t\tairdrop = new Airdrop(exchangeConfig, staking);\n\n\t\taccessManager = new AccessManager(dao);\n\n\t\tliquidizer.setContracts(collateralAndLiquidity, pools, dao);\n\n\t\tupkeep = new Upkeep(pools, exchangeConfig, poolsConfig, daoConfig, stableConfig, priceAggregator, saltRewards, collateralAndLiquidity, emissions, dao);\n\n\t\tdaoVestingWallet = new VestingWallet( address(dao), uint64(block.timestamp), 60 * 60 * 24 * 365 * 10 );\n\t\tteamVestingWallet = new VestingWallet( address(upkeep), uint64(block.timestamp), 60 * 60 * 24 * 365 * 10 );\n\n\t\tbootstrapBallot = new BootstrapBallot(exchangeConfig, airdrop, 60 * 60 * 24 * 5 );\n\t\tinitialDistribution = new InitialDistribution(salt, poolsConfig, emissions, bootstrapBallot, dao, daoVestingWallet, teamVestingWallet, airdrop, saltRewards, collateralAndLiquidity);\n\n\t\tpools.setContracts(dao, collateralAndLiquidity);\n\t\tusds.setCollateralAndLiquidity(collateralAndLiquidity);\n\n\t\texchangeConfig.setContracts(dao, upkeep, initialDistribution, airdrop, teamVestingWallet, daoVestingWallet );\n\t\texchangeConfig.setAccessManager(accessManager);\n\n\t\t// Transfer ownership of the newly created config files to the DAO\n\t\tOwnable(address(exchangeConfig)).transferOwnership( address(dao) );\n\t\tOwnable(address(poolsConfig)).transferOwnership( address(dao) );\n\t\tOwnable(address(priceAggregator)).transferOwnership(address(dao));\n\t\tOwnable(address(daoConfig)).transferOwnership( address(dao) );\n\t\tvm.stopPrank();\n\n\t\tvm.startPrank(address(oldDAO));\n\t\tOwnable(address(stakingConfig)).transferOwnership( address(dao) );\n\t\tOwnable(address(rewardsConfig)).transferOwnership( address(dao) );\n\t\tOwnable(address(stableConfig)).transferOwnership( address(dao) );\n\t\tvm.stopPrank();\n\n\t\t// Move the SALT to the new initialDistribution contract\n\t\tvm.prank(DEPLOYER);\n\t\tsalt.transfer(address(initialDistribution), 100000000 ether);\n\t\t}\n\n\n\tfunction grantAccessAlice() public\n\t\t{\n\t\tbytes memory sig = abi.encodePacked(aliceAccessSignature);\n\n\t\tvm.prank( address(0x1111) );\n\t\taccessManager.grantAccess(sig);\n\t\t}\n\n\n\tfunction grantAccessBob() public\n\t\t{\n\t\tbytes memory sig = abi.encodePacked(bobAccessSignature);\n\n\t\tvm.prank( address(0x2222) );\n\t\taccessManager.grantAccess(sig);\n\t\t}\n\n\n\tfunction grantAccessCharlie() public\n\t\t{\n\t\tbytes memory sig = abi.encodePacked(charlieAccessSignature);\n\n\t\tvm.prank( address(0x3333) );\n\t\taccessManager.grantAccess(sig);\n\t\t}\n\n\n\tfunction grantAccessDeployer() public\n\t\t{\n\t\tbytes memory sig = abi.encodePacked(deployerAccessSignature);\n\n\t\tvm.prank( 0x73107dA86708c2DAd0D91388fB057EeE3E2581aF );\n\t\taccessManager.grantAccess(sig);\n\t\t}\n\n\n\tfunction grantAccessDefault() public\n\t\t{\n\t\tbytes memory sig = abi.encodePacked(defaultAccessSignature);\n\n\t\tvm.prank( 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496 );\n\t\taccessManager.grantAccess(sig);\n\t\t}\n\n\n\tfunction grantAccessTeam() public\n\t\t{\n\t\tbytes memory sig = abi.encodePacked(teamAccessSignature);\n\n\t\tvm.prank( address(0x123456789 ));\n\t\taccessManager.grantAccess(sig);\n\t\t}\n\n\n\n\n\n\tfunction whitelistAlice() public\n\t\t{\n\t\tvm.prank( address(bootstrapBallot) );\n\t\tairdrop.authorizeWallet(address(0x1111));\n\t\t}\n\n\n\tfunction whitelistBob() public\n\t\t{\n\t\tvm.prank( address(bootstrapBallot) );\n\t\tairdrop.authorizeWallet(address(0x2222));\n\t\t}\n\n\n\tfunction whitelistCharlie() public\n\t\t{\n\t\tvm.prank( address(bootstrapBallot) );\n\t\tairdrop.authorizeWallet(address(0x3333));\n\t\t}\n\n\n\tfunction whitelistTeam() public\n\t\t{\n\t\tvm.prank( address(bootstrapBallot) );\n\t\tairdrop.authorizeWallet(address(0x123456789));\n\t\t}\n\n\n\tfunction finalizeBootstrap() public\n\t\t{\n\t\taddress alice = address(0x1111);\n\t\taddress bob = address(0x2222);\n\n\t\twhitelistAlice();\n\t\twhitelistBob();\n\n\t\tbytes memory sig = abi.encodePacked(aliceVotingSignature);\n\t\tvm.startPrank(alice);\n\t\tbootstrapBallot.vote(true, sig);\n\t\tvm.stopPrank();\n\n\t\tsig = abi.encodePacked(bobVotingSignature);\n\t\tvm.startPrank(bob);\n\t\tbootstrapBallot.vote(true, sig);\n\t\tvm.stopPrank();\n\n\t\t// Increase current blocktime to be greater than completionTimestamp\n\t\tvm.warp( bootstrapBallot.completionTimestamp() + 1);\n\n\t\t// Call finalizeBallot()\n\t\tbootstrapBallot.finalizeBallot();\n\t\t}\n\t}"
    },
    {
      "filename": "src/Upkeep.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/finance/VestingWallet.sol\";\nimport \"./price_feed/interfaces/IPriceAggregator.sol\";\nimport \"./stable/interfaces/IStableConfig.sol\";\nimport \"./rewards/interfaces/IEmissions.sol\";\nimport \"./pools/interfaces/IPoolsConfig.sol\";\nimport \"./interfaces/IExchangeConfig.sol\";\nimport \"./dao/interfaces/IDAOConfig.sol\";\nimport \"./pools/interfaces/IPools.sol\";\nimport \"./dao/interfaces/IDAO.sol\";\n\n\n// Performs the following upkeep for each call to performUpkeep():\n// (Uses a maximum of 2.3 million gas with 100 whitelisted pools according to UpkeepGasUsage.t.sol)\n\n// 1. Swaps tokens previously sent to the Liquidizer contract for USDS and burns specified amounts of USDS.\n\n// 2. Withdraws existing WETH arbitrage profits from the Pools contract and rewards the caller of performUpkeep() with default 5% of the withdrawn amount.\n// 3. Converts a default 5% of the remaining WETH to USDS/DAI Protocol Owned Liquidity.\n// 4. Converts a default 20% of the remaining WETH to SALT/USDS Protocol Owned Liquidity.\n// 5. Converts remaining WETH to SALT and sends it to SaltRewards.\n\n// 6. Sends SALT Emissions to the SaltRewards contract.\n// 7. Distributes SALT from SaltRewards to the stakingRewardsEmitter and liquidityRewardsEmitter.\n// 8. Distributes SALT rewards from the stakingRewardsEmitter and liquidityRewardsEmitter.\n\n// 9. Collects SALT rewards from the DAO's Protocol Owned Liquidity (SALT/USDS from formed POL), sends 10% to the initial dev team and burns a default 50% of the remaining - the rest stays in the DAO.\n// 10. Sends SALT from the DAO vesting wallet to the DAO (linear distribution over 10 years).\n// 11. Sends SALT from the team vesting wallet to the team (linear distribution over 10 years).\n\n// WETH arbitrage profits are converted directly via depositSwapWithdraw - as performUpkeep is called often and the generated arbitrage profits should be manageable compared to the size of the reserves.\n// Additionally, simulations show that the impact from sandwich attacks on swap transactions (even without specifying slippage) is limited due to the atomic arbitrage process.\n// See PoolUtils.__placeInternalSwap and Sandwich.t.sol for more details.\n\ncontract Upkeep is IUpkeep, ReentrancyGuard\n    {\n\tusing SafeERC20 for ISalt;\n\tusing SafeERC20 for IUSDS;\n\tusing SafeERC20 for IERC20;\n\n    event UpkeepError(string description, bytes error);\n\n\tIPools immutable public pools;\n\tIExchangeConfig  immutable public exchangeConfig;\n\tIPoolsConfig immutable public poolsConfig;\n\tIDAOConfig immutable public daoConfig;\n\tIStableConfig immutable public stableConfig;\n\tIPriceAggregator immutable public priceAggregator;\n\tISaltRewards immutable public saltRewards;\n\tICollateralAndLiquidity immutable public collateralAndLiquidity;\n\tIEmissions immutable public emissions;\n\tIDAO immutable public dao;\n\n\tIERC20  immutable public weth;\n\tISalt  immutable public salt;\n\tIUSDS  immutable public usds;\n\tIERC20  immutable public dai;\n\n\tuint256 public lastUpkeepTimeEmissions;\n\tuint256 public lastUpkeepTimeRewardsEmitters;\n\n\n    constructor( IPools _pools, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IDAOConfig _daoConfig, IStableConfig _stableConfig, IPriceAggregator _priceAggregator, ISaltRewards _saltRewards, ICollateralAndLiquidity _collateralAndLiquidity, IEmissions _emissions, IDAO _dao )\n\t\t{\n\t\tpools = _pools;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\tdaoConfig = _daoConfig;\n\t\tstableConfig = _stableConfig;\n\t\tpriceAggregator = _priceAggregator;\n\t\tsaltRewards = _saltRewards;\n\t\tcollateralAndLiquidity = _collateralAndLiquidity;\n\t\temissions = _emissions;\n\t\tdao = _dao;\n\n\t\t// Cached for efficiency\n\t\tweth = _exchangeConfig.weth();\n\t\tsalt = _exchangeConfig.salt();\n\t\tusds = _exchangeConfig.usds();\n\t\tdai = _exchangeConfig.dai();\n\n\t\tlastUpkeepTimeEmissions = block.timestamp;\n\t\tlastUpkeepTimeRewardsEmitters = block.timestamp;\n\n\t\t// Approve for future WETH swaps.\n\t\t// This contract only has a temporary WETH balance within the performUpkeep() function itself.\n\t\tweth.approve( address(pools), type(uint256).max );\n\t\t}\n\n\n\tmodifier onlySameContract()\n\t\t{\n    \trequire(msg.sender == address(this), \"Only callable from within the same contract\");\n    \t_;\n\t\t}\n\n\n\t// Note - while the following steps are public so that they can be wrapped in a try/catch, they are all still only callable from this same contract.\n\n\t// 1. Swap tokens previously sent to the Liquidizer contract for USDS and burn specified amounts of USDS.\n\tfunction step1() public onlySameContract\n\t\t{\n\t\tcollateralAndLiquidity.liquidizer().performUpkeep();\n\t\t}\n\n\n\t// 2. Withdraw existing WETH arbitrage profits from the Pools contract and reward the caller of performUpkeep() with default 5% of the withdrawn amount.\n\tfunction step2(address receiver) public onlySameContract\n\t\t{\n\t\tuint256 withdrawnAmount = exchangeConfig.dao().withdrawArbitrageProfits(weth);\n\t\tif ( withdrawnAmount == 0 )\n\t\t\treturn;\n\n\t\t// Default 5% of the arbitrage profits for the caller of performUpkeep()\n\t\tuint256 rewardAmount = withdrawnAmount * daoConfig.upkeepRewardPercent() / 100;\n\n\t\t// Send the reward\n\t\tweth.safeTransfer(receiver, rewardAmount);\n\t\t}\n\n\n\t// Have the DAO form the specified Protocol Owned Liquidity with the given amount of WETH\n\tfunction _formPOL( IERC20 tokenA, IERC20 tokenB, uint256 amountWETH) internal\n\t\t{\n\t\tuint256 wethAmountPerToken = amountWETH >> 1;\n\n\t\t// Swap WETH for the specified tokens\n\t\tuint256 amountA = pools.depositSwapWithdraw( weth, tokenA, wethAmountPerToken, 0, block.timestamp );\n\t\tuint256 amountB = pools.depositSwapWithdraw( weth, tokenB, wethAmountPerToken, 0, block.timestamp );\n\n\t\t// Transfer the tokens to the DAO\n\t\ttokenA.safeTransfer( address(dao), amountA );\n\t\ttokenB.safeTransfer( address(dao), amountB );\n\n\t\t// Have the DAO form POL\n\t\tdao.formPOL(tokenA, tokenB, amountA, amountB);\n\t\t}\n\n\n\t// 3. Convert a default 5% of the remaining WETH to USDS/DAI Protocol Owned Liquidity.\n\tfunction step3() public onlySameContract\n\t\t{\n\t\tuint256 wethBalance = weth.balanceOf( address(this) );\n\t\tif ( wethBalance == 0 )\n\t\t\treturn;\n\n\t\t// A default 5% of the remaining WETH will be swapped for USDS/DAI POL.\n\t\tuint256 amountOfWETH = wethBalance * stableConfig.percentArbitrageProfitsForStablePOL() / 100;\n\t\t_formPOL(usds, dai, amountOfWETH);\n\t\t}\n\n\n\t// 4. Convert a default 20% of the remaining WETH to SALT/USDS Protocol Owned Liquidity.\n\tfunction step4() public onlySameContract\n\t\t{\n\t\tuint256 wethBalance = weth.balanceOf( address(this) );\n\t\tif ( wethBalance == 0 )\n\t\t\treturn;\n\n\t\t// A default 20% of the remaining WETH will be swapped for SALT/USDS POL.\n\t\tuint256 amountOfWETH = wethBalance * daoConfig.arbitrageProfitsPercentPOL() / 100;\n\t\t_formPOL(salt, usds, amountOfWETH);\n\t\t}\n\n\n\t// 5. Convert remaining WETH to SALT and sends it to SaltRewards.\n\tfunction step5() public onlySameContract\n\t\t{\n\t\tuint256 wethBalance = weth.balanceOf( address(this) );\n\t\tif ( wethBalance == 0 )\n\t\t\treturn;\n\n\t\t// Convert remaining WETH to SALT and send it to SaltRewards\n\t\tuint256 amountSALT = pools.depositSwapWithdraw( weth, salt, wethBalance, 0, block.timestamp );\n\t\tsalt.safeTransfer(address(saltRewards), amountSALT);\n\t\t}\n\n\n\t// 6. Send SALT Emissions to the SaltRewards contract.\n\tfunction step6() public onlySameContract\n\t\t{\n\t\tuint256 timeSinceLastUpkeep = block.timestamp - lastUpkeepTimeEmissions;\n\t\temissions.performUpkeep(timeSinceLastUpkeep);\n\n\t\tlastUpkeepTimeEmissions = block.timestamp;\n\t\t}\n\n\n\t// 7. Distribute SALT from SaltRewards to the stakingRewardsEmitter and liquidityRewardsEmitter.\n\tfunction step7() public onlySameContract\n\t\t{\n\t\tuint256[] memory profitsForPools = pools.profitsForWhitelistedPools();\n\n\t\tbytes32[] memory poolIDs = poolsConfig.whitelistedPools();\n\t\tsaltRewards.performUpkeep(poolIDs, profitsForPools );\n\t\tpools.clearProfitsForPools();\n\t\t}\n\n\n\t// 8. Distribute SALT rewards from the stakingRewardsEmitter and liquidityRewardsEmitter.\n\tfunction step8() public onlySameContract\n\t\t{\n\t\tuint256 timeSinceLastUpkeep = block.timestamp - lastUpkeepTimeRewardsEmitters;\n\n\t\tsaltRewards.stakingRewardsEmitter().performUpkeep(timeSinceLastUpkeep);\n\t\tsaltRewards.liquidityRewardsEmitter().performUpkeep(timeSinceLastUpkeep);\n\n\t\tlastUpkeepTimeRewardsEmitters = block.timestamp;\n\t\t}\n\n\n\t// 9. Collect SALT rewards from the DAO's Protocol Owned Liquidity (SALT/USDS from formed POL), send 10% to the initial dev team and burn a default 50% of the remaining - the rest stays in the DAO.\n\tfunction step9() public onlySameContract\n\t\t{\n\t\tdao.processRewardsFromPOL();\n\t\t}\n\n\n\t// 10. Send SALT from the DAO vesting wallet to the DAO (linear distribution over 10 years).\n\tfunction step10() public onlySameContract\n\t\t{\n\t\tVestingWallet(payable(exchangeConfig.daoVestingWallet())).release(address(salt));\n\t\t}\n\n\n\t// 11. Sends SALT from the team vesting wallet to the team (linear distribution over 10 years).\n\tfunction step11() public onlySameContract\n\t\t{\n\t\tuint256 releaseableAmount = VestingWallet(payable(exchangeConfig.teamVestingWallet())).releasable(address(salt));\n\n\t\t// teamVestingWallet actually sends the vested SALT to this contract - which will then need to be sent to the active teamWallet\n\t\tVestingWallet(payable(exchangeConfig.teamVestingWallet())).release(address(salt));\n\n\t\tsalt.safeTransfer( exchangeConfig.managedTeamWallet().mainWallet(), releaseableAmount );\n\t\t}\n\n\n\t// Perform the various steps of performUpkeep as outlined at the top of the contract.\n\t// Each step is wrapped in a try/catch to prevent reversions from cascading through the performUpkeep.\n\tfunction performUpkeep() public nonReentrant\n\t\t{\n\t\t// Perform the multiple steps of performUpkeep()\n \t\ttry this.step1() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 1\", error); }\n\n \t\ttry this.step2(msg.sender) {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 2\", error); }\n\n \t\ttry this.step3() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 3\", error); }\n\n \t\ttry this.step4() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 4\", error); }\n\n \t\ttry this.step5() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 5\", error); }\n\n \t\ttry this.step6() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 6\", error); }\n\n \t\ttry this.step7() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 7\", error); }\n\n \t\ttry this.step8() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 8\", error); }\n\n \t\ttry this.step9() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 9\", error); }\n\n \t\ttry this.step10() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 10\", error); }\n\n \t\ttry this.step11() {}\n\t\tcatch (bytes memory error) { emit UpkeepError(\"Step 11\", error); }\n\t\t}\n\n\n\t// ==== VIEWS ====\n\t// Returns the amount of WETH that will currently be rewarded for calling performUpkeep().\n\t// Useful for potential callers to know if calling the function will be profitable in comparison to current gas costs.\n\tfunction currentRewardsForCallingPerformUpkeep() public view returns (uint256)\n\t\t{\n\t\tuint256 daoWETH = pools.depositedUserBalance( address(dao), weth );\n\n\t\treturn daoWETH * daoConfig.upkeepRewardPercent() / 100;\n\t\t}\n\t}"
    },
    {
      "filename": "src/dev/Deployment.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"forge-std/Test.sol\";\nimport \"../pools/interfaces/IPools.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"../stable/USDS.sol\";\nimport \"../stable/interfaces/IStableConfig.sol\";\nimport \"../price_feed/interfaces/IPriceAggregator.sol\";\nimport \"../staking/interfaces/IStakingConfig.sol\";\nimport \"../staking/interfaces/IStaking.sol\";\nimport \"../staking/Staking.sol\";\nimport \"../rewards/interfaces/IRewardsEmitter.sol\";\nimport \"../rewards/Emissions.sol\";\nimport \"../dao/interfaces/IDAOConfig.sol\";\nimport \"../dao/interfaces/IDAO.sol\";\nimport \"../dao/interfaces/IProposals.sol\";\nimport \"../price_feed/tests/IForcedPriceFeed.sol\";\nimport \"../launch/interfaces/IBootstrapBallot.sol\";\nimport \"openzeppelin-contracts/contracts/finance/VestingWallet.sol\";\nimport \"../launch/interfaces/IAirdrop.sol\";\nimport \"../dao/Proposals.sol\";\nimport \"../dao/DAO.sol\";\nimport \"../AccessManager.sol\";\nimport \"../rewards/SaltRewards.sol\";\nimport \"../launch/InitialDistribution.sol\";\nimport \"../pools/PoolsConfig.sol\";\nimport \"../ExchangeConfig.sol\";\nimport \"../price_feed/PriceAggregator.sol\";\nimport \"../pools/Pools.sol\";\nimport \"../staking/Liquidity.sol\";\nimport \"../stable/CollateralAndLiquidity.sol\";\nimport \"../rewards/RewardsEmitter.sol\";\nimport \"../root_tests/TestERC20.sol\";\nimport \"../launch/Airdrop.sol\";\nimport \"../launch/BootstrapBallot.sol\";\nimport \"../stable/interfaces/ILiquidizer.sol\";\nimport \"../stable/Liquidizer.sol\";\nimport \"../stable/StableConfig.sol\";\nimport \"../Salt.sol\";\nimport \"../ManagedWallet.sol\";\nimport \"../dao/DAOConfig.sol\";\n\n// Stores the contract addresses for the various parts of the exchange and allows the unit tests to be run on them.\n\ncontract Deployment is Test\n    {\n    bool public DEBUG = true;\n\taddress constant public DEPLOYER = 0x73107dA86708c2DAd0D91388fB057EeE3E2581aF;\n\n\t// Test addresses on Sepolia for the Price Feeds\n\taddress public CHAINLINK_BTC_USD = 0x65EC417a4C95d6FE6FB11EBFa86FAFEaE2B3bE2F;\n\taddress public CHAINLINK_ETH_USD = 0x694AA1769357215DE4FAC081bf1f309aDC325306;\n\taddress public UNISWAP_V3_BTC_ETH = 0xFb9785B2CA67AF31087945BCCd02D00768208e38;\n\taddress public UNISWAP_V3_USDC_ETH = 0x3EcF4D43d1C7EC1A609d554BAb2565b223831349;\n\tIERC20 public _testBTC = IERC20(0xd4C3cc58E46C99fbA0c4e4d93C82AE32000cc4D4);\n\tIERC20 public _testETH = IERC20(0x14edfAb9FAE5fe2396565903763Cb29E0d7be7d9);\n\tIERC20 public _testUSDC = IERC20(0x9C65b1773A95d607f41fa205511cd3327cc39D9D);\n\tIForcedPriceFeed public forcedPriceFeed = IForcedPriceFeed(address(0x3B0Eb37f26b502bAe83df4eCc54afBDfb90B5d3a));\n\n\t// The DAO contract can provide us with all other contract addresses in the protocol\n\tIDAO public dao = IDAO(address(0x112223db8E32d056170da32FD3Dba90adCa50159));\n\n\tIExchangeConfig public exchangeConfig = IExchangeConfig(getContract(address(dao), \"exchangeConfig()\" ));\n\tIPoolsConfig public poolsConfig = IPoolsConfig(getContract(address(dao), \"poolsConfig()\" ));\n\tIStakingConfig public stakingConfig = IStakingConfig(getContract(address(dao), \"stakingConfig()\" ));\n\tIStableConfig public stableConfig = IStableConfig(getContract(address(dao), \"stableConfig()\" ));\n\tIRewardsConfig public rewardsConfig = IRewardsConfig(getContract(address(dao), \"rewardsConfig()\" ))"
    }
  ]
}