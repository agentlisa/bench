{
  "Title": "ProposalDeleted events can be emitted with non-existent assertionId",
  "Content": "The `OptimisticGovernor` contract's [`assertionDisputedCallback`](https://github.com/UMAprotocol/protocol/blob/3687d9b3a80ca9b3694211d50a2ccad5415c77e1/packages/core/contracts/gnosis-zodiac/implementation/OptimisticGovernor.sol#L360) function does not validate whether its `assertionId` argument is valid (i.e., whether it is associated with a proposal). This allows a `ProposalDeleted` event [to be emitted](https://github.com/UMAprotocol/protocol/blob/3687d9b3a80ca9b3694211d50a2ccad5415c77e1/packages/core/contracts/gnosis-zodiac/implementation/OptimisticGovernor.sol#L374) for any `assertionId` value, not just values that correspond to actual proposals.\n\n\nA user can accomplish this by interacting with the `OptimisticOracleV3` contract. The `OptimisticOracleV3` contract's [`assertTruth`](https://github.com/UMAprotocol/protocol/blob/3687d9b3a80ca9b3694211d50a2ccad5415c77e1/packages/core/contracts/optimistic-oracle-v3/implementation/OptimisticOracleV3.sol#L138) function may be called by any user to assert truths that will be accepted as true unless disputed. This will result in the generation of a new [`assertionId`](https://github.com/UMAprotocol/protocol/blob/3687d9b3a80ca9b3694211d50a2ccad5415c77e1/packages/core/contracts/optimistic-oracle-v3/implementation/OptimisticOracleV3.sol#L150) that will be stored in the oracle's [`assertions`](https://github.com/UMAprotocol/protocol/blob/3687d9b3a80ca9b3694211d50a2ccad5415c77e1/packages/core/contracts/optimistic-oracle-v3/implementation/OptimisticOracleV3.sol#L158) mapping.\n\n\nIf `assertTruth` is called with the `callbackRecipient` set to zero and the `escalationManager` set to the `OptimisticGovernor` address, a subsequent call to [`disputeAssertion`](https://github.com/UMAprotocol/protocol/blob/3687d9b3a80ca9b3694211d50a2ccad5415c77e1/packages/core/contracts/optimistic-oracle-v3/implementation/OptimisticOracleV3.sol#L220) will call `_callbackOnAssertionDispute`, which in turn will [call](https://github.com/UMAprotocol/protocol/blob/3687d9b3a80ca9b3694211d50a2ccad5415c77e1/packages/core/contracts/optimistic-oracle-v3/implementation/OptimisticOracleV3.sol#L500) the `OptimisticGovernor` contract's `assertionDisputedCallback` function, passing the disputed `assertionId`, which exists in the `assertions` mapping of the oracle, but not in the `proposalHashes` mapping of the `OptimisticGovernor`. Regardless, the `assertionId` value is not checked and execution will enter the `if` condition on [line 369](https://github.com/UMAprotocol/protocol/blob/3687d9b3a80ca9b3694211d50a2ccad5415c77e1/packages/core/contracts/gnosis-zodiac/implementation/OptimisticGovernor.sol#L369) because the caller is the `OptimisticOracle`, and ultimately on [line 374](https://github.com/UMAprotocol/protocol/blob/3687d9b3a80ca9b3694211d50a2ccad5415c77e1/packages/core/contracts/gnosis-zodiac/implementation/OptimisticGovernor.sol#L374) the `ProposalDeleted` event will be emitted.\n\n\nConsider adding a check in the `assertionDisputedCallback` function that ensures the `assertionId` value maps to a non-zero `proposalHash`, which ensures the assertion is associated with a proposal.\n\n\n***Update:** Resolved in [pull request #4486](https://github.com/UMAprotocol/protocol/pull/4486) at commit [d880037](https://github.com/UMAprotocol/protocol/commit/d88003765b84e7e41513189f79db10cb1a96ffd8).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/gnosis-zodiac/implementation/OptimisticGovernor.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.6;\n\n// https://github.com/gnosis/zodiac/blob/master/contracts/core/Module.sol\nimport \"@gnosis.pm/zodiac/contracts/core/Module.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\n\nimport \"../../optimistic-oracle-v3/implementation/ClaimData.sol\";\nimport \"../../optimistic-oracle-v3/interfaces/OptimisticOracleV3Interface.sol\";\nimport \"../../optimistic-oracle-v3/interfaces/OptimisticOracleV3CallbackRecipientInterface.sol\";\n\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/interfaces/AddressWhitelistInterface.sol\";\n\n/**\n * @title Optimistic Governor\n * @notice A contract that allows optimistic governance of a set of transactions. The contract can be used to propose\n * transactions that can be challenged by anyone. If the challenge is not resolved within a certain liveness period, the\n * transactions can be executed.\n */\ncontract OptimisticGovernor is OptimisticOracleV3CallbackRecipientInterface, Module, Lockable {\n    using SafeERC20 for IERC20;\n\n    event OptimisticGovernorDeployed(address indexed owner, address indexed avatar, address target);\n\n    event TransactionsProposed(\n        address indexed proposer,\n        uint256 indexed proposalTime,\n        bytes32 indexed assertionId,\n        Proposal proposal,\n        bytes32 proposalHash,\n        bytes explanation,\n        string rules,\n        uint256 challengeWindowEnds\n    );\n\n    event TransactionExecuted(\n        bytes32 indexed proposalHash,\n        bytes32 indexed assertionId,\n        uint256 indexed transactionIndex\n    );\n\n    event ProposalExecuted(bytes32 indexed proposalHash, bytes32 indexed assertionId);\n\n    event ProposalDeleted(bytes32 indexed proposalHash, bytes32 indexed assertionId);\n\n    event SetBond(IERC20 indexed collateral, uint256 indexed bondAmount);\n\n    event SetCollateral(IERC20 indexed collateral);\n\n    event SetRules(string rules);\n\n    event SetLiveness(uint64 indexed liveness);\n\n    event SetIdentifier(bytes32 indexed identifier);\n\n    event SetEscalationManager(address indexed escalationManager);\n\n    FinderInterface public immutable finder; // Finder used to discover other UMA ecosystem contracts.\n\n    IERC20 public collateral; // Collateral currency used to assert proposed transactions.\n    uint64 public liveness; // The amount of time to dispute proposed transactions before they can be executed.\n    uint256 public bondAmount; // Configured amount of collateral currency to make assertions for proposed transactions.\n    string public rules; // Rules for the Optimistic Governor.\n    bytes32 public identifier; // Identifier used to request price from the DVM, compatible with Optimistic Oracle V3.\n    OptimisticOracleV3Interface public optimisticOracleV3; // Optimistic Oracle V3 contract used to assert proposed transactions.\n    address public escalationManager; // Optional Escalation Manager contract to whitelist proposers / disputers.\n\n    // Keys for assertion claim data.\n    bytes public constant PROPOSAL_HASH_KEY = \"proposalHash\";\n    bytes public constant EXPLANATION_KEY = \"explanation\";\n    bytes public constant RULES_KEY = \"rules\";\n\n    // Struct for a proposed transaction.\n    struct Transaction {\n        address to; // The address to which the transaction is being sent.\n        Enum.Operation operation; // Operation type of transaction: 0 == call, 1 == delegate call.\n        uint256 value; // The value, in wei, to be sent with the transaction.\n        bytes data; // The data payload to be sent in the transaction.\n    }\n\n    // Struct for a proposed set of transactions, used only for off-chain infrastructure.\n    struct Proposal {\n        Transaction[] transactions;\n        uint256 requestTime;\n    }\n\n    mapping(bytes32 => bytes32) public proposalHashes; // Maps proposal hashes to assertionIds.\n    mapping(bytes32 => bytes32) public assertionIds; // Maps assertionIds to proposal hashes.\n\n    /**\n     * @notice Construct Optimistic Governor module.\n     * @param _finder Finder address.\n     * @param _owner Address of the owner.\n     * @param _collateral Address of the ERC20 collateral used for bonds.\n     * @param _bondAmount Amount of collateral currency to make assertions for proposed transactions\n     * @param _rules Reference to the rules for the Optimistic Governor.\n     * @param _identifier The approved identifier to be used with the contract, compatible with Optimistic Oracle V3.\n     * @param _liveness The period, in seconds, in which a proposal can be disputed.\n     */\n    constructor(\n        address _finder,\n        address _owner,\n        address _collateral,\n        uint256 _bondAmount,\n        string memory _rules,\n        bytes32 _identifier,\n        uint64 _liveness\n    ) {\n        bytes memory initializeParams = abi.encode(_owner, _collateral, _bondAmount, _rules, _identifier, _liveness);\n        require(_finder != address(0), \"Finder address can not be empty\");\n        finder = FinderInterface(_finder);\n        setUp(initializeParams);\n    }\n\n    /**\n     * @notice Sets up the Optimistic Governor module.\n     * @param initializeParams ABI encoded parameters to initialize the module with.\n     * @dev This method can be called only either by the constructor or as part of first time initialization when\n     * cloning the module.\n     */\n    function setUp(bytes memory initializeParams) public override initializer {\n        _startReentrantGuardDisabled();\n        __Ownable_init();\n        (\n            address _owner,\n            address _collateral,\n            uint256 _bondAmount,\n            string memory _rules,\n            bytes32 _identifier,\n            uint64 _liveness\n        ) = abi.decode(initializeParams, (address, address, uint256, string, bytes32, uint64));\n        setCollateralAndBond(IERC20(_collateral), _bondAmount);\n        setRules(_rules);\n        setIdentifier(_identifier);\n        setLiveness(_liveness);\n        setAvatar(_owner);\n        setTarget(_owner);\n        transferOwnership(_owner);\n        _sync();\n\n        emit OptimisticGovernorDeployed(_owner, avatar, target);\n    }\n\n    /**\n     * @notice Sets the collateral and bond amount for proposals.\n     * @param _collateral token that will be used for all bonds for the contract.\n     * @param _bondAmount amount of the bond token that will need to be paid for future proposals.\n     */\n    function setCollateralAndBond(IERC20 _collateral, uint256 _bondAmount) public onlyOwner {\n        // ERC20 token to be used as collateral (must be approved by UMA governance).\n        require(_getCollateralWhitelist().isOnWhitelist(address(_collateral)), \"Bond token not supported\");\n        collateral = _collateral;\n\n        // Value of the bond posted for asserting the proposed transactions. If the minimum amount required by\n        // Optimistic Oracle V3 is higher this contract will attempt to pull the required bond amount.\n        bondAmount = _bondAmount;\n        emit SetBond(_collateral, _bondAmount);\n    }\n\n    /**\n     * @notice Sets the rules that will be used to evaluate future proposals.\n     * @param _rules string that outlines or references the location where the rules can be found.\n     */\n    function setRules(string memory _rules) public onlyOwner {\n        // Set reference to the rules for the Optimistic Governor\n        require(bytes(_rules).length > 0, \"Rules can not be empty\");\n        rules = _rules;\n        emit SetRules(_rules);\n    }\n\n    /**\n     * @notice Sets the liveness for future proposals. This is the amount of delay before a proposal is approved by\n     * default.\n     * @param _liveness liveness to set in seconds.\n     */\n    function setLiveness(uint64 _liveness) public onlyOwner {\n        // Set liveness for disputing proposed transactions.\n        require(_liveness > 0, \"Liveness can't be 0\");\n        require(_liveness < 5200 weeks, \"Liveness must be less than 5200 weeks\");\n        liveness = _liveness;\n        emit SetLiveness(_liveness);\n    }\n\n    /**\n     * @notice Sets the identifier for future proposals.\n     * @param _identifier identifier to set.\n     */\n    function setIdentifier(bytes32 _identifier) public onlyOwner {\n        // Set identifier which is used along with the rules to determine if transactions are valid.\n        require(_getIdentifierWhitelist().isIdentifierSupported(_identifier), \"Identifier not supported\");\n        identifier = _identifier;\n        emit SetIdentifier(_identifier);\n    }\n\n    /**\n     * @notice Sets the Escalation Manager for future proposals.\n     * @param _escalationManager address of the Escalation Manager, can be zero to disable this functionality.\n     * @dev Only the owner can call this method. The provided address must conform to the Escalation Manager interface.\n     * FullPolicyEscalationManager can be used, but within the context of this contract it should be used only for\n     * whitelisting of proposers and disputers since Optimistic Governor is deleting disputed proposals.\n     */\n    function setEscalationManager(address _escalationManager) external onlyOwner {\n        escalationManager = _escalationManager;\n        emit SetEscalationManager(_escalationManager);\n    }\n\n    /**\n     * @notice This caches the most up-to-date Optimistic Oracle V3.\n     * @dev If a new Optimistic Oracle V3 is added and this is run between a proposal's introduction and execution, the\n     * proposal will become unexecutable.\n     */\n    function sync() external nonReentrant {\n        _sync();\n    }\n\n    /**\n     * @notice Makes a new proposal for transactions to be executed with an explanation argument.\n     * @param _transactions the transactions being proposed.\n     * @param _explanation Auxillary information that can be referenced to validate the proposal.\n     * @dev Proposer must grant the contract collateral allowance at least to the bondAmount or result of getMinimumBond\n     * from the Optimistic Oracle V3, whichever is greater.\n     */\n    function proposeTransactions(Transaction[] memory _transactions, bytes memory _explanation) external nonReentrant {\n        // note: Optional explanation explains the intent of the transactions to make comprehension easier.\n        uint256 time = getCurrentTime();\n        address proposer = msg.sender;\n\n        // Create proposal in memory to emit in an event.\n        Proposal memory proposal;\n        proposal.requestTime = time;\n\n        // Add transactions to proposal in memory.\n        for (uint256 i = 0; i < _transactions.length; i++) {\n            require(_transactions[i].to != address(0), \"The `to` address cannot be 0x0\");\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\n            if (_transactions[i].data.length > 0) {\n                require(_isContract(_transactions[i].to), \"EOA can't accept tx with data\");\n            }\n        }\n        proposal.transactions = _transactions;\n\n        // Create the proposal hash.\n        bytes32 proposalHash = keccak256(abi.encode(_transactions));\n\n        // Add the proposal hash, explanation and rules to ancillary data.\n        bytes memory claim = _constructClaim(proposalHash, _explanation);\n\n        // Check that the proposal is not already mapped to an assertionId, i.e., is not a duplicate.\n        require(proposalHashes[proposalHash] == bytes32(0), \"Duplicate proposals not allowed\");\n\n        // Get the bond from the proposer and approve the required bond to be used by the Optimistic Oracle V3.\n        // This will fail if the proposer has not granted the Optimistic Governor contract an allowance\n        // of the collateral token equal to or greater than the totalBond.\n        uint256 totalBond = getProposalBond();\n        collateral.safeTransferFrom(msg.sender, address(this), totalBond);\n        collateral.safeIncreaseAllowance(address(optimisticOracleV3), totalBond);\n\n        // Assert that the proposal is correct at the Optimistic Oracle V3.\n        bytes32 assertionId =\n            optimisticOracleV3.assertTruth(\n                claim, // claim containing proposalHash, explanation and rules.\n                proposer, // asserter will receive back bond if the assertion is correct.\n                address(this), // callbackRecipient is set to this contract for automated proposal deletion on disputes.\n                escalationManager, // escalationManager (if set) used for whitelisting proposers / disputers.\n                liveness, // liveness in seconds.\n                collateral, // currency in which the bond is denominated.\n                totalBond, // bond amount used to assert proposal.\n                identifier, // identifier used to determine if the claim is correct at DVM.\n                bytes32(0) // domainId is not set.\n            );\n\n        // Maps the proposal hash to the returned assertionId and vice versa.\n        proposalHashes[proposalHash] = assertionId;\n        assertionIds[assertionId] = proposalHash;\n\n        emit TransactionsProposed(\n            proposer,\n            time,\n            assertionId,\n            proposal,\n            proposalHash,\n            _explanation,\n            rules,\n            time + liveness\n        );\n    }\n\n    /**\n     * @notice Executes an approved proposal.\n     * @param _transactions the transactions being executed. These must exactly match those that were proposed.\n     */\n    function executeProposal(Transaction[] memory _transactions) external payable nonReentrant {\n        // Recreate the proposal hash from the inputs and check that it matches the stored proposal hash.\n        bytes32 _proposalHash = keccak256(abi.encode(_transactions));\n\n        // This will reject the transaction if the proposal hash generated from the inputs does not match the stored\n        // proposal hash. This is possible when a) the transactions have not been proposed, b) transactions have already\n        // been executed, c) the proposal was disputed or d) the proposal was deleted after Optimistic Oracle V3 upgrade.\n        require(proposalHashes[_proposalHash] != bytes32(0), \"Proposal hash does not exist\");\n\n        // Get the original proposal assertionId.\n        bytes32 assertionId = proposalHashes[_proposalHash];\n\n        // Remove proposal hash and assertionId so transactions can not be executed again.\n        delete proposalHashes[_proposalHash];\n        delete assertionIds[assertionId];\n\n        // There is no need to check the assertion result as this point can be reached only for non-disputed assertions.\n        // This will revert if the assertion has not been settled and can not currently be settled.\n        optimisticOracleV3.settleAndGetAssertionResult(assertionId);\n\n        // Execute the transactions.\n        for (uint256 i = 0; i < _transactions.length; i++) {\n            Transaction memory transaction = _transactions[i];\n\n            require(\n                exec(transaction.to, transaction.value, transaction.data, transaction.operation),\n                \"Failed to execute transaction\"\n            );\n            emit TransactionExecuted(_proposalHash, assertionId, i);\n        }\n\n        emit ProposalExecuted(_proposalHash, assertionId);\n    }\n\n    /**\n     * @notice Function to delete a proposal on an Optimistic Oracle V3 upgrade.\n     * @param _proposalHash the hash of the proposal to delete.\n     * @dev In case of an Optimistic Oracle V3 upgrade, the proposal execution would be blocked as its related\n     * assertionId would not be recognized by the new Optimistic Oracle V3. This function allows the proposal to be\n     * deleted if detecting an Optimistic Oracle V3 upgrade so that transactions can be re-proposed if needed.\n     */\n    function deleteProposalOnUpgrade(bytes32 _proposalHash) public nonReentrant {\n        require(_proposalHash != bytes32(0), \"Invalid proposal hash\");\n        bytes32 assertionId = proposalHashes[_proposalHash];\n        require(assertionId != bytes32(0), \"Proposal hash does not exist\");\n\n        // Detect Optimistic Oracle V3 upgrade by checking if it has the matching assertionId.\n        require(optimisticOracleV3.getAssertion(assertionId).asserter == address(0), \"OOv3 upgrade not detected\");\n\n        // Remove proposal hash and assertionId so that transactions can be re-proposed if needed.\n        delete proposalHashes[_proposalHash];\n        delete assertionIds[assertionId];\n\n        emit ProposalDeleted(_proposalHash, assertionId);\n    }\n\n    /**\n     * @notice Callback to automatically delete a proposal that was disputed.\n     * @param assertionId the identifier of the disputed assertion.\n     */\n    function assertionDisputedCallback(bytes32 assertionId) external {\n        // In order to optimize for happy path, the assertionId is validated for potential spoofing only in the\n        // deleteProposalOnUpgrade call. Genuine Optimistic Oracle V3 should always pass a valid assertionId that has a\n        // matching proposalHash in this contract.\n        bytes32 proposalHash = assertionIds[assertionId];\n\n        // Callback should only be called by the Optimistic Oracle V3. Address would not match in case of contract\n        // upgrade, thus try deleting the proposal through deleteProposalOnUpgrade function that should revert if\n        // address mismatch was not caused by an Optimistic Oracle V3 upgrade.\n        if (msg.sender == address(optimisticOracleV3)) {\n            // Delete the disputed proposal and associated assertionId.\n            delete proposalHashes[proposalHash];\n            delete assertionIds[assertionId];\n\n            emit ProposalDeleted(proposalHash, assertionId);\n        } else deleteProposalOnUpgrade(proposalHash);\n    }\n\n    /**\n     * @notice Callback function that is called by Optimistic Oracle V3 when an assertion is resolved.\n     * @dev This function does nothing and is only here to satisfy the callback recipient interface.\n     * @param assertionId The identifier of the assertion that was resolved.\n     * @param assertedTruthfully Whether the assertion was resolved as truthful or not.\n     */\n    function assertionResolvedCallback(bytes32 assertionId, bool assertedTruthfully) external {}\n\n    /**\n     * @notice Gets the current time for this contract.\n     * @dev This only exists so it can be overridden for testing.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /**\n     * @notice Getter function to check required collateral currency approval.\n     * @return The amount of bond required to propose a transaction.\n     */\n    function getProposalBond() public view returns (uint256) {\n        uint256 minimumBond = optimisticOracleV3.getMinimumBond(address(collateral));\n        return minimumBond > bondAmount ? minimumBond : bondAmount;\n    }\n\n    // Gets the address of Collateral Whitelist from the Finder.\n    function _getCollateralWhitelist() internal view returns (AddressWhitelistInterface) {\n        return AddressWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\n    }\n\n    // Gets the address of Identifier Whitelist from the Finder.\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\n    }\n\n    // Gets the address of Store contract from the Finder.\n    function _getStore() internal view returns (StoreInterface) {\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\n    }\n\n    // Caches the address of the Optimistic Oracle V3 from the Finder.\n    function _sync() internal {\n        optimisticOracleV3 = OptimisticOracleV3Interface(\n            finder.getImplementationAddress(OracleInterfaces.OptimisticOracleV3)\n        );\n    }\n\n    // Checks if the address is a contract.\n    function _isContract(address addr) internal view returns (bool) {\n        return addr.code.length > 0;\n    }\n\n    // Constructs the claim that will be asserted at the Optimistic Oracle V3.\n    function _constructClaim(bytes32 _proposalHash, bytes memory _explanation) internal view returns (bytes memory) {\n        return\n            abi.encodePacked(\n                ClaimData.appendKeyValueBytes32(\"\", PROPOSAL_HASH_KEY, _proposalHash),\n                \",\",\n                EXPLANATION_KEY,\n                ':\"',\n                _explanation,\n                '\",',\n                RULES_KEY,\n                ':\"',\n                rules,\n                '\"'\n            );\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/optimistic-oracle-v3/implementation/OptimisticOracleV3.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/OptimisticOracleV3CallbackRecipientInterface.sol\";\nimport \"../interfaces/OptimisticOracleV3Interface.sol\";\nimport \"../interfaces/EscalationManagerInterface.sol\";\n\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../../data-verification-mechanism/interfaces/OracleAncillaryInterface.sol\";\nimport \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\n\nimport \"../../common/implementation/AddressWhitelist.sol\";\nimport \"../../common/implementation/AncillaryData.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/implementation/MultiCaller.sol\";\n\n/**\n * @title Optimistic Oracle V3.\n * @notice The OOv3 is used to assert truths about the world which are verified using an optimistic escalation game.\n * @dev Core idea: an asserter makes a statement about a truth, calling \"assertTruth\". If this statement is not\n * challenged, it is taken as the state of the world. If challenged, it is arbitrated using the UMA DVM, or if\n * configured, an escalation manager. Escalation managers enable integrations to define their own security properties and\n * tradeoffs, enabling the notion of \"sovereign security\".\n */\n\ncontract OptimisticOracleV3 is OptimisticOracleV3Interface, Lockable, Ownable, MultiCaller {\n    using SafeERC20 for IERC20;\n\n    FinderInterface public immutable finder; // Finder used to discover other UMA ecosystem contracts.\n\n    // Cached UMA parameters.\n    address public cachedOracle;\n    mapping(address => WhitelistedCurrency) public cachedCurrencies;\n    mapping(bytes32 => bool) public cachedIdentifiers;\n\n    mapping(bytes32 => Assertion) public assertions; // All assertions made by the Optimistic Oracle V3.\n\n    uint256 public burnedBondPercentage; // Percentage of the bond that is paid to the UMA store if the assertion is disputed.\n\n    bytes32 public constant defaultIdentifier = \"ASSERT_TRUTH\";\n    int256 public constant numericalTrue = 1e18; // Numerical representation of true.\n    IERC20 public defaultCurrency;\n    uint64 public defaultLiveness;\n\n    /**\n     * @notice Construct the OptimisticOracleV3 contract.\n     * @param _finder keeps track of all contracts within the UMA system based on their interfaceName.\n     * @param _defaultCurrency the default currency to bond asserters in assertTruthWithDefaults.\n     * @param _defaultLiveness the default liveness for assertions in assertTruthWithDefaults.\n     */\n    constructor(\n        FinderInterface _finder,\n        IERC20 _defaultCurrency,\n        uint64 _defaultLiveness\n    ) {\n        finder = _finder;\n        setAdminProperties(_defaultCurrency, _defaultLiveness, 0.5e18);\n    }\n\n    /**\n     * @notice Sets the default currency, liveness, and burned bond percentage.\n     * @dev Only callable by the contract owner (UMA governor).\n     * @param _defaultCurrency the default currency to bond asserters in assertTruthWithDefaults.\n     * @param _defaultLiveness the default liveness for assertions in assertTruthWithDefaults.\n     * @param _burnedBondPercentage the percentage of the bond that is sent as fee to UMA Store contract on disputes.\n     */\n    function setAdminProperties(\n        IERC20 _defaultCurrency,\n        uint64 _defaultLiveness,\n        uint256 _burnedBondPercentage\n    ) public onlyOwner {\n        require(_burnedBondPercentage <= 1e18, \"Burned bond percentage > 100\");\n        require(_burnedBondPercentage > 0, \"Burned bond percentage is 0\");\n        burnedBondPercentage = _burnedBondPercentage;\n        defaultCurrency = _defaultCurrency;\n        defaultLiveness = _defaultLiveness;\n        syncUmaParams(defaultIdentifier, address(_defaultCurrency));\n\n        emit AdminPropertiesSet(_defaultCurrency, _defaultLiveness, _burnedBondPercentage);\n    }\n\n    /**\n     * @notice Asserts a truth about the world, using the default currency and liveness. No callback recipient or\n     * escalation manager is enabled. The caller is expected to provide a bond of finalFee/burnedBondPercentage\n     * (with burnedBondPercentage set to 50%, the bond is 2x final fee) of the default currency.\n     * @dev The caller must approve this contract to spend at least the result of getMinimumBond(defaultCurrency).\n     * @param claim the truth claim being asserted. This is an assertion about the world, and is verified by disputers.\n     * @param asserter account that receives bonds back at settlement. This could be msg.sender or\n     * any other account that the caller wants to receive the bond at settlement time.\n     * @return assertionId unique identifier for this assertion.\n     */\n\n    function assertTruthWithDefaults(bytes calldata claim, address asserter) external returns (bytes32) {\n        // Note: re-entrancy guard is done in the inner call.\n        return\n            assertTruth(\n                claim,\n                asserter, // asserter\n                address(0), // callbackRecipient\n                address(0), // escalationManager\n                defaultLiveness,\n                defaultCurrency,\n                getMinimumBond(address(defaultCurrency)),\n                defaultIdentifier,\n                bytes32(0)\n            );\n    }\n\n    /**\n     * @notice Asserts a truth about the world, using a fully custom configuration.\n     * @dev The caller must approve this contract to spend at least bond amount of currency.\n     * @param claim the truth claim being asserted. This is an assertion about the world, and is verified by disputers.\n     * @param asserter account that receives bonds back at settlement. This could be msg.sender or\n     * any other account that the caller wants to receive the bond at settlement time.\n     * @param callbackRecipient if configured, this address will receive a function call assertionResolvedCallback and\n     * assertionDisputedCallback at resolution or dispute respectively. Enables dynamic responses to these events. The\n     * recipient _must_ implement these callbacks and not revert or the assertion resolution will be blocked.\n     * @param escalationManager if configured, this address will control escalation properties of the assertion. This\n     * means a) choosing to arbitrate via the UMA DVM, b) choosing to discard assertions on dispute, or choosing to\n     * validate disputes. Combining these, the asserter can define their own security properties for the assertion.\n     * escalationManager also _must_ implement the same callbacks as callbackRecipient.\n     * @param liveness time to wait before the assertion can be resolved. Assertion can be disputed in this time.\n     * @param currency bond currency pulled from the caller and held in escrow until the assertion is resolved.\n     * @param bond amount of currency to pull from the caller and hold in escrow until the assertion is resolved. This\n     * must be >= getMinimumBond(address(currency)).\n     * @param identifier UMA DVM identifier to use for price requests in the event of a dispute. Must be pre-approved.\n     * @param domainId optional domain that can be used to relate this assertion to others in the escalationManager and\n     * can be used by the configured escalationManager to define custom behavior for groups of assertions. This is\n     * typically used for \"escalation games\" by changing bonds or other assertion properties based on the other\n     * assertions that have come before. If not needed this value should be 0 to save gas.\n     * @return assertionId unique identifier for this assertion.\n     */\n    function assertTruth(\n        bytes memory claim,\n        address asserter,\n        address callbackRecipient,\n        address escalationManager,\n        uint64 liveness,\n        IERC20 currency,\n        uint256 bond,\n        bytes32 identifier,\n        bytes32 domainId\n    ) public nonReentrant returns (bytes32 assertionId) {\n        uint64 time = uint64(getCurrentTime());\n        assertionId = _getId(claim, bond, time, liveness, currency, callbackRecipient, escalationManager, identifier);\n\n        require(asserter != address(0), \"Asserter cant be 0\");\n        require(assertions[assertionId].asserter == address(0), \"Assertion already exists\");\n        require(_validateAndCacheIdentifier(identifier), \"Unsupported identifier\");\n        require(_validateAndCacheCurrency(address(currency)), \"Unsupported currency\");\n        require(bond >= getMinimumBond(address(currency)), \"Bond amount too low\");\n\n        assertions[assertionId] = Assertion({\n            escalationManagerSettings: EscalationManagerSettings({\n                arbitrateViaEscalationManager: false, // Default behavior: use the DVM as an oracle.\n                discardOracle: false, // Default behavior: respect the Oracle result.\n                validateDisputers: false, // Default behavior: disputer will not be validated.\n                escalationManager: escalationManager,\n                assertingCaller: msg.sender\n            }),\n            asserter: asserter,\n            disputer: address(0),\n            callbackRecipient: callbackRecipient,\n            currency: currency,\n            domainId: domainId,\n            identifier: identifier,\n            bond: bond,\n            settled: false,\n            settlementResolution: false,\n            assertionTime: time,\n            expirationTime: time + liveness\n        });\n\n        {\n            EscalationManagerInterface.AssertionPolicy memory assertionPolicy = _getAssertionPolicy(assertionId);\n            require(!assertionPolicy.blockAssertion, \"Assertion not allowed\"); // Check if the assertion is permitted.\n            EscalationManagerSettings storage emSettings = assertions[assertionId].escalationManagerSettings;\n            (emSettings.arbitrateViaEscalationManager, emSettings.discardOracle, emSettings.validateDisputers) = (\n                // Choose which oracle to arbitrate disputes via. If set to true then the escalation manager will\n                // arbitrate disputes. Else, the DVM arbitrates disputes. This lets integrations \"unplug\" the DVM.\n                assertionPolicy.arbitrateViaEscalationManager,\n                // Choose whether to discard the Oracle result. If true then \"throw away\" the assertion. To get an\n                // assertion to be true it must be re-asserted and not disputed.\n                assertionPolicy.discardOracle,\n                // Configures if the escalation manager should validate the disputer on assertions. This enables you\n                // to construct setups such as whitelisted disputers.\n                assertionPolicy.validateDisputers\n            );\n        }\n\n        currency.safeTransferFrom(msg.sender, address(this), bond); // Pull the bond from the caller.\n\n        emit AssertionMade(\n            assertionId,\n            domainId,\n            claim,\n            asserter,\n            callbackRecipient,\n            escalationManager,\n            msg.sender,\n            time + liveness,\n            currency,\n            bond,\n            identifier\n        );\n    }\n\n    /**\n     * @notice Disputes an assertion. Depending on how the assertion was configured, this may either escalate to the UMA\n     * DVM or the configured escalation manager for arbitration.\n     * @dev The caller must approve this contract to spend at least bond amount of currency for the associated assertion.\n     * @param assertionId unique iden"
    }
  ]
}