{
  "Title": "[M-21] Dangerous use of deadline parameter",
  "Content": "\n<https://github.com/code-423n4/2024-03-revert-lend/blob/435b054f9ad2404173f36f0f74a5096c894b12b7/src/transformers/AutoCompound.sol#L159-L172> \n\n<https://github.com/code-423n4/2024-03-revert-lend/blob/435b054f9ad2404173f36f0f74a5096c894b12b7/src/V3Vault.sol#L1032-L1074>\n\n### Vulnerability details\n\nThe protocol is using `block.timestamp` as the `deadline` argument while interacting with the Uniswap NFT Position Manager, which completely defeats the purpose of using a deadline.\n\nActions in the Uniswap `NonfungiblePositionManager` contract are protected by a deadline parameter to limit the execution of pending transactions. Functions that modify the liquidity of the pool check this parameter against the current block timestamp in order to discard expired actions.\n\nThese interactions with the Uniswap position are present throughout the code base, in particular and not only in the functions: `V3Utils::_swapAndMint`, `Automator::_decreaseFullLiquidityAndCollect`, `LeverageTransformer::leverageUp`. Those functions call their corresponding functions in the Uniswap Position Manager, providing the `deadline` argument with their own `deadline` argument.\n\nOn the other hand, `AutoCompound::execute` and `V3Vault::_sendPositionValue` functions provide `block.timestamp` as the argument for the `deadline` parameter in their call to the corresponding underlying Uniswap `NonfungiblePositionManager` contract.\n\n```solidity\nFile: src/transformers/AutoCompound.sol\n\n// deposit liquidity into tokenId\nif (state.maxAddAmount0 > 0 || state.maxAddAmount1 > 0) {\n    _checkApprovals(state.token0, state.token1);\n\n\n    (, state.compounded0, state.compounded1) = nonfungiblePositionManager.increaseLiquidity(\n        INonfungiblePositionManager.IncreaseLiquidityParams(\n@@->    params.tokenId, state.maxAddAmount0, state.maxAddAmount1, 0, 0, block.timestamp\n        )\n    );\n\n\n    // fees are always calculated based on added amount (to incentivize optimal swap)\n    state.amount0Fees = state.compounded0 * rewardX64 / Q64;\n    state.amount1Fees = state.compounded1 * rewardX64 / Q64;\n}\n```\n\n```solidity\nFile: src/V3Vault.sol\n\nif (liquidity > 0) {\n    nonfungiblePositionManager.decreaseLiquidity(\n        INonfungiblePositionManager.DecreaseLiquidityParams(tokenId, liquidity, 0, 0, block.timestamp)\n    );\n}\n```\n\nUsing `block.timestamp` as the deadline is effectively a no-operation that has no effect nor protection. Since `block.timestamp` will take the timestamp value when the transaction gets mined, the check will end up comparing `block.timestamp` against the same value (see [here](<https://github.com/Uniswap/v3-periphery/blob/697c2474757ea89fec12a4e6db16a574fe259610/contracts/base/PeripheryValidation.sol#L7>)).\n\n### Impact\n\nFailure to provide a proper deadline value enables pending transactions to be maliciously executed at a later point. Transactions that provide an insufficient amount of gas such that they are not mined within a reasonable amount of time, can be picked by malicious actors or MEV bots and executed later in detriment of the submitter. See [this issue](https://github.com/code-423n4/2022-12-backed-findings/issues/64) for an excellent reference on the topic (the author runs a MEV bot).\n\n### Recommended Mitigation Steps\n\nAs done in the [`LeverageTransformer::leverageUp`](https://github.com/code-423n4/2024-03-revert-lend/blob/ac520c5fedf4e1654c597a46efaf5a7c27295de1/src/transformers/LeverageTransformer.sol#L82) and [`V3Utils::_swapAndIncrease`](https://github.com/code-423n4/2024-03-revert-lend/blob/ac520c5fedf4e1654c597a46efaf5a7c27295de1/src/transformers/V3Utils.sol#L768) functions, add a deadline parameter to the `AutoCompound::execute` and `V3Vault::_sendPositionValue` functions and forward this parameter to the corresponding underlying call to the Uniswap `NonfungiblePositionManager` contract.\n\n**[kalinbas (Revert) confirmed](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/147#issuecomment-2020750693)**\n\n**[Revert mitigated](https://github.com/code-423n4/2024-04-revert-mitigation?tab=readme-ov-file#scope):**\n> PR [here](https://github.com/revert-finance/lend/pull/24) - added deadline where missing.\n\n**Status:** Mitigation Confirmed. Full details in reports from [thank_you](https://github.com/code-423n4/2024-04-revert-mitigation-findings/issues/96), [b0g0](https://github.com/code-423n4/2024-04-revert-mitigation-findings/issues/55) and [ktg](https://github.com/code-423n4/2024-04-revert-mitigation-findings/issues/23).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-revert-lend",
  "Code": [
    {
      "filename": "src/transformers/AutoCompound.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"v3-periphery/interfaces/INonfungiblePositionManager.sol\";\n\nimport \"../automators/Automator.sol\";\n\n/// @title AutoCompound\n/// @notice Allows operator of AutoCompound contract (Revert controlled bot) to compound a position\n/// Positions need to be approved (approve or setApprovalForAll) for the contract when outside vault\n/// When position is inside Vault - owner needs to approve the position to be transformed by the contract\ncontract AutoCompound is Automator, Multicall, ReentrancyGuard {\n    // autocompound event\n    event AutoCompounded(\n        address account,\n        uint256 tokenId,\n        uint256 amountAdded0,\n        uint256 amountAdded1,\n        uint256 reward0,\n        uint256 reward1,\n        address token0,\n        address token1\n    );\n\n    // config changes\n    event RewardUpdated(address account, uint64 totalRewardX64);\n\n    // balance movements\n    event BalanceAdded(uint256 tokenId, address token, uint256 amount);\n    event BalanceRemoved(uint256 tokenId, address token, uint256 amount);\n    event BalanceWithdrawn(uint256 tokenId, address token, address to, uint256 amount);\n\n    constructor(\n        INonfungiblePositionManager _npm,\n        address _operator,\n        address _withdrawer,\n        uint32 _TWAPSeconds,\n        uint16 _maxTWAPTickDifference\n    ) Automator(_npm, _operator, _withdrawer, _TWAPSeconds, _maxTWAPTickDifference, address(0), address(0)) {}\n\n    mapping(uint256 => mapping(address => uint256)) public positionBalances;\n\n    uint64 public constant MAX_REWARD_X64 = uint64(Q64 / 50); // 2%\n    uint64 public totalRewardX64 = MAX_REWARD_X64; // 2%\n\n    /// @notice params for execute()\n    struct ExecuteParams {\n        // tokenid to autocompound\n        uint256 tokenId;\n        // swap direction - calculated off-chain\n        bool swap0To1;\n        // swap amount - calculated off-chain - if this is set to 0 no swap happens\n        uint256 amountIn;\n    }\n\n    // state used during autocompound execution\n    struct ExecuteState {\n        uint256 amount0;\n        uint256 amount1;\n        uint256 maxAddAmount0;\n        uint256 maxAddAmount1;\n        uint256 amount0Fees;\n        uint256 amount1Fees;\n        uint256 priceX96;\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 compounded0;\n        uint256 compounded1;\n        int24 tick;\n        uint160 sqrtPriceX96;\n        uint256 amountInDelta;\n        uint256 amountOutDelta;\n    }\n\n    /**\n     * @notice Adjust token (which is in a Vault) - via transform method\n     * Can only be called from configured operator account - vault must be configured as well\n     * Swap needs to be done with max price difference from current pool price - otherwise reverts\n     */\n    function executeWithVault(ExecuteParams calldata params, address vault) external {\n        if (!operators[msg.sender] || !vaults[vault]) {\n            revert Unauthorized();\n        }\n        IVault(vault).transform(\n            params.tokenId, address(this), abi.encodeWithSelector(AutoCompound.execute.selector, params)\n        );\n    }\n\n    /**\n     * @notice Adjust token directly (must be in correct state)\n     * Can only be called only from configured operator account, or vault via transform\n     * Swap needs to be done with max price difference from current pool price - otherwise reverts\n     */\n    function execute(ExecuteParams calldata params) external nonReentrant {\n        if (!operators[msg.sender] && !vaults[msg.sender]) {\n            revert Unauthorized();\n        }\n        ExecuteState memory state;\n\n        // collect fees - if the position doesn't have operator set or is called from vault - it won't work\n        (state.amount0, state.amount1) = nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams(\n                params.tokenId, address(this), type(uint128).max, type(uint128).max\n            )\n        );\n\n        // get position info\n        (,, state.token0, state.token1, state.fee, state.tickLower, state.tickUpper,,,,,) =\n            nonfungiblePositionManager.positions(params.tokenId);\n\n        // add previous balances from given tokens\n        state.amount0 = state.amount0 + positionBalances[params.tokenId][state.token0];\n        state.amount1 = state.amount1 + positionBalances[params.tokenId][state.token1];\n\n        // only if there are balances to work with - start autocompounding process\n        if (state.amount0 > 0 || state.amount1 > 0) {\n            uint256 amountIn = params.amountIn;\n\n            // if a swap is requested - check TWAP oracle\n            if (amountIn > 0) {\n                IUniswapV3Pool pool = _getPool(state.token0, state.token1, state.fee);\n                (state.sqrtPriceX96, state.tick,,,,,) = pool.slot0();\n\n                // how many seconds are needed for TWAP protection\n                uint32 tSecs = TWAPSeconds;\n                if (tSecs > 0) {\n                    if (!_hasMaxTWAPTickDifference(pool, tSecs, state.tick, maxTWAPTickDifference)) {\n                        // if there is no valid TWAP - disable swap\n                        amountIn = 0;\n                    }\n                }\n                // if still needed - do swap\n                if (amountIn > 0) {\n                    // no slippage check done - because protected by TWAP check\n                    (state.amountInDelta, state.amountOutDelta) = _poolSwap(\n                        Swapper.PoolSwapParams(\n                            pool, IERC20(state.token0), IERC20(state.token1), state.fee, params.swap0To1, amountIn, 0\n                        )\n                    );\n                    state.amount0 =\n                        params.swap0To1 ? state.amount0 - state.amountInDelta : state.amount0 + state.amountOutDelta;\n                    state.amount1 =\n                        params.swap0To1 ? state.amount1 + state.amountOutDelta : state.amount1 - state.amountInDelta;\n                }\n            }\n\n            uint256 rewardX64 = totalRewardX64;\n\n            state.maxAddAmount0 = state.amount0 * Q64 / (rewardX64 + Q64);\n            state.maxAddAmount1 = state.amount1 * Q64 / (rewardX64 + Q64);\n\n            // deposit liquidity into tokenId\n            if (state.maxAddAmount0 > 0 || state.maxAddAmount1 > 0) {\n                _checkApprovals(state.token0, state.token1);\n\n                (, state.compounded0, state.compounded1) = nonfungiblePositionManager.increaseLiquidity(\n                    INonfungiblePositionManager.IncreaseLiquidityParams(\n                        params.tokenId, state.maxAddAmount0, state.maxAddAmount1, 0, 0, block.timestamp\n                    )\n                );\n\n                // fees are always calculated based on added amount (to incentivize optimal swap)\n                state.amount0Fees = state.compounded0 * rewardX64 / Q64;\n                state.amount1Fees = state.compounded1 * rewardX64 / Q64;\n            }\n\n            // calculate remaining tokens for owner\n            _setBalance(params.tokenId, state.token0, state.amount0 - state.compounded0 - state.amount0Fees);\n            _setBalance(params.tokenId, state.token1, state.amount1 - state.compounded1 - state.amount1Fees);\n\n            // add reward to protocol balance (token 0)\n            _increaseBalance(0, state.token0, state.amount0Fees);\n            _increaseBalance(0, state.token1, state.amount1Fees);\n        }\n\n        emit AutoCompounded(\n            msg.sender,\n            params.tokenId,\n            state.compounded0,\n            state.compounded1,\n            state.amount0Fees,\n            state.amount1Fees,\n            state.token0,\n            state.token1\n        );\n    }\n\n    /**\n     * @notice Withdraws leftover token balance for a token\n     * @param tokenId Id of position to withdraw\n     * @param to Address to send to\n     */\n    function withdrawLeftoverBalances(uint256 tokenId, address to) external nonReentrant {\n        address owner = nonfungiblePositionManager.ownerOf(tokenId);\n        if (vaults[owner]) {\n            owner = IVault(owner).ownerOf(tokenId);\n        }\n        if (owner != msg.sender) {\n            revert Unauthorized();\n        }\n\n        (,, address token0, address token1,,,,,,,,) = nonfungiblePositionManager.positions(tokenId);\n\n        uint256 balance0 = positionBalances[tokenId][token0];\n        if (balance0 > 0) {\n            _withdrawBalanceInternal(tokenId, token0, to, balance0, balance0);\n        }\n        uint256 balance1 = positionBalances[tokenId][token1];\n        if (balance1 > 0) {\n            _withdrawBalanceInternal(tokenId, token1, to, balance1, balance1);\n        }\n    }\n\n    /**\n     * @notice Withdraws token balance (accumulated protocol fee)\n     * @dev The method is overriden, because it differs from standard automator fee handling\n     * @param tokens Addresses of tokens to withdraw\n     * @param to Address to send to\n     */\n    function withdrawBalances(address[] calldata tokens, address to) external override nonReentrant {\n        if (msg.sender != withdrawer) {\n            revert Unauthorized();\n        }\n        uint256 i;\n        uint256 count = tokens.length;\n        for (; i < count; ++i) {\n            uint256 balance = positionBalances[0][tokens[i]];\n            _withdrawBalanceInternal(0, tokens[i], to, balance, balance);\n        }\n    }\n\n    /**\n     * @notice Management method to lower reward(onlyOwner)\n     * @param _totalRewardX64 new total reward (can't be higher than current total reward)\n     */\n    function setReward(uint64 _totalRewardX64) external onlyOwner {\n        require(_totalRewardX64 <= totalRewardX64, \">totalRewardX64\");\n        totalRewardX64 = _totalRewardX64;\n        emit RewardUpdated(msg.sender, _totalRewardX64);\n    }\n\n    function _increaseBalance(uint256 tokenId, address token, uint256 amount) internal {\n        positionBalances[tokenId][token] = positionBalances[tokenId][token] + amount;\n        emit BalanceAdded(tokenId, token, amount);\n    }\n\n    function _setBalance(uint256 tokenId, address token, uint256 amount) internal {\n        uint256 currentBalance = positionBalances[tokenId][token];\n        if (amount != currentBalance) {\n            positionBalances[tokenId][token] = amount;\n            if (amount > currentBalance) {\n                emit BalanceAdded(tokenId, token, amount - currentBalance);\n            } else {\n                emit BalanceRemoved(tokenId, token, currentBalance - amount);\n            }\n        }\n    }\n\n    function _withdrawBalanceInternal(uint256 tokenId, address token, address to, uint256 balance, uint256 amount)\n        internal\n    {\n        require(amount <= balance, \"amount>balance\");\n        positionBalances[tokenId][token] = positionBalances[tokenId][token] - amount;\n        emit BalanceRemoved(tokenId, token, amount);\n        SafeERC20.safeTransfer(IERC20(token), to, amount);\n        emit BalanceWithdrawn(tokenId, token, to, amount);\n    }\n\n    function _checkApprovals(address token0, address token1) internal {\n        // approve tokens once if not yet approved - to save gas during compounds\n        uint256 allowance0 = IERC20(token0).allowance(address(this), address(nonfungiblePositionManager));\n        if (allowance0 == 0) {\n            SafeERC20.safeApprove(IERC20(token0), address(nonfungiblePositionManager), type(uint256).max);\n        }\n        uint256 allowance1 = IERC20(token1).allowance(address(this), address(nonfungiblePositionManager));\n        if (allowance1 == 0) {\n            SafeERC20.safeApprove(IERC20(token1), address(nonfungiblePositionManager), type(uint256).max);\n        }\n    }\n}"
    },
    {
      "filename": "src/V3Vault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"v3-core/interfaces/IUniswapV3Factory.sol\";\nimport \"v3-core/interfaces/IUniswapV3Pool.sol\";\nimport \"v3-core/libraries/TickMath.sol\";\nimport \"v3-core/libraries/FixedPoint128.sol\";\n\nimport \"v3-periphery/libraries/LiquidityAmounts.sol\";\nimport \"v3-periphery/interfaces/INonfungiblePositionManager.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\n\nimport \"permit2/interfaces/IPermit2.sol\";\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IV3Oracle.sol\";\nimport \"./interfaces/IInterestRateModel.sol\";\nimport \"./interfaces/IErrors.sol\";\n\n/// @title Revert Lend Vault for token lending / borrowing using Uniswap V3 LP positions as collateral\n/// @notice The vault manages ONE ERC20 (eg. USDC) asset for lending / borrowing, but collateral positions can be composed of any 2 tokens configured each with a collateralFactor > 0\n/// Vault implements IERC4626 Vault Standard and is itself a ERC20 which represent shares of total lending pool\ncontract V3Vault is ERC20, Multicall, Ownable, IVault, IERC721Receiver, IErrors {\n    using Math for uint256;\n\n    uint256 private constant Q32 = 2 ** 32;\n    uint256 private constant Q96 = 2 ** 96;\n\n    uint32 public constant MAX_COLLATERAL_FACTOR_X32 = uint32(Q32 * 90 / 100); // 90%\n\n    uint32 public constant MIN_LIQUIDATION_PENALTY_X32 = uint32(Q32 * 2 / 100); // 2%\n    uint32 public constant MAX_LIQUIDATION_PENALTY_X32 = uint32(Q32 * 10 / 100); // 10%\n\n    uint32 public constant MIN_RESERVE_PROTECTION_FACTOR_X32 = uint32(Q32 / 100); //1%\n\n    uint32 public constant MAX_DAILY_LEND_INCREASE_X32 = uint32(Q32 / 10); //10%\n    uint32 public constant MAX_DAILY_DEBT_INCREASE_X32 = uint32(Q32 / 10); //10%\n\n    /// @notice Uniswap v3 position manager\n    INonfungiblePositionManager public immutable nonfungiblePositionManager;\n\n    /// @notice Uniswap v3 factory\n    IUniswapV3Factory public immutable factory;\n\n    /// @notice interest rate model implementation\n    IInterestRateModel public immutable interestRateModel;\n\n    /// @notice oracle implementation\n    IV3Oracle public immutable oracle;\n\n    /// @notice permit2 contract\n    IPermit2 public immutable permit2;\n\n    /// @notice underlying asset for lending / borrowing\n    address public immutable override asset;\n\n    /// @notice decimals of underlying token (are the same as ERC20 share token)\n    uint8 private immutable assetDecimals;\n\n    // events\n    event ApprovedTransform(uint256 indexed tokenId, address owner, address target, bool isActive);\n\n    event Add(uint256 indexed tokenId, address owner, uint256 oldTokenId); // when a token is added replacing another token - oldTokenId > 0\n    event Remove(uint256 indexed tokenId, address recipient);\n\n    event ExchangeRateUpdate(uint256 debtExchangeRateX96, uint256 lendExchangeRateX96);\n    // Deposit and Withdraw events are defined in IERC4626\n    event WithdrawCollateral(\n        uint256 indexed tokenId, address owner, address recipient, uint128 liquidity, uint256 amount0, uint256 amount1\n    );\n    event Borrow(uint256 indexed tokenId, address owner, uint256 assets, uint256 shares);\n    event Repay(uint256 indexed tokenId, address repayer, address owner, uint256 assets, uint256 shares);\n    event Liquidate(\n        uint256 indexed tokenId,\n        address liquidator,\n        address owner,\n        uint256 value,\n        uint256 cost,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 reserve,\n        uint256 missing\n    ); // shows exactly how liquidation amounts were divided\n\n    // admin events\n    event WithdrawReserves(uint256 amount, address receiver);\n    event SetTransformer(address transformer, bool active);\n    event SetLimits(\n        uint256 minLoanSize,\n        uint256 globalLendLimit,\n        uint256 globalDebtLimit,\n        uint256 dailyLendIncreaseLimitMin,\n        uint256 dailyDebtIncreaseLimitMin\n    );\n    event SetReserveFactor(uint32 reserveFactorX32);\n    event SetReserveProtectionFactor(uint32 reserveProtectionFactorX32);\n    event SetTokenConfig(address token, uint32 collateralFactorX32, uint32 collateralValueLimitFactorX32);\n\n    event SetEmergencyAdmin(address emergencyAdmin);\n\n    // configured tokens\n    struct TokenConfig {\n        uint32 collateralFactorX32; // how much this token is valued as collateral\n        uint32 collateralValueLimitFactorX32; // how much asset equivalent may be lent out given this collateral\n        uint192 totalDebtShares; // how much debt shares are theoretically backed by this collateral\n    }\n\n    mapping(address => TokenConfig) public tokenConfigs;\n\n    // percentage of interest which is kept in the protocol for reserves\n    uint32 public reserveFactorX32 = 0;\n\n    // percentage of lend amount which needs to be in reserves before withdrawn\n    uint32 public reserveProtectionFactorX32 = MIN_RESERVE_PROTECTION_FACTOR_X32;\n\n    // total of debt shares - increases when borrow - decreases when repay\n    uint256 public debtSharesTotal = 0;\n\n    // exchange rates are Q96 at the beginning - 1 share token per 1 asset token\n    uint256 public lastExchangeRateUpdate = 0;\n    uint256 public lastDebtExchangeRateX96 = Q96;\n    uint256 public lastLendExchangeRateX96 = Q96;\n\n    uint256 public globalDebtLimit = 0;\n    uint256 public globalLendLimit = 0;\n\n    // minimal size of loan (to protect from non-liquidatable positions because of gas-cost)\n    uint256 public minLoanSize = 0;\n\n    // daily lend increase limit handling\n    uint256 public dailyLendIncreaseLimitMin = 0;\n    uint256 public dailyLendIncreaseLimitLeft = 0;\n    uint256 public dailyLendIncreaseLimitLastReset = 0;\n\n    // daily debt increase limit handling\n    uint256 public dailyDebtIncreaseLimitMin = 0;\n    uint256 public dailyDebtIncreaseLimitLeft = 0;\n    uint256 public dailyDebtIncreaseLimitLastReset = 0;\n\n    // lender balances are handled with ERC-20 mint/burn\n\n    // loans are handled with this struct\n    struct Loan {\n        uint256 debtShares;\n    }\n\n    mapping(uint256 => Loan) public loans; // tokenID -> loan mapping\n\n    // storage variables to handle enumerable token ownership\n    mapping(address => uint256[]) private ownedTokens; // Mapping from owner address to list of owned token IDs\n    mapping(uint256 => uint256) private ownedTokensIndex; // Mapping from token ID to index of the owner tokens list (for removal without loop)\n    mapping(uint256 => address) private tokenOwner; // Mapping from token ID to owner\n\n    uint256 private transformedTokenId = 0; // transient storage (when available in dencun)\n\n    mapping(address => bool) public transformerAllowList; // contracts allowed to transform positions (selected audited contracts e.g. V3Utils)\n    mapping(address => mapping(uint256 => mapping(address => bool))) public transformApprovals; // owners permissions for other addresses to call transform on owners behalf (e.g. AutoRange contract)\n\n    // address which can call special emergency actions without timelock\n    address public emergencyAdmin;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        address _asset,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        IInterestRateModel _interestRateModel,\n        IV3Oracle _oracle,\n        IPermit2 _permit2\n    ) ERC20(name, symbol) {\n        asset = _asset;\n        assetDecimals = IERC20Metadata(_asset).decimals();\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        factory = IUniswapV3Factory(_nonfungiblePositionManager.factory());\n        interestRateModel = _interestRateModel;\n        oracle = _oracle;\n        permit2 = _permit2;\n    }\n\n    ////////////////// EXTERNAL VIEW FUNCTIONS\n\n    /// @notice Retrieves global information about the vault\n    /// @return debt Total amount of debt asset tokens\n    /// @return lent Total amount of lent asset tokens\n    /// @return balance Balance of asset token in contract\n    /// @return available Available balance of asset token in contract (balance - reserves)\n    /// @return reserves Amount of reserves\n    function vaultInfo()\n        external\n        view\n        override\n        returns (\n            uint256 debt,\n            uint256 lent,\n            uint256 balance,\n            uint256 available,\n            uint256 reserves,\n            uint256 debtExchangeRateX96,\n            uint256 lendExchangeRateX96\n        )\n    {\n        (debtExchangeRateX96, lendExchangeRateX96) = _calculateGlobalInterest();\n        (balance, available, reserves) = _getAvailableBalance(debtExchangeRateX96, lendExchangeRateX96);\n\n        debt = _convertToAssets(debtSharesTotal, debtExchangeRateX96, Math.Rounding.Up);\n        lent = _convertToAssets(totalSupply(), lendExchangeRateX96, Math.Rounding.Up);\n    }\n\n    /// @notice Retrieves lending information for a specified account.\n    /// @param account The address of the account for which lending info is requested.\n    /// @return amount Amount of lent assets for the account\n    function lendInfo(address account) external view override returns (uint256 amount) {\n        (, uint256 newLendExchangeRateX96) = _calculateGlobalInterest();\n        amount = _convertToAssets(balanceOf(account), newLendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    /// @notice Retrieves details of a loan identified by its token ID.\n    /// @param tokenId The unique identifier of the loan - which is the corresponding UniV3 Position\n    /// @return debt Amount of debt for this position\n    /// @return fullValue Current value of the position priced as asset token\n    /// @return collateralValue Current collateral value of the position priced as asset token\n    /// @return liquidationCost If position is liquidatable - cost to liquidate position - otherwise 0\n    /// @return liquidationValue If position is liquidatable - the value of the (partial) position which the liquidator recieves - otherwise 0\n    function loanInfo(uint256 tokenId)\n        external\n        view\n        override\n        returns (\n            uint256 debt,\n            uint256 fullValue,\n            uint256 collateralValue,\n            uint256 liquidationCost,\n            uint256 liquidationValue\n        )\n    {\n        (uint256 newDebtExchangeRateX96,) = _calculateGlobalInterest();\n\n        debt = _convertToAssets(loans[tokenId].debtShares, newDebtExchangeRateX96, Math.Rounding.Up);\n\n        bool isHealthy;\n        (isHealthy, fullValue, collateralValue,) = _checkLoanIsHealthy(tokenId, debt);\n\n        if (!isHealthy) {\n            (liquidationValue, liquidationCost,) = _calculateLiquidation(debt, fullValue, collateralValue);\n        }\n    }\n\n    /// @notice Retrieves owner of a loan\n    /// @param tokenId The unique identifier of the loan - which is the corresponding UniV3 Position\n    /// @return owner Owner of the loan\n    function ownerOf(uint256 tokenId) external view override returns (address owner) {\n        return tokenOwner[tokenId];\n    }\n\n    /// @notice Retrieves count of loans for owner (for enumerating owners loans)\n    /// @param owner Owner address\n    function loanCount(address owner) external view override returns (uint256) {\n        return ownedTokens[owner].length;\n    }\n\n    /// @notice Retrieves tokenid of loan at given index for owner (for enumerating owners loans)\n    /// @param owner Owner address\n    /// @param index Index\n    function loanAtIndex(address owner, uint256 index) external view override returns (uint256) {\n        return ownedTokens[owner][index];\n    }\n\n    ////////////////// OVERRIDDEN EXTERNAL VIEW FUNCTIONS FROM ERC20\n    /// @inheritdoc IERC20Metadata\n    function decimals() public view override(IERC20Metadata, ERC20) returns (uint8) {\n        return assetDecimals;\n    }\n\n    ////////////////// OVERRIDDEN EXTERNAL VIEW FUNCTIONS FROM ERC4626\n\n    /// @inheritdoc IERC4626\n    function totalAssets() public view override returns (uint256) {\n        return IERC20(asset).balanceOf(address(this));\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 assets) external view override returns (uint256 shares) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToShares(assets, lendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 shares) external view override returns (uint256 assets) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToAssets(shares, lendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxDeposit(address) external view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        uint256 value = _convertToAssets(totalSupply(), lendExchangeRateX96, Math.Rounding.Up);\n        if (value >= globalLendLimit) {\n            return 0;\n        } else {\n            return globalLendLimit - value;\n        }\n    }\n\n    /// @inheritdoc IERC4626\n    function maxMint(address) external view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        uint256 value = _convertToAssets(totalSupply(), lendExchangeRateX96, Math.Rounding.Up);\n        if (value >= globalLendLimit) {\n            return 0;\n        } else {\n            return _convertToShares(globalLendLimit - value, lendExchangeRateX96, Math.Rounding.Down);\n        }\n    }\n\n    /// @inheritdoc IERC4626\n    function maxWithdraw(address owner) external view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToAssets(balanceOf(owner), lendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxRedeem(address owner) external view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToShares(assets, lendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToAssets(shares, lendExchangeRateX96, Math.Rounding.Up);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewWithdraw(uint256 assets) public view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToShares(assets, lendExchangeRateX96, Math.Rounding.Up);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 shares) public view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToAssets(shares, lendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    ////////////////// OVERRIDDEN EXTERNAL FUNCTIONS FROM ERC4626\n\n    /// @inheritdoc IERC4626\n    function deposit(uint256 assets, address receiver) external override returns (uint256) {\n        (, uint256 shares) = _deposit(receiver, assets, false, \"\");\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 shares, address receiver) external override returns (uint256) {\n        (uint256 assets,) = _deposit(receiver, shares, true, \"\");\n        return assets;\n    }\n\n    /// @inheritdoc IERC4626\n    function withdraw(uint256 assets, address receiver, address owner) external override returns (uint256) {\n        (, uint256 shares) = _withdraw(receiver, owner, assets, false);\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function redeem(uint256 shares, address receiver, address owner) external override returns (uint256) {\n        (uint256 assets,) = _withdraw(receiver, owner, shares, true);\n        return assets;\n    }\n\n    // deposit using permit2 data\n    function deposit(uint256 assets, address receiver, bytes calldata permitData) external override returns (uint256) {\n        (, uint256 shares) = _deposit(receiver, assets, false, permitData);\n        return shares;\n    }\n\n    // mint using permit2 data\n    function mint(uint256 shares, address receiver, bytes calldata permitData) external override returns (uint256) {\n        (uint256 assets,) = _deposit(receiver, shares, true, permitData);\n        return assets;\n    }\n\n    ////////////////// EXTERNAL FUNCTIONS\n\n    /// @notice Creates a new collateralized position (transfer approved position)\n    /// @param tokenId The token ID associated with the new position.\n    /// @param recipient Address to recieve the position in the vault\n    function create(uint256 tokenId, address recipient) external override {\n        nonfungiblePositionManager.safeTransferFrom(msg.sender, address(this), tokenId, abi.encode(recipient));\n    }\n\n    /// @notice Creates a new collateralized position with a permit for token spending (transfer position with permit)\n    /// @param tokenId The token ID associated with the new position.\n    /// @param owner Current owner of the position (signature owner)\n    /// @param recipient Address to recieve the position in the vault\n    /// @param deadline Timestamp until which the permit is valid.\n    /// @param v, r, s Components of the signature for the permit.\n    function createWithPermit(\n        uint256 tokenId,\n        address owner,\n        address recipient,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        if (msg.sender != owner) {\n            revert Unauthorized();\n        }\n\n        nonfungiblePositionManager.permit(address(this), tokenId, deadline, v, r, s);\n        nonfungiblePositionManager.safeTransferFrom(owner, address(this), tokenId, abi.encode(recipient));\n    }\n\n    /// @notice Whenever a token is recieved it either creates a new loan, or modifies an existing one when in transform mode.\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address from, uint256 tokenId, bytes calldata data)\n        external\n        override\n        returns (bytes4)\n    {\n        // only Uniswap v3 NFTs allowed - sent from other contract\n        if (msg.sender != address(nonfungiblePositionManager) || from == address(this)) {\n            revert WrongContract();\n        }\n\n        (uint256 debtExchangeRateX96, uint256 lendExchangeRateX96) = _updateGlobalInterest();\n\n        if (transformedTokenId == 0) {\n            address owner = from;\n            if (data.length > 0) {\n                owner = abi.decode(data, (address));\n            }\n            loans[tokenId] = Loan(0);\n\n            _addTokenToOwner(owner, tokenId);\n            emit Add(tokenId, owner, 0);\n        } else {\n            uint256 oldTokenId = transformedTokenId;\n\n            // if in transform mode - and a new position is sent - current position is replaced and returned\n            if (tokenId != oldTokenId) {\n                address owner = tokenOwner[oldTokenId];\n\n                // set transformed token to new one\n                transformedTokenId = tokenId;\n\n                // copy debt to new token\n                loans[tokenId] = Loan(loans[oldTokenId].debtShares);\n\n                _addTokenToOwner(owner, tokenId);\n                emit Add(tokenId, owner, oldTokenId);\n\n                // clears data of old loan\n                _cleanupLoan(oldTokenId, debtExchangeRateX96, lendExchangeRateX96, owner);\n\n                // sets data of new loan\n                _updateAndCheckCollateral(\n                    tokenId, debtExchangeRateX96, lendExchangeRateX96, 0, loans[tokenId].debtShares\n                );\n            }\n        }\n\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    /// @notice Allows another address to call transform on behalf of owner (on a given token)\n    /// @param tokenId The token to be permitted\n    /// @param target The address to be allowed\n    /// @param isActive If it allowed or not\n    function approveTransform(uint256 tokenId, address target, bool isActive) external override {\n        if (tokenOwner[tokenId] != msg.sender) {\n            revert Unauthorized();\n        }\n        transformApprovals[msg.sender][tokenId][target] = isActive;\n\n        emit ApprovedTransform(tokenId, msg.sender, target, isActive);\n    }\n\n    /// @notice Method which allows a contract to transform a loan by changing it (and only at the end checking collateral)\n    /// @param tokenId The token ID to be"
    }
  ]
}