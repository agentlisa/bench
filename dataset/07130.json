{
  "Title": "[M-04] Users may not claim Erc1155 rewards when the Quest has ended",
  "Content": "# Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc1155Quest.sol#L60\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L114\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc1155Quest.sol#L41-L43\n\n\n# Vulnerability details\n\n## Impact\nUnlike Erc20Quest.sol, owner of Erc1155Quest.sol is going to withdraw the remaining tokens from the contract when `block.timestamp == endTime` without deducting the `unclaimedTokens`. As a result, users will be denied of service when attempting to call the inherited `claim()` from Quest.sol. \n\n## Proof of Concept\nAs can be seen from the code block below, when the Quest time has ended, `withdrawRemainingTokens()` is going to withdraw the remaining tokens from the contract on line 60:\n\n[File: Erc1155Quest.sol#L52-L63](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc1155Quest.sol#L52-L63)\n\n```solidity\n    /// @dev Withdraws the remaining tokens from the contract. Only able to be called by owner\n    /// @param to_ The address to send the remaining tokens to\n    function withdrawRemainingTokens(address to_) public override onlyOwner {\n        super.withdrawRemainingTokens(to_);\n        IERC1155(rewardToken).safeTransferFrom(\n            address(this),\n            to_,\n            rewardAmountInWeiOrTokenId,\n60:            IERC1155(rewardToken).balanceOf(address(this), rewardAmountInWeiOrTokenId),\n            '0x00'\n        );\n    }\n```\nWhen a user tries to call `claim()` below, line 114 is going to internally invoke `_transferRewards()`:\n\n[File: Quest.sol#L94-L118](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L94-L118)\n\n```solidity\n    /// @notice Allows user to claim the rewards entitled to them\n    /// @dev User can claim based on the (unclaimed) number of tokens they own of the Quest\n    function claim() public virtual onlyQuestActive {\n        if (isPaused) revert QuestPaused();\n\n        uint[] memory tokens = rabbitHoleReceiptContract.getOwnedTokenIdsOfQuest(questId, msg.sender);\n\n        if (tokens.length == 0) revert NoTokensToClaim();\n\n        uint256 redeemableTokenCount = 0;\n        for (uint i = 0; i < tokens.length; i++) {\n            if (!isClaimed(tokens[i])) {\n                redeemableTokenCount++;\n            }\n        }\n\n        if (redeemableTokenCount == 0) revert AlreadyClaimed();\n\n        uint256 totalRedeemableRewards = _calculateRewards(redeemableTokenCount);\n        _setClaimed(tokens);\n114:        _transferRewards(totalRedeemableRewards);\n        redeemedTokens += redeemableTokenCount;\n\n        emit Claimed(msg.sender, totalRedeemableRewards);\n    }\n```\n`safeTransferFrom()` is going to revert on line 42 because the token balance of the contract is now zero. i.e. less than `amount_`:\n\n[File: Erc1155Quest.sol#L39-L43](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc1155Quest.sol#L39-L43)\n\n```solidity\n    /// @dev Transfers the reward token `rewardAmountInWeiOrTokenId` to the msg.sender\n    /// @param amount_ The amount of reward tokens to transfer\n    function _transferRewards(uint256 amount_) internal override {\n42:        IERC1155(rewardToken).safeTransferFrom(address(this), msg.sender, rewardAmountInWeiOrTokenId, amount_, '0x00');\n    }\n```\n## Tools Used\nManual inspection\n\n## Recommended Mitigation Steps\nConsider refactoring `withdrawRemainingTokens()` as follows:\n\n(Note: The contract will have to separately import {QuestFactory} from './QuestFactory.sol' and initialize `questFactoryContract`.\n\n```diff\n+    function receiptRedeemers() public view returns (uint256) {\n+        return questFactoryContract.getNumberMinted(questId);\n+    }\n\n    function withdrawRemainingTokens(address to_) public override onlyOwner {\n        super.withdrawRemainingTokens(to_);\n\n+        uint unclaimedTokens = (receiptRedeemers() - redeemedTokens)\n+        uint256 nonClaimableTokens = IERC1155(rewardToken).balanceOf(address(this), rewardAmountInWeiOrTokenId) - unclaimedTokens;\n        IERC1155(rewardToken).safeTransferFrom(\n            address(this),\n            to_,\n            rewardAmountInWeiOrTokenId,\n-            IERC1155(rewardToken).balanceOf(address(this), rewardAmountInWeiOrTokenId),\n+            nonClaimableTokens,\n            '0x00'\n        );\n    }\n``` ",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-rabbithole-quest-protocol-contest",
  "Code": [
    {
      "filename": "contracts/Erc1155Quest.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {IERC1155} from '@openzeppelin/contracts/token/ERC1155/ERC1155.sol';\nimport {ERC1155Holder} from '@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol';\nimport {Quest} from './Quest.sol';\n\n/// @title Erc1155Quest\n/// @author RabbitHole.gg\n/// @dev This contract is used to create quests with a reward token that implements the ERC1155 standard\ncontract Erc1155Quest is Quest, ERC1155Holder {\n\n    constructor(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountInWeiOrTokenId_,\n        string memory questId_,\n        address receiptContractAddress_\n    )\n    Quest(\n        rewardTokenAddress_,\n        endTime_,\n        startTime_,\n        totalParticipants_,\n        rewardAmountInWeiOrTokenId_,\n        questId_,\n        receiptContractAddress_\n    ){}\n\n    /// @dev Checks the balance to ensure that it has enough for all of the participants. Only able to be called by owner\n    function start() public override {\n        if (IERC1155(rewardToken).balanceOf(address(this), rewardAmountInWeiOrTokenId) < totalParticipants)\n            revert TotalAmountExceedsBalance();\n        super.start();\n    }\n\n    /// @dev Transfers the reward token `rewardAmountInWeiOrTokenId` to the msg.sender\n    /// @param amount_ The amount of reward tokens to transfer\n    function _transferRewards(uint256 amount_) internal override {\n        IERC1155(rewardToken).safeTransferFrom(address(this), msg.sender, rewardAmountInWeiOrTokenId, amount_, '0x00');\n    }\n\n    /// @dev Returns the amount of rewards. Since an 1155 is just one token, this returns itself\n    /// @param redeemableTokenCount_ The amount of reward tokens that the user is eligible for\n    /// @return The amount of reward tokens that the user is eligible for\n    function _calculateRewards(uint256 redeemableTokenCount_) internal pure override returns (uint256) {\n        return redeemableTokenCount_;\n    }\n\n    /// @dev Withdraws the remaining tokens from the contract. Only able to be called by owner\n    /// @param to_ The address to send the remaining tokens to\n    function withdrawRemainingTokens(address to_) public override onlyOwner {\n        super.withdrawRemainingTokens(to_);\n        IERC1155(rewardToken).safeTransferFrom(\n            address(this),\n            to_,\n            rewardAmountInWeiOrTokenId,\n            IERC1155(rewardToken).balanceOf(address(this), rewardAmountInWeiOrTokenId),\n            '0x00'\n        );\n    }\n}"
    },
    {
      "filename": "contracts/Quest.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IQuest} from './interfaces/IQuest.sol';\nimport {RabbitHoleReceipt} from './RabbitHoleReceipt.sol';\nimport {ECDSA} from '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\n\n/// @title Quest\n/// @author RabbitHole.gg\n/// @notice This contract is the base contract for all Quests. The Erc20Quest and Erc1155Quest contracts inherit from this contract.\ncontract Quest is Ownable, IQuest {\n    RabbitHoleReceipt public immutable rabbitHoleReceiptContract;\n    address public immutable rewardToken;\n    uint256 public immutable endTime;\n    uint256 public immutable startTime;\n    uint256 public immutable totalParticipants;\n    uint256 public immutable rewardAmountInWeiOrTokenId;\n    bool public hasStarted;\n    bool public isPaused;\n    string public questId;\n    uint256 public redeemedTokens;\n\n    mapping(uint256 => bool) private claimedList;\n\n    constructor(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountInWeiOrTokenId_,\n        string memory questId_,\n        address receiptContractAddress_\n    ) {\n        if (endTime_ <= block.timestamp) revert EndTimeInPast();\n        if (startTime_ <= block.timestamp) revert StartTimeInPast();\n        if (endTime_ <= startTime_) revert EndTimeLessThanOrEqualToStartTime();\n        endTime = endTime_;\n        startTime = startTime_;\n        rewardToken = rewardTokenAddress_;\n        totalParticipants = totalParticipants_;\n        rewardAmountInWeiOrTokenId = rewardAmountInWeiOrTokenId_;\n        questId = questId_;\n        rabbitHoleReceiptContract = RabbitHoleReceipt(receiptContractAddress_);\n        redeemedTokens = 0;\n    }\n\n    /// @notice Starts the Quest\n    /// @dev Only the owner of the Quest can call this function\n    function start() public virtual onlyOwner {\n        isPaused = false;\n        hasStarted = true;\n    }\n\n    /// @notice Pauses the Quest\n    /// @dev Only the owner of the Quest can call this function. Also requires that the Quest has started (not by date, but by calling the start function)\n    function pause() public onlyOwner onlyStarted {\n        isPaused = true;\n    }\n\n    /// @notice Unpauses the Quest\n    /// @dev Only the owner of the Quest can call this function. Also requires that the Quest has started (not by date, but by calling the start function)\n    function unPause() public onlyOwner onlyStarted {\n        isPaused = false;\n    }\n\n    /// @notice Marks token ids as claimed\n    /// @param tokenIds_ The token ids to mark as claimed\n    function _setClaimed(uint256[] memory tokenIds_) private {\n        for (uint i = 0; i < tokenIds_.length; i++) {\n            claimedList[tokenIds_[i]] = true;\n        }\n    }\n\n    /// @notice Prevents reward withdrawal until the Quest has ended\n    modifier onlyAdminWithdrawAfterEnd() {\n        if (block.timestamp < endTime) revert NoWithdrawDuringClaim();\n        _;\n    }\n\n    /// @notice Checks if the Quest has started at the function level\n    modifier onlyStarted() {\n        if (!hasStarted) revert NotStarted();\n        _;\n    }\n\n    /// @notice Checks if quest has started both at the function level and at the start time\n    modifier onlyQuestActive() {\n        if (!hasStarted) revert NotStarted();\n        if (block.timestamp < startTime) revert ClaimWindowNotStarted();\n        _;\n    }\n\n    /// @notice Allows user to claim the rewards entitled to them\n    /// @dev User can claim based on the (unclaimed) number of tokens they own of the Quest\n    function claim() public virtual onlyQuestActive {\n        if (isPaused) revert QuestPaused();\n\n        uint[] memory tokens = rabbitHoleReceiptContract.getOwnedTokenIdsOfQuest(questId, msg.sender);\n\n        if (tokens.length == 0) revert NoTokensToClaim();\n\n        uint256 redeemableTokenCount = 0;\n        for (uint i = 0; i < tokens.length; i++) {\n            if (!isClaimed(tokens[i])) {\n                redeemableTokenCount++;\n            }\n        }\n\n        if (redeemableTokenCount == 0) revert AlreadyClaimed();\n\n        uint256 totalRedeemableRewards = _calculateRewards(redeemableTokenCount);\n        _setClaimed(tokens);\n        _transferRewards(totalRedeemableRewards);\n        redeemedTokens += redeemableTokenCount;\n\n        emit Claimed(msg.sender, totalRedeemableRewards);\n    }\n\n    /// @notice Calculate the amount of rewards\n    /// @dev This function must be implemented in the child contracts\n    function _calculateRewards(uint256 redeemableTokenCount_) internal virtual returns (uint256) {\n        revert MustImplementInChild();\n    }\n\n    /// @notice Transfer the rewards to the user\n    /// @dev This function must be implemented in the child contracts\n    /// @param amount_ The amount of rewards to transfer\n    function _transferRewards(uint256 amount_) internal virtual {\n        revert MustImplementInChild();\n    }\n\n    /// @notice Checks if a Receipt token id has been used to claim a reward\n    /// @param tokenId_ The token id to check\n    function isClaimed(uint256 tokenId_) public view returns (bool) {\n        return claimedList[tokenId_] == true;\n    }\n\n    /// @dev Returns the reward amount\n    function getRewardAmount() public view returns (uint256) {\n        return rewardAmountInWeiOrTokenId;\n    }\n\n    /// @dev Returns the reward token address\n    function getRewardToken() public view returns (address) {\n        return rewardToken;\n    }\n\n    /// @notice Allows the owner of the Quest to withdraw any remaining rewards after the Quest has ended\n    function withdrawRemainingTokens(address to_) public virtual onlyOwner onlyAdminWithdrawAfterEnd {}\n}"
    },
    {
      "filename": "contracts/Erc1155Quest.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {IERC1155} from '@openzeppelin/contracts/token/ERC1155/ERC1155.sol';\nimport {ERC1155Holder} from '@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol';\nimport {Quest} from './Quest.sol';\n\n/// @title Erc1155Quest\n/// @author RabbitHole.gg\n/// @dev This contract is used to create quests with a reward token that implements the ERC1155 standard\ncontract Erc1155Quest is Quest, ERC1155Holder {\n\n    constructor(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountInWeiOrTokenId_,\n        string memory questId_,\n        address receiptContractAddress_\n    )\n    Quest(\n        rewardTokenAddress_,\n        endTime_,\n        startTime_,\n        totalParticipants_,\n        rewardAmountInWeiOrTokenId_,\n        questId_,\n        receiptContractAddress_\n    ){}\n\n    /// @dev Checks the balance to ensure that it has enough for all of the participants. Only able to be called by owner\n    function start() public override {\n        if (IERC1155(rewardToken).balanceOf(address(this), rewardAmountInWeiOrTokenId) < totalParticipants)\n            revert TotalAmountExceedsBalance();\n        super.start();\n    }\n\n    /// @dev Transfers the reward token `rewardAmountInWeiOrTokenId` to the msg.sender\n    /// @param amount_ The amount of reward tokens to transfer\n    function _transferRewards(uint256 amount_) internal override {\n        IERC1155(rewardToken).safeTransferFrom(address(this), msg.sender, rewardAmountInWeiOrTokenId, amount_, '0x00');\n    }\n\n    /// @dev Returns the amount of rewards. Since an 1155 is just one token, this returns itself\n    /// @param redeemableTokenCount_ The amount of reward tokens that the user is eligible for\n    /// @return The amount of reward tokens that the user is eligible for\n    function _calculateRewards(uint256 redeemableTokenCount_) internal pure override returns (uint256) {\n        return redeemableTokenCount_;\n    }\n\n    /// @dev Withdraws the remaining tokens from the contract. Only able to be called by owner\n    /// @param to_ The address to send the remaining tokens to\n    function withdrawRemainingTokens(address to_) public override onlyOwner {\n        super.withdrawRemainingTokens(to_);\n        IERC1155(rewardToken).safeTransferFrom(\n            address(this),\n            to_,\n            rewardAmountInWeiOrTokenId,\n            IERC1155(rewardToken).balanceOf(address(this), rewardAmountInWeiOrTokenId),\n            '0x00'\n        );\n    }\n}"
    }
  ]
}