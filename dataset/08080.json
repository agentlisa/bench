{
  "Title": "[M-04] Founders can receive less tokens that expected",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-09-nouns-builder/blob/7e9fddbbacdd7d7812e912a369cfd862ee67dc03/src/token/Token.sol#L118\n\n\n# Vulnerability details\n\nBecause the IDs of the founders tokens are wrongly computed, some of them can have an id higher than 100 and then be never minted. \n\n## Proof of Concept\n\nIf a founder has percetage of `pct`, then `pct` IDs between 0 and 99 should be given to him in the mapping `tokenRecipient`, such that if a token is minted with `tokenId % 100` equal to one of its IDs, it is minted directly to him. But the modulo is not correctly done at when the mapping is filled, so some IDs of a founder can be higher than 100. \n\nIt happens for example if Alcie has 10% and Bob gas 11%. For Alice, `schedule` is equal to 10, so Alices will have the ids 0, 10, 20, ..., 90. But for Bob, `schedule` is also equal to 9. So it will have the ids 1, 11, 21, ..., 91, 100. Indeed, Bob can't have the ID 0 because it belongs to Alice, same for the ID 10 etc. The last eleventh ID that is given to Bob is 100, that can't be reached.\n\nThis happens for example when with two founders the percentages verify `(100 / pct1) - (100 / pct2) == 1`. So (11%, 12%) or (25%, 33%) will behave samely (with more token lost in some case).\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { TokenTest } from \"./Token.t.sol\";\n\ncontract TestMEP_M1 is TokenTest {\n\n    function setUpMEP() internal returns (address alice, address bob, uint256 totalOwnership) {\n        address[] memory wallets = new address[](2);\n        uint256[] memory percents = new uint256[](2);\n        uint256[] memory vestExpiries = new uint256[](2);\n\n        wallets[0] = alice = address(0x0a);\n        wallets[1] = bob = address(0x0b);\n\n        percents[0] = 10;\n        percents[1] = 11;\n        totalOwnership = percents[0] + percents[1];\n\n        vestExpiries[0] = type(uint256).max;\n        vestExpiries[1] = type(uint256).max;\n\n        deployWithCustomFounders(wallets, percents, vestExpiries);\n    }\n\n    // Verifies it on the 100 first tokens\n    function testMEP_M1_1() public {\n\n        (address alice, address bob, uint256 totalOwnership) = setUpMEP();\n\n        // Should mint the 100 first tokens\n        // Alice should receive 10 tokens\n        // Bob should receive 11 tokens\n        for (uint256 i; i < 100 - totalOwnership; ++i) {\n            vm.prank(address(auction));\n            token.mint();\n        }\n\n        assertEq(token.balanceOf(alice), 10, \"Alice's balance is wrong\");\n        assertEq(token.balanceOf(bob), 11, \"Bob's balance is wrong\");\n    }\n\n    // Verifies it with the law of large numbers\n    function testMEP_M1_2() public {\n\n        (address alice, address bob, ) = setUpMEP();\n\n        uint256 tokensToMint = 123456; // enough large to apply the law of large numbers\n        for (uint256 i; i < tokensToMint; ++i) {\n            vm.prank(address(auction));\n            token.mint();\n        }\n\n        uint256 totalSupply = token.totalSupply();\n        assertEq(token.balanceOf(alice) * 100 / totalSupply, 10, \"Alice's percentage is wrong\");\n        assertEq(token.balanceOf(bob) * 100 / totalSupply, 11, \"Bob's percentage is wrong\");\n    }\n}\n\n```\n\n## Recommended Mitigation Steps\n\nReplace the line 118 of `Token.sol` by `baseTokenId = (baseTokenId + schedule) % 100;`.\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-nouns-builder-contest",
  "Code": [
    {
      "filename": "src/token/Token.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { UUPS } from \"../lib/proxy/UUPS.sol\";\nimport { ReentrancyGuard } from \"../lib/utils/ReentrancyGuard.sol\";\nimport { ERC721Votes } from \"../lib/token/ERC721Votes.sol\";\nimport { ERC721 } from \"../lib/token/ERC721.sol\";\n\nimport { TokenStorageV1 } from \"./storage/TokenStorageV1.sol\";\nimport { IBaseMetadata } from \"./metadata/interfaces/IBaseMetadata.sol\";\nimport { IManager } from \"../manager/IManager.sol\";\nimport { IToken } from \"./IToken.sol\";\n\n/// @title Token\n/// @author Rohan Kulkarni\n/// @notice A DAO's ERC-721 governance token\ncontract Token is IToken, UUPS, ReentrancyGuard, ERC721Votes, TokenStorageV1 {\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IManager private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IManager(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /// @notice Initializes a DAO's ERC-721 token contract\n    /// @param _founders The DAO founders\n    /// @param _initStrings The encoded token and metadata initialization strings\n    /// @param _metadataRenderer The token's metadata renderer\n    /// @param _auction The token's auction house\n    function initialize(\n        IManager.FounderParams[] calldata _founders,\n        bytes calldata _initStrings,\n        address _metadataRenderer,\n        address _auction\n    ) external initializer {\n        // Ensure the caller is the contract manager\n        if (msg.sender != address(manager)) revert ONLY_MANAGER();\n\n        // Initialize the reentrancy guard\n        __ReentrancyGuard_init();\n\n        // Store the founders and compute their allocations\n        _addFounders(_founders);\n\n        // Decode the token name and symbol\n        (string memory _name, string memory _symbol, , , ) = abi.decode(_initStrings, (string, string, string, string, string));\n\n        // Initialize the ERC-721 token\n        __ERC721_init(_name, _symbol);\n\n        // Store the metadata renderer and auction house\n        settings.metadataRenderer = IBaseMetadata(_metadataRenderer);\n        settings.auction = _auction;\n    }\n\n    /// @dev Called upon initialization to add founders and compute their vesting allocations\n    /// @param _founders The list of DAO founders\n    function _addFounders(IManager.FounderParams[] calldata _founders) internal {\n        // Cache the number of founders\n        uint256 numFounders = _founders.length;\n\n        // Used to store the total percent ownership among the founders\n        uint256 totalOwnership;\n\n        unchecked {\n            // For each founder:\n            for (uint256 i; i < numFounders; ++i) {\n                // Cache the percent ownership\n                uint256 founderPct = _founders[i].ownershipPct;\n\n                // Continue if no ownership is specified\n                if (founderPct == 0) continue;\n\n                // Update the total ownership and ensure it's valid\n                if ((totalOwnership += uint8(founderPct)) > 100) revert INVALID_FOUNDER_OWNERSHIP();\n\n                // Compute the founder's id\n                uint256 founderId = settings.numFounders++;\n\n                // Get the pointer to store the founder\n                Founder storage newFounder = founder[founderId];\n\n                // Store the founder's vesting details\n                newFounder.wallet = _founders[i].wallet;\n                newFounder.vestExpiry = uint32(_founders[i].vestExpiry);\n                newFounder.ownershipPct = uint8(founderPct);\n\n                // Compute the vesting schedule\n                uint256 schedule = 100 / founderPct;\n\n                // Used to store the base token id the founder will recieve\n                uint256 baseTokenId;\n\n                // For each token to vest:\n                for (uint256 j; j < founderPct; ++j) {\n                    // Get the available token id\n                    baseTokenId = _getNextTokenId(baseTokenId);\n\n                    // Store the founder as the recipient\n                    tokenRecipient[baseTokenId] = newFounder;\n\n                    emit MintScheduled(baseTokenId, founderId, newFounder);\n\n                    // Update the base token id\n                    (baseTokenId += schedule) % 100;\n                }\n            }\n\n            // Store the founders' details\n            settings.totalOwnership = uint8(totalOwnership);\n            settings.numFounders = uint8(numFounders);\n        }\n    }\n\n    /// @dev Finds the next available base token id for a founder\n    /// @param _tokenId The ERC-721 token id\n    function _getNextTokenId(uint256 _tokenId) internal view returns (uint256) {\n        unchecked {\n            while (tokenRecipient[_tokenId].wallet != address(0)) ++_tokenId;\n\n            return _tokenId;\n        }\n    }\n\n    ///                                                          ///\n    ///                             MINT                         ///\n    ///                                                          ///\n\n    /// @notice Mints tokens to the auction house for bidding and handles founder vesting\n    function mint() external nonReentrant returns (uint256 tokenId) {\n        // Cache the auction address\n        address minter = settings.auction;\n\n        // Ensure the caller is the auction\n        if (msg.sender != minter) revert ONLY_AUCTION();\n\n        // Cannot realistically overflow\n        unchecked {\n            do {\n                // Get the next token to mint\n                tokenId = settings.totalSupply++;\n\n                // Lookup whether the token is for a founder, and mint accordingly if so\n            } while (_isForFounder(tokenId));\n        }\n\n        // Mint the next available token to the auction house for bidding\n        _mint(minter, tokenId);\n    }\n\n    /// @dev Overrides _mint to include attribute generation\n    /// @param _to The token recipient\n    /// @param _tokenId The ERC-721 token id\n    function _mint(address _to, uint256 _tokenId) internal override {\n        // Mint the token\n        super._mint(_to, _tokenId);\n\n        // Generate the token attributes\n        if (!settings.metadataRenderer.onMinted(_tokenId)) revert NO_METADATA_GENERATED();\n    }\n\n    /// @dev Checks if a given token is for a founder and mints accordingly\n    /// @param _tokenId The ERC-721 token id\n    function _isForFounder(uint256 _tokenId) private returns (bool) {\n        // Get the base token id\n        uint256 baseTokenId = _tokenId % 100;\n\n        // If there is no scheduled recipient:\n        if (tokenRecipient[baseTokenId].wallet == address(0)) {\n            return false;\n\n            // Else if the founder is still vesting:\n        } else if (block.timestamp < tokenRecipient[baseTokenId].vestExpiry) {\n            // Mint the token to the founder\n            _mint(tokenRecipient[baseTokenId].wallet, _tokenId);\n\n            return true;\n\n            // Else the founder has finished vesting:\n        } else {\n            // Remove them from future lookups\n            delete tokenRecipient[baseTokenId];\n\n            return false;\n        }\n    }\n\n    ///                                                          ///\n    ///                             BURN                         ///\n    ///                                                          ///\n\n    /// @notice Burns a token that did not see any bids\n    /// @param _tokenId The ERC-721 token id\n    function burn(uint256 _tokenId) external {\n        // Ensure the caller is the auction house\n        if (msg.sender != settings.auction) revert ONLY_AUCTION();\n\n        // Burn the token\n        _burn(_tokenId);\n    }\n\n    ///                                                          ///\n    ///                           METADATA                       ///\n    ///                                                          ///\n\n    /// @notice The URI for a token\n    /// @param _tokenId The ERC-721 token id\n    function tokenURI(uint256 _tokenId) public view override(IToken, ERC721) returns (string memory) {\n        return settings.metadataRenderer.tokenURI(_tokenId);\n    }\n\n    /// @notice The URI for the contract\n    function contractURI() public view override(IToken, ERC721) returns (string memory) {\n        return settings.metadataRenderer.contractURI();\n    }\n\n    ///                                                          ///\n    ///                           FOUNDERS                       ///\n    ///                                                          ///\n\n    /// @notice The number of founders\n    function totalFounders() external view returns (uint256) {\n        return settings.numFounders;\n    }\n\n    /// @notice The founders total percent ownership\n    function totalFounderOwnership() external view returns (uint256) {\n        return settings.totalOwnership;\n    }\n\n    /// @notice The vesting details of a founder\n    /// @param _founderId The founder id\n    function getFounder(uint256 _founderId) external view returns (Founder memory) {\n        return founder[_founderId];\n    }\n\n    /// @notice The vesting details of all founders\n    function getFounders() external view returns (Founder[] memory) {\n        // Cache the number of founders\n        uint256 numFounders = settings.numFounders;\n\n        // Get a temporary array to hold all founders\n        Founder[] memory founders = new Founder[](numFounders);\n\n        // Cannot realistically overflow\n        unchecked {\n            // Add each founder to the array\n            for (uint256 i; i < numFounders; ++i) founders[i] = founder[i];\n        }\n\n        return founders;\n    }\n\n    /// @notice The founder scheduled to receive the given token id\n    /// NOTE: If a founder is returned, there's no guarantee they'll receive the token as vesting expiration is not considered\n    /// @param _tokenId The ERC-721 token id\n    function getScheduledRecipient(uint256 _tokenId) external view returns (Founder memory) {\n        return tokenRecipient[_tokenId % 100];\n    }\n\n    ///                                                          ///\n    ///                           SETTINGS                       ///\n    ///                                                          ///\n\n    /// @notice The total supply of tokens\n    function totalSupply() external view returns (uint256) {\n        return settings.totalSupply;\n    }\n\n    /// @notice The address of the auction house\n    function auction() external view returns (address) {\n        return settings.auction;\n    }\n\n    /// @notice The address of the metadata renderer\n    function metadataRenderer() external view returns (address) {\n        return address(settings.metadataRenderer);\n    }\n\n    /// @notice The address of the owner\n    function owner() public view returns (address) {\n        return settings.metadataRenderer.owner();\n    }\n\n    ///                                                          ///\n    ///                         TOKEN UPGRADE                    ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override {\n        // Ensure the caller is the shared owner of the token and metadata renderer\n        if (msg.sender != owner()) revert ONLY_OWNER();\n\n        // Ensure the implementation is valid\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    }
  ]
}