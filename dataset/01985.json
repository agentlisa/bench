{
  "Title": "M-13: Missing checks for whether Arbitrum Sequencer is active",
  "Content": "# Issue M-13: Missing checks for whether Arbitrum Sequencer is active \n\nSource: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/142 \n\n## Found by \n0xepley, Bauchibred, Bauer, Brenzee, J4de, ctf\\_sec, deadrxsezzz, tallo, tsvetanovv\n## Summary\n\nMissing checks for whether Arbitrum Sequencer is active\n\n## Vulnerability Detail\n\nthe onchain deployment context is changed, in prev contest the protocol only attemps to deploy the code to ethereum while in the current contest\n\nthe protocol intends to deploy to arbtrium as well!\n\nChainlink recommends that users using price oracles, check whether the Arbitrum sequencer is active\n\nhttps://docs.chain.link/data-feeds#l2-sequencer-uptime-feeds\n\nIf the sequencer goes down, the index oracles may have stale prices, since L2-submitted transactions (i.e. by the aggregating oracles) will not be processed.\n\n## Impact\n\nStale prices, e.g. if USDC were to de-peg while the sequencer is offline, stale price is used and can result in false liquidation or over-borrowing.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol#L76-L98\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse sequencer oracle to determine whether the sequencer is offline or not, and don't allow orders to be executed while the sequencer is offline.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/69",
  "Code": [
    {
      "filename": "blueberry-core/contracts/oracle/ChainlinkAdapterOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BaseAdapter.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/chainlink/IFeedRegistry.sol\";\n\n/**\n * @author BlueberryProtocol\n * @title ChainlinkAdapterOracle\n * @notice Oracle Adapter contract which provides price feeds from Chainlink\n */\ncontract ChainlinkAdapterOracle is IBaseOracle, BaseAdapter {\n    using SafeCast for int256;\n\n    // Chainlink denominations\n    // (source: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/Denominations.sol)\n    IFeedRegistry public registry;\n    address public constant USD = address(840);\n\n    /// @dev Mapping from original token to remapped token for price querying (e.g. WBTC -> BTC, WETH -> ETH)\n    mapping(address => address) public remappedTokens;\n\n    event SetRegistry(address registry);\n    event SetTokenRemapping(\n        address indexed token,\n        address indexed remappedToken\n    );\n\n    constructor(IFeedRegistry registry_) {\n        if (address(registry_) == address(0)) revert Errors.ZERO_ADDRESS();\n\n        registry = registry_;\n    }\n\n    /// @notice Set chainlink feed registry source\n    /// @param registry_ Chainlink feed registry source\n    function setFeedRegistry(IFeedRegistry registry_) external onlyOwner {\n        if (address(registry_) == address(0)) revert Errors.ZERO_ADDRESS();\n        registry = registry_;\n        emit SetRegistry(address(registry_));\n    }\n\n    /// @notice Set token remapping\n    /// @param tokens_ List of tokens to set remapping\n    /// @param remappedTokens_ List of tokens to set remapping to\n    function setTokenRemappings(\n        address[] calldata tokens_,\n        address[] calldata remappedTokens_\n    ) external onlyOwner {\n        if (remappedTokens_.length != tokens_.length)\n            revert Errors.INPUT_ARRAY_MISMATCH();\n        for (uint256 idx = 0; idx < tokens_.length; idx++) {\n            if (tokens_[idx] == address(0)) revert Errors.ZERO_ADDRESS();\n\n            remappedTokens[tokens_[idx]] = remappedTokens_[idx];\n            emit SetTokenRemapping(tokens_[idx], remappedTokens_[idx]);\n        }\n    }\n\n    /**\n     * @notice Returns the USD price of given token, price value has 18 decimals\n     * @param token_ Token address to get price of\n     * @return price USD price of token in 18 decimal\n     */\n    function getPrice(address token_) external view override returns (uint256) {\n        // remap token if possible\n        address token = remappedTokens[token_];\n        if (token == address(0)) token = token_;\n\n        uint256 maxDelayTime = timeGaps[token];\n        if (maxDelayTime == 0) revert Errors.NO_MAX_DELAY(token_);\n\n        // Get token-USD price\n        uint256 decimals = registry.decimals(token, USD);\n        (, int256 answer, , uint256 updatedAt, ) = registry.latestRoundData(\n            token,\n            USD\n        );\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert Errors.PRICE_OUTDATED(token_);\n        if (answer <= 0) revert Errors.PRICE_NEGATIVE(token_);\n\n        return\n            (answer.toUint256() * Constants.PRICE_PRECISION) / 10 ** decimals;\n    }\n}"
    }
  ]
}