{
  "Title": "Mixed `msg.sender` and `_msgSender()`",
  "Content": "##### Description\nIn some contracts used directly `msg.sender` instead of `_msgSender()`:\n- https://github.com/bondappetit/bondappetit-protocol/blob/88680691fe8d872c5fc26e9500d19cf7caaa9861/contracts/Staking.sol#L173\n- https://github.com/bondappetit/bondappetit-protocol/blob/88680691fe8d872c5fc26e9500d19cf7caaa9861/contracts/StableToken.sol#L12\n- etc..\n\nsince OZ contract introduce Context based contract, all derived ones should use `_msgSender()`\n\n##### Recommendation\nWe recommend to replace `msg.sender` to `_msgSender()` \n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Staking.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./utils/OwnablePausable.sol\";\n\ncontract Staking is OwnablePausable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @notice Address of rewards distributor.\n    address public rewardsDistribution;\n\n    /// @notice Rewards token address.\n    IERC20 public rewardsToken;\n\n    /// @notice Staking token address.\n    IERC20 public stakingToken;\n\n    /// @notice Block number of rewards distibution period finish.\n    uint256 public periodFinish;\n\n    /// @notice Reward distribution amount per block.\n    uint256 public rewardRate;\n\n    /// @notice Blocks count in current distribution period.\n    uint256 public rewardsDuration;\n\n    /// @notice Block number of last update.\n    uint256 public lastUpdateBlock;\n\n    /// @notice Static reward distribution amount per block.\n    uint256 public rewardPerTokenStored;\n\n    /// @notice Staking completion block number.\n    uint256 public stakingEndBlock;\n\n    /// @notice Unstaking start block number.\n    uint256 public unstakingStartBlock;\n\n    /// @notice Rewards paid.\n    mapping(address => uint256) public userRewardPerTokenPaid;\n\n    /// @notice Earned rewards.\n    mapping(address => uint256) public rewards;\n\n    /// @dev Total staking token amount.\n    uint256 internal _totalSupply;\n\n    /// @dev Staking balances.\n    mapping(address => uint256) internal _balances;\n\n    /// @notice An event thats emitted when an reward token addet to contract.\n    event RewardAdded(uint256 reward);\n\n    /// @notice An event thats emitted when an staking token added to contract.\n    event Staked(address indexed user, uint256 amount);\n\n    /// @notice An event thats emitted when an staking token withdrawal from contract.\n    event Withdrawn(address indexed user, uint256 amount);\n\n    /// @notice An event thats emitted when an reward token withdrawal from contract.\n    event RewardPaid(address indexed user, uint256 reward);\n\n    /// @notice An event thats emitted when an rewards distribution address changed.\n    event RewardsDistributionChanged(address newRewardsDistribution);\n\n    /// @notice An event thats emitted when an rewards tokens transfered to recipient.\n    event RewardsTransfered(address recipient, uint256 amount);\n\n    /// @notice An event thats emitted when an staking end block number changed.\n    event StakingEndBlockChanged(uint256 newBlockNumber);\n\n    /// @notice An event thats emitted when an unstaking start block number changed.\n    event UnstakingStartBlockChanged(uint256 newBlockNumber);\n\n    /**\n     * @param _rewardsDistribution Rewards distribution address.\n     * @param _rewardsDuration Duration of distribution.\n     * @param _rewardsToken Address of reward token.\n     * @param _stakingToken Address of staking token.\n     */\n    constructor(\n        address _rewardsDistribution,\n        uint256 _rewardsDuration,\n        address _rewardsToken,\n        address _stakingToken,\n        uint256 _stakingEndBlock,\n        uint256 _unstakingStartBlock\n    ) public {\n        rewardsDistribution = _rewardsDistribution;\n        rewardsDuration = _rewardsDuration;\n        rewardsToken = IERC20(_rewardsToken);\n        stakingToken = IERC20(_stakingToken);\n        stakingEndBlock = _stakingEndBlock;\n        unstakingStartBlock = _unstakingStartBlock;\n    }\n\n    /**\n     * @notice Update target account rewards state.\n     * @param account Target account.\n     */\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateBlock = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /**\n     * @return Total staking token amount.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @param account Target account.\n     * @return Staking token amount.\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @return Block number of last reward.\n     */\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.number, periodFinish);\n    }\n\n    /**\n     * @return Reward per token.\n     */\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return rewardPerTokenStored.add(lastTimeRewardApplicable().sub(lastUpdateBlock).mul(rewardRate).mul(1e18).div(_totalSupply));\n    }\n\n    /**\n     * @param account Target account.\n     * @return Earned rewards.\n     */\n    function earned(address account) public view returns (uint256) {\n        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n    }\n\n    /**\n     * @return Rewards amount for duration.\n     */\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    /**\n     * @notice Stake token.\n     * @param amount Amount staking token.\n     */\n    function stake(uint256 amount) external nonReentrant updateReward(msg.sender) {\n        require(amount > 0, \"Staking::stake: cannot stake 0\");\n        if (stakingEndBlock > 0) {\n            require(block.number < stakingEndBlock, \"Staking:stake: staking completed\");\n        }\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    /**\n     * @notice Withdraw staking token.\n     * @param amount Amount withdraw token.\n     */\n    function withdraw(uint256 amount) public nonReentrant updateReward(msg.sender) {\n        require(amount > 0, \"Staking::withdraw: Cannot withdraw 0\");\n        require(block.number >= unstakingStartBlock, \"Staking:withdraw: unstaking not started\");\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    /**\n     * @notice Withdraw reward token.\n     */\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    /**\n     * @notice Withdraw reward and staking token.\n     */\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    /**\n     * @notice Change rewards distribution address.\n     * @param _rewardDistribution New rewards distribution address.\n     */\n    function changeRewardsDistribution(address _rewardDistribution) external onlyOwner {\n        rewardsDistribution = _rewardDistribution;\n        emit RewardsDistributionChanged(rewardsDistribution);\n    }\n\n    /**\n     * @notice Transfer rewards token to recipient if distribution not start.\n     * @param recipient Recipient.\n     * @param amount Amount transfered rewards token.\n     */\n    function transfer(address recipient, uint256 amount) external onlyOwner {\n        require(block.number >= periodFinish, \"Staking::transfer: distribution not ended\");\n\n        rewardsToken.safeTransfer(recipient, amount);\n        emit RewardsTransfered(recipient, amount);\n    }\n\n    /**\n     * @notice Change staking end block number.\n     * @param _stakingEndBlock New staking end block number.\n     */\n    function changeStakingEndBlock(uint256 _stakingEndBlock) external onlyOwner {\n        stakingEndBlock = _stakingEndBlock;\n        emit StakingEndBlockChanged(stakingEndBlock);\n    }\n\n    /**\n     * @notice Change unstaking start block number.\n     * @param _unstakingStartBlock New unstaking start block number.\n     */\n    function changeUnstakingStartBlock(uint256 _unstakingStartBlock) external onlyOwner {\n        unstakingStartBlock = _unstakingStartBlock;\n        emit UnstakingStartBlockChanged(unstakingStartBlock);\n    }\n\n    /**\n     * @notice Start distribution.\n     * @param reward Distributed rewards amount.\n     */\n    function notifyRewardAmount(uint256 reward) external updateReward(address(0)) {\n        require(msg.sender == rewardsDistribution || msg.sender == owner(), \"Staking::notifyRewardAmount: caller is not RewardsDistribution or Owner address\");\n\n        if (block.number >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.number);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        require(rewardRate <= balance.div(rewardsDuration), \"Staking::notifyRewardAmount: provided reward too high\");\n\n        lastUpdateBlock = block.number;\n        periodFinish = block.number.add(rewardsDuration);\n        emit RewardAdded(reward);\n    }\n}"
    },
    {
      "filename": "contracts/StableToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./utils/AccessControl.sol\";\n\ncontract StableToken is ERC20, AccessControl {\n    /**\n     * @param initialSupply Total supply.\n     */\n    constructor(uint256 initialSupply) public ERC20(\"Appetite USD\", \"USDp\") {\n        _mint(msg.sender, initialSupply);\n    }\n\n    /**\n     * @param account Recipient of created token.\n     * @param amount Amount of token to be created.\n     */\n    function mint(address account, uint256 amount) public onlyAllowed {\n        _mint(account, amount);\n    }\n\n    /**\n     * @param account Owner of removed token.\n     * @param amount Amount of token to be removed.\n     */\n    function burn(address account, uint256 amount) public onlyAllowed {\n        _burn(account, amount);\n    }\n}"
    }
  ]
}