{
  "Title": "[M-02] Hidden governance",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L11\n\n\n# Vulnerability details\n\n## Impact\nThe contract use two governance model, one looks hidden.\n\n## Proof of Concept\nThe VUSD contract uses `VanillaGovernable` but inherits from `ERC20PresetMinterPauserUpgradeable` and this contract uses roles to use some administrative methods like `pause` or `mint`.\n\nThis two-governance model does not seem necessary and can hide or raise suspicion about a rogue pool, thus damaging the user's trust.\n\n## Recommended Mitigation Steps\nUnify governance in only one, VanillaGovernable or role based.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-hubble-contest",
  "Code": [
    {
      "filename": "contracts/VUSD.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC20PresetMinterPauserUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\n\nimport { VanillaGovernable } from \"./legos/Governable.sol\";\n\ncontract VUSD is VanillaGovernable, ERC20PresetMinterPauserUpgradeable {\n    using SafeERC20 for IERC20;\n\n    struct Withdrawal {\n        address usr;\n        uint amount;\n    }\n\n    /// @notice vUSD is backed 1:1 with reserveToken (USDC)\n    IERC20 public immutable reserveToken;\n\n    Withdrawal[] public withdrawals;\n\n    /// @dev withdrawals will start processing at withdrawals[start]\n    uint public start;\n\n    /// @dev Constrained by block gas limit\n    uint public maxWithdrawalProcesses;\n\n    uint256[50] private __gap;\n\n    constructor(address _reserveToken) {\n        require(_reserveToken != address(0), \"vUSD: null _reserveToken\");\n        reserveToken = IERC20(_reserveToken);\n    }\n\n    function init(address _governance) external {\n        super.initialize(\"Hubble USD\", \"hUSD\"); // has initializer modifier\n        _setGovernace(_governance);\n        maxWithdrawalProcesses = 100;\n    }\n\n    function mintWithReserve(address to, uint amount) external {\n        reserveToken.safeTransferFrom(msg.sender, address(this), amount);\n        _mint(to, amount);\n    }\n\n    function withdraw(uint amount) external {\n        burn(amount);\n        withdrawals.push(Withdrawal(msg.sender, amount));\n    }\n\n    function processWithdrawals() external {\n        uint reserve = reserveToken.balanceOf(address(this));\n        require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');\n        uint i = start;\n        while (i < withdrawals.length && (i - start) <= maxWithdrawalProcesses) {\n            Withdrawal memory withdrawal = withdrawals[i];\n            if (reserve < withdrawal.amount) {\n                break;\n            }\n            reserveToken.safeTransfer(withdrawal.usr, withdrawal.amount);\n            reserve -= withdrawal.amount;\n            i += 1;\n        }\n        start = i;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n    function setMaxWithdrawalProcesses(uint _maxWithdrawalProcesses) external onlyGovernance {\n        maxWithdrawalProcesses = _maxWithdrawalProcesses;\n    }\n}"
    }
  ]
}