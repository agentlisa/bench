{
  "Title": "[M-09] Calling transferEth function can revert if receiver input corresponds to a contract that is unable to receive ETH through its receive or fallback function",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/utils/LibAddress.sol#L8-L15\nhttps://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/Crowdfund.sol#L444-L489\nhttps://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/distribution/TokenDistributor.sol#L371-L388\n\n\n# Vulnerability details\n\n## Impact\nThe following `transferEth` function is called when calling the `_burn` or `_transfer` function below. If the `receiver` input for the `transferEth` function corresponds to a contract, it is possible that the receiver contract does not, intentionally or unintentionally, implement the `receive` or `fallback` function in a way that supports receiving ETH or that calling the receiver contract's `receive` or `fallback` function executes complicated logics that cost much gas, which could cause calling `transferEth` to revert. For example, when calling `transferEth` reverts, calling `_burn` also reverts; this means that the receiver contract would not be able to get the voting power and receive the extra contribution it made after the crowdfunding finishes; yet, the receiver contract deserves these voting power and contribution refund. Hence, the receiver contract loses valuables that it deserves, which is unfair to the users who controls it.\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/utils/LibAddress.sol#L8-L15\n```solidity\n    function transferEth(address payable receiver, uint256 amount)\n        internal\n    {\n        (bool s, bytes memory r) = receiver.call{value: amount}(\"\");\n        if (!s) {\n            revert EthTransferFailed(receiver, r);\n        }\n    }\n```\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/crowdfund/Crowdfund.sol#L444-L489\n```solidity\n    function _burn(address payable contributor, CrowdfundLifecycle lc, Party party_)\n        private\n    {\n        // If the CF has won, a party must have been created prior.\n        if (lc == CrowdfundLifecycle.Won) {\n            if (party_ == Party(payable(0))) {\n                revert NoPartyError();\n            }\n        } else if (lc != CrowdfundLifecycle.Lost) {\n            // Otherwise it must have lost.\n            revert WrongLifecycleError(lc);\n        }\n        // Split recipient can burn even if they don't have a token.\n        if (contributor == splitRecipient) {\n            if (_splitRecipientHasBurned) {\n                revert SplitRecipientAlreadyBurnedError();\n            }\n            _splitRecipientHasBurned = true;\n        }\n        // Revert if already burned or does not exist.\n        if (splitRecipient != contributor || _doesTokenExistFor(contributor)) {\n            CrowdfundNFT._burn(contributor);\n        }\n        // Compute the contributions used and owed to the contributor, along\n        // with the voting power they'll have in the governance stage.\n        (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) =\n            _getFinalContribution(contributor);\n        if (votingPower > 0) {\n            // Get the address to delegate voting power to. If null, delegate to self.\n            address delegate = delegationsByContributor[contributor];\n            if (delegate == address(0)) {\n                // Delegate can be unset for the split recipient if they never\n                // contribute. Self-delegate if this occurs.\n                delegate = contributor;\n            }\n            // Mint governance NFT for the contributor.\n            party_.mint(\n                contributor,\n                votingPower,\n                delegate\n            );\n        }\n        // Refund any ETH owed back to the contributor.\n        contributor.transferEth(ethOwed);\n        emit Burned(contributor, ethUsed, ethOwed, votingPower);\n    }\n```\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/main/contracts/distribution/TokenDistributor.sol#L371-L388\n```solidity\n    function _transfer(\n        TokenType tokenType,\n        address token,\n        address payable recipient,\n        uint256 amount\n    )\n        private\n    {\n        bytes32 balanceId = _getBalanceId(tokenType, token);\n        // Reduce stored token balance.\n        _storedBalances[balanceId] -= amount;\n        if (tokenType == TokenType.Native) {\n            recipient.transferEth(amount);\n        } else {\n            assert(tokenType == TokenType.Erc20);\n            IERC20(token).compatTransfer(recipient, amount);\n        }\n    }\n```\n\n## Proof of Concept\nPlease add the following `error` and append the test in `sol-tests\\crowdfund\\BuyCrowdfund.t.sol`. This test will pass to demonstrate the described scenario.\n\n```solidity\n    error EthTransferFailed(address receiver, bytes errData);\n\n    function testContributorContractFailsToReceiveETH() public {\n        uint256 tokenId = erc721Vault.mint();\n        BuyCrowdfund pb = _createCrowdfund(tokenId, 0);\n\n        // This contract is used to simulate a contract that does not implement the receive or fallback function for the purpose of receiving ETH.\n        address payable contributorContract = payable(address(this));\n        vm.deal(contributorContract, 1e18);\n\n        address delegate = _randomAddress();\n\n        // contributorContract contributes 1e18.\n        vm.prank(contributorContract);\n        pb.contribute{ value: 1e18 }(delegate, \"\");\n\n        // The price of the NFT of interest is 0.5e18.\n        Party party_ = pb.buy(\n            payable(address(erc721Vault)),\n            0.5e18,\n            abi.encodeCall(erc721Vault.claim, (tokenId)),\n            defaultGovernanceOpts\n        );\n\n        // After calling the buy function, the party is created with the NFT.\n        assertEq(address(party), address(party_));\n        assertTrue(pb.getCrowdfundLifecycle() == Crowdfund.CrowdfundLifecycle.Won);\n        assertEq(pb.settledPrice(), 0.5e18);\n        assertEq(pb.totalContributions(), 1e18);\n        assertEq(address(pb).balance, 1e18 - 0.5e18);\n\n        // Calling the burn function reverts because contributorContract cannot receive ETH through the receive or fallback function\n        vm.expectRevert(abi.encodeWithSelector(\n            EthTransferFailed.selector,\n            contributorContract,\n            \"\"\n        ));\n        pb.burn(contributorContract);\n\n        // contributorContract does not receive 0.5e18 back from the BuyCrowdfund contract.\n        assertEq(contributorContract.balance, 0);\n    }\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nWhen calling the `transferEth` function, if the receiver contract is unable to receive ETH through its `receive` or `fallback` function, WETH can be used to deposit the corresponding ETH amount, and the deposited amount can be transferred to the receiver contract.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/utils/LibAddress.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nlibrary LibAddress {\n    error EthTransferFailed(address receiver, bytes errData);\n\n    // Transfer ETH with full gas stipend.\n    function transferEth(address payable receiver, uint256 amount)\n        internal\n    {\n        (bool s, bytes memory r) = receiver.call{value: amount}(\"\");\n        if (!s) {\n            revert EthTransferFailed(receiver, r);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/crowdfund/Crowdfund.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../party/Party.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\nimport \"./CrowdfundNFT.sol\";\n\n// Base contract for AuctionCrowdfund/BuyCrowdfund.\n// Holds post-win/loss logic. E.g., burning contribution NFTs and creating a\n// party after winning.\nabstract contract Crowdfund is ERC721Receiver, CrowdfundNFT {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    enum CrowdfundLifecycle {\n        Invalid,\n        Active,\n        Expired,\n        Busy, // Temporary. mid-settlement state\n        Lost,\n        Won\n    }\n\n    // PartyGovernance options that must be known and fixed at crowdfund creation.\n    // This is a subset of PartyGovernance.GovernanceOpts.\n    struct FixedGovernanceOpts {\n        // Address of initial party hosts.\n        address[] hosts;\n        // How long people can vote on a proposal.\n        uint40 voteDuration;\n        // How long to wait after a proposal passes before it can be\n        // executed.\n        uint40 executionDelay;\n        // Minimum ratio of accept votes to consider a proposal passed,\n        // in bps, where 10,000 == 100%.\n        uint16 passThresholdBps;\n        // Fee bps for governance distributions.\n        uint16 feeBps;\n        // Fee recipeint for governance distributions.\n        address payable feeRecipient;\n    }\n\n    // Options to be passed into `_initialize()` when the crowdfund is created.\n    struct CrowdfundOptions {\n        string name;\n        string symbol;\n        address payable splitRecipient;\n        uint16 splitBps;\n        address initialContributor;\n        address initialDelegate;\n        IGateKeeper gateKeeper;\n        bytes12 gateKeeperId;\n        FixedGovernanceOpts governanceOpts;\n    }\n\n    // A record of a single contribution made by a user.\n    // Stored in `_contributionsByContributor`.\n    struct Contribution {\n        // The value of `Crowdfund.totalContributions` when this contribution was made.\n        uint96 previousTotalContributions;\n        // How much was this contribution.\n        uint96 amount;\n    }\n\n    error PartyAlreadyExistsError(Party party);\n    error WrongLifecycleError(CrowdfundLifecycle lc);\n    error InvalidGovernanceOptionsError(bytes32 actualHash, bytes32 expectedHash);\n    error InvalidDelegateError();\n    error NoPartyError();\n    error OnlyContributorAllowedError();\n    error NotAllowedByGateKeeperError(address contributor, IGateKeeper gateKeeper, bytes12 gateKeeperId, bytes gateData);\n    error SplitRecipientAlreadyBurnedError();\n    error InvalidBpsError(uint16 bps);\n\n    event Burned(address contributor, uint256 ethUsed, uint256 ethOwed, uint256 votingPower);\n    event Contributed(address contributor, uint256 amount, address delegate, uint256 previousTotalContributions);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The party instance created by `_createParty()`, if any after a\n    ///         successful crowdfund.\n    Party public party;\n    /// @notice The total (recorded) ETH contributed to this crowdfund.\n    uint96 public totalContributions;\n    /// @notice The gatekeeper contract to use (if non-null) to restrict who can\n    ///         contribute to the party.\n    IGateKeeper public gateKeeper;\n    /// @notice The ID of the gatekeeper strategy to use.\n    bytes12 public gateKeeperId;\n    /// @notice Who will receive a reserved portion of governance power when\n    ///         the governance party is created.\n    address payable public splitRecipient;\n    /// @notice How much governance power to reserve for `splitRecipient`,\n    ///         in bps, where 10,000 = 100%.\n    uint16 public splitBps;\n    // Whether the share for split recipient has been claimed through `burn()`.\n    bool private _splitRecipientHasBurned;\n    /// @notice Hash of party governance options passed into `initialize()`.\n    ///         Used to check whether the `GovernanceOpts` passed into\n    ///         `_createParty()` matches.\n    bytes32 public governanceOptsHash;\n    /// @notice Who a contributor last delegated to.\n    mapping(address => address) public delegationsByContributor;\n    // Array of contributions by a contributor.\n    // One is created for every nonzero contribution made.\n    mapping (address => Contribution[]) private _contributionsByContributor;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) CrowdfundNFT(globals) {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts, credit initial contribution (if\n    // any), and setup gatekeeper.\n    function _initialize(CrowdfundOptions memory opts)\n        internal\n    {\n        CrowdfundNFT._initialize(opts.name, opts.symbol);\n        // Check that BPS values do not exceed the max.\n        if (opts.governanceOpts.feeBps > 1e4) {\n            revert InvalidBpsError(opts.governanceOpts.feeBps);\n        }\n        if (opts.governanceOpts.passThresholdBps > 1e4) {\n            revert InvalidBpsError(opts.governanceOpts.passThresholdBps);\n        }\n        if (opts.splitBps > 1e4) {\n            revert InvalidBpsError(opts.splitBps);\n        }\n        governanceOptsHash = _hashFixedGovernanceOpts(opts.governanceOpts);\n        splitRecipient = opts.splitRecipient;\n        splitBps = opts.splitBps;\n        // If the deployer passed in some ETH during deployment, credit them\n        // for the initial contribution.\n        uint96 initialBalance = address(this).balance.safeCastUint256ToUint96();\n        if (initialBalance > 0) {\n            // If this contract has ETH, either passed in during deployment or\n            // pre-existing, credit it to the `initialContributor`.\n            _contribute(opts.initialContributor, initialBalance, opts.initialDelegate, 0, \"\");\n        }\n        // Set up gatekeeper after initial contribution (initial always gets in).\n        gateKeeper = opts.gateKeeper;\n        gateKeeperId = opts.gateKeeperId;\n    }\n\n    /// @notice Burn the participation NFT for `contributor`, potentially\n    ///         minting voting power and/or refunding unused ETH. `contributor`\n    ///         may also be the split recipient, regardless of whether they are\n    ///         also a contributor or not. This can be called by anyone on a\n    ///         contributor's behalf to unlock their voting power in the\n    ///         governance stage ensuring delegates receive their voting\n    ///         power and governance is not stalled.\n    /// @dev If the party has won, someone needs to call `_createParty()` first. After\n    ///      which, `burn()` will refund unused ETH and mint governance tokens for the\n    ///      given `contributor`.\n    ///      If the party has lost, this will only refund unused ETH (all of it) for\n    ///      the given `contributor`.\n    /// @param contributor The contributor whose NFT to burn for.\n    function burn(address payable contributor)\n        public\n    {\n        return _burn(contributor, getCrowdfundLifecycle(), party);\n    }\n\n    /// @notice `burn()` in batch form.\n    /// @param contributors The contributors whose NFT to burn for.\n    function batchBurn(address payable[] calldata contributors)\n        external\n    {\n        Party party_ = party;\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        for (uint256 i = 0; i < contributors.length; ++i) {\n            _burn(contributors[i], lc, party_);\n        }\n    }\n\n    /// @notice Contribute to this crowdfund and/or update your delegation for the\n    ///         governance phase should the crowdfund succeed.\n    ///         For restricted crowdfunds, `gateData` can be provided to prove\n    ///         membership to the gatekeeper.\n    /// @param delegate The address to delegate to for the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    function contribute(address delegate, bytes memory gateData)\n        public\n        payable\n    {\n        _contribute(\n            msg.sender,\n            msg.value.safeCastUint256ToUint96(),\n            delegate,\n            // We cannot use `address(this).balance - msg.value` as the previous\n            // total contributions in case someone forces (suicides) ETH into this\n            // contract. This wouldn't be such a big deal for open crowdfunds\n            // but private ones (protected by a gatekeeper) could be griefed\n            // because it would ultimately result in governance power that\n            // is unattributed/unclaimable, meaning that party will never be\n            // able to reach 100% consensus.\n            totalContributions,\n            gateData\n        );\n    }\n\n    /// @inheritdoc EIP165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        override(ERC721Receiver, CrowdfundNFT)\n        pure\n        returns (bool)\n    {\n        return ERC721Receiver.supportsInterface(interfaceId) ||\n            CrowdfundNFT.supportsInterface(interfaceId);\n    }\n\n    /// @notice Retrieve info about a participant's contributions.\n    /// @dev This will only be called off-chain so doesn't have to be optimal.\n    /// @param contributor The contributor to retrieve contributions for.\n    /// @return ethContributed The total ETH contributed by `contributor`.\n    /// @return ethUsed The total ETH used by `contributor` to acquire the NFT.\n    /// @return ethOwed The total ETH refunded back to `contributor`.\n    /// @return votingPower The total voting power minted to `contributor`.\n    function getContributorInfo(address contributor)\n        external\n        view\n        returns (\n            uint256 ethContributed,\n            uint256 ethUsed,\n            uint256 ethOwed,\n            uint256 votingPower\n        )\n    {\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        Contribution[] storage contributions = _contributionsByContributor[contributor];\n        uint256 numContributions = contributions.length;\n        for (uint256 i = 0; i < numContributions; ++i) {\n            ethContributed += contributions[i].amount;\n        }\n        if (lc == CrowdfundLifecycle.Won || lc == CrowdfundLifecycle.Lost) {\n            (ethUsed, ethOwed, votingPower) = _getFinalContribution(contributor);\n        }\n    }\n\n    /// @notice Get the current lifecycle of the crowdfund.\n    function getCrowdfundLifecycle() public virtual view returns (CrowdfundLifecycle);\n\n    // Get the final sale price of the bought assets. This will also be the total\n    // voting power of the governance party.\n    function _getFinalPrice() internal virtual view returns (uint256);\n\n    // Can be called after a party has won.\n    // Deploys and initializes a a `Party` instance via the `PartyFactory`\n    // and transfers the bought NFT to it.\n    // After calling this, anyone can burn CF tokens on a contributor's behalf\n    // with the `burn()` function.\n    function _createParty(\n        IPartyFactory partyFactory,\n        FixedGovernanceOpts memory governanceOpts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    )\n        internal\n        returns (Party party_)\n    {\n        if (party != Party(payable(0))) {\n            revert PartyAlreadyExistsError(party);\n        }\n        {\n            bytes16 governanceOptsHash_ = _hashFixedGovernanceOpts(governanceOpts);\n            if (governanceOptsHash_ != governanceOptsHash) {\n                revert InvalidGovernanceOptionsError(governanceOptsHash_, governanceOptsHash);\n            }\n        }\n        party = party_ = partyFactory\n            .createParty(\n                address(this),\n                Party.PartyOptions({\n                    name: name,\n                    symbol: symbol,\n                    governance: PartyGovernance.GovernanceOpts({\n                        hosts: governanceOpts.hosts,\n                        voteDuration: governanceOpts.voteDuration,\n                        executionDelay: governanceOpts.executionDelay,\n                        passThresholdBps: governanceOpts.passThresholdBps,\n                        totalVotingPower: _getFinalPrice().safeCastUint256ToUint96(),\n                        feeBps: governanceOpts.feeBps,\n                        feeRecipient: governanceOpts.feeRecipient\n                    })\n                }),\n                preciousTokens,\n                preciousTokenIds\n            );\n        // Transfer the acquired NFTs to the new party.\n        for (uint256 i = 0; i < preciousTokens.length; ++i) {\n            preciousTokens[i].transferFrom(address(this), address(party_), preciousTokenIds[i]);\n        }\n    }\n\n    // Overloaded single token wrapper for _createParty()\n    function _createParty(\n        IPartyFactory partyFactory,\n        FixedGovernanceOpts memory governanceOpts,\n        IERC721 preciousToken,\n        uint256 preciousTokenId\n    )\n        internal\n        returns (Party party_)\n    {\n        IERC721[] memory tokens = new IERC721[](1);\n        tokens[0] = preciousToken;\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = preciousTokenId;\n        return _createParty(partyFactory, governanceOpts, tokens, tokenIds);\n    }\n\n    function _hashFixedGovernanceOpts(FixedGovernanceOpts memory opts)\n        internal\n        pure\n        returns (bytes16 h)\n    {\n        // Hash in place.\n        assembly {\n            // Replace the address[] hosts field with its hash temporarily.\n            let oldHostsFieldValue := mload(opts)\n            mstore(opts, keccak256(add(mload(opts), 0x20), mul(mload(mload(opts)), 32)))\n            // Hash the entire struct.\n            h := keccak256(opts, 0xC0)\n            // Restore old hosts field value.\n            mstore(opts, oldHostsFieldValue)\n        }\n    }\n\n    function _getFinalContribution(address contributor)\n        internal\n        view\n        returns (uint256 ethUsed, uint256 ethOwed, uint256 votingPower)\n    {\n        uint256 totalEthUsed = _getFinalPrice();\n        {\n            Contribution[] storage contributions = _contributionsByContributor[contributor];\n            uint256 numContributions = contributions.length;\n            for (uint256 i = 0; i < numContributions; ++i) {\n                Contribution memory c = contributions[i];\n                if (c.previousTotalContributions >= totalEthUsed) {\n                    // This entire contribution was not used.\n                    ethOwed += c.amount;\n                } else if (c.previousTotalContributions + c.amount <= totalEthUsed) {\n                    // This entire contribution was used.\n                    ethUsed += c.amount;\n                } else {\n                    // This contribution was partially used.\n                    uint256 partialEthUsed = totalEthUsed - c.previousTotalContributions;\n                    ethUsed += partialEthUsed;\n                    ethOwed = c.amount - partialEthUsed;\n                }\n            }\n        }\n        // one SLOAD with optimizer on\n        address splitRecipient_ = splitRecipient;\n        uint256 splitBps_ = splitBps;\n        if (splitRecipient_ == address(0)) {\n            splitBps_ = 0;\n        }\n        votingPower = ((1e4 - splitBps_) * ethUsed) / 1e4;\n        if (splitRecipient_ == contributor) {\n            // Split recipient is also the contributor so just add the split\n            // voting power.\n            votingPower += (splitBps_ * totalEthUsed + (1e4 - 1)) / 1e4; // round up\n        }\n    }\n\n    function _contribute(\n        address contributor,\n        uint96 amount,\n        address delegate,\n        uint96 previousTotalContributions,\n        bytes memory gateData\n    )\n        internal\n    {\n        // Require a non-null delegate.\n        if (delegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n        // Must not be blocked by gatekeeper.\n        if (gateKeeper != IGateKeeper(address(0))) {\n            if (!gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n                revert NotAllowedByGateKeeperError(\n                    contributor,\n                    gateKeeper,\n                    gateKeeperId,\n                    gateData\n                );\n            }\n        }\n\n        // Update delegate.\n        // OK if this happens out of cycle.\n        delegationsByContributor[contributor] = delegate;\n        emit Contributed(contributor, amount, delegate, previousTotalContributions);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount != 0) {\n            // Increase total contributions.\n            totalContributions += amount;\n\n            // Only allow contributions while the crowdfund is active.\n            {\n                CrowdfundLifecycle lc = getCrowdfundLifecycle();\n                if (lc != CrowdfundLifecycle.Active) {\n                    revert WrongLifecycleError(lc);\n                }\n            }\n            // Create contributions entry for this contributor.\n            Contribution[] storage contributions = _contributionsByContributor[contributor];\n            uint256 numContributions = contributions.length;\n            if (numContributions >= 1) {\n                Contribution memory lastContribution = contributions[numContributions - 1];\n                if (lastContribution.previousTotalContributions == previousTotalContributions) {\n                    // No one else has contributed since so just reuse the last entry.\n                    lastContribution.amount += amount;\n                    contributions[numContributions - 1] = lastContribution;\n                    return;\n                }\n            }\n            // Add a new contribution entry.\n            contributions.push(Contribution({\n                previousTotalContributions: previousTotalContributions,\n                amount: amount\n            }));\n            // Mint a participation NFT if this is their first contribution.\n            if (numContributions == 0) {\n                _mint(contributor);\n            }\n        }\n    }\n\n    function _burn(address payable contributor, CrowdfundLifecycle lc, Party party_)\n        private\n    {\n        // If the CF has won, a party must have been created prior.\n        if (lc == CrowdfundLifecycle.Won) {\n            if (party_ == Party(payable(0))) {\n                revert NoPartyError();\n            }\n        } else if (lc != CrowdfundLifecycle.Lost) {\n            // Otherwise it must have lost.\n            revert WrongLifecycleError(lc);\n        }\n        // Split recipient can burn even if they don't have a token.\n        if (contributor == splitRecipient) {\n            if (_splitRecipientHasBurned) {\n                revert SplitRecipientAlreadyBurnedError();\n            }\n            _splitRecipientHasBurned = true;\n        }\n        // Revert if already burned or does not exist.\n        if (splitRecipient != contributor || _doesTokenExistFor(contributor)) {\n            CrowdfundNFT._burn(contributor);\n        }\n        // Compute the contributions used and owed to the contributor, along\n        // with the voting power they'll have in the governance stage.\n        (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) =\n            _getFinalContribution(contributor);\n        if (votingPower > 0) {\n            // Get the address to delegate voting power to. If null, delegate to self.\n            address delegate = delegationsByContributor[contributor];\n            if (delegate == address(0)) {\n                // Delegate can be unset for the split recipient if they never\n                // contribute. Self-delegate if this occurs.\n                delegate = contributor;\n            }\n            // Mint governance NFT for the contributor.\n            party_.mint(\n                contributor,\n                votingPower,\n                delegate\n            );\n        }\n        // Refund any ETH owed back to the contributor.\n        contributor.transferEth(ethOwed);\n        emit Burned(contributor, ethUsed, ethOwed, votingPower);\n    }\n\n    function _getPartyFactory() internal view returns (IPartyFactory) {\n        return IPartyFactory(_GLOBALS.getAddress(LibGlobals.GLOBAL_PARTY_FACTORY));\n    }\n}"
    },
    {
      "filename": "contracts/distribution/TokenDistributor.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../tokens/IERC20.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibERC20Compat.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\n\nimport \"./ITokenDistributor.sol\";\n\n/// @notice Creates token distributions for parties (or any contract that\n///         implements `ITokenDistributorParty`).\ncontract TokenDistributor is ITokenDistributor {\n    using LibAddress for address payable;\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n\n    struct DistributionState {\n        // The remaining member supply.\n        uint128 remainingMemberSupply;\n        // The 15-byte hash of the `DistributionInfo`.\n        bytes15 distributionHash15;\n        // Whether the distribution's feeRecipient has claimed its fee.\n        bool wasFeeClaimed;\n        // Whether a governance token has claimed its distribution share.\n        mapping(uint256 => bool) hasPartyTokenClaimed;\n    }\n\n    // Arguments for `_createDistribution()`.\n    struct CreateDistributionArgs {\n        ITokenDistributorParty party;\n        TokenType tokenType;\n        address token;\n        uint256 currentTokenBalance;\n        address payable feeRecipient;\n        uint16 feeBps;\n    }\n\n    error OnlyPartyDaoError(address notDao, address partyDao);\n    error OnlyPartyDaoAuthorityError(address notDaoAuthority);\n    error InvalidDistributionInfoError(DistributionInfo info);\n    error DistributionAlreadyClaimedByPartyTokenError(uint256 distributionId, uint256 partyTokenId);\n    error DistributionFeeAlreadyClaimedError(uint256 distributionId);\n    error MustOwnTokenError(address sender, address expectedOwner, uint256 partyTokenId);\n    error EmergencyActionsNotAllowedError();\n    error InvalidDistributionSupplyError(uint128 supply);\n    error OnlyFeeRecipientError(address caller, address feeRecipient);\n    error InvalidFeeBpsError(uint16 feeBps);\n\n    // Token address used to indicate a native distribution (i.e. distribution of ETH).\n    address private constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice The `Globals` contract storing global configuration values. This contract\n    ///         is immutable and it’s address will never change.\n    IGlobals public immutable GLOBALS;\n\n    /// @notice Whether the DAO is no longer allowed to call emergency functions.\n    bool public emergencyActionsDisabled;\n    /// @notice Last distribution ID for a party.\n    mapping(ITokenDistributorParty => uint256) public lastDistributionIdPerParty;\n    /// Last known balance of a token, identified by an ID derived from the token.\n    /// Gets lazily updated when creating and claiming a distribution (transfers).\n    /// Allows one to simply transfer and call `createDistribution()` without\n    /// fussing with allowances.\n    mapping(bytes32 => uint256) private _storedBalances;\n    // tokenDistributorParty => distributionId => DistributionState\n    mapping(ITokenDistributorParty => mapping(uint256 => DistributionState)) private _distributionStates;\n\n    // msg.sender == DAO\n    modifier onlyPartyDao() {\n        {\n            address partyDao = GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n            if (msg.sender != partyDao) {\n                revert OnlyPartyDaoError(msg.sender, partyDao);\n            }\n        }\n        _;\n    }\n\n    // emergencyActionsDisabled == false\n    modifier onlyIfEmergencyActionsAllowed() {\n        if (emergencyActionsDisabled) {\n            revert EmergencyActionsNotAllowedError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) {\n        GLOBALS = globals;\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function createNativeDistribution(\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    )\n        external\n        payable\n        returns (DistributionInfo memory info)\n    {\n        info = _createDistribution(CreateDistributionArgs({\n            party: party,\n            tokenType: TokenType.Native,\n            token: NATIVE_TOKEN_ADDRESS,\n            currentTokenBalance: address(this).balance,\n            feeRecipient: feeRecipient,\n            feeBps: feeBps\n        }));\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function createErc20Distribution(\n        IERC20 token,\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    )\n        external\n        returns (DistributionInfo memory info)\n    {\n        info = _createDistribution(CreateDistributionArgs({\n            party: party,\n            tokenType: TokenType.Erc20,\n            token: address(token),\n            currentTokenBalance: token.balanceOf(address(this)),\n            feeRecipient: feeRecipient,\n            feeBps: feeBps\n        }));\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function claim(DistributionInfo calldata info, uint256 partyTokenId)\n        public\n        returns (uint128 amountClaimed)\n    {\n        // Caller must own the party token.\n        {\n            address ownerOfPartyToken = info.party.ownerOf(partyTokenId);\n            if (msg.sender != ownerOfPartyToken) {\n                revert MustOwnTokenError(msg.sender, ownerOfPartyToken, partyTokenId);\n            }\n        }\n        // DistributionInfo must be correct for this distribution ID.\n        DistributionState storage state = _distributionStates[info.party][info.distributionId];\n        if (state.distributionHash15 != _getDistributionHash(info)) {\n            revert InvalidDistributionInfoError(info);\n        }\n        // The partyTokenId must not have claimed its distribution yet.\n        if (state.hasPartyTokenClaimed[partyTokenId]) {\n            revert DistributionAlreadyClaimedByPartyTokenError(info.distributionId, partyTokenId);\n        }\n        // Mark the partyTokenId as having claimed their distribution.\n        state.hasPartyTokenClaimed[partyTokenId] = true;\n\n        // Compute amount owed to partyTokenId.\n        amountClaimed = getClaimAmount(info.party, info.memberSupply, partyTokenId);\n\n        // Cap at the remaining member supply. Otherwise a malicious\n        // party could drain more than the distribution supply.\n        uint128 remainingMemberSupply = state.remainingMemberSupply;\n        amountClaimed = amountClaimed > remainingMemberSupply\n            ? remainingMemberSupply\n            : amountClaimed;\n        state.remainingMemberSupply = remainingMemberSupply - amountClaimed;\n\n        // Transfer tokens owed.\n        _transfer(\n            info.tokenType,\n            info.token,\n            payable(msg.sender),\n            amountClaimed\n        );\n        emit DistributionClaimedByPartyToken(\n            info.party,\n            partyTokenId,\n            msg.sender,\n            info.tokenType,\n            info.token,\n            amountClaimed\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function claimFee(DistributionInfo calldata info, address payable recipient)\n        public\n    {\n        // DistributionInfo must be correct for this distribution ID.\n        DistributionState storage state = _distributionStates[info.party][info.distributionId];\n        if (state.distributionHash15 != _getDistributionHash(info)) {\n            revert InvalidDistributionInfoError(info);\n        }\n        // Caller must be the fee recipient.\n        if (info.feeRecipient != msg.sender) {\n            revert OnlyFeeRecipientError(msg.sender, info.feeRecipient);\n        }\n        // Must not have claimed the fee yet.\n        if (state.wasFeeClaimed) {\n            revert DistributionFeeAlreadyClaimedError(info.distributionId);\n        }\n        // Mark the fee as claimed.\n        state.wasFeeClaimed = true;\n        // Transfer the tokens owed.\n        _transfer(\n            info.tokenType,\n            info.token,\n            recipient,\n            info.fee\n        );\n        emit DistributionFeeClaimed(\n            info.party,\n            info.feeRecipient,\n            info.tokenType,\n            info.token,\n            info.fee\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function batchClaim(DistributionInfo[] calldata infos, uint256[] calldata partyTokenIds)\n        external\n        returns (uint128[] memory amountsClaimed)\n    {\n        amountsClaimed = new uint128[](infos.length);\n        for (uint256 i = 0; i < infos.length; ++i) {\n            amountsClaimed[i] = claim(infos[i], partyTokenIds[i]);\n        }\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function batchClaimFee(DistributionInfo[] calldata infos, address payable[] calldata recipients)\n        external\n    {\n        for (uint256 i = 0; i < infos.length; ++i) {\n            claimFee(infos[i], recipients[i]);\n        }\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function getClaimAmount(\n        ITokenDistributorParty party,\n        uint256 memberSupply,\n        uint256 partyTokenId\n    )\n        public\n        view\n        returns (uint128)\n    {\n        // getDistributionShareOf() is the fraction of the memberSupply partyTokenId\n        // is entitled to, scaled by 1e18.\n        // We round up here to prevent dust amounts getting trapped in this contract.\n        return (\n            (\n                uint256(party.getDistributionShareOf(partyTokenId))\n                * memberSupply\n                + (1e18 - 1)\n            )\n            / 1e18\n        ).safeCastUint256ToUint128();\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function wasFeeClaimed(ITokenDistributorParty party, uint256 distributionId)\n        external\n        view\n        returns (bool)\n    {\n        return _distributionStates[party][distributionId].wasFeeClaimed;\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function hasPartyTokenIdClaimed(\n        ITokenDistributorParty party,\n        uint256 partyTokenId,\n        uint256 distributionId\n    )\n        external\n        view returns (bool)\n    {\n        return _distributionStates[party][distributionId].hasPartyTokenClaimed[partyTokenId];\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function getRemainingMemberSupply(\n        ITokenDistributorParty party,\n        uint256 distributionId\n    )\n        external\n        view\n        returns (uint128)\n    {\n        return _distributionStates[party][distributionId].remainingMemberSupply;\n    }\n\n    /// @notice DAO-only function to clear a distribution in case something goes wrong.\n    function emergencyRemoveDistribution(\n        ITokenDistributorParty party,\n        uint256 distributionId\n    )\n        onlyPartyDao\n        onlyIfEmergencyActionsAllowed\n        external\n    {\n        delete _distributionStates[party][distributionId];\n    }\n\n    /// @notice DAO-only function to withdraw tokens in case something goes wrong.\n    function emergencyWithdraw(\n        TokenType tokenType,\n        address token,\n        address payable recipient,\n        uint256 amount\n    )\n        onlyPartyDao\n        onlyIfEmergencyActionsAllowed\n        external\n    {\n        _transfer(tokenType, token, recipient, amount);\n    }\n\n    /// @notice DAO-only function to disable emergency functions forever.\n    function disableEmergencyActions() onlyPartyDao external {\n        emergencyActionsDisabled = true;\n    }\n\n    function _createDistribution(CreateDistributionArgs memory args)\n        private\n        returns (DistributionInfo memory info)\n    {\n        if (args.feeBps > 1e4) {\n            revert InvalidFeeBpsError(args.feeBps);\n        }\n        uint128 supply;\n        {\n            bytes32 balanceId = _getBalanceId(args.tokenType, args.token);\n            supply = (args.curr"
    }
  ]
}