{
  "Title": "ERC Recommendations [core]",
  "Content": "#### Procedural Update\n\n\nThe `validateUserOpSignature` function [allows the aggregator to replace the operation signature](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/interfaces/IAggregator.sol#L26). If this happens, the bundler should re-run `validateUserOp` with this new signature to ensure that it succeeds and returns the same aggregator. Otherwise, the operation might fail unexpectedly in the bundle.\n\n\n#### Update Specification\n\n\nThere are places where the specification references outdated features of the system and thus should be updated:\n\n\n* References to `UserOperation` should be replaced with `PackedUserOperation`. This includes updating the field descriptions and all the affected interfaces.\n* The references to `ValidationResultWithAggregator` ([1](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/erc/ERCS/erc-4337.md#L134), [2](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/erc/ERCS/erc-4337.md#L210)) should be removed.\n* The specification should mention the new `IAccountExecute` interface and how it can be used.\n\n\n#### Technical Corrections\n\n\n* The specification [requires](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/erc/ERCS/erc-4337.md#L227) the `EntryPoint` to fail if the account does not exist and the `initCode` is empty. It actually just [skips validation](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/core/EntryPoint.sol#L405) when the `initCode` is empty (although it would revert later when attempting to [interact with the empty address](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/core/EntryPoint.sol#L467)). While failing explicitly would typically be recommended, this check has been [moved to the simulation](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/core/EntryPointSimulations.sol#L171). For completeness, this should be explained in the ERC.\n* The specification [incorrectly claims](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/erc/ERCS/erc-4337.md#L272) that the `postOpReverted` mode implies that the user operation succeeded.\n* The specification [claims](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/erc/ERCS/erc-4337.md#L279) that the paymaster's `addStake` function must be called by the paymaster. However, it is [called by the paymaster's owner address](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/core/BasePaymaster.sol#L119).\n* The specification [requires](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/erc/ERCS/erc-4337.md#L224) the `EntryPoint` to validate the aggregate signature after performing the individual account validations. It is [actually performed](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/contracts/core/EntryPoint.sol#L205) beforehand.\n\n\n#### Additional Context\n\n\nThe specification mentions [some examples](https://github.com/eth-infinitism/account-abstraction/blob/9879c931ce92f0bee1bca1d1b1352eeb98b9a120/erc/ERCS/erc-4337.md#L422) of how to attribute `AAx` errors. It would benefit from a complete table explaining all the error code prefixes.\n\n\n***Update:** Resolved in [pull request #412](https://github.com/eth-infinitism/account-abstraction/pull/412).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/interfaces/IAggregator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n    /**\n     * Validate aggregated signature.\n     * Revert if the aggregated signature does not match the given list of operations.\n     * @param userOps   - Array of UserOperations to validate the signature for.\n     * @param signature - The aggregated signature.\n     */\n    function validateSignatures(\n        PackedUserOperation[] calldata userOps,\n        bytes calldata signature\n    ) external view;\n\n    /**\n     * Validate signature of a single userOp.\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp        - The userOperation received from the user.\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\n     *                        (usually empty, unless account and aggregator support some kind of \"multisig\".\n     */\n    function validateUserOpSignature(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes memory sigForUserOp);\n\n    /**\n     * Aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation.\n     * @param userOps              - Array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature - The aggregated signature.\n     */\n    function aggregateSignatures(\n        PackedUserOperation[] calldata userOps\n    ) external view returns (bytes memory aggregatedSignature);\n}"
    },
    {
      "filename": "erc/ERCS/erc-4337.md",
      "content": "---\neip: 4337\ntitle: Account Abstraction Using Alt Mempool\ndescription: An account abstraction proposal which completely avoids consensus-layer protocol changes, instead relying on higher-layer infrastructure.\nauthor: Vitalik Buterin (@vbuterin), Yoav Weiss (@yoavw), Dror Tirosh (@drortirosh), Shahaf Nacson (@shahafn), Alex Forshtat (@forshtat), Kristof Gazso (@kristofgazso), Tjaden Hess (@tjade273)\ndiscussions-to: https://ethereum-magicians.org/t/erc-4337-account-abstraction-via-entry-point-contract-specification/7160\nstatus: Draft\ntype: Standards Track\ncategory: ERC\ncreated: 2021-09-29\nrequires: 7562\n---\n\n## Abstract\n\nAn account abstraction proposal which completely avoids the need for consensus-layer protocol changes. Instead of adding new protocol features and changing the bottom-layer transaction type, this proposal instead introduces a higher-layer pseudo-transaction object called a `UserOperation`. Users send `UserOperation` objects into a separate mempool. A special class of actor called bundlers package up a set of these objects into a transaction making a `handleOps` call to a special contract, and that transaction then gets included in a block.\n\n## Motivation\n\nSee also `https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020` and the links therein for historical work and motivation, and [EIP-2938](./eip-2938.md) for a consensus layer proposal for implementing the same goal.\n\nThis proposal takes a different approach, avoiding any adjustments to the consensus layer. It seeks to achieve the following goals:\n\n* **Achieve the key goal of account abstraction**: allow users to use smart contract wallets containing arbitrary verification logic instead of EOAs as their primary account. Completely remove any need at all for users to also have EOAs (as status quo SC wallets and [EIP-3074](./eip-3074.md) both require)\n* **Decentralization**\n    * Allow any bundler (think: block builder) to participate in the process of including account-abstracted user operations\n    * Work with all activity happening over a public mempool; users do not need to know the direct communication addresses (eg. IP, onion) of any specific actors\n    * Avoid trust assumptions on bundlers\n* **Do not require any Ethereum consensus changes**: Ethereum consensus layer development is focusing on the merge and later on scalability-oriented features, and there may not be any opportunity for further protocol changes for a long time. Hence, to increase the chance of faster adoption, this proposal avoids Ethereum consensus changes.\n* **Try to support other use cases**\n    * Privacy-preserving applications\n    * Atomic multi-operations (similar goal to [EIP-3074])\n    * Pay tx fees with [ERC-20](./erc-20.md) tokens, allow developers to pay fees for their users, and [EIP-3074]-like **sponsored transaction** use cases more generally\n    * Support aggregated signature (e.g. BLS)\n\n## Specification\n\n### Definitions\n\n* **UserOperation** - a structure that describes a transaction to be sent on behalf of a user. To avoid confusion, it is not named \"transaction\".\n  * Like a transaction, it contains \"sender\", \"to\", \"calldata\", \"maxFeePerGas\", \"maxPriorityFee\", \"signature\", \"nonce\"\n  * unlike a transaction, it contains several other fields, described below\n  * also, the \"signature\" field usage is not defined by the protocol, but by each account implementation\n* **Sender** - the account contract sending a user operation.\n* **EntryPoint** - a singleton contract to execute bundles of UserOperations. Bundlers/Clients whitelist the supported entrypoint.\n* **Bundler** - a node (block builder) that can handle UserOperations,\n  create a valid an EntryPoint.handleOps() transaction,\n  and add it to the block while it is still valid.\n  This can be achieved by a number of ways:\n  * Bundler can act as a block builder itself\n  * If the bundler is not a block builder, it MUST work with the block building infrastructure such as `mev-boost` or\n    other kind of PBS (proposer-builder separation)\n  * The `bundler` can also rely on an experimental `eth_sendRawTransactionConditional` RPC API if it is available.\n* **Aggregator** - a helper contract trusted by accounts to validate an aggregated signature. Bundlers/Clients whitelist the supported aggregators.\n\nTo avoid Ethereum consensus changes, we do not attempt to create new transaction types for account-abstracted transactions. Instead, users package up the action they want their account to take in an ABI-encoded struct called a `UserOperation`:\n\n| Field | Type | Description\n| - | - | - |\n| `sender` | `address` | The account making the operation |\n| `nonce` | `uint256` | Anti-replay parameter (see \"Semi-abstracted Nonce Support\" ) |\n| `initCode` | `bytes` | The initCode of the account (needed if and only if the account is not yet on-chain and needs to be created) |\n| `callData` | `bytes` | The data to pass to the `sender` during the main execution call |\n| `callGasLimit` | `uint256` | The amount of gas to allocate the main execution call |\n| `verificationGasLimit` | `uint256` | The amount of gas to allocate for the verification step |\n| `preVerificationGas` | `uint256` | The amount of gas to pay for to compensate the bundler for pre-verification execution, calldata and any gas overhead that can't be tracked on-chain |\n| `maxFeePerGas` | `uint256` | Maximum fee per gas (similar to [EIP-1559](./eip-1559.md) `max_fee_per_gas`) |\n| `maxPriorityFeePerGas` | `uint256` | Maximum priority fee per gas (similar to EIP-1559 `max_priority_fee_per_gas`) |\n| `paymasterAndData` | `bytes` | Address of paymaster sponsoring the transaction, followed by extra data to send to the paymaster (empty for self-sponsored transaction) |\n| `signature` | `bytes` | Data passed into the account along with the nonce during the verification step |\n\nUsers send `UserOperation` objects to a dedicated user operation mempool. A specialized class of actors called **bundlers** (either block builders running special-purpose code, or users that can relay transactions to block builders eg. through a bundle marketplace such as Flashbots that can guarantee next-block-or-never inclusion) listen in on the user operation mempool, and create **bundle transactions**. A bundle transaction packages up multiple `UserOperation` objects into a single `handleOps` call to a pre-published global **entry point contract**.\n\nTo prevent replay attacks (both cross-chain and multiple `EntryPoint` implementations), the `signature` should depend on `chainid` and the `EntryPoint` address.\n\nThe core interface of the entry point contract is as follows:\n\n```solidity\nfunction handleOps(UserOperation[] calldata ops, address payable beneficiary);\n\nfunction handleAggregatedOps(\n    UserOpsPerAggregator[] calldata opsPerAggregator,\n    address payable beneficiary\n);\n\nstruct UserOpsPerAggregator {\n    UserOperation[] userOps;\n    IAggregator aggregator;\n    bytes signature;\n}\n```\n\nThe core interface required for an account to have is:\n\n```solidity\ninterface IAccount {\n  function validateUserOp\n      (UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds)\n      external returns (uint256 validationData);\n}\n```\n\nThe `userOpHash` is a hash over the userOp (except signature), entryPoint and chainId.  \n\nThe account:\n\n* MUST validate the caller is a trusted EntryPoint\n* If the account does not support signature aggregation, it MUST validate the signature is a valid signature of the `userOpHash`, and\n  SHOULD return SIG_VALIDATION_FAILED (and not revert) on signature mismatch. Any other error MUST revert.\n* MUST pay the entryPoint (caller) at least the \"missingAccountFunds\" (which might be zero, in case current account's deposit is high enough)\n* The account MAY pay more than this minimum, to cover future transactions (it can always issue `withdrawTo` to retrieve it)\n* The return value MUST be packed of `authorizer`, `validUntil` and `validAfter` timestamps.\n  * authorizer - 0 for valid signature, 1 to mark signature failure. Otherwise, an address of an authorizer contract. This ERC defines \"signature aggregator\" as authorizer.\n  * `validUntil` is 6-byte timestamp value, or zero for \"infinite\". The UserOp is valid only up to this time.\n  * `validAfter` is 6-byte timestamp. The UserOp is valid only after this time.\n  \nAn account that works with aggregated signature, should return its signature aggregator address in the \"sigAuthorizer\" return value of validateUserOp.\nIt MAY ignore the signature field\n\nThe core interface required by an aggregator is:\n\n```solidity\ninterface IAggregator {\n\n  function validateUserOpSignature(UserOperation calldata userOp)\n  external view returns (bytes memory sigForUserOp);\n\n  function aggregateSignatures(UserOperation[] calldata userOps) external view returns (bytes memory aggregatesSignature);\n\n  function validateSignatures(UserOperation[] calldata userOps, bytes calldata signature) view external;\n}\n```\n\n* If an account uses an aggregator (returns it from validateUserOp), then its address is returned by `simulateValidation()` reverting with `ValidationResultWithAggregator` instead of `ValidationResult`\n* To accept the UserOp, the bundler must call **validateUserOpSignature()** to validate the userOp's signature.\n* **aggregateSignatures()** must aggregate all UserOp signature into a single value.  \n* Note that the above methods are helper method for the bundler. The bundler MAY use a native library to perform the same validation and aggregation logic.\n* **validateSignatures()** MUST validate the aggregated signature matches for all UserOperations in the array, and revert otherwise.\n  This method is called on-chain by `handleOps()`\n\n#### Semi-abstracted Nonce Support\n\nIn Ethereum protocol, the sequential transaction `nonce` value is used as a replay protection method as well as to\ndetermine the valid order of transaction being included in blocks.\n\nIt also contributes to the transaction hash uniqueness, as a transaction by the same sender with the same\nnonce may not be included in the chain twice.\n\nHowever, requiring a single sequential `nonce` value is limiting the senders' ability to define their custom logic\nwith regard to transaction ordering and replay protection.\n\nInstead of sequential `nonce` we implement a nonce mechanism that uses a single `uint256` nonce value in the `UserOperation`,\nbut treats it as two values:\n\n* 192-bit \"key\"\n* 64-bit \"sequence\"\n\nThese values are represented on-chain in the `EntryPoint` contract.\nWe define the following method in the `EntryPoint` interface to expose these values:\n\n```solidity\nfunction getNonce(address sender, uint192 key) external view returns (uint256 nonce);\n```\n\nFor each `key` the `sequence` is validated and incremented sequentially and monotonically by the `EntryPoint` for\neach UserOperation, however a new key can be introduced with an arbitrary value at any point.\n\nThis approach maintains the guarantee of `UserOperation` hash uniqueness on-chain on the protocol level while allowing\nwallets to implement any custom logic they may need operating on a 192-bit \"key\" field, while fitting the 32 byte word.\n\n##### Reading and validating the nonce\n\nWhen preparing the UserOp clients may make a view call to this method to determine a valid value for the `nonce` field.\n\nBundler's validation of a UserOp should start with `getNonce` to ensure the transaction has a valid `nonce` field.\n\nIf the bundler is willing to accept multiple UserOperations by the same sender into their mempool,\nthis bundler is supposed to track the `key` and `sequence` pair of the UserOperations already added in the mempool.\n\n##### Usage examples\n\n1. Classic sequential nonce.\n\n   In order to require the wallet to have classic, sequential nonce, the validation function should perform:\n\n   ```solidity\n   require(userOp.nonce<type(uint64).max)\n   ```\n\n2. Ordered administrative events\n\n   In some cases, an account may need to have an \"administrative\" channel of operations running in parallel to normal\n   operations.\n\n   In this case, the account may use specific `key` when calling methods on the account itself:\n\n   ```solidity\n   bytes4 sig = bytes4(userOp.callData[0 : 4]);\n   uint key = userOp.nonce >> 64;\n   if (sig == ADMIN_METHODSIG) {\n       require(key == ADMIN_KEY, \"wrong nonce-key for admin operation\");\n   } else {\n       require(key == 0, \"wrong nonce-key for normal operation\");\n   }\n   ```\n\n#### Using signature aggregators\n\nAn account signifies it uses signature aggregation returning its address from `validateUserOp`.\nDuring `simulateValidation`, this aggregator is returned (in the `ValidationResultWithAggregator`)\n\nThe bundler should first accept the aggregator (validate its stake info and that it is not throttled/banned)\nThen it MUST verify the userOp using `aggregator.validateUserOpSignature()`\n\nSignature aggregator SHOULD stake just like a paymaster, unless it is exempt due to not accessing global storage - see [reputation, throttling and banning section](#reputation-scoring-and-throttlingbanning-for-global-entities) for details. Bundlers MAY throttle down and ban aggregators in case they take too much\nresources (or revert) when the above methods are called in view mode, or if the signature aggregation fails.\n\n### Required entry point contract functionality\n\nThere are 2 separate entry point methods: `handleOps` and `handleAggregatedOps`\n\n* `handleOps` handle userOps of accounts that don't require any signature aggregator.\n* `handleAggregatedOps` can handle a batch that contains userOps of multiple aggregators (and also requests without any aggregator)\n* `handleAggregatedOps` performs the same logic below as `handleOps`, but it must transfer the correct aggregator to each userOp, and also must call `validateSignatures` on each aggregator after doing all the per-account validation.\nThe entry point's `handleOps` function must perform the following steps (we first describe the simpler non-paymaster case). It must make two loops, the **verification loop** and the **execution loop**. In the verification loop, the `handleOps` call must perform the following steps for each `UserOperation`:\n\n* **Create the account if it does not yet exist**, using the initcode provided in the `UserOperation`. If the account does not exist, _and_ the initcode is empty, or does not deploy a contract at the \"sender\" address, the call must fail.\n* calculate the maximum possible fee the account needs to pay (based on validation and call gas limits, and current gas values)\n* calculate the fee the account must add to its \"deposit\" in the EntryPoint\n* **Call `validateUserOp` on the account**, passing in the `UserOperation`, its hash and the required fee. The account should verify the operation's signature, and pay the fee if the account considers the operation valid. If any `validateUserOp` call fails, `handleOps` must skip execution of at least that operation, and may revert entirely.\n* Validate the account's deposit in the entryPoint is high enough to cover the max possible cost (cover the already-done verification and max execution gas)\n\nIn the execution loop, the `handleOps` call must perform the following steps for each `UserOperation`:\n\n* **Call the account with the `UserOperation`'s calldata**. It's up to the account to choose how to parse the calldata; an expected workflow is for the account to have an `execute` function that parses the remaining calldata as a series of one or more calls that the account should make.\n* After the call, refund the account's deposit with the excess gas cost that was pre-charged.\\\n A penalty of `10%` (`UNUSED_GAS_PENALTY_PERCENT`) is applied on the amount of gas that is refunded.\\\n This penalty is necessary to prevent the UserOps from reserving large parts of the gas space in the bundle but leaving it unused and preventing the bundler from including other UserOperations.\n* After the execution of all calls, pay the collected fees from all UserOperations to the bundler's provided address\n\n![](../assets/erc-4337/bundle-seq.svg)\n\nBefore accepting a `UserOperation`, bundlers should use an RPC method to locally call the `simulateValidation` function on the entry point, to verify that the signature is correct and the operation actually pays fees; see the [Simulation section below](#simulation) for details.\nA node/bundler SHOULD drop (not add to the mempool) a `UserOperation` that fails the validation\n\n### Extension: paymasters\n\nWe extend the entry point logic to support **paymasters** that can sponsor transactions for other users. This feature can be used to allow application developers to subsidize fees for their users, allow users to pay fees with [ERC-20](./erc-20.md) tokens and many other use cases. When the paymasterAndData field in the UserOp is not empty, the entry point implements a different flow for that UserOperation:\n\n![](../assets/erc-4337/bundle-seq-pm.svg)\n\nDuring the verification loop, in addition to calling `validateUserOp`, the `handleOps` execution also must check that the paymaster has enough ETH deposited with the entry point to pay for the operation, and then call `validatePaymasterUserOp` on the paymaster to verify that the paymaster is willing to pay for the operation. Note that in this case, the `validateUserOp` is called with a `missingAccountFunds` of 0 to reflect that the account's deposit is not used for payment for this userOp.\n\nIf the paymaster's validatePaymasterUserOp returns a \"context\", then `handleOps` must call `postOp` on the paymaster after making the main execution call.\n\nMaliciously crafted paymasters _can_ DoS the system. To prevent this, we use a reputation system. paymaster must either limit its storage usage, or have a stake. see the [reputation, throttling and banning section](#reputation-scoring-and-throttlingbanning-for-global-entities) for details.\n\nThe paymaster interface is as follows:\n\n```c++\n  function validatePaymasterUserOp\n    (UserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\n    external returns (bytes memory context, uint256 validationData);\n\nfunction postOp\n    (PostOpMode mode, bytes calldata context, uint256 actualGasCost, uint256 actualUserOpFeePerGas)\n    external;\n\nenum PostOpMode {\n    opSucceeded, // user op succeeded\n    opReverted, // user op reverted. still has to pay for gas.\n    postOpReverted // user op succeeded, but caused postOp to revert\n}\n```\n\n\n```c++\n// add a paymaster stake (must be called by the paymaster)\nfunction addStake(uint32 _unstakeDelaySec) external payable\n\n// unlock the stake (must wait unstakeDelay before can withdraw)\nfunction unlockStake() external\n\n// withdraw the unlocked stake\nfunction withdrawStake(address payable withdrawAddress) external\n```\n\nThe paymaster must also have a deposit, which the entry point will charge UserOperation costs from.\nThe deposit (for paying gas fees) is separate from the stake (which is locked).\n\nThe entry point must implement the following interface to allow paymasters (and optionally accounts) manage their deposit:\n\n```c++\n// return the deposit of an account\nfunction balanceOf(address account) public view returns (uint256)\n\n// add to the deposit of the given account\nfunction depositTo(address account) public payable\n\n// withdraw from the deposit of the current account\nfunction withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external\n```\n\n### Client behavior upon receiving a UserOperation\n\nWhen a client receives a `UserOperation`, it must first run some basic sanity checks, namely that:\n\n* Either the `sender` is an existing contract, or the `initCode` is not empty (but not both)\n* If `initCode` is not empty, parse its first 20 bytes as a factory address.  Record whether the factory is staked, in case the later simulation indicates that it needs to be.  If the factory accesses global state, it must be staked - see [reputation, throttling and banning section](#reputation-scoring-and-throttlingbanning-for-global-entities) for details.\n* The `verificationGasLimit` is sufficiently low (`<= MAX_VERIFICATION_GAS`) and the `preVerificationGas` is sufficiently high (enough to pay for the calldata gas cost of serializing the `UserOperation` plus `PRE_VERIFICATION_OVERHEAD_GAS`)\n* The `paymasterAndData` is either empty, or start with the **paymaster** address, which is a contract that (i) currently has nonempty code on chain, (ii) has a sufficient deposit to pay for the UserOperation, and (iii) is not currently banned. During simulation, the paymaster's stake is also checked, depending on its storage usage - see [reputation, throttling and banning section](#reputation-scoring-and-throttlingbanning-for-global-entities) for details.\n* The callgas is at least the cost of a `CALL` with non-zero value.\n* The `maxFeePerGas` and `maxPriorityFeePerGas` are above a configurable minimum value that the client is willing to accept. At the minimum, they are sufficiently high to be included with the current `block.basefee`.\n* The sender doesn't have another `UserOperation` already present in the pool (or it replaces an existing entry with the same sender and nonce, with a higher `maxPriorityFeePerGas` and an equally increased `maxFeePerGas`). Only one `UserOperation` per sender may be included in a single batch. A sender is exempt from this rule and may have multiple `UserOperations` in the pool and in a batch if it is staked (see [reputation, throttling and banning section](#reputation-scoring-and-throttlingbanning-for-global-entities) below), but this exception is of limited use to normal accounts.\n\nIf the `UserOperation` object passes these sanity checks, the client must next run the first op simulation, and if the simulation succeeds, the client must add the op to the pool. A second simulation must also happen during bundling to make sure the UserOperation is still valid.\n\n### Simulation\n\n#### Simulation Rationale\n\nIn order to add a UserOperation into the mempool (and later to add it into a bundle) we need to \"simulate\" its validation to make sure it is valid, and that it is capable of paying for its own execution.\nIn addition, we need to verify that the same will hold true when executed on-chain.\nFor this purpose, a UserOperation is not allowed to access any information that might change between simulation and execution, such as current block time, number, hash etc.\nIn addition, a UserOperation is only allowed to access data related to this sender address: Multiple UserOperations should not access the same storage, so that it is impossible to invalidate a large number of UserOperations with a single state change.\nThere are 3 special contracts that interact with the account: the factory (initCode) that deploys the contract, the paymaster that can pay for the gas, and signature aggregator (described later)\nEach of these contracts is also restricted in its storage access, to make sure UserOperation validations are isolated.\n\n#### Specification:\n\nTo simulate a `UserOperation` validation, the client makes a view call to `simulateValidation(userop)`.\n\nThe EntryPoint itself does not implement the simulation methods. Instead, when making the simulation view call, \nThe bundler should provide the alternate EntryPointSimulations code, which extends the EntryPoint with the simulation methods.\n\nThe simulation core methods:\n\n```solidity\n\nstruct ValidationResult {\n    ReturnInfo returnInfo;\n    StakeInfo senderInfo;\n    StakeInfo factoryInfo;\n    StakeInfo paymasterInfo;\n    AggregatorStakeInfo aggregatorInfo;\n}\n\nfunction simulateValidation(UserOperation calldata userOp) \nexternal returns (ValidationResult memory);\n\nstruct ReturnInfo {\n    uint256 preOpGas;\n    uint256 prefund;\n    bool sigFailed;\n    uint48 validAfter;\n    uint48 validUntil;\n    bytes paymasterContext;\n}\n\nstruct AggregatorStakeInfo {\n    address aggregator;\n    StakeInfo stakeInfo;\n}\n\nstruct StakeInfo {\n  uint256 stake;\n  uint256 unstakeDelaySec;\n}\n\n\n```\n\nThis method returns `ValidationResult` or revert on validation failure.\nThe node should drop the UserOperation if the simulation fails (either by revert or by \"signature failure\")\n\nThe simulated call performs the full validation, by calling:\n\n1. If `initCode` is present, create the account.\n2. `account.validateUserOp`.\n3. if specified a paymaster: `paymaster.validatePaymasterUserOp`.\n\nEither `validateUserOp` or `validatePaymasterUserOp` may return a \"validAfter\" and \"validUntil\" timestamps, which is the time-range that this UserOperation is valid on-chain.\nThe simulateValidation call returns this range.\nA node MAY drop a UserOperation if it expires too soon (e.g. wouldn't make it to the next block)\nIf the `ValidationResult` includes `sigFail`, the client SHOULD drop the `UserOperation`.\n\nIn order to prevent DoS attack on bundlers, they must make sure the validation methods above pass the validation rules, which constraint their usage of opcodes and storage.\nFor the complete procedure see [ERC-7562](./erc-7562.md)\n\n#### Alternative Mempools\n\nThe simulation rules above are strict and prevent the ability of paymasters and signature aggregators to grief the system.\nHowever, there might be use-cases where specific paymasters (and signature aggregators) can be validated\n(through manual auditing) and verified that they cannot cause any problem, while still require relaxing of the opcode rules.\nA bundler cannot simply \"whitelist\" request from a specific paymaster: if that paymaster is not accepted by all\nbundlers, then its support will be sporadic at best.\nInstead, we introduce the term \"alternate mempool\": a modified validation rules, and procedure of propagating them to other bundlers. \n\nThe procedure of using alternate mempools is defined in [ERC-7562](./erc-7562.md#Alt-mempools-rules)\n\n### Bundling\n\nDuring bundling, the client should:\n\n* Exclude UserOps that access any sender address of another UserOp in the same batch.\n* Exclude UserOps that access any address created by another UserOp validation in the same batch (via a factory).\n* For each paymaster used in the batch, keep track of the balance while adding UserOps. Ensure that it has sufficient deposit to pay for all the UserOps that use it.\n* Sort UserOps by aggregator, to create the lists of UserOps-per-aggregator.\n* For each aggregator, run the aggregator-specific code to create aggregated signature, and update the UserOps\n\nAfter creating the batch, before including the transaction in a block, the client should:\n\n* Run `debug_traceCall` with maximum possible gas, to enforce the validation rules on opcode and storage access.\n  as well as to verify the entire `handleOps` batch transaction,\n  and use the consumed gas for the actual transaction execution.\n* If the call reverted, check the `FailedOp` event.\n  A `FailedOp` during `handleOps` simulation is an unexpected event since it was supposed to be caught\n  by the single-UserOperation simulation.\n* If any verification context rule was violated the bundlers should treat it the same as\n  if this UserOperation reverted with a `FailedOp` event.\n* Remove the offending UserOperation from the current bundle and from mempool.\n* If the error is caused by a `factory` (error code is `AA1x`) or a `paymaster` (error code is `AA3x`), and the `sender`\n  of the UserOp **is not** a staked entity, then issue a \"ban\" (see [\"Reputation, throttling and banning\"](#reputation-scoring-and-throttlingbanning-for-global-entities))\n  for the guilty factory or paymaster.\n* If the error is caused by a `factory` (error code is `AA1x`) or a `paymaster` (error code is `AA3x`), and the `sender`\n  of the UserOp **is** a staked entity, do not ban the `factory` / `paymaster` from the mempool.\n  Instead, issue a \"ban\" for the staked `sender` entity.\n* Repeat until `debug_traceCall` succeeds.\n\nAs staked entries may use some kind of transient storage to communicate data between UserOperations in the same bundle,\nit is critical that the exact same opcode and precompile banning rules as well as storage access rules are enforced\nfor the `handleOps` validation in its entirety as for individual UserOperations.\nOtherwise, attackers may be able to use the banned opcodes to detect running on-chain and trigger a `FailedOp` revert.\n\nWhen a bundler includes a bundle in a block it must ensure that earlier transactions in the block don't make any UserOperation fail. It should either use access lists to prevent conflicts, or place the bundle as the first transaction in the block.\n\n\n## Rationale\n\nThe main challenge with a purely smart contract wallet based account abstraction system is DoS safety: how can a block builder including an operation make sure that it will actually pay fees, without having to first execute the entire operation? Requiring the block builder to execute the entire operation opens a DoS attack vector, as an attacker could easily send many operations that pretend to pay a fee but then revert at the last moment after a long execution. Similarly, to prevent attackers from cheaply clogging the mempool, nodes in the P2P network need to check if an operation will pay a fee before they are willing to forward it.\n\nThe first step is clean separation between validation (acceptance of UserOperation, and acceptance to pay) and execution.\nIn this proposal, we expect accounts to have a `validateUserOp` method that takes as input a `UserOperation`, and verify the signature and pay the fee.\nOnly if this method returns successfully, the execution will happen.\n\nThe entry point-based approach allows for a clean separation between verification and execution, and keeps accounts' logic simple. It enforces the simple rule that only after validation is successful (and the UserOp can pay), the execution is done, and also guarantees the fee payment.\n\nThe last step is protecting the bundlers from denial-of-service attacks by a mass number of UserOperation that appear to be valid (and pay) but that eventually revert, and thus block the bundler from processing valid UserOperations.\nFor this purpose, the bundler requires a set of [restrictions on the validation function](./erc-7526.md), to prevent such denial-of-service attacks.\n\n\n### Reputation scoring and throttling/banning for global entities\n\n#### Reputation Rationale.\n\nUserOperation's storage access rules prevent them from interfere with each other.\nBut \"global\" entities - paymasters, factories and aggregators are accessed by multiple UserOperations, and thus might invalidate multiple previously-valid UserOperations.\n\nTo prevent abuse, we throttle down (or completely ban for a period of time) an entity that causes invalidation of large number of UserOperations in the mempool.\nTo prevent such entities from \"sybil-attack\", we require them to stake with the system, and thus make such DoS attack very expensive.\nNote that this stake is never slashed, and can be withdrawn any time (after unst"
    }
  ]
}