{
  "Title": "M-4: Possible loss of Funds",
  "Content": "# Issue M-4: Possible loss of Funds \n\nSource: https://github.com/sherlock-audit/2023-06-dodo-judging/issues/101 \n\n## Found by \nAvci, BugHunter101, Chandr, HALITUS, MohammedRizwan, PRAISE, amaechieth, kutugu, seerether, shealtielanz, shogoki, skyge, tsvetanovv\n## Summary\n\nTransfers at Liquidation may silently fail, causing collateral be paid out withoud debt being paid, or liquidator not getting collateral.\n\n## Vulnerability Detail\n\nin [D3VaultLiquidation.sol:liquidate](https://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol#L30-L61) the caller pays the outstanding debt, and received the collateral tokens with a discount in exchange.\nHowever, the transfer of the tokens to pay the debt, as well as the transfer of the collateral Tokens are using the `transferFrom` function of the ERC20 interface instead of `safeTransferFrom`  (which is used in other functions). \nMoreover, the return value of this function is not checked. As not all ERC20 tokens revert on a failed transfer, this could lead to a silent failure of a transfer. As the function will go on in this case this could lead to the liquidation to finish with either:\n- The debt not being paid, but the collateral still paid to the caller --> Loss of protocol funds!\n- The debt being repaid by the caller, but the collateral is not transferred --> Loss of user funds!\n\n\n## Impact\n\nPossible loss of user or protocol funds.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol#L55\n\n\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/main/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol#L59\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUsage of `safeTransferFrom` as in other functions of the same contract is recommended.\n\n\n\n\n\n## Discussion\n\n**Shogoki**\n\nEscalate for 10USDC \nThis is not a duplicate of #203, which talks about USDC and Approval Race Condition protected tokens. \nFurthermore this is a separate issue together with duplicates like: #5 #42 #64 & #214 \n\n**sherlock-admin2**\n\n > Escalate for 10USDC \n> This is not a duplicate of #203, which talks about USDC and Approval Race Condition protected tokens. \n> Furthermore this is a separate issue together with duplicates like: #5 #42 #64 & #214 \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xffff11**\n\nAgree with escalation, it was wrongly duped. \n\n**jesusrod15**\n\nI agree that all the issues that came about race approvals were wrongly duped. Likewise, the rest of the issues that reported incorrect use of transferfrom instead of safetrasnferfrom were always duplicated in the same way in other contest regardless that whats happens. So I think this is a duplicate x example  of #11  #34  #5 #42  #88 and others  issue as this, this is not duplicate of #2  #35 and others  issue as this that are duplicate of #203 \n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nThe duplication has been changed accordingly \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Shogoki](https://github.com/sherlock-audit/2023-06-dodo-judging/issues/101/#issuecomment-1649990207): accepted\n\n**H4LITUS**\n\nThis is a duplicate of [#214](https://github.com/sherlock-audit/2023-06-dodo-judging/issues/214). So why was the status of 214 changed from `reward` to `non-reward`?\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/89",
  "Code": [
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"./D3VaultFunding.sol\";\n\ncontract D3VaultLiquidation is D3VaultFunding {\n    using SafeERC20 for IERC20;\n    using DecimalMath for uint256;\n\n    function isPositiveNetWorthAsset(address pool, address token) internal view returns (bool) {\n        (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n        return balance >= borrows;\n    }\n\n    function getPositiveNetWorthAsset(address pool, address token) internal view returns (uint256) {\n        (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n        if (balance > borrows) {\n            return balance - borrows;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice public liquidate function, repay pool negative worth token and get collateral tokens with discount\n    /// @param pool pool address, must be in belowMM\n    /// @param collateral pool collateral, any positive worth token pool has\n    /// @param collateralAmount collateral amount liquidator claim\n    /// @param debt pool debt, any negative worth token pool has\n    /// @param debtToCover debt amount liquidator repay\n    function liquidate(\n        address pool,\n        address collateral,\n        uint256 collateralAmount,\n        address debt,\n        uint256 debtToCover\n    ) external nonReentrant {\n        accrueInterests();\n\n        require(!ID3MM(pool).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\n        require(!checkBadDebtAfterAccrue(pool), Errors.HAS_BAD_DEBT);\n        require(checkCanBeLiquidatedAfterAccrue(pool), Errors.CANNOT_BE_LIQUIDATED);\n        require(isPositiveNetWorthAsset(pool, collateral), Errors.INVALID_COLLATERAL_TOKEN);\n        require(!isPositiveNetWorthAsset(pool, debt), Errors.INVALID_DEBT_TOKEN);\n        require(getPositiveNetWorthAsset(pool, collateral) >= collateralAmount, Errors.COLLATERAL_AMOUNT_EXCEED);\n        \n        uint256 collateralTokenPrice = ID3Oracle(_ORACLE_).getPrice(collateral);\n        uint256 debtTokenPrice = ID3Oracle(_ORACLE_).getPrice(debt);\n        uint256 collateralAmountMax = debtToCover.mul(debtTokenPrice).div(collateralTokenPrice.mul(DISCOUNT));\n        require(collateralAmount <= collateralAmountMax, Errors.COLLATERAL_AMOUNT_EXCEED);\n\n        AssetInfo storage info = assetInfo[debt];\n        BorrowRecord storage record = info.borrowRecord[pool];\n        uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n        require(debtToCover <= borrows, Errors.DEBT_TO_COVER_EXCEED);\n        IERC20(debt).transferFrom(msg.sender, address(this), debtToCover);\n\n        record.amount = borrows - debtToCover;\n        record.interestIndex = info.borrowIndex;\n        IERC20(collateral).transferFrom(pool, msg.sender, collateralAmount);\n        ID3MM(pool).updateReserveByVault(collateral);\n    }\n\n    // ---------- Liquidate by DODO team ----------\n    /// @notice if occuring bad debt, dodo team will start liquidation to balance debt\n    function startLiquidation(address pool) external onlyLiquidator nonReentrant {\n        accrueInterests();\n\n        require(!ID3MM(pool).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\n        require(checkCanBeLiquidatedAfterAccrue(pool), Errors.CANNOT_BE_LIQUIDATED);\n        ID3MM(pool).startLiquidation();\n\n        uint256 totalAssetValue = getTotalAssetsValue(pool);\n        uint256 totalDebtValue = _getTotalDebtValue(pool);\n        require(totalAssetValue < totalDebtValue, Errors.NO_BAD_DEBT);\n\n        uint256 ratio = totalAssetValue.div(totalDebtValue);\n\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            BorrowRecord storage record = info.borrowRecord[pool];\n            uint256 debt = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex).mul(ratio);\n            liquidationTarget[pool][token] = debt;\n        }\n    }\n\n    function liquidateByDODO(\n        address pool,\n        LiquidationOrder calldata order,\n        bytes calldata routeData,\n        address router\n    ) external onlyLiquidator nonReentrant {\n        uint256 toTokenReserve = IERC20(order.toToken).balanceOf(address(this));\n        uint256 fromTokenValue = DecimalMath.mul(ID3Oracle(_ORACLE_).getPrice(order.fromToken), order.fromAmount);\n\n        // swap using Route\n        {\n            IERC20(order.fromToken).transferFrom(pool, router, order.fromAmount);\n            (bool success, bytes memory data) = router.call(routeData);\n            if (!success) {\n                assembly {\n                    revert(add(data, 32), mload(data))\n                }\n            }\n        }\n\n        // the transferred-in toToken USD value should not be less than 95% of the transferred-out fromToken\n        uint256 receivedToToken = IERC20(order.toToken).balanceOf(address(this)) - toTokenReserve;\n        uint256 toTokenValue = DecimalMath.mul(ID3Oracle(_ORACLE_).getPrice(order.toToken), receivedToToken);\n\n        require(toTokenValue.div(fromTokenValue) >= DISCOUNT, Errors.EXCEED_DISCOUNT);\n        IERC20(order.toToken).safeTransfer(pool, receivedToToken);\n        ID3MM(pool).updateReserveByVault(order.fromToken);\n        ID3MM(pool).updateReserveByVault(order.toToken);\n    }\n\n    function finishLiquidation(address pool) external onlyLiquidator nonReentrant {\n        require(ID3MM(pool).isInLiquidation(), Errors.NOT_IN_LIQUIDATION);\n        accrueInterests();\n\n        bool hasPositiveBalance;\n        bool hasNegativeBalance;\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            uint256 balance = IERC20(token).balanceOf(pool);\n            uint256 debt = liquidationTarget[pool][token];\n            int256 difference = int256(balance) - int256(debt);\n            if (difference > 0) {\n                require(!hasNegativeBalance, Errors.LIQUIDATION_NOT_DONE);\n                hasPositiveBalance = true;\n            } else if (difference < 0) {\n                require(!hasPositiveBalance, Errors.LIQUIDATION_NOT_DONE);\n                hasNegativeBalance = true;\n                debt = balance; // if balance is less than target amount, just repay with balance\n            }\n\n            BorrowRecord storage record = info.borrowRecord[pool];\n            uint256 borrows = record.amount;\n            if (borrows == 0) continue;\n\n            // note: During liquidation process, the pool's debt will slightly increase due to the generated interests. \n            // The liquidation process will not repay the interests. Thus all dToken holders will share the loss equally.\n            uint256 realDebt = borrows.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n            IERC20(token).transferFrom(pool, address(this), debt);\n\n            info.totalBorrows = info.totalBorrows - realDebt;\n            record.amount = 0;\n        }\n\n        ID3MM(pool).finishLiquidation();\n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"./D3VaultFunding.sol\";\n\ncontract D3VaultLiquidation is D3VaultFunding {\n    using SafeERC20 for IERC20;\n    using DecimalMath for uint256;\n\n    function isPositiveNetWorthAsset(address pool, address token) internal view returns (bool) {\n        (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n        return balance >= borrows;\n    }\n\n    function getPositiveNetWorthAsset(address pool, address token) internal view returns (uint256) {\n        (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n        if (balance > borrows) {\n            return balance - borrows;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice public liquidate function, repay pool negative worth token and get collateral tokens with discount\n    /// @param pool pool address, must be in belowMM\n    /// @param collateral pool collateral, any positive worth token pool has\n    /// @param collateralAmount collateral amount liquidator claim\n    /// @param debt pool debt, any negative worth token pool has\n    /// @param debtToCover debt amount liquidator repay\n    function liquidate(\n        address pool,\n        address collateral,\n        uint256 collateralAmount,\n        address debt,\n        uint256 debtToCover\n    ) external nonReentrant {\n        accrueInterests();\n\n        require(!ID3MM(pool).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\n        require(!checkBadDebtAfterAccrue(pool), Errors.HAS_BAD_DEBT);\n        require(checkCanBeLiquidatedAfterAccrue(pool), Errors.CANNOT_BE_LIQUIDATED);\n        require(isPositiveNetWorthAsset(pool, collateral), Errors.INVALID_COLLATERAL_TOKEN);\n        require(!isPositiveNetWorthAsset(pool, debt), Errors.INVALID_DEBT_TOKEN);\n        require(getPositiveNetWorthAsset(pool, collateral) >= collateralAmount, Errors.COLLATERAL_AMOUNT_EXCEED);\n        \n        uint256 collateralTokenPrice = ID3Oracle(_ORACLE_).getPrice(collateral);\n        uint256 debtTokenPrice = ID3Oracle(_ORACLE_).getPrice(debt);\n        uint256 collateralAmountMax = debtToCover.mul(debtTokenPrice).div(collateralTokenPrice.mul(DISCOUNT));\n        require(collateralAmount <= collateralAmountMax, Errors.COLLATERAL_AMOUNT_EXCEED);\n\n        AssetInfo storage info = assetInfo[debt];\n        BorrowRecord storage record = info.borrowRecord[pool];\n        uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n        require(debtToCover <= borrows, Errors.DEBT_TO_COVER_EXCEED);\n        IERC20(debt).transferFrom(msg.sender, address(this), debtToCover);\n\n        record.amount = borrows - debtToCover;\n        record.interestIndex = info.borrowIndex;\n        IERC20(collateral).transferFrom(pool, msg.sender, collateralAmount);\n        ID3MM(pool).updateReserveByVault(collateral);\n    }\n\n    // ---------- Liquidate by DODO team ----------\n    /// @notice if occuring bad debt, dodo team will start liquidation to balance debt\n    function startLiquidation(address pool) external onlyLiquidator nonReentrant {\n        accrueInterests();\n\n        require(!ID3MM(pool).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\n        require(checkCanBeLiquidatedAfterAccrue(pool), Errors.CANNOT_BE_LIQUIDATED);\n        ID3MM(pool).startLiquidation();\n\n        uint256 totalAssetValue = getTotalAssetsValue(pool);\n        uint256 totalDebtValue = _getTotalDebtValue(pool);\n        require(totalAssetValue < totalDebtValue, Errors.NO_BAD_DEBT);\n\n        uint256 ratio = totalAssetValue.div(totalDebtValue);\n\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            BorrowRecord storage record = info.borrowRecord[pool];\n            uint256 debt = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex).mul(ratio);\n            liquidationTarget[pool][token] = debt;\n        }\n    }\n\n    function liquidateByDODO(\n        address pool,\n        LiquidationOrder calldata order,\n        bytes calldata routeData,\n        address router\n    ) external onlyLiquidator nonReentrant {\n        uint256 toTokenReserve = IERC20(order.toToken).balanceOf(address(this));\n        uint256 fromTokenValue = DecimalMath.mul(ID3Oracle(_ORACLE_).getPrice(order.fromToken), order.fromAmount);\n\n        // swap using Route\n        {\n            IERC20(order.fromToken).transferFrom(pool, router, order.fromAmount);\n            (bool success, bytes memory data) = router.call(routeData);\n            if (!success) {\n                assembly {\n                    revert(add(data, 32), mload(data))\n                }\n            }\n        }\n\n        // the transferred-in toToken USD value should not be less than 95% of the transferred-out fromToken\n        uint256 receivedToToken = IERC20(order.toToken).balanceOf(address(this)) - toTokenReserve;\n        uint256 toTokenValue = DecimalMath.mul(ID3Oracle(_ORACLE_).getPrice(order.toToken), receivedToToken);\n\n        require(toTokenValue.div(fromTokenValue) >= DISCOUNT, Errors.EXCEED_DISCOUNT);\n        IERC20(order.toToken).safeTransfer(pool, receivedToToken);\n        ID3MM(pool).updateReserveByVault(order.fromToken);\n        ID3MM(pool).updateReserveByVault(order.toToken);\n    }\n\n    function finishLiquidation(address pool) external onlyLiquidator nonReentrant {\n        require(ID3MM(pool).isInLiquidation(), Errors.NOT_IN_LIQUIDATION);\n        accrueInterests();\n\n        bool hasPositiveBalance;\n        bool hasNegativeBalance;\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            uint256 balance = IERC20(token).balanceOf(pool);\n            uint256 debt = liquidationTarget[pool][token];\n            int256 difference = int256(balance) - int256(debt);\n            if (difference > 0) {\n                require(!hasNegativeBalance, Errors.LIQUIDATION_NOT_DONE);\n                hasPositiveBalance = true;\n            } else if (difference < 0) {\n                require(!hasPositiveBalance, Errors.LIQUIDATION_NOT_DONE);\n                hasNegativeBalance = true;\n                debt = balance; // if balance is less than target amount, just repay with balance\n            }\n\n            BorrowRecord storage record = info.borrowRecord[pool];\n            uint256 borrows = record.amount;\n            if (borrows == 0) continue;\n\n            // note: During liquidation process, the pool's debt will slightly increase due to the generated interests. \n            // The liquidation process will not repay the interests. Thus all dToken holders will share the loss equally.\n            uint256 realDebt = borrows.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n            IERC20(token).transferFrom(pool, address(this), debt);\n\n            info.totalBorrows = info.totalBorrows - realDebt;\n            record.amount = 0;\n        }\n\n        ID3MM(pool).finishLiquidation();\n    }\n}"
    },
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultLiquidation.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"./D3VaultFunding.sol\";\n\ncontract D3VaultLiquidation is D3VaultFunding {\n    using SafeERC20 for IERC20;\n    using DecimalMath for uint256;\n\n    function isPositiveNetWorthAsset(address pool, address token) internal view returns (bool) {\n        (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n        return balance >= borrows;\n    }\n\n    function getPositiveNetWorthAsset(address pool, address token) internal view returns (uint256) {\n        (uint256 balance, uint256 borrows) = _getBalanceAndBorrows(pool, token);\n        if (balance > borrows) {\n            return balance - borrows;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice public liquidate function, repay pool negative worth token and get collateral tokens with discount\n    /// @param pool pool address, must be in belowMM\n    /// @param collateral pool collateral, any positive worth token pool has\n    /// @param collateralAmount collateral amount liquidator claim\n    /// @param debt pool debt, any negative worth token pool has\n    /// @param debtToCover debt amount liquidator repay\n    function liquidate(\n        address pool,\n        address collateral,\n        uint256 collateralAmount,\n        address debt,\n        uint256 debtToCover\n    ) external nonReentrant {\n        accrueInterests();\n\n        require(!ID3MM(pool).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\n        require(!checkBadDebtAfterAccrue(pool), Errors.HAS_BAD_DEBT);\n        require(checkCanBeLiquidatedAfterAccrue(pool), Errors.CANNOT_BE_LIQUIDATED);\n        require(isPositiveNetWorthAsset(pool, collateral), Errors.INVALID_COLLATERAL_TOKEN);\n        require(!isPositiveNetWorthAsset(pool, debt), Errors.INVALID_DEBT_TOKEN);\n        require(getPositiveNetWorthAsset(pool, collateral) >= collateralAmount, Errors.COLLATERAL_AMOUNT_EXCEED);\n        \n        uint256 collateralTokenPrice = ID3Oracle(_ORACLE_).getPrice(collateral);\n        uint256 debtTokenPrice = ID3Oracle(_ORACLE_).getPrice(debt);\n        uint256 collateralAmountMax = debtToCover.mul(debtTokenPrice).div(collateralTokenPrice.mul(DISCOUNT));\n        require(collateralAmount <= collateralAmountMax, Errors.COLLATERAL_AMOUNT_EXCEED);\n\n        AssetInfo storage info = assetInfo[debt];\n        BorrowRecord storage record = info.borrowRecord[pool];\n        uint256 borrows = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n        require(debtToCover <= borrows, Errors.DEBT_TO_COVER_EXCEED);\n        IERC20(debt).transferFrom(msg.sender, address(this), debtToCover);\n\n        record.amount = borrows - debtToCover;\n        record.interestIndex = info.borrowIndex;\n        IERC20(collateral).transferFrom(pool, msg.sender, collateralAmount);\n        ID3MM(pool).updateReserveByVault(collateral);\n    }\n\n    // ---------- Liquidate by DODO team ----------\n    /// @notice if occuring bad debt, dodo team will start liquidation to balance debt\n    function startLiquidation(address pool) external onlyLiquidator nonReentrant {\n        accrueInterests();\n\n        require(!ID3MM(pool).isInLiquidation(), Errors.ALREADY_IN_LIQUIDATION);\n        require(checkCanBeLiquidatedAfterAccrue(pool), Errors.CANNOT_BE_LIQUIDATED);\n        ID3MM(pool).startLiquidation();\n\n        uint256 totalAssetValue = getTotalAssetsValue(pool);\n        uint256 totalDebtValue = _getTotalDebtValue(pool);\n        require(totalAssetValue < totalDebtValue, Errors.NO_BAD_DEBT);\n\n        uint256 ratio = totalAssetValue.div(totalDebtValue);\n\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            BorrowRecord storage record = info.borrowRecord[pool];\n            uint256 debt = record.amount.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex).mul(ratio);\n            liquidationTarget[pool][token] = debt;\n        }\n    }\n\n    function liquidateByDODO(\n        address pool,\n        LiquidationOrder calldata order,\n        bytes calldata routeData,\n        address router\n    ) external onlyLiquidator nonReentrant {\n        uint256 toTokenReserve = IERC20(order.toToken).balanceOf(address(this));\n        uint256 fromTokenValue = DecimalMath.mul(ID3Oracle(_ORACLE_).getPrice(order.fromToken), order.fromAmount);\n\n        // swap using Route\n        {\n            IERC20(order.fromToken).transferFrom(pool, router, order.fromAmount);\n            (bool success, bytes memory data) = router.call(routeData);\n            if (!success) {\n                assembly {\n                    revert(add(data, 32), mload(data))\n                }\n            }\n        }\n\n        // the transferred-in toToken USD value should not be less than 95% of the transferred-out fromToken\n        uint256 receivedToToken = IERC20(order.toToken).balanceOf(address(this)) - toTokenReserve;\n        uint256 toTokenValue = DecimalMath.mul(ID3Oracle(_ORACLE_).getPrice(order.toToken), receivedToToken);\n\n        require(toTokenValue.div(fromTokenValue) >= DISCOUNT, Errors.EXCEED_DISCOUNT);\n        IERC20(order.toToken).safeTransfer(pool, receivedToToken);\n        ID3MM(pool).updateReserveByVault(order.fromToken);\n        ID3MM(pool).updateReserveByVault(order.toToken);\n    }\n\n    function finishLiquidation(address pool) external onlyLiquidator nonReentrant {\n        require(ID3MM(pool).isInLiquidation(), Errors.NOT_IN_LIQUIDATION);\n        accrueInterests();\n\n        bool hasPositiveBalance;\n        bool hasNegativeBalance;\n        for (uint256 i; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            AssetInfo storage info = assetInfo[token];\n            uint256 balance = IERC20(token).balanceOf(pool);\n            uint256 debt = liquidationTarget[pool][token];\n            int256 difference = int256(balance) - int256(debt);\n            if (difference > 0) {\n                require(!hasNegativeBalance, Errors.LIQUIDATION_NOT_DONE);\n                hasPositiveBalance = true;\n            } else if (difference < 0) {\n                require(!hasPositiveBalance, Errors.LIQUIDATION_NOT_DONE);\n                hasNegativeBalance = true;\n                debt = balance; // if balance is less than target amount, just repay with balance\n            }\n\n            BorrowRecord storage record = info.borrowRecord[pool];\n            uint256 borrows = record.amount;\n            if (borrows == 0) continue;\n\n            // note: During liquidation process, the pool's debt will slightly increase due to the generated interests. \n            // The liquidation process will not repay the interests. Thus all dToken holders will share the loss equally.\n            uint256 realDebt = borrows.div(record.interestIndex == 0 ? 1e18 : record.interestIndex).mul(info.borrowIndex);\n            IERC20(token).transferFrom(pool, address(this), debt);\n\n            info.totalBorrows = info.totalBorrows - realDebt;\n            record.amount = 0;\n        }\n\n        ID3MM(pool).finishLiquidation();\n    }\n}"
    }
  ]
}