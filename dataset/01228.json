{
  "Title": "User can create small position after exit with bid",
  "Content": "# User can create small position after exit with bid\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/ExitShortFacet.sol#L175-L180\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/ExitShortFacet.sol#L175-L180</a>\n\n\n## Summary\nUser can create small position after exit with bid, because there is no validation after matching.\n## Vulnerability Details\nShorter can partially exit from position using `ExitShortFacet.exitShort` function. This function acccepts `buyBackAmount` param which is debt amount that user wants to repay.\nIn order to cover debt, function [will create force bid](https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/ExitShortFacet.sol#L210-L212) on behalf of user with `buyBackAmount` as needed asset.\n\nIn the beginning function checks that [position will not be too small](https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/ExitShortFacet.sol#L175-L180) after this action. In case if `buyBackAmount == e.ercDebt` then this check is skipped. This is needed in order to not allow small positions as it creates risks for the system.\n\nThe problem is that such check is not enough and it should be actually done after the bid matching, when you know how many assets were purchased. This is because, matching doesn't guarantee, that there is enough amount that can be sold. As result, not whole `buyBackAmount` can be acquired.\nSo in case if user provides `buyBackAmount == e.ercDebt` then check is skipped and it's possible that `e.ercAmountLeft` will be smaller than needed min position.\n\nWhile this can happen accidentally, also attacker can control this behavour, as he can also provide the price of bid. So he can have a bot that will check ask/short lists and provide such bid, that will fill almost, but not whole `buyBackAmount`. This creates ability to have small positions, which liquidators may not be interested to liquidate, which can create bad debt.\n## Impact\nSmall positions can be created.\n## Tools Used\nVsCode\n## Recommendations\nI think that you need to check position size after bid matching, when you know exactly what have left.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/ExitShortFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U80, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract ExitShortFacet is Modifiers {\n    using U256 for uint256;\n    using U80 for uint80;\n    using U88 for uint88;\n    using LibShortRecord for STypes.ShortRecord;\n    using {LibAsset.burnMsgSenderDebt} for address;\n\n    address private immutable cusd;\n\n    constructor(address _cusd) {\n        cusd = _cusd;\n    }\n\n    /**\n     * @notice Exits a short using shorter's ERC in wallet (i.e.MetaMask)\n     * @dev allows for partial exit via buyBackAmount\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param buyBackAmount Erc amount to buy back\n     *\n     */\n\n    function exitShortWallet(address asset, uint8 id, uint88 buyBackAmount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n\n        short.updateErcDebt(asset);\n        uint256 ercDebt = short.ercDebt;\n        if (buyBackAmount > ercDebt || buyBackAmount == 0) revert Errors.InvalidBuyback();\n\n        if (ercDebt > buyBackAmount) {\n            uint256 leftoverAmt = (ercDebt - buyBackAmount).mul(LibOracle.getPrice(asset));\n            if (leftoverAmt < LibAsset.minBidEth(asset)) {\n                revert Errors.CannotLeaveDustAmount();\n            }\n        }\n\n        asset.burnMsgSenderDebt(buyBackAmount);\n        s.asset[asset].ercDebt -= buyBackAmount;\n        // refund the rest of the collateral if ercDebt is fully paid back\n        if (buyBackAmount == ercDebt) {\n            uint256 vault = s.asset[asset].vault;\n            uint88 collateral = short.collateral;\n            s.vaultUser[vault][msg.sender].ethEscrowed += collateral;\n            LibShortRecord.disburseCollateral(\n                asset, msg.sender, collateral, short.zethYieldRate, short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(asset, msg.sender, id);\n        } else {\n            short.ercDebt -= buyBackAmount;\n            short.maybeResetFlag(asset);\n        }\n        emit Events.ExitShortWallet(asset, msg.sender, id, buyBackAmount);\n    }\n\n    /**\n     * @notice Exits a short using shorter's ERC in balance (ErcEscrowed)\n     * @dev allows for partial exit via buyBackAmount\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param buyBackAmount Erc amount to buy back\n     *\n     */\n\n    function exitShortErcEscrowed(address asset, uint8 id, uint88 buyBackAmount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n\n        short.updateErcDebt(asset);\n        uint256 ercDebt = short.ercDebt;\n        if (buyBackAmount == 0 || buyBackAmount > ercDebt) revert Errors.InvalidBuyback();\n\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][msg.sender];\n        if (AssetUser.ercEscrowed < buyBackAmount) {\n            revert Errors.InsufficientERCEscrowed();\n        }\n\n        if (ercDebt > buyBackAmount) {\n            uint256 leftoverAmt = (ercDebt - buyBackAmount).mul(LibOracle.getPrice(asset));\n            if (leftoverAmt < LibAsset.minBidEth(asset)) {\n                revert Errors.CannotLeaveDustAmount();\n            }\n        }\n\n        AssetUser.ercEscrowed -= buyBackAmount;\n        Asset.ercDebt -= buyBackAmount;\n        // refund the rest of the collateral if ercDebt is fully paid back\n        if (ercDebt == buyBackAmount) {\n            uint88 collateral = short.collateral;\n            s.vaultUser[Asset.vault][msg.sender].ethEscrowed += collateral;\n            LibShortRecord.disburseCollateral(\n                asset, msg.sender, collateral, short.zethYieldRate, short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(asset, msg.sender, id);\n        } else {\n            short.ercDebt -= buyBackAmount;\n            short.maybeResetFlag(asset);\n        }\n        emit Events.ExitShortErcEscrowed(asset, msg.sender, id, buyBackAmount);\n    }\n\n    /**\n     * @notice Exits a short by placing bid on market\n     * @dev allows for partial exit via buyBackAmount\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param buyBackAmount Erc amount to buy back\n     * @param price Price at which shorter wants to place bid\n     * @param shortHintArray Array of hintId for the id to start matching against shorts since you can't match a short < oracle price\n     *\n     */\n\n    function exitShort(\n        address asset,\n        uint8 id,\n        uint88 buyBackAmount,\n        uint80 price,\n        uint16[] memory shortHintArray\n    )\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        MTypes.ExitShort memory e;\n        e.asset = asset;\n        LibOrders.updateOracleAndStartingShortViaTimeBidOnly(\n            e.asset, OF.FifteenMinutes, shortHintArray\n        );\n\n        STypes.Asset storage Asset = s.asset[e.asset];\n        STypes.ShortRecord storage short = s.shortRecords[e.asset][msg.sender][id];\n\n        short.updateErcDebt(e.asset);\n\n        e.beforeExitCR = short.getCollateralRatio(e.asset);\n        e.ercDebt = short.ercDebt;\n        e.collateral = short.collateral;\n\n        if (buyBackAmount == 0 || buyBackAmount > e.ercDebt) {\n            revert Errors.InvalidBuyback();\n        }\n        if (e.ercDebt > buyBackAmount) {\n            uint256 leftoverAmt = (e.ercDebt - buyBackAmount).mul(price);\n            if (leftoverAmt < LibAsset.minBidEth(e.asset)) {\n                revert Errors.CannotLeaveDustAmount();\n            }\n        }\n\n        {\n            uint256 ethAmount = price.mul(buyBackAmount);\n            if (ethAmount > e.collateral) revert Errors.InsufficientCollateral();\n        }\n\n        {\n            uint16 lowestAskKey = s.asks[e.asset][Constants.HEAD].nextId;\n            uint16 startingShortId = s.asset[e.asset].startingShortId;\n\n            if (\n                (\n                    lowestAskKey == Constants.TAIL\n                        || s.asks[e.asset][lowestAskKey].price > price\n                )\n                    && (\n                        startingShortId == Constants.HEAD\n                            || s.shorts[e.asset][startingShortId].price > price\n                    )\n            ) {\n                revert Errors.ExitShortPriceTooLow();\n            }\n        }\n\n        // Temporary accounting to enable bid\n        STypes.VaultUser storage VaultUser = s.vaultUser[Asset.vault][msg.sender];\n        VaultUser.ethEscrowed += e.collateral;\n\n        // Create bid with current msg.sender\n        (e.ethFilled, e.ercAmountLeft) = IDiamond(payable(address(this))).createForcedBid(\n            msg.sender, e.asset, price, buyBackAmount, shortHintArray\n        );\n\n        e.ercFilled = buyBackAmount - e.ercAmountLeft;\n        Asset.ercDebt -= e.ercFilled;\n        s.assetUser[e.asset][msg.sender].ercEscrowed -= e.ercFilled;\n\n        // Refund the rest of the collateral if ercDebt is fully paid back\n        if (e.ercDebt == e.ercFilled) {\n            // Full Exit\n            LibShortRecord.disburseCollateral(\n                e.asset, msg.sender, e.collateral, short.zethYieldRate, short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(e.asset, msg.sender, id); // prevent re-entrancy\n        } else {\n            short.collateral -= e.ethFilled;\n            short.ercDebt -= e.ercFilled;\n\n            //@dev Only allow partial exit if the CR is same or better than before\n            if (short.getCollateralRatio(e.asset) < e.beforeExitCR) {\n                revert Errors.PostExitCRLtPreExitCR();\n            }\n\n            //@dev collateral already subtracted in exitShort()\n            VaultUser.ethEscrowed -= e.collateral - e.ethFilled;\n            LibShortRecord.disburseCollateral(\n                e.asset, msg.sender, e.ethFilled, short.zethYieldRate, short.updatedAt\n            );\n            short.maybeResetFlag(e.asset);\n        }\n        emit Events.ExitShort(asset, msg.sender, id, e.ercFilled);\n    }\n}"
    },
    {
      "filename": "contracts/facets/ExitShortFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U80, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract ExitShortFacet is Modifiers {\n    using U256 for uint256;\n    using U80 for uint80;\n    using U88 for uint88;\n    using LibShortRecord for STypes.ShortRecord;\n    using {LibAsset.burnMsgSenderDebt} for address;\n\n    address private immutable cusd;\n\n    constructor(address _cusd) {\n        cusd = _cusd;\n    }\n\n    /**\n     * @notice Exits a short using shorter's ERC in wallet (i.e.MetaMask)\n     * @dev allows for partial exit via buyBackAmount\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param buyBackAmount Erc amount to buy back\n     *\n     */\n\n    function exitShortWallet(address asset, uint8 id, uint88 buyBackAmount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n\n        short.updateErcDebt(asset);\n        uint256 ercDebt = short.ercDebt;\n        if (buyBackAmount > ercDebt || buyBackAmount == 0) revert Errors.InvalidBuyback();\n\n        if (ercDebt > buyBackAmount) {\n            uint256 leftoverAmt = (ercDebt - buyBackAmount).mul(LibOracle.getPrice(asset));\n            if (leftoverAmt < LibAsset.minBidEth(asset)) {\n                revert Errors.CannotLeaveDustAmount();\n            }\n        }\n\n        asset.burnMsgSenderDebt(buyBackAmount);\n        s.asset[asset].ercDebt -= buyBackAmount;\n        // refund the rest of the collateral if ercDebt is fully paid back\n        if (buyBackAmount == ercDebt) {\n            uint256 vault = s.asset[asset].vault;\n            uint88 collateral = short.collateral;\n            s.vaultUser[vault][msg.sender].ethEscrowed += collateral;\n            LibShortRecord.disburseCollateral(\n                asset, msg.sender, collateral, short.zethYieldRate, short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(asset, msg.sender, id);\n        } else {\n            short.ercDebt -= buyBackAmount;\n            short.maybeResetFlag(asset);\n        }\n        emit Events.ExitShortWallet(asset, msg.sender, id, buyBackAmount);\n    }\n\n    /**\n     * @notice Exits a short using shorter's ERC in balance (ErcEscrowed)\n     * @dev allows for partial exit via buyBackAmount\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param buyBackAmount Erc amount to buy back\n     *\n     */\n\n    function exitShortErcEscrowed(address asset, uint8 id, uint88 buyBackAmount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n\n        short.updateErcDebt(asset);\n        uint256 ercDebt = short.ercDebt;\n        if (buyBackAmount == 0 || buyBackAmount > ercDebt) revert Errors.InvalidBuyback();\n\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][msg.sender];\n        if (AssetUser.ercEscrowed < buyBackAmount) {\n            revert Errors.InsufficientERCEscrowed();\n        }\n\n        if (ercDebt > buyBackAmount) {\n            uint256 leftoverAmt = (ercDebt - buyBackAmount).mul(LibOracle.getPrice(asset));\n            if (leftoverAmt < LibAsset.minBidEth(asset)) {\n                revert Errors.CannotLeaveDustAmount();\n            }\n        }\n\n        AssetUser.ercEscrowed -= buyBackAmount;\n        Asset.ercDebt -= buyBackAmount;\n        // refund the rest of the collateral if ercDebt is fully paid back\n        if (ercDebt == buyBackAmount) {\n            uint88 collateral = short.collateral;\n            s.vaultUser[Asset.vault][msg.sender].ethEscrowed += collateral;\n            LibShortRecord.disburseCollateral(\n                asset, msg.sender, collateral, short.zethYieldRate, short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(asset, msg.sender, id);\n        } else {\n            short.ercDebt -= buyBackAmount;\n            short.maybeResetFlag(asset);\n        }\n        emit Events.ExitShortErcEscrowed(asset, msg.sender, id, buyBackAmount);\n    }\n\n    /**\n     * @notice Exits a short by placing bid on market\n     * @dev allows for partial exit via buyBackAmount\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param buyBackAmount Erc amount to buy back\n     * @param price Price at which shorter wants to place bid\n     * @param shortHintArray Array of hintId for the id to start matching against shorts since you can't match a short < oracle price\n     *\n     */\n\n    function exitShort(\n        address asset,\n        uint8 id,\n        uint88 buyBackAmount,\n        uint80 price,\n        uint16[] memory shortHintArray\n    )\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        MTypes.ExitShort memory e;\n        e.asset = asset;\n        LibOrders.updateOracleAndStartingShortViaTimeBidOnly(\n            e.asset, OF.FifteenMinutes, shortHintArray\n        );\n\n        STypes.Asset storage Asset = s.asset[e.asset];\n        STypes.ShortRecord storage short = s.shortRecords[e.asset][msg.sender][id];\n\n        short.updateErcDebt(e.asset);\n\n        e.beforeExitCR = short.getCollateralRatio(e.asset);\n        e.ercDebt = short.ercDebt;\n        e.collateral = short.collateral;\n\n        if (buyBackAmount == 0 || buyBackAmount > e.ercDebt) {\n            revert Errors.InvalidBuyback();\n        }\n        if (e.ercDebt > buyBackAmount) {\n            uint256 leftoverAmt = (e.ercDebt - buyBackAmount).mul(price);\n            if (leftoverAmt < LibAsset.minBidEth(e.asset)) {\n                revert Errors.CannotLeaveDustAmount();\n            }\n        }\n\n        {\n            uint256 ethAmount = price.mul(buyBackAmount);\n            if (ethAmount > e.collateral) revert Errors.InsufficientCollateral();\n        }\n\n        {\n            uint16 lowestAskKey = s.asks[e.asset][Constants.HEAD].nextId;\n            uint16 startingShortId = s.asset[e.asset].startingShortId;\n\n            if (\n                (\n                    lowestAskKey == Constants.TAIL\n                        || s.asks[e.asset][lowestAskKey].price > price\n                )\n                    && (\n                        startingShortId == Constants.HEAD\n                            || s.shorts[e.asset][startingShortId].price > price\n                    )\n            ) {\n                revert Errors.ExitShortPriceTooLow();\n            }\n        }\n\n        // Temporary accounting to enable bid\n        STypes.VaultUser storage VaultUser = s.vaultUser[Asset.vault][msg.sender];\n        VaultUser.ethEscrowed += e.collateral;\n\n        // Create bid with current msg.sender\n        (e.ethFilled, e.ercAmountLeft) = IDiamond(payable(address(this))).createForcedBid(\n            msg.sender, e.asset, price, buyBackAmount, shortHintArray\n        );\n\n        e.ercFilled = buyBackAmount - e.ercAmountLeft;\n        Asset.ercDebt -= e.ercFilled;\n        s.assetUser[e.asset][msg.sender].ercEscrowed -= e.ercFilled;\n\n        // Refund the rest of the collateral if ercDebt is fully paid back\n        if (e.ercDebt == e.ercFilled) {\n            // Full Exit\n            LibShortRecord.disburseCollateral(\n                e.asset, msg.sender, e.collateral, short.zethYieldRate, short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(e.asset, msg.sender, id); // prevent re-entrancy\n        } else {\n            short.collateral -= e.ethFilled;\n            short.ercDebt -= e.ercFilled;\n\n            //@dev Only allow partial exit if the CR is same or better than before\n            if (short.getCollateralRatio(e.asset) < e.beforeExitCR) {\n                revert Errors.PostExitCRLtPreExitCR();\n            }\n\n            //@dev collateral already subtracted in exitShort()\n            VaultUser.ethEscrowed -= e.collateral - e.ethFilled;\n            LibShortRecord.disburseCollateral(\n                e.asset, msg.sender, e.ethFilled, short.zethYieldRate, short.updatedAt\n            );\n            short.maybeResetFlag(e.asset);\n        }\n        emit Events.ExitShort(asset, msg.sender, id, e.ercFilled);\n    }\n}"
    },
    {
      "filename": "contracts/facets/ExitShortFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U80, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract ExitShortFacet is Modifiers {\n    using U256 for uint256;\n    using U80 for uint80;\n    using U88 for uint88;\n    using LibShortRecord for STypes.ShortRecord;\n    using {LibAsset.burnMsgSenderDebt} for address;\n\n    address private immutable cusd;\n\n    constructor(address _cusd) {\n        cusd = _cusd;\n    }\n\n    /**\n     * @notice Exits a short using shorter's ERC in wallet (i.e.MetaMask)\n     * @dev allows for partial exit via buyBackAmount\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param buyBackAmount Erc amount to buy back\n     *\n     */\n\n    function exitShortWallet(address asset, uint8 id, uint88 buyBackAmount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n\n        short.updateErcDebt(asset);\n        uint256 ercDebt = short.ercDebt;\n        if (buyBackAmount > ercDebt || buyBackAmount == 0) revert Errors.InvalidBuyback();\n\n        if (ercDebt > buyBackAmount) {\n            uint256 leftoverAmt = (ercDebt - buyBackAmount).mul(LibOracle.getPrice(asset));\n            if (leftoverAmt < LibAsset.minBidEth(asset)) {\n                revert Errors.CannotLeaveDustAmount();\n            }\n        }\n\n        asset.burnMsgSenderDebt(buyBackAmount);\n        s.asset[asset].ercDebt -= buyBackAmount;\n        // refund the rest of the collateral if ercDebt is fully paid back\n        if (buyBackAmount == ercDebt) {\n            uint256 vault = s.asset[asset].vault;\n            uint88 collateral = short.collateral;\n            s.vaultUser[vault][msg.sender].ethEscrowed += collateral;\n            LibShortRecord.disburseCollateral(\n                asset, msg.sender, collateral, short.zethYieldRate, short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(asset, msg.sender, id);\n        } else {\n            short.ercDebt -= buyBackAmount;\n            short.maybeResetFlag(asset);\n        }\n        emit Events.ExitShortWallet(asset, msg.sender, id, buyBackAmount);\n    }\n\n    /**\n     * @notice Exits a short using shorter's ERC in balance (ErcEscrowed)\n     * @dev allows for partial exit via buyBackAmount\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param buyBackAmount Erc amount to buy back\n     *\n     */\n\n    function exitShortErcEscrowed(address asset, uint8 id, uint88 buyBackAmount)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        STypes.Asset storage Asset = s.asset[asset];\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n\n        short.updateErcDebt(asset);\n        uint256 ercDebt = short.ercDebt;\n        if (buyBackAmount == 0 || buyBackAmount > ercDebt) revert Errors.InvalidBuyback();\n\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][msg.sender];\n        if (AssetUser.ercEscrowed < buyBackAmount) {\n            revert Errors.InsufficientERCEscrowed();\n        }\n\n        if (ercDebt > buyBackAmount) {\n            uint256 leftoverAmt = (ercDebt - buyBackAmount).mul(LibOracle.getPrice(asset));\n            if (leftoverAmt < LibAsset.minBidEth(asset)) {\n                revert Errors.CannotLeaveDustAmount();\n            }\n        }\n\n        AssetUser.ercEscrowed -= buyBackAmount;\n        Asset.ercDebt -= buyBackAmount;\n        // refund the rest of the collateral if ercDebt is fully paid back\n        if (ercDebt == buyBackAmount) {\n            uint88 collateral = short.collateral;\n            s.vaultUser[Asset.vault][msg.sender].ethEscrowed += collateral;\n            LibShortRecord.disburseCollateral(\n                asset, msg.sender, collateral, short.zethYieldRate, short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(asset, msg.sender, id);\n        } else {\n            short.ercDebt -= buyBackAmount;\n            short.maybeResetFlag(asset);\n        }\n        emit Events.ExitShortErcEscrowed(asset, msg.sender, id, buyBackAmount);\n    }\n\n    /**\n     * @notice Exits a short by placing bid on market\n     * @dev allows for partial exit via buyBackAmount\n     *\n     * @param asset The market that will be impacted\n     * @param id Id of short\n     * @param buyBackAmount Erc amount to buy back\n     * @param price Price at which shorter wants to place bid\n     * @param shortHintArray Array of hintId for the id to start matching against shorts since you can't match a short < oracle price\n     *\n     */\n\n    function exitShort(\n        address asset,\n        uint8 id,\n        uint88 buyBackAmount,\n        uint80 price,\n        uint16[] memory shortHintArray\n    )\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, msg.sender, id)\n    {\n        MTypes.ExitShort memory e;\n        e.asset = asset;\n        LibOrders.updateOracleAndStartingShortViaTimeBidOnly(\n            e.asset, OF.FifteenMinutes, shortHintArray\n        );\n\n        STypes.Asset storage Asset = s.asset[e.asset];\n        STypes.ShortRecord storage short = s.shortRecords[e.asset][msg.sender][id];\n\n        short.updateErcDebt(e.asset);\n\n        e.beforeExitCR = short.getCollateralRatio(e.asset);\n        e.ercDebt = short.ercDebt;\n        e.collateral = short.collateral;\n\n        if (buyBackAmount == 0 || buyBackAmount > e.ercDebt) {\n            revert Errors.InvalidBuyback();\n        }\n        if (e.ercDebt > buyBackAmount) {\n            uint256 leftoverAmt = (e.ercDebt - buyBackAmount).mul(price);\n            if (leftoverAmt < LibAsset.minBidEth(e.asset)) {\n                revert Errors.CannotLeaveDustAmount();\n            }\n        }\n\n        {\n            uint256 ethAmount = price.mul(buyBackAmount);\n            if (ethAmount > e.collateral) revert Errors.InsufficientCollateral();\n        }\n\n        {\n            uint16 lowestAskKey = s.asks[e.asset][Constants.HEAD].nextId;\n            uint16 startingShortId = s.asset[e.asset].startingShortId;\n\n            if (\n                (\n                    lowestAskKey == Constants.TAIL\n                        || s.asks[e.asset][lowestAskKey].price > price\n                )\n                    && (\n                        startingShortId == Constants.HEAD\n                            || s.shorts[e.asset][startingShortId].price > price\n                    )\n            ) {\n                revert Errors.ExitShortPriceTooLow();\n            }\n        }\n\n        // Temporary accounting to enable bid\n        STypes.VaultUser storage VaultUser = s.vaultUser[Asset.vault][msg.sender];\n        VaultUser.ethEscrowed += e.collateral;\n\n        // Create bid with current msg.sender\n        (e.ethFilled, e.ercAmountLeft) = IDiamond(payable(address(this))).createForcedBid(\n            msg.sender, e.asset, price, buyBackAmount, shortHintArray\n        );\n\n        e.ercFilled = buyBackAmount - e.ercAmountLeft;\n        Asset.ercDebt -= e.ercFilled;\n        s.assetUser[e.asset][msg.sender].ercEscrowed -= e.ercFilled;\n\n        // Refund the rest of the collateral if ercDebt is fully paid back\n        if (e.ercDebt == e.ercFilled) {\n            // Full Exit\n            LibShortRecord.disburseCollateral(\n                e.asset, msg.sender, e.collateral, short.zethYieldRate, short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(e.asset, msg.sender, id); // prevent re-entrancy\n        } else {\n            short.collateral -= e.ethFilled;\n            short.ercDebt -= e.ercFilled;\n\n            //@dev Only allow partial exit if the CR is same or better than before\n            if (short.getCollateralRatio(e.asset) < e.beforeExitCR) {\n                revert Errors.PostExitCRLtPreExitCR();\n            }\n\n            //@dev collateral already subtracted in exitShort()\n            VaultUser.ethEscrowed -= e.collateral - e.ethFilled;\n            LibShortRecord.disburseCollateral(\n                e.asset, msg.sender, e.ethFilled, short.zethYieldRate, short.updatedAt\n            );\n            short.maybeResetFlag(e.asset);\n        }\n        emit Events.ExitShort(asset, msg.sender, id, e.ercFilled);\n    }\n}"
    }
  ]
}