{
  "Title": "Funds held in ETHAdapter can be drained by anyone",
  "Content": "The [`ETHAdapter`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/proxy/ETHAdapter.sol) contract is used as a proxy to allow users to interact with the vault through sending and receiving ETH instead of stETH. The adapter achieves this by converting ETH and stETH through a curve pool and then forwarding interactions to and from the vault. In the course of a normal [withdrawal](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/proxy/ETHAdapter.sol#L71) or [redemption](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/proxy/ETHAdapter.sol#L46) transaction, the `ETHAdapter` will pull the funds out of the vault before passing them on to the designated receiver. During the moment the `ETHAdapter` is holding the funds, it first [converts](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/proxy/ETHAdapter.sol#L110-L112) all of its stETH to ETH, and then sends its entire ETH balance to the receiving address.\n\n\nThe issue is that the `ETHAdapter` sends its full balance to the receiver each time, meaning any ETH or stETH that is mistakenly sent to it can be drained by any user who performs a withdrawal or redemption on the `ETHAdapter`. This is exacerbated by the fact that the vault is passed in as a [parameter](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/proxy/ETHAdapter.sol#L72), potentially allowing a user to perform withdrawals and redemptions without interacting with the actual stETH vault.\n\n\nConsider transferring out the exchanged balance from the curve pool to the receiver instead of the entire balance of the `ETHAdapter`. Also consider implementing a rescue or sweep function to allow the recovery of funds that are accidentally sent to the `ETHAdapter`.\n\n\n***Update:** Acknowledged, will not fix. Pods Finance team’s statement:*\n\n\n\n> *For now, we do not want to take action in case of funds sends by mistake to our contract. We see this as a low-priority issue.*\n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/proxy/ETHAdapter.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../interfaces/IConfigurationManager.sol\";\nimport \"../interfaces/ICurvePool.sol\";\nimport \"../interfaces/IVault.sol\";\n\ncontract ETHAdapter {\n    using SafeERC20 for IERC20;\n    using Address for address payable;\n\n    ICurvePool public immutable pool;\n\n    address constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address constant STETH_ADDRESS = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n\n    error ETHAdapter__IncompatibleVault();\n\n    constructor(ICurvePool _pool) {\n        require(_pool.coins(0) == ETH_ADDRESS && _pool.coins(1) == STETH_ADDRESS);\n        pool = _pool;\n    }\n\n    function convertToSTETH(uint256 ethAmount) public view returns (uint256 stETHAmount) {\n        return pool.get_dy(0, 1, ethAmount);\n    }\n\n    function convertToETH(uint256 stETHAmount) public view returns (uint256 ethAmount) {\n        return pool.get_dy(1, 0, stETHAmount);\n    }\n\n    function deposit(\n        IVault vault,\n        address receiver,\n        uint256 minOutput\n    ) external payable returns (uint256 shares) {\n        if (vault.asset() != STETH_ADDRESS) revert ETHAdapter__IncompatibleVault();\n        uint256 assets = pool.exchange{ value: msg.value }(0, 1, msg.value, minOutput);\n        IERC20(vault.asset()).safeApprove(address(vault), assets);\n        return vault.deposit(assets, receiver);\n    }\n\n    function redeem(\n        IVault vault,\n        uint256 shares,\n        address receiver,\n        uint256 minOutput\n    ) external returns (uint256 assets) {\n        assets = vault.redeem(shares, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function redeemWithPermit(\n        IVault vault,\n        uint256 shares,\n        address receiver,\n        uint256 minOutput,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 assets) {\n        vault.permit(msg.sender, address(this), shares, deadline, v, r, s);\n        assets = vault.redeem(shares, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function withdraw(\n        IVault vault,\n        uint256 assets,\n        address receiver,\n        uint256 minOutput\n    ) external returns (uint256 shares) {\n        shares = vault.withdraw(assets, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    function withdrawWithPermit(\n        IVault vault,\n        uint256 assets,\n        address receiver,\n        uint256 minOutput,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 shares) {\n        shares = vault.convertToShares(assets);\n        vault.permit(msg.sender, address(this), shares, deadline, v, r, s);\n        shares = vault.withdraw(assets, address(this), msg.sender);\n        _returnETH(vault, receiver, minOutput);\n    }\n\n    /* We need this default function because this contract will\n        receive ETH from the Curve pool\n    */\n    receive() external payable {}\n\n    function _returnETH(\n        IVault vault,\n        address receiver,\n        uint256 minOutput\n    ) internal {\n        if (vault.asset() != STETH_ADDRESS) revert ETHAdapter__IncompatibleVault();\n        IERC20 asset = IERC20(vault.asset());\n\n        uint256 balance = asset.balanceOf(address(this));\n        asset.safeApprove(address(pool), balance);\n        pool.exchange(1, 0, balance, minOutput);\n\n        payable(receiver).sendValue(address(this).balance);\n    }\n}"
    }
  ]
}