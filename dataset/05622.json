{
  "Title": "[L-08] Closed markets can't be reopened",
  "Content": "\n[WildcatMarket Line 142](https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarket.sol#L142)\n\n### Issue Description\n\nMarkets include a functionality where users can close markets directly, effectively transferring all funds back into the market and setting the `isClosed` parameter of the state to true. While this prevents new lenders from depositing into the market, it only allows lenders to withdraw their funds and interest. The issue is that, once a borrower uses this function, the market cannot be reopened. If the borrower wants to have another market for the same asset, they must deploy a new market with a new prefix to avoid salt collisions. If a borrower does this often it might end up in the Market names looking like \"CodearenaV1234.56DAI\" due to new prefixes being needed each time. Additionally, the markets list would get more and more bloated. \n\n### Recommended Mitigation Steps\n\nTo mitigate this issue, borrowers should be allowed to reset a market. This would require all lenders to withdraw their funds before the reset, but it would reset all parameters, including the scale factor, allowing the market to be restarted.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/market/WildcatMarket.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../libraries/FeeMath.sol';\nimport './WildcatMarketBase.sol';\nimport './WildcatMarketConfig.sol';\nimport './WildcatMarketToken.sol';\nimport './WildcatMarketWithdrawals.sol';\n\ncontract WildcatMarket is\n  WildcatMarketBase,\n  WildcatMarketConfig,\n  WildcatMarketToken,\n  WildcatMarketWithdrawals\n{\n  using MathUtils for uint256;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for address;\n\n  /**\n   * @dev Apply pending interest, delinquency fees and protocol fees\n   *      to the state and process the pending withdrawal batch if\n   *      one exists and has expired, then update the market's\n   *      delinquency status.\n   */\n  function updateState() external nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    _writeState(state);\n  }\n\n  /**\n   * @dev Deposit up to `amount` underlying assets and mint market tokens\n   *      for `msg.sender`.\n   *\n   *      The actual deposit amount is limited by the market's maximum deposit\n   *      amount, which is the configured `maxTotalSupply` minus the current\n   *      total supply.\n   *\n   *      Reverts if the market is closed or if the scaled token amount\n   *      that would be minted for the deposit is zero.\n   */\n  function depositUpTo(\n    uint256 amount\n  ) public virtual nonReentrant returns (uint256 /* actualAmount */) {\n    // Get current state\n    MarketState memory state = _getUpdatedState();\n\n    if (state.isClosed) {\n      revert DepositToClosedMarket();\n    }\n\n    // Reduce amount if it would exceed totalSupply\n    amount = MathUtils.min(amount, state.maximumDeposit());\n\n    // Scale the mint amount\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n    if (scaledAmount == 0) revert NullMintAmount();\n\n    // Transfer deposit from caller\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n\n    // Cache account data and revert if not authorized to deposit.\n    Account memory account = _getAccountWithRole(msg.sender, AuthRole.DepositAndWithdraw);\n    account.scaledBalance += scaledAmount;\n    _accounts[msg.sender] = account;\n\n    emit Transfer(address(0), msg.sender, amount);\n    emit Deposit(msg.sender, amount, scaledAmount);\n\n    // Increase supply\n    state.scaledTotalSupply += scaledAmount;\n\n    // Update stored state\n    _writeState(state);\n\n    return amount;\n  }\n\n  /**\n   * @dev Deposit exactly `amount` underlying assets and mint market tokens\n   *      for `msg.sender`.\n   *\n   *     Reverts if the deposit amount would cause the market to exceed the\n   *     configured `maxTotalSupply`.\n   */\n  function deposit(uint256 amount) external virtual {\n    uint256 actualAmount = depositUpTo(amount);\n    if (amount != actualAmount) {\n      revert MaxSupplyExceeded();\n    }\n  }\n\n  /**\n   * @dev Withdraw available protocol fees to the fee recipient.\n   */\n  function collectFees() external nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    if (state.accruedProtocolFees == 0) {\n      revert NullFeeAmount();\n    }\n    uint128 withdrawableFees = state.withdrawableProtocolFees(totalAssets());\n    if (withdrawableFees == 0) {\n      revert InsufficientReservesForFeeWithdrawal();\n    }\n    state.accruedProtocolFees -= withdrawableFees;\n    _writeState(state);\n    asset.safeTransfer(feeRecipient, withdrawableFees);\n    emit FeesCollected(withdrawableFees);\n  }\n\n  /**\n   * @dev Withdraw funds from the market to the borrower.\n   *\n   *      Can only withdraw up to the assets that are not required\n   *      to meet the borrower's collateral obligations.\n   *\n   *      Reverts if the market is closed.\n   */\n  function borrow(uint256 amount) external onlyBorrower nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    if (state.isClosed) {\n      revert BorrowFromClosedMarket();\n    }\n    uint256 borrowable = state.borrowableAssets(totalAssets());\n    if (amount > borrowable) {\n      revert BorrowAmountTooHigh();\n    }\n    _writeState(state);\n    asset.safeTransfer(msg.sender, amount);\n    emit Borrow(amount);\n  }\n\n  /**\n   * @dev Sets the market APR to 0% and marks market as closed.\n   *\n   *      Can not be called if there are any unpaid withdrawal batches.\n   *\n   *      Transfers remaining debts from borrower if market is not fully\n   *      collateralized; otherwise, transfers any assets in excess of\n   *      debts to the borrower.\n   */\n  function closeMarket() external onlyController nonReentrant {\n    MarketState memory state = _getUpdatedState();\n    state.annualInterestBips = 0;\n    state.isClosed = true;\n    state.reserveRatioBips = 0;\n    if (_withdrawalData.unpaidBatches.length() > 0) {\n      revert CloseMarketWithUnpaidWithdrawals();\n    }\n    uint256 currentlyHeld = totalAssets();\n    uint256 totalDebts = state.totalDebts();\n    if (currentlyHeld < totalDebts) {\n      // Transfer remaining debts from borrower\n      asset.safeTransferFrom(borrower, address(this), totalDebts - currentlyHeld);\n    } else if (currentlyHeld > totalDebts) {\n      // Transfer excess assets to borrower\n      asset.safeTransfer(borrower, currentlyHeld - totalDebts);\n    }\n    _writeState(state);\n    emit MarketClosed(block.timestamp);\n  }\n}"
    }
  ]
}