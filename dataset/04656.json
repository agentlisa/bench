{
  "Title": "Timestamp usage",
  "Content": "There’s a problem with using timestamps and **now** (alias for **block.timestamp**) for contract logic, based on the fact that miners can perform some manipulation. In general,[it’s better not to rely on timestamps for contract logic](https://github.com/ConsenSys/smart-contract-best-practices#timestamp-dependence). The solutions is to use **block.number** instead, and approximate dates with expected block heights and time periods with expected block amounts.\n\n\nThe ROSCA.sol contract uses timestamps at [several](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L198) [points”>The risk of miner manipulation, though, is really low. The potential damage is also limited: miners could only slightly manipulate when each round starts and who the winner is in each round.](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L258%22). As [this comment notes](https://github.com/WeTrustPlatform/rosca-contracts/blob/2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol#L256%22), this won’t affect the functioning of the contract, but the miner of the **cleanUpPreviousRound** call transaction will have absolute control on who the next winner is. We recommend the team to consider the potential risk of this manipulation and switch to **block.number** if necessary.\n\n\nFor more info on this topic, see [this stack exchange question](https://ethereum.stackexchange.com/questions/413/can-a-contract-safely-rely-on-block-timestamp)\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/ROSCA.sol",
      "content": "pragma solidity ^0.4.4;\n\n/**\n * @title ROSCA on a blockchain.\n *\n * A ROSCA (Rotating and Savings Credit Association) is an agreement between\n * trusted friends to contribute funds on a periodic basis to a \"pot\", and in\n * each round one of the participants receives the pot (termed \"winner\").\n * The winner is selected as the person who makes the lowest bid in that round\n * among those who have not won a bid before.\n * The discount (gap between bid and total round contributions) is dispersed\n * evenly between the participants.\n */\ncontract ROSCA {\n\n  ////////////\n  // CONSTANTS\n  ////////////\n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  /////////\n  // EVENTS\n  /////////\n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  ////////////////////\n  // STORAGE VARIABLES\n  ////////////////////\n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  ////////////\n  // MODIFIERS\n  ////////////\n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  ////////////\n  // FUNCTIONS\n  ////////////\n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}"
    }
  ]
}