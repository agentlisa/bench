{
  "Title": "Fee Controller Can DOS Trading Activity",
  "Content": "\n\n\nThe protocol allows fees to be collected. To do so, a protocol fee controller needs to be [set](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/base/ProtocolFees.sol#L103-L110) to a non-zero address. Uniswap governance has the ability to collect up to 0.05% of the token amounts, as enforced by the [`ProtocolFees` contract](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/base/ProtocolFees.sol#L90-L92). The `FeeController` [is queried](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/base/ProtocolFees.sol#L44) by the `ProtocolFees` contract to get a list of fees that need to be taken, specifying the amounts, the token addresses, and the recipients. \n\n\nAny mistakes in that return value will cause the `_injectFees` function to revert if: \n\n\n       • The fee token [is not part of the original order](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/base/ProtocolFees.sol#L88)[.](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/base/ProtocolFees.sol#L88)   \n       • The fee is[too large](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/base/ProtocolFees.sol#L91).  \n       • There is a [duplicated entry](https://github.com/Uniswap/UniswapX/blob/7c5e359fc476f3e55497a8cd6f405f67af2c1dcf/src/base/ProtocolFees.sol#L66). \n\n\nSince the fees are fetched for every order from any reactor, an incorrect response will halt all trading activity. This can be the result of an attack or a bug in the fee controller. \n\n\nIf this is not intended behavior, consider not charging fees when one of the above cases occurs in order to not affect trading activity. Instead of reverting, an event can be emitted and be caught by a monitoring solution. \n\n\n\n\n\n***Update:** Acknowledged, not resolved. The Uniswap team stated:*\n\n\n\n> *This is a known issue, and we acknowledge it for now. We can always redeploy a reactor in such circumstances, which would only cause a minor inconvenience. We will likely decide on a fix before the next version is deployed.*\n\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/base/ProtocolFees.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {Owned} from \"solmate/src/auth/Owned.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {IProtocolFeeController} from \"../interfaces/IProtocolFeeController.sol\";\nimport {CurrencyLibrary} from \"../lib/CurrencyLibrary.sol\";\nimport {ResolvedOrder, OutputToken} from \"../base/ReactorStructs.sol\";\n\n/// @notice Handling for protocol fees\nabstract contract ProtocolFees is Owned {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n    using CurrencyLibrary for address;\n\n    /// @notice thrown if two fee outputs have the same token\n    error DuplicateFeeOutput(address duplicateToken);\n    /// @notice thrown if a given fee output is greater than MAX_FEE_BPS of the order outputs\n    error FeeTooLarge(address token, uint256 amount, address recipient);\n    /// @notice thrown if a fee output token does not have a corresponding non-fee output\n    error InvalidFeeToken(address feeToken);\n\n    event ProtocolFeeControllerSet(address oldFeeController, address newFeeController);\n\n    uint256 private constant BPS = 10_000;\n    uint256 private constant MAX_FEE_BPS = 5;\n\n    /// @dev The address of the fee controller\n    IProtocolFeeController public feeController;\n\n    // @notice Required to customize owner from constructor of BaseReactor.sol\n    constructor(address _owner) Owned(_owner) {}\n\n    /// @notice Injects fees into an order\n    /// @dev modifies the orders to include protocol fee outputs\n    /// @param order The encoded order to inject fees into\n    function _injectFees(ResolvedOrder memory order) internal view {\n        if (address(feeController) == address(0)) {\n            return;\n        }\n\n        OutputToken[] memory feeOutputs = feeController.getFeeOutputs(order);\n        uint256 outputsLength = order.outputs.length;\n        uint256 feeOutputsLength = feeOutputs.length;\n\n        // apply fee outputs\n        // fill new outputs with old outputs\n        OutputToken[] memory newOutputs = new OutputToken[](\n            outputsLength + feeOutputsLength\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < outputsLength; i++) {\n                newOutputs[i] = order.outputs[i];\n            }\n        }\n\n        for (uint256 i = 0; i < feeOutputsLength;) {\n            OutputToken memory feeOutput = feeOutputs[i];\n            // assert no duplicates\n            unchecked {\n                for (uint256 j = 0; j < i; j++) {\n                    if (feeOutput.token == feeOutputs[j].token) {\n                        revert DuplicateFeeOutput(feeOutput.token);\n                    }\n                }\n            }\n\n            // assert not greater than MAX_FEE_BPS\n            uint256 tokenValue;\n            for (uint256 j = 0; j < outputsLength;) {\n                OutputToken memory output = order.outputs[j];\n                if (output.token == feeOutput.token) {\n                    tokenValue += output.amount;\n                }\n                unchecked {\n                    j++;\n                }\n            }\n\n            // allow fee on input token as well\n            if (address(order.input.token) == feeOutput.token) {\n                tokenValue += order.input.amount;\n            }\n\n            if (tokenValue == 0) revert InvalidFeeToken(feeOutput.token);\n\n            if (feeOutput.amount > tokenValue.mulDivDown(MAX_FEE_BPS, BPS)) {\n                revert FeeTooLarge(feeOutput.token, feeOutput.amount, feeOutput.recipient);\n            }\n            newOutputs[outputsLength + i] = feeOutput;\n\n            unchecked {\n                i++;\n            }\n        }\n\n        order.outputs = newOutputs;\n    }\n\n    /// @notice sets the protocol fee controller\n    /// @dev only callable by the owner\n    /// @param _newFeeController the new fee controller\n    function setProtocolFeeController(address _newFeeController) external onlyOwner {\n        address oldFeeController = address(feeController);\n        feeController = IProtocolFeeController(_newFeeController);\n        emit ProtocolFeeControllerSet(oldFeeController, _newFeeController);\n    }\n}"
    },
    {
      "filename": "src/base/ProtocolFees.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {Owned} from \"solmate/src/auth/Owned.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {IProtocolFeeController} from \"../interfaces/IProtocolFeeController.sol\";\nimport {CurrencyLibrary} from \"../lib/CurrencyLibrary.sol\";\nimport {ResolvedOrder, OutputToken} from \"../base/ReactorStructs.sol\";\n\n/// @notice Handling for protocol fees\nabstract contract ProtocolFees is Owned {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n    using CurrencyLibrary for address;\n\n    /// @notice thrown if two fee outputs have the same token\n    error DuplicateFeeOutput(address duplicateToken);\n    /// @notice thrown if a given fee output is greater than MAX_FEE_BPS of the order outputs\n    error FeeTooLarge(address token, uint256 amount, address recipient);\n    /// @notice thrown if a fee output token does not have a corresponding non-fee output\n    error InvalidFeeToken(address feeToken);\n\n    event ProtocolFeeControllerSet(address oldFeeController, address newFeeController);\n\n    uint256 private constant BPS = 10_000;\n    uint256 private constant MAX_FEE_BPS = 5;\n\n    /// @dev The address of the fee controller\n    IProtocolFeeController public feeController;\n\n    // @notice Required to customize owner from constructor of BaseReactor.sol\n    constructor(address _owner) Owned(_owner) {}\n\n    /// @notice Injects fees into an order\n    /// @dev modifies the orders to include protocol fee outputs\n    /// @param order The encoded order to inject fees into\n    function _injectFees(ResolvedOrder memory order) internal view {\n        if (address(feeController) == address(0)) {\n            return;\n        }\n\n        OutputToken[] memory feeOutputs = feeController.getFeeOutputs(order);\n        uint256 outputsLength = order.outputs.length;\n        uint256 feeOutputsLength = feeOutputs.length;\n\n        // apply fee outputs\n        // fill new outputs with old outputs\n        OutputToken[] memory newOutputs = new OutputToken[](\n            outputsLength + feeOutputsLength\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < outputsLength; i++) {\n                newOutputs[i] = order.outputs[i];\n            }\n        }\n\n        for (uint256 i = 0; i < feeOutputsLength;) {\n            OutputToken memory feeOutput = feeOutputs[i];\n            // assert no duplicates\n            unchecked {\n                for (uint256 j = 0; j < i; j++) {\n                    if (feeOutput.token == feeOutputs[j].token) {\n                        revert DuplicateFeeOutput(feeOutput.token);\n                    }\n                }\n            }\n\n            // assert not greater than MAX_FEE_BPS\n            uint256 tokenValue;\n            for (uint256 j = 0; j < outputsLength;) {\n                OutputToken memory output = order.outputs[j];\n                if (output.token == feeOutput.token) {\n                    tokenValue += output.amount;\n                }\n                unchecked {\n                    j++;\n                }\n            }\n\n            // allow fee on input token as well\n            if (address(order.input.token) == feeOutput.token) {\n                tokenValue += order.input.amount;\n            }\n\n            if (tokenValue == 0) revert InvalidFeeToken(feeOutput.token);\n\n            if (feeOutput.amount > tokenValue.mulDivDown(MAX_FEE_BPS, BPS)) {\n                revert FeeTooLarge(feeOutput.token, feeOutput.amount, feeOutput.recipient);\n            }\n            newOutputs[outputsLength + i] = feeOutput;\n\n            unchecked {\n                i++;\n            }\n        }\n\n        order.outputs = newOutputs;\n    }\n\n    /// @notice sets the protocol fee controller\n    /// @dev only callable by the owner\n    /// @param _newFeeController the new fee controller\n    function setProtocolFeeController(address _newFeeController) external onlyOwner {\n        address oldFeeController = address(feeController);\n        feeController = IProtocolFeeController(_newFeeController);\n        emit ProtocolFeeControllerSet(oldFeeController, _newFeeController);\n    }\n}"
    },
    {
      "filename": "src/base/ProtocolFees.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {Owned} from \"solmate/src/auth/Owned.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {IProtocolFeeController} from \"../interfaces/IProtocolFeeController.sol\";\nimport {CurrencyLibrary} from \"../lib/CurrencyLibrary.sol\";\nimport {ResolvedOrder, OutputToken} from \"../base/ReactorStructs.sol\";\n\n/// @notice Handling for protocol fees\nabstract contract ProtocolFees is Owned {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n    using CurrencyLibrary for address;\n\n    /// @notice thrown if two fee outputs have the same token\n    error DuplicateFeeOutput(address duplicateToken);\n    /// @notice thrown if a given fee output is greater than MAX_FEE_BPS of the order outputs\n    error FeeTooLarge(address token, uint256 amount, address recipient);\n    /// @notice thrown if a fee output token does not have a corresponding non-fee output\n    error InvalidFeeToken(address feeToken);\n\n    event ProtocolFeeControllerSet(address oldFeeController, address newFeeController);\n\n    uint256 private constant BPS = 10_000;\n    uint256 private constant MAX_FEE_BPS = 5;\n\n    /// @dev The address of the fee controller\n    IProtocolFeeController public feeController;\n\n    // @notice Required to customize owner from constructor of BaseReactor.sol\n    constructor(address _owner) Owned(_owner) {}\n\n    /// @notice Injects fees into an order\n    /// @dev modifies the orders to include protocol fee outputs\n    /// @param order The encoded order to inject fees into\n    function _injectFees(ResolvedOrder memory order) internal view {\n        if (address(feeController) == address(0)) {\n            return;\n        }\n\n        OutputToken[] memory feeOutputs = feeController.getFeeOutputs(order);\n        uint256 outputsLength = order.outputs.length;\n        uint256 feeOutputsLength = feeOutputs.length;\n\n        // apply fee outputs\n        // fill new outputs with old outputs\n        OutputToken[] memory newOutputs = new OutputToken[](\n            outputsLength + feeOutputsLength\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < outputsLength; i++) {\n                newOutputs[i] = order.outputs[i];\n            }\n        }\n\n        for (uint256 i = 0; i < feeOutputsLength;) {\n            OutputToken memory feeOutput = feeOutputs[i];\n            // assert no duplicates\n            unchecked {\n                for (uint256 j = 0; j < i; j++) {\n                    if (feeOutput.token == feeOutputs[j].token) {\n                        revert DuplicateFeeOutput(feeOutput.token);\n                    }\n                }\n            }\n\n            // assert not greater than MAX_FEE_BPS\n            uint256 tokenValue;\n            for (uint256 j = 0; j < outputsLength;) {\n                OutputToken memory output = order.outputs[j];\n                if (output.token == feeOutput.token) {\n                    tokenValue += output.amount;\n                }\n                unchecked {\n                    j++;\n                }\n            }\n\n            // allow fee on input token as well\n            if (address(order.input.token) == feeOutput.token) {\n                tokenValue += order.input.amount;\n            }\n\n            if (tokenValue == 0) revert InvalidFeeToken(feeOutput.token);\n\n            if (feeOutput.amount > tokenValue.mulDivDown(MAX_FEE_BPS, BPS)) {\n                revert FeeTooLarge(feeOutput.token, feeOutput.amount, feeOutput.recipient);\n            }\n            newOutputs[outputsLength + i] = feeOutput;\n\n            unchecked {\n                i++;\n            }\n        }\n\n        order.outputs = newOutputs;\n    }\n\n    /// @notice sets the protocol fee controller\n    /// @dev only callable by the owner\n    /// @param _newFeeController the new fee controller\n    function setProtocolFeeController(address _newFeeController) external onlyOwner {\n        address oldFeeController = address(feeController);\n        feeController = IProtocolFeeController(_newFeeController);\n        emit ProtocolFeeControllerSet(oldFeeController, _newFeeController);\n    }\n}"
    },
    {
      "filename": "src/base/ProtocolFees.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {Owned} from \"solmate/src/auth/Owned.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {IProtocolFeeController} from \"../interfaces/IProtocolFeeController.sol\";\nimport {CurrencyLibrary} from \"../lib/CurrencyLibrary.sol\";\nimport {ResolvedOrder, OutputToken} from \"../base/ReactorStructs.sol\";\n\n/// @notice Handling for protocol fees\nabstract contract ProtocolFees is Owned {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n    using CurrencyLibrary for address;\n\n    /// @notice thrown if two fee outputs have the same token\n    error DuplicateFeeOutput(address duplicateToken);\n    /// @notice thrown if a given fee output is greater than MAX_FEE_BPS of the order outputs\n    error FeeTooLarge(address token, uint256 amount, address recipient);\n    /// @notice thrown if a fee output token does not have a corresponding non-fee output\n    error InvalidFeeToken(address feeToken);\n\n    event ProtocolFeeControllerSet(address oldFeeController, address newFeeController);\n\n    uint256 private constant BPS = 10_000;\n    uint256 private constant MAX_FEE_BPS = 5;\n\n    /// @dev The address of the fee controller\n    IProtocolFeeController public feeController;\n\n    // @notice Required to customize owner from constructor of BaseReactor.sol\n    constructor(address _owner) Owned(_owner) {}\n\n    /// @notice Injects fees into an order\n    /// @dev modifies the orders to include protocol fee outputs\n    /// @param order The encoded order to inject fees into\n    function _injectFees(ResolvedOrder memory order) internal view {\n        if (address(feeController) == address(0)) {\n            return;\n        }\n\n        OutputToken[] memory feeOutputs = feeController.getFeeOutputs(order);\n        uint256 outputsLength = order.outputs.length;\n        uint256 feeOutputsLength = feeOutputs.length;\n\n        // apply fee outputs\n        // fill new outputs with old outputs\n        OutputToken[] memory newOutputs = new OutputToken[](\n            outputsLength + feeOutputsLength\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < outputsLength; i++) {\n                newOutputs[i] = order.outputs[i];\n            }\n        }\n\n        for (uint256 i = 0; i < feeOutputsLength;) {\n            OutputToken memory feeOutput = feeOutputs[i];\n            // assert no duplicates\n            unchecked {\n                for (uint256 j = 0; j < i; j++) {\n                    if (feeOutput.token == feeOutputs[j].token) {\n                        revert DuplicateFeeOutput(feeOutput.token);\n                    }\n                }\n            }\n\n            // assert not greater than MAX_FEE_BPS\n            uint256 tokenValue;\n            for (uint256 j = 0; j < outputsLength;) {\n                OutputToken memory output = order.outputs[j];\n                if (output.token == feeOutput.token) {\n                    tokenValue += output.amount;\n                }\n                unchecked {\n                    j++;\n                }\n            }\n\n            // allow fee on input token as well\n            if (address(order.input.token) == feeOutput.token) {\n                tokenValue += order.input.amount;\n            }\n\n            if (tokenValue == 0) revert InvalidFeeToken(feeOutput.token);\n\n            if (feeOutput.amount > tokenValue.mulDivDown(MAX_FEE_BPS, BPS)) {\n                revert FeeTooLarge(feeOutput.token, feeOutput.amount, feeOutput.recipient);\n            }\n            newOutputs[outputsLength + i] = feeOutput;\n\n            unchecked {\n                i++;\n            }\n        }\n\n        order.outputs = newOutputs;\n    }\n\n    /// @notice sets the protocol fee controller\n    /// @dev only callable by the owner\n    /// @param _newFeeController the new fee controller\n    function setProtocolFeeController(address _newFeeController) external onlyOwner {\n        address oldFeeController = address(feeController);\n        feeController = IProtocolFeeController(_newFeeController);\n        emit ProtocolFeeControllerSet(oldFeeController, _newFeeController);\n    }\n}"
    }
  ]
}