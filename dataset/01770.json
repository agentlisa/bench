{
  "Title": "3S-LENFT-L02 Throughout codebase: cache variables to save on gas",
  "Content": "#### Description\nThroughout the codebase, several times storage variables are loaded and used in the same scope which incurs in significant gas costs since a SLOAD operation is much more expensive than a MSTORE and then consequent MLOAD operations. Below is a list of several times where this occurs:\n\n**TradingPool**\n- `_addressProvider.getFeeDistributor()`  is called twice in  [buy](https://github.com/leNFT/contracts/blob/2628b49bf5e334e8f8cb0fa2fef7d516bd78bbfe/contracts/protocol/Trading/TradingPool.sol#L384-L390) and [sell](https://github.com/leNFT/contracts/blob/2628b49bf5e334e8f8cb0fa2fef7d516bd78bbfe/contracts/protocol/Trading/TradingPool.sol#L493-L499) function.\n- `_addressProvider` is loaded several times in  [buy](https://github.com/leNFT/contracts/blob/2628b49bf5e334e8f8cb0fa2fef7d516bd78bbfe/contracts/protocol/Trading/TradingPool.sol#L384-L390) and [sell](https://github.com/leNFT/contracts/blob/2628b49bf5e334e8f8cb0fa2fef7d516bd78bbfe/contracts/protocol/Trading/TradingPool.sol#L493-L499) function.\n\n**VotingEscrow**\n- [writeTotalWeightHistory](https://github.com/leNFT/contracts/blob/bb8708ab9ab319f64ef3a45aa549d95755e2afaf/contracts/protocol/VotingEscrow.sol#L196-L200), a lot of storage reads are made in this function, save the most used ones in memory\n- getEpoch(): cache variable `_deployTimestamp` to prevent one storage read\n- cache _addressProvider.getNativeToken() (lines 220 and 225)\n\n\n**Bribes**:\n- claim(): cache `IVotingEscrow(votingEscrow).getEpoch(lockLastPoint.timestamp)` to prevent an external call\n- withdrawBribe(): cache `_userBribes[token][gauge][nextEpoch][msg.sender]`\n\n**LoanCenter**\n-  liquidateLoan() cache _loans[loanId].owner\n\n**Router**\n- cache _addressProvider.getTradingPoolFactory()\n\n**Fee Distribuitor**\n- cache _epochFees[token][epoch] in salvageFees()\n- cache votingEscrow.getEpoch(block.timestamp) (line 146)\n- cache IERC721Upgradeable(address(votingEscrow)).ownerOf(tokenId) in claim()\n\n**Genesis NFT:**\n-  cache _addressProvider.getWETH() (lines 367 and 374 and 394)\n- cache _addressProvider.getVotingEscrow() (lines 433 and 437)\n- cache _tokenIdCounter.current()\n- cache _addressProvider.getNativeToken() and _addressProvider.getWETH() (line 654 and 655)\n\n\n**GaugeController**\n- cache getTotalWeightAt(epoch) function getGaugeRewards()\n\n\n**Lending Gauge**\n- cache votingEscrow.getEpoch(block.timestamp) (line 101)\n\n\n**TradingGauge**\n- cache _lpValue[lpId] (lines 348 and 349)\n\n\n**LendingMarket**\n-  [createLendingPool()](https://github.com/leNFT/contracts/blob/9b1ae95f97ec5d2423c022179642714cee470a68/contracts/protocol/Lending/LendingMarket.sol#L209-L212) -> `_addressProvider` is loaded from storage several times. `_poolCount` is also loaded a couple times\n\n**WETHGateway**\n- throughout contract: _weth variable should be cached in memory in each function (and others storage variables if possible), since it is used more than 2 times most times.\n\n\n#### Recommendation\nWe understand that sometimes saving variables from storage to memory is not possible due to the possibility of the \"Stack too deep\" error; nevertheless, this pattern should still be followed whenever possible. Below is an example implementation in TradingPool, where fee distributor is loaded twice from storage in the same function both in the  [buy function](https://github.com/leNFT/contracts/blob/2628b49bf5e334e8f8cb0fa2fef7d516bd78bbfe/contracts/protocol/Trading/TradingPool.sol#L384-L390) and in the [sell function](https://github.com/leNFT/contracts/blob/2628b49bf5e334e8f8cb0fa2fef7d516bd78bbfe/contracts/protocol/Trading/TradingPool.sol#L493-L499).\n\n```solidity\naddress feeDistributor_ = _addressProvider.getFeeDistributor();\nIERC20(_token).safeTransfer(feeDistributor_ , PercentageMath.percentMul(totalFee, protocolFeePercentage));\nIFeeDistributor(feeDistributor_ ).checkpoint(_token);\n```",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/protocol/Trading/TradingPool.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {ITradingPool} from \"../../interfaces/ITradingPool.sol\";\nimport {IAddressProvider} from \"../../interfaces/IAddressProvider.sol\";\nimport {IPricingCurve} from \"../../interfaces/IPricingCurve.sol\";\nimport {IFeeDistributor} from \"../../interfaces/IFeeDistributor.sol\";\nimport {ITradingPoolFactory} from \"../../interfaces/ITradingPoolFactory.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {DataTypes} from \"../../libraries/types/DataTypes.sol\";\nimport {PercentageMath} from \"../../libraries/utils/PercentageMath.sol\";\nimport {ILiquidityPairMetadata} from \"../../interfaces/ILiquidityPairMetadata.sol\";\nimport {ITradingPool} from \"../../interfaces/ITradingPool.sol\";\n\n/// @title Trading Pool Contract\n/// @author leNFT\n/// @notice A contract that enables the creation of liquidity pools and the trading of NFTs and ERC20 tokens.\n/// @dev This contract manages liquidity pairs, each consisting of a set of NFTs and an ERC20 token, as well as the trading of these pairs.\ncontract TradingPool is\n    ERC165,\n    ERC721Enumerable,\n    ERC721Holder,\n    ITradingPool,\n    Ownable,\n    ReentrancyGuard\n{\n    uint public constant MAX_FEE = 8000; // 80%\n\n    IAddressProvider private immutable _addressProvider;\n    bool private _paused;\n    address private immutable _token;\n    address private immutable _nft;\n    mapping(uint256 => DataTypes.LiquidityPair) private _liquidityPairs;\n    mapping(uint256 => DataTypes.NftToLp) private _nftToLp;\n    uint256 private _lpCount;\n\n    using SafeERC20 for IERC20;\n\n    modifier poolNotPaused() {\n        _requirePoolNotPaused();\n        _;\n    }\n\n    modifier lpExists(uint256 lpId) {\n        _requireLpExists(lpId);\n        _;\n    }\n\n    /// @notice Trading Pool constructor.\n    /// @dev The constructor should only be called by the Trading Pool Factory contract.\n    /// @param addressProvider The address provider contract.\n    /// @param owner The owner of the Trading Pool contract.\n    /// @param token The ERC20 token used in the trading pool.\n    /// @param nft The address of the ERC721 contract.\n    /// @param name The name of the ERC721 token.\n    /// @param symbol The symbol of the ERC721 token.\n    constructor(\n        IAddressProvider addressProvider,\n        address owner,\n        address token,\n        address nft,\n        string memory name,\n        string memory symbol\n    ) ERC721(name, symbol) {\n        require(\n            msg.sender == addressProvider.getTradingPoolFactory(),\n            \"TP:C:MUST_BE_FACTORY\"\n        );\n        _addressProvider = addressProvider;\n        _token = token;\n        _nft = nft;\n        _transferOwnership(owner);\n    }\n\n    /// @notice Returns the token URI for a specific liquidity pair\n    /// @param tokenId The ID of the liquidity pair.\n    /// @return The token URI.\n    function tokenURI(\n        uint256 tokenId\n    ) public view override lpExists(tokenId) returns (string memory) {\n        return\n            ILiquidityPairMetadata(_addressProvider.getLiquidityPairMetadata())\n                .tokenURI(address(this), tokenId);\n    }\n\n    /// @notice Gets the address of the ERC721 traded in the pool.\n    /// @return The address of the ERC721 token.\n    function getNFT() external view override returns (address) {\n        return _nft;\n    }\n\n    /// @notice Gets the address of the ERC20 token traded in the pool.\n    /// @return The address of the ERC20 token.\n    function getToken() external view override returns (address) {\n        return _token;\n    }\n\n    /// @notice Gets the liquidity pair with the specified ID.\n    /// @param lpId The ID of the liquidity pair.\n    /// @return The liquidity pair.\n    function getLP(\n        uint256 lpId\n    )\n        external\n        view\n        override\n        lpExists(lpId)\n        returns (DataTypes.LiquidityPair memory)\n    {\n        return _liquidityPairs[lpId];\n    }\n\n    /// @notice Gets the number of liquidity pairs ever created in the trading pool.\n    /// @return The number of liquidity pairs.\n    function getLpCount() external view override returns (uint256) {\n        return _lpCount;\n    }\n\n    /// @notice Gets the ID of the liquidity pair associated with the specified NFT.\n    /// @param nftId The ID of the NFT.\n    /// @return The ID of the liquidity pair.\n    function nftToLp(uint256 nftId) external view override returns (uint256) {\n        require(\n            IERC721(_nft).ownerOf(nftId) == address(this),\n            \"TP:NTL:NOT_OWNED\"\n        );\n        return _nftToLp[nftId].liquidityPair;\n    }\n\n    /// @notice Adds liquidity to the trading pool.\n    /// @dev At least one of nftIds or tokenAmount must be greater than zero.\n    /// @dev The caller must approve the Trading Pool contract to transfer the NFTs and ERC20 tokens.\n    /// @param receiver The recipient of the liquidity pool tokens.\n    /// @param nftIds The IDs of the NFTs being deposited.\n    /// @param tokenAmount The amount of the ERC20 token being deposited.\n    /// @param spotPrice The spot price of the liquidity pair being created.\n    /// @param curve The pricing curve for the liquidity pair being created.\n    /// @param delta The delta for the liquidity pair being created.\n    /// @param fee The fee for the liquidity pair being created.\n    function addLiquidity(\n        address receiver,\n        DataTypes.LPType lpType,\n        uint256[] calldata nftIds,\n        uint256 tokenAmount,\n        uint256 spotPrice,\n        address curve,\n        uint256 delta,\n        uint256 fee\n    ) external override nonReentrant poolNotPaused {\n        ITradingPoolFactory tradingPoolFactory = ITradingPoolFactory(\n            _addressProvider.getTradingPoolFactory()\n        );\n\n        // Check if pool will exceed maximum permitted amount\n        require(\n            tokenAmount + IERC20(_token).balanceOf(address(this)) <\n                tradingPoolFactory.getTVLSafeguard(),\n            \"TP:AL:SAFEGUARD_EXCEEDED\"\n        );\n\n        // Different types of liquidity pairs have different requirements\n        // Trade: Can contain NFTs and/or tokens\n        // TradeUp: Can contain NFTs and/or tokens, delta must be > 0\n        // TradeDown: Can contain NFTs and/or tokens, delta must be > 0\n        // Buy: Can only contain tokens\n        // Sell: Can only contain NFTs\n        if (\n            lpType == DataTypes.LPType.Trade ||\n            lpType == DataTypes.LPType.TradeUp ||\n            lpType == DataTypes.LPType.TradeDown\n        ) {\n            require(\n                tokenAmount > 0 || nftIds.length > 0,\n                \"TP:AL:DEPOSIT_REQUIRED\"\n            );\n        } else if (lpType == DataTypes.LPType.Buy) {\n            require(tokenAmount > 0 && nftIds.length == 0, \"TP:AL:TOKENS_ONLY\");\n        } else if (lpType == DataTypes.LPType.Sell) {\n            require(nftIds.length > 0 && tokenAmount == 0, \"TP:AL:NFTS_ONLY\");\n        }\n\n        // Directional LPs must have a positive delta in order for the price to move or else\n        // they degenerate into a Trade LPs with delta = 0\n        if (\n            lpType == DataTypes.LPType.TradeUp ||\n            lpType == DataTypes.LPType.TradeDown\n        ) {\n            require(delta > 0, \"TP:AL:DELTA_0\");\n        }\n\n        if (lpType == DataTypes.LPType.Buy || lpType == DataTypes.LPType.Sell) {\n            // Validate fee\n            require(fee == 0, \"TP:AL:INVALID_LIMIT_FEE\");\n        } else {\n            // require that the fee is higher than 0 and less than the maximum fee\n            require(fee > 0 && fee <= MAX_FEE, \"TP:AL:INVALID_FEE\");\n        }\n\n        // Require that the curve conforms to the curve interface\n        require(tradingPoolFactory.isPriceCurve(curve), \"TP:AL:INVALID_CURVE\");\n\n        // Validate LP params for chosen curve\n        IPricingCurve(curve).validateLpParameters(spotPrice, delta, fee);\n\n        // Add user nfts to the pool\n        for (uint i = 0; i < nftIds.length; i++) {\n            IERC721(_nft).safeTransferFrom(\n                msg.sender,\n                address(this),\n                nftIds[i]\n            );\n            _nftToLp[nftIds[i]] = DataTypes.NftToLp({\n                liquidityPair: _lpCount,\n                index: i\n            });\n        }\n\n        // Send user token to the pool\n        if (tokenAmount > 0) {\n            IERC20(_token).safeTransferFrom(\n                msg.sender,\n                address(this),\n                tokenAmount\n            );\n        }\n\n        // Save the user deposit info\n        _liquidityPairs[_lpCount] = DataTypes.LiquidityPair({\n            lpType: lpType,\n            nftIds: nftIds,\n            tokenAmount: tokenAmount,\n            spotPrice: spotPrice,\n            curve: curve,\n            delta: delta,\n            fee: fee\n        });\n\n        // Mint liquidity position NFT\n        ERC721._safeMint(receiver, _lpCount);\n\n        emit AddLiquidity(\n            receiver,\n            _lpCount,\n            lpType,\n            nftIds,\n            tokenAmount,\n            spotPrice,\n            curve,\n            delta,\n            fee\n        );\n\n        _lpCount++;\n    }\n\n    /// @notice Removes liquidity, sending back deposited tokens and transferring the NFTs to the user\n    /// @param lpId The ID of the LP token to remove\n    function removeLiquidity(uint256 lpId) public override nonReentrant {\n        //Require the caller owns LP\n        require(msg.sender == ERC721.ownerOf(lpId), \"TP:RL:NOT_OWNER\");\n\n        // Send pool nfts to the user\n        uint256 nftIdsLength = _liquidityPairs[lpId].nftIds.length;\n        for (uint i = 0; i < nftIdsLength; i++) {\n            IERC721(_nft).safeTransferFrom(\n                address(this),\n                msg.sender,\n                _liquidityPairs[lpId].nftIds[i]\n            );\n            delete _nftToLp[_liquidityPairs[lpId].nftIds[i]];\n        }\n\n        // Send pool token back to user\n        IERC20(_token).safeTransfer(\n            msg.sender,\n            _liquidityPairs[lpId].tokenAmount\n        );\n\n        // delete the user deposit info\n        delete _liquidityPairs[lpId];\n\n        // Burn liquidity position NFT\n        ERC721._burn(lpId);\n\n        emit RemoveLiquidity(msg.sender, lpId);\n    }\n\n    /// @notice Removes liquidity in batches by calling the removeLiquidity function for each LP token ID in the lpIds array\n    /// @param lpIds The IDs of the LP tokens to remove liquidity from\n    function removeLiquidityBatch(uint256[] calldata lpIds) external override {\n        for (uint i = 0; i < lpIds.length; i++) {\n            removeLiquidity(lpIds[i]);\n        }\n    }\n\n    /// @notice Buys NFTs in exchange for pool tokens\n    /// @param onBehalfOf The address to deposit the NFTs to\n    /// @param nftIds The IDs of the NFTs to buy\n    /// @param maximumPrice The maximum price the user is willing to pay for the NFTs\n    /// @return finalPrice The final price paid for the NFTs\n    function buy(\n        address onBehalfOf,\n        uint256[] calldata nftIds,\n        uint256 maximumPrice\n    )\n        external\n        override\n        nonReentrant\n        poolNotPaused\n        returns (uint256 finalPrice)\n    {\n        require(nftIds.length > 0, \"TP:B:NFTS_0\");\n\n        uint256 lpIndex;\n        uint256 fee;\n        uint256 totalFee;\n        uint256 protocolFee;\n        DataTypes.LiquidityPair memory lp;\n        uint256 protocolFeePercentage = ITradingPoolFactory(\n            _addressProvider.getTradingPoolFactory()\n        ).getProtocolFeePercentage();\n        for (uint i = 0; i < nftIds.length; i++) {\n            // Check if the pool contract owns the NFT\n            require(\n                IERC721(_nft).ownerOf(nftIds[i]) == address(this),\n                \"TP:B:NOT_OWNER\"\n            );\n            lpIndex = _nftToLp[nftIds[i]].liquidityPair;\n            lp = _liquidityPairs[lpIndex];\n\n            // Can't buy from buy LP\n            require(lp.lpType != DataTypes.LPType.Buy, \"TP:B:IS_BUY_LP\");\n\n            fee = PercentageMath.percentMul(lp.spotPrice, lp.fee);\n            protocolFee = PercentageMath.percentMul(fee, protocolFeePercentage);\n\n            // Remove nft from liquidity pair nft list\n            _liquidityPairs[lpIndex].nftIds[_nftToLp[nftIds[i]].index] = lp\n                .nftIds[lp.nftIds.length - 1];\n\n            // Update NFT to lp tracker\n            _nftToLp[lp.nftIds[lp.nftIds.length - 1]].index = _nftToLp[\n                nftIds[i]\n            ].index;\n            delete _nftToLp[nftIds[i]];\n            _liquidityPairs[lpIndex].nftIds.pop();\n\n            _liquidityPairs[lpIndex].tokenAmount += (lp.spotPrice +\n                fee -\n                protocolFee);\n\n            // Increase total price and fee sum\n            finalPrice += (lp.spotPrice + fee);\n            totalFee += fee;\n\n            // Update liquidity pair price\n            if (lp.lpType != DataTypes.LPType.TradeDown) {\n                _liquidityPairs[lpIndex].spotPrice = IPricingCurve(lp.curve)\n                    .priceAfterBuy(lp.spotPrice, lp.delta, lp.fee);\n            }\n\n            // Send NFT to user\n            IERC721(_nft).safeTransferFrom(\n                address(this),\n                onBehalfOf,\n                nftIds[i]\n            );\n        }\n\n        require(finalPrice <= maximumPrice, \"TP:B:MAX_PRICE_EXCEEDED\");\n\n        // Get tokens from user\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), finalPrice);\n\n        // Send protocol fee to protocol fee distributor\n        IERC20(_token).safeTransfer(\n            _addressProvider.getFeeDistributor(),\n            PercentageMath.percentMul(totalFee, protocolFeePercentage)\n        );\n        IFeeDistributor(_addressProvider.getFeeDistributor()).checkpoint(\n            _token\n        );\n\n        emit Buy(onBehalfOf, nftIds, finalPrice);\n    }\n\n    /// @notice Allows an address to sell one or more NFTs in exchange for a token amount.\n    /// @param onBehalfOf The address that owns the NFT(s) and will receive the token amount.\n    /// @param nftIds An array of the IDs of the NFTs to sell.\n    /// @param liquidityPairs An array of the IDs of the liquidity pairs to use for the sale.\n    /// @param minimumPrice The minimum acceptable price in tokens for the sale.\n    /// @return finalPrice The final price in tokens received from the sale.\n    function sell(\n        address onBehalfOf,\n        uint256[] calldata nftIds,\n        uint256[] calldata liquidityPairs,\n        uint256 minimumPrice\n    )\n        external\n        override\n        nonReentrant\n        poolNotPaused\n        returns (uint256 finalPrice)\n    {\n        require(nftIds.length == liquidityPairs.length, \"TP:S:NFT_LP_MISMATCH\");\n        require(nftIds.length > 0, \"TP:S:NFTS_0\");\n\n        // Only the swap router can call this function on behalf of another address\n        if (onBehalfOf != msg.sender) {\n            require(\n                msg.sender == _addressProvider.getSwapRouter(),\n                \"TP:S:NOT_SWAP_ROUTER\"\n            );\n        }\n\n        uint256 totalFee;\n        uint256 fee; // We dont declare the protocol fee here to avoid stack too deep errors\n        DataTypes.LiquidityPair memory lp;\n        uint256 lpIndex;\n        uint256 protocolFeePercentage = ITradingPoolFactory(\n            _addressProvider.getTradingPoolFactory()\n        ).getProtocolFeePercentage();\n        // Transfer the NFTs to the pool\n        for (uint i = 0; i < nftIds.length; i++) {\n            // Check if the LP exists\n            lpIndex = liquidityPairs[i];\n            require(_exists(lpIndex), \"TP:S:LP_NOT_FOUND\");\n\n            // Get the LP details\n            lp = _liquidityPairs[lpIndex];\n\n            // Send NFT to the pool\n            IERC721(_nft).safeTransferFrom(\n                onBehalfOf,\n                address(this),\n                nftIds[i]\n            );\n\n            // Can't sell to sell LP\n            require(lp.lpType != DataTypes.LPType.Sell, \"TP:S:IS_SELL_LP\");\n\n            // Calculate the fee and protocol fee for the sale\n            fee = PercentageMath.percentMul(lp.spotPrice, lp.fee);\n\n            require(\n                lp.tokenAmount >=\n                    lp.spotPrice -\n                        fee +\n                        PercentageMath.percentMul(fee, protocolFeePercentage),\n                \"TP:S:INSUFFICIENT_TOKENS_IN_LP\"\n            );\n\n            // Add nft to liquidity pair nft list\n            _liquidityPairs[lpIndex].nftIds.push(nftIds[i]);\n\n            //Update NFT tracker\n            _nftToLp[nftIds[i]] = DataTypes.NftToLp({\n                liquidityPair: lpIndex,\n                index: _liquidityPairs[lpIndex].nftIds.length - 1\n            });\n\n            // Update token amount in liquidity pair\n            _liquidityPairs[lpIndex].tokenAmount -= (lp.spotPrice -\n                fee +\n                PercentageMath.percentMul(fee, protocolFeePercentage));\n\n            // Update total price quote and fee sum\n            finalPrice += (lp.spotPrice - fee);\n            totalFee += fee;\n\n            // Update liquidity pair price\n            if (lp.lpType != DataTypes.LPType.TradeUp) {\n                _liquidityPairs[lpIndex].spotPrice = IPricingCurve(lp.curve)\n                    .priceAfterSell(lp.spotPrice, lp.delta, lp.fee);\n            }\n        }\n\n        // Make sure the final price is greater than or equal to the minimum price set by the user\n        require(finalPrice >= minimumPrice, \"TP:S:MINIMUM_PRICE_NOT_REACHED\");\n\n        // Send tokens to user\n        IERC20(_token).safeTransfer(msg.sender, finalPrice);\n\n        // Send protocol fee to protocol fee distributor and call a checkpoint\n        IERC20(_token).safeTransfer(\n            _addressProvider.getFeeDistributor(),\n            PercentageMath.percentMul(totalFee, protocolFeePercentage)\n        );\n        IFeeDistributor(_addressProvider.getFeeDistributor()).checkpoint(\n            _token\n        );\n\n        emit Sell(onBehalfOf, nftIds, finalPrice);\n    }\n\n    /// @notice Allows the owner of the contract to pause or unpause the contract.\n    /// @param paused A boolean indicating whether to pause or unpause the contract.\n    function setPause(bool paused) external onlyOwner {\n        _paused = paused;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 batchSize\n    ) internal override(ERC721Enumerable) {\n        ERC721Enumerable._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view override(ERC165, ERC721Enumerable) returns (bool) {\n        return\n            type(ITradingPool).interfaceId == interfaceId ||\n            ERC721Enumerable.supportsInterface(interfaceId) ||\n            ERC165.supportsInterface(interfaceId);\n    }\n\n    function _requirePoolNotPaused() internal view {\n        require(!_paused, \"TP:POOL_PAUSED\");\n    }\n\n    function _requireLpExists(uint256 lpIndex) internal view {\n        require(_exists(lpIndex), \"TP:LP_NOT_FOUND\");\n    }\n}"
    },
    {
      "filename": "contracts/protocol/Trading/TradingPool.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {ITradingPool} from \"../../interfaces/ITradingPool.sol\";\nimport {IAddressProvider} from \"../../interfaces/IAddressProvider.sol\";\nimport {IPricingCurve} from \"../../interfaces/IPricingCurve.sol\";\nimport {IFeeDistributor} from \"../../interfaces/IFeeDistributor.sol\";\nimport {ITradingPoolFactory} from \"../../interfaces/ITradingPoolFactory.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {DataTypes} from \"../../libraries/types/DataTypes.sol\";\nimport {PercentageMath} from \"../../libraries/utils/PercentageMath.sol\";\nimport {ILiquidityPairMetadata} from \"../../interfaces/ILiquidityPairMetadata.sol\";\nimport {ITradingPool} from \"../../interfaces/ITradingPool.sol\";\n\n/// @title Trading Pool Contract\n/// @author leNFT\n/// @notice A contract that enables the creation of liquidity pools and the trading of NFTs and ERC20 tokens.\n/// @dev This contract manages liquidity pairs, each consisting of a set of NFTs and an ERC20 token, as well as the trading of these pairs.\ncontract TradingPool is\n    ERC165,\n    ERC721Enumerable,\n    ERC721Holder,\n    ITradingPool,\n    Ownable,\n    ReentrancyGuard\n{\n    uint public constant MAX_FEE = 8000; // 80%\n\n    IAddressProvider private immutable _addressProvider;\n    bool private _paused;\n    address private immutable _token;\n    address private immutable _nft;\n    mapping(uint256 => DataTypes.LiquidityPair) private _liquidityPairs;\n    mapping(uint256 => DataTypes.NftToLp) private _nftToLp;\n    uint256 private _lpCount;\n\n    using SafeERC20 for IERC20;\n\n    modifier poolNotPaused() {\n        _requirePoolNotPaused();\n        _;\n    }\n\n    modifier lpExists(uint256 lpId) {\n        _requireLpExists(lpId);\n        _;\n    }\n\n    /// @notice Trading Pool constructor.\n    /// @dev The constructor should only be called by the Trading Pool Factory contract.\n    /// @param addressProvider The address provider contract.\n    /// @param owner The owner of the Trading Pool contract.\n    /// @param token The ERC20 token used in the trading pool.\n    /// @param nft The address of the ERC721 contract.\n    /// @param name The name of the ERC721 token.\n    /// @param symbol The symbol of the ERC721 token.\n    constructor(\n        IAddressProvider addressProvider,\n        address owner,\n        address token,\n        address nft,\n        string memory name,\n        string memory symbol\n    ) ERC721(name, symbol) {\n        require(\n            msg.sender == addressProvider.getTradingPoolFactory(),\n            \"TP:C:MUST_BE_FACTORY\"\n        );\n        _addressProvider = addressProvider;\n        _token = token;\n        _nft = nft;\n        _transferOwnership(owner);\n    }\n\n    /// @notice Returns the token URI for a specific liquidity pair\n    /// @param tokenId The ID of the liquidity pair.\n    /// @return The token URI.\n    function tokenURI(\n        uint256 tokenId\n    ) public view override lpExists(tokenId) returns (string memory) {\n        return\n            ILiquidityPairMetadata(_addressProvider.getLiquidityPairMetadata())\n                .tokenURI(address(this), tokenId);\n    }\n\n    /// @notice Gets the address of the ERC721 traded in the pool.\n    /// @return The address of the ERC721 token.\n    function getNFT() external view override returns (address) {\n        return _nft;\n    }\n\n    /// @notice Gets the address of the ERC20 token traded in the pool.\n    /// @return The address of the ERC20 token.\n    function getToken() external view override returns (address) {\n        return _token;\n    }\n\n    /// @notice Gets the liquidity pair with the specified ID.\n    /// @param lpId The ID of the liquidity pair.\n    /// @return The liquidity pair.\n    function getLP(\n        uint256 lpId\n    )\n        external\n        view\n        override\n        lpExists(lpId)\n        returns (DataTypes.LiquidityPair memory)\n    {\n        return _liquidityPairs[lpId];\n    }\n\n    /// @notice Gets the number of liquidity pairs ever created in the trading pool.\n    /// @return The number of liquidity pairs.\n    function getLpCount() external view override returns (uint256) {\n        return _lpCount;\n    }\n\n    /// @notice Gets the ID of the liquidity pair associated with the specified NFT.\n    /// @param nftId The ID of the NFT.\n    /// @return The ID of the liquidity pair.\n    function nftToLp(uint256 nftId) external view override returns (uint256) {\n        require(\n            IERC721(_nft).ownerOf(nftId) == address(this),\n            \"TP:NTL:NOT_OWNED\"\n        );\n        return _nftToLp[nftId].liquidityPair;\n    }\n\n    /// @notice Adds liquidity to the trading pool.\n    /// @dev At least one of nftIds or tokenAmount must be greater than zero.\n    /// @dev The caller must approve the Trading Pool contract to transfer the NFTs and ERC20 tokens.\n    /// @param receiver The recipient of the liquidity pool tokens.\n    /// @param nftIds The IDs of the NFTs being deposited.\n    /// @param tokenAmount The amount of the ERC20 token being deposited.\n    /// @param spotPrice The spot price of the liquidity pair being created.\n    /// @param curve The pricing curve for the liquidity pair being created.\n    /// @param delta The delta for the liquidity pair being created.\n    /// @param fee The fee for the liquidity pair being created.\n    function addLiquidity(\n        address receiver,\n        DataTypes.LPType lpType,\n        uint256[] calldata nftIds,\n        uint256 tokenAmount,\n        uint256 spotPrice,\n        address curve,\n        uint256 delta,\n        uint256 fee\n    ) external override nonReentrant poolNotPaused {\n        ITradingPoolFactory tradingPoolFactory = ITradingPoolFactory(\n            _addressProvider.getTradingPoolFactory()\n        );\n\n        // Check if pool will exceed maximum permitted amount\n        require(\n            tokenAmount + IERC20(_token).balanceOf(address(this)) <\n                tradingPoolFactory.getTVLSafeguard(),\n            \"TP:AL:SAFEGUARD_EXCEEDED\"\n        );\n\n        // Different types of liquidity pairs have different requirements\n        // Trade: Can contain NFTs and/or tokens\n        // TradeUp: Can contain NFTs and/or tokens, delta must be > 0\n        // TradeDown: Can contain NFTs and/or tokens, delta must be > 0\n        // Buy: Can only contain tokens\n        // Sell: Can only contain NFTs\n        if (\n            lpType == DataTypes.LPType.Trade ||\n            lpType == DataTypes.LPType.TradeUp ||\n            lpType == DataTypes.LPType.TradeDown\n        ) {\n            require(\n                tokenAmount > 0 || nftIds.length > 0,\n                \"TP:AL:DEPOSIT_REQUIRED\"\n            );\n        } else if (lpType == DataTypes.LPType.Buy) {\n            require(tokenAmount > 0 && nftIds.length == 0, \"TP:AL:TOKENS_ONLY\");\n        } else if (lpType == DataTypes.LPType.Sell) {\n            require(nftIds.length > 0 && tokenAmount == 0, \"TP:AL:NFTS_ONLY\");\n        }\n\n        // Directional LPs must have a positive delta in order for the price to move or else\n        // they degenerate into a Trade LPs with delta = 0\n        if (\n            lpType == DataTypes.LPType.TradeUp ||\n            lpType == DataTypes.LPType.TradeDown\n        ) {\n            require(delta > 0, \"TP:AL:DELTA_0\");\n        }\n\n        if (lpType == DataTypes.LPType.Buy || lpType == DataTypes.LPType.Sell) {\n            // Validate fee\n            require(fee == 0, \"TP:AL:INVALID_LIMIT_FEE\");\n        } else {\n            // require that the fee is higher than 0 and less than the maximum fee\n            require(fee > 0 && fee <= MAX_FEE, \"TP:AL:INVALID_FEE\");\n        }\n\n        // Require that the curve conforms to the curve interface\n        require(tradingPoolFactory.isPriceCurve(curve), \"TP:AL:INVALID_CURVE\");\n\n        // Validate LP params for chosen curve\n        IPricingCurve(curve).validateLpParameters(spotPrice, delta, fee);\n\n        // Add user nfts to the pool\n        for (uint i = 0; i < nftIds.length; i++) {\n            IERC721(_nft).safeTransferFrom(\n                msg.sender,\n                address(this),\n                nftIds[i]\n            );\n            _nftToLp[nftIds[i]] = DataTypes.NftToLp({\n                liquidityPair: _lpCount,\n                index: i\n            });\n        }\n\n        // Send user token to the pool\n        if (tokenAmount > 0) {\n            IERC20(_token).safeTransferFrom(\n                msg.sender,\n                address(this),\n                tokenAmount\n            );\n        }\n\n        // Save the user deposit info\n        _liquidityPairs[_lpCount] = DataTypes.LiquidityPair({\n            lpType: lpType,\n            nftIds: nftIds,\n            tokenAmount: tokenAmount,\n            spotPrice: spotPrice,\n            curve: curve,\n            delta: delta,\n            fee: fee\n        });\n\n        // Mint liquidity position NFT\n        ERC721._safeMint(receiver, _lpCount);\n\n        emit AddLiquidity(\n            receiver,\n            _lpCount,\n            lpType,\n            nftIds,\n            tokenAmount,\n            spotPrice,\n            curve,\n            delta,\n            fee\n        );\n\n        _lpCount++;\n    }\n\n    /// @notice Removes liquidity, sending back deposited tokens and transferring the NFTs to the user\n    /// @param lpId The ID of the LP token to remove\n    function removeLiquidity(uint256 lpId) public override nonReentrant {\n        //Require the caller owns LP\n        require(msg.sender == ERC721.ownerOf(lpId), \"TP:RL:NOT_OWNER\");\n\n        // Send pool nfts to the user\n        uint256 nftIdsLength = _liquidityPairs[lpId].nftIds.length;\n        for (uint i = 0; i < nftIdsLength; i++) {\n            IERC721(_nft).safeTransferFrom(\n                address(this),\n                msg.sender,\n                _liquidityPairs[lpId].nftIds[i]\n            );\n            delete _nftToLp[_liquidityPairs[lpId].nftIds[i]];\n        }\n\n        // Send pool token back to user\n        IERC20(_token).safeTransfer(\n            msg.sender,\n            _liquidityPairs[lpId].tokenAmount\n        );\n\n        // delete the user deposit info\n        delete _liquidityPairs[lpId];\n\n        // Burn liquidity position NFT\n        ERC721._burn(lpId);\n\n        emit RemoveLiquidity(msg.sender, lpId);\n    }\n\n    /// @notice Removes liquidity in batches by calling the removeLiquidity function for each LP token ID in the lpIds array\n    /// @param lpIds The IDs of the LP tokens to remove liquidity from\n    function removeLiquidityBatch(uint256[] calldata lpIds) external override {\n        for (uint i = 0; i < lpIds.length; i++) {\n            removeLiquidity(lpIds[i]);\n        }\n    }\n\n    /// @notice Buys NFTs in exchange for pool tokens\n    /// @param onBehalfOf The address to deposit the NFTs to\n    /// @param nftIds The IDs of the NFTs to buy\n    /// @param maximumPrice The maximum price the user is willing to pay for the NFTs\n    /// @return finalPrice The final price paid for the NFTs\n    function buy(\n        address onBehalfOf,\n        uint256[] calldata nftIds,\n        uint256 maximumPrice\n    )\n        external\n        override\n        nonReentrant\n        poolNotPaused\n        returns (uint256 finalPrice)\n    {\n        require(nftIds.length > 0, \"TP:B:NFTS_0\");\n\n        uint256 lpIndex;\n        uint256 fee;\n        uint256 totalFee;\n        uint256 protocolFee;\n        DataTypes.LiquidityPair memory lp;\n        uint256 protocolFeePercentage = ITradingPoolFactory(\n            _addressProvider.getTradingPoolFactory()\n        ).getProtocolFeePercentage();\n        for (uint i = 0; i < nftIds.length; i++) {\n            // Check if the pool contract owns the NFT\n            require(\n                IERC721(_nft).ownerOf(nftIds[i]) == address(this),\n                \"TP:B:NOT_OWNER\"\n            );\n            lpIndex = _nftToLp[nftIds[i]].liquidityPair;\n            lp = _liquidityPairs[lpIndex];\n\n            // Can't buy from buy LP\n            require(lp.lpType != DataTypes.LPType.Buy, \"TP:B:IS_BUY_LP\");\n\n            fee = PercentageMath.percentMul(lp.spotPrice, lp.fee);\n            protocolFee = PercentageMath.percentMul(fee, protocolFeePercentage);\n\n            // Remove nft from liquidity pair nft list\n            _liquidityPairs[lpIndex].nftIds[_nftToLp[nftIds[i]].index] = lp\n                .nftIds[lp.nftIds.length - 1];\n\n            // Update NFT to lp tracker"
    }
  ]
}