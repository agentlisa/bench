{
  "Title": "[G-05] Cache state variables outside of loop to avoid reading storage on every iteration",
  "Content": "Reading from storage should always try to be avoided within loops. In the following instances, we are able to cache state variables outside of the loop to save a `Gwarmaccess (100 gas)` per loop iteration.\n\nTotal Instances: `1`\n\nEstimiated Gas Saved: `100`\n\nhttps://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/miner/EUSDMiningIncentives.sol#L136-L145\n\n### Cache `peUSDExtraRatio` outside of the loop to save 1 SLOAD per iteration\n\n*Note: This `view` function is invoked within other public `view` functions that themselves are invoked within state-mutating functions. Example: `getReward()` (state-mutating) invokes `isOtherEarningsClaimable` which in turn invokes `stakeOf`.*\n```solidity\nFile: contracts/lybra/miner/EUSDMiningIncentives.sol\n136:    function stakedOf(address user) public view returns (uint256) {\n137:        uint256 amount;\n138:        for (uint i = 0; i < pools.length; i++) {\n139:            ILybra pool = ILybra(pools[i]);\n140:            uint borrowed = pool.getBorrowedOf(user);\n141:            if (pool.getVaultType() == 1) {\n142:                borrowed = borrowed * (1e20 + peUSDExtraRatio) / 1e20; // @audit: sload on every iteration\n143:            }\n144:            amount += borrowed;\n145:        }\n```\n```diff\ndiff --git a/lybra/miner/EUSDMiningIncentives.sol b/lybra/miner/EUSDMiningIncentives.sol\nindex e6c57c8..43746fa 100644\n--- a/lybra/miner/EUSDMiningIncentives.sol\n+++ b/lybra/miner/EUSDMiningIncentives.sol\n@@ -135,11 +135,12 @@ contract EUSDMiningIncentives is Ownable {\n\n     function stakedOf(address user) public view returns (uint256) {\n         uint256 amount;\n+        uint256 _peUSDExtraRatio = peUSDExtraRatio;\n         for (uint i = 0; i < pools.length; i++) {\n             ILybra pool = ILybra(pools[i]);\n             uint borrowed = pool.getBorrowedOf(user);\n             if (pool.getVaultType() == 1) {\n-                borrowed = borrowed * (1e20 + peUSDExtraRatio) / 1e20;\n+                borrowed = borrowed * (1e20 + _peUSDExtraRatio) / 1e20;\n             }\n             amount += borrowed;\n         }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/miner/EUSDMiningIncentives.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title tokenMiner is a stripped down version of Synthetix StakingRewards.sol, to reward esLBR to EUSD minters.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract EUSD.\n * - Get `stakedOf(user)` from getBorrowedOf(user) in contract EUSD.\n * - When an address borrowed EUSD amount changes, call the refreshReward method to update rewards to be claimed.\n */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IesLBR.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/ILybra.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ninterface IesLBRBoost {\n    function getUserBoost(\n        address user,\n        uint256 userUpdatedAt,\n        uint256 finishAt\n    ) external view returns (uint256);\n}\n\ncontract EUSDMiningIncentives is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBRBoost public esLBRBoost;\n    IEUSD public immutable EUSD;\n    address public esLBR;\n    address public LBR;\n    address[] public pools;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration = 2_592_000;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRatio;\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userUpdatedAt;\n    uint256 public extraRatio = 50 * 1e18;\n    uint256 public peUSDExtraRatio = 10 * 1e18;\n    uint256 public biddingFeeRatio = 3000;\n    address public ethlbrStakePool;\n    address public ethlbrLpToken;\n    AggregatorV3Interface internal etherPriceFeed;\n    AggregatorV3Interface internal lbrPriceFeed;\n    bool public isEUSDBuyoutAllowed = true;\n\n    event ClaimReward(address indexed user, uint256 amount, uint256 time);\n    event ClaimedOtherEarnings(address indexed user, address indexed Victim, uint256 buyAmount, uint256 biddingFee, bool useEUSD, uint256 time);\n    event NotifyRewardChanged(uint256 addAmount, uint256 time);\n\n    //etherOracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n    constructor(address _config, address _boost, address _etherOracle, address _lbrOracle) {\n        configurator = Iconfigurator(_config);\n        esLBRBoost = IesLBRBoost(_boost);\n        EUSD = IEUSD(configurator.getEUSDAddress());\n        etherPriceFeed = AggregatorV3Interface(_etherOracle);\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n            userUpdatedAt[_account] = block.timestamp;\n        }\n        _;\n    }\n\n    function setToken(address _lbr, address _eslbr) external onlyOwner {\n        LBR = _lbr;\n        esLBR = _eslbr;\n    }\n\n    function setLBROracle(address _lbrOracle) external onlyOwner {\n        lbrPriceFeed = AggregatorV3Interface(_lbrOracle);\n    }\n\n    function setPools(address[] memory _pools) external onlyOwner {\n        for (uint i = 0; i < _pools.length; i++) {\n            require(configurator.mintVault(_pools[i]), \"NOT_VAULT\");\n        }\n        pools = _pools;\n    }\n\n    function setBiddingCost(uint256 _biddingRatio) external onlyOwner {\n        require(_biddingRatio <= 8000, \"BCE\");\n        biddingFeeRatio = _biddingRatio;\n    }\n\n    function setExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        extraRatio = ratio;\n    }\n\n    function setPeUSDExtraRatio(uint256 ratio) external onlyOwner {\n        require(ratio <= 1e20, \"BCE\");\n        peUSDExtraRatio = ratio;\n    }\n\n    function setBoost(address _boost) external onlyOwner {\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    function setEthlbrStakeInfo(address _pool, address _lp) external onlyOwner {\n        ethlbrStakePool = _pool;\n        ethlbrLpToken = _lp;\n    }\n    function setEUSDBuyoutAllowed(bool _bool) external onlyOwner {\n        isEUSDBuyoutAllowed = _bool;\n    }\n\n    function totalStaked() internal view returns (uint256) {\n        return EUSD.totalSupply();\n    }\n\n    function stakedOf(address user) public view returns (uint256) {\n        uint256 amount;\n        for (uint i = 0; i < pools.length; i++) {\n            ILybra pool = ILybra(pools[i]);\n            uint borrowed = pool.getBorrowedOf(user);\n            if (pool.getVaultType() == 1) {\n                borrowed = borrowed * (1e20 + peUSDExtraRatio) / 1e20;\n            }\n            amount += borrowed;\n        }\n        return amount;\n    }\n\n    function stakedLBRLpValue(address user) public view returns (uint256) {\n        uint256 totalLp = IEUSD(ethlbrLpToken).totalSupply();\n        (, int etherPrice, , , ) = etherPriceFeed.latestRoundData();\n        (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n        uint256 etherInLp = (IEUSD(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(ethlbrLpToken) * uint(etherPrice)) / 1e8;\n        uint256 lbrInLp = (IEUSD(LBR).balanceOf(ethlbrLpToken) * uint(lbrPrice)) / 1e8;\n        uint256 userStaked = IEUSD(ethlbrStakePool).balanceOf(user);\n        return (userStaked * (lbrInLp + etherInLp)) / totalLp;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalStaked() == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return rewardPerTokenStored + (rewardRatio * (lastTimeRewardApplicable() - updatedAt) * 1e18) / totalStaked();\n    }\n\n    /**\n     * @notice Update user's claimable reward data and record the timestamp.\n     */\n    function refreshReward(address _account) external updateReward(_account) {}\n\n    function getBoost(address _account) public view returns (uint256) {\n        uint256 redemptionBoost;\n        if (configurator.isRedemptionProvider(_account)) {\n            redemptionBoost = extraRatio;\n        }\n        return 100 * 1e18 + redemptionBoost + esLBRBoost.getUserBoost(_account, userUpdatedAt[_account], finishAt);\n    }\n\n    function earned(address _account) public view returns (uint256) {\n        return ((stakedOf(_account) * getBoost(_account) * (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) + rewards[_account];\n    }\n\n    function isOtherEarningsClaimable(address user) public view returns (bool) {\n        return (stakedLBRLpValue(user) * 10000) / stakedOf(user) < 500;\n    }\n\n    function getReward() external updateReward(msg.sender) {\n        require(!isOtherEarningsClaimable(msg.sender), \"Insufficient DLP, unable to claim rewards\");\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IesLBR(esLBR).mint(msg.sender, reward);\n            emit ClaimReward(msg.sender, reward, block.timestamp);\n        }\n    }\n\n    function purchaseOtherEarnings(address user, bool useEUSD) external updateReward(user) {\n        require(isOtherEarningsClaimable(user), \"The rewards of the user cannot be bought out\");\n        if(useEUSD) {\n            require(isEUSDBuyoutAllowed, \"The purchase using EUSD is not permitted.\");\n        }\n        uint256 reward = rewards[user];\n        if (reward > 0) {\n            rewards[user] = 0;\n            uint256 biddingFee = (reward * biddingFeeRatio) / 10000;\n            if(useEUSD) {\n                (, int lbrPrice, , , ) = lbrPriceFeed.latestRoundData();\n                biddingFee = biddingFee * uint256(lbrPrice) / 1e8;\n                bool success = EUSD.transferFrom(msg.sender, address(configurator), biddingFee);\n                require(success, \"TF\");\n                try configurator.distributeRewards() {} catch {}\n            } else {\n                IesLBR(LBR).burn(msg.sender, biddingFee);\n            }\n            IesLBR(esLBR).mint(msg.sender, reward);\n\n            emit ClaimedOtherEarnings(msg.sender, user, reward, biddingFee, useEUSD, block.timestamp);\n        }\n    }\n\n    function notifyRewardAmount(\n        uint256 amount\n    ) external onlyOwner updateReward(address(0)) {\n        require(amount > 0, \"amount = 0\");\n        if (block.timestamp >= finishAt) {\n            rewardRatio = amount / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRatio;\n            rewardRatio = (amount + remainingRewards) / duration;\n        }\n\n        require(rewardRatio > 0, \"reward ratio = 0\");\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n        emit NotifyRewardChanged(amount, block.timestamp);\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}"
    }
  ]
}