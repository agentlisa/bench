{
  "Title": "Maximum mintable and depositable amounts returned are incorrect",
  "Content": "The amount of vault shares available for minting is limited by the [`availableCap`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/mixins/Capped.sol#L20). Similarly, the `availableCap` also limits the amount of assets that may be deposited and then later converted into vault shares for the depositor. The [`maxMint`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L236) and [`maxDeposit`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L229) functions do not account for the `availableCap` and instead return the max `uint256` value when called. In order to conform to the [`EIP4626`](https://eips.ethereum.org/EIPS/eip-4626) standard, these functions must return the real amount that can be minted or deposited.\n\n\nConsider changing the `maxMint` and `maxDeposit` functions to return a value that accounts for the `availableCap`.\n\n\n**Update:** *Fixed in [PR#42](https://github.com/pods-finance/yield-contracts/pull/42), with commit `3159de5` being the last one added.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/mixins/Capped.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IConfigurationManager.sol\";\n\nabstract contract Capped {\n    IConfigurationManager private immutable _configuration;\n    uint256 public spentCap;\n\n    error Capped__AmountExceedsCap(uint256 amount, uint256 available);\n\n    constructor(IConfigurationManager _configuration_) {\n        _configuration = _configuration_;\n    }\n\n    /**\n     * @dev Returns the amount that could be used.\n     */\n    function availableCap() public view returns (uint256) {\n        uint256 cap = _configuration.getCap(address(this));\n        return cap == 0 ? type(uint256).max : cap - spentCap;\n    }\n\n    /**\n     * @dev Returns the amount that could be used.\n     * @param amount The amount to be spent\n     */\n    function _spendCap(uint256 amount) internal {\n        uint256 available = availableCap();\n        if (amount > available) revert Capped__AmountExceedsCap(amount, available);\n        spentCap += amount;\n    }\n\n    /**\n     * @dev Restores the cap.\n     * @param amount The amount to be restored\n     */\n    function _restoreCap(uint256 amount) internal {\n        if (availableCap() != type(uint256).max) {\n            spentCap -= amount;\n        }\n    }\n}"
    }
  ]
}