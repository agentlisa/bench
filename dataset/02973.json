{
  "Title": "H-4: Wrong implementation of orderbook can make user can't get their fund back",
  "Content": "# Issue H-4: Wrong implementation of orderbook can make user can't get their fund back \n\nSource: https://github.com/sherlock-audit/2022-09-knox-judging/issues/66 \n\n## Found by \nTrumpero\n\n## Lines of code \nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/OrderBook.sol#L240\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/OrderBook.sol#L182-L190\n\n## Summary\nWhen a user remove an order, next user call `addLimitOrder` can override the latest order with his/her order. It will make one who is owner of that latest order lose their fund. \n\n## Vulnerability Detail\nFunction `_remove` will decrease value of `index.length` by 1 when an order is removed\n```solidity=\n// url = https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/OrderBook.sol#L240\nfunction _remove(Index storage index, uint256 id) internal returns (bool) {\n    index.length = index.length > 0 ? index.length - 1 : 1;\n    ...\n}\n```\nInstead of reserving `id` of removed order to reuse for next created order, function `_insert` use the id of new order is `index.length + 1`\n```solidity=\n// url = https://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/auction/OrderBook.sol#L165-L172\nfunction _insert(\n    Index storage index,\n    int128 price64x64,\n    uint256 size,\n    address buyer\n) internal returns (uint256) {\n    index.length = index.length > 0 ? index.length + 1 : 1;\n    uint256 id = index.length;\n    ...\n}\n```\nIt will override the latest order with new order's data.\n\nFor example\n* Alice create an order with price = 10 --> `id = 1, index.length = 1`\n* Bob create an order with price = 20 --> `id = 2, index.length = 2` \n* Alice cancel order `id = 1` --> `index.length = 1`\n* Candice create new order with price = 30 \n    * At this time, new order will have `id = index.length + 1 = 1 + 1 = 2`. It will override the state of Bob's order: price from 20 -> 30 \n\n## Impact\nUser whose order is overrided can't withdraw their refund `ERC20` and their exercised tokens. \n\n## Code Snippet\n```typescript=\nit.only(\"bug\", async() => {\n    const totalContracts = await auction.getTotalContracts(epoch);\n\n    const buyer1OrderSize = totalContracts.div(5);\n    const buyer2OrderSize = totalContracts.div(5);\n    const buyer3OrderSize = totalContracts.div(5);\n\n    // buyer1 create order with price = 10\n    await asset\n      .connect(signers.buyer1)\n      .approve(addresses.auction, ethers.constants.MaxUint256);\n    await auction.addLimitOrder(epoch, 10, buyer1OrderSize);\n\n    // buyer2 create order with price = 20\n    await asset \n      .connect(signers.buyer2)\n      .approve(addresses.auction, ethers.constants.MaxUint256);\n    await auction\n      .connect(signers.buyer2)\n      .addLimitOrder(epoch, 20, buyer2OrderSize);\n\n    // order with id = 2 have price = 20 \n    expect( (await auction.getOrderById(epoch, 2)).price64x64 ).to.equal(20);\n\n    // buyer1 cancel order with id = 1\n    await auction.connect(signers.buyer1).cancelLimitOrder(epoch, 1);\n\n    // buyer3 create order with price = 30\n    await asset\n      .connect(signers.buyer3)\n      .approve(addresses.auction, ethers.constants.MaxUint256);\n    await auction\n      .connect(signers.buyer3)\n      .addLimitOrder(epoch, 30, buyer3OrderSize);\n\n    // order with id = 2 have price = 30 --> nervous \n    expect( (await auction.getOrderById(epoch, 2)).price64x64 ).to.equal(30);\n});\n```\nTo check with test, u can use this file \nhttps://gist.github.com/Trumpero/adbcd84c33f71856dbf379f581e8abbb\nI write one more describe `::Bug` beside your original describe `::Auction` in file `Auction.behavior.ts` (just too lazy to write a new one). \n\n## Tool used\nHardhat \n\n## Recommendation\nUse an array to store unused (removed) id, then assign each id to the new limit order created instead of using `index.length`. \n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/4",
  "Code": [
    {
      "filename": "knox-contracts/contracts/auction/OrderBook.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Knox Auction Order Book Library\n * @dev based on PiperMerriam's Grove v0.3\n * https://github.com/pipermerriam/ethereum-grove\n */\n\nlibrary OrderBook {\n    struct Index {\n        uint256 head;\n        uint256 length;\n        uint256 root;\n        mapping(uint256 => Order) orders;\n    }\n\n    struct Order {\n        Data data;\n        uint256 parent;\n        uint256 left;\n        uint256 right;\n        uint256 height;\n    }\n\n    struct Data {\n        uint256 id;\n        int128 price64x64;\n        uint256 size;\n        address buyer;\n    }\n\n    /// @dev Retrieve the highest bid in the order book.\n    /// @param index The index that the order is part of.\n    function _head(Index storage index) internal view returns (uint256) {\n        return index.head;\n    }\n\n    /// @dev Retrieve the number of bids in the order book.\n    /// @param index The index that the order is part of.\n    function _length(Index storage index) internal view returns (uint256) {\n        return index.length;\n    }\n\n    /// @dev Retrieve the id, price, size, and buyer for the order.\n    /// @param index The index that the order is part of.\n    /// @param id The id for the order to be looked up.\n    function _getOrderById(Index storage index, uint256 id)\n        internal\n        view\n        returns (Data memory)\n    {\n        return index.orders[id].data;\n    }\n\n    /// @dev Returns the previous bid in descending order.\n    /// @param index The index that the order is part of.\n    /// @param id The id for the order to be looked up.\n    function _getPreviousOrder(Index storage index, uint256 id)\n        internal\n        view\n        returns (uint256)\n    {\n        Order storage currentOrder = index.orders[id];\n\n        if (currentOrder.data.id == 0) {\n            // Unknown order, just return 0;\n            return 0;\n        }\n\n        Order memory child;\n\n        if (currentOrder.left != 0) {\n            // Trace left to latest child in left tree.\n            child = index.orders[currentOrder.left];\n\n            while (child.right != 0) {\n                child = index.orders[child.right];\n            }\n            return child.data.id;\n        }\n\n        if (currentOrder.parent != 0) {\n            // Now we trace back up through parent relationships, looking\n            // for a link where the child is the right child of it's\n            // parent.\n            Order storage parent = index.orders[currentOrder.parent];\n            child = currentOrder;\n\n            while (true) {\n                if (parent.right == child.data.id) {\n                    return parent.data.id;\n                }\n\n                if (parent.parent == 0) {\n                    break;\n                }\n                child = parent;\n                parent = index.orders[parent.parent];\n            }\n        }\n\n        // This is the first order, and has no previous order.\n        return 0;\n    }\n\n    /// @dev Returns the next bid in descending order.\n    /// @param index The index that the order is part of.\n    /// @param id The id for the order to be looked up.\n    function _getNextOrder(Index storage index, uint256 id)\n        internal\n        view\n        returns (uint256)\n    {\n        Order storage currentOrder = index.orders[id];\n\n        if (currentOrder.data.id == 0) {\n            // Unknown order, just return 0;\n            return 0;\n        }\n\n        Order memory child;\n\n        if (currentOrder.right != 0) {\n            // Trace right to earliest child in right tree.\n            child = index.orders[currentOrder.right];\n\n            while (child.left != 0) {\n                child = index.orders[child.left];\n            }\n            return child.data.id;\n        }\n\n        if (currentOrder.parent != 0) {\n            // if the order is the left child of it's parent, then the\n            // parent is the next one.\n            Order storage parent = index.orders[currentOrder.parent];\n            child = currentOrder;\n\n            while (true) {\n                if (parent.left == child.data.id) {\n                    return parent.data.id;\n                }\n\n                if (parent.parent == 0) {\n                    break;\n                }\n                child = parent;\n                parent = index.orders[parent.parent];\n            }\n\n            // Now we need to trace all the way up checking to see if any parent is the\n        }\n\n        // This is the final order.\n        return 0;\n    }\n\n    /// @dev Updates or Inserts the id into the index at its appropriate location based on the price provided.\n    /// @param index The index that the order is part of.\n    // / @param id The unique identifier of the data element the index order will represent.\n    /// @param price64x64 The unit price specified by the buyer.\n    /// @param size The size specified by the buyer.\n    /// @param buyer The buyers wallet address.\n    function _insert(\n        Index storage index,\n        int128 price64x64,\n        uint256 size,\n        address buyer\n    ) internal returns (uint256) {\n        index.length = index.length > 0 ? index.length + 1 : 1;\n        uint256 id = index.length;\n\n        Data memory data = _getOrderById(index, index.head);\n\n        int128 highestPricePaid = data.price64x64;\n\n        if (index.head == 0 || price64x64 > highestPricePaid) {\n            index.head = id;\n        }\n\n        if (index.orders[id].data.id == id) {\n            // A order with this id already exists.  If the price is\n            // the same, then just return early, otherwise, remove it\n            // and reinsert it.\n            if (index.orders[id].data.price64x64 == price64x64) {\n                return id;\n            }\n            _remove(index, id);\n        }\n\n        uint256 previousOrderId = 0;\n\n        if (index.root == 0) {\n            index.root = id;\n        }\n        Order storage currentOrder = index.orders[index.root];\n\n        // Do insertion\n        while (true) {\n            if (currentOrder.data.id == 0) {\n                // This is a new unpopulated order.\n                currentOrder.data.id = id;\n                currentOrder.parent = previousOrderId;\n                currentOrder.data.price64x64 = price64x64;\n                currentOrder.data.size = size;\n                currentOrder.data.buyer = buyer;\n                break;\n            }\n\n            // Set the previous order id.\n            previousOrderId = currentOrder.data.id;\n\n            // The new order belongs in the right subtree\n            if (price64x64 <= currentOrder.data.price64x64) {\n                if (currentOrder.right == 0) {\n                    currentOrder.right = id;\n                }\n                currentOrder = index.orders[currentOrder.right];\n                continue;\n            }\n\n            // The new order belongs in the left subtree.\n            if (currentOrder.left == 0) {\n                currentOrder.left = id;\n            }\n            currentOrder = index.orders[currentOrder.left];\n        }\n\n        // Rebalance the tree\n        _rebalanceTree(index, currentOrder.data.id);\n\n        return id;\n    }\n\n    /// @dev Remove the order for the given unique identifier from the index.\n    /// @param index The index that should be removed\n    /// @param id The unique identifier of the data element to remove.\n    function _remove(Index storage index, uint256 id) internal returns (bool) {\n        index.length = index.length > 0 ? index.length - 1 : 1;\n\n        if (id == index.head) {\n            index.head = _getNextOrder(index, id);\n        }\n\n        Order storage replacementOrder;\n        Order storage parent;\n        Order storage child;\n        uint256 rebalanceOrigin;\n\n        Order storage orderToDelete = index.orders[id];\n\n        if (orderToDelete.data.id != id) {\n            // The id does not exist in the tree.\n            return false;\n        }\n\n        if (orderToDelete.left != 0 || orderToDelete.right != 0) {\n            // This order is not a leaf order and thus must replace itself in\n            // it's tree by either the previous or next order.\n            if (orderToDelete.left != 0) {\n                // This order is guaranteed to not have a right child.\n                replacementOrder = index.orders[\n                    _getPreviousOrder(index, orderToDelete.data.id)\n                ];\n            } else {\n                // This order is guaranteed to not have a left child.\n                replacementOrder = index.orders[\n                    _getNextOrder(index, orderToDelete.data.id)\n                ];\n            }\n            // The replacementOrder is guaranteed to have a parent.\n            parent = index.orders[replacementOrder.parent];\n\n            // Keep note of the location that our tree rebalancing should\n            // start at.\n            rebalanceOrigin = replacementOrder.data.id;\n\n            // Join the parent of the replacement order with any subtree of\n            // the replacement order.  We can guarantee that the replacement\n            // order has at most one subtree because of how getNextOrder and\n            // getPreviousOrder are used.\n            if (parent.left == replacementOrder.data.id) {\n                parent.left = replacementOrder.right;\n                if (replacementOrder.right != 0) {\n                    child = index.orders[replacementOrder.right];\n                    child.parent = parent.data.id;\n                }\n            }\n            if (parent.right == replacementOrder.data.id) {\n                parent.right = replacementOrder.left;\n                if (replacementOrder.left != 0) {\n                    child = index.orders[replacementOrder.left];\n                    child.parent = parent.data.id;\n                }\n            }\n\n            // Now we replace the orderToDelete with the replacementOrder.\n            // This includes parent/child relationships for all of the\n            // parent, the left child, and the right child.\n            replacementOrder.parent = orderToDelete.parent;\n            if (orderToDelete.parent != 0) {\n                parent = index.orders[orderToDelete.parent];\n                if (parent.left == orderToDelete.data.id) {\n                    parent.left = replacementOrder.data.id;\n                }\n                if (parent.right == orderToDelete.data.id) {\n                    parent.right = replacementOrder.data.id;\n                }\n            } else {\n                // If the order we are deleting is the root order update the\n                // index root order pointer.\n                index.root = replacementOrder.data.id;\n            }\n\n            replacementOrder.left = orderToDelete.left;\n            if (orderToDelete.left != 0) {\n                child = index.orders[orderToDelete.left];\n                child.parent = replacementOrder.data.id;\n            }\n\n            replacementOrder.right = orderToDelete.right;\n            if (orderToDelete.right != 0) {\n                child = index.orders[orderToDelete.right];\n                child.parent = replacementOrder.data.id;\n            }\n        } else if (orderToDelete.parent != 0) {\n            // The order being deleted is a leaf order so we only erase it's\n            // parent linkage.\n            parent = index.orders[orderToDelete.parent];\n\n            if (parent.left == orderToDelete.data.id) {\n                parent.left = 0;\n            }\n            if (parent.right == orderToDelete.data.id) {\n                parent.right = 0;\n            }\n\n            // keep note of where the rebalancing should begin.\n            rebalanceOrigin = parent.data.id;\n        } else {\n            // This is both a leaf order and the root order, so we need to\n            // unset the root order pointer.\n            index.root = 0;\n        }\n\n        // Now we zero out all of the fields on the orderToDelete.\n        orderToDelete.data.id = 0;\n        orderToDelete.data.price64x64 = 0;\n        orderToDelete.data.size = 0;\n        orderToDelete.data.buyer = 0x0000000000000000000000000000000000000000;\n        orderToDelete.parent = 0;\n        orderToDelete.left = 0;\n        orderToDelete.right = 0;\n        orderToDelete.height = 0;\n\n        // Walk back up the tree rebalancing\n        if (rebalanceOrigin != 0) {\n            _rebalanceTree(index, rebalanceOrigin);\n        }\n\n        return true;\n    }\n\n    function _rebalanceTree(Index storage index, uint256 id) private {\n        // Trace back up rebalancing the tree and updating heights as\n        // needed..\n        Order storage currentOrder = index.orders[id];\n\n        while (true) {\n            int256 balanceFactor =\n                _getBalanceFactor(index, currentOrder.data.id);\n\n            if (balanceFactor == 2) {\n                // Right rotation (tree is heavy on the left)\n                if (_getBalanceFactor(index, currentOrder.left) == -1) {\n                    // The subtree is leaning right so it need to be\n                    // rotated left before the current order is rotated\n                    // right.\n                    _rotateLeft(index, currentOrder.left);\n                }\n                _rotateRight(index, currentOrder.data.id);\n            }\n\n            if (balanceFactor == -2) {\n                // Left rotation (tree is heavy on the right)\n                if (_getBalanceFactor(index, currentOrder.right) == 1) {\n                    // The subtree is leaning left so it need to be\n                    // rotated right before the current order is rotated\n                    // left.\n                    _rotateRight(index, currentOrder.right);\n                }\n                _rotateLeft(index, currentOrder.data.id);\n            }\n\n            if ((-1 <= balanceFactor) && (balanceFactor <= 1)) {\n                _updateOrderHeight(index, currentOrder.data.id);\n            }\n\n            if (currentOrder.parent == 0) {\n                // Reached the root which may be new due to tree\n                // rotation, so set it as the root and then break.\n                break;\n            }\n\n            currentOrder = index.orders[currentOrder.parent];\n        }\n    }\n\n    function _getBalanceFactor(Index storage index, uint256 id)\n        private\n        view\n        returns (int256)\n    {\n        Order storage order = index.orders[id];\n        return\n            int256(index.orders[order.left].height) -\n            int256(index.orders[order.right].height);\n    }\n\n    function _updateOrderHeight(Index storage index, uint256 id) private {\n        Order storage order = index.orders[id];\n        order.height =\n            _max(\n                index.orders[order.left].height,\n                index.orders[order.right].height\n            ) +\n            1;\n    }\n\n    function _max(uint256 a, uint256 b) private pure returns (uint256) {\n        if (a >= b) {\n            return a;\n        }\n        return b;\n    }\n\n    function _rotateLeft(Index storage index, uint256 id) private {\n        Order storage originalRoot = index.orders[id];\n\n        if (originalRoot.right == 0) {\n            // Cannot rotate left if there is no right originalRoot to rotate into\n            // place.\n            revert();\n        }\n\n        // The right child is the new root, so it gets the original\n        // `originalRoot.parent` as it's parent.\n        Order storage newRoot = index.orders[originalRoot.right];\n        newRoot.parent = originalRoot.parent;\n\n        // The original root needs to have it's right child nulled out.\n        originalRoot.right = 0;\n\n        if (originalRoot.parent != 0) {\n            // If there is a parent order, it needs to now point downward at\n            // the newRoot which is rotating into the place where `order` was.\n            Order storage parent = index.orders[originalRoot.parent];\n\n            // figure out if we're a left or right child and have the\n            // parent point to the new order.\n            if (parent.left == originalRoot.data.id) {\n                parent.left = newRoot.data.id;\n            }\n            if (parent.right == originalRoot.data.id) {\n                parent.right = newRoot.data.id;\n            }\n        }\n\n        if (newRoot.left != 0) {\n            // If the new root had a left child, that moves to be the\n            // new right child of the original root order\n            Order storage leftChild = index.orders[newRoot.left];\n            originalRoot.right = leftChild.data.id;\n            leftChild.parent = originalRoot.data.id;\n        }\n\n        // Update the newRoot's left order to point at the original order.\n        originalRoot.parent = newRoot.data.id;\n        newRoot.left = originalRoot.data.id;\n\n        if (newRoot.parent == 0) {\n            index.root = newRoot.data.id;\n        }\n\n        _updateOrderHeight(index, originalRoot.data.id);\n        _updateOrderHeight(index, newRoot.data.id);\n    }\n\n    function _rotateRight(Index storage index, uint256 id) private {\n        Order storage originalRoot = index.orders[id];\n\n        if (originalRoot.left == 0) {\n            // Cannot rotate right if there is no left order to rotate into\n            // place.\n            revert();\n        }\n\n        // The left child is taking the place of order, so we update it's\n        // parent to be the original parent of the order.\n        Order storage newRoot = index.orders[originalRoot.left];\n        newRoot.parent = originalRoot.parent;\n\n        // Null out the originalRoot.left\n        originalRoot.left = 0;\n\n        if (originalRoot.parent != 0) {\n            // If the order has a parent, update the correct child to point\n            // at the newRoot now.\n            Order storage parent = index.orders[originalRoot.parent];\n\n            if (parent.left == originalRoot.data.id) {\n                parent.left = newRoot.data.id;\n            }\n            if (parent.right == originalRoot.data.id) {\n                parent.right = newRoot.data.id;\n            }\n        }\n\n        if (newRoot.right != 0) {\n            Order storage rightChild = index.orders[newRoot.right];\n            originalRoot.left = newRoot.right;\n            rightChild.parent = originalRoot.data.id;\n        }\n\n        // Update the new root's right order to point to the original order.\n        originalRoot.parent = newRoot.data.id;\n        newRoot.right = originalRoot.data.id;\n\n        if (newRoot.parent == 0) {\n            index.root = newRoot.data.id;\n        }\n\n        // Recompute heights.\n        _updateOrderHeight(index, originalRoot.data.id);\n        _updateOrderHeight(index, newRoot.data.id);\n    }\n}"
    },
    {
      "filename": "knox-contracts/contracts/auction/OrderBook.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Knox Auction Order Book Library\n * @dev based on PiperMerriam's Grove v0.3\n * https://github.com/pipermerriam/ethereum-grove\n */\n\nlibrary OrderBook {\n    struct Index {\n        uint256 head;\n        uint256 length;\n        uint256 root;\n        mapping(uint256 => Order) orders;\n    }\n\n    struct Order {\n        Data data;\n        uint256 parent;\n        uint256 left;\n        uint256 right;\n        uint256 height;\n    }\n\n    struct Data {\n        uint256 id;\n        int128 price64x64;\n        uint256 size;\n        address buyer;\n    }\n\n    /// @dev Retrieve the highest bid in the order book.\n    /// @param index The index that the order is part of.\n    function _head(Index storage index) internal view returns (uint256) {\n        return index.head;\n    }\n\n    /// @dev Retrieve the number of bids in the order book.\n    /// @param index The index that the order is part of.\n    function _length(Index storage index) internal view returns (uint256) {\n        return index.length;\n    }\n\n    /// @dev Retrieve the id, price, size, and buyer for the order.\n    /// @param index The index that the order is part of.\n    /// @param id The id for the order to be looked up.\n    function _getOrderById(Index storage index, uint256 id)\n        internal\n        view\n        returns (Data memory)\n    {\n        return index.orders[id].data;\n    }\n\n    /// @dev Returns the previous bid in descending order.\n    /// @param index The index that the order is part of.\n    /// @param id The id for the order to be looked up.\n    function _getPreviousOrder(Index storage index, uint256 id)\n        internal\n        view\n        returns (uint256)\n    {\n        Order storage currentOrder = index.orders[id];\n\n        if (currentOrder.data.id == 0) {\n            // Unknown order, just return 0;\n            return 0;\n        }\n\n        Order memory child;\n\n        if (currentOrder.left != 0) {\n            // Trace left to latest child in left tree.\n            child = index.orders[currentOrder.left];\n\n            while (child.right != 0) {\n                child = index.orders[child.right];\n            }\n            return child.data.id;\n        }\n\n        if (currentOrder.parent != 0) {\n            // Now we trace back up through parent relationships, looking\n            // for a link where the child is the right child of it's\n            // parent.\n            Order storage parent = index.orders[currentOrder.parent];\n            child = currentOrder;\n\n            while (true) {\n                if (parent.right == child.data.id) {\n                    return parent.data.id;\n                }\n\n                if (parent.parent == 0) {\n                    break;\n                }\n                child = parent;\n                parent = index.orders[parent.parent];\n            }\n        }\n\n        // This is the first order, and has no previous order.\n        return 0;\n    }\n\n    /// @dev Returns the next bid in descending order.\n    /// @param index The index that the order is part of.\n    /// @param id The id for the order to be looked up.\n    function _getNextOrder(Index storage index, uint256 id)\n        internal\n        view\n        returns (uint256)\n    {\n        Order storage currentOrder = index.orders[id];\n\n        if (currentOrder.data.id == 0) {\n            // Unknown order, just return 0;\n            return 0;\n        }\n\n        Order memory child;\n\n        if (currentOrder.right != 0) {\n            // Trace right to earliest child in right tree.\n            child = index.orders[currentOrder.right];\n\n            while (child.left != 0) {\n                child = index.orders[child.left];\n            }\n            return child.data.id;\n        }\n\n        if (currentOrder.parent != 0) {\n            // if the order is the left child of it's parent, then the\n            // parent is the next one.\n            Order storage parent = index.orders[currentOrder.parent];\n            child = currentOrder;\n\n            while (true) {\n                if (parent.left == child.data.id) {\n                    return parent.data.id;\n                }\n\n                if (parent.parent == 0) {\n                    break;\n                }\n                child = parent;\n                parent = index.orders[parent.parent];\n            }\n\n            // Now we need to trace all the way up checking to see if any parent is the\n        }\n\n        // This is the final order.\n        return 0;\n    }\n\n    /// @dev Updates or Inserts the id into the index at its appropriate location based on the price provided.\n    /// @param index The index that the order is part of.\n    // / @param id The unique identifier of the data element the index order will represent.\n    /// @param price64x64 The unit price specified by the buyer.\n    /// @param size The size specified by the buyer.\n    /// @param buyer The buyers wallet address.\n    function _insert(\n        Index storage index,\n        int128 price64x64,\n        uint256 size,\n        address buyer\n    ) internal returns (uint256) {\n        index.length = index.length > 0 ? index.length + 1 : 1;\n        uint256 id = index.length;\n\n        Data memory data = _getOrderById(index, index.head);\n\n        int128 highestPricePaid = data.price64x64;\n\n        if (index.head == 0 || price64x64 > highestPricePaid) {\n            index.head = id;\n        }\n\n        if (index.orders[id].data.id == id) {\n            // A order with this id already exists.  If the price is\n            // the same, then just return early, otherwise, remove it\n            // and reinsert it.\n            if (index.orders[id].data.price64x64 == price64x64) {\n                return id;\n            }\n            _remove(index, id);\n        }\n\n        uint256 previousOrderId = 0;\n\n        if (index.root == 0) {\n            index.root = id;\n        }\n        Order storage currentOrder = index.orders[index.root];\n\n        // Do insertion\n        while (true) {\n            if (currentOrder.data.id == 0) {\n                // This is a new unpopulated order.\n                currentOrder.data.id = id;\n                currentOrder.parent = previousOrderId;\n                currentOrder.data.price64x64 = price64x64;\n                currentOrder.data.size = size;\n                currentOrder.data.buyer = buyer;\n                break;\n            }\n\n            // Set the previous order id.\n            previousOrderId = currentOrder.data.id;\n\n            // The new order belongs in the right subtree\n            if (price64x64 <= currentOrder.data.price64x64) {\n                if (currentOrder.right == 0) {\n                    currentOrder.right = id;\n                }\n                currentOrder = index.orders[currentOrder.right];\n                continue;\n            }\n\n            // The new order belongs in the left subtree.\n            if (currentOrder.left == 0) {\n                currentOrder.left = id;\n            }\n            currentOrder = index.orders[currentOrder.left];\n        }\n\n        // Rebalance the tree\n        _rebalanceTree(index, currentOrder.data.id);\n\n        return id;\n    }\n\n    /// @dev Remove the order for the given unique identifier from the index.\n    /// @param index The index that should be removed\n    /// @param id The unique identifier of the data element to remove.\n    function _remove(Index storage index, uint256 id) internal returns (bool) {\n        index.length = index.length > 0 ? index.length - 1 : 1;\n\n        if (id == index.head) {\n            index.head = _getNextOrder(index, id);\n        }\n\n        Order storage replacementOrder;\n        Order storage parent;\n        Order storage child;\n        uint256 rebalanceOrigin;\n\n        Order storage orderToDelete = index.orders[id];\n\n        if (orderToDelete.data.id != id) {\n            // The id does not exist in the tree.\n            return false;\n        }\n\n        if (orderToDelete.left != 0 || orderToDelete.right != 0) {\n            // This order is not a leaf order and thus must replace itself in\n            // it's tree by either the previous or next order.\n            if (orderToDelete.left != 0) {\n                // This order is guaranteed to not have a right child.\n                replacementOrder = index.orders[\n                    _getPreviousOrder(index, orderToDelete.data.id)\n                ];\n            } else {\n                // This order is guaranteed to not have a left child.\n                replacementOrder = index.orders[\n                    _getNextOrder(index, orderToDelete.data.id)\n                ];\n            }\n            // The replacementOrder is guaranteed to have a parent.\n            parent = index.orders[replacementOrder.parent];\n\n            // Keep note of the location that our tree rebalancing should\n            // start at.\n            rebalanceOrigin = replacementOrder.data.id;\n\n            // Join the parent of the replacement order with any subtree of\n            // the replacement order.  We can guarantee that the replacement\n            // order has at most one subtree because of how getNextOrder and\n            // getPreviousOrder are used.\n            if (parent.left == replacementOrder.data.id) {\n                parent.left = replacementOrder.right;\n                if (replacementOrder.right != 0) {\n                    child = index.orders[replacementOrder.right];\n                    child.parent = parent.data.id;\n                }\n            }\n            if (parent.right == replacementOrder.data.id) {\n                parent.right = replacementOrder.left;\n                if (replacementOrder.left != 0) {\n                    child = index.orders[replacementOrder.left];\n                    child.parent = parent.data.id;\n                }\n            }\n\n            // Now we replace the orderToDelete with the replacementOrder.\n            // This includes parent/child relationships for all of the\n            // parent, the left child, and the right child.\n            replacementOrder.parent = orderToDelete.parent;\n            if (orderToDelete.parent != 0) {\n                parent = index.orders[orderToDelete.parent];\n                if (parent.left == orderToDelete.data.id) {\n                    parent.left = replacementOrder.data.id;\n                }\n                if (parent.right == orderToDelete.data.id) {\n                    parent.right = replacementOrder.data.id;\n                }\n            } else {\n                // If the order we are deleting is the root order update the\n                // index root order pointer.\n                index.root = replacementOrder.data.id;\n            }\n\n            replacementOrder.left = orderToDelete.left;\n            if (orderToDelete.left != 0) {\n                child = index.orders[orderToDelete.left];\n                child.parent = replacementOrder.data.id;\n            }\n\n            replacementOrder.right = orderToDelete.right;\n            if (orderToDelete.right != 0) {\n                child = index.orders[orderToDelete.right];\n                child.parent = replacementOrder.data.id;\n            }\n        } else if (orderToDelete.parent != 0) {\n            // The order being deleted is a leaf order so we only erase it's\n            // parent linkage.\n            parent = index.orders[orderToDelete.parent];\n\n            if (parent.left == orderToDelete.data.id) {\n                parent.left = 0;\n            }\n            if (parent.right == orderToDelete.data.id) {\n                parent.right = 0;\n            }\n\n            // keep note of where the rebalancing should begin.\n            rebalanceOrigin = parent.data.id;\n        } else {\n            // This is both a leaf order and the root order, so we need to\n            // unset the root order pointer.\n            index.root = 0;\n        }\n\n        // Now we zero out all of the fields on the orderToDelete.\n        orderToDelete.data.id = 0;\n        orderToDelete.data.price64x64 = 0;\n        orderToDelete.data.size = 0;\n        orderToDelete.data.buyer = 0x0000000000000000000000000000000000000000;\n        orderToDelete.parent = 0;\n        orderToDelete.left = 0;\n        orderToDelete.right = 0;\n        orderToDelete.height = 0;\n\n        // Walk back up the tree rebalancing\n        if (rebalanceOrigin != 0) {\n            _rebalanceTree(index, rebalanceOrigin);\n        }\n\n        return true;\n    }\n\n    function _rebalanceTree(Index storage index, uint256 id) private {\n        // Trace back up rebalancing the tree and updating heights as\n        // needed..\n        Order storage currentOrder = index.orders[id];\n\n        while (true) {\n            int256 balanceFactor =\n                _getBalanceFactor(index, currentOrder.data.id);\n\n            if (balanceFactor == 2) {\n                // Right rotation (tree is heavy on the left)\n                if (_getBalanceFactor(index, currentOrder.left) == -1) {\n                    // The subtree is leaning right so it need to be\n                    // rotated left before the current order is rotated\n                    // right.\n                    _rotateLeft(index, currentOrder.left);\n                }\n                _rotateRight(index, currentOrder.data.id);\n            }\n\n            if (balanceFactor == -2) {\n                // Left rotation (tree is heavy on the right)\n                if (_getBalanceFactor(index, currentOrder.right) == 1) {\n                    // The subtree is leaning left so it need to be\n                    // rotated right before the current order is rotated\n                    // left.\n                    _rotateRight(index, currentOrder.right);\n                }\n                _rotateLeft(index, currentOrder.data.id);\n            }\n\n            if ((-1 <= balanceFactor) && (balanceFactor <= 1)) {\n                _updateOrderHeight(index, currentOrder.data.id);\n            }\n\n            if (currentOrder.parent == 0) {\n                // Reached the root which may be new due to tree\n                // rotation, so set it as the root and then break.\n                break;\n            }"
    }
  ]
}