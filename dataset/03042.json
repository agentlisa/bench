{
  "Title": "M-8: Missing revert keyword",
  "Content": "# Issue M-8: Missing revert keyword \nSource: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/097-M \n## Found by \nPwnPatrol\n\n## Summary\nMissing `revert` keyword in `functionDelegateCall` bypasses an intended safety check, allowing the function to fail silently.\n\n## Vulnerability Detail\nIn the helper function `functionDelegateCall`, there is a check to confirm that the target being called is a contract.\n\n```solidity\nif (!isContract(target)) Errors.AddressNotContract;\n```\n\nHowever, there is a typo in the check that is missing the `revert` keyword.\n\nAs a result, non-contracts can be submitted as targets, which will cause the delegatecall below to return success (because EVM treats no code as STOP opcode), even though it doesn't do anything.\n\n```solidity\n(bool success, ) = target.delegatecall(data);\nrequire(success, \"CALL_FAILED\");\n```\n\n## Impact\nThe code doesn't accomplish its intended goal of checking to confirm that only contracts are passed as targets, so delegatecalls can silently fail.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/protocol/src/utils/Helpers.sol#L66-L73\n\n```solidity\n    function functionDelegateCall(\n        address target,\n        bytes calldata data\n    ) internal {\n        if (!isContract(target)) Errors.AddressNotContract;\n        (bool success, ) = target.delegatecall(data);\n        require(success, \"CALL_FAILED\");\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd missing `revert` keyword to L70 of Helpers.sol.\n\n```solidity\nif (!isContract(target)) revert Errors.AddressNotContract;\n```\n\n## Sentiment Team\nFixed as recommended. PR [here](https://github.com/sentimentxyz/protocol/pull/227).\n\n## Lead Senior Watson\nConfirmed fix. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/1",
  "Code": [
    {
      "filename": "protocol/src/utils/Helpers.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.15;\n\nimport {Errors} from \"./Errors.sol\";\nimport {IERC20} from \"../interface/tokens/IERC20.sol\";\nimport {IAccount} from \"../interface/core/IAccount.sol\";\n\n/// @author Modified from Rari-Capital/Solmate\nlibrary Helpers {\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amt\n    ) internal {\n        if (!isContract(token)) revert Errors.TokenNotContract();\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amt)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 amt\n    ) internal {\n        if (!isContract(token)) revert Errors.TokenNotContract();\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amt)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\n    }\n\n    function safeTransferEth(address to, uint256 amt) internal {\n        (bool success, ) = to.call{value: amt}(new bytes(0));\n        if(!success) revert Errors.EthTransferFailure();\n    }\n\n    function balanceOf(address token, address owner) internal view returns (uint) {\n        return IERC20(token).balanceOf(owner);\n    }\n\n    function withdrawEth(address account, address to, uint amt) internal {\n        (bool success, ) = IAccount(account).exec(to, amt, new bytes(0));\n        if(!success) revert Errors.EthTransferFailure();\n    }\n\n    function withdraw(address account, address to, address token, uint amt) internal {\n        if (!isContract(token)) revert Errors.TokenNotContract();\n        (bool success, bytes memory data) = IAccount(account).exec(token, 0,\n                abi.encodeWithSelector(IERC20.transfer.selector, to, amt));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(address account, address token, address spender, uint amt) internal {\n        (bool success, bytes memory data) = IAccount(account).exec(token, 0,\n            abi.encodeWithSelector(IERC20.approve.selector, spender, amt));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\n    }\n\n    function isContract(address token) internal view returns (bool) {\n        return token.code.length > 0;\n    }\n\n    function functionDelegateCall(\n        address target,\n        bytes calldata data\n    ) internal {\n        if (!isContract(target)) Errors.AddressNotContract;\n        (bool success, ) = target.delegatecall(data);\n        require(success, \"CALL_FAILED\");\n    }\n}"
    }
  ]
}