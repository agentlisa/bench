{
  "Title": "Using basis points for percentage is not precise enough for realistic use-cases",
  "Content": "# Using basis points for percentage is not precise enough for realistic use-cases\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-08-sparkn/blob/main/src/Distributor.sol#L61\">https://github.com/Cyfrin/2023-08-sparkn/blob/main/src/Distributor.sol#L61</a>\n\n\n## Summary\n\nUsing `10000` for `BASIS_POINTS` is not precise enough for the protocol use case.\n\n## Vulnerability Details\n\nThe `Distributor` contract is intended to be used to distribute its own balance (i.e. prize pool) to recipients. The admin is expected to supply the list of winners, along with their percentage share of the prize pool. The contract will then distribute the prize to the recipients.\n\nHowever, the percentage basis point is defined to be 10000, meaning the smallest possible prize pool denomination is 0.01%. We argue that this is not precise enough.\n- Audit contests (e.g. in Code4rena, Sherlock, Codehawks) have prize pools to tens of thousands of USD worth. A standard contest is usually 50,000 USDC in prize. With 10000 as the basis points, winners can only be denominated to \\$5 of winnings only.\n- SPARKN contest itself has a prize pool of \\$15,000. If any auditor's prize is not divisible by \\$1.5, then it is not possible to fairly distribute the prize for that auditor.\n    - It is common for a contest to have a finding with many duplicates, which payout is less than \\$1.\n    - It is also common for distributing events (e.g. airdrops, prize distribution) to have a percentage not divisible by 0.01\\%.\n\nTherefore it will not be possible to distribute the prize with accuracy in such use-cases.\n\nWhile it is technically possible to distribute the rewards using more than one sponsor transactions and equal number of distribution transactions, it will significantly complicate the reward calculation. In that case it will be better to just use standard ERC20 transferring to the winners, which defeats the purpose of the protocol to begin with. Therefore submitting as high.\n\n## Impact\n\nIt may not be possible to distribute rewards with high enough precision, blocking many realistic use cases.\n\n## Tools Used\n\nManual review\n\n## Recommendations\n\nUse `10**18` for `BASIS_POINTS` instead of the current value, which should be precise enough.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/cllcnja1h0001lc08z7w0orxx",
  "Code": [
    {
      "filename": "src/Distributor.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {ProxyFactory} from \"./ProxyFactory.sol\";\n\n/**\n * @title Distributor contract\n * @notice General ERC20 stable coin tokens, e.g. JPYC, USDC, USDT, DAI, etc, are suppsoed to be used in SPARKN.\n * @notice This contract is used as the implementation of proxy contracts to distribute ERC20 token(e.g. JPYC) to winners\n * @dev The main logic of prize token distribution sits in this contract waiting to be called by factory contract\n * @dev Although the contract is immutable after deployment, If we want to upgrade the implementation contract\n * we can deploy a new one and change the implementation address of proxy contract.\n */\ncontract Distributor {\n    using SafeERC20 for IERC20;\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n\n    error Distributor__InvalidCommissionFee();\n    error Distributor__NoZeroAddress();\n    error Distributor__OnlyFactoryAddressIsAllowed();\n    error Distributor__InvalidTokenAddress();\n    error Distributor__MismatchedArrays();\n    error Distributor__MismatchedPercentages();\n    error Distributor__NoTokenToDistribute();\n\n    //////////////////////////////////////\n    /////// Immutable Variables //////////\n    //////////////////////////////////////\n    /* solhint-disable */\n    uint8 private constant VERSION = 1; // version is 1 for now\n    address private immutable FACTORY_ADDRESS;\n    address private immutable STADIUM_ADDRESS;\n    uint256 private constant COMMISSION_FEE = 500; // this can be changed in the future\n    // a constant value of 10,000 (basis points) = 100%\n    uint256 private constant BASIS_POINTS = 10000;\n\n    // prize distribution event. data is for logging purpose\n    event Distributed(address token, address[] winners, uint256[] percentages, bytes data);\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /// @dev initiate the contract with factory address and other key addresses, fee rate\n    constructor(\n        // uint256 version, // for future use\n        address factoryAddress,\n        address stadiumAddress\n    ) \n    /* solhint-enable */\n    {\n        if (factoryAddress == address(0) || stadiumAddress == address(0)) revert Distributor__NoZeroAddress();\n        FACTORY_ADDRESS = factoryAddress; // initialize with deployed factory address beforehand\n        STADIUM_ADDRESS = stadiumAddress; // official address to receive commission fee\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Distribute token to winners according to the percentages\n     * @dev Only factory contract can call this function\n     * @param token The token address to distribute\n     * @param winners The addresses array of winners\n     * @param percentages The percentages array of winners\n     */\n    function distribute(address token, address[] memory winners, uint256[] memory percentages, bytes memory data)\n        external\n    {\n        if (msg.sender != FACTORY_ADDRESS) {\n            revert Distributor__OnlyFactoryAddressIsAllowed();\n        }\n        _distribute(token, winners, percentages, data);\n    }\n\n    ////////////////////////////////////////////\n    /////// Internal & Private functions ///////\n    ////////////////////////////////////////////\n    /**\n     * @notice An internal function to distribute JPYC to winners\n     * @dev Main logic of distribution is implemented here. The length of winners and percentages must be the same\n     * The token address must be one of the whitelisted tokens\n     * The winners and percentages array are supposed not to be so long, so the loop can stay unbounded\n     * The total percentage must be correct. It must be (100 - COMMITION_FEE).\n     * Finally send the remained token(fee) to STADIUM_ADDRESS with no dust in the contract\n     * @param token The token address\n     * @param winners The addresses of winners\n     * @param percentages The percentages of winners\n     * @param data The data to be logged. It is supposed to be used for showing the realation bbetween winners and proposals.\n     */\n    function _distribute(address token, address[] memory winners, uint256[] memory percentages, bytes memory data)\n        internal\n    {\n        // token address input check\n        if (token == address(0)) revert Distributor__NoZeroAddress();\n        if (!_isWhiteListed(token)) {\n            revert Distributor__InvalidTokenAddress();\n        }\n        // winners and percentages input check\n        if (winners.length == 0 || winners.length != percentages.length) revert Distributor__MismatchedArrays();\n        uint256 percentagesLength = percentages.length;\n        uint256 totalPercentage;\n        for (uint256 i; i < percentagesLength;) {\n            totalPercentage += percentages[i];\n            unchecked {\n                ++i;\n            }\n        }\n        // check if totalPercentage is correct\n        if (totalPercentage != (10000 - COMMISSION_FEE)) {\n            revert Distributor__MismatchedPercentages();\n        }\n        IERC20 erc20 = IERC20(token);\n        uint256 totalAmount = erc20.balanceOf(address(this));\n\n        // if there is no token to distribute, then revert\n        if (totalAmount == 0) revert Distributor__NoTokenToDistribute();\n\n        uint256 winnersLength = winners.length; // cache length\n        for (uint256 i; i < winnersLength;) {\n            uint256 amount = totalAmount * percentages[i] / BASIS_POINTS;\n            erc20.safeTransfer(winners[i], amount);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // send commission fee as well as all the remaining tokens to STADIUM_ADDRESS to avoid dust remaining\n        _commissionTransfer(erc20);\n        emit Distributed(token, winners, percentages, data);\n    }\n\n    /**\n     * @notice Transfer commission fee to STADIUM_ADDRESS\n     * @dev This internal function is called after distribution in `_distribute` function\n     * @param token The token address\n     */\n    function _commissionTransfer(IERC20 token) internal {\n        token.safeTransfer(STADIUM_ADDRESS, token.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Check if the token is whitelisted. calling FACTORY_ADDRESS\n     * @param token The token address\n     * @return true if the token is whitelisted, vice versa\n     */\n    function _isWhiteListed(address token) internal view returns (bool) {\n        return ProxyFactory(FACTORY_ADDRESS).whitelistedTokens(token);\n    }\n\n    ///////////////////////////////////////////\n    /////// Getter pure/view functions ////////\n    ///////////////////////////////////////////\n    /**\n     * @notice returns all the immutable and constant addresses and values\n     * @dev This function is for convenience to check the addresses and values\n     */\n    function getConstants()\n        external\n        view\n        returns (address _FACTORY_ADDRESS, address _STADIUM_ADDRESS, uint256 _COMMISSION_FEE, uint8 _VERSION)\n    {\n        /* solhint-disable */\n        _FACTORY_ADDRESS = FACTORY_ADDRESS;\n        _STADIUM_ADDRESS = STADIUM_ADDRESS;\n        _COMMISSION_FEE = COMMISSION_FEE;\n        _VERSION = VERSION;\n        /* solhint-enable */\n    }\n}"
    }
  ]
}