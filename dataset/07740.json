{
  "Title": "[G-03]  State variables should be cached in stack variables rather than re-reading them from storage",
  "Content": "\nThe instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/OwnableTwoSteps.sol\n\n/// @audit owner on line 87\n91:           emit NewOwner(owner);\n\n/// @audit earliestOwnershipRenouncementTime on line 114\n116:          emit InitiateOwnershipRenouncement(earliestOwnershipRenouncementTime);\n\n```\nhttps://github.com/code-423n4/2022-11-looksrare/blob/e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f/contracts/OwnableTwoSteps.sol#L91\n\n\n```diff\ndiff --git a/contracts/OwnableTwoSteps.sol b/contracts/OwnableTwoSteps.sol\nindex 99d8a7d..366bd03 100644\n--- a/contracts/OwnableTwoSteps.sol\n+++ b/contracts/OwnableTwoSteps.sol\n@@ -84,11 +84,10 @@ abstract contract OwnableTwoSteps is IOwnableTwoSteps {\n         if (ownershipStatus != Status.TransferInProgress) revert TransferNotInProgress();\n         if (msg.sender != potentialOwner) revert WrongPotentialOwner();\n \n-        owner = msg.sender;\n         delete ownershipStatus;\n         delete potentialOwner;\n \n-        emit NewOwner(owner);\n+        emit NewOwner(owner = msg.sender);\n     }\n \n     /**\n@@ -111,9 +110,8 @@ abstract contract OwnableTwoSteps is IOwnableTwoSteps {\n         if (ownershipStatus != Status.NoOngoingTransfer) revert TransferAlreadyInProgress();\n \n         ownershipStatus = Status.RenouncementInProgress;\n-        earliestOwnershipRenouncementTime = block.timestamp + delay;\n \n-        emit InitiateOwnershipRenouncement(earliestOwnershipRenouncementTime);\n+        emit InitiateOwnershipRenouncement(earliestOwnershipRenouncementTime = block.timestamp + delay);\n     }\n \n     /**\n```\n\nNote that the numbers below are wrong due to [this](https://gist.github.com/0xA5DF/cc71e507d45fd51d708b3e8318654ce5) forge bug, where forge doesn't properly track warm/cold slots in tests\n```diff\ndiff --git a/tmp/gas_before b/tmp/gas_after\nindex a3222f9..f393f3c 100644\n--- a/tmp/gas_before\n+++ b/tmp/gas_after\n@@ -174 +174 @@\n-│ confirmOwnershipTransfer                                               ┆ 507             ┆ 2329  ┆ 2379   ┆ 4101  ┆ 3       │\n+│ confirmOwnershipTransfer                                               ┆ 507             ┆ 2328  ┆ 2379   ┆ 4099  ┆ 3       │\n@@ -180 +180 @@\n-│ initiateOwnershipRenouncement                                          ┆ 529             ┆ 27941 ┆ 46039  ┆ 50039 ┆ 7       │\n+│ initiateOwnershipRenouncement                                          ┆ 529             ┆ 27942 ┆ 46042  ┆ 50042 ┆ 7       │\n@@ -346,0 +347 @@\n+Overall gas change: 7 (0.008%)\n```\n\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-11-looksrare",
  "Code": [
    {
      "filename": "contracts/OwnableTwoSteps.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\nimport {IOwnableTwoSteps} from \"./interfaces/IOwnableTwoSteps.sol\";\n\n/**\n * @title OwnableTwoSteps\n * @notice This contract offers transfer of ownership in two steps with potential owner having to confirm the transaction.\n *         Renouncement of the ownership is also a two-step process with a timelock since the next potential owner is address(0).\n */\nabstract contract OwnableTwoSteps is IOwnableTwoSteps {\n    // Address of the current owner\n    address public owner;\n\n    // Address of the potential owner\n    address public potentialOwner;\n\n    // Delay for the timelock (in seconds)\n    uint256 public delay;\n\n    // Earliest ownership renouncement timestamp\n    uint256 public earliestOwnershipRenouncementTime;\n\n    // Ownership status\n    Status public ownershipStatus;\n\n    /**\n     * @notice Modifier to wrap functions for contracts that inherit this contract\n     */\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert NotOwner();\n        }\n        _;\n    }\n\n    /**\n     * @notice Constructor\n     *         Initial owner is the deployment address.\n     *         Delay (for the timelock) must be set by the contract that inherits from this.\n     */\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /**\n     * @notice Cancel transfer of ownership\n     * @dev This function can be used for both cancelling a transfer to a new owner and\n     *      cancelling the renouncement of the ownership.\n     */\n    function cancelOwnershipTransfer() external onlyOwner {\n        if (ownershipStatus == Status.NoOngoingTransfer) revert NoOngoingTransferInProgress();\n\n        if (ownershipStatus == Status.TransferInProgress) {\n            delete potentialOwner;\n        } else if (ownershipStatus == Status.RenouncementInProgress) {\n            delete earliestOwnershipRenouncementTime;\n        }\n\n        delete ownershipStatus;\n\n        emit CancelOwnershipTransfer();\n    }\n\n    /**\n     * @notice Confirm ownership renouncement\n     */\n    function confirmOwnershipRenouncement() external onlyOwner {\n        if (ownershipStatus != Status.RenouncementInProgress) revert RenouncementNotInProgress();\n        if (block.timestamp < earliestOwnershipRenouncementTime) revert RenouncementTooEarly();\n\n        delete earliestOwnershipRenouncementTime;\n        delete owner;\n        delete ownershipStatus;\n\n        emit NewOwner(address(0));\n    }\n\n    /**\n     * @notice Confirm ownership transfer\n     * @dev This function can only be called by the current potential owner.\n     */\n    function confirmOwnershipTransfer() external {\n        if (ownershipStatus != Status.TransferInProgress) revert TransferNotInProgress();\n        if (msg.sender != potentialOwner) revert WrongPotentialOwner();\n\n        owner = msg.sender;\n        delete ownershipStatus;\n        delete potentialOwner;\n\n        emit NewOwner(owner);\n    }\n\n    /**\n     * @notice Initiate transfer of ownership to a new owner\n     * @param newPotentialOwner New potential owner address\n     */\n    function initiateOwnershipTransfer(address newPotentialOwner) external onlyOwner {\n        if (ownershipStatus != Status.NoOngoingTransfer) revert TransferAlreadyInProgress();\n\n        ownershipStatus = Status.TransferInProgress;\n        potentialOwner = newPotentialOwner;\n\n        emit InitiateOwnershipTransfer(owner, newPotentialOwner);\n    }\n\n    /**\n     * @notice Initiate ownership renouncement\n     */\n    function initiateOwnershipRenouncement() external onlyOwner {\n        if (ownershipStatus != Status.NoOngoingTransfer) revert TransferAlreadyInProgress();\n\n        ownershipStatus = Status.RenouncementInProgress;\n        earliestOwnershipRenouncementTime = block.timestamp + delay;\n\n        emit InitiateOwnershipRenouncement(earliestOwnershipRenouncementTime);\n    }\n\n    /**\n     * @notice Set up the timelock delay for renouncing ownership\n     * @param _delay Timelock delay for the owner to confirm renouncing the ownership\n     * @dev This function is expected to be included in the constructor of the contract that inherits this contract.\n     *      If it is not set, there is no timelock to renounce the ownership.\n     */\n    function _setupDelayForRenouncingOwnership(uint256 _delay) internal {\n        delay = _delay;\n    }\n}"
    }
  ]
}