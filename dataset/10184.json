{
  "Title": "[M-04] The assumption that operator == to (user) may not hold leading to failed timelock deposits",
  "Content": "_Submitted by 0xRajeev_\n\nThe contract uses `_msgSender()` to denote an operator who is operating on behalf of the user. This is typically used for meta-transactions where the operator is an intermediary/relayer who may facilitate gas-less transactions on behalf of the user. They may be the same address but it is safer to assume that they may not be.\n\nWhile the code handles this separation of role in most cases, it misses doing so in `timelockDepositTo()` function where it accounts the `_timelockBalances` to the operator address instead of the user specified `to` address. It assumes they are the same. The corresponding usage in `_mintTimelock()` which is called from `withdrawWithTimelockFrom()` uses the user specified 'from' address and not the `_msgSender()`. Therefore the corresponding usage in `timelockDepositTo()` should be the same.\n\nIn the scenario where the operator address != user specified from/to addresses, i.e. meta-transactions, the timelock deposits and withdrawals are made to/from different addresses and so the deposits of timelocked tokens will fail because the operatorâ€™s address does not have the required amount of `_timelockBalances`.\n\nRecommend changing `operator` to `from` on [L281](https://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/PrizePool.sol#L281) of `timelockDepositTo()` and specifying the scenarios where the role of the operator is applicable and document/implement those accordingly.\n\n**[asselstine (PoolTogether) disputed](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/51#issuecomment-868891482):**\n > In the function `timelockDepositTo()` the msg.sender is using their timelocked funds to re-enter the pool.  They can only spend their own funds; they should not be able to spend other user's funds.\n>\n> The warden is saying the `timelockDepositTo` should be callable by anyone and allow them to transfer other user's funds from the timelock back into tickets.  This actually introduces an attack vector.\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/51#issuecomment-907497531):**\n > I think sponsor is misunderstanding warden's concern here. The issue is not that `msg.sender` is being checked, but that `_msgSender` is being checked. Happy to discuss this more if sponsor still disagrees, but I think the concern raised is valid.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-06-pooltogether",
  "Code": [
    {
      "filename": "contracts/PrizePool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/SafeCastUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/introspection/ERC165CheckerUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport \"@pooltogether/fixed-point/contracts/FixedPoint.sol\";\n\nimport \"../external/compound/ICompLike.sol\";\nimport \"../reserve/RegistryInterface.sol\";\nimport \"../reserve/ReserveInterface.sol\";\nimport \"../token/TokenListenerInterface.sol\";\nimport \"../token/TokenListenerLibrary.sol\";\nimport \"../token/ControlledToken.sol\";\nimport \"../token/TokenControllerInterface.sol\";\nimport \"../utils/MappedSinglyLinkedList.sol\";\nimport \"./PrizePoolInterface.sol\";\n\n/// @title Escrows assets and deposits them into a yield source.  Exposes interest to Prize Strategy.  Users deposit and withdraw from this contract to participate in Prize Pool.\n/// @notice Accounting is managed using Controlled Tokens, whose mint and burn functions can only be called by this contract.\n/// @dev Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens\nabstract contract PrizePool is PrizePoolInterface, OwnableUpgradeable, ReentrancyGuardUpgradeable, TokenControllerInterface {\n  using SafeMathUpgradeable for uint256;\n  using SafeCastUpgradeable for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using MappedSinglyLinkedList for MappedSinglyLinkedList.Mapping;\n  using ERC165CheckerUpgradeable for address;\n\n  /// @dev Emitted when an instance is initialized\n  event Initialized(\n    address reserveRegistry,\n    uint256 maxExitFeeMantissa,\n    uint256 maxTimelockDuration\n  );\n\n  /// @dev Event emitted when controlled token is added\n  event ControlledTokenAdded(\n    ControlledTokenInterface indexed token\n  );\n\n  /// @dev Emitted when reserve is captured.\n  event ReserveFeeCaptured(\n    uint256 amount\n  );\n\n  event AwardCaptured(\n    uint256 amount\n  );\n\n  /// @dev Event emitted when assets are deposited\n  event Deposited(\n    address indexed operator,\n    address indexed to,\n    address indexed token,\n    uint256 amount,\n    address referrer\n  );\n\n  /// @dev Event emitted when timelocked funds are re-deposited\n  event TimelockDeposited(\n    address indexed operator,\n    address indexed to,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when interest is awarded to a winner\n  event Awarded(\n    address indexed winner,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when external ERC20s are awarded to a winner\n  event AwardedExternalERC20(\n    address indexed winner,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when external ERC20s are transferred out\n  event TransferredExternalERC20(\n    address indexed to,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when external ERC721s are awarded to a winner\n  event AwardedExternalERC721(\n    address indexed winner,\n    address indexed token,\n    uint256[] tokenIds\n  );\n\n  /// @dev Event emitted when assets are withdrawn instantly\n  event InstantWithdrawal(\n    address indexed operator,\n    address indexed from,\n    address indexed token,\n    uint256 amount,\n    uint256 redeemed,\n    uint256 exitFee\n  );\n\n  /// @dev Event emitted upon a withdrawal with timelock\n  event TimelockedWithdrawal(\n    address indexed operator,\n    address indexed from,\n    address indexed token,\n    uint256 amount,\n    uint256 unlockTimestamp\n  );\n\n  event ReserveWithdrawal(\n    address indexed to,\n    uint256 amount\n  );\n\n  /// @dev Event emitted when timelocked funds are swept back to a user\n  event TimelockedWithdrawalSwept(\n    address indexed operator,\n    address indexed from,\n    uint256 amount,\n    uint256 redeemed\n  );\n\n  /// @dev Event emitted when the Liquidity Cap is set\n  event LiquidityCapSet(\n    uint256 liquidityCap\n  );\n\n  /// @dev Event emitted when the Credit plan is set\n  event CreditPlanSet(\n    address token,\n    uint128 creditLimitMantissa,\n    uint128 creditRateMantissa\n  );\n\n  /// @dev Event emitted when the Prize Strategy is set\n  event PrizeStrategySet(\n    address indexed prizeStrategy\n  );\n\n  /// @dev Emitted when credit is minted\n  event CreditMinted(\n    address indexed user,\n    address indexed token,\n    uint256 amount\n  );\n\n  /// @dev Emitted when credit is burned\n  event CreditBurned(\n    address indexed user,\n    address indexed token,\n    uint256 amount\n  );\n\n  struct CreditPlan {\n    uint128 creditLimitMantissa;\n    uint128 creditRateMantissa;\n  }\n\n  struct CreditBalance {\n    uint192 balance;\n    uint32 timestamp;\n    bool initialized;\n  }\n\n  /// @dev Reserve to which reserve fees are sent\n  RegistryInterface public reserveRegistry;\n\n  /// @dev A linked list of all the controlled tokens\n  MappedSinglyLinkedList.Mapping internal _tokens;\n\n  /// @dev The Prize Strategy that this Prize Pool is bound to.\n  TokenListenerInterface public prizeStrategy;\n\n  /// @dev The maximum possible exit fee fraction as a fixed point 18 number.\n  /// For example, if the maxExitFeeMantissa is \"0.1 ether\", then the maximum exit fee for a withdrawal of 100 Dai will be 10 Dai\n  uint256 public maxExitFeeMantissa;\n\n  /// @dev The maximum possible timelock duration for a timelocked withdrawal (in seconds).\n  uint256 public maxTimelockDuration;\n\n  /// @dev The total funds that are timelocked.\n  uint256 public timelockTotalSupply;\n\n  /// @dev The total funds that have been allocated to the reserve\n  uint256 public reserveTotalSupply;\n\n  /// @dev The total amount of funds that the prize pool can hold.\n  uint256 public liquidityCap;\n\n  /// @dev the The awardable balance\n  uint256 internal _currentAwardBalance;\n\n  /// @dev The timelocked balances for each user\n  mapping(address => uint256) internal _timelockBalances;\n\n  /// @dev The unlock timestamps for each user\n  mapping(address => uint256) internal _unlockTimestamps;\n\n  /// @dev Stores the credit plan for each token.\n  mapping(address => CreditPlan) internal _tokenCreditPlans;\n\n  /// @dev Stores each users balance of credit per token.\n  mapping(address => mapping(address => CreditBalance)) internal _tokenCreditBalances;\n\n  /// @notice Initializes the Prize Pool\n  /// @param _controlledTokens Array of ControlledTokens that are controlled by this Prize Pool.\n  /// @param _maxExitFeeMantissa The maximum exit fee size\n  /// @param _maxTimelockDuration The maximum length of time the withdraw timelock\n  function initialize (\n    RegistryInterface _reserveRegistry,\n    ControlledTokenInterface[] memory _controlledTokens,\n    uint256 _maxExitFeeMantissa,\n    uint256 _maxTimelockDuration\n  )\n    public\n    initializer\n  {\n    require(address(_reserveRegistry) != address(0), \"PrizePool/reserveRegistry-not-zero\");\n    _tokens.initialize();\n    for (uint256 i = 0; i < _controlledTokens.length; i++) {\n      _addControlledToken(_controlledTokens[i]);\n    }\n    __Ownable_init();\n    __ReentrancyGuard_init();\n    _setLiquidityCap(uint256(-1));\n\n    reserveRegistry = _reserveRegistry;\n    maxExitFeeMantissa = _maxExitFeeMantissa;\n    maxTimelockDuration = _maxTimelockDuration;\n\n    emit Initialized(\n      address(_reserveRegistry),\n      maxExitFeeMantissa,\n      maxTimelockDuration\n    );\n  }\n\n  /// @dev Returns the address of the underlying ERC20 asset\n  /// @return The address of the asset\n  function token() external override view returns (address) {\n    return address(_token());\n  }\n\n  /// @dev Returns the total underlying balance of all assets. This includes both principal and interest.\n  /// @return The underlying balance of assets\n  function balance() external returns (uint256) {\n    return _balance();\n  }\n\n  /// @dev Checks with the Prize Pool if a specific token type may be awarded as an external prize\n  /// @param _externalToken The address of the token to check\n  /// @return True if the token may be awarded, false otherwise\n  function canAwardExternal(address _externalToken) external view returns (bool) {\n    return _canAwardExternal(_externalToken);\n  }\n\n  /// @notice Deposits timelocked tokens for a user back into the Prize Pool as another asset.\n  /// @param to The address receiving the tokens\n  /// @param amount The amount of timelocked assets to re-deposit\n  /// @param controlledToken The type of token to be minted in exchange (i.e. tickets or sponsorship)\n  function timelockDepositTo(\n    address to,\n    uint256 amount,\n    address controlledToken\n  )\n    external\n    onlyControlledToken(controlledToken)\n    canAddLiquidity(amount)\n    nonReentrant\n  {\n    address operator = _msgSender();\n    _mint(to, amount, controlledToken, address(0));\n    _timelockBalances[operator] = _timelockBalances[operator].sub(amount);\n    timelockTotalSupply = timelockTotalSupply.sub(amount);\n\n    emit TimelockDeposited(operator, to, controlledToken, amount);\n  }\n\n  /// @notice Deposit assets into the Prize Pool in exchange for tokens\n  /// @param to The address receiving the newly minted tokens\n  /// @param amount The amount of assets to deposit\n  /// @param controlledToken The address of the type of token the user is minting\n  /// @param referrer The referrer of the deposit\n  function depositTo(\n    address to,\n    uint256 amount,\n    address controlledToken,\n    address referrer\n  )\n    external override\n    onlyControlledToken(controlledToken)\n    canAddLiquidity(amount)\n    nonReentrant\n  {\n    address operator = _msgSender();\n\n    _mint(to, amount, controlledToken, referrer);\n\n    _token().safeTransferFrom(operator, address(this), amount);\n    _supply(amount);\n\n    emit Deposited(operator, to, controlledToken, amount, referrer);\n  }\n\n  /// @notice Withdraw assets from the Prize Pool instantly.  A fairness fee may be charged for an early exit.\n  /// @param from The address to redeem tokens from.\n  /// @param amount The amount of tokens to redeem for assets.\n  /// @param controlledToken The address of the token to redeem (i.e. ticket or sponsorship)\n  /// @param maximumExitFee The maximum exit fee the caller is willing to pay.  This should be pre-calculated by the calculateExitFee() fxn.\n  /// @return The actual exit fee paid\n  function withdrawInstantlyFrom(\n    address from,\n    uint256 amount,\n    address controlledToken,\n    uint256 maximumExitFee\n  )\n    external override\n    nonReentrant\n    onlyControlledToken(controlledToken)\n    returns (uint256)\n  {\n    (uint256 exitFee, uint256 burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);\n    require(exitFee <= maximumExitFee, \"PrizePool/exit-fee-exceeds-user-maximum\");\n\n    // burn the credit\n    _burnCredit(from, controlledToken, burnedCredit);\n\n    // burn the tickets\n    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);\n\n    // redeem the tickets less the fee\n    uint256 amountLessFee = amount.sub(exitFee);\n    uint256 redeemed = _redeem(amountLessFee);\n\n    _token().safeTransfer(from, redeemed);\n\n    emit InstantWithdrawal(_msgSender(), from, controlledToken, amount, redeemed, exitFee);\n\n    return exitFee;\n  }\n\n  /// @notice Limits the exit fee to the maximum as hard-coded into the contract\n  /// @param withdrawalAmount The amount that is attempting to be withdrawn\n  /// @param exitFee The exit fee to check against the limit\n  /// @return The passed exit fee if it is less than the maximum, otherwise the maximum fee is returned.\n  function _limitExitFee(uint256 withdrawalAmount, uint256 exitFee) internal view returns (uint256) {\n    uint256 maxFee = FixedPoint.multiplyUintByMantissa(withdrawalAmount, maxExitFeeMantissa);\n    if (exitFee > maxFee) {\n      exitFee = maxFee;\n    }\n    return exitFee;\n  }\n\n  /// @notice Withdraw assets from the Prize Pool by placing them into the timelock.\n  /// The timelock is used to ensure that the tickets have contributed their fair share of the prize.\n  /// @dev Note that if the user has previously timelocked funds then this contract will try to sweep them.\n  /// If the existing timelocked funds are still locked, then the incoming\n  /// balance is added to their existing balance and the new timelock unlock timestamp will overwrite the old one.\n  /// @param from The address to withdraw from\n  /// @param amount The amount to withdraw\n  /// @param controlledToken The type of token being withdrawn\n  /// @return The timestamp from which the funds can be swept\n  function withdrawWithTimelockFrom(\n    address from,\n    uint256 amount,\n    address controlledToken\n  )\n    external override\n    nonReentrant\n    onlyControlledToken(controlledToken)\n    returns (uint256)\n  {\n    uint256 blockTime = _currentTime();\n    (uint256 lockDuration, uint256 burnedCredit) = _calculateTimelockDuration(from, controlledToken, amount);\n    uint256 unlockTimestamp = blockTime.add(lockDuration);\n    _burnCredit(from, controlledToken, burnedCredit);\n    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);\n    _mintTimelock(from, amount, unlockTimestamp);\n    emit TimelockedWithdrawal(_msgSender(), from, controlledToken, amount, unlockTimestamp);\n\n    // return the block at which the funds will be available\n    return unlockTimestamp;\n  }\n\n  /// @notice Adds to a user's timelock balance.  It will attempt to sweep before updating the balance.\n  /// Note that this will overwrite the previous unlock timestamp.\n  /// @param user The user whose timelock balance should increase\n  /// @param amount The amount to increase by\n  /// @param timestamp The new unlock timestamp\n  function _mintTimelock(address user, uint256 amount, uint256 timestamp) internal {\n    // Sweep the old balance, if any\n    address[] memory users = new address[](1);\n    users[0] = user;\n    _sweepTimelockBalances(users);\n\n    timelockTotalSupply = timelockTotalSupply.add(amount);\n    _timelockBalances[user] = _timelockBalances[user].add(amount);\n    _unlockTimestamps[user] = timestamp;\n\n    // if the funds should already be unlocked\n    if (timestamp <= _currentTime()) {\n      _sweepTimelockBalances(users);\n    }\n  }\n\n  /// @notice Updates the Prize Strategy when tokens are transferred between holders.\n  /// @param from The address the tokens are being transferred from (0 if minting)\n  /// @param to The address the tokens are being transferred to (0 if burning)\n  /// @param amount The amount of tokens being trasferred\n  function beforeTokenTransfer(address from, address to, uint256 amount) external override onlyControlledToken(msg.sender) {\n    if (from != address(0)) {\n      uint256 fromBeforeBalance = IERC20Upgradeable(msg.sender).balanceOf(from);\n      // first accrue credit for their old balance\n      uint256 newCreditBalance = _calculateCreditBalance(from, msg.sender, fromBeforeBalance, 0);\n\n      if (from != to) {\n        // if they are sending funds to someone else, we need to limit their accrued credit to their new balance\n        newCreditBalance = _applyCreditLimit(msg.sender, fromBeforeBalance.sub(amount), newCreditBalance);\n      }\n\n      _updateCreditBalance(from, msg.sender, newCreditBalance);\n    }\n    if (to != address(0) && to != from) {\n      _accrueCredit(to, msg.sender, IERC20Upgradeable(msg.sender).balanceOf(to), 0);\n    }\n    // if we aren't minting\n    if (from != address(0) && address(prizeStrategy) != address(0)) {\n      prizeStrategy.beforeTokenTransfer(from, to, amount, msg.sender);\n    }\n  }\n\n  /// @notice Returns the balance that is available to award.\n  /// @dev captureAwardBalance() should be called first\n  /// @return The total amount of assets to be awarded for the current prize\n  function awardBalance() external override view returns (uint256) {\n    return _currentAwardBalance;\n  }\n\n  /// @notice Captures any available interest as award balance.\n  /// @dev This function also captures the reserve fees.\n  /// @return The total amount of assets to be awarded for the current prize\n  function captureAwardBalance() external override nonReentrant returns (uint256) {\n    uint256 tokenTotalSupply = _tokenTotalSupply();\n\n    // it's possible for the balance to be slightly less due to rounding errors in the underlying yield source\n    uint256 currentBalance = _balance();\n    uint256 totalInterest = (currentBalance > tokenTotalSupply) ? currentBalance.sub(tokenTotalSupply) : 0;\n    uint256 unaccountedPrizeBalance = (totalInterest > _currentAwardBalance) ? totalInterest.sub(_currentAwardBalance) : 0;\n\n    if (unaccountedPrizeBalance > 0) {\n      uint256 reserveFee = calculateReserveFee(unaccountedPrizeBalance);\n      if (reserveFee > 0) {\n        reserveTotalSupply = reserveTotalSupply.add(reserveFee);\n        unaccountedPrizeBalance = unaccountedPrizeBalance.sub(reserveFee);\n        emit ReserveFeeCaptured(reserveFee);\n      }\n      _currentAwardBalance = _currentAwardBalance.add(unaccountedPrizeBalance);\n\n      emit AwardCaptured(unaccountedPrizeBalance);\n    }\n\n    return _currentAwardBalance;\n  }\n\n  function withdrawReserve(address to) external override onlyReserve returns (uint256) {\n\n    uint256 amount = reserveTotalSupply;\n    reserveTotalSupply = 0;\n    uint256 redeemed = _redeem(amount);\n\n    _token().safeTransfer(address(to), redeemed);\n\n    emit ReserveWithdrawal(to, amount);\n\n    return redeemed;\n  }\n\n  /// @notice Called by the prize strategy to award prizes.\n  /// @dev The amount awarded must be less than the awardBalance()\n  /// @param to The address of the winner that receives the award\n  /// @param amount The amount of assets to be awarded\n  /// @param controlledToken The address of the asset token being awarded\n  function award(\n    address to,\n    uint256 amount,\n    address controlledToken\n  )\n    external override\n    onlyPrizeStrategy\n    onlyControlledToken(controlledToken)\n  {\n    if (amount == 0) {\n      return;\n    }\n\n    require(amount <= _currentAwardBalance, \"PrizePool/award-exceeds-avail\");\n    _currentAwardBalance = _currentAwardBalance.sub(amount);\n\n    _mint(to, amount, controlledToken, address(0));\n\n    uint256 extraCredit = _calculateEarlyExitFeeNoCredit(controlledToken, amount);\n    _accrueCredit(to, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(to), extraCredit);\n\n    emit Awarded(to, controlledToken, amount);\n  }\n\n  /// @notice Called by the Prize-Strategy to transfer out external ERC20 tokens\n  /// @dev Used to transfer out tokens held by the Prize Pool.  Could be liquidated, or anything.\n  /// @param to The address of the winner that receives the award\n  /// @param amount The amount of external assets to be awarded\n  /// @param externalToken The address of the external asset token being awarded\n  function transferExternalERC20(\n    address to,\n    address externalToken,\n    uint256 amount\n  )\n    external override\n    onlyPrizeStrategy\n  {\n    if (_transferOut(to, externalToken, amount)) {\n      emit TransferredExternalERC20(to, externalToken, amount);\n    }\n  }\n\n  /// @notice Called by the Prize-Strategy to award external ERC20 prizes\n  /// @dev Used to award any arbitrary tokens held by the Prize Pool\n  /// @param to The address of the winner that receives the award\n  /// @param amount The amount of external assets to be awarded\n  /// @param externalToken The address of the external asset token being awarded\n  function awardExternalERC20(\n    address to,\n    address externalToken,\n    uint256 amount\n  )\n    external override\n    onlyPrizeStrategy\n  {\n    if (_transferOut(to, externalToken, amount)) {\n      emit AwardedExternalERC20(to, externalToken, amount);\n    }\n  }\n\n  function _transferOut(\n    address to,\n    address externalToken,\n    uint256 amount\n  )\n    internal\n    returns (bool)\n  {\n    require(_canAwardExternal(externalToken), \"PrizePool/invalid-external-token\");\n\n    if (amount == 0) {\n      return false;\n    }\n\n    IERC20Upgradeable(externalToken).safeTransfer(to, amount);\n\n    return true;\n  }\n\n  /// @notice Called to mint controlled tokens.  Ensures that token listener callbacks are fired.\n  /// @param to The user who is receiving the tokens\n  /// @param amount The amount of tokens they are receiving\n  /// @param controlledToken The token that is going to be minted\n  /// @param referrer The user who referred the minting\n  function _mint(address to, uint256 amount, address controlledToken, address referrer) internal {\n    if (address(prizeStrategy) != address(0)) {\n      prizeStrategy.beforeTokenMint(to, amount, controlledToken, referrer);\n    }\n    ControlledToken(controlledToken).controllerMint(to, amount);\n  }\n\n  /// @notice Called by the prize strategy to award external ERC721 prizes\n  /// @dev Used to award any arbitrary NFTs held by the Prize Pool\n  /// @param to The address of the winner that receives the award\n  /// @param externalToken The address of the external NFT token being awarded\n  /// @param tokenIds An array of NFT Token IDs to be transferred\n  function awardExternalERC721(\n    address to,\n    address externalToken,\n    uint256[] calldata tokenIds\n  )\n    external override\n    onlyPrizeStrategy\n  {\n    require(_canAwardExternal(externalToken), \"PrizePool/invalid-external-token\");\n\n    if (tokenIds.length == 0) {\n      return;\n    }\n\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      IERC721Upgradeable(externalToken).transferFrom(address(this), to, tokenIds[i]);\n    }\n\n    emit AwardedExternalERC721(to, externalToken, tokenIds);\n  }\n\n  /// @notice Calculates the reserve portion of the given amount of funds.  If there is no reserve address, the portion will be zero.\n  /// @param amount The prize amount\n  /// @return The size of the reserve portion of the prize\n  function calculateReserveFee(uint256 amount) public view returns (uint256) {\n    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());\n    if (address(reserve) == address(0)) {\n      return 0;\n    }\n    uint256 reserveRateMantissa = reserve.reserveRateMantissa(address(this));\n    if (reserveRateMantissa == 0) {\n      return 0;\n    }\n    return FixedPoint.multiplyUintByMantissa(amount, reserveRateMantissa);\n  }\n\n  /// @notice Sweep all timelocked balances and transfer unlocked assets to owner accounts\n  /// @param users An array of account addresses to sweep balances for\n  /// @return The total amount of assets swept from the Prize Pool\n  function sweepTimelockBalances(\n    address[] calldata users\n  )\n    external override\n    nonReentrant\n    returns (uint256)\n  {\n    return _sweepTimelockBalances(users);\n  }\n\n  /// @notice Sweep available timelocked balances to their owners.  The full balances will be swept to the owners.\n  /// @param users An array of owner addresses\n  /// @return The total amount of assets swept from the Prize Pool\n  function _sweepTimelockBalances(\n    address[] memory users\n  )\n    internal\n    returns (uint256)\n  {\n    address operator = _msgSender();\n\n    uint256[] memory balances = new uint256[](users.length);\n\n    uint256 totalWithdrawal;\n\n    uint256 i;\n    for (i = 0; i < users.length; i++) {\n      address user = users[i];\n      if (_unlockTimestamps[user] <= _currentTime()) {\n        totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);\n        balances[i] = _timelockBalances[user];\n        delete _timelockBalances[user];\n      }\n    }\n\n    // if there is nothing to do, just quit\n    if (totalWithdrawal == 0) {\n      return 0;\n    }\n\n    timelockTotalSupply = timelockTotalSupply.sub(totalWithdrawal);\n\n    uint256 redeemed = _redeem(totalWithdrawal);\n\n    IERC20Upgradeable underlyingToken = IERC20Upgradeable(_token());\n\n    for (i = 0; i < users.length; i++) {\n      if (balances[i] > 0) {\n        delete _unlockTimestamps[users[i]];\n        uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);\n        uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);\n        underlyingToken.safeTransfer(users[i], transferAmount);\n        emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);\n      }\n    }\n\n    return totalWithdrawal;\n  }\n\n  /// @notice Calculates a timelocked withdrawal duration and credit consumption.\n  /// @param from The user who is withdrawing\n  /// @param amount The amount the user is withdrawing\n  /// @param controlledToken The type of collateral the user is withdrawing (i.e. ticket or sponsorship)\n  /// @return durationSeconds The duration of the timelock in seconds\n  function calculateTimelockDuration(\n    address from,\n    address controlledToken,\n    uint256 amount\n  )\n    external override\n    returns (\n      uint256 durationSeconds,\n      uint256 burnedCredit\n    )\n  {\n    return _calculateTimelockDuration(from, controlledToken, amount);\n  }\n\n  /// @dev Calculates a timelocked withdrawal duration and credit consumption.\n  /// @param from The user who is withdrawing\n  /// @param amount The amount the user is withdrawing\n  /// @param controlledToken The type of collateral the user is withdrawing (i.e. ticket or sponsorship)\n  /// @return durationSeconds The duration of the timelock in seconds\n  /// @return burnedCredit The credit that was burned\n  function _calculateTimelockDuration(\n    address from,\n    address controlledToken,\n    uint256 amount\n  )\n    internal\n    returns (\n      uint256 durationSeconds,\n      uint256 burnedCredit\n    )\n  {\n    (uint256 exitFee, uint256 _burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);\n    uint256 duration = _estimateCreditAccrualTime(controlledToken, amount, exitFee);\n    if (duration > maxTimelockDuration) {\n      duration = maxTimelockDuration;\n    }\n    return (duration, _burnedCredit);\n  }\n\n  /// @notice Calculates the early exit fee for the given amount\n  /// @param from The user who is withdrawing\n  /// @param controlledToken The type of collateral being withdrawn\n  /// @param amount The amount of collateral to be withdrawn\n  /// @return exitFee The exit fee\n  /// @return burnedCredit The user's credit that was burned\n  function calculateEarlyExitFee(\n    address from,\n    address controlledToken,\n    uint256 amount\n  )\n    external override\n    returns (\n      uint256 exitFee,\n      uint256 burnedCredit\n    )\n  {\n    return _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);\n  }\n\n  /// @dev Calculates the early exit fee for the given amount\n  /// @param amount The amount of collateral to be withdrawn\n  /// @return Exit fee\n  function _calculateEarlyExitFeeNoCredit(address controlledToken, uint256 amount) internal view returns (uint256) {\n    return _limitExitFee(\n      amount,\n      FixedPoint.multiplyUintByMantissa(amount, _tokenCreditPlans[controlledToken].creditLimitMantissa)\n    );\n  }\n\n  /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit.\n  /// @param _principal The principal amount on which interest is accruing\n  /// @param _interest The amount of interest that must accrue\n  /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.\n  function estimateCreditAccrualTime(\n    address _controlledToken,\n    uint256 _principal,\n    uint256 _interest\n  )\n    external override\n    view\n    returns (uint256 durationSeconds)\n  {\n    return _estimateCreditAccrualTime(\n      _controlledToken,\n      _principal,\n      _interest\n    );\n  }\n\n  /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit\n  /// @param _principal The principal amount on which interest is accruing\n  /// @param _interest The amount of interest that must accrue\n  /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.\n  function _estimateCreditAccrualTime(\n    address _controlledToken,\n    uint256 _principal,\n    uint256 _interest\n  )\n    internal\n    view\n    returns (uint256 durationSeconds)\n  {\n    // interest = credit rate * principal * time\n    // => time = interest / (credit rate * principal)\n    uint256 accruedPerSecond = FixedPoint.multiplyUintByMantissa(_principal, _tokenCreditPlans[_controlledToken].creditRateMantissa);\n    if (accruedPerSecond == 0) {\n      return 0;\n    }\n    return _interest.div(accruedPerSecond);\n  }\n\n  /// @notice Burns a users credit.\n  /// @param user The user whose credit should be burned\n  /// @param credit The amount of credit to burn\n  function _burnCredit(address user, address controlledToken, uint256 credit) internal {\n    _tokenCreditBalances[controlledToken][user].balance = uint256(_tokenCreditBalances[controlledToken][user].balance).sub(credit).toUint128();\n\n    emit CreditBurned(user, controlledToken, credit);\n  }\n\n  /// @notice Accrues ticket credit for a user assuming their current balance is the passed balance.  May burn credit if they exceed their limit.\n  /// @param user The user for whom to accrue credit\n  /// @param controlledToken The controlled token whose balance we are checking\n  /// @param controlledTokenBalance The balance to use for the user\n  /// @param extra Additional credit to be added\n  function _accrueCredit(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal {\n    _updateCreditBalance(\n      user,\n      controlledToken,\n      _calculateCreditBalance(user, controlledToken, controlledTokenBalance, extra)\n    );\n  }\n\n  function _calculateCreditBalance(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal view returns (uint256) {\n    uint256 newBalance;\n    CreditBalance storage creditBalance = _tokenCreditBalances[controlledToken][user];\n    if (!creditBalance.initialized) {\n      newBalance = 0;\n    } else {\n      uint256 credit = _calculateAccruedCredit(user, controlledToken, controlledTokenBalance);\n      newBalance = _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra));\n    }\n    return newBalance;\n  }\n\n  function _updateCreditBalance(address user, address controlledToken, uint256 newBalance) internal {\n    uint256 oldBalance = _tokenCreditBalances[controlledToken][user].balance;\n\n    _tokenCreditBalances[controlledToken][user] = CreditBalance({\n      balance: newBalance.toUint128(),\n      timestamp: _currentTime().toUint32(),\n      initialized: true\n    });\n\n    if (oldBalance < newBalance) {\n      emit CreditMinted(user, controlledToken, newBalance.sub(oldBalance));\n    } else {\n      emit CreditBurned(user, controlledToken, oldBalance.sub(newBalance));\n    }\n  }\n\n  /// @notice Applies the credit limit to a credit balance.  The balance cannot exceed the credit limit.\n  /// @param controlledToken The controlled token that the user holds\n  /// @param controlledTokenBalance The users ticket balance (used to calculate credit limit)\n  /// @param creditBalance The new credit balance to be checked\n  /// @return The users new credit balance.  Will not exceed the credit limit.\n  function _applyCreditLimit(address controlledToken, uint256 controlledTokenBalance, uint256 creditBalance) internal view returns (uint256) {\n    uint256 creditLimit = FixedPoint.multiplyUintByMantissa(\n      controlledTokenBalance,\n      _tokenCreditPlans[controlledToken].creditLimitMantissa\n    );\n    if (creditBalance > creditLimit) {\n      creditBalance = creditLimit;\n    }\n\n    return creditBalance;\n  }\n\n  /// @notice Calculates the accrued interest for a user\n  /// @param user The user whose credit should be calculated.\n  /// @param controlledToken The controlled token that the user holds\n  /// @param controlledTokenBalance The user's current balance of the controlled tokens.\n  /// @return The credit that has accrued since the last credit update.\n  function _calculateAccruedCredit(address user, address controlledToken, uint256 controlledTokenBalance) internal view returns (uint256) {\n    uint256 userTimestamp = _tokenCreditBalances[controlledToken][user].timestamp;\n\n    if (!_tokenCreditBalances[controlledToken][user].initialized) {\n      return 0;\n    }\n\n    uint256 deltaTime = _currentTime().sub(userTimestamp);\n    uint256 creditPerSecond = FixedPoint.multiplyUintByMantissa(controlledTokenBalance, _tokenCreditPlans[controlledToken].creditRateMantissa);\n    return deltaTime.mul(creditPerSecond);\n  }\n\n  /// @notice Returns the credit balance for a given user.  Not that this includes both minted credit and pending credit.\n  /// @param user The user whose credit balance should be returned\n  /// @return The balance of the users credit\n  function bala"
    }
  ]
}