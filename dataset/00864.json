{
  "Title": "H-3: Tokens that are both bribes and StakeDao gauge rewards will cause loss of funds",
  "Content": "# Issue H-3: Tokens that are both bribes and StakeDao gauge rewards will cause loss of funds \n\nSource: https://github.com/sherlock-audit/2023-11-convergence-judging/issues/182 \n\n## Found by \n0x52, GimelSec, detectiveking, lemonmon\n## Summary\n\nWhen SdtStakingPositionService is pulling rewards and bribes from buffer, the buffer will return a list of tokens and amounts owed. This list is used to set the rewards eligible for distribution. Since this list is never check for duplicate tokens, a shared bribe and reward token would cause the token to show up twice in the list. The issue it that _sdtRewardsByCycle is set and not incremented which will cause the second occurrence of the token to overwrite the first and break accounting. The amount of token received from the gauge reward that is overwritten will be lost forever.\n\n## Vulnerability Detail\n\nIn [L559](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Staking/StakeDAO/SdtStakingPositionService.sol#L559) of SdtStakingPositionService it receives a list of tokens and amount from the buffer.\n\n[SdtBuffer.sol#L90-L168](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Rewards/StakeDAO/SdtBuffer.sol#L90-L168)\n\n        ICommonStruct.TokenAmount[] memory bribeTokens = _sdtBlackHole.pullSdStakingBribes(\n            processor,\n            _processorRewardsPercentage\n        );\n\n        uint256 rewardAmount = _gaugeAsset.reward_count();\n\n        ICommonStruct.TokenAmount[] memory tokenAmounts = new ICommonStruct.TokenAmount[](\n            rewardAmount + bribeTokens.length\n        );\n\n        uint256 counter;\n        address _processor = processor;\n        for (uint256 j; j < rewardAmount; ) {\n            IERC20 token = _gaugeAsset.reward_tokens(j);\n            uint256 balance = token.balanceOf(address(this));\n            if (balance != 0) {\n                uint256 fullBalance = balance;\n\n                ...\n\n                token.transfer(sdtRewardsReceiver, balance);\n\n              **@audit token and amount added from reward_tokens pulled directly from gauge**\n\n                tokenAmounts[counter++] = ICommonStruct.TokenAmount({token: token, amount: balance});\n            }\n\n            ...\n\n        }\n\n        for (uint256 j; j < bribeTokens.length; ) {\n            IERC20 token = bribeTokens[j].token;\n            uint256 amount = bribeTokens[j].amount;\n\n          **@audit token and amount added directly with no check for duplicate token**\n\n            if (amount != 0) {\n                tokenAmounts[counter++] = ICommonStruct.TokenAmount({token: token, amount: amount});\n\n            ...\n\n        }\n\nSdtBuffer#pullRewards returns a list of tokens that is a concatenated array of all bribe and reward tokens. There is not controls in place to remove duplicates from this list of tokens. This means that tokens that are both bribes and rewards will be duplicated in the list.\n\n[SdtStakingPositionService.sol#L561-L577](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Staking/StakeDAO/SdtStakingPositionService.sol#L561-L577)\n\n        for (uint256 i; i < _rewardAssets.length; ) {\n            IERC20 _token = _rewardAssets[i].token;\n            uint256 erc20Id = _tokenToId[_token];\n            if (erc20Id == 0) {\n                uint256 _numberOfSdtRewards = ++numberOfSdtRewards;\n                _tokenToId[_token] = _numberOfSdtRewards;\n                erc20Id = _numberOfSdtRewards;\n            }\n\n          **@audit overwrites and doesn't increment causing duplicates to be lost**            \n\n            _sdtRewardsByCycle[_cvgStakingCycle][erc20Id] = ICommonStruct.TokenAmount({\n                token: _token,\n                amount: _rewardAssets[i].amount\n            });\n            unchecked {\n                ++i;\n            }\n        }\n\nWhen storing this list of rewards, it overwrites _sdtRewardsByCycle with the values from the returned array. This is where the problem arises because duplicates will cause the second entry to overwrite the first entry. Since the first instance is overwritten, all funds in the first occurrence will be lost permanently.\n\n## Impact\n\nTokens that are both bribes and rewards will be cause tokens to be lost forever \n\n## Code Snippet\n\n[SdtStakingPositionService.sol#L550-L582](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Staking/StakeDAO/SdtStakingPositionService.sol#L550-L582)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEither sdtBuffer or SdtStakingPositionService should be updated to combine duplicate token entries and prevent overwriting.\n\n\n\n## Discussion\n\n**0xR3vert**\n\nHello,\n\nThanks a lot for your attention.\n\nAbsolutely, if we kill a gauge or change a type weight during the distribution, it would distribute wrong amounts, even though we're not planning to do that. We can make sure it doesn't happen by doing what you said: locking those functions to avoid any problems.\n\nTherefore, in conclusion, we must consider your issue as a valid.\n\nRegards,\nConvergence Team\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/126",
  "Code": [
    {
      "filename": "sherlock-cvg/contracts/Staking/StakeDAO/SdtStakingPositionService.sol",
      "content": "// SPDX-License-Identifier: MIT\n/**\n _____\n/  __ \\\n| /  \\/ ___  _ ____   _____ _ __ __ _  ___ _ __   ___ ___\n| |    / _ \\| '_ \\ \\ / / _ \\ '__/ _` |/ _ \\ '_ \\ / __/ _ \\\n| \\__/\\ (_) | | | \\ V /  __/ | | (_| |  __/ | | | (_|  __/\n \\____/\\___/|_| |_|\\_/ \\___|_|  \\__, |\\___|_| |_|\\___\\___|\n                                 __/ |\n                                |___/\n */\n\n/// @title Cvg-Finance - SdtStakingPositionService\n/// @notice Staking contract of StakeDao integration.\n///         Allow to Stake, Unstake and Claim rewards.\n///         Cvg Rewards are distributed by CvgCycle, each week.\n///         After each Cvg cycle, rewards from SDT can be claimed and distributed to Stakers.\n/// @dev    Tracks staking shares per CvgCycle even for a cycle in the past.\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../interfaces/ICvgControlTower.sol\";\nimport \"../../interfaces/ICrvPoolPlain.sol\";\nimport \"../../interfaces/ICommonStruct.sol\";\n\ncontract SdtStakingPositionService is Ownable2StepUpgradeable {\n    using SafeERC20 for IERC20;\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            STRUCTS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /// @dev defines the information about an NFT\n    struct TokenInfo {\n        uint256 amountStaked;\n        uint256 pendingStaked;\n    }\n\n    struct LastClaimed {\n        uint128 lastClaimedCvg;\n        uint128 lastClaimedSdt;\n    }\n\n    /// @dev defines the information about a CVG cycle\n    struct CycleInfo {\n        uint256 cvgRewardsAmount;\n        uint256 totalStaked;\n        bool isCvgProcessed;\n        bool isSdtProcessed;\n    }\n\n    struct ClaimableCyclesAndAmounts {\n        uint256 cycleClaimable;\n        uint256 cvgRewards;\n        ICommonStruct.TokenAmount[] sdtRewards;\n    }\n\n    struct WithdrawCallInfo {\n        address addr;\n        bytes signature;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            EVENTS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    event Deposit(uint256 indexed tokenId, address account, uint256 cycleId, uint256 amount);\n    event Withdraw(uint256 indexed tokenId, address account, uint256 cycleId, uint256 amount);\n    event CvgCycleProcess(uint256 cycleId, uint256 rewardAmount);\n    event ClaimCvgMultiple(uint256 indexed tokenId, address account);\n\n    event ClaimCvgSdtMultiple(uint256 indexed tokenId, address account);\n    event ProcessSdtRewards(uint256 indexed cycleId, address operator, ICommonStruct.TokenAmount[] tokenAmounts);\n\n    /// @notice Deposits are paused when true\n    bool public depositPaused;\n\n    /// @notice Convergence control tower\n    ICvgControlTower public cvgControlTower;\n\n    /// @notice Cvg token contract\n    ICvg public cvg;\n\n    /// @notice Asset staked through this contract\n    ISdAssetGauge public stakingAsset;\n\n    /// @notice Receiver of all Sdt rewards.\n    ISdtRewardReceiver public sdtRewardReceiver;\n\n    /// @notice Staking position manager.\n    ISdtStakingPositionManager public sdtStakingPositionManager;\n\n    /// @notice Address where stakingAsset is kept during staking.\n    ///         Is the SdtBlackhole except for the CvgSdtStaking where it is this contract\n    address public vault;\n\n    /// @notice Address of the paired buffer accumulating and sending rewards on processSdtRewards call\n    ISdtBuffer public buffer;\n\n    /// @notice Cvg staking cycle for this staking contract\n    uint128 public stakingCycle;\n    /// @notice Maximum amount of rewards claimable through Sdt,\n    ///         is incremented during the processSdtRewards each time a new reward ERC20 is distributed\n    uint128 public numberOfSdtRewards;\n\n    /// @notice Token symbol\n    string public symbol;\n\n    /// @dev Address and signature of the function to call to withdraw the stakingAsset\n    WithdrawCallInfo private withdrawCallInfo;\n\n    mapping(uint256 => CycleInfo) private _cycleInfo; // cycleId => cycleInfos\n\n    /**\n     *  @notice Get the global information of a cycle.\n     *  Contains the total staked and the distributed amount during the {cycleId}.\n     *  Allows to know if rewards have been processed for a cycle or not.\n     * @param cycleId Id of the cycle to get the information\n     * @return Returns a struct containing the totalStaked on a cycle,\n     */\n    function cycleInfo(uint256 cycleId) external view returns (CycleInfo memory) {\n        return _cycleInfo[cycleId];\n    }\n\n    mapping(uint256 => mapping(uint256 => TokenInfo)) private _tokenInfoByCycle; // cycleId => tokenId => tokenInfos\n\n    /**\n     * @notice Returns the information of a Staking position at a specified cycle Id.\n     * @param cycleId Information of the token will be at this cycle\n     * @param tokenId Token Id of the Staking position\n     * @return amountStaked : Amount used in the share computation.\n     *         pendingStaked : Staked amount not yet eligible for rewards, is removed in priority during a withdraw.\n     *         isCvgRewardsClaimed : Allows to know if the position has already claimed the Cvg rewards for this cycle.\n     *         isSdtRewardsClaimed : Allows to know if the position has already claimed the StakeDao rewards for this cycle.\n     */\n    function tokenInfoByCycle(uint256 cycleId, uint256 tokenId) external view returns (TokenInfo memory) {\n        return _tokenInfoByCycle[cycleId][tokenId];\n    }\n\n    mapping(uint256 => uint256[]) private _stakingHistoryByToken; // tokenId => cycleIds\n\n    /** @notice Array of cycleId where staking/withdraw actions occured in the past.\n     * We need this array in order to be able to claim for an old cycle.\n     * @param tokenId Reads the actions history of this Token ID\n     * @param index   Index of the element to return from the history array\n     * @return A Cycle ID\n     */\n    function stakingHistoryByToken(uint256 tokenId, uint256 index) external view returns (uint256) {\n        return _stakingHistoryByToken[tokenId][index];\n    }\n\n    mapping(IERC20 => uint256) private _tokenToId; // tokenAddress => sdtRewardId\n\n    /** @notice Get the Id of the ERC20 distributed during the StakeDao distribution\n     *  @param erc20Address erc20 address of the reward token from StakeDao\n     *  @return Id of the StakeDao reward\n     */\n    function tokenToId(IERC20 erc20Address) external view returns (uint256) {\n        return _tokenToId[erc20Address];\n    }\n\n    mapping(uint256 => mapping(uint256 => ICommonStruct.TokenAmount)) private _sdtRewardsByCycle; // cycleId => sdtRewardId => TokenAmount\n\n    /** @notice Pair of token/amount distributed for all stakers per cycleId per Id of ERC20 SDT rewards.\n     *  @param cycleId         CycleId where the rewards distribution occurred\n     *  @param sdtRewardsIndex Index of the token rewarded\n     *  @return The reward token and its amount\n     */\n    function sdtRewardsByCycle(\n        uint256 cycleId,\n        uint256 sdtRewardsIndex\n    ) external view returns (ICommonStruct.TokenAmount memory) {\n        return _sdtRewardsByCycle[cycleId][sdtRewardsIndex];\n    }\n\n    mapping(uint256 => LastClaimed) private _lastClaims; // tokenId => lastCycleClaimed\n\n    /** @notice Last cycle claimed on a position for Cvg & StakeDao process.\n     *  @param tokenId Id of the position to get the last cycle claimed.\n     *  @return The last cycles where a claimed occured.\n     */\n    function lastClaims(uint256 tokenId) external view returns (LastClaimed memory) {\n        return _lastClaims[tokenId];\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                      CONSTRUCTOR & INIT\n  =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /** @dev Initialize function of the staking contract, can only be called once\n     *  @param _cvgControlTower   Address of the Cvg Control tower\n     *  @param _stakingAsset      Staked asset ( gaugeAsset or CvgSdt )\n     *  @param _symbol            Symbol to display on the NFT\n     *  @param _isGaugeAsset      Allows to define the type of initialization process\n     *  @param _withdrawCallInfo  Function signature and contract to call on withdraw\n     */\n    function initialize(\n        ICvgControlTower _cvgControlTower,\n        ISdAssetGauge _stakingAsset,\n        string memory _symbol,\n        bool _isGaugeAsset,\n        WithdrawCallInfo calldata _withdrawCallInfo\n    ) external initializer {\n        cvgControlTower = _cvgControlTower;\n        require(address(_stakingAsset) != address(0), \"STAKING_ASSET_ZERO\");\n        stakingAsset = _stakingAsset;\n        symbol = _symbol;\n\n        /// @dev If the stakingAsset is a gaugeToken from StakeDao, it means that the creation and the initialization of\n        ///      the contract is done from the CloneFactory and the function createSdtStakingAndBuffer\n        if (_isGaugeAsset) {\n            /// @dev SdtBlackhole receives all staked gaugeAsset for SDT socialization\n            address _sdtBlackHole = address(_cvgControlTower.sdtBlackHole());\n            require(_sdtBlackHole != address(0), \"SDT_BLACKHOLE_ZERO\");\n            vault = _sdtBlackHole;\n        }\n        /// @dev Else the stakingAsset is CvgSdt, we don't create the contract from the CloneFactory but in the classic way\n        else {\n            /// @dev The staking contract itself receives the CvgSdt staked\n            vault = address(this);\n            /// @dev Setup the buffer of the CvgSdtStaking, we don't need to do it for the contracts created from the CloneFactory\n            address _cvgSdtBuffer = address(_cvgControlTower.cvgSdtBuffer());\n            require(_cvgSdtBuffer != address(0), \"CVGSDT_DISTRIBUTOR_ZERO\");\n            buffer = ISdtBuffer(_cvgSdtBuffer);\n        }\n\n        /// @dev Setup the info of the call made during the withdraw\n        withdrawCallInfo = _withdrawCallInfo;\n\n        /// @dev Initialize internal cycle with the cycle from the control tower\n        stakingCycle = _cvgControlTower.cvgCycle();\n\n        /// @dev To prevent the claim of Sdt on the first Cycle of deployment.\n        ///      Staked asset must be staked during a FULL cycle to be eligible to rewards\n        _cycleInfo[stakingCycle].isSdtProcessed = true;\n\n        ICvg _cvg = _cvgControlTower.cvgToken();\n        require(address(_cvg) != address(0), \"CVG_ZERO\");\n        cvg = _cvg;\n\n        ISdtRewardReceiver _sdtRewardReceiver = ISdtRewardReceiver(_cvgControlTower.sdtRewardReceiver());\n        require(address(_sdtRewardReceiver) != address(0), \"SDT_REWARD_RECEIVER_ZERO\");\n        sdtRewardReceiver = _sdtRewardReceiver;\n\n        ISdtStakingPositionManager _sdtStakingPositionManager = _cvgControlTower.sdtStakingPositionManager();\n        require(address(_sdtStakingPositionManager) != address(0), \"SDT_STAKING_MANAGER_ZERO\");\n        sdtStakingPositionManager = _sdtStakingPositionManager;\n\n        address _treasuryDao = _cvgControlTower.treasuryDao();\n        require(_treasuryDao != address(0), \"TREASURY_DAO_ZERO\");\n        _transferOwnership(_treasuryDao);\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                    MODIFIERS & PRE CHECKS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    modifier checkCompliance(uint256 tokenId) {\n        sdtStakingPositionManager.checkTokenFullCompliance(tokenId, msg.sender);\n        _;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        USER EXTERNAL\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /**\n     * @notice Deposit an amount of stakingAsset (gaugeAsset or CvgSdt) into the vault contract.\n     *         Mints a Staking position (tokenId == 0) or increase one owned.\n     *         Staking rewards are claimable after being staked for one full cycle.\n     * @dev Staking at cycle N implies that first rewards will be claimable at the beginning of cycle N+2, then every cycle.\n     * @param tokenId of the staking position\n     * @param amount of stakingAsset to deposit\n     */\n    function deposit(uint256 tokenId, uint256 amount, address operator) external {\n        /// @dev Verify if deposits are paused\n        require(!depositPaused, \"DEPOSIT_PAUSED\");\n        /// @dev Verify if the staked amount is > 0\n        require(amount != 0, \"DEPOSIT_LTE_0\");\n        /// @dev Memorize storage data\n        ICvgControlTower _cvgControlTower = cvgControlTower;\n        ISdtStakingPositionManager _sdtStakingPositionManager = sdtStakingPositionManager;\n        uint256 _cvgStakingCycle = stakingCycle;\n        /// @dev Fetches the receiver, if the caller is the SdtUtilities, we put the initiator of the tx as receiver\n        address receiver = msg.sender == _cvgControlTower.sdtUtilities() ? operator : msg.sender;\n        uint256 _tokenId;\n        /// @dev If tokenId != 0, user deposits for an already existing position, we have so to check ownership\n        if (tokenId != 0) {\n            /// @dev Fetches, for the tokenId, the owner, the StakingPositionService linked to and the timestamp of unlocking\n            _sdtStakingPositionManager.checkIncreaseDepositCompliance(tokenId, receiver);\n            _tokenId = tokenId;\n        }\n        /// @dev Else, we increment the nextId to get the new tokenId\n        else {\n            _tokenId = _sdtStakingPositionManager.nextId();\n        }\n\n        /// @dev Update the CycleInfo & the TokenInfo for the next cycle\n        _updateAmountStakedDeposit(_tokenId, amount, _cvgStakingCycle + 1);\n\n        /// @dev transfers stakingAsset tokens from caller to the vault contract ( SdtBlackhole or CvgSdtStaking )\n        stakingAsset.transferFrom(msg.sender, vault, amount);\n        /// @dev Mints the NFT to the receiver only when tokenId == 0\n        if (tokenId == 0) {\n            _sdtStakingPositionManager.mint(receiver);\n        }\n\n        emit Deposit(_tokenId, receiver, _cvgStakingCycle, amount);\n    }\n\n    /**\n     * @notice Withdraw stakingAsset (sdAsset-gauge or CvgSdt) from the vault to the Staking Position owner.\n     *         Removing rewards before the end of a cycle leads to the loss of all accumulated rewards during this cycle.\n     * @dev Withdrawing always removes first from the staked amount not yet eligible to rewards.\n     * @param tokenId Staking Position to withdraw token from\n     * @param amount Amount of stakingAsset to withdraw\n     */\n    function withdraw(uint256 tokenId, uint256 amount) external checkCompliance(tokenId) {\n        require(amount != 0, \"WITHDRAW_LTE_0\");\n\n        uint256 _cvgStakingCycle = stakingCycle;\n\n        /// @dev Update the CycleInfo & the TokenInfo for the current & next cycle\n        _updateAmountStakedWithdraw(tokenId, amount, _cvgStakingCycle);\n\n        /// @dev Calls in low level the function withdrawing funds from the vault to the user\n        _callWithSignature(amount);\n\n        emit Withdraw(tokenId, msg.sender, _cvgStakingCycle, amount);\n    }\n\n    /**\n     * @notice Claim CVG rewards for a Staking Position on one OR several already passed AND not claimed cycles.\n     * @dev    CVG are minted on the fly to the owner of the Staking Position\n     * @param tokenId   Staking Position id to claim the rewards of.\n     */\n    function claimCvgRewards(uint256 tokenId) external checkCompliance(tokenId) {\n        uint128 actualCycle = stakingCycle;\n\n        uint128 lastClaimedCvg = _lastClaims[tokenId].lastClaimedCvg;\n        uint128 lastClaimedSdt = _lastClaims[tokenId].lastClaimedSdt;\n        /// @dev As claim claimCvgSdtRewards claims always all Cvg on each cycle.\n        ///      If the last claim action is a CvgSdt claim, we consider it also as the last cvg cycle claimed.\n        ///      Else we take the lastClaimed on Cvg.\n        uint128 lastClaimedCycle = lastClaimedCvg < lastClaimedSdt ? lastClaimedSdt : lastClaimedCvg;\n        uint256 lengthHistory = _stakingHistoryByToken[tokenId].length;\n\n        /// @dev If never claimed on this token\n        if (lastClaimedCycle == 0) {\n            /// @dev Get the length of the history\n            lastClaimedCycle = uint128(_stakingHistoryByToken[tokenId][0]);\n        }\n\n        require(actualCycle > lastClaimedCycle, \"ALL_CVG_CLAIMED_FOR_NOW\");\n\n        uint256 _totalAmount;\n        for (; lastClaimedCycle < actualCycle; ) {\n            /// @dev Retrieve the staked amount at the iterated cycle for this Staking position\n            uint256 tokenStaked = _stakedAmountEligibleAtCycle(lastClaimedCycle, tokenId, lengthHistory);\n            uint256 claimableAmount;\n            /// @dev If no staked amount are eligible to rewards on the iterated cycle.\n            if (tokenStaked != 0) {\n                /// @dev Computes the staking share of the Staking Position compare to the total Staked.\n                ///      By multiplying this share by the total CVG distributed for the cycle, we get the claimable amount.\n                claimableAmount =\n                    (tokenStaked * _cycleInfo[lastClaimedCycle].cvgRewardsAmount) /\n                    _cycleInfo[lastClaimedCycle].totalStaked;\n                /// @dev increments the total amount in CVG to mint to the user\n                _totalAmount += claimableAmount;\n            }\n\n            unchecked {\n                ++lastClaimedCycle;\n            }\n        }\n        require(_totalAmount > 0, \"NO_CVG_TO_CLAIM\");\n\n        /// @dev set the cycle as claimed for the NFT\n        _lastClaims[tokenId].lastClaimedCvg = actualCycle;\n\n        /// @dev mint CVG to user\n        cvg.mintStaking(msg.sender, _totalAmount);\n\n        emit ClaimCvgMultiple(tokenId, msg.sender);\n    }\n\n    /**\n     * @notice Claim CVG and SDT rewards for a Staking Position on one OR several already passed AND not claimed cycles.\n     *         Also allows to claim SDT rewards only if CVG rewards\n     * @dev    CVG are minted on the fly to the owner of the Staking Position\n     * @param _tokenId    of the Position to claim the rewards on\n     * @param _isConvert  convert SDT to CvgSdt\n     * @param _isMint     mint 1:1 through CvgSdt if true, swap through stable pool if false\n     */\n    function claimCvgSdtRewards(uint256 _tokenId, bool _isConvert, bool _isMint) external checkCompliance(_tokenId) {\n        (uint256 cvgClaimable, ICommonStruct.TokenAmount[] memory tokenAmounts) = _claimCvgSdtRewards(_tokenId);\n\n        sdtRewardReceiver.claimCvgSdtSimple(msg.sender, cvgClaimable, tokenAmounts, _isConvert, _isMint);\n\n        emit ClaimCvgSdtMultiple(_tokenId, msg.sender);\n    }\n\n    /**\n     * @notice Claim CVG and SDT rewards for a Staking Position on one OR several already passed AND not claimed cycles.\n     *         Also allows to claim SDT rewards only if CVG rewards haven't been already claimed.\n     * @dev    CVG are minted on the fly to the owner of the Staking Position\n     * @param tokenId    of the Position to claim the rewards on\n     * @param operator   used if called by the SdtUtilities, allows to claim of several tokenId at the same time\n     */\n    function claimCvgSdtMultiple(\n        uint256 tokenId,\n        address operator\n    ) external returns (uint256, ICommonStruct.TokenAmount[] memory) {\n        /// @dev Only the SdtRewardReceiver can claim this function.\n        require(msg.sender == address(sdtRewardReceiver), \"NOT_SDT_REWARD_RECEIVER\");\n        (uint256 cvgClaimable, ICommonStruct.TokenAmount[] memory sdtRewards) = _claimCvgSdtRewards(tokenId);\n\n        emit ClaimCvgSdtMultiple(tokenId, operator);\n        return (cvgClaimable, sdtRewards);\n    }\n\n    /**\n     * @notice Claim CVG and SDT rewards for a Staking Position on one OR several already passed AND not claimed cycles.\n     *         Also allows to claim SDT rewards only if CVG rewards\n     * @dev    CVG are minted on the fly to the owner of the Staking Position\n     * @param tokenId    of the Position to claim the rewards on.\n     */\n    function _claimCvgSdtRewards(\n        uint256 tokenId\n    ) internal returns (uint256, ICommonStruct.TokenAmount[] memory tokenAmounts) {\n        uint128 lastClaimedCvg = _lastClaims[tokenId].lastClaimedCvg;\n        uint128 lastClaimedSdt = _lastClaims[tokenId].lastClaimedSdt;\n        uint128 actualCycle = stakingCycle;\n        uint256 lengthHistory = _stakingHistoryByToken[tokenId].length;\n\n        /// @dev If never claimed on this token\n        if (lastClaimedSdt == 0) {\n            /// @dev Set the lastClaimed as the first action.\n            lastClaimedSdt = uint128(_stakingHistoryByToken[tokenId][0]);\n        }\n        require(actualCycle > lastClaimedSdt, \"ALL_SDT_CLAIMED_FOR_NOW\");\n\n        /// @dev Total amount of CVG, accumulated through all cycles and minted at the end of the function\n        uint256 _cvgClaimable;\n\n        uint256 maxLengthRewards = numberOfSdtRewards;\n        /// @dev Array of all rewards from StakeDao, all cycles are accumulated in this array and transfer at the end of the function\n        ICommonStruct.TokenAmount[] memory _totalRewardsClaimable = new ICommonStruct.TokenAmount[](maxLengthRewards);\n\n        uint256 newLastClaimSdt;\n        bool isSdtRewards;\n        for (; lastClaimedSdt < actualCycle; ) {\n            /// @dev Retrieve the amount staked at the iterated cycle for this Staking position.\n            uint256 tokenStaked = _stakedAmountEligibleAtCycle(lastClaimedSdt, tokenId, lengthHistory);\n            /// @dev Retrieve the total amount staked on the iterated cycle.\n            uint256 totalStaked = _cycleInfo[lastClaimedSdt].totalStaked;\n            /// @dev Nothing to claim on this cycle.\n            if (tokenStaked != 0) {\n                /// @dev CVG PART\n                ///      If the CVG rewards haven't been claimed on the iterated cycle\n                if (lastClaimedCvg <= lastClaimedSdt) {\n                    /// @dev Computes the staking share of the Staking Position compared to the total Staked.\n                    ///      By multiplying this share by the total CVG distributed for the cycle, we get the claimable amount.\n                    /// @dev Increments the total amount in CVG to mint to the user\n                    _cvgClaimable += ((tokenStaked * _cycleInfo[lastClaimedSdt].cvgRewardsAmount) / totalStaked);\n                }\n\n                /// @dev StakeDao PART\n                /// @dev We only do the SDT computation when SDT has been processed for the iterated cycle.\n                if (_cycleInfo[lastClaimedSdt].isSdtProcessed) {\n                    for (uint256 erc20Id; erc20Id < maxLengthRewards; ) {\n                        /// @dev Get the ERC20 and the amount distributed on the iterated cycle.\n                        ICommonStruct.TokenAmount memory rewardAsset = _sdtRewardsByCycle[lastClaimedSdt][erc20Id + 1];\n\n                        /// @dev If there is no amount of this rewardAsset distributed on this cycle\n                        if (rewardAsset.amount != 0) {\n                            isSdtRewards = true;\n\n                            /// @dev if the token is set for the first time\n                            if (address(_totalRewardsClaimable[erc20Id].token) == address(0)) {\n                                /// @dev Get the ERC20 and the amount distributed on the iterated cycle\n                                _totalRewardsClaimable[erc20Id].token = rewardAsset.token;\n                            }\n                            /// @dev Computes the staking share of the Staking Position compared to the total Staked.\n                            ///      By multiplying this share by the total of the StakeDao reward distributed for the cycle, we get the claimable amount.\n                            /// @dev increment the total rewarded amount for the iterated ERC20\n                            _totalRewardsClaimable[erc20Id].amount += ((tokenStaked * rewardAsset.amount) /\n                                totalStaked);\n                        }\n                        unchecked {\n                            ++erc20Id;\n                        }\n                    }\n                    newLastClaimSdt = lastClaimedSdt;\n                }\n            }\n\n            unchecked {\n                ++lastClaimedSdt;\n            }\n        }\n\n        require(isSdtRewards, \"NO_SDT_REWARDS_CLAIMABLE\");\n\n        /// @dev Set the last claim for Sdt reward process\n        /// @dev In case a position claims CvgSdt just after a processStakerRewards, before the processSdtRewards.\n        ///      The position has to flag Cvg as claimed until the actual cycle.\n        if (newLastClaimSdt < actualCycle) {\n            _lastClaims[tokenId].lastClaimedCvg = actualCycle;\n        }\n        _lastClaims[tokenId].lastClaimedSdt = uint128(newLastClaimSdt) + 1;\n\n        return (_cvgClaimable, _totalRewardsClaimable);\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                    CYCLE PROCESSING EXTERNAL\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /**\n     * @notice launches the CVG reward process.\n     * @dev    Updates the internal stakingCycle, writes the amount of CVG distributed for the finished cycle and reports the totalStaked on the next cycle.\n     * @param amount Amount of Cvg to distribute as rewards for the current cycle, computed by the CvgRewards\n     */\n    function processStakersRewards(uint256 amount) external {\n        require(msg.sender == address(cvgControlTower.cvgRewards()), \"NOT_CVG_REWARDS\");\n\n        /// @dev Increments the cvg cycle\n        uint256 _cvgStakingCycle = stakingCycle++;\n\n        /// @dev Sets the amount computed by the CvgRewards ( related to Gauge weights ) in the triggered cycle.\n        _cycleInfo[_cvgStakingCycle].cvgRewardsAmount = amount;\n        /// @dev Reports the old totalStaked on the new cycle\n        _cycleInfo[_cvgStakingCycle + 2].totalStaked = _cycleInfo[_cvgStakingCycle + 1].totalStaked;\n        /// @dev Flags this cycle as processed for CVG rewards\n        _cycleInfo[_cvgStakingCycle].isCvgProcessed = true;\n\n        emit CvgCycleProcess(_cvgStakingCycle, amount);\n    }\n\n    /**\n     * @notice Pull Rewards from the paired buffer.\n     *         Associate these rewards to the last cycle.\n     *         Is callable only one time per cycle, after Cvg rewards have been processed.\n     * @dev    We need to wait that processCvgRewards writes the final totalStaked amount on a cycle before processing SDT rewards.\n     *         As we are merging all rewards in the claimCvgSdt & that rewards from buffer may differ, rewards from StakeDao must always be written at the same index.\n     *         We are so incrementing the numberOfSdtRewards for each new token distributed in the StakeDao rewards.\n     */\n    function processSdtRewards() external {\n        /// @dev Retrieve last staking cycle\n        uint256 _cvgStakingCycle = stakingCycle - 1;\n        /// @dev Allows to don't distribute rewards if no stakers was staked for this cycle.\n        require(_cycleInfo[_cvgStakingCycle].totalStaked != 0, \"NO_STAKERS\");\n        require(_cycleInfo[_cvgStakingCycle].isCvgProcessed, \"CVG_CYCLE_NOT_PROCESSED\");\n        require(!_cycleInfo[_cvgStakingCycle].isSdtProcessed, \"SDT_REWARDS_ALREADY_PROCESSED\");\n\n        /// @dev call and returns tokens and amounts returned in rewards by the gauge\n        ICommonStruct.TokenAmount[] memory _rewardAssets = buffer.pullRewards(msg.sender);\n\n        for (uint256 i; i < _rewardAssets.length; ) {\n            IERC20 _token = _rewardAssets[i].token;\n            uint256 erc20Id = _tokenToId[_token];\n            if (erc20Id == 0) {\n                uint256 _numberOfSdtRewards = ++numberOfSdtRewards;\n                _tokenToId[_token] = _numberOfSdtRewards;\n                erc20Id = _numberOfSdtRewards;\n            }\n\n            _sdtRewardsByCycle[_cvgStakingCycle][erc20Id] = ICommonStruct.TokenAmount({\n                token: _token,\n                amount: _rewardAssets[i].amount\n            });\n            unchecked {\n                ++i;\n            }\n        }\n\n        _cycleInfo[_cvgStakingCycle].isSdtProcessed = true;\n\n        emit ProcessSdtRewards(_cvgStakingCycle, msg.sender, _rewardAssets);\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            PUBLIC\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /**\n     *  @notice Finds NFT staked amount eligible for rewards for a specified _cycleId.\n     *          Finds the latest deposit or withdraw (last action) before the given _cycleId to retrieve the staked amount of the NFT at this period\n     *  @param _tokenId  ID of the token to find the staked amount eligible to rewards\n     *  @param _cycleId  Cycle ID  where to find the staked amount eligible to rewards\n     *  @return The staked amount eligible to rewards\n     */\n    function stakedAmountEligibleAtCycle(\n        uint256 _cycleId,\n        uint256 _tokenId,\n        uint256 _actualCycle\n    ) external view returns (uint256) {\n        /// @dev _cycleId be greater or equal than the cycle of the contract\n        if (_cycleId >= _actualCycle) return 0;\n\n        /// @dev if no action has been performed on this position, it means it's not created so returns 0\n        uint256 length = _stakingHistoryByToken[_tokenId].length;\n        if (length == 0) return 0;\n\n        /// @dev If the cycleId is smaller than the first time a staking action occured on\n        if (_cycleId < _stakingHistoryByToken[_tokenId][0]) return 0;\n\n        uint256 historyCycle;\n        /// @dev Finds the cycle of the last first action performed before the {_cycleId}\n        for (uint256 i = length - 1; ; ) {\n            historyCycle = _stakingHistoryByToken[_tokenId][i];\n            if (historyCycle > _cycleId) {\n                unchecked {\n                    --i;\n                }\n            } else {\n                break;\n            }\n        }\n\n        /// @dev Return the amount staked on this cycle\n        return _tokenInfoByCycle[historyCycle][_tokenId].amountStaked;\n    }\n\n    /**\n     *  @dev Finds NFT staked amount eligible for rewards for a specified _cycleId.\n     *          Finds the latest deposit or withdraw (last action) before the given _cycleId to retrieve the staked amount of the NFT at this period\n     *  @param cycleId  ID of the token to find the staked amount eligible to rewards\n     *  @param tokenId  Cycle ID  where to find the staked amount eligible to rewards\n     *  @param lengthHistory  Cycle ID  where to find the staked amount eligible to rewards\n     *  @return The staked amount eligible to rewards\n     */\n    function _stakedAmountEligibleAtCycle(\n        uint256 cycleId,\n        uint256 tokenId,\n        uint256 lengthHistory\n    ) internal view returns (uint256) {\n        uint256 i = lengthHistory - 1;\n        uint256 historyCycle = _stakingHistoryByToken[tokenId][i];\n        /// @dev Finds the cycle of the last first action performed before the {_cycleId}\n        while (historyCycle > cycleId) {\n            historyCycle = _stakingHistoryByToken[tokenId][i];\n            unchecked {\n                --i;\n            }\n        }\n\n        return _tokenInfoByCycle[historyCycle][tokenId].amountStaked;\n    }\n\n    /**\n     *  @notice Retrieves the total amount staked for a Staking Position.\n     *  @dev    Uses the array of all Staking/Withdraw history to retrieve the last staking value updated in case a user doesn't stake/withdraw at each cycle.\n     *  @param _tokenId  Id of the Staking position.\n     *  @return The total amount staked on this position.\n     */\n    function tokenTotalStaked(uint256 _tokenId) public view returns (uint256) {\n        /// @dev Retrieve the amount of cycle with action on it\n        uint256 _cycleLength = _stakingHistoryByToken[_tokenId].length;\n        /// @dev If 0, means that no action has ever been made on this tokenId\n        if (_cycleLength == 0) return 0;\n\n        /// @dev Retrieves the last cycle where an action occured\n        /// @dev Fetches the amount staked on this cycle in tokenInfoByCycle\n        return _tokenInfoByCycle[_stakingHistoryByToken[_tokenId][_cycleLength - 1]][_tokenId].amountStaked;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        INTERNALS/PRIVATES\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /**\n     *  @dev Updates NFT staking information on deposit.\n     *       When a user stakes, it's always linking this staked amount for the next cycle.\n     *       Increase also the total staked amount for the next cycle.\n     *       Tracks also for cycle in the past the amount staked for each positions.\n     *  @param"
    }
  ]
}