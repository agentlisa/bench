{
  "Title": "Queued transfers can become stuck on the source chain if new Transceivers are added or existing Transceivers are modified before completion",
  "Content": "**Description:** When a sender transfers an amount that exceeds the current outbound capacity, such transfers are sent to a queue for delayed execution within [`NttManager::_transferEntrypoint`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManager.sol#L306-L332). The rate limit duration is defined as an immutable variable determining the temporal lag between queueing and execution, with a typical rate limit duration being 24 hours.\n\n```solidity\n/* snip */\n// now check rate limits\nbool isAmountRateLimited = _isOutboundAmountRateLimited(internalAmount);\nif (!shouldQueue && isAmountRateLimited) {\n    revert NotEnoughCapacity(getCurrentOutboundCapacity(), amount);\n}\nif (shouldQueue && isAmountRateLimited) {\n    // emit an event to notify the user that the transfer is rate limited\n    emit OutboundTransferRateLimited(\n        msg.sender, sequence, amount, getCurrentOutboundCapacity()\n    );\n\n    // queue up and return\n    _enqueueOutboundTransfer(\n        sequence,\n        trimmedAmount,\n        recipientChain,\n        recipient,\n        msg.sender,\n        transceiverInstructions\n    );\n\n    // refund price quote back to sender\n    _refundToSender(msg.value);\n\n    // return the sequence in the queue\n    return sequence;\n}\n/* snip */\n```\n\nIn the event that new Transceivers are added or existing Transceivers are removed from the NTT Manager, any pending queued transfers within the rate limit duration can potentially revert. This is because senders might not have correctly packed the Transceiver instructions for a given Transceiver based on the new configuration, and a missing Transceiver instruction can potentially cause an array index out-of-bounds exception while calculating the delivery price when the instructions are [finally parsed](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/NttManager/NttManager.sol#L357-L358). For example, if there are initially two Transceivers but an additional Transceiver is added while the transfer is rate-limited, the instructions array as shown below will be declared with a length of three, corresponding to the new number of enabled Transceivers; however, the transfer will have only encoded two Transceiver instructions based on the configuration at the time it was initiated.\n\n```solidity\nfunction parseTransceiverInstructions(\n    bytes memory encoded,\n    uint256 numEnabledTransceivers\n) public pure returns (TransceiverInstruction[] memory) {\n    uint256 offset = 0;\n    uint256 instructionsLength;\n    (instructionsLength, offset) = encoded.asUint8Unchecked(offset);\n\n    // We allocate an array with the length of the number of enabled transceivers\n    // This gives us the flexibility to not have to pass instructions for transceivers that\n    // don't need them\n    TransceiverInstruction[] memory instructions =\n        new TransceiverInstruction[](numEnabledTransceivers);\n\n    uint256 lastIndex = 0;\n    for (uint256 i = 0; i < instructionsLength; i++) {\n        TransceiverInstruction memory instruction;\n        (instruction, offset) = parseTransceiverInstructionUnchecked(encoded, offset);\n\n        uint8 instructionIndex = instruction.index;\n\n        // The instructions passed in have to be strictly increasing in terms of transceiver index\n        if (i != 0 && instructionIndex <= lastIndex) {\n            revert UnorderedInstructions();\n        }\n        lastIndex = instructionIndex;\n\n        instructions[instructionIndex] = instruction;\n    }\n\n    encoded.checkLength(offset);\n\n    return instructions;\n}\n```\n\n**Impact:** Missing Transceiver instructions prevents the total delivery price for the corresponding message from being calculated. This prevents any queued Transfers from being executed with the current list of transceivers. As a result, underlying sender funds will be stuck in the `NttManager` contract. Note that a similar issue occurs if the peer NTT manager contract is updated on the destination (say, after a redeployment on the source chain) before an in-flight attestation is received and executed, reverting with an invalid peer error.\n\n**Proof of Concept:** Run the following test:\n```solidity\ncontract TestTransceiverModification is Test, INttManagerEvents, IRateLimiterEvents {\n    NttManager nttManagerChain1;\n    NttManager nttManagerChain2;\n\n    using TrimmedAmountLib for uint256;\n    using TrimmedAmountLib for TrimmedAmount;\n\n    uint16 constant chainId1 = 7;\n    uint16 constant chainId2 = 100;\n    uint8 constant FAST_CONSISTENCY_LEVEL = 200;\n    uint256 constant GAS_LIMIT = 500000;\n\n    uint16 constant SENDING_CHAIN_ID = 1;\n    uint256 constant DEVNET_GUARDIAN_PK =\n        0xcfb12303a19cde580bb4dd771639b0d26bc68353645571a8cff516ab2ee113a0;\n    WormholeSimulator guardian;\n    uint256 initialBlockTimestamp;\n\n    WormholeTransceiver wormholeTransceiverChain1;\n    WormholeTransceiver wormholeTransceiver2Chain1;\n    WormholeTransceiver wormholeTransceiver3Chain1;\n\n    WormholeTransceiver wormholeTransceiverChain2;\n    address userA = address(0x123);\n    address userB = address(0x456);\n    address userC = address(0x789);\n    address userD = address(0xABC);\n\n    address relayer = address(0x28D8F1Be96f97C1387e94A53e00eCcFb4E75175a);\n    IWormhole wormhole = IWormhole(0x706abc4E45D419950511e474C7B9Ed348A4a716c);\n\n    function setUp() public {\n        string memory url = \"https://goerli.blockpi.network/v1/rpc/public\";\n        vm.createSelectFork(url);\n        initialBlockTimestamp = vm.getBlockTimestamp();\n\n        guardian = new WormholeSimulator(address(wormhole), DEVNET_GUARDIAN_PK);\n\n        vm.chainId(chainId1);\n        DummyToken t1 = new DummyToken();\n        NttManager implementation =\n            new MockNttManagerContract(address(t1), INttManager.Mode.LOCKING, chainId1, 1 days);\n\n        nttManagerChain1 =\n            MockNttManagerContract(address(new ERC1967Proxy(address(implementation), \"\")));\n        nttManagerChain1.initialize();\n\n        // transceiver 1\n        WormholeTransceiver wormholeTransceiverChain1Implementation = new MockWormholeTransceiverContract(\n            address(nttManagerChain1),\n            address(wormhole),\n            address(relayer),\n            address(0x0),\n            FAST_CONSISTENCY_LEVEL,\n            GAS_LIMIT\n        );\n        wormholeTransceiverChain1 = MockWormholeTransceiverContract(\n            address(new ERC1967Proxy(address(wormholeTransceiverChain1Implementation), \"\"))\n        );\n\n        // transceiver 2\n        WormholeTransceiver wormholeTransceiverChain1Implementation2 = new MockWormholeTransceiverContract(\n            address(nttManagerChain1),\n            address(wormhole),\n            address(relayer),\n            address(0x0),\n            FAST_CONSISTENCY_LEVEL,\n            GAS_LIMIT\n        );\n        wormholeTransceiver2Chain1 = MockWormholeTransceiverContract(\n            address(new ERC1967Proxy(address(wormholeTransceiverChain1Implementation2), \"\"))\n        );\n\n        // transceiver 3\n        WormholeTransceiver wormholeTransceiverChain1Implementation3 = new MockWormholeTransceiverContract(\n            address(nttManagerChain1),\n            address(wormhole),\n            address(relayer),\n            address(0x0),\n            FAST_CONSISTENCY_LEVEL,\n            GAS_LIMIT\n        );\n        wormholeTransceiver3Chain1 = MockWormholeTransceiverContract(\n            address(new ERC1967Proxy(address(wormholeTransceiverChain1Implementation3), \"\"))\n        );\n\n\n        // Actually initialize properly now\n        wormholeTransceiverChain1.initialize();\n        wormholeTransceiver2Chain1.initialize();\n        wormholeTransceiver3Chain1.initialize();\n\n\n        nttManagerChain1.setTransceiver(address(wormholeTransceiverChain1));\n        nttManagerChain1.setTransceiver(address(wormholeTransceiver2Chain1));\n\n        // third transceiver is NOT set at this point for nttManagerChain1\n        nttManagerChain1.setOutboundLimit(type(uint64).max);\n        nttManagerChain1.setInboundLimit(type(uint64).max, chainId2);\n\n        // Chain 2 setup\n        vm.chainId(chainId2);\n        DummyToken t2 = new DummyTokenMintAndBurn();\n        NttManager implementationChain2 =\n            new MockNttManagerContract(address(t2), INttManager.Mode.BURNING, chainId2, 1 days);\n\n        nttManagerChain2 =\n            MockNttManagerContract(address(new ERC1967Proxy(address(implementationChain2), \"\")));\n        nttManagerChain2.initialize();\n\n        WormholeTransceiver wormholeTransceiverChain2Implementation = new MockWormholeTransceiverContract(\n            address(nttManagerChain2),\n            address(wormhole),\n            address(relayer),\n            address(0x0),\n            FAST_CONSISTENCY_LEVEL,\n            GAS_LIMIT\n        );\n\n        wormholeTransceiverChain2 = MockWormholeTransceiverContract(\n            address(new ERC1967Proxy(address(wormholeTransceiverChain2Implementation), \"\"))\n        );\n        wormholeTransceiverChain2.initialize();\n\n        nttManagerChain2.setTransceiver(address(wormholeTransceiverChain2));\n        nttManagerChain2.setOutboundLimit(type(uint64).max);\n        nttManagerChain2.setInboundLimit(type(uint64).max, chainId1);\n\n        // Register peer contracts for the nttManager and transceiver. Transceivers and nttManager each have the concept of peers here.\n        nttManagerChain1.setPeer(chainId2, bytes32(uint256(uint160(address(nttManagerChain2)))), 9);\n        nttManagerChain2.setPeer(chainId1, bytes32(uint256(uint160(address(nttManagerChain1)))), 7);\n\n        // Set peers for the transceivers\n        wormholeTransceiverChain1.setWormholePeer(\n            chainId2, bytes32(uint256(uint160(address(wormholeTransceiverChain2))))\n        );\n\n       wormholeTransceiver2Chain1.setWormholePeer(\n            chainId2, bytes32(uint256(uint160(address(wormholeTransceiverChain2))))\n        );\n\n       wormholeTransceiver3Chain1.setWormholePeer(\n            chainId2, bytes32(uint256(uint160(address(wormholeTransceiverChain2))))\n        );\n\n\n        wormholeTransceiverChain2.setWormholePeer(\n            chainId1, bytes32(uint256(uint160(address(wormholeTransceiverChain1))))\n        );\n\n\n        require(nttManagerChain1.getThreshold() != 0, \"Threshold is zero with active transceivers\");\n\n        // Actually set it\n        nttManagerChain1.setThreshold(2);\n        nttManagerChain2.setThreshold(1);\n    }\n\n    function testTransceiverModification() external {\n        vm.chainId(chainId1);\n\n        // Setting up the transfer\n        DummyToken token1 = DummyToken(nttManagerChain1.token());\n        uint8 decimals = token1.decimals();\n\n        token1.mintDummy(address(userA), 5 * 10 ** decimals);\n        uint256 outboundLimit = 4 * 10 ** decimals;\n        nttManagerChain1.setOutboundLimit(outboundLimit);\n\n        vm.startPrank(userA);\n\n        uint256 transferAmount = 5 * 10 ** decimals;\n        token1.approve(address(nttManagerChain1), transferAmount);\n\n        // transfer with shouldQueue == true\n        uint64 qSeq = nttManagerChain1.transfer(\n            transferAmount, chainId2, toWormholeFormat(userB), true, encodeTransceiverInstructions(true)\n        );\n        vm.stopPrank();\n\n        assertEq(qSeq, 0);\n        IRateLimiter.OutboundQueuedTransfer memory qt = nttManagerChain1.getOutboundQueuedTransfer(0);\n        assertEq(qt.amount.getAmount(), transferAmount.trim(decimals, decimals).getAmount());\n        assertEq(qt.recipientChain, chainId2);\n        assertEq(qt.recipient, toWormholeFormat(userB));\n        assertEq(qt.txTimestamp, initialBlockTimestamp);\n\n        // assert that the contract also locked funds from the user\n        assertEq(token1.balanceOf(address(userA)), 0);\n        assertEq(token1.balanceOf(address(nttManagerChain1)), transferAmount);\n\n\n        // elapse some random time - 60 seconds\n        uint256 durationElapsedTime = initialBlockTimestamp + 60;\n\n        // now add a third transceiver\n        nttManagerChain1.setTransceiver(address(wormholeTransceiver3Chain1));\n\n        // verify that the third transceiver is added\n        assertEq(nttManagerChain1.getTransceivers().length, 3);\n\n        // remove second transceiver\n        nttManagerChain1.removeTransceiver(address(wormholeTransceiver2Chain1));\n\n          // verify that the second transceiver is removed\n        assertEq(nttManagerChain1.getTransceivers().length, 2);\n\n         // elapse rate limit duration\n         durationElapsedTime = initialBlockTimestamp + nttManagerChain1.rateLimitDuration();\n\n        vm.warp(durationElapsedTime);\n\n        vm.expectRevert(stdError.indexOOBError); //index out of bounds - transceiver instructions array does not have a third element to access\n        nttManagerChain1.completeOutboundQueuedTransfer(0);\n    }\n\n    // Encode an instruction for each of the relayers\n  function encodeTransceiverInstructions(bool relayer_off) public view returns (bytes memory) {\n        WormholeTransceiver.WormholeTransceiverInstruction memory instruction =\n            IWormholeTransceiver.WormholeTransceiverInstruction(relayer_off);\n\n        bytes memory encodedInstructionWormhole =\n            wormholeTransceiverChain1.encodeWormholeTransceiverInstruction(instruction);\n\n        TransceiverStructs.TransceiverInstruction memory TransceiverInstruction1 =\n        TransceiverStructs.TransceiverInstruction({index: 0, payload: encodedInstructionWormhole});\n        TransceiverStructs.TransceiverInstruction memory TransceiverInstruction2 =\n        TransceiverStructs.TransceiverInstruction({index: 1, payload: encodedInstructionWormhole});\n\n        TransceiverStructs.TransceiverInstruction[] memory TransceiverInstructions =\n            new TransceiverStructs.TransceiverInstruction[](2);\n\n        TransceiverInstructions[0] = TransceiverInstruction1;\n        TransceiverInstructions[1] = TransceiverInstruction2;\n\n        return TransceiverStructs.encodeTransceiverInstructions(TransceiverInstructions);\n    }\n}\n```\n\n**Recommended Mitigation:** Consider passing no instructions into the delivery price estimation when the Transceiver index does not exist.\n\n**Wormhole Foundation:** Fixed in [PR \\#360](https://github.com/wormhole-foundation/example-native-token-transfers/pull/360).\n\n**Cyfrin:** Verified. The instructions array is now allocated using the number of registered Transceivers rather than the number of enabled Transceivers, fixing the case where Transceivers are enabled/disabled. This also fixes the case where new Transceivers are registered. Since the loop is over the parsed instructions length, those for any newly registered Transceivers will remain the default value (this logic also applies to the standard transfer call).\n\n\\clearpage",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/NttManager/NttManager.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\nimport \"wormhole-solidity-sdk/Utils.sol\";\nimport \"wormhole-solidity-sdk/libraries/BytesParsing.sol\";\n\nimport \"../libraries/RateLimiter.sol\";\n\nimport \"../interfaces/INttManager.sol\";\nimport \"../interfaces/INttManagerEvents.sol\";\nimport \"../interfaces/INTTToken.sol\";\nimport \"../interfaces/ITransceiver.sol\";\n\nimport {NttManagerState} from \"./NttManagerState.sol\";\n\ncontract NttManager is INttManager, NttManagerState {\n    using BytesParsing for bytes;\n    using SafeERC20 for IERC20;\n    using TrimmedAmountLib for uint256;\n    using TrimmedAmountLib for TrimmedAmount;\n\n    constructor(\n        address _token,\n        Mode _mode,\n        uint16 _chainId,\n        uint64 _rateLimitDuration,\n        bool _skipRateLimiting\n    ) NttManagerState(_token, _mode, _chainId, _rateLimitDuration, _skipRateLimiting) {}\n\n    // ==================== External Interface ===============================================\n\n    /// @inheritdoc INttManager\n    function transfer(\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient\n    ) external payable nonReentrant whenNotPaused returns (uint64) {\n        return _transferEntryPoint(amount, recipientChain, recipient, false, new bytes(1));\n    }\n\n    /// @inheritdoc INttManager\n    function transfer(\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        bool shouldQueue,\n        bytes memory transceiverInstructions\n    ) external payable nonReentrant whenNotPaused returns (uint64) {\n        return _transferEntryPoint(\n            amount, recipientChain, recipient, shouldQueue, transceiverInstructions\n        );\n    }\n\n    /// @inheritdoc INttManager\n    function quoteDeliveryPrice(\n        uint16 recipientChain,\n        TransceiverStructs.TransceiverInstruction[] memory transceiverInstructions,\n        address[] memory enabledTransceivers\n    ) public view returns (uint256[] memory, uint256) {\n        uint256 numEnabledTransceivers = enabledTransceivers.length;\n        mapping(address => TransceiverInfo) storage transceiverInfos = _getTransceiverInfosStorage();\n\n        uint256[] memory priceQuotes = new uint256[](numEnabledTransceivers);\n        uint256 totalPriceQuote = 0;\n        for (uint256 i = 0; i < numEnabledTransceivers; i++) {\n            address transceiverAddr = enabledTransceivers[i];\n            uint8 registeredTransceiverIndex = transceiverInfos[transceiverAddr].index;\n            uint256 transceiverPriceQuote = ITransceiver(transceiverAddr).quoteDeliveryPrice(\n                recipientChain, transceiverInstructions[registeredTransceiverIndex]\n            );\n            priceQuotes[i] = transceiverPriceQuote;\n            totalPriceQuote += transceiverPriceQuote;\n        }\n        return (priceQuotes, totalPriceQuote);\n    }\n\n    /// @inheritdoc INttManager\n    function attestationReceived(\n        uint16 sourceChainId,\n        bytes32 sourceNttManagerAddress,\n        TransceiverStructs.NttManagerMessage memory payload\n    ) external onlyTransceiver {\n        _verifyPeer(sourceChainId, sourceNttManagerAddress);\n\n        bytes32 nttManagerMessageHash =\n            TransceiverStructs.nttManagerMessageDigest(sourceChainId, payload);\n\n        // set the attested flag for this transceiver.\n        // NOTE: Attestation is idempotent (bitwise or 1), but we revert\n        // anyway to ensure that the client does not continue to initiate calls\n        // to receive the same message through the same transceiver.\n        if (\n            transceiverAttestedToMessage(\n                nttManagerMessageHash, _getTransceiverInfosStorage()[msg.sender].index\n            )\n        ) {\n            revert TransceiverAlreadyAttestedToMessage(nttManagerMessageHash);\n        }\n        _setTransceiverAttestedToMessage(nttManagerMessageHash, msg.sender);\n\n        if (isMessageApproved(nttManagerMessageHash)) {\n            executeMsg(sourceChainId, sourceNttManagerAddress, payload);\n        }\n    }\n\n    /// @inheritdoc INttManager\n    function executeMsg(\n        uint16 sourceChainId,\n        bytes32 sourceNttManagerAddress,\n        TransceiverStructs.NttManagerMessage memory message\n    ) public {\n        // verify chain has not forked\n        checkFork(evmChainId);\n\n        bytes32 digest = TransceiverStructs.nttManagerMessageDigest(sourceChainId, message);\n\n        if (!isMessageApproved(digest)) {\n            revert MessageNotApproved(digest);\n        }\n\n        bool msgAlreadyExecuted = _replayProtect(digest);\n        if (msgAlreadyExecuted) {\n            // end execution early to mitigate the possibility of race conditions from transceivers\n            // attempting to deliver the same message when (threshold < number of transceiver messages)\n            // notify client (off-chain process) so they don't attempt redundant msg delivery\n            emit MessageAlreadyExecuted(sourceNttManagerAddress, digest);\n            return;\n        }\n\n        TransceiverStructs.NativeTokenTransfer memory nativeTokenTransfer =\n            TransceiverStructs.parseNativeTokenTransfer(message.payload);\n\n        // verify that the destination chain is valid\n        if (nativeTokenTransfer.toChain != chainId) {\n            revert InvalidTargetChain(nativeTokenTransfer.toChain, chainId);\n        }\n        TrimmedAmount memory nativeTransferAmount =\n            (nativeTokenTransfer.amount.untrim(tokenDecimals_)).trim(tokenDecimals_, tokenDecimals_);\n\n        address transferRecipient = fromWormholeFormat(nativeTokenTransfer.to);\n\n        {\n            // Check inbound rate limits\n            bool isRateLimited = _isInboundAmountRateLimited(nativeTransferAmount, sourceChainId);\n            if (isRateLimited) {\n                // queue up the transfer\n                _enqueueInboundTransfer(digest, nativeTransferAmount, transferRecipient);\n\n                // end execution early\n                return;\n            }\n        }\n\n        // consume the amount for the inbound rate limit\n        _consumeInboundAmount(nativeTransferAmount, sourceChainId);\n        // When receiving a transfer, we refill the outbound rate limit\n        // by the same amount (we call this \"backflow\")\n        _backfillOutboundAmount(nativeTransferAmount);\n\n        _mintOrUnlockToRecipient(digest, transferRecipient, nativeTransferAmount);\n    }\n\n    /// @inheritdoc INttManager\n    function completeInboundQueuedTransfer(bytes32 digest) external nonReentrant whenNotPaused {\n        // find the message in the queue\n        InboundQueuedTransfer memory queuedTransfer = getInboundQueuedTransfer(digest);\n        if (queuedTransfer.txTimestamp == 0) {\n            revert InboundQueuedTransferNotFound(digest);\n        }\n\n        // check that > RATE_LIMIT_DURATION has elapsed\n        if (block.timestamp - queuedTransfer.txTimestamp < rateLimitDuration) {\n            revert InboundQueuedTransferStillQueued(digest, queuedTransfer.txTimestamp);\n        }\n\n        // remove transfer from the queue\n        delete _getInboundQueueStorage()[digest];\n\n        // run it through the mint/unlock logic\n        _mintOrUnlockToRecipient(digest, queuedTransfer.recipient, queuedTransfer.amount);\n    }\n\n    /// @inheritdoc INttManager\n    function completeOutboundQueuedTransfer(uint64 messageSequence)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n        returns (uint64)\n    {\n        // find the message in the queue\n        OutboundQueuedTransfer memory queuedTransfer = _getOutboundQueueStorage()[messageSequence];\n        if (queuedTransfer.txTimestamp == 0) {\n            revert OutboundQueuedTransferNotFound(messageSequence);\n        }\n\n        // check that > RATE_LIMIT_DURATION has elapsed\n        if (block.timestamp - queuedTransfer.txTimestamp < rateLimitDuration) {\n            revert OutboundQueuedTransferStillQueued(messageSequence, queuedTransfer.txTimestamp);\n        }\n\n        // remove transfer from the queue\n        delete _getOutboundQueueStorage()[messageSequence];\n\n        // run it through the transfer logic and skip the rate limit\n        return _transfer(\n            messageSequence,\n            queuedTransfer.amount,\n            queuedTransfer.recipientChain,\n            queuedTransfer.recipient,\n            queuedTransfer.sender,\n            queuedTransfer.transceiverInstructions\n        );\n    }\n\n    // ==================== Internal Business Logic =========================================\n\n    function _sendMessageToTransceivers(\n        uint16 recipientChain,\n        uint256[] memory priceQuotes,\n        TransceiverStructs.TransceiverInstruction[] memory transceiverInstructions,\n        address[] memory enabledTransceivers,\n        bytes memory nttManagerMessage\n    ) internal {\n        uint256 numEnabledTransceivers = enabledTransceivers.length;\n        mapping(address => TransceiverInfo) storage transceiverInfos = _getTransceiverInfosStorage();\n        bytes32 peerAddress = _getPeersStorage()[recipientChain].peerAddress;\n        // call into transceiver contracts to send the message\n        for (uint256 i = 0; i < numEnabledTransceivers; i++) {\n            address transceiverAddr = enabledTransceivers[i];\n            // send it to the recipient nttManager based on the chain\n            ITransceiver(transceiverAddr).sendMessage{value: priceQuotes[i]}(\n                recipientChain,\n                transceiverInstructions[transceiverInfos[transceiverAddr].index],\n                nttManagerMessage,\n                peerAddress\n            );\n        }\n    }\n\n    function _transferEntryPoint(\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        bool shouldQueue,\n        bytes memory transceiverInstructions\n    ) internal returns (uint64) {\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n\n        if (recipient == bytes32(0)) {\n            revert InvalidRecipient();\n        }\n\n        {\n            // Lock/burn tokens before checking rate limits\n            // use transferFrom to pull tokens from the user and lock them\n            // query own token balance before transfer\n            uint256 balanceBefore = _getTokenBalanceOf(token, address(this));\n\n            // transfer tokens\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n            // query own token balance after transfer\n            uint256 balanceAfter = _getTokenBalanceOf(token, address(this));\n\n            // correct amount for potential transfer fees\n            amount = balanceAfter - balanceBefore;\n            if (mode == Mode.BURNING) {\n                {\n                    // NOTE: We don't account for burn fees in this code path.\n                    // We verify that the user's change in balance is equal to the amount that's burned.\n                    // Accounting for burn fees can be non-trivial, since there\n                    // is no standard way to account for the fee if the fee amount\n                    // is taken out of the burn amount.\n                    // For example, if there's a fee of 1 which is taken out of the\n                    // amount, then burning 20 tokens would result in a transfer of only 19 tokens.\n                    // However, the difference in the user's balance would only show 20.\n                    // Since there is no standard way to query for burn fee amounts with burnable tokens,\n                    // and NTT would be used on a per-token basis, implementing this functionality\n                    // is left to integrating projects who may need to account for burn fees on their tokens.\n                    ERC20Burnable(token).burn(amount);\n\n                    // tokens held by the contract after the operation should be the same as before\n                    uint256 balanceAfterBurn = _getTokenBalanceOf(token, address(this));\n                    if (balanceBefore != balanceAfterBurn) {\n                        revert BurnAmountDifferentThanBalanceDiff(balanceBefore, balanceAfterBurn);\n                    }\n                }\n            }\n        }\n\n        // trim amount after burning to ensure transfer amount matches (amount - fee)\n        TrimmedAmount memory trimmedAmount = _trimTransferAmount(amount, recipientChain);\n        TrimmedAmount memory internalAmount = trimmedAmount.shift(tokenDecimals_);\n\n        // get the sequence for this transfer\n        uint64 sequence = _useMessageSequence();\n\n        {\n            // now check rate limits\n            bool isAmountRateLimited = _isOutboundAmountRateLimited(internalAmount);\n            if (!shouldQueue && isAmountRateLimited) {\n                revert NotEnoughCapacity(getCurrentOutboundCapacity(), amount);\n            }\n            if (shouldQueue && isAmountRateLimited) {\n                // emit an event to notify the user that the transfer is rate limited\n                emit OutboundTransferRateLimited(\n                    msg.sender, sequence, amount, getCurrentOutboundCapacity()\n                );\n\n                // queue up and return\n                _enqueueOutboundTransfer(\n                    sequence,\n                    trimmedAmount,\n                    recipientChain,\n                    recipient,\n                    msg.sender,\n                    transceiverInstructions\n                );\n\n                // refund price quote back to sender\n                _refundToSender(msg.value);\n\n                // return the sequence in the queue\n                return sequence;\n            }\n        }\n\n        // otherwise, consume the outbound amount\n        _consumeOutboundAmount(internalAmount);\n        // When sending a transfer, we refill the inbound rate limit for\n        // that chain by the same amount (we call this \"backflow\")\n        _backfillInboundAmount(internalAmount, recipientChain);\n\n        return _transfer(\n            sequence, trimmedAmount, recipientChain, recipient, msg.sender, transceiverInstructions\n        );\n    }\n\n    function _transfer(\n        uint64 sequence,\n        TrimmedAmount memory amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        address sender,\n        bytes memory transceiverInstructions\n    ) internal returns (uint64 msgSequence) {\n        // cache enabled transceivers to avoid multiple storage reads\n        address[] memory enabledTransceivers = _getEnabledTransceiversStorage();\n\n        TransceiverStructs.TransceiverInstruction[] memory instructions = TransceiverStructs\n            .parseTransceiverInstructions(transceiverInstructions, enabledTransceivers.length);\n\n        (uint256[] memory priceQuotes, uint256 totalPriceQuote) =\n            quoteDeliveryPrice(recipientChain, instructions, enabledTransceivers);\n        {\n            // check up front that msg.value will cover the delivery price\n            if (msg.value < totalPriceQuote) {\n                revert DeliveryPaymentTooLow(totalPriceQuote, msg.value);\n            }\n\n            // refund user extra excess value from msg.value\n            uint256 excessValue = msg.value - totalPriceQuote;\n            if (excessValue > 0) {\n                _refundToSender(excessValue);\n            }\n        }\n\n        // push it on the stack again to avoid a stack too deep error\n        uint64 seq = sequence;\n\n        TransceiverStructs.NativeTokenTransfer memory ntt = TransceiverStructs.NativeTokenTransfer(\n            amount, toWormholeFormat(token), recipient, recipientChain\n        );\n\n        // construct the NttManagerMessage payload\n        bytes memory encodedNttManagerPayload = TransceiverStructs.encodeNttManagerMessage(\n            TransceiverStructs.NttManagerMessage(\n                seq, toWormholeFormat(sender), TransceiverStructs.encodeNativeTokenTransfer(ntt)\n            )\n        );\n\n        // send the message\n        _sendMessageToTransceivers(\n            recipientChain, priceQuotes, instructions, enabledTransceivers, encodedNttManagerPayload\n        );\n\n        // push it on the stack again to avoid a stack too deep error\n        TrimmedAmount memory amt = amount;\n        uint16 destinationChain = recipientChain;\n\n        emit TransferSent(\n            recipient, amt.untrim(tokenDecimals_), totalPriceQuote, destinationChain, seq\n        );\n\n        // return the sequence number\n        return sequence;\n    }\n\n    function _mintOrUnlockToRecipient(\n        bytes32 digest,\n        address recipient,\n        TrimmedAmount memory amount\n    ) internal {\n        // calculate proper amount of tokens to unlock/mint to recipient\n        // untrim the amount\n        uint256 untrimmedAmount = amount.untrim(tokenDecimals_);\n\n        emit TransferRedeemed(digest);\n\n        if (mode == Mode.LOCKING) {\n            // unlock tokens to the specified recipient\n            IERC20(token).safeTransfer(recipient, untrimmedAmount);\n        } else if (mode == Mode.BURNING) {\n            // mint tokens to the specified recipient\n            INTTToken(token).mint(recipient, untrimmedAmount);\n        } else {\n            revert InvalidMode(uint8(mode));\n        }\n    }\n\n    /// @inheritdoc INttManager\n    function tokenDecimals() public view override(INttManager, RateLimiter) returns (uint8) {\n        return tokenDecimals_;\n    }\n\n    // ==================== Internal Helpers ===============================================\n\n    function _refundToSender(uint256 refundAmount) internal {\n        // refund the price quote back to sender\n        (bool refundSuccessful,) = payable(msg.sender).call{value: refundAmount}(\"\");\n\n        // check success\n        if (!refundSuccessful) {\n            revert RefundFailed(refundAmount);\n        }\n    }\n\n    function _trimTransferAmount(\n        uint256 amount,\n        uint16 toChain\n    ) internal view returns (TrimmedAmount memory) {\n        uint8 toDecimals = _getPeersStorage()[toChain].tokenDecimals;\n\n        if (toDecimals == 0) {\n            revert InvalidPeerDecimals();\n        }\n\n        TrimmedAmount memory trimmedAmount;\n        {\n            trimmedAmount = amount.trim(tokenDecimals_, toDecimals);\n            // don't deposit dust that can not be bridged due to the decimal shift\n            uint256 newAmount = trimmedAmount.untrim(tokenDecimals_);\n            if (amount != newAmount) {\n                revert TransferAmountHasDust(amount, amount - newAmount);\n            }\n        }\n\n        return trimmedAmount;\n    }\n\n    function _getTokenBalanceOf(\n        address tokenAddr,\n        address accountAddr\n    ) internal view returns (uint256) {\n        (, bytes memory queriedBalance) =\n            tokenAddr.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, accountAddr));\n        return abi.decode(queriedBalance, (uint256));\n    }\n}"
    },
    {
      "filename": "evm/src/NttManager/NttManager.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\nimport \"wormhole-solidity-sdk/Utils.sol\";\nimport \"wormhole-solidity-sdk/libraries/BytesParsing.sol\";\n\nimport \"../libraries/RateLimiter.sol\";\n\nimport \"../interfaces/INttManager.sol\";\nimport \"../interfaces/INttManagerEvents.sol\";\nimport \"../interfaces/INTTToken.sol\";\nimport \"../interfaces/ITransceiver.sol\";\n\nimport {NttManagerState} from \"./NttManagerState.sol\";\n\ncontract NttManager is INttManager, NttManagerState {\n    using BytesParsing for bytes;\n    using SafeERC20 for IERC20;\n    using TrimmedAmountLib for uint256;\n    using TrimmedAmountLib for TrimmedAmount;\n\n    constructor(\n        address _token,\n        Mode _mode,\n        uint16 _chainId,\n        uint64 _rateLimitDuration,\n        bool _skipRateLimiting\n    ) NttManagerState(_token, _mode, _chainId, _rateLimitDuration, _skipRateLimiting) {}\n\n    // ==================== External Interface ===============================================\n\n    /// @inheritdoc INttManager\n    function transfer(\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient\n    ) external payable nonReentrant whenNotPaused returns (uint64) {\n        return _transferEntryPoint(amount, recipientChain, recipient, false, new bytes(1));\n    }\n\n    /// @inheritdoc INttManager\n    function transfer(\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        bool shouldQueue,\n        bytes memory transceiverInstructions\n    ) external payable nonReentrant whenNotPaused returns (uint64) {\n        return _transferEntryPoint(\n            amount, recipientChain, recipient, shouldQueue, transceiverInstructions\n        );\n    }\n\n    /// @inheritdoc INttManager\n    function quoteDeliveryPrice(\n        uint16 recipientChain,\n        TransceiverStructs.TransceiverInstruction[] memory transceiverInstructions,\n        address[] memory enabledTransceivers\n    ) public view returns (uint256[] memory, uint256) {\n        uint256 numEnabledTransceivers = enabledTransceivers.length;\n        mapping(address => TransceiverInfo) storage transceiverInfos = _getTransceiverInfosStorage();\n\n        uint256[] memory priceQuotes = new uint256[](numEnabledTransceivers);\n        uint256 totalPriceQuote = 0;\n        for (uint256 i = 0; i < numEnabledTransceivers; i++) {\n            address transceiverAddr = enabledTransceivers[i];\n            uint8 registeredTransceiverIndex = transceiverInfos[transceiverAddr].index;\n            uint256 transceiverPriceQuote = ITransceiver(transceiverAddr).quoteDeliveryPrice(\n                recipientChain, transceiverInstructions[registeredTransceiverIndex]\n            );\n            priceQuotes[i] = transceiverPriceQuote;\n            totalPriceQuote += transceiverPriceQuote;\n        }\n        return (priceQuotes, totalPriceQuote);\n    }\n\n    /// @inheritdoc INttManager\n    function attestationReceived(\n        uint16 sourceChainId,\n        bytes32 sourceNttManagerAddress,\n        TransceiverStructs.NttManagerMessage memory payload\n    ) external onlyTransceiver {\n        _verifyPeer(sourceChainId, sourceNttManagerAddress);\n\n        bytes32 nttManagerMessageHash =\n            TransceiverStructs.nttManagerMessageDigest(sourceChainId, payload);\n\n        // set the attested flag for this transceiver.\n        // NOTE: Attestation is idempotent (bitwise or 1), but we revert\n        // anyway to ensure that the client does not continue to initiate calls\n        // to receive the same message through the same transceiver.\n        if (\n            transceiverAttestedToMessage(\n                nttManagerMessageHash, _getTransceiverInfosStorage()[msg.sender].index\n            )\n        ) {\n            revert TransceiverAlreadyAttestedToMessage(nttManagerMessageHash);\n        }\n        _setTransceiverAttestedToMessage(nttManagerMessageHash, msg.sender);\n\n        if (isMessageApproved(nttManagerMessageHash)) {\n            executeMsg(sourceChainId, sourceNttManagerAddress, payload);\n        }\n    }\n\n    /// @inheritdoc INttManager\n    function executeMsg(\n        uint16 sourceChainId,\n        bytes32 sourceNttManagerAddress,\n        TransceiverStructs.NttManagerMessage memory message\n    ) public {\n        // verify chain has not forked\n        checkFork(evmChainId);\n\n        bytes32 digest = TransceiverStructs.nttManagerMessageDigest(sourceChainId, message);\n\n        if (!isMessageApproved(digest)) {\n            revert MessageNotApproved(digest);\n        }\n\n        bool msgAlreadyExecuted = _replayProtect(digest);\n        if (msgAlreadyExecuted) {\n            // end execution early to mitigate the possibility of race conditions from transceivers\n            // attempting to deliver the same message when (threshold < number of transceiver messages)\n            // notify client (off-chain process) so they don't attempt redundant msg delivery\n            emit MessageAlreadyExecuted(sourceNttManagerAddress, digest);\n            return;\n        }\n\n        TransceiverStructs.NativeTokenTransfer memory nativeTokenTransfer =\n            TransceiverStructs.parseNativeTokenTransfer(message.payload);\n\n        // verify that the destination chain is valid\n        if (nativeTokenTransfer.toChain != chainId) {\n            revert InvalidTargetChain(nativeTokenTransfer.toChain, chainId);\n        }\n        TrimmedAmount memory nativeTransferAmount =\n            (nativeTokenTransfer.amount.untrim(tokenDecimals_)).trim(tokenDecimals_, tokenDecimals_);\n\n        address transferRecipient = fromWormholeFormat(nativeTokenTransfer.to);\n\n        {\n            // Check inbound rate limits\n            bool isRateLimited = _isInboundAmountRateLimited(nativeTransferAmount, sourceChainId);\n            if (isRateLimited) {\n                // queue up the transfer\n                _enqueueInboundTransfer(digest, nativeTransferAmount, transferRecipient);\n\n                // end execution early\n                return;\n            }\n        }\n\n        // consume the amount for the inbound rate limit\n        _consumeInboundAmount(nativeTransferAmount, sourceChainId);\n        // When receiving a transfer, we refill the outbound rate limit\n        // by the same amount (we call this \"backflow\")\n        _backfillOutboundAmount(nativeTransferAmount);\n\n        _mintOrUnlockToRecipient(digest, transferRecipient, nativeTransferAmount);\n    }\n\n    /// @inheritdoc INttManager\n    function completeInboundQueuedTransfer(bytes32 digest) external nonReentrant whenNotPaused {\n        // find the message in the queue\n        InboundQueuedTransfer memory queuedTransfer = getInboundQueuedTransfer(digest);\n        if (queuedTransfer.txTimestamp == 0) {\n            revert InboundQueuedTransferNotFound(digest);\n        }\n\n        // check that > RATE_LIMIT_DURATION has elapsed\n        if (block.timestamp - queuedTransfer.txTimestamp < rateLimitDuration) {\n            revert InboundQueuedTransferStillQueued(digest, queuedTransfer.txTimestamp);\n        }\n\n        // remove transfer from the queue\n        delete _getInboundQueueStorage()[digest];\n\n        // run it through the mint/unlock logic\n        _mintOrUnlockToRecipient(digest, queuedTransfer.recipient, queuedTransfer.amount);\n    }\n\n    /// @inheritdoc INttManager\n    function completeOutboundQueuedTransfer(uint64 messageSequence)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n        returns (uint64)\n    {\n        // find the message in the queue\n        OutboundQueuedTransfer memory queuedTransfer = _getOutboundQueueStorage()[messageSequence];\n        if (queuedTransfer.txTimestamp == 0) {\n            revert OutboundQueuedTransferNotFound(messageSequence);\n        }\n\n        // check that > RATE_LIMIT_DURATION has elapsed\n        if (block.timestamp - queuedTransfer.txTimestamp < rateLimitDuration) {\n            revert OutboundQueuedTransferStillQueued(messageSequence, queuedTransfer.txTimestamp);\n        }\n\n        // remove transfer from the queue\n        delete _getOutboundQueueStorage()[messageSequence];\n\n        // run it through the transfer logic and skip the rate limit\n        return _transfer(\n            messageSequence,\n            queuedTransfer.amount,\n            queuedTransfer.recipientChain,\n            queuedTransfer.recipient,\n            queuedTransfer.sender,\n            queuedTransfer.transceiverInstructions\n        );\n    }\n\n    // ==================== Internal Business Logic =========================================\n\n    function _sendMessageToTransceivers(\n        uint16 recipientChain,\n        uint256[] memory priceQuotes,\n        TransceiverStructs.TransceiverInstruction[] memory transceiverInstructions,\n        address[] memory enabledTransceivers,\n        bytes memory nttManagerMessage\n    ) internal {\n        uint256 numEnabledTransceivers = enabledTransceivers.length;\n        mapping(address => TransceiverInfo) storage transceiverInfos = _getTransceiverInfosStorage();\n        bytes32 peerAddress = _getPeersStorage()[recipientChain].peerAddress;\n        // call into transceiver contracts to send the message\n        for (uint256 i = 0; i < numEnabledTransceivers; i++) {\n            address transceiverAddr = enabledTransceivers[i];\n            // send it to the recipient nttManager based on the chain\n            ITransceiver(transceiverAddr).sendMessage{value: priceQuotes[i]}(\n                recipientChain,\n                transceiverInstructions[transceiverInfos[transceiverAddr].index],\n                nttManagerMessage,\n                peerAddress\n            );\n        }\n    }\n\n    function _transferEntryPoint(\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        bool shouldQueue,\n        bytes memory transceiverInstructions\n    ) internal returns (uint64) {\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n\n        if (recipient == bytes32(0)) {\n            revert InvalidRecipient();\n        }\n\n        {\n            // Lock/burn tokens before checking rate limits\n            // use transferFrom to pull tokens from the user and lock them\n            // query own token balance before transfer\n            uint256 balanceBefore = _getTokenBalanceOf(token, address(this));\n\n            // transfer tokens\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n            // query own token balance after transfer\n            uint256 balanceAfter = _getTokenBalanceOf(token, address(this));\n\n            // correct amount for potential transfer fees\n            amount = balanceAfter - balanceBefore;\n            if (mode == Mode.BURNING) {\n                {\n                    // NOTE: We don't account for burn fees in this code path.\n                    // We verify that the user's change in balance is equal to the amount that's burned.\n                    // Accounting for burn fees can be non-trivial, since there\n                    // is no standard way to account for the fee if the fee amount\n                    // is taken out of the burn amount.\n                    // For example, if there's a fee of 1 which is taken out of the\n                    // amount, then burning 20 tokens would result in a transfer of only 19 tokens.\n                    // However, the difference in the user's balance would only show 20.\n                    // Since there is no standard way to query for burn fee amounts with burnable tokens,\n                    // and NTT would be used on a per-token basis, implementing this functionality\n                    // is left to integrating projects who may need to account for burn fees on their tokens.\n                    ERC20Burnable(token).burn(amount);\n\n                    // tokens held by the contract after the operation should be the same as before\n                    uint256 balanceAfterBurn = _getTokenBalanceOf(token, address(this));\n                    if (balanceBefore != balanceAfterBurn) {\n                        revert BurnAmountDifferentThanBalanceDiff(balanceBefore, balanceAfterBurn);\n                    }\n                }\n            }\n        }\n\n        // trim amount after burning to ensure transfer amount matches (amount - fee)\n        TrimmedAmount memory trimmedAmount = _trimTransferAmount(amount, recipientChain);\n        TrimmedAmount memory internalAmount = trimmedAmount.shift(tokenDecimals_);\n\n        // get the sequence for this transfer\n        uint64 sequence = _useMessageSequence();\n\n        {\n            // now check rate limits\n            bool isAmountRateLimited = _isOutboundAmountRateLimited(internalAmount);\n            if (!shouldQueue && isAmountRateLimited) {\n                revert NotEnoughCapacity(getCurrentOutboundCapacity(), amount);\n            }\n            if (shouldQueue && isAmountRateLimited) {\n                // emit an event to notify the user that the transfer is rate limited\n                emit OutboundTransferRateLimited(\n                    msg.sender, sequence, amount, getCurrentOutboundCapacity()\n                );\n\n                // queue up and return\n                _enqueueOutboundTransfer(\n                    sequence,\n                    trimmedAmount,\n                    recipientChain,\n                    recipient,\n                    msg.sender,\n                    transceiverInstructions\n                );\n\n                // refund price quote back to sender\n                _refundToSender(msg.value);\n\n                // return the sequence in the queue\n                return sequenc"
    }
  ]
}