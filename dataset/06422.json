{
  "Title": "[M-06] Protocol will not benefit from slashing mechanism when remaining penalty bigger than `minThreshold`",
  "Content": "\nDuring the withdraw process, the function `settleFunds()` get called. This function first calculates the `operatorShare` and the `penaltyAmount`. If the `operatorShare` < `penaltyAmount`, the function calls `slashValidatorSD` in order to slash the operator and start new auction to cover the loss.\n\nThe issue here, is `slashValidatorSD` determines the amount to be reduced based on the smallest value between operators current SD balance and the `poolThreshold.minThreshold`. In this case, where the `operatorShare`(1ETH) is too small than the `penaltyAmount`(10ETH) the system should reduce an equivalent amount to cover the remaining ETH (`9ETH_`). However, the function choose the smallest value which could end up being 4e17. In such cases, the protocol will not favor because starting a new auction with SD amount = 4e17 will not end up with a 9ETH in exchange.\n\n### Proof of Concept\n\n1.  Implementation of `settleFunds`:\n\n<https://github.com/code-423n4/2023-06-stader/blob/main/contracts/ValidatorWithdrawalVault.sol#L54>\n\n    function settleFunds() external override {\n            uint8 poolId = VaultProxy(payable(address(this))).poolId();\n            uint256 validatorId = VaultProxy(payable(address(this))).id();\n            IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n            address nodeRegistry = IPoolUtils(staderConfig.getPoolUtils()).getNodeRegistry(poolId);\n            if (msg.sender != nodeRegistry) {\n                revert CallerNotNodeRegistryContract();\n            }\n            (uint256 userSharePrelim, uint256 operatorShare, uint256 protocolShare) = calculateValidatorWithdrawalShare();\n\n            uint256 penaltyAmount = getUpdatedPenaltyAmount(poolId, validatorId, staderConfig);\n\n            if (operatorShare < penaltyAmount) {\n                ISDCollateral(staderConfig.getSDCollateral()).slashValidatorSD(validatorId, poolId);\n                penaltyAmount = operatorShare;\n            }\n\n            uint256 userShare = userSharePrelim + penaltyAmount;\n            operatorShare = operatorShare - penaltyAmount;\n\n            // Final settlement\n            vaultSettleStatus = true;\n            IPenalty(staderConfig.getPenaltyContract()).markValidatorSettled(poolId, validatorId);\n            IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();\n            UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);\n            IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(\n                getOperatorAddress(poolId, validatorId, staderConfig)\n            );\n            emit SettledFunds(userShare, operatorShare, protocolShare);\n        }\n\n2.  Let's suppose `operatorShare` is 1 ETH, `penaltyAmount` is 5ETH. In this case, the function will enter the `If` condition on L67.\n\n<https://github.com/code-423n4/2023-06-stader/blob/main/contracts/ValidatorWithdrawalVault.sol#L67>\n\n     ISDCollateral(staderConfig.getSDCollateral()).slashValidatorSD(validatorId, poolId);\n\n3.  Implementation of `slashValidatorSD` and `slashSD`.\n\n<https://github.com/code-423n4/2023-06-stader/blob/main/contracts/SDCollateral.sol#L78>\n\n    function slashValidatorSD(uint256 _validatorId, uint8 _poolId) external override nonReentrant {\n            address operator = UtilLib.getOperatorForValidSender(_poolId, _validatorId, msg.sender, staderConfig);\n            isPoolThresholdValid(_poolId);\n            PoolThresholdInfo storage poolThreshold = poolThresholdbyPoolId[_poolId];\n            uint256 sdToSlash = convertETHToSD(poolThreshold.minThreshold);\n            slashSD(operator, sdToSlash);\n        }\n\n        /// @notice used to slash operator SD, incase of operator default\n        /// @dev do provide SD approval to auction contract using `maxApproveSD()`\n        /// @param _operator which operator SD collateral to slash\n        /// @param _sdToSlash amount of SD to slash\n        function slashSD(address _operator, uint256 _sdToSlash) internal {\n            uint256 sdBalance = operatorSDBalance[_operator];\n            uint256 sdSlashed = Math.min(_sdToSlash, sdBalance);\n            if (sdSlashed == 0) {\n                return;\n            }\n            operatorSDBalance[_operator] -= sdSlashed;\n            IAuction(staderConfig.getAuctionContract()).createLot(sdSlashed);\n            emit SDSlashed(_operator, staderConfig.getAuctionContract(), sdSlashed);\n        }\n\n4.  As you can see, on line 82, the function gets the `minThreshold` and passes it to `slashSD`.\n\n5.  On line 92, it selects the smallest value between the current balance of the operator and the `minThreshold`:\n\n<!---->\n\n    uint256 sdSlashed = Math.min(_sdToSlash, sdBalance);\n\n6. If the `minThreshold` < remaining penalty, which is 4 ETH in this case, the function simply ignores that and reduces the operator amount with \"`minThreshold`\" instead. In this case, it's < current SD balance.\n\n7.  The function then starts new auction with the smallest value.\n\n<https://github.com/code-423n4/2023-06-stader/blob/main/contracts/SDCollateral.sol#L97>\n\n    operatorSDBalance[_operator] -= sdSlashed;\n            IAuction(staderConfig.getAuctionContract()).createLot(sdSlashed);\n\nDespite how much the user should pay, the auction will start with the min value and the `penaltyAmount` will not be paid in full.\n\n### Recommended Mitigation Steps\n\nThe function shouldn't use `minThreshold`. It should catch the remaining penalty (difference between `operatorShare` and `penaltyAmount`) and use it to calculate the required SD amount to be slashed.\n\n### Assessed type\n\nContext\n\n**[manoj9april (Stader) acknowledged and commented](https://github.com/code-423n4/2022-06-stader-findings/issues/292#issuecomment-1598299058):**\n > This update is slated for a future release. \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-stader",
  "Code": [
    {
      "filename": "contracts/ValidatorWithdrawalVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\nimport './library/ValidatorStatus.sol';\n\nimport './VaultProxy.sol';\nimport './interfaces/IPenalty.sol';\nimport './interfaces/IPoolUtils.sol';\nimport './interfaces/INodeRegistry.sol';\nimport './interfaces/IStaderStakePoolManager.sol';\nimport './interfaces/IValidatorWithdrawalVault.sol';\nimport './interfaces/SDCollateral/ISDCollateral.sol';\nimport './interfaces/IOperatorRewardsCollector.sol';\n\nimport '@openzeppelin/contracts/utils/math/Math.sol';\n\ncontract ValidatorWithdrawalVault is IValidatorWithdrawalVault {\n    bool internal vaultSettleStatus;\n    using Math for uint256;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {}\n\n    // Allows the contract to receive ETH\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n\n    function distributeRewards() external override {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        uint256 validatorId = VaultProxy(payable(address(this))).id();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        uint256 totalRewards = address(this).balance;\n        if (!staderConfig.onlyOperatorRole(msg.sender) && totalRewards > staderConfig.getRewardsThreshold()) {\n            emit DistributeRewardFailed(totalRewards, staderConfig.getRewardsThreshold());\n            revert InvalidRewardAmount();\n        }\n        if (totalRewards == 0) {\n            revert NotEnoughRewardToDistribute();\n        }\n        (uint256 userShare, uint256 operatorShare, uint256 protocolShare) = IPoolUtils(staderConfig.getPoolUtils())\n            .calculateRewardShare(poolId, totalRewards);\n\n        // Distribute rewards\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();\n        UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);\n        IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(\n            getOperatorAddress(poolId, validatorId, staderConfig)\n        );\n        emit DistributedRewards(userShare, operatorShare, protocolShare);\n    }\n\n    function settleFunds() external override {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        uint256 validatorId = VaultProxy(payable(address(this))).id();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        address nodeRegistry = IPoolUtils(staderConfig.getPoolUtils()).getNodeRegistry(poolId);\n        if (msg.sender != nodeRegistry) {\n            revert CallerNotNodeRegistryContract();\n        }\n        (uint256 userSharePrelim, uint256 operatorShare, uint256 protocolShare) = calculateValidatorWithdrawalShare();\n\n        uint256 penaltyAmount = getUpdatedPenaltyAmount(poolId, validatorId, staderConfig);\n\n        if (operatorShare < penaltyAmount) {\n            ISDCollateral(staderConfig.getSDCollateral()).slashValidatorSD(validatorId, poolId);\n            penaltyAmount = operatorShare;\n        }\n\n        uint256 userShare = userSharePrelim + penaltyAmount;\n        operatorShare = operatorShare - penaltyAmount;\n\n        // Final settlement\n        vaultSettleStatus = true;\n        IPenalty(staderConfig.getPenaltyContract()).markValidatorSettled(poolId, validatorId);\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();\n        UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);\n        IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(\n            getOperatorAddress(poolId, validatorId, staderConfig)\n        );\n        emit SettledFunds(userShare, operatorShare, protocolShare);\n    }\n\n    function calculateValidatorWithdrawalShare()\n        public\n        view\n        returns (\n            uint256 _userShare,\n            uint256 _operatorShare,\n            uint256 _protocolShare\n        )\n    {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        uint256 TOTAL_STAKED_ETH = staderConfig.getStakedEthPerNode();\n        uint256 collateralETH = getCollateralETH(poolId, staderConfig); // 0, incase of permissioned NOs\n        uint256 usersETH = TOTAL_STAKED_ETH - collateralETH;\n        uint256 contractBalance = address(this).balance;\n\n        uint256 totalRewards;\n\n        if (contractBalance <= usersETH) {\n            _userShare = contractBalance;\n            return (_userShare, _operatorShare, _protocolShare);\n        } else if (contractBalance <= TOTAL_STAKED_ETH) {\n            _userShare = usersETH;\n            _operatorShare = contractBalance - _userShare;\n            return (_userShare, _operatorShare, _protocolShare);\n        } else {\n            totalRewards = contractBalance - TOTAL_STAKED_ETH;\n            _operatorShare = collateralETH;\n            _userShare = usersETH;\n        }\n        if (totalRewards > 0) {\n            (uint256 userReward, uint256 operatorReward, uint256 protocolReward) = IPoolUtils(\n                staderConfig.getPoolUtils()\n            ).calculateRewardShare(poolId, totalRewards);\n            _userShare += userReward;\n            _operatorShare += operatorReward;\n            _protocolShare += protocolReward;\n        }\n    }\n\n    // HELPER METHODS\n\n    function getCollateralETH(uint8 _poolId, IStaderConfig _staderConfig) internal view returns (uint256) {\n        return IPoolUtils(_staderConfig.getPoolUtils()).getCollateralETH(_poolId);\n    }\n\n    function getOperatorAddress(\n        uint8 _poolId,\n        uint256 _validatorId,\n        IStaderConfig _staderConfig\n    ) internal view returns (address) {\n        return UtilLib.getOperatorAddressByValidatorId(_poolId, _validatorId, _staderConfig);\n    }\n\n    function getUpdatedPenaltyAmount(\n        uint8 _poolId,\n        uint256 _validatorId,\n        IStaderConfig _staderConfig\n    ) internal returns (uint256) {\n        address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);\n        (, bytes memory pubkey, , , , , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);\n        bytes[] memory pubkeyArray = new bytes[](1);\n        pubkeyArray[0] = pubkey;\n        IPenalty(_staderConfig.getPenaltyContract()).updateTotalPenaltyAmount(pubkeyArray);\n        return IPenalty(_staderConfig.getPenaltyContract()).totalPenaltyAmount(pubkey);\n    }\n}"
    },
    {
      "filename": "contracts/ValidatorWithdrawalVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\nimport './library/ValidatorStatus.sol';\n\nimport './VaultProxy.sol';\nimport './interfaces/IPenalty.sol';\nimport './interfaces/IPoolUtils.sol';\nimport './interfaces/INodeRegistry.sol';\nimport './interfaces/IStaderStakePoolManager.sol';\nimport './interfaces/IValidatorWithdrawalVault.sol';\nimport './interfaces/SDCollateral/ISDCollateral.sol';\nimport './interfaces/IOperatorRewardsCollector.sol';\n\nimport '@openzeppelin/contracts/utils/math/Math.sol';\n\ncontract ValidatorWithdrawalVault is IValidatorWithdrawalVault {\n    bool internal vaultSettleStatus;\n    using Math for uint256;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {}\n\n    // Allows the contract to receive ETH\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n\n    function distributeRewards() external override {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        uint256 validatorId = VaultProxy(payable(address(this))).id();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        uint256 totalRewards = address(this).balance;\n        if (!staderConfig.onlyOperatorRole(msg.sender) && totalRewards > staderConfig.getRewardsThreshold()) {\n            emit DistributeRewardFailed(totalRewards, staderConfig.getRewardsThreshold());\n            revert InvalidRewardAmount();\n        }\n        if (totalRewards == 0) {\n            revert NotEnoughRewardToDistribute();\n        }\n        (uint256 userShare, uint256 operatorShare, uint256 protocolShare) = IPoolUtils(staderConfig.getPoolUtils())\n            .calculateRewardShare(poolId, totalRewards);\n\n        // Distribute rewards\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();\n        UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);\n        IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(\n            getOperatorAddress(poolId, validatorId, staderConfig)\n        );\n        emit DistributedRewards(userShare, operatorShare, protocolShare);\n    }\n\n    function settleFunds() external override {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        uint256 validatorId = VaultProxy(payable(address(this))).id();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        address nodeRegistry = IPoolUtils(staderConfig.getPoolUtils()).getNodeRegistry(poolId);\n        if (msg.sender != nodeRegistry) {\n            revert CallerNotNodeRegistryContract();\n        }\n        (uint256 userSharePrelim, uint256 operatorShare, uint256 protocolShare) = calculateValidatorWithdrawalShare();\n\n        uint256 penaltyAmount = getUpdatedPenaltyAmount(poolId, validatorId, staderConfig);\n\n        if (operatorShare < penaltyAmount) {\n            ISDCollateral(staderConfig.getSDCollateral()).slashValidatorSD(validatorId, poolId);\n            penaltyAmount = operatorShare;\n        }\n\n        uint256 userShare = userSharePrelim + penaltyAmount;\n        operatorShare = operatorShare - penaltyAmount;\n\n        // Final settlement\n        vaultSettleStatus = true;\n        IPenalty(staderConfig.getPenaltyContract()).markValidatorSettled(poolId, validatorId);\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();\n        UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);\n        IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(\n            getOperatorAddress(poolId, validatorId, staderConfig)\n        );\n        emit SettledFunds(userShare, operatorShare, protocolShare);\n    }\n\n    function calculateValidatorWithdrawalShare()\n        public\n        view\n        returns (\n            uint256 _userShare,\n            uint256 _operatorShare,\n            uint256 _protocolShare\n        )\n    {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        uint256 TOTAL_STAKED_ETH = staderConfig.getStakedEthPerNode();\n        uint256 collateralETH = getCollateralETH(poolId, staderConfig); // 0, incase of permissioned NOs\n        uint256 usersETH = TOTAL_STAKED_ETH - collateralETH;\n        uint256 contractBalance = address(this).balance;\n\n        uint256 totalRewards;\n\n        if (contractBalance <= usersETH) {\n            _userShare = contractBalance;\n            return (_userShare, _operatorShare, _protocolShare);\n        } else if (contractBalance <= TOTAL_STAKED_ETH) {\n            _userShare = usersETH;\n            _operatorShare = contractBalance - _userShare;\n            return (_userShare, _operatorShare, _protocolShare);\n        } else {\n            totalRewards = contractBalance - TOTAL_STAKED_ETH;\n            _operatorShare = collateralETH;\n            _userShare = usersETH;\n        }\n        if (totalRewards > 0) {\n            (uint256 userReward, uint256 operatorReward, uint256 protocolReward) = IPoolUtils(\n                staderConfig.getPoolUtils()\n            ).calculateRewardShare(poolId, totalRewards);\n            _userShare += userReward;\n            _operatorShare += operatorReward;\n            _protocolShare += protocolReward;\n        }\n    }\n\n    // HELPER METHODS\n\n    function getCollateralETH(uint8 _poolId, IStaderConfig _staderConfig) internal view returns (uint256) {\n        return IPoolUtils(_staderConfig.getPoolUtils()).getCollateralETH(_poolId);\n    }\n\n    function getOperatorAddress(\n        uint8 _poolId,\n        uint256 _validatorId,\n        IStaderConfig _staderConfig\n    ) internal view returns (address) {\n        return UtilLib.getOperatorAddressByValidatorId(_poolId, _validatorId, _staderConfig);\n    }\n\n    function getUpdatedPenaltyAmount(\n        uint8 _poolId,\n        uint256 _validatorId,\n        IStaderConfig _staderConfig\n    ) internal returns (uint256) {\n        address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);\n        (, bytes memory pubkey, , , , , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);\n        bytes[] memory pubkeyArray = new bytes[](1);\n        pubkeyArray[0] = pubkey;\n        IPenalty(_staderConfig.getPenaltyContract()).updateTotalPenaltyAmount(pubkeyArray);\n        return IPenalty(_staderConfig.getPenaltyContract()).totalPenaltyAmount(pubkey);\n    }\n}"
    },
    {
      "filename": "contracts/SDCollateral.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\n\nimport '../contracts/interfaces/IPoolUtils.sol';\nimport '../contracts/interfaces/SDCollateral/ISDCollateral.sol';\nimport '../contracts/interfaces/SDCollateral/IAuction.sol';\nimport '../contracts/interfaces/IStaderOracle.sol';\n\nimport '@openzeppelin/contracts/utils/math/Math.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ncontract SDCollateral is ISDCollateral, Initializable, AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n    IStaderConfig public override staderConfig;\n    mapping(uint8 => PoolThresholdInfo) public poolThresholdbyPoolId;\n    mapping(address => uint256) public override operatorSDBalance;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _admin, address _staderConfig) public initializer {\n        UtilLib.checkNonZeroAddress(_admin);\n        UtilLib.checkNonZeroAddress(_staderConfig);\n\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        staderConfig = IStaderConfig(_staderConfig);\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n\n        emit UpdatedStaderConfig(_staderConfig);\n    }\n\n    /**\n     * @param _sdAmount SD Token Amount to Deposit\n     * @dev sender should approve this contract for spending SD\n     */\n    function depositSDAsCollateral(uint256 _sdAmount) external override {\n        address operator = msg.sender;\n        operatorSDBalance[operator] += _sdAmount;\n\n        if (!IERC20(staderConfig.getStaderToken()).transferFrom(operator, address(this), _sdAmount)) {\n            revert SDTransferFailed();\n        }\n\n        emit SDDeposited(operator, _sdAmount);\n    }\n\n    /// @notice for operator to request withdraw of sd\n    /// @dev it does not transfer sd tokens immediately\n    /// operator should come back after withdrawal-delay time to claim\n    /// this requested sd is subject to slashes\n    function withdraw(uint256 _requestedSD) external override {\n        address operator = msg.sender;\n        uint256 opSDBalance = operatorSDBalance[operator];\n\n        if (opSDBalance < getOperatorWithdrawThreshold(operator) + _requestedSD) {\n            revert InsufficientSDToWithdraw(opSDBalance);\n        }\n        operatorSDBalance[operator] -= _requestedSD;\n\n        // cannot use safeERC20 as this contract is an upgradeable contract\n        if (!IERC20(staderConfig.getStaderToken()).transfer(payable(operator), _requestedSD)) {\n            revert SDTransferFailed();\n        }\n\n        emit SDWithdrawn(operator, _requestedSD);\n    }\n\n    /// @notice slashes one validator equi. SD amount\n    /// @dev callable only by respective withdrawVaults\n    /// @param _validatorId validator SD collateral to slash\n    function slashValidatorSD(uint256 _validatorId, uint8 _poolId) external override nonReentrant {\n        address operator = UtilLib.getOperatorForValidSender(_poolId, _validatorId, msg.sender, staderConfig);\n        isPoolThresholdValid(_poolId);\n        PoolThresholdInfo storage poolThreshold = poolThresholdbyPoolId[_poolId];\n        uint256 sdToSlash = convertETHToSD(poolThreshold.minThreshold);\n        slashSD(operator, sdToSlash);\n    }\n\n    /// @notice used to slash operator SD, incase of operator default\n    /// @dev do provide SD approval to auction contract using `maxApproveSD()`\n    /// @param _operator which operator SD collateral to slash\n    /// @param _sdToSlash amount of SD to slash\n    function slashSD(address _operator, uint256 _sdToSlash) internal {\n        uint256 sdBalance = operatorSDBalance[_operator];\n        uint256 sdSlashed = Math.min(_sdToSlash, sdBalance);\n        if (sdSlashed == 0) {\n            return;\n        }\n        operatorSDBalance[_operator] -= sdSlashed;\n        IAuction(staderConfig.getAuctionContract()).createLot(sdSlashed);\n        emit SDSlashed(_operator, staderConfig.getAuctionContract(), sdSlashed);\n    }\n\n    /// @notice for max approval to auction contract for spending SD tokens\n    function maxApproveSD() external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        address auctionContract = staderConfig.getAuctionContract();\n        UtilLib.checkNonZeroAddress(auctionContract);\n        IERC20(staderConfig.getStaderToken()).approve(auctionContract, type(uint256).max);\n    }\n\n    // SETTERS\n    function updateStaderConfig(address _staderConfig) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        UtilLib.checkNonZeroAddress(_staderConfig);\n        if (_staderConfig == address(staderConfig)) {\n            revert NoStateChange();\n        }\n        staderConfig = IStaderConfig(_staderConfig);\n        emit UpdatedStaderConfig(_staderConfig);\n    }\n\n    function updatePoolThreshold(\n        uint8 _poolId,\n        uint256 _minThreshold,\n        uint256 _maxThreshold,\n        uint256 _withdrawThreshold,\n        string memory _units\n    ) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        if ((_minThreshold > _withdrawThreshold) || (_minThreshold > _maxThreshold)) {\n            revert InvalidPoolLimit();\n        }\n\n        poolThresholdbyPoolId[_poolId] = PoolThresholdInfo({\n            minThreshold: _minThreshold,\n            maxThreshold: _maxThreshold,\n            withdrawThreshold: _withdrawThreshold,\n            units: _units\n        });\n\n        emit UpdatedPoolThreshold(_poolId, _minThreshold, _withdrawThreshold);\n    }\n\n    // GETTERS\n\n    // returns sum of withdraw threshold accounting for all its(op's) validators\n    function getOperatorWithdrawThreshold(address _operator) public view returns (uint256 operatorWithdrawThreshold) {\n        (uint8 poolId, , uint256 validatorCount) = getOperatorInfo(_operator);\n        isPoolThresholdValid(poolId);\n        PoolThresholdInfo storage poolThreshold = poolThresholdbyPoolId[poolId];\n        return convertETHToSD(poolThreshold.withdrawThreshold * validatorCount);\n    }\n\n    /// @notice checks if operator has enough SD collateral to onboard validators in a specific pool\n    /// @param _operator node operator addr who want to onboard validators\n    /// @param _poolId pool id, where operator wants to onboard validators\n    /// @param _numValidator number of validators to onBoard\n    function hasEnoughSDCollateral(\n        address _operator,\n        uint8 _poolId,\n        uint256 _numValidator\n    ) external view override returns (bool) {\n        return (getRemainingSDToBond(_operator, _poolId, _numValidator) == 0);\n    }\n\n    /// @notice returns minimum amount of SD required to onboard _numValidators in a pool\n    /// @param _poolId pool id, where operator wants to onboard validators\n    /// @param _numValidator number of validators to onBoard (including already onboarded, if any)\n    function getMinimumSDToBond(uint8 _poolId, uint256 _numValidator)\n        public\n        view\n        override\n        returns (uint256 _minSDToBond)\n    {\n        isPoolThresholdValid(_poolId);\n        PoolThresholdInfo storage poolThreshold = poolThresholdbyPoolId[_poolId];\n\n        _minSDToBond = convertETHToSD(poolThreshold.minThreshold);\n        _minSDToBond *= _numValidator;\n    }\n\n    /// @notice returns remaining amount of SD required to onboard _numValidators\n    /// @param _operator node operator addr who want to onboard validators\n    /// @param _poolId pool id, where operator wants to onboard validators\n    /// @param _numValidator number of validators to onBoard (including already onboarded, if any)\n    function getRemainingSDToBond(\n        address _operator,\n        uint8 _poolId,\n        uint256 _numValidator\n    ) public view override returns (uint256) {\n        uint256 sdBalance = operatorSDBalance[_operator];\n        uint256 minSDToBond = getMinimumSDToBond(_poolId, _numValidator);\n        return (sdBalance >= minSDToBond ? 0 : minSDToBond - sdBalance);\n    }\n\n    function getRewardEligibleSD(address _operator) external view override returns (uint256 _rewardEligibleSD) {\n        (uint8 poolId, , uint256 validatorCount) = getOperatorInfo(_operator);\n\n        isPoolThresholdValid(poolId);\n        PoolThresholdInfo storage poolThreshold = poolThresholdbyPoolId[poolId];\n\n        uint256 totalMinThreshold = validatorCount * convertETHToSD(poolThreshold.minThreshold);\n        uint256 totalMaxThreshold = validatorCount * convertETHToSD(poolThreshold.maxThreshold);\n        uint256 sdBalance = operatorSDBalance[_operator];\n        return (sdBalance < totalMinThreshold ? 0 : Math.min(sdBalance, totalMaxThreshold));\n    }\n\n    function convertSDToETH(uint256 _sdAmount) public view override returns (uint256) {\n        uint256 sdPriceInETH = IStaderOracle(staderConfig.getStaderOracle()).getSDPriceInETH();\n        return (_sdAmount * sdPriceInETH) / staderConfig.getDecimals();\n    }\n\n    function convertETHToSD(uint256 _ethAmount) public view override returns (uint256) {\n        uint256 sdPriceInETH = IStaderOracle(staderConfig.getStaderOracle()).getSDPriceInETH();\n        return (_ethAmount * staderConfig.getDecimals()) / sdPriceInETH;\n    }\n\n    // HELPER\n\n    function getOperatorInfo(address _operator)\n        internal\n        view\n        returns (\n            uint8 _poolId,\n            uint256 _operatorId,\n            uint256 _validatorCount\n        )\n    {\n        IPoolUtils poolUtils = IPoolUtils(staderConfig.getPoolUtils());\n        _poolId = poolUtils.getOperatorPoolId(_operator);\n        INodeRegistry nodeRegistry = INodeRegistry(poolUtils.getNodeRegistry(_poolId));\n        _operatorId = nodeRegistry.operatorIDByAddress(_operator);\n        _validatorCount = poolUtils.getOperatorTotalNonTerminalKeys(\n            _poolId,\n            _operator,\n            0,\n            nodeRegistry.getOperatorTotalKeys(_operatorId)\n        );\n    }\n\n    function isPoolThresholdValid(uint8 _poolId) internal view {\n        if (bytes(poolThresholdbyPoolId[_poolId].units).length == 0) {\n            revert InvalidPoolId();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/SDCollateral.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\n\nimport '../contracts/interfaces/IPoolUtils.sol';\nimport '../contracts/interfaces/SDCollateral/ISDCollateral.sol';\nimport '../contracts/interfaces/SDCollateral/IAuction.sol';\nimport '../contracts/interfaces/IStaderOracle.sol';\n\nimport '@openzeppelin/contracts/utils/math/Math.sol';\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ncontract SDCollateral is ISDCollateral, Initializable, AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n    IStaderConfig public override staderConfig;\n    mapping(uint8 => PoolThresholdInfo) public poolThresholdbyPoolId;\n    mapping(address => uint256) public override operatorSDBalance;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _admin, address _staderConfig) public initializer {\n        UtilLib.checkNonZeroAddress(_admin);\n        UtilLib.checkNonZeroAddress(_staderConfig);\n\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        staderConfig = IStaderConfig(_staderConfig);\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n\n        emit UpdatedStaderConfig(_staderConfig);\n    }\n\n    /**\n     * @param _sdAmount SD Token Amount to Deposit\n     * @dev sender should approve this contract for spending SD\n     */\n    function depositSDAsCollateral(uint256 _sdAmount) external override {\n        address operator = msg.sender;\n        operatorSDBalance[operator] += _sdAmount;\n\n        if (!IERC20(staderConfig.getStaderToken()).transferFrom(operator, address(this), _sdAmount)) {\n            revert SDTransferFailed();\n        }\n\n        emit SDDeposited(operator, _sdAmount);\n    }\n\n    /// @notice for operator to request withdraw of sd\n    /// @dev it does not transfer sd tokens immediately\n    /// operator should come back after withdrawal-delay time to claim\n    /// this requested sd is subject to slashes\n    function withdraw(uint256 _requestedSD) external override {\n        address operator = msg.sender;\n        uint256 opSDBalance = operatorSDBalance[operator];\n\n        if (opSDBalance < getOperatorWithdrawThreshold(operator) + _requestedSD) {\n            revert InsufficientSDToWithdraw(opSDBalance);\n        }\n        operatorSDBalance[operator] -= _requestedSD;\n\n        // cannot use safeERC20 as this contract is an upgradeable contract\n        if (!IERC20(staderConfig.getStaderToken()).transfer(payable(operator), _requestedSD)) {\n            revert SDTransferFailed();\n        }\n\n        emit SDWithdrawn(operator, _requestedSD);\n    }\n\n    /// @notice slashes one validator equi. SD amount\n    /// @dev callable only by respective withdrawVaults\n    /// @param _validatorId validator SD collateral to slash\n    function slashValidatorSD(uint256 _validatorId, uint8 _poolId) external override nonReentrant {\n        address operator = UtilLib.getOperatorForValidSender(_poolId, _validatorId, msg.sender, staderConfig);\n        isPoolThresholdValid(_poolId);\n        PoolThresholdInfo storage poolThreshold = poolThresholdbyPoolId[_poolId];\n        uint256 sdToSlash = convertETHToSD(poolThreshold.minThreshold);\n        slashSD(operator, sdToSlash);\n    }\n\n    /// @notice used to slash operator SD, incase of operator default\n    /// @dev do provide SD approval to auction contract using `maxApproveSD()`\n    /// @param _operator which operator SD collateral to slash\n    /// @param _sdToSlash amount of SD to slash\n    function slashSD(address _operator, uint256 _sdToSlash) internal {\n        uint256 sdBalance = operatorSDBalance[_operator];\n        uint256 sdSlashed = Math.min(_sdToSlash, sdBalance);\n        if (sdSlashed == 0) {\n            return;\n        }\n        operatorSDBalance[_operator] -= sdSlashed;\n        IAuction(staderConfig.getAuctionContract()).createLot(sdSlashed);\n        emit SDSlashed(_operator, staderConfig.getAuctionContract(), sdSlashed);\n    }\n\n    /// @notice for max approval to auction contract for spending SD tokens\n    function maxApproveSD() external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        address auctionContract = staderConfig.getAuctionContract();\n        UtilLib.checkNonZeroAddress(auctionContract);\n        IERC20(staderConfig.getStaderToken()).approve(auctionContract, type(uint256).max);\n    }\n\n    // SETTERS\n    function updateStaderConfig(address _staderConfig) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        UtilLib.checkNonZeroAddress(_staderConfig);\n        if (_staderConfig == address(staderConfig)) {\n            revert NoStateChange();\n        }\n        staderConfig = IStaderConfig(_staderConfig);\n        emit UpdatedStaderConfig(_staderConfig);\n    }\n\n    function updatePoolThreshold(\n        uint8 _poolId,\n        uint256 _minThreshold,\n        uint256 _maxThreshold,\n        uint256 _withdrawThreshold,\n        string memory _units\n    ) external override {\n        UtilLib.onlyManagerRole(msg.sender, staderConfig);\n        if ((_minThreshold > _withdrawThreshold) || (_minThreshold > _maxThreshold)) {\n            revert InvalidPoolLimit();\n        }\n\n        poolThresholdbyPoolId[_poolId] = PoolThresholdInfo({\n            minThreshold: _minThreshold,\n            maxThreshold: _maxThreshold,\n            withdrawThreshold: _withdrawThreshold,\n            units: _units\n        });\n\n        emit UpdatedPoolThreshold(_poolId, _minThreshold, _withdrawThreshold);\n    }\n\n    // GETTERS\n\n    // returns sum of withdraw threshold accounting for all its(op's) validators\n    function getOperatorWithdrawThreshold(address _operator) public view returns (uint256 operatorWithdrawThreshold) {\n        (uint8 poolId, , uint256 validatorCount) = getOperatorInfo(_operator);\n        isPoolThresholdValid(poolId);\n        PoolThresholdInfo storage poolThreshold = poolThresholdbyPoolId[poolId];\n        return convertETHToSD(poolThreshold.withdrawThreshold * validatorCount);\n    }\n\n    /// @notice checks if operator has enough SD collateral to onboard validators in a specific pool\n    /// @param _operator node operator addr who want to onboard validators\n    /// @param _poolId pool id, where operator wants to onboard validators\n    /// @param _numValidator number of validators to onBoard\n    function hasEnoughSDCollateral(\n        address _operator,\n        uint8 _poolId,\n        uint256 _numValidator\n    ) external view override returns (bool) {\n        return (getRemainingSDToBond(_operator, _poolId, _numValidator) == 0);\n    }\n\n    /// @notice returns minimum amount of SD required to onboard _numValidators in a pool\n    /// @param _poolId pool id, where operator wants to onboard validators\n    /// @param _numValidator number of validators to onBoard (including already onboarded, if any)\n    function getMinimumSDToBond(uint8 _poolId, uint256 _numValidator)\n        public\n        view\n        override\n        returns (uint256 _minSDToBond)\n    {\n        isPoolThresholdValid(_poolId);\n        PoolThresholdInfo storage poolThreshold = poolThresholdbyPoolId[_poolId];\n\n        _minSDToBond = convertETHToSD(poolThreshold.minThreshold);\n        _minSDToBond *= _numValidator;\n    }\n\n    /// @notice returns remaining amount of SD required to onboard _numValidators\n    /// @param _operator node operator addr who want to onboard validators\n    /// @param _poolId pool id, where operator wants to onboard validators\n    /// @param _numValidator number of validators to onBoard (including already onboarded, if any)\n    function getRemainingSDToBond(\n        address _operator,\n        uint8 _poolId,\n        uint256 _numValidator\n    ) public view override returns (uint256) {\n        uint256 sdBalance = operatorSDBalance[_operator];\n        uint256 minSDToBond = getMinimumSDToBond(_poolId, _numValidator);\n        return (sdBalance >= minSDToBond ? 0 : minSDToBond - sdBalance);\n    }\n\n    function getRewardEligibleSD(address _operator) external view override returns (uint256 _rewardEligibleSD) {\n        (uint8 poolId, , uint256 validatorCount) = getOperatorInfo(_operator);\n\n        isPoolThresholdValid(poolId);\n        PoolThresholdInfo storage poolThreshold = poolThresholdbyPoolId[poolId];\n\n        uint256 totalMinThreshold = validatorCount * convertETHToSD(poolThreshold.minThreshold);\n        uint256 totalMaxThreshold = validatorCount * convertETHToSD(poolThreshold.maxThreshold);\n        uint256 sdBalance = operatorSDBalance[_operator];\n        return (sdBalance < totalMinThreshold ? 0 : Math.min(sdBalance, totalMaxThreshold));\n    }\n\n    function convertSDToETH(uint256 _sdAmount) public view override returns (uint256) {\n        uint256 sdPriceInETH = IStaderOracle(staderConfig.getStaderOracle()).getSDPriceInETH();\n        return (_sdAmount * sdPriceInETH) / staderConfig.getDecimals();\n    }\n\n    function convertETHToSD(uint256 _ethAmount) public view override returns (uint256) {\n        uint256 sdPriceInETH = IStaderOracle(staderConfig.getStaderOracle()).getSDPriceInETH();\n        return (_ethAmount * staderConfig.getDecimals()) / sdPriceIn"
    }
  ]
}