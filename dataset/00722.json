{
  "Title": "M-2: The number of deposits in a round can be larger than MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND",
  "Content": "# Issue M-2: The number of deposits in a round can be larger than MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND \n\nSource: https://github.com/sherlock-audit/2024-01-looksrare-judging/issues/78 \n\n## Found by \n0xMAKEOUTHILL, HSP, KupiaSec, LTDingZhen, bughuntoor, cocacola, deepplus, lil.eth, pontifex, s1ce, unforgiven, zzykxx\n## Summary\nThe number of deposits in a round can be larger than [MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND](https://github.com/sherlock-audit/2024-01-looksrare/blob/main/contracts-yolo/contracts/YoloV2.sol#L81), because there is no such check in [depositETHIntoMultipleRounds()](https://github.com/sherlock-audit/2024-01-looksrare/blob/main/contracts-yolo/contracts/YoloV2.sol#L312) function or [rolloverETH()](https://github.com/sherlock-audit/2024-01-looksrare/blob/main/contracts-yolo/contracts/YoloV2.sol#L643-L646) function.\n\n## Vulnerability Detail\n**depositETHIntoMultipleRounds()** function is called to deposit ETH into multiple rounds, so it's possible that the number of deposits in both current round and next round is **MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND**.\n\nWhen current round's number of deposits reaches **MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND**, the round is drawn:\n```solidity\n        if (\n            _shouldDrawWinner(\n                startingRound.numberOfParticipants,\n                startingRound.maximumNumberOfParticipants,\n                startingRound.deposits.length\n            )\n        ) {\n            _drawWinner(startingRound, startingRoundId);\n        }\n```\n[_drawWinner()](https://github.com/sherlock-audit/2024-01-looksrare/blob/main/contracts-yolo/contracts/YoloV2.sol#L997) function calls VRF provider to get a random number, when the random number is returned by VRF provider, [fulfillRandomWords()](https://github.com/sherlock-audit/2024-01-looksrare/blob/main/contracts-yolo/contracts/YoloV2.sol#L1270) function is called to chose the winner and the next round will be started:\n```solidity\n                _startRound({_roundsCount: roundId});\n```\nIf the next round's deposit number is also **MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND**, [_startRound()](https://github.com/sherlock-audit/2024-01-looksrare/blob/main/contracts-yolo/contracts/YoloV2.sol#L949) function may also draw the next round as well, so it seems that there is no chance the the number of deposits in a round can become larger than **MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND**:\n```solidity\n            if (\n                !paused() &&\n                _shouldDrawWinner(numberOfParticipants, round.maximumNumberOfParticipants, round.deposits.length)\n            ) {\n                _drawWinner(round, roundId);\n            }\n```\nHowever, **_startRound()** function will draw the round **only if the protocol is not paused**. Imagine the following scenario:\n1. The deposit number in `round 1` and `round 2` is **MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND**;\n2. `round 1` is drawn, before random number is sent back by VRF provider, the protocol is paused by the admin for some reason;\n3. Random number is returned and **fulfillRandomWords()** function is called to start `round 2`;\n4. Because protocol is paused, `round 2` is set to **OPEN** but not drawn;\n5. Later admin unpauses the protocol, before [drawWinner()](https://github.com/sherlock-audit/2024-01-looksrare/blob/main/contracts-yolo/contracts/YoloV2.sol#L401) function can be called, some users may deposit more funds into `round 2` by calling **depositETHIntoMultipleRounds()** function or **rolloverETH()** function, this will make the deposit number of `round 2` larger than **MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND**.\n\nPlease run the test code to verify:\n```solidity\n    function test_audit_deposit_more_than_max() public {\n        address alice = makeAddr(\"Alice\");\n        address bob = makeAddr(\"Bob\");\n\n        vm.deal(alice, 2 ether);\n        vm.deal(bob, 2 ether);\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 0.01 ether;\n        amounts[1] = 0.01 ether;\n\n        // Users deposit to make the deposit number equals to MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND in both rounds\n        uint256 MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND = 100;\n        for (uint i; i < MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND / 2; ++i) {\n            vm.prank(alice);\n            yolo.depositETHIntoMultipleRounds{value: 0.02 ether}(amounts);\n\n            vm.prank(bob);\n            yolo.depositETHIntoMultipleRounds{value: 0.02 ether}(amounts);\n        }\n\n        // owner pause the protocol before random word returned\n        vm.prank(owner);\n        yolo.togglePaused();\n\n        // random word returned and round 2 is started but not drawn\n        vm.prank(VRF_COORDINATOR);\n        uint256[] memory randomWords = new uint256[](1);\n        uint256 randomWord = 123;\n        randomWords[0] = randomWord;\n        yolo.rawFulfillRandomWords(FULFILL_RANDOM_WORDS_REQUEST_ID, randomWords);\n\n        // owner unpause the protocol\n        vm.prank(owner);\n        yolo.togglePaused();\n\n        // User deposits into round 2\n        amounts = new uint256[](1);\n        amounts[0] = 0.01 ether;\n        vm.prank(bob);\n        yolo.depositETHIntoMultipleRounds{value: 0.01 ether}(amounts);\n\n        (\n            ,\n            ,\n            ,\n            ,\n            ,\n            ,\n            ,\n            ,\n            ,\n            YoloV2.Deposit[] memory round2Deposits\n        ) = yolo.getRound(2);\n\n        // the number of deposits in round 2 is larger than MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND\n        assertEq(round2Deposits.length, MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND + 1);\n    }\n```\n\n## Impact\nThis issue break the invariant that the number of deposits in a round can be larger than **MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND**.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-01-looksrare/blob/main/contracts-yolo/contracts/YoloV2.sol#L312\nhttps://github.com/sherlock-audit/2024-01-looksrare/blob/main/contracts-yolo/contracts/YoloV2.sol#L643-L646\n\n## Tool used\nManual Review\n\n## Recommendation\nAdd check in [_depositETH()](https://github.com/sherlock-audit/2024-01-looksrare/blob/main/contracts-yolo/contracts/YoloV2.sol#L1417-L1422) function which is called by both **depositETHIntoMultipleRounds()** function and **rolloverETH()** function to ensure the deposit number cannot be larger than **MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND**:\n```diff\n        uint256 roundDepositCount = round.deposits.length;\n\n+       if (roundDepositCount >= MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND) {\n+           revert MaximumNumberOfDepositsReached();\n+       }\n\n        _validateOnePlayerCannotFillUpTheWholeRound(_unsafeAdd(roundDepositCount, 1), round.numberOfParticipants);\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid: when the contract is paused; major functions are meant to stop working; and the chance of pausing is very low as it happen during an emergency\n\n\n\n**0xhiroshi**\n\nhttps://github.com/LooksRare/contracts-yolo/pull/180\n\n**nevillehuang**\n\nThe above comment is incorrect, since this can potentially impact outcome of game by bypassing an explicit rule/invariant of fixed 100 deposits per round, this should constitute medium severity\n\n**mstpr**\n\n> LooksRare/contracts-yolo#180\n\nFix LGTM!\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/163",
  "Code": [
    {
      "filename": "contracts-yolo/contracts/YoloV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {ITransferManager} from \"@looksrare/contracts-transfer-manager/contracts/interfaces/ITransferManager.sol\";\nimport {TokenType as TransferManager__TokenType} from \"@looksrare/contracts-transfer-manager/contracts/enums/TokenType.sol\";\nimport {IERC20} from \"@looksrare/contracts-libs/contracts/interfaces/generic/IERC20.sol\";\nimport {SignatureCheckerMemory} from \"@looksrare/contracts-libs/contracts/SignatureCheckerMemory.sol\";\nimport {ReentrancyGuard} from \"@looksrare/contracts-libs/contracts/ReentrancyGuard.sol\";\nimport {Pausable} from \"@looksrare/contracts-libs/contracts/Pausable.sol\";\n\nimport {LowLevelWETH} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelWETH.sol\";\nimport {LowLevelERC20Transfer} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol\";\nimport {LowLevelERC721Transfer} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC721Transfer.sol\";\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {VRFCoordinatorV2Interface} from \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport {VRFConsumerBaseV2} from \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\n\nimport {IYoloV2} from \"./interfaces/IYoloV2.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport {Arrays} from \"./libraries/Arrays.sol\";\n\n//                                          @@@@@@@@@@@@@                                        @@@@@@@@@@@@@\n// @@@@@@@@@@@@@@@       @@@@@@@@@@@@@@ @@@@%*+++++++++*%@@@@     @@@@@@@@@@@@@@             @@@@%+-:::::::-+%@@@@\n//  @#:........=@@      @@*.........+@@@@*=================*@@@   @@=........=@@           @@@+.................+@@@\n//  @@=........:#@@     @@.........:@@%+=====================+%@@ @@=........=@@         @@%-.....................-#@@\n//  @@%:........=@@    @@=........:%@*=========================+%@@@=........=@@       @@%-.........................=@@@\n//   @@+........:#@   @@#........:%%============================+#@@=........=@@      @@#:...........................:#@@\n//    @@:........+@@  @@:.......:#%%@#*=======*%%@@@%%*==========+%@=........=@@      @#:.........:=*%%@%%#=..........:#@@\n//    @@#........:%@ @@+........+%+==+#@@*==#@@@@   @@@@#=========+@#........=@@     @%-........:*@@@@   @@@@+:........-%@\n//     @@=........=@@@#:.......-%*=======*@@@@         @@@=========*@:.......+@@    @@*.........@@@         @@%:........+@@\n//      @%:.......:%@@=........=@+========*@@            @%=========@+.......+@@    @@-........%@@           @@*........=%@\n//      @@+:.....:.-@#:.:......+@@@@@@@@@@@@             @@%%%%%%%%#@#::....:+@@    @@:.:.....:@@             @@::.:..:.-%@\n//       @%-::::::::*-:::::::::@@*+++++++*@@             @@+++++++++@*:::::::+@@    @@:::::::::%@            @@%::::::::-%@\n//       @@%********=:::::::::*@@*+*#%@@@##@@           @@*========+@=:::::::+@@    @@=::::::::=@@           @@=::::::::+@@\n//        @@@@@@@@@@:::::::::=@@@@@#*++++++*@@        @@@+=========%@::::::::+@@     @%:::::::::=@@@       @@@=:::::::::#@@\n//               @@=:::::::::%@ @@*++++++++++*@@@@@@@@@*+========+#@+::::::::+%@@@@@@@%+::::::::::+@@@@@@@@@+::::::::::+@@\n//              @@#:::::::::*@@  @@*+++++++++*@#++++++==========+*@@+::::::::::::::::::::::::::::::::-===-::::::::::::=@@\n//              @@-::::::::-%@    @@#++++++++%%+===============+#@@@+::::::::::::::::::::::::::::::::::::::::::::::::*@@\n//             @@+:::::::::*@@     @@@*+++++%%+===============*%@@@@+:::::::::::::::::::::*=:::::::::::::::::::::::=%@@\n//             @%-::::::::=@@        @@@#++#@*+============+*@@@  @@+:::::::::::::::::::::%@%+-::::::::::::::::::+%@@\n//            @@%*********%@@          @@@@@*+==========+#@@@@    @@#*********************%@@@@@*-:::::::::::-*@@@@\n//            @@@@@@@@@@@@@@              @@@@@@@%%%@@@@@@@       @@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@%%%@@@@@@@\n//                                               @@@@                                                @@@@@\n\n/**\n * @title YoloV2\n * @notice This contract permissionlessly hosts yolos on LooksRare.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract YoloV2 is\n    IYoloV2,\n    AccessControl,\n    VRFConsumerBaseV2,\n    LowLevelWETH,\n    LowLevelERC20Transfer,\n    LowLevelERC721Transfer,\n    ReentrancyGuard,\n    Pausable\n{\n    using Arrays for uint256[];\n\n    /**\n     * @notice Operators are allowed to add/remove allowed ERC-20 and ERC-721 tokens.\n     */\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    /**\n     * @notice The TWAP period in seconds to use.\n     */\n    uint256 private constant TWAP_DURATION = 3_600;\n\n    /**\n     * @notice The maximum protocol fee in basis points, which is 25%.\n     */\n    uint16 public constant MAXIMUM_PROTOCOL_FEE_BP = 2_500;\n\n    /**\n     * @notice The maximum number of deposits per round.\n     */\n    uint256 private constant MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND = 100;\n\n    /**\n     * @notice Reservoir oracle's message typehash.\n     * @dev It is used to compute the hash of the message using the (message) id, the payload, and the timestamp.\n     */\n    bytes32 private constant RESERVOIR_ORACLE_MESSAGE_TYPEHASH =\n        keccak256(\"Message(bytes32 id,bytes payload,uint256 timestamp,uint256 chainId)\");\n\n    /**\n     * @notice Reservoir oracle's ID typehash.\n     * @dev It is used to compute the hash of the ID using price kind, TWAP seconds, and the contract address.\n     */\n    bytes32 private constant RESERVOIR_ORACLE_ID_TYPEHASH =\n        keccak256(\n            \"ContractWideCollectionPrice(uint8 kind,uint256 twapSeconds,address contract,bool onlyNonFlaggedTokens)\"\n        );\n\n    /**\n     * @notice The bits offset of the round's maximum number of participants in a round slot.\n     */\n    uint256 private constant ROUND__MAXIMUM_NUMBER_OF_PARTICIPANTS_OFFSET = 8;\n\n    /**\n     * @notice The bits offset of the round's protocol fee basis points in a round slot.\n     */\n    uint256 private constant ROUND__PROTOCOL_FEE_BP_OFFSET = 48;\n\n    /**\n     * @notice The bits offset of the round's cutoff time in a round slot.\n     */\n    uint256 private constant ROUND__CUTOFF_TIME_OFFSET = 64;\n\n    /**\n     * @notice The bits offset of the round's value per entry in a round slot.\n     */\n    uint256 private constant ROUND__VALUE_PER_ENTRY_OFFSET = 160;\n\n    /**\n     * @notice The slot offset of the round's value per entry starting from the round's slot.\n     */\n    uint256 private constant ROUND__VALUE_PER_ENTRY_SLOT_OFFSET = 1;\n\n    /**\n     * @notice The bits offset of the randomness request's round ID in a randomness request slot.\n     */\n    uint256 private constant RANDOMNESS_REQUEST__ROUND_ID_OFFSET = 8;\n\n    /**\n     * @notice The slot offset of the round's deposits length starting from the round's slot.\n     */\n    uint256 private constant ROUND__DEPOSITS_LENGTH_SLOT_OFFSET = 3;\n\n    /**\n     * @notice The number of slots a round struct occupies.\n     */\n    uint256 private constant DEPOSIT__OCCUPIED_SLOTS = 4;\n\n    /**\n     * @notice The slot offset of the deposit's token ID starting from the deposit's slot.\n     */\n    uint256 private constant DEPOSIT__TOKEN_ID_SLOT_OFFSET = 1;\n\n    /**\n     * @notice The slot offset of the deposit's token amount starting from the deposit's slot.\n     */\n    uint256 private constant DEPOSIT__TOKEN_AMOUNT_SLOT_OFFSET = 2;\n\n    /**\n     * @notice The slot offset of the deposit's last slot starting from the deposit's slot.\n     */\n    uint256 private constant DEPOSIT__LAST_SLOT_OFFSET = 3;\n\n    /**\n     * @notice The bits offset of the deposit's token address in the deposit's slot 0.\n     */\n    uint256 private constant DEPOSIT__TOKEN_ADDRESS_OFFSET = 8;\n\n    /**\n     * @notice The bits offset of the deposit's current entry index in the deposit's slot 3.\n     */\n    uint256 private constant DEPOSIT__CURRENT_ENTRY_INDEX_OFFSET = 168;\n\n    /**\n     * @notice Wrapped Ether address.\n     */\n    address private immutable WETH;\n\n    /**\n     * @notice The key hash of the Chainlink VRF.\n     */\n    bytes32 private immutable KEY_HASH;\n\n    /**\n     * @notice The subscription ID of the Chainlink VRF.\n     */\n    uint64 public immutable SUBSCRIPTION_ID;\n\n    /**\n     * @notice The Chainlink VRF coordinator.\n     */\n    VRFCoordinatorV2Interface private immutable VRF_COORDINATOR;\n\n    /**\n     * @notice Transfer manager faciliates token transfers.\n     */\n    ITransferManager private immutable transferManager;\n\n    /**\n     * @notice LOOKS token address.\n     */\n    address private immutable LOOKS;\n\n    /**\n     * @notice The value of each entry in ETH.\n     */\n    uint96 public valuePerEntry;\n\n    /**\n     * @notice The duration of each round.\n     */\n    uint40 public roundDuration;\n\n    /**\n     * @notice The protocol fee basis points.\n     */\n    uint16 public protocolFeeBp;\n\n    /**\n     * @notice The protocol fee discount basis points if paid with LOOKS.\n     */\n    uint16 public protocolFeeDiscountBp;\n\n    /**\n     * @notice Number of rounds that have been created.\n     * @dev In this smart contract, roundId is an uint256 but its\n     *      max value can only be 2^40 - 1. Realistically we will still\n     *      not reach this number.\n     */\n    uint40 public roundsCount;\n\n    /**\n     * @notice The maximum number of participants per round.\n     */\n    uint40 public maximumNumberOfParticipantsPerRound;\n\n    /**\n     * @notice Whether token outflow is allowed.\n     */\n    bool public outflowAllowed = true;\n\n    /**\n     * @notice The address of the protocol fee recipient.\n     */\n    address public protocolFeeRecipient;\n\n    /**\n     * @notice ERC-20 oracle address.\n     */\n    IPriceOracle public erc20Oracle;\n\n    /**\n     * @notice Reservoir oracle address.\n     */\n    address public reservoirOracle;\n\n    /**\n     * @notice Reservoir oracle's signature validity period.\n     */\n    uint40 public signatureValidityPeriod;\n\n    /**\n     * @notice It checks whether the currency is allowed.\n     * @dev 0 is not allowed, 1 is allowed.\n     */\n    mapping(address currency => uint256 isAllowed) public isCurrencyAllowed;\n\n    mapping(uint256 roundId => Round) private rounds;\n\n    /**\n     * @notice The deposit count of a user in any given round.\n     */\n    mapping(uint256 roundId => mapping(address depositor => uint256 depositCount)) public depositCount;\n\n    /**\n     * @notice Chainlink randomness requests.\n     */\n    mapping(uint256 requestId => RandomnessRequest) public randomnessRequests;\n\n    /**\n     * @notice The price of an ERC-20/ERC-712 token or a collection in any given round.\n     */\n    mapping(address tokenOrCollection => mapping(uint256 roundId => uint256 price)) public prices;\n\n    /**\n     * @param params The constructor params.\n     */\n    constructor(ConstructorCalldata memory params) VRFConsumerBaseV2(params.vrfCoordinator) {\n        _grantRole(DEFAULT_ADMIN_ROLE, params.owner);\n        _grantRole(OPERATOR_ROLE, params.operator);\n        _updateRoundDuration(params.roundDuration);\n        _updateProtocolFeeRecipient(params.protocolFeeRecipient);\n        _updateProtocolFeeBp(params.protocolFeeBp);\n        _updateProtocolFeeDiscountBp(params.protocolFeeDiscountBp);\n        _updateValuePerEntry(params.valuePerEntry);\n        _updateERC20Oracle(params.erc20Oracle);\n        _updateMaximumNumberOfParticipantsPerRound(params.maximumNumberOfParticipantsPerRound);\n        _updateReservoirOracle(params.reservoirOracle);\n        _updateSignatureValidityPeriod(params.signatureValidityPeriod);\n\n        WETH = params.weth;\n        KEY_HASH = params.keyHash;\n        VRF_COORDINATOR = VRFCoordinatorV2Interface(params.vrfCoordinator);\n        SUBSCRIPTION_ID = params.subscriptionId;\n        LOOKS = params.looks;\n\n        transferManager = ITransferManager(params.transferManager);\n\n        _startRound({_roundsCount: 0});\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function deposit(uint256 roundId, DepositCalldata[] calldata deposits) external payable nonReentrant whenNotPaused {\n        _deposit(roundId, deposits);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function depositETHIntoMultipleRounds(uint256[] calldata amounts) external payable nonReentrant whenNotPaused {\n        uint256 numberOfRounds = amounts.length;\n        if (msg.value == 0 || numberOfRounds == 0) {\n            revert ZeroDeposits();\n        }\n\n        uint256 startingRoundId = roundsCount;\n        Round storage startingRound = rounds[startingRoundId];\n        _validateRoundIsOpen(startingRound);\n\n        _setCutoffTimeIfNotSet(startingRound);\n\n        uint256 expectedValue;\n        uint256[] memory entriesCounts = new uint256[](numberOfRounds);\n\n        for (uint256 i; i < numberOfRounds; ++i) {\n            uint256 roundId = _unsafeAdd(startingRoundId, i);\n            Round storage round = rounds[roundId];\n            uint256 roundValuePerEntry = round.valuePerEntry;\n            if (roundValuePerEntry == 0) {\n                (, , roundValuePerEntry) = _writeDataToRound({roundId: roundId, roundValue: 0});\n            }\n\n            _incrementUserDepositCount(roundId, round);\n\n            uint256 depositAmount = amounts[i];\n            if (depositAmount % roundValuePerEntry != 0) {\n                revert InvalidValue();\n            }\n            uint256 entriesCount = _depositETH(round, roundId, roundValuePerEntry, depositAmount);\n            expectedValue += depositAmount;\n\n            entriesCounts[i] = entriesCount;\n        }\n\n        if (expectedValue != msg.value) {\n            revert InvalidValue();\n        }\n\n        emit MultipleRoundsDeposited(msg.sender, startingRoundId, amounts, entriesCounts);\n\n        if (\n            _shouldDrawWinner(\n                startingRound.numberOfParticipants,\n                startingRound.maximumNumberOfParticipants,\n                startingRound.deposits.length\n            )\n        ) {\n            _drawWinner(startingRound, startingRoundId);\n        }\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function getRound(\n        uint256 roundId\n    )\n        external\n        view\n        returns (\n            RoundStatus status,\n            uint40 maximumNumberOfParticipants,\n            uint16 roundProtocolFeeBp,\n            uint40 cutoffTime,\n            uint40 drawnAt,\n            uint40 numberOfParticipants,\n            address winner,\n            uint96 roundValuePerEntry,\n            uint256 protocolFeeOwed,\n            Deposit[] memory deposits\n        )\n    {\n        Round memory round = rounds[roundId];\n        status = round.status;\n        maximumNumberOfParticipants = round.maximumNumberOfParticipants;\n        roundProtocolFeeBp = round.protocolFeeBp;\n        cutoffTime = round.cutoffTime;\n        drawnAt = round.drawnAt;\n        numberOfParticipants = round.numberOfParticipants;\n        winner = round.winner;\n        roundValuePerEntry = round.valuePerEntry;\n        protocolFeeOwed = round.protocolFeeOwed;\n        deposits = round.deposits;\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function drawWinner() external nonReentrant whenNotPaused {\n        uint256 roundId = roundsCount;\n        Round storage round = rounds[roundId];\n\n        _validateRoundStatus(round, RoundStatus.Open);\n\n        if (block.timestamp < round.cutoffTime) {\n            revert CutoffTimeNotReached();\n        }\n\n        if (round.numberOfParticipants < 2) {\n            revert InsufficientParticipants();\n        }\n\n        _drawWinner(round, roundId);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function cancel() external nonReentrant {\n        _validateOutflowIsAllowed();\n        _cancel({roundId: roundsCount});\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function cancel(uint256 numberOfRounds) external {\n        _validateIsOwner();\n\n        if (numberOfRounds == 0) {\n            revert ZeroRounds();\n        }\n\n        uint256 startingRoundId = roundsCount;\n\n        for (uint256 i; i < numberOfRounds; ++i) {\n            uint256 roundId = _unsafeAdd(startingRoundId, i);\n            rounds[roundId].status = RoundStatus.Cancelled;\n        }\n\n        emit RoundsCancelled(startingRoundId, numberOfRounds);\n\n        _startRound({_roundsCount: _unsafeSubtract(_unsafeAdd(startingRoundId, numberOfRounds), 1)});\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function cancelAfterRandomnessRequest() external nonReentrant {\n        _validateOutflowIsAllowed();\n\n        uint256 roundId = roundsCount;\n        Round storage round = rounds[roundId];\n\n        _validateRoundStatus(round, RoundStatus.Drawing);\n\n        if (block.timestamp < round.drawnAt + 1 days) {\n            revert DrawExpirationTimeNotReached();\n        }\n\n        round.status = RoundStatus.Cancelled;\n\n        emit RoundStatusUpdated(roundId, RoundStatus.Cancelled);\n\n        _startRound({_roundsCount: roundId});\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function claimPrizes(\n        WithdrawalCalldata[] calldata withdrawalCalldata,\n        bool payWithLOOKS\n    ) external payable nonReentrant {\n        _validateOutflowIsAllowed();\n\n        TransferAccumulator memory transferAccumulator;\n        uint256 ethAmount;\n        uint256 protocolFeeOwed;\n\n        _validateArrayLengthIsNotEmpty(withdrawalCalldata.length);\n\n        if (payWithLOOKS) {\n            if (msg.value != 0) {\n                revert InvalidValue();\n            }\n        }\n\n        for (uint256 i; i < withdrawalCalldata.length; ++i) {\n            WithdrawalCalldata calldata perRoundWithdrawalCalldata = withdrawalCalldata[i];\n\n            Round storage round = rounds[perRoundWithdrawalCalldata.roundId];\n\n            _validateRoundStatus(round, RoundStatus.Drawn);\n            _validateMsgSenderIsWinner(round);\n\n            uint256[] calldata depositIndices = perRoundWithdrawalCalldata.depositIndices;\n            _validateArrayLengthIsNotEmpty(depositIndices.length);\n\n            for (uint256 j; j < depositIndices.length; ++j) {\n                uint256 index = depositIndices[j];\n                _validateDepositsArrayIndex(index, round);\n                ethAmount = _transferTokenOut(round.deposits[index], transferAccumulator, ethAmount);\n            }\n\n            protocolFeeOwed += round.protocolFeeOwed;\n            round.protocolFeeOwed = 0;\n        }\n\n        if (protocolFeeOwed != 0) {\n            if (payWithLOOKS) {\n                protocolFeeOwed = _protocolFeeOwedInLOOKS(protocolFeeOwed);\n\n                transferManager.transferERC20(LOOKS, msg.sender, protocolFeeRecipient, protocolFeeOwed);\n\n                emit ProtocolFeePayment(protocolFeeOwed, LOOKS);\n            } else {\n                _transferETHAndWrapIfFailWithGasLimit(WETH, protocolFeeRecipient, protocolFeeOwed, gasleft());\n\n                emit ProtocolFeePayment(protocolFeeOwed, address(0));\n\n                protocolFeeOwed -= msg.value;\n                if (protocolFeeOwed <= ethAmount) {\n                    unchecked {\n                        ethAmount -= protocolFeeOwed;\n                    }\n                } else {\n                    revert ProtocolFeeNotPaid();\n                }\n            }\n        }\n\n        if (transferAccumulator.amount != 0) {\n            _executeERC20DirectTransfer(transferAccumulator.tokenAddress, msg.sender, transferAccumulator.amount);\n        }\n\n        if (ethAmount != 0) {\n            _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, ethAmount, gasleft());\n        }\n\n        emit PrizesClaimed(msg.sender, withdrawalCalldata);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     * @dev This function does not validate withdrawalCalldata to not contain duplicate round IDs and prize indices.\n     *      It is the responsibility of the caller to ensure that. Otherwise, the returned protocol fee owed will be incorrect.\n     */\n    function getClaimPrizesPaymentRequired(\n        WithdrawalCalldata[] calldata withdrawalCalldata,\n        bool payWithLOOKS\n    ) external view returns (uint256 protocolFeeOwed) {\n        uint256 ethAmount;\n\n        for (uint256 i; i < withdrawalCalldata.length; ++i) {\n            WithdrawalCalldata calldata perRoundWithdrawalCalldata = withdrawalCalldata[i];\n            Round storage round = rounds[perRoundWithdrawalCalldata.roundId];\n\n            _validateRoundStatus(round, RoundStatus.Drawn);\n\n            uint256[] calldata depositIndices = perRoundWithdrawalCalldata.depositIndices;\n            uint256 numberOfPrizes = depositIndices.length;\n            uint256 prizesCount = round.deposits.length;\n\n            for (uint256 j; j < numberOfPrizes; ++j) {\n                uint256 index = depositIndices[j];\n                if (index >= prizesCount) {\n                    revert InvalidIndex();\n                }\n\n                Deposit storage prize = round.deposits[index];\n                if (prize.tokenType == YoloV2__TokenType.ETH) {\n                    ethAmount += prize.tokenAmount;\n                }\n            }\n\n            protocolFeeOwed += round.protocolFeeOwed;\n        }\n\n        if (payWithLOOKS) {\n            protocolFeeOwed = _protocolFeeOwedInLOOKS(protocolFeeOwed);\n        } else {\n            if (protocolFeeOwed < ethAmount) {\n                protocolFeeOwed = 0;\n            } else {\n                unchecked {\n                    protocolFeeOwed -= ethAmount;\n                }\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function withdrawDeposits(WithdrawalCalldata[] calldata withdrawalCalldata) external nonReentrant {\n        _validateOutflowIsAllowed();\n\n        TransferAccumulator memory transferAccumulator;\n        uint256 ethAmount;\n\n        _validateArrayLengthIsNotEmpty(withdrawalCalldata.length);\n\n        for (uint256 i; i < withdrawalCalldata.length; ++i) {\n            WithdrawalCalldata calldata perRoundWithdrawalCalldata = withdrawalCalldata[i];\n\n            Round storage round = rounds[perRoundWithdrawalCalldata.roundId];\n\n            _validateRoundStatus(round, RoundStatus.Cancelled);\n\n            uint256[] calldata depositIndices = perRoundWithdrawalCalldata.depositIndices;\n            uint256 depositIndicesLength = depositIndices.length;\n            _validateArrayLengthIsNotEmpty(depositIndicesLength);\n\n            for (uint256 j; j < depositIndicesLength; ++j) {\n                uint256 index = depositIndices[j];\n                _validateDepositsArrayIndex(index, round);\n\n                Deposit storage singleDeposit = round.deposits[index];\n\n                _validateMsgSenderIsDepositor(singleDeposit);\n\n                ethAmount = _transferTokenOut(singleDeposit, transferAccumulator, ethAmount);\n            }\n        }\n\n        if (transferAccumulator.amount != 0) {\n            _executeERC20DirectTransfer(transferAccumulator.tokenAddress, msg.sender, transferAccumulator.amount);\n        }\n\n        if (ethAmount != 0) {\n            _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, ethAmount, gasleft());\n        }\n\n        emit DepositsWithdrawn(msg.sender, withdrawalCalldata);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function rolloverETH(\n        WithdrawalCalldata[] calldata withdrawalCalldata,\n        bool payWithLOOKS\n    ) external nonReentrant whenNotPaused {\n        uint256 rolloverAmount;\n        uint256 protocolFeeOwed;\n\n        uint256 withdrawalCalldataLength = withdrawalCalldata.length;\n        _validateArrayLengthIsNotEmpty(withdrawalCalldataLength);\n\n        for (uint256 i; i < withdrawalCalldataLength; ++i) {\n            WithdrawalCalldata calldata perRoundWithdrawalCalldata = withdrawalCalldata[i];\n\n            Round storage cancelledOrDrawnRound = rounds[perRoundWithdrawalCalldata.roundId];\n\n            RoundStatus status = cancelledOrDrawnRound.status;\n            if (status < RoundStatus.Drawn) {\n                revert InvalidStatus();\n            }\n\n            if (status == RoundStatus.Drawn) {\n                _validateMsgSenderIsWinner(cancelledOrDrawnRound);\n                protocolFeeOwed += cancelledOrDrawnRound.protocolFeeOwed;\n                cancelledOrDrawnRound.protocolFeeOwed = 0;\n            }\n\n            uint256[] calldata depositIndices = perRoundWithdrawalCalldata.depositIndices;\n            uint256 depositIndicesLength = depositIndices.length;\n            _validateArrayLengthIsNotEmpty(depositIndicesLength);\n\n            for (uint256 j; j < depositIndicesLength; ++j) {\n                uint256 index = depositIndices[j];\n                _validateDepositsArrayIndex(index, cancelledOrDrawnRound);\n\n                Deposit storage singleDeposit = cancelledOrDrawnRound.deposits[index];\n\n                _validateDepositNotWithdrawn(singleDeposit);\n\n                if (singleDeposit.tokenType != YoloV2__TokenType.ETH) {\n                    revert InvalidTokenType();\n                }\n\n                if (status == RoundStatus.Cancelled) {\n                    _validateMsgSenderIsDepositor(singleDeposit);\n                }\n\n                singleDeposit.withdrawn = true;\n\n                rolloverAmount += singleDeposit.tokenAmount;\n            }\n        }\n\n        if (protocolFeeOwed != 0) {\n            if (payWithLOOKS) {\n                protocolFeeOwed = _protocolFeeOwedInLOOKS(protocolFeeOwed);\n                transferManager.transferERC20(LOOKS, msg.sender, protocolFeeRecipient, protocolFeeOwed);\n\n                emit ProtocolFeePayment(protocolFeeOwed, LOOKS);\n            } else {\n                if (rolloverAmount < protocolFeeOwed) {\n                    revert ProtocolFeeNotPaid();\n                } else {\n                    unchecked {\n                        rolloverAmount -= protocolFeeOwed;\n                    }\n                }\n\n                _transferETHAndWrapIfFailWithGasLimit(WETH, protocolFeeRecipient, protocolFeeOwed, gasleft());\n\n                emit ProtocolFeePayment(protocolFeeOwed, address(0));\n            }\n        }\n\n        uint256 roundId = roundsCount;\n        Round storage round = rounds[roundId];\n        _validateRoundIsOpen(round);\n\n        _incrementUserDepositCount(roundId, round);\n        _setCutoffTimeIfNotSet(round);\n\n        uint256 roundValuePerEntry = round.valuePerEntry;\n        uint256 dust = rolloverAmount % roundValuePerEntry;\n        if (dust != 0) {\n            unchecked {\n                rolloverAmount -= dust;\n            }\n            _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, dust, gasleft());\n        }\n\n        if (rolloverAmount < roundValuePerEntry) {\n            revert InvalidValue();\n        }\n\n        uint256 entriesCount = _depositETH(round, roundId, roundValuePerEntry, rolloverAmount);\n\n        if (_shouldDrawWinner(round.numberOfParticipants, round.maximumNumberOfParticipants, round.deposits.length)) {\n            _drawWinner(round, roundId);\n        }\n\n        emit Rollover(msg.sender, withdrawalCalldata, roundId, entriesCount);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function togglePaused() external {\n        _validateIsOwner();\n        paused() ? _unpause() : _pause();\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function toggleOutflowAllowed() external {\n        _validateIsOwner();\n        bool _outflowAllowed = outflowAllowed;\n        outflowAllowed = !_outflowAllowed;\n        emit OutflowAllowedUpdated(!_outflowAllowed);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateCurrenciesStatus(address[] calldata currencies, bool isAllowed) external {\n        _validateIsOperator();\n\n        uint256 count = currencies.length;\n        for (uint256 i; i < count; ++i) {\n            isCurrencyAllowed[currencies[i]] = (isAllowed ? 1 : 0);\n        }\n        emit CurrenciesStatusUpdated(currencies, isAllowed);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateRoundDuration(uint40 _roundDuration) external {\n        _validateIsOwner();\n        _updateRoundDuration(_roundDuration);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateSignatureValidityPeriod(uint40 _signatureValidityPeriod) external {\n        _validateIsOwner();\n        _updateSignatureValidityPeriod(_signatureValidityPeriod);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateValuePerEntry(uint96 _valuePerEntry) external {\n        _validateIsOwner();\n        _updateValuePerEntry(_valuePerEntry);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateProtocolFeeRecipient(address _protocolFeeRecipient) external {\n        _validateIsOwner();\n        _updateProtocolFeeRecipient(_protocolFeeRecipient);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateProtocolFeeBp(uint16 _protocolFeeBp) external {\n        _validateIsOwner();\n        _updateProtocolFeeBp(_protocolFeeBp);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateProtocolFeeDiscountBp(uint16 _protocolFeeDiscountBp) external {\n        _validateIsOwner();\n        _updateProtocolFeeDiscountBp(_protocolFeeDiscountBp);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateMaximumNumberOfParticipantsPerRound(uint40 _maximumNumberOfParticipantsPerRound) external {\n        _validateIsOwner();\n        _updateMaximumNumberOfParticipantsPerRound(_maximumNumberOfParticipantsPerRound);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateReservoirOracle(address _reservoirOracle) external {\n        _validateIsOwner();\n        _updateReservoirOracle(_reservoirOracle);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateERC20Oracle(address _erc20Oracle) external {\n        _validateIsOwner();\n        _updateERC20Oracle(_erc20Oracle);\n    }\n\n    /**\n     * @param _roundDuration The duration of each round.\n     */\n    function _updateRoundDuration(uint40 _roundDuration) private {\n        if (_roundDuration > 1 hours) {\n            revert InvalidRoundDuration();\n        }\n\n        roundDuration = _roundDuration;\n        emit RoundDurationUpdated(_roundDuration);\n    }\n\n    /**\n     * @param _signatureValidityPeriod The validity period of a Reservoir signature.\n     */\n    function _updateSignatureValidityPeriod(uint40 _signatureValidityPeriod) private {\n        signatureValidityPeriod = _signatureValidityPeriod;\n        emit SignatureValidityPeriodUpdated(_signatureValidityPeriod);\n    }\n\n    /**\n     * @param _valuePerEntry The value of each entry in ETH.\n     */\n    function _updateValuePerEntry(uint96 _valuePerEntry) private {\n        if (_valuePerEntry == 0) {\n            revert InvalidValue();\n        }\n        valuePerEntry = _valuePerEntry;\n        emit ValuePerEntryUpdated(_valuePerEntry);\n    }\n\n    /**\n     * @param _protocolFeeRecipient The new protocol fee recipient address\n     */\n    function _updateProtocolFeeRecipient(address _protocolFeeRecipient) private {\n        if (_protocolFeeRecipient == address(0)) {\n            revert InvalidValue();\n        }\n        protocolFeeRecipient = _protocolFeeRecipient;\n        emit ProtocolFeeRecipientUpdated(_protocolFeeRecipient);\n    }\n\n    /**\n     * @param _protocolFeeBp The new protocol fee in basis points\n     */\n    function _updateProtocolFeeBp(uint16 _protocolFeeBp) private {\n        if (_protocolFeeBp > MAXIMUM_PROTOCOL_FEE_BP) {\n            revert InvalidValue();\n        }\n        protocolFeeBp = _protocolFeeBp;\n        emit ProtocolFeeBpUpdated(_protocolFeeBp);\n    }\n\n    /**\n     * @param _protocolFeeDiscountBp The new protocol fee in basis points\n     */\n    function _updateProtocolFeeDiscountBp(uint16 _protocolFeeDiscountBp) private {\n        if (_protocolFeeDiscountBp > 10_000) {\n            revert InvalidValue();\n        }\n        protocolFeeDiscountBp = _protocolFeeDiscountBp;\n        emit ProtocolFeeDiscountBpUpdated(_protocolFeeDiscountBp);\n    }\n\n    /**\n     * @param _maximumNumberOfParticipantsPerRound The new maximum number of participants per round\n     */\n    function _updateMaximumNumberOfParticipantsPerRound(uint40 _maximumNumberOfParticipantsPerRound) private {\n        if (_maximumNumberOfParticipantsPerRound < 2) {\n            revert InvalidValue();\n        }\n        maximumNumberOfParticipantsPerRound = _maximumNumberOfParticipantsPerRound;\n        emit MaximumNumberOfParticipantsPerRoundUpdated(_maximumNumberOfParticipantsPerRound);\n    }\n\n    /**\n     * @param _reservoirOracle The new Reservoir oracle address\n     */\n    function _updateReservoirOracle(address _reservoirOracle) private {\n        if (_reservoirOracle == address(0)) {\n            revert InvalidValue();\n        }\n        reservoirOracle = _reservoirOracle;\n        emit ReservoirOracleUpdated(_reservoirOracle);\n    }\n\n    /**\n     * @param _erc20Oracle The new ERC-20 oracle address\n     */\n    function _updateERC20Oracle"
    }
  ]
}