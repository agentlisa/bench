{
  "Title": "[H01][Fixed] ETH could get trapped in the protocol",
  "Content": "The [`Controller` contract](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Controller.sol#L27) allows users to send arbitrary actions such as possible [flash loans](https://blog.openzeppelin.com/flash-loans-and-the-advent-of-episodic-finance/) through the [`_call` internal function](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Controller.sol#L763).\n\n\nAmong other features, it allows sending ETH with the action to then perform a call to a [`CalleeInterface` type of contract](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/interfaces/CalleeInterface.sol#L9).\n\n\nTo do so, it saves the original `msg.value` sent with the [`operate` function call](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Controller.sol#L331) in the [`ethLeft` variable](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Controller.sol#L460) and it [updates the remaining ETH left](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Controller.sol#L769) after each one of those calls to revert in case that it is not enough.\n\n\nNevertheless, if the user sends more than the necessary ETH for the batch of actions, the remaining ETH (stored in the `ethLeft` variable after the last iteration) will not be returned to the user and will be locked in the contract due to the lack of a `withdrawEth` function.\n\n\nConsider either returning all the remaining ETH to the user or creating a function that allows the user to collect the remaining ETH after performing a `Call` action type, taking into account that sending ETH with a push method may trigger the fallback function on the caller’s address.\n\n\n**Update:** *Fixed in [PR#304](https://github.com/opynfinance/GammaProtocol/pull/304) where the `payable` property is removed from the `operate` function. However this change also means it is impossible to do outbound calls which require ETH through the `operate` function.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Controller.sol",
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity =0.6.10;\n\npragma experimental ABIEncoderV2;\n\nimport {OwnableUpgradeSafe} from \"./packages/oz/upgradeability/OwnableUpgradeSafe.sol\";\nimport {ReentrancyGuardUpgradeSafe} from \"./packages/oz/upgradeability/ReentrancyGuardUpgradeSafe.sol\";\nimport {Initializable} from \"./packages/oz/upgradeability/Initializable.sol\";\nimport {SafeMath} from \"./packages/oz/SafeMath.sol\";\nimport {MarginVault} from \"./libs/MarginVault.sol\";\nimport {Actions} from \"./libs/Actions.sol\";\nimport {AddressBookInterface} from \"./interfaces/AddressBookInterface.sol\";\nimport {OtokenInterface} from \"./interfaces/OtokenInterface.sol\";\nimport {MarginCalculatorInterface} from \"./interfaces/MarginCalculatorInterface.sol\";\nimport {OracleInterface} from \"./interfaces/OracleInterface.sol\";\nimport {WhitelistInterface} from \"./interfaces/WhitelistInterface.sol\";\nimport {MarginPoolInterface} from \"./interfaces/MarginPoolInterface.sol\";\nimport {CalleeInterface} from \"./interfaces/CalleeInterface.sol\";\n\n/**\n * @title Controller\n * @author Opyn Team\n * @notice Contract that controls the Gamma Protocol and the interaction of all sub contracts\n */\ncontract Controller is Initializable, OwnableUpgradeSafe, ReentrancyGuardUpgradeSafe {\n    using MarginVault for MarginVault.Vault;\n    using SafeMath for uint256;\n\n    AddressBookInterface public addressbook;\n    WhitelistInterface public whitelist;\n    OracleInterface public oracle;\n    MarginCalculatorInterface public calculator;\n    MarginPoolInterface public pool;\n\n    ///@dev scale used in MarginCalculator\n    uint256 internal constant BASE = 8;\n\n    /// @notice address that has permission to partially pause the system, where system functionality is paused\n    /// except redeem and settleVault\n    address public partialPauser;\n\n    /// @notice address that has permission to fully pause the system, where all system functionality is paused\n    address public fullPauser;\n\n    /// @notice True if all system functionality is paused other than redeem and settle vault\n    bool public systemPartiallyPaused;\n\n    /// @notice True if all system functionality is paused\n    bool public systemFullyPaused;\n\n    /// @notice True if a call action can only be executed to a whitelisted callee\n    bool public callRestricted;\n\n    /// @dev mapping between an owner address and the number of owner address vaults\n    mapping(address => uint256) internal accountVaultCounter;\n    /// @dev mapping between an owner address and a specific vault using a vault id\n    mapping(address => mapping(uint256 => MarginVault.Vault)) internal vaults;\n    /// @dev mapping between an account owner and their approved or unapproved account operators\n    mapping(address => mapping(address => bool)) internal operators;\n\n    /// @notice emits an event when an account operator is updated for a specific account owner\n    event AccountOperatorUpdated(address indexed accountOwner, address indexed operator, bool isSet);\n    /// @notice emits an event when a new vault is opened\n    event VaultOpened(address indexed accountOwner, uint256 vaultId);\n    /// @notice emits an event when a long oToken is deposited into a vault\n    event LongOtokenDeposited(\n        address indexed otoken,\n        address indexed accountOwner,\n        address indexed from,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a long oToken is withdrawn from a vault\n    event LongOtokenWithdrawed(\n        address indexed otoken,\n        address indexed AccountOwner,\n        address indexed to,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a collateral asset is deposited into a vault\n    event CollateralAssetDeposited(\n        address indexed asset,\n        address indexed accountOwner,\n        address indexed from,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a collateral asset is withdrawn from a vault\n    event CollateralAssetWithdrawed(\n        address indexed asset,\n        address indexed AccountOwner,\n        address indexed to,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a short oToken is minted from a vault\n    event ShortOtokenMinted(\n        address indexed otoken,\n        address indexed AccountOwner,\n        address indexed to,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when a short oToken is burned\n    event ShortOtokenBurned(\n        address indexed otoken,\n        address indexed AccountOwner,\n        address indexed from,\n        uint256 vaultId,\n        uint256 amount\n    );\n    /// @notice emits an event when an oToken is redeemed\n    event Redeem(\n        address indexed otoken,\n        address indexed redeemer,\n        address indexed receiver,\n        address collateralAsset,\n        uint256 otokenBurned,\n        uint256 payout\n    );\n    /// @notice emits an event when a vault is settled\n    event VaultSettled(address indexed AccountOwner, address indexed to, uint256 vaultId, uint256 payout);\n    /// @notice emits an event when a call action is executed\n    event CallExecuted(\n        address indexed from,\n        address indexed to,\n        address indexed vaultOwner,\n        uint256 vaultId,\n        bytes data\n    );\n    /// @notice emits an event when the fullPauser address changes\n    event FullPauserUpdated(address indexed oldFullPauser, address indexed newFullPauser);\n    /// @notice emits an event when the partialPauser address changes\n    event PartialPauserUpdated(address indexed oldPartialPauser, address indexed newPartialPauser);\n    /// @notice emits an event when the system partial paused status changes\n    event SystemPartiallyPaused(bool isActive);\n    /// @notice emits an event when the system fully paused status changes\n    event SystemFullyPaused(bool isActive);\n    /// @notice emits an event when the call action restriction changes\n    event CallRestricted(bool isRestricted);\n\n    /**\n     * @notice modifier to check if the system is not partially paused, where only redeem and settleVault is allowed\n     */\n    modifier notPartiallyPaused {\n        _isNotPartiallyPaused();\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if the system is not fully paused, where no functionality is allowed\n     */\n    modifier notFullyPaused {\n        _isNotFullyPaused();\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if sender is the fullPauser address\n     */\n    modifier onlyFullPauser {\n        require(msg.sender == fullPauser, \"Controller: sender is not fullPauser\");\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if the sender is the partialPauser address\n     */\n    modifier onlyPartialPauser {\n        require(msg.sender == partialPauser, \"Controller: sender is not partialPauser\");\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if the sender is the account owner or an approved account operator\n     * @param _sender sender address\n     * @param _accountOwner account owner address\n     */\n    modifier onlyAuthorized(address _sender, address _accountOwner) {\n        _isAuthorized(_sender, _accountOwner);\n\n        _;\n    }\n\n    /**\n     * @notice modifier to check if the called address is a whitelisted callee address\n     * @param _callee called address\n     */\n    modifier onlyWhitelistedCallee(address _callee) {\n        if (callRestricted) {\n            require(_isCalleeWhitelisted(_callee), \"Controller: callee is not a whitelisted address\");\n        }\n\n        _;\n    }\n\n    /**\n     * @dev check if the system is not in a partiallyPaused state\n     */\n    function _isNotPartiallyPaused() internal view {\n        require(!systemPartiallyPaused, \"Controller: system is partially paused\");\n    }\n\n    /**\n     * @dev check if the system is not in an fullyPaused state\n     */\n    function _isNotFullyPaused() internal view {\n        require(!systemFullyPaused, \"Controller: system is fully paused\");\n    }\n\n    /**\n     * @dev check if the sender is an authorized operator\n     * @param _sender msg.sender\n     * @param _accountOwner owner of a vault\n     */\n    function _isAuthorized(address _sender, address _accountOwner) internal view {\n        require(\n            (_sender == _accountOwner) || (operators[_accountOwner][_sender]),\n            \"Controller: msg.sender is not authorized to run action\"\n        );\n    }\n\n    /**\n     * @notice initalize the deployed contract\n     * @param _addressBook addressbook module\n     * @param _owner account owner address\n     */\n    function initialize(address _addressBook, address _owner) external initializer {\n        require(_addressBook != address(0), \"Controller: invalid addressbook address\");\n        require(_owner != address(0), \"Controller: invalid owner address\");\n\n        __Context_init_unchained();\n        __Ownable_init_unchained(_owner);\n        __ReentrancyGuard_init_unchained();\n\n        addressbook = AddressBookInterface(_addressBook);\n        _refreshConfigInternal();\n    }\n\n    /**\n     * @notice allows the partialPauser to toggle the systemPartiallyPaused variable and partially pause or partially unpause the system\n     * @dev can only be called by the partialPauser\n     * @param _partiallyPaused new boolean value to set systemPartiallyPaused to\n     */\n    function setSystemPartiallyPaused(bool _partiallyPaused) external onlyPartialPauser {\n        systemPartiallyPaused = _partiallyPaused;\n\n        emit SystemPartiallyPaused(systemPartiallyPaused);\n    }\n\n    /**\n     * @notice allows the fullPauser to toggle the systemFullyPaused variable and fully pause or fully unpause the system\n     * @dev can only be called by the fullPauser\n     * @param _fullyPaused new boolean value to set systemFullyPaused to\n     */\n    function setSystemFullyPaused(bool _fullyPaused) external onlyFullPauser {\n        systemFullyPaused = _fullyPaused;\n\n        emit SystemFullyPaused(systemFullyPaused);\n    }\n\n    /**\n     * @notice allows the owner to set the fullPauser address\n     * @dev can only be called by the owner\n     * @param _fullPauser new fullPauser address\n     */\n    function setFullPauser(address _fullPauser) external onlyOwner {\n        require(_fullPauser != address(0), \"Controller: fullPauser cannot be set to address zero\");\n\n        emit FullPauserUpdated(fullPauser, _fullPauser);\n\n        fullPauser = _fullPauser;\n    }\n\n    /**\n     * @notice allows the owner to set the partialPauser address\n     * @dev can only be called by the owner\n     * @param _partialPauser new partialPauser address\n     */\n    function setPartialPauser(address _partialPauser) external onlyOwner {\n        require(_partialPauser != address(0), \"Controller: partialPauser cannot be set to address zero\");\n\n        emit PartialPauserUpdated(partialPauser, _partialPauser);\n\n        partialPauser = _partialPauser;\n    }\n\n    /**\n     * @notice allows the owner to toggle the restriction on whitelisted call actions and only allow whitelisted\n     * call addresses or allow any arbitrary call addresses\n     * @dev can only be called by the owner\n     * @param _isRestricted new call restriction state\n     */\n    function setCallRestriction(bool _isRestricted) external onlyOwner {\n        callRestricted = _isRestricted;\n\n        emit CallRestricted(callRestricted);\n    }\n\n    /**\n     * @notice allows a user to give or revoke privileges to an operator which can act on their behalf on their vaults\n     * @dev can only be updated by the vault owner\n     * @param _operator operator that the sender wants to give privileges to or revoke them from\n     * @param _isOperator new boolean value that expresses if the sender is giving or revoking privileges for _operator\n     */\n    function setOperator(address _operator, bool _isOperator) external {\n        operators[msg.sender][_operator] = _isOperator;\n\n        emit AccountOperatorUpdated(msg.sender, _operator, _isOperator);\n    }\n\n    /**\n     * @dev updates the configuration of the controller. can only be called by the owner\n     */\n    function refreshConfiguration() external onlyOwner {\n        _refreshConfigInternal();\n    }\n\n    /**\n     * @notice execute a number of actions on specific vaults\n     * @dev can only be called when the system is not fully paused\n     * @param _actions array of actions arguments\n     */\n    function operate(Actions.ActionArgs[] memory _actions) external payable nonReentrant notFullyPaused {\n        (bool vaultUpdated, address vaultOwner, uint256 vaultId) = _runActions(_actions);\n        if (vaultUpdated) _verifyFinalState(vaultOwner, vaultId);\n    }\n\n    /**\n     * @notice check if a specific address is an operator for an owner account\n     * @param _owner account owner address\n     * @param _operator account operator address\n     * @return True if the _operator is an approved operator for the _owner account\n     */\n    function isOperator(address _owner, address _operator) external view returns (bool) {\n        return operators[_owner][_operator];\n    }\n\n    /**\n     * @notice returns the current controller configuration\n     * @return whitelist, the address of the whitelist module\n     * @return oracle, the address of the oracle module\n     * @return calculator, the address of the calculator module\n     * @return pool, the address of the pool module\n     */\n    function getConfiguration()\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            address\n        )\n    {\n        return (address(whitelist), address(oracle), address(calculator), address(pool));\n    }\n\n    /**\n     * @notice return a vault's proceeds pre or post expiry, the amount of collateral that can be removed from a vault\n     * @param _owner account owner of the vault\n     * @param _vaultId vaultId to return balances for\n     * @return amount of collateral that can be taken out\n     */\n    function getProceed(address _owner, uint256 _vaultId) external view returns (uint256) {\n        MarginVault.Vault memory vault = getVault(_owner, _vaultId);\n\n        (uint256 netValue, ) = calculator.getExcessCollateral(vault);\n        return netValue;\n    }\n\n    /**\n     * @notice get an oToken's payout/cash value after expiry, in the collateral asset\n     * @param _otoken oToken address\n     * @param _amount amount of the oToken to calculate the payout for, always represented in 1e8\n     * @return amount of collateral to pay out\n     */\n    function getPayout(address _otoken, uint256 _amount) public view returns (uint256) {\n        uint256 rate = calculator.getExpiredPayoutRate(_otoken);\n        return rate.mul(_amount).div(10**BASE);\n    }\n\n    /**\n     * @dev return if an expired oToken contract’s settlement price has been finalized\n     * @param _otoken address of the oToken\n     * @return True if the oToken has expired AND all oracle prices at the expiry timestamp have been finalized, False if not\n     */\n    function isSettlementAllowed(address _otoken) public view returns (bool) {\n        OtokenInterface otoken = OtokenInterface(_otoken);\n\n        address underlying = otoken.underlyingAsset();\n        address strike = otoken.strikeAsset();\n        address collateral = otoken.collateralAsset();\n\n        uint256 expiry = otoken.expiryTimestamp();\n\n        bool isUnderlyingFinalized = oracle.isDisputePeriodOver(underlying, expiry);\n        bool isStrikeFinalized = oracle.isDisputePeriodOver(strike, expiry);\n        bool isCollateralFinalized = oracle.isDisputePeriodOver(collateral, expiry);\n\n        return isUnderlyingFinalized && isStrikeFinalized && isCollateralFinalized;\n    }\n\n    /**\n     * @notice get the number of vaults for a specified account owner\n     * @param _accountOwner account owner address\n     * @return number of vaults\n     */\n    function getAccountVaultCounter(address _accountOwner) external view returns (uint256) {\n        return accountVaultCounter[_accountOwner];\n    }\n\n    /**\n     * @notice check if an oToken has expired\n     * @param _otoken oToken address\n     * @return True if the otoken has expired, False if not\n     */\n    function hasExpired(address _otoken) external view returns (bool) {\n        uint256 otokenExpiryTimestamp = OtokenInterface(_otoken).expiryTimestamp();\n\n        return now > otokenExpiryTimestamp;\n    }\n\n    /**\n     * @notice return a specific vault\n     * @param _owner account owner\n     * @param _vaultId vault id of vault to return\n     * @return Vault struct that corresponds to the _vaultId of _owner\n     */\n    function getVault(address _owner, uint256 _vaultId) public view returns (MarginVault.Vault memory) {\n        return vaults[_owner][_vaultId];\n    }\n\n    /**\n     * @notice execute a variety of actions\n     * @dev for each action in the action array, execute the corresponding action, only one vault can be modified\n     * for all actions except SettleVault, Redeem, and Call\n     * @param _actions array of type Actions.ActionArgs[], which expresses which actions the user wants to execute\n     * @return vaultUpdated, indicates if a vault has changed\n     * @return owner, the vault owner if a vault has changed\n     * @return vaultId, the vault Id if a vault has changed\n     */\n    function _runActions(Actions.ActionArgs[] memory _actions)\n        internal\n        returns (\n            bool,\n            address,\n            uint256\n        )\n    {\n        address vaultOwner;\n        uint256 vaultId;\n        uint256 ethLeft = msg.value;\n        bool vaultUpdated;\n\n        for (uint256 i = 0; i < _actions.length; i++) {\n            Actions.ActionArgs memory action = _actions[i];\n            Actions.ActionType actionType = action.actionType;\n\n            if (\n                (actionType != Actions.ActionType.SettleVault) &&\n                (actionType != Actions.ActionType.Redeem) &&\n                (actionType != Actions.ActionType.Call)\n            ) {\n                // check if this action is manipulating the same vault as all other actions, if a vault has already been updated\n                if (vaultUpdated) {\n                    require(vaultOwner == action.owner, \"Controller: can not run actions for different owners\");\n                    require(vaultId == action.vaultId, \"Controller: can not run actions on different vaults\");\n                }\n                vaultUpdated = true;\n                vaultId = action.vaultId;\n                vaultOwner = action.owner;\n            }\n\n            if (actionType == Actions.ActionType.OpenVault) {\n                _openVault(Actions._parseOpenVaultArgs(action));\n            } else if (actionType == Actions.ActionType.DepositLongOption) {\n                _depositLong(Actions._parseDepositArgs(action));\n            } else if (actionType == Actions.ActionType.WithdrawLongOption) {\n                _withdrawLong(Actions._parseWithdrawArgs(action));\n            } else if (actionType == Actions.ActionType.DepositCollateral) {\n                _depositCollateral(Actions._parseDepositArgs(action));\n            } else if (actionType == Actions.ActionType.WithdrawCollateral) {\n                _withdrawCollateral(Actions._parseWithdrawArgs(action));\n            } else if (actionType == Actions.ActionType.MintShortOption) {\n                _mintOtoken(Actions._parseMintArgs(action));\n            } else if (actionType == Actions.ActionType.BurnShortOption) {\n                _burnOtoken(Actions._parseBurnArgs(action));\n            } else if (actionType == Actions.ActionType.Redeem) {\n                _redeem(Actions._parseRedeemArgs(action));\n            } else if (actionType == Actions.ActionType.SettleVault) {\n                _settleVault(Actions._parseSettleVaultArgs(action));\n            } else {\n                // actionType == Actions.ActionType.Call\n                ethLeft = _call(Actions._parseCallArgs(action), ethLeft);\n            }\n        }\n\n        return (vaultUpdated, vaultOwner, vaultId);\n    }\n\n    /**\n     * @notice verify the vault final state after executing all actions\n     * @param _owner account owner address\n     * @param _vaultId vault id of the final vault\n     */\n    function _verifyFinalState(address _owner, uint256 _vaultId) internal view {\n        MarginVault.Vault memory _vault = getVault(_owner, _vaultId);\n        (, bool isValidVault) = calculator.getExcessCollateral(_vault);\n\n        require(isValidVault, \"Controller: invalid final vault state\");\n    }\n\n    /**\n     * @notice open a new vault inside an account\n     * @dev only the account owner or operator can open a vault, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args OpenVaultArgs structure\n     */\n    function _openVault(Actions.OpenVaultArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        accountVaultCounter[_args.owner] = accountVaultCounter[_args.owner].add(1);\n\n        require(\n            _args.vaultId == accountVaultCounter[_args.owner],\n            \"Controller: can not run actions on inexistent vault\"\n        );\n\n        emit VaultOpened(_args.owner, accountVaultCounter[_args.owner]);\n    }\n\n    /**\n     * @notice deposit a long oToken into a vault\n     * @dev only the account owner or operator can deposit a long oToken, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args DepositArgs structure\n     */\n    function _depositLong(Actions.DepositArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"Controller: invalid vault id\");\n        require(\n            (_args.from == msg.sender) || (_args.from == _args.owner),\n            \"Controller: cannot deposit long otoken from this address\"\n        );\n\n        require(\n            whitelist.isWhitelistedOtoken(_args.asset),\n            \"Controller: otoken is not whitelisted to be used as collateral\"\n        );\n\n        OtokenInterface otoken = OtokenInterface(_args.asset);\n\n        require(now < otoken.expiryTimestamp(), \"Controller: otoken used as collateral is already expired\");\n\n        vaults[_args.owner][_args.vaultId].addLong(_args.asset, _args.amount, _args.index);\n\n        pool.transferToPool(_args.asset, _args.from, _args.amount);\n\n        emit LongOtokenDeposited(_args.asset, _args.owner, _args.from, _args.vaultId, _args.amount);\n    }\n\n    /**\n     * @notice withdraw a long oToken from a vault\n     * @dev only the account owner or operator can withdraw a long oToken, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args WithdrawArgs structure\n     */\n    function _withdrawLong(Actions.WithdrawArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"Controller: invalid vault id\");\n\n        OtokenInterface otoken = OtokenInterface(_args.asset);\n\n        require(now < otoken.expiryTimestamp(), \"Controller: can not withdraw an expired otoken\");\n\n        vaults[_args.owner][_args.vaultId].removeLong(_args.asset, _args.amount, _args.index);\n\n        pool.transferToUser(_args.asset, _args.to, _args.amount);\n\n        emit LongOtokenWithdrawed(_args.asset, _args.owner, _args.to, _args.vaultId, _args.amount);\n    }\n\n    /**\n     * @notice deposit a collateral asset into a vault\n     * @dev only the account owner or operator can deposit collateral, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args DepositArgs structure\n     */\n    function _depositCollateral(Actions.DepositArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"Controller: invalid vault id\");\n        require(\n            (_args.from == msg.sender) || (_args.from == _args.owner),\n            \"Controller: cannot deposit collateral from this address\"\n        );\n\n        require(\n            whitelist.isWhitelistedCollateral(_args.asset),\n            \"Controller: asset is not whitelisted to be used as collateral\"\n        );\n\n        vaults[_args.owner][_args.vaultId].addCollateral(_args.asset, _args.amount, _args.index);\n\n        pool.transferToPool(_args.asset, _args.from, _args.amount);\n\n        emit CollateralAssetDeposited(_args.asset, _args.owner, _args.from, _args.vaultId, _args.amount);\n    }\n\n    /**\n     * @notice withdraw a collateral asset from a vault\n     * @dev only the account owner or operator can withdraw collateral, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args WithdrawArgs structure\n     */\n    function _withdrawCollateral(Actions.WithdrawArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"Controller: invalid vault id\");\n\n        MarginVault.Vault memory vault = getVault(_args.owner, _args.vaultId);\n        if (_isNotEmpty(vault.shortOtokens)) {\n            OtokenInterface otoken = OtokenInterface(vault.shortOtokens[0]);\n\n            require(\n                now < otoken.expiryTimestamp(),\n                \"Controller: can not withdraw collateral from a vault with an expired short otoken\"\n            );\n        }\n\n        vaults[_args.owner][_args.vaultId].removeCollateral(_args.asset, _args.amount, _args.index);\n\n        pool.transferToUser(_args.asset, _args.to, _args.amount);\n\n        emit CollateralAssetWithdrawed(_args.asset, _args.owner, _args.to, _args.vaultId, _args.amount);\n    }\n\n    /**\n     * @notice mint short oTokens from a vault which creates an obligation that is recorded in the vault\n     * @dev only the account owner or operator can mint an oToken, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args MintArgs structure\n     */\n    function _mintOtoken(Actions.MintArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"Controller: invalid vault id\");\n\n        require(whitelist.isWhitelistedOtoken(_args.otoken), \"Controller: otoken is not whitelisted to be minted\");\n\n        OtokenInterface otoken = OtokenInterface(_args.otoken);\n\n        require(now < otoken.expiryTimestamp(), \"Controller: can not mint expired otoken\");\n\n        vaults[_args.owner][_args.vaultId].addShort(_args.otoken, _args.amount, _args.index);\n\n        otoken.mintOtoken(_args.to, _args.amount);\n\n        emit ShortOtokenMinted(_args.otoken, _args.owner, _args.to, _args.vaultId, _args.amount);\n    }\n\n    /**\n     * @notice burn oTokens to reduce or remove the minted oToken obligation recorded in a vault\n     * @dev only the account owner or operator can burn an oToken, cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args MintArgs structure\n     */\n    function _burnOtoken(Actions.BurnArgs memory _args)\n        internal\n        notPartiallyPaused\n        onlyAuthorized(msg.sender, _args.owner)\n    {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"Controller: invalid vault id\");\n        require((_args.from == msg.sender) || (_args.from == _args.owner), \"Controller: cannot burn from this address\");\n\n        OtokenInterface otoken = OtokenInterface(_args.otoken);\n\n        require(now < otoken.expiryTimestamp(), \"Controller: can not burn expired otoken\");\n\n        vaults[_args.owner][_args.vaultId].removeShort(_args.otoken, _args.amount, _args.index);\n\n        otoken.burnOtoken(_args.from, _args.amount);\n\n        emit ShortOtokenBurned(_args.otoken, _args.owner, _args.from, _args.vaultId, _args.amount);\n    }\n\n    /**\n     * @notice redeem an oToken after expiry, receiving the payout of the oToken in the collateral asset\n     * @dev cannot be called when system is fullyPaused\n     * @param _args RedeemArgs structure\n     */\n    function _redeem(Actions.RedeemArgs memory _args) internal {\n        OtokenInterface otoken = OtokenInterface(_args.otoken);\n\n        require(now > otoken.expiryTimestamp(), \"Controller: can not redeem un-expired otoken\");\n\n        require(isSettlementAllowed(_args.otoken), \"Controller: asset prices not finalized yet\");\n\n        uint256 payout = getPayout(_args.otoken, _args.amount);\n\n        otoken.burnOtoken(msg.sender, _args.amount);\n\n        pool.transferToUser(otoken.collateralAsset(), _args.receiver, payout);\n\n        emit Redeem(_args.otoken, msg.sender, _args.receiver, otoken.collateralAsset(), _args.amount, payout);\n    }\n\n    /**\n     * @notice settle a vault after expiry, removing the net proceeds/collateral after both long and short oToken payouts have settled\n     * @dev deletes a vault of vaultId after net proceeds/collateral is removed, cannot be called when system is fullyPaused\n     * @param _args SettleVaultArgs structure\n     */\n    function _settleVault(Actions.SettleVaultArgs memory _args) internal onlyAuthorized(msg.sender, _args.owner) {\n        require(_checkVaultId(_args.owner, _args.vaultId), \"Controller: invalid vault id\");\n\n        MarginVault.Vault memory vault = getVault(_args.owner, _args.vaultId);\n\n        require(_isNotEmpty(vault.shortOtokens) || _isNotEmpty(vault.longOtokens), \"Can't settle vault with no otoken\");\n\n        OtokenInterface otoken = _isNotEmpty(vault.shortOtokens)\n            ? OtokenInterface(vault.shortOtokens[0])\n            : OtokenInterface(vault.longOtokens[0]);\n\n        require(now > otoken.expiryTimestamp(), \"Controller: can not settle vault with un-expired otoken\");\n        require(isSettlementAllowed(address(otoken)), \"Controller: asset prices not finalized yet\");\n\n        (uint256 payout, ) = calculator.getExcessCollateral(vault);\n\n        if (_isNotEmpty(vault.longOtokens)) {\n            OtokenInterface longOtoken = OtokenInterface(vault.longOtokens[0]);\n\n            longOtoken.burnOtoken(address(pool), vault.longAmounts[0]);\n        }\n\n        delete vaults[_args.owner][_args.vaultId];\n\n        pool.transferToUser(otoken.collateralAsset(), _args.to, payout);\n\n        emit VaultSettled(_args.owner, _args.to, _args.vaultId, payout);\n    }\n\n    /**\n     * @notice execute arbitrary calls\n     * @dev cannot be called when system is partiallyPaused or fullyPaused\n     * @param _args Call action\n     * @param _ethLeft amount of eth left for this call.\n     */\n    function _call(Actions.CallArgs memory _args, uint256 _ethLeft)\n        internal\n        notPartiallyPaused\n        onlyWhitelistedCallee(_args.callee)\n        returns (uint256)\n    {\n        _ethLeft = _ethLeft.sub(_args.msgValue, \"Controller: msg.value and CallArgs.value mismatch\");\n        CalleeInterface(_args.callee).callFunction{value: _args.msgValue}(\n            msg.sender,\n            _args.owner,\n            _args.vaultId,\n            _args.data\n        );\n\n        emit CallExecuted(msg.sender, _args.callee, _args.owner, _args.vaultId, _args.data);\n\n        return _ethLeft;\n    }\n\n    /**\n     * @notice check if a vault id is valid for a given account owner address\n     * @param _accountOwner account owner address\n     * @param _vaultId vault id to check\n     * @return True if the _vaultId is valid, False if not\n     */\n    function _checkVaultId(address _accountOwner, uint256 _vaultId) internal view returns (bool) {\n        return ((_vaultId > 0) && (_vaultId <= accountVaultCounter[_accountOwner]));\n    }\n\n    function _isNotEmpty(address[] memory _array) internal pure returns (bool) {\n        return (_array.length > 0) && (_array[0] != address(0));\n    }\n\n    /**\n     * @notice return if a callee address is whitelisted or not\n     * @param _callee callee address\n     * @return True if callee address is whitelisted, False if not\n     */\n    function _isCalleeWhitelisted(address _callee) internal view returns (bool) {\n        return whitelist.isWhitelistedCallee(_callee);\n    }\n\n    /**\n     * @dev updates the internal configuration of the controller\n     */\n    function _refreshConfigInternal() internal {\n        whitelist = WhitelistInterface(addressbook.getWhitelist());\n        oracle = OracleInterface(addressbook.getOracle());\n        calculator = MarginCalculatorInterface(addressbook.getMarginCalculator());\n        pool = MarginPoolInterface(addressbook.getMarginPool());\n    }\n}"
    },
    {
      "filename": "contracts/interfaces/CalleeInterface.sol",
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\n/**\n * @dev Contract interface that can be called from Controller as a call action.\n */\ninterface CalleeInterface {\n    /**\n     * Allows users to send this contract arbitrary data.\n     * @"
    }
  ]
}