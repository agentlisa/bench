{
  "Title": "[14] Lower-bound the minimum execution delay in `ValidatorTimelock`",
  "Content": "\n[ValidatorTimelock, function `setExecutionDelay`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/ValidatorTimelock.sol#L59C1-L62C6)\n\n```diff\n+   uint32 MIN_EXECUTION_DELAY = uint32(1 hours); // whatever\n\n    function setExecutionDelay(uint32 _executionDelay) external onlyOwner {\n+       require(_executionDelay >= MIN_EXECUTION_DELAY, \"Don't do that\");\n        executionDelay = _executionDelay;\n        emit NewExecutionDelay(_executionDelay);\n    }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/zksync/ValidatorTimelock.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"./libraries/LibMap.sol\";\nimport \"./interfaces/IExecutor.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Intermediate smart contract between the validator EOA account and the zkSync smart contract.\n/// @dev The primary purpose of this contract is to provide a trustless means of delaying batch execution without\n/// modifying the main zkSync contract. As such, even if this contract is compromised, it will not impact the main\n/// contract.\n/// @dev zkSync actively monitors the chain activity and reacts to any suspicious activity by freezing the chain.\n/// This allows time for investigation and mitigation before resuming normal operations.\n/// @dev The contract overloads all of the 4 methods, that are used in state transition. When the batch is committed,\n/// the timestamp is stored for it. Later, when the owner calls the batch execution, the contract checks that batch\n/// was committed not earlier than X time ago.\ncontract ValidatorTimelock is IExecutor, Ownable2Step {\n    using LibMap for LibMap.Uint32Map;\n\n    /// @dev Part of the IBase interface. Not used in this contract.\n    string public constant override getName = \"ValidatorTimelock\";\n\n    /// @notice The delay between committing and executing batches is changed.\n    event NewExecutionDelay(uint256 _newExecutionDelay);\n\n    /// @notice The validator address is changed.\n    event NewValidator(address _oldValidator, address _newValidator);\n\n    /// @dev The main zkSync smart contract.\n    address public immutable zkSyncContract;\n\n    /// @dev The mapping of L2 batch number => timestamp when it was committed.\n    LibMap.Uint32Map internal committedBatchTimestamp;\n\n    /// @dev The address that can commit/revert/validate/execute batches.\n    address public validator;\n\n    /// @dev The delay between committing and executing batches.\n    uint32 public executionDelay;\n\n    constructor(address _initialOwner, address _zkSyncContract, uint32 _executionDelay, address _validator) {\n        _transferOwnership(_initialOwner);\n        zkSyncContract = _zkSyncContract;\n        executionDelay = _executionDelay;\n        validator = _validator;\n    }\n\n    /// @dev Set new validator address.\n    function setValidator(address _newValidator) external onlyOwner {\n        address oldValidator = validator;\n        validator = _newValidator;\n        emit NewValidator(oldValidator, _newValidator);\n    }\n\n    /// @dev Set the delay between committing and executing batches.\n    function setExecutionDelay(uint32 _executionDelay) external onlyOwner {\n        executionDelay = _executionDelay;\n        emit NewExecutionDelay(_executionDelay);\n    }\n\n    /// @notice Checks if the caller is a validator.\n    modifier onlyValidator() {\n        require(msg.sender == validator, \"8h\");\n        _;\n    }\n\n    /// @dev Returns the timestamp when `_l2BatchNumber` was committed.\n    function getCommittedBatchTimestamp(uint256 _l2BatchNumber) external view returns (uint256) {\n        return committedBatchTimestamp.get(_l2BatchNumber);\n    }\n\n    /// @dev Records the timestamp for all provided committed batches and make\n    /// a call to the zkSync contract with the same calldata.\n    function commitBatches(\n        StoredBatchInfo calldata,\n        CommitBatchInfo[] calldata _newBatchesData\n    ) external onlyValidator {\n        unchecked {\n            // This contract is only a temporary solution, that hopefully will be disabled until 2106 year, so...\n            // It is safe to cast.\n            uint32 timestamp = uint32(block.timestamp);\n            for (uint256 i = 0; i < _newBatchesData.length; ++i) {\n                committedBatchTimestamp.set(_newBatchesData[i].batchNumber, timestamp);\n            }\n        }\n\n        _propagateToZkSync();\n    }\n\n    /// @dev Make a call to the zkSync contract with the same calldata.\n    /// Note: If the batch is reverted, it needs to be committed first before the execution.\n    /// So it's safe to not override the committed batches.\n    function revertBatches(uint256) external onlyValidator {\n        _propagateToZkSync();\n    }\n\n    /// @dev Make a call to the zkSync contract with the same calldata.\n    /// Note: We don't track the time when batches are proven, since all information about\n    /// the batch is known on the commit stage and the proved is not finalized (may be reverted).\n    function proveBatches(\n        StoredBatchInfo calldata,\n        StoredBatchInfo[] calldata,\n        ProofInput calldata\n    ) external onlyValidator {\n        _propagateToZkSync();\n    }\n\n    /// @dev Check that batches were committed at least X time ago and\n    /// make a call to the zkSync contract with the same calldata.\n    function executeBatches(StoredBatchInfo[] calldata _newBatchesData) external onlyValidator {\n        uint256 delay = executionDelay; // uint32\n        unchecked {\n            for (uint256 i = 0; i < _newBatchesData.length; ++i) {\n                uint256 commitBatchTimestamp = committedBatchTimestamp.get(_newBatchesData[i].batchNumber);\n\n                // Note: if the `commitBatchTimestamp` is zero, that means either:\n                // * The batch was committed, but not through this contract.\n                // * The batch wasn't committed at all, so execution will fail in the zkSync contract.\n                // We allow executing such batches.\n                require(block.timestamp >= commitBatchTimestamp + delay, \"5c\"); // The delay is not passed\n            }\n        }\n\n        _propagateToZkSync();\n    }\n\n    /// @dev Call the zkSync contract with the same calldata as this contract was called.\n    /// Note: it is called the zkSync contract, not delegatecalled!\n    function _propagateToZkSync() internal {\n        address contractAddress = zkSyncContract;\n        assembly {\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\n            calldatacopy(0, 0, calldatasize())\n            // Call method of the zkSync contract returns 0 on error\n            let result := call(gas(), contractAddress, 0, 0, calldatasize(), 0, 0)\n            // Get the size of the last return data\n            let size := returndatasize()\n            // Copy the size length of bytes from return data at zero position to pointer position\n            returndatacopy(0, 0, size)\n            // Depending on the result value\n            switch result\n            case 0 {\n                // End execution and revert state changes\n                revert(0, size)\n            }\n            default {\n                // Return data with length of size at pointers position\n                return(0, size)\n            }\n        }\n    }\n}"
    }
  ]
}