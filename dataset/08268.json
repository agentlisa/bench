{
  "Title": "[M-06] ProxyFactory can circumvent ProxyRegistry",
  "Content": "_Submitted by 0xDjango_\n\nThe `deployFor()` function in `MIMOProxyFactory.sol` can be called directly instead of being called within `MIMOProxyRegistry.sol`. This results in the ability to create many MIMOProxies that are not registered within the registry. The proxies deployed directly through the factory will lack the ability to call certain actions such as leveraging and emptying the vault, but will be able to call all functions in `MIMOVaultAction.sol`.\n\nThis inconsistency doesn't feel natural and would be remedied by adding an `onlyRegistry` modifier to the `ProxyFactory.deployFor()` function.\n\n### Proof of Concept\n\n`MIMOProxyFactory.deployFor()` lacking any access control:\n\n      function deployFor(address owner) public override returns (IMIMOProxy proxy) {\n        proxy = IMIMOProxy(mimoProxyBase.clone());\n        proxy.initialize();\n\n\n        // Transfer the ownership from this factory contract to the specified owner.\n        proxy.transferOwnership(owner);\n\n\n        // Mark the proxy as deployed.\n        _proxies[address(proxy)] = true;\n\n\n        // Log the proxy via en event.\n        emit DeployProxy(msg.sender, owner, address(proxy));\n      }\n    }\n\nExample of reduced functionality: `MIMOEmptyVault.executeOperation()` checks proxy existence in the proxy registry therefore can't be called.\n\n      function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n      ) external override returns (bool) {\n        (address owner, uint256 vaultId, SwapData memory swapData) = abi.decode(params, (address, uint256, SwapData));\n        IMIMOProxy mimoProxy = IMIMOProxy(proxyRegistry.getCurrentProxy(owner));\n\n### Recommended Mitigation Steps\n\nAdding access control to ensure that the factory deployFor function is called from the proxy registry would mitigate this issue.\n\n**[RnkSngh (Mimo) confirmed and commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/123#issuecomment-1210553480):**\n > We confirm this is an issue and intend to implement a fix.\n\n**horsefacts (warden) reviewed mitigation:**\n> **Status:** âœ… Resolved\n\n> **Finding:** Wardens identified that proxies could be deployed directly from the `MIMOProxyFactory` without being registered with the `MIMOProxyRegistry`.\n\n> **What changed:** The `ProxyRegistry` contract has been removed, and registration functionality is now included in `MIMOProxyFactory`.<br>\n> The [only mechanism](https://github.com/mimo-capital/2022-08-mimo/blob/4e579420ecbe3fc3e770996610e6ab66b0c8d15b/contracts/proxy/MIMOProxyFactory.sol#L47) for deploying a proxy is now to call `MIMOProxyFactory#deploy`.\n\n> **Why it works:** Since there is only one code path to deploy a `MIMOProxy` and `MIMOProxyFactory` is the single source of truth for proxy registration, it is no longer possible to deploy an unregistered proxy as described in the finding.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-mimo-august-2022-contest",
  "Code": [
    {
      "filename": "contracts/proxy/MIMOProxyFactory.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport \"./interfaces/IMIMOProxyFactory.sol\";\nimport \"./MIMOProxy.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\n/// @title MIMOProxyFactory\ncontract MIMOProxyFactory is IMIMOProxyFactory {\n  using Clones for address;\n\n  address public immutable mimoProxyGuardBase;\n\n  /// @inheritdoc IMIMOProxyFactory\n  uint256 public constant override VERSION = 1;\n\n  /// @notice proxy => proxy state\n  mapping(address => ProxyState) private _proxyStates;\n\n  /// @notice owner => proxy\n  mapping(address => IMIMOProxy) private _currentProxies;\n\n  /// @notice proxy => pending owner\n  mapping(address => address) private _pendingOwners;\n\n  modifier onlyOwner(address proxy) {\n    if (address(_currentProxies[msg.sender]) != proxy) {\n      revert Errors.NOT_OWNER(_proxyStates[proxy].owner, msg.sender);\n    }\n    _;\n  }\n\n  constructor(address _mimoProxyGuardBase) {\n    if (_mimoProxyGuardBase == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    mimoProxyGuardBase = _mimoProxyGuardBase;\n  }\n\n  /**\n    @notice Deploys a new MIMOProxy and MIMOProxyGuard\n    @dev Sets \"msg.sender\" as the owner of the MIMOProxy.\n\n   */\n  function deploy() external override {\n    address currentProxy = address(_currentProxies[msg.sender]);\n    if (address(currentProxy) != address(0)) {\n      revert Errors.ALREADY_OWNER(msg.sender, currentProxy);\n    }\n    MIMOProxy proxy = new MIMOProxy(address(this));\n    IMIMOProxyGuard proxyGuard = IMIMOProxyGuard(mimoProxyGuardBase.clone());\n\n    proxyGuard.initialize(address(this), address(proxy));\n\n    ProxyState memory proxyState = ProxyState({ owner: msg.sender, proxyGuard: proxyGuard, minGas: 5000 });\n\n    _currentProxies[msg.sender] = IMIMOProxy(proxy);\n    _proxyStates[address(proxy)] = proxyState;\n\n    emit ProxyDeployed(msg.sender, address(proxy), proxyState);\n  }\n\n  /**\n    @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    Can only be invoked by the current MIMOProxy `owner`\n    @param proxy Address ot the MIMOProxy to transfer\n    @param newOwner Address of the new owner\n   */\n  function transferOwnership(address proxy, address newOwner) external override onlyOwner(proxy) {\n    // Checks\n    if (newOwner == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    if (address(_currentProxies[newOwner]) != address(0)) {\n      revert Errors.ALREADY_OWNER(newOwner, address(_currentProxies[newOwner]));\n    }\n    // Effects\n    _pendingOwners[proxy] = newOwner;\n    emit OwnershipTransferred(proxy, msg.sender, newOwner);\n  }\n\n  /**\n    @notice Needs to be called by `pendingOwner` to claim ownership\n    @param proxy Address of the MIMOProxy to claim\n    @param clear Clear existing proxy permissions if true and maintain them if false\n   */\n  function claimOwnership(address proxy, bool clear) external override {\n    address pendingOwner = _pendingOwners[proxy];\n\n    // Checks\n    if (msg.sender != pendingOwner) {\n      revert Errors.CALLER_NOT_PENDING_OWNER(msg.sender, pendingOwner);\n    }\n\n    if (address(_currentProxies[pendingOwner]) != address(0)) {\n      revert Errors.ALREADY_OWNER(pendingOwner, address(_currentProxies[pendingOwner]));\n    }\n\n    // Effects\n    address oldOwner = _proxyStates[proxy].owner;\n    delete _currentProxies[oldOwner];\n    _currentProxies[msg.sender] = IMIMOProxy(proxy);\n    _proxyStates[proxy].owner = msg.sender;\n    delete _pendingOwners[proxy];\n    emit OwnershipClaimed(proxy, msg.sender);\n\n    if (clear) {\n      _clearPermissions(proxy);\n    }\n  }\n\n  /**\n    @notice Clear all permissions from the MIMOProxy by deploying a new MIMOProxyGuard\n    Can only be called by the MIMOProxy `owner`\n    @param proxy Addess of the MIMOProxy to clear\n   */\n  function clearPermissions(address proxy) external override onlyOwner(proxy) {\n    _clearPermissions(proxy);\n  }\n\n  /**\n    @param proxy Address of the MIMOProxy\n    @param minGas Gas to reserve for running the remainder of the \"execute\" function after the DELEGATECALL in the \n    MIMOProxy. Prevents the proxy from becoming unusable if EVM opcode gas costs change in the future.\n   */\n  function setMinGas(address proxy, uint256 minGas) external override onlyOwner(proxy) {\n    _proxyStates[proxy].minGas = minGas;\n    emit MinGasSet(proxy, minGas);\n  }\n\n  /**\n    @param proxy Address of the MIMOProxy to check\n    @return result equals true if proxy has been deployed and false if not\n   */\n  function isProxy(address proxy) external view override returns (bool result) {\n    result = _proxyStates[proxy].owner != address(0);\n  }\n\n  /**\n    @notice Returns a MIMOProxy state\n    @dev MIMOProxy state management is outsourced to this contract to prevent storage collisions\n    @param proxy Address of the MIMOProxy\n    @return proxyState as a ProxyState struct containing a MIMOProxy state variables\n   */\n  function getProxyState(address proxy) external view override returns (ProxyState memory proxyState) {\n    proxyState = _proxyStates[proxy];\n  }\n\n  /**\n    @notice Gets the current MIMOProxy of the given owner.\n    @param owner The address of the owner of the current MIMOProxy.\n   */\n  function getCurrentProxy(address owner) external view override returns (IMIMOProxy proxy) {\n    proxy = _currentProxies[owner];\n  }\n\n  /**\n    @param proxy Address of the MIMOProxy\n    @return pendingOwner that has yet to claim his ownership\n   */\n  function getPendingOwner(address proxy) external view override returns (address pendingOwner) {\n    pendingOwner = _pendingOwners[proxy];\n  }\n\n  function _clearPermissions(address proxy) internal {\n    IMIMOProxyGuard proxyGuard = IMIMOProxyGuard(mimoProxyGuardBase.clone());\n    proxyGuard.initialize(address(this), proxy);\n    _proxyStates[proxy].proxyGuard = proxyGuard;\n\n    emit PermissionsCleared(proxy, address(proxyGuard));\n  }\n}"
    }
  ]
}