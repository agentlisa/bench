{
  "Title": "M-5: AuraSpell#closePositionFarm exits pool with single token and without any slippage protection",
  "Content": "# Issue M-5: AuraSpell#closePositionFarm exits pool with single token and without any slippage protection \n\nSource: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/102 \n\n## Found by \n0x52, Breeje, Oxhunter526, Vagner, bitsurfer, nobody2018\n\nWhen exiting the balancer pool, vault#exitPool is called with an empty array for minAmountsOut causing the position to be exited with no slippage protection. Typically it is not an issue to exit off axis but since it is exiting to a single token this can cause massive loss.\n\n## Vulnerability Detail\n\n[AuraSpell.sol#L221-L236](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L221-L236)\n\n                (\n                    uint256[] memory minAmountsOut,\n                    address[] memory tokens,\n                    uint256 borrowTokenIndex\n                ) = _getExitPoolParams(param.borrowToken, lpToken);\n\n                wAuraPools.getVault(lpToken).exitPool(\n                    IBalancerPool(lpToken).getPoolId(),\n                    address(this),\n                    address(this),\n                    IBalancerVault.ExitPoolRequest(\n                        tokens,\n                        minAmountsOut,\n                        abi.encode(0, amountPosRemove, borrowTokenIndex),\n                        false\n                    )\n\nWhen exiting a the balancer vault, closePositionFarm makes a subcall to _getExitPoolParams which is used to set minAmountsOut.\n\n[AuraSpell.sol#L358-L361](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L358-L361)\n\n        (address[] memory tokens, , ) = wAuraPools.getPoolTokens(lpToken);\n\n        uint256 length = tokens.length;\n        uint256[] memory minAmountsOut = new uint256[](length);\n\nInside _getExitPoolParams we see that minAmountsOut are always an empty array. This means that the user has no slippage protection and can be sandwich attacked, suffering massive losses.\n\n## Impact\n\nExits can be sandwich attacked causing massive loss to the user\n\n## Code Snippet\n\n[AuraSpell.sol#L184-L286](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L184-L286)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow user to specify min amount received from exit\n\n\n\n## Discussion\n\n**securitygrid**\n\nEscalate:\nHistorically, lacking slippage protection is H.\n\n\n**sherlock-admin2**\n\n > Escalate:\n> Historically, lacking slippage protection is H.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\n> Escalate: Historically, lacking slippage protection is H.\n\nCan be a high issue\n\n**IAm0x52**\n\nWhy would lack of slippage be considered high in this scenario? Even with zero slippage protection sandwich attack profitability is always contingent on a few external factors such as: liquidity of underlying pool, the fee of the underlying pool, the amount being swapped and the current gas prices. The higher the liquidity and fee of the pool the higher the cost to push the pool price then pull it back. The lower the amount being swapped, the less the attacker can steal. If this cost exceeds the gain from the attack then the attack isn't profitable and won't happen.\n\n**VagnerAndrei26**\n\nI think no slippage is considered high most of the time cause sandwich attacks are easily doable in the space, especially for those experienced in doing it, and even if there are factors to consider even one successful can occur loss of funds for the protocol in a pretty easy manner. So considering that and also past contests I think it should be considered also a high.\n\n**Nabeel-javaid**\n\nas far as I know 98% of the times slippage issues are considered as Medium severity\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates \nThis is a valid medium issue. Agree with the Lead Watson's comments here:\nhttps://github.com/sherlock-audit/2023-07-blueberry-judging/issues/102#issuecomment-1699649100\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [securitygrid](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/102/#issuecomment-1693593255): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/104",
  "Code": [
    {
      "filename": "blueberry-core/contracts/spell/AuraSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/// @title AuraSpell\n/// @author BlueberryProtocol\n/// @notice AuraSpell is the factory contract that\n///         defines how Blueberry Protocol interacts with Aura pools\ncontract AuraSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address to Wrapped Aura Pools\n    IWAuraPools public wAuraPools;\n    /// @dev Address of AURA token\n    address public AURA;\n    /// @dev Address of Stash AURA token\n    address public STASH_AURA;\n\n    /// @dev paraswap AugustusSwapper Address\n    address public augustusSwapper;\n    /// @dev paraswap TokenTransferProxy Address\n    address public tokenTransferProxy;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract with required parameters.\n    /// @param bank_ Reference to the Bank contract.\n    /// @param werc20_ Reference to the WERC20 contract.\n    /// @param weth_ Address of the wrapped Ether token.\n    /// @param wAuraPools_ Address of the wrapped Aura Pools contract.\n    /// @param augustusSwapper_ Address of the paraswap AugustusSwapper.\n    /// @param tokenTransferProxy_ Address of the paraswap TokenTransferProxy.\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wAuraPools_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wAuraPools_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        wAuraPools = IWAuraPools(wAuraPools_);\n        AURA = address(wAuraPools.AURA());\n        STASH_AURA = wAuraPools.STASH_AURA();\n        IWAuraPools(wAuraPools_).setApprovalForAll(address(bank_), true);\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n    }\n\n    /// @notice Allows the owner to add a new strategy.\n    /// @param bpt Address of the Balancer Pool Token.\n    /// @param minPosSize, USD price of minimum position size for given strategy, based 1e18\n    /// @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n    function addStrategy(\n        address bpt,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(bpt, minPosSize, maxPosSize);\n    }\n\n    /// @notice Adds liquidity to a Balancer pool and stakes the resultant tokens in Aura.\n    /// @param param Configuration for opening a position.\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minimumBPT\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        /// Extract strategy details for the given strategy ID.\n        Strategy memory strategy = strategies[param.strategyId];\n        /// Fetch pool information based on provided farming pool ID.\n        (address lpToken, , , , , ) = wAuraPools.getPoolInfoFromPoolId(\n            param.farmingPoolId\n        );\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        /// 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        /// 2. Borrow funds based on specified amount\n        _doBorrow(param.borrowToken, param.borrowAmount);\n\n        /// 3. Add liquidity to the Balancer pool and receive BPT in return.\n        {\n            uint256 _minimumBPT = minimumBPT;\n            IBalancerVault vault = wAuraPools.getVault(lpToken);\n\n            (address[] memory tokens, uint256[] memory balances, ) = wAuraPools\n                .getPoolTokens(lpToken);\n            (\n                uint256[] memory maxAmountsIn,\n                uint256[] memory amountsIn,\n                uint256 poolAmountOut\n            ) = _getJoinPoolParamsAndApprove(\n                    address(vault),\n                    tokens,\n                    balances,\n                    lpToken\n                );\n\n            if (poolAmountOut != 0) {\n                vault.joinPool(\n                    wAuraPools.getBPTPoolId(lpToken),\n                    address(this),\n                    address(this),\n                    IBalancerVault.JoinPoolRequest({\n                        assets: tokens,\n                        maxAmountsIn: maxAmountsIn,\n                        userData: abi.encode(1, amountsIn, _minimumBPT),\n                        fromInternalBalance: false\n                    })\n                );\n            }\n        }\n        /// 4. Ensure that the resulting LTV does not exceed maximum allowed value.\n        _validateMaxLTV(param.strategyId);\n\n        /// 5. Ensure position size is within permissible limits.\n        _validatePosSize(param.strategyId);\n\n        /// 6. Withdraw existing collaterals and burn the associated tokens.\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wAuraPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            (address[] memory rewardTokens, ) = wAuraPools.burn(\n                pos.collId,\n                pos.collateralSize\n            );\n            /// Distribute the multiple rewards to users.\n            uint256 rewardTokensLength = rewardTokens.length;\n            for (uint256 i; i != rewardTokensLength; ) {\n                _doRefundRewards(\n                    rewardTokens[i] == STASH_AURA ? AURA : rewardTokens[i]\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        /// 7. Deposit the tokens in the Aura pool and place the wrapped collateral tokens in the Blueberry Bank.\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wAuraPools), lpAmount);\n        uint256 id = wAuraPools.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wAuraPools), id, lpAmount);\n    }\n\n    /// @notice Closes a position from Balancer pool and exits the Aura farming.\n    /// @param param Parameters for closing the position\n    /// @param expectedRewards Expected reward amounts for each reward token\n    /// @param swapDatas Data required for swapping reward tokens to the debt token\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        uint256[] calldata expectedRewards,\n        bytes[] calldata swapDatas\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        /// Information about the position from Blueberry Bank\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        address[] memory rewardTokens;\n        /// Ensure the position's collateral token matches the expected one\n        {\n            address lpToken = strategies[param.strategyId].vault;\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            if (wAuraPools.getUnderlyingToken(pos.collId) != lpToken)\n                revert Errors.INCORRECT_UNDERLYING(lpToken);\n\n            /// 1. Burn the wrapped tokens, retrieve the BPT tokens, and claim the AURA rewards\n            bank.takeCollateral(param.amountPosRemove);\n            (rewardTokens, ) = wAuraPools.burn(\n                pos.collId,\n                param.amountPosRemove\n            );\n\n            {\n                /// 2. Determine the exact amount of position to remove\n                uint256 amountPosRemove = param.amountPosRemove;\n                if (amountPosRemove == type(uint256).max) {\n                    amountPosRemove = IERC20Upgradeable(lpToken).balanceOf(\n                        address(this)\n                    );\n                }\n\n                /// 3. Parameters for removing liquidity\n                (\n                    uint256[] memory minAmountsOut,\n                    address[] memory tokens,\n                    uint256 borrowTokenIndex\n                ) = _getExitPoolParams(param.borrowToken, lpToken);\n\n                wAuraPools.getVault(lpToken).exitPool(\n                    IBalancerPool(lpToken).getPoolId(),\n                    address(this),\n                    address(this),\n                    IBalancerVault.ExitPoolRequest(\n                        tokens,\n                        minAmountsOut,\n                        abi.encode(0, amountPosRemove, borrowTokenIndex),\n                        false\n                    )\n                );\n            }\n        }\n\n        /// 4. Swap each reward token for the debt token\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i != rewardTokensLength; ) {\n            address sellToken = rewardTokens[i];\n            if (sellToken == STASH_AURA) sellToken = AURA;\n\n            _doCutRewardsFee(sellToken);\n            if (\n                expectedRewards[i] != 0 &&\n                !PSwapLib.swap(\n                    augustusSwapper,\n                    tokenTransferProxy,\n                    sellToken,\n                    expectedRewards[i],\n                    swapDatas[i]\n                )\n            ) revert Errors.SWAP_FAILED(sellToken);\n\n            /// Refund rest (dust) amount to owner\n            _doRefund(sellToken);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        /// 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        /// 6. Withdraw collateral from the bank and repay the borrowed amount\n        {\n            /// Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        /// Ensure that the Loan to Value (LTV) ratio remains within accepted boundaries\n        _validateMaxLTV(param.strategyId);\n\n        /// 7. Refund any remaining tokens to the owner\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n    }\n\n    /// @dev Calculate the parameters required for joining a Balancer pool.\n    /// @param vault Address of the Balancer vault\n    /// @param tokens List of tokens in the Balancer pool\n    /// @param balances Balances of tokens in the Balancer pool\n    /// @param lpToken The LP token for the Balancer pool\n    /// @return maxAmountsIn Maximum amounts to deposit for each token\n    /// @return amountsIn Amounts of each token to deposit\n    /// @return poolAmountOut Amount of LP tokens to be received\n    function _getJoinPoolParamsAndApprove(\n        address vault,\n        address[] memory tokens,\n        uint256[] memory balances,\n        address lpToken\n    ) internal returns (uint256[] memory, uint256[] memory, uint256) {\n        uint256 i;\n        uint256 j;\n        uint256 length = tokens.length;\n        uint256[] memory maxAmountsIn = new uint256[](length);\n        uint256[] memory amountsIn = new uint256[](length);\n        bool isLPIncluded;\n\n        for (i; i != length; ) {\n            if (tokens[i] != lpToken) {\n                amountsIn[j] = IERC20(tokens[i]).balanceOf(address(this));\n                if (amountsIn[j] > 0) {\n                    _ensureApprove(tokens[i], vault, amountsIn[j]);\n                }\n                ++j;\n            } else isLPIncluded = true;\n\n            maxAmountsIn[i] = IERC20(tokens[i]).balanceOf(address(this));\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (isLPIncluded) {\n            assembly {\n                mstore(amountsIn, sub(mload(amountsIn), 1))\n            }\n        }\n\n        uint256 totalLPSupply = IBalancerPool(lpToken).getActualSupply();\n        /// compute in reverse order of how Balancer's `joinPool` computes tokenAmountIn\n        uint256 poolAmountOut;\n        for (i = 0; i != length; ) {\n            if ((maxAmountsIn[i] * totalLPSupply) / balances[i] != 0) {\n                poolAmountOut = type(uint256).max;\n                break;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (maxAmountsIn, amountsIn, poolAmountOut);\n    }\n\n    /// @dev Calculate the parameters required for exiting a Balancer pool.\n    /// @param borrowToken The token to be borrowed\n    /// @param lpToken The LP token for the Balancer pool\n    /// @return minAmountsOut Minimum amounts to receive for each token upon exiting\n    /// @return tokens List of tokens in the Balancer pool\n    /// @return exitTokenIndex Index of the borrowToken in the tokens list\n    function _getExitPoolParams(\n        address borrowToken,\n        address lpToken\n    ) internal view returns (uint256[] memory, address[] memory, uint256) {\n        (address[] memory tokens, , ) = wAuraPools.getPoolTokens(lpToken);\n\n        uint256 length = tokens.length;\n        uint256[] memory minAmountsOut = new uint256[](length);\n        uint256 exitTokenIndex;\n\n        for (uint256 i; i != length; ) {\n            if (tokens[i] == borrowToken) break;\n\n            if (tokens[i] != lpToken) ++exitTokenIndex;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (minAmountsOut, tokens, exitTokenIndex);\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/spell/AuraSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/// @title AuraSpell\n/// @author BlueberryProtocol\n/// @notice AuraSpell is the factory contract that\n///         defines how Blueberry Protocol interacts with Aura pools\ncontract AuraSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address to Wrapped Aura Pools\n    IWAuraPools public wAuraPools;\n    /// @dev Address of AURA token\n    address public AURA;\n    /// @dev Address of Stash AURA token\n    address public STASH_AURA;\n\n    /// @dev paraswap AugustusSwapper Address\n    address public augustusSwapper;\n    /// @dev paraswap TokenTransferProxy Address\n    address public tokenTransferProxy;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract with required parameters.\n    /// @param bank_ Reference to the Bank contract.\n    /// @param werc20_ Reference to the WERC20 contract.\n    /// @param weth_ Address of the wrapped Ether token.\n    /// @param wAuraPools_ Address of the wrapped Aura Pools contract.\n    /// @param augustusSwapper_ Address of the paraswap AugustusSwapper.\n    /// @param tokenTransferProxy_ Address of the paraswap TokenTransferProxy.\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wAuraPools_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wAuraPools_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        wAuraPools = IWAuraPools(wAuraPools_);\n        AURA = address(wAuraPools.AURA());\n        STASH_AURA = wAuraPools.STASH_AURA();\n        IWAuraPools(wAuraPools_).setApprovalForAll(address(bank_), true);\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n    }\n\n    /// @notice Allows the owner to add a new strategy.\n    /// @param bpt Address of the Balancer Pool Token.\n    /// @param minPosSize, USD price of minimum position size for given strategy, based 1e18\n    /// @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n    function addStrategy(\n        address bpt,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(bpt, minPosSize, maxPosSize);\n    }\n\n    /// @notice Adds liquidity to a Balancer pool and stakes the resultant tokens in Aura.\n    /// @param param Configuration for opening a position.\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minimumBPT\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        /// Extract strategy details for the given strategy ID.\n        Strategy memory strategy = strategies[param.strategyId];\n        /// Fetch pool information based on provided farming pool ID.\n        (address lpToken, , , , , ) = wAuraPools.getPoolInfoFromPoolId(\n            param.farmingPoolId\n        );\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        /// 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        /// 2. Borrow funds based on specified amount\n        _doBorrow(param.borrowToken, param.borrowAmount);\n\n        /// 3. Add liquidity to the Balancer pool and receive BPT in return.\n        {\n            uint256 _minimumBPT = minimumBPT;\n            IBalancerVault vault = wAuraPools.getVault(lpToken);\n\n            (address[] memory tokens, uint256[] memory balances, ) = wAuraPools\n                .getPoolTokens(lpToken);\n            (\n                uint256[] memory maxAmountsIn,\n                uint256[] memory amountsIn,\n                uint256 poolAmountOut\n            ) = _getJoinPoolParamsAndApprove(\n                    address(vault),\n                    tokens,\n                    balances,\n                    lpToken\n                );\n\n            if (poolAmountOut != 0) {\n                vault.joinPool(\n                    wAuraPools.getBPTPoolId(lpToken),\n                    address(this),\n                    address(this),\n                    IBalancerVault.JoinPoolRequest({\n                        assets: tokens,\n                        maxAmountsIn: maxAmountsIn,\n                        userData: abi.encode(1, amountsIn, _minimumBPT),\n                        fromInternalBalance: false\n                    })\n                );\n            }\n        }\n        /// 4. Ensure that the resulting LTV does not exceed maximum allowed value.\n        _validateMaxLTV(param.strategyId);\n\n        /// 5. Ensure position size is within permissible limits.\n        _validatePosSize(param.strategyId);\n\n        /// 6. Withdraw existing collaterals and burn the associated tokens.\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wAuraPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            (address[] memory rewardTokens, ) = wAuraPools.burn(\n                pos.collId,\n                pos.collateralSize\n            );\n            /// Distribute the multiple rewards to users.\n            uint256 rewardTokensLength = rewardTokens.length;\n            for (uint256 i; i != rewardTokensLength; ) {\n                _doRefundRewards(\n                    rewardTokens[i] == STASH_AURA ? AURA : rewardTokens[i]\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        /// 7. Deposit the tokens in the Aura pool and place the wrapped collateral tokens in the Blueberry Bank.\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wAuraPools), lpAmount);\n        uint256 id = wAuraPools.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wAuraPools), id, lpAmount);\n    }\n\n    /// @notice Closes a position from Balancer pool and exits the Aura farming.\n    /// @param param Parameters for closing the position\n    /// @param expectedRewards Expected reward amounts for each reward token\n    /// @param swapDatas Data required for swapping reward tokens to the debt token\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        uint256[] calldata expectedRewards,\n        bytes[] calldata swapDatas\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        /// Information about the position from Blueberry Bank\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        address[] memory rewardTokens;\n        /// Ensure the position's collateral token matches the expected one\n        {\n            address lpToken = strategies[param.strategyId].vault;\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            if (wAuraPools.getUnderlyingToken(pos.collId) != lpToken)\n                revert Errors.INCORRECT_UNDERLYING(lpToken);\n\n            /// 1. Burn the wrapped tokens, retrieve the BPT tokens, and claim the AURA rewards\n            bank.takeCollateral(param.amountPosRemove);\n            (rewardTokens, ) = wAuraPools.burn(\n                pos.collId,\n                param.amountPosRemove\n            );\n\n            {\n                /// 2. Determine the exact amount of position to remove\n                uint256 amountPosRemove = param.amountPosRemove;\n                if (amountPosRemove == type(uint256).max) {\n                    amountPosRemove = IERC20Upgradeable(lpToken).balanceOf(\n                        address(this)\n                    );\n                }\n\n                /// 3. Parameters for removing liquidity\n                (\n                    uint256[] memory minAmountsOut,\n                    address[] memory tokens,\n                    uint256 borrowTokenIndex\n                ) = _getExitPoolParams(param.borrowToken, lpToken);\n\n                wAuraPools.getVault(lpToken).exitPool(\n                    IBalancerPool(lpToken).getPoolId(),\n                    address(this),\n                    address(this),\n                    IBalancerVault.ExitPoolRequest(\n                        tokens,\n                        minAmountsOut,\n                        abi.encode(0, amountPosRemove, borrowTokenIndex),\n                        false\n                    )\n                );\n            }\n        }\n\n        /// 4. Swap each reward token for the debt token\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i != rewardTokensLength; ) {\n            address sellToken = rewardTokens[i];\n            if (sellToken == STASH_AURA) sellToken = AURA;\n\n            _doCutRewardsFee(sellToken);\n            if (\n                expectedRewards[i] != 0 &&\n                !PSwapLib.swap(\n                    augustusSwapper,\n                    tokenTransferProxy,\n                    sellToken,\n                    expectedRewards[i],\n                    swapDatas[i]\n                )\n            ) revert Errors.SWAP_FAILED(sellToken);\n\n            /// Refund rest (dust) amount to owner\n            _doRefund(sellToken);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        /// 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        /// 6. Withdraw collateral from the bank and repay the borrowed amount\n        {\n            /// Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        /// Ensure that the Loan to Value (LTV) ratio remains within accepted boundaries\n        _validateMaxLTV(param.strategyId);\n\n        /// 7. Refund any remaining tokens to the owner\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n    }\n\n    /// @dev Calculate the parameters required for joining a Balancer pool.\n    /// @param vault Address of the Balancer vault\n    /// @param tokens List of tokens in the Balancer pool\n    /// @param balances Balances of tokens in the Balancer pool\n    /// @param lpToken The LP token for the Balancer pool\n    /// @return maxAmountsIn Maximum amounts to deposit for each token\n    /// @return amountsIn Amounts of each token to deposit\n    /// @return poolAmountOut Amount of LP tokens to be received\n    function _getJoinPoolParamsAndApprove(\n        address vault,\n        address[] memory tokens,\n        uint256[] memory balances,\n        address lpToken\n    ) internal returns (uint256[] memory, uint256[] memory, uint256) {\n        uint256 i;\n        uint256 j;\n        uint256 length = tokens.length;\n        uint256[] memory maxAmountsIn = new uint256[](length);\n        uint256[] memory amountsIn = new uint256[](length);\n        bool isLPIncluded;\n\n        for (i; i != length; ) {\n            if (tokens[i] != lpToken) {\n                amountsIn[j] = IERC20(tokens[i]).balanceOf(address(this));\n                if (amountsIn[j] > 0) {\n                    _ensureApprove(tokens[i], vault, amountsIn[j]);\n                }\n                ++j;\n            } else isLPIncluded = true;\n\n            maxAmountsIn[i] = IERC20(tokens[i]).balanceOf(address(this));\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (isLPIncluded) {\n            assembly {\n                mstore(amountsIn, sub(mload(amountsIn), 1))\n            }\n        }\n\n        uint256 totalLPSupply = IBalancerPool(lpToken).getActualSupply();\n        /// compute in reverse order of how Balancer's `joinPool` computes tokenAmountIn\n        uint256 poolAmountOut;\n        for (i = 0; i != length; ) {\n            if ((maxAmountsIn[i] * totalLPSupply) / balances[i] != 0) {\n                poolAmountOut = type(uint256).max;\n                break;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (maxAmountsIn, amountsIn, poolAmountOut);\n    }\n\n    /// @dev Calculate the parameters required for exiting a Balancer pool.\n    /// @param borrowToken The token to be borrowed\n    /// @param lpToken The LP token for the Balancer pool\n    /// @return minAmountsOut Minimum amounts to receive for each token upon exiting\n    /// @return tokens List of tokens in the Balancer pool\n    /// @return exitTokenIndex Index of the borrowToken in the tokens list\n    function _getExitPoolParams(\n        address borrowToken,\n        address lpToken\n    ) internal view returns (uint256[] memory, address[] memory, uint256) {\n        (address[] memory tokens, , ) = wAuraPools.getPoolTokens(lpToken);\n\n        uint256 length = tokens.length;\n        uint256[] memory minAmountsOut = new uint256[](length);\n        uint256 exitTokenIndex;\n\n        for (uint256 i; i != length; ) {\n            if (tokens[i] == borrowToken) break;\n\n            if (tokens[i] != lpToken) ++exitTokenIndex;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (minAmountsOut, tokens, exitTokenIndex);\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/spell/AuraSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/// @title AuraSpell\n/// @author BlueberryProtocol\n/// @notice AuraSpell is the factory contract that\n///         defines how Blueberry Protocol interacts with Aura pools\ncontract AuraSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address to Wrapped Aura Pools\n    IWAuraPools public wAuraPools;\n    /// @dev Address of AURA token\n    address public AURA;\n    /// @dev Address of Stash AURA token\n    address public STASH_AURA;\n\n    /// @dev paraswap AugustusSwapper Address\n    address public augustusSwapper;\n    /// @dev paraswap TokenTransferProxy Address\n    address public tokenTransferProxy;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract with required parameters.\n    /// @param bank_ Reference to the Bank contract.\n    /// @param werc20_ Reference to the WERC20 contract.\n    /// @param weth_ Address of the wrapped Ether token.\n    /// @param wAuraPools_ Address of the wrapped Aura Pools contract.\n    /// @param augustusSwapper_ Address of the paraswap AugustusSwapper.\n    /// @param tokenTransferProxy_ Address of the paraswap TokenTransferProxy.\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wAuraPools_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wAuraPools_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        wAuraPools = IWAuraPools(wAuraPools_);\n        AURA = address(wAuraPools.AURA());\n        STASH_AURA = wAuraPools.STASH_AURA();\n        IWAuraPools(wAuraPools_).setApprovalForAll(address(bank_), true);\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n    }\n\n    /// @notice Allows the owner to add a new strategy.\n    /// @param bpt Address of the Balancer Pool Token.\n    /// @param minPosSize, USD price of minimum position size for given strategy, based 1e18\n    /// @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n    function addStrategy("
    }
  ]
}