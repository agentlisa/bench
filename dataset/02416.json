{
  "Title": "H-10: IchiLpOracle is extemely easy to manipulate due to how IchiVault calculates underlying token balances",
  "Content": "# Issue H-10: IchiLpOracle is extemely easy to manipulate due to how IchiVault calculates underlying token balances \n\nSource: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/20 \n\n## Found by \ncarrot, obront, ctf\\_sec, cergyk, banditx0x, psy4n0n, 0x52\n\n## Summary\n\n`IchiVault#getTotalAmounts` uses the `UniV3Pool.slot0` to determine the number of tokens it has in it's position. `slot0` is the most recent data point and is therefore extremely easy to manipulate. Given that the protocol specializes in leverage, the effects of this manipulation would compound to make malicious uses even easier.\n\n## Vulnerability Detail\n\n[ICHIVault.sol](https://etherscan.io/token/0x683f081dbc729dbd34abac708fa0b390d49f1c39#code#L3098)\n\n    function _amountsForLiquidity(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity\n    ) internal view returns (uint256, uint256) {\n        (uint160 sqrtRatioX96, , , , , , ) = IUniswapV3Pool(pool).slot0();\n        return\n            UV3Math.getAmountsForLiquidity(\n                sqrtRatioX96,\n                UV3Math.getSqrtRatioAtTick(tickLower),\n                UV3Math.getSqrtRatioAtTick(tickUpper),\n                liquidity\n            );\n    }\n\n`IchiVault#getTotalAmounts` uses the `UniV3Pool.slot0` to determine the number of tokens it has in it's position. [slot0](https://docs.uniswap.org/contracts/v3/reference/core/interfaces/pool/IUniswapV3PoolState#slot0) is the most recent data point and can easily be manipulated.\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/oracle/IchiLpOracle.sol#L27-L36\n\n`IchiLPOracle` directly uses the token values returned by `vault#getTotalAmounts`. This allows a malicious user to manipulate the valuation of the LP. An example of this kind of manipulation would be to use large buys/sells to alter the composition of the LP to make it worth less or more. \n\n## Impact\n\nIchi LP value can be manipulated to cause loss of funds for the protocol and other users\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nToken balances should be calculated inside the oracle instead of getting them from the `IchiVault`. To determine the liquidity, use a TWAP instead of `slot0`.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/41",
  "Code": [
    {
      "filename": "contracts/oracle/IchiLpOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\n\nimport './UsingBaseOracle.sol';\nimport '../interfaces/IBaseOracle.sol';\nimport '../interfaces/ichi/IICHIVault.sol';\n\ncontract IchiLpOracle is UsingBaseOracle, IBaseOracle {\n    constructor(IBaseOracle _base) UsingBaseOracle(_base) {}\n\n    /**\n     * @notice Return lp token price in USD, with 18 decimals of precision.\n     * @param token The underlying token address for which to get the price.\n     * @return Price in USD\n     */\n    function getPrice(address token) external view override returns (uint256) {\n        IICHIVault vault = IICHIVault(token);\n        uint256 totalSupply = vault.totalSupply();\n        if (totalSupply == 0) return 0;\n\n        address token0 = vault.token0();\n        address token1 = vault.token1();\n\n        (uint256 r0, uint256 r1) = vault.getTotalAmounts();\n        uint256 px0 = base.getPrice(address(token0));\n        uint256 px1 = base.getPrice(address(token1));\n        uint256 t0Decimal = IERC20Metadata(token0).decimals();\n        uint256 t1Decimal = IERC20Metadata(token1).decimals();\n\n        uint256 totalReserve = (r0 * px0) /\n            10**t0Decimal +\n            (r1 * px1) /\n            10**t1Decimal;\n\n        return (totalReserve * 1e18) / totalSupply;\n    }\n}"
    }
  ]
}