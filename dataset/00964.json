{
  "Title": "Missing chainlink price feed",
  "Content": "# Missing chainlink price feed\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/README.md#compatibilities\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/README.md#compatibilities</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/oracles/GMXOracle.sol#L62-70\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/oracles/GMXOracle.sol#L62-70</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/oracles/GMXOracle.sol#L194-214\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/oracles/GMXOracle.sol#L194-214</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/oracles/GMXOracle.sol#L311-315\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/oracles/GMXOracle.sol#L311-315</a>\n\n\n## Summary\nChainlink does not provide a price feed for SOL token on Avalanche.\n\n## Vulnerability Details\nOne of the in-scope tokens ```SOL``` on the ```Avalanche``` blockchain (see README.md) does not have a corresponding Chainlink pricefeed which makes pricing impossible as currently designed.\nSee available Chainlink pricefeeds [here](https://data.chain.link/ethereum/mainnet/crypto-usd/sol-usd)\n\nPrice Feeds are not set in the constructor of ```GMXVault.sol``` so it is possible that the Strategy Vault could be deployed before the missing price feed was noticed.\n\n## Impact\nThis issue affects some core protocol functions, which would make the core operations of a Strategy Vault using SOL on Avalanche impossible:\n ```GMXReader.sol::convertToUsdValue()```\n ```GMXReader.sol::delta()```\n ```GMXOracle.sol::_getTokenPriceMinMaxFormatted()```\n\n## Tools Used\nManual Review\n\n## Recommendations\nUse another Oracle for pricing SOL or remove SOL from the scope of eligible tokens on the AValanche chain.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "README.md",
      "content": "# Steadefi Codehawks Audit\nâ€‹\n<p align=\"center\">\n  <img src=\"https://res.cloudinary.com/droqoz7lg/image/upload/v1698138813/Steadefi_Vertical_Dark_zqwu7k.png\" width=\"400\" alt=\"Steadefi\">\n</p>\n\nâ€‹\n## Contest Details\n- Total Prize Pool: $35,000\n  - High/Medium Awards: $33,000\n  - Low: $2,000\n- Start: 26th October 2023 12:00pm UTC\n- End: 6th November 2023 12:00pm UTC\nâ€‹\n\n## Stats\n- nSLOC: 2,289\n- Complexity Score: 1,634\n- Dollars per nSLOC: ~$15\n- Dollars per Complexity: ~$21\nâ€‹\n## About\nSteadefi provides vaults with automated risk management for earning leveraged yields effectively and passively in bull, crab and bear markets. With lending and leveraged delta long and neutral stategies, Steadefi's vaults cater to different risk/reward strategies to the best yield-generating DeFi protocols.\n\nAs of October 2023, Steadefi is looking to launch vaults that earn yield from GMX v2 on Arbitrum and Avalanche network.\nâ€‹\n\n## Official Links\n- [Protocol Documentation](https://docs.steadefi.com)\n- [Website](https://www.steadefi.com)\n- [Front-End Interface](https://www.steadefi.com/vaults)\n- [Blog](https://blog.steadefi.com)\n- [Twitter](https://twitter.com/steadefi)\n- [Discord](https://discord.gg/steadefi)\nâ€‹\n\n## Protocol Overview\nThere are 2 types of vaults: **Lending Vaults** and **Strategy Vaults**.\n\nA typical set up for 3x Leverage, Delta Long and Delta Neutral strategies to the ETH-USDC GM LP pool on GMXv2, with isolated ETH and USDC lending vaults are as follows:\n\n![Protocol Overview](https://res.cloudinary.com/droqoz7lg/image/upload/v1698422767/protocol-overview_k3yank.png)\n\n> Note that Delta Long strategies borrow only USDC for more leverage, while Delta Neutral strategies borrow both USDC for leverage **as well as** borrow ETH in order to delta hedge the ETH exposure of the liquidity provided to the ETH-USDC GM LP pool (borrowing = hedging).\n\n### Further Technical Documentation\nðŸš¨ **For more details, please check out the [Technical Documentation](https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/docs/technical-documentation.md) directory in this repository.**\n\n### Recorded Video for Codehawks\n[Recorded Explainer Video](https://www.loom.com/share/88ce04a31a4343439cdc9501a6a9448a)\n\n## Actors\n| Role | Responsibilities |\n| ------ | --------------- |\n| Lender | Lenders deposit assets to Lending Vaults (1 asset per Lending Vault) to earn safer, more stable borrow interest on their assets. |\n| Depositor | Depositors deposit assets to Strategy Vaults (Strategy Vaults could accept different assets) to earn earn higher yields than if they were to supply their assets to the yield-earning protocol directly. Depending on the strategy however, they take on different types of risk which would affect their final profit and losses. |\n| Keeper | Keepers are automated \"bots\" that run 24/7, frequently scheduled and/or event-triggered code scripts to perform various protocol maintainence tasks. These tasks include updating of borrow interest rates for Lending Vaults, rebalancing Strategy Vaults whose health are out of its' strategy parameter limits, compounding earned yield for Strategy Vaults, reverting certain issues for strategy vaults when they occur and triggering Emergency Pauses for lending and strategy vaults in the event of any possible issues. |\n| Owner | Owner are administrators that have rights to configure and update various sensitive vault configurations and parameters. Owners of deployed smart-contracts (vaults, oracles, etc.) should be Timelocks of which are managed by Multi-Sigs that require at least a 2 out of 3 signing approval for any transactions to happen with a 24 hours delay. Note that on contract deployment, the immediate Owner is the hot wallet deployer account. After deploying and initial configuration of the contract, the ownership should be immediately transferred from the hot wallet deployer to a Timelock managed by a Multi-Sig. |\n\n\n\n## Scope\n### Contracts in scope:\n```js\ncontracts\nâ”œâ”€â”€ interfaces\n    â”œâ”€â”€ oracles\n        â”œâ”€â”€ IChainlinkOracle.sol\n        â”œâ”€â”€ IGMXOracle.sol\n    â”œâ”€â”€ strategy\n        â”œâ”€â”€ gmx\n            â”œâ”€â”€ IGMXVault.sol\n            â”œâ”€â”€ IGMXVaultEvent.sol\nâ”œâ”€â”€ oracles\n        â”œâ”€â”€ ChainlinkARBOracle.sol\n        â”œâ”€â”€ GMXOracle.sol\nâ”œâ”€â”€ strategy\n        â”œâ”€â”€ gmx\n            â”œâ”€â”€ GMXCallback.sol\n            â”œâ”€â”€ GMXChecks.sol\n            â”œâ”€â”€ GMXCompound.sol\n            â”œâ”€â”€ GMXDeposit.sol\n            â”œâ”€â”€ GMXEmergency.sol\n            â”œâ”€â”€ GMXManager.sol\n            â”œâ”€â”€ GMXProcessDeposit.sol\n            â”œâ”€â”€ GMXProcessWithdraw.sol\n            â”œâ”€â”€ GMXReader.sol\n            â”œâ”€â”€ GMXRebalance.sol\n            â”œâ”€â”€ GMXTrove.sol\n            â”œâ”€â”€ GMXTypes.sol\n            â”œâ”€â”€ GMXVault.sol\n            â”œâ”€â”€ GMXWithdraw.sol\n            â”œâ”€â”€ GMXWorker.sol\nâ””â”€â”€ utils\n    â”œâ”€â”€ Errors.sol\n```\n\n### Contracts out of scope:\n```js\ncontracts\nâ”œâ”€â”€ interfaces\n    â”œâ”€â”€ lending\n    â”œâ”€â”€ protocols\n    â”œâ”€â”€ swap\n    â”œâ”€â”€ tokens\nâ”œâ”€â”€ lending\nâ”œâ”€â”€ oracles\n    â”œâ”€â”€ ChainlinkOracle.sol\nâ”œâ”€â”€ mocks\nâ”œâ”€â”€ swaps\nâ€‹\n```\nâ€‹\n## Compatibilities\nBlockchains:\n  - Arbitrum\n  - Avalanche\n\nTokens on Arbitrum:\n  - ETH\n  - WETH: `0x82aF49447D8a07e3bd95BD0d56f35241523fBab1`\n  - WBTC: `0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f`\n  - ARB: `0x912CE59144191C1204E64559FE8253a0e49E6548`\n  - LINK: `0xf97f4df75117a78c1a5a0dbb814af92458539fb4`\n  - SOL: `0x2bCc6D6CdBbDC0a4071e48bb3B969b06B3330c07`\n  - UNI: `0xfa7f8980b0f1e64a2062791cc3b0871572f1f7f0`\n  - USDC: `0xaf88d065e77c8cC2239327C5EDb3A432268e5831`\n  - ETH-USDC GM: `0x70d95587d40a2caf56bd97485ab3eec10bee6336`\n  - WBTC-USDC GM: `0x47c031236e19d024b42f8AE6780E44A573170703`\n  - ARB-USDC GM: `0xC25cEf6061Cf5dE5eb761b50E4743c1F5D7E5407`\n  - LINK-USDC GM: `0x7f1fa204bb700853D36994DA19F830b6Ad18455C`\n  - SOL-USDC GM: `0x09400D9DB990D5ed3f35D7be61DfAEB900Af03C9`\n  - UNI-USDC GM: `0xc7Abb2C5f3BF3CEB389dF0Eecd6120D451170B50`\n\nTokens on Avalanche:\n  - AVAX\n  - WAVAX: `0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7`\n  - BTC.b: `0x152b9d0FdC40C096757F570A51E494bd4b943E50`\n  - WETH.e: `0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB`\n  - SOL: `0xFE6B19286885a4F7F55AdAD09C3Cd1f906D2478F`\n  - USDC: `0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e`\n  - AVAX-USDC GM: `0x913C1F46b48b3eD35E7dc3Cf754d4ae8499F31CF`\n  - BTC.b-USDC GM: `0xFb02132333A79C8B5Bd0b64E3AbccA5f7fAf2937`\n  - WETH.e-USDC GM: `0xB7e69749E3d2EDd90ea59A4932EFEa2D41E245d7`\n  - SOL-USDC GM: `0xd2eFd1eA687CD78c41ac262B3Bc9B53889ff1F70`\nâ€‹\n## Setup\nInstall all project dependencies with yarn\n```bash\n$ yarn\n```\n\nCompile all contracts\n```bash\n$ yarn compile\n```\n\nNote: You may need to add Foundry to this Hardhat project if you do not have foundry installed: See instructions hereL: [https://hardhat.org/hardhat-runner/docs/advanced/hardhat-and-foundry](https://hardhat.org/hardhat-runner/docs/advanced/hardhat-and-foundry)\n\n### Deployment\nDeploy scripts are all in the `/scripts` directory. Short-cut helper bash functions are in `package.json`.\n\nNote that deployment for different chains or strategies may have different contracts to deploy.\n\nThe steps below are for deploying strategy vaults for ETH-USDC on GMX, using Uniswap for asset swaps.\n\n**After deploying a contract successful, the address of the contract should be updated in `constants.ts` file accordingly so future deploy scripts can utilise the correct deployed contracts.**\n\n**0) Add deployer wallet private key to `.env`**\n\nAdd deployer private key to `.env`\n```javascript\nPRIVATE_KEY_DEPLOYER=<PRIVATE_KEY_OF_DEPLOYER_WALLET>\n```\n\n**1) Deploy Chainlink Oracle**\n```bash\n$ npx hardhat run --network arbitrumOne scripts/arb/oracles/deploy-oracle-chainlink-arb.ts\n```\nNote that the price feeds for ETH and USDC should be updated to this oracle.\n\nThis oracle is re-usable for future Arbitrum protocol oracles and strategy vaults.\n\n**2) Deploy GMX Oracle**\n```bash\n$ npx hardhat run --network arbitrumOne scripts/arb/oracles/deploy-oracle-gmx.ts\n```\nThis oracle is re-usable for future GMX strategy vaults.\n\n**3) Deploy a Swap**\n```bash\n$ npx hardhat run --network arbitrumOne scripts/arb/swap/deploy-swap-uniswap.ts\n```\nNote that the fee tiers for ETH and USDC swap pool should be updated in this swap.\n\nThis swap is re-usable for future Arbitrum strategy vaults.\n\n**4) Deploy Lending Vaults**\n```bash\n# Deploy a native ETH Lending Vault\n$ npx hardhat run --network arbitrumOne scripts/arb/lending/deploy-lending-vault-native.ts\n\n# Deploy a USDC Lending Vault\n$ npx hardhat run --network arbitrumOne scripts/arb/lending/deploy-lending-vault-stable.ts\n```\n\nThese lending vaults will be re-usable for future ETH-USDC GMX strategy vaults.\n\n**5) Deploy Strategy Vaults**\n```bash\n# Deploy re-usable strategy vault external library contracts\n$ npx hardhat run --network arbitrumOne scripts/arb/strategy/gmx/deploy-strategy-gmx-libraries.ts\n\n# Deploy a Leveraged Long strategy vault\n$ npx hardhat run --network arbitrumOne scripts/arb/strategy/gmx/deploy-strategy-gmx-long-eth.ts\n\n# Deploy a Leveraged Neutral strategy vault\n$ npx hardhat run --network arbitrumOne scripts/arb/strategy/gmx/deploy-strategy-gmx-neutral-eth.ts\n```\n\nThe library contracts deployed will also be re-usable for other GMX strategy vaults.\n\n**5) Post-Deployment Setup (optional for audit)**\n- Configure Keepers (Relayers, Sentinels, Autotasks)\n- Configure back-end data collection and database\n- Configure front-end interface\nâ€‹\n\n### Testing\n\nTests coverage\n```bash\n$ forge coverage\n```\n\nRun all tests\n```bash\n$ forge test\n```\n\nRun a particular test suite\n```bash\n$ forge test --match-contract GMXDepositTest\n```\n\nRun a particular test with calltrace\n```bash\n$ forge test --match-test test_createDeposit -vvvv\n```\n\n## Additional Context\n- **Chainlink price feed dependency**\n    - The protocol is dependent on Chainlink price feeds operating accurately and correctly. In situations where it does not, the oracle contracts would already revert, therefore preventing further actions with the vaults.\n    - It should be assumed that for all accepted tokens in this protocol, there is a price feed for it (the \"GM\" LP tokens' price comes from GMX itself which uses Chainlink as well)\n- **Keeper dependency**\n    - The strategy vaults are dependent on keepers running to compound and rebalance the vaults periodically. It should be assumed that the keepers will always be able to run 24/7 to trigger the right functions. However, if there can be issues arising due to such functions, please report them as findings.\n- **GMXTrove only applies if reward tokens are the same as vault's tokenA/tokenB and are airdropped to vault**\n- **It is expected that Neutral strategy vaults will have a leverage factor of 3x and above**\n    - A leverage of less than 3x (e.g. 2x) for Neutral strategies may not work to correctly to borrow enough long token to hedge while still adhering to the correct leverage factor.\n    - The issue will arise in `GMXManager.calcBorrow()` and `GMXReader.additionalCapacity()` where the computation of shortToken (tokenB) to borrow may underflow.\n    - However, Long strategies are OK to have 2x as they simply borrow short token to leverage up.\n    - As it does not make sense to deploy a Neutral strategy vault with less than 3x leverage as the strategy will fail, we did not add checks to this in the constructor function.\n- **Rounding errors**:\n    - Conversion between scaled and normalized balances inherently incurs some rounding error; we consider rounding errors limited to \"dust\" (miniscule amounts left unaccounted for) out of scope unless they lead to additional unexpected behavior (e.g. if a rounding error can prevent withdrawal batches from being closed).\n- **Accounting terms**:\n    - Assets = Equity + Debt\n    - Equity = what depositors put into vault\n    - Debt = loans from Lending vaults\n    - Delta = Refers to the position exposure of this vault's strategy to the underlying volatile asset. Delta can be a negative value.\nâ€‹\n## Known Issues\n\n- **Vault inflation attack**\n    - Just like other smart contract vaults (like ERC-4626 standard), the vaults are also susceptible to a Inflation/Donation Attack that can be carried out by the first depositor to the vault. We will mitigated this by being the first to deposit a small amount to any new vaults and sending the vault share tokens to the vault contract itself, so it will not be accessible to anyone.\n- **GMX Callback failures**\n    - The strategy vaults are dependent on GMX's callback to work. GMX's callbacks are only triggered when GMX's keepers successful execute the deposit/withdraw liquidity orders that our vaults submit to it. If GMX's keepers do not work for whatever reason, there is nothing we can do except to cancel the order request. Note that if the attempt to trigger the callback to the vaults by GMX went through BUT it failed, then this should be a finding, as it could be due to faulty code logic on our vaults or too much gas being used in the callback function (there is a 2 million gas limit for callback functions).\n- **No zero address on constructor and functions**\n    - We have removed zero address checks on constructor and functions unless they are critical to the core/logic of the vault. This is to reduce gas fees incurred for every trigger of the function, as the function may revert naturally when a zero address is passed in. For e.g., no zero address check needed for getting token price/value from oracles.\n- **Post successful compound() may result in vault's health being out of balance**\n    - It is OK for deposit/withdrawals when vault status is out of range, as any deposits will bring vault closer to target leverage and delta, and withdrawals will still obtain their assets accurately and accordingly. If this is found to NOT be the case, then please report this as a finding.\n- **There needs to be enough lending capacity for a successful rebalance**\n    - There can be a situation where there is not enough lending capacity to rebalance the vault correctly (e.g. not enough lending capacity to borrow, so the vault's debt ratio is under the lower debt ratio parameters). The strategy vault can only wait until there is enough lending capacity in order to execute a successul rebalance.\n- **Swap deadline is consciously set as block.timestamp for certain functions**\n    - In: `GMXDeposit.processDepositFailureLiquidityWithdrawal() and `GMXProcessWithdraw.processWithdraw()`\n    - Reminder: A swap deadline timestamp is passed to protect against miners delaying swap transactions until a more favourable time for them to process it.\n    - However for the above 2 functions that implements a swap, we decided to allow the deadline to be set as the current block timestamp for these function as they are triggered as a follow up function (by a callback/keeper) and not directly by a user/keeper. If this follow on functions revert due to the swap transaction being processed after a set fixed deadline timestamp, this will cause the vault to be in a \"stuck\" state. To resolve this, this function will have to be called again with an updated deadline until it succeeds/a miner processes the transaction.\n- **PUSH0 opcode with Solidity version 0.8.21 unsupported on L2 networks**\n     - Known issue and does not cause any issues during compile or runtime during testing\n\n## Attack ideas (Where to look for bugs)\n- **General**\n    - Lenders from lending vaults should be protected from any bad debt or loss of funds as a result of vault's actions. Any flow that results in lending vaults not getting paid back would be critical.\n    - Due to design of GMX v2 where adding/removing liquidity involves two transactions, it could lead to internal accounting issues if the various scenarios (success/cancelled/failure) are not handled properly\n    - All scenarios should be handled to ensure vault eventually returns to an Open status. Consider how a scenario might lead to a stuck vault (other statuses).\n- **Emergency actions**\n    - After emergency actions (pause, close) all loans should be repaid, users' funds secured, and all vault activity should be paused except for emergency withdrawals. Consider ways in which this state might be violated.\n\n- **Main invariants**\n    - Assuming a 3X leveraged vault, leverage should never deviate too far from 3. Otherwise, it would imply excessive over or under-borrowing from lending vaults which could result in bad debt\n    - After every action (deposit/withdraw/rebalance/compound), the vault should be cleared of any token balances. Violation of this could allow a subsequent depositor to benefit from it.\n\n## Additional Known Issues (4nalyzer)\nAdditional known issues can be found [here](https://github.com/Cyfrin/2023-10-SteadeFi/issues/1)"
    },
    {
      "filename": "contracts/oracles/GMXOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISyntheticReader } from \"../interfaces/protocols/gmx/ISyntheticReader.sol\";\nimport { IChainlinkOracle } from \"../interfaces/oracles/IChainlinkOracle.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\n\nimport { console } from \"forge-std/console.sol\";\n\ncontract GMXOracle {\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // GMX DataStore\n  address public immutable dataStore;\n  // GMX Synthetic Reader\n  ISyntheticReader public immutable syntheticReader;\n  // Chainlink oracle\n  IChainlinkOracle public immutable chainlinkOracle;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @param _DataStore Address of GMX DataStore\n    * @param _syntheticReader Address of GMX Synthetic Reader\n    * @param _chainlinkOracle Address of Chainlink oracle\n  */\n  constructor(\n    address _DataStore,\n    ISyntheticReader _syntheticReader,\n    IChainlinkOracle _chainlinkOracle\n  ) {\n    if (_DataStore == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(_syntheticReader) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(_chainlinkOracle) == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    dataStore = _DataStore;\n    syntheticReader = _syntheticReader;\n    chainlinkOracle = _chainlinkOracle;\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Get amountsOut of either the long or short token based on the amountsIn\n    * of either long or short token in the market\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param tokenIn TokenIn address\n    * @param amountIn Amount of tokenIn, expressed in tokenIn's decimals\n    * @return amountsOut Amount of tokenOut within LP (market) to be received, expressed in tokenOut's decimals\n  */\n  function getAmountsOut(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    address tokenIn,\n    uint256 amountIn\n  ) public view returns (uint256) {\n    ISyntheticReader.MarketProps memory _market;\n    _market.marketToken = marketToken;\n    _market.indexToken = indexToken;\n    _market.longToken = longToken;\n    _market.shortToken = shortToken;\n\n    ISyntheticReader.PriceProps memory _indexTokenPrice;\n    _indexTokenPrice.min = _getTokenPriceMinMaxFormatted(indexToken);\n    _indexTokenPrice.max = _getTokenPriceMinMaxFormatted(indexToken);\n\n    ISyntheticReader.PriceProps memory _longTokenPrice;\n    _longTokenPrice.min = _getTokenPriceMinMaxFormatted(longToken);\n    _longTokenPrice.max = _getTokenPriceMinMaxFormatted(longToken);\n\n    ISyntheticReader.PriceProps memory _shortTokenPrice;\n    _shortTokenPrice.min = _getTokenPriceMinMaxFormatted(shortToken);\n    _shortTokenPrice.max = _getTokenPriceMinMaxFormatted(shortToken);\n\n    ISyntheticReader.MarketPrices memory _prices;\n    _prices.indexTokenPrice = _indexTokenPrice;\n    _prices.longTokenPrice = _longTokenPrice;\n    _prices.shortTokenPrice = _shortTokenPrice;\n\n    address _uiFeeReceiver = address(0);\n\n    (uint256 _amountsOut,,) = syntheticReader.getSwapAmountOut(\n      dataStore,\n      _market,\n      _prices,\n      tokenIn,\n      amountIn,\n      _uiFeeReceiver\n    );\n\n    return _amountsOut;\n  }\n\n  /**\n    * @notice Helper function to calculate amountIn of either long or short token for swapping for\n    * desired amountsOut of long or short token\n    * @notice We utilise GMX's getSwapAmountOut() with tokenOut being tokenIn, multiplying\n    * the amountsOut value by 1.0015x to account for fees and normal chainlink price feed differential\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param tokenOut TokenIn address\n    * @param amountsOut Amount of tokenIn, expressed in tokenIn's decimals\n    * @return amountsOut Amount of tokenOut within LP (market) to be received, expressed in tokenOut's decimals\n  */\n  function getAmountsIn(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    address tokenOut,\n    uint256 amountsOut\n  ) public view returns (uint256) {\n    return getAmountsOut(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      tokenOut,\n      amountsOut\n    ) * (1e18 + 15e14) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice Get LP (market) token info\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param pnlFactorType P&L Factory type in bytes32 hashed string\n    * @param maximize Min/max price boolean\n    * @return (marketTokenPrice, MarketPoolValueInfoProps MarketInfo)\n  */\n  function getMarketTokenInfo(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bytes32 pnlFactorType,\n    bool maximize\n  ) public view returns (int256, ISyntheticReader.MarketPoolValueInfoProps memory) {\n    if (address(marketToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(indexToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(longToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(shortToken) == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    ISyntheticReader.MarketProps memory _market;\n    _market.marketToken = marketToken;\n    _market.indexToken = indexToken;\n    _market.longToken = longToken;\n    _market.shortToken = shortToken;\n\n    ISyntheticReader.PriceProps memory _indexTokenPrice;\n    _indexTokenPrice.min = _getTokenPriceMinMaxFormatted(indexToken);\n    _indexTokenPrice.max = _getTokenPriceMinMaxFormatted(indexToken);\n\n    ISyntheticReader.PriceProps memory _longTokenPrice;\n    _longTokenPrice.min = _getTokenPriceMinMaxFormatted(longToken);\n    _longTokenPrice.max = _getTokenPriceMinMaxFormatted(longToken);\n\n    ISyntheticReader.PriceProps memory _shortTokenPrice;\n    _shortTokenPrice.min = _getTokenPriceMinMaxFormatted(shortToken);\n    _shortTokenPrice.max = _getTokenPriceMinMaxFormatted(shortToken);\n\n    return syntheticReader.getMarketTokenPrice(\n      dataStore,\n      _market,\n      _indexTokenPrice,\n      _longTokenPrice,\n      _shortTokenPrice,\n      pnlFactorType,\n      maximize\n    );\n  }\n\n  /**\n    * @notice Get LP (market) token reserves\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @return (reserveA, reserveB) Reserve amount of longToken and shortToken respectively\n  */\n  function getLpTokenReserves(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken\n  ) public view returns (uint256, uint256) {\n    // _pnlFactorType value does not matter in getting token reserves\n    bytes32 _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n\n    // _maximize value does not matter in getting token reserves\n    bool _maximize = false;\n\n    (, ISyntheticReader.MarketPoolValueInfoProps memory _marketInfo) = getMarketTokenInfo(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      _pnlFactorType,\n      _maximize\n    );\n\n    return (\n      _marketInfo.longTokenAmount,\n      _marketInfo.shortTokenAmount\n    );\n  }\n\n  /**\n    * @notice Get LP (market) token reserves\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param isDeposit Boolean for deposit or withdrawal\n    * @param maximize Boolean for minimum or maximum price\n    * @return marketTokenPrice in 1e18\n  */\n  function getLpTokenValue(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    bytes32 _pnlFactorType;\n\n    if (isDeposit) {\n      _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n    } else {\n      _pnlFactorType = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_WITHDRAWALS\"));\n    }\n\n    (int256 _marketTokenPrice,) = getMarketTokenInfo(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      _pnlFactorType,\n      maximize\n    );\n\n    // If LP token value is negative, return 0\n    if (_marketTokenPrice < 0) {\n      return 0;\n    } else {\n      // Price returned in 1e30, we normalize it to 1e18\n      return uint256(_marketTokenPrice) / 1e12;\n    }\n  }\n\n\n  /**\n    * @notice Get token A and token B's LP token amount required for a given value\n    * @param givenValue Given value needed, expressed in 1e30\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param isDeposit Boolean for deposit or withdrawal\n    * @param maximize Boolean for minimum or maximum price\n    * @return lpTokenAmount Amount of LP tokens; expressed in 1e18\n  */\n  function getLpTokenAmount(\n    uint256 givenValue,\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bool isDeposit,\n    bool maximize\n  ) public view returns (uint256) {\n    uint256 _lpTokenValue = getLpTokenValue(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      isDeposit,\n      maximize\n    );\n\n    return givenValue * SAFE_MULTIPLIER / _lpTokenValue;\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Get token price formatted for GMX mix/max decimals for 1e30 normalization\n    * @dev E.g. if token decimals is 18, to normalize to 1e30, we need to return 30-18 = 1e12\n    * consult() usually returns asset price in 8 decimals, so 30 - tokenDecimals - priceDecimals\n    * should format the decimals correctly for 1e30\n    * @param token Token address\n    * @return tokenPriceMinMaxFormatted\n  */\n  function _getTokenPriceMinMaxFormatted(address token) internal view returns (uint256) {\n    (int256 _price, uint8 _priceDecimals) = chainlinkOracle.consult(token);\n\n    return uint256(_price) * 10 ** (30 - IERC20Metadata(token).decimals() - _priceDecimals);\n  }\n}"
    },
    {
      "filename": "contracts/oracles/GMXOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISyntheticReader } from \"../interfaces/protocols/gmx/ISyntheticReader.sol\";\nimport { IChainlinkOracle } from \"../interfaces/oracles/IChainlinkOracle.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\n\nimport { console } from \"forge-std/console.sol\";\n\ncontract GMXOracle {\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // GMX DataStore\n  address public immutable dataStore;\n  // GMX Synthetic Reader\n  ISyntheticReader public immutable syntheticReader;\n  // Chainlink oracle\n  IChainlinkOracle public immutable chainlinkOracle;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @param _DataStore Address of GMX DataStore\n    * @param _syntheticReader Address of GMX Synthetic Reader\n    * @param _chainlinkOracle Address of Chainlink oracle\n  */\n  constructor(\n    address _DataStore,\n    ISyntheticReader _syntheticReader,\n    IChainlinkOracle _chainlinkOracle\n  ) {\n    if (_DataStore == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(_syntheticReader) == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (address(_chainlinkOracle) == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    dataStore = _DataStore;\n    syntheticReader = _syntheticReader;\n    chainlinkOracle = _chainlinkOracle;\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Get amountsOut of either the long or short token based on the amountsIn\n    * of either long or short token in the market\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param tokenIn TokenIn address\n    * @param amountIn Amount of tokenIn, expressed in tokenIn's decimals\n    * @return amountsOut Amount of tokenOut within LP (market) to be received, expressed in tokenOut's decimals\n  */\n  function getAmountsOut(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    address tokenIn,\n    uint256 amountIn\n  ) public view returns (uint256) {\n    ISyntheticReader.MarketProps memory _market;\n    _market.marketToken = marketToken;\n    _market.indexToken = indexToken;\n    _market.longToken = longToken;\n    _market.shortToken = shortToken;\n\n    ISyntheticReader.PriceProps memory _indexTokenPrice;\n    _indexTokenPrice.min = _getTokenPriceMinMaxFormatted(indexToken);\n    _indexTokenPrice.max = _getTokenPriceMinMaxFormatted(indexToken);\n\n    ISyntheticReader.PriceProps memory _longTokenPrice;\n    _longTokenPrice.min = _getTokenPriceMinMaxFormatted(longToken);\n    _longTokenPrice.max = _getTokenPriceMinMaxFormatted(longToken);\n\n    ISyntheticReader.PriceProps memory _shortTokenPrice;\n    _shortTokenPrice.min = _getTokenPriceMinMaxFormatted(shortToken);\n    _shortTokenPrice.max = _getTokenPriceMinMaxFormatted(shortToken);\n\n    ISyntheticReader.MarketPrices memory _prices;\n    _prices.indexTokenPrice = _indexTokenPrice;\n    _prices.longTokenPrice = _longTokenPrice;\n    _prices.shortTokenPrice = _shortTokenPrice;\n\n    address _uiFeeReceiver = address(0);\n\n    (uint256 _amountsOut,,) = syntheticReader.getSwapAmountOut(\n      dataStore,\n      _market,\n      _prices,\n      tokenIn,\n      amountIn,\n      _uiFeeReceiver\n    );\n\n    return _amountsOut;\n  }\n\n  /**\n    * @notice Helper function to calculate amountIn of either long or short token for swapping for\n    * desired amountsOut of long or short token\n    * @notice We utilise GMX's getSwapAmountOut() with tokenOut being tokenIn, multiplying\n    * the amountsOut value by 1.0015x to account for fees and normal chainlink price feed differential\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param tokenOut TokenIn address\n    * @param amountsOut Amount of tokenIn, expressed in tokenIn's decimals\n    * @return amountsOut Amount of tokenOut within LP (market) to be received, expressed in tokenOut's decimals\n  */\n  function getAmountsIn(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    address tokenOut,\n    uint256 amountsOut\n  ) public view returns (uint256) {\n    return getAmountsOut(\n      marketToken,\n      indexToken,\n      longToken,\n      shortToken,\n      tokenOut,\n      amountsOut\n    ) * (1e18 + 15e14) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice Get LP (market) token info\n    * @param marketToken LP token address\n    * @param indexToken Index token address\n    * @param longToken Long token address\n    * @param shortToken Short token address\n    * @param pnlFactorType P&L Factory type in bytes32 hashed string\n    * @param maximize Min/max price boolean\n    * @return (marketTokenPrice, MarketPoolValueInfoProps MarketInfo)\n  */\n  function getMarketTokenInfo(\n    address marketToken,\n    address indexToken,\n    address longToken,\n    address shortToken,\n    bytes32 pnlFactorType,\n    bool"
    }
  ]
}