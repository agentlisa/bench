{
  "Title": "M-12: Vault_Synths.sol code does not consider protocol exchange fee when evaluating the Collateral worth",
  "Content": "# Issue M-12: Vault_Synths.sol code does not consider protocol exchange fee when evaluating the Collateral worth \n\nSource: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/120 \n\n## Found by \nctf\\_sec\n\n## Summary\n\nVault_Synths.sol code does not consider protocol fee.\n\n## Vulnerability Detail\n\nIf we look into the good-written documentation:\n\nhttps://github.com/kree-dotcom/isomorph/blob/789338c8979ab75b8187781a2500908bb26dcdea/docs/Vault_Lyra.md#getwithdrawalfee\n\nI want to quote:\n\n> Because the withdrawalFee of a lyra LP pool can vary we must fetch it each time it is needed to ensure we use an accurate value. LP tokens are devalued by this as a safety measure as any liquidation would include selling the collateral and so should factor in that cost to ensure it is profitable.\n\nIn Vault_Lyra.sol, when calculating the collateral of the LP token, the fee is taken into consideration.\n\n```solidity\nfunction priceCollateralToUSD(bytes32 _currencyKey, uint256 _amount) public view override returns(uint256){\n     //The LiquidityPool associated with the LP Token is used for pricing\n    ILiquidityPoolAvalon LiquidityPool = ILiquidityPoolAvalon(collateralBook.liquidityPoolOf(_currencyKey));\n    //we have already checked for stale greeks so here we call the basic price function.\n    uint256 tokenPrice = LiquidityPool.getTokenPrice();          \n    uint256 withdrawalFee = _getWithdrawalFee(LiquidityPool);\n    uint256 USDValue  = (_amount * tokenPrice) / LOAN_SCALE;\n    //we remove the Liquidity Pool withdrawalFee \n    //as there's no way to remove the LP position without paying this.\n    uint256 USDValueAfterFee = USDValue * (LOAN_SCALE- withdrawalFee)/LOAN_SCALE;\n    return(USDValueAfterFee);\n}\n```\n\nThis is not the case for Vault_Synths.sol, the underlying token also charge exchange fee, but this fee is not reflected when evaluating the Collateral worth.\n\nhttps://docs.synthetix.io/incentives/#exchange-fees\n\n> Exchange fees are generated whenever a user exchanges one synthetic asset (Synth) for another through [Synthetix.Exchange](https://synthetix.exchange/). Fees are typically between 10-100 bps (0.1%-1%), though usually 30 bps, and when generated are sent to the fee pool, where it is available to be claimed proportionally by SNX stakers each week.\n\nIf we go to https://synthetix.io/synths,\n\nwe can see that the sETH token charges 0.25%, the sBTC token charges 0.25%, the sUSD charges 0% fee, but this does not ensure this fee rate will not change in the future.\n\n## Impact\n\nThe collateral may be overvalued because the exchange does not count when evaluating the Collateral worth and result in bad debt which makes the project insolvent.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the project consider protocol exchange fee when evaluating the Collateral worth in Vault_Synths.sol \n\nhttps://github.com/Synthetixio/synthetix/blob/develop/contracts/SystemSettings.sol#L362\n\nPrecisely when the exchange fee is updated, the fee is reflected in the collateral worth.\n\n```solidity\n    function setExchangeFeeRateForSynths(bytes32[] calldata synthKeys, uint256[] calldata exchangeFeeRates)\n        external\n        onlyOwner\n    {\n        flexibleStorage().setExchangeFeeRateForSynths(SETTING_EXCHANGE_FEE_RATE, synthKeys, exchangeFeeRates);\n        for (uint i = 0; i < synthKeys.length; i++) {\n            emit ExchangeFeeUpdated(synthKeys[i], exchangeFeeRates[i]);\n        }\n    }\n\n    /// @notice Set exchange dynamic fee threshold constant in decimal ratio\n    /// @param threshold The exchange dynamic fee threshold\n    /// @return uint threshold constant\n    function setExchangeDynamicFeeThreshold(uint threshold) external onlyOwner {\n        require(threshold != 0, \"Threshold cannot be 0\");\n\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD, threshold);\n\n        emit ExchangeDynamicFeeThresholdUpdated(threshold);\n    }\n```\n\n## Discussion\n\n**kree-dotcom**\n\nSPonsor confirmed, will fix\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/22",
  "Code": [
    {
      "filename": "docs/Vault_Lyra.md",
      "content": "# Vault_Lyra.sol function purposes\n\n## Functions\n\n\n### _checkIfCollateralIsActive\nFor the liquidation system assumptions to function correctly it is essential that when interacted with Lyra LP tokens their value is not stale. If it is stale then liquidators cannot sell the collateral and so will not desire to execute liquidations and the wrong value will be used for altering loans.\n\n- For Lyra LP tokens we check the function “getTokenPriceWithCheck()“ for the LiquidityPool related to this Liquidity Provider token. This tells us two things:\n    1. isStale this tells us if the greeks have been updated recently. If they have not then it is possible that the value of the liquidity Provider Tokens is wrong and so it is dangerous to interact with loans based on their value.\n    2. CircuitBreakerExpiry, this tells us if any of the Lyra circuit breakers (Details here https://docs.lyra.finance/developers/parameters/gwav-parameters#iv-skewvariancecbtimeout and LiquidityCBTimeout below) have been triggered recently and are cooling down. During the cooldown period withdrawals and deposits of LP tokens are restricted and so it can be dangerous to issue new loans. \n    \n\n### getWithdrawalFee \nBecause the withdrawalFee of a lyra LP pool can vary we must fetch it each time it is needed to ensure we use an accurate value. LP tokens are devalued by this as a safety measure as any liquidation would include selling the collateral and so should factor in that cost to ensure it is profitable. \n\n    \n### priceCollateralToUSD\nThis function allows us to price any collateral in USD.\nAs Lyra is based on Synthetix it shows value in sUSD, for simplicity we currently fix sUSD's value at $1 though in practice it has been known to vary from this amount by a few percent.\n\n- This function is left as public for ease of exchange rate checking by outside parties. It is a view function and so harmless. \n\n-  we use the LiquidityPool contract related to the Liquidity Provider token. This contract has a “getTokenPrice()” function which enables us to price any non-stale LP token. Any call to PriceCollateralToUSD must be preceded by a “_checkifCollateralIsActive()” check as the returned prices are meaningless if the collateral is inactive or stale.\n\n### openLoan\nThis function enables a user to open a new loan with any supported collateral. It is intended to be called by anyone in order to open a loan relating to themselves only. \n- The function first checks the supplied collateral is a valid collateral address and that the user has greater than or equal to that quantity of collateral in their possession.\n\n- Next the virtual price associated with this collateral is updated and after this has happened the collateral’s values are fetched from the collateralBook contract. \n\n- Using the currencyKey from this we then call an external contract from Lyra to verify that the collateral token we are using is not stale.\n\n- Now the value of the proposed collateral amount is converted to dollars and we calculate the required collateral amount, in dollars, needed to back the proposed loan. We can then verify that the amount of collateral proposed is greater or equal to this.\n\n- We update the mappings that record the collateral the loan holder has sent to the vault and the isoUSD borrowed from the vault then emit an event to record the opening of a new loan or increasing of an existing one. \n\n- Finally we make calls to the internal functions that handle increasing the collateral and loan of a user by transfering from and to the user. \n\nopenLoan can be used to either open a new loan or increase an existing one.\n    \n### IncreaseCollateralAmount\nThis function handles increasing the amount of collateral an existing loan already has to reduce the risk of a user’s debt falling below the liquidation point.\n\n- First a collateral existance precheck is performed then we verify the user already has a loan with the vault, this is to prevent confusing event logs if there wasn’t already a related loan.\n\n- We check the collateral being added is non-zero and that the user has greater than or equal to that quantity of collateral in their possession.\n\n- The virtual price of this collateral token is then updated and once this has happened we can fetch the collateral’s relevant values from the collateralBook contract.\n\n- Using the currencyKey from this we then call an external contract from Lyra to verify that the collateral token we are using is not stale.\n\n- Next we check to see if increasing the collateral by the suggested amount will bring the user’s debt above the liquidation point. (Nb: this check isn’t essential but seems fair, otherwise a user could increase the collateral of their loan only to have it all taken from them as now liquidation is profitable for a liquidator). \n\n- We record the increase in collateral then emit the IncreaseCollateral event to log this.\n\n- We then call the internal function that handles increasing collateral balances by transfering the collateral tokens from the user.\n\n### closeLoan\nThis function enables the user to close their loans. It can also be used to return collateral in excess of the opening margin requirements and pay down the borrowed loan separately. \n- The function begins by doing prechecks, then the _closeLoanChecks function detailed before is called.\n\n- The virtual price of this collateral token is then updated and once this has happened we can fetch the collateral’s relevant values from the collateralBook contract.\n\n- Using the currencyKey from this we then call an external contract from Lyra to verify that the collateral token we are using is not stale.\n\n- Using the virtual price it then calculates the total debt the user has incurred for this loan, it verifies that the isoUSD being returned doesn’t exceed this value.\n\n- If the user isn’t completely closing the loan (We consider debt of <$0.001 completely closed to avoid dust amounts) the function then checks that the updated amounts of collateral and loan meet the opening margin requirements. \n\n- Because we repay the loan principle prior to the loan interest we determine if the full loan principle has been repaid, if so then any excess repaid over this is interest being repaid, the interest repaid is sent to the Treasury not burnt and so we must record it seperately. \n\n- Next we update the internal ledgers of how much collateral the user still has posted and how much isoUSD total they have to repay. \n\n- Once this is done we emit the ClosedLoan event.\n\n- Finally we transfer any returning collateral back to the user and transfer any isoUSD being repaid to the vault by calling _decreaseLoan.\n\n\n### callLiquidation\nThis is the way that external users can call a liquidation of any current debt that fails to meet the minimum margin ratio of the collateral token they are using. Users are incentivized by a 5% reward on the liquidation amount. Given optimism transaction fees are low this should incentivize the liquidation of any debt amount greater than around $2.\n \n- The function checks the collateral address is valid and the specified loan holder is not the zero address. \n\n- Then it updates the virtual price of this collateral token and once this has happened we can fetch the collateral’s relevant values from the collateralBook contract. \n\n- Using the currencyKey from this we then call an external contract from Lyra to ensure the collateral's price is not stale and the circuit breakers are not active.\n\n- We fetch the loan holder’s accrued debt and supplied collateral before passing these and the collateral characteristics to the viewLiquidatableAmount. This then returns the quantity of collateral that should be liquidated to return the loan holder’s debt to the minimum margin ratio required for this collateral token. \n\n- We check the amount is non-zero, else the loan is not liquidatable at all, then we check if it is greater than the loan holder’s collateral. If so we reduce it to their total collateral. This suggests the debt has gone bad and fully reclaiming the debt is impossible. \n\n- Bad debts should not occur under normal market conditions and will result in a loss to the system if it occurs, the liquidator will however still be incentivized to trigger liquidation by being paid a percentage of the total collateral.\n\n- If the liquidation is the entire collateral supplied we check to see if the debt had gone bad, if so we emit an event BadDebtCleared to log this occurrence and manually reset the loan holder’s loaned isoUSD as with no collateral at stake they would have no incentive to repay it anyway and a non-zero balance would prevent them interacting properly when trying to open new loans. \n\n- We then  call the internal _liquidate function to continue the process."
    },
    {
      "filename": "contracts/SystemSettings.sol",
      "content": "pragma solidity ^0.5.16;\n\n// Inheritance\nimport \"./Owned.sol\";\nimport \"./MixinSystemSettings.sol\";\nimport \"./interfaces/ISystemSettings.sol\";\nimport \"./SystemSettingsLib.sol\";\n\n// https://docs.synthetix.io/contracts/source/contracts/systemsettings\ncontract SystemSettings is Owned, MixinSystemSettings, ISystemSettings {\n    // SystemSettingsLib is a way to split out the setters to reduce contract size\n    using SystemSettingsLib for IFlexibleStorage;\n\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinSystemSettings(_resolver) {\n        // SETTING_CONTRACT_NAME is defined for the getters in MixinSystemSettings and\n        // SystemSettingsLib.contractName() is a view into SystemSettingsLib of the contract name\n        // that's used by the setters. They have to be equal.\n        require(SETTING_CONTRACT_NAME == SystemSettingsLib.contractName(), \"read and write keys not equal\");\n    }\n\n    // ========== VIEWS ==========\n\n    // backwards compatibility to having CONTRACT_NAME public constant\n    // solhint-disable-next-line func-name-mixedcase\n    function CONTRACT_NAME() external view returns (bytes32) {\n        return SystemSettingsLib.contractName();\n    }\n\n    // SIP-37 Fee Reclamation\n    // The number of seconds after an exchange is executed that must be waited\n    // before settlement.\n    function waitingPeriodSecs() external view returns (uint) {\n        return getWaitingPeriodSecs();\n    }\n\n    // SIP-65 Decentralized Circuit Breaker\n    // The factor amount expressed in decimal format\n    // E.g. 3e18 = factor 3, meaning movement up to 3x and above or down to 1/3x and below\n    function priceDeviationThresholdFactor() external view returns (uint) {\n        return getPriceDeviationThresholdFactor();\n    }\n\n    // The raio of collateral\n    // Expressed in 18 decimals. So 800% cratio is 100/800 = 0.125 (0.125e18)\n    function issuanceRatio() external view returns (uint) {\n        return getIssuanceRatio();\n    }\n\n    // How long a fee period lasts at a minimum. It is required for\n    // anyone to roll over the periods, so they are not guaranteed\n    // to roll over at exactly this duration, but the contract enforces\n    // that they cannot roll over any quicker than this duration.\n    function feePeriodDuration() external view returns (uint) {\n        return getFeePeriodDuration();\n    }\n\n    // Users are unable to claim fees if their collateralisation ratio drifts out of target threshold\n    function targetThreshold() external view returns (uint) {\n        return getTargetThreshold();\n    }\n\n    // SIP-15 Liquidations\n    // liquidation time delay after address flagged (seconds)\n    function liquidationDelay() external view returns (uint) {\n        return getLiquidationDelay();\n    }\n\n    // SIP-15 Liquidations\n    // issuance ratio when account can be flagged for liquidation (with 18 decimals), e.g 0.5 issuance ratio\n    // when flag means 1/0.5 = 200% cratio\n    function liquidationRatio() external view returns (uint) {\n        return getLiquidationRatio();\n    }\n\n    // SIP-97 Liquidations\n    // penalty taken away from target of Collateral liquidation (with 18 decimals). E.g. 10% is 0.1e18\n    function liquidationPenalty() external view returns (uint) {\n        return getLiquidationPenalty();\n    }\n\n    // SIP-251 Differentiate Liquidation Penalties\n    // penalty taken away from target of SNX liquidation (with 18 decimals). E.g. 30% is 0.3e18\n    function snxLiquidationPenalty() external view returns (uint) {\n        return getSnxLiquidationPenalty();\n    }\n\n    /* ========== SIP-148: Upgrade Liquidation Mechanism ========== */\n\n    /// @notice Get the escrow duration for liquidation rewards\n    /// @return The escrow duration for liquidation rewards\n    function liquidationEscrowDuration() external view returns (uint) {\n        return getLiquidationEscrowDuration();\n    }\n\n    /// @notice Get the penalty for self liquidation\n    /// @return The self liquidation penalty\n    function selfLiquidationPenalty() external view returns (uint) {\n        return getSelfLiquidationPenalty();\n    }\n\n    /// @notice Get the reward for flagging an account for liquidation\n    /// @return The reward for flagging an account\n    function flagReward() external view returns (uint) {\n        return getFlagReward();\n    }\n\n    /// @notice Get the reward for liquidating an account\n    /// @return The reward for performing a forced liquidation\n    function liquidateReward() external view returns (uint) {\n        return getLiquidateReward();\n    }\n\n    /* ========== End SIP-148 ========== */\n\n    // How long will the ExchangeRates contract assume the rate of any asset is correct\n    function rateStalePeriod() external view returns (uint) {\n        return getRateStalePeriod();\n    }\n\n    /* ========== Exchange Related Fees ========== */\n    function exchangeFeeRate(bytes32 currencyKey) external view returns (uint) {\n        return getExchangeFeeRate(currencyKey);\n    }\n\n    // SIP-184 Dynamic Fee\n    /// @notice Get the dynamic fee threshold\n    /// @return The dynamic fee threshold\n    function exchangeDynamicFeeThreshold() external view returns (uint) {\n        return getExchangeDynamicFeeConfig().threshold;\n    }\n\n    /// @notice Get the dynamic fee weight decay per round\n    /// @return The dynamic fee weight decay per round\n    function exchangeDynamicFeeWeightDecay() external view returns (uint) {\n        return getExchangeDynamicFeeConfig().weightDecay;\n    }\n\n    /// @notice Get the dynamic fee total rounds for calculation\n    /// @return The dynamic fee total rounds for calculation\n    function exchangeDynamicFeeRounds() external view returns (uint) {\n        return getExchangeDynamicFeeConfig().rounds;\n    }\n\n    /// @notice Get the max dynamic fee\n    /// @return The max dynamic fee\n    function exchangeMaxDynamicFee() external view returns (uint) {\n        return getExchangeDynamicFeeConfig().maxFee;\n    }\n\n    /* ========== End Exchange Related Fees ========== */\n\n    function minimumStakeTime() external view returns (uint) {\n        return getMinimumStakeTime();\n    }\n\n    function debtSnapshotStaleTime() external view returns (uint) {\n        return getDebtSnapshotStaleTime();\n    }\n\n    function aggregatorWarningFlags() external view returns (address) {\n        return getAggregatorWarningFlags();\n    }\n\n    // SIP-63 Trading incentives\n    // determines if Exchanger records fee entries in TradingRewards\n    function tradingRewardsEnabled() external view returns (bool) {\n        return getTradingRewardsEnabled();\n    }\n\n    function crossDomainMessageGasLimit(CrossDomainMessageGasLimits gasLimitType) external view returns (uint) {\n        return getCrossDomainMessageGasLimit(gasLimitType);\n    }\n\n    // SIP 112: ETH Wrappr\n    // The maximum amount of ETH held by the EtherWrapper.\n    function etherWrapperMaxETH() external view returns (uint) {\n        return getEtherWrapperMaxETH();\n    }\n\n    // SIP 112: ETH Wrappr\n    // The fee for depositing ETH into the EtherWrapper.\n    function etherWrapperMintFeeRate() external view returns (uint) {\n        return getEtherWrapperMintFeeRate();\n    }\n\n    // SIP 112: ETH Wrappr\n    // The fee for burning sETH and releasing ETH from the EtherWrapper.\n    function etherWrapperBurnFeeRate() external view returns (uint) {\n        return getEtherWrapperBurnFeeRate();\n    }\n\n    // SIP 182: Wrapper Factory\n    // The maximum amount of token held by the Wrapper.\n    function wrapperMaxTokenAmount(address wrapper) external view returns (uint) {\n        return getWrapperMaxTokenAmount(wrapper);\n    }\n\n    // SIP 182: Wrapper Factory\n    // The fee for depositing token into the Wrapper.\n    function wrapperMintFeeRate(address wrapper) external view returns (int) {\n        return getWrapperMintFeeRate(wrapper);\n    }\n\n    // SIP 182: Wrapper Factory\n    // The fee for burning synth and releasing token from the Wrapper.\n    function wrapperBurnFeeRate(address wrapper) external view returns (int) {\n        return getWrapperBurnFeeRate(wrapper);\n    }\n\n    function interactionDelay(address collateral) external view returns (uint) {\n        return getInteractionDelay(collateral);\n    }\n\n    function collapseFeeRate(address collateral) external view returns (uint) {\n        return getCollapseFeeRate(collateral);\n    }\n\n    // SIP-120 Atomic exchanges\n    // max allowed volume per block for atomic exchanges\n    function atomicMaxVolumePerBlock() external view returns (uint) {\n        return getAtomicMaxVolumePerBlock();\n    }\n\n    // SIP-120 Atomic exchanges\n    // time window (in seconds) for TWAP prices when considered for atomic exchanges\n    function atomicTwapWindow() external view returns (uint) {\n        return getAtomicTwapWindow();\n    }\n\n    // SIP-120 Atomic exchanges\n    // equivalent asset to use for a synth when considering external prices for atomic exchanges\n    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address) {\n        return getAtomicEquivalentForDexPricing(currencyKey);\n    }\n\n    // SIP-120 Atomic exchanges\n    // fee rate override for atomic exchanges into a synth\n    function atomicExchangeFeeRate(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicExchangeFeeRate(currencyKey);\n    }\n\n    // SIP-120 Atomic exchanges\n    // consideration window for determining synth volatility\n    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicVolatilityConsiderationWindow(currencyKey);\n    }\n\n    // SIP-120 Atomic exchanges\n    // update threshold for determining synth volatility\n    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicVolatilityUpdateThreshold(currencyKey);\n    }\n\n    // SIP-198: Atomic Exchange At Pure Chainlink Price\n    // Whether to use the pure Chainlink price for a given currency key\n    function pureChainlinkPriceForAtomicSwapsEnabled(bytes32 currencyKey) external view returns (bool) {\n        return getPureChainlinkPriceForAtomicSwapsEnabled(currencyKey);\n    }\n\n    // SIP-229 Atomic exchanges\n    // enable/disable sending of synths cross chain\n    function crossChainSynthTransferEnabled(bytes32 currencyKey) external view returns (uint) {\n        return getCrossChainSynthTransferEnabled(currencyKey);\n    }\n\n    // ========== RESTRICTED ==========\n\n    function setCrossDomainMessageGasLimit(CrossDomainMessageGasLimits _gasLimitType, uint _crossDomainMessageGasLimit)\n        external\n        onlyOwner\n    {\n        flexibleStorage().setCrossDomainMessageGasLimit(_getGasLimitSetting(_gasLimitType), _crossDomainMessageGasLimit);\n        emit CrossDomainMessageGasLimitChanged(_gasLimitType, _crossDomainMessageGasLimit);\n    }\n\n    function setIssuanceRatio(uint ratio) external onlyOwner {\n        flexibleStorage().setIssuanceRatio(SETTING_ISSUANCE_RATIO, ratio);\n        emit IssuanceRatioUpdated(ratio);\n    }\n\n    function setTradingRewardsEnabled(bool _tradingRewardsEnabled) external onlyOwner {\n        flexibleStorage().setTradingRewardsEnabled(SETTING_TRADING_REWARDS_ENABLED, _tradingRewardsEnabled);\n        emit TradingRewardsEnabled(_tradingRewardsEnabled);\n    }\n\n    function setWaitingPeriodSecs(uint _waitingPeriodSecs) external onlyOwner {\n        flexibleStorage().setWaitingPeriodSecs(SETTING_WAITING_PERIOD_SECS, _waitingPeriodSecs);\n        emit WaitingPeriodSecsUpdated(_waitingPeriodSecs);\n    }\n\n    function setPriceDeviationThresholdFactor(uint _priceDeviationThresholdFactor) external onlyOwner {\n        flexibleStorage().setPriceDeviationThresholdFactor(\n            SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR,\n            _priceDeviationThresholdFactor\n        );\n        emit PriceDeviationThresholdUpdated(_priceDeviationThresholdFactor);\n    }\n\n    function setFeePeriodDuration(uint _feePeriodDuration) external onlyOwner {\n        flexibleStorage().setFeePeriodDuration(SETTING_FEE_PERIOD_DURATION, _feePeriodDuration);\n        emit FeePeriodDurationUpdated(_feePeriodDuration);\n    }\n\n    function setTargetThreshold(uint percent) external onlyOwner {\n        uint threshold = flexibleStorage().setTargetThreshold(SETTING_TARGET_THRESHOLD, percent);\n        emit TargetThresholdUpdated(threshold);\n    }\n\n    function setLiquidationDelay(uint time) external onlyOwner {\n        flexibleStorage().setLiquidationDelay(SETTING_LIQUIDATION_DELAY, time);\n        emit LiquidationDelayUpdated(time);\n    }\n\n    // The collateral / issuance ratio ( debt / collateral ) is higher when there is less collateral backing their debt\n    // Upper bound liquidationRatio is 1 + penalty (100% + 10% = 110%) to allow collateral value to cover debt and liquidation penalty\n    function setLiquidationRatio(uint _liquidationRatio) external onlyOwner {\n        flexibleStorage().setLiquidationRatio(\n            SETTING_LIQUIDATION_RATIO,\n            _liquidationRatio,\n            getSnxLiquidationPenalty(),\n            getIssuanceRatio()\n        );\n        emit LiquidationRatioUpdated(_liquidationRatio);\n    }\n\n    function setLiquidationEscrowDuration(uint duration) external onlyOwner {\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_ESCROW_DURATION, duration);\n        emit LiquidationEscrowDurationUpdated(duration);\n    }\n\n    function setSnxLiquidationPenalty(uint penalty) external onlyOwner {\n        flexibleStorage().setSnxLiquidationPenalty(SETTING_SNX_LIQUIDATION_PENALTY, penalty);\n        emit SnxLiquidationPenaltyUpdated(penalty);\n    }\n\n    function setLiquidationPenalty(uint penalty) external onlyOwner {\n        flexibleStorage().setLiquidationPenalty(SETTING_LIQUIDATION_PENALTY, penalty);\n        emit LiquidationPenaltyUpdated(penalty);\n    }\n\n    function setSelfLiquidationPenalty(uint penalty) external onlyOwner {\n        flexibleStorage().setSelfLiquidationPenalty(SETTING_SELF_LIQUIDATION_PENALTY, penalty);\n        emit SelfLiquidationPenaltyUpdated(penalty);\n    }\n\n    function setFlagReward(uint reward) external onlyOwner {\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_FLAG_REWARD, reward);\n        emit FlagRewardUpdated(reward);\n    }\n\n    function setLiquidateReward(uint reward) external onlyOwner {\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATE_REWARD, reward);\n        emit LiquidateRewardUpdated(reward);\n    }\n\n    function setRateStalePeriod(uint period) external onlyOwner {\n        flexibleStorage().setRateStalePeriod(SETTING_RATE_STALE_PERIOD, period);\n        emit RateStalePeriodUpdated(period);\n    }\n\n    /* ========== Exchange Fees Related ========== */\n    function setExchangeFeeRateForSynths(bytes32[] calldata synthKeys, uint256[] calldata exchangeFeeRates)\n        external\n        onlyOwner\n    {\n        flexibleStorage().setExchangeFeeRateForSynths(SETTING_EXCHANGE_FEE_RATE, synthKeys, exchangeFeeRates);\n        for (uint i = 0; i < synthKeys.length; i++) {\n            emit ExchangeFeeUpdated(synthKeys[i], exchangeFeeRates[i]);\n        }\n    }\n\n    /// @notice Set exchange dynamic fee threshold constant in decimal ratio\n    /// @param threshold The exchange dynamic fee threshold\n    /// @return uint threshold constant\n    function setExchangeDynamicFeeThreshold(uint threshold) external onlyOwner {\n        require(threshold != 0, \"Threshold cannot be 0\");\n\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD, threshold);\n\n        emit ExchangeDynamicFeeThresholdUpdated(threshold);\n    }\n\n    /// @notice Set exchange dynamic fee weight decay constant\n    /// @param weightDecay The exchange dynamic fee weight decay\n    /// @return uint weight decay constant\n    function setExchangeDynamicFeeWeightDecay(uint weightDecay) external onlyOwner {\n        require(weightDecay != 0, \"Weight decay cannot be 0\");\n\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY, weightDecay);\n\n        emit ExchangeDynamicFeeWeightDecayUpdated(weightDecay);\n    }\n\n    /// @notice Set exchange dynamic fee last N rounds with minimum 2 rounds\n    /// @param rounds The exchange dynamic fee last N rounds\n    /// @return uint dynamic fee last N rounds\n    function setExchangeDynamicFeeRounds(uint rounds) external onlyOwner {\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS, rounds);\n\n        emit ExchangeDynamicFeeRoundsUpdated(rounds);\n    }\n\n    /// @notice Set max exchange dynamic fee\n    /// @param maxFee The max exchange dynamic fee\n    /// @return uint dynamic fee last N rounds\n    function setExchangeMaxDynamicFee(uint maxFee) external onlyOwner {\n        flexibleStorage().setExchangeMaxDynamicFee(SETTING_EXCHANGE_MAX_DYNAMIC_FEE, maxFee);\n        emit ExchangeMaxDynamicFeeUpdated(maxFee);\n    }\n\n    function setMinimumStakeTime(uint _seconds) external onlyOwner {\n        flexibleStorage().setMinimumStakeTime(SETTING_MINIMUM_STAKE_TIME, _seconds);\n        emit MinimumStakeTimeUpdated(_seconds);\n    }\n\n    function setDebtSnapshotStaleTime(uint _seconds) external onlyOwner {\n        flexibleStorage().setDebtSnapshotStaleTime(SETTING_DEBT_SNAPSHOT_STALE_TIME, _seconds);\n        emit DebtSnapshotStaleTimeUpdated(_seconds);\n    }\n\n    function setAggregatorWarningFlags(address _flags) external onlyOwner {\n        flexibleStorage().setAggregatorWarningFlags(SETTING_AGGREGATOR_WARNING_FLAGS, _flags);\n        emit AggregatorWarningFlagsUpdated(_flags);\n    }\n\n    function setEtherWrapperMaxETH(uint _maxETH) external onlyOwner {\n        flexibleStorage().setEtherWrapperMaxETH(SETTING_ETHER_WRAPPER_MAX_ETH, _maxETH);\n        emit EtherWrapperMaxETHUpdated(_maxETH);\n    }\n\n    function setEtherWrapperMintFeeRate(uint _rate) external onlyOwner {\n        flexibleStorage().setEtherWrapperMintFeeRate(SETTING_ETHER_WRAPPER_MINT_FEE_RATE, _rate);\n        emit EtherWrapperMintFeeRateUpdated(_rate);\n    }\n\n    function setEtherWrapperBurnFeeRate(uint _rate) external onlyOwner {\n        flexibleStorage().setEtherWrapperBurnFeeRate(SETTING_ETHER_WRAPPER_BURN_FEE_RATE, _rate);\n        emit EtherWrapperBurnFeeRateUpdated(_rate);\n    }\n\n    function setWrapperMaxTokenAmount(address _wrapper, uint _maxTokenAmount) external onlyOwner {\n        flexibleStorage().setWrapperMaxTokenAmount(SETTING_WRAPPER_MAX_TOKEN_AMOUNT, _wrapper, _maxTokenAmount);\n        emit WrapperMaxTokenAmountUpdated(_wrapper, _maxTokenAmount);\n    }\n\n    function setWrapperMintFeeRate(address _wrapper, int _rate) external onlyOwner {\n        flexibleStorage().setWrapperMintFeeRate(\n            SETTING_WRAPPER_MINT_FEE_RATE,\n            _wrapper,\n            _rate,\n            getWrapperBurnFeeRate(_wrapper)\n        );\n        emit WrapperMintFeeRateUpdated(_wrapper, _rate);\n    }\n\n    function setWrapperBurnFeeRate(address _wrapper, int _rate) external onlyOwner {\n        flexibleStorage().setWrapperBurnFeeRate(\n            SETTING_WRAPPER_BURN_FEE_RATE,\n            _wrapper,\n            _rate,\n            getWrapperMintFeeRate(_wrapper)\n        );\n        emit WrapperBurnFeeRateUpdated(_wrapper, _rate);\n    }\n\n    function setInteractionDelay(address _collateral, uint _interactionDelay) external onlyOwner {\n        flexibleStorage().setInteractionDelay(SETTING_INTERACTION_DELAY, _collateral, _interactionDelay);\n        emit InteractionDelayUpdated(_interactionDelay);\n    }\n\n    function setCollapseFeeRate(address _collateral, uint _collapseFeeRate) external onlyOwner {\n        flexibleStorage().setCollapseFeeRate(SETTING_COLLAPSE_FEE_RATE, _collateral, _collapseFeeRate);\n        emit CollapseFeeRateUpdated(_collapseFeeRate);\n    }\n\n    function setAtomicMaxVolumePerBlock(uint _maxVolume) external onlyOwner {\n        flexibleStorage().setAtomicMaxVolumePerBlock(SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK, _maxVolume);\n        emit AtomicMaxVolumePerBlockUpdated(_maxVolume);\n    }\n\n    function setAtomicTwapWindow(uint _window) external onlyOwner {\n        flexibleStorage().setAtomicTwapWindow(SETTING_ATOMIC_TWAP_WINDOW, _window);\n        emit AtomicTwapWindowUpdated(_window);\n    }\n\n    function setAtomicEquivalentForDexPricing(bytes32 _currencyKey, address _equivalent) external onlyOwner {\n        flexibleStorage().setAtomicEquivalentForDexPricing(\n            SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING,\n            _currencyKey,\n            _equivalent\n        );\n        emit AtomicEquivalentForDexPricingUpdated(_currencyKey, _equivalent);\n    }\n\n    function setAtomicExchangeFeeRate(bytes32 _currencyKey, uint256 _exchangeFeeRate) external onlyOwner {\n        flexibleStorage().setAtomicExchangeFeeRate(SETTING_ATOMIC_EXCHANGE_FEE_RATE, _currencyKey, _exchangeFeeRate);\n        emit AtomicExchangeFeeUpdated(_currencyKey, _exchangeFeeRate);\n    }\n\n    function setAtomicVolatilityConsiderationWindow(bytes32 _currencyKey, uint _window) external onlyOwner {\n        flexibleStorage().setAtomicVolatilityConsiderationWindow(\n            SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,\n            _currencyKey,\n            _window\n        );\n        emit AtomicVolatilityConsiderationWindowUpdated(_currencyKey, _window);\n    }\n\n    function setAtomicVolatilityUpdateThreshold(bytes32 _currencyKey, uint _threshold) external onlyOwner {\n        flexibleStorage().setAtomicVolatilityUpdateThreshold(\n            SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD,\n            _currencyKey,\n            _threshold\n        );\n        emit AtomicVolatilityUpdateThresholdUpdated(_currencyKey, _threshold);\n    }\n\n    function setPureChainlinkPriceForAtomicSwapsEnabled(bytes32 _currencyKey, bool _enabled) external onlyOwner {\n        flexibleStorage().setPureChainlinkPriceForAtomicSwapsEnabled(\n            SETTING_PURE_CHAINLINK_PRICE_FOR_ATOMIC_SWAPS_ENABLED,\n            _currencyKey,\n            _enabled\n        );\n        emit PureChainlinkPriceForAtomicSwapsEnabledUpdated(_currencyKey, _enabled);\n    }\n\n    function setCrossChainSynthTransferEnabled(bytes32 _currencyKey, uint _value) external onlyOwner {\n        flexibleStorage().setCrossChainSynthTransferEnabled(SETTING_CROSS_SYNTH_TRANSFER_ENABLED, _currencyKey, _value);\n        emit CrossChainSynthTransferEnabledUpdated(_currencyKey, _value);\n    }\n\n    // ========== EVENTS ==========\n    event CrossDomainMessageGasLimitChanged(CrossDomainMessageGasLimits gasLimitType, uint newLimit);\n    event IssuanceRatioUpdated(uint newRatio);\n    event TradingRewardsEnabled(bool enabled);\n    event WaitingPeriodSecsUpdated(uint waitingPeriodSecs);\n    event PriceDeviationThresholdUpdated(uint threshold);\n    event FeePeriodDurationUpdated(uint newFeePeriodDuration);\n    event TargetThresholdUpdated(uint newTargetThreshold);\n    event LiquidationDelayUpdated(uint newDelay);\n    event LiquidationRatioUpdated(uint newRatio);\n    event LiquidationEscrowDurationUpdated(uint newDuration);\n    event LiquidationPenaltyUpdated(uint newPenalty);\n    event SnxLiquidationPenaltyUpdated(uint newPenalty);\n    event SelfLiquidationPenaltyUpdated(uint newPenalty);\n    event FlagRewardUpdated(uint newReward);\n    event LiquidateRewardUpdated(uint newReward);\n    event RateStalePeriodUpdated(uint rateStalePeriod);\n    /* ========== Exchange Fees Related ========== */\n    event ExchangeFeeUpdated(bytes32 synthKey, uint newExchangeFeeRate);\n    event ExchangeDynamicFeeThresholdUpdated(uint dynamicFeeThreshold);\n    event ExchangeDynamicFeeWeightDecayUpdated(uint dynamicFeeWeightDecay);\n    event ExchangeDynamicFeeRoundsUpdated(uint dynamicFeeRounds);\n    event ExchangeMaxDynamicFeeUpdated(uint maxDynamicFee);\n    /* ========== End Exchange Fees Related ========== */\n    event MinimumStakeTimeUpdated(uint minimumStakeTime);\n    event DebtSnapshotStaleTimeUpdated(uint debtSnapshotStaleTime);\n    event AggregatorWarningFlagsUpdated(address flags);\n    event Et"
    }
  ]
}