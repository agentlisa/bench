{
  "Title": "H-4: Revoking vesting schedule does not subtract user votes correctly",
  "Content": "# Issue H-4: Revoking vesting schedule does not subtract user votes correctly \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/118 \n\n## Found by \n0xAnmol, 0xpiken, 0xvj, 9oelm, Afriaudit, Ironsidesec, JigglypuffAndPikachu, KingNFT, KupiaSec, Ruhum, SilverChariot, Tendency, Tychai0s, Varun\\_05, amar, denzi\\_, dimulski, ether\\_sky, lemonmon, marchev, mt030d, rbserver, saidam017, sakshamguruji, samuraii77\n## Summary\n[ZivoeVestingRewards.revokeVestingSchedule()](https://github.com/sherlock-audit/2024-03-zivoe/blob/d4111645b19a1ad3ccc899bea073b6f19be04ccd/zivoe-core-foundry/src/ZivoeRewardsVesting.sol#L429-L467) should reduce the voting power of the user with the withdrawable amount plus the revoked amount. However, it reduces it only by the withdrawable amount.\n\n## Vulnerability Detail\nWhen called, `revokeVestingSchedule()` fetches the withdrawable amount by the user at that moment.\n```solidity\n        uint256 amount = amountWithdrawable(account);\n```\n\nThe revoke logic is executed and the user's checkpoint value is decreased by `amount`.\n```solidity\n        _writeCheckpoint(_checkpoints[account], _subtract, amount);\n```\n\nThe code ignores the amount that's being revoked and the user keeps more voting power than he has to.\nImagine the following:\n`totalVested = 1000`\n`withdrawable = 0`\n\nIf the schedule gets revoked, the user's checkpoint value will not be decreased at all because there is nothing to be withdrawn. The user can later use their voting power to vote on governance proposals.\n\nIn fact, `amountWithdrawable(account)` being close to 0 has a very high likelihood because:\n   - the user can frontrun the transaction and withdraw the tokens they are entitled to\n   -  it's highly likely that a vesting schedule will be removed shortly after creating it.\n\nHowever, even if `amountWithdrawable()` is not equal to 0, the user would still be left with more voting power.\n## Impact\nUsers keep voting power that must have been taken away.\n\n## Code Snippet\nPOC to be run in [Test_ZivoeRewardsVesting.sol](https://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-testing/src/TESTS_Core/Test_ZivoeRewardsVesting.sol)\n```solidity\n    function test_revoking_leaves_votes() public {\n       assert(zvl.try_createVestingSchedule(\n            address(vestZVE), \n            address(moe), \n            0, \n            360,\n            6000 ether, \n            true\n        ));\n        // Vesting succeeded\n        assertEq(vestZVE.balanceOf(address(moe)), 6000 ether);\n\n        hevm.roll(block.number + 1);\n     \n        // User votes have increased\n        assertEq(vestZVE.getPastVotes(address(moe), block.number - 1), 6000 ether);\n\n        assert(zvl.try_revokeVestingSchedule(address(vestZVE), address(moe)));\n        // Revoking succeeded\n        assertEq(vestZVE.balanceOf(address(moe)), 0);\n\n        hevm.roll(block.number + 1);\n        // User votes have not been decreased at all\n        assertEq(vestZVE.getPastVotes(address(moe), block.number - 1), 6000 ether);\n    }\n```\n\n## Tool used\n\nFoundry\n\n## Recommendation\nSubtract the correct amount from the checkpoint's value\n```diff\n-        _writeCheckpoint(_checkpoints[account], _subtract, amount);\n+       _writeCheckpoint(_checkpoints[account], _subtract, vestingAmount - vestingScheduleOf[account].totalWithdrawn + amount)\n```\n\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> high, incorrect checkpoints amount subtracted during `revokeVestingSchedule` causes permanent inflated amount of user votes.\n\n\n\n**pseudonaut**\n\nRecommended suggestion seems incorrect\n\nIt doesn't address the totalSupplyCheckpoints right above that line (both should be in tandem):\n\n```solidity\n_writeCheckpoint(_totalSupplyCheckpoints, _subtract, vestingAmount - vestingScheduleOf[account].totalWithdrawn + amount);\n_writeCheckpoint(_checkpoints[account], _subtract, vestingAmount - vestingScheduleOf[account].totalWithdrawn + amount);\n```\n\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Zivoe/zivoe-core-foundry/pull/268\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/ZivoeRewardsVesting.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"./libraries/ZivoeVotes.sol\";\n\nimport \"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/Context.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"../lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\";\n\ninterface IZivoeGlobals_ZivoeRewardsVesting {\n    /// @notice Returns the address of the ZivoeITO contract.\n    function ITO() external view returns (address);\n\n    /// @notice Returns the address of the ZivoeToken contract.\n    function ZVE() external view returns (address);\n\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n}\n\ninterface IZivoeITO_ZivoeRewardsVesting {\n    /// @dev Tracks $pZVE (credits) an individual has from juniorDeposit().\n    function juniorCredits(address) external returns(uint256);\n\n    /// @dev Tracks $pZVE (credits) an individual has from seniorDeposit().\n    function seniorCredits(address) external returns(uint256);\n}\n\n\n\n/// @notice  This contract facilitates staking and yield distribution, as well as vesting tokens.\n///          This contract has the following responsibilities:\n///            - Allows creation of vesting schedules (and revocation) for \"vestingToken\".\n///            - Allows unstaking of vested tokens.\n///            - Allows claiming yield distributed / \"deposited\" to this contract.\n///            - Allows multiple assets to be added as \"rewardToken\" for distributions (except for \"vestingToken\").\n///            - Vests rewardTokens linearly overtime to stakers.\ncontract ZivoeRewardsVesting is ReentrancyGuard, Context, ZivoeVotes {\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    struct Reward {\n        uint256 rewardsDuration;        /// @dev How long rewards take to vest, e.g. 30 days.\n        uint256 periodFinish;           /// @dev When current rewards will finish vesting.\n        uint256 rewardRate;             /// @dev Rewards emitted per second.\n        uint256 lastUpdateTime;         /// @dev Last time this data struct was updated.\n        uint256 rewardPerTokenStored;   /// @dev Last snapshot of rewardPerToken taken.\n    }\n\n    struct VestingSchedule {\n        uint256 start;              /// @dev The block.timestamp at which tokens will start vesting.\n        uint256 cliff;              /// @dev The block.timestamp at which tokens are first claimable.\n        uint256 end;                /// @dev The block.timestamp at which tokens will stop vesting (finished).\n        uint256 totalVesting;       /// @dev The total amount to vest.\n        uint256 totalWithdrawn;     /// @dev The total amount withdrawn so far.\n        uint256 vestingPerSecond;   /// @dev The amount of vestingToken that vests per second.\n        bool revokable;             /// @dev Whether or not this vesting schedule can be revoked.\n    }\n    \n    address public immutable GBL;       /// @dev The ZivoeGlobals contract.\n\n    address public vestingToken;        /// @dev The token vesting, in this case Zivoe ($ZVE).\n\n    address[] public rewardTokens;      /// @dev Array of ERC20 tokens distributed as rewards (if present).\n    \n    uint256 public vestingTokenAllocated;   /// @dev The amount of vestingToken currently allocated.\n\n    uint256 private _totalSupply;       /// @dev Total supply of (non-transferrable) LP tokens for reards contract.\n\n    /// @dev Contains rewards information for each rewardToken.\n    mapping(address => Reward) public rewardData;\n\n    /// @dev Tracks if a wallet has been assigned a schedule.\n    mapping(address => bool) public vestingScheduleSet;\n\n    /// @dev Tracks the vesting schedule of accounts.\n    mapping(address => VestingSchedule) public vestingScheduleOf;\n\n    /// @dev The order is account -> rewardAsset -> amount.\n    mapping(address => mapping(address => uint256)) public accountRewardPerTokenPaid;\n\n    /// @dev The order is account -> rewardAsset -> amount.\n    mapping(address => mapping(address => uint256)) public rewards;\n\n    /// @dev Contains LP token balance of each account (is 1:1 ratio with amount deposited).\n    mapping(address => uint256) private _balances;\n\n    IERC20 public stakingToken;         /// @dev IERC20 wrapper for the stakingToken (deposited to receive LP tokens).\n\n    \n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the ZivoeRewardsVesting contract.\n    /// @param _stakingToken The ERC20 asset deposited to mint LP tokens (and returned when burning LP tokens).\n    /// @param _GBL The ZivoeGlobals contract.\n    constructor(address _stakingToken, address _GBL) {\n        stakingToken = IERC20(_stakingToken);\n        vestingToken = _stakingToken;\n        GBL = _GBL;\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during addReward().\n    /// @param  reward The asset now supported as a reward.\n    event RewardAdded(address indexed reward);\n\n    /// @notice Emitted during depositReward().\n    /// @param  reward The asset that's being deposited.\n    /// @param  amount The amout deposited.\n    /// @param  depositor The _msgSender() who deposited said reward.\n    event RewardDeposited(address indexed reward, uint256 amount, address indexed depositor);\n\n    /// @notice Emitted during _getRewardAt().\n    /// @param  account The account receiving a reward.\n    /// @param  rewardsToken The ERC20 asset distributed as a reward.\n    /// @param  reward The amount of \"rewardsToken\" distributed.\n    event RewardDistributed(address indexed account, address indexed rewardsToken, uint256 reward);\n\n    /// @notice Emitted during stake().\n    /// @param  account The account staking \"stakingToken\".\n    /// @param  amount The amount of  \"stakingToken\" staked.\n    event Staked(address indexed account, uint256 amount);\n\n    /// @notice Emitted during createVestingSchedule().\n    /// @param  account The account that was given a vesting schedule.\n    /// @return start The block.timestamp at which tokens will start vesting.\n    /// @return cliff The block.timestamp at which tokens are first claimable.\n    /// @return end The block.timestamp at which tokens will stop vesting (finished).\n    /// @return totalVesting The total amount to vest.\n    /// @return vestingPerSecond The amount of vestingToken that vests per second.\n    /// @return revokable Whether or not this vesting schedule can be revoked.\n    event VestingScheduleCreated(\n        address indexed account, \n        uint256 start, \n        uint256 cliff, \n        uint256 end, \n        uint256 totalVesting, \n        uint256 vestingPerSecond, \n        bool revokable\n    );\n\n    /// @notice Emitted during revokeVestingSchedule().\n    /// @param  account The account that was revoked a vesting schedule.\n    /// @param  amountRevoked The amount of tokens revoked.\n    /// @return cliff The updated value for cliff.\n    /// @return end The updated value for end.\n    /// @return totalVesting The total amount vested (claimable).\n    /// @return revokable The final revokable status of schedule (always false after revocation).\n    event VestingScheduleRevoked(\n        address indexed account, \n        uint256 amountRevoked, \n        uint256 cliff, \n        uint256 end, \n        uint256 totalVesting, \n        bool revokable\n    );\n\n    /// @notice Emitted during withdraw().\n    /// @param  account The account withdrawing \"stakingToken\".\n    /// @param  amount The amount of \"stakingToken\" withdrawn.\n    event Withdrawn(address indexed account, uint256 amount);\n\n\n\n    // ---------------\n    //    Modifiers\n    // ---------------\n\n    /// @notice This modifier ensures the caller of a function is ZVL or ZivoeITO.\n    modifier onlyZVLOrITO() {\n        require(\n            _msgSender() == IZivoeGlobals_ZivoeRewardsVesting(GBL).ZVL() || \n            _msgSender() == IZivoeGlobals_ZivoeRewardsVesting(GBL).ITO(),\n            \"ZivoeRewardsVesting::onlyZVLOrITO() _msgSender() != ZVL && _msgSender() != ITO\"\n        );\n        _;\n    }\n\n    /// @notice This modifier ensures account rewards information is updated BEFORE mutative actions.\n    /// @param account The account to update personal rewards information of (if not address(0)).\n    modifier updateReward(address account) {\n        for (uint256 i; i < rewardTokens.length; i++) {\n            address token = rewardTokens[i];\n            rewardData[token].rewardPerTokenStored = rewardPerToken(token);\n            rewardData[token].lastUpdateTime = lastTimeRewardApplicable(token);\n            if (account != address(0)) {\n                rewards[account][token] = earned(account, token);\n                accountRewardPerTokenPaid[account][token] = rewardData[token].rewardPerTokenStored;\n            }\n        }\n        _;\n    }\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Returns the amount of tokens owned by \"account\", received when depositing via stake().\n    /// @param account The account to view information of.\n    /// @return amount The amount of tokens owned by \"account\".\n    function balanceOf(address account) external view returns (uint256 amount) { return _balances[account]; }\n\n    /// @notice Returns the total amount of rewards being distributed to everyone for current rewardsDuration.\n    /// @param  _rewardsToken The asset that's being distributed.\n    /// @return amount The amount of rewards being distributed.\n    function getRewardForDuration(address _rewardsToken) external view returns (uint256 amount) {\n        return rewardData[_rewardsToken].rewardRate.mul(rewardData[_rewardsToken].rewardsDuration);\n    }\n\n    /// @notice Returns the amount of tokens in existence; these are minted and burned when depositing or withdrawing.\n    /// @return amount The amount of tokens in existence.\n    function totalSupply() external view returns (uint256 amount) { return _totalSupply; }\n\n    /// @notice Returns the last snapshot of rewardPerTokenStored taken for a reward asset.\n    /// @param account The account to view information of.\n    /// @param rewardAsset The reward token for which we want to return the rewardPerTokenstored.\n    /// @return amount The latest up-to-date value of rewardPerTokenStored.\n    function viewAccountRewardPerTokenPaid(\n        address account, address rewardAsset\n    ) external view returns (uint256 amount) {\n        return accountRewardPerTokenPaid[account][rewardAsset];\n    }\n\n    /// @notice Returns the rewards earned of a specific rewardToken for an address.\n    /// @param account The account to view information of.\n    /// @param rewardAsset The asset earned as a reward.\n    /// @return amount The amount of rewards earned.\n    function viewRewards(address account, address rewardAsset) external view returns (uint256 amount) {\n        return rewards[account][rewardAsset];\n    }\n    \n    /// @notice Provides information for a vesting schedule.\n    /// @param  account The account to view information of.\n    /// @return start The block.timestamp at which tokens will start vesting.\n    /// @return cliff The block.timestamp at which tokens are first claimable.\n    /// @return end The block.timestamp at which tokens will stop vesting (finished).\n    /// @return totalVesting The total amount to vest.\n    /// @return totalWithdrawn The total amount withdrawn so far.\n    /// @return vestingPerSecond The amount of vestingToken that vests per second.\n    /// @return revokable Whether or not this vesting schedule can be revoked.\n    function viewSchedule(address account) external view returns (\n        uint256 start, \n        uint256 cliff, \n        uint256 end, \n        uint256 totalVesting, \n        uint256 totalWithdrawn, \n        uint256 vestingPerSecond, \n        bool revokable\n    ) {\n        start = vestingScheduleOf[account].start;\n        cliff = vestingScheduleOf[account].cliff;\n        end = vestingScheduleOf[account].end;\n        totalVesting = vestingScheduleOf[account].totalVesting;\n        totalWithdrawn = vestingScheduleOf[account].totalWithdrawn;\n        vestingPerSecond = vestingScheduleOf[account].vestingPerSecond;\n        revokable = vestingScheduleOf[account].revokable;\n    }\n\n    /// @notice Returns the amount of $ZVE tokens an account can withdraw.\n    /// @param  account The account to be withdrawn from.\n    /// @return amount Withdrawable amount of $ZVE tokens.\n    function amountWithdrawable(address account) public view returns (uint256 amount) {\n        if (block.timestamp < vestingScheduleOf[account].cliff) { return 0; }\n        if (\n            block.timestamp >= vestingScheduleOf[account].cliff && \n            block.timestamp < vestingScheduleOf[account].end\n        ) {\n            return vestingScheduleOf[account].vestingPerSecond * (\n                block.timestamp - vestingScheduleOf[account].start\n            ) - vestingScheduleOf[account].totalWithdrawn;\n        }\n        else if (block.timestamp >= vestingScheduleOf[account].end) {\n            return vestingScheduleOf[account].totalVesting - vestingScheduleOf[account].totalWithdrawn;\n        }\n        else { return 0; }\n    }\n\n    /// @notice Provides information on the rewards available for claim.\n    /// @param account The account to view information of.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @return amount The amount of rewards earned.\n    function earned(address account, address _rewardsToken) public view returns (uint256 amount) {\n        return _balances[account].mul(\n            rewardPerToken(_rewardsToken).sub(accountRewardPerTokenPaid[account][_rewardsToken])\n        ).div(1e18).add(rewards[account][_rewardsToken]);\n    }\n\n    /// @notice Helper function for assessing distribution timelines.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @return timestamp The most recent time (in UNIX format) at which rewards are available for distribution.\n    function lastTimeRewardApplicable(address _rewardsToken) public view returns (uint256 timestamp) {\n        return Math.min(block.timestamp, rewardData[_rewardsToken].periodFinish);\n    }\n\n    /// @notice Cumulative amount of rewards distributed per LP token.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @return amount The cumulative amount of rewards distributed per LP token.\n    function rewardPerToken(address _rewardsToken) public view returns (uint256 amount) {\n        if (_totalSupply == 0) { return rewardData[_rewardsToken].rewardPerTokenStored; }\n        return rewardData[_rewardsToken].rewardPerTokenStored.add(\n            lastTimeRewardApplicable(_rewardsToken).sub(\n                rewardData[_rewardsToken].lastUpdateTime\n            ).mul(rewardData[_rewardsToken].rewardRate).mul(1e18).div(_totalSupply)\n        );\n    }\n\n    /// @notice Adds a new asset as a reward to this contract.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @param _rewardsDuration How long rewards take to vest, e.g. 30 days (denoted in seconds).\n    function addReward(address _rewardsToken, uint256 _rewardsDuration) external {\n        require(\n            _msgSender() == IZivoeGlobals_ZivoeRewardsVesting(GBL).ZVL(),\n             \"_msgSender() != IZivoeGlobals_ZivoeRewardsVesting(GBL).ZVL()\"\n        );\n        require(\n            _rewardsToken != IZivoeGlobals_ZivoeRewardsVesting(GBL).ZVE(), \n            \"ZivoeRewardsVesting::addReward() _rewardsToken == IZivoeGlobals_ZivoeRewardsVesting(GBL).ZVE()\"\n        );\n        require(_rewardsDuration > 0, \"ZivoeRewardsVesting::addReward() _rewardsDuration == 0\");\n        require(\n            rewardData[_rewardsToken].rewardsDuration == 0, \n            \"ZivoeRewardsVesting::addReward() rewardData[_rewardsToken].rewardsDuration != 0\"\n        );\n        require(rewardTokens.length < 10, \"ZivoeRewardsVesting::addReward() rewardTokens.length >= 10\");\n\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].rewardsDuration = _rewardsDuration;\n        emit RewardAdded(_rewardsToken);\n    }\n\n    /// @notice Deposits a reward to this contract for distribution.\n    /// @param _rewardsToken The asset that's being distributed.\n    /// @param reward The amount of the _rewardsToken to deposit.\n    function depositReward(address _rewardsToken, uint256 reward) external updateReward(address(0)) nonReentrant {\n        IERC20(_rewardsToken).safeTransferFrom(_msgSender(), address(this), reward);\n\n        // Update vesting accounting for reward (if existing rewards being distributed, increase proportionally).\n        if (block.timestamp >= rewardData[_rewardsToken].periodFinish) {\n            rewardData[_rewardsToken].rewardRate = reward.div(rewardData[_rewardsToken].rewardsDuration);\n        } else {\n            uint256 remaining = rewardData[_rewardsToken].periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardData[_rewardsToken].rewardRate);\n            rewardData[_rewardsToken].rewardRate = reward.add(leftover).div(rewardData[_rewardsToken].rewardsDuration);\n        }\n\n        rewardData[_rewardsToken].lastUpdateTime = block.timestamp;\n        rewardData[_rewardsToken].periodFinish = block.timestamp.add(rewardData[_rewardsToken].rewardsDuration);\n        emit RewardDeposited(_rewardsToken, reward, _msgSender());\n    }\n\n    /// @notice Simultaneously calls withdraw() and getRewards() for convenience.\n    function fullWithdraw() external {\n        withdraw();\n        getRewards();\n    }\n\n    /// @notice Sets the vestingSchedule for an account.\n    /// @param  account The account vesting $ZVE.\n    /// @param  daysToCliff The number of days before vesting is claimable (a.k.a. cliff period).\n    /// @param  daysToVest The number of days for the entire vesting period, from beginning to end.\n    /// @param  amountToVest The amount of tokens being vested.\n    /// @param  revokable If the vested amount can be revoked.\n    function createVestingSchedule(\n        address account, \n        uint256 daysToCliff, \n        uint256 daysToVest, \n        uint256 amountToVest, \n        bool revokable\n    ) external onlyZVLOrITO {\n        require(\n            !vestingScheduleSet[account], \n            \"ZivoeRewardsVesting::createVestingSchedule() vestingScheduleSet[account]\"\n        );\n        require(\n            IERC20(vestingToken).balanceOf(address(this)) - vestingTokenAllocated >= amountToVest, \n            \"ZivoeRewardsVesting::createVestingSchedule() amountToVest > vestingToken.balanceOf(address(this)) - vestingTokenAllocated\"\n        );\n        require(daysToVest <= 1800 days, \"ZivoeRewardsVesting::createVestingSchedule() daysToVest > 1800 days\");\n        require(daysToCliff <= daysToVest, \"ZivoeRewardsVesting::createVestingSchedule() daysToCliff > daysToVest\");\n        require(\n            IZivoeITO_ZivoeRewardsVesting(IZivoeGlobals_ZivoeRewardsVesting(GBL).ITO()).seniorCredits(account) == 0 &&\n            IZivoeITO_ZivoeRewardsVesting(IZivoeGlobals_ZivoeRewardsVesting(GBL).ITO()).juniorCredits(account) == 0,\n            \"ZivoeRewardsVesting::createVestingSchedule() seniorCredits(_msgSender) > 0 || juniorCredits(_msgSender) > 0\"\n        );\n\n        vestingScheduleSet[account] = true;\n        vestingTokenAllocated += amountToVest;\n        \n        vestingScheduleOf[account].start = block.timestamp;\n        vestingScheduleOf[account].cliff = block.timestamp + daysToCliff * 1 days;\n        vestingScheduleOf[account].end = block.timestamp + daysToVest * 1 days;\n        vestingScheduleOf[account].totalVesting = amountToVest;\n        vestingScheduleOf[account].vestingPerSecond = amountToVest / (daysToVest * 1 days);\n        vestingScheduleOf[account].revokable = revokable;\n        \n        emit VestingScheduleCreated(\n            account, \n            vestingScheduleOf[account].start, \n            vestingScheduleOf[account].cliff, \n            vestingScheduleOf[account].end, \n            vestingScheduleOf[account].totalVesting, \n            vestingScheduleOf[account].vestingPerSecond, \n            vestingScheduleOf[account].revokable\n        );\n\n        _stake(amountToVest, account);\n    }\n\n    /// @notice Ends vesting schedule for a given account (if revokable).\n    /// @param  account The acount to revoke a vesting schedule for.\n    function revokeVestingSchedule(address account) external updateReward(account) onlyZVLOrITO nonReentrant {\n        require(\n            vestingScheduleSet[account], \n            \"ZivoeRewardsVesting::revokeVestingSchedule() !vestingScheduleSet[account]\"\n        );\n        require(\n            vestingScheduleOf[account].revokable, \n            \"ZivoeRewardsVesting::revokeVestingSchedule() !vestingScheduleOf[account].revokable\"\n        );\n        \n        uint256 amount = amountWithdrawable(account);\n        uint256 vestingAmount = vestingScheduleOf[account].totalVesting;\n\n        vestingTokenAllocated -= amount;\n\n        vestingScheduleOf[account].totalWithdrawn += amount;\n        vestingScheduleOf[account].totalVesting = vestingScheduleOf[account].totalWithdrawn;\n        vestingScheduleOf[account].cliff = block.timestamp - 1;\n        vestingScheduleOf[account].end = block.timestamp;\n\n        vestingTokenAllocated -= (vestingAmount - vestingScheduleOf[account].totalWithdrawn);\n\n        _totalSupply = _totalSupply.sub(vestingAmount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, vestingAmount);\n        _writeCheckpoint(_checkpoints[account], _subtract, amount);\n        _balances[account] = 0;\n        stakingToken.safeTransfer(account, amount);\n\n        vestingScheduleOf[account].revokable = false;\n\n        emit VestingScheduleRevoked(\n            account, \n            vestingAmount - vestingScheduleOf[account].totalWithdrawn, \n            vestingScheduleOf[account].cliff, \n            vestingScheduleOf[account].end, \n            vestingScheduleOf[account].totalVesting, \n            false\n        );\n    }\n\n    /// @notice Stakes the specified amount of stakingToken to this contract.\n    /// @dev Intended to be private, so only callable via createVestingSchedule().\n    /// @param amount The amount of the _rewardsToken to deposit.\n    /// @param account The account to stake for.\n    function _stake(uint256 amount, address account) private nonReentrant updateReward(account) {\n        require(amount > 0, \"ZivoeRewardsVesting::_stake() amount == 0\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n        _writeCheckpoint(_checkpoints[account], _add, amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Staked(account, amount);\n    }\n\n    /// @notice Claim rewards for all possible _rewardTokens.\n    function getRewards() public updateReward(_msgSender()) {\n        for (uint256 i = 0; i < rewardTokens.length; i++) { _getRewardAt(i); }\n    }\n    \n    /// @notice Claim rewards for a specific _rewardToken.\n    /// @param index The index to claim, corresponds to a given index of rewardToken[].\n    function _getRewardAt(uint256 index) internal nonReentrant {\n        address _rewardsToken = rewardTokens[index];\n        uint256 reward = rewards[_msgSender()][_rewardsToken];\n        if (reward > 0) {\n            rewards[_msgSender()][_rewardsToken] = 0;\n            IERC20(_rewardsToken).safeTransfer(_msgSender(), reward);\n            emit RewardDistributed(_msgSender(), _rewardsToken, reward);\n        }\n    }\n\n    /// @notice Withdraws the available amount of stakingToken from this contract.\n    function withdraw() public nonReentrant updateReward(_msgSender()) {\n        uint256 amount = amountWithdrawable(_msgSender());\n        require(amount > 0, \"ZivoeRewardsVesting::withdraw() amountWithdrawable(_msgSender()) == 0\");\n        \n        vestingScheduleOf[_msgSender()].totalWithdrawn += amount;\n        vestingTokenAllocated -= amount;\n\n        _totalSupply = _totalSupply.sub(amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n        _writeCheckpoint(_checkpoints[_msgSender()], _subtract, amount);\n        _balances[_msgSender()] = _balances[_msgSender()].sub(amount);\n        stakingToken.safeTransfer(_msgSender(), amount);\n\n        emit Withdrawn(_msgSender(), amount);\n    }\n\n}"
    }
  ]
}