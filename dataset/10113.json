{
  "Title": "[H-02] Miners Can Re-Roll the VRF Output to Game the Protocol",
  "Content": "_Submitted by leastwood_.\n\n#### Impact\n\nMiners are able to rewrite a chain's history if they dislike the VRF output used by the protocol. Consider the following example:\n\n*   A miner or well-funded user is participating in the PoolTogether protocol.\n*   A VRF request is made and fulfilled in the same block.\n*   The protocol participant does not benefit from the VRF output and therefore wants to increase their chances of winning by including the output in another block, producing an entirely new VRF output. This is done by re-orging the chain, i.e. following a new canonical chain where the VRF output has not been included in a block.\n*   This attack can be continued as long as the attacker controls 51% of the network. The miner itself could control a much smaller proportion of the network and still be able to mine a few blocks in succession, although this is of low probability but entirely possible.\n*   A well-funded user could also pay miners to re-org the chain on their behalf in the form of MEV to achieve the same benefit.\n\nThe PoolTogether team is aware of this issue but is yet to mitigate this attack vector fully.\n\n#### Proof of Concept\n\n- <https://docs.chain.link/docs/vrf-security-considerations/#choose-a-safe-block-confirmation-time-which-will-vary-between-blockchains>\n- <https://github.com/pooltogether/pooltogether-rng-contracts/blob/master/contracts/RNGChainlink.sol>\n- <https://github.com/pooltogether/v4-core/blob/master/contracts/DrawBeacon.sol#L311-L324>\n- <https://github.com/pooltogether/v4-core/blob/master/contracts/DrawBeacon.sol#L218-L232>\n- <https://github.com/pooltogether/blockhash-analysis-simulation>\n\n#### Tools Used\n\n- Manual code review\n- Discussions with Brendan\n\n#### Recommended Mitigation Steps\n\nConsider adding a confirmation time between when the actual VRF request was made and when it was later fulfilled on-chain. This could be as few as 5 blocks, reducing the probability of an effective chain reorganization to extremely close to 0.\n\n**[asselstine (PoolTogether) acknowledged](https://github.com/code-423n4/2021-10-pooltogether-findings/issues/56#issuecomment-942861105):**\n > Yes, this is something I've known for awhile.  The VRF operator whose signature we are requesting *could* collude with a miner to manipulate the blockhash that is being fed to the VRF.\n> \n> We're using the original VRF implementation by Chainlink.  VRF 2.0 is rolling out soon, and we'll explore confirmation times with their team.\n> \n> \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-pooltogether-findings/issues/56#issuecomment-943848009):**\n > The warden has identified a \"supply chain\" attack on the VRF, while the finding may seem innocuous, it does pose the fundamental question as to whether Chainlink's VRF is a source of truly verifiable randomness that won't be gamed for personal gains.\n> \n> The sponsor does agree on the attack vector, the miner and the chainlink provider could collude with the purpose of gaming the system.\n> \n> I find it hard to leave this as a High Severity finding, because it implies that Chainlink's VRF Service is flawed in it's design\n> \n> However, if trace of proof of collusion between miners and chainlink operators where to be found, this would question the impartiality of their service.\n> \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-pooltogether-findings/issues/56#issuecomment-944362046):**\n > After a day of thinking I've decided to leave the finding as high risk.\n> Not as a statement to Chainlink's security model, as that's outside of scope, but because the finding is objectively true.\n> \n> A malicious operator can, in conjunction with a miner, re-roll the VRF to pursue their own gains.\n> \n> I'm not sure what could be done to mitigate this at the chain level, it seems to me that at this time, there may be no source of true randomness that can be achieved on-chain without assuming a degree of counter-party risk\n\n\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-10-pooltogether",
  "Code": [
    {
      "filename": "contracts/DrawBeacon.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"@pooltogether/pooltogether-rng-contracts/contracts/RNGInterface.sol\";\nimport \"@pooltogether/owner-manager-contracts/contracts/Ownable.sol\";\n\nimport \"./interfaces/IDrawBeacon.sol\";\nimport \"./interfaces/IDrawBuffer.sol\";\n\n\n/**\n  * @title  PoolTogether V4 DrawBeacon\n  * @author PoolTogether Inc Team\n  * @notice Manages RNG (random number generator) requests and pushing Draws onto DrawBuffer.\n            The DrawBeacon has 3 major actions for requesting a random number: start, cancel and complete.\n            To create a new Draw, the user requests a new random number from the RNG service.\n            When the random number is available, the user can create the draw using the create() method\n            which will push the draw onto the DrawBuffer.\n            If the RNG service fails to deliver a rng, when the request timeout elapses, the user can cancel the request.\n*/\ncontract DrawBeacon is IDrawBeacon, Ownable {\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ============ Variables ============ */\n\n    /// @notice RNG contract interface\n    RNGInterface internal rng;\n\n    /// @notice Current RNG Request\n    RngRequest internal rngRequest;\n\n    /// @notice DrawBuffer address\n    IDrawBuffer internal drawBuffer;\n\n    /**\n     * @notice RNG Request Timeout.  In fact, this is really a \"complete draw\" timeout.\n     * @dev If the rng completes the award can still be cancelled.\n     */\n    uint32 internal rngTimeout;\n\n    /// @notice Seconds between beacon period request\n    uint32 internal beaconPeriodSeconds;\n\n    /// @notice Epoch timestamp when beacon period can start\n    uint64 internal beaconPeriodStartedAt;\n\n    /**\n     * @notice Next Draw ID to use when pushing a Draw onto DrawBuffer\n     * @dev Starts at 1. This way we know that no Draw has been recorded at 0.\n     */\n    uint32 internal nextDrawId;\n\n    /* ============ Structs ============ */\n\n    /**\n     * @notice RNG Request\n     * @param id          RNG request ID\n     * @param lockBlock   Block number that the RNG request is locked\n     * @param requestedAt Time when RNG is requested\n     */\n    struct RngRequest {\n        uint32 id;\n        uint32 lockBlock;\n        uint64 requestedAt;\n    }\n\n    /* ============ Events ============ */\n\n    /**\n     * @notice Emit when the DrawBeacon is deployed.\n     * @param nextDrawId Draw ID at which the DrawBeacon should start. Can't be inferior to 1.\n     * @param beaconPeriodStartedAt Timestamp when beacon period starts.\n     */\n    event Deployed(\n        uint32 nextDrawId,\n        uint64 beaconPeriodStartedAt\n    );\n\n    /* ============ Modifiers ============ */\n\n    modifier requireDrawNotStarted() {\n        _requireDrawNotStarted();\n        _;\n    }\n\n    modifier requireCanStartDraw() {\n        require(_isBeaconPeriodOver(), \"DrawBeacon/beacon-period-not-over\");\n        require(!isRngRequested(), \"DrawBeacon/rng-already-requested\");\n        _;\n    }\n\n    modifier requireCanCompleteRngRequest() {\n        require(isRngRequested(), \"DrawBeacon/rng-not-requested\");\n        require(isRngCompleted(), \"DrawBeacon/rng-not-complete\");\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Deploy the DrawBeacon smart contract.\n     * @param _owner Address of the DrawBeacon owner\n     * @param _drawBuffer The address of the draw buffer to push draws to\n     * @param _rng The RNG service to use\n     * @param _nextDrawId Draw ID at which the DrawBeacon should start. Can't be inferior to 1.\n     * @param _beaconPeriodStart The starting timestamp of the beacon period.\n     * @param _beaconPeriodSeconds The duration of the beacon period in seconds\n     */\n    constructor(\n        address _owner,\n        IDrawBuffer _drawBuffer,\n        RNGInterface _rng,\n        uint32 _nextDrawId,\n        uint64 _beaconPeriodStart,\n        uint32 _beaconPeriodSeconds,\n        uint32 _rngTimeout\n    ) Ownable(_owner) {\n        require(_beaconPeriodStart > 0, \"DrawBeacon/beacon-period-greater-than-zero\");\n        require(address(_rng) != address(0), \"DrawBeacon/rng-not-zero\");\n        require(_nextDrawId >= 1, \"DrawBeacon/next-draw-id-gte-one\");\n\n        beaconPeriodStartedAt = _beaconPeriodStart;\n        nextDrawId = _nextDrawId;\n\n        _setBeaconPeriodSeconds(_beaconPeriodSeconds);\n        _setDrawBuffer(_drawBuffer);\n        _setRngService(_rng);\n        _setRngTimeout(_rngTimeout);\n\n        emit Deployed(_nextDrawId, _beaconPeriodStart);\n        emit BeaconPeriodStarted(_beaconPeriodStart);\n    }\n\n    /* ============ Public Functions ============ */\n\n    /**\n     * @notice Returns whether the random number request has completed.\n     * @return True if a random number request has completed, false otherwise.\n     */\n    function isRngCompleted() public view override returns (bool) {\n        return rng.isRequestComplete(rngRequest.id);\n    }\n\n    /**\n     * @notice Returns whether a random number has been requested\n     * @return True if a random number has been requested, false otherwise.\n     */\n    function isRngRequested() public view override returns (bool) {\n        return rngRequest.id != 0;\n    }\n\n    /**\n     * @notice Returns whether the random number request has timed out.\n     * @return True if a random number request has timed out, false otherwise.\n     */\n    function isRngTimedOut() public view override returns (bool) {\n        if (rngRequest.requestedAt == 0) {\n            return false;\n        } else {\n            return rngTimeout + rngRequest.requestedAt < _currentTime();\n        }\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc IDrawBeacon\n    function canStartDraw() external view override returns (bool) {\n        return _isBeaconPeriodOver() && !isRngRequested();\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function canCompleteDraw() external view override returns (bool) {\n        return isRngRequested() && isRngCompleted();\n    }\n\n    /// @notice Calculates the next beacon start time, assuming all beacon periods have occurred between the last and now.\n    /// @return The next beacon period start time\n    function calculateNextBeaconPeriodStartTimeFromCurrentTime() external view returns (uint64) {\n        return\n            _calculateNextBeaconPeriodStartTime(\n                beaconPeriodStartedAt,\n                beaconPeriodSeconds,\n                _currentTime()\n            );\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function calculateNextBeaconPeriodStartTime(uint64 _time)\n        external\n        view\n        override\n        returns (uint64)\n    {\n        return\n            _calculateNextBeaconPeriodStartTime(\n                beaconPeriodStartedAt,\n                beaconPeriodSeconds,\n                _time\n            );\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function cancelDraw() external override {\n        require(isRngTimedOut(), \"DrawBeacon/rng-not-timedout\");\n        uint32 requestId = rngRequest.id;\n        uint32 lockBlock = rngRequest.lockBlock;\n        delete rngRequest;\n        emit DrawCancelled(requestId, lockBlock);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function completeDraw() external override requireCanCompleteRngRequest {\n        uint256 randomNumber = rng.randomNumber(rngRequest.id);\n        uint32 _nextDrawId = nextDrawId;\n        uint64 _beaconPeriodStartedAt = beaconPeriodStartedAt;\n        uint32 _beaconPeriodSeconds = beaconPeriodSeconds;\n        uint64 _time = _currentTime();\n\n        // create Draw struct\n        IDrawBeacon.Draw memory _draw = IDrawBeacon.Draw({\n            winningRandomNumber: randomNumber,\n            drawId: _nextDrawId,\n            timestamp: rngRequest.requestedAt, // must use the startAward() timestamp to prevent front-running\n            beaconPeriodStartedAt: _beaconPeriodStartedAt,\n            beaconPeriodSeconds: _beaconPeriodSeconds\n        });\n\n        drawBuffer.pushDraw(_draw);\n\n        // to avoid clock drift, we should calculate the start time based on the previous period start time.\n        uint64 nextBeaconPeriodStartedAt = _calculateNextBeaconPeriodStartTime(\n            _beaconPeriodStartedAt,\n            _beaconPeriodSeconds,\n            _time\n        );\n        beaconPeriodStartedAt = nextBeaconPeriodStartedAt;\n        nextDrawId = _nextDrawId + 1;\n\n        // Reset the rngRequest state so Beacon period can start again.\n        delete rngRequest;\n\n        emit DrawCompleted(randomNumber);\n        emit BeaconPeriodStarted(nextBeaconPeriodStartedAt);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function beaconPeriodRemainingSeconds() external view override returns (uint64) {\n        return _beaconPeriodRemainingSeconds();\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function beaconPeriodEndAt() external view override returns (uint64) {\n        return _beaconPeriodEndAt();\n    }\n\n    function getBeaconPeriodSeconds() external view returns (uint32) {\n        return beaconPeriodSeconds;\n    }\n\n    function getBeaconPeriodStartedAt() external view returns (uint64) {\n        return beaconPeriodStartedAt;\n    }\n\n    function getDrawBuffer() external view returns (IDrawBuffer) {\n        return drawBuffer;\n    }\n\n    function getNextDrawId() external view returns (uint32) {\n        return nextDrawId;\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function getLastRngLockBlock() external view override returns (uint32) {\n        return rngRequest.lockBlock;\n    }\n\n    function getLastRngRequestId() external view override returns (uint32) {\n        return rngRequest.id;\n    }\n\n    function getRngService() external view returns (RNGInterface) {\n        return rng;\n    }\n\n    function getRngTimeout() external view returns (uint32) {\n        return rngTimeout;\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function isBeaconPeriodOver() external view override returns (bool) {\n        return _isBeaconPeriodOver();\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function setDrawBuffer(IDrawBuffer newDrawBuffer)\n        external\n        override\n        onlyOwner\n        returns (IDrawBuffer)\n    {\n        return _setDrawBuffer(newDrawBuffer);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function startDraw() external override requireCanStartDraw {\n        (address feeToken, uint256 requestFee) = rng.getRequestFee();\n\n        if (feeToken != address(0) && requestFee > 0) {\n            IERC20(feeToken).safeIncreaseAllowance(address(rng), requestFee);\n        }\n\n        (uint32 requestId, uint32 lockBlock) = rng.requestRandomNumber();\n        rngRequest.id = requestId;\n        rngRequest.lockBlock = lockBlock;\n        rngRequest.requestedAt = _currentTime();\n\n        emit DrawStarted(requestId, lockBlock);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function setBeaconPeriodSeconds(uint32 _beaconPeriodSeconds)\n        external\n        override\n        onlyOwner\n        requireDrawNotStarted\n    {\n        _setBeaconPeriodSeconds(_beaconPeriodSeconds);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function setRngTimeout(uint32 _rngTimeout) external override onlyOwner requireDrawNotStarted {\n        _setRngTimeout(_rngTimeout);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function setRngService(RNGInterface _rngService)\n        external\n        override\n        onlyOwner\n        requireDrawNotStarted\n    {\n        _setRngService(_rngService);\n    }\n\n    /**\n     * @notice Sets the RNG service that the Prize Strategy is connected to\n     * @param _rngService The address of the new RNG service interface\n     */\n    function _setRngService(RNGInterface _rngService) internal\n    {\n        rng = _rngService;\n        emit RngServiceUpdated(_rngService);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Calculates when the next beacon period will start\n     * @param _beaconPeriodStartedAt The timestamp at which the beacon period started\n     * @param _beaconPeriodSeconds The duration of the beacon period in seconds\n     * @param _time The timestamp to use as the current time\n     * @return The timestamp at which the next beacon period would start\n     */\n    function _calculateNextBeaconPeriodStartTime(\n        uint64 _beaconPeriodStartedAt,\n        uint32 _beaconPeriodSeconds,\n        uint64 _time\n    ) internal pure returns (uint64) {\n        uint64 elapsedPeriods = (_time - _beaconPeriodStartedAt) / _beaconPeriodSeconds;\n        return _beaconPeriodStartedAt + (elapsedPeriods * _beaconPeriodSeconds);\n    }\n\n    /**\n     * @notice returns the current time.  Used for testing.\n     * @return The current time (block.timestamp)\n     */\n    function _currentTime() internal view virtual returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    /**\n     * @notice Returns the timestamp at which the beacon period ends\n     * @return The timestamp at which the beacon period ends\n     */\n    function _beaconPeriodEndAt() internal view returns (uint64) {\n        return beaconPeriodStartedAt + beaconPeriodSeconds;\n    }\n\n    /**\n     * @notice Returns the number of seconds remaining until the prize can be awarded.\n     * @return The number of seconds remaining until the prize can be awarded.\n     */\n    function _beaconPeriodRemainingSeconds() internal view returns (uint64) {\n        uint64 endAt = _beaconPeriodEndAt();\n        uint64 time = _currentTime();\n\n        if (endAt <= time) {\n            return 0;\n        }\n\n        return endAt - time;\n    }\n\n    /**\n     * @notice Returns whether the beacon period is over.\n     * @return True if the beacon period is over, false otherwise\n     */\n    function _isBeaconPeriodOver() internal view returns (bool) {\n        return _beaconPeriodEndAt() <= _currentTime();\n    }\n\n    /**\n     * @notice Check to see draw is in progress.\n     */\n    function _requireDrawNotStarted() internal view {\n        uint256 currentBlock = block.number;\n\n        require(\n            rngRequest.lockBlock == 0 || currentBlock < rngRequest.lockBlock,\n            \"DrawBeacon/rng-in-flight\"\n        );\n    }\n\n    /**\n     * @notice Set global DrawBuffer variable.\n     * @dev    All subsequent Draw requests/completions will be pushed to the new DrawBuffer.\n     * @param _newDrawBuffer  DrawBuffer address\n     * @return DrawBuffer\n     */\n    function _setDrawBuffer(IDrawBuffer _newDrawBuffer) internal returns (IDrawBuffer) {\n        IDrawBuffer _previousDrawBuffer = drawBuffer;\n        require(address(_newDrawBuffer) != address(0), \"DrawBeacon/draw-history-not-zero-address\");\n\n        require(\n            address(_newDrawBuffer) != address(_previousDrawBuffer),\n            \"DrawBeacon/existing-draw-history-address\"\n        );\n\n        drawBuffer = _newDrawBuffer;\n\n        emit DrawBufferUpdated(_newDrawBuffer);\n\n        return _newDrawBuffer;\n    }\n\n    /**\n     * @notice Sets the beacon period in seconds.\n     * @param _beaconPeriodSeconds The new beacon period in seconds.  Must be greater than zero.\n     */\n    function _setBeaconPeriodSeconds(uint32 _beaconPeriodSeconds) internal {\n        require(_beaconPeriodSeconds > 0, \"DrawBeacon/beacon-period-greater-than-zero\");\n        beaconPeriodSeconds = _beaconPeriodSeconds;\n\n        emit BeaconPeriodSecondsUpdated(_beaconPeriodSeconds);\n    }\n\n    /**\n     * @notice Sets the RNG request timeout in seconds.  This is the time that must elapsed before the RNG request can be cancelled and the pool unlocked.\n     * @param _rngTimeout The RNG request timeout in seconds.\n     */\n    function _setRngTimeout(uint32 _rngTimeout) internal {\n        require(_rngTimeout > 60, \"DrawBeacon/rng-timeout-gt-60-secs\");\n        rngTimeout = _rngTimeout;\n\n        emit RngTimeoutSet(_rngTimeout);\n    }\n}"
    },
    {
      "filename": "contracts/DrawBeacon.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"@pooltogether/pooltogether-rng-contracts/contracts/RNGInterface.sol\";\nimport \"@pooltogether/owner-manager-contracts/contracts/Ownable.sol\";\n\nimport \"./interfaces/IDrawBeacon.sol\";\nimport \"./interfaces/IDrawBuffer.sol\";\n\n\n/**\n  * @title  PoolTogether V4 DrawBeacon\n  * @author PoolTogether Inc Team\n  * @notice Manages RNG (random number generator) requests and pushing Draws onto DrawBuffer.\n            The DrawBeacon has 3 major actions for requesting a random number: start, cancel and complete.\n            To create a new Draw, the user requests a new random number from the RNG service.\n            When the random number is available, the user can create the draw using the create() method\n            which will push the draw onto the DrawBuffer.\n            If the RNG service fails to deliver a rng, when the request timeout elapses, the user can cancel the request.\n*/\ncontract DrawBeacon is IDrawBeacon, Ownable {\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n\n    /* ============ Variables ============ */\n\n    /// @notice RNG contract interface\n    RNGInterface internal rng;\n\n    /// @notice Current RNG Request\n    RngRequest internal rngRequest;\n\n    /// @notice DrawBuffer address\n    IDrawBuffer internal drawBuffer;\n\n    /**\n     * @notice RNG Request Timeout.  In fact, this is really a \"complete draw\" timeout.\n     * @dev If the rng completes the award can still be cancelled.\n     */\n    uint32 internal rngTimeout;\n\n    /// @notice Seconds between beacon period request\n    uint32 internal beaconPeriodSeconds;\n\n    /// @notice Epoch timestamp when beacon period can start\n    uint64 internal beaconPeriodStartedAt;\n\n    /**\n     * @notice Next Draw ID to use when pushing a Draw onto DrawBuffer\n     * @dev Starts at 1. This way we know that no Draw has been recorded at 0.\n     */\n    uint32 internal nextDrawId;\n\n    /* ============ Structs ============ */\n\n    /**\n     * @notice RNG Request\n     * @param id          RNG request ID\n     * @param lockBlock   Block number that the RNG request is locked\n     * @param requestedAt Time when RNG is requested\n     */\n    struct RngRequest {\n        uint32 id;\n        uint32 lockBlock;\n        uint64 requestedAt;\n    }\n\n    /* ============ Events ============ */\n\n    /**\n     * @notice Emit when the DrawBeacon is deployed.\n     * @param nextDrawId Draw ID at which the DrawBeacon should start. Can't be inferior to 1.\n     * @param beaconPeriodStartedAt Timestamp when beacon period starts.\n     */\n    event Deployed(\n        uint32 nextDrawId,\n        uint64 beaconPeriodStartedAt\n    );\n\n    /* ============ Modifiers ============ */\n\n    modifier requireDrawNotStarted() {\n        _requireDrawNotStarted();\n        _;\n    }\n\n    modifier requireCanStartDraw() {\n        require(_isBeaconPeriodOver(), \"DrawBeacon/beacon-period-not-over\");\n        require(!isRngRequested(), \"DrawBeacon/rng-already-requested\");\n        _;\n    }\n\n    modifier requireCanCompleteRngRequest() {\n        require(isRngRequested(), \"DrawBeacon/rng-not-requested\");\n        require(isRngCompleted(), \"DrawBeacon/rng-not-complete\");\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Deploy the DrawBeacon smart contract.\n     * @param _owner Address of the DrawBeacon owner\n     * @param _drawBuffer The address of the draw buffer to push draws to\n     * @param _rng The RNG service to use\n     * @param _nextDrawId Draw ID at which the DrawBeacon should start. Can't be inferior to 1.\n     * @param _beaconPeriodStart The starting timestamp of the beacon period.\n     * @param _beaconPeriodSeconds The duration of the beacon period in seconds\n     */\n    constructor(\n        address _owner,\n        IDrawBuffer _drawBuffer,\n        RNGInterface _rng,\n        uint32 _nextDrawId,\n        uint64 _beaconPeriodStart,\n        uint32 _beaconPeriodSeconds,\n        uint32 _rngTimeout\n    ) Ownable(_owner) {\n        require(_beaconPeriodStart > 0, \"DrawBeacon/beacon-period-greater-than-zero\");\n        require(address(_rng) != address(0), \"DrawBeacon/rng-not-zero\");\n        require(_nextDrawId >= 1, \"DrawBeacon/next-draw-id-gte-one\");\n\n        beaconPeriodStartedAt = _beaconPeriodStart;\n        nextDrawId = _nextDrawId;\n\n        _setBeaconPeriodSeconds(_beaconPeriodSeconds);\n        _setDrawBuffer(_drawBuffer);\n        _setRngService(_rng);\n        _setRngTimeout(_rngTimeout);\n\n        emit Deployed(_nextDrawId, _beaconPeriodStart);\n        emit BeaconPeriodStarted(_beaconPeriodStart);\n    }\n\n    /* ============ Public Functions ============ */\n\n    /**\n     * @notice Returns whether the random number request has completed.\n     * @return True if a random number request has completed, false otherwise.\n     */\n    function isRngCompleted() public view override returns (bool) {\n        return rng.isRequestComplete(rngRequest.id);\n    }\n\n    /**\n     * @notice Returns whether a random number has been requested\n     * @return True if a random number has been requested, false otherwise.\n     */\n    function isRngRequested() public view override returns (bool) {\n        return rngRequest.id != 0;\n    }\n\n    /**\n     * @notice Returns whether the random number request has timed out.\n     * @return True if a random number request has timed out, false otherwise.\n     */\n    function isRngTimedOut() public view override returns (bool) {\n        if (rngRequest.requestedAt == 0) {\n            return false;\n        } else {\n            return rngTimeout + rngRequest.requestedAt < _currentTime();\n        }\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc IDrawBeacon\n    function canStartDraw() external view override returns (bool) {\n        return _isBeaconPeriodOver() && !isRngRequested();\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function canCompleteDraw() external view override returns (bool) {\n        return isRngRequested() && isRngCompleted();\n    }\n\n    /// @notice Calculates the next beacon start time, assuming all beacon periods have occurred between the last and now.\n    /// @return The next beacon period start time\n    function calculateNextBeaconPeriodStartTimeFromCurrentTime() external view returns (uint64) {\n        return\n            _calculateNextBeaconPeriodStartTime(\n                beaconPeriodStartedAt,\n                beaconPeriodSeconds,\n                _currentTime()\n            );\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function calculateNextBeaconPeriodStartTime(uint64 _time)\n        external\n        view\n        override\n        returns (uint64)\n    {\n        return\n            _calculateNextBeaconPeriodStartTime(\n                beaconPeriodStartedAt,\n                beaconPeriodSeconds,\n                _time\n            );\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function cancelDraw() external override {\n        require(isRngTimedOut(), \"DrawBeacon/rng-not-timedout\");\n        uint32 requestId = rngRequest.id;\n        uint32 lockBlock = rngRequest.lockBlock;\n        delete rngRequest;\n        emit DrawCancelled(requestId, lockBlock);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function completeDraw() external override requireCanCompleteRngRequest {\n        uint256 randomNumber = rng.randomNumber(rngRequest.id);\n        uint32 _nextDrawId = nextDrawId;\n        uint64 _beaconPeriodStartedAt = beaconPeriodStartedAt;\n        uint32 _beaconPeriodSeconds = beaconPeriodSeconds;\n        uint64 _time = _currentTime();\n\n        // create Draw struct\n        IDrawBeacon.Draw memory _draw = IDrawBeacon.Draw({\n            winningRandomNumber: randomNumber,\n            drawId: _nextDrawId,\n            timestamp: rngRequest.requestedAt, // must use the startAward() timestamp to prevent front-running\n            beaconPeriodStartedAt: _beaconPeriodStartedAt,\n            beaconPeriodSeconds: _beaconPeriodSeconds\n        });\n\n        drawBuffer.pushDraw(_draw);\n\n        // to avoid clock drift, we should calculate the start time based on the previous period start time.\n        uint64 nextBeaconPeriodStartedAt = _calculateNextBeaconPeriodStartTime(\n            _beaconPeriodStartedAt,\n            _beaconPeriodSeconds,\n            _time\n        );\n        beaconPeriodStartedAt = nextBeaconPeriodStartedAt;\n        nextDrawId = _nextDrawId + 1;\n\n        // Reset the rngRequest state so Beacon period can start again.\n        delete rngRequest;\n\n        emit DrawCompleted(randomNumber);\n        emit BeaconPeriodStarted(nextBeaconPeriodStartedAt);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function beaconPeriodRemainingSeconds() external view override returns (uint64) {\n        return _beaconPeriodRemainingSeconds();\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function beaconPeriodEndAt() external view override returns (uint64) {\n        return _beaconPeriodEndAt();\n    }\n\n    function getBeaconPeriodSeconds() external view returns (uint32) {\n        return beaconPeriodSeconds;\n    }\n\n    function getBeaconPeriodStartedAt() external view returns (uint64) {\n        return beaconPeriodStartedAt;\n    }\n\n    function getDrawBuffer() external view returns (IDrawBuffer) {\n        return drawBuffer;\n    }\n\n    function getNextDrawId() external view returns (uint32) {\n        return nextDrawId;\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function getLastRngLockBlock() external view override returns (uint32) {\n        return rngRequest.lockBlock;\n    }\n\n    function getLastRngRequestId() external view override returns (uint32) {\n        return rngRequest.id;\n    }\n\n    function getRngService() external view returns (RNGInterface) {\n        return rng;\n    }\n\n    function getRngTimeout() external view returns (uint32) {\n        return rngTimeout;\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function isBeaconPeriodOver() external view override returns (bool) {\n        return _isBeaconPeriodOver();\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function setDrawBuffer(IDrawBuffer newDrawBuffer)\n        external\n        override\n        onlyOwner\n        returns (IDrawBuffer)\n    {\n        return _setDrawBuffer(newDrawBuffer);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function startDraw() external override requireCanStartDraw {\n        (address feeToken, uint256 requestFee) = rng.getRequestFee();\n\n        if (feeToken != address(0) && requestFee > 0) {\n            IERC20(feeToken).safeIncreaseAllowance(address(rng), requestFee);\n        }\n\n        (uint32 requestId, uint32 lockBlock) = rng.requestRandomNumber();\n        rngRequest.id = requestId;\n        rngRequest.lockBlock = lockBlock;\n        rngRequest.requestedAt = _currentTime();\n\n        emit DrawStarted(requestId, lockBlock);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function setBeaconPeriodSeconds(uint32 _beaconPeriodSeconds)\n        external\n        override\n        onlyOwner\n        requireDrawNotStarted\n    {\n        _setBeaconPeriodSeconds(_beaconPeriodSeconds);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function setRngTimeout(uint32 _rngTimeout) external override onlyOwner requireDrawNotStarted {\n        _setRngTimeout(_rngTimeout);\n    }\n\n    /// @inheritdoc IDrawBeacon\n    function setRngService(RNGInterface _rngService)\n        external\n        override\n        onlyOwner\n        requireDrawNotStarted\n    {\n        _setRngService(_rngService);\n    }\n\n    /**\n     * @notice Sets the RNG service that the Prize Strategy is connected to\n     * @param _rngService The address of the new RNG service interface\n     */\n    function _setRngService(RNGInterface _rngService) internal\n    {\n        rng = _rngService;\n        emit RngServiceUpdated(_rngService);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Calculates when the next beacon period will start\n     * @param _beaconPeriodStartedAt The timestamp at which the beacon period started\n     * @param _beaconPeriodSeconds The duration of the beacon period in seconds\n     * @param _time The timestamp to use as the current time\n     * @return The timestamp at which the next beacon period would start\n     */\n    function _calculateNextBeaconPeriodStartTime(\n        uint64 _beaconPeriodStartedAt,\n        uint32 _beaconPeriodSeconds,\n        uint64 _time\n    ) internal pure returns (uint64) {\n        uint64 elapsedPeriods = (_time - _beaconPeriodStartedAt) / _beaconPeriodSeconds;\n        return _beaconPeriodStartedAt + (elapsedPeriods * _beaconPeriodSeconds);\n    }\n\n    /**\n     * @notice returns the current time.  Used for testing.\n     * @return The current time (block.timestamp)\n     */\n    function _currentTime() internal view virtual returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    /**\n     * @notice Returns the timestamp at which the beacon period ends\n     * @return The timestamp at which the beacon period ends\n     */\n    function _beaconPeriodEndAt() internal view returns (uint64) {\n        return beaconPeriodStartedAt + beaconPeriodSeconds;\n    }\n\n    /**\n     * @notice Returns the number of seconds remaining until the prize can be awarded.\n     * @return The number of seconds remaining until the prize can be awarded.\n     */\n    function _beaconPeriodRemainingSeconds() internal view returns (uint64) {\n        uint64 endAt = _beaconPeriodEndAt();\n        uint64 time = _currentTime();\n\n        if (endAt <= time) {\n            return 0;\n        }\n\n        return endAt - time;\n    }\n\n    /**\n     * @notice Returns whether the beacon period is over.\n     * @return True if the beacon period is over, false otherwise\n     */\n    function _isBeaconPeriodOver() internal view returns (bool) {\n        return _beaconPeriodEndAt() <= _currentTime();\n    }\n\n    /**\n     * @notice Check to see draw is in progress.\n     */\n    function _requireDrawNotStarted() internal view {\n        uint256 currentBlock = block.number;\n\n        require(\n            rngRequest.lockBlock == 0 || currentBlock < rngRequest.lockBlock,\n            \"DrawBeacon/rng-in-flight\"\n        );\n    }\n\n    /**\n     * @notice Set global DrawBuffer variable.\n     * @dev    All subsequent Draw requests/completions will be pushed to the new DrawBuffer.\n     * @param _newDrawBuffer  DrawBuffer address\n     * @return DrawBuffer\n     */\n    function _setDrawBuffer(IDrawBuffer _newDrawBuffer) internal returns (IDrawBuffer) {\n        IDrawBuffer _previousDrawBuffer = drawBuffer;\n        require(address(_newDrawBuffer) != address(0), \"DrawBeacon/draw-history-not-zero-address\");\n\n        require(\n            address(_newDrawBuffer) != address(_previousDrawBuffer),\n            \"DrawBeacon/existing-draw-history-address\"\n        );\n\n        drawBuffer = _newDrawBuffer;\n\n        emit DrawBufferUpdated(_newDrawBuffer);\n\n        return _newDrawBuffer;\n    }\n\n    /**\n     * @notice Sets the beacon period in seconds.\n     * @param _beaconPeriodSeconds The new beacon period in seconds.  Must be greater than zero.\n     */\n    function _setBeaconPeriodSeconds(uint32 _beaconPeriodSeconds) internal {\n        require(_beaconPeriodSeconds > 0, \"DrawBeacon/beacon-period-greater-than-zero\");\n        beaconPeriodSeconds = _beaconPeriodSeconds;\n\n        emit BeaconPeriodSecondsUpdated(_beaconPeriodSeconds);\n    }\n\n    /**\n     * @notice Sets the RNG request timeout in seconds.  This is the time that must elapsed before the RNG request can be cancelled and the pool unlocked.\n     * @param _rngTimeout The RNG request timeout in seconds.\n     */\n    function _setRngTimeout(uint32 _rngTimeout) internal {\n        require(_rngTimeout > 60, \"DrawBeacon/rng-timeout-gt-60-secs\");\n        rngTimeout = _rngTimeout;\n\n        emit RngTimeoutSet(_rngTimeout);\n    }\n}"
    }
  ]
}