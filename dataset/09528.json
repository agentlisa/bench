{
  "Title": "[H-06] Setting new controller can break `YVaultLPFarming`",
  "Content": "_Submitted by cmichel_\n\n[yVaultLPFarming.sol#L170](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/yVaultLPFarming.sol#L170)<br>\n[yVault.sol#L108](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/yVault/yVault.sol#L108)<br>\n\nThe accruals in `yVaultLPFarming` will fail if [`currentBalance < previousBalance`](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/farming/yVaultLPFarming.sol#L170) in `_computeUpdate`.\n\n```solidity\ncurrentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));\nuint256 newRewards = currentBalance - previousBalance;\n```\n\nNo funds can be withdrawn anymore as the `withdraw` functions first trigger an `_update`.\n\nThe `currentBalance < previousBalance` case can, for example, be triggerd by decreasing the `vault.balanceOfJPEG()` due to calling `yVault.setController`:\n\n```solidity\nfunction setController(address _controller) public onlyOwner {\n    // @audit can reduce balanceofJpeg which breaks other masterchef contract\n    require(_controller != address(0), \"INVALID_CONTROLLER\");\n    controller = IController(_controller);\n}\n\nfunction balanceOfJPEG() external view returns (uint256) {\n    // @audit new controller could return a smaller balance\n    return controller.balanceOfJPEG(address(token));\n}\n```\n\n### Recommended Mitigation Steps\n\nSetting a new controller on a vault must be done very carefully and requires a migration.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/80#issuecomment-1109891540):**\n > This is not a duplicate of H-05. Though both of them deal with issues related to balanceOfJPEG, they describe different causes.\n\n**[spaghettieth (JPEG'd) acknowledged](https://github.com/code-423n4/2022-04-jpegd-findings/issues/80)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-04-jpegd",
  "Code": [
    {
      "filename": "contracts/farming/yVaultLPFarming.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/IYVault.sol\";\n\n/// @title JPEG'd yVault token farm\n/// @notice Users can stake their JPEG'd vault tokens and earn JPEG rewards\n/// @dev The rewards are taken from the PUSD Convex pool and distributed to stakers based on their share of the total staked tokens.\ncontract YVaultLPFarming is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IYVault;\n    using Address for address;\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Claim(address indexed user, uint256 rewards);\n\n    IYVault public immutable vault;\n    IERC20 public immutable jpeg;\n\n    uint256 public totalStaked;\n\n    uint256 internal lastRewardBlock;\n    uint256 internal previousBalance;\n    uint256 internal accRewardPerShare;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => uint256) private userLastAccRewardPerShare;\n    mapping(address => uint256) private userPendingRewards;\n\n    /// @notice Contracts that are allowed to interact with the LP farm\n    /// @dev See the {noContract} modifier for more info\n    mapping(address => bool) public whitelistedContracts;\n\n    ///@param _vault The yVault address\n    ///@param _jpeg The JPEG token address\n    constructor(address _vault, address _jpeg) {\n        require(_vault != address(0), \"INVALID_VAULT\");\n        require(_jpeg != address(0), \"INVALID_JPEG\");\n\n        vault = IYVault(_vault);\n        jpeg = IERC20(_jpeg);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the farm.\n    /// Prevents non-whitelisted 3rd party contracts (e.g. autocompounders) from diluting farmers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts aren't allowed to farm\"\n        );\n        _;\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Frontend function used to calculate the amount of rewards `_user` can claim\n    /// @param _user The address of the user\n    /// @return The amount of rewards claimable by user `_user`\n    function pendingReward(address _user)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 rewardShare = accRewardPerShare;\n        uint256 staked = totalStaked;\n        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,\n        //we need to calculate the up to date amount to return an accurate reward value\n        if (block.number > lastRewardBlock && staked > 0) {\n            (rewardShare, ) = _computeUpdate();\n        }\n        return\n            //rewards that the user had already accumulated but not claimed\n            userPendingRewards[_user] +\n            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share\n            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable\n            //by the user\n            (balanceOf[_user] * (rewardShare - userLastAccRewardPerShare[_user])) /\n            1e36;\n    }\n\n    /// @notice Allows users to deposit `_amount` of vault tokens. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Deposit} event\n    /// @param _amount The amount of tokens to deposit\n    function deposit(uint256 _amount) external noContract(msg.sender) {\n        require(_amount > 0, \"invalid_amount\");\n\n        _update();\n        _withdrawReward(msg.sender);\n\n        vault.safeTransferFrom(msg.sender, address(this), _amount);\n\n        balanceOf[msg.sender] += _amount;\n        totalStaked += _amount;\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to withdraw `_amount` of vault tokens. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Withdraw} event\n    /// @param _amount The amount of tokens to withdraw\n    function withdraw(uint256 _amount) external noContract(msg.sender) {\n        require(_amount > 0, \"invalid_amount\");\n        require(balanceOf[msg.sender] >= _amount, \"insufficient_amount\");\n\n        _update();\n        _withdrawReward(msg.sender);\n\n        balanceOf[msg.sender] -= _amount;\n        totalStaked -= _amount;\n\n        vault.safeTransfer(msg.sender, _amount);\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to claim rewards. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Claim} event\n    function claim() external noContract(msg.sender) {\n        _update();\n        _withdrawReward(msg.sender);\n\n        uint256 rewards = userPendingRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        userPendingRewards[msg.sender] = 0;\n        //we are subtracting the claimed rewards from the previous to have a consistent value next time\n        //{_update is called}\n        previousBalance -= rewards;\n\n        if (jpeg.balanceOf(address(this)) < rewards)\n            vault.withdrawJPEG();\n\n        jpeg.safeTransfer(msg.sender, rewards);\n\n        emit Claim(msg.sender, rewards);\n    }\n\n    /// @dev Updates this contract's rewards state\n    function _update() internal {\n        if (block.number <= lastRewardBlock) return;\n\n        lastRewardBlock = block.number;\n\n        if (totalStaked == 0) return;\n\n        (accRewardPerShare, previousBalance) = _computeUpdate();\n    }\n\n    /// @dev Computes the updated contract state without writing storage\n    /// @return newAccRewardsPerShare The new value of `accRewardsPerShare`\n    /// @return currentBalance The new value of `previousBalance`\n    function _computeUpdate() internal view returns (uint256 newAccRewardsPerShare, uint256 currentBalance) {\n        currentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));\n        uint256 newRewards = currentBalance - previousBalance;\n\n        newAccRewardsPerShare = accRewardPerShare + newRewards * 1e36 / totalStaked;\n    }\n\n    /// @dev Updates `account`'s claimable rewards by adding pending rewards\n    /// @param account The account to update\n    function _withdrawReward(address account) internal returns (uint256) {\n        uint256 pending = (balanceOf[account] *\n            (accRewardPerShare - userLastAccRewardPerShare[account])) / 1e36;\n\n        if (pending > 0) userPendingRewards[account] += pending;\n\n        userLastAccRewardPerShare[account] = accRewardPerShare;\n\n        return pending;\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}"
    },
    {
      "filename": "contracts/vaults/yVault/yVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/IYVault.sol\";\n\n/// @title JPEG'd yVault\n/// @notice Allows users to deposit fungible assets into autocompounding strategy contracts (e.g. {StrategyPUSDConvex}).\n/// Non whitelisted contracts can't deposit/withdraw.\n/// Owner is DAO\ncontract YVault is ERC20, Ownable {\n    using SafeERC20 for ERC20;\n    using Address for address;\n\n    event Deposit(address indexed depositor, uint256 wantAmount);\n    event Withdrawal(address indexed withdrawer, uint256 wantAmount);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    ERC20 public immutable token;\n    IController public controller;\n    \n    address public farm;\n    \n    Rate internal availableTokensRate;\n\n    mapping(address => bool) public whitelistedContracts;\n\n    /// @param _token The token managed by this vault\n    /// @param _controller The JPEG'd strategies controller\n    constructor(\n        address _token,\n        address _controller,\n        Rate memory _availableTokensRate\n    )\n        ERC20(\n            string(\n                abi.encodePacked(\"JPEG\\xE2\\x80\\x99d \", ERC20(_token).name())\n            ),\n            string(abi.encodePacked(\"JPEGD\", ERC20(_token).symbol()))\n        )\n    {\n        setController(_controller);\n        setAvailableTokensRate(_availableTokensRate);\n        token = ERC20(_token);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the vault.\n    /// Prevents non-whitelisted 3rd party contracts from diluting stakers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts not allowed\"\n        );\n        _;\n    }\n\n    /// @inheritdoc ERC20\n    function decimals() public view virtual override returns (uint8) {\n        return token.decimals();\n    }\n\n    /// @return The total amount of tokens managed by this vault and the underlying strategy\n    function balance() public view returns (uint256) {\n        return\n            token.balanceOf(address(this)) +\n            controller.balanceOf(address(token));\n    }\n\n    // @return The amount of JPEG tokens claimable by {YVaultLPFarming}\n    function balanceOfJPEG() external view returns (uint256) {\n        return controller.balanceOfJPEG(address(token));\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Allows the owner to set the rate of tokens held by this contract that the underlying strategy should be able to borrow\n    /// @param _rate The new rate\n    function setAvailableTokensRate(Rate memory _rate) public onlyOwner {\n        require(\n            _rate.numerator > 0 && _rate.denominator >= _rate.numerator,\n            \"INVALID_RATE\"\n        );\n        availableTokensRate = _rate;\n    }\n\n    /// @notice ALlows the owner to set this vault's controller\n    /// @param _controller The new controller\n    function setController(address _controller) public onlyOwner {\n        require(_controller != address(0), \"INVALID_CONTROLLER\");\n        controller = IController(_controller);\n    }\n\n    /// @notice Allows the owner to set the yVault LP farm\n    /// @param _farm The new farm\n    function setFarmingPool(address _farm) public onlyOwner {\n        require(_farm != address(0), \"INVALID_FARMING_POOL\");\n        farm = _farm;\n    }\n\n    /// @return How much the vault allows to be borrowed by the underlying strategy.\n    /// Sets minimum required on-hand to keep small withdrawals cheap\n    function available() public view returns (uint256) {\n        return\n            (token.balanceOf(address(this)) * availableTokensRate.numerator) /\n            availableTokensRate.denominator;\n    }\n\n    /// @notice Deposits `token` into the underlying strategy\n    function earn() external {\n        uint256 _bal = available();\n        token.safeTransfer(address(controller), _bal);\n        controller.earn(address(token), _bal);\n    }\n\n    /// @notice Allows users to deposit their entire `token` balance\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    /// @notice Allows users to deposit `token`. Contracts can't call this function\n    /// @param _amount The amount to deposit\n    function deposit(uint256 _amount) public noContract(msg.sender) {\n        require(_amount > 0, \"INVALID_AMOUNT\");\n        uint256 balanceBefore = balance();\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 supply = totalSupply();\n        uint256 shares;\n        if (supply == 0) {\n            shares = _amount;\n        } else {\n            //balanceBefore can't be 0 if totalSupply is > 0\n            shares = (_amount * supply) / balanceBefore;\n        }\n        _mint(msg.sender, shares);\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to withdraw all their deposited balance\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /// @notice Allows users to withdraw tokens. Contracts can't call this function\n    /// @param _shares The amount of shares to burn\n    function withdraw(uint256 _shares) public noContract(msg.sender) {\n        require(_shares > 0, \"INVALID_AMOUNT\");\n\n        uint256 supply = totalSupply();\n        require(supply > 0, \"NO_TOKENS_DEPOSITED\");\n\n        uint256 backingTokens = (balance() * _shares) / supply;\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 vaultBalance = token.balanceOf(address(this));\n        if (vaultBalance < backingTokens) {\n            uint256 toWithdraw = backingTokens - vaultBalance;\n            controller.withdraw(address(token), toWithdraw);\n        }\n\n        token.safeTransfer(msg.sender, backingTokens);\n        emit Withdrawal(msg.sender, backingTokens);\n    }\n\n    /// @notice Allows anyone to withdraw JPEG to `farm` \n    function withdrawJPEG() external {\n        require(farm != address(0), \"NO_FARM\");\n        controller.withdrawJPEG(address(token), farm);\n    }\n\n    /// @return The underlying tokens per share\n    function getPricePerFullShare() external view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) return 0;\n        return (balance() * 1e18) / supply;\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}"
    },
    {
      "filename": "contracts/farming/yVaultLPFarming.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/IYVault.sol\";\n\n/// @title JPEG'd yVault token farm\n/// @notice Users can stake their JPEG'd vault tokens and earn JPEG rewards\n/// @dev The rewards are taken from the PUSD Convex pool and distributed to stakers based on their share of the total staked tokens.\ncontract YVaultLPFarming is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IYVault;\n    using Address for address;\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Claim(address indexed user, uint256 rewards);\n\n    IYVault public immutable vault;\n    IERC20 public immutable jpeg;\n\n    uint256 public totalStaked;\n\n    uint256 internal lastRewardBlock;\n    uint256 internal previousBalance;\n    uint256 internal accRewardPerShare;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => uint256) private userLastAccRewardPerShare;\n    mapping(address => uint256) private userPendingRewards;\n\n    /// @notice Contracts that are allowed to interact with the LP farm\n    /// @dev See the {noContract} modifier for more info\n    mapping(address => bool) public whitelistedContracts;\n\n    ///@param _vault The yVault address\n    ///@param _jpeg The JPEG token address\n    constructor(address _vault, address _jpeg) {\n        require(_vault != address(0), \"INVALID_VAULT\");\n        require(_jpeg != address(0), \"INVALID_JPEG\");\n\n        vault = IYVault(_vault);\n        jpeg = IERC20(_jpeg);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the farm.\n    /// Prevents non-whitelisted 3rd party contracts (e.g. autocompounders) from diluting farmers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts aren't allowed to farm\"\n        );\n        _;\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Frontend function used to calculate the amount of rewards `_user` can claim\n    /// @param _user The address of the user\n    /// @return The amount of rewards claimable by user `_user`\n    function pendingReward(address _user)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 rewardShare = accRewardPerShare;\n        uint256 staked = totalStaked;\n        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,\n        //we need to calculate the up to date amount to return an accurate reward value\n        if (block.number > lastRewardBlock && staked > 0) {\n            (rewardShare, ) = _computeUpdate();\n        }\n        return\n            //rewards that the user had already accumulated but not claimed\n            userPendingRewards[_user] +\n            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share\n            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable\n            //by the user\n            (balanceOf[_user] * (rewardShare - userLastAccRewardPerShare[_user])) /\n            1e36;\n    }\n\n    /// @notice Allows users to deposit `_amount` of vault tokens. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Deposit} event\n    /// @param _amount The amount of tokens to deposit\n    function deposit(uint256 _amount) external noContract(msg.sender) {\n        require(_amount > 0, \"invalid_amount\");\n\n        _update();\n        _withdrawReward(msg.sender);\n\n        vault.safeTransferFrom(msg.sender, address(this), _amount);\n\n        balanceOf[msg.sender] += _amount;\n        totalStaked += _amount;\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to withdraw `_amount` of vault tokens. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Withdraw} event\n    /// @param _amount The amount of tokens to withdraw\n    function withdraw(uint256 _amount) external noContract(msg.sender) {\n        require(_amount > 0, \"invalid_amount\");\n        require(balanceOf[msg.sender] >= _amount, \"insufficient_amount\");\n\n        _update();\n        _withdrawReward(msg.sender);\n\n        balanceOf[msg.sender] -= _amount;\n        totalStaked -= _amount;\n\n        vault.safeTransfer(msg.sender, _amount);\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to claim rewards. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Claim} event\n    function claim() external noContract(msg.sender) {\n        _update();\n        _withdrawReward(msg.sender);\n\n        uint256 rewards = userPendingRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        userPendingRewards[msg.sender] = 0;\n        //we are subtracting the claimed rewards from the previous to have a consistent value next time\n        //{_update is called}\n        previousBalance -= rewards;\n\n        if (jpeg.balanceOf(address(this)) < rewards)\n            vault.withdrawJPEG();\n\n        jpeg.safeTransfer(msg.sender, rewards);\n\n        emit Claim(msg.sender, rewards);\n    }\n\n    /// @dev Updates this contract's rewards state\n    function _update() internal {\n        if (block.number <= lastRewardBlock) return;\n\n        lastRewardBlock = block.number;\n\n        if (totalStaked == 0) return;\n\n        (accRewardPerShare, previousBalance) = _computeUpdate();\n    }\n\n    /// @dev Computes the updated contract state without writing storage\n    /// @return newAccRewardsPerShare The new value of `accRewardsPerShare`\n    /// @return currentBalance The new value of `previousBalance`\n    function _computeUpdate() internal view returns (uint256 newAccRewardsPerShare, uint256 currentBalance) {\n        currentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));\n        uint256 newRewards = currentBalance - previousBalance;\n\n        newAccRewardsPerShare = accRewardPerShare + newRewards * 1e36 / totalStaked;\n    }\n\n    /// @dev Updates `account`'s claimable rewards by adding pending rewards\n    /// @param account The account to update\n    function _withdrawReward(address account) internal returns (uint256) {\n        uint256 pending = (balanceOf[account] *\n            (accRewardPerShare - userLastAccRewardPerShare[account])) / 1e36;\n\n        if (pending > 0) userPendingRewards[account] += pending;\n\n        userLastAccRewardPerShare[account] = accRewardPerShare;\n\n        return pending;\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}"
    }
  ]
}