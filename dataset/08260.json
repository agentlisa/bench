{
  "Title": "[M-08] If a MIMOProxy owner destroys their proxy, they cannot deploy another from the same address",
  "Content": "_Submitted by horsefacts_\n\nWhen deploying a new `MIMOProxy`, the `MIMOProxyRegistry` first checks whether a proxy exists with the same owner for the given address. If an existing proxy is found, the deployment reverts:\n\n[`MIMOProxyRegistry#deployFor`](https://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/proxy/MIMOProxyRegistry.sol#L45-L59)\n\n```solidity\n  function deployFor(address owner) public override returns (IMIMOProxy proxy) {\n    IMIMOProxy currentProxy = _currentProxies[owner];\n\n    // Do not deploy if the proxy already exists and the owner is the same.\n    if (address(currentProxy) != address(0) && currentProxy.owner() == owner) {\n      revert CustomErrors.PROXY_ALREADY_EXISTS(owner);\n    }\n\n    // Deploy the proxy via the factory.\n    proxy = factory.deployFor(owner);\n\n    // Set or override the current proxy for the owner.\n    _currentProxies[owner] = IMIMOProxy(proxy);\n  }\n}\n```\n\nHowever, if a `MIMOProxy` owner intentionally or accidentally destroys their proxy by `delegatecall`ing a target that calls `selfdestruct`, the address of their destroyed proxy will remain in the `_currentProxies` mapping, but the static call to `currentProxy.owner()` on L49 will revert. The caller will be blocked from deploying a new proxy from the same address that created their original \\`MIMOProxy.\n\n### Impact\n\nIf a user accidentally destroys their MIMOProxy, they must use a new EOA address to deploy another.\n\n### Recommended Mitigation Steps\n\nCheck whether the proxy has been destroyed as part of the \"proxy already exists\" conditions. If the proxy address has a codesize of zero, it has been destroyed:\n\n```solidity\n    // Do not deploy if the proxy already exists and the owner is the same.\n    if (address(currentProxy) != address(0) && currentProxy.code.length > 0 && currentProxy.owner() == owner) {\n      revert CustomErrors.PROXY_ALREADY_EXISTS(owner);\n    }\n\n```\n\n#### Test cases\n\nWe'll use this `ProxyAttacks` helper contract to manipulate proxy storage. Note that it has the same storage layout as `MIMOProxy`.\n\n```solidity\ncontract ProxyAttacks {\n\n   address public owner;\n   uint256 public minGasReserve;\n   mapping(address => mapping(address => mapping(bytes4 => bool))) internal _permissions;\n\n   // Selector 0x9cb8a26a\n   function selfDestruct() external {\n     selfdestruct(payable(address(0)));\n   }\n}\n```\n\nThen deploy the `ProxyAttacks` helper in a test environment and use `MIMOProxy` to `delegatecall` into it:\n\n```typescript\nimport chai, { expect } from 'chai';\nimport { solidity } from 'ethereum-waffle';\nimport { deployments, ethers } from 'hardhat';\n\nimport { MIMOProxy, MIMOProxyFactory, MIMOProxyRegistry, ProxyAttacks } from '../../typechain';\n\nchai.use(solidity);\n\nconst setup = deployments.createFixture(async () => {\n  const { deploy } = deployments;\n  const [owner, attacker] = await ethers.getSigners();\n\n  await deploy(\"MIMOProxy\", {\n    from: owner.address,\n    args: [],\n  });\n  const mimoProxyBase: MIMOProxy = await ethers.getContract(\"MIMOProxy\");\n\n  await deploy(\"MIMOProxyFactory\", {\n    from: owner.address,\n    args: [mimoProxyBase.address],\n  });\n  const mimoProxyFactory: MIMOProxyFactory = await ethers.getContract(\"MIMOProxyFactory\");\n\n  await deploy(\"MIMOProxyRegistry\", {\n    from: owner.address,\n    args: [mimoProxyFactory.address],\n  });\n  const mimoProxyRegistry: MIMOProxyRegistry = await ethers.getContract(\"MIMOProxyRegistry\");\n\n  await deploy(\"ProxyAttacks\", {\n    from: owner.address,\n    args: [],\n  });\n  const proxyAttacks: ProxyAttacks = await ethers.getContract(\"ProxyAttacks\");\n\n  return {\n    owner,\n    attacker,\n    mimoProxyBase,\n    mimoProxyFactory,\n    mimoProxyRegistry,\n    proxyAttacks,\n  };\n});\n\ndescribe(\"Proxy attack tests\", () => {\n  it(\"Proxy instance self destruct + recreation\", async () => {\n    const { owner, mimoProxyRegistry, proxyAttacks } = await setup();\n    await mimoProxyRegistry.deploy();\n    const currentProxy = await mimoProxyRegistry.getCurrentProxy(owner.address);\n    const proxy = await ethers.getContractAt(\"MIMOProxy\", currentProxy);\n\n    // Delegatecall to selfDestruct on ProxyAttacks contract\n    await proxy.execute(proxyAttacks.address, \"0x9cb8a26a\");\n\n    // Owner's existing proxy is destroyed\n    expect(proxy.owner()).to.be.revertedWith(\"call revert exception\");\n\n    // Cannot deploy another proxy for this address through the registry\n    await expect(mimoProxyRegistry.deploy()).to.be.revertedWith(\"function returned an unexpected amount of data\");\n  });\n});\n```\n**[RayXpub (Mimo) confirmed and commented](https://github.com/code-423n4/2022-08-mimo-findings/issues/162#issuecomment-1210522543):**\n > We confirm this issue and intend to implement a fix. \n\n**horsefacts (warden) reviewed mitigation:**\n> **Status:** ✅ Resolved\n\n> **Finding:** A warden identified that if a `MIMOProxy` owner destroys their proxy by calling selfdestruct, they cannot deploy another from the same address.\n\n> **What changed:** The Mimo team added [a check](https://github.com/mimo-capital/2022-08-mimo/blob/5a63c76ed74186d11d3adb361d3b3aacefa7795e/contracts/proxy/MIMOProxyFactory.sol#L50) for the current proxy’s codesize in `MIMOProxyFactory#deploy`. If the proxy has been destroyed it is will be deleted from the `_proxyStates` mapping and a new proxy can be deployed. A [unit test](https://github.com/mimo-capital/2022-08-mimo/blob/5a63c76ed74186d11d3adb361d3b3aacefa7795e/test/01_unit/proxy/MIMOProxyFactory.test.ts#L230) demonstrates this behavior.\n\n> **Why it works:** Since a proxy’s codesize will be zero when it has been destroyed, and cannot be zero otherwise, this check will allow the owner of a destroyed proxy to deploy another.\n\n\n\n***\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-mimo-august-2022-contest",
  "Code": [
    {
      "filename": "contracts/proxy/MIMOProxyRegistry.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"./interfaces/IMIMOProxy.sol\";\nimport \"./interfaces/IMIMOProxyFactory.sol\";\nimport \"./interfaces/IMIMOProxyRegistry.sol\";\nimport \"../core/interfaces/IAddressProvider.sol\";\nimport \"../core/interfaces/IAccessController.sol\";\nimport { CustomErrors } from \"../libraries/CustomErrors.sol\";\n\n/// @title MIMOProxyRegistry\ncontract MIMOProxyRegistry is IMIMOProxyRegistry {\n  /// PUBLIC STORAGE ///\n\n  /// @inheritdoc IMIMOProxyRegistry\n  IMIMOProxyFactory public override factory;\n\n  /// INTERNAL STORAGE ///\n\n  /// @notice Internal mapping of owners to current proxies.\n  mapping(address => IMIMOProxy) internal _currentProxies;\n\n  /// CONSTRUCTOR ///\n\n  /// @param factory_ The base contract of the factory\n  constructor(IMIMOProxyFactory factory_) {\n    factory = factory_;\n  }\n\n  /// PUBLIC CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxyRegistry\n  function getCurrentProxy(address owner) external view override returns (IMIMOProxy proxy) {\n    proxy = _currentProxies[owner];\n  }\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /// @inheritdoc IMIMOProxyRegistry\n  function deploy() external override returns (IMIMOProxy proxy) {\n    proxy = deployFor(msg.sender);\n  }\n\n  /// @inheritdoc IMIMOProxyRegistry\n  function deployFor(address owner) public override returns (IMIMOProxy proxy) {\n    IMIMOProxy currentProxy = _currentProxies[owner];\n\n    // Do not deploy if the proxy already exists and the owner is the same.\n    if (address(currentProxy) != address(0) && currentProxy.owner() == owner) {\n      revert CustomErrors.PROXY_ALREADY_EXISTS(owner);\n    }\n\n    // Deploy the proxy via the factory.\n    proxy = factory.deployFor(owner);\n\n    // Set or override the current proxy for the owner.\n    _currentProxies[owner] = IMIMOProxy(proxy);\n  }\n}"
    },
    {
      "filename": "contracts/proxy/MIMOProxyFactory.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport \"./interfaces/IMIMOProxyFactory.sol\";\nimport \"./MIMOProxy.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\n/// @title MIMOProxyFactory\ncontract MIMOProxyFactory is IMIMOProxyFactory {\n  using Clones for address;\n\n  address public immutable mimoProxyGuardBase;\n\n  /// @inheritdoc IMIMOProxyFactory\n  uint256 public constant override VERSION = 1;\n\n  /// @notice proxy => proxy state\n  mapping(address => ProxyState) private _proxyStates;\n\n  /// @notice owner => proxy\n  mapping(address => IMIMOProxy) private _currentProxies;\n\n  /// @notice proxy => pending owner\n  mapping(address => address) private _pendingOwners;\n\n  modifier onlyOwner(address proxy) {\n    if (address(_currentProxies[msg.sender]) != proxy) {\n      revert Errors.NOT_OWNER(_proxyStates[proxy].owner, msg.sender);\n    }\n    _;\n  }\n\n  constructor(address _mimoProxyGuardBase) {\n    if (_mimoProxyGuardBase == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    mimoProxyGuardBase = _mimoProxyGuardBase;\n  }\n\n  /**\n    @notice Deploys a new MIMOProxy and MIMOProxyGuard\n    @dev Sets \"msg.sender\" as the owner of the MIMOProxy.\n\n   */\n  function deploy() external override {\n    address currentProxy = address(_currentProxies[msg.sender]);\n    if (address(currentProxy) != address(0)) {\n      if (currentProxy.code.length == 0) {\n        delete _proxyStates[currentProxy];\n      } else {\n        revert Errors.ALREADY_OWNER(msg.sender, currentProxy);\n      }\n    }\n    MIMOProxy proxy = new MIMOProxy(address(this));\n    IMIMOProxyGuard proxyGuard = IMIMOProxyGuard(mimoProxyGuardBase.clone());\n\n    proxyGuard.initialize(address(this), address(proxy));\n\n    ProxyState memory proxyState = ProxyState({ owner: msg.sender, proxyGuard: proxyGuard, minGas: 5000 });\n\n    _currentProxies[msg.sender] = IMIMOProxy(proxy);\n    _proxyStates[address(proxy)] = proxyState;\n\n    emit ProxyDeployed(msg.sender, address(proxy), proxyState);\n  }\n\n  /**\n    @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    Can only be invoked by the current MIMOProxy `owner`\n    @param proxy Address ot the MIMOProxy to transfer\n    @param newOwner Address of the new owner\n   */\n  function transferOwnership(address proxy, address newOwner) external override onlyOwner(proxy) {\n    // Checks\n    if (newOwner == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    if (address(_currentProxies[newOwner]) != address(0)) {\n      revert Errors.ALREADY_OWNER(newOwner, address(_currentProxies[newOwner]));\n    }\n    // Effects\n    _pendingOwners[proxy] = newOwner;\n    emit OwnershipTransferred(proxy, msg.sender, newOwner);\n  }\n\n  /**\n    @notice Needs to be called by `pendingOwner` to claim ownership\n    @param proxy Address of the MIMOProxy to claim\n    @param clear Clear existing proxy permissions if true and maintain them if false\n   */\n  function claimOwnership(address proxy, bool clear) external override {\n    address pendingOwner = _pendingOwners[proxy];\n\n    // Checks\n    if (msg.sender != pendingOwner) {\n      revert Errors.CALLER_NOT_PENDING_OWNER(msg.sender, pendingOwner);\n    }\n\n    if (address(_currentProxies[pendingOwner]) != address(0)) {\n      revert Errors.ALREADY_OWNER(pendingOwner, address(_currentProxies[pendingOwner]));\n    }\n\n    // Effects\n    address oldOwner = _proxyStates[proxy].owner;\n    delete _currentProxies[oldOwner];\n    _currentProxies[msg.sender] = IMIMOProxy(proxy);\n    _proxyStates[proxy].owner = msg.sender;\n    delete _pendingOwners[proxy];\n    emit OwnershipClaimed(proxy, msg.sender);\n\n    if (clear) {\n      _clearPermissions(proxy);\n    }\n  }\n\n  /**\n    @notice Clear all permissions from the MIMOProxy by deploying a new MIMOProxyGuard\n    Can only be called by the MIMOProxy `owner`\n    @param proxy Addess of the MIMOProxy to clear\n   */\n  function clearPermissions(address proxy) external override onlyOwner(proxy) {\n    _clearPermissions(proxy);\n  }\n\n  /**\n    @param proxy Address of the MIMOProxy\n    @param minGas Gas to reserve for running the remainder of the \"execute\" function after the DELEGATECALL in the \n    MIMOProxy. Prevents the proxy from becoming unusable if EVM opcode gas costs change in the future.\n   */\n  function setMinGas(address proxy, uint256 minGas) external override onlyOwner(proxy) {\n    _proxyStates[proxy].minGas = minGas;\n    emit MinGasSet(proxy, minGas);\n  }\n\n  /**\n    @param proxy Address of the MIMOProxy to check\n    @return result equals true if proxy has been deployed and false if not\n   */\n  function isProxy(address proxy) external view override returns (bool result) {\n    result = _proxyStates[proxy].owner != address(0);\n  }\n\n  /**\n    @notice Returns a MIMOProxy state\n    @dev MIMOProxy state management is outsourced to this contract to prevent storage collisions\n    @param proxy Address of the MIMOProxy\n    @return proxyState as a ProxyState struct containing a MIMOProxy state variables\n   */\n  function getProxyState(address proxy) external view override returns (ProxyState memory proxyState) {\n    proxyState = _proxyStates[proxy];\n  }\n\n  /**\n    @notice Gets the current MIMOProxy of the given owner.\n    @param owner The address of the owner of the current MIMOProxy.\n   */\n  function getCurrentProxy(address owner) external view override returns (IMIMOProxy proxy) {\n    proxy = _currentProxies[owner];\n  }\n\n  /**\n    @param proxy Address of the MIMOProxy\n    @return pendingOwner that has yet to claim his ownership\n   */\n  function getPendingOwner(address proxy) external view override returns (address pendingOwner) {\n    pendingOwner = _pendingOwners[proxy];\n  }\n\n  function _clearPermissions(address proxy) internal {\n    IMIMOProxyGuard proxyGuard = IMIMOProxyGuard(mimoProxyGuardBase.clone());\n    proxyGuard.initialize(address(this), proxy);\n    _proxyStates[proxy].proxyGuard = proxyGuard;\n\n    emit PermissionsCleared(proxy, address(proxyGuard));\n  }\n}"
    }
  ]
}