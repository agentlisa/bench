{
  "Title": "[Suggestion-01] Change interest rate model to jump rate model",
  "Content": "\n### Reference\n\n<https://github.com/code-423n4/2022-02-anchor/blob/main/contracts/money-market-contracts/contracts/interest_model/src/contract.rs#L114-L135>\n\n<https://github.com/compound-finance/compound-protocol/blob/master/contracts/JumpRateModel.sol>\n\n<https://docs.benqi.fi/benqi-liquidity-market/protocol-parameters>\n\n### Description\n\nThe current interest rate model used is a simple model that scales linearly with market utilization. A better interest rate model that Compound and its forks are using is the jump rate model, because it is more efficient at incentivizing liquidity at higher utilization rates.\n\n### Recommended Mitigation Steps\n\nChange the interest rate model to the jump rate model, where a kink is introduced to increase the interest multiplier after a specified market utilization rate.\n\n**[Alex the Entreprenerd (triage) commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/13#issuecomment-1205884657):**\n > This looks like the most complete report.\n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-02-anchor",
  "Code": [
    {
      "filename": "contracts/money-market-contracts/contracts/interest_model/src/contract.rs",
      "content": "use crate::error::ContractError;\nuse crate::state::{read_config, store_config, Config};\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\n\nuse cosmwasm_bignumber::Decimal256;\nuse cosmwasm_bignumber::Uint256;\nuse cosmwasm_std::{to_binary, Addr, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};\nuse moneymarket::common::optional_addr_validate;\nuse moneymarket::interest_model::{\n    BorrowRateResponse, ConfigResponse, ExecuteMsg, InstantiateMsg, QueryMsg,\n};\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -> StdResult<Response> {\n    store_config(\n        deps.storage,\n        &Config {\n            owner: deps.api.addr_canonicalize(&msg.owner)?,\n            base_rate: msg.base_rate,\n            interest_multiplier: msg.interest_multiplier,\n        },\n    )?;\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -> Result<Response, ContractError> {\n    match msg {\n        ExecuteMsg::UpdateConfig {\n            owner,\n            base_rate,\n            interest_multiplier,\n        } => {\n            let api = deps.api;\n            update_config(\n                deps,\n                info,\n                optional_addr_validate(api, owner)?,\n                base_rate,\n                interest_multiplier,\n            )\n        }\n    }\n}\n\npub fn update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    owner: Option<Addr>,\n    base_rate: Option<Decimal256>,\n    interest_multiplier: Option<Decimal256>,\n) -> Result<Response, ContractError> {\n    let mut config: Config = read_config(deps.storage)?;\n    if deps.api.addr_canonicalize(info.sender.as_str())? != config.owner {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(owner) = owner {\n        config.owner = deps.api.addr_canonicalize(owner.as_str())?;\n    }\n\n    if let Some(base_rate) = base_rate {\n        config.base_rate = base_rate;\n    }\n\n    if let Some(interest_multiplier) = interest_multiplier {\n        config.interest_multiplier = interest_multiplier;\n    }\n\n    store_config(deps.storage, &config)?;\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    match msg {\n        QueryMsg::Config {} => to_binary(&query_config(deps)?),\n        QueryMsg::BorrowRate {\n            market_balance,\n            total_liabilities,\n            total_reserves,\n        } => to_binary(&query_borrow_rate(\n            deps,\n            market_balance,\n            total_liabilities,\n            total_reserves,\n        )?),\n    }\n}\n\nfn query_config(deps: Deps) -> StdResult<ConfigResponse> {\n    let state = read_config(deps.storage)?;\n    let resp = ConfigResponse {\n        owner: deps.api.addr_humanize(&state.owner)?.to_string(),\n        base_rate: state.base_rate,\n        interest_multiplier: state.interest_multiplier,\n    };\n\n    Ok(resp)\n}\n\nfn query_borrow_rate(\n    deps: Deps,\n    market_balance: Uint256,\n    total_liabilities: Decimal256,\n    total_reserves: Decimal256,\n) -> StdResult<BorrowRateResponse> {\n    let config: Config = read_config(deps.storage)?;\n\n    // ignore decimal parts\n    let total_value_in_market =\n        Decimal256::from_uint256(market_balance) + total_liabilities - total_reserves;\n\n    let utilization_ratio = if total_value_in_market.is_zero() {\n        Decimal256::zero()\n    } else {\n        total_liabilities / total_value_in_market\n    };\n\n    Ok(BorrowRateResponse {\n        rate: utilization_ratio * config.interest_multiplier + config.base_rate,\n    })\n}"
    }
  ]
}