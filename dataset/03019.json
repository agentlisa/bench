{
  "Title": "M-3: Loss of funds with high liquidExitPenalty",
  "Content": "# Issue M-3: Loss of funds with high liquidExitPenalty \n\nSource: https://github.com/sherlock-audit/2022-09-sherlock-judging/tree/main/012-M \n\n## Found by \ndefsec, Chom, sirhashalot\n\n## Summary\n\nA high `liquidExitPenalty` fee percentage in the TrueFi protocol can result in a loss of user funds. The issue is that only the Sherlock contract owner can set the `yieldStrategy` in use and call `liquidExit` to withdraw funds from TrueFi. A withdrawal from the TrueFi yield strategy with unfavorable withdrawal fees can occur in the event that `yieldStrategy` is set to TrueFi and `liquidExit` is called with high withdrawal fees. This could be done intentionally by a rogue admin (centralization risk) but it can also happen in a benign manner when many users want to withdraw funds at the same time and USDC must be made available to them, regardless of the exit penalty fee.\n\n## Vulnerability Detail\n\nTrueFi has [a variable withdrawal fee](https://docs.truefi.io/faq/how-it-works/lending-on-truefi/pool/withdrawing-funds). The specific numbers are [in this spreadsheet](https://docs.google.com/spreadsheets/d/1ZXGRxunIwe0eYPu7j4QjCwXxe63tNKtpCvRiJnqK0jo/edit?usp=sharing), with a maximum fee of 10%. There is a [large comment block](https://github.com/sherlock-protocol/sherlock-v2-core/blob/355c70df23aa9aa7d46567c9540a6d15be93fcab/contracts/strategy/TrueFiStrategy.sol#L23-L50) in the TrueFi strategy explaining how this strategy will keep the withdrawal fee small. The problem underlying this strategy as it is coded is that a withdrawal at the wrong time can result in substantial loss of user funds. In a worse case scenario, it could lead to a bank run where some users are unable to get their deposits back because so much is lost to fee.\n\nThere is another substantial risk in lending to the TrueFi protocol. The risk is that TrueFi borrowers do not pay back their undercollateralized loans. This risk is clearly identified in [the TrueFi documentation](https://docs.truefi.io/faq/how-it-works/lending-on-truefi/pool#what-are-the-risks-involved-in-lending-to-the-truefi-lending-pool). While this risk may be unlikely with the current list of TrueFi borrowers, Sherlock must monitor new borrowers in the TrueFi ecosystem over time to assure that the risk level remains low.\n\n## Impact\n\nThe TrueFi strategy can result in loss of user deposits in certain circumstances.\n\n## Code Snippet\n\nThe function that the owner can use to set the yield strategy\nhttps://github.com/sherlock-protocol/sherlock-v2-core/blob/355c70df23aa9aa7d46567c9540a6d15be93fcab/contracts/Sherlock.sol#L272-L280\n\nThe function that the owner can use to withdraw funds from TrueFi\nhttps://github.com/sherlock-protocol/sherlock-v2-core/blob/355c70df23aa9aa7d46567c9540a6d15be93fcab/contracts/strategy/TrueFiStrategy.sol#L155-L185\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe TrueFi strategy is higher risk than other strategies for Sherlock staking. This level of risk may not be acceptable to some users because of the risk of loss of funds. If this strategy is to be used, Sherlock must insure its deposits in TrueFi to avoid losing user's deposits because Sherlock's reputation is on the line.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/5",
  "Code": [
    {
      "filename": "contracts/strategy/TrueFiStrategy.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport './base/BaseStrategy.sol';\n\nimport '../interfaces/truefi/ITrueFiPool2.sol';\nimport '../interfaces/truefi/ITrueMultiFarm.sol';\n\n// This contract contains logic for depositing staker funds into TrueFi as a yield strategy\n// https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueFiPool2.sol\n// https://docs.truefi.io/faq/main-lending-pools/pool#lending-pools-smart-contracts\n\n// TRU farming\n// https://docs.truefi.io/faq/main-lending-pools/farming-liquidity-mining\n\n// Joining fee is currently 0, is able to change\n\n/*\nThoughts on adding `liquidExitPenalty` to `balanceOf()`\n\nIn the most extreme example where all our money is in TrueFi and we don't assume the exit fee,\npeople will see balance = 100 USDC, but when actually withdrawing it will be 90 USDC\n(because of the exit fee)\n\nIn the other most extreme example where all our money is not yet in TrueFi and we do assume the exit fee,\npeople can see balance = 100 USDC but when we deposit it, it will be 90 USDC (because of the exit fee)\n(note: this affects the exit fee in a positive way as it adds liquidity)\n\n^ these extremes assume our deposits/withdraws don't have any effect on the exit fee.\nBut with the current 180m$ pool it will take 9m$ to move the poolLiquidty 5%,\nwhich is 0.91% -> 10% in the most extreme scenario\n\nTakeaways\n- We want to account the exit fee to not 'surprise' people on withdraw with a lower balance\n- We want to be a small part of the pool (<=5%?) to keep it liquid and not move the exitFee to 10% on exit.\n\nWhat happen if we are a large part of the pool?\n\nFor example if balanceOf = totalSupply and we have deposited 100 USDC\nOnly 10 USDC is liquid (10%) which makes the exit fee 0.48%\n\n`balanceOf()` would show 99,52 USDC as the exit fee is applied\nIf we call `liquidExit()` with 10 USDC, 0% will be liquid and the exit fee jumps up to 10%\n`balanceOf()` would show 10 USDC + 81 (90 USDC - 10% exit fee) = 91 USDC\n*/\n\n// All tfUSDC will be staked in the farm at any time (except runtime of a transaction)\ncontract TrueFiStrategy is BaseStrategy {\n  using SafeERC20 for IERC20;\n  using SafeERC20 for ITrueFiPool2;\n\n  // Value copied from https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueFiPool2.sol#L487\n  uint256 private constant BASIS_PRECISION = 10000;\n\n  // the tfUSDC pool\n  ITrueFiPool2 public constant tfUSDC = ITrueFiPool2(0xA991356d261fbaF194463aF6DF8f0464F8f1c742);\n  // TrueFi farm, used to stake tfUSDC and earn TrueFi tokens\n  ITrueMultiFarm public constant tfFarm =\n    ITrueMultiFarm(0xec6c3FD795D6e6f202825Ddb56E01b3c128b0b10);\n  // The TrueFi token\n  IERC20 public constant rewardToken = IERC20(0x4C19596f5aAfF459fA38B0f7eD92F11AE6543784);\n\n  // Address to receive rewards\n  address public constant LIQUIDITY_MINING_RECEIVER = 0x666B8EbFbF4D5f0CE56962a25635CfF563F13161;\n\n  /// @param _initialParent Contract that will be the parent in the tree structure\n  constructor(IMaster _initialParent) BaseNode(_initialParent) {\n    // Approve tfUSDC max amount of USDC\n    want.safeIncreaseAllowance(address(tfUSDC), type(uint256).max);\n    // Approve tfFarm max amount of tfUSDC\n    tfUSDC.safeIncreaseAllowance(address(tfFarm), type(uint256).max);\n  }\n\n  /// @notice Signal if strategy is ready to be used\n  /// @return Boolean indicating if strategy is ready\n  function setupCompleted() external view override returns (bool) {\n    return true;\n  }\n\n  /// @notice Deposit all USDC in this contract in TrueFi\n  /// @notice Joining fee may apply, this will lower the balance of the system on deposit\n  /// @notice Works under the assumption this contract contains USDC\n  function _deposit() internal override whenNotPaused {\n    // https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueFiPool2.sol#L469\n    tfUSDC.join(want.balanceOf(address(this)));\n\n    // Don't stake in the tfFarm if shares are 0\n    // This would make the function call revert\n    // https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueMultiFarm.sol#L101\n    if (tfFarm.getShare(tfUSDC) == 0) return;\n\n    // How much tfUSDC is in this contract\n    // Could both be tfUSDC that was already in here before the `_deposit()` call\n    // And new tfUSDC that was minted in the `tfUSDC.join()` call\n    uint256 tfUsdcBalance = tfUSDC.balanceOf(address(this));\n\n    // Stake all tfUSDC in the tfFarm\n    tfFarm.stake(tfUSDC, tfUsdcBalance);\n  }\n\n  /// @notice Send all USDC in this contract to core\n  /// @notice Funds need to be withdrawn using `liquidExit()` first\n  /// @return amount Amount of USDC withdrawn\n  function _withdrawAll() internal override returns (uint256 amount) {\n    // Amount of USDC in the contract\n    amount = want.balanceOf(address(this));\n    // Transfer USDC to core\n    if (amount != 0) want.safeTransfer(core, amount);\n  }\n\n  /// @notice Send `_amount` USDC in this contract to core\n  /// @notice Funds need to be withdrawn using `liquidExit()` first\n  /// @param _amount Amount of USDC to withdraw\n  function _withdraw(uint256 _amount) internal override {\n    // Transfer USDC to core\n    want.safeTransfer(core, _amount);\n  }\n\n  /// @notice View how much tfUSDC is staked in the farm\n  /// @return Amount of tfUSDC staked\n  function _viewTfUsdcStaked() private view returns (uint256) {\n    // Amount of tfUSDC staked in the tfFarm\n    return tfFarm.staked(tfUSDC, address(this));\n  }\n\n  /// @notice View USDC in this contract + USDC in TrueFi\n  /// @notice Takes into account exit penalty for liquidating full tfUSDC balance\n  /// @return Amount of USDC in this strategy\n  function _balanceOf() internal view override returns (uint256) {\n    // https://docs.truefi.io/faq/main-lending-pools/developer-guide/truefipool2-contract#calculating-lending-pool-token-prices\n\n    // How much USDC is locked in TrueFi\n    // Based on staked tfUSDC + tfUSDC in this contract\n    uint256 tfUsdcBalance = (tfUSDC.poolValue() *\n      (_viewTfUsdcStaked() + tfUSDC.balanceOf(address(this)))) / tfUSDC.totalSupply();\n\n    // How much USDC we get if we liquidate the full position\n    tfUsdcBalance = (tfUsdcBalance * tfUSDC.liquidExitPenalty(tfUsdcBalance)) / BASIS_PRECISION;\n\n    // Return USDC in contract + USDC we can get from TrueFi\n    return want.balanceOf(address(this)) + tfUsdcBalance;\n  }\n\n  /// @notice Exit `_amount` of tfUSDC (pool LP tokens)\n  /// @notice Up to 10% exit fee may apply.\n  /// @notice There are two situations in which the pool will not let you withdraw via Liquid Exit:\n  /// @notice 1) If there is no liquid asset in the lending pool and no liquid exit is deployed in Curve.\n  /// @notice 2) If the pool needs to liquidate its position in Curve and will incur a loss of more than 10 basis points.\n  /// @dev Can only be called by owner\n  function liquidExit(uint256 _amount) external onlyOwner {\n    // https://github.com/trusttoken/contracts-pre22/blob/main/contracts/truefi2/TrueFiPool2.sol#L487\n    // here's a spreadsheet that shows the exit penalty at different liquidRatio levels ( = liquidValue / poolValue):\n    // https://docs.google.com/spreadsheets/d/1ZXGRxunIwe0eYPu7j4QjCwXxe63tNKtpCvRiJnqK0jo/edit#gid=0\n\n    // Exiting 0 tokens doesn't make sense\n    if (_amount == 0) revert ZeroArg();\n\n    // Amount of tfUSDC in this contract\n    uint256 tfUsdcBalance = tfUSDC.balanceOf(address(this));\n    uint256 tfUsdcStaked = _viewTfUsdcStaked();\n\n    // Exit MAX amount of tokens\n    if (_amount == type(uint256).max) {\n      _amount = tfUsdcBalance + tfUsdcStaked;\n      // Exiting 0 tokens doesn't make sense\n      if (_amount == 0) revert InvalidState();\n    }\n    // We can not withdraw more tfUSDC than we have access to\n    else if (_amount > tfUsdcBalance + tfUsdcStaked) revert InvalidArg();\n\n    // Unstake tfUSDC if it isn't in the contract already\n    if (_amount > tfUsdcBalance) {\n      // Unstake tfUSDC from tfFarm so we are able to exit `_amount`\n      tfFarm.unstake(tfUSDC, _amount - tfUsdcBalance);\n    }\n\n    // At this point there should be at least `_amount` of tfUSDC in the contract\n    // Unstake tfUSDC tokens from the pool, this will send USDC to this contract\n    tfUSDC.liquidExit(_amount);\n  }\n\n  /// @notice Claim TrueFi tokens earned by farming\n  /// @dev TrueFi tokens will be send to LIQUIDITY_MINING_RECEIVER\n  function claimReward() external {\n    IERC20[] memory tokens = new IERC20[](1);\n    tokens[0] = tfUSDC;\n\n    // Claim TrueFi tokens for tfUSDC\n    tfFarm.claim(tokens);\n\n    // How much TrueFi tokens does this contract hold\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    // Send all TrueFi tokens to LIQUIDITY_MINING_RECEIVER\n    if (rewardBalance != 0) rewardToken.safeTransfer(LIQUIDITY_MINING_RECEIVER, rewardBalance);\n  }\n}"
    },
    {
      "filename": "contracts/Sherlock.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\n\nimport './interfaces/ISherlock.sol';\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\n\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The minimal amount needed to mint a position\n  uint256 public constant MIN_STAKE = 10**6; // 1 USDC\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (26 weeks)\n  uint256 public constant ARB_RESTAKE_PERIOD = 26 weeks;\n\n  // The percentage of someone's stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 => bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 => uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 => uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 => uint256) internal stakeShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  string private constant baseURI = 'https://nft.sherlock.xyz/api/mainnet/';\n\n  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 _token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i < _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of `_tokenID`\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd_[_tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of `_tokenID`\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards_[_tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for `_period` of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for `_period` of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  /// @dev After updating the contract, call setSherlockCoreAddress() on the new contract\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  /// @notice Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligible for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligible for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  /// @dev After updating the contract, call setSherlockCoreAddress() on the new contract\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  /// @dev After updating the contract, call setSherlockCoreAddress() on the new contract\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy New address of the strategy\n  /// @dev Call will fail if underlying withdrawAll call fails\n  /// @dev After updating the contract, call setSherlockCoreAddress() on the new contract\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    yieldStrategy.withdrawAll();\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy ignoring state of current strategy\n  /// @param _yieldStrategy New address of the strategy\n  /// @dev tries a yieldStrategyWithdrawAll() on old strategy, ignore failure\n  function updateYieldStrategyForce(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit `_amount` into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw `_amount` from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can still be replaced with a new contract in a `paused` state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn't needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &&\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can still be replaced with a new contract in an `unpaused` state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn't needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &&\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override whenNotPaused {}\n\n  function _baseURI() internal view virtual override returns (string memory) {\n    return baseURI;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of `_amount` to `_receiver`\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends\n  /// @dev `_period` needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd_[_id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards_[_id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards_[_id];\n    if (sherReward == 0) return;\n\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards_[_id];\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount > mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes `_amount` of tokens and locks up for `_"
    }
  ]
}