{
  "Title": "```LibWstethEthOracle::getWstethEthPrice``` returns wrong ```wstETH/ETH``` price in some conditions impacting system operations",
  "Content": "# ```LibWstethEthOracle::getWstethEthPrice``` returns wrong ```wstETH/ETH``` price in some conditions impacting system operations\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-04-beanstalk-2/blob/a3d702c2e108cac6ebdf2416906cbca73c83ec99/protocol/contracts/libraries/Oracle/LibWstethEthOracle.sol#L35-L37\">https://github.com/Cyfrin/2024-04-beanstalk-2/blob/a3d702c2e108cac6ebdf2416906cbca73c83ec99/protocol/contracts/libraries/Oracle/LibWstethEthOracle.sol#L35-L37</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-04-beanstalk-2/blob/a3d702c2e108cac6ebdf2416906cbca73c83ec99/protocol/contracts/libraries/Oracle/LibWstethEthOracle.sol#L93-L98\">https://github.com/Cyfrin/2024-04-beanstalk-2/blob/a3d702c2e108cac6ebdf2416906cbca73c83ec99/protocol/contracts/libraries/Oracle/LibWstethEthOracle.sol#L93-L98</a>\n\n\n## Summary\nThe ```LibWstethEthOracle::getWstethEthPrice``` function is designed in the system to compute the ```wstETH/ETH``` price . On the top of the ```LibWstethEthOracle``` contract a detailed NatSpec describes the price computation logic. Reported here for clarity: \"It then computes a wstETH:ETH price by taking the minimum of (3) and either the average of (1) and (2) if (1) and (2) are within `MAX_DIFFERENCE` from each other or (1).\"\n\nAccording to the NatSpec, the contract should compute the ```wstETH:ETH``` price by taking the minimum of the the redemption value or the average of the Chainlink and Uniswap oracle prices if their percent difference is within a specified threshold (```MAX_DIFFERENCE```) or the Chainlink oracle price if the percent difference exceeds this threshold. However, the actual implementation does not handle the scenario where the percent difference exceeds ```MAX_DIFFERENCE```. Consequently, users interacts with the system, such as minting fertilizer tokens, using inaccurate price data.\n\n## Vulnerability Details\nThe ```LibWstethEthOracle::getWstethEthPrice``` lacks explicit handling for scenarios where the percent difference between the Chainlink and Uniswap oracle prices is greater then ```MAX_DIFFERENCE```. This omission leads to situations where the contract does not default to the Chainlink price as intended, affecting the accuracy and reliability of the ```wstETH:ETH``` price computation. \n\n```solidity\n/**\n * @title Wsteth Eth Oracle Library\n * @author brendan\n * @notice Computes the wstETH:ETH price.\n * @dev\n * The oracle reads from 4 data sources:\n * a. wstETH:stETH Redemption Rate: (0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0)\n * b. stETH:ETH Chainlink Oracle: (0x86392dC19c0b719886221c78AB11eb8Cf5c52812)\n * c. wstETH:ETH Uniswap Pool: (0x109830a1AAaD605BbF02a9dFA7B0B92EC2FB7dAa)\n * d. stETH:ETH Redemption: (1:1)\n *\n * It then computes the wstETH:ETH price in 3 ways:\n * 1. wstETH -> ETH via Chainlink: a * b\n * 2. wstETH -> ETH via wstETH:ETH Uniswap Pool: c * 1\n * 3. wstETH -> ETH via stETH redemption: a * d\n *\n@> * It then computes a wstETH:ETH price by taking the minimum of (3) and either the average of (1) and (2)\n@> * if (1) and (2) are within `MAX_DIFFERENCE` from each other or (1).\n**/\n\n\n    function getWstethEthPrice(uint256 lookback) internal view returns (uint256 wstethEthPrice) {\n\n        uint256 chainlinkPrice = lookback == 0 ? \n            LibChainlinkOracle.getPrice(WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR, LibChainlinkOracle.FOUR_DAY_TIMEOUT) :\n            LibChainlinkOracle.getTwap(WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR, LibChainlinkOracle.FOUR_DAY_TIMEOUT, lookback);\n\n        // Check if the chainlink price is broken or frozen.\n        if (chainlinkPrice == 0) return 0;\n\n        uint256 stethPerWsteth = IWsteth(C.WSTETH).stEthPerToken();\n        \n        chainlinkPrice = chainlinkPrice.mul(stethPerWsteth).div(CHAINLINK_DENOMINATOR);\n\n\n        // Uniswap V3 only supports a uint32 lookback.\n        if (lookback > type(uint32).max) return 0;\n        uint256 uniswapPrice = LibUniswapOracle.getTwap(\n            lookback == 0 ? LibUniswapOracle.FIFTEEN_MINUTES :\n            uint32(lookback),\n            WSTETH_ETH_UNIV3_01_POOL, C.WSTETH, C.WETH, ONE\n        );\n\n        // Check if the uniswapPrice oracle fails.\n        if (uniswapPrice == 0) return 0;\n\n@>        if (LibOracleHelpers.getPercentDifference(chainlinkPrice, uniswapPrice) < MAX_DIFFERENCE) {\n@>           wstethEthPrice = chainlinkPrice.add(uniswapPrice).div(AVERAGE_DENOMINATOR);\n@>            if (wstethEthPrice > stethPerWsteth) wstethEthPrice = stethPerWsteth;\n@>            wstethEthPrice = wstethEthPrice.div(PRECISION_DENOMINATOR);\n        }\n    }\n}\n```\n\n## Impact\nThe absence of the missing return of the Chainlink oracle price in scenarios of significant price discrepancy between the Chainlink and Uniswap oracles (```LibOracleHelpers.getPercentDifference(chainlinkPrice, uniswapPrice) > MAX_DIFFERENCE```) can lead to a scenario where the contract uses an average price that does not accurately reflect market conditions. The smart contract will operate with an inaccurate ```wstETH:ETH``` price, impacting operations dependent on this price. This could result in financial losses for users and undermine the integrity of the system.\n\nFor example, in the beanstalk system, the ```FertilizerFacet::mintFertilizer``` function relies on the ```LibWstethEthOracle::getWstethEthPrice``` to fetch the ```wstETH:ETH``` price from. This price is crucial for calculating the amount of Fertilizer tokens that can be acquired with the provided ```tokenAmountIn```. However, if this function returns an inaccurate price, it would not reflect the actual price of the asset. Consequently, users could continue to mint fertilizer tokens using this inaccurate price data, leading to transactions occurring at incorrect prices.\n\n## Tools Used\nManual review\n\n## Recommendations\nModify the ```LibWstethEthOracle::getWstethEthPrice``` function to include explicit logic for handling the case where the percent difference between the Chainlink and Uniswap prices is greater then ```MAX_DIFFERENCE```.\n\n```diff\nif (LibOracleHelpers.getPercentDifference(chainlinkPrice, uniswapPrice) < MAX_DIFFERENCE) {\n            wstethEthPrice = chainlinkPrice.add(uniswapPrice).div(AVERAGE_DENOMINATOR);\n+      } else {\n+        wstethEthPrice = chainlinkPrice;\n+    }\n            if (wstethEthPrice > stethPerWsteth) wstethEthPrice = stethPerWsteth;\n            wstethEthPrice = wstethEthPrice.div(PRECISION_DENOMINATOR);\n-        }\n```",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clu7665bs0001fmt5yahc8tyh",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/Oracle/LibWstethEthOracle.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibChainlinkOracle} from \"./LibChainlinkOracle.sol\";\nimport {LibUniswapOracle} from \"./LibUniswapOracle.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {LibAppStorage, AppStorage} from \"contracts/libraries/LibAppStorage.sol\";\nimport {C} from \"contracts/C.sol\";\nimport {LibOracleHelpers} from \"contracts/libraries/Oracle/LibOracleHelpers.sol\";\n\ninterface IWsteth {\n    function stEthPerToken() external view returns (uint256);\n}\n\n/**\n * @title Wsteth Eth Oracle Library\n * @author brendan\n * @notice Computes the wstETH:ETH price.\n * @dev\n * The oracle reads from 4 data sources:\n * a. wstETH:stETH Redemption Rate: (0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0)\n * b. stETH:ETH Chainlink Oracle: (0x86392dC19c0b719886221c78AB11eb8Cf5c52812)\n * c. wstETH:ETH Uniswap Pool: (0x109830a1AAaD605BbF02a9dFA7B0B92EC2FB7dAa)\n * d. stETH:ETH Redemption: (1:1)\n *\n * It then computes the wstETH:ETH price in 3 ways:\n * 1. wstETH -> ETH via Chainlink: a * b\n * 2. wstETH -> ETH via wstETH:ETH Uniswap Pool: c * 1\n * 3. wstETH -> ETH via stETH redemption: a * d\n *\n * It then computes a wstETH:ETH price by taking the minimum of (3) and either the average of (1) and (2)\n * if (1) and (2) are within `MAX_DIFFERENCE` from each other or (1).\n **/\nlibrary LibWstethEthOracle {\n    using SafeMath for uint256;\n\n    // The maximum percent difference such that the oracle assumes no manipulation is occuring.\n    uint256 constant MAX_DIFFERENCE = 0.01e18; // 1%\n    uint256 constant CHAINLINK_DENOMINATOR = 1e6;\n    uint128 constant ONE = 1e18;\n    uint128 constant AVERAGE_DENOMINATOR = 2;\n    uint128 constant PRECISION_DENOMINATOR = 1e12;\n\n    /////////////////// ORACLES ///////////////////\n    address constant WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR =\n        0x86392dC19c0b719886221c78AB11eb8Cf5c52812;\n    address internal constant WSTETH_ETH_UNIV3_01_POOL = 0x109830a1AAaD605BbF02a9dFA7B0B92EC2FB7dAa; // 0.01% pool\n    ///////////////////////////////////////////////\n\n    /**\n     * @dev Returns the instantaneous wstETH/ETH price\n     * Return value has 6 decimal precision.\n     * Returns 0 if the either the Chainlink Oracle or Uniswap Oracle cannot fetch a valid price.\n     **/\n    function getWstethEthPrice() internal view returns (uint256) {\n        return getWstethEthPrice(0);\n    }\n\n    /**\n     * @dev Returns the wstETH/ETH price with the option of using a TWA lookback.\n     * Return value has 6 decimal precision.\n     * Returns 0 if the either the Chainlink Oracle or Uniswap Oracle cannot fetch a valid price.\n     **/\n    function getWstethEthPrice(uint256 lookback) internal view returns (uint256 wstethEthPrice) {\n\n        uint256 chainlinkPrice = lookback == 0 ? \n            LibChainlinkOracle.getPrice(WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR, LibChainlinkOracle.FOUR_DAY_TIMEOUT) :\n            LibChainlinkOracle.getTwap(WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR, LibChainlinkOracle.FOUR_DAY_TIMEOUT, lookback);\n\n        // Check if the chainlink price is broken or frozen.\n        if (chainlinkPrice == 0) return 0;\n\n        uint256 stethPerWsteth = IWsteth(C.WSTETH).stEthPerToken();\n        \n        chainlinkPrice = chainlinkPrice.mul(stethPerWsteth).div(CHAINLINK_DENOMINATOR);\n\n\n        // Uniswap V3 only supports a uint32 lookback.\n        if (lookback > type(uint32).max) return 0;\n        uint256 uniswapPrice = LibUniswapOracle.getTwap(\n            lookback == 0 ? LibUniswapOracle.FIFTEEN_MINUTES :\n            uint32(lookback),\n            WSTETH_ETH_UNIV3_01_POOL, C.WSTETH, C.WETH, ONE\n        );\n\n        // Check if the uniswapPrice oracle fails.\n        if (uniswapPrice == 0) return 0;\n\n        if (LibOracleHelpers.getPercentDifference(chainlinkPrice, uniswapPrice) < MAX_DIFFERENCE) {\n            wstethEthPrice = chainlinkPrice.add(uniswapPrice).div(AVERAGE_DENOMINATOR);\n            if (wstethEthPrice > stethPerWsteth) wstethEthPrice = stethPerWsteth;\n            wstethEthPrice = wstethEthPrice.div(PRECISION_DENOMINATOR);\n        }\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Oracle/LibWstethEthOracle.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {LibChainlinkOracle} from \"./LibChainlinkOracle.sol\";\nimport {LibUniswapOracle} from \"./LibUniswapOracle.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {LibAppStorage, AppStorage} from \"contracts/libraries/LibAppStorage.sol\";\nimport {C} from \"contracts/C.sol\";\nimport {LibOracleHelpers} from \"contracts/libraries/Oracle/LibOracleHelpers.sol\";\n\ninterface IWsteth {\n    function stEthPerToken() external view returns (uint256);\n}\n\n/**\n * @title Wsteth Eth Oracle Library\n * @author brendan\n * @notice Computes the wstETH:ETH price.\n * @dev\n * The oracle reads from 4 data sources:\n * a. wstETH:stETH Redemption Rate: (0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0)\n * b. stETH:ETH Chainlink Oracle: (0x86392dC19c0b719886221c78AB11eb8Cf5c52812)\n * c. wstETH:ETH Uniswap Pool: (0x109830a1AAaD605BbF02a9dFA7B0B92EC2FB7dAa)\n * d. stETH:ETH Redemption: (1:1)\n *\n * It then computes the wstETH:ETH price in 3 ways:\n * 1. wstETH -> ETH via Chainlink: a * b\n * 2. wstETH -> ETH via wstETH:ETH Uniswap Pool: c * 1\n * 3. wstETH -> ETH via stETH redemption: a * d\n *\n * It then computes a wstETH:ETH price by taking the minimum of (3) and either the average of (1) and (2)\n * if (1) and (2) are within `MAX_DIFFERENCE` from each other or (1).\n **/\nlibrary LibWstethEthOracle {\n    using SafeMath for uint256;\n\n    // The maximum percent difference such that the oracle assumes no manipulation is occuring.\n    uint256 constant MAX_DIFFERENCE = 0.01e18; // 1%\n    uint256 constant CHAINLINK_DENOMINATOR = 1e6;\n    uint128 constant ONE = 1e18;\n    uint128 constant AVERAGE_DENOMINATOR = 2;\n    uint128 constant PRECISION_DENOMINATOR = 1e12;\n\n    /////////////////// ORACLES ///////////////////\n    address constant WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR =\n        0x86392dC19c0b719886221c78AB11eb8Cf5c52812;\n    address internal constant WSTETH_ETH_UNIV3_01_POOL = 0x109830a1AAaD605BbF02a9dFA7B0B92EC2FB7dAa; // 0.01% pool\n    ///////////////////////////////////////////////\n\n    /**\n     * @dev Returns the instantaneous wstETH/ETH price\n     * Return value has 6 decimal precision.\n     * Returns 0 if the either the Chainlink Oracle or Uniswap Oracle cannot fetch a valid price.\n     **/\n    function getWstethEthPrice() internal view returns (uint256) {\n        return getWstethEthPrice(0);\n    }\n\n    /**\n     * @dev Returns the wstETH/ETH price with the option of using a TWA lookback.\n     * Return value has 6 decimal precision.\n     * Returns 0 if the either the Chainlink Oracle or Uniswap Oracle cannot fetch a valid price.\n     **/\n    function getWstethEthPrice(uint256 lookback) internal view returns (uint256 wstethEthPrice) {\n\n        uint256 chainlinkPrice = lookback == 0 ? \n            LibChainlinkOracle.getPrice(WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR, LibChainlinkOracle.FOUR_DAY_TIMEOUT) :\n            LibChainlinkOracle.getTwap(WSTETH_ETH_CHAINLINK_PRICE_AGGREGATOR, LibChainlinkOracle.FOUR_DAY_TIMEOUT, lookback);\n\n        // Check if the chainlink price is broken or frozen.\n        if (chainlinkPrice == 0) return 0;\n\n        uint256 stethPerWsteth = IWsteth(C.WSTETH).stEthPerToken();\n        \n        chainlinkPrice = chainlinkPrice.mul(stethPerWsteth).div(CHAINLINK_DENOMINATOR);\n\n\n        // Uniswap V3 only supports a uint32 lookback.\n        if (lookback > type(uint32).max) return 0;\n        uint256 uniswapPrice = LibUniswapOracle.getTwap(\n            lookback == 0 ? LibUniswapOracle.FIFTEEN_MINUTES :\n            uint32(lookback),\n            WSTETH_ETH_UNIV3_01_POOL, C.WSTETH, C.WETH, ONE\n        );\n\n        // Check if the uniswapPrice oracle fails.\n        if (uniswapPrice == 0) return 0;\n\n        if (LibOracleHelpers.getPercentDifference(chainlinkPrice, uniswapPrice) < MAX_DIFFERENCE) {\n            wstethEthPrice = chainlinkPrice.add(uniswapPrice).div(AVERAGE_DENOMINATOR);\n            if (wstethEthPrice > stethPerWsteth) wstethEthPrice = stethPerWsteth;\n            wstethEthPrice = wstethEthPrice.div(PRECISION_DENOMINATOR);\n        }\n    }\n}"
    }
  ]
}