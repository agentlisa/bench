{
  "Title": "[M-13] It may be possible to DoS AuctionHouse by specifying malicious creators",
  "Content": "\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/AuctionHouse.sol#L378> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/AuctionHouse.sol#L394> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/AuctionHouse.sol#L400> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/ERC20TokenEmitter.sol#L212> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/ERC20TokenEmitter.sol#L109> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/NontransferableERC20Votes.sol#L131> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/base/erc20/ERC20Upgradeable.sol#L232> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/base/erc20/ERC20VotesUpgradeable.sol#L62> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/base/VotesUpgradeable.sol#L222> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/base/VotesUpgradeable.sol#L227> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/base/VotesUpgradeable.sol#L245-L249>\n\n**Note:** *there is another bug in `AuctionHouse::_settleAuction` that causes DoS (querying `verbs.getArtPieceById` too many times), but this submission describes another issue and from now on, **I assume that `verbs.getArtPieceById` is not called in loop in `_settleAuction`***.\n\n### Brief Description\n\nMalicious user can specify creators of art piece maliciously, so that `AuctionHouse::_settleAuction` will use over `20 000 000` gas units, which is close to the block gas limit (`30 000 000`). If block gas limit is ever decreased in the future or the cost of some operations in EVM increase, this will put `AuctionHouse` in the permanent DoS state as `_settleAuction` will attempt to use more gas than the block gas limit.\n\n### Detailed description\n\nUser who calls `CultureIndex::createPiece` can specify up to `100` arbitrary creators, who will get paid if the created piece wins voting and is bought in an auction. The function handling that is called `_settleAuction` and looks like this:\n\n<details>\n\n```solidity\n    function _settleAuction() internal {\n            [...]\n            else verbs.transferFrom(address(this), _auction.bidder, _auction.verbId);\n\n\n            [...]\n\n                //Transfer creator's share to the creator, for each creator, and build arrays for erc20TokenEmitter.buyToken\n                if (creatorsShare > 0 && entropyRateBps > 0) {\n                    for (uint256 i = 0; i < numCreators; i++) {\n                        [...]\n\n                        //Transfer creator's share to the creator\n                        _safeTransferETHWithFallback(creator.creator, paymentAmount);\n                    }\n                }\n\n\n                //Buy token from ERC20TokenEmitter for all the creators\n                if (creatorsShare > ethPaidToCreators) {\n                    creatorTokensEmitted = erc20TokenEmitter.buyToken{ value: creatorsShare - ethPaidToCreators }(\n                        vrgdaReceivers,\n                        vrgdaSplits,\n                        IERC20TokenEmitter.ProtocolRewardAddresses({\n                            builder: address(0),\n                            purchaseReferral: address(0),\n                            deployer: deployer\n                        })\n                    );\n                }\n            }\n        }\n        [...]\n```\n</details>\n\nAs can be seen, it performs several external transactions. The most important are (I purposely ignore `verbs.getArtPieceById` here as the issue addresses malicious creators only):\n\n*   `_safeTransferETHWithFallback(creator.creator, paymentAmount)`\n*   `creatorTokensEmitted = erc20TokenEmitter.buyToken`\n\nIn order to make `_settleAuction` as costly as possible, attacker can do several things:\n\n*   Specify as many creators as possible (`100`).\n*   Consume as much gas as possible in `receive()` of all of these creators.\n*   Make each creator different, so that `sset` operations performed later in the code change `0` to nonzero entries (so that it costs `20000` per word instead of `2900`, for `sreset`).\n\nSince `_safeTransferETHWithFallback` specifies `50 000` gas in a call, each such call will cost `> 50 000 + 9 000 = 59 000` gas (`9 000` for `callvalue` operation). Since the number of creators can be `100`, it will use over `5 900 000` gas by itself (including cost for converting `ETH` to `WETH` and sending it each time).\n\nI will not analyse each memory reads and writes here (I tried to specify the most important places in the \"Links to affected code\" section of this submission), but another \"heavy\" function, in terms of gas usage is `erc20TokenEmitter.buyToken` as it will update users' balances (change from `0` to nonzero) and the same will happen for their voting power.\n\nFrom the tests I have made (see PoC), it follows that attacker can cause `settleCurrentAndCreateNewAuction` (that calls `_settleAuction`) to use over `20 000 000` gas units.\n\n### Impact\n\nIf the attack is able to cause `_settleAuction` to reach block gas limit, `AuctionHouse` will be DoSed as it won't be possible to settle auctions.\n\nWhile it's not the case at the moment (attacker can now reach `20 000 000`), I will now demonstrate why it's problematic even right now:\n\n*   Ethereum / Base / Optimism block gas limit can change in the future; if it's decreased, it will be possible to DoS `AuctionHouse`\n*   EVM operations' cost can change - **it is not a hypothetical scenario**: for example the cost of `sload` increased from `50` to `2100` (or `100` in case of warm access) from the frontier hardfork (see [frontier](https://ethereum.github.io/execution-specs/autoapi/ethereum/frontier/vm/gas/index.html?gas-sload#gas-sload) and [shanghai](https://ethereum.github.io/execution-specs/autoapi/ethereum/shanghai/vm/gas/index.html?gas-cold-sload#gas-cold-sload))\n\nSince EVM operations' gas cost increase is a real scenario that has happened in the past and the end effect is severe (DoS of `AuctionHouse`), but the attack is:\n\n*   Not yet possible (it is in fact possible combined with another exploit of specifying a very \"heavy\" NFT that I will describe in another submission, not to mention the bug about calling `getArtPieceById` that I mentioned earlier), but it will already harm user who calls `_settleAuction` as he will have to pay a lot for the gas.\n*   In order for the attack to be performed, attacker would have to win the voting first.\n\nHence, I believe that Medium severity is appropriate for this issue.\n\n### Proof of Concept\n\nFirst of all, please modify the code in the `AuctionHouse::_settleAuction` in the following way:\n\n*   Replace `ICultureIndex.CreatorBps memory creator = verbs.getArtPieceById(_auction.verbId).creators[i];` with `ICultureIndex.CreatorBps memory creator = artPiece.creators[i];`.\n*   Put `ICultureIndex.ArtPiece memory artPiece = verbs.getArtPieceById(_auction.verbId);` right before `if (creatorsShare > 0 && entropyRateBps > 0) {`.\n\n**It is a fix for another bug that is in the `_settleAuction` and since this submission describes another attack vector, we have to fix it first (as otherwise it won't be possible to calculate precisely the impact of the described attack)**.\n\nThen, please put the following contract definition in `AuctionSettling.t.sol`:\n\n```solidity\ncontract InfiniteLoop\n{\n    receive() external payable\n    {\n        while (true)\n        {\n\n        }\n    }\n}\n```\n\nThen, please put the following code in `AuctionSettling.t.sol` and run the test (`import \"forge-std/console.sol\";` will be needed as well):\n\n<details>\n\n```solidity\n    // this function creates an auction and wait for its finish\n    // if `toDoS` is true, it will create `100` creators and each creator will be a malicious contract that will\n    // run an infinite loop in its `receive()`\n    // if `toDoS` is false, it will create only `1` \"honest\" creator\n    function _createAndFinishAuction(bool toDoS) internal\n    {\n        uint nCreators = toDoS ? 100 : 1;\n        address[] memory creatorAddresses = new address[](nCreators);\n        uint256[] memory creatorBps = new uint256[](nCreators);\n        uint256 totalBps = 0;\n        address[] memory creators = new address[](nCreators + 1);\n        for (uint i = 0; i < nCreators + 1; i++)\n        {\n            if (toDoS)\n                creators[i] = address(new InfiniteLoop());\n            else\n                creators[i] = address(uint160(0x1234 + i));\n        }\n\n        for (uint256 i = 0; i < nCreators; i++) {\n            creatorAddresses[i] = address(creators[i]);\n            if (i == nCreators - 1) {\n                creatorBps[i] = 10_000 - totalBps;\n            } else {\n                creatorBps[i] = (10_000) / (nCreators - 1);\n            }\n            totalBps += creatorBps[i];\n        }\n\n        uint256 verbId = createArtPieceMultiCreator(\n            \"Multi Creator Art\",\n            \"An art piece with multiple creators\",\n            ICultureIndex.MediaType.IMAGE,\n            \"ipfs://multi-creator-art\",\n            \"\",\n            \"\",\n            creatorAddresses,\n            creatorBps\n        );\n\n        vm.startPrank(auction.owner());\n        auction.unpause();\n        vm.stopPrank();\n\n        uint256 bidAmount = auction.reservePrice();\n        vm.deal(address(creators[nCreators]), bidAmount + 1 ether);\n        vm.startPrank(address(creators[nCreators]));\n        auction.createBid{ value: bidAmount }(verbId, address(creators[nCreators]));\n        vm.stopPrank();\n\n        vm.warp(block.timestamp + auction.duration() + 1); // Fast forward time to end the auction\n    }\n\n    function testDOS() public\n    {\n        uint gasConsumption1;\n        uint gasConsumption2;\n        uint gas0;\n        uint gas1;\n\n        vm.startPrank(cultureIndex.owner());\n        cultureIndex._setQuorumVotesBPS(0);\n        vm.stopPrank();\n\n        _createAndFinishAuction(true);\n\n        gas0 = gasleft();\n        auction.settleCurrentAndCreateNewAuction();\n        gas1 = gasleft();\n        // we calculate gas consumption in case of `100` malicious creators\n        gasConsumption1 = gas0 - gas1;\n\n        _createAndFinishAuction(false);\n\n        gas0 = gasleft();\n        auction.settleCurrentAndCreateNewAuction();\n        gas1 = gasleft();\n        // we calculate gas consumption in case of `1` \"honest\" creator\n        gasConsumption2 = gas0 - gas1;\n\n        console.log(\"Gas consumption difference =\", gasConsumption1 - gasConsumption2);\n    }\n```\n</details>\n\nIt will output a value `~20 500 000` as a gas difference between the use with one \"honest\" creator and `100` malicious creators when `settleCurrentAndCreateNewAuction` is called.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nConsider limiting the number of creators that may be specified.\n\nAlternatively, don't distribute `ETH` and `ERC20` tokens to creators in `_settleAuction` - instead let them receive their rewards in a separate function (for example, called `claimRewards`), that one of them will call, independently from `_settleAuction`.\n\n**[0xTheC0der (Judge) commented](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/93#issuecomment-1879687734):**\n > See comment on primary issue: https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/195#issuecomment-1879684718\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/revolution/src/AuctionHouse.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The Verbs DAO auction house\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// AuctionHouse.sol is a modified version of Zora's AuctionHouse.sol:\n// https://github.com/ourzora/auction-house/blob/54a12ec1a6cf562e49f0a4917990474b11350a2d/contracts/AuctionHouse.sol\n//\n// AuctionHouse.sol source code Copyright Zora licensed under the GPL-3.0 license.\n\npragma solidity ^0.8.22;\n\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IAuctionHouse } from \"./interfaces/IAuctionHouse.sol\";\nimport { IVerbsToken } from \"./interfaces/IVerbsToken.sol\";\nimport { IWETH } from \"./interfaces/IWETH.sol\";\nimport { IERC20TokenEmitter } from \"./interfaces/IERC20TokenEmitter.sol\";\nimport { ICultureIndex } from \"./interfaces/ICultureIndex.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\ncontract AuctionHouse is\n    IAuctionHouse,\n    VersionedContract,\n    UUPS,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    Ownable2StepUpgradeable\n{\n    // The Verbs ERC721 token contract\n    IVerbsToken public verbs;\n\n    // The ERC20 governance token\n    IERC20TokenEmitter public erc20TokenEmitter;\n\n    // The address of the WETH contract\n    address public WETH;\n\n    // The minimum amount of time left in an auction after a new bid is created\n    uint256 public timeBuffer;\n\n    // The minimum price accepted in an auction\n    uint256 public reservePrice;\n\n    // The minimum percentage difference between the last bid amount and the current bid\n    uint8 public minBidIncrementPercentage;\n\n    // The split of the winning bid that is reserved for the creator of the Verb in basis points\n    uint256 public creatorRateBps;\n\n    // The all time minimum split of the winning bid that is reserved for the creator of the Verb in basis points\n    uint256 public minCreatorRateBps;\n\n    // The split of (auction proceeds * creatorRate) that is sent to the creator as ether in basis points\n    uint256 public entropyRateBps;\n\n    // The duration of a single auction\n    uint256 public duration;\n\n    // The active auction\n    IAuctionHouse.Auction public auction;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder public immutable manager;\n\n    // TODO investigate this - The minimum gas threshold for creating an auction (minting VerbsToken)\n    uint32 public constant MIN_TOKEN_MINT_GAS_THRESHOLD = 750_000;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initialize the auction house and base contracts,\n     * populate configuration values, and pause the contract.\n     * @dev This function can only be called once.\n     * @param _erc721Token The address of the Verbs ERC721 token contract.\n     * @param _erc20TokenEmitter The address of the ERC-20 token emitter contract.\n     * @param _initialOwner The address of the owner.\n     * @param _weth The address of the WETH contract\n     * @param _auctionParams The auction params for auctions.\n     */\n    function initialize(\n        address _erc721Token,\n        address _erc20TokenEmitter,\n        address _initialOwner,\n        address _weth,\n        IRevolutionBuilder.AuctionParams calldata _auctionParams\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n        require(_weth != address(0), \"WETH cannot be zero address\");\n\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init(_initialOwner);\n\n        _pause();\n\n        require(\n            _auctionParams.creatorRateBps >= _auctionParams.minCreatorRateBps,\n            \"Creator rate must be greater than or equal to the creator rate\"\n        );\n\n        verbs = IVerbsToken(_erc721Token);\n        erc20TokenEmitter = IERC20TokenEmitter(_erc20TokenEmitter);\n        timeBuffer = _auctionParams.timeBuffer;\n        reservePrice = _auctionParams.reservePrice;\n        minBidIncrementPercentage = _auctionParams.minBidIncrementPercentage;\n        duration = _auctionParams.duration;\n        creatorRateBps = _auctionParams.creatorRateBps;\n        entropyRateBps = _auctionParams.entropyRateBps;\n        minCreatorRateBps = _auctionParams.minCreatorRateBps;\n        WETH = _weth;\n    }\n\n    /**\n     * @notice Settle the current auction, mint a new Verb, and put it up for auction.\n     */\n    // Can technically reenter via cross function reentrancies in _createAuction, auction, and pause, but those are only callable by the owner.\n    // @wardens if you can find an exploit here go for it - we might be wrong.\n    // slither-disable-next-line reentrancy-eth\n    function settleCurrentAndCreateNewAuction() external override nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /**\n     * @notice Settle the current auction.\n     * @dev This function can only be called when the contract is paused.\n     */\n    function settleAuction() external override whenPaused nonReentrant {\n        _settleAuction();\n    }\n\n    /**\n     * @notice Create a bid for a Verb, with a given amount.\n     * @dev This contract only accepts payment in ETH.\n     * @param verbId The ID of the Verb to bid on.\n     * @param bidder The address of the bidder.\n     */\n    function createBid(uint256 verbId, address bidder) external payable override nonReentrant {\n        IAuctionHouse.Auction memory _auction = auction;\n\n        //require bidder is valid address\n        require(bidder != address(0), \"Bidder cannot be zero address\");\n        require(_auction.verbId == verbId, \"Verb not up for auction\");\n        //slither-disable-next-line timestamp\n        require(block.timestamp < _auction.endTime, \"Auction expired\");\n        require(msg.value >= reservePrice, \"Must send at least reservePrice\");\n        require(\n            msg.value >= _auction.amount + ((_auction.amount * minBidIncrementPercentage) / 100),\n            \"Must send more than last bid by minBidIncrementPercentage amount\"\n        );\n\n        address payable lastBidder = _auction.bidder;\n\n        auction.amount = msg.value;\n        auction.bidder = payable(bidder);\n\n        // Extend the auction if the bid was received within `timeBuffer` of the auction end time\n        bool extended = _auction.endTime - block.timestamp < timeBuffer;\n        if (extended) auction.endTime = _auction.endTime = block.timestamp + timeBuffer;\n\n        // Refund the last bidder, if applicable\n        if (lastBidder != address(0)) _safeTransferETHWithFallback(lastBidder, _auction.amount);\n\n        emit AuctionBid(_auction.verbId, bidder, msg.sender, msg.value, extended);\n\n        if (extended) emit AuctionExtended(_auction.verbId, _auction.endTime);\n    }\n\n    /**\n     * @notice Pause the Verbs auction house.\n     * @dev This function can only be called by the owner when the\n     * contract is unpaused. While no new auctions can be started when paused,\n     * anyone can settle an ongoing auction.\n     */\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Set the split of the winning bid that is reserved for the creator of the Verb in basis points.\n     * @dev Only callable by the owner.\n     * @param _creatorRateBps New creator rate in basis points.\n     */\n    function setCreatorRateBps(uint256 _creatorRateBps) external onlyOwner {\n        require(\n            _creatorRateBps >= minCreatorRateBps,\n            \"Creator rate must be greater than or equal to minCreatorRateBps\"\n        );\n        require(_creatorRateBps <= 10_000, \"Creator rate must be less than or equal to 10_000\");\n        creatorRateBps = _creatorRateBps;\n\n        emit CreatorRateBpsUpdated(_creatorRateBps);\n    }\n\n    /**\n     * @notice Set the minimum split of the winning bid that is reserved for the creator of the Verb in basis points.\n     * @dev Only callable by the owner.\n     * @param _minCreatorRateBps New minimum creator rate in basis points.\n     */\n    function setMinCreatorRateBps(uint256 _minCreatorRateBps) external onlyOwner {\n        require(_minCreatorRateBps <= creatorRateBps, \"Min creator rate must be less than or equal to creator rate\");\n        require(_minCreatorRateBps <= 10_000, \"Min creator rate must be less than or equal to 10_000\");\n\n        //ensure new min rate cannot be lower than previous min rate\n        require(\n            _minCreatorRateBps > minCreatorRateBps,\n            \"Min creator rate must be greater than previous minCreatorRateBps\"\n        );\n\n        minCreatorRateBps = _minCreatorRateBps;\n\n        emit MinCreatorRateBpsUpdated(_minCreatorRateBps);\n    }\n\n    /**\n     * @notice Set the split of (auction proceeds * creatorRate) that is sent to the creator as ether in basis points.\n     * @dev Only callable by the owner.\n     * @param _entropyRateBps New entropy rate in basis points.\n     */\n    function setEntropyRateBps(uint256 _entropyRateBps) external onlyOwner {\n        require(_entropyRateBps <= 10_000, \"Entropy rate must be less than or equal to 10_000\");\n\n        entropyRateBps = _entropyRateBps;\n        emit EntropyRateBpsUpdated(_entropyRateBps);\n    }\n\n    /**\n     * @notice Unpause the Verbs auction house.\n     * @dev This function can only be called by the owner when the\n     * contract is paused. If required, this function will start a new auction.\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n\n        if (auction.startTime == 0 || auction.settled) {\n            _createAuction();\n        }\n    }\n\n    /**\n     * @notice Set the auction time buffer.\n     * @dev Only callable by the owner.\n     */\n    function setTimeBuffer(uint256 _timeBuffer) external override onlyOwner {\n        timeBuffer = _timeBuffer;\n\n        emit AuctionTimeBufferUpdated(_timeBuffer);\n    }\n\n    /**\n     * @notice Set the auction reserve price.\n     * @dev Only callable by the owner.\n     */\n    function setReservePrice(uint256 _reservePrice) external override onlyOwner {\n        reservePrice = _reservePrice;\n\n        emit AuctionReservePriceUpdated(_reservePrice);\n    }\n\n    /**\n     * @notice Set the auction minimum bid increment percentage.\n     * @dev Only callable by the owner.\n     */\n    function setMinBidIncrementPercentage(uint8 _minBidIncrementPercentage) external override onlyOwner {\n        minBidIncrementPercentage = _minBidIncrementPercentage;\n\n        emit AuctionMinBidIncrementPercentageUpdated(_minBidIncrementPercentage);\n    }\n\n    /**\n     * @notice Create an auction.\n     * @dev Store the auction details in the `auction` state variable and emit an AuctionCreated event.\n     * If the mint reverts, the minter was updated without pausing this contract first. To remedy this,\n     * catch the revert and pause this contract.\n     */\n    function _createAuction() internal {\n        // Check if there's enough gas to safely execute token.mint() and subsequent operations\n        require(gasleft() >= MIN_TOKEN_MINT_GAS_THRESHOLD, \"Insufficient gas for creating auction\");\n\n        try verbs.mint() returns (uint256 verbId) {\n            uint256 startTime = block.timestamp;\n            uint256 endTime = startTime + duration;\n\n            auction = Auction({\n                verbId: verbId,\n                amount: 0,\n                startTime: startTime,\n                endTime: endTime,\n                bidder: payable(0),\n                settled: false\n            });\n\n            emit AuctionCreated(verbId, startTime, endTime);\n        } catch {\n            _pause();\n        }\n    }\n\n    /**\n     * @notice Settle an auction, finalizing the bid and paying out to the owner. Pays out to the creator and the owner based on the creatorRateBps and entropyRateBps.\n     * @dev If there are no bids, the Verb is burned.\n     */\n    function _settleAuction() internal {\n        IAuctionHouse.Auction memory _auction = auction;\n\n        require(_auction.startTime != 0, \"Auction hasn't begun\");\n        require(!_auction.settled, \"Auction has already been settled\");\n        //slither-disable-next-line timestamp\n        require(block.timestamp >= _auction.endTime, \"Auction hasn't completed\");\n\n        auction.settled = true;\n\n        uint256 creatorTokensEmitted = 0;\n        // Check if contract balance is greater than reserve price\n        if (address(this).balance < reservePrice) {\n            // If contract balance is less than reserve price, refund to the last bidder\n            if (_auction.bidder != address(0)) {\n                _safeTransferETHWithFallback(_auction.bidder, _auction.amount);\n            }\n\n            // And then burn the Noun\n            verbs.burn(_auction.verbId);\n        } else {\n            //If no one has bid, burn the Verb\n            if (_auction.bidder == address(0))\n                verbs.burn(_auction.verbId);\n                //If someone has bid, transfer the Verb to the winning bidder\n            else verbs.transferFrom(address(this), _auction.bidder, _auction.verbId);\n\n            if (_auction.amount > 0) {\n                // Ether going to owner of the auction\n                uint256 auctioneerPayment = (_auction.amount * (10_000 - creatorRateBps)) / 10_000;\n\n                //Total amount of ether going to creator\n                uint256 creatorsShare = _auction.amount - auctioneerPayment;\n\n                uint256 numCreators = verbs.getArtPieceById(_auction.verbId).creators.length;\n                address deployer = verbs.getArtPieceById(_auction.verbId).sponsor;\n\n                //Build arrays for erc20TokenEmitter.buyToken\n                uint256[] memory vrgdaSplits = new uint256[](numCreators);\n                address[] memory vrgdaReceivers = new address[](numCreators);\n\n                //Transfer auction amount to the DAO treasury\n                _safeTransferETHWithFallback(owner(), auctioneerPayment);\n\n                uint256 ethPaidToCreators = 0;\n\n                //Transfer creator's share to the creator, for each creator, and build arrays for erc20TokenEmitter.buyToken\n                if (creatorsShare > 0 && entropyRateBps > 0) {\n                    for (uint256 i = 0; i < numCreators; i++) {\n                        ICultureIndex.CreatorBps memory creator = verbs.getArtPieceById(_auction.verbId).creators[i];\n                        vrgdaReceivers[i] = creator.creator;\n                        vrgdaSplits[i] = creator.bps;\n\n                        //Calculate paymentAmount for specific creator based on BPS splits - same as multiplying by creatorDirectPayment\n                        uint256 paymentAmount = (creatorsShare * entropyRateBps * creator.bps) / (10_000 * 10_000);\n                        ethPaidToCreators += paymentAmount;\n\n                        //Transfer creator's share to the creator\n                        _safeTransferETHWithFallback(creator.creator, paymentAmount);\n                    }\n                }\n\n                //Buy token from ERC20TokenEmitter for all the creators\n                if (creatorsShare > ethPaidToCreators) {\n                    creatorTokensEmitted = erc20TokenEmitter.buyToken{ value: creatorsShare - ethPaidToCreators }(\n                        vrgdaReceivers,\n                        vrgdaSplits,\n                        IERC20TokenEmitter.ProtocolRewardAddresses({\n                            builder: address(0),\n                            purchaseReferral: address(0),\n                            deployer: deployer\n                        })\n                    );\n                }\n            }\n        }\n\n        emit AuctionSettled(_auction.verbId, _auction.bidder, _auction.amount, creatorTokensEmitted);\n    }\n\n    /// @notice Transfer ETH/WETH from the contract\n    /// @param _to The recipient address\n    /// @param _amount The amount transferring\n    function _safeTransferETHWithFallback(address _to, uint256 _amount) private {\n        // Ensure the contract has enough ETH to transfer\n        if (address(this).balance < _amount) revert(\"Insufficient balance\");\n\n        // Used to store if the transfer succeeded\n        bool success;\n\n        assembly {\n            // Transfer ETH to the recipient\n            // Limit the call to 50,000 gas\n            success := call(50000, _to, _amount, 0, 0, 0, 0)\n        }\n\n        // If the transfer failed:\n        if (!success) {\n            // Wrap as WETH\n            IWETH(WETH).deposit{ value: _amount }();\n\n            // Transfer WETH instead\n            bool wethSuccess = IWETH(WETH).transfer(_to, _amount);\n\n            // Ensure successful transfer\n            if (!wethSuccess) revert(\"WETH transfer failed\");\n        }\n    }\n\n    ///                                                          ///\n    ///                        AUCTION UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner whenPaused {\n        // Ensure the new implementation is registered by the Builder DAO\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/AuctionHouse.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The Verbs DAO auction house\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// AuctionHouse.sol is a modified version of Zora's AuctionHouse.sol:\n// https://github.com/ourzora/auction-house/blob/54a12ec1a6cf562e49f0a4917990474b11350a2d/contracts/AuctionHouse.sol\n//\n// AuctionHouse.sol source code Copyright Zora licensed under the GPL-3.0 license.\n\npragma solidity ^0.8.22;\n\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IAuctionHouse } from \"./interfaces/IAuctionHouse.sol\";\nimport { IVerbsToken } from \"./interfaces/IVerbsToken.sol\";\nimport { IWETH } from \"./interfaces/IWETH.sol\";\nimport { IERC20TokenEmitter } from \"./interfaces/IERC20TokenEmitter.sol\";\nimport { ICultureIndex } from \"./interfaces/ICultureIndex.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\ncontract AuctionHouse is\n    IAuctionHouse,\n    VersionedContract,\n    UUPS,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    Ownable2StepUpgradeable\n{\n    // The Verbs ERC721 token contract\n    IVerbsToken public verbs;\n\n    // The ERC20 governance token\n    IERC20TokenEmitter public erc20TokenEmitter;\n\n    // The address of the WETH contract\n    address public WETH;\n\n    // The minimum amount of time left in an auction after a new bid is created\n    uint256 public timeBuffer;\n\n    // The minimum price accepted in an auction\n    uint256 public reservePrice;\n\n    // The minimum percentage difference between the last bid amount and the current bid\n    uint8 public minBidIncrementPercentage;\n\n    // The split of the winning bid that is reserved for the creator of the Verb in basis points\n    uint256 public creatorRateBps;\n\n    // The all time minimum split of the winning bid that is reserved for the creator of the Verb in basis points\n    uint256 public minCreatorRateBps;\n\n    // The split of (auction proceeds * creatorRate) that is sent to the creator as ether in basis points\n    uint256 public entropyRateBps;\n\n    // The duration of a single auction\n    uint256 public duration;\n\n    // The active auction\n    IAuctionHouse.Auction public auction;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder public immutable manager;\n\n    // TODO investigate this - The minimum gas threshold for creating an auction (minting VerbsToken)\n    uint32 public constant MIN_TOKEN_MINT_GAS_THRESHOLD = 750_000;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initialize the auction house and base contracts,\n     * populate configuration values, and pause the contract.\n     * @dev This function can only be called once.\n     * @param _erc721Token The address of the Verbs ERC721 token contract.\n     * @param _erc20TokenEmitter The address of the ERC-20 token emitter contract.\n     * @param _initialOwner The address of the owner.\n     * @param _weth The address of the WETH contract\n     * @param _auctionParams The auction params for auctions.\n     */\n    function initialize(\n        address _erc721Token,\n        address _erc20TokenEmitter,\n        address _initialOwner,\n        address _weth,\n        IRevolutionBuilder.AuctionParams calldata _auctionParams\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n        require(_weth != address(0), \"WETH cannot be zero address\");\n\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init(_initialOwner);\n\n        _pause();\n\n        require(\n            _auctionParams.creatorRateBps >= _auctionParams.minCreatorRateBps,\n            \"Creator rate must be greater than or equal to the creator rate\"\n        );\n\n        verbs = IVerbsToken(_erc721Token);\n        erc20TokenEmitter = IERC20TokenEmitter(_erc20TokenEmitter);\n        timeBuffer = _auctionParams.timeBuffer;\n        reservePrice = _auctionParams.reservePrice;\n        minBidIncrementPercentage = _auctionParams.minBidIncrementPercentage;\n        duration = _auctionParams.duration;\n        creatorRateBps = _auctionParams.creatorRateBps;\n        entropyRateBps = _auctionParams.entropyRateBps;\n        minCreatorRateBps = _auctionParams.minCreatorRateBps;\n        WETH = _weth;\n    }\n\n    /**\n     * @notice Settle the current auction, mint a new Verb, and put it up for auction.\n     */\n    // Can technically reenter via cross function reentrancies in _createAuction, auction, and pause, but those are only callable by the owner.\n    // @wardens if you can find an exploit here go for it - we might be wrong.\n    // slither-disable-next-line reentrancy-eth\n    function settleCurrentAndCreateNewAuction() external override nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /**\n     * @notice Settle the current auction.\n     * @dev This function can only be called when the contract is paused.\n     */\n    function settleAuction() external override whenPaused nonReentrant {\n        _settleAuction();\n    }\n\n    /**\n     * @notice Create a bid for a Verb, with a given amount.\n     * @dev This contract only accepts payment in ETH.\n     * @param verbId The ID of the Verb to bid on.\n     * @param bidder The address of the bidder.\n     */\n    function createBid(uint256 verbId, address bidder) external payable override nonReentrant {\n        IAuctionHouse.Auction memory _auction = auction;\n\n        //require bidder is valid address\n        require(bidder != address(0), \"Bidder cannot be zero address\");\n        require(_auction.verbId == verbId, \"Verb not up for auction\");\n        //slither-disable-next-line timestamp\n        require(block.timestamp < _auction.endTime, \"Auction expired\");\n        require(msg.value >= reservePrice, \"Must send at least reservePrice\");\n        require(\n            msg.value >= _auction.amount + ((_auction.amount * minBidIncrementPercentage) / 100),\n            \"Must send more than last bid by minBidIncrementPercentage amount\"\n        );\n\n        address payable lastBidder = _auction.bidder;\n\n        auction.amount = msg.value;\n        auction.bidder = payable(bidder);\n\n        // Extend the auction if the bid was received within `timeBuffer` of the auction end time\n        bool extended = _auction.endTime - block.timestamp < timeBuffer;\n        if (extended) auction.endTime = _auction.endTime = block.timestamp + timeBuffer;\n\n        // Refund the last bidder, if applicable\n        if (lastBidder != address(0)) _safeTransferETHWithFallback(lastBidder, _auction.amount);\n\n        emit AuctionBid(_auction.verbId, bidder, msg.sender, msg.value, extended);\n\n        if (extended) emit AuctionExtended(_auction.verbId, _auction.endTime);\n    }\n\n    /**\n     * @notice Pause the Verbs auction house.\n     * @dev This function can only be called by the owner when the\n     * contract is unpaused. While no new auctions can be started when paused,\n     * anyone can settle an ongoing auction.\n     */\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Set the split of the winning bid that is reserved for the creator of the Verb in basis points.\n     * @dev Only callable by the owner.\n     * @param _creatorRateBps New creator rate in basis points.\n     */\n    function setCreatorRateBps(uint256 _creatorRateBps) external onlyOwner {\n        require(\n            _creatorRateBps >= minCreatorRateBps,\n            \"Creator rate must be greater than or equal to minCreatorRateBps\"\n        );\n        require(_creatorRateBps <= 10_000, \"Creator rate must be less than or equal to 10_000\");\n        creatorRateBps = _creatorRateBps;\n\n        emit CreatorRateBpsUpdated(_creatorRateBps);\n    }\n\n    /**\n     * @notice Set the minimum split of the winning bid that is reserved for the creator of the Verb in basis points.\n     * @dev Only callable by the owner.\n     * @param _minCreatorRateBps New minimum creator rate in basis points.\n     */\n    function setMinCreatorRateBps(uint256 _minCreatorRateBps) external onlyOwner {\n        require(_minCreatorRateBps <= creatorRateBps, \"Min creator rate must be less than or equal to creator rate\");\n        require(_minCreatorRateBps <= 10_000, \"Min creator rate must be less than or equal to 10_000\");\n\n        //ensure new min rate cannot be lower than previous min rate\n        require(\n            _minCreatorRateBps > minCreatorRateBps,\n            \"Min creator rate must be greater than previous minCreatorRateBps\"\n        );\n\n        minCreatorRateBps = _minCreatorRateBps;\n\n        emit MinCreatorRateBpsUpdated(_minCreatorRateBps);\n    }\n\n    /**\n     * @notice Set the split of (auction proceeds * creatorRate) that is sent to the creator as ether in basis points.\n     * @dev Only callable by the owner.\n     * @param _entropyRateBps New entropy rate in basis points.\n     */\n    function setEntropyRateBps(uint256 _entropyRateBps) external onlyOwner {\n        require(_entropyRateBps <= 10_000, \"Entropy rate must be less than or equal to 10_000\");\n\n        entropyRateBps = _entropyRateBps;\n        emit EntropyRateBpsUpdated(_entropyRateBps);\n    }\n\n    /**\n     * @notice Unpause the Verbs auction house.\n     * @dev This function can only be called by the owner when the\n     * contract is paused. If required, this function will start a new auction.\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n\n        if (auction.startTime == 0 || auction.settled) {\n            _createAuction();\n        }\n    }\n\n    /**\n     * @notice Set the auction time buffer.\n     * @dev Only callable by the owner.\n     */\n    function setTimeBuffer(uint256 _timeBuffer) external override onlyOwner {\n        timeBuffer = _timeBuffer;\n\n        emit AuctionTimeBufferUpdated(_timeBuffer);\n    }\n\n    /**\n     * @notice Set the auction reserve price.\n     * @dev Only callable by the owner.\n     */\n    function setReservePrice(uint256 _reservePrice) external override onlyOwner {\n        reservePrice = _reservePrice;\n\n        emit AuctionReservePriceUpdated(_reservePrice);\n    }\n\n    /**\n     * @notice Set the auction minimum bid increment percentage.\n     * @dev Only callable by the owner.\n     */\n    function setMinBidIncrementPercentage(uint8 _minBidIncrementPercentage) external override onlyOwner {\n        minBidIncrementPercentage = _minBidIncrementPercentage;\n\n        emit AuctionMinBidIncrementPercentageUpdated(_minBidIncrementPercentage);\n    }\n\n    /**\n     * @notice Create an auction.\n     * @dev Store the auction details in the `auction` state variable and emit an AuctionCreated event.\n     * If the mint reverts, the minter was updated without pausing this contract first. To remedy this,\n     * catch the revert and pause this contract.\n     */\n    function _createAuction() internal {\n        // Check if there's enough gas to safely execute token.mint() and subsequent operations\n        require(gasleft() >= MIN_TOKEN_MINT_GAS_THRESHOLD, \"Insufficient gas for creating auction\");\n\n        try verbs.mint() returns (uint256 verbId) {\n            uint256 startTime = block.timestamp;\n            uint256 endTime = startTime + duration;\n\n            auction = Auction({\n                verbId: verbId,\n                amount: 0,\n                startTime: startTime,\n                endTime: endTime,\n                bidder: payable(0),\n                settled: false\n            });\n\n            emit AuctionCreated(verbId, startTime, endTime);\n        } catch {\n            _pause();\n        }\n    }\n\n    /**\n     * @notice Settle an auction, finalizing the bid and paying out to the owner. Pays out to the creator and the owner based on the creatorRateBps and entropyRateBps.\n     * @dev If there are no bids, the Verb is burned.\n     */\n    function _settleAuction() internal {\n        IAuctionHouse.Auction memory _auction = auction;\n\n        require(_auction.startTime != 0, \"Auction hasn't begun\");\n        require(!_auction.settled, \"Auction has already been settled\");\n        //slither-disable-next-line timestamp\n        require(block.timestamp >= _auction.endTime, \"Auction hasn't completed\");\n\n        auction.settled = true;\n\n        uint256 creatorTokensEmitted = 0;\n        // Check if contract balance is greater than reserve price\n        if (address(this).balance < reservePrice) {\n            // If contract balance is less than reserve price, refund to the last bidder"
    }
  ]
}