{
  "Title": "M-4: Native funds can be lost by submit() as msg.value isn't synchronized with amount",
  "Content": "# Issue M-4: Native funds can be lost by submit() as msg.value isn't synchronized with amount \n\nSource: https://github.com/sherlock-audit/2022-11-telcoin-judging/issues/76 \n\n## Found by \nhyh\n\n## Summary\n\nWhen used with native funds FeeBuyback#submit() doesn't check for the `amount` argument to correspond to `msg.value` actually linked to the call. \n\n## Vulnerability Detail\n\nThis can lead either to bloating or to underpaying of the actual fee depending on the mechanics that will be used to call submit(). I.e. as two values can differ, and only one can be correct, the difference is a fund loss either to the `owner` (when the fee is overpaid) or to `recipient` (when the fee is underpaid vs correct formula).\n\n## Impact\n\nNet impact is a fund loss proportional to the difference of the `amount` and `msg.value`. This can be either incomplete setup (native funds case isn't fully covered in a calling script) or an operational mistake (it is covered correctly, but a wrong value was occasionally left from a testing, and so on) situation.\n\nSetting the severity to be medium as this is conditional on the actual usage of submit().\n\n## Code Snippet\n\nsubmit() uses `msg.value`, which can differ from `amount`:\n\nhttps://github.com/sherlock-audit/2022-11-telcoin/blob/main/contracts/fee-buyback/FeeBuyback.sol#L35-L82\n\n```solidity\n  /**\n   * @notice submits wallet transactions\n   * @dev a secondary swap may occur\n   * @dev staking contract updates may be made\n   * @dev function can be paused\n   * @param wallet address of the primary transaction\n   * @param walletData bytes wallet data for primary transaction\n   * @param token address the token that is being swapped from in a secondary transaction\n   * @param amount uint256 the quantity of the token being swapped\n   * @param swapData bytes swap data from primary transaction\n   * @return boolean representing if a referral transaction was made\n   */\n  function submit(address wallet, bytes memory walletData, address token, address recipient, uint256 amount, bytes memory swapData) external override payable onlyOwner() returns (bool) {\n    //Perform user swap first\n    ...\n\n    //check if this is a referral transaction\n    //if not exit execution\n    if (token == address(0) || recipient == address(0) || amount == 0 ) {\n      return false;\n    }\n\n    //if swapped token is in TEL, no swap is necessary\n    //do simple transfer from and submit\n    if (token == address(_telcoin)) {\n      ...\n    }\n\n    //MATIC does not allow for approvals\n    //ERC20s only\n    if (token != MATIC) {\n      IERC20(token).transferFrom(_safe, address(this), amount);\n      IERC20(token).approve(_aggregator, amount);\n    }\n\n    //Perform secondary swap from fee token to TEL\n    //do simple transfer from and submit\n    (bool swapResult,) = _aggregator.call{value: msg.value}(swapData);\n    require(swapResult, \"FeeBuyback: swap transaction failed\");\n    _telcoin.approve(address(_referral), _telcoin.balanceOf(address(this)));\n    require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n    return true;\n  }\n```\n\nI.e. the funds in the native case aren't checked (can be zero, can be 100x of the fee needed), provided `amount` is just ignored.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn order to maintain the uniform approach consider requiring that `amount` does exactly correspond to `msg.value`, when MATIC is used, for example:\n\nhttps://github.com/sherlock-audit/2022-11-telcoin/blob/main/contracts/fee-buyback/FeeBuyback.sol#L68-L73\n\n```solidity\n    //MATIC does not allow for approvals\n    //ERC20s only\n    if (token != MATIC) {\n      IERC20(token).transferFrom(_safe, address(this), amount);\n      IERC20(token).approve(_aggregator, amount);\n+   } else {\n+     require(amount == msg.value, \"FeeBuyback: wrong amount\");    \n    }\n```\n\n## Discussion\n\n**amshirif**\n\nhttps://github.com/telcoin/telcoin-staking/pull/10\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/25",
  "Code": [
    {
      "filename": "contracts/fee-buyback/FeeBuyback.sol",
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.0;\n\n//imports\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./TieredOwnership.sol\";\nimport \"./IFeeBuyback.sol\";\nimport \"./ISimplePlugin.sol\";\n\n/**\n * @title FeeBuyback\n * @author Amir Shirif, Telcoin, LLC.\n * @notice Helps facilitate a secondary swap, if required, to allow the referrer of a user to receive a fraction of the generated transaction fee, based on the stake of the referrer.\n */\ncontract FeeBuyback is IFeeBuyback, TieredOwnership {\n  //MATIC address\n  address constant public MATIC = 0x0000000000000000000000000000000000001010;\n  //1 inch aggregator address\n  address immutable public _aggregator;\n  //location of fee rewards\n  address immutable public _safe;\n  //reward token\n  IERC20 immutable public _telcoin;\n  //destination of rewards\n  ISimplePlugin immutable public _referral;\n\n  //constructor\n  constructor(address aggregator_, address safe_, IERC20 telcoin_, ISimplePlugin referral_) TieredOwnership() {\n    _aggregator = aggregator_;\n    _safe = safe_;\n    _telcoin = telcoin_;\n    _referral = referral_;\n  }\n\n  /**\n   * @notice submits wallet transactions\n   * @dev a secondary swap may occur\n   * @dev staking contract updates may be made\n   * @dev function can be paused\n   * @param wallet address of the primary transaction\n   * @param walletData bytes wallet data for primary transaction\n   * @param token address the token that is being swapped from in a secondary transaction\n   * @param amount uint256 the quantity of the token being swapped\n   * @param swapData bytes swap data from primary transaction\n   * @return boolean representing if a referral transaction was made\n   */\n  function submit(address wallet, bytes memory walletData, address token, address recipient, uint256 amount, bytes memory swapData) external override payable onlyOwner() returns (bool) {\n    //Perform user swap first\n    //Verify success\n    (bool walletResult,) = wallet.call{value: 0}(walletData);\n    require(walletResult, \"FeeBuyback: wallet transaction failed\");\n\n    //check if this is a referral transaction\n    //if not exit execution\n    if (token == address(0) || recipient == address(0) || amount == 0 ) {\n      return false;\n    }\n\n    //if swapped token is in TEL, no swap is necessary\n    //do simple transfer from and submit\n    if (token == address(_telcoin)) {\n      _telcoin.transferFrom(_safe, address(this), amount);\n      _telcoin.approve(address(_referral), _telcoin.balanceOf(address(this)));\n      require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n      return true;\n    }\n\n    //MATIC does not allow for approvals\n    //ERC20s only\n    if (token != MATIC) {\n      IERC20(token).transferFrom(_safe, address(this), amount);\n      IERC20(token).approve(_aggregator, amount);\n    }\n\n    //Perform secondary swap from fee token to TEL\n    //do simple transfer from and submit\n    (bool swapResult,) = _aggregator.call{value: msg.value}(swapData);\n    require(swapResult, \"FeeBuyback: swap transaction failed\");\n    _telcoin.approve(address(_referral), _telcoin.balanceOf(address(this)));\n    require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n    return true;\n  }\n\n  /**\n  * @notice Sends ERC20 tokens trapped in contract to external address\n  * @dev Only an owner is allowed to make this function call\n  * @param account is the receiving address\n  * @param externalToken is the token being sent\n  * @param amount is the quantity being sent\n  * @return boolean value indicating whether the operation succeeded.\n  *\n  * Emits a {Transfer} event.\n  */\n  function rescueERC20(address account, address externalToken, uint256 amount) public onlyExecutor() returns (bool) {\n    IERC20(externalToken).transfer(account, amount);\n    return true;\n  }\n}"
    },
    {
      "filename": "contracts/fee-buyback/FeeBuyback.sol",
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.0;\n\n//imports\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./TieredOwnership.sol\";\nimport \"./IFeeBuyback.sol\";\nimport \"./ISimplePlugin.sol\";\n\n/**\n * @title FeeBuyback\n * @author Amir Shirif, Telcoin, LLC.\n * @notice Helps facilitate a secondary swap, if required, to allow the referrer of a user to receive a fraction of the generated transaction fee, based on the stake of the referrer.\n */\ncontract FeeBuyback is IFeeBuyback, TieredOwnership {\n  //MATIC address\n  address constant public MATIC = 0x0000000000000000000000000000000000001010;\n  //1 inch aggregator address\n  address immutable public _aggregator;\n  //location of fee rewards\n  address immutable public _safe;\n  //reward token\n  IERC20 immutable public _telcoin;\n  //destination of rewards\n  ISimplePlugin immutable public _referral;\n\n  //constructor\n  constructor(address aggregator_, address safe_, IERC20 telcoin_, ISimplePlugin referral_) TieredOwnership() {\n    _aggregator = aggregator_;\n    _safe = safe_;\n    _telcoin = telcoin_;\n    _referral = referral_;\n  }\n\n  /**\n   * @notice submits wallet transactions\n   * @dev a secondary swap may occur\n   * @dev staking contract updates may be made\n   * @dev function can be paused\n   * @param wallet address of the primary transaction\n   * @param walletData bytes wallet data for primary transaction\n   * @param token address the token that is being swapped from in a secondary transaction\n   * @param amount uint256 the quantity of the token being swapped\n   * @param swapData bytes swap data from primary transaction\n   * @return boolean representing if a referral transaction was made\n   */\n  function submit(address wallet, bytes memory walletData, address token, address recipient, uint256 amount, bytes memory swapData) external override payable onlyOwner() returns (bool) {\n    //Perform user swap first\n    //Verify success\n    (bool walletResult,) = wallet.call{value: 0}(walletData);\n    require(walletResult, \"FeeBuyback: wallet transaction failed\");\n\n    //check if this is a referral transaction\n    //if not exit execution\n    if (token == address(0) || recipient == address(0) || amount == 0 ) {\n      return false;\n    }\n\n    //if swapped token is in TEL, no swap is necessary\n    //do simple transfer from and submit\n    if (token == address(_telcoin)) {\n      _telcoin.transferFrom(_safe, address(this), amount);\n      _telcoin.approve(address(_referral), _telcoin.balanceOf(address(this)));\n      require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n      return true;\n    }\n\n    //MATIC does not allow for approvals\n    //ERC20s only\n    if (token != MATIC) {\n      IERC20(token).transferFrom(_safe, address(this), amount);\n      IERC20(token).approve(_aggregator, amount);\n    }\n\n    //Perform secondary swap from fee token to TEL\n    //do simple transfer from and submit\n    (bool swapResult,) = _aggregator.call{value: msg.value}(swapData);\n    require(swapResult, \"FeeBuyback: swap transaction failed\");\n    _telcoin.approve(address(_referral), _telcoin.balanceOf(address(this)));\n    require(_referral.increaseClaimableBy(recipient, _telcoin.balanceOf(address(this))), \"FeeBuyback: balance was not adjusted\");\n    return true;\n  }\n\n  /**\n  * @notice Sends ERC20 tokens trapped in contract to external address\n  * @dev Only an owner is allowed to make this function call\n  * @param account is the receiving address\n  * @param externalToken is the token being sent\n  * @param amount is the quantity being sent\n  * @return boolean value indicating whether the operation succeeded.\n  *\n  * Emits a {Transfer} event.\n  */\n  function rescueERC20(address account, address externalToken, uint256 amount) public onlyExecutor() returns (bool) {\n    IERC20(externalToken).transfer(account, amount);\n    return true;\n  }\n}"
    }
  ]
}