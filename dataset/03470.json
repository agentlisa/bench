{
  "Title": "[L01] Cannot settle at expiration",
  "Content": "The `settle` function of the `LongShortPair` contract [considers settlement conditions](https://github.com/UMAprotocol/protocol/blob/d4e7ea22159b2eed8e39d5b86ce0026ea3b8b995/packages/core/contracts/financial-templates/long-short-pair/LongShortPair.sol#L233-L234) when the current time is strictly before or after the expiration timestamp. However, it incorrectly reverts when the current time matches the expiration timestamp.\n\n\nConsider using an inclusive bound to match the [`postExpiration` modifier](https://github.com/UMAprotocol/protocol/blob/d4e7ea22159b2eed8e39d5b86ce0026ea3b8b995/packages/core/contracts/financial-templates/long-short-pair/LongShortPair.sol#L105-L108).\n\n\n**Update:** *Fixed in commit [`f03cdaa50b16d29e8f42f000bf7cd50a042cf616`](https://github.com/UMAprotocol/protocol/pull/3527/commits/f03cdaa50b16d29e8f42f000bf7cd50a042cf616) in [PR3527](https://github.com/UMAprotocol/protocol/pull/3527).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/financial-templates/long-short-pair/LongShortPair.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../common/financial-product-libraries/long-short-pair-libraries/LongShortPairFinancialProductLibrary.sol\";\n\nimport \"../../common/implementation/AncillaryData.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\n\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\n\nimport \"../../oracle/interfaces/OracleInterface.sol\";\nimport \"../../common/interfaces/AddressWhitelistInterface.sol\";\nimport \"../../oracle/interfaces/FinderInterface.sol\";\nimport \"../../oracle/interfaces/OptimisticOracleInterface.sol\";\nimport \"../../oracle/interfaces/IdentifierWhitelistInterface.sol\";\n\nimport \"../../oracle/implementation/Constants.sol\";\n\n/**\n * @title Long Short Pair.\n * @notice Uses a combination of long and short tokens to tokenize the bounded price exposure to a given identifier.\n */\n\ncontract LongShortPair is Testable, Lockable {\n    using FixedPoint for FixedPoint.Unsigned;\n    using SafeERC20 for IERC20;\n\n    /*************************************\n     *  LONG SHORT PAIR DATA STRUCTURES  *\n     *************************************/\n\n    // Define the contract's constructor parameters as a struct to enable more variables to be specified.\n    struct ConstructorParams {\n        string pairName; // Name of the long short pair contract.\n        uint64 expirationTimestamp; // Unix timestamp of when the contract will expire.\n        uint256 collateralPerPair; // How many units of collateral are required to mint one pair of synthetic tokens.\n        bytes32 priceIdentifier; // Price identifier, registered in the DVM for the long short pair.\n        bool enableEarlyExpiration; // Enables the LSP contract to be settled early.\n        ExpandedIERC20 longToken; // Token used as long in the LSP. Mint and burn rights needed by this contract.\n        ExpandedIERC20 shortToken; // Token used as short in the LSP. Mint and burn rights needed by this contract.\n        IERC20 collateralToken; // Collateral token used to back LSP synthetics.\n        LongShortPairFinancialProductLibrary financialProductLibrary; // Contract providing settlement payout logic.\n        bytes customAncillaryData; // Custom ancillary data to be passed along with the price request to the OO.\n        uint256 proposerReward; // Optimistic oracle reward amount, pulled from the caller of the expire function.\n        uint256 optimisticOracleLivenessTime; // OO liveness time for price requests.\n        uint256 optimisticOracleProposerBond; // OO proposer bond for price requests.\n        FinderInterface finder; // DVM finder to find other UMA ecosystem contracts.\n        address timerAddress; // Timer used to synchronize contract time in testing. Set to 0x000... in production.\n    }\n\n    bool public receivedSettlementPrice;\n\n    bool public enableEarlyExpiration; // If set, the LSP contract can request to be settled early by calling the OO.\n    uint64 public expirationTimestamp;\n    uint64 public earlyExpirationTimestamp; // Set in the case the contract is expired early.\n    string public pairName;\n    uint256 public collateralPerPair; // Amount of collateral a pair of tokens is always redeemable for.\n\n    // Number between 0 and 1e18 to allocate collateral between long & short tokens at redemption. 0 entitles each short\n    // to collateralPerPair and each long to 0. 1e18 makes each long worth collateralPerPair and short 0.\n    uint256 public expiryPercentLong;\n    bytes32 public priceIdentifier;\n\n    // Price returned from the Optimistic oracle at settlement time.\n    int256 public expiryPrice;\n\n    // External contract interfaces.\n    IERC20 public collateralToken;\n    ExpandedIERC20 public longToken;\n    ExpandedIERC20 public shortToken;\n    FinderInterface public finder;\n    LongShortPairFinancialProductLibrary public financialProductLibrary;\n\n    // Optimistic oracle customization parameters.\n    bytes public customAncillaryData;\n    uint256 public proposerReward;\n    uint256 public optimisticOracleLivenessTime;\n    uint256 public optimisticOracleProposerBond;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event TokensCreated(address indexed sponsor, uint256 indexed collateralUsed, uint256 indexed tokensMinted);\n    event TokensRedeemed(address indexed sponsor, uint256 indexed collateralReturned, uint256 indexed tokensRedeemed);\n    event ContractExpired(address indexed caller);\n    event EarlyExpirationRequested(address indexed caller, uint64 earlyExpirationTimeStamp);\n    event PositionSettled(address indexed sponsor, uint256 collateralReturned, uint256 longTokens, uint256 shortTokens);\n\n    /****************************************\n     *               MODIFIERS              *\n     ****************************************/\n\n    modifier preExpiration() {\n        require(getCurrentTime() < expirationTimestamp, \"Only callable pre-expiry\");\n        _;\n    }\n\n    modifier postExpiration() {\n        require(getCurrentTime() >= expirationTimestamp, \"Only callable post-expiry\");\n        _;\n    }\n\n    modifier notEarlyExpired() {\n        require(!isContractEarlyExpired(), \"Contract already early expired\");\n        _;\n    }\n\n    /**\n     * @notice Construct the LongShortPair\n     * @param params Constructor params used to initialize the LSP. Key-valued object with the following structure:\n     *    - `pairName`: Name of the long short pair contract.\n     *    - `expirationTimestamp`: Unix timestamp of when the contract will expire.\n     *    - `collateralPerPair`: How many units of collateral are required to mint one pair of synthetic tokens.\n     *    - `priceIdentifier`: Price identifier, registered in the DVM for the long short pair.\n     *    - `longToken`: Token used as long in the LSP. Mint and burn rights needed by this contract.\n     *    - `shortToken`: Token used as short in the LSP. Mint and burn rights needed by this contract.\n     *    - `collateralToken`: Collateral token used to back LSP synthetics.\n     *    - `financialProductLibrary`: Contract providing settlement payout logic.\n     *    - `customAncillaryData`: Custom ancillary data to be passed along with the price request to the OO.\n     *    - `proposerReward`: Preloaded reward to incentivize settlement price proposals.\n     *    - `optimisticOracleLivenessTime`: OO liveness time for price requests.\n     *    - `optimisticOracleProposerBond`: OO proposer bond for price requests.\n     *    - `finder`: DVM finder to find other UMA ecosystem contracts.\n     *    - `timerAddress`: Timer used to synchronize contract time in testing. Set to 0x000... in production.\n     */\n    constructor(ConstructorParams memory params) Testable(params.timerAddress) {\n        finder = params.finder;\n        require(bytes(params.pairName).length > 0, \"Pair name cant be empty\");\n        require(params.expirationTimestamp > getCurrentTime(), \"Expiration timestamp in past\");\n        require(params.collateralPerPair > 0, \"Collateral per pair cannot be 0\");\n        require(_getIdentifierWhitelist().isIdentifierSupported(params.priceIdentifier), \"Identifier not registered\");\n        require(address(_getOptimisticOracle()) != address(0), \"Invalid finder\");\n        require(address(params.financialProductLibrary) != address(0), \"Invalid FinancialProductLibrary\");\n        require(_getCollateralWhitelist().isOnWhitelist(address(params.collateralToken)), \"Collateral not whitelisted\");\n        require(params.optimisticOracleLivenessTime > 0, \"OO liveness cannot be 0\");\n        require(params.optimisticOracleLivenessTime < 5200 weeks, \"OO liveness too large\");\n\n        pairName = params.pairName;\n        expirationTimestamp = params.expirationTimestamp;\n        collateralPerPair = params.collateralPerPair;\n        priceIdentifier = params.priceIdentifier;\n        enableEarlyExpiration = params.enableEarlyExpiration;\n\n        longToken = params.longToken;\n        shortToken = params.shortToken;\n        collateralToken = params.collateralToken;\n\n        financialProductLibrary = params.financialProductLibrary;\n        OptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\n        require(\n            optimisticOracle.stampAncillaryData(params.customAncillaryData, address(this)).length <=\n                optimisticOracle.ancillaryBytesLimit(),\n            \"Ancillary Data too long\"\n        );\n\n        customAncillaryData = params.customAncillaryData;\n        proposerReward = params.proposerReward;\n        optimisticOracleLivenessTime = params.optimisticOracleLivenessTime;\n        optimisticOracleProposerBond = params.optimisticOracleProposerBond;\n    }\n\n    /****************************************\n     *          POSITION FUNCTIONS          *\n     ****************************************/\n\n    /**\n     * @notice Creates a pair of long and short tokens equal in number to tokensToCreate. Pulls the required collateral\n     * amount into this contract, defined by the collateralPerPair value.\n     * @dev The caller must approve this contract to transfer `tokensToCreate * collateralPerPair` amount of collateral.\n     * @param tokensToCreate number of long and short synthetic tokens to create.\n     * @return collateralUsed total collateral used to mint the synthetics.\n     */\n    function create(uint256 tokensToCreate) public preExpiration() nonReentrant() returns (uint256 collateralUsed) {\n        // Note the use of mulCeil to prevent small collateralPerPair causing rounding of collateralUsed to 0 enabling\n        // callers to mint dust LSP tokens without paying any collateral.\n        collateralUsed = FixedPoint.Unsigned(tokensToCreate).mulCeil(FixedPoint.Unsigned(collateralPerPair)).rawValue;\n\n        collateralToken.safeTransferFrom(msg.sender, address(this), collateralUsed);\n\n        require(longToken.mint(msg.sender, tokensToCreate));\n        require(shortToken.mint(msg.sender, tokensToCreate));\n\n        emit TokensCreated(msg.sender, collateralUsed, tokensToCreate);\n    }\n\n    /**\n     * @notice Redeems a pair of long and short tokens equal in number to tokensToRedeem. Returns the commensurate\n     * amount of collateral to the caller for the pair of tokens, defined by the collateralPerPair value.\n     * @dev This contract must have the `Burner` role for the `longToken` and `shortToken` in order to call `burnFrom`.\n     * @dev The caller does not need to approve this contract to transfer any amount of `tokensToRedeem` since long\n     * and short tokens are burned, rather than transferred, from the caller.\n     * @dev This method can be called either pre or post expiration.\n     * @param tokensToRedeem number of long and short synthetic tokens to redeem.\n     * @return collateralReturned total collateral returned in exchange for the pair of synthetics.\n     */\n    function redeem(uint256 tokensToRedeem) public nonReentrant() returns (uint256 collateralReturned) {\n        require(longToken.burnFrom(msg.sender, tokensToRedeem));\n        require(shortToken.burnFrom(msg.sender, tokensToRedeem));\n\n        collateralReturned = FixedPoint.Unsigned(tokensToRedeem).mul(FixedPoint.Unsigned(collateralPerPair)).rawValue;\n\n        collateralToken.safeTransfer(msg.sender, collateralReturned);\n\n        emit TokensRedeemed(msg.sender, collateralReturned, tokensToRedeem);\n    }\n\n    /**\n     * @notice Settle long and/or short tokens in for collateral at a rate informed by the contract settlement.\n     * @dev Uses financialProductLibrary to compute the redemption rate between long and short tokens.\n     * @dev This contract must have the `Burner` role for the `longToken` and `shortToken` in order to call `burnFrom`.\n     * @dev The caller does not need to approve this contract to transfer any amount of `tokensToRedeem` since long\n     * and short tokens are burned, rather than transferred, from the caller.\n     * @dev This function can be called before or after expiration method to facilitate early expiration. If a price has\n     * not yet been resolved for either normal or early expiration yet then it will revert.\n     * @param longTokensToRedeem number of long tokens to settle.\n     * @param shortTokensToRedeem number of short tokens to settle.\n     * @return collateralReturned total collateral returned in exchange for the pair of synthetics.\n     */\n    function settle(uint256 longTokensToRedeem, uint256 shortTokensToRedeem)\n        public\n        nonReentrant()\n        returns (uint256 collateralReturned)\n    {\n        // Either early expiration is enabled and its before the expiration timestamp or it is after the expiration time.\n        require(\n            (enableEarlyExpiration && getCurrentTime() < expirationTimestamp) || getCurrentTime() > expirationTimestamp,\n            \"Can not settle\"\n        );\n\n        // Get the settlement price and store it. Also sets expiryPercentLong to inform settlement. Reverts if either:\n        // a) the price request has not resolved (either a normal expiration call or early expiration call) or b) If the\n        // the contract was attempted to be settled early but the price returned is the ignore oracle price.\n        // Note that we use the bool receivedSettlementPrice over checking for price != 0 as 0 is a valid price.\n        if (!receivedSettlementPrice) getExpirationPrice();\n\n        require(longToken.burnFrom(msg.sender, longTokensToRedeem));\n        require(shortToken.burnFrom(msg.sender, shortTokensToRedeem));\n\n        // expiryPercentLong is a number between 0 and 1e18. 0 means all collateral goes to short tokens and 1e18 means\n        // all collateral goes to the long token. Total collateral returned is the sum of payouts.\n        uint256 longCollateralRedeemed =\n            FixedPoint\n                .Unsigned(longTokensToRedeem)\n                .mul(FixedPoint.Unsigned(collateralPerPair))\n                .mul(FixedPoint.Unsigned(expiryPercentLong))\n                .rawValue;\n        uint256 shortCollateralRedeemed =\n            FixedPoint\n                .Unsigned(shortTokensToRedeem)\n                .mul(FixedPoint.Unsigned(collateralPerPair))\n                .mul(FixedPoint.fromUnscaledUint(1).sub(FixedPoint.Unsigned(expiryPercentLong)))\n                .rawValue;\n\n        collateralReturned = longCollateralRedeemed + shortCollateralRedeemed;\n        collateralToken.safeTransfer(msg.sender, collateralReturned);\n\n        emit PositionSettled(msg.sender, collateralReturned, longTokensToRedeem, shortTokensToRedeem);\n    }\n\n    /****************************************\n     *        GLOBAL STATE FUNCTIONS        *\n     ****************************************/\n\n    /**\n     * @notice Enables the LSP to request early expiration. This initiates a price request to the optimistic oracle at\n     * the provided timestamp with a modified version of the ancillary data that includes the key \"earlyExpiration:1\"\n     * which signals to the OO that this is an early expiration request, rather than standard settlement.\n     * @dev Will revert if: a) the contract is already early expire, b) it is after the expiration timestamp, c)\n     * early expiration is disabled for this contract, d) the proposed expiration timestamp is in the future.\n     * e) an early expiration attempt has already been made (in pending state).\n     * @param _earlyExpirationTimestamp timestamp at which the early expiration is proposed.\n     */\n    function requestEarlyExpiration(uint64 _earlyExpirationTimestamp)\n        public\n        nonReentrant()\n        notEarlyExpired()\n        preExpiration()\n    {\n        require(enableEarlyExpiration, \"Early expiration disabled\");\n        require(_earlyExpirationTimestamp <= getCurrentTime(), \"Only propose expire in the past\");\n\n        earlyExpirationTimestamp = _earlyExpirationTimestamp;\n\n        _requestOraclePrice(earlyExpirationTimestamp, getEarlyExpirationAncillaryData());\n\n        emit EarlyExpirationRequested(msg.sender, _earlyExpirationTimestamp);\n    }\n\n    /**\n     * @notice Expire the LSP contract. Makes a request to the optimistic oracle to inform the settlement price.\n     * @dev Will revert if: a) the contract is already early expire, b) it is before the expiration timestamp or c)\n     * an expire call has already been made.\n     */\n    function expire() public nonReentrant() notEarlyExpired() postExpiration() {\n        _requestOraclePrice(expirationTimestamp, customAncillaryData);\n\n        emit ContractExpired(msg.sender);\n    }\n\n    /***********************************\n     *      GLOBAL VIEW FUNCTIONS      *\n     ***********************************/\n\n    /**\n     * @notice Returns the number of long and short tokens a sponsor wallet holds.\n     * @param sponsor address of the sponsor to query.\n     * @return longTokens the number of long tokens held by the sponsor.\n     * @return shortTokens the number of short tokens held by the sponsor.\n     */\n    function getPositionTokens(address sponsor)\n        public\n        view\n        nonReentrantView()\n        returns (uint256 longTokens, uint256 shortTokens)\n    {\n        return (longToken.balanceOf(sponsor), shortToken.balanceOf(sponsor));\n    }\n\n    /**\n     * @notice Generates a modified ancillary data that indicates the contract is being expired early.\n     */\n    function getEarlyExpirationAncillaryData() public view returns (bytes memory) {\n        return AncillaryData.appendKeyValueUint(customAncillaryData, \"earlyExpiration\", 1);\n    }\n\n    /**\n     * @notice Defines a special number that, if returned during an attempted early expiration, will cause the contract\n     * to do nothing and not expire. This enables the OO (and DVM voters in the case of a dispute) to choose to keep\n     * the contract running, thereby denying the early settlement request.\n     */\n    function ignoreEarlyExpirationPrice() public pure returns (int256) {\n        return type(int256).min;\n    }\n\n    /**\n     * @notice If the earlyExpirationTimestamp is != 0 then a previous early expiration OO request might still be in the\n     * pending state. Check if the OO contains the ignore early price. If it does not contain this then the contract\n     * was early expired correctly. Note that _getOraclePrice call will revert if the price request is still pending,\n     * thereby reverting all upstream calls pre-settlement of the early expiration price request.\n     */\n    function isContractEarlyExpired() public returns (bool) {\n        return (earlyExpirationTimestamp != 0 &&\n            _getOraclePrice(earlyExpirationTimestamp, getEarlyExpirationAncillaryData()) !=\n            ignoreEarlyExpirationPrice());\n    }\n\n    /****************************************\n     *          INTERNAL FUNCTIONS          *\n     ****************************************/\n\n    // Return the oracle price for a given request timestamp and ancillary data combo.\n    function _getOraclePrice(uint64 requestTimestamp, bytes memory requestAncillaryData) internal returns (int256) {\n        return _getOptimisticOracle().settleAndGetPrice(priceIdentifier, requestTimestamp, requestAncillaryData);\n    }\n\n    // Request a price in the optimistic oracle for a given request timestamp and ancillary data combo. Set the bonds\n    // accordingly to the deployer's parameters. Will revert if re-requesting for a previously requested combo.\n    function _requestOraclePrice(uint256 requestTimestamp, bytes memory requestAncillaryData) internal {\n        OptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\n\n        // If the proposer reward was set then pull it from the caller of the function.\n        if (proposerReward > 0) {\n            collateralToken.safeTransferFrom(msg.sender, address(this), proposerReward);\n            collateralToken.safeApprove(address(optimisticOracle), proposerReward);\n        }\n        optimisticOracle.requestPrice(\n            priceIdentifier,\n            requestTimestamp,\n            requestAncillaryData,\n            collateralToken,\n            proposerReward\n        );\n\n        // Set the Optimistic oracle liveness for the price request.\n        optimisticOracle.setCustomLiveness(\n            priceIdentifier,\n            requestTimestamp,\n            requestAncillaryData,\n            optimisticOracleLivenessTime\n        );\n\n        // Set the Optimistic oracle proposer bond for the price request.\n        optimisticOracle.setBond(priceIdentifier, requestTimestamp, requestAncillaryData, optimisticOracleProposerBond);\n    }\n\n    // Fetch the optimistic oracle expiration price. If the oracle has the price for the provided expiration timestamp\n    // and customData combo then return this. Else, try fetch the price on the early expiration ancillary data. If\n    // there is no price for either, revert. If the early expiration price is the ignore price will also revert.\n    function getExpirationPrice() internal {\n        if (_getOptimisticOracle().hasPrice(address(this), priceIdentifier, expirationTimestamp, customAncillaryData))\n            expiryPrice = _getOraclePrice(expirationTimestamp, customAncillaryData);\n        else {\n            expiryPrice = _getOraclePrice(earlyExpirationTimestamp, getEarlyExpirationAncillaryData());\n            require(expiryPrice != ignoreEarlyExpirationPrice(), \"Oracle prevents early expiration\");\n        }\n\n        // Finally, compute the value of expiryPercentLong based on the expiryPrice. Cap the return value at 1e18 as\n        // this should, by definition, between 0 and 1e18.\n        expiryPercentLong = Math.min(\n            financialProductLibrary.percentageLongCollateralAtExpiry(expiryPrice),\n            FixedPoint.fromUnscaledUint(1).rawValue\n        );\n\n        receivedSettlementPrice = true;\n    }\n\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\n    }\n\n    function _getCollateralWhitelist() internal view returns (AddressWhitelistInterface) {\n        return AddressWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\n    }\n\n    function _getOptimisticOracle() internal view returns (OptimisticOracleInterface) {\n        return OptimisticOracleInterface(finder.getImplementationAddress(OracleInterfaces.OptimisticOracle));\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/financial-templates/long-short-pair/LongShortPair.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../common/financial-product-libraries/long-short-pair-libraries/LongShortPairFinancialProductLibrary.sol\";\n\nimport \"../../common/implementation/AncillaryData.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/implementation/FixedPoint.sol\";\n\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\n\nimport \"../../oracle/interfaces/OracleInterface.sol\";\nimport \"../../common/interfaces/AddressWhitelistInterface.sol\";\nimport \"../../oracle/interfaces/FinderInterface.sol\";\nimport \"../../oracle/interfaces/OptimisticOracleInterface.sol\";\nimport \"../../oracle/interfaces/IdentifierWhitelistInterface.sol\";\n\nimport \"../../oracle/implementation/Constants.sol\";\n\n/**\n * @title Long Short Pair.\n * @notice Uses a combination of long and short tokens to tokenize the bounded price exposure to a given identifier.\n */\n\ncontract LongShortPair is Testable, Lockable {\n    using FixedPoint for FixedPoint.Unsigned;\n    using SafeERC20 for IERC20;\n\n    /*************************************\n     *  LONG SHORT PAIR DATA STRUCTURES  *\n     *************************************/\n\n    // Define the contract's constructor parameters as a struct to enable more variables to be specified.\n    struct ConstructorParams {\n        string pairName; // Name of the long short pair contract.\n        uint64 expirationTimestamp; // Unix timestamp of when the contract will expire.\n        uint256 collateralPerPair; // How many units of collateral are required to mint one pair of synthetic tokens.\n        bytes32 priceIdentifier; // Price identifier, registered in the DVM for the long short pair.\n        bool enableEarlyExpiration; // Enables the LSP contract to be settled early.\n        ExpandedIERC20 longToken; // Token used as long in the LSP. Mint and burn rights needed by this contract.\n        ExpandedIERC20 shortToken; // Token used as short in the LSP. Mint and burn rights needed by this contract.\n        IERC20 collateralToken; // Collateral token used to back LSP synthetics.\n        LongShortPairFinancialProductLibrary financialProductLibrary; // Contract providing settlement payout logic.\n        bytes customAncillaryData; // Custom ancillary data to be passed along with the price request to the OO.\n        uint256 proposerReward; // Optimistic oracle reward amount, pulled from the caller of the expire function.\n        uint256 optimisticOracleLivenessTime; // OO liveness time for price requests.\n        uint256 optimisticOracleProposerBond; // OO proposer bond for price requests.\n        FinderInterface finder; // DVM finder to find other UMA ecosystem contracts.\n        address timerAddress; // Timer used to synchronize contract time in testing. Set to 0x000... in production.\n    }\n\n    bool public receivedSettlementPrice;\n\n    bool public enableEarlyExpiration; // If set, the LSP contract can request to be settled early by calling the OO.\n    uint64 public expirationTimestamp;\n    uint64 public earlyExpirationTimestamp; // Set in the case the contract is expired early.\n    string public pairName;\n    uint256 public collateralPerPair; // Amount of collateral a pair of tokens is always redeemable for.\n\n    // Number between 0 and 1e18 to allocate collateral between long & short tokens at redemption. 0 entitles each short\n    // to collateralPerPair and each long to 0. 1e18 makes each long worth collateralPerPair and short 0.\n    uint256 public expiryPercentLong;\n    bytes32 public priceIdentifier;\n\n    // Price returned from the Optimistic oracle at settlement time.\n    int256 public expiryPrice;\n\n    // External contract interfaces.\n    IERC20 public collateralToken;\n    ExpandedIERC20 public longToken;\n    ExpandedIERC20 public shortToken;\n    FinderInterface public finder;\n    LongShortPairFinancialProductLibrary public financialProductLibrary;\n\n    // Optimistic oracle customization parameters.\n    bytes public customAncillaryData;\n    uint256 public proposerReward;\n    uint256 public optimisticOracleLivenessTime;\n    uint256 public optimisticOracleProposerBond;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event TokensCreated(address indexed sponsor, uint256 indexed collateralUsed, uint256 indexed tokensMinted);\n    event TokensRedeemed(address indexed sponsor, uint256 indexed collateralReturned, uint256 indexed tokensRedeemed);\n    event ContractExpired(address indexed caller);\n    event EarlyExpirationRequested(address indexed caller, uint64 earlyExpirationTimeStamp);\n    event PositionSettled(address indexed sponsor, uint256 collateralReturned, uint256 longTokens, uint256 shortTokens);\n\n    /****************************************\n     *               MODIFIERS              *\n     ****************************************/\n\n    modifier preExpiration() {\n        require(getCurrentTime() < expirationTimestamp, \"Only callable pre-expiry\");\n        _;\n    }\n\n    modifier postExpiration() {\n        require(getCurrentTime() >= expirationTimestamp, \"Only callable post-expiry\");\n        _;\n    }\n\n    modifier notEarlyExpired() {\n        require(!isContractEarlyExpired(), \"Contract already early expired\");\n        _;\n    }\n\n    /**\n     * @notice Construct the LongShortPair\n     * @param params Constructor params used to initialize the LSP. Key-valued object with the following structure:\n     *    - `pairName`: Name of the long short pair contract.\n     *    - `expirationTimestamp`: Unix timestamp of when the contract will expire.\n     *    - `collateralPerPair`: How many units of collateral are required to mint one pair of synthetic tokens.\n     *    - `priceIdentifier`: Price identifier, registered in the DVM for the long short pair.\n     *    - `longToken`: Token used as long in the LSP. Mint and burn rights needed by this contract.\n     *    - `shortToken`: Token used as short in the LSP. Mint and burn rights needed by this contract.\n     *    - `collateralToken`: Collateral token used to back LSP synthetics.\n     *    - `financialProductLibrary`: Contract providing settlement payout logic.\n     *    - `customAncillaryData`: Custom ancillary data to be passed along with the price request to the OO.\n     *    - `proposerReward`: Preloaded reward to incentivize settlement price proposals.\n     *    - `optimisticOracleLivenessTime`: OO liveness time for price requests.\n     *    - `optimisticOracleProposerBond`: OO proposer bond for price requests.\n     *    - `finder`: DVM finder to find other UMA ecosystem contracts.\n     *    - `timerAddress`: Timer used to synchronize contract time in testing. Set to 0x000... in production.\n     */\n    constructor(ConstructorParams memory params) Testable(params.timerAddress) {\n        finder = params.finder;\n        require(bytes(params.pairName).length > 0, \"Pair name cant be empty\");\n        require(params.expirationTimestamp > getCurrentTime(), \"Expiration timestamp in past\");\n        require(params.collateralPerPair > 0, \"Collateral per pair cannot be 0\");\n        require(_getIdentifierWhitelist().isIdentifierSupported(params.priceIdentifier), \"Identifier not registered\");\n        require(address(_getOptimisticOracle()) != address(0), \"Invalid finder\");\n        require(address(params.financialProductLibrary) != address(0), \"Invalid FinancialProductLibrary\");\n        require(_getCollateralWhitelist().isOnWhitelist(address(params.collateralToken)), \"Collateral not whitelisted\");\n        require(params.optimisticOracleLivenessTime > 0, \"OO liveness cannot be 0\");\n        require(params.optimisticOracleLivenessTime < 5200 weeks, \"OO liveness too large\");\n\n        pairName = params.pairName;\n        expirationTimestamp = params.expirationTimestamp;\n        collateralPerPair = params.collateralPerPair;\n        priceIdentifier = params.priceIdentifier;\n        enableEarlyExpiration = params.enableEarlyExpiration;\n\n        longToken = params.longToken;\n        shortToken = params.shortToken;\n        collateralToken = params.collateralToken;\n\n        financialProductLibrary = params.financialProductLibrary;\n        OptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\n        require(\n            optimisticOracle.stampAncillaryData(params.customAncillaryData, address(this)).length <=\n                optimisticOracle.ancillaryBytesLimit(),\n            \"Ancillary Data too long\"\n        );\n\n        customAncillaryData = params.customAncillaryData;\n        proposerReward = params.proposerReward;\n        optimisticOracleLivenessTime = params.optimisticOracleLivenessTime;\n        optimisticOracleProposerBond = params.optimisticOracleProposerBond;\n    }\n\n    /****************************************\n     *          POSITION FUNCTIONS          *\n     ****************************************/\n\n    /**\n     * @notice Creates a pair of long and short tokens equal in number to tokensToCreate. Pulls the required collateral\n     * amount into this contract, defined by the collateralPerPair value.\n     * @dev The caller must approve this contract to transfer `tokensToCreate * collateralPerPair` amount of collateral.\n     * @param tokensToCreate number of long and short synthetic tokens to create.\n     * @return collateralUsed total collateral used to mint the synthetics.\n     */\n    function create(uint256 tokensToCreate) public preExpiration() nonReentrant() returns (uint256 collateralUsed) {\n        // Note the use of mulCeil to prevent small collateralPerPair causing rounding of collateralUsed to 0 enabling\n        // callers to mint dust LSP tokens without paying any collateral.\n        collateralUsed = FixedPoint.Unsigned(tokensToCreate).mulCeil(FixedPoint.Unsigned(collateralPerPair)).rawVal"
    }
  ]
}