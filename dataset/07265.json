{
  "Title": "[H-19] Vaults don't verify that a strategy's deadline has passed",
  "Content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/VaultImplementation.sol#L229-L266><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/AstariaRouter.sol#L439>\n\nThe vault doesn't verify that a deadline hasn't passed when a commitment is validated. Users are able to take out loans using strategies that have already expired. Depending on the nature of the strategy that can cause a loss of funds for the LPs.\n\n### Proof of Concept\n\nWhen you take out a loan using the AstariaRouter, the deadline is verified:\n\n```sol\n  function _validateCommitment(\n    RouterStorage storage s,\n    IAstariaRouter.Commitment calldata commitment,\n    uint256 timeToSecondEpochEnd\n  ) internal view returns (ILienToken.Lien memory lien) {\n    if (block.timestamp > commitment.lienRequest.strategy.deadline) {\n      revert InvalidCommitmentState(CommitmentState.EXPIRED);\n    }\n// ...\n```\n\nBut, `VaultImplementation._validateCommitment()` skips that check:\n\n```sol\n  function _validateCommitment(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  ) internal view {\n    uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n    ERC721 CT = ERC721(address(COLLATERAL_TOKEN()));\n    address holder = CT.ownerOf(collateralId);\n    address operator = CT.getApproved(collateralId);\n    if (\n      msg.sender != holder &&\n      receiver != holder &&\n      receiver != operator &&\n      !CT.isApprovedForAll(holder, msg.sender)\n    ) {\n      revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n    }\n    VIData storage s = _loadVISlot();\n    address recovered = ecrecover(\n      keccak256(\n        _encodeStrategyData(\n          s,\n          params.lienRequest.strategy,\n          params.lienRequest.merkle.root\n        )\n      ),\n      params.lienRequest.v,\n      params.lienRequest.r,\n      params.lienRequest.s\n    );\n    if (\n      (recovered != owner() && recovered != s.delegate) ||\n      recovered == address(0)\n    ) {\n      revert IVaultImplementation.InvalidRequest(\n        InvalidRequestReason.INVALID_SIGNATURE\n      );\n    }\n  }\n```\n\nIf you search for `deadline` in the codebase you'll see that there's no other place where the property is accessed.\n\nAs long as the user takes out the loan from the vault directly, they can use strategies that have expired. The vault owner could prevent this from happening by incrementing the `strategistNonce` after the strategy expired.\n\n### Recommended Mitigation Steps\n\nIn `VaultImplementation._validateCommitment()` check that `deadline > block.timestamp`.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/122)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/VaultImplementation.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**                                                     \n*  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗ \n* ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n* ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n* ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n* ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n* ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n*\n* Astaria Labs, Inc\n*/\n\npragma solidity =0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {LienToken} from \"core/LienToken.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {AstariaVaultBase} from \"core/AstariaVaultBase.sol\";\nimport {IVaultImplementation} from \"core/interfaces/IVaultImplementation.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\n/**\n * @title VaultImplementation\n * @notice A base implementation for the minimal features of an Astaria Vault.\n */\nabstract contract VaultImplementation is\n  AstariaVaultBase,\n  ERC721TokenReceiver,\n  IVaultImplementation\n{\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n\n  bytes32 public constant STRATEGY_TYPEHASH =\n    keccak256(\"StrategyDetails(uint256 nonce,uint256 deadline,bytes32 root)\");\n\n  bytes32 constant EIP_DOMAIN =\n    keccak256(\n      \"EIP712Domain(string version,uint256 chainId,address verifyingContract)\"\n    );\n  bytes32 constant VERSION = keccak256(\"0\");\n\n  function name() external view virtual override returns (string memory);\n\n  function symbol() external view virtual override returns (string memory);\n\n  uint256 private constant VI_SLOT =\n    uint256(keccak256(\"xyz.astaria.VaultImplementation.storage.location\")) - 1;\n\n  function getStrategistNonce() external view returns (uint256) {\n    return _loadVISlot().strategistNonce;\n  }\n\n  function incrementNonce() external {\n    VIData storage s = _loadVISlot();\n    if (msg.sender != owner() && msg.sender != s.delegate) {\n      revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n    }\n    s.strategistNonce++;\n    emit NonceUpdated(s.strategistNonce);\n  }\n\n  /**\n   * @notice modify the deposit cap for the vault\n   * @param newCap The deposit cap.\n   */\n  function modifyDepositCap(uint256 newCap) external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().depositCap = newCap.safeCastTo88();\n  }\n\n  function _loadVISlot() internal pure returns (VIData storage s) {\n    uint256 slot = VI_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  /**\n   * @notice modify the allowlist for the vault\n   * @param depositor the depositor to modify\n   * @param enabled the status of the depositor\n   */\n  function modifyAllowList(address depositor, bool enabled) external virtual {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().allowList[depositor] = enabled;\n    emit AllowListUpdated(depositor, enabled);\n  }\n\n  /**\n   * @notice disable the allowList for the vault\n   */\n  function disableAllowList() external virtual {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().allowListEnabled = false;\n    emit AllowListEnabled(false);\n  }\n\n  /**\n   * @notice enable the allowList for the vault\n   */\n  function enableAllowList() external virtual {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().allowListEnabled = true;\n    emit AllowListEnabled(true);\n  }\n\n  /**\n   * @notice receive hook for ERC721 tokens, nothing special done\n   */\n  function onERC721Received(\n    address, // operator_\n    address, // from_\n    uint256, // tokenId_\n    bytes calldata // data_\n  ) external pure override returns (bytes4) {\n    return ERC721TokenReceiver.onERC721Received.selector;\n  }\n\n  modifier whenNotPaused() {\n    if (ROUTER().paused()) {\n      revert InvalidRequest(InvalidRequestReason.PAUSED);\n    }\n\n    if (_loadVISlot().isShutdown) {\n      revert InvalidRequest(InvalidRequestReason.SHUTDOWN);\n    }\n    _;\n  }\n\n  function getShutdown() external view returns (bool) {\n    return _loadVISlot().isShutdown;\n  }\n\n  function shutdown() external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().isShutdown = true;\n    emit VaultShutdown();\n  }\n\n  function domainSeparator() public view virtual returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          EIP_DOMAIN,\n          VERSION, //version\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  /*\n   * @notice encodes the data for a 712 signature\n   * @param tokenContract The address of the token contract\n   * @param tokenId The id of the token\n   * @param amount The amount of the token\n   */\n  function encodeStrategyData(\n    IAstariaRouter.StrategyDetailsParam calldata strategy,\n    bytes32 root\n  ) external view returns (bytes memory) {\n    VIData storage s = _loadVISlot();\n    return _encodeStrategyData(s, strategy, root);\n  }\n\n  function _encodeStrategyData(\n    VIData storage s,\n    IAstariaRouter.StrategyDetailsParam calldata strategy,\n    bytes32 root\n  ) internal view returns (bytes memory) {\n    bytes32 hash = keccak256(\n      abi.encode(STRATEGY_TYPEHASH, s.strategistNonce, strategy.deadline, root)\n    );\n    return\n      abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), hash);\n  }\n\n  function init(InitParams calldata params) external virtual {\n    require(msg.sender == address(ROUTER()));\n    VIData storage s = _loadVISlot();\n\n    if (params.delegate != address(0)) {\n      s.delegate = params.delegate;\n    }\n    s.depositCap = params.depositCap.safeCastTo88();\n    if (params.allowListEnabled) {\n      s.allowListEnabled = true;\n      uint256 i;\n      for (; i < params.allowList.length; ) {\n        s.allowList[params.allowList[i]] = true;\n        unchecked {\n          ++i;\n        }\n      }\n    }\n  }\n\n  function setDelegate(address delegate_) external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    VIData storage s = _loadVISlot();\n    s.delegate = delegate_;\n    emit DelegateUpdated(delegate_);\n    emit AllowListUpdated(delegate_, true);\n  }\n\n  /**\n   * @dev Validates the terms for a requested loan.\n   * Who is requesting the borrow, is it a smart contract? or is it a user?\n   * if a smart contract, then ensure that the contract is approved to borrow and is also receiving the funds.\n   * if a user, then ensure that the user is approved to borrow and is also receiving the funds.\n   * The terms are hashed and signed by the borrower, and the signature validated against the strategist's address\n   * lien details are decoded from the obligation data and validated the collateral\n   *\n   * @param params The Commitment information containing the loan parameters and the merkle proof for the strategy supporting the requested loan.\n   * @param receiver The address of the prospective borrower.\n   */\n  function _validateCommitment(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  ) internal view {\n    uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n    ERC721 CT = ERC721(address(COLLATERAL_TOKEN()));\n    address holder = CT.ownerOf(collateralId);\n    address operator = CT.getApproved(collateralId);\n    if (\n      msg.sender != holder &&\n      receiver != holder &&\n      receiver != operator &&\n      !CT.isApprovedForAll(holder, msg.sender)\n    ) {\n      revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n    }\n    VIData storage s = _loadVISlot();\n    address recovered = ecrecover(\n      keccak256(\n        _encodeStrategyData(\n          s,\n          params.lienRequest.strategy,\n          params.lienRequest.merkle.root\n        )\n      ),\n      params.lienRequest.v,\n      params.lienRequest.r,\n      params.lienRequest.s\n    );\n    if (\n      (recovered != owner() && recovered != s.delegate) ||\n      recovered == address(0)\n    ) {\n      revert IVaultImplementation.InvalidRequest(\n        InvalidRequestReason.INVALID_SIGNATURE\n      );\n    }\n  }\n\n  function _afterCommitToLien(\n    uint40 end,\n    uint256 lienId,\n    uint256 slope\n  ) internal virtual {}\n\n  function _beforeCommitToLien(IAstariaRouter.Commitment calldata)\n    internal\n    virtual\n  {}\n\n  /**\n   * @notice Pipeline for lifecycle of new loan origination.\n   * Origination consists of a few phases: pre-commitment validation, lien token issuance, strategist reward, and after commitment actions\n   * Starts by depositing collateral and take optimized-out a lien against it. Next, verifies the merkle proof for a loan commitment. Vault owners are then rewarded fees for successful loan origination.\n   * @param params Commitment data for the incoming lien request\n   * @param receiver The borrower receiving the loan.\n   * @return lienId The id of the newly minted lien token.\n   */\n  function commitToLien(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  )\n    external\n    whenNotPaused\n    returns (uint256 lienId, ILienToken.Stack[] memory stack, uint256 payout)\n  {\n    _beforeCommitToLien(params);\n    uint256 slopeAddition;\n    (lienId, stack, slopeAddition, payout) = _requestLienAndIssuePayout(\n      params,\n      receiver\n    );\n    _afterCommitToLien(\n      stack[stack.length - 1].point.end,\n      lienId,\n      slopeAddition\n    );\n  }\n\n  /**\n   * @notice Buy optimized-out a lien to replace it with new terms.\n   * @param position The position of the specified lien.\n   * @param incomingTerms The loan terms of the new lien.\n   */\n  function buyoutLien(\n    ILienToken.Stack[] calldata stack,\n    uint8 position,\n    IAstariaRouter.Commitment calldata incomingTerms\n  )\n    external\n    whenNotPaused\n    returns (ILienToken.Stack[] memory, ILienToken.Stack memory)\n  {\n    LienToken lienToken = LienToken(address(ROUTER().LIEN_TOKEN()));\n\n    (uint256 owed, uint256 buyout) = lienToken.getBuyout(stack[position]);\n\n    if (buyout > ERC20(asset()).balanceOf(address(this))) {\n      revert IVaultImplementation.InvalidRequest(\n        InvalidRequestReason.INSUFFICIENT_FUNDS\n      );\n    }\n\n    _validateCommitment(incomingTerms, recipient());\n\n    ERC20(asset()).safeApprove(address(ROUTER().TRANSFER_PROXY()), buyout);\n\n    return\n      lienToken.buyoutLien(\n        ILienToken.LienActionBuyout({\n          position: position,\n          encumber: ILienToken.LienActionEncumber({\n            amount: owed,\n            receiver: recipient(),\n            lien: ROUTER().validateCommitment({\n              commitment: incomingTerms,\n              timeToSecondEpochEnd: _timeToSecondEndIfPublic()\n            }),\n            stack: stack\n          })\n        })\n      );\n  }\n\n  function _timeToSecondEndIfPublic()\n    internal\n    view\n    virtual\n    returns (uint256 timeToSecondEpochEnd)\n  {\n    return 0;\n  }\n\n  /**\n   * @notice Retrieves the recipient of loan repayments. For PublicVaults (VAULT_TYPE 2), this is always the vault address. For PrivateVaults, retrieves the owner() of the vault.\n   * @return The address of the recipient.\n   */\n  function recipient() public view returns (address) {\n    if (IMPL_TYPE() == uint8(IAstariaRouter.ImplementationType.PublicVault)) {\n      return address(this);\n    } else {\n      return owner();\n    }\n  }\n\n  /**\n   * @dev Generates a Lien for a valid loan commitment proof and sends the loan amount to the borrower.\n   * @param c The Commitment information containing the loan parameters and the merkle proof for the strategy supporting the requested loan.\n   * @param receiver The borrower requesting the loan.\n   */\n  function _requestLienAndIssuePayout(\n    IAstariaRouter.Commitment calldata c,\n    address receiver\n  )\n    internal\n    returns (\n      uint256 newLienId,\n      ILienToken.Stack[] memory stack,\n      uint256 slope,\n      uint256 payout\n    )\n  {\n    _validateCommitment(c, receiver);\n    (newLienId, stack, slope) = ROUTER().requestLienPosition(c, recipient());\n    payout = _handleProtocolFee(c.lienRequest.amount);\n    ERC20(asset()).safeTransfer(receiver, payout);\n  }\n\n  function _handleProtocolFee(uint256 amount) internal returns (uint256) {\n    address feeTo = ROUTER().feeTo();\n    bool feeOn = feeTo != address(0);\n    if (feeOn) {\n      uint256 fee = ROUTER().getProtocolFee(amount);\n\n      unchecked {\n        amount -= fee;\n      }\n      ERC20(asset()).safeTransfer(feeTo, fee);\n    }\n    return amount;\n  }\n}"
    },
    {
      "filename": "src/AstariaRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {IVaultImplementation} from \"core/interfaces/IVaultImplementation.sol\";\nimport {IAstariaVaultBase} from \"core/interfaces/IAstariaVaultBase.sol\";\nimport {IStrategyValidator} from \"core/interfaces/IStrategyValidator.sol\";\n\nimport {MerkleProofLib} from \"core/utils/MerkleProofLib.sol\";\nimport {Pausable} from \"core/utils/Pausable.sol\";\nimport {IERC4626} from \"core/interfaces/IERC4626.sol\";\nimport {ERC4626Router} from \"gpl/ERC4626Router.sol\";\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {OrderParameters} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {AuthInitializable} from \"core/AuthInitializable.sol\";\nimport {Initializable} from \"./utils/Initializable.sol\";\n\n/**\n * @title AstariaRouter\n * @notice This contract manages the deployment of Vaults and universal Astaria actions.\n */\ncontract AstariaRouter is\n  AuthInitializable,\n  Initializable,\n  ERC4626Router,\n  Pausable,\n  IAstariaRouter\n{\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n\n  uint256 private constant ROUTER_SLOT =\n    uint256(keccak256(\"xyz.astaria.AstariaRouter.storage.location\")) - 1;\n\n  // cast --to-bytes32 $(cast sig \"OutOfBoundError()\")\n  uint256 private constant OUTOFBOUND_ERROR_SELECTOR =\n    0x571e08d100000000000000000000000000000000000000000000000000000000;\n  uint256 private constant ONE_WORD = 0x20;\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Setup transfer authority and set up addresses for deployed CollateralToken, LienToken, TransferProxy contracts, as well as PublicVault and SoloVault implementations to clone.\n   * @param _AUTHORITY The authority manager.\n   * @param _COLLATERAL_TOKEN The address of the deployed CollateralToken contract.\n   * @param _LIEN_TOKEN The address of the deployed LienToken contract.\n   * @param _TRANSFER_PROXY The address of the deployed TransferProxy contract.\n   * @param _VAULT_IMPL The address of a base implementation of VaultImplementation for cloning.\n   * @param _SOLO_IMPL The address of a base implementation of a PrivateVault for cloning.\n   */\n  function initialize(\n    Authority _AUTHORITY,\n    ICollateralToken _COLLATERAL_TOKEN,\n    ILienToken _LIEN_TOKEN,\n    ITransferProxy _TRANSFER_PROXY,\n    address _VAULT_IMPL,\n    address _SOLO_IMPL,\n    address _WITHDRAW_IMPL,\n    address _BEACON_PROXY_IMPL,\n    address _CLEARING_HOUSE_IMPL\n  ) external initializer {\n    __initAuth(msg.sender, address(_AUTHORITY));\n    RouterStorage storage s = _loadRouterSlot();\n\n    s.COLLATERAL_TOKEN = _COLLATERAL_TOKEN;\n    s.LIEN_TOKEN = _LIEN_TOKEN;\n    s.TRANSFER_PROXY = _TRANSFER_PROXY;\n    s.implementations[uint8(ImplementationType.PrivateVault)] = _SOLO_IMPL;\n    s.implementations[uint8(ImplementationType.PublicVault)] = _VAULT_IMPL;\n    s.implementations[uint8(ImplementationType.WithdrawProxy)] = _WITHDRAW_IMPL;\n    s.implementations[\n      uint8(ImplementationType.ClearingHouse)\n    ] = _CLEARING_HOUSE_IMPL;\n    s.BEACON_PROXY_IMPLEMENTATION = _BEACON_PROXY_IMPL;\n    s.auctionWindow = uint32(2 days);\n    s.auctionWindowBuffer = uint32(1 days);\n\n    s.liquidationFeeNumerator = uint32(130);\n    s.liquidationFeeDenominator = uint32(1000);\n    s.minInterestBPS = uint32((uint256(1e15) * 5) / (365 days));\n    s.minEpochLength = uint32(7 days);\n    s.maxEpochLength = uint32(45 days);\n    s.maxInterestRate = ((uint256(1e16) * 200) / (365 days)).safeCastTo88();\n    //63419583966; // 200% apy / second\n    s.buyoutFeeNumerator = uint32(100);\n    s.buyoutFeeDenominator = uint32(1000);\n    s.minDurationIncrease = uint32(5 days);\n    s.guardian = msg.sender;\n  }\n\n  function mint(\n    IERC4626 vault,\n    address to,\n    uint256 shares,\n    uint256 maxAmountIn\n  )\n    public\n    payable\n    virtual\n    override\n    validVault(address(vault))\n    returns (uint256 amountIn)\n  {\n    return super.mint(vault, to, shares, maxAmountIn);\n  }\n\n  function deposit(\n    IERC4626 vault,\n    address to,\n    uint256 amount,\n    uint256 minSharesOut\n  )\n    public\n    payable\n    virtual\n    override\n    validVault(address(vault))\n    returns (uint256 sharesOut)\n  {\n    return super.deposit(vault, to, amount, minSharesOut);\n  }\n\n  function withdraw(\n    IERC4626 vault,\n    address to,\n    uint256 amount,\n    uint256 maxSharesOut\n  )\n    public\n    payable\n    virtual\n    override\n    validVault(address(vault))\n    returns (uint256 sharesOut)\n  {\n    return super.withdraw(vault, to, amount, maxSharesOut);\n  }\n\n  function redeem(\n    IERC4626 vault,\n    address to,\n    uint256 shares,\n    uint256 minAmountOut\n  )\n    public\n    payable\n    virtual\n    override\n    validVault(address(vault))\n    returns (uint256 amountOut)\n  {\n    return super.redeem(vault, to, shares, minAmountOut);\n  }\n\n  function redeemFutureEpoch(\n    IPublicVault vault,\n    uint256 shares,\n    address receiver,\n    uint64 epoch\n  ) public virtual validVault(address(vault)) returns (uint256 assets) {\n    return vault.redeemFutureEpoch(shares, receiver, msg.sender, epoch);\n  }\n\n  modifier validVault(address targetVault) {\n    if (!isValidVault(targetVault)) {\n      revert InvalidVault(targetVault);\n    }\n    _;\n  }\n\n  function pullToken(\n    address token,\n    uint256 amount,\n    address recipient\n  ) public payable override {\n    RouterStorage storage s = _loadRouterSlot();\n    s.TRANSFER_PROXY.tokenTransferFrom(\n      address(token),\n      msg.sender,\n      recipient,\n      amount\n    );\n  }\n\n  function _loadRouterSlot() internal pure returns (RouterStorage storage rs) {\n    uint256 slot = ROUTER_SLOT;\n    assembly {\n      rs.slot := slot\n    }\n  }\n\n  function feeTo() public view returns (address) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.feeTo;\n  }\n\n  function BEACON_PROXY_IMPLEMENTATION() public view returns (address) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.BEACON_PROXY_IMPLEMENTATION;\n  }\n\n  function LIEN_TOKEN() public view returns (ILienToken) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.LIEN_TOKEN;\n  }\n\n  function TRANSFER_PROXY() public view returns (ITransferProxy) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.TRANSFER_PROXY;\n  }\n\n  function COLLATERAL_TOKEN() public view returns (ICollateralToken) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.COLLATERAL_TOKEN;\n  }\n\n  /**\n   * @dev Enables _pause, freezing functions with the whenNotPaused modifier.\n   */\n  function __emergencyPause() external requiresAuth whenNotPaused {\n    _pause();\n  }\n\n  /**\n   * @dev Disables _pause, un-freezing functions with the whenNotPaused modifier.\n   */\n  function __emergencyUnpause() external requiresAuth whenPaused {\n    _unpause();\n  }\n\n  function fileBatch(File[] calldata files) external requiresAuth {\n    uint256 i;\n    for (; i < files.length; ) {\n      _file(files[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function file(File calldata incoming) public requiresAuth {\n    _file(incoming);\n  }\n\n  function _file(File calldata incoming) internal {\n    RouterStorage storage s = _loadRouterSlot();\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    if (what == FileType.AuctionWindow) {\n      (uint256 window, uint256 windowBuffer) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      s.auctionWindow = window.safeCastTo32();\n      s.auctionWindowBuffer = windowBuffer.safeCastTo32();\n    } else if (what == FileType.LiquidationFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.liquidationFeeNumerator = numerator.safeCastTo32();\n      s.liquidationFeeDenominator = denominator.safeCastTo32();\n    } else if (what == FileType.ProtocolFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.protocolFeeNumerator = numerator.safeCastTo32();\n      s.protocolFeeDenominator = denominator.safeCastTo32();\n    } else if (what == FileType.BuyoutFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.buyoutFeeNumerator = numerator.safeCastTo32();\n      s.buyoutFeeDenominator = denominator.safeCastTo32();\n    } else if (what == FileType.MinInterestBPS) {\n      uint256 value = abi.decode(data, (uint256));\n      s.minInterestBPS = value.safeCastTo32();\n    } else if (what == FileType.MinDurationIncrease) {\n      uint256 value = abi.decode(data, (uint256));\n      s.minDurationIncrease = value.safeCastTo32();\n    } else if (what == FileType.MinEpochLength) {\n      s.minEpochLength = abi.decode(data, (uint256)).safeCastTo32();\n    } else if (what == FileType.MaxEpochLength) {\n      s.maxEpochLength = abi.decode(data, (uint256)).safeCastTo32();\n    } else if (what == FileType.MaxInterestRate) {\n      s.maxInterestRate = abi.decode(data, (uint256)).safeCastTo88();\n    } else if (what == FileType.FeeTo) {\n      address addr = abi.decode(data, (address));\n      if (addr == address(0)) revert InvalidFileData();\n      s.feeTo = addr;\n    } else if (what == FileType.StrategyValidator) {\n      (uint8 TYPE, address addr) = abi.decode(data, (uint8, address));\n      if (addr == address(0)) revert InvalidFileData();\n      s.strategyValidators[TYPE] = addr;\n    } else {\n      revert UnsupportedFile();\n    }\n\n    emit FileUpdated(what, data);\n  }\n\n  function setNewGuardian(address _guardian) external {\n    RouterStorage storage s = _loadRouterSlot();\n    require(msg.sender == s.guardian);\n    s.newGuardian = _guardian;\n  }\n\n  function __renounceGuardian() external {\n    RouterStorage storage s = _loadRouterSlot();\n    require(msg.sender == s.guardian);\n    s.guardian = address(0);\n    s.newGuardian = address(0);\n  }\n\n  function __acceptGuardian() external {\n    RouterStorage storage s = _loadRouterSlot();\n    require(msg.sender == s.newGuardian);\n    s.guardian = s.newGuardian;\n    delete s.newGuardian;\n  }\n\n  function fileGuardian(File[] calldata file) external {\n    RouterStorage storage s = _loadRouterSlot();\n    require(msg.sender == address(s.guardian));\n\n    uint256 i;\n    for (; i < file.length; ) {\n      FileType what = file[i].what;\n      bytes memory data = file[i].data;\n      if (what == FileType.Implementation) {\n        (uint8 implType, address addr) = abi.decode(data, (uint8, address));\n        if (addr == address(0)) revert InvalidFileData();\n        s.implementations[implType] = addr;\n      } else if (what == FileType.CollateralToken) {\n        address addr = abi.decode(data, (address));\n        if (addr == address(0)) revert InvalidFileData();\n        s.COLLATERAL_TOKEN = ICollateralToken(addr);\n      } else if (what == FileType.LienToken) {\n        address addr = abi.decode(data, (address));\n        if (addr == address(0)) revert InvalidFileData();\n        s.LIEN_TOKEN = ILienToken(addr);\n      } else if (what == FileType.TransferProxy) {\n        address addr = abi.decode(data, (address));\n        if (addr == address(0)) revert InvalidFileData();\n        s.TRANSFER_PROXY = ITransferProxy(addr);\n      } else {\n        revert UnsupportedFile();\n      }\n      emit FileUpdated(what, data);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  //PUBLIC\n\n  function getImpl(uint8 implType) external view returns (address impl) {\n    impl = _loadRouterSlot().implementations[implType];\n    if (impl == address(0)) {\n      revert(\"unsupported/impl\");\n    }\n  }\n\n  function getAuctionWindow(bool includeBuffer) public view returns (uint256) {\n    RouterStorage storage s = _loadRouterSlot();\n    return s.auctionWindow + (includeBuffer ? s.auctionWindowBuffer : 0);\n  }\n\n  function _sliceUint(bytes memory bs, uint256 start)\n    internal\n    pure\n    returns (uint256 x)\n  {\n    uint256 length = bs.length;\n\n    assembly {\n      let end := add(ONE_WORD, start)\n\n      if lt(length, end) {\n        mstore(0, OUTOFBOUND_ERROR_SELECTOR)\n        revert(0, ONE_WORD)\n      }\n\n      x := mload(add(bs, end))\n    }\n  }\n\n  function validateCommitment(\n    IAstariaRouter.Commitment calldata commitment,\n    uint256 timeToSecondEpochEnd\n  ) public view returns (ILienToken.Lien memory lien) {\n    return\n      _validateCommitment(_loadRouterSlot(), commitment, timeToSecondEpochEnd);\n  }\n\n  function _validateCommitment(\n    RouterStorage storage s,\n    IAstariaRouter.Commitment calldata commitment,\n    uint256 timeToSecondEpochEnd\n  ) internal view returns (ILienToken.Lien memory lien) {\n    if (block.timestamp > commitment.lienRequest.strategy.deadline) {\n      revert InvalidCommitmentState(CommitmentState.EXPIRED);\n    }\n    uint8 nlrType = uint8(_sliceUint(commitment.lienRequest.nlrDetails, 0));\n    address strategyValidator = s.strategyValidators[nlrType];\n    if (strategyValidator == address(0)) {\n      revert InvalidStrategy(nlrType);\n    }\n    (bytes32 leaf, ILienToken.Details memory details) = IStrategyValidator(\n      strategyValidator\n    ).validateAndParse(\n        commitment.lienRequest,\n        s.COLLATERAL_TOKEN.ownerOf(\n          commitment.tokenContract.computeId(commitment.tokenId)\n        ),\n        commitment.tokenContract,\n        commitment.tokenId\n      );\n\n    if (details.rate == uint256(0) || details.rate > s.maxInterestRate) {\n      revert InvalidCommitmentState(CommitmentState.INVALID_RATE);\n    }\n\n    if (details.maxAmount < commitment.lienRequest.amount) {\n      revert InvalidCommitmentState(CommitmentState.INVALID_AMOUNT);\n    }\n\n    if (\n      !MerkleProofLib.verify(\n        commitment.lienRequest.merkle.proof,\n        commitment.lienRequest.merkle.root,\n        leaf\n      )\n    ) {\n      revert InvalidCommitmentState(CommitmentState.INVALID);\n    }\n\n    if (timeToSecondEpochEnd > 0 && details.duration > timeToSecondEpochEnd) {\n      details.duration = timeToSecondEpochEnd;\n    }\n\n    lien = ILienToken.Lien({\n      collateralType: nlrType,\n      details: details,\n      strategyRoot: commitment.lienRequest.merkle.root,\n      collateralId: commitment.tokenContract.computeId(commitment.tokenId),\n      vault: commitment.lienRequest.strategy.vault,\n      token: IAstariaVaultBase(commitment.lienRequest.strategy.vault).asset()\n    });\n  }\n\n  function commitToLiens(IAstariaRouter.Commitment[] memory commitments)\n    public\n    whenNotPaused\n    returns (uint256[] memory lienIds, ILienToken.Stack[] memory stack)\n  {\n    RouterStorage storage s = _loadRouterSlot();\n\n    uint256 totalBorrowed;\n    lienIds = new uint256[](commitments.length);\n    _transferAndDepositAssetIfAble(\n      s,\n      commitments[0].tokenContract,\n      commitments[0].tokenId\n    );\n\n    uint256 i;\n    for (; i < commitments.length; ) {\n      if (i != 0) {\n        commitments[i].lienRequest.stack = stack;\n      }\n      uint256 payout;\n      (lienIds[i], stack, payout) = _executeCommitment(s, commitments[i]);\n      totalBorrowed += payout;\n      unchecked {\n        ++i;\n      }\n    }\n\n    ERC20(IAstariaVaultBase(commitments[0].lienRequest.strategy.vault).asset())\n      .safeTransfer(msg.sender, totalBorrowed);\n  }\n\n  function newVault(address delegate, address underlying)\n    external\n    whenNotPaused\n    returns (address)\n  {\n    address[] memory allowList = new address[](1);\n    allowList[0] = msg.sender;\n    RouterStorage storage s = _loadRouterSlot();\n\n    return\n      _newVault(\n        s,\n        underlying,\n        uint256(0),\n        delegate,\n        uint256(0),\n        true,\n        allowList,\n        uint256(0)\n      );\n  }\n\n  function newPublicVault(\n    uint256 epochLength,\n    address delegate,\n    address underlying,\n    uint256 vaultFee,\n    bool allowListEnabled,\n    address[] calldata allowList,\n    uint256 depositCap\n  ) public whenNotPaused returns (address) {\n    RouterStorage storage s = _loadRouterSlot();\n    if (s.minEpochLength > epochLength) {\n      revert IPublicVault.InvalidState(\n        IPublicVault.InvalidStates.EPOCH_TOO_LOW\n      );\n    }\n    if (s.maxEpochLength < epochLength) {\n      revert IPublicVault.InvalidState(\n        IPublicVault.InvalidStates.EPOCH_TOO_HIGH\n      );\n    }\n    return\n      _newVault(\n        s,\n        underlying,\n        epochLength,\n        delegate,\n        vaultFee,\n        allowListEnabled,\n        allowList,\n        depositCap\n      );\n  }\n\n  function requestLienPosition(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  )\n    external\n    whenNotPaused\n    validVault(msg.sender)\n    returns (\n      uint256,\n      ILienToken.Stack[] memory,\n      uint256\n    )\n  {\n    RouterStorage storage s = _loadRouterSlot();\n\n    return\n      s.LIEN_TOKEN.createLien(\n        ILienToken.LienActionEncumber({\n          lien: _validateCommitment({\n            s: s,\n            commitment: params,\n            timeToSecondEpochEnd: IPublicVault(msg.sender).supportsInterface(\n              type(IPublicVault).interfaceId\n            )\n              ? IPublicVault(msg.sender).timeToSecondEpochEnd()\n              : 0\n          }),\n          amount: params.lienRequest.amount,\n          stack: params.lienRequest.stack,\n          receiver: receiver\n        })\n      );\n  }\n\n  function canLiquidate(ILienToken.Stack memory stack)\n    public\n    view\n    returns (bool)\n  {\n    RouterStorage storage s = _loadRouterSlot();\n    return (stack.point.end <= block.timestamp ||\n      msg.sender == s.COLLATERAL_TOKEN.ownerOf(stack.lien.collateralId));\n  }\n\n  function liquidate(ILienToken.Stack[] memory stack, uint8 position)\n    public\n    returns (OrderParameters memory listedOrder)\n  {\n    if (!canLiquidate(stack[position])) {\n      revert InvalidLienState(LienState.HEALTHY);\n    }\n\n    RouterStorage storage s = _loadRouterSlot();\n    uint256 auctionWindowMax = s.auctionWindow + s.auctionWindowBuffer;\n\n    s.LIEN_TOKEN.stopLiens(\n      stack[position].lien.collateralId,\n      auctionWindowMax,\n      stack,\n      msg.sender\n    );\n    emit Liquidation(stack[position].lien.collateralId, position);\n    listedOrder = s.COLLATERAL_TOKEN.auctionVault(\n      ICollateralToken.AuctionVaultParams({\n        settlementToken: stack[position].lien.token,\n        collateralId: stack[position].lien.collateralId,\n        maxDuration: auctionWindowMax,\n        startingPrice: stack[0].lien.details.liquidationInitialAsk,\n        endingPrice: 1_000 wei\n      })\n    );\n  }\n\n  function getProtocolFee(uint256 amountIn) external view returns (uint256) {\n    RouterStorage storage s = _loadRouterSlot();\n\n    return\n      amountIn.mulDivDown(s.protocolFeeNumerator, s.protocolFeeDen"
    }
  ]
}