{
  "Title": "M-1: DepositReceipt_Base.sol#L21 : HEARTBEAT_TIME gap is too huge",
  "Content": "# Issue M-1: DepositReceipt_Base.sol#L21 : HEARTBEAT_TIME gap is too huge \n\nSource: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/256 \n\n## Found by \nak1\n\n## Summary\n\nHEARTBEAT_TIME = 24 hours could not be safe. The oracle data still be stale one.\n\n## Vulnerability Detail\n\noracle is using the HEARTBEAT_TIME  as 24 hours. Since the price of oracle could vary in the time gap of 3 hours, using 24 hours could be still dangerous.\n\n## Impact\nStale data used. Front runnable issue.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_Base.sol#L21\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse 3 hours as hearbeat.\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor Confirmed. 24Hrs was originally for the sUSD chainlink feed, as seen here it can and should be much lower for other price feeds https://data.chain.link/optimism/mainnet/crypto-usd/eth-usd (mouse over trigger parameters)\n\n**kree-dotcom**\n\nclicked wrong button\n\n**kree-dotcom**\n\n3 hours as recommended by the auditor does not seem sufficient. Some Optimism price feeds such as ETH/USD and OP/USD have Heartbeats of 1200s or 20min. Currently we cannot find a method to fetch this via the oracle address and it looks like the Heartbeat sensitivity would have to be set per deployment of the depositReceipt.\n\n**kree-dotcom**\n\nFixed, https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/398f40cce538461396966ac22273f846d56f6f27\n\n`HEARTBEAT_TIME` is now an immutable var that is set by the deployer for each instance of a depositReceipt.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/22",
  "Code": [
    {
      "filename": "contracts/Velo-Deposit-Tokens/contracts/DepositReceipt_Base.sol",
      "content": "pragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n//chainlink aggregator interface extended \nimport \"./Interfaces/IAggregatorV3.sol\";\nimport \"./Interfaces/IAccessControlledOffchainAggregator.sol\";\n\nimport \"./Interfaces/IRouter.sol\";\n\n\nabstract contract DepositReceipt_Base is  ERC721Enumerable, AccessControl {\n    \n    // Role based access control, minters can mint or burn moUSD\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");  \n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");  \n\n    \n    uint256 private constant HEARTBEAT_TIME = 24 hours; //Check heartbeat frequency when adding new feeds\n    uint256 constant BASE = 1 ether; //division base\n    uint256 constant HUNDRED_TOKENS = 1e20; //due to constructor restrictions we know the non-USDC token has 18d.p.\n    uint256 constant HUNDRED = 100; //used to scale 100 token price to 1 token price\n    \n    //Mapping from NFTid to number of associated poolTokens\n    mapping(uint256 => uint256) public pooledTokens;\n    //Mapping from NFTid to original depositor contract(where tokens can be redeemed by anyone)\n    mapping(uint256 => address) public relatedDepositor;\n\n    //last NFT id, used as key\n    uint256 public currentLastId;\n\n    //router used for underlying asset quotes\n    IRouter public router;\n\n    //hardcoded price bounds used by chainlink for ETH feed\n    int192 ETHMaxPrice;\n    int192 ETHMinPrice;\n    //hardcoded price bounds used by chainlink for Token in USD feed\n    int192 tokenMaxPrice;\n    int192 tokenMinPrice;\n\n    //underlying gauge token details\n    address public token0; \n    address public token1;\n    bool public stable;\n\n    \n    \n    \n\n    event AddNewMinter(address indexed account, address indexed addedBy);\n    event NFTSplit(uint256 oldNFTId, uint256 newNFTId);\n    event NFTDataModified(uint256 NFTId, uint256 pastPooledTokens, uint256 newPooledTokens);\n\n\n    modifier onlyMinter{\n        require(hasRole(MINTER_ROLE, msg.sender), \"Caller is not a minter\");\n        _;\n    }\n\n    modifier onlyAdmin{\n        require(hasRole(ADMIN_ROLE, msg.sender), \"Caller is not an admin\");\n        _;\n    }\n    \n    function addMinter(address _account) external onlyAdmin{\n        _setupRole(MINTER_ROLE, _account);\n        emit AddNewMinter(_account,  msg.sender);\n    }\n\n    /**\n   * @notice as supportsInterface is present in both ERC721 and AccessControl we must specify the override here to dictate the order\n   */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Enumerable, AccessControl) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n    /**\n   * @notice Splits a deposit Receipt  into two NFTs. Assigns `percentageSplit` of the original\n   * pooled tokens to the new certificate.\n   * @notice only the owner of an NFTId or approved approved addresses can split an NFT\n   * @param _NFTId The id of the DepositReceipt NFT.\n   * @param _percentageSplit The percentage of pooled tokens assigned to the new NFT.\n   */\n\n   //Borrowed from original Lyra.finance ERC721 design.\n  function split(uint256 _NFTId, uint256 _percentageSplit) external returns (uint256) {\n    require(_percentageSplit < BASE, \"split must be less than 100%\");\n    require(_isApprovedOrOwner(msg.sender, _NFTId), \"ERC721: caller is not token owner or approved\");\n\n    uint256 existingPooledTokens = pooledTokens[_NFTId];\n    uint256 newPooledTokens = (existingPooledTokens * _percentageSplit)/ BASE;\n    pooledTokens[_NFTId] = existingPooledTokens - newPooledTokens;\n    uint256 newNFTId = _mintNewNFT(newPooledTokens, relatedDepositor[_NFTId]);\n    \n\n    emit NFTSplit(_NFTId, newNFTId);\n    emit NFTDataModified(_NFTId, existingPooledTokens, existingPooledTokens - newPooledTokens);\n    emit NFTDataModified(newNFTId, 0, newPooledTokens);\n    return newNFTId;\n    }\n    \n     /**\n      * @notice Only minter roles can burn Deposit receipts\n      * @dev burns 'amount' of tokens to address 'account', and emits Transfer event to \n      * to zero address.\n      * @param _NFTId The NFT id of the token to be burned, sender must be holder or approved by holder\n     **/\n    function burn(uint256 _NFTId) external onlyMinter{\n        require(_isApprovedOrOwner(msg.sender, _NFTId), \"ERC721: caller is not token owner or approved\");\n        delete pooledTokens[_NFTId];\n        delete relatedDepositor[_NFTId];\n        _burn(_NFTId);\n    }\n    /**\n      * @notice Only minter roles can mint Deposit receipts for new Pooled Tokens\n      * @dev Mints new NFT with '_pooledTokenAmount' of pooledTokens associated with it\n      * @param _pooledTokenAmount amount of pooled tokens to be associated with NFT\n     **/\n    function safeMint( uint _pooledTokenAmount) external onlyMinter returns(uint256){\n        return (_mintNewNFT(_pooledTokenAmount, msg.sender));\n    }\n\n    /**\n      * @notice Only callable by Minters via safeMint or  by split()\n      * @dev Mints new NFT with '_pooledTokenAmount' of pooledTokens associated with it and emits Transfer event\n      * @param _pooledTokenAmount amount of pooled tokens to be associated with NFT\n      * @param _depositor the address to be recorded as the related depositor where the pooledTokens can be withdrawn from\n     **/\n    function _mintNewNFT( uint _pooledTokenAmount, address _depositor) internal returns(uint256){\n        uint256 NFTId = currentLastId;\n        currentLastId += 1;\n        pooledTokens[NFTId] = _pooledTokenAmount;\n        relatedDepositor[NFTId] = _depositor; \n        _safeMint( msg.sender, NFTId);\n        return(NFTId);\n\n    }\n    /**\n     * @notice Pass through function that converts pooledTokens to underlying asset amounts. \n     * @dev for pricing THIS MUST NOT be used in isolation, use priceLiquidity instead\n     * @param _liquidity amount of pooledTokens you want to find the underlying liquidity for.\n     */\n    function viewQuoteRemoveLiquidity(uint256 _liquidity) public view returns( uint256, uint256 ){\n        uint256 token0Amount;\n        uint256 token1Amount;\n        (token0Amount, token1Amount) = router.quoteRemoveLiquidity(\n                                    token0, \n                                    token1,\n                                    stable,\n                                    _liquidity );\n        return (token0Amount, token1Amount);\n\n    }\n\n    /** \n     * @dev This function is view but uses block.timestamp which will only return a non-zero value in a tx call.\n     * @param _priceFeed the Chainlink aggregator for the price you want to retrieve, ETH or Token.\n     * @param _maxPrice the immutable maximum price this aggregator has\n     * @param _minPrice the immutable minimum price this aggregator has\n     * @return Oracle price converted to a uint256 for ease of use elsewhere\n     */\n    function getOraclePrice(IAggregatorV3 _priceFeed, int192 _maxPrice, int192 _minPrice) public view returns (uint256 ) {\n        (\n            /*uint80 roundID*/,\n            int signedPrice,\n            /*uint startedAt*/,\n            uint timeStamp,\n            /*uint80 answeredInRound*/\n        ) = _priceFeed.latestRoundData();\n        //check for Chainlink oracle deviancies, force a revert if any are present. Helps prevent a LUNA like issue\n        require(signedPrice > 0, \"Negative Oracle Price\");\n        require(timeStamp >= block.timestamp - HEARTBEAT_TIME , \"Stale pricefeed\");\n        require(signedPrice < _maxPrice, \"Upper price bound breached\");\n        require(signedPrice > _minPrice, \"Lower price bound breached\");\n        uint256 price = uint256(signedPrice);\n        return price;\n\n\n    }\n\n   /**\n    *  @notice this is used to price pooled Tokens by determining their underlying assets and then pricing these\n    *  @notice the two ways to do this are to price to USDC as  a dollar equivalent or to ETH then use Chainlink price feeds\n    *  @dev each DepositReceipt has a bespoke valuation method, make sure it fits the tokens\n    *  @dev each DepositReceipt's valuation method is sensitive to available liquidity keep this in mind as liquidating a pooled token by using the same pool will reduce overall liquidity\n\n    */\n    function priceLiquidity(uint256 _liquidity) external virtual view returns(uint256);\n}"
    }
  ]
}