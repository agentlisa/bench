{
  "Title": "Missing full sanity checks on adding accredited investors",
  "Content": "It is possible to `addAccreditedInvestor` with `minInvest` being greater than `maxCumulativeInvest`. Although this configuration will be recorded properly, it will throw an exception on [line 92](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeePresale.sol#L92) of the `buyTokens` function, therefore preventing the investor to take a part into the sale.\n\n\nWe recommend adding an extra precondition `require( minInvest &lt;= maxCumulativeInvest)` in [line 119](https://github.com/qiibee/qb-contracts/blob/26d5963491c26a56938c723a342b666d3b478ea7/contracts/QiibeePresale.sol#L119) so any potential errors are detected as early as possible.\n\n\n***Update:** Fixed in [this](https://github.com/qiibee/qb-contracts/commit/25efdbf5bc29de12a724450c540218f6c8e59129) commit.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/QiibeePresale.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport \"./Crowdsale.sol\";\n\n/**\n   @title Presale event\n\n   Implementation of the QBX Presale Token Generation Event (PTGE): A X-week capped presale with a\n   soft cap (goal) and a hard cap, both of them expressed in wei.\n\n   This presale is only for accredited investors, who will have to be whitelisted by the owner\n   using the addAccreditedInvestor() function. Each accredited investor has its own token rate, a\n   minimum amount of wei for each one of his transactions, a maximum cumulative investment and\n   vesting settings (cliff and vesting period).\n\n   On each purchase, the corresponding amount of tokens (given by the investor’s rate) will be\n   minted and vested (if the investor has vesting settings).\n\n   In case of the goal not being reached by purchases made during the event, all funds sent during\n   this period will be made available to be claimed by the originating addresses.\n\n   The token begins paused and remains like that at the end of the presale. The unpause of the token\n   will be done at the end of the qiibee crowdsale.\n */\n\ncontract QiibeePresale is Crowdsale {\n\n    using SafeMath for uint256;\n\n    struct AccreditedInvestor {\n      uint256 rate;\n      uint64 cliff;\n      uint64 vesting;\n      bool revokable;\n      bool burnsOnRevoke;\n      uint256 minInvest; // minimum invest in wei for a given investor\n      uint256 maxCumulativeInvest; // maximum cumulative invest in wei for a given investor\n    }\n\n    mapping (address => AccreditedInvestor) public accredited; // whitelist of investors\n\n    bool public isFinalized = false;\n\n    event NewAccreditedInvestor(address indexed from, address indexed buyer);\n\n    /*\n     * @dev Constructor.\n     * @param _startTime see `startTimestamp`\n     * @param _endTime see `endTimestamp`\n     * @param _goal see `see goal`\n     * @param _cap see `see cap`\n     * @param _maxGasPrice see `see maxGasPrice`\n     * @param _minBuyingRequestInterval see `see minBuyingRequestInterval`\n     * @param _wallet see `wallet`\n     */\n    function QiibeePresale(\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _goal,\n        uint256 _cap,\n        uint256 _maxGasPrice,\n        uint256 _minBuyingRequestInterval,\n        address _wallet\n    )\n      Crowdsale(_startTime, _endTime, _goal, _cap, _maxGasPrice, _minBuyingRequestInterval, _wallet)\n    {\n    }\n\n    /*\n     * @param beneficiary beneficiary address where tokens are sent to\n     */\n    function buyTokens(address beneficiary) public payable whenNotPaused{\n        require(beneficiary != address(0));\n        require(validPurchase());\n\n        AccreditedInvestor storage data = accredited[msg.sender];\n\n        // investor's data\n        uint256 rate = data.rate;\n        uint256 minInvest = data.minInvest;\n        uint256 maxCumulativeInvest = data.maxCumulativeInvest;\n        uint64 from = uint64(endTime);\n        uint64 cliff = from + data.cliff;\n        uint64 vesting = cliff + data.vesting;\n        bool revokable = data.revokable;\n        bool burnsOnRevoke = data.burnsOnRevoke;\n\n        uint256 tokens = msg.value.mul(rate);\n\n        // check investor's limits\n        uint256 newBalance = balances[beneficiary].add(msg.value);\n        require(newBalance <= maxCumulativeInvest && msg.value >= minInvest);\n\n        if (data.cliff > 0 && data.vesting > 0) {\n          require(token.mintVestedTokens(beneficiary, tokens, from, cliff, vesting, revokable, burnsOnRevoke, wallet));\n        } else {\n          require(token.mint(beneficiary, tokens));\n        }\n\n        // update state\n        balances[beneficiary] = newBalance;\n        weiRaised = weiRaised.add(msg.value);\n        tokensSold = tokensSold.add(tokens);\n\n        TokenPurchase(msg.sender, beneficiary, msg.value, tokens);\n\n        forwardFunds();\n    }\n\n    /*\n     * @dev Add an address to the accredited list.\n     */\n    function addAccreditedInvestor(address investor, uint256 rate, uint64 cliff, uint64 vesting, bool revokable, bool burnsOnRevoke, uint256 minInvest, uint256 maxCumulativeInvest) public onlyOwner {\n        require(investor != address(0));\n        require(rate > 0);\n        require(vesting >= cliff);\n        require(minInvest > 0);\n        require(maxCumulativeInvest > 0);\n\n        accredited[investor] = AccreditedInvestor(rate, cliff, vesting, revokable, burnsOnRevoke, minInvest, maxCumulativeInvest);\n\n        NewAccreditedInvestor(msg.sender, investor);\n    }\n\n    /*\n     * @dev checks if an address is accredited\n     * @return true if investor is accredited\n     */\n    function isAccredited(address investor) public constant returns (bool) {\n        AccreditedInvestor storage data = accredited[investor];\n        return data.rate > 0; //TODO: is there any way to properly check this?\n    }\n\n    /*\n     * @dev Remove an address from the accredited list.\n     */\n    function removeAccreditedInvestor(address investor) public onlyOwner {\n        require(investor != address(0));\n        delete accredited[investor];\n    }\n\n\n    // @return true if investors can buy at the moment\n    function validPurchase() internal constant returns (bool) {\n      require(isAccredited(msg.sender));\n      return super.validPurchase();\n    }\n\n    /**\n     * @dev Must be called after crowdsale ends, to do some extra finalization\n     * work. Calls the contract's finalization function.\n     */\n    function finalize() public {\n      require(!isFinalized);\n      require(hasEnded());\n\n      finalization();\n      Finalized();\n\n      isFinalized = true;\n\n      // transfer the ownership of the token to the foundation\n      token.transferOwnership(wallet);\n    }\n\n}"
    },
    {
      "filename": "contracts/QiibeePresale.sol",
      "content": "pragma solidity ^0.4.11;\n\nimport \"./Crowdsale.sol\";\n\n/**\n   @title Presale event\n\n   Implementation of the QBX Presale Token Generation Event (PTGE): A X-week capped presale with a\n   soft cap (goal) and a hard cap, both of them expressed in wei.\n\n   This presale is only for accredited investors, who will have to be whitelisted by the owner\n   using the addAccreditedInvestor() function. Each accredited investor has its own token rate, a\n   minimum amount of wei for each one of his transactions, a maximum cumulative investment and\n   vesting settings (cliff and vesting period).\n\n   On each purchase, the corresponding amount of tokens (given by the investor’s rate) will be\n   minted and vested (if the investor has vesting settings).\n\n   In case of the goal not being reached by purchases made during the event, all funds sent during\n   this period will be made available to be claimed by the originating addresses.\n\n   The token begins paused and remains like that at the end of the presale. The unpause of the token\n   will be done at the end of the qiibee crowdsale.\n */\n\ncontract QiibeePresale is Crowdsale {\n\n    using SafeMath for uint256;\n\n    struct AccreditedInvestor {\n      uint256 rate;\n      uint64 cliff;\n      uint64 vesting;\n      bool revokable;\n      bool burnsOnRevoke;\n      uint256 minInvest; // minimum invest in wei for a given investor\n      uint256 maxCumulativeInvest; // maximum cumulative invest in wei for a given investor\n    }\n\n    mapping (address => AccreditedInvestor) public accredited; // whitelist of investors\n\n    bool public isFinalized = false;\n\n    event NewAccreditedInvestor(address indexed from, address indexed buyer);\n\n    /*\n     * @dev Constructor.\n     * @param _startTime see `startTimestamp`\n     * @param _endTime see `endTimestamp`\n     * @param _goal see `see goal`\n     * @param _cap see `see cap`\n     * @param _maxGasPrice see `see maxGasPrice`\n     * @param _minBuyingRequestInterval see `see minBuyingRequestInterval`\n     * @param _wallet see `wallet`\n     */\n    function QiibeePresale(\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _goal,\n        uint256 _cap,\n        uint256 _maxGasPrice,\n        uint256 _minBuyingRequestInterval,\n        address _wallet\n    )\n      Crowdsale(_startTime, _endTime, _goal, _cap, _maxGasPrice, _minBuyingRequestInterval, _wallet)\n    {\n    }\n\n    /*\n     * @param beneficiary beneficiary address where tokens are sent to\n     */\n    function buyTokens(address beneficiary) public payable whenNotPaused{\n        require(beneficiary != address(0));\n        require(validPurchase());\n\n        AccreditedInvestor storage data = accredited[msg.sender];\n\n        // investor's data\n        uint256 rate = data.rate;\n        uint256 minInvest = data.minInvest;\n        uint256 maxCumulativeInvest = data.maxCumulativeInvest;\n        uint64 from = uint64(endTime);\n        uint64 cliff = from + data.cliff;\n        uint64 vesting = cliff + data.vesting;\n        bool revokable = data.revokable;\n        bool burnsOnRevoke = data.burnsOnRevoke;\n\n        uint256 tokens = msg.value.mul(rate);\n\n        // check investor's limits\n        uint256 newBalance = balances[beneficiary].add(msg.value);\n        require(newBalance <= maxCumulativeInvest && msg.value >= minInvest);\n\n        if (data.cliff > 0 && data.vesting > 0) {\n          require(token.mintVestedTokens(beneficiary, tokens, from, cliff, vesting, revokable, burnsOnRevoke, wallet));\n        } else {\n          require(token.mint(beneficiary, tokens));\n        }\n\n        // update state\n        balances[beneficiary] = newBalance;\n        weiRaised = weiRaised.add(msg.value);\n        tokensSold = tokensSold.add(tokens);\n\n        TokenPurchase(msg.sender, beneficiary, msg.value, tokens);\n\n        forwardFunds();\n    }\n\n    /*\n     * @dev Add an address to the accredited list.\n     */\n    function addAccreditedInvestor(address investor, uint256 rate, uint64 cliff, uint64 vesting, bool revokable, bool burnsOnRevoke, uint256 minInvest, uint256 maxCumulativeInvest) public onlyOwner {\n        require(investor != address(0));\n        require(rate > 0);\n        require(vesting >= cliff);\n        require(minInvest > 0);\n        require(maxCumulativeInvest > 0);\n\n        accredited[investor] = AccreditedInvestor(rate, cliff, vesting, revokable, burnsOnRevoke, minInvest, maxCumulativeInvest);\n\n        NewAccreditedInvestor(msg.sender, investor);\n    }\n\n    /*\n     * @dev checks if an address is accredited\n     * @return true if investor is accredited\n     */\n    function isAccredited(address investor) public constant returns (bool) {\n        AccreditedInvestor storage data = accredited[investor];\n        return data.rate > 0; //TODO: is there any way to properly check this?\n    }\n\n    /*\n     * @dev Remove an address from the accredited list.\n     */\n    function removeAccreditedInvestor(address investor) public onlyOwner {\n        require(investor != address(0));\n        delete accredited[investor];\n    }\n\n\n    // @return true if investors can buy at the moment\n    function validPurchase() internal constant returns (bool) {\n      require(isAccredited(msg.sender));\n      return super.validPurchase();\n    }\n\n    /**\n     * @dev Must be called after crowdsale ends, to do some extra finalization\n     * work. Calls the contract's finalization function.\n     */\n    function finalize() public {\n      require(!isFinalized);\n      require(hasEnded());\n\n      finalization();\n      Finalized();\n\n      isFinalized = true;\n\n      // transfer the ownership of the token to the foundation\n      token.transferOwnership(wallet);\n    }\n\n}"
    }
  ]
}