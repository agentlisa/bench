{
  "Title": "Unrestrained revert reason [core]",
  "Content": "The `EntryPoint` contract can emit a [`FailedOp` error](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IEntryPoint.sol#L63) where the `reason` parameter provides additional context for troubleshooting purposes. However, there are two locations ([line 375](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L375) and [line 417](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L417)) where an untrusted contract can provide the reason, potentially including misleading error codes. For example, the sender `validateUserOp` function might revert with `\"AA90 invalid beneficiary\"`, which might cause confusion during simulation.\n\n\nConsider prefixing the externally provided revert reasons with a uniquely identifying error code.\n\n\n***Update:** Resolved in [pull request #200](https://github.com/eth-infinitism/account-abstraction/pull/200) and merged at commit [`3d8f450`](https://github.com/eth-infinitism/account-abstraction/commit/3d8f4508b23d712859d08aa848d6fc729c2761ad).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/interfaces/IEntryPoint.sol",
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./UserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\n\ninterface IEntryPoint is IStakeManager {\n\n    /***\n     * An event emitted after each successful request\n     * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\n     * @param sender - the account that generates this request.\n     * @param paymaster - if non-null, the paymaster that pays for this request.\n     * @param nonce - the nonce value from the request\n     * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation\n     * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution)\n     * @param success - true if the sender transaction succeeded, false if reverted.\n     */\n    event UserOperationEvent(bytes32 indexed userOpHash, address indexed sender, address indexed paymaster, uint256 nonce, bool success, uint256 actualGasCost, uint256 actualGasUsed);\n\n    /**\n     * account \"sender\" was deployed.\n     * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender the account that is deployed\n     * @param factory the factory used to deploy this account (in the initCode)\n     * @param paymaster the paymaster used by this UserOp\n     */\n    event AccountDeployed(bytes32 indexed userOpHash, address indexed sender, address factory, address paymaster);\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length\n     * @param userOpHash the request unique identifier.\n     * @param sender the sender of this request\n     * @param nonce the nonce used in the request\n     * @param revertReason - the return bytes from the (reverted) call to \"callData\".\n     */\n    event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason);\n\n    /**\n     * signature aggregator used by the following UserOperationEvents within this bundle.\n     */\n    event SignatureAggregatorChanged(address aggregator);\n\n    /**\n     * a custom revert error of handleOps, to identify the offending op.\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\n     *  @param paymaster - if paymaster.validatePaymasterUserOp fails, this will be the paymaster's address. if validateUserOp failed,\n     *       this value will be zero (since it failed before accessing the paymaster)\n     *  @param reason - revert reason\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of account/paymaster reverts.\n     */\n    error FailedOp(uint256 opIndex, address paymaster, string reason);\n\n    /**\n     * error case when a signature aggregator fails to verify the aggregated signature it had created.\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    //UserOps handled, per aggregator\n    struct UserOpsPerAggregator {\n        UserOperation[] userOps;\n\n        // aggregator address\n        IAggregator aggregator;\n        // aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperation.\n     * no signature aggregator is used.\n     * if any account requires an aggregator (that is, it returned an \"actualAggregator\" when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\n     * @param beneficiary the address to receive the fees\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     */\n    function getUserOpHash(UserOperation calldata userOp) external view returns (bytes32);\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\n     * @param userOp the user operation to validate.\n     */\n    function simulateValidation(UserOperation calldata userOp) external;\n\n    /**\n     * Successful result from simulateValidation.\n     * @param returnInfo gas and time-range returned values\n     * @param senderInfo stake information about the sender\n     * @param factoryInfo stake information about the factor (if any)\n     * @param paymasterInfo stake information about the paymaster (if any)\n     */\n    error ValidationResult(ReturnInfo returnInfo,\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo);\n\n\n    /**\n     * Successful result from simulateValidation, if the account returns a signature aggregator\n     * @param returnInfo gas and time-range returned values\n     * @param senderInfo stake information about the sender\n     * @param factoryInfo stake information about the factor (if any)\n     * @param paymasterInfo stake information about the paymaster (if any)\n     * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\n     *      bundler MUST use it to verify the signature, or reject the UserOperation\n     */\n    error ValidationResultWithAggregation(ReturnInfo returnInfo,\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo,\n        AggregatorStakeInfo aggregatorInfo);\n\n    /**\n     * gas and return values during simulation\n     * @param preOpGas the gas used for validation (including preValidationGas)\n     * @param prefund the required prefund for this operation\n     * @param sigFailed validateUserOp's (or paymaster's) signature check failed\n     * @param validAfter - first timestamp this UserOp is valid (merging account and paymaster time-range)\n     * @param validUntil - last timestamp this UserOp is valid (merging account and paymaster time-range)\n     * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        bool sigFailed;\n        uint64 validAfter;\n        uint64 validUntil;\n        bytes paymasterContext;\n    }\n\n    /**\n     * returned aggregated signature info.\n     * the aggregator returned by the account, and its current stake.\n     */\n    struct AggregatorStakeInfo {\n        address actualAggregator;\n        StakeInfo stakeInfo;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * this method always revert, and returns the address in SenderAddressResult error\n     * @param initCode the constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n    /**\n     * return value of getSenderAddress\n     */\n    error SenderAddressResult(address sender);\n\n\n    /**\n     * simulate full execution of a UserOperation (including both validation and target execution)\n     * this method will always revert with \"ExecutionResult\".\n     * it performs full validation of the UserOperation, but ignores signature error.\n     * Note that in order to collect the the success/failure of the target call, it must be executed\n     * with trace enabled to track the emitted events.\n     */\n    function simulateHandleOp(UserOperation calldata op) external;\n\n    error ExecutionResult(uint256 preOpGas, uint256 paid, uint64 validAfter, uint64 validBefore);\n}"
    }
  ]
}