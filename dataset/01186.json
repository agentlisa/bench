{
  "Title": "Logic in `LibFertilizer::push` related to (deprecated) intermediate addition of Fertilizer to FIFO list should be removed",
  "Content": "Intermediate addition to the FIFO list was formerly allowed only by the Beanstalk DAO, but this functionality has since been deprecated in the current upgrade with the removal of `FertilizerFacet::addFertilizerOwner`. Consequently, the [corresponding logic](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/contracts/libraries/LibFertilizer.sol#L139-L147) in `LibFertilizer::push` should be removed as this now represents unreachable code.\n\n**Beanstalk Farms:** the `push(...)` function is still used internally [here](https://github.com/BeanstalkFarms/Beanstalk/blob/12c608a22535e3a1fe379db1153185fe43851ea7/protocol/contracts/libraries/LibFertilizer.sol#L60).\n\nThe highlighted segment is not used reachable anymore, but in the case where the humidity is changed for some reason, it could again be reached. For this reason, the decision was made to leave it in.\n\n**Cyfrin:** Acknowledged.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/LibFertilizer.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {AppStorage, LibAppStorage} from \"./LibAppStorage.sol\";\nimport {LibSafeMath128} from \"./LibSafeMath128.sol\";\nimport {C} from \"../C.sol\";\nimport {LibUnripe} from \"./LibUnripe.sol\";\nimport {IWell} from \"contracts/interfaces/basin/IWell.sol\";\n\n/**\n * @author Publius\n * @title Fertilizer\n **/\n\nlibrary LibFertilizer {\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n    using SafeCast for uint256;\n\n    event SetFertilizer(uint128 id, uint128 bpf);\n\n    // 6 - 3\n    uint128 private constant PADDING = 1e3;\n    uint128 private constant DECIMALS = 1e6;\n    uint128 private constant REPLANT_SEASON = 6074;\n    uint128 private constant RESTART_HUMIDITY = 2500;\n    uint128 private constant END_DECREASE_SEASON = REPLANT_SEASON + 461;\n\n    function addFertilizer(\n        uint128 season,\n        uint256 fertilizerAmount,\n        uint256 minLP\n    ) internal returns (uint128 id) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        uint128 fertilizerAmount128 = fertilizerAmount.toUint128();\n\n        // Calculate Beans Per Fertilizer and add to total owed\n        uint128 bpf = getBpf(season);\n        s.unfertilizedIndex = s.unfertilizedIndex.add(\n            fertilizerAmount.mul(bpf)\n        );\n        // Get id\n        id = s.bpf.add(bpf);\n        // Update Total and Season supply\n        s.fertilizer[id] = s.fertilizer[id].add(fertilizerAmount128);\n        s.activeFertilizer = s.activeFertilizer.add(fertilizerAmount);\n        // Add underlying to Unripe Beans and Unripe LP\n        addUnderlying(fertilizerAmount.mul(DECIMALS), minLP);\n        // If not first time adding Fertilizer with this id, return\n        if (s.fertilizer[id] > fertilizerAmount128) return id;\n        // If first time, log end Beans Per Fertilizer and add to Season queue.\n        push(id);\n        emit SetFertilizer(id, bpf);\n    }\n\n    function getBpf(uint128 id) internal pure returns (uint128 bpf) {\n        bpf = getHumidity(id).add(1000).mul(PADDING);\n    }\n\n    function getHumidity(uint128 id) internal pure returns (uint128 humidity) {\n        if (id == 0) return 5000;\n        if (id >= END_DECREASE_SEASON) return 200;\n        uint128 humidityDecrease = id.sub(REPLANT_SEASON).mul(5);\n        humidity = RESTART_HUMIDITY.sub(humidityDecrease);\n    }\n\n    /**\n     * @dev Any WETH contributions should already be transferred to the Bean:Eth Well to allow for a gas efficient liquidity\n     * addition through the use of `sync`. See {FertilizerFacet.mintFertilizer} for an example.\n     */\n    function addUnderlying(uint256 usdAmount, uint256 minAmountOut) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // Calculate how many new Deposited Beans will be minted\n        uint256 percentToFill = usdAmount.mul(C.precision()).div(\n            remainingRecapitalization()\n        );\n        uint256 newDepositedBeans;\n        if (C.unripeBean().totalSupply() > s.u[C.UNRIPE_BEAN].balanceOfUnderlying) {\n            newDepositedBeans = (C.unripeBean().totalSupply()).sub(\n                s.u[C.UNRIPE_BEAN].balanceOfUnderlying\n            );\n            newDepositedBeans = newDepositedBeans.mul(percentToFill).div(\n                C.precision()\n            );\n        }\n\n        // Calculate how many Beans to add as LP\n        uint256 newDepositedLPBeans = usdAmount.mul(C.exploitAddLPRatio()).div(\n            DECIMALS\n        );\n\n        // Mint the Deposited Beans to Beanstalk.\n        C.bean().mint(\n            address(this),\n            newDepositedBeans\n        );\n\n        // Mint the LP Beans to the Well to sync.\n        C.bean().mint(\n            address(C.BEAN_ETH_WELL),\n            newDepositedLPBeans\n        );\n\n        uint256 newLP = IWell(C.BEAN_ETH_WELL).sync(\n            address(this),\n            minAmountOut\n        );\n\n        // Increment underlying balances of Unripe Tokens\n        LibUnripe.incrementUnderlying(C.UNRIPE_BEAN, newDepositedBeans);\n        LibUnripe.incrementUnderlying(C.UNRIPE_LP, newLP);\n\n        s.recapitalized = s.recapitalized.add(usdAmount);\n    }\n\n    function push(uint128 id) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        if (s.fFirst == 0) {\n            // Queue is empty\n            s.season.fertilizing = true;\n            s.fLast = id;\n            s.fFirst = id;\n        } else if (id <= s.fFirst) {\n            // Add to front of queue\n            setNext(id, s.fFirst);\n            s.fFirst = id;\n        } else if (id >= s.fLast) {\n            // Add to back of queue\n            setNext(s.fLast, id);\n            s.fLast = id;\n        } else {\n            // Add to middle of queue\n            uint128 prev = s.fFirst;\n            uint128 next = getNext(prev);\n            // Search for proper place in line\n            while (id > next) {\n                prev = next;\n                next = getNext(next);\n            }\n            setNext(prev, id);\n            setNext(id, next);\n        }\n    }\n\n    function remainingRecapitalization()\n        internal\n        view\n        returns (uint256 remaining)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 totalDollars = C\n            .dollarPerUnripeLP()\n            .mul(C.unripeLP().totalSupply())\n            .div(DECIMALS);\n        totalDollars = totalDollars / 1e6 * 1e6; // round down to nearest USDC\n        if (s.recapitalized >= totalDollars) return 0;\n        return totalDollars.sub(s.recapitalized);\n    }\n\n    function pop() internal returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint128 first = s.fFirst;\n        s.activeFertilizer = s.activeFertilizer.sub(getAmount(first));\n        uint128 next = getNext(first);\n        if (next == 0) {\n            // If all Unfertilized Beans have been fertilized, delete line.\n            require(s.activeFertilizer == 0, \"Still active fertilizer\");\n            s.fFirst = 0;\n            s.fLast = 0;\n            s.season.fertilizing = false;\n            return false;\n        }\n        s.fFirst = getNext(first);\n        return true;\n    }\n\n    function getAmount(uint128 id) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.fertilizer[id];\n    }\n\n    function getNext(uint128 id) internal view returns (uint128) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.nextFid[id];\n    }\n\n    function setNext(uint128 id, uint128 next) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.nextFid[id] = next;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/LibFertilizer.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {AppStorage, LibAppStorage} from \"./LibAppStorage.sol\";\nimport {LibSafeMath128} from \"./LibSafeMath128.sol\";\nimport {C} from \"../C.sol\";\nimport {LibUnripe} from \"./LibUnripe.sol\";\nimport {IWell} from \"contracts/interfaces/basin/IWell.sol\";\n\n/**\n * @author Publius\n * @title Fertilizer\n **/\n\nlibrary LibFertilizer {\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n    using SafeCast for uint256;\n\n    event SetFertilizer(uint128 id, uint128 bpf);\n\n    // 6 - 3\n    uint128 private constant PADDING = 1e3;\n    uint128 private constant DECIMALS = 1e6;\n    uint128 private constant REPLANT_SEASON = 6074;\n    uint128 private constant RESTART_HUMIDITY = 2500;\n    uint128 private constant END_DECREASE_SEASON = REPLANT_SEASON + 461;\n\n    function addFertilizer(\n        uint128 season,\n        uint256 fertilizerAmount,\n        uint256 minLP\n    ) internal returns (uint128 id) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        uint128 fertilizerAmount128 = fertilizerAmount.toUint128();\n\n        // Calculate Beans Per Fertilizer and add to total owed\n        uint128 bpf = getBpf(season);\n        s.unfertilizedIndex = s.unfertilizedIndex.add(\n            fertilizerAmount.mul(bpf)\n        );\n        // Get id\n        id = s.bpf.add(bpf);\n        // Update Total and Season supply\n        s.fertilizer[id] = s.fertilizer[id].add(fertilizerAmount128);\n        s.activeFertilizer = s.activeFertilizer.add(fertilizerAmount);\n        // Add underlying to Unripe Beans and Unripe LP\n        addUnderlying(fertilizerAmount.mul(DECIMALS), minLP);\n        // If not first time adding Fertilizer with this id, return\n        if (s.fertilizer[id] > fertilizerAmount128) return id;\n        // If first time, log end Beans Per Fertilizer and add to Season queue.\n        push(id);\n        emit SetFertilizer(id, bpf);\n    }\n\n    function getBpf(uint128 id) internal pure returns (uint128 bpf) {\n        bpf = getHumidity(id).add(1000).mul(PADDING);\n    }\n\n    function getHumidity(uint128 id) internal pure returns (uint128 humidity) {\n        if (id == 0) return 5000;\n        if (id >= END_DECREASE_SEASON) return 200;\n        uint128 humidityDecrease = id.sub(REPLANT_SEASON).mul(5);\n        humidity = RESTART_HUMIDITY.sub(humidityDecrease);\n    }\n\n    /**\n     * @dev Any WETH contributions should already be transferred to the Bean:Eth Well to allow for a gas efficient liquidity\n     * addition through the use of `sync`. See {FertilizerFacet.mintFertilizer} for an example.\n     */\n    function addUnderlying(uint256 usdAmount, uint256 minAmountOut) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // Calculate how many new Deposited Beans will be minted\n        uint256 percentToFill = usdAmount.mul(C.precision()).div(\n            remainingRecapitalization()\n        );\n        uint256 newDepositedBeans;\n        if (C.unripeBean().totalSupply() > s.u[C.UNRIPE_BEAN].balanceOfUnderlying) {\n            newDepositedBeans = (C.unripeBean().totalSupply()).sub(\n                s.u[C.UNRIPE_BEAN].balanceOfUnderlying\n            );\n            newDepositedBeans = newDepositedBeans.mul(percentToFill).div(\n                C.precision()\n            );\n        }\n\n        // Calculate how many Beans to add as LP\n        uint256 newDepositedLPBeans = usdAmount.mul(C.exploitAddLPRatio()).div(\n            DECIMALS\n        );\n\n        // Mint the Deposited Beans to Beanstalk.\n        C.bean().mint(\n            address(this),\n            newDepositedBeans\n        );\n\n        // Mint the LP Beans to the Well to sync.\n        C.bean().mint(\n            address(C.BEAN_ETH_WELL),\n            newDepositedLPBeans\n        );\n\n        uint256 newLP = IWell(C.BEAN_ETH_WELL).sync(\n            address(this),\n            minAmountOut\n        );\n\n        // Increment underlying balances of Unripe Tokens\n        LibUnripe.incrementUnderlying(C.UNRIPE_BEAN, newDepositedBeans);\n        LibUnripe.incrementUnderlying(C.UNRIPE_LP, newLP);\n\n        s.recapitalized = s.recapitalized.add(usdAmount);\n    }\n\n    function push(uint128 id) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        if (s.fFirst == 0) {\n            // Queue is empty\n            s.season.fertilizing = true;\n            s.fLast = id;\n            s.fFirst = id;\n        } else if (id <= s.fFirst) {\n            // Add to front of queue\n            setNext(id, s.fFirst);\n            s.fFirst = id;\n        } else if (id >= s.fLast) {\n            // Add to back of queue\n            setNext(s.fLast, id);\n            s.fLast = id;\n        } else {\n            // Add to middle of queue\n            uint128 prev = s.fFirst;\n            uint128 next = getNext(prev);\n            // Search for proper place in line\n            while (id > next) {\n                prev = next;\n                next = getNext(next);\n            }\n            setNext(prev, id);\n            setNext(id, next);\n        }\n    }\n\n    function remainingRecapitalization()\n        internal\n        view\n        returns (uint256 remaining)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 totalDollars = C\n            .dollarPerUnripeLP()\n            .mul(C.unripeLP().totalSupply())\n            .div(DECIMALS);\n        totalDollars = totalDollars / 1e6 * 1e6; // round down to nearest USDC\n        if (s.recapitalized >= totalDollars) return 0;\n        return totalDollars.sub(s.recapitalized);\n    }\n\n    function pop() internal returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint128 first = s.fFirst;\n        s.activeFertilizer = s.activeFertilizer.sub(getAmount(first));\n        uint128 next = getNext(first);\n        if (next == 0) {\n            // If all Unfertilized Beans have been fertilized, delete line.\n            require(s.activeFertilizer == 0, \"Still active fertilizer\");\n            s.fFirst = 0;\n            s.fLast = 0;\n            s.season.fertilizing = false;\n            return false;\n        }\n        s.fFirst = getNext(first);\n        return true;\n    }\n\n    function getAmount(uint128 id) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.fertilizer[id];\n    }\n\n    function getNext(uint128 id) internal view returns (uint128) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.nextFid[id];\n    }\n\n    function setNext(uint128 id, uint128 next) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.nextFid[id] = next;\n    }\n}"
    }
  ]
}