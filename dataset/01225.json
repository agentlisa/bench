{
  "Title": "Users can avoid liquidation while being under the primary liquidation ratio if on the last short record",
  "Content": "# Users can avoid liquidation while being under the primary liquidation ratio if on the last short record\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L153\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibShortRecord.sol#L153</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L43\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L43</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L89\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L89</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L351\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/MarginCallPrimaryFacet.sol#L351</a>\n\n\n## Summary\nThe protocol permits users to maintain up to 254 concurrent short records. When this limit is reached, any additional orders are appended to the final position, rather than creating a new one. A short record is subject to flagging if it breaches the primary liquidation ratio set by the protocol, leading to potential liquidation if it remains below the threshold for a predefined period.\n\nThe vulnerability emerges from the dependency of liquidation times on the **`updatedAt`** value of shorts. For the last short record, the appending of any new orders provides an alternative pathway for updating the **`updatedAt`** value of shorts, enabling users to circumvent liquidation by submitting minimal shorts to block liquidation by adjusting the time difference, thus avoiding liquidation even when they do not meet the collateral requirements for a healthy state.\n\n## Vulnerability Details\nlets take a look at the code to see how this works.\n1. **Flagging of Short Record:**\n    - The **`flagShort`** function allows a short to be flagged if it's under **`primaryLiquidationCR`**, subsequently invoking **`setFlagger`** which updates the short's **`updatedAt`** timestamp to the current time.\n\n```solidity\nfunction flagShort(address asset, address shorter, uint8 id, uint16 flaggerHint)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, shorter, id)\n    {\n        // initial code\n\n        short.setFlagger(cusd, flaggerHint);\n        emit Events.FlagShort(asset, shorter, id, msg.sender, adjustedTimestamp);\n    }\n```\n\n1. **Liquidation Eligibility Check:**\n    - The **`_canLiquidate`** function assesses whether the flagged short is still under **`primaryLiquidationCR`** after a certain period and if it's eligible for liquidation, depending on the **`updatedAt`** timestamp and various liquidation time frames.\n\n```solidity\nfunction _canLiquidate(MTypes.MarginCallPrimary memory m)\n        private\n        view\n        returns (bool)\n    {\n       // Initial code\n\n        uint256 timeDiff = LibOrders.getOffsetTimeHours() - m.short.updatedAt;\n        uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(m.asset);\n\n        if (timeDiff >= resetLiquidationTime) {\n            return false;\n        } else {\n            uint256 secondLiquidationTime = LibAsset.secondLiquidationTime(m.asset);\n            bool isBetweenFirstAndSecondLiquidationTime = timeDiff\n                > LibAsset.firstLiquidationTime(m.asset) && timeDiff <= secondLiquidationTime\n                && s.flagMapping[m.short.flaggerId] == msg.sender;\n            bool isBetweenSecondAndResetLiquidationTime =\n                timeDiff > secondLiquidationTime && timeDiff <= resetLiquidationTime;\n            if (\n                !(\n                    (isBetweenFirstAndSecondLiquidationTime)\n                        || (isBetweenSecondAndResetLiquidationTime)\n                )\n            ) {\n                revert Errors.MarginCallIneligibleWindow();\n            }\n\n            return true;\n        }\n    }\n}\n```\n\n1. **Short Record Merging:**\n    - For the last short record, the **`fillShortRecord`** function combines new matched shorts with the existing one, invoking the **`merge`** function, which updates the **`updatedAt`** value to the current time.\n\n```solidity\nfunction fillShortRecord(\n        address asset,\n        address shorter,\n        uint8 shortId,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint256 ercDebtRate,\n        uint256 zethYieldRate\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        uint256 ercDebtSocialized = ercAmount.mul(ercDebtRate);\n        uint256 yield = collateral.mul(zethYieldRate);\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][shortId];\n        if (short.status == SR.Cancelled) {\n            short.ercDebt = short.collateral = 0;\n        }\n\n        short.status = status;\n        LibShortRecord.merge(\n            short,\n            ercAmount,\n            ercDebtSocialized,\n            collateral,\n            yield,\n            LibOrders.getOffsetTimeHours()\n        );\n    }\n```\n\n- In the merge function we see that we update the updatedAt value to creationTime which is  LibOrders.getOffsetTimeHours().\n\n```solidity\nfunction merge(\n        STypes.ShortRecord storage short,\n        uint88 ercDebt,\n        uint256 ercDebtSocialized,\n        uint88 collateral,\n        uint256 yield,\n        uint24 creationTime\n    ) internal {\n        // Resolve ercDebt\n        ercDebtSocialized += short.ercDebt.mul(short.ercDebtRate);\n        short.ercDebt += ercDebt;\n        short.ercDebtRate = ercDebtSocialized.divU64(short.ercDebt);\n        // Resolve zethCollateral\n        yield += short.collateral.mul(short.zethYieldRate);\n        short.collateral += collateral;\n        short.zethYieldRate = yield.divU80(short.collateral);\n        // Assign updatedAt\n        short.updatedAt = creationTime;\n    }\n```\n\n- This means that even if the position was flagged and is still under the **`primaryLiquidationCR`**, it cannot be liquidated as the **`updatedAt`** timestamp has been updated, making the time difference not big enough.\n\n<details>\n  <summary><b>Click to expand Proof of Concept</b></summary>\n\n  ```solidity\n    function testShortAvoidLiquidation() public {\n        // fill  shorts (up to 254)\n        for (uint i; i < 253; i++) {\n            fundLimitShortOpt(DEFAULT_PRICE, DEFAULT_AMOUNT * 5, sender);\n            fundLimitBidOpt(DEFAULT_PRICE, DEFAULT_AMOUNT * 5, receiver);\n        } \n        \n        // check users last shortrecord\n        assertTrue(getShortRecord(sender, 254).status == SR.FullyFilled);\n\n        // price drop\n        skipTimeAndSetEth(1 hours, 2000 ether);\n\n        // flag short\n        vm.prank(receiver);\n        diamond.flagShort(asset, sender, 254, Constants.HEAD);\n\n        // check flag\n        assertTrue(getShortRecord(sender, 254).flaggerId == 1);\n\n        // skip time to primary liquidation time\n        skipTimeAndSetEth(11 hours, 2000 ether);\n\n        // User matches new min short (added to last spot)\n        fundLimitShortOpt(DEFAULT_PRICE * 2, DEFAULT_AMOUNT  , sender);\n        fundLimitBidOpt(DEFAULT_PRICE * 2, DEFAULT_AMOUNT  , receiver);\n\n        // flagger tries to liquidate short in eligible window\n        fundLimitAskOpt(DEFAULT_PRICE, DEFAULT_AMOUNT * 6, extra);\n        vm.startPrank(receiver);\n        vm.expectRevert(Errors.MarginCallIneligibleWindow.selector);\n        diamond.liquidate(\n            asset, sender, 254, shortHintArrayStorage\n        );\n        vm.stopPrank();\n    }\n```\n</details>\n\n## Impact\nThis allows a user with a position under the primaryLiquidationCR to avoid primary liquidation even if the short is in the valid time ranges for liquidation.\n\n## Tools Used\n- Manual analysis\n- Foundry\n\n## Recommendations\nImpose stricter conditions for updating the last short record when the position is flagged and remains under the **`primaryLiquidationCR`** post-merge, similar to how the **`combineShorts`** function works.\n\n```solidity\nfunction createShortRecord(\n        address asset,\n        address shorter,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint64 ercDebtRate,\n        uint80 zethYieldRate,\n        uint40 tokenId\n    ) internal returns (uint8 id) {\n        AppStorage storage s = appStorage();\n\n        // Initial code\n\n        } else {\n            // All shortRecordIds used, combine into max shortRecordId\n            id = Constants.SHORT_MAX_ID;\n            fillShortRecord(\n                asset,\n                shorter,\n                id,\n                status,\n                collateral,\n                ercAmount,\n                ercDebtRate,\n                zethYieldRate\n            );\n\n\t\t\t\t// If the short was flagged, ensure resulting c-ratio > primaryLiquidationCR\n\t\t        if (Constants.SHORT_MAX_ID.shortFlagExists) {\n\t                if (\n\t                    Constants.SHORT_MAX_ID.getCollateralRatioSpotPrice(\n\t                        LibOracle.getSavedOrSpotOraclePrice(_asset)\n\t                    ) < LibAsset.primaryLiquidationCR(_asset)\n\t                ) revert Errors.InsufficientCollateral();\n\t                // Resulting combined short has sufficient c-ratio to remove flag\n\t                Constants.SHORT_MAX_ID.resetFlag();\n\t\t        }\n            }\n    }\n```",
  "Impact": "HIGH",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/libraries/LibShortRecord.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {STypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibShortRecord {\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    function getCollateralRatio(STypes.ShortRecord memory short, address asset)\n        internal\n        view\n        returns (uint256 cRatio)\n    {\n        return short.collateral.div(short.ercDebt.mul(LibOracle.getPrice(asset)));\n    }\n\n    function getCollateralRatioSpotPrice(\n        STypes.ShortRecord memory short,\n        uint256 oraclePrice\n    ) internal pure returns (uint256 cRatio) {\n        return short.collateral.div(short.ercDebt.mul(oraclePrice));\n    }\n\n    /**\n     * @notice Returns number of active shortRecords\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter address\n     *\n     * @return shortRecordCount\n     */\n    function getShortRecordCount(address asset, address shorter)\n        internal\n        view\n        returns (uint256 shortRecordCount)\n    {\n        AppStorage storage s = appStorage();\n\n        // Retrieve first non-HEAD short\n        uint8 id = s.shortRecords[asset][shorter][Constants.HEAD].nextId;\n        if (id <= Constants.HEAD) {\n            return 0;\n        }\n\n        while (true) {\n            shortRecordCount++;\n            // One short of one shorter in this order book\n            STypes.ShortRecord storage currentShort = s.shortRecords[asset][shorter][id];\n            // Move to next short unless this is the last one\n            if (currentShort.nextId > Constants.HEAD) {\n                id = currentShort.nextId;\n            } else {\n                return shortRecordCount;\n            }\n        }\n    }\n\n    function createShortRecord(\n        address asset,\n        address shorter,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint64 ercDebtRate,\n        uint80 zethYieldRate,\n        uint40 tokenId\n    ) internal returns (uint8 id) {\n        AppStorage storage s = appStorage();\n\n        // ensure the tokenId can be downcasted to 40 bits\n        if (tokenId > type(uint40).max) revert Errors.InvalidTokenId();\n\n        uint8 nextId;\n        (id, nextId) = setShortRecordIds(asset, shorter);\n\n        if (id <= Constants.SHORT_MAX_ID) {\n            s.shortRecords[asset][shorter][id] = STypes.ShortRecord({\n                prevId: Constants.HEAD,\n                id: id,\n                nextId: nextId,\n                status: status,\n                collateral: collateral,\n                ercDebt: ercAmount,\n                ercDebtRate: ercDebtRate,\n                zethYieldRate: zethYieldRate,\n                flaggerId: 0,\n                tokenId: tokenId,\n                updatedAt: LibOrders.getOffsetTimeHours()\n            });\n            emit Events.CreateShortRecord(asset, shorter, id);\n        } else {\n            // All shortRecordIds used, combine into max shortRecordId\n            id = Constants.SHORT_MAX_ID;\n            fillShortRecord(\n                asset,\n                shorter,\n                id,\n                status,\n                collateral,\n                ercAmount,\n                ercDebtRate,\n                zethYieldRate\n            );\n        }\n    }\n\n    function transferShortRecord(\n        address asset,\n        address from,\n        address to,\n        uint40 tokenId,\n        STypes.NFT memory nft\n    ) internal {\n        AppStorage storage s = appStorage();\n        STypes.ShortRecord storage short = s.shortRecords[asset][from][nft.shortRecordId];\n        if (short.status == SR.Cancelled) revert Errors.OriginalShortRecordCancelled();\n        if (short.flaggerId != 0) revert Errors.CannotTransferFlaggedShort();\n\n        deleteShortRecord(asset, from, nft.shortRecordId);\n\n        uint8 id = createShortRecord(\n            asset,\n            to,\n            SR.FullyFilled,\n            short.collateral,\n            short.ercDebt,\n            short.ercDebtRate,\n            short.zethYieldRate,\n            tokenId\n        );\n\n        if (id == Constants.SHORT_MAX_ID) {\n            revert Errors.ReceiverExceededShortRecordLimit();\n        }\n\n        s.nftMapping[tokenId].owner = to;\n        s.nftMapping[tokenId].shortRecordId = id;\n    }\n\n    function fillShortRecord(\n        address asset,\n        address shorter,\n        uint8 shortId,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint256 ercDebtRate,\n        uint256 zethYieldRate\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        uint256 ercDebtSocialized = ercAmount.mul(ercDebtRate);\n        uint256 yield = collateral.mul(zethYieldRate);\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][shortId];\n        if (short.status == SR.Cancelled) {\n            short.ercDebt = short.collateral = 0;\n        }\n\n        short.status = status;\n        LibShortRecord.merge(\n            short,\n            ercAmount,\n            ercDebtSocialized,\n            collateral,\n            yield,\n            LibOrders.getOffsetTimeHours()\n        );\n    }\n\n    function deleteShortRecord(address asset, address shorter, uint8 id) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage shortRecord = s.shortRecords[asset][shorter][id];\n        // Because of the onlyValidShortRecord modifier, only cancelShort can pass SR.Cancelled\n        // Don't recycle shortRecord id 254 so it can be used for all overflow uint8 ids\n        if (shortRecord.status != SR.PartialFill && id < Constants.SHORT_MAX_ID) {\n            // remove the links of ID in the market\n            // @dev (ID) is exiting, [ID] is inserted\n            // BEFORE: PREV <-> (ID) <-> NEXT\n            // AFTER : PREV <----------> NEXT\n            s.shortRecords[asset][shorter][shortRecord.prevId].nextId = shortRecord.nextId;\n            if (shortRecord.nextId != Constants.HEAD) {\n                s.shortRecords[asset][shorter][shortRecord.nextId].prevId =\n                    shortRecord.prevId;\n            }\n            // Make reuseable for future short records\n            uint8 prevHEAD = s.shortRecords[asset][shorter][Constants.HEAD].prevId;\n            s.shortRecords[asset][shorter][Constants.HEAD].prevId = id;\n            // Move the cancelled ID behind HEAD to re-use it\n            // note: C_IDs (cancelled ids) only need to point back (set prevId, can retain nextId)\n            // BEFORE: .. C_ID2 <- C_ID1 <--------- HEAD <-> ... [ID]\n            // AFTER1: .. C_ID2 <- C_ID1 <- [ID] <- HEAD <-> ...\n            if (prevHEAD > Constants.HEAD) {\n                shortRecord.prevId = prevHEAD;\n            } else {\n                // if this is the first ID cancelled\n                // HEAD.prevId needs to be HEAD\n                // and one of the cancelled id.prevID should point to HEAD\n                // BEFORE: HEAD <--------- HEAD <-> ... [ID]\n                // AFTER1: HEAD <- [ID] <- HEAD <-> ...\n                shortRecord.prevId = Constants.HEAD;\n            }\n\n            //Event for delete SR is emitted here and not at the top level because\n            //SR may be cancelled, but there might tied to an active short order\n            //The code above is hit when that SR id is ready for reuse\n            emit Events.DeleteShortRecord(asset, shorter, id);\n        }\n\n        shortRecord.status = SR.Cancelled;\n    }\n\n    function setShortRecordIds(address asset, address shorter)\n        private\n        returns (uint8 id, uint8 nextId)\n    {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage guard = s.shortRecords[asset][shorter][Constants.HEAD];\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][shorter];\n        // Initialize HEAD in case of first short createShortRecord\n        if (AssetUser.shortRecordId == 0) {\n            AssetUser.shortRecordId = Constants.SHORT_STARTING_ID;\n            guard.prevId = Constants.HEAD;\n            guard.nextId = Constants.HEAD;\n        }\n        // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n        // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n        // place created short next to HEAD\n        nextId = guard.nextId;\n        uint8 canceledId = guard.prevId;\n        // @dev (ID) is exiting, [ID] is inserted\n        // in this case, the protocol re-uses (ID) and moves it to [ID]\n        // check if a previously closed short exists\n        if (canceledId > Constants.HEAD) {\n            // BEFORE: CancelledID <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n            // AFTER1: CancelledID <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n            uint8 prevCanceledId = s.shortRecords[asset][shorter][canceledId].prevId;\n            if (prevCanceledId > Constants.HEAD) {\n                guard.prevId = prevCanceledId;\n            } else {\n                // BEFORE: HEAD <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n                // AFTER1: HEAD <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n                guard.prevId = Constants.HEAD;\n            }\n            // re-use the previous order's id\n            id = canceledId;\n        } else {\n            // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n            // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n            // otherwise just increment to a new short record id\n            // and the short record grows in height/size\n            id = AssetUser.shortRecordId;\n            // Avoids overflow revert, prevents DOS on uint8\n            if (id < type(uint8).max) {\n                AssetUser.shortRecordId += 1;\n            } else {\n                // If max id reached, match into max shortRecordId\n                return (id, nextId);\n            }\n        }\n\n        if (nextId > Constants.HEAD) {\n            s.shortRecords[asset][shorter][nextId].prevId = id;\n        }\n        guard.nextId = id;\n    }\n\n    function updateErcDebt(address asset, address shorter, uint8 shortId) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][shortId];\n\n        // Distribute ercDebt\n        uint64 ercDebtRate = s.asset[asset].ercDebtRate;\n        uint88 ercDebt = short.ercDebt.mulU88(ercDebtRate - short.ercDebtRate);\n\n        if (ercDebt > 0) {\n            short.ercDebt += ercDebt;\n            short.ercDebtRate = ercDebtRate;\n        }\n    }\n\n    function updateErcDebt(STypes.ShortRecord storage short, address asset) internal {\n        AppStorage storage s = appStorage();\n\n        // Distribute ercDebt\n        uint64 ercDebtRate = s.asset[asset].ercDebtRate;\n        uint88 ercDebt = short.ercDebt.mulU88(ercDebtRate - short.ercDebtRate);\n\n        if (ercDebt > 0) {\n            short.ercDebt += ercDebt;\n            short.ercDebtRate = ercDebtRate;\n        }\n    }\n\n    function merge(\n        STypes.ShortRecord storage short,\n        uint88 ercDebt,\n        uint256 ercDebtSocialized,\n        uint88 collateral,\n        uint256 yield,\n        uint24 creationTime\n    ) internal {\n        // Resolve ercDebt\n        ercDebtSocialized += short.ercDebt.mul(short.ercDebtRate);\n        short.ercDebt += ercDebt;\n        short.ercDebtRate = ercDebtSocialized.divU64(short.ercDebt);\n        // Resolve zethCollateral\n        yield += short.collateral.mul(short.zethYieldRate);\n        short.collateral += collateral;\n        short.zethYieldRate = yield.divU80(short.collateral);\n        // Assign updatedAt\n        short.updatedAt = creationTime;\n    }\n\n    function disburseCollateral(\n        address asset,\n        address shorter,\n        uint88 collateral,\n        uint256 zethYieldRate,\n        uint24 updatedAt\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.Asset storage Asset = s.asset[asset];\n        uint256 vault = Asset.vault;\n        STypes.Vault storage Vault = s.vault[vault];\n\n        Vault.zethCollateral -= collateral;\n        Asset.zethCollateral -= collateral;\n        // Distribute yield\n        uint88 yield = collateral.mulU88(Vault.zethYieldRate - zethYieldRate);\n        if (yield > 0) {\n            /*\n            @dev If somebody exits a short, gets margin called, decreases their collateral before YIELD_DELAY_HOURS duration is up,\n            they lose their yield to the TAPP\n            */\n            bool isNotRecentlyModified =\n                LibOrders.getOffsetTimeHours() - updatedAt > Constants.YIELD_DELAY_HOURS;\n            if (isNotRecentlyModified) {\n                s.vaultUser[vault][shorter].ethEscrowed += yield;\n            } else {\n                s.vaultUser[vault][address(this)].ethEscrowed += yield;\n            }\n        }\n    }\n\n    function burnNFT(uint256 tokenId) internal {\n        //@dev No need to check downcast tokenId because it is handled in function that calls burnNFT\n        AppStorage storage s = appStorage();\n        STypes.NFT storage nft = s.nftMapping[tokenId];\n        if (nft.owner == address(0)) revert Errors.NotMinted();\n        address asset = s.assetMapping[nft.assetId];\n        STypes.ShortRecord storage short =\n            s.shortRecords[asset][nft.owner][nft.shortRecordId];\n        delete s.nftMapping[tokenId];\n        delete s.getApproved[tokenId];\n        delete short.tokenId;\n        emit Events.Transfer(nft.owner, address(0), tokenId);\n    }\n\n    function setFlagger(\n        STypes.ShortRecord storage short,\n        address cusd,\n        uint16 flaggerHint\n    ) internal {\n        AppStorage storage s = appStorage();\n        STypes.AssetUser storage flagStorage = s.assetUser[cusd][msg.sender];\n\n        //@dev Whenever a new flagger flags, use the flaggerIdCounter.\n        if (flagStorage.g_flaggerId == 0) {\n            address flaggerToReplace = s.flagMapping[flaggerHint];\n\n            uint256 timeDiff = flaggerToReplace != address(0)\n                ? LibOrders.getOffsetTimeHours()\n                    - s.assetUser[cusd][flaggerToReplace].g_updatedAt\n                : 0;\n            //@dev re-use an inactive flaggerId\n            if (timeDiff > LibAsset.firstLiquidationTime(cusd)) {\n                delete s.assetUser[cusd][flaggerToReplace].g_flaggerId;\n                short.flaggerId = flagStorage.g_flaggerId = flaggerHint;\n            } else if (s.flaggerIdCounter < type(uint16).max) {\n                //@dev generate brand new flaggerId\n                short.flaggerId = flagStorage.g_flaggerId = s.flaggerIdCounter;\n                s.flaggerIdCounter++;\n            } else {\n                revert Errors.InvalidFlaggerHint();\n            }\n            s.flagMapping[short.flaggerId] = msg.sender;\n        } else {\n            //@dev re-use flaggerId if flagger has an existing one\n            short.flaggerId = flagStorage.g_flaggerId;\n        }\n        short.updatedAt = flagStorage.g_updatedAt = LibOrders.getOffsetTimeHours();\n    }\n\n    //@dev reset flag info if new cratio is above primaryLiquidationCR\n    function maybeResetFlag(STypes.ShortRecord storage short, address asset) internal {\n        if (short.flaggerId != 0) {\n            if (\n                LibShortRecord.getCollateralRatio(short, asset)\n                    >= LibAsset.primaryLiquidationCR(asset)\n            ) {\n                LibShortRecord.resetFlag(short);\n            }\n        }\n    }\n\n    function resetFlag(STypes.ShortRecord storage shortRecord) internal {\n        delete shortRecord.flaggerId;\n        shortRecord.updatedAt = LibOrders.getOffsetTimeHours();\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarginCallPrimaryFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarginCallPrimaryFacet is Modifiers {\n    using LibShortRecord for STypes.ShortRecord;\n    using U256 for uint256;\n    using U96 for uint96;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    address private immutable cusd;\n\n    constructor(address _cusd) {\n        cusd = _cusd;\n    }\n\n    /**\n     * @notice Flags short under primaryLiquidationCR to be eligible for liquidation after time has passed\n     * @dev Used to flag for primary liquidation method\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id id of short getting liquidated\n     * @param flaggerHint Hint ID for gas-optimized update of short flagger\n     *\n     */\n    function flagShort(address asset, address shorter, uint8 id, uint16 flaggerHint)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, shorter, id)\n    {\n        if (msg.sender == shorter) revert Errors.CannotFlagSelf();\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][id];\n        short.updateErcDebt(asset);\n\n        if (\n            short.getCollateralRatioSpotPrice(LibOracle.getSavedOrSpotOraclePrice(asset))\n                >= LibAsset.primaryLiquidationCR(asset)\n        ) {\n            revert Errors.SufficientCollateral();\n        }\n\n        uint256 adjustedTimestamp = LibOrders.getOffsetTimeHours();\n\n        // check if already flagged\n        if (short.flaggerId != 0) {\n            uint256 timeDiff = adjustedTimestamp - short.updatedAt;\n            uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(asset);\n\n            if (timeDiff <= resetLiquidationTime) {\n                revert Errors.MarginCallAlreadyFlagged();\n            }\n        }\n\n        short.setFlagger(cusd, flaggerHint);\n        emit Events.FlagShort(asset, shorter, id, msg.sender, adjustedTimestamp);\n    }\n\n    /**\n     * @notice Liquidates short by forcing shorter to place bid on market\n     * @dev Primary liquidation method. Requires flag\n     * @dev Shorter will bear the cost of forcedBid on market\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id Id of short getting liquidated\n     * @param shortHintArray Array of hintId for the id to start matching against shorts since you can't match a short < oracle price\n     *\n     * @return gasFee Estimated cost of gas for the forcedBid\n     * @return ethFilled Amount of eth filled in forcedBid\n     */\n    function liquidate(\n        address asset,\n        address shorter,\n        uint8 id,\n        uint16[] memory shortHintArray\n    )\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, shorter, id)\n        returns (uint88, uint88)\n    {\n        if (msg.sender == shorter) revert Errors.CannotLiquidateSelf();\n\n        //@dev marginCall requires more up-to-date oraclePrice (15 min vs createLimitBid's 1 hour)\n        LibOrders.updateOracleAndStartingShortViaTimeBidOnly(\n            asset, OF.FifteenMinutes, shortHintArray\n        );\n\n        MTypes.MarginCallPrimary memory m = _setMarginCallStruct(asset, shorter, id);\n\n        if (m.cRatio >= LibAsset.primaryLiquidationCR(m.asset)) {\n            revert Errors.SufficientCollateral();\n        }\n\n        // revert if no asks, or price too high\n        _checklowestSell(m);\n\n        // check if within margin call time window\n        if (!_canLiquidate(m)) {\n            STypes.ShortRecord storage shortRecord = s.shortRecords[asset][shorter][id];\n            shortRecord.resetFlag();\n            return (0, 0);\n        }\n\n        _performForcedBid(m, shortHintArray);\n\n        _marginFeeHandler(m);\n\n        _fullorPartialLiquidation(m);\n        emit Events.Liquidate(asset, shorter, id, msg.sender, m.ercDebtMatched);\n\n        return (m.gasFee, m.ethFilled);\n    }\n\n    //PRIVATE FUNCTIONS\n\n    // Reverts if no eligible sells, or if lowest sell price is too high\n    // @dev startingShortId is updated via updateOracleAndStartingShortViaTimeBidOnly() prior to call\n    function _checklowestSell(MTypes.MarginCallPrimary memory m) private view {\n        uint16 lowestAskKey = s.asks[m.asset][Constants.HEAD].nextId;\n        uint16 startingShortId = s.asset[m.asset].startingShortId;\n        uint256 bufferPrice = m.oraclePrice.mul(m.forcedBidPriceBuffer);\n        if (\n            // Checks for no eligible asks\n            (\n                lowestAskKey == Constants.TAIL\n                    || s.asks[m.asset][lowestAskKey].price > bufferPrice\n            )\n            // Checks for no eligible shorts\n            && (\n                startingShortId == Constants.HEAD // means no short >= oracleprice\n                    || s.shorts[m.asset][startingShortId].price > bufferPrice\n            )\n        ) {\n            revert Errors.NoSells();\n        }\n    }\n\n    /**\n     * @notice Sets the memory struct m with initial data\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id Id of short getting liquidated\n     *\n     * @return m Memory struct used throughout MarginCallPrimaryFacet.sol\n     */\n\n    function _setMarginCallStruct(address asset, address shorter, uint8 id)\n        private\n        returns (MTypes.MarginCallPrimary memory)\n    {\n        LibShortRecord.updateErcDebt(asset, shorter, id);\n        {\n            MTypes.MarginCallPrimary memory m;\n            m.asset = asset;\n            m.short = s.shortRecords[asset][shorter][id];\n            m.vault = s.asset[asset].vault;\n            m.shorter = shorter;\n            m.minimumCR = LibAsset.minimumCR(asset);\n            m.oraclePrice = LibOracle.getPrice(asset);\n            m.cRatio = m.short.getCollateralRatio(asset);\n            m.forcedBidPriceBuffer = LibAsset.forcedBidPriceBuffer(asset);\n            m.callerFeePct = LibAsset.callerFeePct(m.asset);\n            m.tappFeePct = LibAsset.tappFeePct(m.asset);\n            m.ethDebt = m.short.ercDebt.mul(m.oraclePrice).mul(m.forcedBidPriceBuffer).mul(\n                1 ether + m.tappFeePct + m.callerFeePct\n            ); // ethDebt accounts for forcedBidPriceBuffer and potential fees\n            return m;\n        }\n    }\n\n    /**\n     * @notice Handles the set up and execution of making a forcedBid\n     * @dev Shorter will bear the cost of forcedBid on market\n     * @dev Depending on shorter's cRatio, the TAPP can attempt to fund bid\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     * @param shortHintArray Array of hintId for the id to start matching against shorts since you can't match a short < oracle price\n     *\n     */\n\n    function _performForcedBid(\n        MTypes.MarginCallPrimary memory m,\n        uint16[] memory shortHintArray\n    ) private {\n        uint256 startGas = gasleft();\n        uint88 ercAmountLeft;\n\n        //@dev Provide higher price to better ensure it can fully fill the margin call\n        uint80 _bidPrice = m.oraclePrice.mulU80(m.forcedBidPriceBuffer);\n\n        // Shorter loses leftover collateral to TAPP when unable to maintain CR above the minimum\n        m.loseCollateral = m.cRatio <= m.minimumCR;\n\n        //@dev Increase ethEscrowed by shorter's full collateral for forced bid\n        s.vaultUser[m.vault][address(this)].ethEscrowed += m.short.collateral;\n\n        // Check ability of TAPP plus short collateral to pay back ethDebt\n        if (s.vaultUser[m.vault][address(this)].ethEscrowed < m.ethDebt) {\n            uint96 ercDebtPrev = m.short.ercDebt;\n            if (s.asset[m.asset].ercDebt <= ercDebtPrev) {\n                // Occurs when only one shortRecord in the asset (market)\n                revert Errors.CannotSocializeDebt();\n            }\n            m.loseCollateral = true;\n            // @dev Max ethDebt can only be the ethEscrowed in the TAPP\n            m.ethDebt = s.vaultUser[m.vault][address(this)].ethEscrowed;\n            // Reduce ercDebt proportional to ethDebt\n            m.short.ercDebt = uint88(\n                m.ethDebt.div(_bidPrice.mul(1 ether + m.callerFeePct + m.tappFeePct))\n            ); // @dev(safe-cast)\n            uint96 ercDebtSocialized = ercDebtPrev - m.short.ercDebt;\n            // Update ercDebtRate to socialize loss (increase debt) to other shorts\n            s.asset[m.asset].ercDebtRate +=\n                ercDebtSocialized.divU64(s.asset[m.asset].ercDebt - ercDebtPrev);\n        }\n\n        // @dev MarginCall contract will be the caller. Virtual accounting done later for shorter or TAPP\n        (m.ethFilled, ercAmountLeft) = IDiamond(payable(address(this))).createForcedBid(\n            address(this), m.asset, _bidPrice, m.short.ercDebt, shortHintArray\n        );\n\n        m.ercDebtMatched = m.short.ercDebt - ercAmountLeft;\n\n        //@dev virtually burning the repurchased debt\n        s.assetUser[m.asset][address(this)].ercEscrowed -= m.ercDebtMatched;\n        s.asset[m.asset].ercDebt -= m.ercDebtMatched;\n\n        uint256 gasUsed = startGas - gasleft();\n        //@dev manually setting basefee to 1,000,000 in foundry.toml;\n        //@dev By basing gasFee off of baseFee instead of priority, adversaries are prevent from draining the TAPP\n        m.gasFee = uint88(gasUsed * block.basefee); // @dev(safe-cast)\n    }\n\n    /**\n     * @notice Handles the distribution of marginFee\n     * @dev MarginFee is taken into consideration when determining black swan\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    function _marginFeeHandler(MTypes.MarginCallPrimary memory m) private {\n        STypes.VaultUser storage VaultUser = s.vaultUser[m.vault][msg.sender];\n        STypes.VaultUser storage TAPP = s.vaultUser[m.vault][address(this)];\n        // distribute fees to TAPP and caller\n        uint88 tappFee = m.ethFilled.mulU88(m.tappFeePct);\n        uint88 callerFee = m.ethFilled.mulU88(m.callerFeePct) + m.gasFee;\n\n        m.totalFee += tappFee + callerFee;\n        //@dev TAPP already received the gasFee for being the forcedBid caller. tappFee nets out.\n        if (TAPP.ethEscrowed >= callerFee) {\n            TAPP.ethEscrowed -= callerFee;\n            VaultUser.ethEscrowed += callerFee;\n        } else {\n            // Give caller (portion of?) tappFee instead of gasFee\n            VaultUser.ethEscrowed += callerFee - m.gasFee + tappFee;\n            m.totalFee -= m.gasFee;\n            TAPP.ethEscrowed -= m.totalFee;\n        }\n    }\n\n    function min88(uint256 a, uint88 b) private pure returns (uint88) {\n        if (a > type(uint88).max) revert Errors.InvalidAmount();\n        return a < b ? uint88(a) : b;\n    }\n\n    /**\n     * @notice Handles accounting in event of full or partial liquidations\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    function _fullorPartialLiquidation(MTypes.MarginCallPrimary memory m) private {\n        uint88 decreaseCol = min88(m.totalFee + m.ethFilled, m.short.collateral);\n\n        if (m.short.ercDebt == m.ercDebtMatched) {\n            // Full liquidation\n            LibShortRecord.disburseCollateral(\n                m.asset,\n                m.shorter,\n                m.short.collateral,\n                m.short.zethYieldRate,\n                m.short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n            if (!m.loseCollateral) {\n                m.short.collateral -= decreaseCol;\n                s.vaultUser[m.vault][m.shorter].ethEscrowed += m.short.collateral;\n                s.vaultUser[m.vault][address(this)].ethEscrowed -= m.short.collateral;\n            }\n        } else {\n            // Partial liquidation\n            m.short.ercDebt -= m.ercDebtMatched;\n            m.short.collateral -= decreaseCol;\n            s.shortRecords[m.asset][m.shorter][m.short.id] = m.short;\n\n            s.vaultUser[m.vault][address(this)].ethEscrowed -= m.short.collateral;\n            LibShortRecord.disburseCollateral(\n                m.asset, m.shorter, decreaseCol, m.short.zethYieldRate, m.short.updatedAt\n            );\n\n            // TAPP absorbs leftover short, unless it already owns the short\n            if (m.loseCollateral && m.shorter != address(this)) {\n                // Delete partially liquidated short\n                LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n                // Absorb leftovers into TAPP short\n                LibShortRecord.fillShortRecord(\n                    m.asset,\n                    address(this),\n                    Constants.SHORT_STARTING_ID,\n                    SR.FullyFilled,\n                    m.short.collateral,\n                    m.short.ercDebt,\n                    s.asset[m.asset].ercDebtRate,\n                    m.short.zethYieldRate\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Helper that evaluates if a short is eligible for liquidation (i.e. flagged and within appropriate time frame)\n     * @dev Shorter has 10 hours after initial flag to bring cRatio up above maintainence margin...\n     * @dev ...After that, the flagger has 2 hours to liquidate the shorter. If short is not liquidated by shorter within that time, ANYBODY can then liquidate...\n     * @dev ...After 16 total hours have passed and the short has not been liquidated, the flag gets reset and the flagging process begins anew\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    // check if within margin call time window\n    function _canLiquidate(MTypes.MarginCallPrimary memory m)\n        private\n        view\n        returns (bool)\n    {\n        //@dev if cRatio is below the minimumCR, allow liquidation regardless of flagging\n        if (m.cRatio < m.minimumCR) return true;\n\n        //@dev Only check if flagger is empty, not updatedAt\n        if (m.short.flaggerId == 0) {\n            revert Errors.ShortNotFlagged();\n        }\n\n        /*\n         * Timeline: \n         * \n         * updatedAt (~0 hrs)\n         * ..\n         * [Errors.MarginCallIneligibleWindow]\n         * ..\n         * firstLiquidationTime (~10hrs, +10 hrs)\n         * ..\n         * [return msg.sender == short.flagger]\n         * ..\n         * secondLiquidationTime (~12hrs, +2 hrs)\n         * ..\n         * [return true (msg.sender is anyone)]\n         * ..\n         * resetLiquidationTime (~16hrs, +4 hrs)\n         * ..\n         * [return false (reset flag)]\n        */\n\n        uint256 timeDiff = LibOrders.getOffsetTimeHours() - m.short.updatedAt;\n        uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(m.asset);\n\n        if (timeDiff >= resetLiquidationTime) {\n            return false;\n        } else {\n            uint256 secondLiquidationTime = LibAsset.secondLiquidationTime(m.asset);\n            bool isBetweenFirstAndSecondLiquidationTime = timeDiff\n                > LibAsset.firstLiquidationTime(m.asset) && timeDiff <= secondLiquidationTime\n                && s.flagMapping[m.short.flaggerId] == msg.sender;\n            bool isBetweenSecondAndResetLiquidationTime =\n                timeDiff > secondLiquidationTime && timeDiff <= resetLiquidationTime;\n            if (\n                !(\n                    (isBetweenFirstAndSecondLiquidationTime)\n                        || (isBetweenSecondAndResetLiquidationTime)\n                )\n            ) {\n                revert Errors.MarginCallIneligibleWindow();\n            }\n\n            return true;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarginCallPrimaryFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";"
    }
  ]
}