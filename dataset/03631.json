{
  "Title": "Local variable shadowing",
  "Content": "##### Description\nAt the line\n- https://github.com/aave/incentives-proposal/blob/f6712e33db79210a7ae8106f7cfa1ce2adea8d69/contracts/incentives/DistributionManager.sol#L28\nand the lines:\n- https://github.com/aave/incentives-proposal/blob/f6712e33db79210a7ae8106f7cfa1ce2adea8d69/contracts/incentives/StakedTokenIncentivesController.sol#L57\n- https://github.com/aave/incentives-proposal/blob/f6712e33db79210a7ae8106f7cfa1ce2adea8d69/contracts/incentives/StakedTokenIncentivesController.sol#L92\n- https://github.com/aave/incentives-proposal/blob/f6712e33db79210a7ae8106f7cfa1ce2adea8d69/contracts/incentives/StakedTokenIncentivesController.sol#L113\n- https://github.com/aave/incentives-proposal/blob/f6712e33db79210a7ae8106f7cfa1ce2adea8d69/contracts/incentives/StakedTokenIncentivesController.sol#L123\n- https://github.com/aave/incentives-proposal/blob/f6712e33db79210a7ae8106f7cfa1ce2adea8d69/contracts/incentives/StakedTokenIncentivesController.sol#L134\n- https://github.com/aave/incentives-proposal/blob/f6712e33db79210a7ae8106f7cfa1ce2adea8d69/contracts/incentives/StakedTokenIncentivesController.sol#L186\n\ndetection of shadowing using `assets` local variables.\n\n##### Recommendation\nWe recommend renaming the local variables that shadow another component.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/incentives/DistributionManager.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.5;\npragma experimental ABIEncoderV2;\n\nimport {IAaveDistributionManager} from '../interfaces/IAaveDistributionManager.sol';\nimport {SafeMath} from '../lib/SafeMath.sol';\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\n\n/**\n * @title DistributionManager\n * @notice Accounting contract to manage multiple staking distributions\n * @author Aave\n **/\ncontract DistributionManager is IAaveDistributionManager {\n  using SafeMath for uint256;\n\n  struct AssetData {\n    uint104 emissionPerSecond;\n    uint104 index;\n    uint40 lastUpdateTimestamp;\n    mapping(address => uint256) users;\n  }\n\n  address public immutable EMISSION_MANAGER;\n\n  uint8 public constant PRECISION = 18;\n\n  mapping(address => AssetData) public assets;\n\n  uint256 internal _distributionEnd;\n\n  modifier onlyEmissionManager() {\n    require(msg.sender == EMISSION_MANAGER, 'ONLY_EMISSION_MANAGER');\n    _;\n  }\n\n  constructor(address emissionManager) {\n    EMISSION_MANAGER = emissionManager;\n  }\n\n  /// @inheritdoc IAaveDistributionManager\n  function setDistributionEnd(uint256 distributionEnd) external override onlyEmissionManager {\n    _distributionEnd = distributionEnd;\n    emit DistributionEndUpdated(distributionEnd);\n  }\n\n  /// @inheritdoc IAaveDistributionManager\n  function getDistributionEnd() external view override returns (uint256) {\n    return _distributionEnd;\n  }\n\n  /// @inheritdoc IAaveDistributionManager\n  function DISTRIBUTION_END() external view override returns (uint256) {\n    return _distributionEnd;\n  }\n\n  /// @inheritdoc IAaveDistributionManager\n  function getUserAssetData(address user, address asset) public view override returns (uint256) {\n    return assets[asset].users[user];\n  }\n\n  /// @inheritdoc IAaveDistributionManager\n  function getAssetData(address asset) public view override returns (uint256, uint256, uint256) {\n    return (assets[asset].index, assets[asset].emissionPerSecond, assets[asset].lastUpdateTimestamp);\n  }\n\n  /**\n   * @dev Configure the assets for a specific emission\n   * @param assetsConfigInput The array of each asset configuration\n   **/\n  function _configureAssets(DistributionTypes.AssetConfigInput[] memory assetsConfigInput)\n    internal\n  {\n    for (uint256 i = 0; i < assetsConfigInput.length; i++) {\n      AssetData storage assetConfig = assets[assetsConfigInput[i].underlyingAsset];\n\n      _updateAssetStateInternal(\n        assetsConfigInput[i].underlyingAsset,\n        assetConfig,\n        assetsConfigInput[i].totalStaked\n      );\n\n      assetConfig.emissionPerSecond = assetsConfigInput[i].emissionPerSecond;\n\n      emit AssetConfigUpdated(\n        assetsConfigInput[i].underlyingAsset,\n        assetsConfigInput[i].emissionPerSecond\n      );\n    }\n  }\n\n  /**\n   * @dev Updates the state of one distribution, mainly rewards index and timestamp\n   * @param asset The address of the asset being updated\n   * @param assetConfig Storage pointer to the distribution's config\n   * @param totalStaked Current total of staked assets for this distribution\n   * @return The new distribution index\n   **/\n  function _updateAssetStateInternal(\n    address asset,\n    AssetData storage assetConfig,\n    uint256 totalStaked\n  ) internal returns (uint256) {\n    uint256 oldIndex = assetConfig.index;\n    uint256 emissionPerSecond = assetConfig.emissionPerSecond;\n    uint128 lastUpdateTimestamp = assetConfig.lastUpdateTimestamp;\n\n    if (block.timestamp == lastUpdateTimestamp) {\n      return oldIndex;\n    }\n\n    uint256 newIndex =\n      _getAssetIndex(oldIndex, emissionPerSecond, lastUpdateTimestamp, totalStaked);\n\n    if (newIndex != oldIndex) {\n      require(uint104(newIndex) == newIndex, 'Index overflow');\n      //optimization: storing one after another saves one SSTORE\n      assetConfig.index = uint104(newIndex);\n      assetConfig.lastUpdateTimestamp = uint40(block.timestamp);\n      emit AssetIndexUpdated(asset, newIndex);\n    } else {\n      assetConfig.lastUpdateTimestamp = uint40(block.timestamp);\n    }\n\n    return newIndex;\n  }\n\n  /**\n   * @dev Updates the state of an user in a distribution\n   * @param user The user's address\n   * @param asset The address of the reference asset of the distribution\n   * @param stakedByUser Amount of tokens staked by the user in the distribution at the moment\n   * @param totalStaked Total tokens staked in the distribution\n   * @return The accrued rewards for the user until the moment\n   **/\n  function _updateUserAssetInternal(\n    address user,\n    address asset,\n    uint256 stakedByUser,\n    uint256 totalStaked\n  ) internal returns (uint256) {\n    AssetData storage assetData = assets[asset];\n    uint256 userIndex = assetData.users[user];\n    uint256 accruedRewards = 0;\n\n    uint256 newIndex = _updateAssetStateInternal(asset, assetData, totalStaked);\n\n    if (userIndex != newIndex) {\n      if (stakedByUser != 0) {\n        accruedRewards = _getRewards(stakedByUser, newIndex, userIndex);\n      }\n\n      assetData.users[user] = newIndex;\n      emit UserIndexUpdated(user, asset, newIndex);\n    }\n\n    return accruedRewards;\n  }\n\n  /**\n   * @dev Used by \"frontend\" stake contracts to update the data of an user when claiming rewards from there\n   * @param user The address of the user\n   * @param stakes List of structs of the user data related with his stake\n   * @return The accrued rewards for the user until the moment\n   **/\n  function _claimRewards(address user, DistributionTypes.UserStakeInput[] memory stakes)\n    internal\n    returns (uint256)\n  {\n    uint256 accruedRewards = 0;\n\n    for (uint256 i = 0; i < stakes.length; i++) {\n      accruedRewards = accruedRewards.add(\n        _updateUserAssetInternal(\n          user,\n          stakes[i].underlyingAsset,\n          stakes[i].stakedByUser,\n          stakes[i].totalStaked\n        )\n      );\n    }\n\n    return accruedRewards;\n  }\n\n  /**\n   * @dev Return the accrued rewards for an user over a list of distribution\n   * @param user The address of the user\n   * @param stakes List of structs of the user data related with his stake\n   * @return The accrued rewards for the user until the moment\n   **/\n  function _getUnclaimedRewards(address user, DistributionTypes.UserStakeInput[] memory stakes)\n    internal\n    view\n    returns (uint256)\n  {\n    uint256 accruedRewards = 0;\n\n    for (uint256 i = 0; i < stakes.length; i++) {\n      AssetData storage assetConfig = assets[stakes[i].underlyingAsset];\n      uint256 assetIndex =\n        _getAssetIndex(\n          assetConfig.index,\n          assetConfig.emissionPerSecond,\n          assetConfig.lastUpdateTimestamp,\n          stakes[i].totalStaked\n        );\n\n      accruedRewards = accruedRewards.add(\n        _getRewards(stakes[i].stakedByUser, assetIndex, assetConfig.users[user])\n      );\n    }\n    return accruedRewards;\n  }\n\n  /**\n   * @dev Internal function for the calculation of user's rewards on a distribution\n   * @param principalUserBalance Amount staked by the user on a distribution\n   * @param reserveIndex Current index of the distribution\n   * @param userIndex Index stored for the user, representation his staking moment\n   * @return The rewards\n   **/\n  function _getRewards(\n    uint256 principalUserBalance,\n    uint256 reserveIndex,\n    uint256 userIndex\n  ) internal pure returns (uint256) {\n    return principalUserBalance.mul(reserveIndex.sub(userIndex)) / 10**uint256(PRECISION);\n  }\n\n  /**\n   * @dev Calculates the next value of an specific distribution index, with validations\n   * @param currentIndex Current index of the distribution\n   * @param emissionPerSecond Representing the total rewards distributed per second per asset unit, on the distribution\n   * @param lastUpdateTimestamp Last moment this distribution was updated\n   * @param totalBalance of tokens considered for the distribution\n   * @return The new index.\n   **/\n  function _getAssetIndex(\n    uint256 currentIndex,\n    uint256 emissionPerSecond,\n    uint128 lastUpdateTimestamp,\n    uint256 totalBalance\n  ) internal view returns (uint256) {\n    uint256 distributionEnd = _distributionEnd;\n    if (\n      emissionPerSecond == 0 ||\n      totalBalance == 0 ||\n      lastUpdateTimestamp == block.timestamp ||\n      lastUpdateTimestamp >= distributionEnd\n    ) {\n      return currentIndex;\n    }\n\n    uint256 currentTimestamp =\n      block.timestamp > distributionEnd ? distributionEnd : block.timestamp;\n    uint256 timeDelta = currentTimestamp.sub(lastUpdateTimestamp);\n    return\n      emissionPerSecond.mul(timeDelta).mul(10**uint256(PRECISION)).div(totalBalance).add(\n        currentIndex\n      );\n  }\n}"
    },
    {
      "filename": "contracts/incentives/StakedTokenIncentivesController.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.5;\npragma experimental ABIEncoderV2;\n\nimport {SafeERC20} from '@aave/aave-stake/contracts/lib/SafeERC20.sol';\nimport {SafeMath} from '../lib/SafeMath.sol';\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\nimport {VersionedInitializable} from '@aave/aave-stake/contracts/utils/VersionedInitializable.sol';\nimport {DistributionManager} from './DistributionManager.sol';\nimport {IStakedTokenWithConfig} from '../interfaces/IStakedTokenWithConfig.sol';\nimport {IERC20} from '@aave/aave-stake/contracts/interfaces/IERC20.sol';\nimport {IScaledBalanceToken} from '../interfaces/IScaledBalanceToken.sol';\nimport {IAaveIncentivesController} from '../interfaces/IAaveIncentivesController.sol';\n\n/**\n * @title StakedTokenIncentivesController\n * @notice Distributor contract for rewards to the Aave protocol, using a staked token as rewards asset.\n * The contract stakes the rewards before redistributing them to the Aave protocol participants.\n * The reference staked token implementation is at https://github.com/aave/aave-stake-v2\n * @author Aave\n **/\ncontract StakedTokenIncentivesController is\n  IAaveIncentivesController,\n  VersionedInitializable,\n  DistributionManager\n{\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  uint256 public constant REVISION = 2;\n\n  IStakedTokenWithConfig public immutable STAKE_TOKEN;\n\n  mapping(address => uint256) internal _usersUnclaimedRewards;\n\n  // this mapping allows whitelisted addresses to claim on behalf of others\n  // useful for contracts that hold tokens to be rewarded but don't have any native logic to claim Liquidity Mining rewards\n  mapping(address => address) internal _authorizedClaimers;\n\n  modifier onlyAuthorizedClaimers(address claimer, address user) {\n    require(_authorizedClaimers[user] == claimer, 'CLAIMER_UNAUTHORIZED');\n    _;\n  }\n\n  constructor(IStakedTokenWithConfig stakeToken, address emissionManager)\n    DistributionManager(emissionManager)\n  {\n    STAKE_TOKEN = stakeToken;\n  }\n\n  /**\n   * @dev Initialize IStakedTokenIncentivesController. Empty after REVISION 1, but maintains the expected interface.\n   **/\n  function initialize(address) external initializer {}\n\n  /// @inheritdoc IAaveIncentivesController\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\n    external\n    override\n    onlyEmissionManager\n  {\n    require(assets.length == emissionsPerSecond.length, 'INVALID_CONFIGURATION');\n\n    DistributionTypes.AssetConfigInput[] memory assetsConfig =\n      new DistributionTypes.AssetConfigInput[](assets.length);\n\n    for (uint256 i = 0; i < assets.length; i++) {\n      assetsConfig[i].underlyingAsset = assets[i];\n      assetsConfig[i].emissionPerSecond = uint104(emissionsPerSecond[i]);\n\n      require(assetsConfig[i].emissionPerSecond == emissionsPerSecond[i], 'INVALID_CONFIGURATION');\n\n      assetsConfig[i].totalStaked = IScaledBalanceToken(assets[i]).scaledTotalSupply();\n    }\n    _configureAssets(assetsConfig);\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function handleAction(\n    address user,\n    uint256 totalSupply,\n    uint256 userBalance\n  ) external override {\n    uint256 accruedRewards = _updateUserAssetInternal(user, msg.sender, userBalance, totalSupply);\n    if (accruedRewards != 0) {\n      _usersUnclaimedRewards[user] = _usersUnclaimedRewards[user].add(accruedRewards);\n      emit RewardsAccrued(user, accruedRewards);\n    }\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function getRewardsBalance(address[] calldata assets, address user)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    uint256 unclaimedRewards = _usersUnclaimedRewards[user];\n\n    DistributionTypes.UserStakeInput[] memory userState =\n      new DistributionTypes.UserStakeInput[](assets.length);\n    for (uint256 i = 0; i < assets.length; i++) {\n      userState[i].underlyingAsset = assets[i];\n      (userState[i].stakedByUser, userState[i].totalStaked) = IScaledBalanceToken(assets[i])\n        .getScaledUserBalanceAndSupply(user);\n    }\n    unclaimedRewards = unclaimedRewards.add(_getUnclaimedRewards(user, userState));\n    return unclaimedRewards;\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to\n  ) external override returns (uint256) {\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimRewards(assets, amount, msg.sender, msg.sender, to);\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function claimRewardsOnBehalf(\n    address[] calldata assets,\n    uint256 amount,\n    address user,\n    address to\n  ) external override onlyAuthorizedClaimers(msg.sender, user) returns (uint256) {\n    require(user != address(0), 'INVALID_USER_ADDRESS');\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimRewards(assets, amount, msg.sender, user, to);\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function claimRewardsToSelf(address[] calldata assets, uint256 amount)\n    external\n    override\n    returns (uint256)\n  {\n    return _claimRewards(assets, amount, msg.sender, msg.sender, msg.sender);\n  }\n\n  /**\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards.\n   * @param amount Amount of rewards to claim\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n\n  /// @inheritdoc IAaveIncentivesController\n  function setClaimer(address user, address caller) external override onlyEmissionManager {\n    _authorizedClaimers[user] = caller;\n    emit ClaimerSet(user, caller);\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function getClaimer(address user) external view override returns (address) {\n    return _authorizedClaimers[user];\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function getUserUnclaimedRewards(address _user) external view override returns (uint256) {\n    return _usersUnclaimedRewards[_user];\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function REWARD_TOKEN() external view override returns (address) {\n    return address(STAKE_TOKEN);\n  }\n\n  /**\n   * @dev returns the revision of the implementation contract\n   */\n  function getRevision() internal pure override returns (uint256) {\n    return REVISION;\n  }\n\n  /**\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards.\n   * @param amount Amount of rewards to claim\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n  function _claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address claimer,\n    address user,\n    address to\n  ) internal returns (uint256) {\n    if (amount == 0) {\n      return 0;\n    }\n    uint256 unclaimedRewards = _usersUnclaimedRewards[user];\n\n    DistributionTypes.UserStakeInput[] memory userState =\n      new DistributionTypes.UserStakeInput[](assets.length);\n    for (uint256 i = 0; i < assets.length; i++) {\n      userState[i].underlyingAsset = assets[i];\n      (userState[i].stakedByUser, userState[i].totalStaked) = IScaledBalanceToken(assets[i])\n        .getScaledUserBalanceAndSupply(user);\n    }\n\n    uint256 accruedRewards = _claimRewards(user, userState);\n    if (accruedRewards != 0) {\n      unclaimedRewards = unclaimedRewards.add(accruedRewards);\n      emit RewardsAccrued(user, accruedRewards);\n    }\n\n    if (unclaimedRewards == 0) {\n      return 0;\n    }\n\n    uint256 amountToClaim = amount > unclaimedRewards ? unclaimedRewards : amount;\n    _usersUnclaimedRewards[user] = unclaimedRewards - amountToClaim; // Safe due to the previous line\n\n    STAKE_TOKEN.stake(to, amountToClaim);\n    emit RewardsClaimed(user, to, claimer, amountToClaim);\n\n    return amountToClaim;\n  }\n}"
    },
    {
      "filename": "contracts/incentives/StakedTokenIncentivesController.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.5;\npragma experimental ABIEncoderV2;\n\nimport {SafeERC20} from '@aave/aave-stake/contracts/lib/SafeERC20.sol';\nimport {SafeMath} from '../lib/SafeMath.sol';\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\nimport {VersionedInitializable} from '@aave/aave-stake/contracts/utils/VersionedInitializable.sol';\nimport {DistributionManager} from './DistributionManager.sol';\nimport {IStakedTokenWithConfig} from '../interfaces/IStakedTokenWithConfig.sol';\nimport {IERC20} from '@aave/aave-stake/contracts/interfaces/IERC20.sol';\nimport {IScaledBalanceToken} from '../interfaces/IScaledBalanceToken.sol';\nimport {IAaveIncentivesController} from '../interfaces/IAaveIncentivesController.sol';\n\n/**\n * @title StakedTokenIncentivesController\n * @notice Distributor contract for rewards to the Aave protocol, using a staked token as rewards asset.\n * The contract stakes the rewards before redistributing them to the Aave protocol participants.\n * The reference staked token implementation is at https://github.com/aave/aave-stake-v2\n * @author Aave\n **/\ncontract StakedTokenIncentivesController is\n  IAaveIncentivesController,\n  VersionedInitializable,\n  DistributionManager\n{\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  uint256 public constant REVISION = 2;\n\n  IStakedTokenWithConfig public immutable STAKE_TOKEN;\n\n  mapping(address => uint256) internal _usersUnclaimedRewards;\n\n  // this mapping allows whitelisted addresses to claim on behalf of others\n  // useful for contracts that hold tokens to be rewarded but don't have any native logic to claim Liquidity Mining rewards\n  mapping(address => address) internal _authorizedClaimers;\n\n  modifier onlyAuthorizedClaimers(address claimer, address user) {\n    require(_authorizedClaimers[user] == claimer, 'CLAIMER_UNAUTHORIZED');\n    _;\n  }\n\n  constructor(IStakedTokenWithConfig stakeToken, address emissionManager)\n    DistributionManager(emissionManager)\n  {\n    STAKE_TOKEN = stakeToken;\n  }\n\n  /**\n   * @dev Initialize IStakedTokenIncentivesController. Empty after REVISION 1, but maintains the expected interface.\n   **/\n  function initialize(address) external initializer {}\n\n  /// @inheritdoc IAaveIncentivesController\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\n    external\n    override\n    onlyEmissionManager\n  {\n    require(assets.length == emissionsPerSecond.length, 'INVALID_CONFIGURATION');\n\n    DistributionTypes.AssetConfigInput[] memory assetsConfig =\n      new DistributionTypes.AssetConfigInput[](assets.length);\n\n    for (uint256 i = 0; i < assets.length; i++) {\n      assetsConfig[i].underlyingAsset = assets[i];\n      assetsConfig[i].emissionPerSecond = uint104(emissionsPerSecond[i]);\n\n      require(assetsConfig[i].emissionPerSecond == emissionsPerSecond[i], 'INVALID_CONFIGURATION');\n\n      assetsConfig[i].totalStaked = IScaledBalanceToken(assets[i]).scaledTotalSupply();\n    }\n    _configureAssets(assetsConfig);\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function handleAction(\n    address user,\n    uint256 totalSupply,\n    uint256 userBalance\n  ) external override {\n    uint256 accruedRewards = _updateUserAssetInternal(user, msg.sender, userBalance, totalSupply);\n    if (accruedRewards != 0) {\n      _usersUnclaimedRewards[user] = _usersUnclaimedRewards[user].add(accruedRewards);\n      emit RewardsAccrued(user, accruedRewards);\n    }\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function getRewardsBalance(address[] calldata assets, address user)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    uint256 unclaimedRewards = _usersUnclaimedRewards[user];\n\n    DistributionTypes.UserStakeInput[] memory userState =\n      new DistributionTypes.UserStakeInput[](assets.length);\n    for (uint256 i = 0; i < assets.length; i++) {\n      userState[i].underlyingAsset = assets[i];\n      (userState[i].stakedByUser, userState[i].totalStaked) = IScaledBalanceToken(assets[i])\n        .getScaledUserBalanceAndSupply(user);\n    }\n    unclaimedRewards = unclaimedRewards.add(_getUnclaimedRewards(user, userState));\n    return unclaimedRewards;\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to\n  ) external override returns (uint256) {\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimRewards(assets, amount, msg.sender, msg.sender, to);\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function claimRewardsOnBehalf(\n    address[] calldata assets,\n    uint256 amount,\n    address user,\n    address to\n  ) external override onlyAuthorizedClaimers(msg.sender, user) returns (uint256) {\n    require(user != address(0), 'INVALID_USER_ADDRESS');\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimRewards(assets, amount, msg.sender, user, to);\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function claimRewardsToSelf(address[] calldata assets, uint256 amount)\n    external\n    override\n    returns (uint256)\n  {\n    return _claimRewards(assets, amount, msg.sender, msg.sender, msg.sender);\n  }\n\n  /**\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards.\n   * @param amount Amount of rewards to claim\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n\n  /// @inheritdoc IAaveIncentivesController\n  function setClaimer(address user, address caller) external override onlyEmissionManager {\n    _authorizedClaimers[user] = caller;\n    emit ClaimerSet(user, caller);\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function getClaimer(address user) external view override returns (address) {\n    return _authorizedClaimers[user];\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function getUserUnclaimedRewards(address _user) external view override returns (uint256) {\n    return _usersUnclaimedRewards[_user];\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function REWARD_TOKEN() external view override returns (address) {\n    return address(STAKE_TOKEN);\n  }\n\n  /**\n   * @dev returns the revision of the implementation contract\n   */\n  function getRevision() internal pure override returns (uint256) {\n    return REVISION;\n  }\n\n  /**\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards.\n   * @param amount Amount of rewards to claim\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n  function _claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address claimer,\n    address user,\n    address to\n  ) internal returns (uint256) {\n    if (amount == 0) {\n      return 0;\n    }\n    uint256 unclaimedRewards = _usersUnclaimedRewards[user];\n\n    DistributionTypes.UserStakeInput[] memory userState =\n      new DistributionTypes.UserStakeInput[](assets.length);\n    for (uint256 i = 0; i < assets.length; i++) {\n      userState[i].underlyingAsset = assets[i];\n      (userState[i].stakedByUser, userState[i].totalStaked) = IScaledBalanceToken(assets[i])\n        .getScaledUserBalanceAndSupply(user);\n    }\n\n    uint256 accruedRewards = _claimRewards(user, userState);\n    if (accruedRewards != 0) {\n      unclaimedRewards = unclaimedRewards.add(accruedRewards);\n      emit RewardsAccrued(user, accruedRewards);\n    }\n\n    if (unclaimedRewards == 0) {\n      return 0;\n    }\n\n    uint256 amountToClaim = amount > unclaimedRewards ? unclaimedRewards : amount;\n    _usersUnclaimedRewards[user] = unclaimedRewards - amountToClaim; // Safe due to the previous line\n\n    STAKE_TOKEN.stake(to, amountToClaim);\n    emit RewardsClaimed(user, to, claimer, amountToClaim);\n\n    return amountToClaim;\n  }\n}"
    },
    {
      "filename": "contracts/incentives/StakedTokenIncentivesController.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.5;\npragma experimental ABIEncoderV2;\n\nimport {SafeERC20} from '@aave/aave-stake/contracts/lib/SafeERC20.sol';\nimport {SafeMath} from '../lib/SafeMath.sol';\nimport {DistributionTypes} from '../lib/DistributionTypes.sol';\nimport {VersionedInitializable} from '@aave/aave-stake/contracts/utils/VersionedInitializable.sol';\nimport {DistributionManager} from './DistributionManager.sol';\nimport {IStakedTokenWithConfig} from '../interfaces/IStakedTokenWithConfig.sol';\nimport {IERC20} from '@aave/aave-stake/contracts/interfaces/IERC20.sol';\nimport {IScaledBalanceToken} from '../interfaces/IScaledBalanceToken.sol';\nimport {IAaveIncentivesController} from '../interfaces/IAaveIncentivesController.sol';\n\n/**\n * @title StakedTokenIncentivesController\n * @notice Distributor contract for rewards to the Aave protocol, using a staked token as rewards asset.\n * The contract stakes the rewards before redistributing them to the Aave protocol participants.\n * The reference staked token implementation is at https://github.com/aave/aave-stake-v2\n * @author Aave\n **/\ncontract StakedTokenIncentivesController is\n  IAaveIncentivesController,\n  VersionedInitializable,\n  DistributionManager\n{\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  uint256 public constant REVISION = 2;\n\n  IStakedTokenWithConfig public immutable STAKE_TOKEN;\n\n  mapping(address => uint256) internal _usersUnclaimedRewards;\n\n  // this mapping allows whitelisted addresses to claim on behalf of others\n  // useful for contracts that hold tokens to be rewarded but don't have any native logic to claim Liquidity Mining rewards\n  mapping(address => address) internal _authorizedClaimers;\n\n  modifier onlyAuthorizedClaimers(address claimer, address user) {\n    require(_authorizedClaimers[user] == claimer, 'CLAIMER_UNAUTHORIZED');\n    _;\n  }\n\n  constructor(IStakedTokenWithConfig stakeToken, address emissionManager)\n    DistributionManager(emissionManager)\n  {\n    STAKE_TOKEN = stakeToken;\n  }\n\n  /**\n   * @dev Initialize IStakedTokenIncentivesController. Empty after REVISION 1, but maintains the expected interface.\n   **/\n  function initialize(address) external initializer {}\n\n  /// @inheritdoc IAaveIncentivesController\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\n    external\n    override\n    onlyEmissionManager\n  {\n    require(assets.length == emissionsPerSecond.length, 'INVALID_CONFIGURATION');\n\n    DistributionTypes.AssetConfigInput[] memory assetsConfig =\n      new DistributionTypes.AssetConfigInput[](assets.length);\n\n    for (uint256 i = 0; i < assets.length; i++) {\n      assetsConfig[i].underlyingAsset = assets[i];\n      assetsConfig[i].emissionPerSecond = uint104(emissionsPerSecond[i]);\n\n      require(assetsConfig[i].emissionPerSecond == emissionsPerSecond[i], 'INVALID_CONFIGURATION');\n\n      assetsConfig[i].totalStaked = IScaledBalanceToken(assets[i]).scaledTotalSupply();\n    }\n    _configureAssets(assetsConfig);\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function handleAction(\n    address user,\n    uint256 totalSupply,\n    uint256 userBalance\n  ) external override {\n    uint256 accruedRewards = _updateUserAssetInternal(user, msg.sender, userBalance, totalSupply);\n    if (accruedRewards != 0) {\n      _usersUnclaimedRewards[user] = _usersUnclaimedRewards[user].add(accruedRewards);\n      emit RewardsAccrued(user, accruedRewards);\n    }\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function getRewardsBalance(address[] calldata assets, address user)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    uint256 unclaimedRewards = _usersUnclaimedRewards[user];\n\n    DistributionTypes.UserStakeInput[] memory userState =\n      new DistributionTypes.UserStakeInput[](assets.length);\n    for (uint256 i = 0; i < assets.length; i++) {\n      userState[i].underlyingAsset = assets[i];\n      (userState[i].stakedByUser, userState[i].totalStaked) = IScaledBalanceToken(assets[i])\n        .getScaledUserBalanceAndSupply(user);\n    }\n    unclaimedRewards = unclaimedRewards.add(_getUnclaimedRewards(user, userState));\n    return unclaimedRewards;\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to\n  ) external override returns (uint256) {\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimRewards(assets, amount, msg.sender, msg.sender, to);\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function claimRewardsOnBehalf(\n    address[] calldata assets,\n    uint256 amount,\n    address user,\n    address to\n  ) external override onlyAuthorizedClaimers(msg.sender, user) returns (uint256) {\n    require(user != address(0), 'INVALID_USER_ADDRESS');\n    require(to != address(0), 'INVALID_TO_ADDRESS');\n    return _claimRewards(assets, amount, msg.sender, user, to);\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function claimRewardsToSelf(address[] calldata assets, uint256 amount)\n    external\n    override\n    returns (uint256)\n  {\n    return _claimRewards(assets, amount, msg.sender, msg.sender, msg.sender);\n  }\n\n  /**\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards.\n   * @param amount Amount of rewards to claim\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n\n  /// @inheritdoc IAaveIncentivesController\n  function setClaimer(address user, address caller) external override onlyEmissionManager {\n    _authorizedClaimers[user] = caller;\n    emit ClaimerSet(user, caller);\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function getClaimer(address user) external view override returns (address) {\n    return _authorizedClaimers[user];\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function getUserUnclaimedRewards(address _user) external view override returns (uint256) {\n    return _usersUnclaimedRewards[_user];\n  }\n\n  /// @inheritdoc IAaveIncentivesController\n  function REWARD_TOKEN() external view override returns (address) {\n    return address(STAKE_TOKEN);\n  }\n\n  /**\n   * @dev returns the revision of the implementation contract\n   */\n  function getRevision() internal pure override returns (uint256) {\n    return REVISION;\n  }\n\n  /**\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards.\n   * @param amount Amount of rewards to claim\n   * @param user Address to check and claim rewards\n   * @param to Address that will be receiving the rewards\n   * @return Rewards claimed\n   **/\n  function _claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address claimer,\n    address user,\n    address to\n  ) internal returns (uint256) {\n    if (amount == 0) {\n      return 0;\n    }\n    uint256 unclaimedRewards = _usersUnclaimedRewards[user];\n\n    DistributionTypes.UserStakeInput[] memory userState =\n      new DistributionTypes.UserStakeInput[](assets.length);\n    for (uint256 i = 0; i < assets.length; i++) {\n      userState[i].underlyingAsset = assets[i];\n      (userState[i].stakedByUser, userState[i].totalStaked) = IScaledBalanceToken(assets[i])\n        .getScaledUserBalanceAndSupply(user);\n    }\n\n    uint256 accruedRewards = _claimRewards(user, userState);\n    if (accruedRewards != 0) {\n      unclaimedRewards = unclaimedRewards.add(accruedRewards);\n      emit RewardsAccrued(user, accruedRewards);\n    }\n\n    if (unclaimedRewards == 0) {\n      return 0;\n    }\n\n    uint256 amountToClaim = amount > unclaimedRewards ? unclaimedRewards : amount;\n    _usersUnclaimedRewards[user] = unclaimedRewards - amountToClaim; // Safe due to the previous line\n\n    STAKE_TOKEN.stake(to, amountToClaim);\n    emit RewardsClaimed(user, to, claimer, amountToClaim);\n\n    return amountToClaim;\n  }\n}"
    },
    {
      "filename": "contracts/incentives/StakedTokenIncentivesController.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.7.5;\npragma experimental ABIEncoderV2;\n\nimport {SafeERC20} from '@aave/aave-stake/contracts/lib/SafeERC20.s"
    }
  ]
}