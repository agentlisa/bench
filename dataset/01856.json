{
  "Title": "Unsynchronized positions in `NonFungiblePositionManager` and `AlgebraEternalFarming` can be exploited for receiving unfair rewards",
  "Content": "##### Description\n\nIf `FarmingCenter._updatePosition` reverts internally, `NonFungiblePositionManager` ignores that revert here: https://github.com/cryptoalgebra/Algebra/blob/7290fad656bfa89db3743c52af631154f6a8a2d5/src/periphery/contracts/NonfungiblePositionManager.sol#L369 leading to unsynchronized positions between the actual position and the farming position. The `_updatePosition` function consists of sequential calls to the `exitFarming` and `enterFarming` functions within the `AlgebraEternalFarming` contract https://github.com/cryptoalgebra/Algebra/blob/7290fad656bfa89db3743c52af631154f6a8a2d5/src/tokenomics/contracts/FarmingCenter.sol#L94. While the `exitFarming` function does not possess explicit revert statements, the `enterFarming` function can revert here: https://github.com/cryptoalgebra/Algebra/blob/7290fad656bfa89db3743c52af631154f6a8a2d5/src/tokenomics/contracts/farmings/AlgebraEternalFarming.sol#L385. These reverts prevent the creation of farming positions in detached or deactivated farmings. Consequently, if a pool is detached, every call to `NonFungiblePositionManager.decreaseLiquidity` will revert within the `FarmingCenter._updatePosition` function. As a result, the actual liquidity of the position in the pool will decrease, but the liquidity in the farming position will remain unchanged, allowing the `tokenId` owner to continue collecting higher rewards than deserved.\n\nFurthermore, this vulnerability can be exploited by users who can find a way to manually detach the pool from its incentive. Consider the following scenario:\n\n* The exploiter obtains a flashloan from an external project\n* The exploiter mints a position in the pool using loaned tokens and enters farming\n* The exploiter detaches the pool\n* The exploiter decreases liquidity of the position to the minimum possible causing desynchronization in `AlgebraEternalFarming` which retains the liquidity of the flahsloaned tokens.\n* The exploiter repays the flashloan\n\nIn this scenario, the exploiter can collect rewards without maintaining an actual position.\n\n##### Recommendation\nWe recommend implementing the forced exit from the farming position in cases when a revert occurs within the call of `NonFungiblePositionManager` here: https://github.com/cryptoalgebra/Algebra/blob/7290fad656bfa89db3743c52af631154f6a8a2d5/src/periphery/contracts/NonfungiblePositionManager.sol#L369, if feasible, to prevent unsynchronized farming positions.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/periphery/contracts/NonfungiblePositionManager.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.17;\npragma abicoder v2;\n\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraPool.sol';\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraFactory.sol';\nimport '@cryptoalgebra/core/contracts/libraries/Constants.sol';\nimport '@cryptoalgebra/core/contracts/libraries/FullMath.sol';\n\nimport './interfaces/INonfungiblePositionManager.sol';\nimport './interfaces/INonfungibleTokenPositionDescriptor.sol';\nimport './interfaces/IPositionFollower.sol';\nimport './libraries/PositionKey.sol';\nimport './libraries/PoolInteraction.sol';\nimport './libraries/PoolAddress.sol';\nimport './base/LiquidityManagement.sol';\nimport './base/PeripheryImmutableState.sol';\nimport './base/Multicall.sol';\nimport './base/ERC721Permit.sol';\nimport './base/PeripheryValidation.sol';\nimport './base/SelfPermit.sol';\nimport './base/PoolInitializer.sol';\n\n/// @title NFT positions\n/// @notice Wraps Algebra  positions in the ERC721 non-fungible token interface\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-periphery\ncontract NonfungiblePositionManager is\n    INonfungiblePositionManager,\n    Multicall,\n    ERC721Permit,\n    PeripheryImmutableState,\n    PoolInitializer,\n    LiquidityManagement,\n    PeripheryValidation,\n    SelfPermit\n{\n    using PoolInteraction for IAlgebraPool;\n\n    // details about the Algebra position\n    struct Position {\n        uint88 nonce; // the nonce for permits\n        address operator; // the address that is approved for spending this token\n        uint80 poolId; // the ID of the pool with which this token is connected\n        int24 tickLower; // the tick range of the position\n        int24 tickUpper;\n        uint128 liquidity; // the liquidity of the position\n        uint256 feeGrowthInside0LastX128; // the fee growth of the aggregate position as of the last action on the individual position\n        uint256 feeGrowthInside1LastX128;\n        uint128 tokensOwed0; // how many uncollected tokens are owed to the position, as of the last computation\n        uint128 tokensOwed1;\n    }\n\n    /// @dev IDs of pools assigned by this contract\n    mapping(address => uint80) private _poolIds;\n\n    /// @dev Pool keys by pool ID, to save on SSTOREs for position data\n    mapping(uint80 => PoolAddress.PoolKey) private _poolIdToPoolKey;\n\n    /// @dev The token ID position data\n    mapping(uint256 => Position) private _positions;\n\n    /// @dev The ID of the next token that will be minted. Skips 0\n    uint176 private _nextId = 1;\n    /// @dev The ID of the next pool that is used for the first time. Skips 0\n    uint80 private _nextPoolId = 1;\n\n    /// @dev The address of the token descriptor contract, which handles generating token URIs for position tokens\n    address private immutable _tokenDescriptor;\n\n    /// @dev The address of the farming center contract, which handles farmings logic\n    address public farmingCenter;\n\n    /// @dev mapping tokenId => farmingCenter\n    mapping(uint256 => address) public farmingApprovals;\n\n    /// @dev mapping tokenId => farmingCenter\n    mapping(uint256 => address) public tokenFarmedIn;\n\n    bytes32 public constant NONFUNGIBLE_POSITION_MANAGER_ADMINISTRATOR_ROLE =\n        keccak256('NONFUNGIBLE_POSITION_MANAGER_ADMINISTRATOR_ROLE');\n\n    constructor(\n        address _factory,\n        address _WNativeToken,\n        address _tokenDescriptor_,\n        address _poolDeployer\n    )\n        ERC721Permit('Algebra Positions NFT-V2', 'ALGB-POS', '2')\n        PeripheryImmutableState(_factory, _WNativeToken, _poolDeployer)\n    {\n        _tokenDescriptor = _tokenDescriptor_;\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function positions(\n        uint256 tokenId\n    )\n        external\n        view\n        override\n        returns (\n            uint88 nonce,\n            address operator,\n            address token0,\n            address token1,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        )\n    {\n        Position memory position = _positions[tokenId];\n        require(position.poolId != 0, 'Invalid token ID');\n        PoolAddress.PoolKey storage poolKey = _poolIdToPoolKey[position.poolId];\n        return (\n            position.nonce,\n            position.operator,\n            poolKey.token0,\n            poolKey.token1,\n            position.tickLower,\n            position.tickUpper,\n            position.liquidity,\n            position.feeGrowthInside0LastX128,\n            position.feeGrowthInside1LastX128,\n            position.tokensOwed0,\n            position.tokensOwed1\n        );\n    }\n\n    /// @dev Caches a pool key\n    function cachePoolKey(address pool, PoolAddress.PoolKey memory poolKey) private returns (uint80 poolId) {\n        if ((poolId = _poolIds[pool]) == 0) {\n            unchecked {\n                _poolIds[pool] = (poolId = _nextPoolId++);\n            }\n            _poolIdToPoolKey[poolId] = poolKey;\n        }\n    }\n\n    function getPoolById(uint80 poolId) private view returns (address) {\n        return PoolAddress.computeAddress(poolDeployer, _poolIdToPoolKey[poolId]);\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function mint(\n        MintParams calldata params\n    )\n        external\n        payable\n        override\n        checkDeadline(params.deadline)\n        returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1)\n    {\n        IAlgebraPool pool;\n        uint256 actualLiquidity;\n        (liquidity, actualLiquidity, amount0, amount1, pool) = addLiquidity(\n            AddLiquidityParams({\n                token0: params.token0,\n                token1: params.token1,\n                recipient: address(this),\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                amount0Desired: params.amount0Desired,\n                amount1Desired: params.amount1Desired,\n                amount0Min: params.amount0Min,\n                amount1Min: params.amount1Min\n            })\n        );\n\n        unchecked {\n            _mint(params.recipient, (tokenId = _nextId++));\n        }\n\n        (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool._getPositionInPool(\n            address(this),\n            params.tickLower,\n            params.tickUpper\n        );\n\n        // idempotent set\n        uint80 poolId = cachePoolKey(\n            address(pool),\n            PoolAddress.PoolKey({token0: params.token0, token1: params.token1})\n        );\n\n        _positions[tokenId] = Position({\n            nonce: 0,\n            operator: address(0),\n            poolId: poolId,\n            tickLower: params.tickLower,\n            tickUpper: params.tickUpper,\n            liquidity: uint128(actualLiquidity),\n            feeGrowthInside0LastX128: feeGrowthInside0LastX128,\n            feeGrowthInside1LastX128: feeGrowthInside1LastX128,\n            tokensOwed0: 0,\n            tokensOwed1: 0\n        });\n\n        emit IncreaseLiquidity(tokenId, liquidity, uint128(actualLiquidity), amount0, amount1, address(pool));\n    }\n\n    modifier isAuthorizedForToken(uint256 tokenId) {\n        _checkAuthorizationForToken(tokenId);\n        _;\n    }\n\n    function _checkAuthorizationForToken(uint256 tokenId) private view {\n        require(_isApprovedOrOwner(msg.sender, tokenId), 'Not approved');\n    }\n\n    function tokenURI(uint256 tokenId) public view override(ERC721, IERC721Metadata) returns (string memory) {\n        require(_exists(tokenId));\n        return INonfungibleTokenPositionDescriptor(_tokenDescriptor).tokenURI(this, tokenId);\n    }\n\n    // save bytecode by removing implementation of unused method\n    function baseURI() public pure returns (string memory) {}\n\n    function _updateUncollectedFees(\n        Position storage position,\n        IAlgebraPool pool,\n        address owner,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 positionLiquidity\n    ) private returns (uint128 tokensOwed0, uint128 tokensOwed1) {\n        (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool._getPositionInPool(\n            owner,\n            tickLower,\n            tickUpper\n        );\n        unchecked {\n            tokensOwed0 = uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128,\n                    positionLiquidity,\n                    Constants.Q128\n                )\n            );\n            tokensOwed1 = uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128,\n                    positionLiquidity,\n                    Constants.Q128\n                )\n            );\n        }\n\n        position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;\n        position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function increaseLiquidity(\n        IncreaseLiquidityParams calldata params\n    )\n        external\n        payable\n        override\n        checkDeadline(params.deadline)\n        returns (uint128 liquidity, uint256 amount0, uint256 amount1)\n    {\n        Position storage position = _positions[params.tokenId];\n\n        PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];\n\n        IAlgebraPool pool;\n        uint256 actualLiquidity;\n        (liquidity, actualLiquidity, amount0, amount1, pool) = addLiquidity(\n            AddLiquidityParams({\n                token0: poolKey.token0,\n                token1: poolKey.token1,\n                tickLower: position.tickLower,\n                tickUpper: position.tickUpper,\n                amount0Desired: params.amount0Desired,\n                amount1Desired: params.amount1Desired,\n                amount0Min: params.amount0Min,\n                amount1Min: params.amount1Min,\n                recipient: address(this)\n            })\n        );\n\n        // this is now updated to the current transaction\n        uint128 positionLiquidity = position.liquidity;\n        (uint128 tokensOwed0, uint128 tokensOwed1) = _updateUncollectedFees(\n            position,\n            pool,\n            address(this),\n            position.tickLower,\n            position.tickUpper,\n            positionLiquidity\n        );\n\n        unchecked {\n            position.tokensOwed0 += tokensOwed0;\n            position.tokensOwed1 += tokensOwed1;\n            position.liquidity = positionLiquidity + uint128(actualLiquidity);\n        }\n\n        if (farmingCenter != address(0) && tokenFarmedIn[params.tokenId] == farmingCenter) {\n            try IPositionFollower(farmingCenter).applyLiquidityDelta(params.tokenId, int256(actualLiquidity)) {\n                // do nothing\n            } catch {\n                emit FarmingFailed(params.tokenId);\n            }\n        }\n\n        emit IncreaseLiquidity(params.tokenId, liquidity, uint128(actualLiquidity), amount0, amount1, address(pool));\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function decreaseLiquidity(\n        DecreaseLiquidityParams calldata params\n    )\n        external\n        payable\n        override\n        isAuthorizedForToken(params.tokenId)\n        checkDeadline(params.deadline)\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(params.liquidity > 0);\n        Position storage position = _positions[params.tokenId];\n\n        (uint80 poolId, int24 tickLower, int24 tickUpper, uint128 positionLiquidity) = (\n            position.poolId,\n            position.tickLower,\n            position.tickUpper,\n            position.liquidity\n        );\n        require(positionLiquidity >= params.liquidity);\n\n        IAlgebraPool pool = IAlgebraPool(getPoolById(poolId));\n        (amount0, amount1) = pool._burnPositionInPool(tickLower, tickUpper, params.liquidity);\n\n        require(amount0 >= params.amount0Min && amount1 >= params.amount1Min, 'Price slippage check');\n\n        // scope to prevent stack-too-deep\n        {\n            // this is now updated to the current transaction\n            (uint128 tokensOwed0, uint128 tokensOwed1) = _updateUncollectedFees(\n                position,\n                pool,\n                address(this),\n                tickLower,\n                tickUpper,\n                positionLiquidity\n            );\n\n            unchecked {\n                position.tokensOwed0 += uint128(amount0) + tokensOwed0;\n                position.tokensOwed1 += uint128(amount1) + tokensOwed1;\n\n                // subtraction is safe because we checked positionLiquidity is gte params.liquidity\n                position.liquidity = positionLiquidity - params.liquidity;\n            }\n        }\n\n        if (farmingCenter != address(0) && tokenFarmedIn[params.tokenId] == farmingCenter) {\n            try\n                IPositionFollower(farmingCenter).applyLiquidityDelta(params.tokenId, -int256(uint256(params.liquidity)))\n            {\n                // do nothing\n            } catch {\n                emit FarmingFailed(params.tokenId);\n            }\n        }\n\n        emit DecreaseLiquidity(params.tokenId, params.liquidity, amount0, amount1);\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function collect(\n        CollectParams calldata params\n    ) external payable override isAuthorizedForToken(params.tokenId) returns (uint256 amount0, uint256 amount1) {\n        require(params.amount0Max > 0 || params.amount1Max > 0);\n        // allow collecting to the nft position manager address with address 0\n        address recipient = params.recipient == address(0) ? address(this) : params.recipient;\n\n        Position storage position = _positions[params.tokenId];\n        IAlgebraPool pool = IAlgebraPool(getPoolById(position.poolId));\n\n        (uint128 tokensOwed0, uint128 tokensOwed1) = (position.tokensOwed0, position.tokensOwed1);\n\n        // trigger an update of the position fees owed and fee growth snapshots if it has any liquidity\n        (int24 tickLower, int24 tickUpper, uint128 positionLiquidity) = (\n            position.tickLower,\n            position.tickUpper,\n            position.liquidity\n        );\n        if (positionLiquidity > 0) {\n            pool._burnPositionInPool(tickLower, tickUpper, 0);\n            (uint128 _tokensOwed0, uint128 _tokensOwed1) = _updateUncollectedFees(\n                position,\n                pool,\n                address(this),\n                tickLower,\n                tickUpper,\n                positionLiquidity\n            );\n\n            unchecked {\n                tokensOwed0 += _tokensOwed0;\n                tokensOwed1 += _tokensOwed1;\n            }\n        }\n\n        // compute the arguments to give to the pool#collect method\n        (uint128 amount0Collect, uint128 amount1Collect) = (\n            params.amount0Max > tokensOwed0 ? tokensOwed0 : params.amount0Max,\n            params.amount1Max > tokensOwed1 ? tokensOwed1 : params.amount1Max\n        );\n\n        // the actual amounts collected are returned\n        (amount0, amount1) = pool.collect(recipient, tickLower, tickUpper, amount0Collect, amount1Collect);\n\n        // sometimes there will be a few less wei than expected due to rounding down in core, but we just subtract the full amount expected\n        // instead of the actual amount so we can burn the token\n        unchecked {\n            (position.tokensOwed0, position.tokensOwed1) = (tokensOwed0 - amount0Collect, tokensOwed1 - amount1Collect);\n        }\n\n        emit Collect(params.tokenId, recipient, amount0Collect, amount1Collect);\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function burn(uint256 tokenId) external payable override isAuthorizedForToken(tokenId) {\n        Position storage position = _positions[tokenId];\n        require(position.liquidity | position.tokensOwed0 | position.tokensOwed1 == 0, 'Not cleared');\n\n        if (farmingCenter != address(0) && tokenFarmedIn[tokenId] == farmingCenter) {\n            try IPositionFollower(farmingCenter).burnPosition(tokenId) {\n                // do nothing\n            } catch {\n                emit FarmingFailed(tokenId);\n            }\n        }\n\n        delete _positions[tokenId];\n        delete farmingApprovals[tokenId];\n        delete tokenFarmedIn[tokenId];\n        _burn(tokenId);\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function approveForFarming(uint256 tokenId, bool approve) external payable override isAuthorizedForToken(tokenId) {\n        farmingApprovals[tokenId] = approve ? farmingCenter : address(0);\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function switchFarmingStatus(uint256 tokenId, bool toFarming) external override {\n        address _farmingCenter = farmingCenter;\n        bool accessAllowed = msg.sender == _farmingCenter;\n        if (toFarming) {\n            require(farmingApprovals[tokenId] == _farmingCenter, 'not approved for farming');\n        } else {\n            accessAllowed = accessAllowed || msg.sender == tokenFarmedIn[tokenId];\n        }\n        require(accessAllowed, 'only FarmingCenter');\n        tokenFarmedIn[tokenId] = toFarming ? _farmingCenter : address(0);\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function setFarmingCenter(address newFarmingCenter) external override {\n        require(IAlgebraFactory(factory).hasRoleOrOwner(NONFUNGIBLE_POSITION_MANAGER_ADMINISTRATOR_ROLE, msg.sender));\n        farmingCenter = newFarmingCenter;\n    }\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 tokenId) public view override(ERC721, IERC721) returns (address) {\n        require(_exists(tokenId), 'ERC721: approved query for nonexistent token');\n\n        return _positions[tokenId].operator;\n    }\n\n    function _getAndIncrementNonce(uint256 tokenId) internal override returns (uint256) {\n        unchecked {\n            return uint256(_positions[tokenId].nonce++);\n        }\n    }\n\n    /// @dev Overrides _transfer to clear farming approval\n    function _transfer(address from, address to, uint256 tokenId) internal override {\n        delete farmingApprovals[tokenId];\n        super._transfer(from, to, tokenId);\n    }\n\n    /// @dev Overrides _approve to use the operator in the position, which is packed with the position permit nonce\n    function _approve(address to, uint256 tokenId) internal override(ERC721) {\n        _positions[tokenId].operator = to;\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\n}"
    },
    {
      "filename": "src/periphery/contracts/NonfungiblePositionManager.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.17;\npragma abicoder v2;\n\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraPool.sol';\nimport '@cryptoalgebra/core/contracts/interfaces/IAlgebraFactory.sol';\nimport '@cryptoalgebra/core/contracts/libraries/Constants.sol';\nimport '@cryptoalgebra/core/contracts/libraries/FullMath.sol';\n\nimport './interfaces/INonfungiblePositionManager.sol';\nimport './interfaces/INonfungibleTokenPositionDescriptor.sol';\nimport './interfaces/IPositionFollower.sol';\nimport './libraries/PositionKey.sol';\nimport './libraries/PoolInteraction.sol';\nimport './libraries/PoolAddress.sol';\nimport './base/LiquidityManagement.sol';\nimport './base/PeripheryImmutableState.sol';\nimport './base/Multicall.sol';\nimport './base/ERC721Permit.sol';\nimport './base/PeripheryValidation.sol';\nimport './base/SelfPermit.sol';\nimport './base/PoolInitializer.sol';\n\n/// @title NFT positions\n/// @notice Wraps Algebra  positions in the ERC721 non-fungible token interface\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-periphery\ncontract NonfungiblePositionManager is\n    INonfungiblePositionManager,\n    Multicall,\n    ERC721Permit,\n    PeripheryImmutableState,\n    PoolInitializer,\n    LiquidityManagement,\n    PeripheryValidation,\n    SelfPermit\n{\n    using PoolInteraction for IAlgebraPool;\n\n    // details about the Algebra position\n    struct Position {\n        uint88 nonce; // the nonce for permits\n        address operator; // the address that is approved for spending this token\n        uint80 poolId; // the ID of the pool with which this token is connected\n        int24 tickLower; // the tick range of the position\n        int24 tickUpper;\n        uint128 liquidity; // the liquidity of the position\n        uint256 feeGrowthInside0LastX128; // the fee growth of the aggregate position as of the last action on the individual position\n        uint256 feeGrowthInside1LastX128;\n        uint128 tokensOwed0; // how many uncollected tokens are owed to the position, as of the last computation\n        uint128 tokensOwed1;\n    }\n\n    /// @dev IDs of pools assigned by this contract\n    mapping(address => uint80) private _poolIds;\n\n    /// @dev Pool keys by pool ID, to save on SSTOREs for position data\n    mapping(uint80 => PoolAddress.PoolKey) private _poolIdToPoolKey;\n\n    /// @dev The token ID position data\n    mapping(uint256 => Position) private _positions;\n\n    /// @dev The ID of the next token that will be minted. Skips 0\n    uint176 private _nextId = 1;\n    /// @dev The ID of the next pool that is used for the first time. Skips 0\n    uint80 private _nextPoolId = 1;\n\n    /// @dev The address of the token descriptor contract, which handles generating token URIs for position tokens\n    address private immutable _tokenDescriptor;\n\n    /// @dev The address of the farming center contract, which handles farmings logic\n    address public farmingCenter;\n\n    /// @dev mapping tokenId => farmingCenter\n    mapping(uint256 => address) public farmingApprovals;\n\n    /// @dev mapping tokenId => farmingCenter\n    mapping(uint256 => address) public tokenFarmedIn;\n\n    bytes32 public constant NONFUNGIBLE_POSITION_MANAGER_ADMINISTRATOR_ROLE =\n        keccak256('NONFUNGIBLE_POSITION_MANAGER_ADMINISTRATOR_ROLE');\n\n    constructor(\n        address _factory,\n        address _WNativeToken,\n        address _tokenDescriptor_,\n        address _poolDeployer\n    )\n        ERC721Permit('Algebra Positions NFT-V2', 'ALGB-POS', '2')\n        PeripheryImmutableState(_factory, _WNativeToken, _poolDeployer)\n    {\n        _tokenDescriptor = _tokenDescriptor_;\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function positions(\n        uint256 tokenId\n    )\n        external\n        view\n        override\n        returns (\n            uint88 nonce,\n            address operator,\n            address token0,\n            address token1,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        )\n    {\n        Position memory position = _positions[tokenId];\n        require(position.poolId != 0, 'Invalid token ID');\n        PoolAddress.PoolKey storage poolKey = _poolIdToPoolKey[position.poolId];\n        return (\n            position.nonce,\n            position.operator,\n            poolKey.token0,\n            poolKey.token1,\n            position.tickLower,\n            position.tickUpper,\n            position.liquidity,\n            position.feeGrowthInside0LastX128,\n            position.feeGrowthInside1LastX128,\n            position.tokensOwed0,\n            position.tokensOwed1\n        );\n    }\n\n    /// @dev Caches a pool key\n    function cachePoolKey(address pool, PoolAddress.PoolKey memory poolKey) private returns (uint80 poolId) {\n        if ((poolId = _poolIds[pool]) == 0) {\n            unchecked {\n                _poolIds[pool] = (poolId = _nextPoolId++);\n            }\n            _poolIdToPoolKey[poolId] = poolKey;\n        }\n    }\n\n    function getPoolById(uint80 poolId) private view returns (address) {\n        return PoolAddress.computeAddress(poolDeployer, _poolIdToPoolKey[poolId]);\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function mint(\n        MintParams calldata params\n    )\n        external\n        payable\n        override\n        checkDeadline(params.deadline)\n        returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1)\n    {\n        IAlgebraPool pool;\n        uint256 actualLiquidity;\n        (liquidity, actualLiquidity, amount0, amount1, pool) = addLiquidity(\n            AddLiquidityParams({\n                token0: params.token0,\n                token1: params.token1,\n                recipient: address(this),\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                amount0Desired: params.amount0Desired,\n                amount1Desired: params.amount1Desired,\n                amount0Min: params.amount0Min,\n                amount1Min: params.amount1Min\n            })\n        );\n\n        unchecked {\n            _mint(params.recipient, (tokenId = _nextId++));\n        }\n\n        (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool._getPositionInPool(\n            address(this),\n            params.tickLower,\n            params.tickUpper\n        );\n\n        // idempotent set\n        uint80 poolId = cachePoolKey(\n            address(pool),\n            PoolAddress.PoolKey({token0: params.token0, token1: params.token1})\n        );\n\n        _positions[tokenId] = Position({\n            nonce: 0,\n            operator: address(0),\n            poolId: poolId,\n            tickLower: params.tickLower,\n            tickUpper: params.tickUpper,\n            liquidity: uint128(actualLiquidity),\n            feeGrowthInside0LastX128: feeGrowthInside0LastX128,\n            feeGrowthInside1LastX128: feeGrowthInside1LastX128,\n            tokensOwed0: 0,\n            tokensOwed1: 0\n        });\n\n        emit IncreaseLiquidity(tokenId, liquidity, uint128(actualLiquidity), amount0, amount1, address(pool));\n    }\n\n    modifier isAuthorizedForToken(uint256 tokenId) {\n        _checkAuthorizationForToken(tokenId);\n        _;\n    }\n\n    function _checkAuthorizationForToken(uint256 tokenId) private view {\n        require(_isApprovedOrOwner(msg.sender, tokenId), 'Not approved');\n    }\n\n    function tokenURI(uint256 tokenId) public view override(ERC721, IERC721Metadata) returns (string memory) {\n        require(_exists(tokenId));\n        return INonfungibleTokenPositionDescriptor(_tokenDescriptor).tokenURI(this, tokenId);\n    }\n\n    // save bytecode by removing implementation of unused method\n    function baseURI() public pure returns (string memory) {}\n\n    function _updateUncollectedFees(\n        Position storage position,\n        IAlgebraPool pool,\n        address owner,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 positionLiquidity\n    ) private returns (uint128 tokensOwed0, uint128 tokensOwed1) {\n        (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool._getPositionInPool(\n            owner,\n            tickLower,\n            tickUpper\n        );\n        unchecked {\n            tokensOwed0 = uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128,\n                    positionLiquidity,\n                    Constants.Q128\n                )\n            );\n            tokensOwed1 = uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128,\n                    positionLiquidity,\n                    Constants.Q128\n                )\n            );\n        }\n\n        position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;\n        position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function increaseLiquidity(\n        IncreaseLiquidityParams calldata params\n    )\n        external\n        payable\n        override\n        checkDeadline(params.deadline)\n        returns (uint128 liquidity, uint256 amount0, uint256 amount1)\n    {\n        Position storage position = _positions[params.tokenId];\n\n        PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];\n\n        IAlgebraPool pool;\n        uint256 actualLiquidity;\n        (liquidity, actualLiquidity, amount0, amount1, pool) = addLiquidity(\n            AddLiquidityParams({\n                token0: poolKey.token0,\n                token1: poolKey.token1,\n                tickLower: position.tickLower,\n                tickUpper: position.tickUpper,\n                amount0Desired: params.amount0Desired,\n                amount1Desired: params.amount1Desired,\n                amount0Min: params.amount0Min,\n                amount1Min: params.amount1Min,\n                recipient: address(this)\n            })\n        );\n\n        // this is now updated to the current transaction\n        uint128 positionLiquidity = position.liquidity;\n        (uint128 tokensOwed0, uint128 tokensOwed1) = _updateUncollectedFees(\n            position,\n            pool,\n            address(this),\n            position.tickLower,\n            position.tickUpper,\n            positionLiquidity\n        );\n\n        unchecked {\n            position.tokensOwed0 += tokensOwed0;\n            position.tokensOwed1 += tokensOwed1;\n            position.liquidity = positionLiquidity + uint128(actualLiquidity);\n        }\n\n        if (farmingCenter != address(0) && tokenFarmedIn[params.tokenId] == farmingCenter) {\n            try IPositionFollower(farmingCenter).applyLiquidityDelta(params.tokenId, int256(actualLiquidity)) {\n                // do nothing\n            } catch {\n                emit FarmingFailed(params.tokenId);\n            }\n        }\n\n        emit IncreaseLiquidity(params.tokenId, liquidity, uint128(actualLiquidity), amount0, amount1, address(pool));\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function decreaseLiquidity(\n        DecreaseLiquidityParams calldata params\n    )\n        external\n        payable\n        override\n        isAuthorizedForToken(params.tokenId)\n        checkDeadline(params.deadline)\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(params.liquidity > 0);\n        Position storage position = _positions[params.tokenId];\n\n        (uint80 poolId, int24 tickLower, int24 tickUpper, uint128 positionLiquidity) = (\n            position.poolId,\n            position.tickLower,\n            position.tickUpper,\n            position.liquidity\n        );\n        require(positionLiquidity >= params.liquidity);\n\n        IAlgebraPool pool = IAlgebraPool(getPoolById(poolId));\n        (amount0, amount1) = pool._burnPositionInPool(tickLower, tickUpper, params.liquidity);\n\n        require(amount0 >= params.amount0Min && amount1 >= params.amount1Min, 'Price slippage check');\n\n        // scope to prevent stack-too-deep\n        {\n            // this is now updated to the current transaction\n            (uint128 tokensOwed0, uint128 tokensOwed1) = _updateUncollectedFees(\n                position,\n                pool,\n                address(this),\n                tickLower,\n                tickUpper,\n                positionLiquidity\n            );\n\n            unchecked {\n                position.tokensOwed0 += uint128(amount0) + tokensOwed0;\n                position.tokensOwed1 += uint128(amount1) + tokensOwed1;\n\n                // subtraction is safe because we checked positionLiquidity is gte params.liquidity\n                position.liquidity = positionLiquidity - params.liquidity;\n            }\n        }\n\n        if (farmingCenter != address(0) && tokenFarmedIn[params.tokenId] == farmingCenter) {\n            try\n                IPositionFollower(farmingCenter).applyLiquidityDelta(params.tokenId, -int256(uint256(params.liquidity)))\n            {\n                // do nothing\n            } catch {\n                emit FarmingFailed(params.tokenId);\n            }\n        }\n\n        emit DecreaseLiquidity(params.tokenId, params.liquidity, amount0, amount1);\n    }\n\n    /// @inheritdoc INonfungiblePositionManager\n    function collect(\n        CollectParams calldata params\n    ) external payable override isAuthorizedForToken(params.tokenId) returns (uint256 amount0, uint256 amount1) {\n        require(params.amount0Max > 0 || params.amount1Max > 0);\n        // allow collecting to the nft position manager address with address 0\n        address recipient = params.recipient == address(0) ? address(this) : params.recipient;\n\n        Position storage position = _positions[params.tokenId];\n        IAlgebraPool pool = IAlgebraPool(getPoolById(position.poolId));\n\n        (uint128 tokensOwed0, uint128 tokensOwed1) = (position.tokensOwed0, position.tokensOwed1);"
    }
  ]
}