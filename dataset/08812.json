{
  "Title": "[M-18] Repaying AAVE Loan in `_local` rather than `adopted` asset",
  "Content": "_Submitted by cloudjunky_\n\nWhen repaying the AAVE Portal in [`repayAavePortal()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80) the `_local` asset is used to repay the loan in `_backLoan()` rather than the `adopted` asset. This is likely to cause issues in production when actually repaying loans if the asset/token being repayed to AAVE is not the same as the asset/token that was borrowed.\n\n### Proof of Concept\n\nThe comment on [`L93`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L93) of [`PortalFacet.sol`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol) states;\n\n    // Need to swap into adopted asset or asset that was backing the loan\n    // The router will always be holding collateral in the local asset while the loaned asset\n    // is the adopted asset\n\nThe swap is executed on [`L98`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L98) in the call to `AssetLogic.swapFromLocalAssetIfNeededForExactOut()` however the return value `adopted` is never used (it's an unused local variable). The full function is shown below;\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave\n    (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalAmount,\n      _maxIn\n    );\n\n    if (!success) revert PortalFacet__repayAavePortal_swapFailed();\n\n    // decrement router balances\n    unchecked {\n      s.routerBalances[msg.sender][_local] -= amountIn;\n    }\n\n    // back loan\n    _backLoan(_local, _backingAmount, _feeAmount, _transferId);\n\nThe balance of the `_local` token is reduced but instead of the `adopted` token being passed to [`_backLoan()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L112) in L112 the `_local` token is used.\n\n### Tools Used\n\nVim\n\n### Recommended Mitigation Steps\n\nTo be consistent with the comments in the [`repayAavePortal()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80) function `adopted` should be passed to `_backLoan` so that the loan is repayed in the appropriate token.\n\nRemove the reference to `_local` in the [`_backLoan()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L112) function and replace it with `adopted` so it reads;\n\n`_backLoan(adopted, _backingAmount, _feeAmount, _transferId);`\n\n**[jakekidd (Connext) confirmed and resolved](https://github.com/code-423n4/2022-06-connext-findings/issues/103)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/103#issuecomment-1214780723):**\n > If routers are able to repay Aave debt using a token of higher denomination (i.e. pay `USDC` debt using `ETH` or `DAI`), then the liquidity portal functionality will be broken until Connext applies the necessary protocol upgrade to become solvent again.\n> \n> Considering the fact that only whitelisted routers have access to this feature and the bridge transfers are not broken but instead limited, I think `medium` severity makes sense.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-06-connext",
  "Code": [
    {
      "filename": "contracts/contracts/core/connext/facets/PortalFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\n\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\n\ncontract PortalFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error PortalFacet__setAavePortalFee_invalidFee();\n  error PortalFacet__repayAavePortal_insufficientFunds();\n  error PortalFacet__repayAavePortal_swapFailed();\n  error PortalFacet__repayAavePortalFor_notSupportedAsset();\n  error PortalFacet__repayAavePortalFor_zeroAmount();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a router executed a manual repayment to Aave Portal\n   * @param router - The router that execute the repayment\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRouterRepayment(address indexed router, address asset, uint256 amount, uint256 fee);\n\n  // ============ Getters methods ==============\n\n  function getAavePortalDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function getAavePortalFeeDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function aavePool() external view returns (address) {\n    return s.aavePool;\n  }\n\n  function aavePortalFee() external view returns (uint256) {\n    return s.aavePortalFeeNumerator;\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Sets the Aave Pool contract address.\n   * @dev Allows to set the aavePool to address zero to disable Aave Portal if needed\n   * @param _aavePool The address of the Aave Pool contract\n   */\n  function setAavePool(address _aavePool) external onlyOwner {\n    s.aavePool = _aavePool;\n  }\n\n  /**\n   * @notice Sets the Aave Portal fee numerator\n   * @param _aavePortalFeeNumerator The new value for the Aave Portal fee numerator\n   */\n  function setAavePortalFee(uint256 _aavePortalFeeNumerator) external onlyOwner {\n    if (_aavePortalFeeNumerator > s.LIQUIDITY_FEE_DENOMINATOR) revert PortalFacet__setAavePortalFee_invalidFee();\n\n    s.aavePortalFeeNumerator = _aavePortalFeeNumerator;\n  }\n\n  /**\n   * @notice Used by routers to perform a manual repayment to Aave Portals to cover any outstanding debt\n   * @dev The router must be approved for portal and with enough liquidity, and must be the caller of this\n   * function\n   * @param _local The local asset (what router stores liquidity in)\n   * @param _backingAmount The principle to be paid (in adopted asset)\n   * @param _feeAmount The fee to be paid (in adopted asset)\n   * @param _maxIn The max value of the local asset to swap for the _backingAmount of adopted asset\n   */\n  function repayAavePortal(\n    address _local,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    uint256 _maxIn,\n    bytes32 _transferId\n  ) external {\n    uint256 totalAmount = _backingAmount + _feeAmount; // in adopted\n    uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local\n\n    // Sanity check: has that much to spend\n    if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();\n\n    // Need to swap into adopted asset or asset that was backing the loan\n    // The router will always be holding collateral in the local asset while the loaned asset\n    // is the adopted asset\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave\n    (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalAmount,\n      _maxIn\n    );\n\n    if (!success) revert PortalFacet__repayAavePortal_swapFailed();\n\n    // decrement router balances\n    unchecked {\n      s.routerBalances[msg.sender][_local] -= amountIn;\n    }\n\n    // back loan\n    _backLoan(_local, _backingAmount, _feeAmount, _transferId);\n  }\n\n  /**\n   * @notice This allows anyone to repay the portal in the adopted asset for a given router\n   * and transfer\n   * @dev Should always be paying in the backing asset for the aave loan\n   * @param _router Router who took out the credit\n   * @param _adopted Address of the adopted asset (asset backing the loan)\n   * @param _backingAmount Amount of principle to repay\n   * @param _feeAmount Amount of fees to repay\n   * @param _transferId Corresponding transfer id for the fees\n   */\n  function repayAavePortalFor(\n    address _router,\n    address _adopted,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    bytes32 _transferId\n  ) external payable {\n    address adopted = _adopted == address(0) ? address(s.wrapper) : _adopted;\n    // Ensure the asset is whitelisted\n    ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[adopted];\n    if (canonical.id == bytes32(0)) {\n      revert PortalFacet__repayAavePortalFor_notSupportedAsset();\n    }\n\n    // Transfer funds to the contract\n    uint256 total = _backingAmount + _feeAmount;\n    if (total == 0) revert PortalFacet__repayAavePortalFor_zeroAmount();\n\n    (, uint256 amount) = AssetLogic.handleIncomingAsset(_adopted, total, 0);\n\n    // If this was a fee on transfer token, reduce the total\n    if (amount < total) {\n      uint256 missing = total - amount;\n      if (missing < _feeAmount) {\n        // Debit fee amount\n        _feeAmount -= missing;\n      } else {\n        // Debit backing amount\n        missing -= _feeAmount;\n        _feeAmount = 0;\n        _backingAmount -= missing;\n      }\n    }\n\n    // No need to swap because this is the adopted asset. Simply\n    // repay the loan\n    _backLoan(adopted, _backingAmount, _feeAmount, _transferId);\n  }\n\n  // ============ Internal functions ============\n\n  /**\n   * @notice Calls backUnbacked on the aave contracts\n   * @dev Assumes funds in adopted asset are already on contract\n   * @param _asset Address of the adopted asset (asset backing the loan)\n   * @param _backing Amount of principle to repay\n   * @param _fee Amount of fees to repay\n   * @param _transferId Corresponding transfer id for the fees\n   */\n  function _backLoan(\n    address _asset,\n    uint256 _backing,\n    uint256 _fee,\n    bytes32 _transferId\n  ) internal {\n    // reduce debt\n    s.portalDebt[_transferId] -= _backing;\n    s.portalFeeDebt[_transferId] -= _fee;\n\n    // increase allowance\n    SafeERC20Upgradeable.safeIncreaseAllowance(IERC20Upgradeable(_asset), s.aavePool, _backing + _fee);\n\n    // back loan\n    IAavePool(s.aavePool).backUnbacked(_asset, _backing, _fee);\n\n    // emit event\n    emit AavePortalRouterRepayment(msg.sender, _asset, _backing, _fee);\n  }\n}"
    },
    {
      "filename": "contracts/contracts/core/connext/facets/PortalFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\n\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\n\ncontract PortalFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error PortalFacet__setAavePortalFee_invalidFee();\n  error PortalFacet__repayAavePortal_insufficientFunds();\n  error PortalFacet__repayAavePortal_swapFailed();\n  error PortalFacet__repayAavePortalFor_notSupportedAsset();\n  error PortalFacet__repayAavePortalFor_zeroAmount();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a router executed a manual repayment to Aave Portal\n   * @param router - The router that execute the repayment\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRouterRepayment(address indexed router, address asset, uint256 amount, uint256 fee);\n\n  // ============ Getters methods ==============\n\n  function getAavePortalDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function getAavePortalFeeDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function aavePool() external view returns (address) {\n    return s.aavePool;\n  }\n\n  function aavePortalFee() external view returns (uint256) {\n    return s.aavePortalFeeNumerator;\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Sets the Aave Pool contract address.\n   * @dev Allows to set the aavePool to address zero to disable Aave Portal if needed\n   * @param _aavePool The address of the Aave Pool contract\n   */\n  function setAavePool(address _aavePool) external onlyOwner {\n    s.aavePool = _aavePool;\n  }\n\n  /**\n   * @notice Sets the Aave Portal fee numerator\n   * @param _aavePortalFeeNumerator The new value for the Aave Portal fee numerator\n   */\n  function setAavePortalFee(uint256 _aavePortalFeeNumerator) external onlyOwner {\n    if (_aavePortalFeeNumerator > s.LIQUIDITY_FEE_DENOMINATOR) revert PortalFacet__setAavePortalFee_invalidFee();\n\n    s.aavePortalFeeNumerator = _aavePortalFeeNumerator;\n  }\n\n  /**\n   * @notice Used by routers to perform a manual repayment to Aave Portals to cover any outstanding debt\n   * @dev The router must be approved for portal and with enough liquidity, and must be the caller of this\n   * function\n   * @param _local The local asset (what router stores liquidity in)\n   * @param _backingAmount The principle to be paid (in adopted asset)\n   * @param _feeAmount The fee to be paid (in adopted asset)\n   * @param _maxIn The max value of the local asset to swap for the _backingAmount of adopted asset\n   */\n  function repayAavePortal(\n    address _local,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    uint256 _maxIn,\n    bytes32 _transferId\n  ) external {\n    uint256 totalAmount = _backingAmount + _feeAmount; // in adopted\n    uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local\n\n    // Sanity check: has that much to spend\n    if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();\n\n    // Need to swap into adopted asset or asset that was backing the loan\n    // The router will always be holding collateral in the local asset while the loaned asset\n    // is the adopted asset\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave\n    (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalAmount,\n      _maxIn\n    );\n\n    if (!success) revert PortalFacet__repayAavePortal_swapFailed();\n\n    // decrement router balances\n    unchecked {\n      s.routerBalances[msg.sender][_local] -= amountIn;\n    }\n\n    // back loan\n    _backLoan(_local, _backingAmount, _feeAmount, _transferId);\n  }\n\n  /**\n   * @notice This allows anyone to repay the portal in the adopted asset for a given router\n   * and transfer\n   * @dev Should always be paying in the backing asset for the aave loan\n   * @param _router Router who took out the credit\n   * @param _adopted Address of the adopted asset (asset backing the loan)\n   * @param _backingAmount Amount of principle to repay\n   * @param _feeAmount Amount of fees to repay\n   * @param _transferId Corresponding transfer id for the fees\n   */\n  function repayAavePortalFor(\n    address _router,\n    address _adopted,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    bytes32 _transferId\n  ) external payable {\n    address adopted = _adopted == address(0) ? address(s.wrapper) : _adopted;\n    // Ensure the asset is whitelisted\n    ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[adopted];\n    if (canonical.id == bytes32(0)) {\n      revert PortalFacet__repayAavePortalFor_notSupportedAsset();\n    }\n\n    // Transfer funds to the contract\n    uint256 total = _backingAmount + _feeAmount;\n    if (total == 0) revert PortalFacet__repayAavePortalFor_zeroAmount();\n\n    (, uint256 amount) = AssetLogic.handleIncomingAsset(_adopted, total, 0);\n\n    // If this was a fee on transfer token, reduce the total\n    if (amount < total) {\n      uint256 missing = total - amount;\n      if (missing < _feeAmount) {\n        // Debit fee amount\n        _feeAmount -= missing;\n      } else {\n        // Debit backing amount\n        missing -= _feeAmount;\n        _feeAmount = 0;\n        _backingAmount -= missing;\n      }\n    }\n\n    // No need to swap because this is the adopted asset. Simply\n    // repay the loan\n    _backLoan(adopted, _backingAmount, _feeAmount, _transferId);\n  }\n\n  // ============ Internal functions ============\n\n  /**\n   * @notice Calls backUnbacked on the aave contracts\n   * @dev Assumes funds in adopted asset are already on contract\n   * @param _asset Address of the adopted asset (asset backing the loan)\n   * @param _backing Amount of principle to repay\n   * @param _fee Amount of fees to repay\n   * @param _transferId Corresponding transfer id for the fees\n   */\n  function _backLoan(\n    address _asset,\n    uint256 _backing,\n    uint256 _fee,\n    bytes32 _transferId\n  ) internal {\n    // reduce debt\n    s.portalDebt[_transferId] -= _backing;\n    s.portalFeeDebt[_transferId] -= _fee;\n\n    // increase allowance\n    SafeERC20Upgradeable.safeIncreaseAllowance(IERC20Upgradeable(_asset), s.aavePool, _backing + _fee);\n\n    // back loan\n    IAavePool(s.aavePool).backUnbacked(_asset, _backing, _fee);\n\n    // emit event\n    emit AavePortalRouterRepayment(msg.sender, _asset, _backing, _fee);\n  }\n}"
    },
    {
      "filename": "contracts/contracts/core/connext/facets/PortalFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\n\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\n\ncontract PortalFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error PortalFacet__setAavePortalFee_invalidFee();\n  error PortalFacet__repayAavePortal_insufficientFunds();\n  error PortalFacet__repayAavePortal_swapFailed();\n  error PortalFacet__repayAavePortalFor_notSupportedAsset();\n  error PortalFacet__repayAavePortalFor_zeroAmount();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a router executed a manual repayment to Aave Portal\n   * @param router - The router that execute the repayment\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRouterRepayment(address indexed router, address asset, uint256 amount, uint256 fee);\n\n  // ============ Getters methods ==============\n\n  function getAavePortalDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function getAavePortalFeeDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function aavePool() external view returns (address) {\n    return s.aavePool;\n  }\n\n  function aavePortalFee() external view returns (uint256) {\n    return s.aavePortalFeeNumerator;\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Sets the Aave Pool contract address.\n   * @dev Allows to set the aavePool to address zero to disable Aave Portal if needed\n   * @param _aavePool The address of the Aave Pool contract\n   */\n  function setAavePool(address _aavePool) external onlyOwner {\n    s.aavePool = _aavePool;\n  }\n\n  /**\n   * @notice Sets the Aave Portal fee numerator\n   * @param _aavePortalFeeNumerator The new value for the Aave Portal fee numerator\n   */\n  function setAavePortalFee(uint256 _aavePortalFeeNumerator) external onlyOwner {\n    if (_aavePortalFeeNumerator > s.LIQUIDITY_FEE_DENOMINATOR) revert PortalFacet__setAavePortalFee_invalidFee();\n\n    s.aavePortalFeeNumerator = _aavePortalFeeNumerator;\n  }\n\n  /**\n   * @notice Used by routers to perform a manual repayment to Aave Portals to cover any outstanding debt\n   * @dev The router must be approved for portal and with enough liquidity, and must be the caller of this\n   * function\n   * @param _local The local asset (what router stores liquidity in)\n   * @param _backingAmount The principle to be paid (in adopted asset)\n   * @param _feeAmount The fee to be paid (in adopted asset)\n   * @param _maxIn The max value of the local asset to swap for the _backingAmount of adopted asset\n   */\n  function repayAavePortal(\n    address _local,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    uint256 _maxIn,\n    bytes32 _transferId\n  ) external {\n    uint256 totalAmount = _backingAmount + _feeAmount; // in adopted\n    uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local\n\n    // Sanity check: has that much to spend\n    if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();\n\n    // Need to swap into adopted asset or asset that was backing the loan\n    // The router will always be holding collateral in the local asset while the loaned asset\n    // is the adopted asset\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave\n    (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalAmount,\n      _maxIn\n    );\n\n    if (!success) revert PortalFacet__repayAavePortal_swapFailed();\n\n    // decrement router balances\n    unchecked {\n      s.routerBalances[msg.sender][_local] -= amountIn;\n    }\n\n    // back loan\n    _backLoan(_local, _backingAmount, _feeAmount, _transferId);\n  }\n\n  /**\n   * @notice This allows anyone to repay the portal in the adopted asset for a given router\n   * and transfer\n   * @dev Should always be paying in the backing asset for the aave loan\n   * @param _router Router who took out the credit\n   * @param _adopted Address of the adopted asset (asset backing the loan)\n   * @param _backingAmount Amount of principle to repay\n   * @param _feeAmount Amount of fees to repay\n   * @param _transferId Corresponding transfer id for the fees\n   */\n  function repayAavePortalFor(\n    address _router,\n    address _adopted,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    bytes32 _transferId\n  ) external payable {\n    address adopted = _adopted == address(0) ? address(s.wrapper) : _adopted;\n    // Ensure the asset is whitelisted\n    ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[adopted];\n    if (canonical.id == bytes32(0)) {\n      revert PortalFacet__repayAavePortalFor_notSupportedAsset();\n    }\n\n    // Transfer funds to the contract\n    uint256 total = _backingAmount + _feeAmount;\n    if (total == 0) revert PortalFacet__repayAavePortalFor_zeroAmount();\n\n    (, uint256 amount) = AssetLogic.handleIncomingAsset(_adopted, total, 0);\n\n    // If this was a fee on transfer token, reduce the total\n    if (amount < total) {\n      uint256 missing = total - amount;\n      if (missing < _feeAmount) {\n        // Debit fee amount\n        _feeAmount -= missing;\n      } else {\n        // Debit backing amount\n        missing -= _feeAmount;\n        _feeAmount = 0;\n        _backingAmount -= missing;\n      }\n    }\n\n    // No need to swap because this is the adopted asset. Simply\n    // repay the loan\n    _backLoan(adopted, _backingAmount, _feeAmount, _transferId);\n  }\n\n  // ============ Internal functions ============\n\n  /**\n   * @notice Calls backUnbacked on the aave contracts\n   * @dev Assumes funds in adopted asset are already on contract\n   * @param _asset Address of the adopted asset (asset backing the loan)\n   * @param _backing Amount of principle to repay\n   * @param _fee Amount of fees to repay\n   * @param _transferId Corresponding transfer id for the fees\n   */\n  function _backLoan(\n    address _asset,\n    uint256 _backing,\n    uint256 _fee,\n    bytes32 _transferId\n  ) internal {\n    // reduce debt\n    s.portalDebt[_transferId] -= _backing;\n    s.portalFeeDebt[_transferId] -= _fee;\n\n    // increase allowance\n    SafeERC20Upgradeable.safeIncreaseAllowance(IERC20Upgradeable(_asset), s.aavePool, _backing + _fee);\n\n    // back loan\n    IAavePool(s.aavePool).backUnbacked(_asset, _backing, _fee);\n\n    // emit event\n    emit AavePortalRouterRepayment(msg.sender, _asset, _backing, _fee);\n  }\n}"
    },
    {
      "filename": "contracts/contracts/core/connext/facets/PortalFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\n\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\n\ncontract PortalFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error PortalFacet__setAavePortalFee_invalidFee();\n  error PortalFacet__repayAavePortal_insufficientFunds();\n  error PortalFacet__repayAavePortal_swapFailed();\n  error PortalFacet__repayAavePortalFor_notSupportedAsset();\n  error PortalFacet__repayAavePortalFor_zeroAmount();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a router executed a manual repayment to Aave Portal\n   * @param router - The router that execute the repayment\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRouterRepayment(address indexed router, address asset, uint256 amount, uint256 fee);\n\n  // ============ Getters methods ==============\n\n  function getAavePortalDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function getAavePortalFeeDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function aavePool() external view returns (address) {\n    return s.aavePool;\n  }\n\n  function aavePortalFee() external view returns (uint256) {\n    return s.aavePortalFeeNumerator;\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Sets the Aave Pool contract address.\n   * @dev Allows to set the aavePool to address zero to disable Aave Portal if needed\n   * @param _aavePool The address of the Aave Pool contract\n   */\n  function setAavePool(address _aavePool) external onlyOwner {\n    s.aavePool = _aavePool;\n  }\n\n  /**\n   * @notice Sets the Aave Portal fee numerator\n   * @param _aavePortalFeeNumerator The new value for the Aave Portal fee numerator\n   */\n  function setAavePortalFee(uint256 _aavePortalFeeNumerator) external onlyOwner {\n    if (_aavePortalFeeNumerator > s.LIQUIDITY_FEE_DENOMINATOR) revert PortalFacet__setAavePortalFee_invalidFee();\n\n    s.aavePortalFeeNumerator = _aavePortalFeeNumerator;\n  }\n\n  /**\n   * @notice Used by routers to perform a manual repayment to Aave Portals to cover any outstanding debt\n   * @dev The router must be approved for portal and with enough liquidity, and must be the caller of this\n   * function\n   * @param _local The local asset (what router stores liquidity in)\n   * @param _backingAmount The principle to be paid (in adopted asset)\n   * @param _feeAmount The fee to be paid (in adopted asset)\n   * @param _maxIn The max value of the local asset to swap for the _backingAmount of adopted asset\n   */\n  function repayAavePortal(\n    address _local,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    uint256 _maxIn,\n    bytes32 _transferId\n  ) external {\n    uint256 totalAmount = _backingAmount + _feeAmount; // in adopted\n    uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local\n\n    // Sanity check: has that much to spend\n    if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();\n\n    // Need to swap into adopted asset or asset that was backing the loan\n    // The router will always be holding collateral in the local asset while the loaned asset\n    // is the adopted asset\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave\n    (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalAmount,\n      _maxIn\n    );\n\n    if (!success) revert PortalFacet__repayAavePortal_swapFailed();\n\n    // decrement router balances\n    unchecked {\n      s.routerBalances[msg.sender][_local] -= amountIn;\n    }\n\n    // back loan\n    _backLoan(_local, _backingAmount, _feeAmount, _transferId);\n  }\n\n  /**\n   * @notice This allows anyone to repay the portal in the adopted asset for a given router\n   * and transfer\n   * @dev Should always be paying in the backing asset for the aave loan\n   * @param _router Router who took out the credit\n   * @param _adopted Address of the adopted asset (asset backing the loan)\n   * @param _backingAmount Amount of principle to repay\n   * @param _feeAmount Amount of fees to repay\n   * @param _transferId Corresponding transfer id for the fees\n   */\n  function repayAavePortalFor(\n    address _router,\n    address _adopted,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    bytes32 _transferId\n  ) external payable {\n    address adopted = _adopted == address(0) ? address(s.wrapper) : _adopted;\n    // Ensure the asset is whitelisted\n    ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[adopted];\n    if (canonical.id == bytes32(0)) {\n      revert PortalFacet__repayAavePortalFor_notSupportedAsset();\n    }\n\n    // Transfer funds to the contract\n    uint256 total = _backingAmount + _feeAmount;\n    if (total == 0) revert PortalFacet__repayAavePortalFor_zeroAmount();\n\n    (, uint256 amount) = AssetLogic.handleIncomingAsset(_adopted, total, 0);\n\n    // If this was a fee on transfer token, reduce the total\n    if (amount < total) {\n      uint256 missing = total - amount;\n      if (missing < _feeAmount) {\n        // Debit fee amount\n        _feeAmount -= missing;\n      } else {\n        // Debit backing amount\n        missing -= _feeAmount;\n        _feeAmount = 0;\n        _backingAmount -= missing;\n      }\n    }\n\n    // No need to swap because this is the adopted asset. Simply\n    // repay the loan\n    _backLoan(adopted, _backingAmount, _feeAmount, _transferId);\n  }\n\n  // ============ Internal functions ============\n\n  /**\n   * @notice Calls backUnbacked on the aave contracts\n   * @dev Assumes funds in adopted asset are already on contract\n   * @param _asset Address of the adopted asset (asset backing the loan)\n   * @param _backing Amount of principle to repay\n   * @param _fee Amount of fees to repay\n   * @param _transferId Corresponding transfer id for the fees\n   */\n  function _backLoan(\n    address _asset,\n    uint256 _backing,\n    uint256 _fee,\n    bytes32 _transferId\n  ) internal {\n    // reduce debt\n    s.portalDebt[_transferId] -= _backing;\n    s.portalFeeDebt[_transferId] -= _fee;\n\n    // increase allowance\n    SafeERC20Upgradeable.safeIncreaseAllowance(IERC20Upgradeable(_asset), s.aavePool, _backing + _fee);\n\n    // back loan\n    IAavePool(s.aavePool).backUnbacked(_asset, _backing, _fee);\n\n    // emit event\n    emit AavePortalRouterRepayment(msg.sender, _asset, _backing, _fee);\n  }\n}"
    },
    {
      "filename": "contracts/contracts/core/connext/facets/PortalFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.14;\n\nimport {SafeERC20Upgradeable, IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\n\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {ConnextMessage} from \"../libraries/ConnextMessage.sol\";\n\ncontract PortalFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error PortalFacet__setAavePortalFee_invalidFee();\n  error PortalFacet__repayAavePortal_insufficientFunds();\n  error PortalFacet__repayAavePortal_swapFailed();\n  error PortalFacet__repayAavePortalFor_notSupportedAsset();\n  error PortalFacet__repayAavePortalFor_zeroAmount();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a router executed a manual repayment to Aave Portal\n   * @param router - The router that execute the repayment\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRouterRepayment(address indexed router, address asset, uint256 amount, uint256 fee);\n\n  // ============ Getters methods ==============\n\n  function getAavePortalDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function getAavePortalFeeDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function aavePool() external view returns (address) {\n    return s.aavePool;\n  }\n\n  function aavePortalFee() external view returns (uint256) {\n    return s.aavePortalFeeNumerator;\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Sets the Aave Pool contract address.\n   * @dev Allows to set the aavePool to address zero to disable Aave Portal if needed\n   * @param _aavePool The address of the Aave Pool contract\n   */\n  function setAavePool(address _aavePool) external onlyOwner {\n    s.aavePool = _aavePool;\n  }\n\n  /**\n   * @notice Sets the Aave Portal fee numerator\n   * @param _aavePortalFeeNumerator The new value for the Aave Portal fee numerator\n   */\n  function setAavePortalFee(uint256 _aavePortalFeeNumerator) external onlyOwner {\n    if (_aavePortalFeeNumerator > s.LIQUIDITY_FEE_DENOMINATOR) revert PortalFacet__setAavePortalFee_invalidFee();\n\n    s.aavePortalFeeNumerator = _aavePortalFeeNumerator;\n  }\n\n  /**\n   * @notice Used by routers to perform a manual repayment to Aave Portals to cover any outstanding debt\n   * @dev The router must be approved for portal and with enough liquidity, and must be the caller of this\n   * function\n   * @param _local The local asset (what router stores liquidity in)\n   * @param _backingAmount The principle to be paid (in adopted asset)\n   * @param _feeAmount The fee to be paid (in adopted asset)\n   * @param _maxIn The max value of the local asset to swap for the _backingAmount of adopted asset\n   */\n  function repayAavePortal(\n    address _local,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    uint256 _maxIn,\n    bytes32 _transferId\n  ) external {\n    uint256 totalAmount = _backingAmount + _feeAmount; // in adopted\n    uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local\n\n    // Sanity check: has that much to spend\n    if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();\n\n    // Need to swap into adopted asset or asset that was backing the loan\n    // The router will always be holding collateral in the local asset while the loaned asset\n    // is the adopted asset\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave\n    (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      _local,\n      totalAmount,\n      _maxIn\n    );\n\n    if (!success) revert PortalFacet__repayAavePortal_swapFailed();\n\n    // decrement router balances\n    unchecked {\n      s.routerBalances[msg.sender][_local] -= amountIn;\n    }\n\n    // back loan\n    _backLoan(_local, _backingAmount, _feeAmount, _transferId);\n  }\n\n  /**\n   * @notice This allows anyone to repay the portal in the adopted asset for a given router\n   * and transfer\n   * @dev Should always be paying in the backing asset for the aave loan\n   * @param _router Router who took out the credit\n   * @param _adopted Address of the adopted asset (asset backing the loan)\n   * @param _backingAmount Amount of principle to repay\n   * @param _feeAmount Amount of fees to repay\n   * @param _transferId Corresponding transfer id for the fees\n   */\n  function repayAavePortalFor(\n    address _router,\n    address _adopted,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    bytes32 _transferId\n  ) external payable {\n    address adopted = _adopted == address(0) ? address(s.wrapper) : _adopted;\n    // Ensure the asset is whitelisted\n    ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[adopted];\n    if (canonical.id == bytes32(0)) {\n      revert PortalFacet__repayAavePortalFor"
    }
  ]
}