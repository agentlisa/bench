{
  "Title": "[M-08] \"TWAP\" used is an observation-weighted-average-price, not a time-weighted one",
  "Content": "_Submitted by IllIllI_\n\nWhile users are incentivized to call the heartbeat, the incentive may be removed later, or it may be more profitable to use old prices, so users may not call the heartbeat during unfavorable prices, leading to the TWAP price being incorrect, and users getting the wrong price for their assets.\n\nA similar case of an incomplete TWAP algorithm was found to be of [Medium](https://github.com/code-423n4/2022-06-nibbl-findings/issues/191) risk.\n\n### Proof of Concept\n\nA TWAP is a Time-Weighted average price, but the algorithm below does not take into account the time between observations:\n\n```solidity\nFile: /src/modules/PRICE.sol   #1\n\n134          // Calculate new moving average\n135          if (currentPrice > earliestPrice) {\n136              _movingAverage += (currentPrice - earliestPrice) / numObs;\n137          } else {\n138              _movingAverage -= (earliestPrice - currentPrice) / numObs;\n139          }\n140  \n141          // Push new observation into storage and store timestamp taken at\n142          observations[nextObsIndex] = currentPrice;\n143          lastObservationTime = uint48(block.timestamp);\n144:         nextObsIndex = (nextObsIndex + 1) % numObs;\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/PRICE.sol#L134-L144>\n\nWhile the `Heart` policy enforces an upper bound on how frequently updates are added to the average, there is no guarantee that users call `beat()` in a timely manner:\n\n```solidity\nFile: /src/policies/Heart.sol   #2\n\n92       function beat() external nonReentrant {\n93           if (!active) revert Heart_BeatStopped();\n94:          if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle();\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L92-L94>\n\nThe incentive may be set to too low an amount:\n\n```solidity\nFile: /src/policies/Heart.sol   #3\n\n140      function setRewardTokenAndAmount(ERC20 token_, uint256 reward_)\n141          external\n142          onlyRole(\"heart_admin\")\n143      {\n144          rewardToken = token_;\n145          reward = reward_;\n146          emit RewardUpdated(token_, reward_);\n147:     }\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Heart.sol#L140-L147>\n\nOr users may find it more profitable to skip a particular update, or front-run an unfavorable update, with a transaction that trades assets at the old price\n\n### Recommended Mitigation Steps\n\nAlways call an internal version of `beat()` that doesn't revert, in functions that swap user assets. The code should also track the timestamps of when each `beat()` is called, and include the amount of time that has passed since the last beat, in the TWAP calculation\n\n**[Oighty (Olympus) disagreed with severity and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/267#issuecomment-1241043919):**\n > The referenced issue is a bit different than our use case since we will be using a much longer duration moving average. The goal is to get an approximate moving average over a certain period of time (e.g. 120 days) vs. an exact number since, as you say, the time of each observation cannot be guaranteed to be at a specific time. We believe that using a long duration with a sufficient number of observations will make this value close enough to the true value it is approximating, and prevents actors from manipulating the value by waiting to provide a specific value (1 out of ~360 obs doesn't move the needle). The use of the \"TWAP\" term may be semantically inaccurate.\n> \n> As for not guaranteeing that the update will be called or issues with several observations close to each other, see comments on [#405](https://github.com/code-423n4/2022-08-olympus-findings/issues/405) and [#79](https://github.com/code-423n4/2022-08-olympus-findings/issues/79).\n> \n> The mitigations suggested do not seem to provide a solution that improves the system. Calling `beat()` on user actions would not have the observations roughly evenly spaced. Tracking timestamps is possible, but I don't see how it improves the data.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/267#issuecomment-1251044977):**\n > @Oighty - I think the warden is suggesting that the call to beat() in the user actions would do more to ensure that the \"TWAP\" stays up to date.  If the call isn't past the correct period, it would just return and make no change (costing some amount of gas, ofc).\n> \n> I do think it may be worth considering, that way no user action can take place without the TWAP being as up to date as possible and no additional calls to the contract may be necessary if users are interacting with the contract frequently enough. \n> \n> While this is related to [#79](https://github.com/code-423n4/2022-08-olympus-findings/issues/79) - I think the points raised here and the mitigation is sufficiently different to warrant this issue to stand alone.  \n\n**[Oighty (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/267#issuecomment-1255235303):**\n > That's a fair point. One issue with calling `beat` on user actions, e.g. `Operator.swap`, is that it would update the wall price that the user is swapping at. Therefore, the call could fail due to the slippage check. This could be confusing behavior and may have unintended consequences of DOS'ing the system. Additionally, the gas cost of `beat` is highly variable (sometimes up to 600k gas when opening a bond market) and would cause some users to unexpectedly pay a lot more gas for a swap.\n> \n> I'll discuss with the team, but I don't think the pros exceed the cons.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/modules/PRICE.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {AggregatorV2V3Interface} from \"interfaces/AggregatorV2V3Interface.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport \"src/Kernel.sol\";\n\nimport {FullMath} from \"libraries/FullMath.sol\";\n\n// ERRORS\nerror Price_InvalidParams();\nerror Price_NotInitialized();\nerror Price_AlreadyInitialized();\nerror Price_BadFeed(address priceFeed);\n\n/// @notice Price oracle data storage contract\n/// @dev    The Olympus Price Oracle contract provides a standard interface for OHM price data against a reserve asset.\n///         It also implements a moving average price calculation (same as a TWAP) on the price feed data over a configured\n///         duration and observation frequency. The data provided by this contract is used by the Olympus Range Operator to\n///         perform market operations. The Olympus Price Oracle is updated each epoch by the Olympus Heart contract.\ncontract OlympusPrice is Module {\n    using FullMath for uint256;\n\n    /* ========== EVENTS =========== */\n    event NewObservation(uint256 timestamp_, uint256 price_, uint256 movingAverage_);\n    event MovingAverageDurationChanged(uint48 movingAverageDuration_);\n    event ObservationFrequencyChanged(uint48 observationFrequency_);\n    /* ========== STATE VARIABLES ========== */\n\n    /// @dev    Price feeds. Chainlink typically provides price feeds for an asset in ETH. Therefore, we use two price feeds against ETH, one for OHM and one for the Reserve asset, to calculate the relative price of OHM in the Reserve asset.\n    AggregatorV2V3Interface internal immutable _ohmEthPriceFeed;\n    AggregatorV2V3Interface internal immutable _reserveEthPriceFeed;\n\n    /// @dev Moving average data\n    uint256 internal _movingAverage; /// See getMovingAverage()\n\n    /// @notice Array of price observations. Check nextObsIndex to determine latest data point.\n    /// @dev    Observations are stored in a ring buffer where the moving average is the sum of all observations divided by the number of observations.\n    ///         Observations can be cleared by changing the movingAverageDuration or observationFrequency and must be re-initialized.\n    uint256[] public observations;\n\n    /// @notice Index of the next observation to make. The current value at this index is the oldest observation.\n    uint32 public nextObsIndex;\n\n    /// @notice Number of observations used in the moving average calculation. Computed from movingAverageDuration / observationFrequency.\n    uint32 public numObservations;\n\n    /// @notice Frequency (in seconds) that observations should be stored.\n    uint48 public observationFrequency;\n\n    /// @notice Duration (in seconds) over which the moving average is calculated.\n    uint48 public movingAverageDuration;\n\n    /// @notice Unix timestamp of last observation (in seconds).\n    uint48 public lastObservationTime;\n\n    /// @notice Number of decimals in the price values provided by the contract.\n    uint8 public constant decimals = 18;\n\n    /// @notice Whether the price module is initialized (and therefore active).\n    bool public initialized;\n\n    // Scale factor for converting prices, calculated from decimal values.\n    uint256 internal immutable _scaleFactor;\n\n    /*//////////////////////////////////////////////////////////////\n                            MODULE INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        AggregatorV2V3Interface ohmEthPriceFeed_,\n        AggregatorV2V3Interface reserveEthPriceFeed_,\n        uint48 observationFrequency_,\n        uint48 movingAverageDuration_\n    ) Module(kernel_) {\n        /// @dev Moving Average Duration should be divisible by Observation Frequency to get a whole number of observations\n        if (movingAverageDuration_ == 0 || movingAverageDuration_ % observationFrequency_ != 0)\n            revert Price_InvalidParams();\n\n        // Set price feeds, decimals, and scale factor\n        _ohmEthPriceFeed = ohmEthPriceFeed_;\n        uint8 ohmEthDecimals = _ohmEthPriceFeed.decimals();\n\n        _reserveEthPriceFeed = reserveEthPriceFeed_;\n        uint8 reserveEthDecimals = _reserveEthPriceFeed.decimals();\n\n        uint256 exponent = decimals + reserveEthDecimals - ohmEthDecimals;\n        if (exponent > 38) revert Price_InvalidParams();\n        _scaleFactor = 10**exponent;\n\n        // Set parameters and calculate number of observations\n        observationFrequency = observationFrequency_;\n        movingAverageDuration = movingAverageDuration_;\n\n        numObservations = uint32(movingAverageDuration_ / observationFrequency_);\n\n        // Store blank observations array\n        observations = new uint256[](numObservations);\n        /// nextObsIndex is initialized to 0\n\n        emit MovingAverageDurationChanged(movingAverageDuration_);\n        emit ObservationFrequencyChanged(observationFrequency_);\n    }\n\n    /// @inheritdoc Module\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"PRICE\");\n    }\n\n    /// @inheritdoc Module\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /* ========== POLICY FUNCTIONS ========== */\n\n    /// @notice Trigger an update of the moving average. Permissioned.\n    /// @dev    This function does not have a time-gating on the observationFrequency on this contract. It is set on the Heart policy contract.\n    ///         The Heart beat frequency should be set to the same value as the observationFrequency.\n    function updateMovingAverage() external permissioned {\n        // Revert if not initialized\n        if (!initialized) revert Price_NotInitialized();\n\n        // Cache numbe of observations to save gas.\n        uint32 numObs = numObservations;\n\n        // Get earliest observation in window\n        uint256 earliestPrice = observations[nextObsIndex];\n\n        uint256 currentPrice = getCurrentPrice();\n\n        // Calculate new moving average\n        if (currentPrice > earliestPrice) {\n            _movingAverage += (currentPrice - earliestPrice) / numObs;\n        } else {\n            _movingAverage -= (earliestPrice - currentPrice) / numObs;\n        }\n\n        // Push new observation into storage and store timestamp taken at\n        observations[nextObsIndex] = currentPrice;\n        lastObservationTime = uint48(block.timestamp);\n        nextObsIndex = (nextObsIndex + 1) % numObs;\n\n        emit NewObservation(block.timestamp, currentPrice, _movingAverage);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Get the current price of OHM in the Reserve asset from the price feeds\n    function getCurrentPrice() public view returns (uint256) {\n        if (!initialized) revert Price_NotInitialized();\n\n        // Get prices from feeds\n        uint256 ohmEthPrice;\n        uint256 reserveEthPrice;\n        {\n            (, int256 ohmEthPriceInt, , uint256 updatedAt, ) = _ohmEthPriceFeed.latestRoundData();\n            // Use a multiple of observation frequency to determine what is too old to use.\n            // Price feeds will not provide an updated answer if the data doesn't change much.\n            // This would be similar to if the feed just stopped updating; therefore, we need a cutoff.\n            if (updatedAt < block.timestamp - 3 * uint256(observationFrequency))\n                revert Price_BadFeed(address(_ohmEthPriceFeed));\n            ohmEthPrice = uint256(ohmEthPriceInt);\n\n            int256 reserveEthPriceInt;\n            (, reserveEthPriceInt, , updatedAt, ) = _reserveEthPriceFeed.latestRoundData();\n            if (updatedAt < block.timestamp - uint256(observationFrequency))\n                revert Price_BadFeed(address(_reserveEthPriceFeed));\n            reserveEthPrice = uint256(reserveEthPriceInt);\n        }\n\n        // Convert to OHM/RESERVE price\n        uint256 currentPrice = (ohmEthPrice * _scaleFactor) / reserveEthPrice;\n\n        return currentPrice;\n    }\n\n    /// @notice Get the last stored price observation of OHM in the Reserve asset\n    function getLastPrice() external view returns (uint256) {\n        if (!initialized) revert Price_NotInitialized();\n        uint32 lastIndex = nextObsIndex == 0 ? numObservations - 1 : nextObsIndex - 1;\n        return observations[lastIndex];\n    }\n\n    /// @notice Get the moving average of OHM in the Reserve asset over the defined window (see movingAverageDuration and observationFrequency).\n    function getMovingAverage() external view returns (uint256) {\n        if (!initialized) revert Price_NotInitialized();\n        return _movingAverage;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initialize the price module\n    /// @notice Access restricted to activated policies\n    /// @param  startObservations_ - Array of observations to initialize the moving average with. Must be of length numObservations.\n    /// @param  lastObservationTime_ - Unix timestamp of last observation being provided (in seconds).\n    /// @dev    This function must be called after the Price module is deployed to activate it and after updating the observationFrequency\n    ///         or movingAverageDuration (in certain cases) in order for the Price module to function properly.\n    function initialize(uint256[] memory startObservations_, uint48 lastObservationTime_)\n        external\n        permissioned\n    {\n        if (initialized) revert Price_AlreadyInitialized();\n\n        // Cache numObservations to save gas.\n        uint256 numObs = observations.length;\n\n        // Check that the number of start observations matches the number expected\n        if (startObservations_.length != numObs || lastObservationTime_ > uint48(block.timestamp))\n            revert Price_InvalidParams();\n\n        // Push start observations into storage and total up observations\n        uint256 total;\n        for (uint256 i; i < numObs; ) {\n            if (startObservations_[i] == 0) revert Price_InvalidParams();\n            total += startObservations_[i];\n            observations[i] = startObservations_[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Set moving average, last observation time, and initialized flag\n        _movingAverage = total / numObs;\n        lastObservationTime = lastObservationTime_;\n        initialized = true;\n    }\n\n    /// @notice Change the moving average window (duration)\n    /// @param  movingAverageDuration_ - Moving average duration in seconds, must be a multiple of observation frequency\n    /// @dev    Changing the moving average duration will erase the current observations array\n    ///         and require the initialize function to be called again. Ensure that you have saved\n    ///         the existing data and can re-populate before calling this function.\n    function changeMovingAverageDuration(uint48 movingAverageDuration_) external permissioned {\n        // Moving Average Duration should be divisible by Observation Frequency to get a whole number of observations\n        if (movingAverageDuration_ == 0 || movingAverageDuration_ % observationFrequency != 0)\n            revert Price_InvalidParams();\n\n        // Calculate the new number of observations\n        uint256 newObservations = uint256(movingAverageDuration_ / observationFrequency);\n\n        // Store blank observations array of new size\n        observations = new uint256[](newObservations);\n\n        // Set initialized to false and update state variables\n        initialized = false;\n        lastObservationTime = 0;\n        _movingAverage = 0;\n        nextObsIndex = 0;\n        movingAverageDuration = movingAverageDuration_;\n        numObservations = uint32(newObservations);\n\n        emit MovingAverageDurationChanged(movingAverageDuration_);\n    }\n\n    /// @notice   Change the observation frequency of the moving average (i.e. how often a new observation is taken)\n    /// @param    observationFrequency_ - Observation frequency in seconds, must be a divisor of the moving average duration\n    /// @dev      Changing the observation frequency clears existing observation data since it will not be taken at the right time intervals.\n    ///           Ensure that you have saved the existing data and/or can re-populate before calling this function.\n    function changeObservationFrequency(uint48 observationFrequency_) external permissioned {\n        // Moving Average Duration should be divisible by Observation Frequency to get a whole number of observations\n        if (observationFrequency_ == 0 || movingAverageDuration % observationFrequency_ != 0)\n            revert Price_InvalidParams();\n\n        // Calculate the new number of observations\n        uint256 newObservations = uint256(movingAverageDuration / observationFrequency_);\n\n        // Since the old observations will not be taken at the right intervals,\n        // the observations array will need to be reinitialized.\n        // Although, there are a handful of situations that could be handled\n        // (e.g. clean multiples of the old frequency),\n        // it is easier to do so off-chain and reinitialize the array.\n\n        // Store blank observations array of new size\n        observations = new uint256[](newObservations);\n\n        // Set initialized to false and update state variables\n        initialized = false;\n        lastObservationTime = 0;\n        _movingAverage = 0;\n        nextObsIndex = 0;\n        observationFrequency = observationFrequency_;\n        numObservations = uint32(newObservations);\n\n        emit ObservationFrequencyChanged(observationFrequency_);\n    }\n}"
    },
    {
      "filename": "src/policies/Heart.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IHeart} from \"policies/interfaces/IHeart.sol\";\nimport {IOperator} from \"policies/interfaces/IOperator.sol\";\n\nimport {OlympusPrice} from \"modules/PRICE.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// @title  Olympus Heart\n/// @notice Olympus Heart (Policy) Contract\n/// @dev    The Olympus Heart contract provides keeper rewards to call the heart beat function which fuels\n///         Olympus market operations. The Heart orchestrates state updates in the correct order to ensure\n///         market operations use up to date information.\ncontract OlympusHeart is IHeart, Policy, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    error Heart_OutOfCycle();\n    error Heart_BeatStopped();\n    error Heart_InvalidParams();\n\n    event Beat(uint256 timestamp_);\n    event RewardIssued(address to_, uint256 rewardAmount_);\n    event RewardUpdated(ERC20 token_, uint256 rewardAmount_);\n\n    /// @notice Status of the Heart, false = stopped, true = beating\n    bool public active;\n\n    /// @notice Timestamp of the last beat (UTC, in seconds)\n    uint256 public lastBeat;\n\n    /// @notice Reward for beating the Heart (in reward token decimals)\n    uint256 public reward;\n\n    /// @notice Reward token address that users are sent for beating the Heart\n    ERC20 public rewardToken;\n\n    // Modules\n    OlympusPrice internal PRICE;\n\n    // Policies\n    IOperator internal _operator;\n\n    /*//////////////////////////////////////////////////////////////\n                            POLICY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        IOperator operator_,\n        ERC20 rewardToken_,\n        uint256 reward_\n    ) Policy(kernel_) {\n        _operator = operator_;\n\n        active = true;\n        lastBeat = block.timestamp;\n        rewardToken = rewardToken_;\n        reward = reward_;\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](1);\n        dependencies[0] = toKeycode(\"PRICE\");\n\n        PRICE = OlympusPrice(getModuleAddress(dependencies[0]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        permissions = new Permissions[](1);\n        permissions[0] = Permissions(PRICE.KEYCODE(), PRICE.updateMovingAverage.selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function beat() external nonReentrant {\n        if (!active) revert Heart_BeatStopped();\n        if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle();\n\n        // Update the moving average on the Price module\n        PRICE.updateMovingAverage();\n\n        // Trigger price range update and market operations\n        _operator.operate();\n\n        // Update the last beat timestamp\n        lastBeat += frequency();\n\n        // Issue reward to sender\n        _issueReward(msg.sender);\n\n        emit Beat(block.timestamp);\n    }\n\n    function _issueReward(address to_) internal {\n        rewardToken.safeTransfer(to_, reward);\n        emit RewardIssued(to_, reward);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function frequency() public view returns (uint256) {\n        return uint256(PRICE.observationFrequency());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function resetBeat() external onlyRole(\"heart_admin\") {\n        lastBeat = block.timestamp - frequency();\n    }\n\n    /// @inheritdoc IHeart\n    function toggleBeat() external onlyRole(\"heart_admin\") {\n        active = !active;\n    }\n\n    /// @inheritdoc IHeart\n    function setRewardTokenAndAmount(ERC20 token_, uint256 reward_)\n        external\n        onlyRole(\"heart_admin\")\n    {\n        rewardToken = token_;\n        reward = reward_;\n        emit RewardUpdated(token_, reward_);\n    }\n\n    /// @inheritdoc IHeart\n    function withdrawUnspentRewards(ERC20 token_) external onlyRole(\"heart_admin\") {\n        token_.safeTransfer(msg.sender, token_.balanceOf(address(this)));\n    }\n}"
    },
    {
      "filename": "src/policies/Heart.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IHeart} from \"policies/interfaces/IHeart.sol\";\nimport {IOperator} from \"policies/interfaces/IOperator.sol\";\n\nimport {OlympusPrice} from \"modules/PRICE.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// @title  Olympus Heart\n/// @notice Olympus Heart (Policy) Contract\n/// @dev    The Olympus Heart contract provides keeper rewards to call the heart beat function which fuels\n///         Olympus market operations. The Heart orchestrates state updates in the correct order to ensure\n///         market operations use up to date information.\ncontract OlympusHeart is IHeart, Policy, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    error Heart_OutOfCycle();\n    error Heart_BeatStopped();\n    error Heart_InvalidParams();\n\n    event Beat(uint256 timestamp_);\n    event RewardIssued(address to_, uint256 rewardAmount_);\n    event RewardUpdated(ERC20 token_, uint256 rewardAmount_);\n\n    /// @notice Status of the Heart, false = stopped, true = beating\n    bool public active;\n\n    /// @notice Timestamp of the last beat (UTC, in seconds)\n    uint256 public lastBeat;\n\n    /// @notice Reward for beating the Heart (in reward token decimals)\n    uint256 public reward;\n\n    /// @notice Reward token address that users are sent for beating the Heart\n    ERC20 public rewardToken;\n\n    // Modules\n    OlympusPrice internal PRICE;\n\n    // Policies\n    IOperator internal _operator;\n\n    /*//////////////////////////////////////////////////////////////\n                            POLICY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        Kernel kernel_,\n        IOperator operator_,\n        ERC20 rewardToken_,\n        uint256 reward_\n    ) Policy(kernel_) {\n        _operator = operator_;\n\n        active = true;\n        lastBeat = block.timestamp;\n        rewardToken = rewardToken_;\n        reward = reward_;\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](1);\n        dependencies[0] = toKeycode(\"PRICE\");\n\n        PRICE = OlympusPrice(getModuleAddress(dependencies[0]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        permissions = new Permissions[](1);\n        permissions[0] = Permissions(PRICE.KEYCODE(), PRICE.updateMovingAverage.selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function beat() external nonReentrant {\n        if (!active) revert Heart_BeatStopped();\n        if (block.timestamp < lastBeat + frequency()) revert Heart_OutOfCycle();\n\n        // Update the moving average on the Price module\n        PRICE.updateMovingAverage();\n\n        // Trigger price range update and market operations\n        _operator.operate();\n\n        // Update the last beat timestamp\n        lastBeat += frequency();\n\n        // Issue reward to sender\n        _issueReward(msg.sender);\n\n        emit Beat(block.timestamp);\n    }\n\n    function _issueReward(address to_) internal {\n        rewardToken.safeTransfer(to_, reward);\n        emit RewardIssued(to_, reward);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function frequency() public view returns (uint256) {\n        return uint256(PRICE.observationFrequency());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IHeart\n    function resetBeat() external onlyRole(\"heart_admin\") {\n        lastBeat = block.timestamp - frequency();\n    }\n\n    /// @inheritdoc IHeart\n    function toggleBeat() external onlyRole(\"heart_admin\") {\n        active = !active;\n    }\n\n    /// @inheritdoc IHeart\n    function setRewardTokenAndAmount(ERC20 token_, uint256 reward_)\n        external\n        onlyRole(\"heart_admin\")\n    {\n        rewardToken = token_;\n        reward = reward_;\n        emit RewardUpdated(token_, reward_);\n    }\n\n    /// @inheritdoc IHeart\n    function withdrawUnspentRewards(ERC20 token_) external onlyRole(\"heart_admin\") {\n        token_.safeTransfer(msg.sender, token_.balanceOf(address(this)));\n    }\n}"
    }
  ]
}