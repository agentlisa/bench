{
  "Title": "H-1: AuraSpell#openPositionFarm fails to return all rewards to user",
  "Content": "# Issue H-1: AuraSpell#openPositionFarm fails to return all rewards to user \n\nSource: https://github.com/sherlock-audit/2023-05-blueberry-judging/issues/29 \n\n## Found by \n0x52, nobody2018\n## Summary\n\nWhen a user adds to an existing position on AuraSpell, the contract burns their current position and remints them a new one. The issues is that WAuraPool will send all reward tokens to the contract but it only sends Aura back to the user, causing all other rewards to be lost.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/wrapper/WAuraPools.sol#L256-L261\n\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n        }\n\nInside WAuraPools#burn reward tokens are sent to the user.\n\nhttps://github.com/sherlock-audit/2023-05-blueberry/blob/main/blueberry-core/contracts/spell/AuraSpell.sol#L130-L140\n\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wAuraPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wAuraPools.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(AURA);\n        }\n\nWe see above that the contract only refunds Aura to the user causing all other extra reward tokens received by the contract to be lost to the user.\n\n## Impact\n\nUser will lose all extra reward tokens from their original position\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWAuraPool returns the reward tokens it sends. Use this list to refund all tokens to the user\n\n\n\n## Discussion\n\n**sleepriverfish**\n\nEscalate for 10 USDC.\nThe issue was  excluded from #Blueberry Update, it appears to have been rewarded in #Blueberry Update 2.\nhttps://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42\n\n**sherlock-admin**\n\n > Escalate for 10 USDC.\n> The issue was  excluded from #Blueberry Update, it appears to have been rewarded in #Blueberry Update 2.\n> https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**securitygrid**\n\nEscalate for 10 USDC\nvalid H. Nobody escalated [it](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42) \n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> valid H. Nobody escalated [it](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42) \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IAm0x52**\n\nAgreed with second escalation\n\n**sleepriverfish**\n\nSo, the issue https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/42 considered invalid? I believe it should be categorized and rewarded in some way.\n\n**hrishibhat**\n\nEscalation rejected\n\nValid high\nThe issue mentioned above has been resolved accordingly in the respective contest. \n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Valid high\n> The issue mentioned above has been resolved accordingly in the respective contest. \n\n    This issue's escalations have been rejected!\n\n    Watsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/77",
  "Code": [
    {
      "filename": "blueberry-core/contracts/wrapper/WAuraPools.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/aura/IAuraRewarder.sol\";\n\n/**\n * @title WAuraPools\n * @author BlueberryProtocol\n * @notice Wrapped Aura Pools is the wrapper of LP positions\n * @dev Leveraged LP Tokens will be wrapped here and be held in BlueberryBank \n *      and do not generate yields. LP Tokens are identified by tokenIds \n *      encoded from lp token address.\n */\ncontract WAuraPools is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    EnsureApprove,\n    IERC20Wrapper,\n    IWAuraPools\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev Address to Aura Pools contract\n    IAuraPools public auraPools;\n    /// @dev Address to AURA token\n    IERC20Upgradeable public AURA;\n    /// @dev Mapping from gauge id to accBalPerShare\n    mapping(uint256 => uint256) public accCrvPerShares;\n    /// @dev Mapping from token id to accExtPerShare\n    mapping(uint256 => uint256[]) public accExtPerShare;\n\n    function initialize(\n        address aura_,\n        address auraPools_\n    ) external initializer {\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WAuraPools\");\n        AURA = IERC20Upgradeable(aura_);\n        auraPools = IAuraPools(auraPools_);\n    }\n\n    /// @notice Encode pid, auraPerShare to ERC1155 token id\n    /// @param pid Pool id (16-bit)\n    /// @param auraPerShare AURA amount per share, multiplied by 1e18 (240-bit)\n    function encodeId(\n        uint256 pid,\n        uint256 auraPerShare\n    ) public pure returns (uint256 id) {\n        if (pid >= (1 << 16)) revert Errors.BAD_PID(pid);\n        if (auraPerShare >= (1 << 240))\n            revert Errors.BAD_REWARD_PER_SHARE(auraPerShare);\n        return (pid << 240) | auraPerShare;\n    }\n\n    /// @notice Decode ERC1155 token id to pid, auraPerShare\n    /// @param id Token id\n    function decodeId(\n        uint256 id\n    ) public pure returns (uint256 gid, uint256 auraPerShare) {\n        gid = id >> 240; // First 16 bits\n        auraPerShare = id & ((1 << 240) - 1); // Last 240 bits\n    }\n\n    /// @notice Get underlying ERC20 token of ERC1155 given token id\n    /// @param id Token id\n    function getUnderlyingToken(\n        uint256 id\n    ) external view override returns (address uToken) {\n        (uint256 pid, ) = decodeId(id);\n        (uToken, , , , , ) = getPoolInfoFromPoolId(pid);\n    }\n\n    function getVault(address bpt) public view returns (IBalancerVault) {\n        return IBalancerVault(IBalancerPool(bpt).getVault());\n    }\n\n    function getPoolTokens(\n        address bpt\n    )\n        external\n        view\n        returns (\n            address[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangedBlock\n        )\n    {\n        return getVault(bpt).getPoolTokens(IBalancerPool(bpt).getPoolId());\n    }\n\n    function getPool(\n        address bpt,\n        uint256 pid\n    ) external view returns (address, uint256) {\n        return getVault(bpt).getPool(bytes32(pid));\n    }\n\n    function getPoolInfoFromPoolId(\n        uint256 pid\n    )\n        public\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        )\n    {\n        return auraPools.poolInfo(pid);\n    }\n\n    function _getPendingReward(\n        uint stRewardPerShare,\n        address rewarder,\n        uint amount,\n        uint lpDecimals\n    ) internal view returns (uint rewards) {\n        uint256 enRewardPerShare = IAuraRewarder(rewarder).rewardPerToken();\n        uint256 share = enRewardPerShare > stRewardPerShare\n            ? enRewardPerShare - stRewardPerShare\n            : 0;\n        rewards = (share * amount) / (10 ** lpDecimals);\n    }\n\n    /// @notice Return pending rewards from the farming pool\n    /// @dev Reward tokens can be multiple tokens\n    /// @param tokenId Token Id\n    /// @param amount amount of share\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {\n        (uint256 pid, uint256 stCrvPerShare) = decodeId(tokenId);\n        (address lpToken, , , address crvRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        uint256 lpDecimals = IERC20MetadataUpgradeable(lpToken).decimals();\n        uint extraRewardsCount = IAuraRewarder(crvRewarder)\n            .extraRewardsLength();\n        tokens = new address[](extraRewardsCount + 1);\n        rewards = new uint256[](extraRewardsCount + 1);\n\n        tokens[0] = IAuraRewarder(crvRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            crvRewarder,\n            amount,\n            lpDecimals\n        );\n\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address rewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n            uint256 stRewardPerShare = accExtPerShare[tokenId][i];\n            tokens[i + 1] = IAuraRewarder(rewarder).rewardToken();\n            rewards[i + 1] = _getPendingReward(\n                stRewardPerShare,\n                rewarder,\n                amount,\n                lpDecimals\n            );\n        }\n    }\n\n    /// @notice Mint ERC1155 token for the given LP token\n    /// @param pid Aura Pool id\n    /// @param amount Token amount to wrap\n    function mint(\n        uint256 pid,\n        uint256 amount\n    ) external nonReentrant returns (uint256 id) {\n        (address lpToken, , , address crvRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        _ensureApprove(lpToken, address(auraPools), amount);\n        auraPools.deposit(pid, amount, true);\n\n        uint256 crvRewardPerToken = IAuraRewarder(crvRewarder).rewardPerToken();\n        id = encodeId(pid, crvRewardPerToken);\n        _mint(msg.sender, id, amount, \"\");\n        // Store extra rewards info\n        uint extraRewardsCount = IAuraRewarder(crvRewarder)\n            .extraRewardsLength();\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address extraRewarder = IAuraRewarder(crvRewarder).extraRewards(i);\n            uint rewardPerToken = IAuraRewarder(extraRewarder).rewardPerToken();\n            accExtPerShare[id].push(rewardPerToken);\n        }\n    }\n\n    /// @notice Burn ERC1155 token to redeem ERC20 token back\n    /// @param id Token id to burn\n    /// @param amount Token amount to burn\n    /// @return rewardTokens Reward tokens rewards harvested\n    function burn(\n        uint256 id,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        returns (address[] memory rewardTokens, uint256[] memory rewards)\n    {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, ) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        (address lpToken, , , address balRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        // Claim Rewards\n        IAuraRewarder(balRewarder).withdraw(amount, true);\n        // Withdraw LP\n        auraPools.withdraw(pid, amount);\n\n        // Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        // Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n        }\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/spell/AuraSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Router02.sol\";\n\n/**\n * @title AuraSpell\n * @author BlueberryProtocol\n * @notice AuraSpell is the factory contract that\n * defines how Blueberry Protocol interacts with Aura pools\n */\ncontract AuraSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev Address to Wrapped Aura Pools\n    IWAuraPools public wAuraPools;\n    /// @dev address of CurveOracle\n    ICurveOracle public crvOracle;\n    /// @dev address of AURA token\n    address public AURA;\n\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wAuraPools_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wAuraPools_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        wAuraPools = IWAuraPools(wAuraPools_);\n        AURA = address(wAuraPools.AURA());\n        IWAuraPools(wAuraPools_).setApprovalForAll(address(bank_), true);\n    }\n\n    /**\n     * @notice Add strategy to the spell\n     * @param bpt Address of Balaner Pool Token\n     * @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n     */\n    function addStrategy(address bpt, uint256 maxPosSize) external onlyOwner {\n        _addStrategy(bpt, maxPosSize);\n    }\n\n    /**\n     * @notice Add liquidity to Balancer pool, with staking to Aura\n     */\n    function openPositionFarm(\n        OpenPosParam calldata param\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        (address lpToken, ) = wAuraPools.getPool(\n            strategy.vault,\n            param.farmingPoolId\n        );\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        // 3. Add liquidity on Balancer, get BPT\n        {\n            IBalancerVault vault = wAuraPools.getVault(lpToken);\n            _ensureApprove(param.borrowToken, address(vault), borrowBalance);\n\n            (address[] memory tokens, uint256[] memory balances, ) = wAuraPools\n                .getPoolTokens(lpToken);\n            uint[] memory maxAmountsIn = new uint[](2);\n            maxAmountsIn[0] = IERC20(tokens[0]).balanceOf(address(this));\n            maxAmountsIn[1] = IERC20(tokens[1]).balanceOf(address(this));\n\n            uint totalLPSupply = IBalancerPool(lpToken).totalSupply();\n            // compute in reverse order of how Balancer's `joinPool` computes tokenAmountIn\n            uint poolAmountFromA = (maxAmountsIn[0] * totalLPSupply) /\n                balances[0];\n            uint poolAmountFromB = (maxAmountsIn[1] * totalLPSupply) /\n                balances[1];\n            uint poolAmountOut = poolAmountFromA > poolAmountFromB\n                ? poolAmountFromB\n                : poolAmountFromA;\n\n            bytes32 poolId = bytes32(param.farmingPoolId);\n            if (poolAmountOut > 0) {\n                vault.joinPool(\n                    poolId,\n                    address(this),\n                    address(this),\n                    IBalancerVault.JoinPoolRequest(\n                        tokens,\n                        maxAmountsIn,\n                        \"\",\n                        false\n                    )\n                );\n            }\n        }\n\n        // 4. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        // 5. Validate Max Pos Size\n        _validateMaxPosSize(param.strategyId);\n\n        // 6. Take out existing collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wAuraPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wAuraPools.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(AURA);\n        }\n\n        // 7. Deposit on Aura Pool, Put wrapped collateral tokens on Blueberry Bank\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wAuraPools), lpAmount);\n        uint256 id = wAuraPools.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wAuraPools), id, lpAmount);\n    }\n\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        IUniswapV2Router02 swapRouter,\n        address[][] calldata swapPath\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address lpToken = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collToken != address(wAuraPools))\n            revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n        if (wAuraPools.getUnderlyingToken(pos.collId) != lpToken)\n            revert Errors.INCORRECT_UNDERLYING(lpToken);\n\n        // 1. Take out collateral - Burn wrapped tokens, receive BPT tokens and harvest AURA\n        bank.takeCollateral(param.amountPosRemove);\n        (address[] memory rewardTokens, ) = wAuraPools.burn(\n            pos.collId,\n            param.amountPosRemove\n        );\n\n        {\n            // 2. Calculate actual amount to remove\n            uint256 amountPosRemove = param.amountPosRemove;\n            if (amountPosRemove == type(uint256).max) {\n                amountPosRemove = IERC20Upgradeable(lpToken).balanceOf(\n                    address(this)\n                );\n            }\n\n            // 3. Remove liquidity\n            (address[] memory tokens, , ) = wAuraPools.getPoolTokens(lpToken);\n            uint[] memory minAmountsOut = new uint[](2);\n            wAuraPools.getVault(lpToken).exitPool(\n                IBalancerPool(lpToken).getPoolId(),\n                address(this),\n                address(this),\n                IBalancerVault.ExitPoolRequest(tokens, minAmountsOut, \"\", false)\n            );\n        }\n\n        // 4. Swap rewards tokens to debt token\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 rewards = _doCutRewardsFee(rewardTokens[i]);\n            _ensureApprove(rewardTokens[i], address(swapRouter), rewards);\n            swapRouter.swapExactTokensForTokens(\n                rewards,\n                0,\n                swapPath[i],\n                address(this),\n                type(uint256).max\n            );\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 6. Repay\n        {\n            // Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        // 7. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n        _doRefund(AURA);\n    }\n}"
    }
  ]
}