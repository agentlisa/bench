{
  "Title": "Event is probably missing",
  "Content": "##### Description:\nAt the line https://github.com/yearn/yearn-vaults/tree/e390c2a6b2ba6e2ecc8f3a72a1ea4adfabd17544/contracts/BaseWrapper.sol#L50 in method `setRegistry()` should probably emit an event `SetRegistry`.\nAt the line https://github.com/yearn/yearn-vaults/tree/e390c2a6b2ba6e2ecc8f3a72a1ea4adfabd17544/contracts/BaseWrapper.sol#L104 in method `_deposit()` should probably emit an event `Deposit`.\nAt the line https://github.com/yearn/yearn-vaults/tree/e390c2a6b2ba6e2ecc8f3a72a1ea4adfabd17544/contracts/BaseWrapper.sol#L140 in method `_withdraw()` should probably emit an event `Withdraw`.\nAt the line https://github.com/yearn/yearn-vaults/tree/e390c2a6b2ba6e2ecc8f3a72a1ea4adfabd17544/contracts/BaseWrapper.sol#L218 in method `_migrate()` should probably emit an event `Migrate`.\n\nAt the line https://github.com/yearn/yearn-vaults/tree/e390c2a6b2ba6e2ecc8f3a72a1ea4adfabd17544/contracts/Registry.vy#L304 in method `setBanksy()` should probably emit an event `SetBanksy`.\n\nAt the line https://github.com/yearn/yearn-vaults/blob/e390c2a6b2ba6e2ecc8f3a72a1ea4adfabd17544/contracts/yToken.sol#L171 in method `depositETH()` should probably emit an event `DepositETH`.\nAt the line https://github.com/yearn/yearn-vaults/blob/e390c2a6b2ba6e2ecc8f3a72a1ea4adfabd17544/contracts/yToken.sol#L180 in method `withdrawETH` should probably emit an event `WithdrawETH`.\n\n\n##### Recommendation\nIt is recommended to create new events.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/yToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport {VaultAPI, BaseWrapper} from \"./BaseWrapper.sol\";\n\ncontract yToken is IERC20, BaseWrapper {\n    using SafeMath for uint256;\n\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    constructor(address _token, address _registry) public BaseWrapper(_token, _registry) {}\n\n    function name() external view returns (string memory) {\n        VaultAPI _bestVault = bestVault();\n        return _bestVault.name();\n    }\n\n    function symbol() external view returns (string memory) {\n        VaultAPI _bestVault = bestVault();\n        return _bestVault.symbol();\n    }\n\n    function decimals() external view returns (uint256) {\n        VaultAPI _bestVault = bestVault();\n        return _bestVault.decimals();\n    }\n\n    function totalSupply() external override view returns (uint256 total) {\n        return totalAssets();\n    }\n\n    function balanceOf(address account) external override view returns (uint256 balance) {\n        return totalVaultBalance(account);\n    }\n\n    function _transfer(\n        address sender,\n        address receiver,\n        uint256 amount\n    ) internal {\n        require(receiver != address(0), \"ERC20: transfer to the zero address\");\n        require(amount == _withdraw(sender, receiver, amount, true)); // `true` means use `bestVault`\n        emit Transfer(sender, receiver, amount);\n    }\n\n    function transfer(address receiver, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, receiver, amount);\n        return true;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address receiver,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, receiver, amount);\n        _approve(sender, msg.sender, allowance[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    function deposit(uint256 amount) external returns (uint256) {\n        return _deposit(msg.sender, msg.sender, amount, true); // `true` = pull from sender\n    }\n\n    function withdraw(uint256 amount) external returns (uint256) {\n        return _withdraw(msg.sender, msg.sender, amount, true); // `true` = withdraw from `bestVault`\n    }\n\n    function _permitAll(\n        address user,\n        VaultAPI[] calldata vaults,\n        bytes[] calldata signatures\n    ) internal {\n        require(vaults.length == signatures.length);\n        for (uint256 i = 0; i < vaults.length; i++) {\n            require(vaults[i].permit(user, address(this), uint256(-1), 0, signatures[i]));\n        }\n    }\n\n    function permitAll(VaultAPI[] calldata vaults, bytes[] calldata signatures) public {\n        _permitAll(msg.sender, vaults, signatures);\n    }\n\n    function migrate() external returns (uint256) {\n        return _migrate(msg.sender);\n    }\n\n    function migrate(uint256 amount) external returns (uint256) {\n        return _migrate(msg.sender, amount);\n    }\n\n    function migrate(uint256 amount, uint256 maxMigrationLoss) external returns (uint256) {\n        return _migrate(msg.sender, amount, maxMigrationLoss);\n    }\n\n    function migrate(VaultAPI[] calldata vaults, bytes[] calldata signatures) external returns (uint256) {\n        _permitAll(msg.sender, vaults, signatures);\n        return _migrate(msg.sender);\n    }\n\n    function migrate(\n        VaultAPI[] calldata vaults,\n        bytes[] calldata signatures,\n        uint256 amount\n    ) external returns (uint256) {\n        _permitAll(msg.sender, vaults, signatures);\n        return _migrate(msg.sender, amount);\n    }\n\n    function migrate(\n        VaultAPI[] calldata vaults,\n        bytes[] calldata signatures,\n        address user,\n        uint256 amount\n    ) external returns (uint256) {\n        _permitAll(user, vaults, signatures);\n        return _migrate(user, amount);\n    }\n\n    function revokeAll(VaultAPI[] calldata vaults, bytes[] calldata signatures) external {\n        require(vaults.length == signatures.length);\n        for (uint256 i = 0; i < vaults.length; i++) {\n            require(vaults[i].permit(msg.sender, address(this), 0, 0, signatures[i]));\n        }\n    }\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\ncontract yWETH is yToken {\n    using Address for address payable;\n\n    constructor(address _weth, address _registry) public yToken(_weth, _registry) {}\n\n    function depositETH() public payable returns (uint256) {\n        uint256 amount = msg.value;\n        // NOTE: `BaseWrapper.token` is WETH\n        IWETH(address(token)).deposit{value: amount}();\n        // NOTE: Deposit handles approvals\n        // NOTE: Need to use different method to deposit than `yToken`\n        return _deposit(address(this), msg.sender, amount, false); // `false` = pull from `this`\n    }\n\n    function withdrawETH(uint256 amount) external returns (uint256 withdrawn) {\n        // NOTE: Need to use different method to withdraw than `yToken`\n        withdrawn = _withdraw(msg.sender, address(this), amount, true); // `true` = withdraw from `bestVault`\n        // NOTE: `BaseWrapper.token` is WETH\n        IWETH(address(token)).withdraw(withdrawn);\n        // NOTE: Any unintentionally\n        msg.sender.sendValue(address(this).balance);\n    }\n\n    receive() external payable {\n        if (msg.sender != address(token)) {\n            depositETH();\n        } // else: WETH is sending us back ETH, so don't do anything (to avoid recursion)\n    }\n}"
    },
    {
      "filename": "contracts/yToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport {VaultAPI, BaseWrapper} from \"./BaseWrapper.sol\";\n\ncontract yToken is IERC20, BaseWrapper {\n    using SafeMath for uint256;\n\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    constructor(address _token, address _registry) public BaseWrapper(_token, _registry) {}\n\n    function name() external view returns (string memory) {\n        VaultAPI _bestVault = bestVault();\n        return _bestVault.name();\n    }\n\n    function symbol() external view returns (string memory) {\n        VaultAPI _bestVault = bestVault();\n        return _bestVault.symbol();\n    }\n\n    function decimals() external view returns (uint256) {\n        VaultAPI _bestVault = bestVault();\n        return _bestVault.decimals();\n    }\n\n    function totalSupply() external override view returns (uint256 total) {\n        return totalAssets();\n    }\n\n    function balanceOf(address account) external override view returns (uint256 balance) {\n        return totalVaultBalance(account);\n    }\n\n    function _transfer(\n        address sender,\n        address receiver,\n        uint256 amount\n    ) internal {\n        require(receiver != address(0), \"ERC20: transfer to the zero address\");\n        require(amount == _withdraw(sender, receiver, amount, true)); // `true` means use `bestVault`\n        emit Transfer(sender, receiver, amount);\n    }\n\n    function transfer(address receiver, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, receiver, amount);\n        return true;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address receiver,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, receiver, amount);\n        _approve(sender, msg.sender, allowance[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    function deposit(uint256 amount) external returns (uint256) {\n        return _deposit(msg.sender, msg.sender, amount, true); // `true` = pull from sender\n    }\n\n    function withdraw(uint256 amount) external returns (uint256) {\n        return _withdraw(msg.sender, msg.sender, amount, true); // `true` = withdraw from `bestVault`\n    }\n\n    function _permitAll(\n        address user,\n        VaultAPI[] calldata vaults,\n        bytes[] calldata signatures\n    ) internal {\n        require(vaults.length == signatures.length);\n        for (uint256 i = 0; i < vaults.length; i++) {\n            require(vaults[i].permit(user, address(this), uint256(-1), 0, signatures[i]));\n        }\n    }\n\n    function permitAll(VaultAPI[] calldata vaults, bytes[] calldata signatures) public {\n        _permitAll(msg.sender, vaults, signatures);\n    }\n\n    function migrate() external returns (uint256) {\n        return _migrate(msg.sender);\n    }\n\n    function migrate(uint256 amount) external returns (uint256) {\n        return _migrate(msg.sender, amount);\n    }\n\n    function migrate(uint256 amount, uint256 maxMigrationLoss) external returns (uint256) {\n        return _migrate(msg.sender, amount, maxMigrationLoss);\n    }\n\n    function migrate(VaultAPI[] calldata vaults, bytes[] calldata signatures) external returns (uint256) {\n        _permitAll(msg.sender, vaults, signatures);\n        return _migrate(msg.sender);\n    }\n\n    function migrate(\n        VaultAPI[] calldata vaults,\n        bytes[] calldata signatures,\n        uint256 amount\n    ) external returns (uint256) {\n        _permitAll(msg.sender, vaults, signatures);\n        return _migrate(msg.sender, amount);\n    }\n\n    function migrate(\n        VaultAPI[] calldata vaults,\n        bytes[] calldata signatures,\n        address user,\n        uint256 amount\n    ) external returns (uint256) {\n        _permitAll(user, vaults, signatures);\n        return _migrate(user, amount);\n    }\n\n    function revokeAll(VaultAPI[] calldata vaults, bytes[] calldata signatures) external {\n        require(vaults.length == signatures.length);\n        for (uint256 i = 0; i < vaults.length; i++) {\n            require(vaults[i].permit(msg.sender, address(this), 0, 0, signatures[i]));\n        }\n    }\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\ncontract yWETH is yToken {\n    using Address for address payable;\n\n    constructor(address _weth, address _registry) public yToken(_weth, _registry) {}\n\n    function depositETH() public payable returns (uint256) {\n        uint256 amount = msg.value;\n        // NOTE: `BaseWrapper.token` is WETH\n        IWETH(address(token)).deposit{value: amount}();\n        // NOTE: Deposit handles approvals\n        // NOTE: Need to use different method to deposit than `yToken`\n        return _deposit(address(this), msg.sender, amount, false); // `false` = pull from `this`\n    }\n\n    function withdrawETH(uint256 amount) external returns (uint256 withdrawn) {\n        // NOTE: Need to use different method to withdraw than `yToken`\n        withdrawn = _withdraw(msg.sender, address(this), amount, true); // `true` = withdraw from `bestVault`\n        // NOTE: `BaseWrapper.token` is WETH\n        IWETH(address(token)).withdraw(withdrawn);\n        // NOTE: Any unintentionally\n        msg.sender.sendValue(address(this).balance);\n    }\n\n    receive() external payable {\n        if (msg.sender != address(token)) {\n            depositETH();\n        } // else: WETH is sending us back ETH, so don't do anything (to avoid recursion)\n    }\n}"
    }
  ]
}