{
  "Title": "M-5: GMX Reward Router's claimForAccount() can be abused to incorrectly add WETH to tokensIn",
  "Content": "# Issue M-5: GMX Reward Router's claimForAccount() can be abused to incorrectly add WETH to tokensIn \n\nSource: https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/10 \n\n## Found by \nobront\n\n## Summary\n\nWhen `claimFees()` is called, the Controller automatically adds WETH to the user's account. However, in the case where no fees have accrued yet, there will not be WETH withdrawn. In this case, the user will have WETH added as an asset in their account, while they won't actually have any WETH holdings.\n\n## Vulnerability Detail\n\nWhen a user calls the GMX Reward Router's `claimFees()` function, the RewardRouterController confirms the validity of this call in the `canCallClaimFees()` function:\n\n```solidity\nfunction canCallClaimFees()\n    internal\n    view\n    returns (bool, address[] memory, address[] memory)\n{\n    return (true, WETH, new address[](0));\n}\n```\n\nThis function assumes that any user calling `claimFees()` will always receive `WETH`. However, this is only the case if their stake has been accruing. \n\nImagine the following two actions are taken in the same block:\n- Deposit assets into GMX staking\n- Call claimFees()\n\nThe result will be that `claimFees()` returns no `WETH`, but `WETH` is added to the account's asset list.\n\nThe same is true if a user performs the following three actions:\n- Call claimFees()\n- Withdraw all ETH from the WETH contract\n- Call claimFees() again\n\n## Impact\n\nA user can force their account into a state where it has `WETH` on the asset list, but doesn't actually hold any `WETH`.\n\nThis specific Impact was judged as Medium for multiple issues in the previous contest:\n- https://github.com/sherlock-audit/2022-11-sentiment-judging/issues/20\n- https://github.com/sherlock-audit/2022-11-sentiment-judging/issues/7\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-sentiment/blob/main/controller-55/src/gmx/RewardRouterController.sol#L54-L60\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe best way to solve this is actually not at the Controller level. It's to solve the issue of fake assets being added once and not have to worry about it on the Controller level in the future.\n\nThis can be accomplished in `AccountManager.sol#_updateTokensIn()`. It should be updated to only add the token to the assets list if it has a positive balance, as follows:\n\n```diff\nfunction _updateTokensIn(address account, address[] memory tokensIn)\n    internal\n{\n    uint tokensInLen = tokensIn.length;\n    for(uint i; i < tokensInLen; ++i) {\n-        if (IAccount(account).hasAsset(tokensIn[i]) == false)\n+        if (IAccount(account).hasAsset(tokensIn[i]) == false && IERC20(token).balanceOf(account) > 0)\n            IAccount(account).addAsset(tokensIn[i]);\n    }\n}\n```\n\nHowever, `_updateTokensIn()` is currently called before the function is executed in `exec()`, so that would need to be changed as well:\n\n```diff\nfunction exec(address account, address target, uint amt, bytes calldata data) external onlyOwner(account) {\n    bool isAllowed;\n    address[] memory tokensIn;\n    address[] memory tokensOut;\n    (isAllowed, tokensIn, tokensOut) = controller.canCall(target, (amt > 0), data);\n    if (!isAllowed) revert Errors.FunctionCallRestricted();\n-    _updateTokensIn(account, tokensIn);\n    (bool success,) = IAccount(account).exec(target, amt, data);\n    if (!success)\n        revert Errors.AccountInteractionFailure(account, target, amt, data);\n+    _updateTokensIn(account, tokensIn);\n    _updateTokensOut(account, tokensOut);\n    if (!riskEngine.isAccountHealthy(account))\n        revert Errors.RiskThresholdBreached();\n}\n```\n\nWhile this fix does require changing a core contract, it would negate the need to worry about edge cases causing incorrect accounting of tokens on any future integrations, which I think is a worthwhile trade off.\n\nThis accuracy is especially important as Sentiment becomes better known and integrated into the Arbitrum ecosystem. While I know that having additional assets doesn't cause internal problems at present, it is hard to predict what issues inaccurate data will cause in the future. Seeing that Plutus is checking Sentiment contracts for their whitelist drove this point home — we need to ensure the data stays accurate, even in edge cases, or else there will be trickle down problems we can't currently predict.\n\n## Discussion\n\n**bahurum**\n\nEscalate for 50 USDC.\nI believe that this issue is Low severity.\nI filed a list of issues with same impact as a Low severity submission (https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/26).\nThis issue will never lead to loss or lockup of funds. So by Sherlock judging criteria this is Low severity. \nOtherwise, please provide a scenario where this issue leads to a loss or lockup of funds.\nThe watson mentions some similiar issues judged as Medium in previous contests. I didn't see those before or I would have escalated them as well for the same reason.\n\n**sherlock-admin**\n\n > Escalate for 50 USDC.\n> I believe that this issue is Low severity.\n> I filed a list of issues with same impact as a Low severity submission (https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/26).\n> This issue will never lead to loss or lockup of funds. So by Sherlock judging criteria this is Low severity. \n> Otherwise, please provide a scenario where this issue leads to a loss or lockup of funds.\n> The watson mentions some similiar issues judged as Medium in previous contests. I didn't see those before or I would have escalated them as well for the same reason.\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**zobront**\n\nBaharum is correct that within the protocol, as it stands, there are no risks of an account having an incorrect Assets list. \n\nBut Sentiment is becoming increasingly incorporated into the Arbitrum DeFi ecosystem. Sentiment purports that their account Asset lists are accurate and they go to extreme lengths with the Controller setup (and take on additional security risk) to track tokens in and out to keep it accurate. If it didn’t matter, they could just use the list of all allowed tokens when taking operations on an account.\n\nAs I stated in my Recommendations:\n\n> [W]e need to ensure the data stays accurate, even in edge cases, or else there will be trickle down problems we can't currently predict.\n\nI believe this is a valid Medium, and is the kind of thing that Sentiment needs to understand when releasing new Controllers with the explicit goal of keeping Asset lists accurate as users interact with a given protocol.\n\n**bahurum**\n\nThank you for your reply. \n\nWhile I agree that data accuracy is desired, I'd like to insist that IMO the impact of this issue is not within Sherlock's definition of Medium severity issue, since there is no path to loss of funds, unless the contrary is shown. \n\nFor integration, if an asset with zero balance is in an account's asset list, I don't see that as a problem since an external protocol can check if the balance is positive if a zero balance ever causes issues. \n\nIf Sherlock thinks differently then I encourage them to reconsider my Low severity issue #26 along with your 2 issues #10 and #5 as a Medium.\n\n**zobront**\n\nI agree that your Low should be Medium.\n\n**hrishibhat**\n\nEscalation accepted. \n\nConsidering issue #26 as a valid medium in this case\n\n**sherlock-admin**\n\n> Escalation accepted. \n> \n> Considering issue #26 as a valid medium in this case\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/37",
  "Code": [
    {
      "filename": "controller-55/src/gmx/RewardRouterController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IController} from \"../core/IController.sol\";\n\n/**\n    @title Reward Router Controller for claiming and compounding rewards\n    @dev arbi:0xA906F338CB21815cBc4Bc87ace9e68c87eF8d8F1\n*/\ncontract RewardRouterController is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                              STORAGE VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice compound()\n    bytes4 constant compound = 0xf69e2046;\n\n    /// @notice claimFees()\n    bytes4 constant claimFees = 0xd294f093;\n\n    /// @notice WETH\n    address[] WETH;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    constructor(address _WETH) {\n        WETH.push(_WETH);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function canCall(address, bool, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == compound) return canCallCompound();\n        if (sig == claimFees) return canCallClaimFees();\n\n        return (false, new address[](0), new address[](0));\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function canCallClaimFees()\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        return (true, WETH, new address[](0));\n    }\n\n    function canCallCompound()\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        return (true, WETH, new address[](0));\n    }\n}"
    }
  ]
}