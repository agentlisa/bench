{
  "Title": "Gas saving in price calculation",
  "Content": "##### Description\nIn the function for calculating price, you can save gas when calculating the variables `S_` and` c` in case if `i=1`, `j=0`, `N_COINS=2`:\nhttps://github.com/lidofinance/curve-merkle-oracle/blob/ae093b308999a564ed3f23d52c6c5dce946dbfa7/contracts/StableSwapPriceHelper.vy#L63-L72\n\n##### Recommendation\nWe recommendto calculate variables using following formula:\n```vyper=\nS_ = x\nc = D * D / (x * N_COINS)\n```\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/StableSwapPriceHelper.vy",
      "content": "# @version 0.2.8\n\n# The following code has been copied with minimal modifications from\n# https://github.com/curvefi/curve-contract/blob/3fa3b6c/contracts/pools/steth/StableSwapSTETH.vy\n\n\nN_COINS: constant(int128) = 2\nFEE_DENOMINATOR: constant(uint256) = 10 ** 10\nA_PRECISION: constant(uint256) = 100\n\n\n@pure\n@internal\ndef get_D(xp: uint256[N_COINS], amp: uint256) -> uint256:\n    S: uint256 = 0\n    Dprev: uint256 = 0\n\n    for _x in xp:\n        S += _x\n    if S == 0:\n        return 0\n\n    D: uint256 = S\n    Ann: uint256 = amp * N_COINS\n    for _i in range(255):\n        D_P: uint256 = D\n        for _x in xp:\n            D_P = D_P * D / (_x * N_COINS + 1)  # +1 is to prevent /0\n        Dprev = D\n        D = (Ann * S / A_PRECISION + D_P * N_COINS) * D / ((Ann - A_PRECISION) * D / A_PRECISION + (N_COINS + 1) * D_P)\n        # Equality with the precision of 1\n        if D > Dprev:\n            if D - Dprev <= 1:\n                return D\n        else:\n            if Dprev - D <= 1:\n                return D\n    # convergence typically occurs in 4 rounds or less, this should be unreachable!\n    # if it does happen the pool is borked and LPs can withdraw via `remove_liquidity`\n    raise\n\n\n@view\n@internal\ndef get_y(i: int128, j: int128, x: uint256, xp: uint256[N_COINS], amp: uint256) -> uint256:\n    # x in the input is converted to the same price/precision\n\n    assert i != j       # dev: same coin\n    assert j >= 0       # dev: j below zero\n    assert j < N_COINS  # dev: j above N_COINS\n\n    # should be unreachable, but good for safety\n    assert i >= 0\n    assert i < N_COINS\n\n    D: uint256 = self.get_D(xp, amp)\n    Ann: uint256 = amp * N_COINS\n    c: uint256 = D\n    S_: uint256 = 0\n    _x: uint256 = 0\n    y_prev: uint256 = 0\n\n    for _i in range(N_COINS):\n        if _i == i:\n            _x = x\n        elif _i != j:\n            _x = xp[_i]\n        else:\n            continue\n        S_ += _x\n        c = c * D / (_x * N_COINS)\n    c = c * D * A_PRECISION / (Ann * N_COINS)\n    b: uint256 = S_ + D * A_PRECISION / Ann  # - D\n    y: uint256 = D\n    for _i in range(255):\n        y_prev = y\n        y = (y*y + c) / (2 * y + b - D)\n        # Equality with the precision of 1\n        if y > y_prev:\n            if y - y_prev <= 1:\n                return y\n        else:\n            if y_prev - y <= 1:\n                return y\n    raise\n\n\n@view\n@external\ndef get_dy(i: int128, j: int128, dx: uint256, xp: uint256[N_COINS], A: uint256, fee: uint256) -> uint256:\n    x: uint256 = xp[i] + dx\n    y: uint256 = self.get_y(i, j, x, xp, A)\n    dy: uint256 = xp[j] - y - 1\n    return dy - fee * dy / FEE_DENOMINATOR"
    }
  ]
}