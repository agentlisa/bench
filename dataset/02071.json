{
  "Title": "H-5: ADL operations do not have any slippage protection",
  "Content": "# Issue H-5: ADL operations do not have any slippage protection \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/143 \n\n## Found by \nBreeje, IllIllI\n\n## Summary\n\nADL operations do not have any slippage protection\n\n\n## Vulnerability Detail\n\nADL orders, generated by the ADL keeper, are forced to allow unlimited slippage, which means the user may get a lot less than they deserve.\n\n\n## Impact\n\nThere may be a large price impact associated with the ADL order, causing the user's large gain to become a loss, if the price impact factor is large enough, which may be the case if the price suddenly spikes up a lot, and there are many ADL operations after a lot of users exit their positions.\n\n\n## Code Snippet\n\nAny price is allowed, and the minimum output amount is set to zero:\n```solidity\n// File: gmx-synthetics/contracts/adl/AdlUtils.sol : AdlUtils.createAdlOrder()   #1\n\n141    \n142            Order.Numbers memory numbers = Order.Numbers(\n143                Order.OrderType.MarketDecrease, // orderType\n144                Order.DecreasePositionSwapType.NoSwap, // decreasePositionSwapType\n145                params.sizeDeltaUsd, // sizeDeltaUsd\n146                0, // initialCollateralDeltaAmount\n147                0, // triggerPrice\n148 @>             position.isLong() ? 0 : type(uint256).max, // acceptablePrice\n149                0, // executionFee\n150                0, // callbackGasLimit\n151 @>             0, // minOutputAmount\n152                params.updatedAtBlock // updatedAtBlock\n153:           );\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/adl/AdlUtils.sol#L141-L153\n\nThe only checks after the ADL order completes are related to [global](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/AdlHandler.sol#L150-L160) metrics, not position-specific ones.\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nIntroduce a `MAX_POSITION_IMPACT_FACTOR_FOR_ADL`, similar to `MAX_POSITION_IMPACT_FACTOR_FOR_LIQUIDATIONS`\n\n\n\n\n## Discussion\n\n**xvi10**\n\nThe maximum price impact is capped by the MAX_POSITION_IMPACT_FACTOR value\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/adl/AdlUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../order/OrderStoreUtils.sol\";\nimport \"../order/OrderEventUtils.sol\";\nimport \"../position/PositionUtils.sol\";\nimport \"../position/PositionStoreUtils.sol\";\nimport \"../nonce/NonceUtils.sol\";\n\n// @title AdlUtils\n// @dev Library to help with auto-deleveraging\n// This is particularly for markets with an index token that is different from\n// the long token\n//\n// For example, if there is a DOGE / USD perp market with ETH as the long token\n// it would be possible for the price of DOGE to increase faster than the price of\n// ETH\n//\n// In this scenario, profitable positions should be closed through ADL to ensure\n// that the system remains fully solvent\nlibrary AdlUtils {\n    using SafeCast for int256;\n    using Array for uint256[];\n    using Market for Market.Props;\n    using Position for Position.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    // @dev CreateAdlOrderParams struct used in createAdlOrder to avoid stack\n    // too deep errors\n    //\n    // @param dataStore DataStore\n    // @param orderStore OrderStore\n    // @param account the account to reduce the position for\n    // @param market the position's market\n    // @param collateralToken the position's collateralToken\n    // @param isLong whether the position is long or short\n    // @param sizeDeltaUsd the size to reduce the position by\n    // @param updatedAtBlock the block to set the order's updatedAtBlock to\n    struct CreateAdlOrderParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        address account;\n        address market;\n        address collateralToken;\n        bool isLong;\n        uint256 sizeDeltaUsd;\n        uint256 updatedAtBlock;\n    }\n\n    error InvalidSizeDeltaForAdl(uint256 sizeDeltaUsd, uint256 positionSizeInUsd);\n    error AdlNotEnabled();\n\n    // @dev Multiple positions may need to be reduced to ensure that the pending\n    // profits does not exceed the allowed thresholds\n    //\n    // This automatic reduction of positions can only be done if the pool is in a state\n    // where auto-deleveraging is required\n    //\n    // This function checks the pending profit state and updates an isAdlEnabled\n    // flag to avoid having to repeatedly validate whether auto-deleveraging is required\n    //\n    // Once the pending profit has been reduced below the threshold this function can\n    // be called again to clear the flag\n    //\n    // The ADL check would be possible to do in AdlHandler.executeAdl as well\n    // but with that order keepers could use stale oracle prices to prove that\n    // an ADL state is possible\n    //\n    // Having this function allows any order keeper to disable ADL if prices\n    // have updated such that ADL is no longer needed\n    //\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param oracle Oracle\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param maxOracleBlockNumbers the oracle block numbers for the prices stored in the oracle\n    function updateAdlState(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        Oracle oracle,\n        address market,\n        bool isLong,\n        uint256[] memory maxOracleBlockNumbers\n    ) external {\n        uint256 latestAdlBlock = getLatestAdlBlock(dataStore, market, isLong);\n\n        if (!maxOracleBlockNumbers.areGreaterThanOrEqualTo(latestAdlBlock)) {\n            OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(maxOracleBlockNumbers, latestAdlBlock);\n        }\n\n        Market.Props memory _market = MarketUtils.getEnabledMarket(dataStore, market);\n        MarketUtils.MarketPrices memory prices = MarketUtils.getMarketPrices(oracle, _market);\n        (bool shouldEnableAdl, int256 pnlToPoolFactor, uint256 maxPnlFactor) = MarketUtils.isPnlFactorExceeded(\n            dataStore,\n            _market,\n            prices,\n            isLong,\n            Keys.MAX_PNL_FACTOR\n        );\n\n        setIsAdlEnabled(dataStore, market, isLong, shouldEnableAdl);\n        setLatestAdlBlock(dataStore, market, isLong, block.number);\n\n        emitAdlStateUpdated(eventEmitter, market, isLong, pnlToPoolFactor, maxPnlFactor, shouldEnableAdl);\n    }\n\n    // @dev Construct an ADL order\n    //\n    // A decrease order is used to reduce a profitable position\n    //\n    // @param params CreateAdlOrderParams\n    // @return the key of the created order\n    function createAdlOrder(CreateAdlOrderParams memory params) external returns (bytes32) {\n        bytes32 positionKey = PositionUtils.getPositionKey(params.account, params.market, params.collateralToken, params.isLong);\n        Position.Props memory position = PositionStoreUtils.get(params.dataStore, positionKey);\n\n        if (params.sizeDeltaUsd > position.sizeInUsd()) {\n            revert InvalidSizeDeltaForAdl(params.sizeDeltaUsd, position.sizeInUsd());\n        }\n\n        Order.Addresses memory addresses = Order.Addresses(\n            params.account, // account\n            params.account, // receiver\n            address(0), // callbackContract\n            params.market, // market\n            position.collateralToken(), // initialCollateralToken\n            new address[](0) // swapPath\n        );\n\n        Order.Numbers memory numbers = Order.Numbers(\n            Order.OrderType.MarketDecrease, // orderType\n            Order.DecreasePositionSwapType.NoSwap, // decreasePositionSwapType\n            params.sizeDeltaUsd, // sizeDeltaUsd\n            0, // initialCollateralDeltaAmount\n            0, // triggerPrice\n            position.isLong() ? 0 : type(uint256).max, // acceptablePrice\n            0, // executionFee\n            0, // callbackGasLimit\n            0, // minOutputAmount\n            params.updatedAtBlock // updatedAtBlock\n        );\n\n        Order.Flags memory flags = Order.Flags(\n            position.isLong(), // isLong\n            true, // shouldUnwrapNativeToken\n            false // isFrozen\n        );\n\n        Order.Props memory order = Order.Props(\n            addresses,\n            numbers,\n            flags\n        );\n\n        bytes32 key = NonceUtils.getNextKey(params.dataStore);\n        OrderStoreUtils.set(params.dataStore, key, order);\n\n        OrderEventUtils.emitOrderCreated(params.eventEmitter, key, order);\n\n        return key;\n    }\n\n    // @dev validate if the requested ADL can be executed\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param maxOracleBlockNumbers the oracle block numbers for the prices stored in the oracle\n    function validateAdl(\n        DataStore dataStore,\n        address market,\n        bool isLong,\n        uint256[] memory maxOracleBlockNumbers\n    ) external view {\n        bool isAdlEnabled = AdlUtils.getIsAdlEnabled(dataStore, market, isLong);\n        if (!isAdlEnabled) {\n            revert AdlNotEnabled();\n        }\n\n        uint256 latestAdlBlock = AdlUtils.getLatestAdlBlock(dataStore, market, isLong);\n        if (!maxOracleBlockNumbers.areGreaterThanOrEqualTo(latestAdlBlock)) {\n            OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(maxOracleBlockNumbers, latestAdlBlock);\n        }\n    }\n\n    // @dev get the latest block at which the ADL flag was updated\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    //\n    // @return the latest block at which the ADL flag was updated\n    function getLatestAdlBlock(DataStore dataStore, address market, bool isLong) internal view returns (uint256) {\n        return dataStore.getUint(Keys.latestAdlBlockKey(market, isLong));\n    }\n\n    // @dev set the latest block at which the ADL flag was updated\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param value the latest block value\n    //\n    // @return the latest block value\n    function setLatestAdlBlock(DataStore dataStore, address market, bool isLong, uint256 value) internal returns (uint256) {\n        return dataStore.setUint(Keys.latestAdlBlockKey(market, isLong), value);\n    }\n\n    // @dev get whether ADL is enabled\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    //\n    // @return whether ADL is enabled\n    function getIsAdlEnabled(DataStore dataStore, address market, bool isLong) internal view returns (bool) {\n        return dataStore.getBool(Keys.isAdlEnabledKey(market, isLong));\n    }\n\n    // @dev set whether ADL is enabled\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param value whether ADL is enabled\n    //\n    // @return whether ADL is enabled\n    function setIsAdlEnabled(DataStore dataStore, address market, bool isLong, bool value) internal returns (bool) {\n        return dataStore.setBool(Keys.isAdlEnabledKey(market, isLong), value);\n    }\n\n    // @dev emit ADL state update events\n    //\n    // @param eventEmitter EventEmitter\n    // @param market address of the market for the ADL state update\n    // @param isLong indicates the ADL state update is for the long or short side of the market\n    // @param pnlToPoolFactor the ratio of PnL to pool value\n    // @param maxPnlFactor the max PnL factor\n    // @param shouldEnableAdl whether ADL was enabled or disabled\n    function emitAdlStateUpdated(\n        EventEmitter eventEmitter,\n        address market,\n        bool isLong,\n        int256 pnlToPoolFactor,\n        uint256 maxPnlFactor,\n        bool shouldEnableAdl\n    ) internal {\n        EventUtils.EventLogData memory eventData;\n\n        eventData.intItems.initItems(1);\n        eventData.intItems.setItem(0, \"pnlToPoolFactor\", pnlToPoolFactor);\n\n        eventData.uintItems.initItems(1);\n        eventData.uintItems.setItem(0, \"maxPnlFactor\", maxPnlFactor);\n\n        eventData.boolItems.initItems(2);\n        eventData.boolItems.setItem(0, \"isLong\", isLong);\n        eventData.boolItems.setItem(1, \"shouldEnableAdl\", shouldEnableAdl);\n\n        eventEmitter.emitEventLog1(\n            \"AdlStateUpdated\",\n            Cast.toBytes32(market),\n            eventData\n        );\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/exchange/AdlHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderHandler.sol\";\n\n// @title AdlHandler\n// @dev Contract to handle adls\ncontract AdlHandler is BaseOrderHandler {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    error AdlNotRequired(int256 pnlToPoolFactor, uint256 maxPnlFactorForAdl);\n    error InvalidAdl(int256 nextPnlToPoolFactor, int256 pnlToPoolFactor);\n    error PnlOvercorrected(int256 nextPnlToPoolFactor, uint256 minPnlFactorForAdl);\n\n    // @dev ExecuteAdlCache struct used in executeAdl to avoid\n    // stack too deep errors\n    struct ExecuteAdlCache {\n        uint256 startingGas;\n        uint256[] minOracleBlockNumbers;\n        uint256[] maxOracleBlockNumbers;\n        bytes32 key;\n        bool shouldAllowAdl;\n        uint256 maxPnlFactorForAdl;\n        int256 pnlToPoolFactor;\n        int256 nextPnlToPoolFactor;\n        uint256 minPnlFactorForAdl;\n    }\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        OrderVault _orderVault,\n        Oracle _oracle,\n        SwapHandler _swapHandler,\n        IReferralStorage _referralStorage\n    ) BaseOrderHandler(\n        _roleStore,\n        _dataStore,\n        _eventEmitter,\n        _orderVault,\n        _oracle,\n        _swapHandler,\n        _referralStorage\n    ) {}\n\n    // @dev checks the ADL state to update the isAdlEnabled flag\n    // @param market the market to check\n    // @param isLong whether to check the long or short side\n    // @param oracleParams OracleUtils.SetPricesParams\n    function updateAdlState(\n        address market,\n        bool isLong,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyAdlKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256[] memory maxOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMaxOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        AdlUtils.updateAdlState(\n            dataStore,\n            eventEmitter,\n            oracle,\n            market,\n            isLong,\n            maxOracleBlockNumbers\n        );\n    }\n\n    // @dev auto-deleverages a position\n    // @param account the position's account\n    // @param market the position's market\n    // @param collateralToken the position's collateralToken\n    // @param isLong whether the position is long or short\n    // @param sizeDeltaUsd the size to reduce the position by\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeAdl(\n        address account,\n        address market,\n        address collateralToken,\n        bool isLong,\n        uint256 sizeDeltaUsd,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyAdlKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        ExecuteAdlCache memory cache;\n\n        cache.startingGas = gasleft();\n\n        cache.minOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMinOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        cache.maxOracleBlockNumbers = OracleUtils.getUncompactedOracleBlockNumbers(\n            oracleParams.compactedMaxOracleBlockNumbers,\n            oracleParams.tokens.length\n        );\n\n        AdlUtils.validateAdl(\n            dataStore,\n            market,\n            isLong,\n            cache.maxOracleBlockNumbers\n        );\n\n        (cache.shouldAllowAdl, cache.pnlToPoolFactor, cache.maxPnlFactorForAdl) = MarketUtils.isPnlFactorExceeded(\n            dataStore,\n            oracle,\n            market,\n            isLong,\n            Keys.MAX_PNL_FACTOR_FOR_ADL\n        );\n\n        if (!cache.shouldAllowAdl) {\n            revert AdlNotRequired(cache.pnlToPoolFactor, cache.maxPnlFactorForAdl);\n        }\n\n        cache.key = AdlUtils.createAdlOrder(\n            AdlUtils.CreateAdlOrderParams(\n                dataStore,\n                eventEmitter,\n                account,\n                market,\n                collateralToken,\n                isLong,\n                sizeDeltaUsd,\n                cache.minOracleBlockNumbers[0]\n            )\n        );\n\n        BaseOrderUtils.ExecuteOrderParams memory params = _getExecuteOrderParams(cache.key, oracleParams, msg.sender, cache.startingGas);\n\n        FeatureUtils.validateFeature(params.contracts.dataStore, Keys.executeAdlFeatureDisabledKey(address(this), uint256(params.order.orderType())));\n\n        OrderUtils.executeOrder(params);\n\n        // validate that the ratio of pending pnl to pool value was decreased\n        cache.nextPnlToPoolFactor = MarketUtils.getPnlToPoolFactor(dataStore, oracle, market, isLong, true);\n        if (cache.nextPnlToPoolFactor >= cache.pnlToPoolFactor) {\n            revert InvalidAdl(cache.nextPnlToPoolFactor, cache.pnlToPoolFactor);\n        }\n\n        cache.minPnlFactorForAdl = MarketUtils.getMinPnlFactorAfterAdl(dataStore, market, isLong);\n\n        if (cache.nextPnlToPoolFactor < cache.minPnlFactorForAdl.toInt256()) {\n            revert PnlOvercorrected(cache.nextPnlToPoolFactor, cache.minPnlFactorForAdl);\n        }\n    }\n}"
    }
  ]
}