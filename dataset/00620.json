{
  "Title": "Implementation Keeps Functionalities for Deprecated Variables",
  "Content": "At line [82](https://github.com/scroll-tech/scroll/blob/45e1305de5f7a1dc5aadadd7d3bb6726a5dee949/contracts/src/L1/gateways/L1GatewayRouter.sol#L82) of `L1GatewayRouter.sol`, it is explained that the `ethGateway` parameter is no longer in use. However, the logic that makes use of/changes this variable, such as the [check](https://github.com/scroll-tech/scroll/blob/45e1305de5f7a1dc5aadadd7d3bb6726a5dee949/contracts/src/L1/gateways/L1GatewayRouter.sol#L96) in the initialize function and the [`setETHGateway`](https://github.com/scroll-tech/scroll/blob/45e1305de5f7a1dc5aadadd7d3bb6726a5dee949/contracts/src/L1/gateways/L1GatewayRouter.sol#L244) function, is maintained.\n\n\nIf a variable is no longer in use, consider removing the logic that uses it.\n\n\n***Update:** Resolved in [pull request #1094](https://github.com/scroll-tech/scroll/pull/1094) at commit [`223538d`](https://github.com/scroll-tech/scroll/pull/1094/commits/223538de478e26415fe57682254cdfb9469a5d79).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/gateways/L1GatewayRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {IL1ScrollMessenger} from \"../IL1ScrollMessenger.sol\";\nimport {IL1ETHGateway} from \"./IL1ETHGateway.sol\";\nimport {IL1ERC20Gateway} from \"./IL1ERC20Gateway.sol\";\nimport {IL1GatewayRouter} from \"./IL1GatewayRouter.sol\";\n\n/// @title L1GatewayRouter\n/// @notice The `L1GatewayRouter` is the main entry for depositing Ether and ERC20 tokens.\n/// All deposited tokens are routed to corresponding gateways.\n/// @dev One can also use this contract to query L1/L2 token address mapping.\n/// In the future, ERC-721 and ERC-1155 tokens will be added to the router too.\ncontract L1GatewayRouter is OwnableUpgradeable, IL1GatewayRouter {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The address of `L1ScrollMessenger`.\n    address public immutable messenger;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The address of L1ETHGateway.\n    /// @dev This variable is no longer used.\n    address public ethGateway;\n\n    /// @notice The addess of default ERC20 gateway, normally the L1StandardERC20Gateway contract.\n    address public defaultERC20Gateway;\n\n    /// @notice Mapping from ERC20 token address to corresponding L1ERC20Gateway.\n    // solhint-disable-next-line var-name-mixedcase\n    mapping(address => address) public ERC20Gateway;\n\n    /// @notice The address of gateway in current execution context.\n    address public gatewayInContext;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyNotInContext() {\n        require(gatewayInContext == address(0), \"Only not in context\");\n        _;\n    }\n\n    modifier onlyInContext() {\n        require(_msgSender() == gatewayInContext, \"Only in deposit context\");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(address _messenger) {\n        if (_messenger == address(0)) revert ErrorZeroAddress();\n\n        _disableInitializers();\n\n        messenger = _messenger;\n    }\n\n    /// @notice Initialize the storage of L1GatewayRouter.\n    ///\n    /// @dev The parameters `_ethGateway` is no longer used.\n    ///\n    /// @param _ethGateway The address of L1ETHGateway contract.\n    /// @param _defaultERC20Gateway The address of default ERC20 Gateway contract.\n    function initialize(address _ethGateway, address _defaultERC20Gateway) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // it can be zero during initialization\n        if (_defaultERC20Gateway != address(0)) {\n            defaultERC20Gateway = _defaultERC20Gateway;\n            emit SetDefaultERC20Gateway(address(0), _defaultERC20Gateway);\n        }\n\n        // it can be zero during initialization\n        if (_ethGateway != address(0)) {\n            ethGateway = _ethGateway;\n            emit SetETHGateway(address(0), _ethGateway);\n        }\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function getL2ERC20Address(address _l1Address) external view override returns (address) {\n        address _gateway = getERC20Gateway(_l1Address);\n        if (_gateway == address(0)) {\n            return address(0);\n        }\n\n        return IL1ERC20Gateway(_gateway).getL2ERC20Address(_l1Address);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function getERC20Gateway(address _token) public view returns (address) {\n        address _gateway = ERC20Gateway[_token];\n        if (_gateway == address(0)) {\n            _gateway = defaultERC20Gateway;\n        }\n        return _gateway;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    /// @dev All the gateways should have reentrancy guard to prevent potential attack though this function.\n    function requestERC20(\n        address _sender,\n        address _token,\n        uint256 _amount\n    ) external onlyInContext returns (uint256) {\n        address _caller = _msgSender();\n        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_caller);\n        IERC20Upgradeable(_token).safeTransferFrom(_sender, _caller, _amount);\n        _amount = IERC20Upgradeable(_token).balanceOf(_caller) - _balance;\n        return _amount;\n    }\n\n    /*************************************************\n     * Public Mutating Functions from L1ERC20Gateway *\n     *************************************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositERC20AndCall(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        address _gateway = getERC20Gateway(_token);\n        require(_gateway != address(0), \"no gateway available\");\n\n        // enter deposit context\n        gatewayInContext = _gateway;\n\n        // encode msg.sender with _data\n        bytes memory _routerData = abi.encode(_msgSender(), _data);\n\n        IL1ERC20Gateway(_gateway).depositERC20AndCall{value: msg.value}(_token, _to, _amount, _routerData, _gasLimit);\n\n        // leave deposit context\n        gatewayInContext = address(0);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address,\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert(\"should never be called\");\n    }\n\n    /***********************************************\n     * Public Mutating Functions from L1ETHGateway *\n     ***********************************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        depositETHAndCall(_msgSender(), _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        depositETHAndCall(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) public payable override onlyNotInContext {\n        IL1ScrollMessenger(messenger).sendMessage{value: msg.value}(_to, _amount, _data, _gasLimit, _msgSender());\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external payable virtual override {\n        revert(\"should never be called\");\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @inheritdoc IL1GatewayRouter\n    function setETHGateway(address _newEthGateway) external onlyOwner {\n        address _oldETHGateway = ethGateway;\n        ethGateway = _newEthGateway;\n\n        emit SetETHGateway(_oldETHGateway, _newEthGateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setDefaultERC20Gateway(address _newDefaultERC20Gateway) external onlyOwner {\n        address _oldDefaultERC20Gateway = defaultERC20Gateway;\n        defaultERC20Gateway = _newDefaultERC20Gateway;\n\n        emit SetDefaultERC20Gateway(_oldDefaultERC20Gateway, _newDefaultERC20Gateway);\n    }\n\n    /// @inheritdoc IL1GatewayRouter\n    function setERC20Gateway(address[] memory _tokens, address[] memory _gateways) external onlyOwner {\n        require(_tokens.length == _gateways.length, \"length mismatch\");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _oldGateway = ERC20Gateway[_tokens[i]];\n            ERC20Gateway[_tokens[i]] = _gateways[i];\n\n            emit SetERC20Gateway(_tokens[i], _oldGateway, _gateways[i]);\n        }\n    }\n}"
    }
  ]
}