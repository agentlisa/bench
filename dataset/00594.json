{
  "Title": "Missing Function Comments",
  "Content": "Most of the functions in the codebase do not have explanatory comments. Also, note that the `extractUserTypes` function is missing a `@param` statement for the [`fromPath` parameter](https://github.com/latticexyz/mud/blob/f6133591a86eb169a7b1b2b8d342733a887af610/packages/common/src/codegen/utils/extractUserTypes.ts#L20).\n\n\nTo improve the readability of the codebase, consider documenting all functions and their parameters.\n\n\n***Update:** Resolved in [pull request #2185](https://github.com/latticexyz/mud/pull/2185). The Lattice Labs team stated:*\n\n\n\n> *We pulled out some return values into TS interfaces to make it easier to document params and added comment headers to the rest of the functions.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/common/src/codegen/utils/extractUserTypes.ts",
      "content": "import { parse, visit } from \"@solidity-parser/parser\";\nimport { MUDError } from \"../../errors\";\n\nexport interface SolidityUserDefinedType {\n  typeId: string;\n  internalTypeId: string;\n  importSymbol: string;\n  fromPath: string;\n  isRelativePath: boolean;\n}\n\n/**\n * Parse the solidity data to extract user-defined type information.\n * @param data contents of a solidity file with the user types declarations\n * @param userTypeNames names of the user types to extract\n */\nexport function extractUserTypes(\n  data: string,\n  userTypeNames: string[],\n  fromPath: string\n): Record<string, SolidityUserDefinedType> {\n  const ast = parse(data);\n\n  const isRelativePath = fromPath.at(0) === \".\";\n  const userDefinedTypes: Record<string, SolidityUserDefinedType> = {};\n\n  visit(ast, {\n    TypeDefinition({ name, definition }, parent) {\n      if (definition.name.includes(\"fixed\")) throw new MUDError(`Fixed point numbers are not supported by MUD`);\n      if (userTypeNames.includes(name)) {\n        if (name in userDefinedTypes) {\n          throw new MUDError(`File has multiple user types with the same name: ${name}`);\n        }\n\n        if (parent?.type === \"ContractDefinition\") {\n          userDefinedTypes[name] = {\n            typeId: `${parent.name}.${name}`,\n            internalTypeId: definition.name,\n            importSymbol: parent.name,\n            fromPath,\n            isRelativePath,\n          };\n        } else {\n          userDefinedTypes[name] = {\n            typeId: name,\n            internalTypeId: definition.name,\n            importSymbol: name,\n            fromPath,\n            isRelativePath,\n          };\n        }\n      }\n    },\n  });\n\n  return userDefinedTypes;\n}"
    }
  ]
}