{
  "Title": "[G-12] Use Shift Right/Left instead of Division/Multiplication",
  "Content": "\nA division/multiplication by any number x being a power of 2 can be calculated by shifting to the right/left. While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas. \n\nFurthermore, Solidity's division operation also includes a division-by-0 prevention which is bypassed using shifting.\n\n3 results 2 files:\n```diff\ncontracts/smart-contract-wallet/libs/Math.sol:\n- 36:        return (a & b) + (a ^ b) / 2;\n+ 36:        return (a & b) + (a ^ b) >> 1;\n```\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/Math.sol#L36\n\n\n```diff\ncontracts/smart-contract-wallet/SmartAccount.sol:\n- 200:      uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n+ 200:      uint256 startGas = gasleft() + 21000 + msg.data.length << 3;\n```\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L200\n\n\n```diff\n- 224:       require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n+ 224:       require(gasleft() >= max((_tx.targetTxGas << 6) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n```\nhttps://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L224\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-biconomy-smart-contract-wallet-contest",
  "Code": [
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/libs/Math.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity 0.8.12;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}"
    },
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"./libs/LibAddress.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./BaseSmartAccount.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./base/ModuleManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract SmartAccount is \n     Singleton,\n     BaseSmartAccount,\n     IERC165,\n     ModuleManager,\n     SignatureDecoder,\n     SecuredTokenTransfer,\n     ISignatureValidatorConstants,\n     FallbackManager,\n     Initializable,\n     ReentrancyGuardUpgradeable\n    {\n    using ECDSA for bytes32;\n    using LibAddress for address;\n\n    // Storage\n\n    // Version\n    string public constant VERSION = \"1.0.2\"; // using AA 0.3.0\n\n    // Domain Seperators\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // review? if rename wallet to account is must\n    // keccak256(\n    //     \"AccountTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 internal constant ACCOUNT_TX_TYPEHASH = 0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;\n\n    // Owner storage\n    address public owner;\n\n    // uint96 private _nonce; //changed to 2D nonce below\n    // @notice there is no _nonce \n    mapping(uint256 => uint256) public nonces;\n\n    // AA storage\n    // review\n    IEntryPoint private _entryPoint;\n\n    \n    // Events\n    // EOA + Version tracking\n    event ImplementationUpdated(address _scw, string version, address newImplementation);\n    event EntryPointChanged(address oldEntryPoint, address newEntryPoint);\n    event EOAChanged(address indexed _scw, address indexed _oldEOA, address indexed _newEOA);\n    event WalletHandlePayment(bytes32 txHash, uint256 payment);\n    // nice to have\n    // event SmartAccountInitialized(IEntryPoint indexed entryPoint, address indexed owner);\n\n    // modifiers\n    // onlyOwner\n    /**\n     * @notice Throws if the sender is not an the owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Smart Account:: Sender is not authorized\");\n        _;\n    }\n\n    // onlyOwner OR self\n    modifier mixedAuth {\n        require(msg.sender == owner || msg.sender == address(this),\"Only owner or self\");\n        _;\n   }\n\n   // only from EntryPoint\n   modifier onlyEntryPoint {\n        require(msg.sender == address(entryPoint()), \"wallet: not from EntryPoint\");\n        _; \n   }\n\n   function nonce() public view virtual override returns (uint256) {\n        return nonces[0];\n    }\n\n    function nonce(uint256 _batchId) public view virtual override returns (uint256) {\n        return nonces[_batchId];\n    }\n\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    // @notice authorized modifier (onlySelf) is already inherited\n\n    // Setters\n\n    function setOwner(address _newOwner) external mixedAuth {\n        require(_newOwner != address(0), \"Smart Account:: new Signatory address cannot be zero\");\n        address oldOwner = owner;\n        owner = _newOwner;\n        emit EOAChanged(address(this), oldOwner, _newOwner);\n    }\n\n    /**\n     * @notice Updates the implementation of the base wallet\n     * @param _implementation New wallet implementation\n     */\n    function updateImplementation(address _implementation) external mixedAuth {\n        require(_implementation.isContract(), \"INVALID_IMPLEMENTATION\");\n        _setImplementation(_implementation);\n        // EOA + Version tracking\n        emit ImplementationUpdated(address(this), VERSION, _implementation);\n    }\n\n    function updateEntryPoint(address _newEntryPoint) external mixedAuth {\n        require(_newEntryPoint != address(0), \"Smart Account:: new entry point address cannot be zero\");\n        emit EntryPointChanged(address(_entryPoint), _newEntryPoint);\n        _entryPoint = IEntryPoint(payable(_newEntryPoint));\n    }\n\n    // Getters\n\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /// @dev Returns the chain id used by this contract.\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    //@review getNonce specific to EntryPoint requirements\n    /**\n     * @dev returns a value from the nonces 2d mapping\n     * @param batchId : the key of the user's batch being queried\n     * @return nonce : the number of transaction made within said batch\n     */\n    function getNonce(uint256 batchId)\n    public view\n    returns (uint256) {\n        return nonces[batchId];\n    }\n\n\n    // init\n    // Initialize / Setup\n    // Used to setup\n    // i. owner ii. entry point address iii. handler\n    function init(address _owner, address _entryPointAddress, address _handler) public override initializer { \n        require(owner == address(0), \"Already initialized\");\n        require(address(_entryPoint) == address(0), \"Already initialized\");\n        require(_owner != address(0),\"Invalid owner\");\n        require(_entryPointAddress != address(0), \"Invalid Entrypoint\");\n        require(_handler != address(0), \"Invalid Entrypoint\");\n        owner = _owner;\n        _entryPoint =  IEntryPoint(payable(_entryPointAddress));\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\n        setupModules(address(0), bytes(\"\"));\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    // Gnosis style transaction with optional repay in native tokens OR ERC20 \n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\n    /// Note: The fees are always transferred, even if the user transaction fails.\n    /// @param _tx Wallet transaction \n    /// @param batchId batchId key for 2D nonces\n    /// @param refundInfo Required information for gas refunds\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\n    function execTransaction(\n        Transaction memory _tx,\n        uint256 batchId,\n        FeeRefund memory refundInfo,\n        bytes memory signatures\n    ) public payable virtual override returns (bool success) {\n        // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n        //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n        uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n        //console.log(\"init %s\", 21000 + msg.data.length * 8);\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData =\n                encodeTransactionData(\n                    // Transaction info\n                    _tx,\n                    // Payment info\n                    refundInfo,\n                    // Signature info\n                    nonces[batchId]\n                );\n            // Increase nonce and execute transaction.\n            // Default space aka batchId is 0\n            nonces[batchId]++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n\n\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \"BSA010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than targetTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas\n            success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);\n            // If no targetTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \"BSA013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            // uint256 extraGas;\n            if (refundInfo.gasPrice > 0) {\n                //console.log(\"sent %s\", startGas - gasleft());\n                // extraGas = gasleft();\n                payment = handlePayment(startGas - gasleft(), refundInfo.baseGas, refundInfo.gasPrice, refundInfo.tokenGasPriceFactor, refundInfo.gasToken, refundInfo.refundReceiver);\n                emit WalletHandlePayment(txHash, payment);\n            }\n            // extraGas = extraGas - gasleft();\n            //console.log(\"extra gas %s \", extraGas);\n        }\n    }\n\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) private nonReentrant returns (uint256 payment) {\n        // uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        // uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hp %s\", requiredGas);\n    }\n\n    function handlePaymentRevert(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver\n    ) external returns (uint256 payment) {\n        uint256 startGas = gasleft();\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            (bool success,) = receiver.call{value: payment}(\"\");\n            require(success, \"BSA011\");\n        } else {\n            payment = (gasUsed + baseGas) * (gasPrice) / (tokenGasPriceFactor);\n            require(transferToken(gasToken, receiver, payment), \"BSA012\");\n        }\n        uint256 requiredGas = startGas - gasleft();\n        //console.log(\"hpr %s\", requiredGas);\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /**\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(\n        bytes32 dataHash,\n        bytes memory data,\n        bytes memory signatures\n    ) public view virtual {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i = 0;\n        address _signer;\n        (v, r, s) = signatureSplit(signatures, i);\n        //review\n        if(v == 0) {\n            // If v is 0 then it is a contract signature\n            // When handling contract signatures the address of the contract is encoded into r\n            _signer = address(uint160(uint256(r)));\n\n            // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= uint256(1) * 65, \"BSA021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s) + 32 <= signatures.length, \"BSA022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \"BSA023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"BSA024\");\n        }\n        else if(v > 30) {\n            // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n            // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n            _signer = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        } else {\n            _signer = ecrecover(dataHash, v, r, s);\n            require(_signer == owner, \"INVALID_SIGNATURE\");\n        }\n    }\n\n    /// @dev Allows to estimate a transaction.\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\n    /// @param to Destination address of Safe transaction.\n    /// @param value Ether value of transaction.\n    /// @param data Data payload of transaction.\n    /// @param operation Operation type of transaction.\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\n    function requiredTxGas(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (uint256) {\n        uint256 startGas = gasleft();\n        // We don't provide an error message here, as we use it to return the estimate\n        require(execute(to, value, data, operation, gasleft()));\n        uint256 requiredGas = startGas - gasleft();\n        // Convert response to string and return via error message\n        revert(string(abi.encodePacked(requiredGas)));\n    }\n\n    /// @dev Returns hash to be signed by owner.\n    /// @param to Destination address.\n    /// @param value Ether value.\n    /// @param data Data payload.\n    /// @param operation Operation type.\n    /// @param targetTxGas Fas that should be used for the safe transaction.\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 targetTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        uint256 tokenGasPriceFactor,\n        address gasToken,\n        address payable refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        Transaction memory _tx = Transaction({\n            to: to,\n            value: value,\n            data: data,\n            operation: operation,\n            targetTxGas: targetTxGas\n        });\n        FeeRefund memory refundInfo = FeeRefund({\n            baseGas: baseGas,\n            gasPrice: gasPrice,\n            tokenGasPriceFactor: tokenGasPriceFactor,\n            gasToken: gasToken,\n            refundReceiver: refundReceiver\n        });\n        return keccak256(encodeTransactionData(_tx, refundInfo, _nonce));\n    }\n\n    /// @dev Returns the bytes that are hashed to be signed by owner.\n    /// @param _tx Wallet transaction \n    /// @param refundInfo Required information for gas refunds\n    /// @param _nonce Transaction nonce.\n    /// @return Transaction hash bytes.\n    function encodeTransactionData(\n        Transaction memory _tx,\n        FeeRefund memory refundInfo,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash =\n            keccak256(\n                abi.encode(\n                    ACCOUNT_TX_TYPEHASH,\n                    _tx.to,\n                    _tx.value,\n                    keccak256(_tx.data),\n                    _tx.operation,\n                    _tx.targetTxGas,\n                    refundInfo.baseGas,\n                    refundInfo.gasPrice,\n                    refundInfo.gasToken,\n                    refundInfo.refundReceiver,\n                    _nonce\n                )\n            );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    // Extra Utils \n    function transfer(address payable dest, uint amount) external nonReentrant onlyOwner {\n        require(dest != address(0), \"this action will burn your funds\");\n        (bool success,) = dest.call{value:amount}(\"\");\n        require(success,\"transfer failed\");\n    }\n\n    function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\n        IERC20 tokenContract = IERC20(token);\n        SafeERC20.safeTransfer(tokenContract, dest, amount);\n    }\n\n    function execute(address dest, uint value, bytes calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        _call(dest, value, func);\n    }\n\n    function executeBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\n        _requireFromEntryPointOrOwner();\n        require(dest.length == func.length, \"wrong array lengths\");\n        for (uint i = 0; i < dest.length;) {\n            _call(dest[i], 0, func[i]);"
    }
  ]
}