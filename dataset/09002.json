{
  "Title": "[H-03] User rewards stop accruing after any `_writeCheckpoint` calling action",
  "Content": "\nAny user balance affecting action, i.e. deposit, withdraw/withdrawToken or getReward, calls \\_writeCheckpoint to update the balance records used for the earned reward estimation. The issue is that \\_writeCheckpoint always sets false to `voted` flag for the each new checkpoint due to wrong index used in the mapping access, while only voted periods are eligible for accruing the rewards.\n\nThis way any balance changing action of a voted user will lead to stopping of the rewards accrual for the user, until next vote will be cast. I.e. any action that has no relation to voting and should have only balance change as the reward accruing process impact, in fact removes any future rewards from the user until the next vote.\n\nSetting the severity to be high as the impact here violates system logic and means next periods accrued rewards loss for a user.\n\n### Proof of Concept\n\n\\_writeCheckpoint adds a new checkpoint if block.timestamp is not found in the last checkpoint:\n\n[Gauge.sol#L302-L313](https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L302-L313)<br>\n\n```solidity\n    function _writeCheckpoint(address account, uint balance) internal {\n        uint _timestamp = block.timestamp;\n        uint _nCheckPoints = numCheckpoints[account];\n\n        if (_nCheckPoints > 0 && checkpoints[account][_nCheckPoints - 1].timestamp == _timestamp) {\n            checkpoints[account][_nCheckPoints - 1].balanceOf = balance;\n        } else {\n            bool prevVoteStatus = (_nCheckPoints > 0) ? checkpoints[account][_nCheckPoints].voted : false;\n            checkpoints[account][_nCheckPoints] = Checkpoint(_timestamp, balance, prevVoteStatus);\n            numCheckpoints[account] = _nCheckPoints + 1;\n        }\n    }\n```\n\nHowever, instead of moving vote status from the previous checkpoint it records `false` to `prevVoteStatus` all the time as last status is `checkpoints[account][_nCheckPoints-1].voted`, while `checkpoints[account][_nCheckPoints]` isn't created yet and is empty:\n\n[Gauge.sol#L309](https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L309)<br>\n\n```solidity\n\tbool prevVoteStatus = (_nCheckPoints > 0) ? checkpoints[account][_nCheckPoints].voted : false;\n```\n\nNotice that `checkpoints` is a mapping and no range check violation happens:\n\n[Gauge.sol#L74-L75](https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L74-L75)<br>\n\n```solidity\n    /// @notice A record of balance checkpoints for each account, by index\n    mapping (address => mapping (uint => Checkpoint)) public checkpoints;\n```\n\nThis will effectively lead to rewards removal on any user action, as earned() used in rewards estimation counts only voted periods:\n\n[Gauge.sol#L483-L502](https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L483-L502)<br>\n\n```solidity\n        if (_endIndex > 0) {\n            for (uint i = _startIndex; i < _endIndex; i++) {\n                Checkpoint memory cp0 = checkpoints[account][i];\n                Checkpoint memory cp1 = checkpoints[account][i+1];\n                (uint _rewardPerTokenStored0,) = getPriorRewardPerToken(token, cp0.timestamp);\n                (uint _rewardPerTokenStored1,) = getPriorRewardPerToken(token, cp1.timestamp);\n                if (cp0.voted) {\n                    reward += cp0.balanceOf * (_rewardPerTokenStored1 - _rewardPerTokenStored0) / PRECISION;\n                }\n            }\n        }\n\n        Checkpoint memory cp = checkpoints[account][_endIndex];\n        uint lastCpWeeksVoteEnd = cp.timestamp - (cp.timestamp % (7 days)) + BRIBE_LAG + DURATION;\n        if (block.timestamp > lastCpWeeksVoteEnd) {\n            (uint _rewardPerTokenStored,) = getPriorRewardPerToken(token, cp.timestamp);\n            if (cp.voted) {\n                reward += cp.balanceOf * (rewardPerToken(token) - Math.max(_rewardPerTokenStored, userRewardPerTokenStored[token][account])) / PRECISION;\n            }\n        }\n```\n\nI.e. if a user has voted, then performed any of the operations that call \\_writeCheckpoint update: deposit, withdraw/withdrawToken or getReward, then this user will not have any rewards for the period between this operation and the next vote as all checkpoints that were created by \\_writeCheckpoint will have `voted == false`.\n\n### Recommended Mitigation Steps\n\nUpdate the index to be `_nCheckPoints-1`:\n\n<https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L309>\n\n```solidity\n-\tbool prevVoteStatus = (_nCheckPoints > 0) ? checkpoints[account][_nCheckPoints].voted : false;\n+\tbool prevVoteStatus = (_nCheckPoints > 0) ? checkpoints[account][_nCheckPoints - 1].voted : false;\n```\n\n**[pooltypes (Velodrome) disputed](https://github.com/code-423n4/2022-05-velodrome-findings/issues/59)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/59#issuecomment-1171780662):**\n > Due to 1 typo / oversight in the line `\n> bool prevVoteStatus = (_nCheckPoints > 0) ? checkpoints[account][_nCheckPoints].voted : false;`\n> All future checkpoints are registered as having `voted` set to false.\n> \n> Due to a configuration choice (or mistake as detailed in other findings), having `voted` set to false causes all rewards to not be receiveable.\n> \n> While the impact is loss of Yield (typically a medium finding), the finding shows how this bug will systematically impact all gauges for all users.\n> \n> Because of that, I believe High Severity to be appropriate.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-05-velodrome",
  "Code": [
    {
      "filename": "contracts/contracts/Gauge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGaugeFactory.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPair.sol';\nimport './interfaces/IVoter.sol';\nimport './interfaces/IVotingEscrow.sol';\n\n// Gauges are used to incentivize pools, they emit reward tokens every 7 days for staked LP tokens\ncontract Gauge {\n\n    address public immutable stake; // the LP token that needs to be staked for rewards\n    address public immutable _ve; // the ve token used for gauges\n    address public immutable bribe;\n    address public immutable voter;\n    address immutable factory;\n    bool public isForPair;\n\n    uint public derivedSupply;\n    mapping(address => uint) public derivedBalances;\n\n    uint internal constant DURATION = 5 days; // rewards are released over the voting period\n    uint internal constant BRIBE_LAG = 1 days;\n    uint internal constant MAX_REWARD_TOKENS = 16;\n\n    enum VotingStage\n    {\n        BribesPhase,\n        VotesPhase,\n        RewardsPhase\n    }\n\n    uint internal constant PRECISION = 10 ** 18;\n\n    // default snx staking contract implementation\n    mapping(address => uint) public rewardRate;\n    mapping(address => uint) public periodFinish;\n    mapping(address => uint) public lastUpdateTime;\n    mapping(address => uint) public rewardPerTokenStored;\n\n    mapping(address => mapping(address => uint)) public lastEarn;\n    mapping(address => mapping(address => uint)) public userRewardPerTokenStored;\n\n    mapping(address => uint) public tokenIds;\n\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n\n    address[] public rewards;\n    mapping(address => bool) public isReward;\n\n    /// @notice A checkpoint for marking balance\n    struct Checkpoint {\n        uint timestamp;\n        uint balanceOf;\n        bool voted;\n    }\n\n    /// @notice A checkpoint for marking reward rate\n    struct RewardPerTokenCheckpoint {\n        uint timestamp;\n        uint rewardPerToken;\n    }\n\n    /// @notice A checkpoint for marking supply\n    struct SupplyCheckpoint {\n        uint timestamp;\n        uint supply;\n    }\n\n    /// @notice A record of balance checkpoints for each account, by index\n    mapping (address => mapping (uint => Checkpoint)) public checkpoints;\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint) public numCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (uint => SupplyCheckpoint) public supplyCheckpoints;\n    /// @notice The number of checkpoints\n    uint public supplyNumCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (address => mapping (uint => RewardPerTokenCheckpoint)) public rewardPerTokenCheckpoints;\n    /// @notice The number of checkpoints for each token\n    mapping (address => uint) public rewardPerTokenNumCheckpoints;\n\n    uint public fees0;\n    uint public fees1;\n\n    event Deposit(address indexed from, uint tokenId, uint amount);\n    event Withdraw(address indexed from, uint tokenId, uint amount);\n    event NotifyReward(address indexed from, address indexed reward, uint amount);\n    event ClaimFees(address indexed from, uint claimed0, uint claimed1);\n    event ClaimRewards(address indexed from, address indexed reward, uint amount);\n\n    constructor(address _stake, address _bribe, address  __ve, address _voter, bool _isForPair) {\n        stake = _stake;\n        bribe = _bribe;\n        _ve = __ve;\n        voter = _voter;\n\n        factory = msg.sender;\n\n        IBribe(bribe).setGauge(address(this));\n        address _token = IVotingEscrow(_ve).token();\n        IBribe(bribe).addRewardToken(_token);\n        isReward[_token] = true;\n        rewards.push(_token);\n\n        isForPair = _isForPair;\n        if (isForPair) {\n            (address _token0, address _token1) = IPair(stake).tokens();\n            IBribe(bribe).addRewardToken(_token0);\n            isReward[_token0] = true;\n            rewards.push(_token0);\n            IBribe(bribe).addRewardToken(_token1);\n            isReward[_token1] = true;\n            rewards.push(_token1);\n        }\n    }\n\n    // simple re-entrancy check\n    uint internal _unlocked = 1;\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    function claimFees() external lock returns (uint claimed0, uint claimed1) {\n        return _claimFees();\n    }\n\n    function _claimFees() internal returns (uint claimed0, uint claimed1) {\n        if (!isForPair) {\n            return (0, 0);\n        }\n        (claimed0, claimed1) = IPair(stake).claimFees();\n        if (claimed0 > 0 || claimed1 > 0) {\n            uint _fees0 = fees0 + claimed0;\n            uint _fees1 = fees1 + claimed1;\n            (address _token0, address _token1) = IPair(stake).tokens();\n            if (_fees0 / DURATION > 0) {\n                fees0 = 0;\n                _safeApprove(_token0, bribe, _fees0);\n                IBribe(bribe).notifyRewardAmount(_token0, _fees0);\n            } else {\n                fees0 = _fees0;\n            }\n            if (_fees1 / DURATION > 0) {\n                fees1 = 0;\n                _safeApprove(_token1, bribe, _fees1);\n                IBribe(bribe).notifyRewardAmount(_token1, _fees1);\n            } else {\n                fees1 = _fees1;\n            }\n\n            emit ClaimFees(msg.sender, claimed0, claimed1);\n        }\n    }\n\n    function getVotingStage(uint timestamp) public pure returns (VotingStage) {\n        uint modTime = timestamp % (7 days);\n        if (modTime < BRIBE_LAG) {\n            return VotingStage.BribesPhase;\n        } else if (modTime > (BRIBE_LAG + DURATION)) {\n            return VotingStage.RewardsPhase;\n        }\n        return VotingStage.VotesPhase;\n    }\n\n    function deliverBribes() external lock {\n        require(msg.sender == voter);\n        IBribe sb = IBribe(bribe);\n        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n        uint numRewards = sb.rewardsListLength();\n\n        for (uint i = 0; i < numRewards; i++) {\n            address token = sb.rewards(i);\n            uint epochRewards = sb.deliverReward(token, bribeStart);\n            if (epochRewards > 0) {\n                _notifyBribeAmount(token, epochRewards, bribeStart);\n            }\n        }\n    }\n\n    function setVoteStatus(address account, bool voted) external {\n        require(msg.sender == voter);\n        uint nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            checkpoints[account][0] = Checkpoint(block.timestamp, 0, voted);\n            numCheckpoints[account] = 1;\n        } else {\n            checkpoints[account][nCheckpoints - 1].voted = voted;\n        }\n    }\n\n    /**\n    * @notice Determine the prior balance for an account as of a block number\n    * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n    * @param account The address of the account to check\n    * @param timestamp The timestamp to get the balance at\n    * @return The balance the account had as of the given block\n    */\n    function getPriorBalanceIndex(address account, uint timestamp) public view returns (uint) {\n        uint nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    function getPriorSupplyIndex(uint timestamp) public view returns (uint) {\n        uint nCheckpoints = supplyNumCheckpoints;\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (supplyCheckpoints[nCheckpoints - 1].timestamp <= timestamp) {\n            return (nCheckpoints - 1);\n        }\n\n        // Next check implicit zero balance\n        if (supplyCheckpoints[0].timestamp > timestamp) {\n            return 0;\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            SupplyCheckpoint memory cp = supplyCheckpoints[center];\n            if (cp.timestamp == timestamp) {\n                return center;\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return lower;\n    }\n\n    function getPriorRewardPerToken(address token, uint timestamp) public view returns (uint, uint) {\n        uint nCheckpoints = rewardPerTokenNumCheckpoints[token];\n        if (nCheckpoints == 0) {\n            return (0,0);\n        }\n\n        // First check most recent balance\n        if (rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp <= timestamp) {\n            return (rewardPerTokenCheckpoints[token][nCheckpoints - 1].rewardPerToken, rewardPerTokenCheckpoints[token][nCheckpoints - 1].timestamp);\n        }\n\n        // Next check implicit zero balance\n        if (rewardPerTokenCheckpoints[token][0].timestamp > timestamp) {\n            return (0,0);\n        }\n\n        uint lower = 0;\n        uint upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            RewardPerTokenCheckpoint memory cp = rewardPerTokenCheckpoints[token][center];\n            if (cp.timestamp == timestamp) {\n                return (cp.rewardPerToken, cp.timestamp);\n            } else if (cp.timestamp < timestamp) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return (rewardPerTokenCheckpoints[token][lower].rewardPerToken, rewardPerTokenCheckpoints[token][lower].timestamp);\n    }\n\n    function _writeCheckpoint(address account, uint balance) internal {\n        uint _timestamp = block.timestamp;\n        uint _nCheckPoints = numCheckpoints[account];\n\n        if (_nCheckPoints > 0 && checkpoints[account][_nCheckPoints - 1].timestamp == _timestamp) {\n            checkpoints[account][_nCheckPoints - 1].balanceOf = balance;\n        } else {\n            bool prevVoteStatus = (_nCheckPoints > 0) ? checkpoints[account][_nCheckPoints].voted : false;\n            checkpoints[account][_nCheckPoints] = Checkpoint(_timestamp, balance, prevVoteStatus);\n            numCheckpoints[account] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeRewardPerTokenCheckpoint(address token, uint reward, uint timestamp) internal {\n        uint _nCheckPoints = rewardPerTokenNumCheckpoints[token];\n\n        if (_nCheckPoints > 0 && rewardPerTokenCheckpoints[token][_nCheckPoints - 1].timestamp == timestamp) {\n            rewardPerTokenCheckpoints[token][_nCheckPoints - 1].rewardPerToken = reward;\n        } else {\n            rewardPerTokenCheckpoints[token][_nCheckPoints] = RewardPerTokenCheckpoint(timestamp, reward);\n            rewardPerTokenNumCheckpoints[token] = _nCheckPoints + 1;\n        }\n    }\n\n    function _writeSupplyCheckpoint() internal {\n        uint _nCheckPoints = supplyNumCheckpoints;\n        uint _timestamp = block.timestamp;\n\n        if (_nCheckPoints > 0 && supplyCheckpoints[_nCheckPoints - 1].timestamp == _timestamp) {\n            supplyCheckpoints[_nCheckPoints - 1].supply = derivedSupply;\n        } else {\n            supplyCheckpoints[_nCheckPoints] = SupplyCheckpoint(_timestamp, derivedSupply);\n            supplyNumCheckpoints = _nCheckPoints + 1;\n        }\n    }\n\n    function rewardsListLength() external view returns (uint) {\n        return rewards.length;\n    }\n\n    // returns the last time the reward was modified or periodFinish if the reward has ended\n    function lastTimeRewardApplicable(address token) public view returns (uint) {\n        return Math.min(block.timestamp, periodFinish[token]);\n    }\n\n    function getReward(address account, address[] memory tokens) external lock {\n        require(msg.sender == account || msg.sender == voter);\n        _unlocked = 1;\n        IVoter(voter).distribute(address(this));\n        _unlocked = 2;\n\n        for (uint i = 0; i < tokens.length; i++) {\n            (rewardPerTokenStored[tokens[i]], lastUpdateTime[tokens[i]]) = _updateRewardPerToken(tokens[i]);\n\n            uint _reward = earned(tokens[i], account);\n            lastEarn[tokens[i]][account] = block.timestamp;\n            userRewardPerTokenStored[tokens[i]][account] = rewardPerTokenStored[tokens[i]];\n            if (_reward > 0) _safeTransfer(tokens[i], account, _reward);\n\n            emit ClaimRewards(msg.sender, tokens[i], _reward);\n        }\n\n        uint _derivedBalance = derivedBalances[account];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(account);\n        derivedBalances[account] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(account, derivedBalances[account]);\n        _writeSupplyCheckpoint();\n    }\n\n\n    function rewardPerToken(address token) public view returns (uint) {\n        if (derivedSupply == 0) {\n            return rewardPerTokenStored[token];\n        }\n        return rewardPerTokenStored[token] + ((lastTimeRewardApplicable(token) - Math.min(lastUpdateTime[token], periodFinish[token])) * rewardRate[token] * PRECISION / derivedSupply);\n    }\n\n    function derivedBalance(address account) public view returns (uint) {\n        return balanceOf[account];\n    }\n\n    function batchRewardPerToken(address token, uint maxRuns) external {\n        (rewardPerTokenStored[token], lastUpdateTime[token])  = _batchRewardPerToken(token, maxRuns);\n    }\n\n    function _batchRewardPerToken(address token, uint maxRuns) internal returns (uint, uint) {\n        uint _startTimestamp = lastUpdateTime[token];\n        uint reward = rewardPerTokenStored[token];\n\n        if (supplyNumCheckpoints == 0) {\n            return (reward, _startTimestamp);\n        }\n\n        if (rewardRate[token] == 0) {\n            return (reward, block.timestamp);\n        }\n\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\n        uint _endIndex = Math.min(supplyNumCheckpoints-1, maxRuns);\n\n        for (uint i = _startIndex; i < _endIndex; i++) {\n            SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\n            if (sp0.supply > 0) {\n                SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\n                (uint _reward, uint _endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\n                reward += _reward;\n                _writeRewardPerTokenCheckpoint(token, reward, _endTime);\n                _startTimestamp = _endTime;\n            }\n        }\n\n        return (reward, _startTimestamp);\n    }\n\n    function _calcRewardPerToken(address token, uint timestamp1, uint timestamp0, uint supply, uint startTimestamp) internal view returns (uint, uint) {\n        uint endTime = Math.max(timestamp1, startTimestamp);\n        return (((Math.min(endTime, periodFinish[token]) - Math.min(Math.max(timestamp0, startTimestamp), periodFinish[token])) * rewardRate[token] * PRECISION / supply), endTime);\n    }\n\n    function _updateRewardForAllTokens() internal {\n        uint length = rewards.length;\n        for (uint i; i < length; i++) {\n            address token = rewards[i];\n            (rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);\n        }\n    }\n\n    function _updateRewardPerToken(address token) internal returns (uint, uint) {\n        uint _startTimestamp = lastUpdateTime[token];\n        uint reward = rewardPerTokenStored[token];\n\n        if (supplyNumCheckpoints == 0) {\n            return (reward, _startTimestamp);\n        }\n\n        if (rewardRate[token] == 0) {\n            return (reward, block.timestamp);\n        }\n\n        uint _startIndex = getPriorSupplyIndex(_startTimestamp);\n        uint _endIndex = supplyNumCheckpoints-1;\n\n        if (_endIndex > 0) {\n            for (uint i = _startIndex; i < _endIndex; i++) {\n                SupplyCheckpoint memory sp0 = supplyCheckpoints[i];\n                if (sp0.supply > 0) {\n                    SupplyCheckpoint memory sp1 = supplyCheckpoints[i+1];\n                    (uint _reward, uint _endTime) = _calcRewardPerToken(token, sp1.timestamp, sp0.timestamp, sp0.supply, _startTimestamp);\n                    reward += _reward;\n                    _writeRewardPerTokenCheckpoint(token, reward, _endTime);\n                    _startTimestamp = _endTime;\n                }\n            }\n        }\n\n        SupplyCheckpoint memory sp = supplyCheckpoints[_endIndex];\n        if (sp.supply > 0) {\n            (uint _reward,) = _calcRewardPerToken(token, lastTimeRewardApplicable(token), Math.max(sp.timestamp, _startTimestamp), sp.supply, _startTimestamp);\n            reward += _reward;\n            _writeRewardPerTokenCheckpoint(token, reward, block.timestamp);\n            _startTimestamp = block.timestamp;\n        }\n\n        return (reward, _startTimestamp);\n    }\n\n    // earned is an estimation, it won't be exact till the supply > rewardPerToken calculations have run\n    function earned(address token, address account) public view returns (uint) {\n        uint _startTimestamp = Math.max(lastEarn[token][account], rewardPerTokenCheckpoints[token][0].timestamp);\n        if (numCheckpoints[account] == 0) {\n            return 0;\n        }\n\n        uint _startIndex = getPriorBalanceIndex(account, _startTimestamp);\n        uint _endIndex = numCheckpoints[account]-1;\n\n        uint reward = 0;\n\n        if (_endIndex > 0) {\n            for (uint i = _startIndex; i < _endIndex; i++) {\n                Checkpoint memory cp0 = checkpoints[account][i];\n                Checkpoint memory cp1 = checkpoints[account][i+1];\n                (uint _rewardPerTokenStored0,) = getPriorRewardPerToken(token, cp0.timestamp);\n                (uint _rewardPerTokenStored1,) = getPriorRewardPerToken(token, cp1.timestamp);\n                if (cp0.voted) {\n                    reward += cp0.balanceOf * (_rewardPerTokenStored1 - _rewardPerTokenStored0) / PRECISION;\n                }\n            }\n        }\n\n        Checkpoint memory cp = checkpoints[account][_endIndex];\n        uint lastCpWeeksVoteEnd = cp.timestamp - (cp.timestamp % (7 days)) + BRIBE_LAG + DURATION;\n        if (block.timestamp > lastCpWeeksVoteEnd) {\n            (uint _rewardPerTokenStored,) = getPriorRewardPerToken(token, cp.timestamp);\n            if (cp.voted) {\n                reward += cp.balanceOf * (rewardPerToken(token) - Math.max(_rewardPerTokenStored, userRewardPerTokenStored[token][account])) / PRECISION;\n            }\n        }\n\n        return reward;\n    }\n\n    function depositAll(uint tokenId) external {\n        deposit(IERC20(stake).balanceOf(msg.sender), tokenId);\n    }\n\n    function deposit(uint amount, uint tokenId) public lock {\n        require(amount > 0);\n\n        _updateRewardForAllTokens();\n\n        _safeTransferFrom(stake, msg.sender, address(this), amount);\n        totalSupply += amount;\n        balanceOf[msg.sender] += amount;\n\n        if (tokenId > 0) {\n            require(IVotingEscrow(_ve).ownerOf(tokenId) == msg.sender);\n            if (tokenIds[msg.sender] == 0) {\n                tokenIds[msg.sender] = tokenId;\n                IVoter(voter).attachTokenToGauge(tokenId, msg.sender);\n            }\n            require(tokenIds[msg.sender] == tokenId);\n        } else {\n            tokenId = tokenIds[msg.sender];\n        }\n\n        uint _derivedBalance = derivedBalances[msg.sender];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(msg.sender);\n        derivedBalances[msg.sender] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(msg.sender, _derivedBalance);\n        _writeSupplyCheckpoint();\n\n        IVoter(voter).emitDeposit(tokenId, msg.sender, amount);\n        emit Deposit(msg.sender, tokenId, amount);\n    }\n\n    function withdrawAll() external {\n        withdraw(balanceOf[msg.sender]);\n    }\n\n    function withdraw(uint amount) public {\n        _updateRewardForAllTokens();\n\n        uint tokenId = 0;\n        if (amount == balanceOf[msg.sender]) {\n            tokenId = tokenIds[msg.sender];\n        }\n        withdrawToken(amount, tokenId);\n    }\n\n    function withdrawToken(uint amount, uint tokenId) public lock {\n        totalSupply -= amount;\n        balanceOf[msg.sender] -= amount;\n        _safeTransfer(stake, msg.sender, amount);\n\n        if (tokenId > 0) {\n            require(tokenId == tokenIds[msg.sender]);\n            tokenIds[msg.sender] = 0;\n            IVoter(voter).detachTokenFromGauge(tokenId, msg.sender);\n        } else {\n            tokenId = tokenIds[msg.sender];\n        }\n\n        uint _derivedBalance = derivedBalances[msg.sender];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(msg.sender);\n        derivedBalances[msg.sender] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n\n        _writeCheckpoint(msg.sender, derivedBalances[msg.sender]);\n        _writeSupplyCheckpoint();\n\n        IVoter(voter).emitWithdraw(tokenId, msg.sender, amount);\n        emit Withdraw(msg.sender, tokenId, amount);\n    }\n\n    function left(address token) external view returns (uint) {\n        if (block.timestamp >= periodFinish[token]) return 0;\n        uint _remaining = periodFinish[token] - block.timestamp;\n        return _remaining * rewardRate[token];\n    }\n\n    function notifyRewardAmount(address token, uint amount) external lock {\n        require(token != stake);\n        require(amount > 0);\n        if (!isReward[token]) {\n            require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n        }\n        // rewards accrue only during the bribe period\n        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n        uint adjustedTstamp = block.timestamp < bribeStart ? bribeStart : bribeStart + 7 days;\n        if (rewardRate[token] == 0) _writeRewardPerTokenCheckpoint(token, 0, adjustedTstamp);\n        (rewardPerTokenStored[token], lastUpdateTime[token]) = _updateRewardPerToken(token);\n        _claimFees();\n\n        if (block.timestamp >= periodFinish[token]) {\n            _safeTransferFrom(token, msg.sender, address(this), amount);\n            rewardRate[token] = amount / DURATION;\n        } else {\n            uint _remaining = periodFinish[token] - block.timestamp;\n            uint _left = _remaining * rewardRate[token];\n            require(amount > _left);\n            _safeTransferFrom(token, msg.sender, address(this), amount);\n            rewardRate[token] = (amount + _left) / DURATION;\n        }\n        require(rewardRate[token] > 0);\n        uint balance = IERC20(token).balanceOf(address(this));\n        require(rewardRate[token] <= balance / DURATION, \"Provided reward too high\");\n        periodFinish[token] = adjustedTstamp + DURATION;\n        if (!isReward[token]) {\n            isReward[token] = true;\n            rewards.push(token);\n            IBribe(bribe).addRewardToken(token);\n        }\n\n        emit NotifyReward(msg.sender, token, amount);\n    }\n\n    function swapOutRewardToken(uint i, address oldToken, address newToken) external {\n        require(msg.sender == IGaugeFactory(factory).team(), 'only team');\n        require(rewards[i] == oldToken);\n        isReward[oldToken] = false;\n        isReward[newToken] = true;\n        rewards[i] = newToken;\n    }\n\n    function swapOutBribeRewardToken(uint i, address oldToken, address newToken) external {\n        require(msg.sender == IGaugeFactory(factory).team(), 'only team');\n        IBribe(bribe).swapOutRewardToken(i, oldToken, newToken);\n    }\n\n    function addBribeRewardToken(address token) external {\n        require(msg.sender == bribe);\n        if (!isReward[token]) {\n            require(rewards.length < MAX_REWARD_TOKENS, \"too many rewards tokens\");\n            isReward[token] = true;\n            rewards.push(token);\n        }\n    }\n\n    function _notifyBribeAmount(address token, uint amount, uint epochStart) internal {\n        if (block.timestamp >= periodFinish[token]) {\n            rewardRate[token] = amount / DURATION;\n        } else {\n            uint _remaining = periodFinish[token] - block.timestamp;\n            uint _left = _remaining * rewardRate[token];\n            require(amount > _left);\n            rewardRate[token] = (amount + _left) / DURATION;\n        }\n\n        lastUpdateTime[token] = epochStart;\n        periodFinish[token] = epochStart + DURATION;\n\n        emit NotifyReward(msg.sender, token, amount);\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function _safeApprove(address token, address spender, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.approve.selector, spender, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}"
    },
    {
      "filename": "contracts/contracts/Gauge.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IGaugeFactory.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPair.sol';\nimport './interfaces/IVoter.sol';\nimport './interfaces/IVotingEscrow.sol';\n\n// Gauges are used to incentivize pools, they emit reward tokens every 7 days for staked LP tokens\ncontract Gauge {\n\n    address public immutable stake; // the LP token that needs to be staked for rewards\n    address public immutable _ve; // the ve token used for gauges\n    address public immutable bribe;\n    address public immutable voter;\n    address immutable factory;\n    bool public isForPair;\n\n    uint public derivedSupply;\n    mapping(address => uint) public derivedBalances;\n\n    uint internal constant DURATION = 5 days; // rewards are released over the voting period\n    uint internal constant BRIBE_LAG = 1 days;\n    uint internal constant MAX_REWARD_TOKENS = 16;\n\n    enum VotingStage\n    {\n        BribesPhase,\n        VotesPhase,\n        RewardsPhase\n    }\n\n    uint internal constant PRECISION = 10 ** 18;\n\n    // default snx staking contract implementation\n    mapping(address => uint) public rewardRate;\n    mapping(address => uint) public periodFinish;\n    mapping(address => uint) public lastUpdateTime;\n    mapping(address => uint) public rewardPerTokenStored;\n\n    mapping(address => mapping(address => uint)) public lastEarn;\n    mapping(address => mapping(address => uint)) public userRewardPerTokenStored;\n\n    mapping(address => uint) public tokenIds;\n\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n\n    address[] public rewards;\n    mapping(address => bool) public isReward;\n\n    /// @notice A checkpoint for marking balance\n    struct Checkpoint {\n        uint timestamp;\n        uint balanceOf;\n        bool voted;\n    }\n\n    /// @notice A checkpoint for marking reward rate\n    struct RewardPerTokenCheckpoint {\n        uint timestamp;\n        uint rewardPerToken;\n    }\n\n    /// @notice A checkpoint for marking supply\n    struct SupplyCheckpoint {\n        uint timestamp;\n        uint supply;\n    }\n\n    /// @notice A record of balance checkpoints for each account, by index\n    mapping (address => mapping (uint => Checkpoint)) public checkpoints;\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint) public numCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (uint => SupplyCheckpoint) public supplyCheckpoints;\n    /// @notice The number of checkpoints\n    uint public supplyNumCheckpoints;\n    /// @notice A record of balance checkpoints for each token, by index\n    mapping (address => mapping (uint => RewardPerTokenCheckpoint)) public rewardPerTokenCheckpoints;\n    /// @notice The number of checkpoints for each token\n    mapping (address => uint) public rewardPerTokenNumCheckpoints;\n\n    uint public fees0;\n    uint public fees1;\n\n    event Deposit(address indexed from, uint tokenId, uint amount);\n    event Withdraw(address indexed from, uint tokenId, uint amount);\n    event NotifyReward(address indexed from, address indexed reward, uint amount);\n    event ClaimFees(address indexed from, uint claimed0, uint claimed1);\n    event ClaimRewards(address indexed from, address indexed reward, uint amount);\n\n    constructor(address _stake, address _bribe, address  __ve, address _voter, bool _isForPair) {\n        stake = _stake;\n        bribe = _bribe;\n        _ve = __ve;\n        voter = _voter;\n\n        factory = msg.sender;\n\n        IBribe(bribe).setGauge(address(this));\n        address _token = IVotingEscrow(_ve).token();\n        IBribe(bribe).addRewardToken(_token);\n        isReward[_token] = true;\n        rewards.push(_token);\n\n        isForPair = _isForPair;\n        if (isForPair) {\n            (address _token0, address _token1) = IPair(stake).tokens();\n            IBribe(bribe).addRewardToken(_token0);\n            isReward[_token0] = true;\n            rewards.push(_token0);\n            IBribe(bribe).addRewardToken(_token1);\n            isReward[_token1] = true;\n            rewards.push(_token1);\n        }\n    }\n\n    // simple re-entrancy check\n    uint internal _unlocked = 1;\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    function claimFees() external lock returns (uint claimed0, uint claimed1) {\n        return _claimFees();\n    }\n\n    function _claimFees() internal returns (uint claimed0, uint claimed1) {\n        if (!isForPair) {\n            return (0, 0);\n        }\n        (claimed0, claimed1) = IPair(stake).claimFees();\n        if (claimed0 > 0 || claimed1 > 0) {\n            uint _fees0 = fees0 + claimed0;\n            uint _fees1 = fees1 + claimed1;\n            (address _token0, address _token1) = IPair(stake).tokens();\n            if (_fees0 / DURATION > 0) {\n                fees0 = 0;\n                _safeApprove(_token0, bribe, _fees0);\n                IBribe(bribe).notifyRewardAmount(_token0, _fees0);\n            } else {\n                fees0 = _fees0;\n            }\n            if (_fees1 / DURATION > 0) {\n                fees1 = 0;\n                _safeApprove(_token1, bribe, _fees1);\n                IBribe(bribe).notifyRewardAmount(_token1, _fees1);\n            } else {\n                fees1 = _fees1;\n            }\n\n            emit ClaimFees(msg.sender, claimed0, claimed1);\n        }\n    }\n\n    function getVotingStage(uint timestamp) public pure returns (VotingStage) {\n        uint modTime = timestamp % (7 days);\n        if (modTime < BRIBE_LAG) {\n            return VotingStage.BribesPhase;\n        } else if (modTime > (BRIBE_LAG + DURATION)) {\n            return VotingStage.RewardsPhase;\n        }\n        return VotingStage.VotesPhase;\n    }\n\n    function deliverBribes() external lock {\n        require(msg.sender == voter);\n        IBribe sb = IBribe(bribe);\n        uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;\n        uint numRewards = sb.rewardsListLength();\n\n        for (uint i = 0; i < numRewards; i++) {\n            address token = sb.rewards(i);\n            uint epochRewards = sb.deliverReward(token, bribeStart);\n            if (epochRewards > 0) {"
    }
  ]
}