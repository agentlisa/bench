{
  "Title": "[Gâ€‘23] Use assembly to emit events",
  "Content": "\nWe can use assembly to emit events efficiently by utilizing scratch space and the free memory pointer. This will allow us to potentially avoid memory expansion costs. Note: In order to do this optimization safely, we will need to cache and restore the free memory pointer.\n\nFor example, for a generic emit event for `eventSentAmountExample`:\n```\n // uint256 id, uint256 value, uint256 amount\nemit eventSentAmountExample(id, value, amount);\n```\n\nWe can use the following assembly emit events:\n```\n   assembly {\n            let memptr := mload(0x40)\n            mstore(0x00, calldataload(0x44))\n            mstore(0x20, calldataload(0xa4))\n            mstore(0x40, amount)\n            log1(\n                0x00,\n                0x60,\n                // keccak256(\"eventSentAmountExample(uint256,uint256,uint256)\")\n                0xa622cf392588fbf2cd020ff96b2f4ebd9c76d7a4bc7f3e6b2f18012312e76bc3\n            )\n            mstore(0x40, memptr)\n        }\n```        \n```solidity\nFile: /contracts/custom/OwnableUnset.sol\n72   emit OwnershipTransferred(oldOwner, newOwner);\n```\nhttps://github.com/ERC725Alliance/ERC725/blob/v5.1.0/implementations/contracts/custom/OwnableUnset.sol#L72\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-lukso",
  "Code": [
    {
      "filename": "implementations/contracts/custom/OwnableUnset.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OwnableUnset\n * @dev modified version of OpenZeppelin implementation, where:\n * - _setOwner(address) function is internal, so this function can be used in constructor\n * of contracts implementation (instead of using transferOwnership(address)\n * - the contract does not inherit from Context contract\n */\nabstract contract OwnableUnset {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Changes the owner if `newOwner` and oldOwner are different\n     * This pattern is useful in inheritance.\n     */\n    function _setOwner(address newOwner) internal virtual {\n        if (newOwner != owner()) {\n            address oldOwner = _owner;\n            _owner = newOwner;\n            emit OwnershipTransferred(oldOwner, newOwner);\n        }\n    }\n}"
    }
  ]
}