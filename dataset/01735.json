{
  "Title": "M-12: Accounts will not be liquidated when they are meant to.",
  "Content": "# Issue M-12: Accounts will not be liquidated when they are meant to. \n\nSource: https://github.com/sherlock-audit/2023-05-perennial-judging/issues/132 \n\n## Found by \n0xGoodess, Emmanuel, mstpr-brainbot, simon135\n## Summary\nIn the case that the totalMaintenance*liquidationFee is higher than the account's totalCollateral, liquidators are paid the totalCollateral. I think one of the reasons for this is to avoid the case where liquidating an account would attempt to debit fees that is greater than the collateral balance\nThe problem is that, the value of totalCollateral used as fee is slightly higher value than the current collateral balance, which means that in such cases, attempts to liquidate the account would revert due to underflow errors.\n\n## Vulnerability Detail\nHere is the `liquidate` function:\n```solidity\nfunction liquidate(\n        address account,\n        IProduct product\n    ) external nonReentrant notPaused isProduct(product) settleForAccount(account, product) {\n        if (product.isLiquidating(account)) revert CollateralAccountLiquidatingError(account);\n\n        UFixed18 totalMaintenance = product.maintenance(account); maintenance?\n        UFixed18 totalCollateral = collateral(account, product); \n\n        if (!totalMaintenance.gt(totalCollateral))\n            revert CollateralCantLiquidate(totalMaintenance, totalCollateral);\n\n        product.closeAll(account);\n\n        // claim fee\n        UFixed18 liquidationFee = controller().liquidationFee();\n      \n        UFixed18 collateralForFee = UFixed18Lib.max(totalMaintenance, controller().minCollateral()); \n        UFixed18 fee = UFixed18Lib.min(totalCollateral, collateralForFee.mul(liquidationFee)); \n\n        _products[product].debitAccount(account, fee); \n        token.push(msg.sender, fee);\n\n        emit Liquidation(account, product, msg.sender, fee);\n    }\n```\n`fee=min(totalCollateral,collateralForFee*liquidationFee)`\nBut the PROBLEM is, the value of totalCollateral is fetched before calling `product.closeAll`, and `product.closeAll` debits the closePosition fee from the collateral balance. So there is an attempt to debit `totalCollateral`, when the current collateral balance of the account is `totalCollateral`-closePositionFees\nThis allows the following:\n- There is an ETH-long market with following configs:\n    - maintenance=5%\n    - minCollateral=100USDC\n    - liquidationFee=20%\n    - ETH price=$1000\n- User uses 500USDC to open $10000(10ETH) position\n- Price of ETH spikes up to $6000\n- Required maintenance= 60000*5%=$3000 which is higher than account's collateral balance(500USDC), therefore account should be liquidated\n- A watcher attempts to liquidate the account which does the following:\n    - totalCollateral=500USDC\n    - `product.closeAll` closes the position and debits a makerFee of 10USDC\n    - current collateral balance=490USDC\n    - collateralForFee=totalMaintenance=$3000\n    - fee=min(500,3000*20%)=500\n    - `_products[product].debitAccount(account,fee)` attempts to subtract 500 from 490 which would revert due to underflow\n    - account does not get liquidated\n- Now, User is not liquidated even when he is using 500USD to control a $60000 position at 120x leverage(whereas, maxLeverage=20x)\n\nNOTE: This would happen when the market token's price increases by (1/liquidationFee)x. In the above example, price of ETH increased by 6x (from 1000USD to 6000USD) which is greater than 5(1/20%)\n\n## Impact\nA User's position will not be liquidated even when his collateral balance falls WELL below the required maintenance. I believe this is of HIGH impact because this scenario is very likely to happen, and when it does, the protocol will be greatly affected because a lot of users will be trading abnormally high leveraged positions without getting liquidated.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/collateral/Collateral.sol#L118\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/collateral/Collateral.sol#L123\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/collateral/Collateral.sol#L129-L132\n\n## Tool used\n\nManual Review\n\n## Recommendation\n`totalCollateral` that would be paid to liquidator should be refetched after `product.closeAll` is called to get the current collateral balance after closePositionFees have been debited.\n\n\n\n## Discussion\n\n**KenzoAgada**\n\nSee the `Recommendation` section above for the root of the issue.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/79",
  "Code": [
    {
      "filename": "perennial-mono/packages/perennial/contracts/collateral/Collateral.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\nimport \"@equilibria/root/control/unstructured/UInitializable.sol\";\nimport \"@equilibria/root/control/unstructured/UReentrancyGuard.sol\";\nimport \"../interfaces/ICollateral.sol\";\nimport \"./types/OptimisticLedger.sol\";\nimport \"../controller/UControllerProvider.sol\";\n\n/**\n * @title Collateral\n * @notice Manages logic and state for all collateral accounts in the protocol.\n */\ncontract Collateral is ICollateral, UInitializable, UControllerProvider, UReentrancyGuard {\n    /// @dev ERC20 stablecoin for collateral\n    Token18 public immutable token;\n\n    /// @dev Per product collateral state\n    mapping(IProduct => OptimisticLedger) private _products;\n\n    /// @dev Protocol and product fees collected, but not yet claimed\n    mapping(address => UFixed18) public fees;\n\n    /**\n     * @notice Initializes the immutable contract state\n     * @dev Called at implementation instantiate and constant for that implementation.\n     * @param token_ Collateral ERC20 stablecoin address\n     */\n    constructor(Token18 token_) {\n        token = token_;\n    }\n\n    /**\n     * @notice Initializes the contract state\n     * @dev Must be called atomically as part of the upgradeable proxy deployment to\n     *      avoid front-running\n     * @param controller_ Factory contract address\n     */\n    function initialize(IController controller_) external initializer(1) {\n        __UControllerProvider__initialize(controller_);\n        __UReentrancyGuard__initialize();\n    }\n\n    /**\n     * @notice Deposits `amount` collateral from `msg.sender` to `account`'s `product`\n     *         account\n     * @param account Account to deposit the collateral for\n     * @param product Product to credit the collateral to\n     * @param amount Amount of collateral to deposit\n     */\n    function depositTo(address account, IProduct product, UFixed18 amount)\n    external\n    nonReentrant\n    notPaused\n    notZeroAddress(account)\n    isProduct(product)\n    collateralInvariant(account, product)\n    {\n        _products[product].creditAccount(account, amount);\n        token.pull(msg.sender, amount);\n\n        emit Deposit(account, product, amount);\n    }\n\n    /**\n     * @notice Withdraws `amount` collateral from `msg.sender`'s `product` account\n     *         and sends it to `receiver`\n     * @param receiver Account to withdraw the collateral to\n     * @param product Product to withdraw the collateral from\n     * @param amount Amount of collateral to withdraw\n     */\n    function withdrawTo(address receiver, IProduct product, UFixed18 amount) external {\n        withdrawFrom(msg.sender, receiver, product, amount);\n    }\n\n    /**\n     * @notice Withdraws `amount` collateral from `account`'s `product` account\n     *         and sends it to `receiver`\n     * @param account Account to withdraw the collateral from\n     * @param receiver Account to withdraw the collateral to\n     * @param product Product to withdraw the collateral from\n     * @param amount Amount of collateral to withdraw\n     */\n    function withdrawFrom(address account, address receiver, IProduct product, UFixed18 amount)\n    public\n    nonReentrant\n    notPaused\n    notZeroAddress(receiver)\n    isProduct(product)\n    onlyAccountOrMultiInvoker(account)\n    settleForAccount(account, product)\n    collateralInvariant(account, product)\n    maintenanceInvariant(account, product)\n    {\n        amount = amount.eq(UFixed18Lib.MAX) ? collateral(account, product) : amount;\n        _products[product].debitAccount(account, amount);\n        token.push(receiver, amount);\n\n        emit Withdrawal(account, product, amount);\n    }\n\n    /**\n     * @notice Liquidates `account`'s `product` collateral account\n     * @dev Account must be under-collateralized, fee returned immediately to `msg.sender`\n     * @param account Account to liquidate\n     * @param product Product to liquidate for\n     */\n    function liquidate(address account, IProduct product)\n    external\n    nonReentrant\n    notPaused\n    isProduct(product)\n    settleForAccount(account, product)\n    {\n        if (product.isLiquidating(account)) revert CollateralAccountLiquidatingError(account);\n\n        UFixed18 totalMaintenance = product.maintenance(account);\n        UFixed18 totalCollateral = collateral(account, product);\n\n        if (!totalMaintenance.gt(totalCollateral))\n            revert CollateralCantLiquidate(totalMaintenance, totalCollateral);\n\n        product.closeAll(account);\n\n        // claim fee\n        UFixed18 liquidationFee = controller().liquidationFee();\n        // If maintenance is less than minCollateral, use minCollateral for fee amount\n        UFixed18 collateralForFee = UFixed18Lib.max(totalMaintenance, controller().minCollateral());\n        UFixed18 fee = UFixed18Lib.min(totalCollateral, collateralForFee.mul(liquidationFee));\n\n        _products[product].debitAccount(account, fee);\n        token.push(msg.sender, fee);\n\n        emit Liquidation(account, product, msg.sender, fee);\n    }\n\n    /**\n     * @notice Credits `amount` to `account`'s collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel.\n     *      Moves collateral within a product, any collateral leaving the product due to\n     *      fees has already been accounted for in the settleProduct flywheel.\n     *      Debits in excess of the account balance get recorded as shortfall, and can be\n     *      resolved by the product owner as needed.\n     * @param account Account to credit\n     * @param amount Amount to credit the account (can be negative)\n     */\n    function settleAccount(address account, Fixed18 amount) external onlyProduct {\n        IProduct product = IProduct(msg.sender);\n\n        UFixed18 newShortfall = _products[product].settleAccount(account, amount);\n\n        emit AccountSettle(product, account, amount, newShortfall);\n    }\n\n    /**\n     * @notice Debits `amount` from product's total collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel\n     *      Removes collateral from the product as fees.\n     * @param amount Amount to debit from the account\n     */\n    function settleProduct(UFixed18 amount) external onlyProduct {\n        (IProduct product, IController controller) = (IProduct(msg.sender), controller());\n\n        address protocolTreasury = controller.treasury();\n        address productTreasury = controller.treasury(product);\n\n        UFixed18 protocolFee = amount.mul(controller.protocolFee());\n        UFixed18 productFee = amount.sub(protocolFee);\n\n        _products[product].debit(amount);\n        fees[protocolTreasury] = fees[protocolTreasury].add(protocolFee);\n        fees[productTreasury] = fees[productTreasury].add(productFee);\n\n        emit ProductSettle(product, protocolFee, productFee);\n    }\n\n    /**\n     * @notice Returns the balance of `account`'s `product` collateral account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return The balance of the collateral account\n     */\n    function collateral(address account, IProduct product) public view returns (UFixed18) {\n        return _products[product].balances[account];\n    }\n\n    /**\n     * @notice Returns the total balance of `product`'s collateral\n     * @param product Product to return for\n     * @return The total balance of collateral in the product\n     */\n    function collateral(IProduct product) external view returns (UFixed18) {\n        return _products[product].total;\n    }\n\n    /**\n     * @notice Returns the current shortfall of `product`'s collateral\n     * @param product Product to return for\n     * @return The current shortfall of the product\n     */\n    function shortfall(IProduct product) external view returns (UFixed18) {\n        return _products[product].shortfall;\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatable(address account, IProduct product) external view returns (bool) {\n        if (product.isLiquidating(account)) return false;\n\n        return product.maintenance(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     *         after the next oracle version settlement\n     * @dev Takes into account the current pre-position on the account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatableNext(address account, IProduct product) external view returns (bool) {\n        return product.maintenanceNext(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Injects additional collateral into a product to resolve shortfall\n     * @dev Shortfall is a measure of settled insolvency in the market\n     *      This hook can be used by the product owner or an insurance fund to re-capitalize an insolvent market\n     * @param product Product to resolve shortfall for\n     * @param amount Amount of shortfall to resolve\n     */\n    function resolveShortfall(IProduct product, UFixed18 amount) external isProduct(product) notPaused {\n        _products[product].resolve(amount);\n        token.pull(msg.sender, amount);\n\n        emit ShortfallResolution(product, amount);\n    }\n\n    /**\n     * @notice Claims all of `msg.sender`'s fees\n     */\n    function claimFee() external notPaused {\n        UFixed18 amount = fees[msg.sender];\n\n        fees[msg.sender] = UFixed18Lib.ZERO;\n        token.push(msg.sender, amount);\n\n        emit FeeClaim(msg.sender, amount);\n    }\n\n    /// @dev Ensure that the address is non-zero\n    modifier notZeroAddress(address account) {\n        if (account == address(0)) revert CollateralZeroAddressError();\n\n        _;\n    }\n\n    /// @dev Ensure that the user has sufficient margin for both current and next maintenance\n    modifier maintenanceInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 maintenance = product.maintenance(account);\n        UFixed18 maintenanceNext = product.maintenanceNext(account);\n\n        if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))\n            revert CollateralInsufficientCollateralError();\n    }\n\n    /// @dev Ensure that the account is either empty or above the collateral minimum\n    modifier collateralInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 accountCollateral = collateral(account, product);\n        if (!accountCollateral.isZero() && accountCollateral.lt(controller().minCollateral()))\n            revert CollateralUnderLimitError();\n    }\n\n    /// @dev Helper to fully settle an account's state\n    modifier settleForAccount(address account, IProduct product) {\n        product.settleAccount(account);\n\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-mono/packages/perennial/contracts/collateral/Collateral.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\nimport \"@equilibria/root/control/unstructured/UInitializable.sol\";\nimport \"@equilibria/root/control/unstructured/UReentrancyGuard.sol\";\nimport \"../interfaces/ICollateral.sol\";\nimport \"./types/OptimisticLedger.sol\";\nimport \"../controller/UControllerProvider.sol\";\n\n/**\n * @title Collateral\n * @notice Manages logic and state for all collateral accounts in the protocol.\n */\ncontract Collateral is ICollateral, UInitializable, UControllerProvider, UReentrancyGuard {\n    /// @dev ERC20 stablecoin for collateral\n    Token18 public immutable token;\n\n    /// @dev Per product collateral state\n    mapping(IProduct => OptimisticLedger) private _products;\n\n    /// @dev Protocol and product fees collected, but not yet claimed\n    mapping(address => UFixed18) public fees;\n\n    /**\n     * @notice Initializes the immutable contract state\n     * @dev Called at implementation instantiate and constant for that implementation.\n     * @param token_ Collateral ERC20 stablecoin address\n     */\n    constructor(Token18 token_) {\n        token = token_;\n    }\n\n    /**\n     * @notice Initializes the contract state\n     * @dev Must be called atomically as part of the upgradeable proxy deployment to\n     *      avoid front-running\n     * @param controller_ Factory contract address\n     */\n    function initialize(IController controller_) external initializer(1) {\n        __UControllerProvider__initialize(controller_);\n        __UReentrancyGuard__initialize();\n    }\n\n    /**\n     * @notice Deposits `amount` collateral from `msg.sender` to `account`'s `product`\n     *         account\n     * @param account Account to deposit the collateral for\n     * @param product Product to credit the collateral to\n     * @param amount Amount of collateral to deposit\n     */\n    function depositTo(address account, IProduct product, UFixed18 amount)\n    external\n    nonReentrant\n    notPaused\n    notZeroAddress(account)\n    isProduct(product)\n    collateralInvariant(account, product)\n    {\n        _products[product].creditAccount(account, amount);\n        token.pull(msg.sender, amount);\n\n        emit Deposit(account, product, amount);\n    }\n\n    /**\n     * @notice Withdraws `amount` collateral from `msg.sender`'s `product` account\n     *         and sends it to `receiver`\n     * @param receiver Account to withdraw the collateral to\n     * @param product Product to withdraw the collateral from\n     * @param amount Amount of collateral to withdraw\n     */\n    function withdrawTo(address receiver, IProduct product, UFixed18 amount) external {\n        withdrawFrom(msg.sender, receiver, product, amount);\n    }\n\n    /**\n     * @notice Withdraws `amount` collateral from `account`'s `product` account\n     *         and sends it to `receiver`\n     * @param account Account to withdraw the collateral from\n     * @param receiver Account to withdraw the collateral to\n     * @param product Product to withdraw the collateral from\n     * @param amount Amount of collateral to withdraw\n     */\n    function withdrawFrom(address account, address receiver, IProduct product, UFixed18 amount)\n    public\n    nonReentrant\n    notPaused\n    notZeroAddress(receiver)\n    isProduct(product)\n    onlyAccountOrMultiInvoker(account)\n    settleForAccount(account, product)\n    collateralInvariant(account, product)\n    maintenanceInvariant(account, product)\n    {\n        amount = amount.eq(UFixed18Lib.MAX) ? collateral(account, product) : amount;\n        _products[product].debitAccount(account, amount);\n        token.push(receiver, amount);\n\n        emit Withdrawal(account, product, amount);\n    }\n\n    /**\n     * @notice Liquidates `account`'s `product` collateral account\n     * @dev Account must be under-collateralized, fee returned immediately to `msg.sender`\n     * @param account Account to liquidate\n     * @param product Product to liquidate for\n     */\n    function liquidate(address account, IProduct product)\n    external\n    nonReentrant\n    notPaused\n    isProduct(product)\n    settleForAccount(account, product)\n    {\n        if (product.isLiquidating(account)) revert CollateralAccountLiquidatingError(account);\n\n        UFixed18 totalMaintenance = product.maintenance(account);\n        UFixed18 totalCollateral = collateral(account, product);\n\n        if (!totalMaintenance.gt(totalCollateral))\n            revert CollateralCantLiquidate(totalMaintenance, totalCollateral);\n\n        product.closeAll(account);\n\n        // claim fee\n        UFixed18 liquidationFee = controller().liquidationFee();\n        // If maintenance is less than minCollateral, use minCollateral for fee amount\n        UFixed18 collateralForFee = UFixed18Lib.max(totalMaintenance, controller().minCollateral());\n        UFixed18 fee = UFixed18Lib.min(totalCollateral, collateralForFee.mul(liquidationFee));\n\n        _products[product].debitAccount(account, fee);\n        token.push(msg.sender, fee);\n\n        emit Liquidation(account, product, msg.sender, fee);\n    }\n\n    /**\n     * @notice Credits `amount` to `account`'s collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel.\n     *      Moves collateral within a product, any collateral leaving the product due to\n     *      fees has already been accounted for in the settleProduct flywheel.\n     *      Debits in excess of the account balance get recorded as shortfall, and can be\n     *      resolved by the product owner as needed.\n     * @param account Account to credit\n     * @param amount Amount to credit the account (can be negative)\n     */\n    function settleAccount(address account, Fixed18 amount) external onlyProduct {\n        IProduct product = IProduct(msg.sender);\n\n        UFixed18 newShortfall = _products[product].settleAccount(account, amount);\n\n        emit AccountSettle(product, account, amount, newShortfall);\n    }\n\n    /**\n     * @notice Debits `amount` from product's total collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel\n     *      Removes collateral from the product as fees.\n     * @param amount Amount to debit from the account\n     */\n    function settleProduct(UFixed18 amount) external onlyProduct {\n        (IProduct product, IController controller) = (IProduct(msg.sender), controller());\n\n        address protocolTreasury = controller.treasury();\n        address productTreasury = controller.treasury(product);\n\n        UFixed18 protocolFee = amount.mul(controller.protocolFee());\n        UFixed18 productFee = amount.sub(protocolFee);\n\n        _products[product].debit(amount);\n        fees[protocolTreasury] = fees[protocolTreasury].add(protocolFee);\n        fees[productTreasury] = fees[productTreasury].add(productFee);\n\n        emit ProductSettle(product, protocolFee, productFee);\n    }\n\n    /**\n     * @notice Returns the balance of `account`'s `product` collateral account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return The balance of the collateral account\n     */\n    function collateral(address account, IProduct product) public view returns (UFixed18) {\n        return _products[product].balances[account];\n    }\n\n    /**\n     * @notice Returns the total balance of `product`'s collateral\n     * @param product Product to return for\n     * @return The total balance of collateral in the product\n     */\n    function collateral(IProduct product) external view returns (UFixed18) {\n        return _products[product].total;\n    }\n\n    /**\n     * @notice Returns the current shortfall of `product`'s collateral\n     * @param product Product to return for\n     * @return The current shortfall of the product\n     */\n    function shortfall(IProduct product) external view returns (UFixed18) {\n        return _products[product].shortfall;\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatable(address account, IProduct product) external view returns (bool) {\n        if (product.isLiquidating(account)) return false;\n\n        return product.maintenance(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     *         after the next oracle version settlement\n     * @dev Takes into account the current pre-position on the account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatableNext(address account, IProduct product) external view returns (bool) {\n        return product.maintenanceNext(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Injects additional collateral into a product to resolve shortfall\n     * @dev Shortfall is a measure of settled insolvency in the market\n     *      This hook can be used by the product owner or an insurance fund to re-capitalize an insolvent market\n     * @param product Product to resolve shortfall for\n     * @param amount Amount of shortfall to resolve\n     */\n    function resolveShortfall(IProduct product, UFixed18 amount) external isProduct(product) notPaused {\n        _products[product].resolve(amount);\n        token.pull(msg.sender, amount);\n\n        emit ShortfallResolution(product, amount);\n    }\n\n    /**\n     * @notice Claims all of `msg.sender`'s fees\n     */\n    function claimFee() external notPaused {\n        UFixed18 amount = fees[msg.sender];\n\n        fees[msg.sender] = UFixed18Lib.ZERO;\n        token.push(msg.sender, amount);\n\n        emit FeeClaim(msg.sender, amount);\n    }\n\n    /// @dev Ensure that the address is non-zero\n    modifier notZeroAddress(address account) {\n        if (account == address(0)) revert CollateralZeroAddressError();\n\n        _;\n    }\n\n    /// @dev Ensure that the user has sufficient margin for both current and next maintenance\n    modifier maintenanceInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 maintenance = product.maintenance(account);\n        UFixed18 maintenanceNext = product.maintenanceNext(account);\n\n        if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))\n            revert CollateralInsufficientCollateralError();\n    }\n\n    /// @dev Ensure that the account is either empty or above the collateral minimum\n    modifier collateralInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 accountCollateral = collateral(account, product);\n        if (!accountCollateral.isZero() && accountCollateral.lt(controller().minCollateral()))\n            revert CollateralUnderLimitError();\n    }\n\n    /// @dev Helper to fully settle an account's state\n    modifier settleForAccount(address account, IProduct product) {\n        product.settleAccount(account);\n\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-mono/packages/perennial/contracts/collateral/Collateral.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\nimport \"@equilibria/root/control/unstructured/UInitializable.sol\";\nimport \"@equilibria/root/control/unstructured/UReentrancyGuard.sol\";\nimport \"../interfaces/ICollateral.sol\";\nimport \"./types/OptimisticLedger.sol\";\nimport \"../controller/UControllerProvider.sol\";\n\n/**\n * @title Collateral\n * @notice Manages logic and state for all collateral accounts in the protocol.\n */\ncontract Collateral is ICollateral, UInitializable, UControllerProvider, UReentrancyGuard {\n    /// @dev ERC20 stablecoin for collateral\n    Token18 public immutable token;\n\n    /// @dev Per product collateral state\n    mapping(IProduct => OptimisticLedger) private _products;\n\n    /// @dev Protocol and product fees collected, but not yet claimed\n    mapping(address => UFixed18) public fees;\n\n    /**\n     * @notice Initializes the immutable contract state\n     * @dev Called at implementation instantiate and constant for that implementation.\n     * @param token_ Collateral ERC20 stablecoin address\n     */\n    constructor(Token18 token_) {\n        token = token_;\n    }\n\n    /**\n     * @notice Initializes the contract state\n     * @dev Must be called atomically as part of the upgradeable proxy deployment to\n     *      avoid front-running\n     * @param controller_ Factory contract address\n     */\n    function initialize(IController controller_) external initializer(1) {\n        __UControllerProvider__initialize(controller_);\n        __UReentrancyGuard__initialize();\n    }\n\n    /**\n     * @notice Deposits `amount` collateral from `msg.sender` to `account`'s `product`\n     *         account\n     * @param account Account to deposit the collateral for\n     * @param product Product to credit the collateral to\n     * @param amount Amount of collateral to deposit\n     */\n    function depositTo(address account, IProduct product, UFixed18 amount)\n    external\n    nonReentrant\n    notPaused\n    notZeroAddress(account)\n    isProduct(product)\n    collateralInvariant(account, product)\n    {\n        _products[product].creditAccount(account, amount);\n        token.pull(msg.sender, amount);\n\n        emit Deposit(account, product, amount);\n    }\n\n    /**\n     * @notice Withdraws `amount` collateral from `msg.sender`'s `product` account\n     *         and sends it to `receiver`\n     * @param receiver Account to withdraw the collateral to\n     * @param product Product to withdraw the collateral from\n     * @param amount Amount of collateral to withdraw\n     */\n    function withdrawTo(address receiver, IProduct product, UFixed18 amount) external {\n        withdrawFrom(msg.sender, receiver, product, amount);\n    }\n\n    /**\n     * @notice Withdraws `amount` collateral from `account`'s `product` account\n     *         and sends it to `receiver`\n     * @param account Account to withdraw the collateral from\n     * @param receiver Account to withdraw the collateral to\n     * @param product Product to withdraw the collateral from\n     * @param amount Amount of collateral to withdraw\n     */\n    function withdrawFrom(address account, address receiver, IProduct product, UFixed18 amount)\n    public\n    nonReentrant\n    notPaused\n    notZeroAddress(receiver)\n    isProduct(product)\n    onlyAccountOrMultiInvoker(account)\n    settleForAccount(account, product)\n    collateralInvariant(account, product)\n    maintenanceInvariant(account, product)\n    {\n        amount = amount.eq(UFixed18Lib.MAX) ? collateral(account, product) : amount;\n        _products[product].debitAccount(account, amount);\n        token.push(receiver, amount);\n\n        emit Withdrawal(account, product, amount);\n    }\n\n    /**\n     * @notice Liquidates `account`'s `product` collateral account\n     * @dev Account must be under-collateralized, fee returned immediately to `msg.sender`\n     * @param account Account to liquidate\n     * @param product Product to liquidate for\n     */\n    function liquidate(address account, IProduct product)\n    external\n    nonReentrant\n    notPaused\n    isProduct(product)\n    settleForAccount(account, product)\n    {\n        if (product.isLiquidating(account)) revert CollateralAccountLiquidatingError(account);\n\n        UFixed18 totalMaintenance = product.maintenance(account);\n        UFixed18 totalCollateral = collateral(account, product);\n\n        if (!totalMaintenance.gt(totalCollateral))\n            revert CollateralCantLiquidate(totalMaintenance, totalCollateral);\n\n        product.closeAll(account);\n\n        // claim fee\n        UFixed18 liquidationFee = controller().liquidationFee();\n        // If maintenance is less than minCollateral, use minCollateral for fee amount\n        UFixed18 collateralForFee = UFixed18Lib.max(totalMaintenance, controller().minCollateral());\n        UFixed18 fee = UFixed18Lib.min(totalCollateral, collateralForFee.mul(liquidationFee));\n\n        _products[product].debitAccount(account, fee);\n        token.push(msg.sender, fee);\n\n        emit Liquidation(account, product, msg.sender, fee);\n    }\n\n    /**\n     * @notice Credits `amount` to `account`'s collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel.\n     *      Moves collateral within a product, any collateral leaving the product due to\n     *      fees has already been accounted for in the settleProduct flywheel.\n     *      Debits in excess of the account balance get recorded as shortfall, and can be\n     *      resolved by the product owner as needed.\n     * @param account Account to credit\n     * @param amount Amount to credit the account (can be negative)\n     */\n    function settleAccount(address account, Fixed18 amount) external onlyProduct {\n        IProduct product = IProduct(msg.sender);\n\n        UFixed18 newShortfall = _products[product].settleAccount(account, amount);\n\n        emit AccountSettle(product, account, amount, newShortfall);\n    }\n\n    /**\n     * @notice Debits `amount` from product's total collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel\n     *      Removes collateral from the product as fees.\n     * @param amount Amount to debit from the account\n     */\n    function settleProduct(UFixed18 amount) external onlyProduct {\n        (IProduct product, IController controller) = (IProduct(msg.sender), controller());\n\n        address protocolTreasury = controller.treasury();\n        address productTreasury = controller.treasury(product);\n\n        UFixed18 protocolFee = amount.mul(controller.protocolFee());\n        UFixed18 productFee = amount.sub(protocolFee);\n\n        _products[product].debit(amount);\n        fees[protocolTreasury] = fees[protocolTreasury].add(protocolFee);\n        fees[productTreasury] = fees[productTreasury].add(productFee);\n\n        emit ProductSettle(product, protocolFee, productFee);\n    }\n\n    /**\n     * @notice Returns the balance of `account`'s `product` collateral account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return The balance of the collateral account\n     */\n    function collateral(address account, IProduct product) public view returns (UFixed18) {\n        return _products[product].balances[account];\n    }\n\n    /**\n     * @notice Returns the total balance of `product`'s collateral\n     * @param product Product to return for\n     * @return The total balance of collateral in the product\n     */\n    function collateral(IProduct product) external view returns (UFixed18) {\n        return _products[product].total;\n    }\n\n    /**\n     * @notice Returns the current shortfall of `product`'s collateral\n     * @param product Product to return for\n     * @return The current shortfall of the product\n     */\n    function shortfall(IProduct product) external view returns (UFixed18) {\n        return _products[product].shortfall;\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatable(address account, IProduct product) external view returns (bool) {\n        if (product.isLiquidating(account)) return false;\n\n        return product.maintenance(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     *         after the next oracle version settlement\n     * @dev Takes into account the current pre-position on the account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatableNext(address account, IProduct product) external view returns (bool) {\n        return product.maintenanceNext(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Injects additional collateral into a product to resolve shortfall\n     * @dev Shortfall is a measure of settled insolvency in the market\n     *      This hook can be used by the product owner or an insurance fund to re-capitalize an insolvent market\n     * @param product Product to resolve shortfall for\n     * @param amount Amount of shortfall to resolve\n     */\n    function resolveShortfall(IProduct product, UFixed18 amount) external isProduct(product) notPaused {\n        _products[product].resolve(amount);\n        token.pull(msg.sender, amount);\n\n        emit ShortfallResolution(product, amount);\n    }\n\n    /**\n     * @notice Claims all of `msg.sender`'s fees\n     */\n    function claimFee() external notPaused {\n        UFixed18 amount = fees[msg.sender];\n\n        fees[msg.sender] = UFixed18Lib.ZERO;\n        token.push(msg.sender, amount);\n\n        emit FeeClaim(msg.sender, amount);\n    }\n\n    /// @dev Ensure that the address is non-zero\n    modifier notZeroAddress(address account) {\n        if (account == address(0)) revert CollateralZeroAddressError();\n\n        _;\n    }\n\n    /// @dev Ensure that the user has sufficient margin for both current and next maintenance\n    modifier maintenanceInvariant(address account, IProduct product) {\n        _;\n\n        UFixed18 maintenance = product.maintenance(account);\n        UFixed18 maintenanceNext = product.maintenanceNext(account);\n\n        if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))\n            revert CollateralInsufficientC"
    }
  ]
}