{
  "Title": "[L01] Using .call for init is not flexible",
  "Content": "When [deploying another `ACOToken`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L235) using `ACOFactory.sol`, after [a minimal proxy is deployed](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L239-L245), the low-level [`call` function is used](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L246) to call [`init`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L177) for the proxy. The [`_acoTokenInitializeError`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L257) function is used to [return any error message from the proxy](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L247).\n\n\nWhile such a method of calling `init` makes sense when `ACOToken.sol`‘s `init` function may be [changed](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L178), we noticed the presence of the [`_getAcoTokenInitData`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L212-L228) function, which is used to format data for passing into the `init` function [in the `createAcoToken`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L124) function. This is the only method which calls `_deployAcoToken`, and is therefore the only way to deploy a new `ACOToken` proxy instance.\n\n\nIf any future changes are made to the parameters passed into the `init` function of `ACOToken.sol`, a modified version of `ACOFactory.sol` will have to be deployed, as the `_getAcoTokenInitData` function will no longer be valid. So, the use of the low-level `call` function is unfortunately not any more useful than a direct call to the `init` function, since the flexibility of passing arbitrary data is lost. However, by implementing extra code to [format the `init` input data](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L219-L226) and [handle any errors](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L258-L267), a larger surface for error is created.\n\n\nConsider removing [`_getAcoTokenInitData`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L212) and [`_acoTokenInitializeError`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L257), and replacing the low-level `call` with a direct call to the proxy’s `init` function. This will require importing [`IACOToken.sol`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/interfaces/IACOToken.sol) and adding the [`init`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L177-L185) function to the interface. All parameters for `init` can then be passed directly to [`_deployAcoToken`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L235). By doing so, the code’s readability and auditability will be greatly increased, and the surface for error will be made significantly smaller.\n\n\n**Update:** *Fixed in [pull request #13](https://github.com/AuctusProject/aco/pull/13).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "smart-contracts/contracts/core/ACOFactory.sol",
      "content": "pragma solidity ^0.6.6;\n\nimport \"../libs/Address.sol\";\nimport \"../libs/BokkyPooBahsDateTimeLibrary.sol\";\nimport \"../libs/Strings.sol\";\n\n/**\n * @title ACOFactory\n * @dev The contract is the implementation for the ACOProxy.\n */\ncontract ACOFactory {\n    \n    /**\n     * @dev Emitted when the factory admin address has been changed.\n     * @param previousFactoryAdmin Address of the previous factory admin.\n     * @param newFactoryAdmin Address of the new factory admin.\n     */\n    event SetFactoryAdmin(address previousFactoryAdmin, address newFactoryAdmin);\n    \n    /**\n     * @dev Emitted when the ACO token implementation has been changed.\n     * @param previousAcoTokenImplementation Address of the previous ACO token implementation.\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\n     */\n    event SetAcoTokenImplementation(address previousAcoTokenImplementation, address newAcoTokenImplementation);\n    \n    /**\n     * @dev Emitted when the ACO fee has been changed.\n     * @param previousAcoFee Value of the previous ACO fee.\n     * @param newAcoFee Value of the new ACO fee.\n     */\n    event SetAcoFee(uint256 previousAcoFee, uint256 newAcoFee);\n    \n    /**\n     * @dev Emitted when the ACO fee destination address has been changed.\n     * @param previousAcoFeeDestination Address of the previous ACO fee destination.\n     * @param newAcoFeeDestination Address of the new ACO fee destination.\n     */\n    event SetAcoFeeDestination(address previousAcoFeeDestination, address newAcoFeeDestination);\n    \n    /**\n     * @dev Emitted when a new ACO token has been created.\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param isCall True if the type is CALL, false for PUT.\n     * @param strikePrice The strike price with the strike asset precision.\n     * @param expiryTime The UNIX time for the ACO token expiration.\n     * @param acoToken Address of the new ACO token created.\n     * @param acoTokenImplementation Address of the ACO token implementation used on creation.\n     */\n    event NewAcoToken(address indexed underlying, address indexed strikeAsset, bool indexed isCall, uint256 strikePrice, uint256 expiryTime, address acoToken, address acoTokenImplementation);\n    \n    /**\n     * @dev The ACO fee value. \n     * It is a percentage value (100000 is 100%).\n     */\n    uint256 public acoFee;\n    \n    /**\n     * @dev The factory admin address.\n     */\n    address public factoryAdmin;\n    \n    /**\n     * @dev The ACO token implementation address.\n     */\n    address public acoTokenImplementation;\n    \n    /**\n     * @dev The ACO fee destination address.\n     */\n    address public acoFeeDestination;\n    \n    /**\n     * @dev Modifier to check if the `msg.sender` is the factory admin.\n     * Only factory admin address can execute.\n     */\n    modifier onlyFactoryAdmin() {\n        require(msg.sender == factoryAdmin, \"ACOFactory::onlyFactoryAdmin\");\n        _;\n    }\n    \n    /**\n     * @dev Function to initialize the contract.\n     * It should be called through the `data` argument when creating the proxy.\n     * It must be called only once. The `assert` is to guarantee that behavior.\n     * @param _factoryAdmin Address of the factory admin.\n     * @param _acoTokenImplementation Address of the ACO token implementation.\n     * @param _acoFee Value of the ACO fee.\n     * @param _acoFeeDestination Address of the ACO fee destination.\n     */\n    function init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) public {\n        require(factoryAdmin == address(0) && acoTokenImplementation == address(0), \"ACOFactory::init: Contract already initialized.\");\n        \n        _setFactoryAdmin(_factoryAdmin);\n        _setAcoTokenImplementation(_acoTokenImplementation);\n        _setAcoFee(_acoFee);\n        _setAcoFeeDestination(_acoFeeDestination);\n    }\n\n    /**\n     * @dev Function to guarantee that the contract will not receive ether.\n     */\n    receive() external payable virtual {\n        revert();\n    }\n    \n    /**\n     * @dev Function to create a new ACO token.\n     * It deploys a minimal proxy for the ACO token implementation address. \n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param isCall Whether the ACO token is the Call type.\n     * @param strikePrice The strike price with the strike asset precision.\n     * @param expiryTime The UNIX time for the ACO token expiration.\n     */\n    function createAcoToken(\n        address underlying, \n        address strikeAsset, \n        bool isCall,\n        uint256 strikePrice, \n        uint256 expiryTime\n    ) onlyFactoryAdmin external virtual {\n        address acoToken = _deployAcoToken(_getAcoTokenInitData(underlying, strikeAsset, isCall, strikePrice, expiryTime));\n        emit NewAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoToken, acoTokenImplementation);   \n    }\n    \n    /**\n     * @dev Function to set the factory admin address.\n     * Only can be called by the factory admin.\n     * @param newFactoryAdmin Address of the new factory admin.\n     */\n    function setFactoryAdmin(address newFactoryAdmin) onlyFactoryAdmin external virtual {\n        _setFactoryAdmin(newFactoryAdmin);\n    }\n    \n    /**\n     * @dev Function to set the ACO token implementation address.\n     * Only can be called by the factory admin.\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\n     */\n    function setAcoTokenImplementation(address newAcoTokenImplementation) onlyFactoryAdmin external virtual {\n        _setAcoTokenImplementation(newAcoTokenImplementation);\n    }\n    \n    /**\n     * @dev Function to set the ACO fee.\n     * Only can be called by the factory admin.\n     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\n     */\n    function setAcoFee(uint256 newAcoFee) onlyFactoryAdmin external virtual {\n        _setAcoFee(newAcoFee);\n    }\n    \n    /**\n     * @dev Function to set the ACO destination address.\n     * Only can be called by the factory admin.\n     * @param newAcoFeeDestination Address of the new ACO destination.\n     */\n    function setAcoFeeDestination(address newAcoFeeDestination) onlyFactoryAdmin external virtual {\n        _setAcoFeeDestination(newAcoFeeDestination);\n    }\n    \n    /**\n     * @dev Internal function to set the factory admin address.\n     * @param newFactoryAdmin Address of the new factory admin.\n     */\n    function _setFactoryAdmin(address newFactoryAdmin) internal virtual {\n        require(newFactoryAdmin != address(0), \"ACOFactory::_setFactoryAdmin: Invalid factory admin\");\n        emit SetFactoryAdmin(factoryAdmin, newFactoryAdmin);\n        factoryAdmin = newFactoryAdmin;\n    }\n    \n    /**\n     * @dev Internal function to set the ACO token implementation address.\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\n     */\n    function _setAcoTokenImplementation(address newAcoTokenImplementation) internal virtual {\n        require(Address.isContract(newAcoTokenImplementation), \"ACOFactory::_setAcoTokenImplementation: Invalid ACO token implementation\");\n        emit SetAcoTokenImplementation(acoTokenImplementation, newAcoTokenImplementation);\n        acoTokenImplementation = newAcoTokenImplementation;\n    }\n    \n    /**\n     * @dev Internal function to set the ACO fee.\n     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\n     */\n    function _setAcoFee(uint256 newAcoFee) internal virtual {\n        emit SetAcoFee(acoFee, newAcoFee);\n        acoFee = newAcoFee;\n    }\n    \n    /**\n     * @dev Internal function to set the ACO destination address.\n     * @param newAcoFeeDestination Address of the new ACO destination.\n     */\n    function _setAcoFeeDestination(address newAcoFeeDestination) internal virtual {\n        require(newAcoFeeDestination != address(0), \"ACOFactory::_setAcoFeeDestination: Invalid ACO fee destination\");\n        emit SetAcoFeeDestination(acoFeeDestination, newAcoFeeDestination);\n        acoFeeDestination = newAcoFeeDestination;\n    }\n    \n    /**\n     * @dev Internal function to get the ACO token initialize data.\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param isCall True if the type is CALL, false for PUT.\n     * @param strikePrice The strike price with the strike asset precision.\n     * @param expiryTime The UNIX time for the ACO token expiration.\n     * @return ABI encoded with signature for initializing ACO token.\n     */\n    function _getAcoTokenInitData(\n        address underlying, \n        address strikeAsset, \n        bool isCall,\n        uint256 strikePrice, \n        uint256 expiryTime\n    ) internal view virtual returns(bytes memory) {\n        return abi.encodeWithSignature(\"init(address,address,bool,uint256,uint256,uint256,address)\",\n            underlying,\n            strikeAsset,\n            isCall,\n            strikePrice,\n            expiryTime,\n            acoFee,\n            acoFeeDestination\n        );\n    }\n    \n    /**\n     * @dev Internal function to deploy a minimal proxy using ACO token implementation.\n     * @param initData ABI encoded with signature for initializing the new ACO token.\n     * @return Address of the new minimal proxy deployed for the ACO token.\n     */\n    function _deployAcoToken(bytes memory initData) internal virtual returns(address) {\n        require(initData.length > 0, \"ACOFactory::_deployToken: Invalid init data\");\n        bytes20 implentationBytes = bytes20(acoTokenImplementation);\n        address proxy;\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), implentationBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            proxy := create(0, clone, 0x37)\n        }\n        (bool success, bytes memory returnData) = proxy.call(initData);\n        require(success, _acoTokenInititalizeError(returnData));\n        return proxy;\n    }\n    \n    /**\n     * @dev Internal function to handle the return data on initializing ACO token with an error.\n     * 4 bytes (function signature) + 32 bytes (offset) + 32 bytes (error string length) + X bytes (error string)\n     * @param data Returned data with an error.\n     * @return String with the error.\n     */\n    function _acoTokenInititalizeError(bytes memory data) internal pure virtual returns(string memory) {\n        if (data.length >= 100) {\n            bytes memory buffer = new bytes(data.length - 68);\n            uint256 index = 0;\n            for (uint256 i = 68; i < data.length; ++i) {\n                buffer[index++] = data[i];\n            }\n            return string(buffer);\n        } else {\n            return \"ACOFactory::_acoTokenInititalizeError\";\n        }  \n    }\n}"
    },
    {
      "filename": "smart-contracts/contracts/core/ACOFactory.sol",
      "content": "pragma solidity ^0.6.6;\n\nimport \"../libs/Address.sol\";\nimport \"../libs/BokkyPooBahsDateTimeLibrary.sol\";\nimport \"../libs/Strings.sol\";\n\n/**\n * @title ACOFactory\n * @dev The contract is the implementation for the ACOProxy.\n */\ncontract ACOFactory {\n    \n    /**\n     * @dev Emitted when the factory admin address has been changed.\n     * @param previousFactoryAdmin Address of the previous factory admin.\n     * @param newFactoryAdmin Address of the new factory admin.\n     */\n    event SetFactoryAdmin(address previousFactoryAdmin, address newFactoryAdmin);\n    \n    /**\n     * @dev Emitted when the ACO token implementation has been changed.\n     * @param previousAcoTokenImplementation Address of the previous ACO token implementation.\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\n     */\n    event SetAcoTokenImplementation(address previousAcoTokenImplementation, address newAcoTokenImplementation);\n    \n    /**\n     * @dev Emitted when the ACO fee has been changed.\n     * @param previousAcoFee Value of the previous ACO fee.\n     * @param newAcoFee Value of the new ACO fee.\n     */\n    event SetAcoFee(uint256 previousAcoFee, uint256 newAcoFee);\n    \n    /**\n     * @dev Emitted when the ACO fee destination address has been changed.\n     * @param previousAcoFeeDestination Address of the previous ACO fee destination.\n     * @param newAcoFeeDestination Address of the new ACO fee destination.\n     */\n    event SetAcoFeeDestination(address previousAcoFeeDestination, address newAcoFeeDestination);\n    \n    /**\n     * @dev Emitted when a new ACO token has been created.\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param isCall True if the type is CALL, false for PUT.\n     * @param strikePrice The strike price with the strike asset precision.\n     * @param expiryTime The UNIX time for the ACO token expiration.\n     * @param acoToken Address of the new ACO token created.\n     * @param acoTokenImplementation Address of the ACO token implementation used on creation.\n     */\n    event NewAcoToken(address indexed underlying, address indexed strikeAsset, bool indexed isCall, uint256 strikePrice, uint256 expiryTime, address acoToken, address acoTokenImplementation);\n    \n    /**\n     * @dev The ACO fee value. \n     * It is a percentage value (100000 is 100%).\n     */\n    uint256 public acoFee;\n    \n    /**\n     * @dev The factory admin address.\n     */\n    address public factoryAdmin;\n    \n    /**\n     * @dev The ACO token implementation address.\n     */\n    address public acoTokenImplementation;\n    \n    /**\n     * @dev The ACO fee destination address.\n     */\n    address public acoFeeDestination;\n    \n    /**\n     * @dev Modifier to check if the `msg.sender` is the factory admin.\n     * Only factory admin address can execute.\n     */\n    modifier onlyFactoryAdmin() {\n        require(msg.sender == factoryAdmin, \"ACOFactory::onlyFactoryAdmin\");\n        _;\n    }\n    \n    /**\n     * @dev Function to initialize the contract.\n     * It should be called through the `data` argument when creating the proxy.\n     * It must be called only once. The `assert` is to guarantee that behavior.\n     * @param _factoryAdmin Address of the factory admin.\n     * @param _acoTokenImplementation Address of the ACO token implementation.\n     * @param _acoFee Value of the ACO fee.\n     * @param _acoFeeDestination Address of the ACO fee destination.\n     */\n    function init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) public {\n        require(factoryAdmin == address(0) && acoTokenImplementation == address(0), \"ACOFactory::init: Contract already initialized.\");\n        \n        _setFactoryAdmin(_factoryAdmin);\n        _setAcoTokenImplementation(_acoTokenImplementation);\n        _setAcoFee(_acoFee);\n        _setAcoFeeDestination(_acoFeeDestination);\n    }\n\n    /**\n     * @dev Function to guarantee that the contract will not receive ether.\n     */\n    receive() external payable virtual {\n        revert();\n    }\n    \n    /**\n     * @dev Function to create a new ACO token.\n     * It deploys a minimal proxy for the ACO token implementation address. \n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param isCall Whether the ACO token is the Call type.\n     * @param strikePrice The strike price with the strike asset precision.\n     * @param expiryTime The UNIX time for the ACO token expiration.\n     */\n    function createAcoToken(\n        address underlying, \n        address strikeAsset, \n        bool isCall,\n        uint256 strikePrice, \n        uint256 expiryTime\n    ) onlyFactoryAdmin external virtual {\n        address acoToken = _deployAcoToken(_getAcoTokenInitData(underlying, strikeAsset, isCall, strikePrice, expiryTime));\n        emit NewAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoToken, acoTokenImplementation);   \n    }\n    \n    /**\n     * @dev Function to set the factory admin address.\n     * Only can be called by the factory admin.\n     * @param newFactoryAdmin Address of the new factory admin.\n     */\n    function setFactoryAdmin(address newFactoryAdmin) onlyFactoryAdmin external virtual {\n        _setFactoryAdmin(newFactoryAdmin);\n    }\n    \n    /**\n     * @dev Function to set the ACO token implementation address.\n     * Only can be called by the factory admin.\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\n     */\n    function setAcoTokenImplementation(address newAcoTokenImplementation) onlyFactoryAdmin external virtual {\n        _setAcoTokenImplementation(newAcoTokenImplementation);\n    }\n    \n    /**\n     * @dev Function to set the ACO fee.\n     * Only can be called by the factory admin.\n     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\n     */\n    function setAcoFee(uint256 newAcoFee) onlyFactoryAdmin external virtual {\n        _setAcoFee(newAcoFee);\n    }\n    \n    /**\n     * @dev Function to set the ACO destination address.\n     * Only can be called by the factory admin.\n     * @param newAcoFeeDestination Address of the new ACO destination.\n     */\n    function setAcoFeeDestination(address newAcoFeeDestination) onlyFactoryAdmin external virtual {\n        _setAcoFeeDestination(newAcoFeeDestination);\n    }\n    \n    /**\n     * @dev Internal function to set the factory admin address.\n     * @param newFactoryAdmin Address of the new factory admin.\n     */\n    function _setFactoryAdmin(address newFactoryAdmin) internal virtual {\n        require(newFactoryAdmin != address(0), \"ACOFactory::_setFactoryAdmin: Invalid factory admin\");\n        emit SetFactoryAdmin(factoryAdmin, newFactoryAdmin);\n        factoryAdmin = newFactoryAdmin;\n    }\n    \n    /**\n     * @dev Internal function to set the ACO token implementation address.\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\n     */\n    function _setAcoTokenImplementation(address newAcoTokenImplementation) internal virtual {\n        require(Address.isContract(newAcoTokenImplementation), \"ACOFactory::_setAcoTokenImplementation: Invalid ACO token implementation\");\n        emit SetAcoTokenImplementation(acoTokenImplementation, newAcoTokenImplementation);\n        acoTokenImplementation = newAcoTokenImplementation;\n    }\n    \n    /**\n     * @dev Internal function to set the ACO fee.\n     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\n     */\n    function _setAcoFee(uint256 newAcoFee) internal virtual {\n        emit SetAcoFee(acoFee, newAcoFee);\n        acoFee = newAcoFee;\n    }\n    \n    /**\n     * @dev Internal function to set the ACO destination address.\n     * @param newAcoFeeDestination Address of the new ACO destination.\n     */\n    function _setAcoFeeDestination(address newAcoFeeDestination) internal virtual {\n        require(newAcoFeeDestination != address(0), \"ACOFactory::_setAcoFeeDestination: Invalid ACO fee destination\");\n        emit SetAcoFeeDestination(acoFeeDestination, newAcoFeeDestination);\n        acoFeeDestination = newAcoFeeDestination;\n    }\n    \n    /**\n     * @dev Internal function to get the ACO token initialize data.\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param isCall True if the type is CALL, false for PUT.\n     * @param strikePrice The strike price with the strike asset precision.\n     * @param expiryTime The UNIX time for the ACO token expiration.\n     * @return ABI encoded with signature for initializing ACO token.\n     */\n    function _getAcoTokenInitData(\n        address underlying, \n        address strikeAsset, \n        bool isCall,\n        uint256 strikePrice, \n        uint256 expiryTime\n    ) internal view virtual returns(bytes memory) {\n        return abi.encodeWithSignature(\"init(address,address,bool,uint256,uint256,uint256,address)\",\n            underlying,\n            strikeAsset,\n            isCall,\n            strikePrice,\n            expiryTime,\n            acoFee,\n            acoFeeDestination\n        );\n    }\n    \n    /**\n     * @dev Internal function to deploy a minimal proxy using ACO token implementation.\n     * @param initData ABI encoded with signature for initializing the new ACO token.\n     * @return Address of the new minimal proxy deployed for the ACO token.\n     */\n    function _deployAcoToken(bytes memory initData) internal virtual returns(address) {\n        require(initData.length > 0, \"ACOFactory::_deployToken: Invalid init data\");\n        bytes20 implentationBytes = bytes20(acoTokenImplementation);\n        address proxy;\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), implentationBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            proxy := create(0, clone, 0x37)\n        }\n        (bool success, bytes memory returnData) = proxy.call(initData);\n        require(success, _acoTokenInititalizeError(returnData));\n        return proxy;\n    }\n    \n    /**\n     * @dev Internal function to handle the return data on initializing ACO token with an error.\n     * 4 bytes (function signature) + 32 bytes (offset) + 32 bytes (error string length) + X bytes (error string)\n     * @param data Returned data with an error.\n     * @return String with the error.\n     */\n    function _acoTokenInititalizeError(bytes memory data) internal pure virtual returns(string memory) {\n        if (data.length >= 100) {\n            bytes memory buffer = new bytes(data.length - 68);\n            uint256 index = 0;\n            for (uint256 i = 68; i < data.length; ++i) {\n                buffer[index++] = data[i];\n            }\n            return string(buffer);\n        } else {\n            return \"ACOFactory::_acoTokenInititalizeError\";\n        }  \n    }\n}"
    },
    {
      "filename": "smart-contracts/contracts/core/ACOFactory.sol",
      "content": "pragma solidity ^0.6.6;\n\nimport \"../libs/Address.sol\";\nimport \"../libs/BokkyPooBahsDateTimeLibrary.sol\";\nimport \"../libs/Strings.sol\";\n\n/**\n * @title ACOFactory\n * @dev The contract is the implementation for the ACOProxy.\n */\ncontract ACOFactory {\n    \n    /**\n     * @dev Emitted when the factory admin address has been changed.\n     * @param previousFactoryAdmin Address of the previous factory admin.\n     * @param newFactoryAdmin Address of the new factory admin.\n     */\n    event SetFactoryAdmin(address previousFactoryAdmin, address newFactoryAdmin);\n    \n    /**\n     * @dev Emitted when the ACO token implementation has been changed.\n     * @param previousAcoTokenImplementation Address of the previous ACO token implementation.\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\n     */\n    event SetAcoTokenImplementation(address previousAcoTokenImplementation, address newAcoTokenImplementation);\n    \n    /**\n     * @dev Emitted when the ACO fee has been changed.\n     * @param previousAcoFee Value of the previous ACO fee.\n     * @param newAcoFee Value of the new ACO fee.\n     */\n    event SetAcoFee(uint256 previousAcoFee, uint256 newAcoFee);\n    \n    /**\n     * @dev Emitted when the ACO fee destination address has been changed.\n     * @param previousAcoFeeDestination Address of the previous ACO fee destination.\n     * @param newAcoFeeDestination Address of the new ACO fee destination.\n     */\n    event SetAcoFeeDestination(address previousAcoFeeDestination, address newAcoFeeDestination);\n    \n    /**\n     * @dev Emitted when a new ACO token has been created.\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param isCall True if the type is CALL, false for PUT.\n     * @param strikePrice The strike price with the strike asset precision.\n     * @param expiryTime The UNIX time for the ACO token expiration.\n     * @param acoToken Address of the new ACO token created.\n     * @param acoTokenImplementation Address of the ACO token implementation used on creation.\n     */\n    event NewAcoToken(address indexed underlying, address indexed strikeAsset, bool indexed isCall, uint256 strikePrice, uint256 expiryTime, address acoToken, address acoTokenImplementation);\n    \n    /**\n     * @dev The ACO fee value. \n     * It is a percentage value (100000 is 100%).\n     */\n    uint256 public acoFee;\n    \n    /**\n     * @dev The factory admin address.\n     */\n    address public factoryAdmin;\n    \n    /**\n     * @dev The ACO token implementation address.\n     */\n    address public acoTokenImplementation;\n    \n    /**\n     * @dev The ACO fee destination address.\n     */\n    address public acoFeeDestination;\n    \n    /**\n     * @dev Modifier to check if the `msg.sender` is the factory admin.\n     * Only factory admin address can execute.\n     */\n    modifier onlyFactoryAdmin() {\n        require(msg.sender == factoryAdmin, \"ACOFactory::onlyFactoryAdmin\");\n        _;\n    }\n    \n    /**\n     * @dev Function to initialize the contract.\n     * It should be called through the `data` argument when creating the proxy.\n     * It must be called only once. The `assert` is to guarantee that behavior.\n     * @param _factoryAdmin Address of the factory admin.\n     * @param _acoTokenImplementation Address of the ACO token implementation.\n     * @param _acoFee Value of the ACO fee.\n     * @param _acoFeeDestination Address of the ACO fee destination.\n     */\n    function init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) public {\n        require(factoryAdmin == address(0) && acoTokenImplementation == address(0), \"ACOFactory::init: Contract already initialized.\");\n        \n        _setFactoryAdmin(_factoryAdmin);\n        _setAcoTokenImplementation(_acoTokenImplementation);\n        _setAcoFee(_acoFee);\n        _setAcoFeeDestination(_acoFeeDestination);\n    }\n\n    /**\n     * @dev Function to guarantee that the contract will not receive ether.\n     */\n    receive() external payable virtual {\n        revert();\n    }\n    \n    /**\n     * @dev Function to create a new ACO token.\n     * It deploys a minimal proxy for the ACO token implementation address. \n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param isCall Whether the ACO token is the Call type.\n     * @param strikePrice The strike price with the strike asset precision.\n     * @param expiryTime The UNIX time for the ACO token expiration.\n     */\n    function createAcoToken(\n        address underlying, \n        address strikeAsset, \n        bool isCall,\n        uint256 strikePrice, \n        uint256 expiryTime\n    ) onlyFactoryAdmin external virtual {\n        address acoToken = _deployAcoToken(_getAcoTokenInitData(underlying, strikeAsset, isCall, strikePrice, expiryTime));\n        emit NewAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoToken, acoTokenImplementation);   \n    }\n    \n    /**\n     * @dev Function to set the factory admin address.\n     * Only can be called by the factory admin.\n     * @param newFactoryAdmin Address of the new factory admin.\n     */\n    function setFactoryAdmin(address newFactoryAdmin) onlyFactoryAdmin external virtual {\n        _setFactoryAdmin(newFactoryAdmin);\n    }\n    \n    /**\n     * @dev Function to set the ACO token implementation address.\n     * Only can be called by the factory admin.\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\n     */\n    function setAcoTokenImplementation(address newAcoTokenImplementation) onlyFactoryAdmin external virtual {\n        _setAcoTokenImplementation(newAcoTokenImplementation);\n    }\n    \n    /**\n     * @dev Function to set the ACO fee.\n     * Only can be called by the factory admin.\n     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\n     */\n    function setAcoFee(uint256 newAcoFee) onlyFactoryAdmin external virtual {\n        _setAcoFee(newAcoFee);\n    }\n    \n    /**\n     * @dev Function to set the ACO destination address.\n     * Only can be called by the factory admin.\n     * @param newAcoFeeDestination Address of the new ACO destination.\n     */\n    function setAcoFeeDestination(address newAcoFeeDestination) onlyFactoryAdmin external virtual {\n        _setAcoFeeDestination(newAcoFeeDestination);\n    }\n    \n    /**\n     * @dev Internal function to set the factory admin address.\n     * @param newFactoryAdmin Address of the new factory admin.\n     */\n    function _setFactoryAdmin(address newFactoryAdmin) internal virtual {\n        require(newFactoryAdmin != address(0), \"ACOFactory::_setFactoryAdmin: Invalid factory admin\");\n        emit SetFactoryAdmin(factoryAdmin, newFactoryAdmin);\n        factoryAdmin = newFactoryAdmin;\n    }\n    \n    /**\n     * @dev Internal function to set the ACO token implementation address.\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\n     */\n    function _setAcoTokenImplementation(address newAcoTokenImplementation) internal virtual {\n        require(Address.isContract(newAcoTokenImplementation), \"ACOFactory::_setAcoTokenImplementation: Invalid ACO token implementation\");\n        emit SetAcoTokenImplementation(acoTokenImplementation, newAcoTokenImplementation);\n        acoTokenImplementation = newAcoTokenImplementation;\n    }\n    \n    /**\n     * @dev Internal function to set the ACO fee.\n     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\n     */\n    function _setAcoFee(uint256 newAcoFee) internal virtual {\n        emit SetAcoFee(acoFee, newAcoFee);\n        acoFee = newAcoFee;\n    }\n    \n    /**\n     * @dev Internal function to set the ACO destination address.\n     * @param newAcoFeeDestination Address of the new ACO destination.\n     */\n    function _setAcoFeeDestination(address newAcoFeeDestination) internal virtual {\n        require(newAcoFeeDestination != address(0), \"ACOFactory::_setAcoFeeDestination: Invalid ACO fee destination\");\n        emit SetAcoFeeDestination(acoFeeDestination, newAcoFeeDestination);\n        acoFeeDestination = newAcoFeeDestination;\n    }\n    \n    /**\n     * @dev Internal function to get the ACO token initialize data.\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param isCall True if the type is CALL, false for PUT.\n     * @param strikePrice The strike price with the strike asset precision.\n     * @param expiryTime The UNIX time for the ACO token expiration.\n     * @return ABI encoded with signature for initializing ACO token.\n     */\n    function _getAcoTokenInitData(\n        address underlying, \n        address strikeAsset, \n        bool isCall,\n        uint256 strikePrice, \n        uint256 expiryTime\n    ) internal view virtual returns(bytes memory) {\n        return abi.encodeWithSignature(\"init(address,address,bool,uint256,uint256,uint256,address)\",\n            underlying,\n            strikeAsset,\n            isCall,\n            strikePrice,\n            expiryTime,\n            acoFee,\n            acoFeeDestination\n        );\n    }\n    \n    /**\n     * @dev Internal function to deploy a minimal proxy using ACO token implementation.\n     * @param initData ABI encoded with signature for initializing the new ACO token.\n     * @return Address of the new minimal proxy deployed for the ACO token.\n     */\n    function _deployAcoToken(bytes memory initData) internal virtual returns(address) {\n        require(initData.length > 0, \"ACOFactory::_deployToken: Invalid init data\");\n        bytes20 implentationBytes = bytes20(acoTokenImplementation);\n        address proxy;\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), implentationBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            proxy := create(0, clone, 0x37)"
    }
  ]
}