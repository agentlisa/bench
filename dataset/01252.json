{
  "Title": "Order creation can run out of gas since relying on previous order matchtype",
  "Content": "# Order creation can run out of gas since relying on previous order matchtype\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOrders.sol#L943C1-L947\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOrders.sol#L943C1-L947</a>\n\n\n## Vulnerability Details\nIf the hint order id has been reused and the previous order type is `matched` the current code iterates from the head of the linked list under the assumption that `since the previous order has been matched it must have been at the top of the orderbook which would mean the new order with a similar price would also be somewhere near the top of the orderbook`. \n```solidity\n    function findOrderHintId(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        MTypes.OrderHint[] memory orderHintArray\n    ) internal returns (uint16 hintId) {\n\n          // more code\n\n          // @audit if a reused order's prevOrderType is matched, returns HEAD\n\n          if (hintOrderType == O.Cancelled || hintOrderType == O.Matched) {\n                emit Events.FindOrderHintId(0);\n                continue;\n            } else if (\n                orders[asset][orderHint.hintId].creationTime == orderHint.creationTime\n            ) {\n                emit Events.FindOrderHintId(1);\n                return orderHint.hintId;\n            } else if (orders[asset][orderHint.hintId].prevOrderType == O.Matched) {\n                //@dev If hint was prev matched, it means that the hint was close to HEAD and therefore is reasonable to use HEAD\n                emit Events.FindOrderHintId(2);\n                return Constants.HEAD;\n            }\n```\nhttps://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/LibOrders.sol#L927-L947\n\nBut it is possible that the initial order was cancelled and the id reused multiple times with the previous order being close to the market price resulting in a match. This can lead to a possible exhaustion of gas if the user's order has a price far from the top of the orderbook.\n\n### Example scenario\n1. Current state of bids in orderbook:\n    1. Top bid 2000\n    2. Total bids 1000\n    3. Bids ids are from 100 to 999. No order is cancelled and reusable.\n2. A user wants to bid at 1700 which would be the 800th order pricewise.\n3. User calls `createBid` passing in `[799,798]` for the orderHintArray.\n4. The following tx's occur in the same block before the user's `createBid` call in the following order.\n    1. Order id `799` gets cancelled.\n    2. Another user creates a limit order at `2001` which now has order id `799` since it is reused.\n    3. A market/new limit ask order fills the bid.\n    4. Another user creates a limit order at price `1800`.\n5. In `createBid` when finding the hint id, the condition `prevOrderType == O.Matched` will pass and the hintId returned will be the `HEAD`. \n6. The loop starts to check for the price match from `HEAD` and exhausts gas before iterating over 800 bids.\n## Impact\nOrder creation can run out-of-gas on particular flow\n\n### Test Code\nAdd the following change in test/AskSellOrders.t.sol and run\n```diff\ndiff --git a/test/AskSellOrders.t.sol b/test/AskSellOrders.t.sol\nindex 4e8a4a9..264ea32 100644\n--- a/test/AskSellOrders.t.sol\n+++ b/test/AskSellOrders.t.sol\n@@ -8,7 +8,7 @@ import {Errors} from \"contracts/libraries/Errors.sol\";\n import {STypes, MTypes, O} from \"contracts/libraries/DataTypes.sol\";\n \n import {OBFixture} from \"test/utils/OBFixture.sol\";\n-// import {console} from \"contracts/libraries/console.sol\";\n+import {console} from \"contracts/libraries/console.sol\";\n \n contract SellOrdersTest is OBFixture {\n     using U256 for uint256;\n@@ -59,6 +59,49 @@ contract SellOrdersTest is OBFixture {\n         assertEq(asks[0].price, DEFAULT_PRICE);\n     }\n \n+    function testPossibleOutOfGasInLoopDueToHighIterations() public {\n+        for (uint256 i = 0; i < 1000; i++) {\n+            fundLimitAskOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, sender);\n+        }\n+\n+        // a new order at the bottom of the order book\n+        fundLimitAskOpt(HIGHER_PRICE, DEFAULT_AMOUNT, sender);\n+        assertTrue(getAsks()[1000].price == HIGHER_PRICE);\n+        assertTrue(getAsks()[1000].ercAmount == DEFAULT_AMOUNT);\n+\n+        // user wants to create an order at HIGHER_PRICE\n+        MTypes.OrderHint[] memory orderHintArray =\n+            diamond.getHintArray(asset, HIGHER_PRICE, O.LimitAsk);\n+        uint16 targetOrderId = orderHintArray[0].hintId;\n+        assertTrue(targetOrderId == getAsks()[1000].id);\n+\n+        // the target order gets cancelled\n+        vm.prank(sender);\n+        cancelAsk(targetOrderId);\n+\n+        // a person creates a limit ask which reuses the cancelled order id\n+        fundLimitAskOpt(LOWER_PRICE, DEFAULT_AMOUNT, sender);\n+        assertTrue(getAsks()[0].id == targetOrderId);\n+\n+        // a bid matches the targetId\n+        fundLimitBid(LOWER_PRICE, DEFAULT_AMOUNT, receiver);\n+\n+        // another person creates a limit ask which reuses the matched order id\n+        fundLimitAskOpt(LOWER_PRICE, DEFAULT_AMOUNT, sender);\n+        assertTrue(getAsks()[0].id == targetOrderId);\n+\n+        // the tx of the user goes through\n+        depositUsd(sender, DEFAULT_AMOUNT);\n+        vm.prank(sender);\n+        uint256 gasStart = gasleft();\n+        diamond.createAsk(\n+            asset, HIGHER_PRICE, DEFAULT_AMOUNT, Constants.LIMIT_ORDER, orderHintArray\n+        );\n+        uint256 gasUsed = gasStart - gasleft();\n+        assertGt(gasUsed, 2_000_000);\n+        console.log(gasUsed);\n+    }\n+\n     function testAddingLimitSellAskUsdGreaterThanBidUsd() public {\n         fundLimitBidOpt(DEFAULT_PRICE, DEFAULT_AMOUNT, receiver);\n         fundLimitAskOpt(DEFAULT_PRICE, DEFAULT_AMOUNT * 2, sender);\n```\n\n## Recommendations\nI think the probability of the above scenario is higher than that of multiple user's cancelling their orders. Hence moving to the next hint order as soon as the current hint order has been found to be reused could be better and will cost less gas on error.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/libraries/LibOrders.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, Math104, U80, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {STypes, MTypes, O, SR, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibOrders {\n    using LibOracle for address;\n    using U256 for uint256;\n    using Math104 for uint104;\n    using U80 for uint80;\n    using U88 for uint88;\n\n    // @dev in seconds\n    function getOffsetTime() internal view returns (uint32 timeInSeconds) {\n        // shouldn't overflow in 136 years\n        return uint32(block.timestamp - Constants.STARTING_TIME); // @dev(safe-cast)\n    }\n\n    // @dev in hours\n    function getOffsetTimeHours() internal view returns (uint24 timeInHours) {\n        return uint24(getOffsetTime() / 1 hours);\n    }\n\n    function convertCR(uint16 cr) internal pure returns (uint256) {\n        return (uint256(cr) * 1 ether) / Constants.TWO_DECIMAL_PLACES;\n    }\n\n    // For matched token reward\n    function increaseSharesOnMatch(\n        address asset,\n        STypes.Order memory order,\n        MTypes.Match memory matchTotal,\n        uint88 eth\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        // @dev use the diff to get more time (2159), to prevent overflow at year 2106\n        uint32 timeTillMatch = getOffsetTime() - order.creationTime;\n        if (timeTillMatch > Constants.MIN_DURATION) {\n            // shares in eth-days\n            uint88 shares = eth * (timeTillMatch / 1 days);\n            matchTotal.dittoMatchedShares += shares;\n\n            uint256 vault = s.asset[asset].vault;\n            s.vaultUser[vault][order.addr].dittoMatchedShares += shares;\n        }\n    }\n\n    function currentOrders(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset\n    ) internal view returns (STypes.Order[] memory) {\n        uint16 currentId = orders[asset][Constants.HEAD].nextId;\n        uint256 size;\n\n        while (currentId != Constants.TAIL) {\n            size++;\n            currentId = orders[asset][currentId].nextId;\n        }\n\n        STypes.Order[] memory list = new STypes.Order[](size);\n        currentId = orders[asset][Constants.HEAD].nextId; // reset currentId\n\n        for (uint256 i = 0; i < size; i++) {\n            list[i] = orders[asset][currentId];\n            currentId = orders[asset][currentId].nextId;\n        }\n        return list;\n    }\n\n    function isShort(STypes.Order memory order) internal pure returns (bool) {\n        return order.orderType == O.LimitShort;\n    }\n\n    function addBid(\n        address asset,\n        STypes.Order memory order,\n        MTypes.OrderHint[] memory orderHintArray\n    ) internal {\n        AppStorage storage s = appStorage();\n        uint16 hintId;\n\n        if (order.orderType == O.MarketBid) {\n            return;\n        }\n        uint16 nextId = s.bids[asset][Constants.HEAD].nextId;\n        if (order.price > s.bids[asset][nextId].price || nextId == Constants.TAIL) {\n            hintId = Constants.HEAD;\n        } else {\n            hintId = findOrderHintId(s.bids, asset, orderHintArray);\n        }\n\n        addOrder(s.bids, asset, order, hintId);\n\n        uint256 vault = s.asset[asset].vault;\n        uint88 eth = order.ercAmount.mulU88(order.price);\n        s.vaultUser[vault][order.addr].ethEscrowed -= eth;\n    }\n\n    function addAsk(\n        address asset,\n        STypes.Order memory order,\n        MTypes.OrderHint[] memory orderHintArray\n    ) internal {\n        AppStorage storage s = appStorage();\n        uint16 hintId;\n\n        if (order.orderType == O.MarketAsk) {\n            return;\n        }\n        uint16 nextId = s.asks[asset][Constants.HEAD].nextId;\n        if (order.price < s.asks[asset][nextId].price || nextId == Constants.TAIL) {\n            hintId = Constants.HEAD;\n        } else {\n            hintId = findOrderHintId(s.asks, asset, orderHintArray);\n        }\n        addOrder(s.asks, asset, order, hintId);\n\n        s.assetUser[asset][order.addr].ercEscrowed -= order.ercAmount;\n    }\n\n    /**\n     * @notice Add short struct onto market\n     *\n     * @param asset The market that will be impacted\n     * @param order The short struct passed from shortMatchAlgo\n     * @param orderHintArray array of Id passed in front end for optimized looping\n     */\n\n    function addShort(\n        address asset,\n        STypes.Order memory order,\n        MTypes.OrderHint[] memory orderHintArray\n    ) internal {\n        AppStorage storage s = appStorage();\n        uint16 hintId;\n        uint16 nextId = s.shorts[asset][Constants.HEAD].nextId;\n        if (order.price < s.shorts[asset][nextId].price || nextId == Constants.TAIL) {\n            hintId = Constants.HEAD;\n        } else {\n            hintId = findOrderHintId(s.shorts, asset, orderHintArray);\n        }\n\n        //@dev: Only need to set this when placing incomingShort onto market\n        addOrder(s.shorts, asset, order, hintId);\n        updateStartingShortIdViaShort(asset, order);\n        uint256 vault = s.asset[asset].vault;\n        uint88 eth = order.ercAmount.mulU88(order.price).mulU88(\n            LibOrders.convertCR(order.initialMargin)\n        );\n        s.vaultUser[vault][order.addr].ethEscrowed -= eth;\n    }\n\n    /**\n     * @notice Add ask/short struct onto market\n     *\n     * @param asset The market that will be impacted\n     * @param incomingOrder The ask or short struct passed from sellMatchAlgo\n     * @param orderHintArray array of Id passed in front end for optimized looping\n     */\n\n    function addSellOrder(\n        STypes.Order memory incomingOrder,\n        address asset,\n        MTypes.OrderHint[] memory orderHintArray\n    ) private {\n        O o = normalizeOrderType(incomingOrder.orderType);\n        if (o == O.LimitShort) {\n            addShort(asset, incomingOrder, orderHintArray);\n        } else if (o == O.LimitAsk) {\n            addAsk(asset, incomingOrder, orderHintArray);\n        }\n    }\n\n    /**\n     * @notice Adds order onto market\n     * @dev Reuses order ids for gas saving and id recycling\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param incomingOrder Bid, Ask, or Short Order\n     * @param hintId Id passed in front end for optimized looping\n     */\n\n    // @dev partial addOrder\n    function addOrder(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        STypes.Order memory incomingOrder,\n        uint16 hintId\n    ) private {\n        AppStorage storage s = appStorage();\n        // hint.prevId <-> hint <-> hint.nextId\n        // set links of incoming to hint\n        uint16 prevId = findPrevOfIncomingId(orders, asset, incomingOrder, hintId);\n        uint16 nextId = orders[asset][prevId].nextId;\n        incomingOrder.prevId = prevId;\n        incomingOrder.nextId = nextId;\n        uint16 id = incomingOrder.id;\n        uint16 canceledID = orders[asset][Constants.HEAD].prevId;\n        // @dev (ID) is exiting, [ID] is inserted\n        // in this case, the protocol is re-using (ID) and moving it to [ID]\n        // check if a previously cancelled or matched order exists\n        if (canceledID != Constants.HEAD) {\n            incomingOrder.prevOrderType = orders[asset][canceledID].orderType;\n            // BEFORE: CancelledID <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n            // AFTER1: CancelledID <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n            uint16 prevCanceledID = orders[asset][canceledID].prevId;\n            if (prevCanceledID != Constants.HEAD) {\n                orders[asset][Constants.HEAD].prevId = prevCanceledID;\n            } else {\n                // BEFORE: HEAD <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n                // AFTER1: HEAD <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n                orders[asset][Constants.HEAD].prevId = Constants.HEAD;\n            }\n            // re-use the previous order's id\n            id = incomingOrder.id = canceledID;\n        } else {\n            // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n            // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n            // otherwise just increment to a new order id\n            // and the market grows in height/size\n            s.asset[asset].orderId += 1;\n        }\n        orders[asset][id] = incomingOrder;\n        if (nextId != Constants.TAIL) {\n            orders[asset][nextId].prevId = incomingOrder.id;\n        }\n\n        orders[asset][prevId].nextId = incomingOrder.id;\n    }\n\n    /**\n     * @notice Verifies that bid id is between two id based on price\n     *\n     * @param asset The market that will be impacted\n     * @param _prevId The first id supposedly preceding the new price\n     * @param _newPrice price of prospective order\n     * @param _nextId The first id supposedly following the new price\n     *\n     * @return direction int direction to search (PREV, EXACT, NEXT)\n     */\n\n    function verifyBidId(address asset, uint16 _prevId, uint256 _newPrice, uint16 _nextId)\n        internal\n        view\n        returns (int256 direction)\n    {\n        AppStorage storage s = appStorage();\n        //@dev: TAIL can't be prevId because it will always be last item in list\n        bool check1 =\n            s.bids[asset][_prevId].price >= _newPrice || _prevId == Constants.HEAD;\n        bool check2 =\n            _newPrice > s.bids[asset][_nextId].price || _nextId == Constants.TAIL;\n\n        if (check1 && check2) {\n            return Constants.EXACT;\n        } else if (!check1) {\n            return Constants.PREV;\n        } else if (!check2) {\n            return Constants.NEXT;\n        }\n    }\n\n    /**\n     * @notice Verifies that short id is between two id based on price\n     *\n     * @param asset The market that will be impacted\n     * @param _prevId The first id supposedly preceding the new price\n     * @param _newPrice price of prospective order\n     * @param _nextId The first id supposedly following the new price\n     *\n     * @return direction int direction to search (PREV, EXACT, NEXT)\n     */\n    function verifySellId(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 _prevId,\n        uint256 _newPrice,\n        uint16 _nextId\n    ) private view returns (int256 direction) {\n        //@dev: TAIL can't be prevId because it will always be last item in list\n        bool check1 =\n            orders[asset][_prevId].price <= _newPrice || _prevId == Constants.HEAD;\n\n        bool check2 =\n            _newPrice < orders[asset][_nextId].price || _nextId == Constants.TAIL;\n\n        if (check1 && check2) {\n            return Constants.EXACT;\n        } else if (!check1) {\n            return Constants.PREV;\n        } else if (!check2) {\n            return Constants.NEXT;\n        }\n    }\n\n    /**\n     * @notice Handles the reordering of market when order is canceled\n     * @dev Reuses order ids for gas saving and id recycling\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param id Id of order\n     */\n\n    function cancelOrder(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 id\n    ) internal {\n        // save this since it may be replaced\n        uint16 prevHEAD = orders[asset][Constants.HEAD].prevId;\n\n        // remove the links of ID in the market\n        // @dev (ID) is exiting, [ID] is inserted\n        // BEFORE: PREV <-> (ID) <-> NEXT\n        // AFTER : PREV <----------> NEXT\n        orders[asset][orders[asset][id].nextId].prevId = orders[asset][id].prevId;\n        orders[asset][orders[asset][id].prevId].nextId = orders[asset][id].nextId;\n\n        // create the links using the other side of the HEAD\n        emit Events.CancelOrder(asset, id, orders[asset][id].orderType);\n        _reuseOrderIds(orders, asset, id, prevHEAD, O.Cancelled);\n    }\n\n    /**\n     * @notice moves the matched id to the prev side of HEAD\n     * @dev this is how an id gets re-used\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param id ID of most recent matched order\n     *\n     */\n    function matchOrder(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 id\n    ) internal {\n        uint16 prevHEAD = orders[asset][Constants.HEAD].prevId;\n        _reuseOrderIds(orders, asset, id, prevHEAD, O.Matched);\n    }\n\n    // shared function for both canceling and order and matching an order\n    function _reuseOrderIds(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 id,\n        uint16 prevHEAD,\n        O cancelledOrMatched\n    ) private {\n        // matching ID1 and ID2\n        // BEFORE: HEAD <- <---------------- HEAD <-> (ID1) <-> (ID2) <-> (ID3) <-> NEXT\n        // AFTER1: HEAD <- [ID1] <---------- HEAD <-----------> (ID2) <-> (ID3) <-> NEXT\n        // AFTER2: HEAD <- [ID1] <- [ID2] <- HEAD <---------------------> (ID3) <-> NEXT\n\n        // @dev mark as cancelled instead of deleting the order itself\n        orders[asset][id].orderType = cancelledOrMatched;\n        orders[asset][Constants.HEAD].prevId = id;\n        // Move the cancelled ID behind HEAD to re-use it\n        // note: C_IDs (cancelled ids) only need to point back (set prevId, can retain nextId)\n        // BEFORE: .. C_ID2 <- C_ID1 <--------- HEAD <-> ... [ID]\n        // AFTER1: .. C_ID2 <- C_ID1 <- [ID] <- HEAD <-> ...\n        if (prevHEAD != Constants.HEAD) {\n            orders[asset][id].prevId = prevHEAD;\n        } else {\n            // if this is the first ID cancelled\n            // HEAD.prevId needs to be HEAD\n            // and one of the cancelled id.prevID should point to HEAD\n            // BEFORE: HEAD <--------- HEAD <-> ... [ID]\n            // AFTER1: HEAD <- [ID] <- HEAD <-> ...\n            orders[asset][id].prevId = Constants.HEAD;\n        }\n    }\n\n    /**\n     * @notice Helper function for finding the (previous) id so that an incoming\n     * @notice order can be placed onto the correct market.\n     * @notice Uses hintId if possible, otherwise fallback to traversing the\n     * @notice list of orders starting from HEAD\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param incomingOrder the Order to be placed\n     * @param hintId Id used to optimize finding the place to insert into ob\n     */\n\n    function findPrevOfIncomingId(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        STypes.Order memory incomingOrder,\n        uint16 hintId\n    ) internal view returns (uint16) {\n        uint16 nextId = orders[asset][hintId].nextId;\n\n        // if invalid hint (if the id points to 0 then it's an empty id)\n        if (hintId == 0 || nextId == 0) {\n            return getOrderId(\n                orders,\n                asset,\n                Constants.NEXT,\n                Constants.HEAD,\n                incomingOrder.price,\n                incomingOrder.orderType\n            );\n        }\n\n        // check if the hint is valid\n        int256 direction = verifyId(\n            orders, asset, hintId, incomingOrder.price, nextId, incomingOrder.orderType\n        );\n\n        // if its 0, it's correct\n        // otherwise it could be off because a tx could of modified state\n        // so search in a direction based on price.\n        if (direction == Constants.EXACT) {\n            return hintId;\n        } else if (direction == Constants.NEXT) {\n            return getOrderId(\n                orders,\n                asset,\n                Constants.NEXT,\n                nextId,\n                incomingOrder.price,\n                incomingOrder.orderType\n            );\n        } else {\n            uint16 prevId = orders[asset][hintId].prevId;\n            return getOrderId(\n                orders,\n                asset,\n                Constants.PREV,\n                prevId,\n                incomingOrder.price,\n                incomingOrder.orderType\n            );\n        }\n    }\n\n    /**\n     * @notice Verifies that an id is between two id based on price and orderType\n     *\n     * @param asset The market that will be impacted\n     * @param prevId The first id supposedly preceding the new price\n     * @param newPrice price of prospective order\n     * @param nextId The first id supposedly following the new price\n     * @param orderType order type (bid, ask, short)\n     *\n     * @return direction int direction to search (PREV, EXACT, NEXT)\n     */\n    function verifyId(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 prevId,\n        uint256 newPrice,\n        uint16 nextId,\n        O orderType\n    ) internal view returns (int256 direction) {\n        orderType = normalizeOrderType(orderType);\n\n        if (orderType == O.LimitAsk || orderType == O.LimitShort) {\n            return verifySellId(orders, asset, prevId, newPrice, nextId);\n        } else if (orderType == O.LimitBid) {\n            return verifyBidId(asset, prevId, newPrice, nextId);\n        }\n    }\n\n    // @dev not used to change state, just which methods to call\n    function normalizeOrderType(O o) private pure returns (O newO) {\n        if (o == O.LimitBid || o == O.MarketBid) {\n            return O.LimitBid;\n        } else if (o == O.LimitAsk || o == O.MarketAsk) {\n            return O.LimitAsk;\n        } else if (o == O.LimitShort) {\n            return O.LimitShort;\n        }\n    }\n\n    /**\n     * @notice Helper function for finding and returning id of potential order\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param direction int direction to search (PREV, EXACT, NEXT)\n     * @param hintId hint id\n     * @param _newPrice price of prospective order used to find the id\n     * @param orderType which OrderType to verify\n     */\n\n    function getOrderId(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        int256 direction,\n        uint16 hintId,\n        uint256 _newPrice,\n        O orderType\n    ) internal view returns (uint16 _hintId) {\n        while (true) {\n            uint16 nextId = orders[asset][hintId].nextId;\n\n            if (\n                verifyId(orders, asset, hintId, _newPrice, nextId, orderType)\n                    == Constants.EXACT\n            ) {\n                return hintId;\n            }\n\n            if (direction == Constants.PREV) {\n                uint16 prevId = orders[asset][hintId].prevId;\n                hintId = prevId;\n            } else {\n                hintId = nextId;\n            }\n        }\n    }\n\n    /**\n     * @notice Helper function for updating the bids mapping when matched\n     * @dev More efficient way to remove matched orders. Instead\n     * @dev Instead of canceling each one, just wait till the last match and only swap prevId/nextId there, since the rest are gone\n     *\n     * @param orders The market that will be impacted\n     * @param asset The market that will be impacted\n     * @param id Most recent matched Bid\n     * @param isOrderFullyFilled Boolean to see if full or partial\n     */\n    function updateBidOrdersOnMatch(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 id,\n        bool isOrderFullyFilled\n    ) internal {\n        // BEFORE: HEAD <-> ... <-> (ID) <-> NEXT\n        // AFTER : HEAD <------------------> NEXT\n        if (isOrderFullyFilled) {\n            _updateOrders(orders, asset, Constants.HEAD, id);\n        } else {\n            // BEFORE: HEAD <-> ... <-> (ID)\n            // AFTER : HEAD <---------> (ID)\n            orders[asset][id].prevId = Constants.HEAD;\n            orders[asset][Constants.HEAD].nextId = id;\n        }\n    }\n\n    /**\n     * @notice Helper function for updating the asks/shorts mapping when matched by incomingBid\n     * @dev firstShortId isn't necessarily HEAD because orders start matching from oracle price\n     *\n     * @param asset The market that will be impacted\n     * @param b Memory based struct passed from BidMatchAlgo\n     */\n    function updateSellOrdersOnMatch(address asset, MTypes.BidMatchAlgo memory b)\n        internal\n    {\n        AppStorage storage s = appStorage();\n        if (b.matchedAskId != 0) {\n            _updateOrders(s.asks, asset, Constants.HEAD, b.matchedAskId);\n        }\n\n        if (b.matchedShortId != 0) {\n            if (!b.isMovingBack && !b.isMovingFwd) {\n                //@dev Handles only matching one thing\n                //@dev If does not get fully matched, b.matchedShortId == 0 and therefore not hit this block\n                _updateOrders(s.shorts, asset, b.prevShortId, b.matchedShortId);\n            } else if (!b.isMovingBack && b.isMovingFwd) {\n                //@dev Handles moving forward only\n                _updateOrders(\n                    s.shorts, asset, b.firstShortIdBelowOracle, b.matchedShortId\n                );\n            } else if (b.isMovingBack && !b.isMovingFwd) {\n                //@handles moving backwards only.\n                _updateOrders(s.shorts, asset, b.prevShortId, b.shortHintId);\n            } else if (b.isMovingBack && b.isMovingFwd) {\n                uint16 id = b.prevShortId == b.firstShortIdBelowOracle\n                    ? b.shortHintId\n                    : b.matchedShortId;\n                //@dev Handle going backward and forward\n                _updateOrders(s.shorts, asset, b.firstShortIdBelowOracle, id);\n            }\n        }\n    }\n\n    /**\n     * @notice Base helper function for updating any kind of orders\n     *\n     * @param orders the order mapping\n     * @param asset The market that will be impacted\n     * @param headId Either HEAD or first SHORT with price >= oracle price\n     * @param lastMatchedId Most recent matched SHORT in a specific Bid transaction\n     */\n    function _updateOrders(\n        mapping(address => mapping(uint16 => STypes.Order)) storage orders,\n        address asset,\n        uint16 headId,\n        uint16 lastMatchedId\n    ) private {\n        // BEFORE: FIRST <-> ... <-> (LAST) <-> NEXT\n        // AFTER : FIRST <--------------------> NEXT\n        uint16 nextAskId = orders[asset][lastMatchedId].nextId;\n        if (nextAskId != Constants.TAIL) {\n            orders[asset][nextAskId].prevId = headId;\n        }\n        orders[asset][headId].nextId = nextAskId;\n    }\n\n    /**\n     * @notice The matching algorithm for asks\n     *\n     * @param asset The market that will be impacted\n     * @param incomingAsk Newly created ask struct\n     * @param orderHintArray Id passed in from front end for optimized looping\n     * @param minAskEth Minimum ask dust amount\n     *\n     */\n\n    function sellMatchAlgo(\n        address asset,\n        STypes.Order memory incomingAsk,\n        MTypes.OrderHint[] memory orderHintArray,\n        uint256 minAskEth\n    ) internal {\n        AppStorage storage s = appStorage();\n        uint16 startingId = s.bids[asset][Constants.HEAD].nextId;\n        STypes.Order storage highestBidInitial = s.bids[asset][startingId];\n        if (incomingAsk.price > highestBidInitial.price) {\n            if (incomingAsk.ercAmount.mul(incomingAsk.price) >= minAskEth) {\n                addSellOrder(incomingAsk, asset, orderHintArray);\n            }\n            return;\n        }\n        // matching loop starts\n        MTypes.Match memory matchTotal;\n        while (true) {\n            STypes.Order memory highestBid = s.bids[asset][startingId];\n            if (incomingAsk.price <= highestBid.price) {\n                // Consider ask filled if only dust amount left\n                if (incomingAsk.ercAmount.mul(highestBid.price) == 0) {\n                    updateBidOrdersOnMatch(s.bids, asset, highestBid.id, false);\n                    incomingAsk.ercAmount = 0;\n                    matchIncomingSell(asset, incomingAsk, matchTotal);\n                    return;\n                }\n                matchHighestBid(incomingAsk, highestBid, asset, matchTotal);\n                if (incomingAsk.ercAmount > highestBid.ercAmount) {\n                    incomingAsk.ercAmount -= highestBid.ercAmount;\n                    highestBid.ercAmount = 0;\n                    matchOrder(s.bids, asset, highestBid.id);\n\n                    // loop\n                    startingId = highestBid.nextId;\n                    if (startingId == Constants.TAIL) {\n                        incomingAsk.shortRecordId =\n                            matchIncomingSell(asset, incomingAsk, matchTotal);\n\n                        if (incomingAsk.ercAmount.mul(incomingAsk.price) >= minAskEth) {\n                            addSellOrder(incomingAsk, asset, orderHintArray);\n                        }\n                        s.bids[asset][Constants.HEAD].nextId = Constants.TAIL;\n                        return;\n                    }\n                } else {\n                    // If the product of remaining ercAmount and price rounds down to 0 just close the bid order\n                    bool dustErcAmount = (highestBid.ercAmount - incomingAsk.ercAmount)\n                        .mul(highestBid.price) == 0;\n\n                    if (dustErcAmount || incomingAsk.ercAmount == highestBid.ercAmount) {\n                        matchOrder(s.bids, asset, highestBid.id);\n                        updateBidOrdersOnMatch(s.bids, asset, highestBid.id, true);\n                    } else {\n                        s.bids[asset][highestBid.id].ercAmount =\n                            highestBid.ercAmount - incomingAsk.ercAmount;\n                        updateBidOrdersOnMatch(s.bids, asset, highestBid.id, false);\n                    }\n                    incomingAsk.ercAmount = 0;\n                    matchIncomingSell(asset, incomingAsk, matchTotal);\n                    return;\n                }\n            } else {\n                updateBidOrdersOnMatch(s.bids, asset, highestBid.id, false);\n                incomingAsk.shortRecordId =\n                    matchIncomingSell(asset, incomingAsk, matchTotal);\n\n                if (incomingAsk.ercAmount.mul(incomingAsk.price) >= minAskEth) {\n                    addSellOrder(incomingAsk, asset, orderHintArray);\n                }\n                return;\n            }\n        }\n    }\n\n    function matchIncomingSell(\n        address asset,\n        STypes.Order memory incomingOrder,\n        MTypes.Match memory matchTotal\n    ) private returns (uint8 shortRecordId) {\n        O o = normalizeOrderType(incomingOrder.orderType);\n\n        if (o == O.LimitShort) {\n            return matchIncomingShort(asset, incomingOrder, matchTotal);\n        } else if (o == O.LimitAsk) {\n            matchIncomingAsk(asset, incomingOrder, matchTotal);\n        }\n    }\n\n    /**\n     * @notice Final settlement of incoming ask\n     *\n     * @param asset The market that will be impacted\n     * @param incomingAsk Newly created ask struct\n     * @param matchTotal Struct of the running matched totals\n     */\n\n    function matchIncomingAsk(\n        address asset,\n        STypes.Order memory incomingAsk,\n        MTypes.Match memory matchTotal\n    ) private {\n        AppStorage storage s = appStorage();\n        uint256 vault = s.asset[asset].vault;\n        s.assetUser[asset][incomingAsk.addr].ercEscrowed -= matchTotal.fillErc;\n        s.vaultUser[vault][incomingAsk.addr].ethEscrowed += matchTotal.fillEth;\n        s.vault[vault].dittoMatchedShares += matchTotal.dittoMatchedShares;\n    }\n\n    /**\n     * @notice Final settlement of incoming short\n     *\n     * @param asset The market that will be impacted\n     * @param incomingShort Newly created short struct\n     * @param matchTotal Struct of the running matched totals\n     */\n\n    function matchIncomingShort(\n        address asset,\n        STypes.Order memory incomingShort,\n        MTypes.Match memory matchTotal\n    ) private returns (uint8 shortRecordId) {\n        AppStorage storage s = appStorage();\n        STypes.Asset storage Asset = s.asset[asset];\n        uint256 vault = Asset.vault;\n        STypes.Vault storage Vault = s.vault[vault];\n\n        s.vaultUser[vault][incomingShort.addr].ethEscrowed -= matchTotal.colUsed;\n        matchTotal.fillEth += matchTotal.colUsed;\n\n        SR status = incomingShort.ercAmount == 0 ? SR.FullyFilled : SR.PartialFill;\n\n        shortRecordId = LibShortRecord.createShortRecord(\n            asset,\n            incomingShort.addr,\n            status,\n            matchTotal.fillEth,\n            matchTotal.fillErc,\n            Asset.ercDebtRate,\n            Vault.zethYieldRate,\n            0\n        );\n\n        Vault.dittoMatchedShares += matchTotal.dittoMatchedShares;\n        Vault.zethCollateral += matchTotal.fillEth;\n        Asset.zethCollateral += matchTotal.fillEth;\n        Asset.ercDebt += matchTotal.fillErc;\n    }\n\n    /**\n     * @notice Settles highest bid and updates incoming Ask or Short\n     * @dev DittoMatchedShares only assigned for bids sitting > 2 weeks of seconds\n     *\n     * @param incomingSell Newly created Ask or Short\n     * @param highestBid Highest bid (first bid) in the sorted bid\n     * @param asset The market that will be impacted\n     * @param matchTotal Struct of the running matched totals\n     */\n\n    function matchHighestBid(\n        STypes.Order memory incomingSell,\n        STypes.Order memory highestBid,\n        address asset,\n        MTypes.Match memory matchTotal\n    ) internal {\n        AppStorage storage s = appStorage();\n        uint88 fillErc = incomingSell.ercAmount > highestBid.ercAmount\n            ? highestBid.ercAmount\n            : incomingSell.ercAmount;\n        uint88 fillEth = highestBid.price.mulU88(fillErc);\n\n        increaseSharesOnMatch(asset, highestBid, matchTotal, fillEth);\n\n        if (incomingSell.orderType == O.LimitShort) {\n            matchTotal.colUsed += incomingSell.price.mulU88(fillErc).mulU88(\n                LibOrders.convertCR(incomingSell.initialMargin)\n            );\n        }\n        matchTotal.fillErc += fillErc;\n        matchTotal.fillEth += fillEth;\n\n        // @dev this happens at the end so fillErc isn't affected in previous calculations\n        s.assetUser[asset][highestBid.addr].ercEscrowed += fillErc;\n    }\n\n    function _updateOracleAndStartingShort(address asset, uint16[] memory shortHintArray)\n        private\n    {\n        AppStorage storage s = appStorage();\n        uint256 oraclePrice = LibOracle.getOraclePrice(asset);\n        uint256 savedPrice = asset.getPrice();\n        asset.setPriceAndTime(oraclePrice, getOffsetTime());\n        bool shortOrdersIsEmpty = s.shorts[asset][Constants.HEAD].nextId == Constants.TAIL;\n        if (shortOrdersIsEmpty) {\n            s.asset[asset].startingShortId = Constants.HEAD;\n        } else {\n            if (oraclePrice == savedPrice) {\n                return;\n            }\n            uint16 shortHintId;\n            for (uint256 i = 0; i < shortHintArray.length;) {\n                shortHintId = shortHintArray[i];\n                unchecked {\n                    ++i;\n                }\n\n                {\n                    O shortOrderType = s.shorts[asset][shortHintId].orderType;\n                    if (\n                        shortOrderType == O.Cancelled || shortOrderType == O.Matched\n                            || shortOrderType == O.Uninitialized\n                    ) {\n                        continue;\n                    }\n                }\n\n                uint80 shortPrice = s.shorts[asset][shortHintId].price;\n                uint16 prevId = s.shorts[asset][shortHintId].prevId;\n                //@dev: force hint to be within 1% of oracleprice\n                bool startingShortWithinOracleRange = shortPrice\n                    <= oraclePrice.mul(1.01 ether)\n                    && s.shorts[asset][prevId].price >= oraclePrice;\n                bool isExactStartingShort = shortPrice >= oraclePrice\n                    && s.shorts[asset][prevId].price < oraclePrice;\n                bool allShortUnderOraclePrice = shortPrice < oraclePrice\n                    && s.shorts[asset][shortHintId].nextId == Constants.TAIL;\n\n                if (startingShortWithinOracleRange || isExactStartingShort) {"
    }
  ]
}