{
  "Title": "[M-07] `SmartAccount.sol` is intended to be upgradable but inherits from contracts that contain storage and no gaps",
  "Content": "\n[contracts/smart-contract-wallet/base/ModuleManager.sol#L18](https://github.com/code-423n4/2023-01-biconomy/blob/53c8c3823175aeb26dee5529eeefa81240a406ba/scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol#L18)\n\nSmartAccount.sol inherits from contracts that are not stateless and don't contain storage gaps which can be dangerous when upgrading.\n\n### Proof of Concept\n\nWhen creating upgradable contracts that inherit from other contracts is important that there are storage gap in case storage variable are added to inherited contracts. If an inherited contract is a stateless contract (i.e. it doesn't have any storage) then it is acceptable to omit a storage gap, since these function similar to libraries and aren't intended to add any storage. The issue is that SmartAccount.sol inherits from contracts that contain storage that don't contain any gaps such as ModuleManager.sol. These contracts can pose a significant risk when updating a contract because they can shift the storage slots of all inherited contracts.\n\n### Recommended Mitigation Steps\n\nAdd storage gaps to all inherited contracts that contain storage variables.\n\n**[livingrockrises (Biconomy) commented](https://github.com/code-423n4/2023-01-biconomy-findings/issues/261#issuecomment-1397357822):**\n > Regarding storage gaps I want to bring this up.\n> \n> SmartAccount first storage is Singleton(first inherited contract)<br>\n> that says<br>\n> `// singleton slot always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.`\n> \n> \"In case of an upgrade, adding new storage variables to the inherited contracts will collapse the storage layout.\" Is this still valid?\n\n**[livingrockrises (Biconomy) acknowledged](https://github.com/code-423n4/2023-01-biconomy-findings/issues/261#issuecomment-1420646233)**\n\n**[livingrockrises (Biconomy) commented](https://github.com/code-423n4/2023-01-biconomy-findings/issues/261#issuecomment-1426985780):**\n > Would like to hear judge's views on fixing this and upgradeability as a whole.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2023-01-biconomy-findings/issues/261#issuecomment-1427071881):**\n > > Would like to hear judge's views on fixing this and upgradeability as a whole.\n> \n> Immediately actionable items would be to use the upgradable variant of OZ contract when available; ModuleManager should also be modified to include a storage gap. \n> \n> Since the proxy implementation is upgradable by the owner (which can be anyone aka not a dev), it would be nice to implement UUPS like safe-rail (as mentioned in [`#352`](https://github.com/code-423n4/2023-01-biconomy-findings/issues/352)) to prevent the user upgrading to a broken implementation irreversibly. \n> \n> Will also add that lack of storage gap is not typically a Med issue, but considering this contract has a mix of storage gapped and non-storage gapped base contract, and a risky upgrade mechanism, it is considered as Med risk in this contest.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-biconomy-smart-contract-wallet-contest",
  "Code": [
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol",
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.12;\n\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\nimport \"./Executor.sol\";\n\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\ncontract ModuleManager is SelfAuthorized, Executor {    \n    // Events\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    mapping(address => address) internal modules;\n\n    function setupModules(address to, bytes memory data) internal {\n        require(modules[SENTINEL_MODULES] == address(0), \"BSA100\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), \"BSA000\");\n    }\n\n    /// @dev Allows to add a module to the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Enables the module `module` for the Safe.\n    /// @param module Module to be whitelisted.\n    function enableModule(address module) public authorized {\n        // Module address cannot be null or sentinel.\n        require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n        // Module cannot be added twice.\n        require(modules[module] == address(0), \"BSA102\");\n        modules[module] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = module;\n        emit EnabledModule(module);\n    }\n\n    /// @dev Allows to remove a module from the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Disables the module `module` for the Safe.\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(address prevModule, address module) public authorized {\n        // Validate module address and check that it corresponds to module index.\n        require(module != address(0) && module != SENTINEL_MODULES, \"BSA101\");\n        require(modules[prevModule] == module, \"BSA103\");\n        modules[prevModule] = modules[module];\n        modules[module] = address(0);\n        emit DisabledModule(module);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public virtual returns (bool success) {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"BSA104\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public returns (bool success, bytes memory returnData) {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) public view returns (bool) {\n        return SENTINEL_MODULES != module && modules[module] != address(0);\n    }\n\n    /// @dev Returns array of modules. Useful for a widget\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while (currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }\n}"
    }
  ]
}