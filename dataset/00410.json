{
  "Title": "H-5: `_computeClosingFactor` function will return incorrect values, lower than needed, because it uses `collateralizationRate` to calculate the denominator",
  "Content": "# Issue H-5: `_computeClosingFactor` function will return incorrect values, lower than needed, because it uses `collateralizationRate` to calculate the denominator \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/53 \n\n## Found by \ncergyk, duc\n## Summary\n`_computeClosingFactor` is used to calculate the required borrow amount that should be liquidated to make the user's position solvent. However, this function uses `collateralizationRate` (defaulting to 75%) to calculate the liquidated amount, while the threshold to be liquidatable is `liquidationCollateralizationRate` (defaulting to 80%). Therefore, it will return incorrect liquidated amount.\n## Vulnerability Detail\nIn `_computeClosingFactor` of Market contract:\n```solidity=\n//borrowPart and collateralPartInAsset should already be scaled due to the exchange rate computation\nuint256 liquidationStartsAt =\n    (collateralPartInAsset * _liquidationCollateralizationRate) / (10 ** ratesPrecision);///80% collateral value in asset in default\n\nif (borrowPart < liquidationStartsAt) return 0;\n\n//compute numerator\nuint256 numerator = borrowPart - liquidationStartsAt;\n//compute denominator\nuint256 diff =\n    (collateralizationRate * ((10 ** ratesPrecision) + _liquidationMultiplier)) / (10 ** ratesPrecision);\nint256 denominator = (int256(10 ** ratesPrecision) - int256(diff)) * int256(1e13);\n\n//compute closing factor\nint256 x = (int256(numerator) * int256(1e18)) / denominator;\n```\nA user will be able to be liquidated if their ratio between borrow and collateral value exceeds `liquidationCollateralizationRate` (see [`_isSolvent()`](https://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/Market.sol#L476-L477) function).\nHowever, `_computeClosingFactor` uses `collateralizationRate`  (defaulting to 75%) to calculate the denominator for the needed liquidate amount, while the numerator is calculated by using `liquidationCollateralizationRate` (80% in default). These variables were initialized in [`_initCoreStorage()`](https://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BigBang.sol#L176-L178).\n\nIn the above calculation of `_computeClosingFactor` function, in default:\n`_liquidationMultiplier` = 12%,\n`numerator` = `borrowPart` - `liquidationStartsAt` = borrowAmount - 80% * collateralToAssetAmount \n=> x will be: **numerator / (1 - 75% * 112%) = numerator / 16%**\n\nHowever, during a partial liquidation of BigBang or Singularity, the actual collateral bonus is `liquidationBonusAmount`, defaulting to 10%. ([code snippet](https://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLiquidation.sol#L197-L199)). Therefore, the minimum liquidated amount required to make user solvent (unable to be liquidated again) is: **numerator / (1 - 80% * 110%) = numerator / 12%**.\n\nAs result, `computeClosingFactor()` function will return a lower liquidated amount than needed to make user solvent, even when that function attempts to over-liquidate with  `_liquidationMultiplier` > `liquidationBonusAmount`.\n\n## Impact\nThis issue will result in the user still being liquidatable after a partial liquidation because it liquidates a lower amount than needed. Therefore, the user will never be solvent again after they are undercollateralized until their position is fully liquidated. This may lead to the user being liquidated more than expected, or experiencing a loss of funds in attempting to recover their position.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/Market.sol#L325-L326\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUse `liquidationCollateralizationRate` instead of `collateralizationRate` to calculate the denominator in `_computeClosingFactor`\n\n\n\n## Discussion\n\n**cryptotechmaker**\n\nFixed by https://github.com/Tapioca-DAO/Tapioca-bar/pull/355\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/355.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/Market.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {ILeverageExecutor} from \"tapioca-periph/interfaces/bar/ILeverageExecutor.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPearlmit} from \"tapioca-periph/interfaces/periph/IPearlmit.sol\";\nimport {IPenrose} from \"tapioca-periph/interfaces/bar/IPenrose.sol\";\nimport {MarketERC20} from \"./MarketERC20.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract Market is MarketERC20, Ownable {\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum PauseType {\n        Borrow,\n        Repay,\n        AddCollateral,\n        RemoveCollateral,\n        Liquidation,\n        LeverageBuy,\n        LeverageSell,\n        AddAsset,\n        RemoveAsset\n    }\n\n    /// @notice pause options\n    mapping(PauseType pauseProp => bool pauseStatus) public pauseOptions;\n    /// @notice conservator's addresss\n    /// @dev conservator can pause/unpause the contract\n    address public conservator;\n\n    /// @notice returns YieldBox address\n    IYieldBox public yieldBox;\n    /// @notice returns Penrose address\n    IPenrose public penrose;\n\n    IPearlmit public pearlmit;\n\n    /// @notice collateral token address\n    IERC20 public collateral;\n    /// @notice collateral token YieldBox id\n    uint256 public collateralId;\n    /// @notice asset token address\n    IERC20 public asset;\n    /// @notice asset token YieldBox id\n    uint256 public assetId;\n    /// @notice oracle address\n    ITapiocaOracle public oracle;\n    /// @notice oracleData\n    bytes public oracleData;\n    /// @notice Exchange and interest rate tracking.\n    /// This is 'cached' here because calls to Oracles can be very expensive.\n    /// Asset -> collateral = assetAmount * exchangeRate.\n    uint256 public exchangeRate;\n    /// @notice cached rate is valid only for the `rateValidDuration` time\n    uint256 public rateValidDuration;\n    /// @notice latest timestamp when `exchangeRate` was updated\n    uint256 public rateTimestamp;\n\n    /// @notice total amount borrowed\n    /// @dev elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\n    Rebase public totalBorrow;\n    /// @notice total collateral supplied\n    uint256 public totalCollateralShare;\n    /// @notice max borrow cap\n    uint256 public totalBorrowCap;\n    /// @notice borrow amount per user\n    mapping(address => uint256) public userBorrowPart;\n    /// @notice collateral share per user\n    mapping(address => uint256) public userCollateralShare;\n\n    /// @notice accrual protocol rewards\n    uint256 public protocolFee; // 10%\n    /// @notice min % a liquidator can receive in rewards\n    uint256 public minLiquidatorReward = 8e4; //80%\n    /// @notice max % a liquidator can receive in rewards\n    uint256 public maxLiquidatorReward = 9e4; //90%\n    /// @notice max liquidatable bonus amount\n    /// @dev max % added to the amount that can be liquidated\n    uint256 public liquidationBonusAmount = 1e4; //10%\n    /// @notice collateralization rate\n    uint256 public collateralizationRate; // 75%\n    /// @notice liquidation collateralization rate\n    uint256 public liquidationCollateralizationRate; //80%\n    /// @notice liquidation multiplier used to compute liquidator rewards\n    uint256 public liquidationMultiplier = 12000; //12%\n    /// @notice returns the leverage executor\n    ILeverageExecutor public leverageExecutor;\n\n    // ***************** //\n    // *** CONSTANTS *** //\n    // ***************** //\n    uint256 internal EXCHANGE_RATE_PRECISION; //not costant, but can only be set in the 'init' method\n    uint256 internal constant FEE_PRECISION = 1e5;\n    uint256 internal constant FEE_PRECISION_DECIMALS = 5;\n\n    error ExchangeRateNotValid();\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when `leverageExecutor` is updated\n    event LeverageExecutorSet(address indexed oldVal, address indexed newVal);\n    /// @notice event emitted when `exchangeRate` validation duration is updated\n    event ExchangeRateDurationUpdated(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when conservator is updated\n    event ConservatorUpdated(address indexed old, address indexed _new);\n    /// @notice event emitted when pause state is changed\n    event PausedUpdated(PauseType indexed _type, bool indexed oldState, bool indexed newState);\n    /// @notice event emitted when cached exchange rate is updated\n    event LogExchangeRate(uint256 indexed rate);\n    /// @notice event emitted when borrow cap is updated\n    event LogBorrowCapUpdated(uint256 indexed _oldVal, uint256 indexed _newVal);\n    /// @notice event emitted when oracle data is updated\n    event OracleDataUpdated();\n    /// @notice event emitted when oracle is updated\n    event OracleUpdated(address newAddr);\n    /// @notice event emitted when a position is liquidated\n    event Liquidated(\n        address indexed liquidator,\n        address[] indexed users,\n        uint256 indexed liquidatorReward,\n        uint256 protocolReward,\n        uint256 repayedAmount,\n        uint256 collateralShareRemoved\n    );\n    /// @notice event emitted when the liquidation multiplier rate is updated\n    event LiquidationMultiplierUpdated(uint256 indexed oldVal, uint256 indexed newVal);\n    /// @notice event emitted on setMarketConfig updates\n    event ValueUpdated(uint256 indexed valType, uint256 indexed _newVal);\n\n    modifier optionNotPaused(PauseType _type) {\n        require(!pauseOptions[_type], \"Market: paused\");\n        _;\n    }\n\n    modifier notSelf(address destination) {\n        require(destination != address(this), \"Market: cannot execute on itself\");\n        _;\n    }\n\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\n    modifier solvent(address from, bool liquidation) {\n        updateExchangeRate();\n        _accrue();\n\n        _;\n\n        require(_isSolvent(from, exchangeRate, liquidation), \"Market: insolvent\");\n    }\n\n    bool internal initialized;\n\n    modifier onlyOnce() {\n        require(!initialized, \"Market: initialized\");\n        _;\n        initialized = true;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice updates `leverageExecutor`\n    /// @param _executor the new ILeverageExecutor\n    function setLeverageExecutor(ILeverageExecutor _executor) external onlyOwner {\n        emit LeverageExecutorSet(address(leverageExecutor), address(_executor));\n        leverageExecutor = _executor;\n    }\n\n    /// @notice sets common market configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    /// @param _oracle oracle address\n    /// @param _oracleData oracle data\n    /// @param _conservator conservator address; conservator is allowed to pause/unpause the contract\n    /// @param _protocolFee protocol fee percentage\n    /// @param _liquidationBonusAmount extra amount factored in the closing factor computation\n    /// @param _minLiquidatorReward minimum reward percentage a liquidator can receive\n    /// @param _maxLiquidatorReward maximum reward percentage a liquidator can receive\n    /// @param _totalBorrowCap max amount that can be borrowed from the contract\n    /// @param _collateralizationRate the new collateralization rate value (75000 is 75%)\n    /// @param _liquidationCollateralizationRate the new liquidation collateralization rate value (75000 is 75%)\n    function setMarketConfig(\n        ITapiocaOracle _oracle,\n        bytes calldata _oracleData,\n        address _conservator,\n        uint256 _protocolFee,\n        uint256 _liquidationBonusAmount,\n        uint256 _minLiquidatorReward,\n        uint256 _maxLiquidatorReward,\n        uint256 _totalBorrowCap,\n        uint256 _collateralizationRate,\n        uint256 _liquidationCollateralizationRate\n    ) external onlyOwner {\n        if (address(_oracle) != address(0)) {\n            oracle = _oracle;\n            emit OracleUpdated(address(_oracle));\n        }\n\n        if (_oracleData.length > 0) {\n            oracleData = _oracleData;\n            emit OracleDataUpdated();\n        }\n\n        if (_conservator != address(0)) {\n            emit ConservatorUpdated(conservator, _conservator);\n            conservator = _conservator;\n        }\n\n        if (_protocolFee > 0) {\n            require(_protocolFee <= FEE_PRECISION, \"Market: not valid\");\n            protocolFee = _protocolFee;\n            emit ValueUpdated(2, _protocolFee);\n        }\n\n        if (_liquidationBonusAmount > 0) {\n            require(_liquidationBonusAmount < FEE_PRECISION, \"Market: not valid\");\n            liquidationBonusAmount = _liquidationBonusAmount;\n            emit ValueUpdated(3, _liquidationBonusAmount);\n        }\n\n        if (_minLiquidatorReward > 0) {\n            require(_minLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(_minLiquidatorReward < maxLiquidatorReward, \"Market: not valid\");\n            minLiquidatorReward = _minLiquidatorReward;\n            emit ValueUpdated(4, _minLiquidatorReward);\n        }\n\n        if (_maxLiquidatorReward > 0) {\n            require(_maxLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(_maxLiquidatorReward > minLiquidatorReward, \"Market: not valid\");\n            maxLiquidatorReward = _maxLiquidatorReward;\n            emit ValueUpdated(5, _maxLiquidatorReward);\n        }\n\n        if (_totalBorrowCap > 0) {\n            emit LogBorrowCapUpdated(totalBorrowCap, _totalBorrowCap);\n            totalBorrowCap = _totalBorrowCap;\n            emit ValueUpdated(6, _totalBorrowCap);\n        }\n\n        if (_collateralizationRate > 0) {\n            require(_collateralizationRate <= FEE_PRECISION, \"Market: not valid\");\n            require(_collateralizationRate <= liquidationCollateralizationRate, \"Market: collateralizationRate too big\");\n            require(\n                _collateralizationRate * (FEE_PRECISION + liquidationMultiplier) < FEE_PRECISION * FEE_PRECISION,\n                \"Market: CR * (1 + LM) >= 1\"\n            );\n            collateralizationRate = _collateralizationRate;\n            emit ValueUpdated(7, _collateralizationRate);\n        }\n\n        if (_liquidationCollateralizationRate > 0) {\n            require(\n                _liquidationCollateralizationRate >= collateralizationRate,\n                \"Market: liquidationCollateralizationRate too small\"\n            );\n            require(_liquidationCollateralizationRate <= FEE_PRECISION, \"Market: not valid\");\n            liquidationCollateralizationRate = _liquidationCollateralizationRate;\n            emit ValueUpdated(8, _liquidationCollateralizationRate);\n        }\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns the maximum liquidatable amount for user\n    /// @param borrowPart amount borrowed\n    /// @param collateralPartInAsset collateral's value in borrowed asset\n    /// @param ratesPrecision collateralizationRate and liquidationCollateralizationRate precision\n    function computeClosingFactor(uint256 borrowPart, uint256 collateralPartInAsset, uint256 ratesPrecision)\n        public\n        view\n        returns (uint256)\n    {\n        return _computeClosingFactor(\n            borrowPart,\n            collateralPartInAsset,\n            ratesPrecision,\n            liquidationCollateralizationRate,\n            liquidationMultiplier,\n            totalBorrow\n        );\n    }\n\n    function _computeClosingFactor(\n        uint256 borrowPart,\n        uint256 collateralPartInAsset,\n        uint256 ratesPrecision,\n        uint256 _liquidationCollateralizationRate,\n        uint256 _liquidationMultiplier,\n        Rebase memory _totalBorrow\n    ) internal view returns (uint256) {\n        // Obviously it's not `borrowPart` anymore but `borrowAmount`\n        borrowPart = (borrowPart * _totalBorrow.elastic) / _totalBorrow.base;\n\n        //borrowPart and collateralPartInAsset should already be scaled due to the exchange rate computation\n        uint256 liquidationStartsAt =\n            (collateralPartInAsset * _liquidationCollateralizationRate) / (10 ** ratesPrecision);\n\n        if (borrowPart < liquidationStartsAt) return 0;\n\n        //compute numerator\n        uint256 numerator = borrowPart - liquidationStartsAt;\n        //compute denominator\n        uint256 diff =\n            (collateralizationRate * ((10 ** ratesPrecision) + _liquidationMultiplier)) / (10 ** ratesPrecision);\n        int256 denominator = (int256(10 ** ratesPrecision) - int256(diff)) * int256(1e13);\n\n        //compute closing factor\n        int256 x = (int256(numerator) * int256(1e18)) / denominator;\n        int256 xPos = x < 0 ? -x : x;\n\n        //assure closing factor validity\n        if (uint256(xPos) > borrowPart) return borrowPart;\n\n        return uint256(xPos);\n    }\n\n    /// @notice return the amount of collateral for a `user` to be solvent, min TVL and max TVL. Returns 0 if user already solvent.\n    /// @dev we use a `CLOSED_COLLATERIZATION_RATE` that is a safety buffer when making the user solvent again,\n    ///      to prevent from being liquidated. This function is valid only if user is not solvent by `_isSolvent()`.\n    /// @param user The user to check solvency.\n    /// @param _exchangeRate the exchange rate asset/collateral.\n    /// @return amountToSolvency the amount of collateral to be solvent.\n    /// @return minTVL the asset value of the collateral amount factored by collateralizationRate\n    /// @return maxTVL the asset value of the collateral amount.\n    function computeTVLInfo(address user, uint256 _exchangeRate)\n        public\n        view\n        returns (uint256 amountToSolvency, uint256 minTVL, uint256 maxTVL)\n    {\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return (0, 0, 0);\n\n        Rebase memory _totalBorrow = _accrueView();\n\n        uint256 collateralAmountInAsset = _computeMaxBorrowableAmount(user, _exchangeRate);\n\n        borrowPart = (borrowPart * _totalBorrow.elastic) / _totalBorrow.base;\n\n        unchecked {\n            amountToSolvency = borrowPart >= collateralAmountInAsset ? borrowPart - collateralAmountInAsset : 0;\n        }\n        (minTVL, maxTVL) = _computeMaxAndMinLTVInAsset(userCollateralShare[user], _exchangeRate);\n    }\n\n    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.\n    /// @dev This function is supposed to be invoked if needed because Oracle queries can be expensive.\n    ///      Oracle should consider USDO at 1$\n    /// @return updated True if `exchangeRate` was updated.\n    /// @return rate The new exchange rate.\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\n        (updated, rate) = oracle.get(oracleData);\n\n        if (updated) {\n            require(rate != 0, \"Market: invalid rate\");\n            exchangeRate = rate;\n            rateTimestamp = block.timestamp;\n            emit LogExchangeRate(rate);\n        } else {\n            require(rateTimestamp + rateValidDuration >= block.timestamp, \"Market: rate too old\");\n            // Return the old rate if fetching wasn't successful & rate isn't too old\n            rate = exchangeRate;\n        }\n    }\n\n    /// @notice computes the possible liquidator reward\n    /// @param user the user for which a liquidation operation should be performed\n    /// @param _exchangeRate the exchange rate asset/collateral to use for internal computations\n    function computeLiquidatorReward(address user, uint256 _exchangeRate) external view returns (uint256) {\n        return _getCallerReward(user, _exchangeRate);\n    }\n\n    // ************************** //\n    // *** INTERNAL FUNCTIONS *** //\n    // ************************** //\n    function _accrue() internal virtual;\n\n    function _accrueView() internal view virtual returns (Rebase memory);\n\n    /**\n     * @inheritdoc MarketERC20\n     */\n    function _allowedLend(address from, uint256 share) internal virtual override {\n        if (from != msg.sender) {\n            require(allowance[from][msg.sender] >= share, \"Market: not approved\");\n            if (allowance[from][msg.sender] != type(uint256).max) {\n                allowance[from][msg.sender] -= share;\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc MarketERC20\n     */\n    function _allowedBorrow(address from, uint256 share) internal virtual override {\n        if (from != msg.sender) {\n            // TODO review risk of using this\n            (uint256 pearlmitAllowed,) = penrose.pearlmit().allowance(from, msg.sender, address(yieldBox), collateralId);\n            require(allowanceBorrow[from][msg.sender] >= share || pearlmitAllowed >= share, \"Market: not approved\");\n            if (allowanceBorrow[from][msg.sender] != type(uint256).max) {\n                allowanceBorrow[from][msg.sender] -= share;\n            }\n        }\n    }\n\n    function _updateOracleRateForLiquidations() internal {\n        try oracle.get(oracleData) returns (bool _updated, uint256 _exchangeRate) {\n            if (_updated && _exchangeRate > 0) {\n                exchangeRate = _exchangeRate; //update cached rate\n                rateTimestamp = block.timestamp;\n            } else {\n                _exchangeRate = exchangeRate; //use stored rate\n                if (_exchangeRate == 0) revert ExchangeRateNotValid();\n            }\n        } catch {\n            if (exchangeRate == 0) revert ExchangeRateNotValid();\n        }\n    }\n\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (bytes memory) {\n        if (_returnData.length > 1000) return \"Market: reason too long\";\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Market: no return data\";\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return _returnData; // All that remains is the revert string\n    }\n\n    function _computeMaxBorrowableAmount(address user, uint256 _exchangeRate)\n        internal\n        view\n        returns (uint256 collateralAmountInAsset)\n    {\n        require(_exchangeRate > 0, \"Market: exchangeRate not valid\");\n        uint256 userCollateralAmount = yieldBox.toAmount(collateralId, userCollateralShare[user], false);\n        collateralAmountInAsset =\n            (userCollateralAmount * (EXCHANGE_RATE_PRECISION / FEE_PRECISION) * collateralizationRate) / _exchangeRate;\n    }\n\n    /// @notice Concrete implementation of `isSolvent`. Includes a parameter to allow caching `exchangeRate`.\n    /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.\n    function _isSolvent(address user, uint256 _exchangeRate, bool _liquidation) internal view returns (bool) {\n        // accrue must have already been called!\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return true;\n        uint256 collateralShare = userCollateralShare[user];\n        if (collateralShare == 0) return false;\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 collateralAmount = yieldBox.toAmount(collateralId, collateralShare, false);\n        return collateralAmount * (EXCHANGE_RATE_PRECISION / FEE_PRECISION)\n            * (_liquidation ? liquidationCollateralizationRate : collateralizationRate)\n        // Moved exchangeRate here instead of dividing the other side to preserve more precision\n        >= (borrowPart * _totalBorrow.elastic * _exchangeRate) / _totalBorrow.base;\n    }\n\n    /// @notice Returns the min and max LTV for user in asset price\n    function _computeMaxAndMinLTVInAsset(uint256 collateralShare, uint256 _exchangeRate)\n        internal\n        view\n        returns (uint256 min, uint256 max)\n    {\n        require(_exchangeRate > 0, \"Market: exchangeRate not valid\");\n        uint256 collateralAmount = yieldBox.toAmount(collateralId, collateralShare, false);\n\n        max = (collateralAmount * EXCHANGE_RATE_PRECISION) / _exchangeRate;\n        min = (max * collateralizationRate) / FEE_PRECISION;\n    }\n\n    function _getCallerReward(address user, uint256 _exchangeRate) internal view returns (uint256) {\n        (uint256 startTVLInAsset, uint256 maxTVLInAsset) =\n            _computeMaxAndMinLTVInAsset(userCollateralShare[user], _exchangeRate);\n\n        uint256 borrowed = userBorrowPart[user];\n        if (borrowed == 0) return 0;\n        if (startTVLInAsset == 0) return 0;\n\n        borrowed = (borrowed * totalBorrow.elastic) / totalBorrow.base;\n\n        if (borrowed < startTVLInAsset) return 0;\n        if (borrowed >= maxTVLInAsset) return minLiquidatorReward;\n\n        uint256 rewardPercentage = ((borrowed - startTVLInAsset) * FEE_PRECISION) / (maxTVLInAsset - startTVLInAsset);\n\n        int256 diff = int256(minLiquidatorReward) - int256(maxLiquidatorReward);\n        int256 reward = (diff * int256(rewardPercentage)) / int256(FEE_PRECISION) + int256(maxLiquidatorReward);\n\n        if (reward < int256(minLiquidatorReward)) {\n            reward = int256(minLiquidatorReward);\n        }\n\n        return uint256(reward);\n    }\n\n    function _computeAllowanceAmountInAsset(\n        address user,\n        uint256 _exchangeRate,\n        uint256 borrowAmount,\n        uint256 assetDecimals\n    ) internal view returns (uint256) {\n        uint256 maxBorrowable = _computeMaxBorrowableAmount(user, _exchangeRate);\n\n        uint256 shareRatio = _getRatio(borrowAmount, maxBorrowable, assetDecimals);\n        return (shareRatio * userCollateralShare[user]) / (10 ** assetDecimals);\n    }\n\n    function _getRatio(uint256 numerator, uint256 denominator, uint256 precision) internal pure returns (uint256) {\n        if (numerator == 0 || denominator == 0) {\n            return 0;\n        }\n        uint256 _numerator = numerator * 10 ** (precision + 1);\n        uint256 _quotient = ((_numerator / denominator) + 5) / 10;\n        return (_quotient);\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BigBang.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {ILeverageExecutor} from \"tapioca-periph/interfaces/bar/ILeverageExecutor.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPearlmit} from \"tapioca-periph/interfaces/periph/IPearlmit.sol\";\nimport {IPenrose} from \"tapioca-periph/interfaces/bar/IPenrose.sol\";\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBLiquidation} from \"./BBLiquidation.sol\";\nimport {BBCollateral} from \"./BBCollateral.sol\";\nimport {BBLeverage} from \"./BBLeverage.sol\";\nimport {BBCommon} from \"./BBCommon.sol\";\nimport {BBBorrow} from \"./BBBorrow.sol\";\n\n// solhint-disable max-line-length\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BigBang is BBCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n    using SafeApprove for address;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error BadPair();\n    error DebtRatesNotValid();\n    error MaxDebtRateNotValid();\n    error NotValid();\n    error ModuleNotSet();\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    /// @notice enum representing each type of module associated with a Singularity market\n    /// @dev modules are contracts that holds a portion of the market's logic\n    enum Module {\n        Base,\n        Borrow,\n        Collateral,\n        Liquidation,\n        Leverage\n    }\n    /// @notice returns the liquidation module\n\n    BBLiquidation public liquidationModule;\n    /// @notice returns the borrow module\n    BBBorrow public borrowModule;\n    /// @notice returns the collateral module\n    BBCollateral public collateralModule;\n    /// @notice returns the leverage module\n    BBLeverage public leverageModule;\n\n    struct _InitMemoryData {\n        IPenrose _penrose;\n        IERC20 _collateral;\n        uint256 _collateralId;\n        ITapiocaOracle _oracle;\n        uint256 _exchangeRatePrecision;\n        uint256 _collateralizationRate;\n        uint256 _liquidationCollateralizationRate;\n        ILeverageExecutor _leverageExecutor;\n    }\n\n    struct _InitMemoryModulesData {\n        address _liquidationModule;\n        address _borrowModule;\n        address _collateralModule;\n        address _leverageModule;\n    }\n\n    struct _InitMemoryDebtData {\n        uint256 _debtRateAgainstEth;\n        uint256 _debtRateMin;\n        uint256 _debtRateMax;\n    }\n\n    /// @notice The init function that acts as a constructor\n    function init(bytes calldata initData) external onlyOnce {\n        (\n            _InitMemoryModulesData memory initModulesData,\n            _InitMemoryDebtData memory initDebtData,\n            _InitMemoryData memory initMemoryData\n        ) = abi.decode(initData, (_InitMemoryModulesData, _InitMemoryDebtData, _InitMemoryData));\n\n        _initModules(\n            initModulesData._liquidationModule,\n            initModulesData._borrowModule,\n            initModulesData._collateralModule,\n            initModulesData._leverageModule\n        );\n        _initCoreStorage(\n            initMemoryData._penrose,\n            initMemoryData._collateral,\n            initMemoryData._collateralId,\n            initMemoryData._oracle,\n            initMemoryData._exchangeRatePrecision,\n            initMemoryData._collateralizationRate,\n            initMemoryData._liquidationCollateralizationRate,\n            initMemoryData._leverageExecutor\n        );\n        _initDebtStorage(initDebtData._debtRateAgainstEth, initDebtData._debtRateMin, initDebtData._debtRateMax);\n    }\n\n    function _initModules(\n        address _liquidationModule,\n        address _borrowModule,\n        address _collateralModule,\n        address _leverageModule\n    ) private {\n        liquidationModule = BBLiquidation(_liquidationModule);\n        collateralModule = BBCollateral(_collateralModule);\n        borrowModule = BBBorrow(_borrowModule);\n        leverageModule = BBLeverage(_leverageModule);\n    }\n\n    function _initDebtStorage(uint256 _debtRateAgainstEth, uint256 _debtRateMin, uint256 _debtRateMax) private {\n        isMainMarket = collateralId == penrose.mainAssetId();\n        if (!isMainMarket) {\n            if (minDebtRate != 0 && maxDebtRate != 0) {\n                if (_debtRateMin >= _debtRateMax) revert DebtRatesNotValid();\n                if (_debtRateMax > 1e18) revert MaxDebtRateNotValid();\n            }\n            debtRateAgainstEthMarket = _debtRateAgainstEth;\n            maxDebtRate = _debtRateMax;\n            minDebtRate = _debtRateMin;\n        }\n    }\n\n    function _initCoreStorage(\n        IPenrose _penrose,\n        IERC20 _collateral,\n        uint256 _collateralId,\n        ITapiocaOracle _oracle,\n        uint256 _exchangeRatePrecision,\n        uint256 _collateralizationRate,\n        uint256 _liquidationCollateralizationRate,\n        ILeverageExecutor _leverageExecutor\n    ) private {\n        penrose = _penrose;\n        pearlmit = IPearlmit(_penrose.pearlmit());\n        yieldBox = IYieldBox(_penrose.yieldBox());\n\n        address _asset = penrose.usdoToken();\n\n        if (address(_collateral) == address(0)) revert BadPair();\n        if (address(_asset) == address(0)) revert BadPair();\n        if (address(_oracle) == address(0)) revert BadPair();\n        if (_collateralizationRate > FEE_PRECISION) revert NotValid();\n        if (_liquidationCollateralizationRate > FEE_PRECISION) {\n            revert NotValid();\n        }\n        asset = IERC20(_asset);\n        assetId = penrose.usdoAssetId();\n        collateral = _collateral;\n        collateralId = _collateralId;\n        oracle = _oracle;\n        updateExchangeRate();\n        protocolFee = 10000; // 10%; used for accrual\n        collateralizationRate = _collateralizationRate > 0 ? _collateralizationRate : 75000;\n        liquidationCollateralizationRate =\n            _liquidationCollateralizationRate > 0 ? _liquidationCollateralizationRate : 80000;\n\n        if (liquidationCollateralizationRate < collateralizationRate) {\n            revert NotValid();\n        }\n\n        EXCHANGE_RATE_PRECISION = _exchangeRatePrecision > 0 ? _exchangeRatePrecision : 1e18;\n\n        minLiquidatorReward = 8e4;\n        maxLiquidatorReward = 9e4;\n        liquidationBonusAmount = 1e4;\n        liquidationMultiplier = 12000; //12%\n\n        rateValidDuration = 24 hours;\n        minMintFee = 0;\n        maxMintFee = 1000; // 1%\n        maxMintFeeStart = 975000000000000000; // 0.975 *1e18\n        minMintFeeStart = 1000000000000000000; // 1*1e18\n\n        leverageExecutor = _leverageExecutor;\n\n        _transferOwnership(address(penrose));\n        conservator = address(penrose);\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @notice Allows batched call to BingBang.\n    /// @param calls An array encoded call data.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    function execute(Module[] calldata modules, bytes[] calldata calls, bool revertOnFail)\n        external\n        nonReentrant\n        returns (bool[] memory successes, bytes[] memory results)\n    {\n        successes = new bool[](calls.length);\n        results = new bytes[](calls.length);\n        if (modules.length != calls.length) revert NotValid();\n        unchecked {\n            for (uint256 i; i < calls.length; i++) {\n                (bool success, bytes memory result) = _extractModule(modules[i]).delegatecall(calls[i]);\n\n                if (!success && revertOnFail) {\n                    revert(abi.decode(_getRevertMsg(result), (string)));\n                }\n                successes[i] = success;\n                results[i] = !success ? _getRevertMsg(result) : result;\n            }\n        }\n    }\n\n    // ************************* //\n    // *** OWNER FUNCTIONS ***** //\n    // ************************* //\n    /// @notice updates the pause state of the contract\n    /// @dev can only be called by the conservator\n    /// @param val the new value\n    function updatePause(PauseType _type, bool val) external {\n        require(msg.sender == conservator, \"Market: unauthorized\");\n        require(val != pauseOptions[_type], \"Market: same state\");\n        emit PausedUpdated(_type, pauseOptions[_type], val);\n        pauseOptions[_type] = val;\n    }\n\n    /// @notice updates the pause state of the contract for all types\n    /// @param val the new val\n    function updatePauseAll(bool val) external {\n        require(msg.sender == conservator, \"Market: unauthorized\");\n\n        pauseOptions[PauseType.Borrow] = val;\n        pauseOptions[PauseType.Repay] = val;\n        pauseOptions[PauseType.AddCollateral] = val;\n        pauseOptions[PauseType.RemoveCollateral] = val;\n        pauseOptions[PauseType.Liquidation] = val;\n        pauseOptions[PauseType.LeverageBuy] = val;\n        pauseOptions[PauseType.LeverageSell] = val;\n\n        emit PausedUpdated(PauseType.Borrow, pauseOptions[PauseType.Borrow], val);\n        emit PausedUpdated(PauseType.Repay, pauseOptions[PauseType.Repay], val);\n        emit PausedUpdated(PauseType.AddCollateral, pauseOptions[PauseType.AddCollateral], val);\n        emit PausedUpdated(PauseType.RemoveCollateral, pauseOptions[PauseType"
    }
  ]
}