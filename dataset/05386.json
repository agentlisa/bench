{
  "Title": "[NC-01] Typo mistakes",
  "Content": "https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/MaxHeap.sol#L64\n\n```diff\n-    /// @notice Struct to represent an item in the heap by it's ID\n+    /// @notice Struct to represent an item in the heap by its ID\n```\nhttps://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/MaxHeap.sol#L64-L65\n\n```diff\n-    /// @notice Struct to represent an item in the heap by it's ID\n    mapping(uint256 => uint256) public heap;\n+    /// @notice Mapping to represent an item in the heap by it's ID\n    mapping(uint256 => uint256) public heap;\n```\nhttps://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/CultureIndex.sol#L437-L438\n\n```diff\n-        // Ensure to address is not 0\n        if (from == address(0)) revert ADDRESS_ZERO();\n+        // Ensure from address is not 0\n        if (from == address(0)) revert ADDRESS_ZERO();\n```\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/revolution/src/MaxHeap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\n/// @title MaxHeap implementation in Solidity\n/// @dev This contract implements a Max Heap data structure with basic operations\n/// @author Written by rocketman and gpt4\ncontract MaxHeap is VersionedContract, UUPS, Ownable2StepUpgradeable, ReentrancyGuardUpgradeable {\n    /// @notice The parent contract that is allowed to update the data store\n    address public admin;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                          MODIFIERS                       ///\n    ///                                                          ///\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Sender is not the admin\");\n        _;\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initializes the maxheap contract\n     * @param _initialOwner The initial owner of the contract\n     * @param _admin The contract that is allowed to update the data store\n     */\n    function initialize(address _initialOwner, address _admin) public initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        admin = _admin;\n\n        __Ownable_init(_initialOwner);\n        __ReentrancyGuard_init();\n    }\n\n    /// @notice Struct to represent an item in the heap by it's ID\n    mapping(uint256 => uint256) public heap;\n\n    uint256 public size = 0;\n\n    /// @notice Mapping to keep track of the value of an item in the heap\n    mapping(uint256 => uint256) public valueMapping;\n\n    /// @notice Mapping to keep track of the position of an item in the heap\n    mapping(uint256 => uint256) public positionMapping;\n\n    /// @notice Get the parent index of a given position\n    /// @param pos The position for which to find the parent\n    /// @return The index of the parent node\n    function parent(uint256 pos) private pure returns (uint256) {\n        require(pos != 0, \"Position should not be zero\");\n        return (pos - 1) / 2;\n    }\n\n    /// @notice Swap two nodes in the heap\n    /// @param fpos The position of the first node\n    /// @param spos The position of the second node\n    function swap(uint256 fpos, uint256 spos) private {\n        (heap[fpos], heap[spos]) = (heap[spos], heap[fpos]);\n        (positionMapping[heap[fpos]], positionMapping[heap[spos]]) = (fpos, spos);\n    }\n\n    /// @notice Reheapify the heap starting at a given position\n    /// @dev This ensures that the heap property is maintained\n    /// @param pos The starting position for the heapify operation\n    function maxHeapify(uint256 pos) internal {\n        uint256 left = 2 * pos + 1;\n        uint256 right = 2 * pos + 2;\n\n        uint256 posValue = valueMapping[heap[pos]];\n        uint256 leftValue = valueMapping[heap[left]];\n        uint256 rightValue = valueMapping[heap[right]];\n\n        if (pos >= (size / 2) && pos <= size) return;\n\n        if (posValue < leftValue || posValue < rightValue) {\n            if (leftValue > rightValue) {\n                swap(pos, left);\n                maxHeapify(left);\n            } else {\n                swap(pos, right);\n                maxHeapify(right);\n            }\n        }\n    }\n\n    /// @notice Insert an element into the heap\n    /// @dev The function will revert if the heap is full\n    /// @param itemId The item ID to insert\n    /// @param value The value to insert\n    function insert(uint256 itemId, uint256 value) public onlyAdmin {\n        heap[size] = itemId;\n        valueMapping[itemId] = value; // Update the value mapping\n        positionMapping[itemId] = size; // Update the position mapping\n\n        uint256 current = size;\n        while (current != 0 && valueMapping[heap[current]] > valueMapping[heap[parent(current)]]) {\n            swap(current, parent(current));\n            current = parent(current);\n        }\n        size++;\n    }\n\n    /// @notice Update the value of an existing item in the heap\n    /// @param itemId The item ID whose vote count needs to be updated\n    /// @param newValue The new value for the item\n    /// @dev This function adjusts the heap to maintain the max-heap property after updating the vote count\n    function updateValue(uint256 itemId, uint256 newValue) public onlyAdmin {\n        uint256 position = positionMapping[itemId];\n        uint256 oldValue = valueMapping[itemId];\n\n        // Update the value in the valueMapping\n        valueMapping[itemId] = newValue;\n\n        // Decide whether to perform upwards or downwards heapify\n        if (newValue > oldValue) {\n            // Upwards heapify\n            while (position != 0 && valueMapping[heap[position]] > valueMapping[heap[parent(position)]]) {\n                swap(position, parent(position));\n                position = parent(position);\n            }\n        } else if (newValue < oldValue) maxHeapify(position); // Downwards heapify\n    }\n\n    /// @notice Extract the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function extractMax() external onlyAdmin returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n\n        uint256 popped = heap[0];\n        heap[0] = heap[--size];\n        maxHeapify(0);\n\n        return (popped, valueMapping[popped]);\n    }\n\n    /// @notice Get the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function getMax() public view returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n        return (heap[0], valueMapping[heap[0]]);\n    }\n\n    ///                                                          ///\n    ///                     MAX HEAP UPGRADE                     ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/MaxHeap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\n/// @title MaxHeap implementation in Solidity\n/// @dev This contract implements a Max Heap data structure with basic operations\n/// @author Written by rocketman and gpt4\ncontract MaxHeap is VersionedContract, UUPS, Ownable2StepUpgradeable, ReentrancyGuardUpgradeable {\n    /// @notice The parent contract that is allowed to update the data store\n    address public admin;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                          MODIFIERS                       ///\n    ///                                                          ///\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Sender is not the admin\");\n        _;\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initializes the maxheap contract\n     * @param _initialOwner The initial owner of the contract\n     * @param _admin The contract that is allowed to update the data store\n     */\n    function initialize(address _initialOwner, address _admin) public initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        admin = _admin;\n\n        __Ownable_init(_initialOwner);\n        __ReentrancyGuard_init();\n    }\n\n    /// @notice Struct to represent an item in the heap by it's ID\n    mapping(uint256 => uint256) public heap;\n\n    uint256 public size = 0;\n\n    /// @notice Mapping to keep track of the value of an item in the heap\n    mapping(uint256 => uint256) public valueMapping;\n\n    /// @notice Mapping to keep track of the position of an item in the heap\n    mapping(uint256 => uint256) public positionMapping;\n\n    /// @notice Get the parent index of a given position\n    /// @param pos The position for which to find the parent\n    /// @return The index of the parent node\n    function parent(uint256 pos) private pure returns (uint256) {\n        require(pos != 0, \"Position should not be zero\");\n        return (pos - 1) / 2;\n    }\n\n    /// @notice Swap two nodes in the heap\n    /// @param fpos The position of the first node\n    /// @param spos The position of the second node\n    function swap(uint256 fpos, uint256 spos) private {\n        (heap[fpos], heap[spos]) = (heap[spos], heap[fpos]);\n        (positionMapping[heap[fpos]], positionMapping[heap[spos]]) = (fpos, spos);\n    }\n\n    /// @notice Reheapify the heap starting at a given position\n    /// @dev This ensures that the heap property is maintained\n    /// @param pos The starting position for the heapify operation\n    function maxHeapify(uint256 pos) internal {\n        uint256 left = 2 * pos + 1;\n        uint256 right = 2 * pos + 2;\n\n        uint256 posValue = valueMapping[heap[pos]];\n        uint256 leftValue = valueMapping[heap[left]];\n        uint256 rightValue = valueMapping[heap[right]];\n\n        if (pos >= (size / 2) && pos <= size) return;\n\n        if (posValue < leftValue || posValue < rightValue) {\n            if (leftValue > rightValue) {\n                swap(pos, left);\n                maxHeapify(left);\n            } else {\n                swap(pos, right);\n                maxHeapify(right);\n            }\n        }\n    }\n\n    /// @notice Insert an element into the heap\n    /// @dev The function will revert if the heap is full\n    /// @param itemId The item ID to insert\n    /// @param value The value to insert\n    function insert(uint256 itemId, uint256 value) public onlyAdmin {\n        heap[size] = itemId;\n        valueMapping[itemId] = value; // Update the value mapping\n        positionMapping[itemId] = size; // Update the position mapping\n\n        uint256 current = size;\n        while (current != 0 && valueMapping[heap[current]] > valueMapping[heap[parent(current)]]) {\n            swap(current, parent(current));\n            current = parent(current);\n        }\n        size++;\n    }\n\n    /// @notice Update the value of an existing item in the heap\n    /// @param itemId The item ID whose vote count needs to be updated\n    /// @param newValue The new value for the item\n    /// @dev This function adjusts the heap to maintain the max-heap property after updating the vote count\n    function updateValue(uint256 itemId, uint256 newValue) public onlyAdmin {\n        uint256 position = positionMapping[itemId];\n        uint256 oldValue = valueMapping[itemId];\n\n        // Update the value in the valueMapping\n        valueMapping[itemId] = newValue;\n\n        // Decide whether to perform upwards or downwards heapify\n        if (newValue > oldValue) {\n            // Upwards heapify\n            while (position != 0 && valueMapping[heap[position]] > valueMapping[heap[parent(position)]]) {\n                swap(position, parent(position));\n                position = parent(position);\n            }\n        } else if (newValue < oldValue) maxHeapify(position); // Downwards heapify\n    }\n\n    /// @notice Extract the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function extractMax() external onlyAdmin returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n\n        uint256 popped = heap[0];\n        heap[0] = heap[--size];\n        maxHeapify(0);\n\n        return (popped, valueMapping[popped]);\n    }\n\n    /// @notice Get the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function getMax() public view returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n        return (heap[0], valueMapping[heap[0]]);\n    }\n\n    ///                                                          ///\n    ///                     MAX HEAP UPGRADE                     ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/CultureIndex.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\nimport { ERC20VotesUpgradeable } from \"./base/erc20/ERC20VotesUpgradeable.sol\";\nimport { MaxHeap } from \"./MaxHeap.sol\";\nimport { ICultureIndex } from \"./interfaces/ICultureIndex.sol\";\n\nimport { ERC721CheckpointableUpgradeable } from \"./base/ERC721CheckpointableUpgradeable.sol\";\nimport { EIP712Upgradeable } from \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract CultureIndex is\n    ICultureIndex,\n    VersionedContract,\n    UUPS,\n    Ownable2StepUpgradeable,\n    ReentrancyGuardUpgradeable,\n    EIP712Upgradeable\n{\n    /// @notice The EIP-712 typehash for gasless votes\n    bytes32 public constant VOTE_TYPEHASH =\n        keccak256(\"Vote(address from,uint256[] pieceIds,uint256 nonce,uint256 deadline)\");\n\n    /// @notice An account's nonce for gasless votes\n    mapping(address => uint256) public nonces;\n\n    // The MaxHeap data structure used to keep track of the top-voted piece\n    MaxHeap public maxHeap;\n\n    // The ERC20 token used for voting\n    ERC20VotesUpgradeable public erc20VotingToken;\n\n    // The ERC721 token used for voting\n    ERC721CheckpointableUpgradeable public erc721VotingToken;\n\n    // The weight of the 721 voting token\n    uint256 public erc721VotingTokenWeight;\n\n    /// @notice The maximum settable quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS = 6_000; // 6,000 basis points or 60%\n\n    /// @notice The minimum vote weight required in order to vote\n    uint256 public minVoteWeight;\n\n    /// @notice The basis point number of votes in support of a art piece required in order for a quorum to be reached and for an art piece to be dropped.\n    uint256 public quorumVotesBPS;\n\n    /// @notice The name of the culture index\n    string public name;\n\n    /// @notice A description of the culture index - can include rules or guidelines\n    string public description;\n\n    // The list of all pieces\n    mapping(uint256 => ArtPiece) public pieces;\n\n    // The internal piece ID tracker\n    uint256 public _currentPieceId;\n\n    // The mapping of all votes for a piece\n    mapping(uint256 => mapping(address => Vote)) public votes;\n\n    // The total voting weight for a piece\n    mapping(uint256 => uint256) public totalVoteWeights;\n\n    // Constant for max number of creators\n    uint256 public constant MAX_NUM_CREATORS = 100;\n\n    // The address that is allowed to drop art pieces\n    address public dropperAdmin;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initializes a token's metadata descriptor\n     * @param _erc20VotingToken The address of the ERC20 voting token, commonly referred to as \"points\"\n     * @param _erc721VotingToken The address of the ERC721 voting token, commonly the dropped art pieces\n     * @param _initialOwner The owner of the contract, allowed to drop pieces. Commonly updated to the AuctionHouse\n     * @param _maxHeap The address of the max heap contract\n     * @param _dropperAdmin The address that can drop new art pieces\n     * @param _cultureIndexParams The CultureIndex settings\n     */\n    function initialize(\n        address _erc20VotingToken,\n        address _erc721VotingToken,\n        address _initialOwner,\n        address _maxHeap,\n        address _dropperAdmin,\n        IRevolutionBuilder.CultureIndexParams memory _cultureIndexParams\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        require(_cultureIndexParams.quorumVotesBPS <= MAX_QUORUM_VOTES_BPS, \"invalid quorum bps\");\n        require(_cultureIndexParams.erc721VotingTokenWeight > 0, \"invalid erc721 voting token weight\");\n        require(_erc721VotingToken != address(0), \"invalid erc721 voting token\");\n        require(_erc20VotingToken != address(0), \"invalid erc20 voting token\");\n\n        // Setup ownable\n        __Ownable_init(_initialOwner);\n\n        // Initialize EIP-712 support\n        __EIP712_init(string.concat(_cultureIndexParams.name, \" CultureIndex\"), \"1\");\n\n        __ReentrancyGuard_init();\n\n        erc20VotingToken = ERC20VotesUpgradeable(_erc20VotingToken);\n        erc721VotingToken = ERC721CheckpointableUpgradeable(_erc721VotingToken);\n        erc721VotingTokenWeight = _cultureIndexParams.erc721VotingTokenWeight;\n        name = _cultureIndexParams.name;\n        description = _cultureIndexParams.description;\n        quorumVotesBPS = _cultureIndexParams.quorumVotesBPS;\n        minVoteWeight = _cultureIndexParams.minVoteWeight;\n        dropperAdmin = _dropperAdmin;\n\n        emit QuorumVotesBPSSet(quorumVotesBPS, _cultureIndexParams.quorumVotesBPS);\n\n        // Create maxHeap\n        maxHeap = MaxHeap(_maxHeap);\n    }\n\n    ///                                                          ///\n    ///                         MODIFIERS                        ///\n    ///                                                          ///\n\n    /**\n     *  Validates the media type and associated data.\n     * @param metadata The metadata associated with the art piece.\n     *\n     * Requirements:\n     * - The media type must be one of the defined types in the MediaType enum.\n     * - The corresponding media data must not be empty.\n     */\n    function validateMediaType(ArtPieceMetadata calldata metadata) internal pure {\n        require(uint8(metadata.mediaType) > 0 && uint8(metadata.mediaType) <= 5, \"Invalid media type\");\n\n        if (metadata.mediaType == MediaType.IMAGE)\n            require(bytes(metadata.image).length > 0, \"Image URL must be provided\");\n        else if (metadata.mediaType == MediaType.ANIMATION)\n            require(bytes(metadata.animationUrl).length > 0, \"Animation URL must be provided\");\n        else if (metadata.mediaType == MediaType.TEXT)\n            require(bytes(metadata.text).length > 0, \"Text must be provided\");\n    }\n\n    /**\n     * @notice Checks the total basis points from an array of creators and returns the length\n     * @param creatorArray An array of Creator structs containing address and basis points.\n     * @return Returns the total basis points calculated from the array of creators.\n     *\n     * Requirements:\n     * - The `creatorArray` must not contain any zero addresses.\n     * - The function will return the length of the `creatorArray`.\n     */\n    function validateCreatorsArray(CreatorBps[] calldata creatorArray) internal pure returns (uint256) {\n        uint256 creatorArrayLength = creatorArray.length;\n        //Require that creatorArray is not more than MAX_NUM_CREATORS to prevent gas limit issues\n        require(creatorArrayLength <= MAX_NUM_CREATORS, \"Creator array must not be > MAX_NUM_CREATORS\");\n\n        uint256 totalBps;\n        for (uint i; i < creatorArrayLength; i++) {\n            require(creatorArray[i].creator != address(0), \"Invalid creator address\");\n            totalBps += creatorArray[i].bps;\n        }\n\n        require(totalBps == 10_000, \"Total BPS must sum up to 10,000\");\n\n        return creatorArrayLength;\n    }\n\n    /**\n     * @notice Creates a new piece of art with associated metadata and creators.\n     * @param metadata The metadata associated with the art piece, including name, description, image, and optional animation URL.\n     * @param creatorArray An array of creators who contributed to the piece, along with their respective basis points that must sum up to 10,000.\n     * @return Returns the unique ID of the newly created art piece.\n     *\n     * Emits a {PieceCreated} event for the newly created piece.\n     * Emits a {PieceCreatorAdded} event for each creator added to the piece.\n     *\n     * Requirements:\n     * - `metadata` must include name, description, and image. Animation URL is optional.\n     * - `creatorArray` must not contain any zero addresses.\n     * - The sum of basis points in `creatorArray` must be exactly 10,000.\n     */\n    function createPiece(\n        ArtPieceMetadata calldata metadata,\n        CreatorBps[] calldata creatorArray\n    ) public returns (uint256) {\n        uint256 creatorArrayLength = validateCreatorsArray(creatorArray);\n\n        // Validate the media type and associated data\n        validateMediaType(metadata);\n\n        uint256 pieceId = _currentPieceId++;\n\n        /// @dev Insert the new piece into the max heap\n        maxHeap.insert(pieceId, 0);\n\n        ArtPiece storage newPiece = pieces[pieceId];\n\n        newPiece.pieceId = pieceId;\n        newPiece.totalVotesSupply = _calculateVoteWeight(\n            erc20VotingToken.totalSupply(),\n            erc721VotingToken.totalSupply()\n        );\n        newPiece.totalERC20Supply = erc20VotingToken.totalSupply();\n        newPiece.metadata = metadata;\n        newPiece.sponsor = msg.sender;\n        newPiece.creationBlock = block.number;\n        newPiece.quorumVotes = (quorumVotesBPS * newPiece.totalVotesSupply) / 10_000;\n\n        for (uint i; i < creatorArrayLength; i++) {\n            newPiece.creators.push(creatorArray[i]);\n        }\n\n        emit PieceCreated(pieceId, msg.sender, metadata, newPiece.quorumVotes, newPiece.totalVotesSupply);\n\n        // Emit an event for each creator\n        for (uint i; i < creatorArrayLength; i++) {\n            emit PieceCreatorAdded(pieceId, creatorArray[i].creator, msg.sender, creatorArray[i].bps);\n        }\n\n        return newPiece.pieceId;\n    }\n\n    /**\n     * @notice Checks if a specific voter has already voted for a given art piece.\n     * @param pieceId The ID of the art piece.\n     * @param voter The address of the voter.\n     * @return A boolean indicating if the voter has voted for the art piece.\n     */\n    function hasVoted(uint256 pieceId, address voter) external view returns (bool) {\n        return votes[pieceId][voter].voterAddress != address(0);\n    }\n\n    /**\n     * @notice Returns the voting power of a voter at the current block.\n     * @param account The address of the voter.\n     * @return The voting power of the voter.\n     */\n    function getVotes(address account) external view override returns (uint256) {\n        return _getVotes(account);\n    }\n\n    /**\n     * @notice Returns the voting power of a voter at the current block.\n     * @param account The address of the voter.\n     * @return The voting power of the voter.\n     */\n    function getPastVotes(address account, uint256 blockNumber) external view override returns (uint256) {\n        return _getPastVotes(account, blockNumber);\n    }\n\n    /**\n     * @notice Calculates the vote weight of a voter.\n     * @param erc20Balance The ERC20 balance of the voter.\n     * @param erc721Balance The ERC721 balance of the voter.\n     * @return The vote weight of the voter.\n     */\n    function _calculateVoteWeight(uint256 erc20Balance, uint256 erc721Balance) internal view returns (uint256) {\n        return erc20Balance + (erc721Balance * erc721VotingTokenWeight * 1e18);\n    }\n\n    function _getVotes(address account) internal view returns (uint256) {\n        return _calculateVoteWeight(erc20VotingToken.getVotes(account), erc721VotingToken.getVotes(account));\n    }\n\n    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256) {\n        return\n            _calculateVoteWeight(\n                erc20VotingToken.getPastVotes(account, blockNumber),\n                erc721VotingToken.getPastVotes(account, blockNumber)\n            );\n    }\n\n    /**\n     * @notice Cast a vote for a specific ArtPiece.\n     * @param pieceId The ID of the ArtPiece to vote for.\n     * @param voter The address of the voter.\n     * @dev Requires that the pieceId is valid, the voter has not already voted on this piece, and the weight is greater than the minimum vote weight.\n     * Emits a VoteCast event upon successful execution.\n     */\n    function _vote(uint256 pieceId, address voter) internal {\n        require(pieceId < _currentPieceId, \"Invalid piece ID\");\n        require(voter != address(0), \"Invalid voter address\");\n        require(!pieces[pieceId].isDropped, \"Piece has already been dropped\");\n        require(!(votes[pieceId][voter].voterAddress != address(0)), \"Already voted\");\n\n        uint256 weight = _getPastVotes(voter, pieces[pieceId].creationBlock);\n        require(weight > minVoteWeight, \"Weight must be greater than minVoteWeight\");\n\n        votes[pieceId][voter] = Vote(voter, weight);\n        totalVoteWeights[pieceId] += weight;\n\n        uint256 totalWeight = totalVoteWeights[pieceId];\n\n        // TODO add security consideration here based on block created to prevent flash attacks on drops?\n        maxHeap.updateValue(pieceId, totalWeight);\n        emit VoteCast(pieceId, voter, weight, totalWeight);\n    }\n\n    /**\n     * @notice Cast a vote for a specific ArtPiece.\n     * @param pieceId The ID of the ArtPiece to vote for.\n     * @dev Requires that the pieceId is valid, the voter has not already voted on this piece, and the weight is greater than the minimum vote weight.\n     * Emits a VoteCast event upon successful execution.\n     */\n    function vote(uint256 pieceId) public nonReentrant {\n        _vote(pieceId, msg.sender);\n    }\n\n    /**\n     * @notice Cast a vote for a list of ArtPieces.\n     * @param pieceIds The IDs of the ArtPieces to vote for.\n     * @dev Requires that the pieceIds are valid, the voter has not already voted on this piece, and the weight is greater than the minimum vote weight.\n     * Emits a series of VoteCast event upon successful execution.\n     */\n    function voteForMany(uint256[] calldata pieceIds) public nonReentrant {\n        _voteForMany(pieceIds, msg.sender);\n    }\n\n    /**\n     * @notice Cast a vote for a list of ArtPieces pieceIds.\n     * @param pieceIds The IDs of the ArtPieces to vote for.\n     * @param from The address of the voter.\n     * @dev Requires that the pieceIds are valid, the voter has not already voted on this piece, and the weight is greater than the minimum vote weight.\n     * Emits a series of VoteCast event upon successful execution.\n     */\n    function _voteForMany(uint256[] calldata pieceIds, address from) internal {\n        uint256 len = pieceIds.length;\n        for (uint256 i; i < len; i++) {\n            _vote(pieceIds[i], from);\n        }\n    }\n\n    /// @notice Execute a vote via signature\n    /// @param from Vote from this address\n    /// @param pieceIds Vote on this list of pieceIds\n    /// @param deadline Deadline for the signature to be valid\n    /// @param v V component of signature\n    /// @param r R component of signature\n    /// @param s S component of signature\n    function voteForManyWithSig(\n        address from,\n        uint256[] calldata pieceIds,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant {\n        bool success = _verifyVoteSignature(from, pieceIds, deadline, v, r, s);\n\n        if (!success) revert INVALID_SIGNATURE();\n\n        _voteForMany(pieceIds, from);\n    }\n\n    /// @notice Execute a batch of votes via signature, each with their own signature\n    /// @param from Vote from these addresses\n    /// @param pieceIds Vote on these lists of pieceIds\n    /// @param deadline Deadlines for the signature to be valid\n    /// @param v V component of signatures\n    /// @param r R component of signatures\n    /// @param s S component of signatures\n    function batchVoteForManyWithSig(\n        address[] memory from,\n        uint256[][] calldata pieceIds,\n        uint256[] memory deadline,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    ) external nonReentrant {\n        uint256 len = from.length;\n        require(\n            len == pieceIds.length && len == deadline.length && len == v.length && len == r.length && len == s.length,\n            \"Array lengths must match\"\n        );\n\n        for (uint256 i; i < len; i++) {\n            if (!_verifyVoteSignature(from[i], pieceIds[i], deadline[i], v[i], r[i], s[i])) revert INVALID_SIGNATURE();\n        }\n\n        for (uint256 i; i < len; i++) {\n            _voteForMany(pieceIds[i], from[i]);"
    }
  ]
}