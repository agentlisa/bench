{
  "Title": "[G-06] Multiple accesses of a mapping/array should use a storage pointer",
  "Content": "Caching a mapping's value in a storage pointer when the value is accessed multiple times saves ~40 gas per access due to not having to perform the same offset calculation every time. Help the Optimizer by saving a storage variable's reference instead of repeatedly fetching it.\n\nTo achieve this, declare a storage pointer for the variable and use it instead of repeatedly fetching the reference in a map or an array. As an example, instead of repeatedly calling `stakes[tokenId_]`, save its reference via a storage pointer: `StakeInfo storage stakeInfo = stakes[tokenId_]` and use the pointer instead.\n\n**Note: These are instances the automated report missed**\n\nTotal Instances: `14`\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/RewardsManager.sol#L389-L412\n\n*Gas Savings for `RewardsManager.claimRewards`, obtained via protocol's tests: Avg 290 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |  393064  |  \n| After  |  392774  | \n\n### Cache storage pointers for `stakes[tokenId_]` and `isEpochClaimed[tokenId_]`\n```solidity\nFile: ajna-core/src/RewardsManager.sol\n389:        address ajnaPool         = stakes[tokenId_].ajnaPool;\n390:        uint256 lastClaimedEpoch = stakes[tokenId_].lastClaimedEpoch;\n391:        uint256 stakingEpoch     = stakes[tokenId_].stakingEpoch;\n...\n411:            rewardsClaimed[epoch]           += nextEpochRewards;\n412:            isEpochClaimed[tokenId_][epoch] = true;\n```\n```diff\ndiff --git a/src/RewardsManager.sol b/src/RewardsManager.sol\nindex 314b476..028e487 100644\n--- a/src/RewardsManager.sol\n+++ b/src/RewardsManager.sol\n@@ -385,14 +385,16 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n         uint256 tokenId_,\n         uint256 epochToClaim_\n     ) internal returns (uint256 rewards_) {\n-\n-        address ajnaPool         = stakes[tokenId_].ajnaPool;\n-        uint256 lastClaimedEpoch = stakes[tokenId_].lastClaimedEpoch;\n-        uint256 stakingEpoch     = stakes[tokenId_].stakingEpoch;\n+\n+        StakeInfo storage stakeInfo = stakes[tokenId_];\n+        address ajnaPool         = stakeInfo.ajnaPool;\n+        uint256 lastClaimedEpoch = stakeInfo.lastClaimedEpoch;\n+        uint256 stakingEpoch     = stakeInfo.stakingEpoch;\n\n         uint256[] memory positionIndexes = positionManager.getPositionIndexesFiltered(tokenId_);\n\n         // iterate through all burn periods to calculate and claim rewards\n+        mapping(uint256 => bool) storage _isEpochClaimed = isEpochClaimed[tokenId_];\n         for (uint256 epoch = lastClaimedEpoch; epoch < epochToClaim_; ) {\n\n             uint256 nextEpochRewards = _calculateNextEpochRewards(\n@@ -409,7 +411,7 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n\n             // update epoch token claim trackers\n             rewardsClaimed[epoch]           += nextEpochRewards;\n-            isEpochClaimed[tokenId_][epoch] = true;\n+            _isEpochClaimed[epoch] = true;\n         }\n     }\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/RewardsManager.sol#L748-L755\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/RewardsManager.sol#L775-L785\n\n*Gas Savings for `RewardsManager.moveStakedLiquidity`, obtained via protocol's tests: Avg 1373 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |  2112272  |  \n| After  |  2110899  | \n\n### Cache storage pointer for `bucketExchangeRates[pool_][bucketIndex_]`\n```solidity\nFile: ajna-core/src/RewardsManager.sol\n748:        uint256 burnExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_];\n749:\n750:        // update bucket exchange rate at epoch only if it wasn't previously updated\n751:        if (burnExchangeRate == 0) {\n752:            uint256 curBucketExchangeRate = IPool(pool_).bucketExchangeRate(bucketIndex_);\n753:\n754:            // record bucket exchange rate at epoch\n755:            bucketExchangeRates[pool_][bucketIndex_][burnEpoch_] = curBucketExchangeRate;\n\n775:        uint256 burnExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_];\n776:\n777:        // update bucket exchange rate at epoch only if it wasn't previously updated\n778:        if (burnExchangeRate == 0) {\n779:            uint256 curBucketExchangeRate = IPool(pool_).bucketExchangeRate(bucketIndex_);\n780:\n781:            // record bucket exchange rate at epoch\n782:            bucketExchangeRates[pool_][bucketIndex_][burnEpoch_] = curBucketExchangeRate;\n783:\n784:            // retrieve the bucket exchange rate at the previous epoch\n785:            uint256 prevBucketExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_ - 1];\n```\n```diff\ndiff --git a/src/RewardsManager.sol b/src/RewardsManager.sol\nindex 314b476..8e2250e 100644\n--- a/src/RewardsManager.sol\n+++ b/src/RewardsManager.sol\n@@ -745,14 +745,15 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n         uint256 bucketIndex_,\n         uint256 burnEpoch_\n     ) internal {\n-        uint256 burnExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_];\n+        mapping(uint256 => uint256) storage _bucketExchangeRates = bucketExchangeRates[pool_][bucketIndex_];\n+        uint256 burnExchangeRate = _bucketExchangeRates[burnEpoch_];\n\n         // update bucket exchange rate at epoch only if it wasn't previously updated\n         if (burnExchangeRate == 0) {\n             uint256 curBucketExchangeRate = IPool(pool_).bucketExchangeRate(bucketIndex_);\n\n             // record bucket exchange rate at epoch\n-            bucketExchangeRates[pool_][bucketIndex_][burnEpoch_] = curBucketExchangeRate;\n+            _bucketExchangeRates[burnEpoch_] = curBucketExchangeRate;\n         }\n     }\n\n@@ -772,17 +773,18 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n         uint256 totalBurned_,\n         uint256 interestEarned_\n     ) internal returns (uint256 rewards_) {\n-        uint256 burnExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_];\n+        mapping(uint256 => uint256) storage _bucketExchangeRates = bucketExchangeRates[pool_][bucketIndex_];\n+        uint256 burnExchangeRate = _bucketExchangeRates[burnEpoch_];\n\n         // update bucket exchange rate at epoch only if it wasn't previously updated\n         if (burnExchangeRate == 0) {\n             uint256 curBucketExchangeRate = IPool(pool_).bucketExchangeRate(bucketIndex_);\n\n             // record bucket exchange rate at epoch\n-            bucketExchangeRates[pool_][bucketIndex_][burnEpoch_] = curBucketExchangeRate;\n+            _bucketExchangeRates[burnEpoch_] = curBucketExchangeRate;\n\n             // retrieve the bucket exchange rate at the previous epoch\n-            uint256 prevBucketExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_ - 1];\n+            uint256 prevBucketExchangeRate = _bucketExchangeRates[burnEpoch_ - 1];\n\n             // skip reward calculation if update at the previous epoch was missed and if exchange rate decreased due to bad debt\n             // prevents excess rewards from being provided from using a 0 value as an input to the interestFactor calculation below.\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/RewardsManager.sol#L442-L448\n\n*Gas Savings for `RewardsManager.claimRewards`, obtained via protocol's tests: Avg 4795 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |  393064  |  \n| After  |  388269  | \n\n### Cache storage pointer for `bucketExchangeRates[ajnaPool_]` and `stakes[tokenId_]`\n```solidity\nFile: ajna-core/src/RewardsManager.sol\n442:            BucketState memory bucketSnapshot = stakes[tokenId_].snapshot[bucketIndex];\n443:\n444:            uint256 bucketRate;\n445:            if (epoch_ != stakingEpoch_) {\n446:\n447:                // if staked in a previous epoch then use the initial exchange rate of epoch\n448:                bucketRate = bucketExchangeRates[ajnaPool_][bucketIndex][epoch_];\n```\n```diff\ndiff --git a/src/RewardsManager.sol b/src/RewardsManager.sol\nindex 314b476..e416c82 100644\n--- a/src/RewardsManager.sol\n+++ b/src/RewardsManager.sol\n@@ -437,15 +437,17 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {\n         uint256 interestEarned;\n\n         // iterate through all buckets and calculate epoch rewards for\n+        StakeInfo storage _stakeInfo = stakes[tokenId_];\n+        mapping(uint256 => mapping(uint256 => uint256)) storage _bucketExchangeRates = bucketExchangeRates[ajnaPool_];\n         for (uint256 i = 0; i < positionIndexes_.length; ) {\n             bucketIndex = positionIndexes_[i];\n-            BucketState memory bucketSnapshot = stakes[tokenId_].snapshot[bucketIndex];\n+            BucketState memory bucketSnapshot = _stakeInfo.snapshot[bucketIndex];\n\n             uint256 bucketRate;\n             if (epoch_ != stakingEpoch_) {\n\n                 // if staked in a previous epoch then use the initial exchange rate of epoch\n-                bucketRate = bucketExchangeRates[ajnaPool_][bucketIndex][epoch_];\n+                bucketRate = _bucketExchangeRates[bucketIndex][epoch_];\n             } else {\n\n                 // if staked during the epoch then use the bucket rate at the time of staking\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L190-L207\n\n*Gas Savings for `PositionManager.memorializePositions`, obtained via protocol's tests: Avg 1043 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |  1134444 |  \n| After  |  1133401 | \n\n### Cache storage pointer for `positions[params_.tokenId]`\n```solidity\nFile: ajna-core/src/PositionManager.sol\n190:            Position memory position = positions[params_.tokenId][index];\n191:\n192:            // check for previous deposits\n193:            if (position.depositTime != 0) {\n194:                // check that bucket didn't go bankrupt after prior memorialization\n195:                if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) {\n196:                    // if bucket did go bankrupt, zero out the LP tracked by position manager\n197:                    position.lps = 0;\n198:                }\n199:            }\n200:\n201:            // update token position LP\n202:            position.lps += lpBalance;\n203:            // set token's position deposit time to the original lender's deposit time\n204:            position.depositTime = depositTime;\n205:\n206:            // save position in storage\n207:            positions[params_.tokenId][index] = position;\n```\n```diff\ndiff --git a/src/PositionManager.sol b/src/PositionManager.sol\nindex 261fbc1..08e09a9 100644\n--- a/src/PositionManager.sol\n+++ b/src/PositionManager.sol\n@@ -177,7 +177,8 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n\n         uint256 indexesLength = params_.indexes.length;\n         uint256 index;\n-\n+\n+        mapping(uint256 => Position) storage _position = positions[params_.tokenId];\n         for (uint256 i = 0; i < indexesLength; ) {\n             index = params_.indexes[i];\n\n@@ -186,8 +187,8 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n             positionIndex.add(index);\n\n             (uint256 lpBalance, uint256 depositTime) = pool.lenderInfo(index, owner);\n-\n-            Position memory position = positions[params_.tokenId][index];\n+\n+            Position memory position = _position[index];\n\n             // check for previous deposits\n             if (position.depositTime != 0) {\n@@ -204,7 +205,7 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n             position.depositTime = depositTime;\n\n             // save position in storage\n-            positions[params_.tokenId][index] = position;\n+            _position[index] = position;\n\n             unchecked { ++i; }\n         }\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L367-L380\n\n*Gas Savings for `PositionManager.reedemPositions`, obtained via protocol's tests: Avg 167 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |  139811  |  \n| After  |  139644  | \n\n### Cache storage pointer for `positions[params_.tokenId]`\n```solidity\nFile: ajna-core/src/PositionManager.sol\n367:            Position memory position = positions[params_.tokenId][index];\n368:\n369:            if (position.depositTime == 0 || position.lps == 0) revert RemovePositionFailed();\n370:\n371:            // check that bucket didn't go bankrupt after memorialization\n372:            if (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) revert BucketBankrupt();\n373:\n374:            // remove bucket index at which a position has added liquidity\n375:            if (!positionIndex.remove(index)) revert RemovePositionFailed();\n376:\n377:            lpAmounts[i] = position.lps;\n378:\n379:            // remove LP tracked by position manager at bucket index\n380:            delete positions[params_.tokenId][index];\n```\n```diff\ndiff --git a/src/PositionManager.sol b/src/PositionManager.sol\nindex 261fbc1..09f3417 100644\n--- a/src/PositionManager.sol\n+++ b/src/PositionManager.sol\n@@ -360,11 +360,12 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n         uint256[] memory lpAmounts = new uint256[](indexesLength);\n\n         uint256 index;\n-\n+\n+        mapping(uint256 => Position) storage _position = positions[params_.tokenId];\n         for (uint256 i = 0; i < indexesLength; ) {\n             index = params_.indexes[i];\n\n-            Position memory position = positions[params_.tokenId][index];\n+            Position memory position = _position[index];\n\n             if (position.depositTime == 0 || position.lps == 0) revert RemovePositionFailed();\n\n@@ -377,7 +378,7 @@ contract PositionManager is ERC721, PermitERC721, IPositionManager, Multicall, R\n             lpAmounts[i] = position.lps;\n\n             // remove LP tracked by position manager at bucket index\n-            delete positions[params_.tokenId][index];\n+            delete _position[index];\n\n             unchecked { ++i; }\n         }\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/ExtraordinaryFunding.sol#L135-L148\n\n*Gas Savings for `GrantFund.voteExtraordinary`, obtained via protocol's tests: Avg 67 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   31424  |  \n| After  |   31357  | \n\n### Cache storage pointer for `hashVotedExtraordinary[proposalId_]`\n```solidity\nFile: ajna-grants/src/grants/base/ExtraordinaryFunding.sol\n135:        if (hasVotedExtraordinary[proposalId_][msg.sender]) revert AlreadyVoted();\n136:\n137:        ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n138:        // revert if proposal is inactive\n139:        if (proposal.startBlock > block.number || proposal.endBlock < block.number || proposal.executed) {\n140:            revert ExtraordinaryFundingProposalInactive();\n141:        }\n142:\n143:        // check voting power at snapshot block and update proposal votes\n144:        votesCast_ = _getVotesExtraordinary(msg.sender, proposalId_);\n145:        proposal.votesReceived += SafeCast.toUint120(votesCast_);\n146:\n147:        // record that voter has voted on this extraordinary funding proposal\n148:        hasVotedExtraordinary[proposalId_][msg.sender] = true;\n```\n```diff\ndiff --git a/src/grants/base/ExtraordinaryFunding.sol b/src/grants/base/ExtraordinaryFunding.sol\nindex 4a70abb..e128c97 100644\n--- a/src/grants/base/ExtraordinaryFunding.sol\n+++ b/src/grants/base/ExtraordinaryFunding.sol\n@@ -132,7 +132,8 @@ abstract contract ExtraordinaryFunding is Funding, IExtraordinaryFunding {\n         uint256 proposalId_\n     ) external override returns (uint256 votesCast_) {\n         // revert if msg.sender already voted on proposal\n-        if (hasVotedExtraordinary[proposalId_][msg.sender]) revert AlreadyVoted();\n+        mapping(address => bool) storage _hasVoted = hasVotedExtraordinary[proposalId_];\n+        if (_hasVoted[msg.sender]) revert AlreadyVoted();\n\n         ExtraordinaryFundingProposal storage proposal = _extraordinaryFundingProposals[proposalId_];\n         // revert if proposal is inactive\n@@ -145,7 +146,7 @@ abstract contract ExtraordinaryFunding is Funding, IExtraordinaryFunding {\n         proposal.votesReceived += SafeCast.toUint120(votesCast_);\n\n         // record that voter has voted on this extraordinary funding proposal\n-        hasVotedExtraordinary[proposalId_][msg.sender] = true;\n+        _hasVoted[msg.sender] = true;\n\n         emit VoteCast(\n             msg.sender,\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L248-L255\n\n*Gas Savings for `GrantFund.claimDelegateReward`, obtained via protocol's tests: Avg 64 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   65340  |  \n| After  |   65276  | \n\n### Cache storage pointer for `hasClaimedRewards[distributionId_]`\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n248:        if(hasClaimedReward[distributionId_][msg.sender]) revert RewardAlreadyClaimed();\n249:\n250:        QuadraticVoter memory voter = _quadraticVoters[distributionId_][msg.sender];\n251:\n252:        // calculate rewards earned for voting\n253:        rewardClaimed_ = _getDelegateReward(currentDistribution, voter);\n254:\n255:        hasClaimedReward[distributionId_][msg.sender] = true;\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..623b47a 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -245,14 +245,15 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n         if(block.number < _getChallengeStageEndBlock(currentDistribution.endBlock)) revert ChallengePeriodNotEnded();\n\n         // check rewards haven't already been claimed\n-        if(hasClaimedReward[distributionId_][msg.sender]) revert RewardAlreadyClaimed();\n+        mapping(address => bool) storage _hasClaimedReward = hasClaimedReward[distributionId_];\n+        if(_hasClaimedReward[msg.sender]) revert RewardAlreadyClaimed();\n\n         QuadraticVoter memory voter = _quadraticVoters[distributionId_][msg.sender];\n\n         // calculate rewards earned for voting\n         rewardClaimed_ = _getDelegateReward(currentDistribution, voter);\n\n-        hasClaimedReward[distributionId_][msg.sender] = true;\n+        _hasClaimedReward[msg.sender] = true;\n\n         emit DelegateRewardClaimed(\n             msg.sender,\n```\n\nhttps://github.com/code-423n4/2023-05-ajna/blob/main/ajna-grants/src/grants/base/StandardFunding.sol#L706-L743\n\n*Gas Savings for `GrantFund.screeningVote`, obtained via protocol's tests: Avg 1850 gas*\n\n|        |    Max   |\n| ------ | -------- |\n| Before |   399146 |  \n| After  |   397296 | \n\n### Cache storage pointer for `screeningVotesCast[distributionId]`\n```solidity\nFile: ajna-grants/src/grants/base/StandardFunding.sol\n706:        if (screeningVotesCast[distributionId][account_] + votes_ > _getVotesScreening(distributionId, account_)) revert InsufficientVotingPower();\n...\n743:        screeningVotesCast[proposal_.distributionId][account_] += votes_;\n```\n```diff\ndiff --git a/src/grants/base/StandardFunding.sol b/src/grants/base/StandardFunding.sol\nindex 928b337..094a83c 100644\n--- a/src/grants/base/StandardFunding.sol\n+++ b/src/grants/base/StandardFunding.sol\n@@ -703,7 +703,8 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n         uint24 distributionId = proposal_.distributionId;\n\n         // check that the voter has enough voting power to cast the vote\n-        if (screeningVotesCast[distributionId][account_] + votes_ > _getVotesScreening(distributionId, account_)) revert InsufficientVotingPower();\n+        mapping(address => uint256) storage _screeningVotesCast = screeningVotesCast[distributionId];\n+        if (_screeningVotesCast[account_] + votes_ > _getVotesScreening(distributionId, account_)) revert InsufficientVotingPower();\n\n         uint256[] storage currentTopTenProposals = _topTenProposals[distributionId];\n         uint256 proposalId = proposal_.proposalId;\n@@ -740,7 +741,7 @@ abstract contract StandardFunding is Funding, IStandardFunding {\n         }\n\n         // record voters vote\n-        screeningVotesCast[proposal_.distributionId][account_] += votes_;\n+        _screeningVotesCast[account_] += votes_;\n\n         // emit VoteCast instead of VoteCastWithParams to maintain compatibility with Tally\n         emit VoteCast(\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-ajna",
  "Code": [
    {
      "filename": "ajna-core/src/RewardsManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { IERC20 }          from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { IERC721 }         from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { SafeERC20 }       from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport { IPool }                        from './interfaces/pool/IPool.sol';\nimport { IPositionManager }             from './interfaces/position/IPositionManager.sol';\nimport { IPositionManagerOwnerActions } from './interfaces/position/IPositionManagerOwnerActions.sol';\nimport {\n    IRewardsManager,\n    IRewardsManagerOwnerActions,\n    IRewardsManagerState,\n    IRewardsManagerDerivedState\n} from './interfaces/rewards/IRewardsManager.sol';\nimport { StakeInfo, BucketState } from './interfaces/rewards/IRewardsManagerState.sol';\n\nimport { PositionManager } from './PositionManager.sol';\n\nimport { Maths } from './libraries/internal/Maths.sol';\n\n/**\n *  @title  Rewards (staking) Manager contract\n *  @notice Pool lenders can optionally mint `NFT` that represents their positions.\n *          The Rewards contract allows pool lenders with positions `NFT` to stake and earn `Ajna` tokens. \n *          Lenders with `NFT`s can:\n *          - `stake` token\n *          - `update bucket exchange rate` and earn rewards\n *          - `claim` rewards\n *          - `unstake` token\n */\ncontract RewardsManager is IRewardsManager, ReentrancyGuard {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    /**\n     * @notice Maximum percentage of tokens burned that can be claimed as `Ajna` token `LP` `NFT` rewards.\n     */\n    uint256 internal constant REWARD_CAP = 0.8 * 1e18;\n    /**\n     * @notice Maximum percentage of tokens burned that can be claimed as `Ajna` token update rewards.\n     */\n    uint256 internal constant UPDATE_CAP = 0.1 * 1e18;\n    /**\n     * @notice Reward factor by which to scale the total rewards earned.\n     * @dev ensures that rewards issued to staked lenders in a given pool are less than the `Ajna` tokens burned in that pool.\n     */\n    uint256 internal constant REWARD_FACTOR = 0.5 * 1e18;\n    /**\n     * @notice Reward factor by which to scale rewards earned for updating a buckets exchange rate.\n     */\n    uint256 internal constant UPDATE_CLAIM_REWARD = 0.05 * 1e18;\n    /**\n     * @notice Time period after a burn event in which buckets exchange rates can be updated.\n     */\n    uint256 internal constant UPDATE_PERIOD = 2 weeks;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /// @dev `tokenID => epoch => bool has claimed` mapping.\n    mapping(uint256 => mapping(uint256 => bool)) public override isEpochClaimed;\n    /// @dev `epoch => rewards claimed` mapping.\n    mapping(uint256 => uint256) public override rewardsClaimed;\n    /// @dev `epoch => update bucket rate rewards claimed` mapping.\n    mapping(uint256 => uint256) public override updateRewardsClaimed;\n\n    /// @dev Mapping of per pool bucket exchange rates at a given burn event `poolAddress => bucketIndex => epoch => bucket exchange rate`.\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) internal bucketExchangeRates;\n\n    /// @dev Mapping `tokenID => Stake info`.\n    mapping(uint256 => StakeInfo) internal stakes;\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @dev Address of the `Ajna` token.\n    address public immutable ajnaToken;\n    /// @dev The `PositionManager` contract\n    IPositionManager public immutable positionManager;\n\n    /*******************/\n    /*** Constructor ***/\n    /*******************/\n\n    constructor(address ajnaToken_, IPositionManager positionManager_) {\n        if (ajnaToken_ == address(0)) revert DeployWithZeroAddress();\n\n        ajnaToken = ajnaToken_;\n        positionManager = positionManager_;\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    already claimed `AlreadyClaimed()`\n     *  @dev    === Emit events ===\n     *  @dev    - `ClaimRewards`\n     */\n    function claimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) external override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        if (isEpochClaimed[tokenId_][epochToClaim_]) revert AlreadyClaimed();\n\n        _claimRewards(stakeInfo, tokenId_, epochToClaim_, true, stakeInfo.ajnaPool);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    invalid index params `MoveStakedLiquidityInvalid()`\n     *  @dev    === Emit events ===\n     *  @dev    - `MoveStakedLiquidity`\n     */\n    function moveStakedLiquidity(\n        uint256 tokenId_,\n        uint256[] memory fromBuckets_,\n        uint256[] memory toBuckets_,\n        uint256 expiry_\n    ) external nonReentrant override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        // check move array sizes match to be able to match on index\n        uint256 fromBucketLength = fromBuckets_.length;\n        if (fromBucketLength != toBuckets_.length) revert MoveStakedLiquidityInvalid();\n\n        address ajnaPool = stakeInfo.ajnaPool;\n        uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();\n\n        // claim rewards before moving liquidity, if any\n        _claimRewards(\n            stakeInfo,\n            tokenId_,\n            curBurnEpoch,\n            false,\n            ajnaPool\n        );\n\n        uint256 fromIndex;\n        uint256 toIndex;\n        for (uint256 i = 0; i < fromBucketLength; ) {\n            fromIndex = fromBuckets_[i];\n            toIndex = toBuckets_[i];\n\n            // call out to position manager to move liquidity between buckets\n            IPositionManagerOwnerActions.MoveLiquidityParams memory moveLiquidityParams = IPositionManagerOwnerActions.MoveLiquidityParams(\n                tokenId_,\n                ajnaPool,\n                fromIndex,\n                toIndex,\n                expiry_\n            );\n            positionManager.moveLiquidity(moveLiquidityParams);\n\n            // update to bucket state\n            BucketState storage toBucket = stakeInfo.snapshot[toIndex];\n            toBucket.lpsAtStakeTime  = uint128(positionManager.getLP(tokenId_, toIndex));\n            toBucket.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(toIndex));\n            delete stakeInfo.snapshot[fromIndex];\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked { ++i; }\n        }\n\n        emit MoveStakedLiquidity(tokenId_, fromBuckets_, toBuckets_);\n\n        // update to bucket list exchange rates, from buckets are aready updated on claim\n        // calculate rewards for updating exchange rates, if any\n        uint256 updateReward = _updateBucketExchangeRates(\n            ajnaPool,\n            toBuckets_\n        );\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Stake`\n     */\n    function stake(\n        uint256 tokenId_\n    ) external override {\n        address ajnaPool = PositionManager(address(positionManager)).poolKey(tokenId_);\n\n        // check that msg.sender is owner of tokenId\n        if (IERC721(address(positionManager)).ownerOf(tokenId_) != msg.sender) revert NotOwnerOfDeposit();\n\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n        stakeInfo.owner    = msg.sender;\n        stakeInfo.ajnaPool = ajnaPool;\n\n        uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();\n\n        // record the staking epoch\n        stakeInfo.stakingEpoch = uint96(curBurnEpoch);\n\n        // initialize last time interaction at staking epoch\n        stakeInfo.lastClaimedEpoch = uint96(curBurnEpoch);\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n\n        for (uint256 i = 0; i < positionIndexes.length; ) {\n\n            uint256 bucketId = positionIndexes[i];\n\n            BucketState storage bucketState = stakeInfo.snapshot[bucketId];\n\n            // record the number of lps in bucket at the time of staking\n            bucketState.lpsAtStakeTime = uint128(positionManager.getLP(\n                tokenId_,\n                bucketId\n            ));\n            // record the bucket exchange rate at the time of staking\n            bucketState.rateAtStakeTime = uint128(IPool(ajnaPool).bucketExchangeRate(bucketId));\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked { ++i; }\n        }\n\n        emit Stake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT to this contract\n        IERC721(address(positionManager)).transferFrom(msg.sender, address(this), tokenId_);\n\n        // calculate rewards for updating exchange rates, if any\n        uint256 updateReward = _updateBucketExchangeRates(\n            ajnaPool,\n            positionIndexes\n        );\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Revert on ===\n     *  @dev    not owner `NotOwnerOfDeposit()`\n     *  @dev    === Emit events ===\n     *  @dev    - `ClaimRewards`\n     *  @dev    - `Unstake`\n     */\n    function unstake(\n        uint256 tokenId_\n    ) external override {\n        StakeInfo storage stakeInfo = stakes[tokenId_];\n\n        if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();\n\n        address ajnaPool = stakeInfo.ajnaPool;\n\n        // claim rewards, if any\n        _claimRewards(\n            stakeInfo,\n            tokenId_,\n            IPool(ajnaPool).currentBurnEpoch(),\n            false,\n            ajnaPool\n        );\n\n        // remove bucket snapshots recorded at the time of staking\n        uint256[] memory positionIndexes = positionManager.getPositionIndexes(tokenId_);\n        for (uint256 i = 0; i < positionIndexes.length; ) {\n            delete stakeInfo.snapshot[positionIndexes[i]]; // reset BucketState struct for current position\n\n            unchecked { ++i; }\n        }\n\n        // remove recorded stake info\n        delete stakes[tokenId_];\n\n        emit Unstake(msg.sender, ajnaPool, tokenId_);\n\n        // transfer LP NFT from contract to sender\n        IERC721(address(positionManager)).transferFrom(address(this), msg.sender, tokenId_);\n    }\n\n    /**\n     *  @inheritdoc IRewardsManagerOwnerActions\n     *  @dev    === Emit events ===\n     *  @dev    - `UpdateExchangeRates`\n     */\n    function updateBucketExchangeRatesAndClaim(\n        address pool_,\n        uint256[] calldata indexes_\n    ) external override returns (uint256 updateReward) {\n        updateReward = _updateBucketExchangeRates(pool_, indexes_);\n\n        // transfer rewards to sender\n        _transferAjnaRewards(updateReward);\n    }\n\n    /*******************************/\n    /*** External View Functions ***/\n    /*******************************/\n\n    /// @inheritdoc IRewardsManagerDerivedState\n    function calculateRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) external view override returns (uint256 rewards_) {\n\n        address ajnaPool         = stakes[tokenId_].ajnaPool;\n        uint256 lastClaimedEpoch = stakes[tokenId_].lastClaimedEpoch;\n        uint256 stakingEpoch     = stakes[tokenId_].stakingEpoch;\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexesFiltered(tokenId_);\n\n        // iterate through all burn periods to calculate and claim rewards\n        for (uint256 epoch = lastClaimedEpoch; epoch < epochToClaim_; ) {\n\n            rewards_ += _calculateNextEpochRewards(\n                tokenId_,\n                epoch,\n                stakingEpoch,\n                ajnaPool,\n                positionIndexes\n            );\n\n            unchecked { ++epoch; }\n        }\n    }\n\n    /// @inheritdoc IRewardsManagerState\n    function getStakeInfo(\n        uint256 tokenId_\n    ) external view override returns (address, address, uint256) {\n        return (\n            stakes[tokenId_].owner,\n            stakes[tokenId_].ajnaPool,\n            stakes[tokenId_].lastClaimedEpoch\n        );\n    }\n\n    /// @inheritdoc IRewardsManagerState\n    function getBucketStateStakeInfo(\n        uint256 tokenId_,\n        uint256 bucketId_\n    ) external view override returns (uint256, uint256) {\n        return (\n            stakes[tokenId_].snapshot[bucketId_].lpsAtStakeTime,\n            stakes[tokenId_].snapshot[bucketId_].rateAtStakeTime\n        );\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Calculate the amount of rewards that have been accumulated by a staked `NFT`.\n     *  @dev    Rewards are calculated as the difference in exchange rates between the last interaction burn event and the current burn event.\n     *  @param  tokenId_      `ID` of the staked `LP` `NFT`.\n     *  @param  epochToClaim_ The burn epoch to claim rewards for (rewards calculation starts from the last claimed epoch).\n     *  @return rewards_      Amount of rewards earned by the `NFT`.\n     */\n    function _calculateAndClaimRewards(\n        uint256 tokenId_,\n        uint256 epochToClaim_\n    ) internal returns (uint256 rewards_) {\n\n        address ajnaPool         = stakes[tokenId_].ajnaPool;\n        uint256 lastClaimedEpoch = stakes[tokenId_].lastClaimedEpoch;\n        uint256 stakingEpoch     = stakes[tokenId_].stakingEpoch;\n\n        uint256[] memory positionIndexes = positionManager.getPositionIndexesFiltered(tokenId_);\n\n        // iterate through all burn periods to calculate and claim rewards\n        for (uint256 epoch = lastClaimedEpoch; epoch < epochToClaim_; ) {\n\n            uint256 nextEpochRewards = _calculateNextEpochRewards(\n                tokenId_,\n                epoch,\n                stakingEpoch,\n                ajnaPool,\n                positionIndexes\n            );\n\n            rewards_ += nextEpochRewards;\n\n            unchecked { ++epoch; }\n\n            // update epoch token claim trackers\n            rewardsClaimed[epoch]           += nextEpochRewards;\n            isEpochClaimed[tokenId_][epoch] = true;\n        }\n    }\n\n    /**\n     *  @notice Calculate the amount of rewards that have been accumulated by a staked `NFT` in next epoch.\n     *  @dev    Rewards are calculated as the difference in exchange rates between the last interaction burn event and the current burn event.\n     *  @param  tokenId_         `ID` of the staked `LP` `NFT`.\n     *  @param  epoch_           The current epoch.\n     *  @param  stakingEpoch_    The epoch in which token was staked.\n     *  @param  ajnaPool_        Address of the pool.\n     *  @param  positionIndexes_ Bucket ids associated with `NFT` staked.\n     *  @return epochRewards_    Calculated rewards in epoch.\n     */\n    function _calculateNextEpochRewards(\n        uint256 tokenId_,\n        uint256 epoch_,\n        uint256 stakingEpoch_,\n        address ajnaPool_,\n        uint256[] memory positionIndexes_\n    ) internal view returns (uint256 epochRewards_) {\n\n        uint256 nextEpoch = epoch_ + 1;\n        uint256 claimedRewardsInNextEpoch = rewardsClaimed[nextEpoch];\n        uint256 bucketIndex;\n        uint256 interestEarned;\n\n        // iterate through all buckets and calculate epoch rewards for\n        for (uint256 i = 0; i < positionIndexes_.length; ) {\n            bucketIndex = positionIndexes_[i];\n            BucketState memory bucketSnapshot = stakes[tokenId_].snapshot[bucketIndex];\n\n            uint256 bucketRate;\n            if (epoch_ != stakingEpoch_) {\n\n                // if staked in a previous epoch then use the initial exchange rate of epoch\n                bucketRate = bucketExchangeRates[ajnaPool_][bucketIndex][epoch_];\n            } else {\n\n                // if staked during the epoch then use the bucket rate at the time of staking\n                bucketRate = bucketSnapshot.rateAtStakeTime;\n            }\n\n            // calculate the amount of interest accrued in current epoch\n            interestEarned += _calculateExchangeRateInterestEarned(\n                ajnaPool_,\n                nextEpoch,\n                bucketIndex,\n                bucketSnapshot.lpsAtStakeTime,\n                bucketRate\n            ); \n            unchecked { ++i; }\n        }\n\n        // calculate and accumulate rewards if interest earned\n        if (interestEarned != 0) {\n            epochRewards_ = _calculateNewRewards(\n                ajnaPool_,\n                interestEarned,\n                nextEpoch,\n                epoch_,\n                claimedRewardsInNextEpoch\n            );\n        }\n    }\n\n    /**\n     *  @notice Calculate the amount of interest that has accrued to a lender in a bucket based upon their `LP`.\n     *  @param  pool_           Address of the pool whose exchange rates are being checked.\n     *  @param  nextEventEpoch_ The next event epoch to check the exchange rate for.\n     *  @param  bucketIndex_    Index of the bucket to check the exchange rate for.\n     *  @param  bucketLP_       Amount of `LP` in bucket.\n     *  @param  exchangeRate_   Exchange rate in current epoch.\n     *  @return interestEarned_ The amount of interest accrued.\n     */\n    function _calculateExchangeRateInterestEarned(\n        address pool_,\n        uint256 nextEventEpoch_,\n        uint256 bucketIndex_,\n        uint256 bucketLP_,\n        uint256 exchangeRate_\n    ) internal view returns (uint256 interestEarned_) {\n\n        if (exchangeRate_ != 0) {\n\n            uint256 nextExchangeRate = bucketExchangeRates[pool_][bucketIndex_][nextEventEpoch_];\n\n            // calculate interest earned only if next exchange rate is higher than current exchange rate\n            if (nextExchangeRate > exchangeRate_) {\n\n                // calculate the equivalent amount of quote tokens given the stakes lp balance,\n                // and the exchange rate at the next and current burn events\n                interestEarned_ = Maths.wmul(nextExchangeRate - exchangeRate_, bucketLP_);\n            }\n\n        }\n    }\n\n    /**\n     *  @notice Calculate new rewards between current and next epoch, based on earned interest.\n     *  @param  ajnaPool_              Address of the pool.\n     *  @param  interestEarned_        The amount of interest accrued to current epoch.\n     *  @param  nextEpoch_             The next burn event epoch to calculate new rewards.\n     *  @param  epoch_                 The current burn event epoch to calculate new rewards.\n     *  @param  rewardsClaimedInEpoch_ Rewards claimed in epoch.\n     *  @return newRewards_            New rewards between current and next burn event epoch.\n     */\n    function _calculateNewRewards(\n        address ajnaPool_,\n        uint256 interestEarned_,\n        uint256 nextEpoch_,\n        uint256 epoch_,\n        uint256 rewardsClaimedInEpoch_\n    ) internal view returns (uint256 newRewards_) {\n        (\n            ,\n            // total interest accumulated by the pool over the claim period\n            uint256 totalBurnedInPeriod,\n            // total tokens burned over the claim period\n            uint256 totalInterestEarnedInPeriod\n        ) = _getPoolAccumulators(ajnaPool_, nextEpoch_, epoch_);\n\n        // calculate rewards earned\n        newRewards_ = totalInterestEarnedInPeriod == 0 ? 0 : Maths.wmul(\n            REWARD_FACTOR,\n            Maths.wdiv(\n                Maths.wmul(interestEarned_, totalBurnedInPeriod),\n                totalInterestEarnedInPeriod\n            )\n        );\n\n        uint256 rewardsCapped = Maths.wmul(REWARD_CAP, totalBurnedInPeriod);\n\n        // Check rewards claimed - check that less than 80% of the tokens for a given burn event have been claimed.\n        if (rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped) {\n\n            // set claim reward to difference between cap and reward\n            newRewards_ = rewardsCapped - rewardsClaimedInEpoch_;\n        }\n    }\n\n    /**\n     *  @notice Claim rewards that have been accumulated by a staked `NFT`.\n     *  @param  stakeInfo_     `StakeInfo` struct containing details of stake to claim rewards for.\n     *  @param  tokenId_       `ID` of the staked `LP` `NFT`.\n     *  @param  epochToClaim_  The burn epoch to claim rewards for (rewards calculation starts from the last claimed epoch)\n     *  @param  validateEpoch_ True if the epoch is received as a parameter and needs to be validated (lower or equal with latest epoch).\n     *  @param  ajnaPool_      Address of `Ajna` pool associated with the stake.\n     */\n    function _claimRewards(\n        StakeInfo storage stakeInfo_,\n        uint256 tokenId_,\n        uint256 epochToClaim_,\n        bool validateEpoch_,\n        address ajnaPool_\n    ) internal {\n\n        // revert if higher epoch to claim than current burn epoch\n        if (validateEpoch_ && epochToClaim_ > IPool(ajnaPool_).currentBurnEpoch()) revert EpochNotAvailable();\n\n        // update bucket exchange rates and claim associated rewards\n        uint256 rewardsEarned = _updateBucketExchangeRates(\n            ajnaPool_,\n            positionManager.getPositionIndexes(tokenId_)\n        );\n\n        rewardsEarned += _calculateAndClaimRewards(tokenId_, epochToClaim_);\n\n        uint256[] memory burnEpochsClaimed = _getBurnEpochsClaimed(\n            stakeInfo_.lastClaimedEpoch,\n            epochToClaim_\n        );\n\n        emit ClaimRewards(\n            msg.sender,\n            ajnaPool_,\n            tokenId_,\n            burnEpochsClaimed,\n            rewardsEarned\n        );\n\n        // update last interaction burn event\n        stakeInfo_.lastClaimedEpoch = uint96(epochToClaim_);\n\n        // transfer rewards to sender\n        _transferAjnaRewards(rewardsEarned);\n    }\n\n    /**\n     *  @notice Retrieve an array of burn epochs from which a depositor has claimed rewards.\n     *  @param  lastClaimedEpoch_      The last burn period in which a depositor claimed rewards.\n     *  @param  burnEpochToStartClaim_ The most recent burn period from a depositor earned rewards.\n     *  @return burnEpochsClaimed_     Array of burn epochs from which a depositor has claimed rewards.\n     */\n    function _getBurnEpochsClaimed(\n        uint256 lastClaimedEpoch_,\n        uint256 burnEpochToStartClaim_\n    ) internal pure returns (uint256[] memory burnEpochsClaimed_) {\n        uint256 numEpochsClaimed = burnEpochToStartClaim_ - lastClaimedEpoch_;\n\n        burnEpochsClaimed_ = new uint256[](numEpochsClaimed);\n\n        uint256 i;\n        uint256 claimEpoch = lastClaimedEpoch_ + 1;\n        while (claimEpoch <= burnEpochToStartClaim_) {\n            burnEpochsClaimed_[i] = claimEpoch;\n\n            // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n            unchecked {\n                ++i;\n                ++claimEpoch;\n            }\n        }\n    }\n\n    /**\n     *  @notice Retrieve the total ajna tokens burned and total interest earned by a pool since a given block.\n     *  @param  pool_                  Address of the `Ajna` pool to retrieve accumulators of.\n     *  @param  currentBurnEventEpoch_ The latest burn event.\n     *  @param  lastBurnEventEpoch_    The burn event to use as checkpoint since which values have accumulated.\n     *  @return Timestamp of the latest burn event.\n     *  @return Total `Ajna` tokens burned by the pool since the last burn event.\n     *  @return Total interest earned by the pool since the last burn event.\n     */\n    function _getPoolAccumulators(\n        address pool_,\n        uint256 currentBurnEventEpoch_,\n        uint256 lastBurnEventEpoch_\n    ) internal view returns (uint256, uint256, uint256) {\n        (\n            uint256 currentBurnTime,\n            uint256 totalInterestLatest,\n            uint256 totalBurnedLatest\n        ) = IPool(pool_).burnInfo(currentBurnEventEpoch_);\n\n        (\n            ,\n            uint256 totalInterestAtBlock,\n            uint256 totalBurnedAtBlock\n        ) = IPool(pool_).burnInfo(lastBurnEventEpoch_);\n\n        uint256 totalBurned   = totalBurnedLatest   != 0 ? totalBurnedLatest   - totalBurnedAtBlock   : totalBurnedAtBlock;\n        uint256 totalInterest = totalInterestLatest != 0 ? totalInterestLatest - totalInterestAtBlock : totalInterestAtBlock;\n\n        return (\n            currentBurnTime,\n            totalBurned,\n            totalInterest\n        );\n    }\n\n    /**\n     *  @notice Update the exchange rate of a list of buckets.\n     *  @dev    Called as part of `stake`, `unstake`, and `claimRewards`, as well as `updateBucketExchangeRatesAndClaim`.\n     *  @dev    Caller can claim `5%` of the rewards that have accumulated to each bucket since the last burn event, if it hasn't already been updated.\n     *  @param  pool_           Address of the pool whose exchange rates are being updated.\n     *  @param  indexes_        List of bucket indexes to be updated.\n     *  @return updatedRewards_ Update exchange rate rewards.\n     */\n    function _updateBucketExchangeRates(\n        address pool_,\n        uint256[] memory indexes_\n    ) internal returns (uint256 updatedRewards_) {\n        // get the current burn epoch from the given pool\n        uint256 curBurnEpoch = IPool(pool_).currentBurnEpoch();\n\n        // update exchange rates only if the pool has not yet burned any tokens without calculating any reward\n        if (curBurnEpoch == 0) {\n            for (uint256 i = 0; i < indexes_.length; ) {\n\n                _updateBucketExchangeRate(\n                    pool_,\n                    indexes_[i],\n                    curBurnEpoch\n                );\n\n                // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n                unchecked { ++i; }\n            }\n        }\n\n        else {\n            // retrieve accumulator values used to calculate rewards accrued\n            (\n                uint256 curBurnTime,\n                uint256 totalBurned,\n                uint256 totalInterestEarned\n            ) = _getPoolAccumulators(pool_, curBurnEpoch, curBurnEpoch - 1);\n\n            if (block.timestamp <= curBurnTime + UPDATE_PERIOD) {\n\n                // update exchange rates and calculate rewards if tokens were burned and within allowed time period\n                for (uint256 i = 0; i < indexes_.length; ) {\n\n                    // calculate rewards earned for updating bucket exchange rate\n                    updatedRewards_ += _updateBucketExchangeRateAndCalculateRewards(\n                        pool_,\n                        indexes_[i],\n                        curBurnEpoch,\n                        totalBurned,\n                        totalInterestEarned\n                    );\n\n                    // iterations are bounded by array length (which is itself bounded), preventing overflow / underflow\n                    unchecked { ++i; }\n                }\n\n                uint256 rewardsCap            = Maths.wmul(UPDATE_CAP, totalBurned);\n                uint256 rewardsClaimedInEpoch = updateRewardsClaimed[curBurnEpoch];\n\n                // update total tokens claimed for updating bucket exchange rates tracker\n                if (rewardsClaimedInEpoch + updatedRewards_ >= rewardsCap) {\n                    // if update reward is greater than cap, set to remaining difference\n                    updatedRewards_ = rewardsCap - rewardsClaimedInEpoch;\n                }\n\n                // accumulate the full amount of additional rewards\n                updateRewardsClaimed[curBurnEpoch] += updatedRewards_;\n            }\n        }\n\n        // emit event with the list of bucket indexes updated\n        emit UpdateExchangeRates(msg.sender, pool_, indexes_, updatedRewards_);\n    }\n\n    /**\n     *  @notice Update the exchange rate of a specific bucket.\n     *  @param  pool_        Address of the pool whose exchange rates are being updated.\n     *  @param  bucketIndex_ Bucket index to update exchange rate.\n     *  @param  burnEpoch_   Current burn epoch of the pool.\n     */\n    function _updateBucketExchangeRate(\n        address pool_,\n        uint256 bucketIndex_,\n        uint256 burnEpoch_\n    ) internal {\n        uint256 burnExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_];\n\n        // update bucket exchange rate at epoch only if it wasn't previously updated\n        if (burnExchangeRate == 0) {\n            uint256 curBucketExchangeRate = IPool(pool_).bucketExchangeRate(bucketIndex_);\n\n            // record bucket exchange rate at epoch\n            bucketExchangeRates[pool_][bucketIndex_][burnEpoch_] = curBucketExchangeRate;\n        }\n    }\n\n    /**\n     *  @notice Update the exchange rate of a specific bucket and calculate rewards based on prev exchange rate.\n     *  @param  pool_           Address of the pool whose exchange rates are being updated.\n     *  @param  bucketIndex_    Bucket index to update exchange rate.\n     *  @param  burnEpoch_      Current burn epoch of the pool.\n     *  @param  totalBurned_    Total `Ajna` tokens burned in pool.\n     *  @param  interestEarned_ Total interest rate earned in pool.\n     *  @return rewards_        Rewards for bucket exchange rate update.\n     */\n    function _updateBucketExchangeRateAndCalculateRewards(\n        address pool_,\n        uint256 bucketIndex_,\n        uint256 burnEpoch_,\n        uint256 totalBurned_,\n        uint256 interestEarned_\n    ) internal returns (uint256 rewards_) {\n        uint256 burnExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_];\n\n        // update bucket exchange rate at epoch only if it wasn't previously updated\n        if (burnExchangeRate == 0) {\n            uint256 curBucketExchangeRate = IPool(pool_).bucketExchangeRate(bucketIndex_);\n\n            // record bucket exchange rate at epoch\n            bucketExchangeRates[pool_][bucketIndex_][burnEpoch_] = curBucketExchangeRate;\n\n            // retrieve the bucket exchange rate at the previous epoch\n            uint256 prevBucketExchangeRate = bucketExchangeRates[pool_][bucketIndex_][burnEpoch_ - 1];\n\n            // skip reward calculation if update at the previous epoch was missed and if exchange rate decreased due to bad debt\n            // prevents excess rewards from being provided from using a 0 value as an input to the interestFactor calculation below.\n            if (prevBucketExchangeRate != 0 && prevBucketExchangeRate < curBucketExchangeRate) {\n\n                // retrieve current deposit of the bucket\n                (, , , uint256 bucketDeposit, ) = IPool(pool_).bucketInfo(bucketIndex_);\n\n                uint256 burnFactor     = Maths.wmul(totalBurned_, bucketDeposit);\n                uint256 interestFactor = interestEarned_ == 0 ? 0 : Maths.wdiv(\n                    Maths.WAD - Maths.wdiv(prevBucketExchangeRate, curBucketExchangeRate),\n                    interestEarned_\n                );\n\n                // calculate rewards earned for updating bucket exchange rate \n                rewards_ += Maths.wmul(UPDATE_CLAIM_REWARD, Maths.wmul(burnFactor, interestFactor));\n            }\n        }\n    }\n\n    /** @notice Utility method to transfer `Ajna` rewards to the sender\n     *  @dev   This method is used to transfer rewards to the `msg.sender` after a successful claim or update.\n     *  @dev   It is used to ensure that rewards claimers will be able to claim some portion of the remaining tokens if a claim would exceed the remaining contract balance.\n     *  @param rewardsEarned_ Amount of rewards earned by the caller.\n     */\n    function _transferAjnaRewards(uint256 rewardsEarned_) internal {\n        // check that rewards earned isn't greater than remaining balance\n        // if remaining balance is greater, set to remaining balance\n        uint256 ajnaBalance = IERC20(ajnaToken).balanceOf(address(this));\n        if (rewardsEarned_ > ajnaBalance) rewardsEarned_ = ajnaBalance;\n\n        if (rewardsEarned_ != 0) {\n            // transfer rewards to sender\n            IERC20(ajnaToken).safeTransfer(msg.sender, rewardsEarned_);\n        }\n    }\n\n}"
    },
    {
      "filename": "ajna-core/src/RewardsManager.sol",
      "content": "// SPDX-Lice"
    }
  ]
}