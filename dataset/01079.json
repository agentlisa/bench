{
  "Title": "M-1: Wrong auctionPrice used in calculating BPF to determine bond reward (or penalty)",
  "Content": "# Issue M-1: Wrong auctionPrice used in calculating BPF to determine bond reward (or penalty) \n\nSource: https://github.com/sherlock-audit/2023-09-ajna-judging/issues/16 \n\n## Found by \nCL001\nAccording to the Ajna Protocol Whitepaper(section  7.4.2 Deposit Take),in example:\n\n\"Instead of Eve purchasing collateral using take, she will call deposit take. Note auction goes through 6 twenty minute halvings, followed by 2 two hour halvings, and then finally 22.8902 minutes (0.1900179029 * 120min) of a two hour halving. After 6.3815 hours (6*20 minutes +2*120 minutes + 22.8902 minutes), the auction price has fallen to 312, 998. 784 Â· 2 ^ âˆ’(6+2+0.1900179) =1071.77\nwhich is below the price of 1100 where Carol has 20000 deposit.\nDeposit take will purchase the collateral using the deposit at price 1100 and the neutral price is 1222.6515, so the BPF calculation is:\nBPF = 0.011644 * 1222.6515-1100 / 1222.6515-1050 = 0.008271889129â€œ.\n\nAs described in the whiterpaper, in the case of user who calls Deposit Take, the correct approach to calculating BPF is to use bucket price(1100  instead of 1071.77) when auctionPrice < bucketPrice .\n\n## Vulnerability Detail\n1.bucketTake() function in TakerActions.sol calls the  _takeBucket()._prepareTake() to calculate the BPF.\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/87abfb6a9150e5df3819de58cbd972a66b3b50e3/ajna-core/src/libraries/external/TakerActions.sol#L416\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/87abfb6a9150e5df3819de58cbd972a66b3b50e3/ajna-core/src/libraries/external/TakerActions.sol#L688\n\n2.In _prepareTake() function,the BPF is calculated using vars.auctionPrice which is calculated by _auctionPrice() function.\n```solidity\nfunction _prepareTake(\n        Liquidation memory liquidation_,\n        uint256 t0Debt_,\n        uint256 collateral_,\n        uint256 inflator_\n    ) internal view returns (TakeLocalVars memory vars) {\n ........\n        vars.auctionPrice = _auctionPrice(liquidation_.referencePrice, kickTime);\n        vars.bondFactor   = liquidation_.bondFactor;\n        vars.bpf          = _bpf(\n            vars.borrowerDebt,\n            collateral_,\n            neutralPrice,\n            liquidation_.bondFactor,\n            vars.auctionPrice\n        );\n```\n3.The _takeBucket() function made a judgment after _prepareTake() \n```solidity\n // cannot arb with a price lower than the auction price\nif (vars_.auctionPrice > vars_.bucketPrice) revert AuctionPriceGtBucketPrice();\n// if deposit take then price to use when calculating take is bucket price\nif (params_.depositTake) vars_.auctionPrice = vars_.bucketPrice;\n```\n\nso the root cause of this issue is that  in a scenario where a user calls Deposit Take(params_.depositTake ==true) ,BPF will calculated base on vars_.auctionPrice  instead of bucketPrice. \n\nAnd then,BPF is used to calculate takePenaltyFactor, borrowerPrice , netRewardedPrice and bondChange in the  _calculateTakeFlowsAndBondChange() functionï¼Œand direct impact on  the _rewardBucketTake() function.\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/87abfb6a9150e5df3819de58cbd972a66b3b50e3/ajna-core/src/libraries/external/TakerActions.sol#L724\n\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/87abfb6a9150e5df3819de58cbd972a66b3b50e3/ajna-core/src/libraries/external/TakerActions.sol#L640\n```solidity\n vars_ = _calculateTakeFlowsAndBondChange(\n            borrower_.collateral,\n            params_.inflator,\n            params_.collateralScale,\n            vars_\n        );\n.............\n_rewardBucketTake(\n            auctions_,\n            deposits_,\n            buckets_,\n            liquidation,\n            params_.index,\n            params_.depositTake,\n            vars_\n        );\n```\n\n\n## Impact\nWrong auctionPrice used in calculating BFP which subsequently influences the _calculateTakeFlowsAndBondChange() and _rewardBucketTake() function will result in bias .\n\n\nFollowing the example of the Whitepaper(section 7.4.2 Deposit Take)ï¼š\nBPF = 0.011644 * (1222.6515-1100 / 1222.6515-1050) = 0.008271889129\nThe collateral purchased is min{20, 20000/(1-0.00827) * 1100, 21000/(1-0.01248702772 )* 1100)} which is 18.3334 unit of ETH .Therefore, 18.3334 ETH are moved from the loan into the claimable collateral of bucket 1100, and the deposit is reduced to 0. Dave is awarded LPB in that bucket worth 18. 3334 Â· 1100 Â· 0. 008271889129 = 166. 8170374 ð·ð´ð¼.\nThe debt repaid is 19914.99407 DAI\n\n----------------------------------------------\n\nBased on the current implementations:\nBPF = 0.011644 * (1222.6515-1071.77 / 1222.6515-1050) = 0.010175.\nTPF = 5/4*0.011644 - 1/4 *0.010175 = 0.01201125.\nThe collateral purchased is 18.368 unit of ETH.\nThe debt repaid is 20000 * (1-0.01201125) / (1-0.010175) = 19962.8974DAI\nDave is awarded LPB in that bucket worth 18. 368 Â· 1100 Â· 0. 010175 = 205.58 ð·ð´ð¼.\n\nSo,Dave earn more rewardsï¼ˆ38.703 DAIï¼‰ than he should have.\n\nAs the Whitepaper says:\n\"\nthe caller would typically have other motivations. She might have called it because she is Carol, who wanted to buy the ETH but not add additional DAI to the contract. She might be Bob, who is looking to get his debt repaid at the best price. She might be Alice, who is looking to avoid bad debt being pushed into the contract. She also might be Dave, who is looking to ensure a return on his liquidation bond.\"\n\n\n\n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-09-ajna/blob/87abfb6a9150e5df3819de58cbd972a66b3b50e3/ajna-core/src/libraries/external/TakerActions.sol#L416\n\n## Tool used\nManual Review\n\n## Recommendation\nIn the case of Deposit Take calculate BPF using  bucketPrice instead of auctionPrice .\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**n33k** commented:\n>  \"`if (params_.depositTake) vars_.auctionPrice = vars_.bucketPrice;` made \"\n\n\n\n**Czar102**\n\nIt seems this issue was accepted and it was opened during the escalation period. The sponsor closed the issue after the escalation period. Since there were no escalations, I believe this is valid. \n\nI will reopen the issue.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/114",
  "Code": [
    {
      "filename": "ajna-core/src/libraries/external/TakerActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { PRBMathSD59x18 } from \"@prb-math/contracts/PRBMathSD59x18.sol\";\nimport { Math }           from '@openzeppelin/contracts/utils/math/Math.sol';\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    BurnEvent,\n    DepositsState,\n    Liquidation,\n    LoansState,\n    PoolState,\n    ReserveAuctionState\n}                        from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    TakeResult\n}                        from '../../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    _auctionPrice,\n    _bpf,\n    _priceAt,\n    _reserveAuctionPrice,\n    _roundToScale,\n    _roundUpToScale\n}                           from '../helpers/PoolHelper.sol';\nimport { _revertOnMinDebt } from '../helpers/RevertsHelper.sol';\n\nimport { SettlerActions } from './SettlerActions.sol';\n\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  Auction Taker Actions library\n    @notice External library containing actions involving taking auctions within pool:\n            - `take` and `bucketTake` auctioned collateral; take reserves\n */\nlibrary TakerActions {\n\n    /*******************************/\n    /*** Function Params Structs ***/\n    /*******************************/\n\n    /// @dev Struct used to hold `bucketTake` function params.\n    struct BucketTakeParams {\n        address borrower;        // borrower address to take from\n        bool    depositTake;     // deposit or arb take, used by bucket take\n        uint256 index;           // bucket index, used by bucket take\n        uint256 inflator;        // [WAD] current pool inflator\n        uint256 collateralScale; // precision of collateral token based on decimals\n    }\n\n    /// @dev Struct used to hold `take` function params.\n    struct TakeParams {\n        address borrower;        // borrower address to take from\n        uint256 takeCollateral;  // [WAD] desired amount to take\n        uint256 inflator;        // [WAD] current pool inflator\n        uint256 poolType;        // pool type (ERC20 or NFT)\n        uint256 collateralScale; // precision of collateral token based on decimals\n    }\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `take` function local vars.\n    struct TakeLocalVars {\n        uint256 auctionPrice;                // [WAD] The price of auction.\n        uint256 bondChange;                  // [WAD] The change made on the bond size (beeing reward or penalty).\n        uint256 borrowerDebt;                // [WAD] The accrued debt of auctioned borrower.\n        int256  bpf;                         // The bond penalty factor.\n        uint256 bondFactor;                  // [WAD] The bond factor.\n        uint256 bucketPrice;                 // [WAD] The bucket price.\n        uint256 bucketScale;                 // [WAD] The bucket scale.\n        uint256 collateralAmount;            // [WAD] The amount of collateral taken.\n        uint256 excessQuoteToken;            // [WAD] Difference of quote token that borrower receives after take (for fractional NFT only)\n        uint256 factor;                      // The take factor, calculated based on bond penalty factor.\n        bool    isRewarded;                  // True if kicker is rewarded (auction price lower than neutral price), false if penalized (auction price greater than neutral price).\n        address kicker;                      // Address of auction kicker.\n        uint256 quoteTokenAmount;            // [WAD] Scaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral\n        uint256 t0RepayAmount;               // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t0 terms.\n        uint256 t0BorrowerDebt;              // [WAD] Borrower's t0 debt.\n        uint256 unscaledDeposit;             // [WAD] Unscaled bucket quantity\n        uint256 unscaledQuoteTokenAmount;    // [WAD] The unscaled token amount that taker should pay for collateral taken.\n        uint256 depositCollateralConstraint; // [WAD] Constraint on bucket take from deposit present in bucket\n        uint256 debtCollateralConstraint;    // [WAD] Constraint on take due to debt.\n   }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event BucketTake(address indexed borrower, uint256 index, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);\n    event BucketTakeLPAwarded(address indexed taker, address indexed kicker, uint256 lpAwardedTaker, uint256 lpAwardedKicker);\n    event Take(address indexed borrower, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);\n    event ReserveAuction(uint256 claimableReservesRemaining, uint256 auctionPrice, uint256 currentBurnEpoch);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error AuctionNotTakeable();\n    error AuctionPriceGtBucketPrice();\n    error CollateralRoundingNeededButNotPossible();\n    error InsufficientLiquidity();\n    error InsufficientCollateral();\n    error InvalidAmount();\n    error NoAuction();\n    error NoReserves();\n    error NoReservesAuction();\n    error ReserveAuctionTooSoon();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IPoolTakerActions` for descriptions.\n     *  @notice Performs bucket take collateral on an auction, rewards taker and kicker (if case) and updates loan info (settles auction if case).\n     *  @dev    === Reverts on ===\n     *  @dev    not enough collateral to take `InsufficientCollateral()`\n     *  @return result_ `TakeResult` struct containing details of bucket take result.\n    */\n    function bucketTake(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        PoolState memory poolState_,\n        address borrowerAddress_,\n        bool    depositTake_,\n        uint256 index_,\n        uint256 collateralScale_\n    ) external returns (TakeResult memory result_) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n        // revert if borrower's collateral is 0\n        if (borrower.collateral == 0) revert InsufficientCollateral();\n\n        result_.debtPreAction       = borrower.t0Debt;\n        result_.collateralPreAction = borrower.collateral;\n\n        // bucket take auction\n        TakeLocalVars memory vars = _takeBucket(\n            auctions_,\n            buckets_,\n            deposits_,\n            borrower,\n            BucketTakeParams({\n                borrower:        borrowerAddress_,\n                inflator:        poolState_.inflator,\n                depositTake:     depositTake_,\n                index:           index_,\n                collateralScale: collateralScale_\n            })\n        );\n\n        // update borrower after take\n        borrower.collateral -= vars.collateralAmount;\n        borrower.t0Debt     = vars.t0BorrowerDebt - vars.t0RepayAmount;\n        // update pool params after take\n        poolState_.t0Debt -= vars.t0RepayAmount;\n        poolState_.debt   = Maths.wmul(poolState_.t0Debt, poolState_.inflator);\n\n        // update loan after take\n        (\n            result_.newLup,\n            result_.settledAuction,\n            result_.remainingCollateral,\n            result_.compensatedCollateral\n        ) = _takeLoan(auctions_, buckets_, deposits_, loans_, poolState_, borrower, borrowerAddress_);\n\n        // complete take result struct\n        result_.debtPostAction       = borrower.t0Debt;\n        result_.collateralPostAction = borrower.collateral;\n        result_.t0PoolDebt           = poolState_.t0Debt;\n        result_.poolDebt             = poolState_.debt;\n        result_.collateralAmount     = vars.collateralAmount;\n        // if settled then debt in auction changed is the entire borrower debt, otherwise only repaid amount\n        result_.t0DebtInAuctionChange = result_.settledAuction ? vars.t0BorrowerDebt : vars.t0RepayAmount;\n    }\n\n    /**\n     *  @notice See `IPoolTakerActions` for descriptions.\n     *  @notice Performs take collateral on an auction, rewards taker and kicker (if case) and updates loan info (settles auction if case).\n     *  @dev    === Reverts on ===\n     *  @dev    insufficient collateral to take `InsufficientCollateral()`\n     *  @return result_ `TakeResult` struct containing details of take result.\n    */\n    function take(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        PoolState memory poolState_,\n        address borrowerAddress_,\n        uint256 collateral_,\n        uint256 collateralScale_\n    ) external returns (TakeResult memory result_) {\n        // revert if no amount to take\n        if (collateral_ == 0) revert InvalidAmount();\n\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        if (\n            // revert in case of NFT take when there isn't a full token to be taken\n            (poolState_.poolType == uint8(PoolType.ERC721) && borrower.collateral < 1e18) ||\n            // revert in case of ERC20 take when no collateral to be taken\n            (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)\n        ) {\n            revert InsufficientCollateral();\n        }\n\n        result_.debtPreAction       = borrower.t0Debt;\n        result_.collateralPreAction = borrower.collateral;\n\n        // take auction\n        TakeLocalVars memory vars = _take(\n            auctions_,\n            borrower,\n            TakeParams({\n                borrower:        borrowerAddress_,\n                takeCollateral:  collateral_,\n                inflator:        poolState_.inflator,\n                poolType:        poolState_.poolType,\n                collateralScale: collateralScale_\n            })\n        );\n\n        // update borrower after take\n        borrower.collateral -= vars.collateralAmount;\n        borrower.t0Debt     = vars.t0BorrowerDebt - vars.t0RepayAmount;\n        // update pool params after take\n        poolState_.t0Debt -= vars.t0RepayAmount;\n        poolState_.debt   = Maths.wmul(poolState_.t0Debt, poolState_.inflator);\n\n        // update loan after take\n        (\n            result_.newLup,\n            result_.settledAuction,\n            result_.remainingCollateral,\n            result_.compensatedCollateral\n        ) = _takeLoan(auctions_, buckets_, deposits_, loans_, poolState_, borrower, borrowerAddress_);\n\n        // complete take result struct\n        result_.debtPostAction       = borrower.t0Debt;\n        result_.collateralPostAction = borrower.collateral;\n        result_.t0PoolDebt           = poolState_.t0Debt;\n        result_.poolDebt             = poolState_.debt;\n        result_.collateralAmount     = vars.collateralAmount;\n        result_.quoteTokenAmount     = vars.quoteTokenAmount;\n        result_.excessQuoteToken     = vars.excessQuoteToken;\n        // if settled then debt in auction changed is the entire borrower debt, otherwise only repaid amount\n        result_.t0DebtInAuctionChange = result_.settledAuction ? vars.t0BorrowerDebt : vars.t0RepayAmount;\n    }\n\n    /*************************/\n    /***  Reserve Auction  ***/\n    /*************************/\n\n    /**\n     *  @notice See `IPoolTakerActions` for descriptions.\n     *  @dev    === Write state ===\n     *  @dev    decrement `reserveAuction.unclaimed` accumulator\n     *  @dev    === Reverts on ===\n     *  @dev    not kicked or `72` hours didn't pass `NoReservesAuction()`\n     *  @dev    === Emit events ===\n     *  @dev    - `ReserveAuction`\n     */\n    function takeReserves(\n        ReserveAuctionState storage reserveAuction_,\n        uint256 maxAmount_\n    ) external returns (uint256 amount_, uint256 ajnaRequired_) {\n        // revert if no amount to be taken\n        if (maxAmount_ == 0) revert InvalidAmount();\n\n        uint256 kicked = reserveAuction_.kicked;\n\n        if (kicked != 0 && block.timestamp - kicked <= 72 hours) {\n            uint256 unclaimed = reserveAuction_.unclaimed;\n            uint256 price     = _reserveAuctionPrice(kicked);\n\n            amount_       = Maths.min(unclaimed, maxAmount_);\n            ajnaRequired_ = Maths.ceilWmul(amount_, price);\n\n            unclaimed -= amount_;\n\n            reserveAuction_.unclaimed = unclaimed;\n\n            uint256 totalBurned = reserveAuction_.totalAjnaBurned + ajnaRequired_;\n            \n            // accumulate additional ajna burned\n            reserveAuction_.totalAjnaBurned = totalBurned;\n\n            uint256 burnEventEpoch = reserveAuction_.latestBurnEventEpoch;\n\n            // record burn event information to enable querying by staking rewards\n            BurnEvent storage burnEvent = reserveAuction_.burnEvents[burnEventEpoch];\n            burnEvent.totalInterest = reserveAuction_.totalInterestEarned;\n            burnEvent.totalBurned   = totalBurned;\n\n            emit ReserveAuction(\n                unclaimed,\n                price,\n                burnEventEpoch\n            );\n        } else {\n            revert NoReservesAuction();\n        }\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Performs take collateral on an auction and updates bond size and kicker balance accordingly.\n     *  @dev    === Emit events ===\n     *  @dev    - `Take`\n     *  @param  auctions_ Struct for pool auctions state.\n     *  @param  borrower_ Struct containing auctioned borrower details.\n     *  @param  params_   Struct containing take action params details.\n     *  @return vars_     Struct containing auction take vars.\n    */\n    function _take(\n        AuctionsState storage auctions_,\n        Borrower memory borrower_,\n        TakeParams memory params_\n    ) internal returns (TakeLocalVars memory vars_) {\n        Liquidation storage liquidation = auctions_.liquidations[params_.borrower];\n\n        // Auction may not be taken in the same block it was kicked\n        if (liquidation.kickTime == block.timestamp) revert AuctionNotTakeable();\n\n        vars_ = _prepareTake(\n            liquidation,\n            borrower_.t0Debt,\n            borrower_.collateral,\n            params_.inflator\n        );\n\n        // These are placeholder max values passed to calculateTakeFlows because there is no explicit bound on the\n        // quote token amount in take calls (as opposed to bucketTake)\n        vars_.unscaledDeposit = type(uint256).max;\n        vars_.bucketScale     = Maths.WAD;\n\n        uint256 takeableCollateral = borrower_.collateral;\n        // for NFT take make sure the take flow and bond change calculation happens for the rounded collateral that can be taken\n        if (params_.poolType == uint8(PoolType.ERC721)) {\n            takeableCollateral = (takeableCollateral / 1e18) * 1e18;\n        }\n\n        // In the case of take, the taker binds the collateral qty but not the quote token qty\n        // ugly to get take work like a bucket take -- this is the max amount of quote token from the take that could go to\n        // reduce the debt of the borrower -- analagous to the amount of deposit in the bucket for a bucket take\n        vars_ = _calculateTakeFlowsAndBondChange(\n            Maths.min(takeableCollateral, params_.takeCollateral),\n            params_.inflator,\n            params_.collateralScale,\n            vars_\n        );\n\n        _rewardTake(auctions_, liquidation, vars_);\n\n        emit Take(\n            params_.borrower,\n            vars_.quoteTokenAmount,\n            vars_.collateralAmount,\n            vars_.bondChange,\n            vars_.isRewarded\n        );\n\n        if (params_.poolType == uint8(PoolType.ERC721)) {\n            // slither-disable-next-line divide-before-multiply\n            uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 / 1 = 2\n\n            // collateral taken not a round number\n            if (collateralTaken != vars_.collateralAmount) {\n                if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 1e18) {\n                    // round up collateral to take\n                    collateralTaken += 1e18;\n\n                    // taker should send additional quote tokens to cover difference between collateral needed to be taken and rounded collateral, at auction price\n                    // borrower will get quote tokens for the difference between rounded collateral and collateral taken to cover debt\n                    vars_.excessQuoteToken = Maths.wmul(collateralTaken - vars_.collateralAmount, vars_.auctionPrice);\n                    vars_.collateralAmount = collateralTaken;\n                } else {\n                    // shouldn't get here, but just in case revert\n                    revert CollateralRoundingNeededButNotPossible();\n                }\n            }\n        }\n    }\n\n    /**\n     *  @notice Performs bucket take collateral on an auction and rewards taker and kicker (if case).\n     *  @dev    === Emit events ===\n     *  @dev    - `BucketTake`\n     *  @param  auctions_ Struct for pool auctions state.\n     *  @param  buckets_  Struct for pool buckets state.\n     *  @param  deposits_ Struct for pool deposits state.\n     *  @param  borrower_ Struct containing auctioned borrower details.\n     *  @param  params_   Struct containing take action details.\n     *  @return vars_     Struct containing auction take vars.\n    */\n    function _takeBucket(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        Borrower memory borrower_,\n        BucketTakeParams memory params_\n    ) internal returns (TakeLocalVars memory vars_) {\n        Liquidation storage liquidation = auctions_.liquidations[params_.borrower];\n\n        // Auction may not be taken in the same block it was kicked\n        if (liquidation.kickTime == block.timestamp) revert AuctionNotTakeable();\n\n        vars_= _prepareTake(\n            liquidation,\n            borrower_.t0Debt,\n            borrower_.collateral,\n            params_.inflator\n        );\n\n        vars_.unscaledDeposit = Deposits.unscaledValueAt(deposits_, params_.index);\n\n        // revert if no quote tokens in arbed bucket\n        if (vars_.unscaledDeposit == 0) revert InsufficientLiquidity();\n\n        vars_.bucketPrice  = _priceAt(params_.index);\n\n        // cannot arb with a price lower than the auction price\n        if (vars_.auctionPrice > vars_.bucketPrice) revert AuctionPriceGtBucketPrice();\n        \n        // if deposit take then price to use when calculating take is bucket price\n        if (params_.depositTake) vars_.auctionPrice = vars_.bucketPrice;\n\n        vars_.bucketScale = Deposits.scale(deposits_, params_.index);\n\n        vars_ = _calculateTakeFlowsAndBondChange(\n            borrower_.collateral,\n            params_.inflator,\n            params_.collateralScale,\n            vars_\n        );\n\n        // revert if bucket deposit cannot cover at least one unit of collateral\n        if (vars_.collateralAmount == 0) revert InsufficientLiquidity();\n\n        _rewardBucketTake(\n            auctions_,\n            deposits_,\n            buckets_,\n            liquidation,\n            params_.index,\n            params_.depositTake,\n            vars_\n        );\n\n        emit BucketTake(\n            params_.borrower,\n            params_.index,\n            vars_.quoteTokenAmount,\n            vars_.collateralAmount,\n            vars_.bondChange,\n            vars_.isRewarded\n        );\n    }\n\n    /**\n     *  @notice Performs update of an auctioned loan that was taken (using bucket or regular take).\n     *  @notice If borrower's debt has been fully covered, then auction is settled. Update loan's state.\n     *  @dev    === Reverts on ===\n     *  @dev    borrower debt less than pool min debt `AmountLTMinDebt()`\n     *  @param  auctions_              Struct for pool auctions state.\n     *  @param  buckets_               Struct for pool buckets state.\n     *  @param  deposits_              Struct for pool deposits state.\n     *  @param  loans_                 Struct for pool loans state.\n     *  @param  poolState_             Struct containing pool details.\n     *  @param  borrower_              The borrower details owning loan that is taken.\n     *  @param  borrowerAddress_       The address of the borrower.\n     *  @return newLup_                The new `LUP` of pool (after debt is repaid).\n     *  @return settledAuction_        True if auction is settled by the take action. (`NFT` take: rebalance borrower collateral in pool if true)\n     *  @return remainingCollateral_   Borrower collateral remaining after take action. (`NFT` take: collateral to be rebalanced in case of `NFT` settlement)\n     *  @return compensatedCollateral_ Amount of collateral compensated, to be deducted from pool pledged collateral accumulator.\n    */\n    function _takeLoan(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        PoolState memory poolState_,\n        Borrower memory borrower_,\n        address borrowerAddress_\n    ) internal returns (\n        uint256 newLup_,\n        bool settledAuction_,\n        uint256 remainingCollateral_,\n        uint256 compensatedCollateral_\n    ) {\n\n        uint256 borrowerDebt = Maths.wmul(borrower_.t0Debt, poolState_.inflator);\n\n        // check that taking from loan doesn't leave borrower debt under min debt amount\n        _revertOnMinDebt(\n            loans_,\n            poolState_.debt,\n            borrowerDebt,\n            poolState_.quoteTokenScale\n        );\n\n        remainingCollateral_ = borrower_.collateral;\n\n        // if debt is fully repaid, settle the auction\n        if (borrower_.t0Debt == 0) {\n            settledAuction_ = true;\n\n            // settle auction and update borrower's collateral with value after settlement\n            (remainingCollateral_, compensatedCollateral_) = SettlerActions._settleAuction(\n                auctions_,\n                buckets_,\n                deposits_,\n                borrowerAddress_,\n                borrower_.collateral,\n                poolState_.poolType\n            );\n\n            borrower_.collateral = remainingCollateral_;\n        }\n\n        // update loan state, stamp borrower Np to Tp ratio only when exiting from auction\n        Loans.update(\n            loans_,\n            borrower_,\n            borrowerAddress_,\n            poolState_.rate,\n            !settledAuction_,\n            settledAuction_ // stamp borrower Np to Tp ratio if exiting from auction\n        );\n\n        // calculate new lup with repaid debt from take\n        newLup_ = Deposits.getLup(deposits_, poolState_.debt);\n    }\n\n    /**\n     *  @notice Rewards actors of a regular take action.\n     *  @dev    === Write state ===\n     *  @dev    update liquidation `bond size` accumulator\n     *  @dev    update kicker's `locked balance` accumulator\n     *  @dev    update `auctions.totalBondEscrowed` accumulator\n     *  @param  auctions_     Struct for pool auctions state.\n     *  @param  liquidation_  Struct containing details of auction.\n     *  @param  vars          Struct containing take action result details.\n     */\n    function _rewardTake(\n        AuctionsState storage auctions_,\n        Liquidation storage liquidation_,\n        TakeLocalVars memory vars\n    ) internal {\n        if (vars.isRewarded) {\n            // take is below neutralPrice, Kicker is rewarded\n            liquidation_.bondSize                 += uint160(vars.bondChange);\n            auctions_.kickers[vars.kicker].locked += vars.bondChange;\n            auctions_.totalBondEscrowed           += vars.bondChange;\n        } else {\n            // take is above neutralPrice, Kicker is penalized\n            vars.bondChange = Maths.min(liquidation_.bondSize, vars.bondChange);\n\n            liquidation_.bondSize                 -= uint160(vars.bondChange);\n            auctions_.kickers[vars.kicker].locked -= vars.bondChange;\n            auctions_.totalBondEscrowed           -= vars.bondChange;\n        }\n    }\n\n    /**\n     *  @notice Rewards actors of a bucket take action.\n     *  @dev    === Write state ===\n     *  @dev    - `Buckets.addLenderLP`:\n     *  @dev      increment taker `lender.lps` accumulator and `lender.depositTime` state\n     *  @dev      increment kicker `lender.lps` accumulator and l`ender.depositTime` state\n     *  @dev    - update liquidation bond size accumulator\n     *  @dev    - update kicker's locked balance accumulator\n     *  @dev    - update `auctions.totalBondEscrowed` accumulator\n     *  @dev    - `Deposits.unscaledRemove()` (remove amount in `Fenwick` tree, from index):\n     *  @dev      update `values` array state\n     *  @dev    - increment `bucket.collateral` and `bucket.lps` accumulator\n     *  @dev    === Emit events ===\n     *  @dev    - `BucketTakeLPAwarded`\n     *  @param  auctions_     Struct for pool auctions state.\n     *  @param  deposits_     Struct for pool deposits state.\n     *  @param  buckets_      Struct for pool buckets state.\n     *  @param  liquidation_  Struct containing details of auction to be taken from.\n     *  @param  bucketIndex_  Index of a bucket, likely the `HPB`, in which collateral will be deposited.\n     *  @param  depositTake_  If `true` then the take will happen at an auction price equal with bucket price. Auction price is used otherwise.\n     *  @param  vars          Struct containing bucket take action result details.\n     */\n    function _rewardBucketTake(\n        AuctionsState storage auctions_,\n        DepositsState storage deposits_,\n        mapping(uint256 => Bucket) storage buckets_,\n        Liquidation storage liquidation_,\n        uint256 bucketIndex_,\n        bool depositTake_,\n        TakeLocalVars memory vars\n    ) internal {\n        Bucket storage bucket = buckets_[bucketIndex_];\n\n        uint256 bankruptcyTime = bucket.bankruptcyTime;\n        uint256 scaledDeposit  = Maths.wmul(vars.unscaledDeposit, vars.bucketScale);\n        uint256 totalLPReward;\n        uint256 takerLPReward;\n        uint256 kickerLPReward;\n\n        // if arb take - taker is awarded collateral * (bucket price - auction price) worth (in quote token terms) units of LPB in the bucket\n        if (!depositTake_) {\n            takerLPReward = Buckets.quoteTokensToLP(\n                bucket.collateral,\n                bucket.lps,\n                scaledDeposit,\n                Maths.wmul(vars.collateralAmount, vars.bucketPrice - vars.auctionPrice),\n                vars.bucketPrice,\n                Math.Rounding.Down\n            );\n            totalLPReward = takerLPReward;\n\n            Buckets.addLenderLP(bucket, bankruptcyTime, msg.sender, takerLPReward);\n        }\n\n        // the bondholder/kicker is awarded bond change worth of LPB in the bucket\n        if (vars.isRewarded) {\n            kickerLPReward = Buckets.quoteTokensToLP(\n                bucket.collateral,\n                bucket.lps,\n                scaledDeposit,\n                vars.bondChange,\n                vars.bucketPrice,\n                Math.Rounding.Down\n            );\n            totalLPReward  += kickerLPReward;\n\n            Buckets.addLenderLP(bucket, bankruptcyTime, vars.kicker, kickerLPReward);\n        } else {\n            // take is above neutralPrice, Kicker is penalized\n            vars.bondChange = Maths.min(liquidation_.bondSize, vars.bondChange);\n\n            liquidation_.bondSize -= uint160(vars.bondChange);\n\n            auctions_.kickers[vars.kicker].locked -= vars.bondChange;\n            auctions_.totalBondEscrowed           -= vars.bondChange;\n        }\n\n        // remove quote tokens from bucketâ€™s deposit\n        Deposits.unscaledRemove(deposits_, bucketIndex_, vars.unscaledQuoteTokenAmount);\n\n        // total rewarded LP are added to the bucket LP balance\n        if (totalLPReward != 0) bucket.lps += totalLPReward;\n        // collateral is added to the bucketâ€™s claimable collateral\n        bucket.collateral += vars.collateralAmount;\n\n        emit BucketTakeLPAwarded(\n            msg.sender,\n            vars.kicker,\n            takerLPReward,\n            kickerLPReward\n        );\n    }\n\n    /**\n     *  @notice Utility function to validate take and calculate take's parameters.\n     *  @dev    reverts on:\n     *              - loan is not in auction NoAuction()\n     *  @param  liquidation_ Liquidation struct holding auction details.\n     *  @param  t0Debt_      Borrower t0 debt.\n     *  @param  collateral_  Borrower collateral.\n     *  @param  inflator_    The pool's inflator, used to calculate borrower debt.\n     *  @return vars         The prepared vars for take action.\n     */\n    function _prepareTake(\n        Liquidation memory liquidation_,\n        uint256 t0Debt_,\n        uint256 collateral_,\n        uint256 inflator_\n    ) internal view returns (TakeLocalVars memory vars) {\n\n        uint256 kickTime = liquidation_.kickTime;\n        if (kickTime == 0) revert NoAuction();\n\n        vars.t0BorrowerDebt = t0Debt_;\n\n        vars.borrowerDebt = Maths.wmul(vars.t0BorrowerDebt, inflator_);\n\n        uint256 neutralPrice = liquidation_.neutralPrice;\n\n        vars.auctionPrice = _auctionPrice(liquidation_.referencePrice, kickTime);\n        vars.bondFactor   = liquidation_.bondFactor;\n        vars.bpf          = _bpf(\n            vars.borrowerDebt,\n            collateral_,\n            neutralPrice,\n            liquidation_.bondFactor,\n            vars.auctionPrice\n        );\n        vars.factor       = uint256(1e18 - Maths.maxInt(0, vars.bpf));\n        vars.kicker       = liquidation_.kicker;\n        vars.isRewarded   = (vars.bpf  >= 0);\n    }\n\n    /**\n     *  @notice Computes the flows of collateral, quote token between the borrower, lender and kicker.\n     *  @param  totalCollateral_        Total collateral in loan.\n     *  @param  inflator_               Current pool inflator.\n     *  @param  vars                    TakeParams for the take/buckettake\n     */\n    function _calculateTakeFlowsAndBondChange(\n        uint256              totalCollateral_,\n        uint256              inflator_,\n        uint256              collateralScale_,\n        TakeLocalVars memory vars\n    ) internal pure returns (\n        TakeLocalVars memory\n    ) {\n        // price is the current auction price, which is the price paid by the LENDER for collateral\n        // from the borrower point of view, there is a take penalty of  (1.25 * bondFactor - 0.25 * bpf)\n        // Therefore the price is actually price * (1.0 - 1.25 * bondFactor + 0.25 * bpf)\n        uint256 takePenaltyFactor    = uint256(5 * int256(vars.bondFactor) - vars.bpf + 3) / 4;  // Round up\n        uint256 borrowerPrice        = Maths.floorWmul(vars.auctionPrice, Maths.WAD - takePenaltyFactor);\n\n        // To determine the value of quote token removed from a bucket in a bucket take call, we need to account for whether the bond is\n        // rewarded or not.  If the bond is rewarded, we need to remove the bond reward amount from the amount removed, else it's simply the \n        // collateral times auction price.\n        uint256 netRewardedPrice     = (vars.isRewarded) ? Maths.wmul(Maths.WAD - uint256(vars.bpf), vars.auctionPrice) : vars.auctionPrice;\n\n        // auctions may not be zero-bid; prevent divide-by-zero in constraint calculations\n        if (vars.auctionPrice == 0) revert InvalidAmount();\n\n        // Collateral taken in bucket takes is constrained by the deposit available at the price including the reward.  This is moot in the case of takes.\n        vars.depositCollateralConstraint = (vars.unscaledDeposit != type(uint256).max) ? _roundToScale(Math.mulDiv(vars.unscaledDeposit, vars.bucketScale, netRewardedPrice), collateralScale_) : type(uint256).max;\n\n        // Collateral taken is also constained by the borrower's debt, at the price they receive.\n        vars.debtCollateralConstraint = borrowerPrice != 0 ? _roundUpToScale(Maths.ceilWdiv(vars.borrowerDebt, borrowerPrice), collateralScale_) : type(uint256).max;\n        \n        if (vars.depositCollateralConstraint <= vars.debtCollateralConstraint && vars.depositCollateralConstraint <= totalCollateral_) {\n            // quote toke"
    }
  ]
}