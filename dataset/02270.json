{
  "Title": "H-6: Curve vault will undervalue or overvalue the LP Pool tokens if it comprises tokens with different decimals",
  "Content": "# Issue H-6: Curve vault will undervalue or overvalue the LP Pool tokens if it comprises tokens with different decimals \n\nSource: https://github.com/sherlock-audit/2023-02-notional-judging/issues/8 \n\n## Found by \nxiaoming90\n\n## Summary\n\nA Curve vault that comprises tokens with different decimals will undervalue or overvalue the LP Pool tokens. As a result, users might be liquidated prematurely or be able to borrow more than they are allowed. Additionally, the vault settlement process might break.\n\n## Vulnerability Detail\n\nThe `TwoTokenPoolUtils._getTimeWeightedPrimaryBalance` function, which is utilized by the Curve vault, is used to compute the total value of the LP Pool tokens (`poolClaim`) denominated in the primary token.\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/common/internal/pool/TwoTokenPoolUtils.sol#L67\n\n```solidity\nFile: TwoTokenPoolUtils.sol\n67:     function _getTimeWeightedPrimaryBalance(\n68:         TwoTokenPoolContext memory poolContext,\n69:         StrategyContext memory strategyContext,\n70:         uint256 poolClaim,\n71:         uint256 oraclePrice,\n72:         uint256 spotPrice\n73:     ) internal view returns (uint256 primaryAmount) {\n74:         // Make sure spot price is within oracleDeviationLimit of pairPrice\n75:         strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n76:         \n77:         // Get shares of primary and secondary balances with the provided poolClaim\n78:         uint256 totalSupply = poolContext.poolToken.totalSupply();\n79:         uint256 primaryBalance = poolContext.primaryBalance * poolClaim / totalSupply;\n80:         uint256 secondaryBalance = poolContext.secondaryBalance * poolClaim / totalSupply;\n81: \n82:         // Value the secondary balance in terms of the primary token using the oraclePairPrice\n83:         uint256 secondaryAmountInPrimary = secondaryBalance * strategyContext.poolClaimPrecision / oraclePrice;\n84: \n85:         // Make sure primaryAmount is reported in primaryPrecision\n86:         uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n87:         primaryAmount = (primaryBalance + secondaryAmountInPrimary) * primaryPrecision / strategyContext.poolClaimPrecision;\n88:     }\n```\n\nIf a leverage vault supports a Curve Pool that contains two tokens with different decimals, the math within the `TwoTokenPoolUtils._getTimeWeightedPrimaryBalance` function would not work, and the value returned from it will be incorrect. Consider the following two scenarios:\n\n#### If primary token's decimals (e.g. 18) > secondary token's decimals (e.g. 6)\n\nTo illustrate the issue, assume the following:\n\n- The leverage vault supports the [DAI-USDC Curve Pool](https://curve.fi/#/ethereum/pools/compound/deposit), and its primary token of the vault is DAI.\n- DAI's decimals are 18, while USDC's decimals are 6.\n- Curve Pool's total supply is 100\n- The Curve Pool holds 100 DAI and 100 USDC\n- For the sake of simplicity, the price of DAI and USDC is 1:1. Thus, the `oraclePrice` within the function will be `1 * 10^18`. Note that the oracle price is always scaled up to 18 decimals within the vault.\n\nThe caller of the `TwoTokenPoolUtils._getTimeWeightedPrimaryBalance` function wanted to compute the total value of 50 LP Pool tokens.\n\n```solidity\nprimaryBalance = poolContext.primaryBalance * poolClaim / totalSupply; // 100 DAI * 50 / 100\nsecondaryBalance = poolContext.secondaryBalance * poolClaim / totalSupply; // 100 USDC * 50 / 100\n```\n\nThe `primaryBalance` will be `50 DAI`. `50 DAI` denominated in WEI will be `50 * 10^18` since the decimals of DAI are 18.\n\nThe `secondaryBalance` will be `50 USDC`. `50 USDC` denominated in WEI will be `50 * 10^6` since the decimals of USDC are 6.\n\nNext, the code logic attempts to value the secondary balance (50 USDC) in terms of the primary token (DAI) using the oracle price (`1 * 10^18`).\n\n```solidity\nsecondaryAmountInPrimary = secondaryBalance * strategyContext.poolClaimPrecision / oraclePrice;\nsecondaryAmountInPrimary = 50 USDC * 10^18 / (1 * 10^18)\nsecondaryAmountInPrimary = (50 * 10^6) * 10^18 / (1 * 10^18)\nsecondaryAmountInPrimary = 50 * 10^6\n```\n\n50 USDC should be worth 50 DAI (`50 * 10^18`). However, the `secondaryAmountInPrimary` shows that it is only worth 0.00000000005 DAI (`50 * 10^6`).\n\n```solidity\nprimaryAmount = (primaryBalance + secondaryAmountInPrimary) * primaryPrecision / strategyContext.poolClaimPrecision;\nprimaryAmount = [(50 * 10^18) + (50 * 10^6)] * 10^18 / 10^18\nprimaryAmount = [(50 * 10^18) + (50 * 10^6)] // cancel out the 10^18\nprimaryAmount = 50 DAI + 0.00000000005 DAI = 50.00000000005 DAI\n```\n\n50 LP Pool tokens should be worth 100 DAI. However, the `TwoTokenPoolUtils._getTimeWeightedPrimaryBalance` function shows that it is only worth 50.00000000005 DAI, which undervalues the LP Pool tokens.\n\n#### If primary token's decimals (e.g. 6) < secondary token's decimals (e.g. 18)\n\nTo illustrate the issue, assume the following:\n\n- The leverage vault supports the [DAI-USDC Curve Pool](https://curve.fi/#/ethereum/pools/compound/deposit), and its primary token of the vault is USDC.\n- USDC's decimals are 6, while DAI's decimals are 18.\n- Curve Pool's total supply is 100\n- The Curve Pool holds 100 USDC and 100 DAI\n- For the sake of simplicity, the price of DAI and USDC is 1:1. Thus, the `oraclePrice` within the function will be `1 * 10^18`. Note that the oracle price is always scaled up to 18 decimals within the vault.\n\nThe caller of the `TwoTokenPoolUtils._getTimeWeightedPrimaryBalance` function wanted to compute the total value of 50 LP Pool tokens.\n\n```solidity\nprimaryBalance = poolContext.primaryBalance * poolClaim / totalSupply; // 100 USDC * 50 / 100\nsecondaryBalance = poolContext.secondaryBalance * poolClaim / totalSupply; // 100 DAI * 50 / 100\n```\n\nThe `primaryBalance` will be `50 USDC`. `50 USDC` denominated in WEI will be `50 * 10^6` since the decimals of USDC are 6.\n\nThe `secondaryBalance` will be `50 DAI`. `50 DAI` denominated in WEI will be `50 * 10^18` since the decimals of DAI are 18.\n\nNext, the code logic attempts to value the secondary balance (50 DAI) in terms of the primary token (USDC) using the oracle price (`1 * 10^18`).\n\n```solidity\nsecondaryAmountInPrimary = secondaryBalance * strategyContext.poolClaimPrecision / oraclePrice;\nsecondaryAmountInPrimary = 50 DAI * 10^18 / (1 * 10^18)\nsecondaryAmountInPrimary = (50 * 10^18) * 10^18 / (1 * 10^18)\nsecondaryAmountInPrimary = 50 * 10^18\n```\n\n50 DAI should be worth 50 USDC (`50 * 10^6`). However, the `secondaryAmountInPrimary` shows that it is worth 50,000,000,000,000 USDC (`50 * 10^18`).\n\n```solidity\nprimaryAmount = (primaryBalance + secondaryAmountInPrimary) * primaryPrecision / strategyContext.poolClaimPrecision;\nprimaryAmount = [(50 * 10^6) + (50 * 10^18)] * 10^6 / 10^18\nprimaryAmount = [(50 * 10^6) + (50 * 10^18)] / 10^12\nprimaryAmount = 50,000,000.00005 = 50 million\n```\n\n50 LP Pool tokens should be worth 100 USDC. However, the `TwoTokenPoolUtils._getTimeWeightedPrimaryBalance` function shows that it is worth 50 million USDC, which overvalues the LP Pool tokens.\n\nIn summary, if a leverage vault has two tokens with different decimals:\n\n- If primary token's decimals (e.g. 18) > secondary token's decimals (e.g. 6), then `TwoTokenPoolUtils._getTimeWeightedPrimaryBalance` function will undervalue the LP Pool tokens\n- If primary token's decimals (e.g. 6) < secondary token's decimals (e.g. 18), then `TwoTokenPoolUtils._getTimeWeightedPrimaryBalance` function will overvalue the LP Pool tokens\n\n## Impact\n\nA vault supporting tokens with two different decimals will undervalue or overvalue the LP Pool tokens. \n\nThe affected `TwoTokenPoolUtils._getTimeWeightedPrimaryBalance` function is called within the `Curve2TokenPoolUtils._convertStrategyToUnderlying` function that is used for valuing strategy tokens in terms of the primary balance. As a result, the strategy tokens will be overvalued or undervalued\n\nFollowing are some of the impacts of this issue:\n\n- If the strategy tokens are overvalued or undervalued, the users might be liquidated prematurely or be able to borrow more than they are allowed to since the `Curve2TokenPoolUtils._convertStrategyToUnderlying` function is indirectly used for computing the collateral ratio of an account within Notional's `VaultConfiguration.calculateCollateralRatio` function.\n- `expectedUnderlyingRedeemed` is computed based on the `Curve2TokenPoolUtils._convertStrategyToUnderlying` function. If the `expectedUnderlyingRedeemed` is incorrect, it will break the vault settlement process.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/common/internal/pool/TwoTokenPoolUtils.sol#L67\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen valuing the secondary balance in terms of the primary token using the oracle price, the result should be scaled up or down the decimals of the primary token accordingly if the decimals of the two tokens are different.\n\nThe root cause of this issue is in the following portion of the code, which attempts to add the `primaryBalance` and `secondaryAmountInPrimary` before multiplying with the `primaryPrecision`. The `primaryBalance` and `secondaryAmountInPrimary` might not be denominated in the same decimals. Therefore, they cannot be added together without scaling them if the decimals of two tokens are different.\n\n```solidity\nprimaryAmount = (primaryBalance + secondaryAmountInPrimary) * primaryPrecision / strategyContext.poolClaimPrecision;\n```\n\nConsider implementing the following changes to ensure that the math within the `_getTimeWeightedPrimaryBalance` function work with tokens with different decimals. The below approach will scale the secondary token to match the primary token's precision before performing further computation.\n\n```diff\nfunction _getTimeWeightedPrimaryBalance(\n\tTwoTokenPoolContext memory poolContext,\n\tStrategyContext memory strategyContext,\n\tuint256 poolClaim,\n\tuint256 oraclePrice,\n\tuint256 spotPrice\n) internal view returns (uint256 primaryAmount) {\n\t// Make sure spot price is within oracleDeviationLimit of pairPrice\n\tstrategyContext._checkPriceLimit(oraclePrice, spotPrice);\n\t\n\t// Get shares of primary and secondary balances with the provided poolClaim\n\tuint256 totalSupply = poolContext.poolToken.totalSupply();\n\tuint256 primaryBalance = poolContext.primaryBalance * poolClaim / totalSupply;\n\tuint256 secondaryBalance = poolContext.secondaryBalance * poolClaim / totalSupply;\n\n+\t// Scale secondary balance to primaryPrecision\n+\tuint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n+\tuint256 secondaryPrecision = 10 ** poolContext.secondaryDecimals;\n+\tsecondaryBalance = secondaryBalance * primaryPrecision / secondaryPrecision\n\t\t\t\n\t// Value the secondary balance in terms of the primary token using the oraclePairPrice\n\tuint256 secondaryAmountInPrimary = secondaryBalance * strategyContext.poolClaimPrecision / oraclePrice;\n\t\n-\t// Make sure primaryAmount is reported in primaryPrecision\n-\tuint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n-\tprimaryAmount = (primaryBalance + secondaryAmountInPrimary) * primaryPrecision / strategyContext.poolClaimPrecision;\n+\tprimaryAmount = primaryBalance + secondaryAmountInPrimary\n}\n```\n\nThe `poolContext.primaryBalance` or `poolClaim` are not scaled up to `strategyContext.poolClaimPrecision`. Thus, the `primaryBalance` is not scaled in any form. Thus, I do not see the need to perform any conversion at the last line of the `_getTimeWeightedPrimaryBalance` function.\n\n```solidity\nuint256 primaryBalance = poolContext.primaryBalance * poolClaim / totalSupply;\n```\n\nThe following attempts to run through the examples in the previous section showing that the updated function produces valid results after the changes.\n\nIf primary token's decimals (e.g. 18) > secondary token's decimals (e.g. 6)\n\n```solidity\nPrimary Balance = 50 DAI (18 Deci), Secondary Balance = 50 USDC (6 Deci)\n\nsecondaryBalance = secondaryBalance * primaryPrecision / secondaryPrecision\nsecondaryBalance = 50 USDC * 10^18 / 10^6\nsecondaryBalance = (50 * 10^6) * 10^18 / 10^6 = (50 * 10^18)\n\nsecondaryAmountInPrimary = secondaryBalance * strategyContext.poolClaimPrecision / oraclePrice;\nsecondaryAmountInPrimary = (50 * 10^18) * 10^18 / (1 * 10^18)\nsecondaryAmountInPrimary = (50 * 10^18) * 10^18 / (1 * 10^18)\nsecondaryAmountInPrimary = 50 * 10^18\n\nprimaryAmount = primaryBalance + secondaryAmountInPrimary\nprimaryAmount = (50 * 10^18) + (50 * 10^18) = (100 * 10^18) = 100 DAI\n```\n\nIf primary token's decimals (e.g. 6) < secondary token's decimals (e.g. 18)\n\n```solidity\nPrimary Balance = 50 USDC (6 Deci), Secondary Balance = 50 DAI (18 Deci)\n\nsecondaryBalance = secondaryBalance * primaryPrecision / secondaryPrecision\nsecondaryBalance = 50 DAI * 10^6 / 10^18\nsecondaryBalance = (50 * 10^18) * 10^6 / 10^18 = (50 * 10^6)\n\nsecondaryAmountInPrimary = secondaryBalance * strategyContext.poolClaimPrecision / oraclePrice;\nsecondaryAmountInPrimary = (50 * 10^6) * 10^18 / (1 * 10^18)\nsecondaryAmountInPrimary = (50 * 10^6) * 10^18 / (1 * 10^18)\nsecondaryAmountInPrimary = 50 * 10^6\n\nprimaryAmount = primaryBalance + secondaryAmountInPrimary\nprimaryAmount = (50 * 10^6) + (50 * 10^6) = (100 * 10^6) = 100 USDC\n```\n\nIf primary token's decimals (e.g. 6) == secondary token's decimals (e.g. 6)\n\n```solidity\nPrimary Balance = 50 USDC (6 Deci), Secondary Balance = 50 USDT (6 Deci)\n\nsecondaryBalance = secondaryBalance * primaryPrecision / secondaryPrecision\nsecondaryBalance = 50 USDT * 10^6 / 10^6\nsecondaryBalance = (50 * 10^6) * 10^6 / 10^6 = (50 * 10^6)\n\nsecondaryAmountInPrimary = secondaryBalance * strategyContext.poolClaimPrecision / oraclePrice;\nsecondaryAmountInPrimary = (50 * 10^6) * 10^18 / (1 * 10^18)\nsecondaryAmountInPrimary = (50 * 10^6) * 10^18 / (1 * 10^18)\nsecondaryAmountInPrimary = 50 * 10^6\n\nprimaryAmount = primaryBalance + secondaryAmountInPrimary\nprimaryAmount = (50 * 10^6) + (50 * 10^6) = (100 * 10^6) = 100 USDC\n```\n\n`strategyContext.poolClaimPrecision` set to `CurveConstants.CURVE_PRECISION`, which is `1e18`. `oraclePrice` is always in `1e18` precision.\n\n## Discussion\n\n**jeffywu**\n\nValid, since this is shared code it is better to always scale decimals up to 18 rather than assume that they are. Even if this results in duplicate work for the Balancer strategies.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/52",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/common/internal/pool/TwoTokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {\n    TwoTokenPoolContext, \n    StrategyContext, \n    DepositTradeParams, \n    TradeParams,\n    SingleSidedRewardTradeParams,\n    Proportional2TokenRewardTradeParams,\n    RedeemParams\n} from \"../../VaultTypes.sol\";\nimport {VaultConstants} from \"../../VaultConstants.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {RewardUtils} from \"../reward/RewardUtils.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {IERC20} from \"../../../../../interfaces/IERC20.sol\";\n\nlibrary TwoTokenPoolUtils {\n    using StrategyUtils for StrategyContext;\n\n    /// @notice Gets the oracle price pair price between two tokens using a weighted\n    /// average between a chainlink oracle and the balancer TWAP oracle.\n    /// @param poolContext oracle context variables\n    /// @param strategyContext strategy context variables\n    /// @return oraclePairPrice oracle price for the pair in 18 decimals\n    function _getOraclePairPrice(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext\n    ) internal view returns (uint256 oraclePairPrice) {\n        (int256 rate, int256 decimals) = strategyContext.tradingModule.getOraclePrice(\n            poolContext.primaryToken, poolContext.secondaryToken\n        );\n        require(rate > 0);\n        require(decimals >= 0);\n\n        if (uint256(decimals) != strategyContext.poolClaimPrecision) {\n            rate = (rate * int256(strategyContext.poolClaimPrecision)) / decimals;\n        }\n\n        // No overflow in rate conversion, checked above\n        oraclePairPrice = uint256(rate);\n    }\n\n    /// @notice calculates the expected primary and secondary amounts based on\n    /// the given spot price and oracle price\n    function _getMinExitAmounts(\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 spotPrice,\n        uint256 oraclePrice,\n        uint256 poolClaim\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalPoolSupply = poolContext.poolToken.totalSupply();\n        minPrimary = (poolContext.primaryBalance * poolClaim * \n            strategyContext.vaultSettings.poolSlippageLimitPercent) / \n            (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * poolClaim * \n            strategyContext.vaultSettings.poolSlippageLimitPercent) / \n            (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _getTimeWeightedPrimaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        uint256 poolClaim,\n        uint256 oraclePrice,\n        uint256 spotPrice\n    ) internal view returns (uint256 primaryAmount) {\n        // Make sure spot price is within oracleDeviationLimit of pairPrice\n        strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n        \n        // Get shares of primary and secondary balances with the provided poolClaim\n        uint256 totalSupply = poolContext.poolToken.totalSupply();\n        uint256 primaryBalance = poolContext.primaryBalance * poolClaim / totalSupply;\n        uint256 secondaryBalance = poolContext.secondaryBalance * poolClaim / totalSupply;\n\n        // Value the secondary balance in terms of the primary token using the oraclePairPrice\n        uint256 secondaryAmountInPrimary = secondaryBalance * strategyContext.poolClaimPrecision / oraclePrice;\n\n        // Make sure primaryAmount is reported in primaryPrecision\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        primaryAmount = (primaryBalance + secondaryAmountInPrimary) * primaryPrecision / strategyContext.poolClaimPrecision;\n    }\n\n    /// @notice Trade primary currency for secondary if the trade is specified\n    function _tradePrimaryForSecondary(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        bytes memory data\n    ) internal returns (uint256 primarySold, uint256 secondaryBought) {\n        (DepositTradeParams memory params) = abi.decode(data, (DepositTradeParams));\n\n        (primarySold, secondaryBought) = StrategyUtils._executeTradeExactIn({\n            params: params.tradeParams, \n            tradingModule: strategyContext.tradingModule, \n            sellToken: poolContext.primaryToken, \n            buyToken: poolContext.secondaryToken, \n            amount: params.tradeAmount,\n            useDynamicSlippage: true\n        });\n    }\n\n    function _sellSecondaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        RedeemParams memory params,\n        uint256 secondaryBalance\n    ) internal returns (uint256 primaryPurchased) {\n        (TradeParams memory tradeParams) = abi.decode(\n            params.secondaryTradeParams, (TradeParams)\n        );\n\n        ( /*uint256 amountSold */, primaryPurchased) = \n            StrategyUtils._executeTradeExactIn({\n                params: tradeParams,\n                tradingModule: strategyContext.tradingModule,\n                sellToken: poolContext.secondaryToken,\n                buyToken: poolContext.primaryToken,\n                amount: secondaryBalance,\n                useDynamicSlippage: true\n            });\n    }\n\n    function _validateTrades(\n        IERC20[] memory rewardTokens,\n        SingleSidedRewardTradeParams memory primaryTrade,\n        SingleSidedRewardTradeParams memory secondaryTrade,\n        address primaryToken,\n        address secondaryToken\n    ) private pure {\n        // Validate trades\n        if (!RewardUtils._isValidRewardToken(rewardTokens, primaryTrade.sellToken)) {\n            revert Errors.InvalidRewardToken(primaryTrade.sellToken);\n        }\n        if (secondaryTrade.sellToken != primaryTrade.sellToken) {\n            revert Errors.InvalidRewardToken(secondaryTrade.sellToken);\n        }\n        if (primaryTrade.buyToken != primaryToken) {\n            revert Errors.InvalidRewardToken(primaryTrade.buyToken);\n        }\n        if (secondaryTrade.buyToken != secondaryToken) {\n            revert Errors.InvalidRewardToken(secondaryTrade.buyToken);\n        }\n    }\n\n    function _executeRewardTrades(\n        TwoTokenPoolContext calldata poolContext,\n        IERC20[] memory rewardTokens,\n        ITradingModule tradingModule,\n        bytes calldata data\n    ) internal returns (address rewardToken, uint256 primaryAmount, uint256 secondaryAmount) {\n        Proportional2TokenRewardTradeParams memory params = abi.decode(\n            data,\n            (Proportional2TokenRewardTradeParams)\n        );\n\n        _validateTrades(\n            rewardTokens,\n            params.primaryTrade,\n            params.secondaryTrade,\n            poolContext.primaryToken,\n            poolContext.secondaryToken\n        );\n\n        (/*uint256 amountSold*/, primaryAmount) = StrategyUtils._executeTradeExactIn({\n            params: params.primaryTrade.tradeParams,\n            tradingModule: tradingModule,\n            sellToken: params.primaryTrade.sellToken,\n            buyToken: params.primaryTrade.buyToken,\n            amount: params.primaryTrade.amount,\n            useDynamicSlippage: false\n        });\n\n        (/*uint256 amountSold*/, secondaryAmount) = StrategyUtils._executeTradeExactIn({\n            params: params.secondaryTrade.tradeParams,\n            tradingModule: tradingModule,\n            sellToken: params.secondaryTrade.sellToken,\n            buyToken: params.secondaryTrade.buyToken,\n            amount: params.secondaryTrade.amount,\n            useDynamicSlippage: false\n        });\n\n        rewardToken = params.primaryTrade.sellToken;\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/common/internal/pool/TwoTokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {\n    TwoTokenPoolContext, \n    StrategyContext, \n    DepositTradeParams, \n    TradeParams,\n    SingleSidedRewardTradeParams,\n    Proportional2TokenRewardTradeParams,\n    RedeemParams\n} from \"../../VaultTypes.sol\";\nimport {VaultConstants} from \"../../VaultConstants.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {RewardUtils} from \"../reward/RewardUtils.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {ITradingModule} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {IERC20} from \"../../../../../interfaces/IERC20.sol\";\n\nlibrary TwoTokenPoolUtils {\n    using StrategyUtils for StrategyContext;\n\n    /// @notice Gets the oracle price pair price between two tokens using a weighted\n    /// average between a chainlink oracle and the balancer TWAP oracle.\n    /// @param poolContext oracle context variables\n    /// @param strategyContext strategy context variables\n    /// @return oraclePairPrice oracle price for the pair in 18 decimals\n    function _getOraclePairPrice(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext\n    ) internal view returns (uint256 oraclePairPrice) {\n        (int256 rate, int256 decimals) = strategyContext.tradingModule.getOraclePrice(\n            poolContext.primaryToken, poolContext.secondaryToken\n        );\n        require(rate > 0);\n        require(decimals >= 0);\n\n        if (uint256(decimals) != strategyContext.poolClaimPrecision) {\n            rate = (rate * int256(strategyContext.poolClaimPrecision)) / decimals;\n        }\n\n        // No overflow in rate conversion, checked above\n        oraclePairPrice = uint256(rate);\n    }\n\n    /// @notice calculates the expected primary and secondary amounts based on\n    /// the given spot price and oracle price\n    function _getMinExitAmounts(\n        TwoTokenPoolContext calldata poolContext,\n        StrategyContext calldata strategyContext,\n        uint256 spotPrice,\n        uint256 oraclePrice,\n        uint256 poolClaim\n    ) internal view returns (uint256 minPrimary, uint256 minSecondary) {\n        strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n\n        // min amounts are calculated based on the share of the Balancer pool with a small discount applied\n        uint256 totalPoolSupply = poolContext.poolToken.totalSupply();\n        minPrimary = (poolContext.primaryBalance * poolClaim * \n            strategyContext.vaultSettings.poolSlippageLimitPercent) / \n            (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS));\n        minSecondary = (poolContext.secondaryBalance * poolClaim * \n            strategyContext.vaultSettings.poolSlippageLimitPercent) / \n            (totalPoolSupply * uint256(VaultConstants.VAULT_PERCENT_BASIS));\n    }\n\n    function _getTimeWeightedPrimaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        uint256 poolClaim,\n        uint256 oraclePrice,\n        uint256 spotPrice\n    ) internal view returns (uint256 primaryAmount) {\n        // Make sure spot price is within oracleDeviationLimit of pairPrice\n        strategyContext._checkPriceLimit(oraclePrice, spotPrice);\n        \n        // Get shares of primary and secondary balances with the provided poolClaim\n        uint256 totalSupply = poolContext.poolToken.totalSupply();\n        uint256 primaryBalance = poolContext.primaryBalance * poolClaim / totalSupply;\n        uint256 secondaryBalance = poolContext.secondaryBalance * poolClaim / totalSupply;\n\n        // Value the secondary balance in terms of the primary token using the oraclePairPrice\n        uint256 secondaryAmountInPrimary = secondaryBalance * strategyContext.poolClaimPrecision / oraclePrice;\n\n        // Make sure primaryAmount is reported in primaryPrecision\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n        primaryAmount = (primaryBalance + secondaryAmountInPrimary) * primaryPrecision / strategyContext.poolClaimPrecision;\n    }\n\n    /// @notice Trade primary currency for secondary if the trade is specified\n    function _tradePrimaryForSecondary(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        bytes memory data\n    ) internal returns (uint256 primarySold, uint256 secondaryBought) {\n        (DepositTradeParams memory params) = abi.decode(data, (DepositTradeParams));\n\n        (primarySold, secondaryBought) = StrategyUtils._executeTradeExactIn({\n            params: params.tradeParams, \n            tradingModule: strategyContext.tradingModule, \n            sellToken: poolContext.primaryToken, \n            buyToken: poolContext.secondaryToken, \n            amount: params.tradeAmount,\n            useDynamicSlippage: true\n        });\n    }\n\n    function _sellSecondaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        RedeemParams memory params,\n        uint256 secondaryBalance\n    ) internal returns (uint256 primaryPurchased) {\n        (TradeParams memory tradeParams) = abi.decode(\n            params.secondaryTradeParams, (TradeParams)\n        );\n\n        ( /*uint256 amountSold */, primaryPurchased) = \n            StrategyUtils._executeTradeExactIn({\n                params: tradeParams,\n                tradingModule: strategyContext.tradingModule,\n                sellToken: poolContext.secondaryToken,\n                buyToken: poolContext.primaryToken,\n                amount: secondaryBalance,\n                useDynamicSlippage: true\n            });\n    }\n\n    function _validateTrades(\n        IERC20[] memory rewardTokens,\n        SingleSidedRewardTradeParams memory primaryTrade,\n        SingleSidedRewardTradeParams memory secondaryTrade,\n        address primaryToken,\n        address secondaryToken\n    ) private pure {\n        // Validate trades\n        if (!RewardUtils._isValidRewardToken(rewardTokens, primaryTrade.sellToken)) {\n            revert Errors.InvalidRewardToken(primaryTrade.sellToken);\n        }\n        if (secondaryTrade.sellToken != primaryTrade.sellToken) {\n            revert Errors.InvalidRewardToken(secondaryTrade.sellToken);\n        }\n        if (primaryTrade.buyToken != primaryToken) {\n            revert Errors.InvalidRewardToken(primaryTrade.buyToken);\n        }\n        if (secondaryTrade.buyToken != secondaryToken) {\n            revert Errors.InvalidRewardToken(secondaryTrade.buyToken);\n        }\n    }\n\n    function _executeRewardTrades(\n        TwoTokenPoolContext calldata poolContext,\n        IERC20[] memory rewardTokens,\n        ITradingModule tradingModule,\n        bytes calldata data\n    ) internal returns (address rewardToken, uint256 primaryAmount, uint256 secondaryAmount) {\n        Proportional2TokenRewardTradeParams memory params = abi.decode(\n            data,\n            (Proportional2TokenRewardTradeParams)\n        );\n\n        _validateTrades(\n            rewardTokens,\n            params.primaryTrade,\n            params.secondaryTrade,\n            poolContext.primaryToken,\n            poolContext.secondaryToken\n        );\n\n        (/*uint256 amountSold*/, primaryAmount) = StrategyUtils._executeTradeExactIn({\n            params: params.primaryTrade.tradeParams,\n            tradingModule: tradingModule,\n            sellToken: params.primaryTrade.sellToken,\n            buyToken: params.primaryTrade.buyToken,\n            amount: params.primaryTrade.amount,\n            useDynamicSlippage: false\n        });\n\n        (/*uint256 amountSold*/, secondaryAmount) = StrategyUtils._executeTradeExactIn({\n            params: params.secondaryTrade.tradeParams,\n            tradingModule: tradingModule,\n            sellToken: params.secondaryTrade.sellToken,\n            buyToken: params.secondaryTrade.buyToken,\n            amount: params.secondaryTrade.amount,\n            useDynamicSlippage: false\n        });\n\n        rewardToken = params.primaryTrade.sellToken;\n    }\n}"
    }
  ]
}