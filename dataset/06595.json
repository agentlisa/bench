{
  "Title": "[M-16] Sometimes calculateBorrowerReward and calculateSupplierReward return incorrect results",
  "Content": "\nSometimes `calculateBorrowerReward` and `calculateSupplierReward` return incorrect results.\n\n### Proof of Concept\n\nWhenever a user wants to know pending rewards they call `getPendingRewards`; sometimes, it returns incorrect results.\n\nThere is a bug inside `calculateBorrowerReward` and `calculateSupplierReward`\n\n```solidity\n    function calculateBorrowerReward(\n        address vToken,\n        RewardsDistributor rewardsDistributor,\n        address borrower,\n        RewardTokenState memory borrowState,\n        Exp memory marketBorrowIndex\n    ) internal view returns (uint256) {\n        Double memory borrowIndex = Double({ mantissa: borrowState.index });\n        Double memory borrowerIndex = Double({\n            mantissa: rewardsDistributor.rewardTokenBorrowerIndex(vToken, borrower)\n        });\n//      @audit\n//        if (borrowerIndex.mantissa == 0 && borrowIndex.mantissa >= rewardsDistributor.rewardTokenInitialIndex()) {\n        if (borrowerIndex.mantissa == 0 && borrowIndex.mantissa > 0) {\n            // Covers the case where users borrowed tokens before the market's borrow state index was set\n            borrowerIndex.mantissa = rewardsDistributor.rewardTokenInitialIndex();\n        }\n        Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n        uint256 borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\n        uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);\n        return borrowerDelta;\n    }\n\n```\n\n[contracts/Lens/PoolLens.sol#L495](https://github.com/code-423n4/2023-05-venus/blob/9853f6f4fe906b635e214b22de9f627c6a17ba5b/contracts/Lens/PoolLens.sol#L495)\n\n```solidity\n    function calculateSupplierReward(\n        address vToken,\n        RewardsDistributor rewardsDistributor,\n        address supplier,\n        RewardTokenState memory supplyState\n    ) internal view returns (uint256) {\n        Double memory supplyIndex = Double({ mantissa: supplyState.index });\n        Double memory supplierIndex = Double({\n            mantissa: rewardsDistributor.rewardTokenSupplierIndex(vToken, supplier)\n        });\n//      @audit\n//        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa  >= rewardsDistributor.rewardTokenInitialIndex()) {\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n            // Covers the case where users supplied tokens before the market's supply state index was set\n            supplierIndex.mantissa = rewardsDistributor.rewardTokenInitialIndex();\n        }\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n        uint256 supplierTokens = VToken(vToken).balanceOf(supplier);\n        uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\n        return supplierDelta;\n    }\n\n```\n\n[contracts/Lens/PoolLens.sol#L516](https://github.com/code-423n4/2023-05-venus/blob/9853f6f4fe906b635e214b22de9f627c6a17ba5b/contracts/Lens/PoolLens.sol#L516)\n\nInside `rewardsDistributor` original functions are written like this:\n\n```solidity\n    function _distributeSupplierRewardToken(address vToken, address supplier) internal {\n...\n        if (supplierIndex == 0 && supplyIndex >= rewardTokenInitialIndex) {\n            // Covers the case where users supplied tokens before the market's supply state index was set.\n            // Rewards the user with REWARD TOKEN accrued from the start of when supplier rewards were first\n            // set for the market.\n            supplierIndex = rewardTokenInitialIndex;\n        }\n...\n    }\n```\n\n[contracts/Rewards/RewardsDistributor.sol#L340](https://github.com/code-423n4/2023-05-venus/blob/9853f6f4fe906b635e214b22de9f627c6a17ba5b/contracts/Rewards/RewardsDistributor.sol#L340)\n\n```solidity\n    function _distributeBorrowerRewardToken(\n        address vToken,\n        address borrower,\n        Exp memory marketBorrowIndex\n    ) internal {\n...\n        if (borrowerIndex == 0 && borrowIndex >= rewardTokenInitialIndex) {\n            // Covers the case where users borrowed tokens before the market's borrow state index was set.\n            // Rewards the user with REWARD TOKEN accrued from the start of when borrower rewards were first\n            // set for the market.\n            borrowerIndex = rewardTokenInitialIndex;\n        }\n...\n}\n```\n\n[Rewards/RewardsDistributor.sol#L374](https://github.com/code-423n4/2023-05-venus/blob/9853f6f4fe906b635e214b22de9f627c6a17ba5b/contracts/Rewards/RewardsDistributor.sol#L374)\n\n### Recommended Mitigation Steps\n\n```diff\n    function calculateSupplierReward(\n        address vToken,\n        RewardsDistributor rewardsDistributor,\n        address supplier,\n        RewardTokenState memory supplyState\n    ) internal view returns (uint256) {\n        Double memory supplyIndex = Double({ mantissa: supplyState.index });\n        Double memory supplierIndex = Double({\n            mantissa: rewardsDistributor.rewardTokenSupplierIndex(vToken, supplier)\n        });\n-        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n+        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa  >= rewardsDistributor.rewardTokenInitialIndex()) {\n            // Covers the case where users supplied tokens before the market's supply state index was set\n            supplierIndex.mantissa = rewardsDistributor.rewardTokenInitialIndex();\n        }\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n        uint256 supplierTokens = VToken(vToken).balanceOf(supplier);\n        uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\n        return supplierDelta;\n    }\n```\n\n```diff\n    function calculateBorrowerReward(\n        address vToken,\n        RewardsDistributor rewardsDistributor,\n        address borrower,\n        RewardTokenState memory borrowState,\n        Exp memory marketBorrowIndex\n    ) internal view returns (uint256) {\n        Double memory borrowIndex = Double({ mantissa: borrowState.index });\n        Double memory borrowerIndex = Double({\n            mantissa: rewardsDistributor.rewardTokenBorrowerIndex(vToken, borrower)\n        });\n-        if (borrowerIndex.mantissa == 0 && borrowIndex.mantissa > 0) {\n+        if (borrowerIndex.mantissa == 0 && borrowIndex.mantissa >= rewardsDistributor.rewardTokenInitialIndex()) {\n            // Covers the case where users borrowed tokens before the market's borrow state index was set\n            borrowerIndex.mantissa = rewardsDistributor.rewardTokenInitialIndex();\n        }\n        Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n        uint256 borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\n        uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);\n        return borrowerDelta;\n    }\n```\n\n### Assessed type\n\nInvalid Validation\n\n**[chechu (Venus) confirmed](https://github.com/code-423n4/2023-05-venus-findings/issues/9#issuecomment-1560066298)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-venus",
  "Code": [
    {
      "filename": "contracts/Lens/PoolLens.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@venusprotocol/oracle/contracts/PriceOracle.sol\";\n\nimport \"../VToken.sol\";\nimport \"../ComptrollerInterface.sol\";\nimport \"../Pool/PoolRegistryInterface.sol\";\nimport \"../Pool/PoolRegistry.sol\";\n\ncontract PoolLens is ExponentialNoError {\n    /**\n     * @dev Struct for PoolDetails.\n     */\n    struct PoolData {\n        string name;\n        address creator;\n        address comptroller;\n        uint256 blockPosted;\n        uint256 timestampPosted;\n        string category;\n        string logoURL;\n        string description;\n        address priceOracle;\n        uint256 closeFactor;\n        uint256 liquidationIncentive;\n        uint256 minLiquidatableCollateral;\n        VTokenMetadata[] vTokens;\n    }\n\n    /**\n     * @dev Struct for VToken.\n     */\n    struct VTokenMetadata {\n        address vToken;\n        uint256 exchangeRateCurrent;\n        uint256 supplyRatePerBlock;\n        uint256 borrowRatePerBlock;\n        uint256 reserveFactorMantissa;\n        uint256 supplyCaps;\n        uint256 borrowCaps;\n        uint256 totalBorrows;\n        uint256 totalReserves;\n        uint256 totalSupply;\n        uint256 totalCash;\n        bool isListed;\n        uint256 collateralFactorMantissa;\n        address underlyingAssetAddress;\n        uint256 vTokenDecimals;\n        uint256 underlyingDecimals;\n    }\n\n    /**\n     * @dev Struct for VTokenBalance.\n     */\n    struct VTokenBalances {\n        address vToken;\n        uint256 balanceOf;\n        uint256 borrowBalanceCurrent;\n        uint256 balanceOfUnderlying;\n        uint256 tokenBalance;\n        uint256 tokenAllowance;\n    }\n\n    /**\n     * @dev Struct for underlyingPrice of VToken.\n     */\n    struct VTokenUnderlyingPrice {\n        address vToken;\n        uint256 underlyingPrice;\n    }\n\n    /**\n     * @dev Struct with pending reward info for a market.\n     */\n    struct PendingReward {\n        address vTokenAddress;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Struct with reward distribution totals for a single reward token and distributor.\n     */\n    struct RewardSummary {\n        address distributorAddress;\n        address rewardTokenAddress;\n        uint256 totalRewards;\n        PendingReward[] pendingRewards;\n    }\n\n    /**\n     * @dev Struct used in RewardDistributor to save last updated market state.\n     */\n    struct RewardTokenState {\n        // The market's last updated rewardTokenBorrowIndex or rewardTokenSupplyIndex\n        uint224 index;\n        // The block number the index was last updated at\n        uint32 block;\n    }\n\n    /**\n     * @dev Struct with bad debt of a market denominated\n     */\n    struct BadDebt {\n        address vTokenAddress;\n        uint256 badDebtUsd;\n    }\n\n    /**\n     * @dev Struct with bad debt total denominated in usd for a pool and an array of BadDebt structs for each market\n     */\n    struct BadDebtSummary {\n        address comptroller;\n        uint256 totalBadDebtUsd;\n        BadDebt[] badDebts;\n    }\n\n    /**\n     * @param vTokens The list of vToken Addresses.\n     * @param account The user Account.\n     * @notice Returns the BalanceInfo of all VTokens.\n     */\n    function vTokenBalancesAll(VToken[] calldata vTokens, address account) external returns (VTokenBalances[] memory) {\n        uint256 vTokenCount = vTokens.length;\n        VTokenBalances[] memory res = new VTokenBalances[](vTokenCount);\n        for (uint256 i; i < vTokenCount; ++i) {\n            res[i] = vTokenBalances(vTokens[i], account);\n        }\n        return res;\n    }\n\n    /**\n     * @param poolRegistryAddress The address of Pool.\n     * @notice Returns arrays of all Venus pools' data.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     */\n    function getAllPools(address poolRegistryAddress) external view returns (PoolData[] memory) {\n        PoolRegistryInterface poolRegistryInterface = PoolRegistryInterface(poolRegistryAddress);\n        PoolRegistry.VenusPool[] memory venusPools = poolRegistryInterface.getAllPools();\n        uint256 poolLength = venusPools.length;\n\n        PoolData[] memory poolDataItems = new PoolData[](poolLength);\n\n        for (uint256 i; i < poolLength; ++i) {\n            PoolRegistry.VenusPool memory venusPool = venusPools[i];\n            PoolData memory poolData = getPoolDataFromVenusPool(poolRegistryAddress, venusPool);\n            poolDataItems[i] = poolData;\n        }\n\n        return poolDataItems;\n    }\n\n    /**\n     * @param poolRegistryAddress The address of Pool.\n     * @param comptroller The Comptroller implementation address.\n     * @notice Returns Venus pool Unitroller (Comptroller proxy) contract addresses.\n     */\n    function getPoolByComptroller(address poolRegistryAddress, address comptroller)\n        external\n        view\n        returns (PoolData memory)\n    {\n        PoolRegistryInterface poolRegistryInterface = PoolRegistryInterface(poolRegistryAddress);\n        return getPoolDataFromVenusPool(poolRegistryAddress, poolRegistryInterface.getPoolByComptroller(comptroller));\n    }\n\n    /**\n     * @param poolRegistryAddress The address of Pool.\n     * @param comptroller The pool comptroller.\n     * @param asset The underlyingAsset of VToken.\n     * @notice Returns VToken in a Pool for an Asset.\n     */\n    function getVTokenForAsset(\n        address poolRegistryAddress,\n        address comptroller,\n        address asset\n    ) external view returns (address) {\n        PoolRegistryInterface poolRegistryInterface = PoolRegistryInterface(poolRegistryAddress);\n        return poolRegistryInterface.getVTokenForAsset(comptroller, asset);\n    }\n\n    /**\n     * @param poolRegistryAddress The address of Pool.\n     * @param asset The underlyingAsset of VToken.\n     * @notice Returns all Pools supported by an Asset.\n     */\n    function getPoolsSupportedByAsset(address poolRegistryAddress, address asset)\n        external\n        view\n        returns (address[] memory)\n    {\n        PoolRegistryInterface poolRegistryInterface = PoolRegistryInterface(poolRegistryAddress);\n        return poolRegistryInterface.getPoolsSupportedByAsset(asset);\n    }\n\n    /**\n     * @param vTokens The list of vToken Addresses.\n     * @notice Returns the underlyingPrice Info of all VTokens.\n     */\n    function vTokenUnderlyingPriceAll(VToken[] calldata vTokens)\n        external\n        view\n        returns (VTokenUnderlyingPrice[] memory)\n    {\n        uint256 vTokenCount = vTokens.length;\n        VTokenUnderlyingPrice[] memory res = new VTokenUnderlyingPrice[](vTokenCount);\n        for (uint256 i; i < vTokenCount; ++i) {\n            res[i] = vTokenUnderlyingPrice(vTokens[i]);\n        }\n        return res;\n    }\n\n    /**\n     * @notice Returns the pending rewards for a user for a given pool.\n     * @param account The user account.\n     * @param comptrollerAddress address\n     * @return Pending rewards array\n     */\n    function getPendingRewards(address account, address comptrollerAddress)\n        external\n        view\n        returns (RewardSummary[] memory)\n    {\n        VToken[] memory markets = ComptrollerInterface(comptrollerAddress).getAllMarkets();\n        RewardsDistributor[] memory rewardsDistributors = ComptrollerViewInterface(comptrollerAddress)\n        .getRewardDistributors();\n        RewardSummary[] memory rewardSummary = new RewardSummary[](rewardsDistributors.length);\n        for (uint256 i; i < rewardsDistributors.length; ++i) {\n            RewardSummary memory reward;\n            reward.distributorAddress = address(rewardsDistributors[i]);\n            reward.rewardTokenAddress = address(rewardsDistributors[i].rewardToken());\n            reward.totalRewards = rewardsDistributors[i].rewardTokenAccrued(account);\n            reward.pendingRewards = _calculateNotDistributedAwards(account, markets, rewardsDistributors[i]);\n            rewardSummary[i] = reward;\n        }\n        return rewardSummary;\n    }\n\n    /**\n     * @notice Returns a summary of a pool's bad debt broken down by market\n     *\n     * @param comptrollerAddress Address of the comptroller\n     *\n     * @return badDebtSummary A struct with comptroller address, total bad debut denominated in usd, and\n     *   a break down of bad debt by market\n     */\n    function getPoolBadDebt(address comptrollerAddress) external view returns (BadDebtSummary memory) {\n        uint256 totalBadDebtUsd;\n\n        // Get every market in the pool\n        ComptrollerViewInterface comptroller = ComptrollerViewInterface(comptrollerAddress);\n        VToken[] memory markets = comptroller.getAllMarkets();\n        PriceOracle priceOracle = comptroller.oracle();\n\n        BadDebt[] memory badDebts = new BadDebt[](markets.length);\n\n        BadDebtSummary memory badDebtSummary;\n        badDebtSummary.comptroller = comptrollerAddress;\n        badDebtSummary.badDebts = badDebts;\n\n        // // Calculate the bad debt is USD per market\n        for (uint256 i; i < markets.length; ++i) {\n            BadDebt memory badDebt;\n            badDebt.vTokenAddress = address(markets[i]);\n            badDebt.badDebtUsd =\n                VToken(address(markets[i])).badDebt() *\n                priceOracle.getUnderlyingPrice(address(markets[i]));\n            badDebtSummary.badDebts[i] = badDebt;\n            totalBadDebtUsd = totalBadDebtUsd + badDebt.badDebtUsd;\n        }\n\n        badDebtSummary.totalBadDebtUsd = totalBadDebtUsd;\n\n        return badDebtSummary;\n    }\n\n    /**\n     * @param vToken The vTokenAddress.\n     * @param account The user Account.\n     * @notice Returns the BalanceInfo of VToken.\n     */\n    function vTokenBalances(VToken vToken, address account) public returns (VTokenBalances memory) {\n        uint256 balanceOf = vToken.balanceOf(account);\n        uint256 borrowBalanceCurrent = vToken.borrowBalanceCurrent(account);\n        uint256 balanceOfUnderlying = vToken.balanceOfUnderlying(account);\n        uint256 tokenBalance;\n        uint256 tokenAllowance;\n\n        IERC20 underlying = IERC20(vToken.underlying());\n        tokenBalance = underlying.balanceOf(account);\n        tokenAllowance = underlying.allowance(account, address(vToken));\n\n        return\n            VTokenBalances({\n                vToken: address(vToken),\n                balanceOf: balanceOf,\n                borrowBalanceCurrent: borrowBalanceCurrent,\n                balanceOfUnderlying: balanceOfUnderlying,\n                tokenBalance: tokenBalance,\n                tokenAllowance: tokenAllowance\n            });\n    }\n\n    /**\n     * @param venusPool The VenusPool Object from PoolRegistry.\n     * @notice Returns enriched PoolData.\n     */\n    function getPoolDataFromVenusPool(address poolRegistryAddress, PoolRegistry.VenusPool memory venusPool)\n        public\n        view\n        returns (PoolData memory)\n    {\n        //get tokens in the Pool\n        ComptrollerInterface comptrollerInstance = ComptrollerInterface(venusPool.comptroller);\n\n        VToken[] memory vTokens = comptrollerInstance.getAllMarkets();\n\n        VTokenMetadata[] memory vTokenMetadataItems = vTokenMetadataAll(vTokens);\n\n        PoolRegistryInterface poolRegistryInterface = PoolRegistryInterface(poolRegistryAddress);\n\n        PoolRegistry.VenusPoolMetaData memory venusPoolMetaData = poolRegistryInterface.getVenusPoolMetadata(\n            venusPool.comptroller\n        );\n\n        ComptrollerViewInterface comptrollerViewInstance = ComptrollerViewInterface(venusPool.comptroller);\n\n        PoolData memory poolData = PoolData({\n            name: venusPool.name,\n            creator: venusPool.creator,\n            comptroller: venusPool.comptroller,\n            blockPosted: venusPool.blockPosted,\n            timestampPosted: venusPool.timestampPosted,\n            category: venusPoolMetaData.category,\n            logoURL: venusPoolMetaData.logoURL,\n            description: venusPoolMetaData.description,\n            vTokens: vTokenMetadataItems,\n            priceOracle: address(comptrollerViewInstance.oracle()),\n            closeFactor: comptrollerViewInstance.closeFactorMantissa(),\n            liquidationIncentive: comptrollerViewInstance.liquidationIncentiveMantissa(),\n            minLiquidatableCollateral: comptrollerViewInstance.minLiquidatableCollateral()\n        });\n\n        return poolData;\n    }\n\n    /**\n     * @param vToken The address of vToken.\n     * @notice Returns the metadata of VToken.\n     */\n    function vTokenMetadata(VToken vToken) public view returns (VTokenMetadata memory) {\n        uint256 exchangeRateCurrent = vToken.exchangeRateStored();\n        address comptrollerAddress = address(vToken.comptroller());\n        ComptrollerViewInterface comptroller = ComptrollerViewInterface(comptrollerAddress);\n        (bool isListed, uint256 collateralFactorMantissa) = comptroller.markets(address(vToken));\n        address underlyingAssetAddress;\n        uint256 underlyingDecimals;\n\n        underlyingAssetAddress = vToken.underlying();\n        underlyingDecimals = IERC20Metadata(vToken.underlying()).decimals();\n\n        return\n            VTokenMetadata({\n                vToken: address(vToken),\n                exchangeRateCurrent: exchangeRateCurrent,\n                supplyRatePerBlock: vToken.supplyRatePerBlock(),\n                borrowRatePerBlock: vToken.borrowRatePerBlock(),\n                reserveFactorMantissa: vToken.reserveFactorMantissa(),\n                supplyCaps: comptroller.supplyCaps(address(vToken)),\n                borrowCaps: comptroller.borrowCaps(address(vToken)),\n                totalBorrows: vToken.totalBorrows(),\n                totalReserves: vToken.totalReserves(),\n                totalSupply: vToken.totalSupply(),\n                totalCash: vToken.getCash(),\n                isListed: isListed,\n                collateralFactorMantissa: collateralFactorMantissa,\n                underlyingAssetAddress: underlyingAssetAddress,\n                vTokenDecimals: vToken.decimals(),\n                underlyingDecimals: underlyingDecimals\n            });\n    }\n\n    /**\n     * @param vTokens The list of vToken Addresses.\n     * @notice Returns the metadata of all VTokens.\n     */\n    function vTokenMetadataAll(VToken[] memory vTokens) public view returns (VTokenMetadata[] memory) {\n        uint256 vTokenCount = vTokens.length;\n        VTokenMetadata[] memory res = new VTokenMetadata[](vTokenCount);\n        for (uint256 i; i < vTokenCount; ++i) {\n            res[i] = vTokenMetadata(vTokens[i]);\n        }\n        return res;\n    }\n\n    /**\n     * @param vToken The vToken Addresses.\n     * @notice Returns the underlyingPrice of VToken.\n     */\n    function vTokenUnderlyingPrice(VToken vToken) public view returns (VTokenUnderlyingPrice memory) {\n        ComptrollerViewInterface comptroller = ComptrollerViewInterface(address(vToken.comptroller()));\n        PriceOracle priceOracle = comptroller.oracle();\n\n        return\n            VTokenUnderlyingPrice({\n                vToken: address(vToken),\n                underlyingPrice: priceOracle.getUnderlyingPrice(address(vToken))\n            });\n    }\n\n    function _calculateNotDistributedAwards(\n        address account,\n        VToken[] memory markets,\n        RewardsDistributor rewardsDistributor\n    ) internal view returns (PendingReward[] memory) {\n        PendingReward[] memory pendingRewards = new PendingReward[](markets.length);\n        for (uint256 i; i < markets.length; ++i) {\n            // Market borrow and supply state we will modify update in-memory, in order to not modify storage\n            RewardTokenState memory borrowState;\n            (borrowState.index, borrowState.block) = rewardsDistributor.rewardTokenBorrowState(address(markets[i]));\n            RewardTokenState memory supplyState;\n            (supplyState.index, supplyState.block) = rewardsDistributor.rewardTokenSupplyState(address(markets[i]));\n            Exp memory marketBorrowIndex = Exp({ mantissa: markets[i].borrowIndex() });\n\n            //Update market supply and borrow index in-memory\n            updateMarketBorrowIndex(address(markets[i]), rewardsDistributor, borrowState, marketBorrowIndex);\n            updateMarketSupplyIndex(address(markets[i]), rewardsDistributor, supplyState);\n\n            //Calculate pending rewards\n            uint256 borrowReward = calculateBorrowerReward(\n                address(markets[i]),\n                rewardsDistributor,\n                account,\n                borrowState,\n                marketBorrowIndex\n            );\n            uint256 supplyReward = calculateSupplierReward(\n                address(markets[i]),\n                rewardsDistributor,\n                account,\n                supplyState\n            );\n\n            PendingReward memory pendingReward;\n            pendingReward.vTokenAddress = address(markets[i]);\n            pendingReward.amount = borrowReward + supplyReward;\n            pendingRewards[i] = pendingReward;\n        }\n        return pendingRewards;\n    }\n\n    function updateMarketBorrowIndex(\n        address vToken,\n        RewardsDistributor rewardsDistributor,\n        RewardTokenState memory borrowState,\n        Exp memory marketBorrowIndex\n    ) internal view {\n        uint256 borrowSpeed = rewardsDistributor.rewardTokenBorrowSpeeds(vToken);\n        uint256 blockNumber = block.number;\n        uint256 deltaBlocks = sub_(blockNumber, uint256(borrowState.block));\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\n            // Remove the total earned interest rate since the opening of the market from total borrows\n            uint256 borrowAmount = div_(VToken(vToken).totalBorrows(), marketBorrowIndex);\n            uint256 tokensAccrued = mul_(deltaBlocks, borrowSpeed);\n            Double memory ratio = borrowAmount > 0 ? fraction(tokensAccrued, borrowAmount) : Double({ mantissa: 0 });\n            Double memory index = add_(Double({ mantissa: borrowState.index }), ratio);\n            borrowState.index = safe224(index.mantissa, \"new index overflows\");\n            borrowState.block = safe32(blockNumber, \"block number overflows\");\n        } else if (deltaBlocks > 0) {\n            borrowState.block = safe32(blockNumber, \"block number overflows\");\n        }\n    }\n\n    function updateMarketSupplyIndex(\n        address vToken,\n        RewardsDistributor rewardsDistributor,\n        RewardTokenState memory supplyState\n    ) internal view {\n        uint256 supplySpeed = rewardsDistributor.rewardTokenSupplySpeeds(vToken);\n        uint256 blockNumber = block.number;\n        uint256 deltaBlocks = sub_(blockNumber, uint256(supplyState.block));\n        if (deltaBlocks > 0 && supplySpeed > 0) {\n            uint256 supplyTokens = VToken(vToken).totalSupply();\n            uint256 tokensAccrued = mul_(deltaBlocks, supplySpeed);\n            Double memory ratio = supplyTokens > 0 ? fraction(tokensAccrued, supplyTokens) : Double({ mantissa: 0 });\n            Double memory index = add_(Double({ mantissa: supplyState.index }), ratio);\n            supplyState.index = safe224(index.mantissa, \"new index overflows\");\n            supplyState.block = safe32(blockNumber, \"block number overflows\");\n        } else if (deltaBlocks > 0) {\n            supplyState.block = safe32(blockNumber, \"block number overflows\");\n        }\n    }\n\n    function calculateBorrowerReward(\n        address vToken,\n        RewardsDistributor rewardsDistributor,\n        address borrower,\n        RewardTokenState memory borrowState,\n        Exp memory marketBorrowIndex\n    ) internal view returns (uint256) {\n        Double memory borrowIndex = Double({ mantissa: borrowState.index });\n        Double memory borrowerIndex = Double({\n            mantissa: rewardsDistributor.rewardTokenBorrowerIndex(vToken, borrower)\n        });\n        if (borrowerIndex.mantissa == 0 && borrowIndex.mantissa > 0) {\n            // Covers the case where users borrowed tokens before the market's borrow state index was set\n            borrowerIndex.mantissa = rewardsDistributor.rewardTokenInitialIndex();\n        }\n        Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n        uint256 borrowerAmount = div_(VToken(vToken).borrowBalanceStored(borrower), marketBorrowIndex);\n        uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);\n        return borrowerDelta;\n    }\n\n    function calculateSupplierReward(\n        address vToken,\n        RewardsDistributor rewardsDistributor,\n        address supplier,\n        RewardTokenState memory supplyState\n    ) internal view returns (uint256) {\n        Double memory supplyIndex = Double({ mantissa: supplyState.index });\n        Double memory supplierIndex = Double({\n            mantissa: rewardsDistributor.rewardTokenSupplierIndex(vToken, supplier)\n        });\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n            // Covers the case where users supplied tokens before the market's supply state index was set\n            supplierIndex.mantissa = rewardsDistributor.rewardTokenInitialIndex();\n        }\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n        uint256 supplierTokens = VToken(vToken).balanceOf(supplier);\n        uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\n        return supplierDelta;\n    }\n}"
    },
    {
      "filename": "contracts/Lens/PoolLens.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@venusprotocol/oracle/contracts/PriceOracle.sol\";\n\nimport \"../VToken.sol\";\nimport \"../ComptrollerInterface.sol\";\nimport \"../Pool/PoolRegistryInterface.sol\";\nimport \"../Pool/PoolRegistry.sol\";\n\ncontract PoolLens is ExponentialNoError {\n    /**\n     * @dev Struct for PoolDetails.\n     */\n    struct PoolData {\n        string name;\n        address creator;\n        address comptroller;\n        uint256 blockPosted;\n        uint256 timestampPosted;\n        string category;\n        string logoURL;\n        string description;\n        address priceOracle;\n        uint256 closeFactor;\n        uint256 liquidationIncentive;\n        uint256 minLiquidatableCollateral;\n        VTokenMetadata[] vTokens;\n    }\n\n    /**\n     * @dev Struct for VToken.\n     */\n    struct VTokenMetadata {\n        address vToken;\n        uint256 exchangeRateCurrent;\n        uint256 supplyRatePerBlock;\n        uint256 borrowRatePerBlock;\n        uint256 reserveFactorMantissa;\n        uint256 supplyCaps;\n        uint256 borrowCaps;\n        uint256 totalBorrows;\n        uint256 totalReserves;\n        uint256 totalSupply;\n        uint256 totalCash;\n        bool isListed;\n        uint256 collateralFactorMantissa;\n        address underlyingAssetAddress;\n        uint256 vTokenDecimals;\n        uint256 underlyingDecimals;\n    }\n\n    /**\n     * @dev Struct for VTokenBalance.\n     */\n    struct VTokenBalances {\n        address vToken;\n        uint256 balanceOf;\n        uint256 borrowBalanceCurrent;\n        uint256 balanceOfUnderlying;\n        uint256 tokenBalance;\n        uint256 tokenAllowance;\n    }\n\n    /**\n     * @dev Struct for underlyingPrice of VToken.\n     */\n    struct VTokenUnderlyingPrice {\n        address vToken;\n        uint256 underlyingPrice;\n    }\n\n    /**\n     * @dev Struct with pending reward info for a market.\n     */\n    struct PendingReward {\n        address vTokenAddress;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Struct with reward distribution totals for a single reward token and distributor.\n     */\n    struct RewardSummary {\n        address distributorAddress;\n        address rewardTokenAddress;\n        uint256 totalRewards;\n        PendingReward[] pendingRewards;\n    }\n\n    /**\n     * @dev Struct used in RewardDistributor to save last updated market state.\n     */\n    struct RewardTokenState {\n        // The market's last updated rewardTokenBorrowIndex or rewardTokenSupplyIndex\n        uint224 index;\n        // The block number the index was last updated at\n        uint32 block;\n    }\n\n    /**\n     * @dev Struct with bad debt of a market denominated\n     */\n    struct BadDebt {\n        address vTokenAddress;\n        uint256 badDebtUsd;\n    }\n\n    /**\n     * @dev Struct with bad debt total denominated in usd for a pool and an array of BadDebt structs for each market\n     */\n    struct BadDebtSummary {\n        address comptroller;\n        uint256 totalBadDebtUsd;\n        BadDebt[] badDebts;\n    }\n\n    /**\n     * @param vTokens The list of vToken Addresses.\n     * @param account The user Account.\n     * @notice Returns the BalanceInfo of all VTokens.\n     */\n    function vTokenBalancesAll(VToken[] calldata vTokens, address account) external returns (VTokenBalances[] memory) {\n        uint256 vTokenCount = vTokens.length;\n        VTokenBalances[] memory res = new VTokenBalances[](vTokenCount);\n        for (uint256 i; i < vTokenCount; ++i) {\n            res[i] = vTokenBalances(vTokens[i], account);\n        }\n        return res;\n    }\n\n    /**\n     * @param poolRegistryAddress The address of Pool.\n     * @notice Returns arrays of all Venus pools' data.\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n     */\n    function getAllPools(address poolRegistryAddress) external view returns (PoolData[] memory) {\n        PoolRegistryInterface poolRegistryInterface = PoolRegistryInterface(poolRegistryAddress);\n        PoolRegistry.VenusPool[] memory venusPools = poolRegistryInterface.getAllPools();\n        uint256 poolLength = venusPools.length;\n\n        PoolData[] memory poolDataItems = new PoolData[](poolLength);\n\n        for (uint256 i; i < poolLength; ++i) {\n            PoolRegistry.VenusPool memory venusPool = venusPools[i];\n            PoolData memory poolData = getPoolDataFromVenusPool(poolRegistryAddress, venusPool);\n            poolDataItems[i] = poolData;\n        }\n\n        return poolDataItems;\n    }\n\n    /**\n     * @param poolRegistryAddress The address of Pool.\n     * @param comptroller The Comptroller implementation address.\n     * @notice Returns Venus pool Unitroller (Comptroller proxy) contract addresses.\n     */\n    function getPoolByComptroller(address poolRegistryAddress, address comptroller)\n        external\n        view\n        returns (PoolData memory)\n    {\n        PoolRegistryInterface poolRegistryInterface = PoolRegistryInterface(poolRegistryAddress);\n        return getPoolDataFromVenusPool(poolRegistryAddress, poolRegistryInterface.getPoolByComptroller(comptroller));\n    }\n\n    /**\n     * @param poolRegistryAddress The address of Pool.\n     * @param comptroller The pool comptroller.\n     * @param asset The underlyingAsset of VToken.\n     * @notice Returns VToken in a Pool for an Asset.\n     */\n    function getVTokenForAsset(\n        address poolRegistryAddress,\n        address comptroller,\n        address asset\n    ) external view returns (address) {\n        PoolRegistryInterface poolRegistryInterface = PoolRegistryInterface(poolRegistryAddress);\n        return poolRegistryInterface.getVTokenForAsset(comptroller, asset);\n    }\n\n    /**\n     * @param poolRegistryAddress The address of Pool.\n     * @param asset The underlyingAsset of VToken.\n     * @notice Returns all Pools supported by an Asset.\n     */\n    function getPoolsSupportedByAsset(address poolRegistryAddress, address asset)\n        external\n        view\n        returns (address[] memory)\n    {\n        PoolRegistryInterface poolRegistryInterface = PoolRegistryInterface(poolRegistryAddress);\n        return poolRegistryInterface.getPoolsSupportedByAsset(asset);\n    }\n\n    /**\n     * @param vTokens The list of vToken Addresses.\n     * @notice Returns the underlyingPrice Info of all VTokens.\n     */\n    function vTokenUnderlyingPriceAll(VToken[] calldata vTokens)\n        external\n        view\n        returns (VTokenUnderlyingPrice[] memory)\n    {\n        uint256 vTokenCount = vTokens.length;\n        VTokenUnderlyingPrice[] memory res = new VTokenUnderlyingPrice[](vTokenCount);\n        for (uint256 i; i < vTokenCount; ++i) {\n            res[i] = vTokenUnderlyingPrice(vTokens[i]);\n        }\n        return res;\n    }\n\n    /**\n     * @notice Returns the pending rewards for a user for a given pool.\n     * @param account The user account.\n     * @param comptrollerAddress address\n     * @return Pending rewards array\n     */\n    function getPendingRewards(address account, address comptrollerAddress)\n        external\n        view\n        returns (RewardSummary[] memory)\n    {\n        VToken[] memory markets = ComptrollerInterface(comptrollerAddress).getAllMarkets();\n        RewardsDistributor[] memory rewardsDistributors = ComptrollerViewInterface(comptrollerAddress)\n        .getRewardDistributors();\n        RewardSummary[] memory rewardSummary = new RewardSummary[](rewardsDistributors.length);\n        for (uint256 i; i < rewardsDistributors.length; ++i) {\n            RewardSummary memory reward;\n            reward.distributorAddress = address(rewardsDistributors[i]);\n            reward.rewardTokenAddress = address(rewardsDistributors[i].rewardToken());\n            reward.totalRewards = rewardsDistributors[i].rewardTokenAccrued(account);\n            reward.pendingRewards = _calculateNotDistributedAwards(account, markets, rewardsDistributors[i]);\n            rewardSummary[i] = reward;\n        }\n        return rewardSummary;\n    }\n\n    /**\n     * @notice Returns a summary of a pool's bad debt broken down by market\n     *\n     * @param comptrollerAddress Address of the comptroller\n     *\n     * @return badDebtSummary A struct with comptroller address, total bad debut denominated in usd, and\n     *   a break down of bad debt by market\n     */\n    function getPoolBadDebt(address comptrollerAddress) external view returns (BadDebtSummary memory) {\n        uint256 totalBadDebtUsd;\n\n        // Get every market in the pool\n        ComptrollerViewInterface comptroller = ComptrollerViewInterface(comptrollerAddress);\n        VToken[] memory markets = comptroller.getAllMarkets();\n        PriceOracle priceOracle = comptroller.oracle();\n\n        BadDebt[] memory badDebts = new BadDebt[](markets.length);\n\n        BadDebtSummary memory badDebtSummary;\n        badDebtSummary.comptroller = comptrollerAddress;\n        badDebtSummary.badDebts = badDebts;\n\n        // // Calculate the bad debt is USD per market\n        for (uint256 i; i < markets.length; ++i) {\n            BadDebt memory badDebt;\n            badDebt.vTokenAddress = address(markets[i]);\n            badDebt.badDebtUsd =\n                VToken(address(markets[i])).badDebt() *\n                priceOracle.getUnderlyingPrice(address(markets[i]));\n            badDebtSummary.badDebts[i] = badDebt;\n            totalBadDebtUsd = totalBadDebtUsd + badDebt.badDebtUsd;\n        }\n\n        badDebtSummary.totalBadDebtUsd = totalBadDebtUsd;\n\n        return badDebtSummary;\n    }\n\n    /**\n     * @param vToken The vTokenAddress.\n     * @param account The user Account.\n     * @notice Returns the BalanceInfo of VToken.\n     */\n    function vTokenBalances(VToken vToken, address account) public returns (VTokenBalances memory) {\n        uint256 balanceOf = vToken.balanceOf(account);\n        uint256 borrowBalanceCurrent = vToken.borrowBalanceCurrent(account);\n        uint256 balanceOfUnderlying = vToken.balanceOfUnderlying(account);\n        uint256 tokenBalance;\n        uint256 tokenAllowance;\n\n        IERC20 underlying = IERC20(vToken.underlying());\n        tokenBalance = underlying.balanceOf(account);\n        tokenAllowance = underlying.allowance(account, address(vToken));\n\n        return\n            VTokenBalances({\n                vToken: address(vToken),\n                balanceOf: balanceOf,\n                borrowBalanceCurrent: borrowBalanceCurrent,\n                balanceOfUnderlying: balanceOfUnderlying,\n                tokenBalance: tokenBalance,\n                tokenAllowance: tokenAllowance\n            });\n    }\n\n    /**\n     * @param venusPool The VenusPool Object from PoolRegistry.\n     * @notice Returns enriched PoolData.\n     */\n    function getPoolDataFromVenusPool(address poolRegistryAddress, PoolRegistry.VenusPool memory venusPool)\n        public\n        view\n        returns (PoolData memory)\n    {\n        //get tokens in the Pool\n        ComptrollerInterface comptrollerInstance = ComptrollerInterface(venusPool.comptroller);\n\n        VToken[] memory vTokens = comptrollerInstance.getAllMarkets();\n\n        VTokenMetadata[] memory vTokenMetadataItems = vTokenMetadataAll(vTokens);\n\n        PoolRegistryInterface poolRegistryInterface = PoolRegistryInterface(poolRegistryAddress);\n\n        PoolRegistry.VenusPoolMetaData memory venusPoolMetaData = poolRegistryInterface.getVenusPoolMetadata(\n            venusPool.comptroller\n        );"
    }
  ]
}