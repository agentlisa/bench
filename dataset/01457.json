{
  "Title": "Unnecessary Access Allowance to the Comptroller Implementation",
  "Content": "The security check `ensureAdminOr(comptrollerImplementation)` in [`_setVenusSpeeds`](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/facets/PolicyFacet.sol#L406) and [`_grantXVS`](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/facets/RewardFacet.sol#L109) allows `msg.sender` to be the `admin` or the `comptrollerImplementation`. There is no reason to allow for `msg.sender == comptrollerImplementation` since the facets are called by the `Diamond` contract through `delegateCall`.\n\n\nAllowing access from the `comptrollerImplementation` opens a potential attack path if the implementation were able to do calls to the `Unitroller`.\n\n\nConsider disallowing access to these functions from the `ComtprollerImplementation`.\n\n\n***Update:** Resolved in [pull request #312](https://github.com/VenusProtocol/venus-protocol/pull/312) at commit [0aa7e17](https://github.com/VenusProtocol/venus-protocol/pull/312/commits/0aa7e177fd47cbcb2c22fd8ea66a304ee7692868).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Comptroller/Diamond/facets/PolicyFacet.sol",
      "content": "pragma solidity 0.5.16;\n\nimport \"../../../Utils/ErrorReporter.sol\";\nimport \"./XVSRewardsHelper.sol\";\nimport \"../../../Tokens/VTokens/VToken.sol\";\n\n/**\n * @dev This facet contains all the hooks used while transferring the assets\n */\ncontract PolicyFacet is XVSRewardsHelper {\n    /// @notice Emitted when a new borrow-side XVS speed is calculated for a market\n    event VenusBorrowSpeedUpdated(VToken indexed vToken, uint newSpeed);\n\n    /// @notice Emitted when a new supply-side XVS speed is calculated for a market\n    event VenusSupplySpeedUpdated(VToken indexed vToken, uint newSpeed);\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param vToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function mintAllowed(address vToken, address minter, uint mintAmount) external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.MINT);\n        ensureListed(markets[vToken]);\n\n        uint256 supplyCap = supplyCaps[vToken];\n        require(supplyCap != 0, \"market supply cap is 0\");\n\n        uint256 vTokenSupply = VToken(vToken).totalSupply();\n        Exp memory exchangeRate = Exp({ mantissa: VToken(vToken).exchangeRateStored() });\n        uint256 nextTotalSupply = mul_ScalarTruncateAddUInt(exchangeRate, vTokenSupply, mintAmount);\n        require(nextTotalSupply <= supplyCap, \"market supply cap reached\");\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vToken);\n        distributeSupplierVenus(vToken, minter);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function mintVerify(address vToken, address minter, uint actualMintAmount, uint mintTokens) external {}\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param vToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of vTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function redeemAllowed(address vToken, address redeemer, uint redeemTokens) external returns (uint) {\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.REDEEM);\n\n        uint allowed = redeemAllowedInternal(vToken, redeemer, redeemTokens);\n        if (allowed != uint(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vToken);\n        distributeSupplierVenus(vToken, redeemer);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates redeem and reverts on rejection. May emit log\n     * @param vToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    // solhint-disable-next-line no-unused-vars\n    function redeemVerify(address vToken, address redeemer, uint redeemAmount, uint redeemTokens) external pure {\n        require(redeemTokens != 0 || redeemAmount == 0, \"redeemTokens zero\");\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param vToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function borrowAllowed(address vToken, address borrower, uint borrowAmount) external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.BORROW);\n\n        ensureListed(markets[vToken]);\n\n        if (!markets[vToken].accountMembership[borrower]) {\n            // only vTokens may call borrowAllowed if borrower not in market\n            require(msg.sender == vToken, \"sender must be vToken\");\n\n            // attempt to add borrower to the market\n            Error err = addToMarketInternal(VToken(vToken), borrower);\n            if (err != Error.NO_ERROR) {\n                return uint(err);\n            }\n        }\n\n        if (oracle.getUnderlyingPrice(VToken(vToken)) == 0) {\n            return uint(Error.PRICE_ERROR);\n        }\n\n        uint borrowCap = borrowCaps[vToken];\n        // Borrow cap of 0 corresponds to unlimited borrowing\n        if (borrowCap != 0) {\n            uint nextTotalBorrows = add_(VToken(vToken).totalBorrows(), borrowAmount);\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n        }\n\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(\n            borrower,\n            VToken(vToken),\n            0,\n            borrowAmount\n        );\n        if (err != Error.NO_ERROR) {\n            return uint(err);\n        }\n        if (shortfall != 0) {\n            return uint(Error.INSUFFICIENT_LIQUIDITY);\n        }\n\n        // Keep the flywheel moving\n        Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\n        updateVenusBorrowIndex(vToken, borrowIndex);\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates borrow and reverts on rejection. May emit log\n     * @param vToken Asset whose underlying is being borrowed\n     * @param borrower The address borrowing the underlying\n     * @param borrowAmount The amount of the underlying asset requested to borrow\n     */\n    // solhint-disable-next-line no-unused-vars\n    function borrowVerify(address vToken, address borrower, uint borrowAmount) external {}\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param vToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function repayBorrowAllowed(\n        address vToken,\n        // solhint-disable-next-line no-unused-vars\n        address payer,\n        address borrower,\n        // solhint-disable-next-line no-unused-vars\n        uint repayAmount\n    ) external returns (uint) {\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.REPAY);\n        ensureListed(markets[vToken]);\n\n        // Keep the flywheel moving\n        Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\n        updateVenusBorrowIndex(vToken, borrowIndex);\n        distributeBorrowerVenus(vToken, borrower, borrowIndex);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates repayBorrow and reverts on rejection. May emit log\n     * @param vToken Asset being repaid\n     * @param payer The address repaying the borrow\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n    function repayBorrowVerify(\n        address vToken,\n        address payer,\n        address borrower,\n        uint actualRepayAmount,\n        uint borrowerIndex\n    ) external {}\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n    function liquidateBorrowAllowed(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint repayAmount\n    ) external view returns (uint) {\n        checkProtocolPauseState();\n\n        // if we want to pause liquidating to vTokenCollateral, we should pause seizing\n        checkActionPauseState(vTokenBorrowed, Action.LIQUIDATE);\n\n        if (liquidatorContract != address(0) && liquidator != liquidatorContract) {\n            return uint(Error.UNAUTHORIZED);\n        }\n\n        ensureListed(markets[vTokenCollateral]);\n        if (address(vTokenBorrowed) != address(vaiController)) {\n            ensureListed(markets[vTokenBorrowed]);\n        }\n\n        /* The borrower must have shortfall in order to be liquidatable */\n        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, VToken(address(0)), 0, 0);\n        if (err != Error.NO_ERROR) {\n            return uint(err);\n        }\n        if (shortfall == 0) {\n            return uint(Error.INSUFFICIENT_SHORTFALL);\n        }\n\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\n        uint borrowBalance;\n        if (address(vTokenBorrowed) != address(vaiController)) {\n            borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);\n        } else {\n            borrowBalance = vaiController.getVAIRepayAmount(borrower);\n        }\n        //-- maxClose = multipy of closeFactorMantissa and borrowBalance\n        if (repayAmount > mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance)) {\n            return uint(Error.TOO_MUCH_REPAY);\n        }\n\n        return uint(Error.NO_ERROR);\n    }\n\n    function liquidateBorrowVerify(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint actualRepayAmount,\n        uint seizeTokens\n    ) external {}\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    function seizeAllowed(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens // solhint-disable-line no-unused-vars\n    ) external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vTokenCollateral, Action.SEIZE);\n\n        Market storage market = markets[vTokenCollateral];\n\n        // We've added VAIController as a borrowed token list check for seize\n        ensureListed(market);\n\n        if (!market.accountMembership[borrower]) {\n            return uint(Error.MARKET_NOT_COLLATERAL);\n        }\n\n        if (address(vTokenBorrowed) != address(vaiController)) {\n            ensureListed(markets[vTokenBorrowed]);\n        }\n\n        if (VToken(vTokenCollateral).comptroller() != VToken(vTokenBorrowed).comptroller()) {\n            return uint(Error.COMPTROLLER_MISMATCH);\n        }\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vTokenCollateral);\n        distributeSupplierVenus(vTokenCollateral, borrower);\n        distributeSupplierVenus(vTokenCollateral, liquidator);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates seize and reverts on rejection. May emit log\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n    // solhint-disable-next-line no-unused-vars\n    function seizeVerify(\n        address vTokenCollateral,\n        address vTokenBorrowed,\n        address liquidator,\n        address borrower,\n        uint seizeTokens\n    ) external {}\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param vToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of vTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n    function transferAllowed(address vToken, address src, address dst, uint transferTokens) external returns (uint) {\n        // Pausing is a very serious situation - we revert to sound the alarms\n        checkProtocolPauseState();\n        checkActionPauseState(vToken, Action.TRANSFER);\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        uint allowed = redeemAllowedInternal(vToken, src, transferTokens);\n        if (allowed != uint(Error.NO_ERROR)) {\n            return allowed;\n        }\n\n        // Keep the flywheel moving\n        updateVenusSupplyIndex(vToken);\n        distributeSupplierVenus(vToken, src);\n        distributeSupplierVenus(vToken, dst);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Validates transfer and reverts on rejection. May emit log\n     * @param vToken Asset being transferred\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of vTokens to transfer\n     */\n    // solhint-disable-next-line no-unused-vars\n    function transferVerify(address vToken, address src, address dst, uint transferTokens) external {}\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint) {\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            VToken(address(0)),\n            0,\n            0\n        );\n\n        return (uint(err), liquidity, shortfall);\n    }\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param vTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        address vTokenModify,\n        uint redeemTokens,\n        uint borrowAmount\n    ) external view returns (uint, uint, uint) {\n        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(\n            account,\n            VToken(vTokenModify),\n            redeemTokens,\n            borrowAmount\n        );\n        return (uint(err), liquidity, shortfall);\n    }\n\n    // setter functionality\n    /**\n     * @notice Set XVS speed for a single market\n     * @param vTokens The market whose XVS speed to update\n     * @param supplySpeeds New XVS speed for supply\n     * @param borrowSpeeds New XVS speed for borrow\n     */\n    function _setVenusSpeeds(\n        VToken[] calldata vTokens,\n        uint[] calldata supplySpeeds,\n        uint[] calldata borrowSpeeds\n    ) external {\n        ensureAdminOr(comptrollerImplementation);\n\n        uint numTokens = vTokens.length;\n        require(\n            numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length,\n            \"Comptroller::_setVenusSpeeds invalid input\"\n        );\n\n        for (uint i; i < numTokens; ++i) {\n            ensureNonzeroAddress(address(vTokens[i]));\n            setVenusSpeedInternal(vTokens[i], supplySpeeds[i], borrowSpeeds[i]);\n        }\n    }\n\n    function setVenusSpeedInternal(VToken vToken, uint supplySpeed, uint borrowSpeed) internal {\n        ensureListed(markets[address(vToken)]);\n\n        if (venusSupplySpeeds[address(vToken)] != supplySpeed) {\n            // Supply speed updated so let's update supply state to ensure that\n            //  1. XVS accrued properly for the old speed, and\n            //  2. XVS accrued at the new speed starts after this block.\n\n            updateVenusSupplyIndex(address(vToken));\n            // Update speed and emit event\n            venusSupplySpeeds[address(vToken)] = supplySpeed;\n            emit VenusSupplySpeedUpdated(vToken, supplySpeed);\n        }\n\n        if (venusBorrowSpeeds[address(vToken)] != borrowSpeed) {\n            // Borrow speed updated so let's update borrow state to ensure that\n            //  1. XVS accrued properly for the old speed, and\n            //  2. XVS accrued at the new speed starts after this block.\n            Exp memory borrowIndex = Exp({ mantissa: vToken.borrowIndex() });\n            updateVenusBorrowIndex(address(vToken), borrowIndex);\n\n            // Update speed and emit event\n            venusBorrowSpeeds[address(vToken)] = borrowSpeed;\n            emit VenusBorrowSpeedUpdated(vToken, borrowSpeed);\n        }\n    }\n}"
    }
  ]
}