{
  "Title": "H-5: swapValidatorDetails incorrectly writes keys to memory, resulting in permanently locked beacon chain deposits",
  "Content": "# Issue H-5: swapValidatorDetails incorrectly writes keys to memory, resulting in permanently locked beacon chain deposits \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/84 \n\n## Found by \n0xkaden, Stiglitz, hash\n## Summary\n\nWhen loading BLS public keys from storage to memory, the keys are partly overwritten with zero bytes. This ultimately causes allocations of these malformed public keys to permanently lock deposited ETH in the beacon chain deposit contract.\n\n## Vulnerability Detail\n\nValidatorDetails.swapValidatorDetails is used by RioLRTOperatorRegistry.reportOutOfOrderValidatorExits to swap the details in storage of validators which have been exited out of order:\n\n```solidity\n// Swap the position of the validators starting from the `fromIndex` with the validators that were next in line to be exited.\nVALIDATOR_DETAILS_POSITION.swapValidatorDetails(operatorId, fromIndex, validators.exited, validatorCount);\n```\n\nIn swapValidatorDetails, for each swap to occur, we load two keys into memory from storage:\n\n```solidity\nkeyOffset1 = position.computeStorageKeyOffset(operatorId, startIndex1);\nkeyOffset2 = position.computeStorageKeyOffset(operatorId, startIndex2);\nassembly {\n    // Load key1 into memory\n    let _part1 := sload(keyOffset1) // Load bytes 0..31\n    let _part2 := sload(add(keyOffset1, 1)) // Load bytes 32..47\n    mstore(add(key1, 0x20), _part1) // Store bytes 0..31\n    mstore(add(key1, 0x30), shr(128, _part2)) // Store bytes 16..47\n\n    isEmpty := iszero(or(_part1, _part2)) // Store if key1 is empty\n\n    // Load key2 into memory\n    _part1 := sload(keyOffset2) // Load bytes 0..31\n    _part2 := sload(add(keyOffset2, 1)) // Load bytes 32..47\n    mstore(add(key2, 0x20), _part1) // Store bytes 0..31\n    mstore(add(key2, 0x30), shr(128, _part2)) // Store bytes 16..47\n\n    isEmpty := or(isEmpty, iszero(or(_part1, _part2))) // Store if key1 or key2 is empty\n}\n```\n\nThe problem here is that when we store the keys in memory, they don't end up as intended. Let's look at how it works to see where it goes wrong.\n\nThe keys used here are BLS public keys, with a length of 48 bytes, e.g.: `0x95cfcb859956953f9834f8b14cdaa939e472a2b5d0471addbe490b97ed99c6eb8af94bc3ba4d4bfa93d087d522e4b78d`. As such, previously to entering this for loop, we initialize key1 and key2 in memory as 48 byte arrays:\n\n```solidity\nbytes memory key1 = new bytes(48);\nbytes memory key2 = new bytes(48);\n```\n\nSince they're longer than 32 bytes, they have to be stored in two separate storage slots, thus we do two sloads per key to retrieve `_part1` and `_part2`, containing the first 32 bytes and the last 16 bytes respectively.\n\nThe following lines are used with the intention of storing the key in two separate memory slots, similarly to how they're stored in storage:\n\n```solidity\nmstore(add(key1, 0x20), _part1) // Store bytes 0..31\nmstore(add(key1, 0x30), shr(128, _part2)) // Store bytes 16..47\n```\n\nThe problem however is that the second mstore shifts `_part2` 128 bits to the right, causing the leftmost 128 bits to zeroed. Since this mstore is applied only 16 (0x10) bytes after the first mstore, we overwrite bytes 16..31 with zero bytes. We can test this in chisel to prove it:\n\nUsing this example key: `0x95cfcb859956953f9834f8b14cdaa939e472a2b5d0471addbe490b97ed99c6eb8af94bc3ba4d4bfa93d087d522e4b78d`\n\nWe assign the first 32 bytes to `_part1`: \n```solidity\nbytes32 _part1 = 0x95cfcb859956953f9834f8b14cdaa939e472a2b5d0471addbe490b97ed99c6eb\n```\n\nWe assign the last 16 bytes to `_part2`: \n```solidity\nbytes32 _part2 = bytes32(bytes16(0x8af94bc3ba4d4bfa93d087d522e4b78d))\n```\n\nWe assign 48 bytes in memory for `key1`:\n```solidity\nbytes memory key1 = new bytes(48);\n```\n\nAnd we run the following snippet from swapValidatorDetails in chisel: \n```solidity\nassembly {\n  mstore(add(key1, 0x20), _part1) // Store bytes 0..31\n  mstore(add(key1, 0x30), shr(128, _part2)) // Store bytes 16..47\n}\n```\n\nNow we can check the resulting memory using `!memdump`, which outputs the following:\n\n```solidity\nâžœ !memdump\n[0x00:0x20]: 0x0000000000000000000000000000000000000000000000000000000000000000\n[0x20:0x40]: 0x0000000000000000000000000000000000000000000000000000000000000000\n[0x40:0x60]: 0x00000000000000000000000000000000000000000000000000000000000000e0\n[0x60:0x80]: 0x0000000000000000000000000000000000000000000000000000000000000000\n[0x80:0xa0]: 0x0000000000000000000000000000000000000000000000000000000000000030\n[0xa0:0xc0]: 0x95cfcb859956953f9834f8b14cdaa93900000000000000000000000000000000\n[0xc0:0xe0]: 0x8af94bc3ba4d4bfa93d087d522e4b78d00000000000000000000000000000000\n```\n\nWe can see from the memory that at the free memory pointer, the length of key1 is defined 48 bytes (0x30), and following it is the resulting key with 16 bytes zeroed in the middle of the key.\n\n## Impact\n\nWhenever we swapValidatorDetails using reportOutOfOrderValidatorExits, both sets of validators will have broken public keys and when allocated to will cause ETH to be permanently locked in the beacon deposit contract. \n\nWe can see how this manifests in allocateETHDeposits where we retrieve the public keys for allocations:\n\n```solidity\n// Load the allocated validator details from storage and update the deposited validator count.\n(pubKeyBatch, signatureBatch) = ValidatorDetails.allocateMemory(newDepositAllocation);\nVALIDATOR_DETAILS_POSITION.loadValidatorDetails(\n    operatorId, validators.deposited, newDepositAllocation, pubKeyBatch, signatureBatch, 0\n);\n...\nallocations[allocationIndex] = OperatorETHAllocation(operator.delegator, newDepositAllocation, pubKeyBatch, signatureBatch);\n```\n\nWe then use the public keys to stakeETH:\n\n```solidity\n(uint256 depositsAllocated, IRioLRTOperatorRegistry.OperatorETHAllocation[] memory allocations) = operatorRegistry.allocateETHDeposits(\n    depositCount\n);\ndepositAmount = depositsAllocated * ETH_DEPOSIT_SIZE;\n\nfor (uint256 i = 0; i < allocations.length; ++i) {\n    uint256 deposits = allocations[i].deposits;\n\n    IRioLRTOperatorDelegator(allocations[i].delegator).stakeETH{value: deposits * ETH_DEPOSIT_SIZE}(\n        deposits, allocations[i].pubKeyBatch, allocations[i].signatureBatch\n    );\n}\n```\n\nUltimately for each allocation, the public key is passed to the beacon DepositContract.deposit where it deposits to a public key for which we don't have the associated private key and thus can never withdraw.\n\n## Code Snippet\n\n- https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/utils/ValidatorDetails.sol#L151\n- https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/utils/ValidatorDetails.sol#L159\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe can solve this by simply mstoring `_part2` prior to mstoring `_part1`, allowing the mstore of `_part1` to overwrite the zero bytes from `_part2`:\n\n```solidity\nmstore(add(key1, 0x30), shr(128, _part2)) // Store bytes 16..47\nmstore(add(key1, 0x20), _part1) // Store bytes 0..31\n```\n\nNote that the above change must be made for both keys.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/rio-org/rio-sherlock-audit/pull/2.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "rio-sherlock-audit/contracts/utils/ValidatorDetails.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\n/// @title Library for managing validator details in storage.\n/// @notice Modified from KRogLA's work for Lido.\nlibrary ValidatorDetails {\n    using ValidatorDetails for bytes32;\n\n    /// @notice The validator pubkey byte length.\n    uint256 internal constant PUBKEY_LENGTH = 48;\n\n    /// @notice The validator signature byte length.\n    uint256 internal constant SIGNATURE_LENGTH = 96;\n\n    /// @notice The maximum uint40 value.\n    uint256 internal constant UINT40_MAX = type(uint40).max;\n\n    /// @notice Thrown when the number of keys is invalid.\n    error INVALID_KEYS_COUNT();\n\n    /// @notice Thrown when the indexes of keys overlap.\n    error INDEXES_OVERLAP();\n\n    /// @notice Thrown when the keys and signatures lengths mismatch.\n    error LENGTH_MISMATCH();\n\n    /// @notice Thrown when the key is empty.\n    error EMPTY_KEY();\n\n    /// @notice Emitted when a new validator signing key is added.\n    /// @param operatorId The operator ID.\n    /// @param pubkey The validator public key.\n    event ValidatorDetailsAdded(uint8 indexed operatorId, bytes pubkey);\n\n    /// @notice Emitted when a validator signing key is removed.\n    /// @param operatorId The operator ID.\n    /// @param pubkey The validator public key.\n    event ValidatorDetailsRemoved(uint8 indexed operatorId, bytes pubkey);\n\n    /// @notice Emitted when the indexes of two validator signing keys are swapped.\n    /// @param operatorId The operator ID.\n    /// @param pubkey1 The first validator public key.\n    /// @param pubkey2 The second validator public key.\n    event ValidatorDetailsSwapped(uint8 indexed operatorId, bytes pubkey1, bytes pubkey2);\n\n    // forgefmt: disable-next-item\n    /// @notice Compute the storage key offset.\n    /// @param position The storage slot.\n    /// @param operatorId The operator ID.\n    /// @param keyIndex The key index.\n    function computeStorageKeyOffset(bytes32 position, uint8 operatorId, uint256 keyIndex) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(position, operatorId, keyIndex)));\n    }\n\n    /// @notice Store operator details.\n    /// @param position The storage slot.\n    /// @param operatorId The operator ID.\n    /// @param startIndex The start index.\n    /// @param keysCount Keys count to load.\n    /// @param pubkeys Keys buffer to read from.\n    /// @param signatures Signatures buffer to read from.\n    /// @return totalKeysCount New total keys count.\n    function saveValidatorDetails(\n        bytes32 position,\n        uint8 operatorId,\n        uint256 startIndex,\n        uint256 keysCount,\n        bytes memory pubkeys,\n        bytes memory signatures\n    ) internal returns (uint40) {\n        if (keysCount == 0 || startIndex + keysCount > UINT40_MAX) revert INVALID_KEYS_COUNT();\n        if (pubkeys.length != keysCount * PUBKEY_LENGTH || signatures.length != keysCount * SIGNATURE_LENGTH) {\n            revert LENGTH_MISMATCH();\n        }\n\n        uint256 currentOffset;\n        bool isEmpty;\n        bytes memory tempKey = new bytes(48);\n\n        for (uint256 i; i < keysCount;) {\n            currentOffset = position.computeStorageKeyOffset(operatorId, startIndex);\n            assembly {\n                let _ofs := add(add(pubkeys, 0x20), mul(i, 48)) // PUBKEY_LENGTH = 48\n                let _part1 := mload(_ofs) // bytes 0..31\n                let _part2 := mload(add(_ofs, 0x10)) // bytes 16..47\n                isEmpty := iszero(or(_part1, _part2))\n                mstore(add(tempKey, 0x30), _part2) // Store 2nd part first\n                mstore(add(tempKey, 0x20), _part1) // Store 1st part with overwrite bytes 16-31\n            }\n\n            if (isEmpty) revert EMPTY_KEY();\n            assembly {\n                // Store key\n                sstore(currentOffset, mload(add(tempKey, 0x20))) // Store bytes 0..31\n                sstore(add(currentOffset, 1), shl(128, mload(add(tempKey, 0x30)))) // Store bytes 32..47\n\n                // Store signature\n                let _ofs := add(add(signatures, 0x20), mul(i, 96)) // SIGNATURE_LENGTH = 96\n                sstore(add(currentOffset, 2), mload(_ofs))\n                sstore(add(currentOffset, 3), mload(add(_ofs, 0x20)))\n                sstore(add(currentOffset, 4), mload(add(_ofs, 0x40)))\n                i := add(i, 1)\n                startIndex := add(startIndex, 1)\n            }\n            emit ValidatorDetailsAdded(operatorId, tempKey);\n        }\n        return uint40(startIndex);\n    }\n\n    /// @notice Swap operator detail indexes in storage.\n    /// @param position The storage slot.\n    /// @param operatorId The operator ID.\n    /// @param startIndex1 The start index of the first set of keys.\n    /// @param startIndex2 The start index of the second set of keys.\n    /// @param keysCount Keys count to swap.\n    function swapValidatorDetails(\n        bytes32 position,\n        uint8 operatorId,\n        uint256 startIndex1,\n        uint256 startIndex2,\n        uint256 keysCount\n    ) internal {\n        if (keysCount == 0 || startIndex1 + keysCount > UINT40_MAX || startIndex2 + keysCount > UINT40_MAX) {\n            revert INVALID_KEYS_COUNT();\n        }\n\n        // forgefmt: disable-next-item\n        // Ensure no overlap in indexes\n        if ((startIndex1 < startIndex2 && startIndex1 + keysCount >= startIndex2) || (startIndex2 < startIndex1 && startIndex2 + keysCount >= startIndex1)) {\n            revert INDEXES_OVERLAP();\n        }\n\n        uint256 keyOffset1;\n        uint256 keyOffset2;\n\n        bool isEmpty;\n\n        bytes memory key1 = new bytes(48);\n        bytes memory key2 = new bytes(48);\n        bytes memory signature1 = new bytes(96);\n        bytes memory signature2 = new bytes(96);\n\n        for (uint256 i; i < keysCount;) {\n            keyOffset1 = position.computeStorageKeyOffset(operatorId, startIndex1);\n            keyOffset2 = position.computeStorageKeyOffset(operatorId, startIndex2);\n            assembly {\n                // Load key1 into memory\n                let _part1 := sload(keyOffset1) // Load bytes 0..31\n                let _part2 := sload(add(keyOffset1, 1)) // Load bytes 32..47\n                mstore(add(key1, 0x20), _part1) // Store bytes 0..31\n                mstore(add(key1, 0x30), shr(128, _part2)) // Store bytes 16..47\n\n                isEmpty := iszero(or(_part1, _part2)) // Store if key1 is empty\n\n                // Load key2 into memory\n                _part1 := sload(keyOffset2) // Load bytes 0..31\n                _part2 := sload(add(keyOffset2, 1)) // Load bytes 32..47\n                mstore(add(key2, 0x20), _part1) // Store bytes 0..31\n                mstore(add(key2, 0x30), shr(128, _part2)) // Store bytes 16..47\n\n                isEmpty := or(isEmpty, iszero(or(_part1, _part2))) // Store if key1 or key2 is empty\n            }\n\n            if (isEmpty) revert EMPTY_KEY();\n            assembly {\n                // Load signature1 into memory\n                mstore(add(signature1, 0x20), sload(add(keyOffset1, 2)))\n                mstore(add(signature1, 0x40), sload(add(keyOffset1, 3)))\n                mstore(add(signature1, 0x60), sload(add(keyOffset1, 4)))\n\n                // Load signature2 into memory\n                mstore(add(signature2, 0x20), sload(add(keyOffset2, 2)))\n                mstore(add(signature2, 0x40), sload(add(keyOffset2, 3)))\n                mstore(add(signature2, 0x60), sload(add(keyOffset2, 4)))\n\n                // Swap keys\n                sstore(keyOffset1, mload(add(key2, 0x20))) // Store bytes 0..31\n                sstore(add(keyOffset1, 1), shl(128, mload(add(key2, 0x30)))) // Store bytes 32..47\n                sstore(keyOffset2, mload(add(key1, 0x20))) // Store bytes 0..31\n                sstore(add(keyOffset2, 1), shl(128, mload(add(key1, 0x30)))) // Store bytes 32..47\n\n                // Swap signatures\n                sstore(add(keyOffset1, 2), mload(add(signature2, 0x20)))\n                sstore(add(keyOffset1, 3), mload(add(signature2, 0x40)))\n                sstore(add(keyOffset1, 4), mload(add(signature2, 0x60)))\n                sstore(add(keyOffset2, 2), mload(add(signature1, 0x20)))\n                sstore(add(keyOffset2, 3), mload(add(signature1, 0x40)))\n                sstore(add(keyOffset2, 4), mload(add(signature1, 0x60)))\n\n                i := add(i, 1)\n                startIndex1 := add(startIndex1, 1)\n                startIndex2 := add(startIndex2, 1)\n            }\n            emit ValidatorDetailsSwapped(operatorId, key1, key2);\n        }\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Remove validator details from storage.\n    /// @param position The storage slot.\n    /// @param operatorId The Operator ID.\n    /// @param startIndex The start index.\n    /// @param keysCount Keys count to load.\n    /// @param totalKeysCount Current total keys count for operator.\n    /// @return totalKeysCount New total keys count.\n    function removeValidatorDetails(bytes32 position, uint8 operatorId, uint256 startIndex, uint256 keysCount, uint256 totalKeysCount) internal returns (uint40) {\n        if (keysCount == 0 || startIndex + keysCount > totalKeysCount || totalKeysCount > UINT40_MAX) {\n            revert INVALID_KEYS_COUNT();\n        }\n\n        uint256 currentOffset;\n        uint256 lastOffset;\n        uint256 j;\n\n        bytes memory tempKey = new bytes(48);\n\n        // Remove from the last index\n        for (uint256 i = startIndex + keysCount; i > startIndex;) {\n            currentOffset = position.computeStorageKeyOffset(operatorId, i - 1);\n            assembly {\n                // Read key\n                mstore(add(tempKey, 0x30), shr(128, sload(add(currentOffset, 1)))) // bytes 16..47\n                mstore(add(tempKey, 0x20), sload(currentOffset)) // bytes 0..31\n            }\n            if (i < totalKeysCount) {\n                lastOffset = position.computeStorageKeyOffset(operatorId, totalKeysCount - 1);\n\n                // Move last key to deleted key index\n                for (j = 0; j < 5;) {\n                    assembly {\n                        sstore(add(currentOffset, j), sload(add(lastOffset, j)))\n                        j := add(j, 1)\n                    }\n                }\n                currentOffset = lastOffset;\n            }\n\n            // Clear storage\n            for (j = 0; j < 5;) {\n                assembly {\n                    sstore(add(currentOffset, j), 0)\n                    j := add(j, 1)\n                }\n            }\n            assembly {\n                totalKeysCount := sub(totalKeysCount, 1)\n                i := sub(i, 1)\n            }\n            emit ValidatorDetailsRemoved(operatorId, tempKey);\n        }\n        return uint40(totalKeysCount);\n    }\n\n    /// @notice Load validator details from storage.\n    /// @param position The storage slot.\n    /// @param operatorId The operator ID.\n    /// @param startIndex The start index.\n    /// @param keysCount Keys count to load.\n    /// @param pubkeys Pre-allocated key buffer to read in.\n    /// @param signatures Pre-allocated signature buffer to read in.\n    /// @param bufferOffset start offset in `pubkeys`/`signatures` buffer to place values (in number of keys).\n    function loadValidatorDetails(\n        bytes32 position,\n        uint8 operatorId,\n        uint256 startIndex,\n        uint256 keysCount,\n        bytes memory pubkeys,\n        bytes memory signatures,\n        uint256 bufferOffset\n    ) internal view {\n        uint256 currentOffset;\n        for (uint256 i; i < keysCount;) {\n            currentOffset = position.computeStorageKeyOffset(operatorId, startIndex + i);\n\n            assembly {\n                // Read key\n                let _ofs := add(add(pubkeys, 0x20), mul(add(bufferOffset, i), 48)) // PUBKEY_LENGTH = 48\n                mstore(add(_ofs, 0x10), shr(128, sload(add(currentOffset, 1)))) // bytes 16..47\n                mstore(_ofs, sload(currentOffset)) // bytes 0..31\n\n                // Store signature, if `signatures` is not empty\n                if gt(mload(signatures), 0) {\n                    _ofs := add(add(signatures, 0x20), mul(add(bufferOffset, i), 96)) // SIGNATURE_LENGTH = 96\n                    mstore(_ofs, sload(add(currentOffset, 2)))\n                    mstore(add(_ofs, 0x20), sload(add(currentOffset, 3)))\n                    mstore(add(_ofs, 0x40), sload(add(currentOffset, 4)))\n                }\n                i := add(i, 1)\n            }\n        }\n    }\n\n    /// @notice Allocate memory for `keyCount` public keys.\n    /// @param keyCount The number of public keys.\n    function allocateMemoryForPubKeys(uint256 keyCount) internal pure returns (bytes memory) {\n        return new bytes(keyCount * PUBKEY_LENGTH);\n    }\n\n    /// @notice Allocate memory for `count` validator details.\n    /// @param count The number of validators.\n    function allocateMemory(uint256 count) internal pure returns (bytes memory, bytes memory) {\n        return (allocateMemoryForPubKeys(count), new bytes(count * SIGNATURE_LENGTH));\n    }\n}"
    },
    {
      "filename": "rio-sherlock-audit/contracts/utils/ValidatorDetails.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\n/// @title Library for managing validator details in storage.\n/// @notice Modified from KRogLA's work for Lido.\nlibrary ValidatorDetails {\n    using ValidatorDetails for bytes32;\n\n    /// @notice The validator pubkey byte length.\n    uint256 internal constant PUBKEY_LENGTH = 48;\n\n    /// @notice The validator signature byte length.\n    uint256 internal constant SIGNATURE_LENGTH = 96;\n\n    /// @notice The maximum uint40 value.\n    uint256 internal constant UINT40_MAX = type(uint40).max;\n\n    /// @notice Thrown when the number of keys is invalid.\n    error INVALID_KEYS_COUNT();\n\n    /// @notice Thrown when the indexes of keys overlap.\n    error INDEXES_OVERLAP();\n\n    /// @notice Thrown when the keys and signatures lengths mismatch.\n    error LENGTH_MISMATCH();\n\n    /// @notice Thrown when the key is empty.\n    error EMPTY_KEY();\n\n    /// @notice Emitted when a new validator signing key is added.\n    /// @param operatorId The operator ID.\n    /// @param pubkey The validator public key.\n    event ValidatorDetailsAdded(uint8 indexed operatorId, bytes pubkey);\n\n    /// @notice Emitted when a validator signing key is removed.\n    /// @param operatorId The operator ID.\n    /// @param pubkey The validator public key.\n    event ValidatorDetailsRemoved(uint8 indexed operatorId, bytes pubkey);\n\n    /// @notice Emitted when the indexes of two validator signing keys are swapped.\n    /// @param operatorId The operator ID.\n    /// @param pubkey1 The first validator public key.\n    /// @param pubkey2 The second validator public key.\n    event ValidatorDetailsSwapped(uint8 indexed operatorId, bytes pubkey1, bytes pubkey2);\n\n    // forgefmt: disable-next-item\n    /// @notice Compute the storage key offset.\n    /// @param position The storage slot.\n    /// @param operatorId The operator ID.\n    /// @param keyIndex The key index.\n    function computeStorageKeyOffset(bytes32 position, uint8 operatorId, uint256 keyIndex) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(position, operatorId, keyIndex)));\n    }\n\n    /// @notice Store operator details.\n    /// @param position The storage slot.\n    /// @param operatorId The operator ID.\n    /// @param startIndex The start index.\n    /// @param keysCount Keys count to load.\n    /// @param pubkeys Keys buffer to read from.\n    /// @param signatures Signatures buffer to read from.\n    /// @return totalKeysCount New total keys count.\n    function saveValidatorDetails(\n        bytes32 position,\n        uint8 operatorId,\n        uint256 startIndex,\n        uint256 keysCount,\n        bytes memory pubkeys,\n        bytes memory signatures\n    ) internal returns (uint40) {\n        if (keysCount == 0 || startIndex + keysCount > UINT40_MAX) revert INVALID_KEYS_COUNT();\n        if (pubkeys.length != keysCount * PUBKEY_LENGTH || signatures.length != keysCount * SIGNATURE_LENGTH) {\n            revert LENGTH_MISMATCH();\n        }\n\n        uint256 currentOffset;\n        bool isEmpty;\n        bytes memory tempKey = new bytes(48);\n\n        for (uint256 i; i < keysCount;) {\n            currentOffset = position.computeStorageKeyOffset(operatorId, startIndex);\n            assembly {\n                let _ofs := add(add(pubkeys, 0x20), mul(i, 48)) // PUBKEY_LENGTH = 48\n                let _part1 := mload(_ofs) // bytes 0..31\n                let _part2 := mload(add(_ofs, 0x10)) // bytes 16..47\n                isEmpty := iszero(or(_part1, _part2))\n                mstore(add(tempKey, 0x30), _part2) // Store 2nd part first\n                mstore(add(tempKey, 0x20), _part1) // Store 1st part with overwrite bytes 16-31\n            }\n\n            if (isEmpty) revert EMPTY_KEY();\n            assembly {\n                // Store key\n                sstore(currentOffset, mload(add(tempKey, 0x20))) // Store bytes 0..31\n                sstore(add(currentOffset, 1), shl(128, mload(add(tempKey, 0x30)))) // Store bytes 32..47\n\n                // Store signature\n                let _ofs := add(add(signatures, 0x20), mul(i, 96)) // SIGNATURE_LENGTH = 96\n                sstore(add(currentOffset, 2), mload(_ofs))\n                sstore(add(currentOffset, 3), mload(add(_ofs, 0x20)))\n                sstore(add(currentOffset, 4), mload(add(_ofs, 0x40)))\n                i := add(i, 1)\n                startIndex := add(startIndex, 1)\n            }\n            emit ValidatorDetailsAdded(operatorId, tempKey);\n        }\n        return uint40(startIndex);\n    }\n\n    /// @notice Swap operator detail indexes in storage.\n    /// @param position The storage slot.\n    /// @param operatorId The operator ID.\n    /// @param startIndex1 The start index of the first set of keys.\n    /// @param startIndex2 The start index of the second set of keys.\n    /// @param keysCount Keys count to swap.\n    function swapValidatorDetails(\n        bytes32 position,\n        uint8 operatorId,\n        uint256 startIndex1,\n        uint256 startIndex2,\n        uint256 keysCount\n    ) internal {\n        if (keysCount == 0 || startIndex1 + keysCount > UINT40_MAX || startIndex2 + keysCount > UINT40_MAX) {\n            revert INVALID_KEYS_COUNT();\n        }\n\n        // forgefmt: disable-next-item\n        // Ensure no overlap in indexes\n        if ((startIndex1 < startIndex2 && startIndex1 + keysCount >= startIndex2) || (startIndex2 < startIndex1 && startIndex2 + keysCount >= startIndex1)) {\n            revert INDEXES_OVERLAP();\n        }\n\n        uint256 keyOffset1;\n        uint256 keyOffset2;\n\n        bool isEmpty;\n\n        bytes memory key1 = new bytes(48);\n        bytes memory key2 = new bytes(48);\n        bytes memory signature1 = new bytes(96);\n        bytes memory signature2 = new bytes(96);\n\n        for (uint256 i; i < keysCount;) {\n            keyOffset1 = position.computeStorageKeyOffset(operatorId, startIndex1);\n            keyOffset2 = position.computeStorageKeyOffset(operatorId, startIndex2);\n            assembly {\n                // Load key1 into memory\n                let _part1 := sload(keyOffset1) // Load bytes 0..31\n                let _part2 := sload(add(keyOffset1, 1)) // Load bytes 32..47\n                mstore(add(key1, 0x20), _part1) // Store bytes 0..31\n                mstore(add(key1, 0x30), shr(128, _part2)) // Store bytes 16..47\n\n                isEmpty := iszero(or(_part1, _part2)) // Store if key1 is empty\n\n                // Load key2 into memory\n                _part1 := sload(keyOffset2) // Load bytes 0..31\n                _part2 := sload(add(keyOffset2, 1)) // Load bytes 32..47\n                mstore(add(key2, 0x20), _part1) // Store bytes 0..31\n                mstore(add(key2, 0x30), shr(128, _part2)) // Store bytes 16..47\n\n                isEmpty := or(isEmpty, iszero(or(_part1, _part2))) // Store if key1 or key2 is empty\n            }\n\n            if (isEmpty) revert EMPTY_KEY();\n            assembly {\n                // Load signature1 into memory\n                mstore(add(signature1, 0x20), sload(add(keyOffset1, 2)))\n                mstore(add(signature1, 0x40), sload(add(keyOffset1, 3)))\n                mstore(add(signature1, 0x60), sload(add(keyOffset1, 4)))\n\n                // Load signature2 into memory\n                mstore(add(signature2, 0x20), sload(add(keyOffset2, 2)))\n                mstore(add(signature2, 0x40), sload(add(keyOffset2, 3)))\n                mstore(add(signature2, 0x60), sload(add(keyOffset2, 4)))\n\n                // Swap keys\n                sstore(keyOffset1, mload(add(key2, 0x20))) // Store bytes 0..31\n                sstore(add(keyOffset1, 1), shl(128, mload(add(key2, 0x30)))) // Store bytes 32..47\n                sstore(keyOffset2, mload(add(key1, 0x20))) // Store bytes 0..31\n                sstore(add(keyOffset2, 1), shl(128, mload(add(key1, 0x30)))) // Store bytes 32..47\n\n                // Swap signatures\n                sstore(add(keyOffset1, 2), mload(add(signature2, 0x20)))\n                sstore(add(keyOffset1, 3), mload(add(signature2, 0x40)))\n                sstore(add(keyOffset1, 4), mload(add(signature2, 0x60)))\n                sstore(add(keyOffset2, 2), mload(add(signature1, 0x20)))\n                sstore(add(keyOffset2, 3), mload(add(signature1, 0x40)))\n                sstore(add(keyOffset2, 4), mload(add(signature1, 0x60)))\n\n                i := add(i, 1)\n                startIndex1 := add(startIndex1, 1)\n                startIndex2 := add(startIndex2, 1)\n            }\n            emit ValidatorDetailsSwapped(operatorId, key1, key2);\n        }\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Remove validator details from storage.\n    /// @param position The storage slot.\n    /// @param operatorId The Operator ID.\n    /// @param startIndex The start index.\n    /// @param keysCount Keys count to load.\n    /// @param totalKeysCount Current total keys count for operator.\n    /// @return totalKeysCount New total keys count.\n    function removeValidatorDetails(bytes32 position, uint8 operatorId, uint256 startIndex, uint256 keysCount, uint256 totalKeysCount) internal returns (uint40) {\n        if (keysCount == 0 || startIndex + keysCount > totalKeysCount || totalKeysCount > UINT40_MAX) {\n            revert INVALID_KEYS_COUNT();\n        }\n\n        uint256 currentOffset;\n        uint256 lastOffset;\n        uint256 j;\n\n        bytes memory tempKey = new bytes(48);\n\n        // Remove from the last index\n        for (uint256 i = startIndex + keysCount; i > startIndex;) {\n            currentOffset = position.computeStorageKeyOffset(operatorId, i - 1);\n            assembly {\n                // Read key\n                mstore(add(tempKey, 0x30), shr(128, sload(add(currentOffset, 1)))) // bytes 16..47\n                mstore(add(tempKey, 0x20), sload(currentOffset)) // bytes 0..31\n            }\n            if (i < totalKeysCount) {\n                lastOffset = position.computeStorageKeyOffset(operatorId, totalKeysCount - 1);\n\n                // Move last key to deleted key index\n                for (j = 0; j < 5;) {\n                    assembly {\n                        sstore(add(currentOffset, j), sload(add(lastOffset, j)))\n                        j := add(j, 1)\n                    }\n                }\n                currentOffset = lastOffset;\n            }\n\n            // Clear storage\n            for (j = 0; j < 5;) {\n                assembly {\n                    sstore(add(currentOffset, j), 0)\n                    j := add(j, 1)\n                }\n            }\n            assembly {\n                totalKeysCount := sub(totalKeysCount, 1)\n                i := sub(i, 1)\n            }\n            emit ValidatorDetailsRemoved(operatorId, tempKey);\n        }\n        return uint40(totalKeysCount);\n    }\n\n    /// @notice Load validator details from storage.\n    /// @param position The storage slot.\n    /// @param operatorId The operator ID.\n    /// @param startIndex The start index.\n    /// @param keysCount Keys count to load.\n    /// @param pubkeys Pre-allocated key buffer to read in.\n    /// @param signatures Pre-allocated signature buffer to read in.\n    /// @param bufferOffset start offset in `pubkeys`/`signatures` buffer to place values (in number of keys).\n    function loadValidatorDetails(\n        bytes32 position,\n        uint8 operatorId,\n        uint256 startIndex,\n        uint256 keysCount,\n        bytes memory pubkeys,\n        bytes memory signatures,\n        uint256 bufferOffset\n    ) internal view {\n        uint256 currentOffset;\n        for (uint256 i; i < keysCount;) {\n            currentOffset = position.computeStorageKeyOffset(operatorId, startIndex + i);\n\n            assembly {\n                // Read key\n                let _ofs := add(add(pubkeys, 0x20), mul(add(bufferOffset, i), 48)) // PUBKEY_LENGTH = 48\n                mstore(add(_ofs, 0x10), shr(128, sload(add(currentOffset, 1)))) // bytes 16..47\n                mstore(_ofs, sload(currentOffset)) // bytes 0..31\n\n                // Store signature, if `signatures` is not empty\n                if gt(mload(signatures), 0) {\n                    _ofs := add(add(signatures, 0x20), mul(add(bufferOffset, i), 96)) // SIGNATURE_LENGTH = 96\n                    mstore(_ofs, sload(add(currentOffset, 2)))\n                    mstore(add(_ofs, 0x20), sload(add(currentOffset, 3)))\n                    mstore(add(_ofs, 0x40), sload(add(currentOffset, 4)))\n                }\n                i := add(i, 1)\n            }\n        }\n    }\n\n    /// @notice Allocate memory for `keyCount` public keys.\n    /// @param keyCount The number of public keys.\n    function allocateMemoryForPubKeys(uint256 keyCount) internal pure returns (bytes memory) {\n        return new bytes(keyCount * PUBKEY_LENGTH);\n    }\n\n    /// @notice Allocate memory for `count` validator details.\n    /// @param count The number of validators.\n    function allocateMemory(uint256 count) internal pure returns (bytes memory, bytes memory) {\n        return (allocateMemoryForPubKeys(count), new bytes(count * SIGNATURE_LENGTH));\n    }\n}"
    }
  ]
}