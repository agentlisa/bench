{
  "Title": "Potentially Stuck ETH in GasSwap",
  "Content": "In the [`GasSwap` contract](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/gateways/L1ERC20Gateway.sol#L130), the [`swap` function](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/gateways/L1ERC20Gateway.sol#L128C14-L128C32) allows a user to swap ERC-20 tokens for ETH. The swap is [executed by calling an approved target](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/rollup/L1MessageQueue.sol), which in return transfers ETH to the `GasSwap` contract through the [`receive` function](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/rollup/L1MessageQueue.sol#L382). The user is then [reimbursed](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/rollup/L1MessageQueue.sol#L102) the output amount of ETH after deducting the fee.\n\n\nHowever, any user can accidentally transfer ETH to the `GasSwap` contract without calling the `swap` function. Any ETH transferred outside of a swap will be locked in the contract and is only redeemable through the owner.\n\n\nConsider only allowing ETH transfers to the `GasSwap` contract from approved targets to minimize the probability of having ETH accidentally locked in this contract. Alternatively, consider only allowing ETH transfers to the contract during a swap.\n\n\n***Update:** Acknowledged, not resolved. The Scroll team stated:*\n\n\n\n> *Our owner can rescue the stuck ETH as long as the user provides the transfer transaction.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/gateways/L1ERC20Gateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IL1ERC20Gateway} from \"./IL1ERC20Gateway.sol\";\nimport {IL1GatewayRouter} from \"./IL1GatewayRouter.sol\";\n\nimport {ScrollGatewayBase} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\n\nimport {IL2ERC20Gateway} from \"../../L2/gateways/IL2ERC20Gateway.sol\";\nimport {IScrollMessenger} from \"../../libraries/IScrollMessenger.sol\";\nimport {ScrollConstants} from \"../../libraries/constants/ScrollConstants.sol\";\nimport {ScrollGatewayBase} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\nimport {IMessageDropCallback} from \"../../libraries/callbacks/IMessageDropCallback.sol\";\n\n// solhint-disable no-empty-blocks\n\nabstract contract L1ERC20Gateway is IL1ERC20Gateway, IMessageDropCallback, ScrollGatewayBase {\n    using SafeERC20 for IERC20;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @dev The storage slots for future usage.\n    uint256[50] private __gap;\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        _deposit(_token, msg.sender, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) external payable override {\n        _deposit(_token, _to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function depositERC20AndCall(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) external payable override {\n        _deposit(_token, _to, _amount, _data, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ERC20Gateway\n    function finalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCallByCounterpart nonReentrant {\n        _beforeFinalizeWithdrawERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n\n        // @note can possible trigger reentrant call to this contract or messenger,\n        // but it seems not a big problem.\n        IERC20(_l1Token).safeTransfer(_to, _amount);\n\n        _doCallback(_to, _data);\n\n        emit FinalizeWithdrawERC20(_l1Token, _l2Token, _from, _to, _amount, _data);\n    }\n\n    /// @inheritdoc IMessageDropCallback\n    function onDropMessage(bytes calldata _message) external payable virtual onlyInDropContext nonReentrant {\n        // _message should start with 0x8431f5c1  =>  finalizeDepositERC20(address,address,address,address,uint256,bytes)\n        require(bytes4(_message[0:4]) == IL2ERC20Gateway.finalizeDepositERC20.selector, \"invalid selector\");\n\n        // decode (token, receiver, amount)\n        (address _token, , address _receiver, , uint256 _amount, ) = abi.decode(\n            _message[4:],\n            (address, address, address, address, uint256, bytes)\n        );\n\n        // do dome check for each custom gateway\n        _beforeDropMessage(_token, _receiver, _amount);\n\n        IERC20(_token).safeTransfer(_receiver, _amount);\n\n        emit RefundERC20(_token, _receiver, _amount);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function hook to perform checks and actions before finalizing the withdrawal.\n    /// @param _l1Token The address of corresponding L1 token in L1.\n    /// @param _l2Token The address of corresponding L2 token in L2.\n    /// @param _from The address of account who withdraw the token in L2.\n    /// @param _to The address of recipient in L1 to receive the token.\n    /// @param _amount The amount of the token to withdraw.\n    /// @param _data Optional data to forward to recipient's account.\n    function _beforeFinalizeWithdrawERC20(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) internal virtual;\n\n    /// @dev Internal function hook to perform checks and actions before dropping the message.\n    /// @param _token The L1 token address.\n    /// @param _receiver The recipient address on L1.\n    /// @param _amount The amount of token to refund.\n    function _beforeDropMessage(\n        address _token,\n        address _receiver,\n        uint256 _amount\n    ) internal virtual;\n\n    /// @dev Internal function to transfer ERC20 token to this contract.\n    /// @param _token The address of token to transfer.\n    /// @param _amount The amount of token to transfer.\n    /// @param _data The data passed by caller.\n    function _transferERC20In(\n        address _token,\n        uint256 _amount,\n        bytes memory _data\n    )\n        internal\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address _from = msg.sender;\n        if (router == msg.sender) {\n            // Extract real sender if this call is from L1GatewayRouter.\n            (_from, _data) = abi.decode(_data, (address, bytes));\n            _amount = IL1GatewayRouter(msg.sender).requestERC20(_from, _token, _amount);\n        } else {\n            // common practice to handle fee on transfer token.\n            uint256 _before = IERC20(_token).balanceOf(address(this));\n            IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n            uint256 _after = IERC20(_token).balanceOf(address(this));\n            // no unchecked here, since some weird token may return arbitrary balance.\n            _amount = _after - _before;\n        }\n        // ignore weird fee on transfer token\n        require(_amount > 0, \"deposit zero amount\");\n\n        return (_from, _amount, _data);\n    }\n\n    /// @dev Internal function to do all the deposit operations.\n    ///\n    /// @param _token The token to deposit.\n    /// @param _to The recipient address to recieve the token in L2.\n    /// @param _amount The amount of token to deposit.\n    /// @param _data Optional data to forward to recipient's account.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function _deposit(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) internal virtual;\n}"
    }
  ]
}