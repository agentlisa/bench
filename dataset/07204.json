{
  "Title": "[G-07] Multiple accesses of a mapping/array should use a local variable cache",
  "Content": "\nCaching a mapping's value in a local storage or calldata variable when the value is accessed multiple times saves ~42 gas per access due to not having to perform the same offset calculation every time.<br>\n**Help the Optimizer by saving a storage variable's reference instead of repeatedly fetching it**\n\nTo help the optimizer,declare a storage type variable and use it instead of repeatedly fetching the reference in a map or an array.<br>\nAs an example, instead of repeatedly calling `someMap[someIndex]`, save its reference like this: `SomeStruct storage someStruct = someMap[someIndex]` and use it.\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/CashManager.sol#L662-L686\n\n### CashManager.sol.requestRedemption(): redemptionInfoPerEpoch[currentEpoch] should be cached in storage\n```solidity\nFile:/contracts/cash/CashManager.sol\n662:  function requestRedemption(\n\n678:    redemptionInfoPerEpoch[currentEpoch].addressToBurnAmt[\n679:        msg.sender\n680:      ] += amountCashToRedeem;\n681:    redemptionInfoPerEpoch[currentEpoch].totalBurned += amountCashToRedeem;\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/cash/CashManager.sol#L851-L876\n\n### CashManager.sol.setPendingRedemptionBalance(): redemptionInfoPerEpoch[epoch] should be cached in local storage\n```solidity\nFile:/contracts/cash/CashManager.sol\n851:  function setPendingRedemptionBalance(\n\n859:    uint256 previousBalance = redemptionInfoPerEpoch[epoch].addressToBurnAmt[\n860:      user\n861:    ];\n\n864:    if (balance < previousBalance) {\n865:      redemptionInfoPerEpoch[epoch].totalBurned -= previousBalance - balance;\n866:    } else if (balance > previousBalance) {\n867:      redemptionInfoPerEpoch[epoch].totalBurned += balance - previousBalance;\n868:    }\n869:    redemptionInfoPerEpoch[epoch].addressToBurnAmt[user] = balance;\n870:    emit PendingRedemptionBalanceSet(\n871:      user,\n872:      epoch,\n873:      balance,\n874:      redemptionInfoPerEpoch[epoch].totalBurned\n875:    );\n876:  }\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L720-L721\n\n### CTokenCash.sol.borrowFresh(): accountBorrows[borrower] should be cached in local storage\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n720:    accountBorrows[borrower].principal = accountBorrowsNew;//@audit: Initial access\n721:    accountBorrows[borrower].interestIndex = borrowIndex;//@audit: 2nd access\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cCash/CTokenCash.sol#L822-L823\n\n### CTokenCash.sol.repayBorrowFresh(): accountBorrows[borrower] should be cached in local storage\n```solidity\nFile: /contracts/lending/tokens/cCash/CTokenCash.sol\n822:    accountBorrows[borrower].principal = accountBorrowsNew; //@audit: Initial access\n823:    accountBorrows[borrower].interestIndex = borrowIndex;//@audit: 2nd access\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CTokenModified.sol#L720-L721\n\n### CTokenModified.sol.borrowFresh(): accountBorrows[borrower] should be cached in local storage\n```solidity\nFile:/contracts/lending/tokens/cToken/CTokenModified.sol\n720:    accountBorrows[borrower].principal = accountBorrowsNew;//@audit: Initial access\n721:    accountBorrows[borrower].interestIndex = borrowIndex;//@audit: 2nd access\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/tokens/cToken/CTokenModified.sol#L822-L823\n\n### CTokenModified.sol.repayBorrowFresh(): accountBorrows[borrower] should be cached in local storage\n```solidity\nFile:/contracts/lending/tokens/cToken/CTokenModified.sol\n822:   accountBorrows[borrower].principal = accountBorrowsNew;//@audit: Initial access\n823:   accountBorrows[borrower].interestIndex = borrowIndex;//@audit: 2nd access\n```\n\nhttps://github.com/code-423n4/2023-01-ondo/blob/f3426e5b6b4561e09460b2e6471eb694efdd6c70/contracts/lending/OndoPriceOracleV2.sol#L251-L267\n\n### OndoPriceOracleV2.sol.\\_setFTokenToChainlinkOracle(): fTokenToChainlinkOracle\\[fToken] should be cached in local storage\n```solidity\nFile: /contracts/lending/OndoPriceOracleV2.sol\n251:  function _setFTokenToChainlinkOracle(\n\n260:    fTokenToChainlinkOracle[fToken].scaleFactor = (10 **\n261:      (36 -\n262:        uint256(IERC20Like(underlying).decimals()) -\n263:        uint256(AggregatorV3Interface(chainlinkOracle).decimals()))); //@audit: Initial access\n264:    fTokenToChainlinkOracle[fToken].oracle = AggregatorV3Interface(\n265:      chainlinkOracle\n266:    );//@audit: 2nd access\n267:  }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-ondo-finance-contest",
  "Code": [
    {
      "filename": "contracts/cash/CashManager.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\nimport \"contracts/cash/interfaces/ICashManager.sol\";\nimport \"contracts/cash/interfaces/IMulticall.sol\";\nimport \"contracts/cash/token/Cash.sol\";\nimport \"contracts/cash/kyc/KYCRegistryClientConstructable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/security/Pausable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/token/IERC20.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/token/IERC20Metadata.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/token/SafeERC20.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract CashManager is\n  ICashManager,\n  IMulticall,\n  AccessControlEnumerable,\n  KYCRegistryClientConstructable,\n  Pausable,\n  ReentrancyGuard\n{\n  using SafeERC20 for IERC20;\n\n  /// @dev Tokens\n  // ERC20 token used to Mint CASH with\n  IERC20 public immutable collateral;\n\n  // CASH contract\n  Cash public immutable cash;\n\n  /// @dev Collateral Recipients\n  // The address to which the `collateral` is sent\n  address public assetRecipient;\n\n  // The address to which fees are sent\n  address public feeRecipient;\n\n  // The address from which redemptions are processed\n  address public assetSender;\n\n  /// @dev Mint/Redeem Parameters\n  // Minimum amount that must be deposited to mint CASH\n  // Denoted in decimals of `collateral`\n  uint256 public minimumDepositAmount = 10_000;\n\n  // Minimum amount that must be redeemed for a withdraw request\n  uint256 public minimumRedeemAmount;\n\n  // Minting fee specified in basis points\n  uint256 public mintFee = 0;\n\n  // Limit for how far `exchangeRate` can stray from\n  // `lastSetMintExchangeRate` within an epoch (in basis points)\n  uint256 public exchangeRateDeltaLimit = 100;\n\n  // Struct representing all redemption requests in an epoch\n  struct RedemptionRequests {\n    // Total CASH burned in the epoch\n    uint256 totalBurned;\n    // Mapping from address to amount of CASH address burned\n    mapping(address => uint256) addressToBurnAmt;\n  }\n\n  // Mapping from epoch to redemption info struct for that epoch\n  mapping(uint256 => RedemptionRequests) public redemptionInfoPerEpoch;\n\n  // Mapping used for getting the exchange rate during a given epoch\n  mapping(uint256 => uint256) public epochToExchangeRate;\n\n  // Nested mapping containing mint requests for an epoch\n  // { <epoch> : {<user> : <collateralAmount> }\n  mapping(uint256 => mapping(address => uint256)) public mintRequestsPerEpoch;\n\n  // Helper constant that allows us to specify basis points in calculations\n  uint256 public constant BPS_DENOMINATOR = 10_000;\n\n  // Decimal multiplier representing the difference between `CASH` decimals\n  // In `collateral` token decimals\n  uint256 public immutable decimalsMultiplier;\n\n  /// @dev Epoch Parameters\n  // Epoch that contract is currently in\n  uint256 public currentEpoch;\n\n  // Duration of an epoch in seconds\n  uint256 public epochDuration;\n\n  // Timestamp of the start of `currentEpoch`\n  uint256 public currentEpochStartTimestamp;\n\n  // `exchangeRate` at start of `currentEpoch`\n  uint256 public lastSetMintExchangeRate = 1e6;\n\n  /// @dev Mint/Redeem Limit Parameters\n  // Maximum amount that can be minted during an epoch\n  uint256 public mintLimit;\n\n  // Amount already minted during the `currentEpoch`\n  uint256 public currentMintAmount;\n\n  // Maximum amount that can be redeemed during an epoch\n  uint256 public redeemLimit;\n\n  // Amount already redeemed during the `currentEpoch`\n  uint256 public currentRedeemAmount;\n\n  /// @dev Role Based Access control members\n  bytes32 public constant MANAGER_ADMIN = keccak256(\"MANAGER_ADMIN\");\n  bytes32 public constant PAUSER_ADMIN = keccak256(\"PAUSER_ADMIN\");\n  bytes32 public constant SETTER_ADMIN = keccak256(\"SETTER_ADMIN\");\n\n  /// @notice constructor\n  constructor(\n    address _collateral,\n    address _cash,\n    address managerAdmin,\n    address pauser,\n    address _assetRecipient,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _mintLimit,\n    uint256 _redeemLimit,\n    uint256 _epochDuration,\n    address _kycRegistry,\n    uint256 _kycRequirementGroup\n  ) KYCRegistryClientConstructable(_kycRegistry, _kycRequirementGroup) {\n    if (_collateral == address(0)) {\n      revert CollateralZeroAddress();\n    }\n    if (_cash == address(0)) {\n      revert CashZeroAddress();\n    }\n    if (_assetRecipient == address(0)) {\n      revert AssetRecipientZeroAddress();\n    }\n    if (_assetSender == address(0)) {\n      revert AssetSenderZeroAddress();\n    }\n    if (_feeRecipient == address(0)) {\n      revert FeeRecipientZeroAddress();\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, managerAdmin);\n    _grantRole(MANAGER_ADMIN, managerAdmin);\n    _setRoleAdmin(PAUSER_ADMIN, MANAGER_ADMIN);\n    _setRoleAdmin(SETTER_ADMIN, MANAGER_ADMIN);\n    _grantRole(PAUSER_ADMIN, pauser);\n\n    collateral = IERC20(_collateral);\n    cash = Cash(_cash);\n    feeRecipient = _feeRecipient;\n    assetRecipient = _assetRecipient;\n    assetSender = _assetSender;\n    currentEpoch = currentEpoch;\n\n    mintLimit = _mintLimit;\n    redeemLimit = _redeemLimit;\n    epochDuration = _epochDuration;\n\n    currentEpochStartTimestamp =\n      block.timestamp -\n      (block.timestamp % epochDuration);\n\n    // Implicit constraint: cash decimals >= collateral decimals.\n    decimalsMultiplier =\n      10 **\n        (IERC20Metadata(_cash).decimals() -\n          IERC20Metadata(_collateral).decimals());\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            Mint Logic\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Function used by users to submit a request to mint\n   *\n   * @param collateralAmountIn The amount of collateral one wishes to deposit\n   *                           to mint CASH tokens\n   */\n  function requestMint(\n    uint256 collateralAmountIn\n  )\n    external\n    override\n    updateEpoch\n    nonReentrant\n    whenNotPaused\n    checkKYC(msg.sender)\n  {\n    if (collateralAmountIn < minimumDepositAmount) {\n      revert MintRequestAmountTooSmall();\n    }\n\n    uint256 feesInCollateral = _getMintFees(collateralAmountIn);\n    uint256 depositValueAfterFees = collateralAmountIn - feesInCollateral;\n\n    _checkAndUpdateMintLimit(depositValueAfterFees);\n\n    collateral.safeTransferFrom(msg.sender, feeRecipient, feesInCollateral);\n    collateral.safeTransferFrom(\n      msg.sender,\n      assetRecipient,\n      depositValueAfterFees\n    );\n\n    mintRequestsPerEpoch[currentEpoch][msg.sender] += depositValueAfterFees;\n\n    emit MintRequested(\n      msg.sender,\n      currentEpoch,\n      collateralAmountIn,\n      depositValueAfterFees,\n      feesInCollateral\n    );\n  }\n\n  /**\n   * @notice Function used by users to claim an airdrop for a given epoch\n   *\n   * @param user       The user who requested to mint\n   * @param epochToClaim The epoch in which the mint was requested\n   *\n   * @dev We perform KYC check on the user destined to receive `cash`, not the\n   *      msg.sender\n   */\n  function claimMint(\n    address user,\n    uint256 epochToClaim\n  ) external override updateEpoch nonReentrant whenNotPaused checkKYC(user) {\n    uint256 collateralDeposited = mintRequestsPerEpoch[epochToClaim][user];\n    if (collateralDeposited == 0) {\n      revert NoCashToClaim();\n    }\n    if (epochToExchangeRate[epochToClaim] == 0) {\n      revert ExchangeRateNotSet();\n    }\n\n    // Get the amount of CASH due at a given rate per epoch\n    uint256 cashOwed = _getMintAmountForEpoch(\n      collateralDeposited,\n      epochToClaim\n    );\n\n    mintRequestsPerEpoch[epochToClaim][user] = 0;\n    cash.mint(user, cashOwed);\n\n    emit MintCompleted(\n      user,\n      cashOwed,\n      collateralDeposited,\n      epochToExchangeRate[epochToClaim],\n      epochToClaim\n    );\n  }\n\n  /**\n   * @notice Sets mint exchange rate\n   *\n   * @param exchangeRate New mint exchange rate (in 6 decimals)\n   * @param epochToSet   The epoch we want to set the exchange rate for\n   *\n   * @dev If the exchange rate differs more than `exchangeRateDeltaLimit`\n   *      from the last exchange rate set, the entire contract will be paused.\n   *      See `overrideExchangeRate` should this check need to be bypassed\n   */\n  function setMintExchangeRate(\n    uint256 exchangeRate,\n    uint256 epochToSet\n  ) external override updateEpoch onlyRole(SETTER_ADMIN) {\n    if (exchangeRate == 0) {\n      revert ZeroExchangeRate();\n    }\n    if (epochToSet >= currentEpoch) {\n      revert EpochNotElapsed();\n    }\n    if (epochToExchangeRate[epochToSet] != 0) {\n      revert EpochExchangeRateAlreadySet();\n    }\n\n    uint256 rateDifference;\n    if (exchangeRate > lastSetMintExchangeRate) {\n      rateDifference = exchangeRate - lastSetMintExchangeRate;\n    } else if (exchangeRate < lastSetMintExchangeRate) {\n      rateDifference = lastSetMintExchangeRate - exchangeRate;\n    }\n\n    uint256 maxDifferenceThisEpoch = (lastSetMintExchangeRate *\n      exchangeRateDeltaLimit) / BPS_DENOMINATOR;\n\n    if (rateDifference > maxDifferenceThisEpoch) {\n      epochToExchangeRate[epochToSet] = exchangeRate;\n      _pause();\n      emit MintExchangeRateCheckFailed(\n        epochToSet,\n        lastSetMintExchangeRate,\n        exchangeRate\n      );\n    } else {\n      uint256 oldExchangeRate = lastSetMintExchangeRate;\n      epochToExchangeRate[epochToSet] = exchangeRate;\n      lastSetMintExchangeRate = exchangeRate;\n      emit MintExchangeRateSet(epochToSet, oldExchangeRate, exchangeRate);\n    }\n  }\n\n  /**\n   * @notice Override admin function for changing the representation of the\n   *         amount of collateral a user has deposited to kick off minting\n   *         process\n   *\n   * @param user       The user whose balance is being set\n   * @param epoch      The epoch in which to set user balance for\n   * @param oldBalance The user's previous balance\n   * @param newBalance The user's new balance to set\n   *\n   * @dev The total burned amount for the epoch must be set appropriately\n   *      in order to correctly calculate redemptions.\n   * @dev `oldBalance` is provided to prevent front running attacks where a\n   *      user could attempt to claim before and after this is set.\n   */\n  function setPendingMintBalance(\n    address user,\n    uint256 epoch,\n    uint256 oldBalance,\n    uint256 newBalance\n  ) external updateEpoch onlyRole(MANAGER_ADMIN) {\n    if (oldBalance != mintRequestsPerEpoch[epoch][user]) {\n      revert UnexpectedMintBalance();\n    }\n    if (epoch > currentEpoch) {\n      revert CannotServiceFutureEpoch();\n    }\n    mintRequestsPerEpoch[epoch][user] = newBalance;\n    emit PendingMintBalanceSet(user, epoch, oldBalance, newBalance);\n  }\n\n  /**\n   * @notice Allows for the `MANAGER_ADMIN` to arbitrarily set an exchange\n   *         rate for a given epoch\n   *\n   * @param correctExchangeRate      The exchange rate we wish to update to\n   * @param epochToSet               The epoch for which we want to set the rate\n   * @param _lastSetMintExchangeRate Value to set `lastSetMintExchangeRate` to\n   *                                 if not equal to 0\n   *\n   * @dev This function allows the caller to also update the\n   *      `lastSetMintExchangeRate`, which is compared against\n   *      when calling `setMintExchangeRate` to prevent large\n   *      swings in prices.\n   */\n  function overrideExchangeRate(\n    uint256 correctExchangeRate,\n    uint256 epochToSet,\n    uint256 _lastSetMintExchangeRate\n  ) external override updateEpoch onlyRole(MANAGER_ADMIN) {\n    if (epochToSet >= currentEpoch) {\n      revert MustServicePastEpoch();\n    }\n    uint256 incorrectRate = epochToExchangeRate[epochToSet];\n    epochToExchangeRate[epochToSet] = correctExchangeRate;\n    if (_lastSetMintExchangeRate != 0) {\n      lastSetMintExchangeRate = _lastSetMintExchangeRate;\n    }\n    emit MintExchangeRateOverridden(\n      epochToSet,\n      incorrectRate,\n      correctExchangeRate,\n      lastSetMintExchangeRate\n    );\n  }\n\n  /**\n   * @notice Sets mint exchange rate delta limit\n   *\n   * @param _exchangeRateDeltaLimit New mint exchange rate delta limit (in bps)\n   */\n  function setMintExchangeRateDeltaLimit(\n    uint256 _exchangeRateDeltaLimit\n  ) external override onlyRole(MANAGER_ADMIN) {\n    uint256 oldExchangeRateDeltaLimit = exchangeRateDeltaLimit;\n    exchangeRateDeltaLimit = _exchangeRateDeltaLimit;\n    emit ExchangeRateDeltaLimitSet(\n      oldExchangeRateDeltaLimit,\n      _exchangeRateDeltaLimit\n    );\n  }\n\n  /**\n   * @notice Sets mint fee\n   *\n   * @param _mintFee new mint fee specified in basis points\n   *\n   * @dev The maximum fee that can be set is 10_000 bps, or 100%\n   */\n  function setMintFee(\n    uint256 _mintFee\n  ) external override onlyRole(MANAGER_ADMIN) {\n    if (_mintFee >= BPS_DENOMINATOR) {\n      revert MintFeeTooLarge();\n    }\n    uint256 oldMintFee = mintFee;\n    mintFee = _mintFee;\n    emit MintFeeSet(oldMintFee, _mintFee);\n  }\n\n  /**\n   * @notice Sets minimum deposit amount\n   *\n   * @param _minimumDepositAmount New minimum deposit amount\n   *                              (in decimals specified by `collateral`)\n   *\n   * @dev Must be larger than BPS_DENOMINATOR due to keep our `_getMintFees`\n   *      calculation correct. For example, if a deposit amount is less than\n   *      BPS_DENOMINAOR (say 9999) and `mintFee` = 1,\n   *      (collateralAmount * mintFee) / BPS_DENOMINATOR will incorrectly\n   *      return 0.\n   */\n  function setMinimumDepositAmount(\n    uint256 _minimumDepositAmount\n  ) external override onlyRole(MANAGER_ADMIN) {\n    if (_minimumDepositAmount < BPS_DENOMINATOR) {\n      revert MinimumDepositAmountTooSmall();\n    }\n    uint256 oldMinimumDepositAmount = minimumDepositAmount;\n    minimumDepositAmount = _minimumDepositAmount;\n    emit MinimumDepositAmountSet(\n      oldMinimumDepositAmount,\n      _minimumDepositAmount\n    );\n  }\n\n  /**\n   * @notice Sets fee recipient\n   *\n   * @param _feeRecipient New fee recipient address\n   */\n  function setFeeRecipient(\n    address _feeRecipient\n  ) external override onlyRole(MANAGER_ADMIN) {\n    address oldFeeRecipient = feeRecipient;\n    feeRecipient = _feeRecipient;\n    emit FeeRecipientSet(oldFeeRecipient, _feeRecipient);\n  }\n\n  /**\n   * @notice Sets asset recipient\n   *\n   * @param _assetRecipient New asset recipient address\n   */\n  function setAssetRecipient(\n    address _assetRecipient\n  ) external override onlyRole(MANAGER_ADMIN) {\n    address oldAssetRecipient = assetRecipient;\n    assetRecipient = _assetRecipient;\n    emit AssetRecipientSet(oldAssetRecipient, _assetRecipient);\n  }\n\n  /**\n   * @notice Given amount of `collateral`, returns how much CASH should be\n   *         minted\n   *\n   * @param collateralAmountIn Amount of `collateral` to exchange\n   *                           (in 18 decimals)\n   * @param epoch              The epoch we want to set the rate\n   *                           for\n   *\n   * @return cashAmountOut The amount of cash to be returned\n   *\n   * @dev Scales to 24 decimals to divide by exchange rate in 6 decimals,\n   *      bringing us down to 18 decimals of precision\n   */\n  function _getMintAmountForEpoch(\n    uint256 collateralAmountIn,\n    uint256 epoch\n  ) private view returns (uint256 cashAmountOut) {\n    uint256 amountE24 = _scaleUp(collateralAmountIn) * 1e6;\n    cashAmountOut = amountE24 / epochToExchangeRate[epoch];\n  }\n\n  /**\n   * @notice Given amount of `collateral`, returns how\n   *\n   *\n   * @param collateralAmount Amount `collateral` to exchange\n   *                         (in decimals of `collateral`)\n   */\n  function _getMintFees(\n    uint256 collateralAmount\n  ) private view returns (uint256) {\n    return (collateralAmount * mintFee) / BPS_DENOMINATOR;\n  }\n\n  /**\n   * @notice Scale provided amount up by `decimalsMultiplier`\n   *\n   * @dev This helper is used for converting the collateral's decimals\n   *      representation to the CASH amount decimals representation.\n   */\n  function _scaleUp(uint256 amount) private view returns (uint256) {\n    return amount * decimalsMultiplier;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            Pause Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Will pause minting functionality of this contract\n   *\n   */\n  function pause() external onlyRole(PAUSER_ADMIN) {\n    _pause();\n  }\n\n  /**\n   * @notice Will unpause minting functionality of this contract\n   */\n  function unpause() external onlyRole(MANAGER_ADMIN) {\n    _unpause();\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    Epoch and Rate Limiting Logic\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Update the duration of one epoch\n   *\n   * @param _epochDuration The epoch duration in seconds\n   */\n  function setEpochDuration(\n    uint256 _epochDuration\n  ) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldEpochDuration = epochDuration;\n    epochDuration = _epochDuration;\n    emit EpochDurationSet(oldEpochDuration, _epochDuration);\n  }\n\n  /**\n   * @notice Modifier to transition epoch\n   */\n  modifier updateEpoch() {\n    transitionEpoch();\n    _;\n  }\n\n  /**\n   * @notice Transition to another epoch\n   *\n   * @dev Should be called prior to `_checkAndUpdateRedeemLimit`\n   *      and `_checkAndUpdateMintLimit`\n   * @dev Epochs do not always have to be incremented by 1\n   *\n   * @notice If this function determines to transition the epoch\n   *         1) The total supply at the end of the epoch is stored\n   *         2) `currentRedeemAmount` & `currentMintAmount` are set to 0\n   *         3) `currentEpoch` is incremented by number of epochs that\n   *            have elapsed\n   *         4) `currentEpochStartTimestamp` is set.\n   */\n  function transitionEpoch() public {\n    uint256 epochDifference = (block.timestamp - currentEpochStartTimestamp) /\n      epochDuration;\n    if (epochDifference > 0) {\n      currentRedeemAmount = 0;\n      currentMintAmount = 0;\n      currentEpoch += epochDifference;\n      currentEpochStartTimestamp =\n        block.timestamp -\n        (block.timestamp % epochDuration);\n    }\n  }\n\n  /**\n   * @notice Update the amount of token that can be minted during one epoch\n   *\n   * @param _mintLimit The token amount\n   *\n   * @dev If a limit is zero, the relevant check always fails.\n   */\n  function setMintLimit(uint256 _mintLimit) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldMintLimit = mintLimit;\n    mintLimit = _mintLimit;\n    emit MintLimitSet(oldMintLimit, _mintLimit);\n  }\n\n  /**\n   * @notice Update the amount of token that can be redeemed during one epoch\n   *\n   * @param _redeemLimit The token amount\n   *\n   * @dev If a limit is zero, the relevant check always fails.\n   */\n  function setRedeemLimit(\n    uint256 _redeemLimit\n  ) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldRedeemLimit = redeemLimit;\n    redeemLimit = _redeemLimit;\n    emit RedeemLimitSet(oldRedeemLimit, _redeemLimit);\n  }\n\n  /**\n   * @notice Checks the requested mint amount against the rate limiter\n   *\n   * @param collateralAmountIn The requested mint amount\n   *\n   * @dev Reverts if the requested mint amount exceeds the current limit\n   * @dev Should only be called w/n functions w/ `updateEpoch` modifier\n   */\n  function _checkAndUpdateMintLimit(uint256 collateralAmountIn) private {\n    if (collateralAmountIn > mintLimit - currentMintAmount) {\n      revert MintExceedsRateLimit();\n    }\n\n    currentMintAmount += collateralAmountIn;\n  }\n\n  /**\n   * @notice Checks the requested redeem amount against the rate limiter\n   *\n   * @param amount The requested redeem amount\n   *\n   * @dev Reverts if the requested redeem amount exceeds the current limit\n   * @dev Should only be called w/n function w/ `updateEpoch` modifier\n   */\n  function _checkAndUpdateRedeemLimit(uint256 amount) private {\n    if (amount == 0) {\n      revert RedeemAmountCannotBeZero();\n    }\n    if (amount > redeemLimit - currentRedeemAmount) {\n      revert RedeemExceedsRateLimit();\n    }\n\n    currentRedeemAmount += amount;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          Redeem Logic\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Adds a RedemptionRequests member to the current epoch array &\n   *         burns tokens\n   *\n   * @param amountCashToRedeem The requested redeem amount\n   */\n  function requestRedemption(\n    uint256 amountCashToRedeem\n  )\n    external\n    override\n    updateEpoch\n    nonReentrant\n    whenNotPaused\n    checkKYC(msg.sender)\n  {\n    if (amountCashToRedeem < minimumRedeemAmount) {\n      revert WithdrawRequestAmountTooSmall();\n    }\n\n    _checkAndUpdateRedeemLimit(amountCashToRedeem);\n\n    redemptionInfoPerEpoch[currentEpoch].addressToBurnAmt[\n        msg.sender\n      ] += amountCashToRedeem;\n    redemptionInfoPerEpoch[currentEpoch].totalBurned += amountCashToRedeem;\n\n    cash.burnFrom(msg.sender, amountCashToRedeem);\n\n    emit RedemptionRequested(msg.sender, amountCashToRedeem, currentEpoch);\n  }\n\n  /**\n   * @notice Allows for an admin account to distribute collateral to users\n   *         based off of the total amount of cash tokens burned w/n a given\n   *         epoch. This function also allows for an admin to refund redemption\n   *         requests w/n an epoch provided that the redemption cannot be\n   *         serviced\n   *\n   * @param redeemers              List of addresses to which we want to\n   *                               issue redemptions to\n   * @param refundees              List of addresses to which we want to issue\n   *                               refunds to in the form of cash tokens\n   * @param collateralAmountToDist The total amount to distribute for redemptions\n   *                               including fees to accrue to Ondo\n   *                               (In units of collateral)\n   * @param epochToService         The epoch number we wish to issue redemptions/\n   *                               refunds for\n   * @param fees                   The amount of fees to send to Ondo\n   *                               (In units of collateral)\n   */\n  function completeRedemptions(\n    address[] calldata redeemers,\n    address[] calldata refundees,\n    uint256 collateralAmountToDist,\n    uint256 epochToService,\n    uint256 fees\n  ) external override updateEpoch onlyRole(MANAGER_ADMIN) {\n    _checkAddressesKYC(redeemers);\n    _checkAddressesKYC(refundees);\n    if (epochToService >= currentEpoch) {\n      revert MustServicePastEpoch();\n    }\n    // Calculate the total quantity of shares tokens burned w/n an epoch\n    uint256 refundedAmt = _processRefund(refundees, epochToService);\n    uint256 quantityBurned = redemptionInfoPerEpoch[epochToService]\n      .totalBurned - refundedAmt;\n    uint256 amountToDist = collateralAmountToDist - fees;\n    _processRedemption(redeemers, amountToDist, quantityBurned, epochToService);\n    collateral.safeTransferFrom(assetSender, feeRecipient, fees);\n    emit RedemptionFeesCollected(feeRecipient, fees, epochToService);\n  }\n\n  /**\n   * @notice Will iterate over the array of `addressToWithdraw` calculate\n   *         the proportion of burned tokens w/n a given epoch and will\n   *         then distribute collateral based off this % of burned tokens\n   *\n   * @param redeemers      List of addresses we are issuing redemptions too\n   * @param amountToDist   The amount to distribute to clients minus the\n   *                       the fee amount taken by Ondo\n   * @param quantityBurned The total amount of tokens burned in an epoch\n   *                       minus those burned by users who are issued a\n   *                       refund\n   * @param epochToService The epoch we wish to service redemptions and\n   *                       redemptions for\n   */\n  function _processRedemption(\n    address[] calldata redeemers,\n    uint256 amountToDist,\n    uint256 quantityBurned,\n    uint256 epochToService\n  ) private {\n    uint256 size = redeemers.length;\n    for (uint256 i = 0; i < size; ++i) {\n      address redeemer = redeemers[i];\n      uint256 cashAmountReturned = redemptionInfoPerEpoch[epochToService]\n        .addressToBurnAmt[redeemer];\n      redemptionInfoPerEpoch[epochToService].addressToBurnAmt[redeemer] = 0;\n      uint256 collateralAmountDue = (amountToDist * cashAmountReturned) /\n        quantityBurned;\n\n      if (collateralAmountDue == 0) {\n        revert CollateralRedemptionTooSmall();\n      }\n\n      collateral.safeTransferFrom(assetSender, redeemer, collateralAmountDue);\n      emit RedemptionCompleted(\n        redeemer,\n        cashAmountReturned,\n        collateralAmountDue,\n        epochToService\n      );\n    }\n  }\n\n  /**\n   * @notice Iterates over the array of `addressToRefund` and mint them\n   *         back the same quantity of cash tokens burned.\n   *\n   * @param refundees      List of addresses we are issuing refunds for\n   * @param epochToService The epoch we wish to service redemptions for\n   *\n   * @return totalCashAmountRefunded The total amount of cash refunded for `epochToService`.\n   */\n  function _processRefund(\n    address[] calldata refundees,\n    uint256 epochToService\n  ) private returns (uint256 totalCashAmountRefunded) {\n    uint256 size = refundees.length;\n    for (uint256 i = 0; i < size; ++i) {\n      address refundee = refundees[i];\n      uint256 cashAmountBurned = redemptionInfoPerEpoch[epochToService]\n        .addressToBurnAmt[refundee];\n      redemptionInfoPerEpoch[epochToService].addressToBurnAmt[refundee] = 0;\n      cash.mint(refundee, cashAmountBurned);\n      totalCashAmountRefunded += cashAmountBurned;\n      emit RefundIssued(refundee, cashAmountBurned, epochToService);\n    }\n    return totalCashAmountRefunded;\n  }\n\n  /**\n   * @notice will change the `assetSender` variable\n   *\n   * @param newAssetSender The address we wish to change `assetSender` too\n   */\n  function setAssetSender(\n    address newAssetSender\n  ) external onlyRole(MANAGER_ADMIN) {\n    address oldAssetSender = assetSender;\n    assetSender = newAssetSender;\n    emit AssetSenderSet(oldAssetSender, newAssetSender);\n  }\n\n  /**\n   * @notice Allows for `MANAGER_ADMIN` to set a new `minimumRedeemAmount`\n   *\n   * @param newRedeemMinimum The new minimum redemption amount\n   *                         in units of 1e18\n   */\n  function setRedeemMinimum(\n    uint256 newRedeemMinimum\n  ) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldRedeemMin = minimumRedeemAmount;\n    minimumRedeemAmount = newRedeemMinimum;\n    emit MinimumRedeemAmountSet(oldRedeemMin, minimumRedeemAmount);\n  }\n\n  /**\n   * @notice Custom view function to return the quantity burned by\n   *         an address w/n a given epoch.\n   *\n   * @param epoch The epoch we want to query\n   * @param user  The user we want to know the burned quantity\n   *              of cash tokens for in a given epoch\n   */\n  function getBurnedQuantity(\n    uint256 epoch,\n    address user\n  ) external view returns (uint256) {\n    return redemptionInfoPerEpoch[epoch].addressToBurnAmt[user];\n  }\n\n  /**\n   * @notice Override admin function for changing the representation of the\n   *         amount of CASH a user has burned to kick off redemption process\n   *\n   * @param user    The user whose balance is being set\n   * @param epoch   The epoch in which to set user balance for\n   * @param balance The user's new balance\n   *\n   * @dev The total burned amount for the epoch must be set appropriately\n   *      in order to correctly calculate redemptions.\n   */\n  function setPendingRedemptionBalance(\n    address user,\n    uint256 epoch,\n    uint256 balance\n  ) external updateEpoch onlyRole(MANAGER_ADMIN) {\n    if (epoch > currentEpoch) {\n      revert CannotServiceFutureEpoch();\n    }\n    uint256 previousBalance = redemptionInfoPerEpoch[epoch].addressToBurnAmt[\n      user\n    ];\n    // Increment or decrement total burned for the epoch based on whether we\n    // are increasing or decreasing the balance.\n    if (balance < previousBalance) {\n      redemptionInfoPerEpoch[epoch].totalBurned -= previousBalance - balance;\n    } else if (balance > previousBalance) {\n      redemptionInfoPerEpoch[epoch].totalBurned += balance - previousBalance;\n    }\n    redemptionInfoPerEpoch[epoch].addressToBurnAmt[user] = balance;\n    emit PendingRedemptionBalanceSet(\n      user,\n      epoch,\n      balance,\n      redemptionInfoPerEpoch[epoch].totalBurned\n    );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           KYC FUNCTIONS\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Modifier to check KYC status of an account\n   */\n  modifier checkKYC(address account) {\n    _checkKYC(account);\n    _;\n  }\n\n  /**\n   * @notice Update KYC group of the contract for which\n   *         accounts are checked against\n   *\n   * @param _kycRequirementGroup The new KYC requirement group\n   */\n  function setKYCRequirementGroup(\n    uint256 _kycRequirementGroup\n  ) external override onlyRole(MANAGER_ADMIN) {\n    _setKYCRequirementGroup(_kycRequirementGroup);\n  }\n\n  /**\n   * @notice Update KYC registry address\n   *\n   * @param _kycRegistry The new KYC registry address\n   */\n  function setKYCRegistry(\n    address _kycRegistry\n  ) external override onlyRole(MANAGER_ADMIN) {\n    _setKYCRegistry(_kycRegistry);\n  }\n\n  /**\n   * @notice Private function to check KYC status\n   *         of an address\n   *\n   * @param account The account to check KYC status for\n   */\n  function _checkKYC(address account) private view {\n    if (!_getKYCStatus(account)) {\n      revert KYCCheckFailed();\n    }\n  }\n\n  /**\n   * @notice Private function to check KYC status\n   *         of an array of addresses\n   *\n   * @param accounts The accounts to check KYC status for\n   */\n  function _checkAddressesKYC(address[] calldata accounts) private view {\n    uint256 size = accounts.length;\n    for (uint256 i = 0; i < size; ++i) {\n      _checkKYC(accounts[i]);\n    }\n  }\n\n  /**\n   * @notice Allows for arbitrary batched calls\n   *\n   * @dev All external calls made through this function will\n   *      msg.sender == contract address\n   *\n   * @param exCallData Struct consisting of\n   *       1) target - contract to call\n   *       2) data - data to call target with\n   *       3) value - eth value to call target with\n   */\n  function multiexcall(\n    ExCallData[] calldata exCallData\n  )\n    external\n    payable\n    override\n    nonReentrant\n    onlyRole(MANAGER_ADMIN)\n    whenPaused\n    returns (bytes[] memory results)\n  {\n    results = new bytes[](exCallData.length);\n    for (uint256 i = 0; i < exCallData.length; ++i) {\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\n        value: exCallData[i].value\n      }(exCallData[i].data);\n      require(success, \"Call Failed\");\n      results[i] = ret;\n    }\n  }\n}"
    },
    {
      "filename": "contracts/cash/CashManager.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\nimport \"contracts/cash/interfaces/ICashManager.sol\";\nimport \"contracts/cash/interfaces/IMulticall.sol\";\nimport \"contracts/cash/token/Cash.sol\";\nimport \"contracts/cash/kyc/KYCRegistryClientConstructable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/security/Pausable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/token/IERC20.sol\";\nimport \"contracts/cash/external/openzeppelin/c"
    }
  ]
}