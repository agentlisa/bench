{
  "Title": "H-2: Adversary can economically exploit wstETHLiquidityVault",
  "Content": "# Issue H-2: Adversary can economically exploit wstETHLiquidityVault \n\nSource: https://github.com/sherlock-audit/2023-02-olympus-judging/issues/110 \n\n## Found by \nBahurum, Bobface, KingNFT, cducrest-brainbot, 0x52, immeas\n\n## Summary\n\nAdversary can profit off of the single sided liquidity vault by depositing, buying OHM, withdrawing then dumping the profited OHM. This attack remains profitable regardless of the value of `THRESHOLD`.\n\n## Vulnerability Detail\n\nSingleSidedLiquidityVault#deposit allows a user to specify the amount of wstETH they wish to deposit into the vault. The vault then mints the proper amount of OHM to match this, then deposits both into the wstETH/OHM liquidity pool on Balancer. If the price of OHM changes between deposit and withdrawal, the vault will effectively eat the IL caused by the movement. If the price decreases then the vault will burn more OHM than minted. If the price increases then the vault will burn less OHM than minted. This discrepancy can be exploited by malicious users to profit at the expense of the vault.\n\nFirst we will outline the flow of the attack then run through the numbers:\n1. Deposit wstETH, which causes the vault to mint OHM as a counter-asset\n2. Buy OHM from the liquidity pool making sure to not go outside the price threshold to trigger the isPoolSafe check\n3. Withdraw wstETH\n4. Sell acquired OHM for a profit\n\nNow we can crunch the numbers to prove that this is profitable:\n\nThe only assumption we need to make is the price of OHM/wstETH which for simplicity we will assume is 1:1.\n\nBalances before attack:\nLiquidity: 80 OHM 80 wstETH\nAdversary: 20 wstETH\n\nBalances after adversary has deposited to the pool:\nLiquidity: 100 OHM 100 wstETH\nAdversary: 0 wstETH\n\nBalances after adversary sells wstETH for OHM (1% movement in price):\nLiquidity: 99.503 OHM 100.498 wstETH\nAdversary: 0.496 OHM -0.498 wstETH\n\nBalances after adversary removes their liquidity:\nLiquidity: 79.602 OHM 80.399 wstETH\nAdversary: 0.496 OHM 19.7 wstETH \n\nBalances after selling profited OHM:\nLiquidity: 80.099 OHM 79.9 wstETH \nAdversary: 20.099 wstETH\n\nWe can see that the adversary will gain wstETH for each time they loop this through attack. The profit being made i For simplicity I have only walked through a single direction attack but the adversary could easily drop the price to the lower threshold then start the attack to gain a larger amount of wstETH.\n\nNo matter how tight the threshold is set it is impossible to make this kind of attack unprofitable. Tighter thresholds just increases the amount of capital required to make it profitable. Another issue is that the THRESHOLD value can only get so small before the it starts causing random reverts for legitimate users.\n\nFor additional context, the fee charged by the pool only slightly impacts the profitability of this attack. Since the attacker only needs to manipulate the price within the threshold, fees scale linearly with THRESHOLD and therefore don't change the profitability of the attack.\n\n## Impact\n\nVault can be exploited for a nearly unlimited amount of OHM\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L187-L244\n\n## Tool used\n\nChatGPT\n\n## Recommendation\n\nThe only mechanism I can think of to prevent this is to add a withdraw/deposit fee to the vault\n\n## Discussion\n\n**unbanksy**\n\nThe auditor incorrectly assumes that the user receives OHM on withdraw:\n\n```\nBalances after adversary sells wstETH for OHM (1% movement in price):\nLiquidity: 99.503 OHM 100.498 wstETH\nAdversary: 0.496 OHM -0.498 wstETH\n``` \n\nThat is not the case as the OHM is burned by the protocol. @0xLienid right?\n\n**0xLienid**\n\n@unbanksy I don't think that's the assumption the auditor is making. Based on their math it seems they recognize that the user only gets the wstETH portion back based on these steps:\n\n```\nBalances after adversary sells wstETH for OHM (1% movement in price):\nLiquidity: 99.503 OHM 100.498 wstETH\nAdversary: 0.496 OHM -0.498 wstETH\n\nBalances after adversary removes their liquidity:\nLiquidity: 79.602 OHM 80.399 wstETH\nAdversary: 0.496 OHM 19.7 wstETH\n```\n\nI think the \"Balances after adversary removes their liquidity\" step might be wrong and the adversary should end up with 19.6016 wstETH which would make this not really profitable.\n\n**IAm0x52**\n\n@0xLienid The 19.7 is a typo. When they withdraw they get 20.0996 which makes their net 19.6016. So it should read 19.6 at that step not 19.7. When the user sells their OHM they net 0.499 stETH so the final balance is correct at 20.099 (19.6+0.499) and the attack is profitable. \n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/50",
  "Code": [
    {
      "filename": "src/policies/lending/abstracts/SingleSidedLiquidityVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system dependencies\nimport {MINTRv1} from \"src/modules/MINTR/MINTR.v1.sol\";\nimport {LQREGv1} from \"src/modules/LQREG/LQREG.v1.sol\";\nimport {ROLESv1, RolesConsumer} from \"src/modules/ROLES/OlympusRoles.sol\";\nimport \"src/Kernel.sol\";\n\n// Import external dependencies\nimport {AggregatorV3Interface} from \"src/interfaces/AggregatorV2V3Interface.sol\";\n\n// Import internal dependencies\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\n// Import types\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {OlympusERC20Token} from \"src/external/OlympusERC20.sol\";\n\n// Import utilities\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\n\n/// @title  Olympus Base Single Sided Liquidity Vault Contract\n/// @dev    Some caveats around this contract:\n///         - No internal reward token should also be an external reward token\n///         - No pair token should also be an external reward token\n///         - No pair, internal reward, or external reward tokens should be ERC777s or non-standard ERC20s\nabstract contract SingleSidedLiquidityVault is Policy, ReentrancyGuard, RolesConsumer {\n    using TransferHelper for ERC20;\n\n    // ========= ERRORS ========= //\n\n    error LiquidityVault_Inactive();\n    error LiquidityVault_StillActive();\n    error LiquidityVault_LimitViolation();\n    error LiquidityVault_PoolImbalanced();\n    error LiquidityVault_BadPriceFeed();\n    error LiquidityVault_InvalidRemoval();\n    error LiquidityVault_InvalidParams();\n\n    // ========= EVENTS ========= //\n\n    event Deposit(address indexed user, uint256 pairAmount, uint256 ohmMinted);\n    event Withdraw(address indexed user, uint256 pairAmount, uint256 ohmBurned);\n    event RewardsClaimed(address indexed user, address indexed token, uint256 amount);\n\n    // ========= DATA STRUCTURES ========= //\n\n    struct InternalRewardToken {\n        address token;\n        uint256 decimalsAdjustment;\n        uint256 rewardsPerSecond;\n        uint256 lastRewardTime;\n        uint256 accumulatedRewardsPerShare;\n    }\n\n    struct ExternalRewardToken {\n        address token;\n        uint256 decimalsAdjustment;\n        uint256 accumulatedRewardsPerShare;\n        uint256 lastBalance;\n    }\n\n    // ========= STATE ========= //\n\n    // Modules\n    MINTRv1 public MINTR;\n    LQREGv1 public LQREG;\n\n    // Tokens\n    OlympusERC20Token public ohm;\n    ERC20 public pairToken;\n\n    // Token Decimals\n    uint256 public pairTokenDecimals;\n\n    // Pool\n    address public liquidityPool;\n\n    // Aggregate Contract State\n    uint256 public totalLP;\n    uint256 public ohmMinted;\n    uint256 public ohmRemoved;\n    mapping(address => uint256) public accumulatedFees;\n\n    // User State\n    mapping(address => uint256) public pairTokenDeposits;\n    mapping(address => uint256) public lpPositions;\n    mapping(address => mapping(address => uint256)) public userRewardDebts; // Rewards accumulated prior to user's joining (MasterChef V2 math)\n    mapping(address => mapping(address => uint256)) public cachedUserRewards; // Rewards that have been accumulated but not claimed (avoids underflow errors)\n    mapping(address => bool) internal _hasDeposited; // Used to determine if a user has ever deposited\n    address[] public users; // Used to track users that have interacted with this contract (for migration in the event of a bug)\n\n    // Reward Token State\n    /// @notice An internal reward token is a token where the vault is the only source of rewards and the\n    ///         vault handles all accounting around how many reward tokens to distribute over time\n    InternalRewardToken[] public internalRewardTokens;\n\n    /// @notice An external reward token is a token where the primary accrual of reward tokens occurs outside\n    ///         the scope of this contract in a system like Convex or Aura. The vault is responsible for harvesting\n    ///         rewards back to the vault and then distributing them proportionally to users\n    ExternalRewardToken[] public externalRewardTokens;\n\n    // Exchange Name (used by frontend)\n    string public EXCHANGE;\n\n    // Configuration values\n    uint256 public LIMIT;\n    uint256 public THRESHOLD;\n    uint256 public FEE;\n    uint256 public constant PRECISION = 1000;\n    bool public isVaultActive;\n\n    //============================================================================================//\n    //                                      POLICY SETUP                                          //\n    //============================================================================================//\n\n    constructor(\n        Kernel kernel_,\n        address ohm_,\n        address pairToken_,\n        address liquidityPool_\n    ) Policy(kernel_) {\n        // Set tokens\n        ohm = OlympusERC20Token(ohm_);\n        pairToken = ERC20(pairToken_);\n\n        // Set token decimals\n        pairTokenDecimals = pairToken.decimals();\n\n        // Set pool\n        liquidityPool = liquidityPool_;\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](3);\n        dependencies[0] = toKeycode(\"MINTR\");\n        dependencies[1] = toKeycode(\"LQREG\");\n        dependencies[2] = toKeycode(\"ROLES\");\n\n        MINTR = MINTRv1(getModuleAddress(dependencies[0]));\n        LQREG = LQREGv1(getModuleAddress(dependencies[1]));\n        ROLES = ROLESv1(getModuleAddress(dependencies[2]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        Keycode mintrKeycode = MINTR.KEYCODE();\n        Keycode lqregKeycode = LQREG.KEYCODE();\n\n        permissions = new Permissions[](5);\n        permissions[0] = Permissions(mintrKeycode, MINTR.mintOhm.selector);\n        permissions[1] = Permissions(mintrKeycode, MINTR.burnOhm.selector);\n        permissions[2] = Permissions(mintrKeycode, MINTR.increaseMintApproval.selector);\n        permissions[3] = Permissions(lqregKeycode, LQREG.addVault.selector);\n        permissions[4] = Permissions(lqregKeycode, LQREG.removeVault.selector);\n    }\n\n    //============================================================================================//\n    //                                           MODIFIERS                                        //\n    //============================================================================================//\n\n    modifier onlyWhileActive() {\n        if (!isVaultActive) revert LiquidityVault_Inactive();\n        _;\n    }\n\n    //============================================================================================//\n    //                                       CORE FUNCTIONS                                       //\n    //============================================================================================//\n\n    /// @notice                 Deposits pair tokens, mints OHM against the deposited pair tokens, and deposits the\n    ///                         pair token and OHM into a liquidity pool and receives LP tokens in return\n    /// @param  amount_         The amount of pair tokens to deposit\n    /// @param  slippageParam_  Represents the slippage on joining the liquidity pool. Can either be the minimum LP token\n    ///                         amount to receive in the cases of Balancer or Curve, or can be a value (in thousandths) which\n    ///                         will be used to calculate the minimum amount of OHM and pair tokens to use in the case of Uniswap,\n    ///                         Sushiswap, Fraxswap, etc.\n    /// @dev                    This needs to be non-reentrant since the contract only knows the amount of LP tokens it\n    ///                         receives after an external interaction with the liquidity pool\n    function deposit(uint256 amount_, uint256 slippageParam_)\n        external\n        onlyWhileActive\n        nonReentrant\n        returns (uint256 lpAmountOut)\n    {\n        // If this is a new user, add them to the users array in case we need to migrate\n        // their state in the future\n        if (!_hasDeposited[msg.sender]) {\n            _hasDeposited[msg.sender] = true;\n            users.push(msg.sender);\n        }\n\n        // Calculate amount of OHM to borrow\n        uint256 ohmToBorrow = _valueCollateral(amount_);\n\n        // Cache pair token and OHM balance before deposit\n        uint256 pairTokenBalanceBefore = pairToken.balanceOf(address(this));\n        uint256 ohmBalanceBefore = ohm.balanceOf(address(this));\n\n        // The pool being imbalanced is less of a concern here on deposit than on withdrawal,\n        // but in the event the frontend miscalculates the expected LP amount to receive, we want\n        // to reduce the risk of entering a manipulated pool at a bad price\n        if (!_isPoolSafe()) revert LiquidityVault_PoolImbalanced();\n        if (!_canDeposit(ohmToBorrow)) revert LiquidityVault_LimitViolation();\n\n        _depositUpdateRewardState();\n\n        // Gather tokens for deposit\n        pairToken.safeTransferFrom(msg.sender, address(this), amount_);\n        _borrow(ohmToBorrow);\n\n        uint256 lpReceived = _deposit(ohmToBorrow, amount_, slippageParam_);\n\n        // Calculate amount of pair tokens and OHM unused in deposit\n        uint256 unusedPairToken = pairToken.balanceOf(address(this)) - pairTokenBalanceBefore;\n        uint256 unusedOhm = ohm.balanceOf(address(this)) - ohmBalanceBefore;\n\n        // Return unused pair tokens to user\n        if (unusedPairToken > 0) pairToken.safeTransfer(msg.sender, unusedPairToken);\n\n        // Burn unused OHM\n        if (unusedOhm > 0) _repay(unusedOhm);\n\n        uint256 pairTokenUsed = amount_ - unusedPairToken;\n        uint256 ohmUsed = ohmToBorrow - unusedOhm;\n\n        ohmMinted += ohmUsed;\n        totalLP += lpReceived;\n\n        pairTokenDeposits[msg.sender] += pairTokenUsed;\n        lpPositions[msg.sender] += lpReceived;\n\n        // Update user's reward debts\n        _depositUpdateRewardDebts(lpReceived);\n\n        emit Deposit(msg.sender, pairTokenUsed, ohmUsed);\n    }\n\n    /// @notice                     Withdraws pair tokens and OHM from a liquidity pool, returns any received pair tokens to the\n    ///                             user, and burns any received OHM\n    /// @param  lpAmount_           The amount of LP tokens to withdraw\n    /// @param  minTokenAmounts_    The minimum amounts of pair tokens and OHM to receive\n    /// @dev                        This needs to be non-reentrant since the contract only knows the amount of OHM and\n    ///                             pair tokens it receives after an external call to withdraw liquidity\n    function withdraw(\n        uint256 lpAmount_,\n        uint256[] calldata minTokenAmounts_,\n        bool claim_\n    ) external onlyWhileActive nonReentrant returns (uint256) {\n        // Liquidity vaults should always be built around a two token pool so we can assume\n        // the array will always have two elements\n        if (lpAmount_ == 0 || minTokenAmounts_[0] == 0 || minTokenAmounts_[1] == 0)\n            revert LiquidityVault_InvalidParams();\n        if (!_isPoolSafe()) revert LiquidityVault_PoolImbalanced();\n\n        _withdrawUpdateRewardState(lpAmount_, claim_);\n\n        totalLP -= lpAmount_;\n        lpPositions[msg.sender] -= lpAmount_;\n\n        // Withdraw OHM and pairToken from LP\n        (uint256 ohmReceived, uint256 pairTokenReceived) = _withdraw(lpAmount_, minTokenAmounts_);\n\n        // Reduce deposit values\n        uint256 userDeposit = pairTokenDeposits[msg.sender];\n        pairTokenDeposits[msg.sender] -= pairTokenReceived > userDeposit\n            ? userDeposit\n            : pairTokenReceived;\n        ohmMinted -= ohmReceived > ohmMinted ? ohmMinted : ohmReceived;\n        ohmRemoved += ohmReceived > ohmMinted ? ohmReceived - ohmMinted : 0;\n\n        // Return assets\n        _repay(ohmReceived);\n        pairToken.safeTransfer(msg.sender, pairTokenReceived);\n\n        emit Withdraw(msg.sender, pairTokenReceived, ohmReceived);\n        return pairTokenReceived;\n    }\n\n    /// @notice                     Claims user's rewards for all reward tokens\n    function claimRewards() external onlyWhileActive nonReentrant {\n        uint256 numInternalRewardTokens = internalRewardTokens.length;\n        uint256 numExternalRewardTokens = externalRewardTokens.length;\n\n        uint256[] memory accumulatedRewards = _accumulateExternalRewards();\n\n        for (uint256 i; i < numInternalRewardTokens; ) {\n            _claimInternalRewards(i);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        for (uint256 i; i < numExternalRewardTokens; ) {\n            _updateExternalRewardState(i, accumulatedRewards[i]);\n            _claimExternalRewards(i);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    //============================================================================================//\n    //                                       VIEW FUNCTIONS                                       //\n    //============================================================================================//\n\n    /// @notice                         Gets the max amount of pair tokens that can be deposited currently\n    /// @return uint256                 The max amount of pair tokens that can be deposited currently\n    function getMaxDeposit() public view returns (uint256) {\n        uint256 currentPoolOhmShare = _getPoolOhmShare();\n        uint256 emitted;\n\n        // Calculate max OHM mintable amount\n        if (ohmMinted > currentPoolOhmShare) emitted = ohmMinted - currentPoolOhmShare;\n        uint256 maxOhmAmount = LIMIT + ohmRemoved - ohmMinted - emitted;\n\n        // Convert max OHM mintable amount to pair token amount\n        uint256 ohmPerPairToken = _valueCollateral(1e18); // OHM per 1 pairToken\n        uint256 pairTokenDecimalAdjustment = 10**pairToken.decimals();\n        return (maxOhmAmount * pairTokenDecimalAdjustment) / ohmPerPairToken;\n    }\n\n    /// @notice                         Gets all users that have deposited into the vault\n    /// @return address[]               An array of all users that have deposited into the vault\n    function getUsers() public view returns (address[] memory) {\n        return users;\n    }\n\n    /// @notice                         Gets a list of all the internal reward tokens\n    /// @return InternalRewardToken[]   An array of all the internal reward tokens\n    function getInternalRewardTokens() public view returns (InternalRewardToken[] memory) {\n        return internalRewardTokens;\n    }\n\n    /// @notice                         Gets a list of all the external reward tokens\n    /// @return ExternalRewardToken[]   An array of all the external reward tokens\n    function getExternalRewardTokens() public view returns (ExternalRewardToken[] memory) {\n        return externalRewardTokens;\n    }\n\n    /// @notice                         Returns the amount of rewards a user has earned for a given reward token\n    /// @param  id_                     The ID of the reward token\n    /// @param  user_                   The user's address to check rewards for\n    /// @return uint256                 The amount of rewards the user has earned\n    function internalRewardsForToken(uint256 id_, address user_) public view returns (uint256) {\n        InternalRewardToken memory rewardToken = internalRewardTokens[id_];\n        uint256 lastRewardTime = rewardToken.lastRewardTime;\n        uint256 accumulatedRewardsPerShare = rewardToken.accumulatedRewardsPerShare;\n\n        if (block.timestamp > lastRewardTime && totalLP != 0) {\n            uint256 timeDiff = block.timestamp - lastRewardTime;\n            uint256 totalRewards = timeDiff * rewardToken.rewardsPerSecond;\n\n            // This correctly uses 1e18 because the LP tokens of all major DEXs have 18 decimals\n            accumulatedRewardsPerShare += (totalRewards * 1e18) / totalLP;\n        }\n\n        // This correctly uses 1e18 because the LP tokens of all major DEXs have 18 decimals\n        uint256 totalAccumulatedRewards = (lpPositions[user_] * accumulatedRewardsPerShare) -\n            userRewardDebts[user_][rewardToken.token];\n\n        return (cachedUserRewards[user_][rewardToken.token] + totalAccumulatedRewards) / 1e18;\n    }\n\n    /// @notice                         Returns the amount of rewards a user has earned for a given external reward token\n    /// @param  id_                     The ID of the external reward token\n    /// @param  user_                   The user's address to check rewards for\n    /// @return uint256                 The amount of rewards the user has earned\n    function externalRewardsForToken(uint256 id_, address user_) public view returns (uint256) {\n        ExternalRewardToken memory rewardToken = externalRewardTokens[id_];\n\n        // This correctly uses 1e18 because the LP tokens of all major DEXs have 18 decimals\n        uint256 totalAccumulatedRewards = (lpPositions[user_] *\n            rewardToken.accumulatedRewardsPerShare) - userRewardDebts[user_][rewardToken.token];\n\n        return (cachedUserRewards[user_][rewardToken.token] + totalAccumulatedRewards) / 1e18;\n    }\n\n    /// @notice                         Calculates the net amount of OHM that this contract has emitted to or removed from the broader market\n    /// @return emitted                 The amount of OHM that this contract has emitted to the broader market\n    /// @return removed                 The amount of OHM that this contract has removed from the broader market\n    /// @dev                            This is based on a point-in-time snapshot of the liquidity pool's current OHM balance\n    function getOhmEmissions() external view returns (uint256 emitted, uint256 removed) {\n        uint256 currentPoolOhmShare = _getPoolOhmShare();\n\n        if (ohmMinted > currentPoolOhmShare + ohmRemoved)\n            emitted = ohmMinted - currentPoolOhmShare - ohmRemoved;\n        else removed = currentPoolOhmShare + ohmRemoved - ohmMinted;\n    }\n\n    //============================================================================================//\n    //                                     INTERNAL FUNCTIONS                                     //\n    //============================================================================================//\n\n    // ========= CHECKS AND SAFETY ========= //\n\n    function _canDeposit(uint256 amount_) internal view virtual returns (bool) {\n        if (amount_ + ohmMinted > LIMIT + ohmRemoved) revert LiquidityVault_LimitViolation();\n        return true;\n    }\n\n    function _isPoolSafe() internal view returns (bool) {\n        uint256 pairTokenDecimals = pairToken.decimals();\n        uint256 poolPrice = _getPoolPrice();\n        uint256 oraclePrice = _valueCollateral(10**pairTokenDecimals); // 1 pair token in OHM\n\n        // Pool price should fall within a threshold of the oracle price\n        uint256 lowerBound = (oraclePrice * (PRECISION - THRESHOLD)) / PRECISION;\n        uint256 upperBound = (oraclePrice * (PRECISION + THRESHOLD)) / PRECISION;\n\n        return poolPrice >= lowerBound && poolPrice <= upperBound;\n    }\n\n    function _validatePrice(address priceFeed_, uint256 updateThreshold_)\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            uint80 roundId,\n            int256 priceInt,\n            ,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = AggregatorV3Interface(priceFeed_).latestRoundData();\n\n        // Validate chainlink price feed data\n        // 1. Price should be greater than 0\n        // 2. Updated at timestamp should be within the update threshold\n        // 3. Answered in round ID should be the same as round ID\n        if (\n            priceInt <= 0 ||\n            updatedAt < block.timestamp - updateThreshold_ ||\n            answeredInRound != roundId\n        ) revert LiquidityVault_BadPriceFeed();\n\n        return uint256(priceInt);\n    }\n\n    // ========= OHM MANAGEMENT ========= //\n\n    function _borrow(uint256 amount_) internal {\n        MINTR.increaseMintApproval(address(this), amount_);\n        MINTR.mintOhm(address(this), amount_);\n    }\n\n    function _repay(uint256 amount_) internal {\n        ohm.increaseAllowance(address(MINTR), amount_);\n        MINTR.burnOhm(address(this), amount_);\n    }\n\n    // ========= REWARDS CALCULATIONS ========= //\n\n    function _accumulateInternalRewards() internal view returns (uint256[] memory) {\n        uint256 numInternalRewardTokens = internalRewardTokens.length;\n        uint256[] memory accumulatedInternalRewards = new uint256[](numInternalRewardTokens);\n\n        for (uint256 i; i < numInternalRewardTokens; ) {\n            InternalRewardToken memory rewardToken = internalRewardTokens[i];\n\n            uint256 totalRewards;\n            if (totalLP > 0) {\n                uint256 timeDiff = block.timestamp - rewardToken.lastRewardTime;\n                totalRewards = (timeDiff * rewardToken.rewardsPerSecond);\n            }\n\n            accumulatedInternalRewards[i] = totalRewards;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return accumulatedInternalRewards;\n    }\n\n    // ========= ACCUMULATED REWARDS STATE MANAGEMENT ========= //\n\n    function _updateInternalRewardState(uint256 id_, uint256 amountAccumulated_) internal {\n        // This correctly uses 1e18 because the LP tokens of all major DEXs have 18 decimals\n        InternalRewardToken storage rewardToken = internalRewardTokens[id_];\n        if (totalLP != 0)\n            rewardToken.accumulatedRewardsPerShare += (amountAccumulated_ * 1e18) / totalLP;\n        rewardToken.lastRewardTime = block.timestamp;\n    }\n\n    function _updateExternalRewardState(uint256 id_, uint256 amountAccumulated_) internal {\n        // This correctly uses 1e18 because the LP tokens of all major DEXs have 18 decimals\n        if (totalLP != 0)\n            externalRewardTokens[id_].accumulatedRewardsPerShare +=\n                (amountAccumulated_ * 1e18) /\n                totalLP;\n    }\n\n    // ========= PRE/POST ACTION HOOKS ========= //\n\n    function _depositUpdateRewardState() internal {\n        uint256 numInternalRewardTokens = internalRewardTokens.length;\n        uint256 numExternalRewardTokens = externalRewardTokens.length;\n\n        // Handles accounting logic for internal and external rewards, harvests external rewards\n        uint256[] memory accumulatedInternalRewards = _accumulateInternalRewards();\n        uint256[] memory accumulatedExternalRewards = _accumulateExternalRewards();\n\n        // Update internal reward token state\n        // This has to be done before the contract receives any LP tokens which is why it's not baked into the\n        // for loop for updating reward debts like in both withdrawal functions\n        for (uint256 i; i < numInternalRewardTokens; ) {\n            _updateInternalRewardState(i, accumulatedInternalRewards[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Update external reward token state\n        for (uint256 i; i < numExternalRewardTokens; ) {\n            _updateExternalRewardState(i, accumulatedExternalRewards[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _depositUpdateRewardDebts(uint256 lpReceived_) internal {\n        uint256 numInternalRewardTokens = internalRewardTokens.length;\n        uint256 numExternalRewardTokens = externalRewardTokens.length;\n\n        for (uint256 i; i < numInternalRewardTokens; ) {\n            // Reward debts for this deposit should be equal to the rewards accrued for a given value\n            // of LP tokens prior to the user joining the pool with the given value of LP tokens\n            InternalRewardToken memory rewardToken = internalRewardTokens[i];\n            userRewardDebts[msg.sender][rewardToken.token] +=\n                lpReceived_ *\n                rewardToken.accumulatedRewardsPerShare;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        for (uint256 i; i < numExternalRewardTokens; ) {\n            // Reward debts for this deposit should be equal to the rewards accrued for a given value\n            // of LP tokens prior to the user joining the pool with the given value of LP tokens\n            ExternalRewardToken memory rewardToken = externalRewardTokens[i];\n            userRewardDebts[msg.sender][rewardToken.token] +=\n                lpReceived_ *\n                rewardToken.accumulatedRewardsPerShare;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _withdrawUpdateRewardState(uint256 lpAmount_, bool claim_) internal {\n        uint256 numInternalRewardTokens = internalRewardTokens.length;\n        uint256 numExternalRewardTokens = externalRewardTokens.length;\n\n        // Handles accounting logic for internal and external rewards, harvests external rewards\n        uint256[] memory accumulatedInternalRewards = _accumulateInternalRewards();\n        uint256[] memory accumulatedExternalRewards = _accumulateExternalRewards();\n\n        for (uint256 i; i < numInternalRewardTokens; ) {\n            _updateInternalRewardState(i, accumulatedInternalRewards[i]);\n            if (claim_) _claimInternalRewards(i);\n\n            // Update reward debts so as to not understate the amount of rewards owed to the user, and push\n            // any unclaimed rewards to the user's reward debt so that they can be claimed later\n            InternalRewardToken memory rewardToken = internalRewardTokens[i];\n            uint256 rewardDebtDiff = lpAmount_ * rewardToken.accumulatedRewardsPerShare;\n\n            if (rewardDebtDiff > userRewardDebts[msg.sender][rewardToken.token]) {\n                userRewardDebts[msg.sender][rewardToken.token] = 0;\n                cachedUserRewards[msg.sender][rewardToken.token] +=\n                    rewardDebtDiff -\n                    userRewardDebts[msg.sender][rewardToken.token];\n            } else {\n                userRewardDebts[msg.sender][rewardToken.token] -= rewardDebtDiff;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        for (uint256 i; i < numExternalRewardTokens; ) {\n            _updateExternalRewardState(i, accumulatedExternalRewards[i]);\n            if (claim_) _claimExternalRewards(i);\n\n            // Update reward debts so as to not understate the amount of rewards owed to the user, and push\n            // any unclaimed rewards to the user's reward debt so that they can be claimed later\n            ExternalRewardToken memory rewardToken = externalRewardTokens[i];\n            uint256 rewardDebtDiff = lpAmount_ * rewardToken.accumulatedRewardsPerShare;\n\n            if (rewardDebtDiff > userRewardDebts[msg.sender][rewardToken.token]) {\n                userRewardDebts[msg.sender][rewardToken.token] = 0;\n                cachedUserRewards[msg.sender][rewardToken.token] +=\n                    rewardDebtDiff -\n                    userRewardDebts[msg.sender][rewardToken.token];\n            } else {\n                userRewardDebts[msg.sender][rewardToken.token] -= rewardDebtDiff;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // ========= REWARDS CLAIMING ========= //\n\n    function _claimInternalRewards(uint256 id_) internal {\n        address rewardToken = internalRewardTokens[id_].token;\n        uint256 reward = internalRewardsForToken(id_, msg.sender);\n        uint256 fee = (reward * FEE) / PRECISION;\n\n        userRewardDebts[msg.sender][rewardToken] += reward;\n        accumulatedFees[rewardToken] += fee;\n\n        if (reward > 0) ERC20(rewardToken).safeTransfer(msg.sender, reward - fee);\n\n        emit RewardsClaimed(msg.sender, rewardToken, reward - fee);\n    }\n\n    function _claimExternalRewards(uint256 id_) internal {\n        ExternalRewardToken storage rewardToken = externalRewardTokens[id_];\n        uint256 reward = externalRewardsForToken(id_, msg.sender);\n        uint256 fee = (reward * FEE) / PRECISION;\n\n        userRewardDebts[msg.sender][rewardToken.token] += reward;\n        accumulatedFees[rewardToken.token] += fee;\n\n        if (reward > 0) ERC20(rewardToken.token).safeTransfer(msg.sender, reward - fee);\n        rewardToken.lastBalance = ERC20(rewardToken.token).balanceOf(address(this));\n\n        emit RewardsClaimed(msg.sender, rewardToken.token, reward - fee);\n    }\n\n    //============================================================================================//\n    //                                      ADMIN FUNCTIONS                                       //\n    //============================================================================================//\n\n    /// @notice                 Registers the vault in the LQREG contract\n    /// @dev                    This function can only be accessed by the liquidityvault_admin role\n    function activate() external onlyRole(\"liquidityvault_admin\") {\n        isVaultActive = true;\n        LQREG.addVault(address(this));\n    }\n\n    /// @notice                 Unregisters the vault in the LQREG contract and sets the borrowable limit to 0\n    /// @dev                    This function can only be accessed by the liquidityvault_admin role\n    function deactivate() external onlyRole(\"liquidityvault_admin\") {\n        LIMIT = 0;\n        isVaultActive = false;\n        LQREG.removeVault(address(this));\n    }\n\n    /// @notice                    Adds a new internal reward token to the contract\n    /// @param  token_             The address of the reward token\n    /// @param  rewardsPerSecond_  The amount of reward tokens to distribute per second\n    /// @param  startTimestamp_    The timestamp at which to start distributing rewards\n    /// @dev                       This function can only be accessed by the liquidityvault_admin role\n    function addInternalRewardToken(\n        address token_,\n        uint256 rewardsPerSecond_,\n        uint256 startTimestamp_\n    ) external onlyRole(\"liquidityvault_admin\") {\n        InternalRewardToken memory newInternalRewardToken = InternalRewardToken({\n            token: token_,\n            decimalsAdjustment: 10**ERC20(token_).decimals(),\n            rewardsPerSecond: rewardsPerSecond_,\n            lastRewardTime: block.timestamp > startTimestamp_ ? block.timestamp : startTimestamp_,\n            accumulatedRewardsPerShare: 0\n        });\n\n        internalRewardTokens.push(newInternalRewardToken);\n    }\n\n    /// @notice                 Removes an internal reward token from the contract\n    /// @param  id_             The index of the reward token to remove\n    /// @param  token_          The address of the reward token to remove\n    /// @dev                    This function can only be accessed by the liquidityvault_admin role\n    function removeInternalRewardToken(uint256 id_, address token_)\n        external\n        onlyRole(\"liquidityvault_admin\")\n    {\n        if (internalRewardTokens[id_].token != token_) revert LiquidityVault_InvalidRemoval();\n\n        // Delete reward token from array by swapping with the last element and popping\n        internalRewardTokens[id_] = internalRewardTokens[internalRewardTokens.length - 1];\n        internalRewardTokens.pop();\n    }\n\n    /// @notice                 Adds a new external reward token to the contract\n    /// @param  token_          The address of the reward token\n    /// @dev                    This function can only be accessed by the liquidityvault_admin role\n    function addExternalRewardToken(address token_) external onlyRole(\"liquidityvault_admin\") {\n        ExternalRewardToken memory newRewardToken = ExternalRewardToken({\n            token: token_,\n            decimalsAdjustment: 10**ERC20(token_).decimals(),\n            accumulatedRewardsPerShare: 0,\n            lastBalance: 0\n        });\n\n        externalRewardTokens.push(newRewardToken);\n    }\n\n    /// @notice                 Removes an external reward token from the contract\n    /// @param  id_             The index of the reward token to remove\n    /// @param  token_          The address of the reward token to remove\n    /// @dev                    This function can only be accessed by the liquidityvault_admin role\n    function removeExternalRewardToken(uint256 id_, address token_)\n        external\n        onlyRole(\"liquidityvault_admin\")\n    {\n        if (externalRewardTokens[id_].token != token_) revert LiquidityVault_InvalidRemoval();\n\n        // Delete reward token from array by swapping with the last element and popping\n        externalRewardTokens[id_] = externalRewardTokens[externalRewardTokens.length - 1];"
    }
  ]
}