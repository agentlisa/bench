{
  "Title": "M-8: In the function _handleERC20Received, the fee was incorrectly charged",
  "Content": "# Issue M-8: In the function _handleERC20Received, the fee was incorrectly charged \n\nSource: https://github.com/sherlock-audit/2024-03-woofi-swap-judging/issues/114 \n\n## Found by \nAamirusmani1552, Nyx, aman, charles\\_\\_cheerful, hals, mstpr-brainbot, petro1912, yotov721, zraxx\n## Summary\n\nIn the function _handleERC20Received, the fee was incorrectly charged.\n\n## Vulnerability Detail\n\nIn the contract, when external swap occurs, a portion of the fee will be charged. However, in function _handleERC20Received, the fee is also charged in internal swap.\n\n```solidity\n} else {\n    // Deduct the external swap fee\n    uint256 fee = (bridgedAmount * dstExternalFeeRate) / FEE_BASE;\n    bridgedAmount -= fee;  // @@audit: fee should not be applied to internal swap \n\n    TransferHelper.safeApprove(bridgedToken, address(wooRouter), bridgedAmount);\n    if (dst1inch.swapRouter != address(0)) {\n        try\n            wooRouter.externalSwap(\n```\n\nAt the same time, when the internal swap fails, this part of the fee will not be returned to the user.\n\n## Impact\n\nInternal swaps are incorrectly charged, and fees are not refunded when internal swap fail.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L412-L414\n\nhttps://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L478\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nApply fee calculation only to external swaps.\n\n```dart\nfunction _handleERC20Received(\n    uint256 refId,\n    address to,\n    address toToken,\n    address bridgedToken,\n    uint256 bridgedAmount,\n    uint256 minToAmount,\n    Dst1inch memory dst1inch\n) internal {\n    address msgSender = _msgSender();\n\n    // ...\n\n    } else {\n        if (dst1inch.swapRouter != address(0)) {\n            // Deduct the external swap fee\n            uint256 fee = (bridgedAmount * dstExternalFeeRate) / FEE_BASE;\n            bridgedAmount -= fee;  \n\n            TransferHelper.safeApprove(bridgedToken, address(wooRouter), bridgedAmount);\n            try\n                wooRouter.externalSwap(\n                    // ...\n                )\n            returns (uint256 realToAmount) {\n                emit WooCrossSwapOnDstChain(\n                    // ...\n                );\n            } catch {\n                bridgedAmount += fee;\n                TransferHelper.safeTransfer(bridgedToken, to, bridgedAmount);\n                emit WooCrossSwapOnDstChain(\n                    // ...\n                );\n            }\n        } else {\n            TransferHelper.safeApprove(bridgedToken, address(wooRouter), bridgedAmount);\n            try wooRouter.swap(bridgedToken, toToken, bridgedAmount, minToAmount, payable(to), to) returns (\n                uint256 realToAmount\n            ) {\n               // ...\n            } catch {\n                // ...\n            }\n        }\n    }\n}\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/woonetwork/WooPoolV2/pull/112/commits/be8655bf5d9660684eff1e2c12ff5d140fddc474.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/277",
  "Code": [
    {
      "filename": "WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\n// OpenZeppelin Contracts\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n// Local Contracts\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {IWooCrossChainRouterV3} from \"../interfaces/CrossChain/IWooCrossChainRouterV3.sol\";\nimport {IWooRouterV2} from \"../interfaces/IWooRouterV2.sol\";\nimport {IStargateEthVault} from \"../interfaces/Stargate/IStargateEthVault.sol\";\nimport {IStargateRouter} from \"../interfaces/Stargate/IStargateRouter.sol\";\nimport {ILzApp} from \"../interfaces/LayerZero/ILzApp.sol\";\nimport {ISgInfo} from \"../interfaces/CrossChain/ISgInfo.sol\";\n\nimport {TransferHelper} from \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\n/// @title cross chain router implementation, version 3.\n/// @notice Router for stateless execution of cross chain swap against WOOFi or 1inch swap.\n/// @custom:stargate-contracts https://stargateprotocol.gitbook.io/stargate/developers/contract-addresses/mainnet\ncontract WooCrossChainRouterV4 is IWooCrossChainRouterV3, Ownable, Pausable, ReentrancyGuard {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /* ----- Constants ----- */\n\n    address public constant ETH_PLACEHOLDER_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /* ----- Variables ----- */\n\n    IWooRouterV2 public wooRouter;\n    ISgInfo public sgInfo;\n\n    address public immutable weth;\n    address public feeAddr;\n    uint256 public bridgeSlippage; // 1 in 10000th: default 1%\n\n    uint16 public srcExternalFeeRate; // unit: 0.1 bps (1e6 = 100%, 25 = 2.5 bps)\n    uint16 public dstExternalFeeRate; // unit: 0.1 bps (1e6 = 100%, 25 = 2.5 bps)\n    uint256 public constant FEE_BASE = 1e5;\n\n    mapping(uint16 => address) public wooCrossRouters; // chainId => WooCrossChainRouterV3 address\n\n    receive() external payable {}\n\n    constructor(\n        address _weth,\n        address _wooRouter,\n        address _sgInfo\n    ) {\n        weth = _weth;\n        wooRouter = IWooRouterV2(_wooRouter);\n        sgInfo = ISgInfo(_sgInfo);\n\n        bridgeSlippage = 100;\n\n        srcExternalFeeRate = 25;\n        dstExternalFeeRate = 25;\n    }\n\n    /* ----- Functions ----- */\n\n    function crossSwap(\n        uint256 refId,\n        address payable to,\n        SrcInfos memory srcInfos,\n        DstInfos calldata dstInfos,\n        Src1inch calldata src1inch,\n        Dst1inch calldata dst1inch\n    ) external payable whenNotPaused nonReentrant {\n        require(srcInfos.fromToken != address(0), \"WooCrossChainRouterV3: !srcInfos.fromToken\");\n        require(\n            dstInfos.toToken != address(0) && dstInfos.toToken != sgInfo.sgETHs(dstInfos.chainId),\n            \"WooCrossChainRouterV3: !dstInfos.toToken\"\n        );\n        require(to != address(0), \"WooCrossChainRouterV3: !to\");\n\n        uint256 msgValue = msg.value;\n        uint256 bridgeAmount;\n        uint256 fee = 0;\n\n        {\n            // Step 1: transfer\n            if (srcInfos.fromToken == ETH_PLACEHOLDER_ADDR) {\n                require(srcInfos.fromAmount <= msgValue, \"WooCrossChainRouterV3: !srcInfos.fromAmount\");\n                srcInfos.fromToken = weth;\n                IWETH(weth).deposit{value: srcInfos.fromAmount}();\n                msgValue -= srcInfos.fromAmount;\n            } else {\n                TransferHelper.safeTransferFrom(srcInfos.fromToken, msg.sender, address(this), srcInfos.fromAmount);\n            }\n\n            // Step 2: local swap by 1inch router\n            if (srcInfos.fromToken != srcInfos.bridgeToken) {\n                TransferHelper.safeApprove(srcInfos.fromToken, address(wooRouter), srcInfos.fromAmount);\n                if (src1inch.swapRouter != address(0)) {\n                    // external swap via 1inch\n                    bridgeAmount = wooRouter.externalSwap(\n                        src1inch.swapRouter,\n                        src1inch.swapRouter,\n                        srcInfos.fromToken,\n                        srcInfos.bridgeToken,\n                        srcInfos.fromAmount,\n                        srcInfos.minBridgeAmount,\n                        payable(address(this)),\n                        src1inch.data\n                    );\n                    fee = (bridgeAmount * srcExternalFeeRate) / FEE_BASE;\n                } else {\n                    // swap via WOOFi\n                    bridgeAmount = wooRouter.swap(\n                        srcInfos.fromToken,\n                        srcInfos.bridgeToken,\n                        srcInfos.fromAmount,\n                        srcInfos.minBridgeAmount,\n                        payable(address(this)),\n                        to\n                    );\n                }\n            } else {\n                require(\n                    srcInfos.fromAmount == srcInfos.minBridgeAmount,\n                    \"WooCrossChainRouterV3: !srcInfos.minBridgeAmount\"\n                );\n                bridgeAmount = srcInfos.fromAmount;\n            }\n\n            require(\n                bridgeAmount <= IERC20(srcInfos.bridgeToken).balanceOf(address(this)),\n                \"WooCrossChainRouterV3: !bridgeAmount\"\n            );\n        }\n\n        // Step 3: deduct the swap fee\n        bridgeAmount -= fee;\n\n        // Step 4: cross chain swap by StargateRouter\n        _bridgeByStargate(refId, to, msgValue, bridgeAmount, srcInfos, dstInfos, dst1inch);\n\n        emit WooCrossSwapOnSrcChain(\n            refId,\n            _msgSender(),\n            to,\n            srcInfos.fromToken,\n            srcInfos.fromAmount,\n            srcInfos.bridgeToken,\n            srcInfos.minBridgeAmount,\n            bridgeAmount,\n            src1inch.swapRouter == address(0) ? 0 : 1,\n            fee\n        );\n    }\n\n    function sgReceive(\n        uint16, // srcChainId\n        bytes memory, // srcAddress\n        uint256, // nonce\n        address bridgedToken,\n        uint256 amountLD,\n        bytes memory payload\n    ) external {\n        require(msg.sender == sgInfo.sgRouter(), \"WooCrossChainRouterV3: INVALID_CALLER\");\n\n        // make sure the same order to abi.encode when decode payload\n        (uint256 refId, address to, address toToken, uint256 minToAmount, Dst1inch memory dst1inch) = abi.decode(\n            payload,\n            (uint256, address, address, uint256, Dst1inch)\n        );\n\n        // toToken won't be SGETH, and bridgedToken won't be ETH_PLACEHOLDER_ADDR\n        if (bridgedToken == sgInfo.sgETHs(sgInfo.sgChainIdLocal())) {\n            // bridgedToken is SGETH, received native token\n            _handleNativeReceived(refId, to, toToken, amountLD, minToAmount, dst1inch);\n        } else {\n            // bridgedToken is not SGETH, received ERC20 token\n            _handleERC20Received(refId, to, toToken, bridgedToken, amountLD, minToAmount, dst1inch);\n        }\n    }\n\n    function quoteLayerZeroFee(\n        uint256 refId,\n        address to,\n        DstInfos calldata dstInfos,\n        Dst1inch calldata dst1inch\n    ) external view returns (uint256, uint256) {\n        bytes memory payload = abi.encode(refId, to, dstInfos.toToken, dstInfos.minToAmount, dst1inch);\n        IStargateRouter.lzTxObj memory obj = IStargateRouter.lzTxObj(\n            dstInfos.dstGasForCall,\n            dstInfos.airdropNativeAmount,\n            abi.encodePacked(to)\n        );\n        IStargateRouter stargateRouter = IStargateRouter(sgInfo.sgRouter());\n        return\n            stargateRouter.quoteLayerZeroFee(\n                dstInfos.chainId,\n                1, // https://stargateprotocol.gitbook.io/stargate/developers/function-types\n                obj.dstNativeAddr,\n                payload,\n                obj\n            );\n    }\n\n    /// @dev OKAY to be public method\n    function claimFee(address token) external nonReentrant {\n        require(feeAddr != address(0), \"WooCrossChainRouterV3: !feeAddr\");\n        uint256 amount = _generalBalanceOf(token, address(this));\n        if (amount > 0) {\n            if (token == ETH_PLACEHOLDER_ADDR) {\n                TransferHelper.safeTransferETH(feeAddr, amount);\n            } else {\n                TransferHelper.safeTransfer(token, feeAddr, amount);\n            }\n        }\n    }\n\n    function _bridgeByStargate(\n        uint256 refId,\n        address payable to,\n        uint256 msgValue,\n        uint256 bridgeAmount,\n        SrcInfos memory srcInfos,\n        DstInfos calldata dstInfos,\n        Dst1inch calldata dst1inch\n    ) internal {\n        require(\n            sgInfo.sgPoolIds(sgInfo.sgChainIdLocal(), srcInfos.bridgeToken) > 0,\n            \"WooCrossChainRouterV3: !srcInfos.bridgeToken\"\n        );\n        require(\n            sgInfo.sgPoolIds(dstInfos.chainId, dstInfos.bridgeToken) > 0,\n            \"WooCrossChainRouterV3: !dstInfos.bridgeToken\"\n        );\n\n        bytes memory payload = abi.encode(refId, to, dstInfos.toToken, dstInfos.minToAmount, dst1inch);\n\n        uint256 dstMinBridgeAmount = (bridgeAmount * (10000 - bridgeSlippage)) / 10000;\n        bytes memory dstWooCrossChainRouter = abi.encodePacked(wooCrossRouters[dstInfos.chainId]);\n\n        IStargateRouter.lzTxObj memory obj = IStargateRouter.lzTxObj(\n            dstInfos.dstGasForCall,\n            dstInfos.airdropNativeAmount,\n            abi.encodePacked(to)\n        );\n        IStargateRouter stargateRouter = IStargateRouter(sgInfo.sgRouter());\n\n        if (srcInfos.bridgeToken == weth) {\n            IWETH(weth).withdraw(bridgeAmount);\n            msgValue += bridgeAmount;\n        } else {\n            TransferHelper.safeApprove(srcInfos.bridgeToken, sgInfo.sgRouter(), bridgeAmount);\n        }\n\n        stargateRouter.swap{value: msgValue}(\n            dstInfos.chainId, // dst chain id\n            sgInfo.sgPoolIds(sgInfo.sgChainIdLocal(), srcInfos.bridgeToken), // bridge token's pool id on src chain\n            sgInfo.sgPoolIds(dstInfos.chainId, dstInfos.bridgeToken), // bridge token's pool id on dst chain\n            payable(_msgSender()), // rebate address\n            bridgeAmount, // swap amount on src chain\n            dstMinBridgeAmount, // min received amount on dst chain\n            obj, // config: dstGasForCall, dstAirdropNativeAmount, dstReceiveAirdropNativeTokenAddr\n            dstWooCrossChainRouter, // smart contract to call on dst chain\n            payload // payload to piggyback\n        );\n    }\n\n    function _handleNativeReceived(\n        uint256 refId,\n        address to,\n        address toToken,\n        uint256 bridgedAmount,\n        uint256 minToAmount,\n        Dst1inch memory dst1inch\n    ) internal {\n        address msgSender = _msgSender();\n\n        if (toToken == ETH_PLACEHOLDER_ADDR) {\n            // Directly transfer ETH\n            TransferHelper.safeTransferETH(to, bridgedAmount);\n            emit WooCrossSwapOnDstChain(\n                refId,\n                msgSender,\n                to,\n                weth,\n                bridgedAmount,\n                toToken,\n                ETH_PLACEHOLDER_ADDR,\n                minToAmount,\n                bridgedAmount,\n                dst1inch.swapRouter == address(0) ? 0 : 1,\n                0\n            );\n            return;\n        }\n\n        // Swap required!\n        IWETH(weth).deposit{value: bridgedAmount}();\n\n        if (dst1inch.swapRouter != address(0)) {\n            uint256 fee = (bridgedAmount * dstExternalFeeRate) / FEE_BASE;\n            uint256 swapAmount = bridgedAmount - fee;\n            TransferHelper.safeApprove(weth, address(wooRouter), swapAmount);\n            try\n                wooRouter.externalSwap(\n                    dst1inch.swapRouter,\n                    dst1inch.swapRouter,\n                    weth,\n                    toToken,\n                    swapAmount,\n                    minToAmount,\n                    payable(to),\n                    dst1inch.data\n                )\n            returns (uint256 realToAmount) {\n                emit WooCrossSwapOnDstChain(\n                    refId,\n                    msgSender,\n                    to,\n                    weth,\n                    swapAmount,\n                    toToken,\n                    toToken,\n                    minToAmount,\n                    realToAmount,\n                    dst1inch.swapRouter == address(0) ? 0 : 1,\n                    fee\n                );\n            } catch {\n                TransferHelper.safeApprove(weth, address(wooRouter), 0);\n                TransferHelper.safeTransfer(weth, to, bridgedAmount);\n                emit WooCrossSwapOnDstChain(\n                    refId,\n                    msgSender,\n                    to,\n                    weth,\n                    bridgedAmount,\n                    toToken,\n                    weth,\n                    minToAmount,\n                    bridgedAmount,\n                    dst1inch.swapRouter == address(0) ? 0 : 1,\n                    0\n                );\n            }\n        } else {\n            TransferHelper.safeApprove(weth, address(wooRouter), bridgedAmount);\n            try wooRouter.swap(weth, toToken, bridgedAmount, minToAmount, payable(to), to) returns (\n                uint256 realToAmount\n            ) {\n                emit WooCrossSwapOnDstChain(\n                    refId,\n                    msgSender,\n                    to,\n                    weth,\n                    bridgedAmount,\n                    toToken,\n                    toToken,\n                    minToAmount,\n                    realToAmount,\n                    dst1inch.swapRouter == address(0) ? 0 : 1,\n                    0\n                );\n            } catch {\n                TransferHelper.safeApprove(weth, address(wooRouter), 0);\n                TransferHelper.safeTransfer(weth, to, bridgedAmount);\n                emit WooCrossSwapOnDstChain(\n                    refId,\n                    msgSender,\n                    to,\n                    weth,\n                    bridgedAmount,\n                    toToken,\n                    weth,\n                    minToAmount,\n                    bridgedAmount,\n                    dst1inch.swapRouter == address(0) ? 0 : 1,\n                    0\n                );\n            }\n        }\n    }\n\n    function _handleERC20Received(\n        uint256 refId,\n        address to,\n        address toToken,\n        address bridgedToken,\n        uint256 bridgedAmount,\n        uint256 minToAmount,\n        Dst1inch memory dst1inch\n    ) internal {\n        address msgSender = _msgSender();\n\n        if (toToken == bridgedToken) {\n            TransferHelper.safeTransfer(bridgedToken, to, bridgedAmount);\n            emit WooCrossSwapOnDstChain(\n                refId,\n                msgSender,\n                to,\n                bridgedToken,\n                bridgedAmount,\n                toToken,\n                toToken,\n                minToAmount,\n                bridgedAmount,\n                dst1inch.swapRouter == address(0) ? 0 : 1,\n                0\n            );\n        } else {\n            // Deduct the external swap fee\n            uint256 fee = (bridgedAmount * dstExternalFeeRate) / FEE_BASE;\n            bridgedAmount -= fee;\n\n            TransferHelper.safeApprove(bridgedToken, address(wooRouter), bridgedAmount);\n            if (dst1inch.swapRouter != address(0)) {\n                try\n                    wooRouter.externalSwap(\n                        dst1inch.swapRouter,\n                        dst1inch.swapRouter,\n                        bridgedToken,\n                        toToken,\n                        bridgedAmount,\n                        minToAmount,\n                        payable(to),\n                        dst1inch.data\n                    )\n                returns (uint256 realToAmount) {\n                    emit WooCrossSwapOnDstChain(\n                        refId,\n                        msgSender,\n                        to,\n                        bridgedToken,\n                        bridgedAmount,\n                        toToken,\n                        toToken,\n                        minToAmount,\n                        realToAmount,\n                        dst1inch.swapRouter == address(0) ? 0 : 1,\n                        fee\n                    );\n                } catch {\n                    bridgedAmount += fee;\n                    TransferHelper.safeTransfer(bridgedToken, to, bridgedAmount);\n                    emit WooCrossSwapOnDstChain(\n                        refId,\n                        msgSender,\n                        to,\n                        bridgedToken,\n                        bridgedAmount,\n                        toToken,\n                        bridgedToken,\n                        minToAmount,\n                        bridgedAmount,\n                        dst1inch.swapRouter == address(0) ? 0 : 1,\n                        0\n                    );\n                }\n            } else {\n                try wooRouter.swap(bridgedToken, toToken, bridgedAmount, minToAmount, payable(to), to) returns (\n                    uint256 realToAmount\n                ) {\n                    emit WooCrossSwapOnDstChain(\n                        refId,\n                        msgSender,\n                        to,\n                        bridgedToken,\n                        bridgedAmount,\n                        toToken,\n                        toToken,\n                        minToAmount,\n                        realToAmount,\n                        dst1inch.swapRouter == address(0) ? 0 : 1,\n                        0\n                    );\n                } catch {\n                    TransferHelper.safeTransfer(bridgedToken, to, bridgedAmount);\n                    emit WooCrossSwapOnDstChain(\n                        refId,\n                        msgSender,\n                        to,\n                        bridgedToken,\n                        bridgedAmount,\n                        toToken,\n                        bridgedToken,\n                        minToAmount,\n                        bridgedAmount,\n                        dst1inch.swapRouter == address(0) ? 0 : 1,\n                        0\n                    );\n                }\n            }\n        }\n    }\n\n    function _generalBalanceOf(address token, address who) internal view returns (uint256) {\n        return token == ETH_PLACEHOLDER_ADDR ? who.balance : IERC20(token).balanceOf(who);\n    }\n\n    /* ----- Owner & Admin Functions ----- */\n\n    function setFeeAddr(address _feeAddr) external onlyOwner {\n        feeAddr = _feeAddr;\n    }\n\n    function setWooRouter(address _wooRouter) external onlyOwner {\n        require(_wooRouter != address(0), \"WooCrossChainRouterV3: !_wooRouter\");\n        wooRouter = IWooRouterV2(_wooRouter);\n    }\n\n    function setBridgeSlippage(uint256 _bridgeSlippage) external onlyOwner {\n        require(_bridgeSlippage <= 10000, \"WooCrossChainRouterV3: !_bridgeSlippage\");\n        bridgeSlippage = _bridgeSlippage;\n    }\n\n    function setWooCrossRouter(uint16 _chainId, address _crossRouter) external onlyOwner {\n        require(_crossRouter != address(0), \"WooCrossChainRouterV3: !_crossRouter\");\n        wooCrossRouters[_chainId] = _crossRouter;\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function inCaseTokenGotStuck(address stuckToken) external onlyOwner {\n        if (stuckToken == ETH_PLACEHOLDER_ADDR) {\n            TransferHelper.safeTransferETH(msg.sender, address(this).balance);\n        } else {\n            uint256 amount = IERC20(stuckToken).balanceOf(address(this));\n            TransferHelper.safeTransfer(stuckToken, msg.sender, amount);\n        }\n    }\n}"
    },
    {
      "filename": "WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\n// OpenZeppelin Contracts\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n// Local Contracts\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {IWooCrossChainRouterV3} from \"../interfaces/CrossChain/IWooCrossChainRouterV3.sol\";\nimport {IWooRouterV2} from \"../interfaces/IWooRouterV2.sol\";\nimport {IStargateEthVault} from \"../interfaces/Stargate/IStargateEthVault.sol\";\nimport {IStargateRouter} from \"../interfaces/Stargate/IStargateRouter.sol\";\nimport {ILzApp} from \"../interfaces/LayerZero/ILzApp.sol\";\nimport {ISgInfo} from \"../interfaces/CrossChain/ISgInfo.sol\";\n\nimport {TransferHelper} from \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\n/// @title cross chain router implementation, version 3.\n/// @notice Router for stateless execution of cross chain swap against WOOFi or 1inch swap.\n/// @custom:stargate-contracts https://stargateprotocol.gitbook.io/stargate/developers/contract-addresses/mainnet\ncontract WooCrossChainRouterV4 is IWooCrossChainRouterV3, Ownable, Pausable, ReentrancyGuard {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /* ----- Constants ----- */\n\n    address public constant ETH_PLACEHOLDER_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /* ----- Variables ----- */\n\n    IWooRouterV2 public wooRouter;\n    ISgInfo public sgInfo;\n\n    address public immutable weth;\n    address public feeAddr;\n    uint256 public bridgeSlippage; // 1 in 10000th: default 1%\n\n    uint16 public srcExternalFeeRate; // unit: 0.1 bps (1e6 = 100%, 25 = 2.5 bps)\n    uint16 public dstExternalFeeRate; // unit: 0.1 bps (1e6 = 100%, 25 = 2.5 bps)\n    uint256 public constant FEE_BASE = 1e5;\n\n    mapping(uint16 => address) public wooCrossRouters; // chainId => WooCrossChainRouterV3 address\n\n    receive() external payable {}\n\n    constructor(\n        address _weth,\n        address _wooRouter,\n        address _sgInfo\n    ) {\n        weth = _weth;\n        wooRouter = IWooRouterV2(_wooRouter);\n        sgInfo = ISgInfo(_sgInfo);\n\n        bridgeSlippage = 100;\n\n        srcExternalFeeRate = 25;\n        dstExternalFeeRate = 25;\n    }\n\n    /* ----- Functions ----- */\n\n    function crossSwap(\n        uint256 refId,\n        address payable to,\n        SrcInfos memory srcInfos,\n        DstInfos calldata dstInfos,\n        Src1inch calldata src1inch,\n        Dst1inch calldata dst1inch\n    ) external payable whenNotPaused nonReentrant {\n        require(srcInfos.fromToken != address(0), \"WooCrossChainRouterV3: !srcInfos.fromToken\");\n        require(\n            dstInfos.toToken != address(0) && dstInfos.toToken != sgInfo.sgETHs(dstInfos.chainId),\n            \"WooCrossChainRouterV3: !dstInfos.toToken\"\n        );\n        require(to != address(0), \"WooCrossChainRouterV3: !to\");\n\n        uint256 msgValue = msg.value;\n        uint256 bridgeAmount;\n        uint256 fee = 0;\n\n        {\n            // Step 1: transfer\n            if (srcInfos.fromToken == ETH_PLACEHOLDER_ADDR) {\n                require(srcInfos.fromAmount <= msgValue, \"WooCrossChainRouterV3: !srcInfos.fromAmount\");\n                srcInfos.fromToken = weth;\n                IWETH(weth).deposit{value: srcInfos.fromAmount}();\n                msgValue -= srcInfos.fromAmount;\n            } else {\n                TransferHelper.safeTransferFrom(srcInfos.fromToken, msg.sender, address(this), srcInfos.fromAmount);\n            }\n\n            // Step 2: local swap by 1inch router\n            if (srcInfos.fromToken != srcInfos.bridgeToken) {\n                TransferHelper.safeApprove(srcInfos.fromToken, address(wooRouter), srcInfos.fromAmount);\n                if (src1inch.swapRouter != address(0)) {\n                    // external swap via 1inch\n                    bridgeAmount = wooRouter.externalSwap(\n                        src1inch.swapRouter,\n                        src1inch.swapRouter,\n                        srcInfos.fromToken,\n                        srcInfos.bridgeToken,\n                        srcInfos.fromAmount,\n                        srcInfos.minBridgeAmount,\n                        payable(address(this)),\n                        src1inch.data\n                    );\n                    fee = (bridgeAmount * srcExternalFeeRate) / FEE_BASE;\n                } else {\n                    // swap via WOOFi\n                    bridgeAmount = wooRouter.swap(\n                        srcInfos.fromToken,\n                        srcInfos.bridgeToken,\n                        srcInfos.fromAmount,\n                        srcInfos.minBridgeAmount,\n                        payable(address(this)),\n                        to\n                    );\n                }\n            } else {\n                require(\n                    srcInfos.fromAmount == srcInfos.minBridgeAmount,\n                    \"WooCrossChainRouterV3: !srcInfos.minBridgeAmount\"\n                );\n                bridgeAmount = srcInfos.fromAmount;\n            }\n\n            require(\n                bridgeAmount <= IERC20(srcInfos.bridgeToken).balanceOf(address(this)),\n                \"WooCrossChainRouterV3: !bridgeAmount\"\n            );\n        }\n\n        // Step 3: deduct the swap fee\n        bridgeAmount -= fee;\n\n        // Step 4: cross chain swap by StargateRouter\n        _bridgeByStargate(refId, to, msgValue, bridgeAmount, srcInfos, dstInfos, dst1inch);\n\n        emit WooCrossSwapOnSrcChain(\n            refId,\n            _msgSender(),\n            to,\n            srcInfos.fromToken,\n            srcInfos.fromAmount,\n            srcInfos.bridgeToken,\n            srcInfos.minBridgeAmount,\n            bridgeAmount,\n            src1inch.swapRouter == address(0) ? 0 : 1,\n            fee\n        );\n    }\n\n    function sgReceive(\n        uint16, // srcChainId\n        bytes memory, // srcAddress\n        uint256, // nonce\n        address bridgedToken,\n        uint256 amountLD,\n        bytes memory payload\n    ) external {\n        require(msg.sender == sgInfo.sgRouter(), \"WooCrossChainRouterV3: INVALID_CALLER\");\n\n        // make sure the same order to abi.encode when decode payload\n        (uint256 refId, address to, address toToken, uint256 minToAmount, Dst1inch memory dst1inch) = abi.decode(\n            payload,\n            (uint256, address, address, uint256, Dst1inch)\n        );\n\n        // toToken won't be SGETH, and bridgedToken won't be ETH_PLACEHOLDER_ADDR\n        if (bridgedToken == sgInfo.sgETHs(sgInfo.sgChainIdLocal())) {\n            // bridgedToken is SGETH, received native token\n            _handleNativeReceived(refId, to, toToken, amountLD, minToAmount, dst1inch);\n        } else {\n            // bridgedToken is not SGETH, received ERC20 token\n            _handleERC20Received(refId, to, toToken, bridgedToken, amountLD, minToAmount, dst1inch);\n        }\n    }\n\n    function quoteLayerZeroFee(\n        uint256 refId,\n        address to,\n        DstInfos calldata dstInfos,\n        Dst1inch calldata dst1inch\n    ) external view returns (uint256, uint256) {\n        bytes memory payload = abi.encode(refId, to, dstInfos.toToken, dstInfos.minToAmount, dst1inch);\n        IStargateRouter.lzTxObj memory obj = IStargateRouter.lzTxObj(\n            dstInfos.dstGasForCall,\n            dstInfos.airdropNativeAmount,\n            abi.encodePacked(to)\n        );\n        IStargateRouter stargateRouter = IStargateRouter(sgInfo.sgRouter());\n        return\n            stargateRouter.quoteLayerZeroFee(\n                dstInfos.chainId,\n                1, // https://stargateprotocol.gitbook.io/stargate/developers/function-types\n                obj.dstNativeAddr,\n                payload,\n                obj\n            );\n    }\n\n    /// @dev OKAY to be public method\n    function claimFee(address token) external nonReentrant {\n        require(feeAddr != address(0), \"WooCrossChainRouterV3: !feeAddr\");\n        uint256 amount = _generalBalanceOf(token, address(this));\n        if (amount > 0) {\n            if (token == ETH_PLACEHOLDER_ADDR) {\n                TransferHelper.safeTransferETH(feeAddr, amount);\n            } else {\n                TransferHelper.safeTransfer(token, feeAddr, amount);\n            }\n        }\n    }\n\n    function _bridgeByStargate(\n        uint256 refId,\n        address payable to,\n        uint256 msgValue,\n        uint256 bridgeAmount,\n        SrcInfos memory srcInfos,\n        DstInfos calldata dstInfos,\n        Dst1inch calldata dst1inch\n    ) internal {\n        require(\n            sgInfo.sgPoolIds(sgInfo.sgChainIdLocal(), srcInfos.bridgeToken) > 0,\n            \"WooCrossChainRouterV3: !srcInfos.bridgeToken\"\n        );\n        require(\n            sgInfo.sgPoolIds(dstInfos.chainId, dstInfos.bridgeToken) > 0,\n            \"WooCrossChainRouterV3: !dstInfos.bridgeToken\"\n        );\n\n        bytes memory payload = abi.encode(refId, to, dstInfos.toToken, dstInfos.minToAmount, dst1inch);\n\n        uint256 dstMinBridgeAmount = (bridgeAmount * (10000 - bridgeSlippage)) / 10000;\n        bytes memory dstWooCrossChainRouter = abi.encodePacked(wooCrossRouters[dstInfos.chainId]);\n\n        IStargateRouter.lzTxObj memory obj = IStargateRouter.lzTxObj(\n            dstInfos.dstGasForCall,\n            dstInfos.airdropNativeAmount,\n            abi.encodePacked(to)\n        );\n        IStargateRouter stargateRouter = IStargateRouter(sgInfo.sgRouter());\n\n        if (srcInfos.bridgeToken == weth) {\n            IWETH(weth).withdraw(bridgeAmount);\n            msgValue += bridgeAmount;\n        } else {\n            TransferHelper.safeApprove(srcInfos.bridgeToken, sgInfo.sgRouter(), bridgeAmount);\n        }\n\n        stargateRouter.swap{value: msgValue}(\n            dstInfos.chainId, // dst chain id\n            sgInfo.sgPoolIds(sgInfo.sgChainIdLocal(), srcInfos.bridgeToken), // bridge token's pool id on src chain\n            sgInfo.sgPoolIds(dstInfos.chainId, dstInfos.bridgeToken), // bridge token's pool id on dst chain\n            payable(_msgSender()), // rebate address\n            bridgeAmount, // swap amount on src chain\n            dstMinBridgeAmount, // min received amount on dst chain\n            obj, // config: dstGasForCall, dstAirdropNativeAmount, dstReceiveAirdropNativeTokenAddr\n            dstWooCrossChainRouter, // smart contract to call on dst chain\n            payload // payload to piggyback\n        );\n    }\n\n    function _handleNativeReceived(\n        uint256 refId,\n        address to,\n        address toToken,\n        uint256 bridgedAmount,\n        uint256 minToAmount,\n        Dst1inch memory dst1inch\n    ) internal {\n        address msgSender = _msgSender();\n\n        if (toToken == ETH_PLACEHOLDER_ADDR) {\n            // Directly transfer ETH\n            TransferHelper.safeTransferETH(to, bridgedAmount);\n            emit WooCrossSwapOnDstChain(\n                refId,\n                msgSender,\n                to,\n                weth,\n                bridgedAmount,\n                toToken,\n                ETH_PLACEHOLDER_ADDR,\n                minToAmount,\n                bridgedAmount,\n                dst1inch.swapRouter == address(0) ? 0 : 1,\n                0\n            );\n            return;\n        }\n\n        // Swap required!\n        IWETH(weth).deposit{value: bridgedAmount}();\n\n        if (dst1inch.swapRouter != address(0)) {\n            uint256 fee = (bridgedAmount * dstExternalFeeRate) / FEE_BASE;\n            uint256 swapAmount = bridgedAmount - fee;\n            TransferHelper.safeApprove(weth, address(wooRouter), swapAmount);\n            try\n                wooRouter.externalSwap(\n                    dst1inch.swapRouter,\n                    dst1inch.swapRouter,\n                    weth,\n                    toToken,\n                    swapAmount,\n                    minToAmount,\n                    payable(to),\n                    dst1inch.data\n                )\n            returns (uint256 realToAmount) {\n                emit WooCrossSwapOnDstChain(\n                    refId,\n                    msgSender,\n                    to,\n                    weth,\n                    swapAmount,\n                    toToken,\n                    toToken,\n                    minToAmount,\n                    realToAmount,\n                    dst1inch.swapRouter == address(0) ? 0 : 1,\n                    fee\n                );\n            } catch {\n                TransferHelper.safeApprove(weth, address(wooRouter), 0);\n                TransferHelper.safeTransfer(weth, to, bridgedAmount);"
    }
  ]
}