{
  "Title": "[G-23] Use `assembly` for math (add, sub, mul, div)",
  "Content": "\nUse `assembly` for math instead of Solidity. You can check for overflow/underflow in `assembly` to ensure safety. If using Solidity versions `<` 0.8.0 and you are using `Safemath`, you can gain significant gas savings by using `assembly` to calculate values and checking for overflow/underflow.\n\n<details>\n\n**Addition:**\n\n```\n//addition in Solidity\nfunction addTest(uint256 a, uint256 b) public pure {\n    uint256 c = a + b;\n}\n```\n\nGas: 303\n\n```\n//addition in assembly\nfunction addAssemblyTest(uint256 a, uint256 b) public pure {\n    assembly {\n        let c := add(a, b)\n        if lt(c, a) {\n            mstore(0x00, \"overflow\")\n            revert(0x00, 0x20)\n        }\n    }\n}\n```\n\nGas: 263\n\n**Subtraction:**\n\n```\n//subtraction in Solidity\nfunction subTest(uint256 a, uint256 b) public pure {\n  uint256 c = a - b;\n}\n```\n\nGas: 300\n\n```\n//subtraction in assembly\nfunction subAssemblyTest(uint256 a, uint256 b) public pure {\n    assembly {\n        let c := sub(a, b)\n        if gt(c, a) {\n            mstore(0x00, \"underflow\")\n            revert(0x00, 0x20)\n        }\n    }\n}\n```\n\nGas: 263\n\n**Multiplication:**\n\n```\n//multiplication in Solidity\nfunction mulTest(uint256 a, uint256 b) public pure {\n    uint256 c = a * b;\n}\n```\n\nGas: 325\n\n```\n//multiplication in assembly\nfunction mulAssemblyTest(uint256 a, uint256 b) public pure {\n    assembly {\n        let c := mul(a, b)\n        if lt(c, a) {\n            mstore(0x00, \"overflow\")\n            revert(0x00, 0x20)\n        }\n    }\n}\n```\n\nGas: 265\n\n**Division:**\n\n```\n//division in Solidity\nfunction divTest(uint256 a, uint256 b) public pure {\n    uint256 c = a * b;\n}\n```\n\nGas: 325\n\n```\n//division in assembly\nfunction divAssemblyTest(uint256 a, uint256 b) public pure {\n    assembly {\n        let c := div(a, b)\n        if gt(c, a) {\n            mstore(0x00, \"underflow\")\n            revert(0x00, 0x20)\n        }\n    }\n}\n```\n\nGas: 265\n\n```solidity\nFile: src/erc-20/ERC20Gauges.sol\n379    function _add112(uint112 a, uint112 b) private pure returns (uint112) {\n        return a + b;\n       }\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/ERC20Gauges.sol#L379\n\n```solidity\nFile: src/erc-20/ERC20MultiVotes.sol\n73   low = mid + 1;\n\n82   return (a & b) + (a ^ b) / 2;\n\n259  return a + b;\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/ERC20MultiVotes.sol#L73\n\n```solidity\nFile: src/governance/GovernorBravoDelegateMaia.sol\n526   uint256 c = a + b;\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/governance/GovernorBravoDelegateMaia.sol#L526\n\n```solidity\nFile: src/hermes/minters/BaseV2Minter.sol\n134   uint256 _required = _growth + newWeeklyEmission;\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/minters/BaseV2Minter.sol#L134\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-20/ERC20Gauges.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Gauge weight logic inspired by Tribe DAO Contracts (flywheel-v2/src/token/ERC20Gauges.sol)\npragma solidity ^0.8.0;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {ERC20MultiVotes} from \"./ERC20MultiVotes.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20Gauges} from \"./interfaces/IERC20Gauges.sol\";\n\n/// @title  An ERC20 with an embedded \"Gauge\" style vote with liquid weights\nabstract contract ERC20Gauges is ERC20MultiVotes, ReentrancyGuard, IERC20Gauges {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /**\n     * @notice Construct a new ERC20Gauges\n     * @param _gaugeCycleLength the length of a gauge cycle in seconds\n     * @param _incrementFreezeWindow the length of the grace period in seconds\n     */\n    constructor(uint32 _gaugeCycleLength, uint32 _incrementFreezeWindow) {\n        if (_incrementFreezeWindow >= _gaugeCycleLength) revert IncrementFreezeError();\n        gaugeCycleLength = _gaugeCycleLength;\n        incrementFreezeWindow = _incrementFreezeWindow;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    uint32 public immutable override gaugeCycleLength;\n\n    /// @inheritdoc IERC20Gauges\n    uint32 public immutable override incrementFreezeWindow;\n\n    /// @inheritdoc IERC20Gauges\n    mapping(address => mapping(address => uint112)) public override getUserGaugeWeight;\n\n    /// @inheritdoc IERC20Gauges\n    /// @dev NOTE this may contain weights for deprecated gauges\n    mapping(address => uint112) public override getUserWeight;\n\n    /// @notice a mapping from a gauge to the total weight allocated to it\n    /// @dev NOTE this may contain weights for deprecated gauges\n    mapping(address => Weight) internal _getGaugeWeight;\n\n    /// @notice the total global allocated weight ONLY of live gauges\n    Weight internal _totalWeight;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead weight\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                              VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    function getGaugeCycleEnd() external view returns (uint32) {\n        return _getGaugeCycleEnd();\n    }\n\n    function _getGaugeCycleEnd() internal view returns (uint32) {\n        uint32 nowPlusOneCycle = block.timestamp.toUint32() + gaugeCycleLength;\n        unchecked {\n            return (nowPlusOneCycle / gaugeCycleLength) * gaugeCycleLength; // cannot divide by zero and always <= nowPlusOneCycle so no overflow\n        }\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function getGaugeWeight(address gauge) external view returns (uint112) {\n        return _getGaugeWeight[gauge].currentWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function getStoredGaugeWeight(address gauge) external view returns (uint112) {\n        if (_deprecatedGauges.contains(gauge)) return 0;\n        return _getStoredWeight(_getGaugeWeight[gauge], _getGaugeCycleEnd());\n    }\n\n    function _getStoredWeight(Weight storage gaugeWeight, uint32 currentCycle) internal view returns (uint112) {\n        return gaugeWeight.currentCycle < currentCycle ? gaugeWeight.currentWeight : gaugeWeight.storedWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function totalWeight() external view returns (uint112) {\n        return _totalWeight.currentWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function storedTotalWeight() external view returns (uint112) {\n        return _getStoredWeight(_totalWeight, _getGaugeCycleEnd());\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function gauges() external view returns (address[] memory) {\n        return _gauges.values();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _gauges.at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function isGauge(address gauge) external view returns (bool) {\n        return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function numGauges() external view returns (uint256) {\n        return _gauges.length();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function deprecatedGauges() external view returns (address[] memory) {\n        return _deprecatedGauges.values();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function numDeprecatedGauges() external view returns (uint256) {\n        return _deprecatedGauges.length();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function userGauges(address user) external view returns (address[] memory) {\n        return _userGauges[user].values();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function isUserGauge(address user, address gauge) external view returns (bool) {\n        return _userGauges[user].contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function userGauges(address user, uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _userGauges[user].at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function numUserGauges(address user) external view returns (uint256) {\n        return _userGauges[user].length();\n    }\n\n    /// @inheritdoc ERC20MultiVotes\n    function userUnusedVotes(address user) public view override returns (uint256) {\n        return super.userUnusedVotes(user) - getUserWeight[user];\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function calculateGaugeAllocation(address gauge, uint256 quantity) external view returns (uint256) {\n        if (_deprecatedGauges.contains(gauge)) return 0;\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        uint112 total = _getStoredWeight(_totalWeight, currentCycle);\n        uint112 weight = _getStoredWeight(_getGaugeWeight[gauge], currentCycle);\n        return (quantity * weight) / total;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    function incrementGauge(address gauge, uint112 weight) external nonReentrant returns (uint112 newUserWeight) {\n        uint32 currentCycle = _getGaugeCycleEnd();\n        _incrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n        return _incrementUserAndGlobalWeights(msg.sender, weight, currentCycle);\n    }\n\n    /**\n     * @notice Increment the weight of a gauge for a user\n     * @dev This function calls accrueBribes for the gauge to ensure the gauge handles the balance change.\n     * @param user the user to increment the weight of\n     * @param gauge the gauge to increment the weight of\n     * @param weight the weight to increment by\n     * @param cycle the cycle to increment the weight for\n     */\n    function _incrementGaugeWeight(address user, address gauge, uint112 weight, uint32 cycle) internal {\n        if (!_gauges.contains(gauge) || _deprecatedGauges.contains(gauge)) revert InvalidGaugeError();\n        unchecked {\n            if (cycle - block.timestamp <= incrementFreezeWindow) revert IncrementFreezeError();\n        }\n\n        IBaseV2Gauge(gauge).accrueBribes(user);\n\n        bool added = _userGauges[user].add(gauge); // idempotent add\n        if (added && _userGauges[user].length() > maxGauges && !canContractExceedMaxGauges[user]) {\n            revert MaxGaugeError();\n        }\n\n        getUserGaugeWeight[user][gauge] += weight;\n\n        _writeGaugeWeight(_getGaugeWeight[gauge], _add112, weight, cycle);\n\n        emit IncrementGaugeWeight(user, gauge, weight, cycle);\n    }\n\n    /**\n     * @notice Increment the weight of a gauge for a user and the total weight\n     * @param user the user to increment the weight of\n     * @param weight the weight to increment by\n     * @param cycle the cycle to increment the weight for\n     * @return newUserWeight the new user's weight\n     */\n    function _incrementUserAndGlobalWeights(address user, uint112 weight, uint32 cycle)\n        internal\n        returns (uint112 newUserWeight)\n    {\n        newUserWeight = getUserWeight[user] + weight;\n\n        // new user weight must be less than or equal to the total user weight\n        if (newUserWeight > getVotes(user)) revert OverWeightError();\n\n        // Update gauge state\n        getUserWeight[user] = newUserWeight;\n\n        _writeGaugeWeight(_totalWeight, _add112, weight, cycle);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function incrementGauges(address[] calldata gaugeList, uint112[] calldata weights)\n        external\n        nonReentrant\n        returns (uint256 newUserWeight)\n    {\n        uint256 size = gaugeList.length;\n        if (weights.length != size) revert SizeMismatchError();\n\n        // store total in summary for a batch update on user/global state\n        uint112 weightsSum;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Update a gauge's specific state\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n            uint112 weight = weights[i];\n            weightsSum += weight;\n\n            _incrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n            unchecked {\n                i++;\n            }\n        }\n        return _incrementUserAndGlobalWeights(msg.sender, weightsSum, currentCycle);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function decrementGauge(address gauge, uint112 weight) external nonReentrant returns (uint112 newUserWeight) {\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // All operations will revert on underflow, protecting against bad inputs\n        _decrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n        if (!_deprecatedGauges.contains(gauge)) {\n            _writeGaugeWeight(_totalWeight, _subtract112, weight, currentCycle);\n        }\n        return _decrementUserWeights(msg.sender, weight);\n    }\n\n    /**\n     * @notice Decrement the weight of a gauge for a user\n     * @dev This function calls accrueBribes for the gauge to ensure the gauge handles the balance change.\n     * @param user the user to decrement the weight of\n     * @param gauge the gauge to decrement the weight of\n     * @param weight the weight to decrement by\n     * @param cycle the cycle to decrement the weight for\n     */\n    function _decrementGaugeWeight(address user, address gauge, uint112 weight, uint32 cycle) internal {\n        if (!_gauges.contains(gauge)) revert InvalidGaugeError();\n\n        uint112 oldWeight = getUserGaugeWeight[user][gauge];\n\n        IBaseV2Gauge(gauge).accrueBribes(user);\n\n        getUserGaugeWeight[user][gauge] = oldWeight - weight;\n        if (oldWeight == weight) {\n            // If removing all weight, remove gauge from user list.\n            require(_userGauges[user].remove(gauge));\n        }\n\n        _writeGaugeWeight(_getGaugeWeight[gauge], _subtract112, weight, cycle);\n\n        emit DecrementGaugeWeight(user, gauge, weight, cycle);\n    }\n\n    /**\n     * @notice Decrement the weight of a gauge for a user and the total weight\n     * @param user the user to decrement the weight of\n     * @param weight the weight to decrement by\n     * @return newUserWeight the new user's weight\n     */\n    function _decrementUserWeights(address user, uint112 weight) internal returns (uint112 newUserWeight) {\n        newUserWeight = getUserWeight[user] - weight;\n        getUserWeight[user] = newUserWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function decrementGauges(address[] calldata gaugeList, uint112[] calldata weights)\n        external\n        nonReentrant\n        returns (uint112 newUserWeight)\n    {\n        uint256 size = gaugeList.length;\n        if (weights.length != size) revert SizeMismatchError();\n\n        // store total in summary for the batch update on user and global state\n        uint112 weightsSum;\n        uint112 globalWeightsSum;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Update the gauge's specific state\n        // All operations will revert on underflow, protecting against bad inputs\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n            uint112 weight = weights[i];\n            weightsSum += weight;\n            if (!_deprecatedGauges.contains(gauge)) globalWeightsSum += weight;\n\n            _decrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n            unchecked {\n                i++;\n            }\n        }\n        _writeGaugeWeight(_totalWeight, _subtract112, globalWeightsSum, currentCycle);\n\n        return _decrementUserWeights(msg.sender, weightsSum);\n    }\n\n    /**\n     * @dev this function is the key to the entire contract.\n     *  The storage weight it operates on is either a global or gauge-specific weight.\n     *  The operation applied is either addition for incrementing gauges or subtraction for decrementing a gauge.\n     * @param weight the weight to apply the operation to\n     * @param op the operation to apply\n     * @param delta the amount to apply the operation by\n     * @param cycle the cycle to apply the operation for\n     */\n    function _writeGaugeWeight(\n        Weight storage weight,\n        function(uint112, uint112) view returns (uint112) op,\n        uint112 delta,\n        uint32 cycle\n    ) private {\n        uint112 currentWeight = weight.currentWeight;\n        // If the last cycle of the weight is before the current cycle, use the current weight as the stored.\n        uint112 stored = weight.currentCycle < cycle ? currentWeight : weight.storedWeight;\n        uint112 newWeight = op(currentWeight, delta);\n\n        weight.storedWeight = stored;\n        weight.currentWeight = newWeight;\n        weight.currentCycle = cycle;\n    }\n\n    function _add112(uint112 a, uint112 b) private pure returns (uint112) {\n        return a + b;\n    }\n\n    function _subtract112(uint112 a, uint112 b) private pure returns (uint112) {\n        return a - b;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    uint256 public override maxGauges;\n\n    /// @inheritdoc IERC20Gauges\n    mapping(address => bool) public override canContractExceedMaxGauges;\n\n    /// @inheritdoc IERC20Gauges\n    function addGauge(address gauge) external onlyOwner returns (uint112) {\n        return _addGauge(gauge);\n    }\n\n    /**\n     * @notice Add a gauge to the contract\n     * @param gauge the gauge to add\n     * @return weight the previous weight of the gauge, if it was already added\n     */\n    function _addGauge(address gauge) internal returns (uint112 weight) {\n        bool newAdd = _gauges.add(gauge);\n        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);\n        // add and fail loud if zero address or already present and not deprecated\n        if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGaugeError();\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Check if some previous weight exists and re-add to the total. Gauge and user weights are preserved.\n        weight = _getGaugeWeight[gauge].currentWeight;\n        if (weight > 0) {\n            _writeGaugeWeight(_totalWeight, _add112, weight, currentCycle);\n        }\n\n        emit AddGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function removeGauge(address gauge) external onlyOwner {\n        _removeGauge(gauge);\n    }\n\n    /**\n     * @notice Remove a gauge from the contract\n     * @param gauge the gauge to remove\n     */\n    function _removeGauge(address gauge) internal {\n        // add to deprecated and fail loud if not present\n        if (!_deprecatedGauges.add(gauge)) revert InvalidGaugeError();\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Remove weight from total but keep the gauge and user weights in storage in case the gauge is re-added.\n        uint112 weight = _getGaugeWeight[gauge].currentWeight;\n        if (weight > 0) {\n            _writeGaugeWeight(_totalWeight, _subtract112, weight, currentCycle);\n        }\n\n        emit RemoveGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function replaceGauge(address oldGauge, address newGauge) external onlyOwner {\n        _removeGauge(oldGauge);\n        _addGauge(newGauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function setMaxGauges(uint256 newMax) external onlyOwner {\n        uint256 oldMax = maxGauges;\n        maxGauges = newMax;\n\n        emit MaxGaugesUpdate(oldMax, newMax);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function setContractExceedMaxGauges(address account, bool canExceedMax) external onlyOwner {\n        if (canExceedMax && account.code.length == 0) revert Errors.NonContractError(); // can only approve contracts\n\n        canContractExceedMaxGauges[account] = canExceedMax;\n\n        emit CanContractExceedMaxGaugesUpdate(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires userUnusedVotes < amount.\n    /// _decrementWeightUntilFree is called as a greedy algorithm to free up weight.\n    /// It may be more gas efficient to free weight before burning or transferring tokens.\n\n    /**\n     * @notice Burns `amount` of tokens from `from` address.\n     * @dev Frees weights and votes with a greedy algorithm if needed to burn tokens\n     * @param from The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address from, uint256 amount) internal virtual override {\n        _decrementWeightUntilFree(from, amount);\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `msg.sender` to `to` address.\n     * @dev Frees weights and votes with a greedy algorithm if needed to burn tokens\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        _decrementWeightUntilFree(msg.sender, amount);\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `from` address to `to` address.\n     * @dev Frees weights and votes with a greedy algorithm if needed to burn tokens\n     * @param from the address to transfer from.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        _decrementWeightUntilFree(from, amount);\n        return super.transferFrom(from, to, amount);\n    }\n\n    /**\n     * @notice A greedy algorithm for freeing weight before a token burn/transfer\n     * @dev Frees up entire gauges, so likely will free more than `weight`\n     * @param user the user to free weight for\n     * @param weight the weight to free\n     */\n    function _decrementWeightUntilFree(address user, uint256 weight) internal nonReentrant {\n        uint256 userFreeWeight = freeVotes(user) + userUnusedVotes(user);\n\n        // early return if already free\n        if (userFreeWeight >= weight) return;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // cache totals for batch updates\n        uint112 userFreed;\n        uint112 totalFreed;\n\n        // Loop through all user gauges, live and deprecated\n        address[] memory gaugeList = _userGauges[user].values();\n\n        // Free gauges through the entire list or until underweight\n        uint256 size = gaugeList.length;\n        for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight;) {\n            address gauge = gaugeList[i];\n            uint112 userGaugeWeight = getUserGaugeWeight[user][gauge];\n            if (userGaugeWeight != 0) {\n                // If the gauge is live (not deprecated), include its weight in the total to remove\n                if (!_deprecatedGauges.contains(gauge)) {\n                    totalFreed += userGaugeWeight;\n                }\n                userFreed += userGaugeWeight;\n                _decrementGaugeWeight(user, gauge, userGaugeWeight, currentCycle);\n\n                unchecked {\n                    i++;\n                }\n            }\n        }\n\n        getUserWeight[user] -= userFreed;\n        _writeGaugeWeight(_totalWeight, _subtract112, totalFreed, currentCycle);\n    }\n}"
    },
    {
      "filename": "src/erc-20/ERC20MultiVotes.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Voting logic inspired by OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20MultiVotes} from \"./interfaces/IERC20MultiVotes.sol\";\n\n/// @title ERC20 Multi-Delegation Voting contract\nabstract contract ERC20MultiVotes is ERC20, Ownable, IERC20MultiVotes {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /*///////////////////////////////////////////////////////////////\n                        VOTE CALCULATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice votes checkpoint list per user.\n    mapping(address => Checkpoint[]) private _checkpoints;\n\n    /// @inheritdoc IERC20MultiVotes\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return _checkpoints[account].length.toUint32();\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function freeVotes(address account) public view virtual returns (uint256) {\n        return balanceOf[account] - userDelegatedVotes[account];\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function getVotes(address account) public view virtual returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function userUnusedVotes(address user) public view virtual returns (uint256) {\n        return getVotes(user);\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function getPriorVotes(address account, uint256 blockNumber) public view virtual returns (uint256) {\n        if (blockNumber >= block.number) revert BlockError();\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /// @dev Lookup a value in a list of (sorted) checkpoints.\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20MultiVotes\n    uint256 public override maxDelegates;\n\n    /// @inheritdoc IERC20MultiVotes\n    mapping(address => bool) public override canContractExceedMaxDelegates;\n\n    /// @inheritdoc IERC20MultiVotes\n    function setMaxDelegates(uint256 newMax) external onlyOwner {\n        uint256 oldMax = maxDelegates;\n        maxDelegates = newMax;\n\n        emit MaxDelegatesUpdate(oldMax, newMax);\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function setContractExceedMaxDelegates(address account, bool canExceedMax) external onlyOwner {\n        if (canExceedMax && account.code.length == 0) revert Errors.NonContractError(); // can only approve contracts\n\n        canContractExceedMaxDelegates[account] = canExceedMax;\n\n        emit CanContractExceedMaxDelegatesUpdate(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        DELEGATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice How many votes a user has delegated to a delegatee.\n    mapping(address => mapping(address => uint256)) private _delegatesVotesCount;\n\n    /// @notice How many votes a user has delegated to him.\n    mapping(address => uint256) public userDelegatedVotes;\n\n    /// @notice The delegatees of a user.\n    mapping(address => EnumerableSet.AddressSet) private _delegates;\n\n    /// @inheritdoc IERC20MultiVotes\n    function delegatesVotesCount(address delegator, address delegatee) public view virtual returns (uint256) {\n        return _delegatesVotesCount[delegator][delegatee];\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function delegates(address delegator) public view returns (address[] memory) {\n        return _delegates[delegator].values();\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function delegateCount(address delegator) public view returns (uint256) {\n        return _delegates[delegator].length();\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function incrementDelegation(address delegatee, uint256 amount) public virtual {\n        _incrementDelegation(msg.sender, delegatee, amount);\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function undelegate(address delegatee, uint256 amount) public virtual {\n        _undelegate(msg.sender, delegatee, amount);\n    }\n\n    /// @inheritdoc IERC20MultiVotes\n    function delegate(address newDelegatee) external virtual {\n        _delegate(msg.sender, newDelegatee);\n    }\n\n    /**\n     * @notice Delegates all votes from `delegator` to `delegatee`\n     * @dev Reverts if delegateCount > 1\n     * @param delegator The address to delegate votes from\n     * @param newDelegatee The address to delegate votes to\n     */\n    function _delegate(address delegator, address newDelegatee) internal virtual {\n        uint256 count = delegateCount(delegator);\n\n        // undefined behavior for delegateCount > 1\n        if (count > 1) revert DelegationError();\n\n        address oldDelegatee;\n        // if already delegated, undelegate first\n        if (count == 1) {\n            oldDelegatee = _delegates[delegator].at(0);\n            _undelegate(delegator, oldDelegatee, _delegatesVotesCount[delegator][oldDelegatee]);\n        }\n\n        // redelegate only if newDelegatee is not empty\n        if (newDelegatee != address(0)) {\n            _incrementDelegation(delegator, newDelegatee, freeVotes(delegator));\n        }\n        emit DelegateChanged(delegator, oldDelegatee, newDelegatee);\n    }\n\n    /**\n     * @notice Delegates votes from `delegator` to `delegatee`\n     * @dev Reverts if delegator is not approved and exceeds maxDelegates\n     * @param delegator The address to delegate votes from\n     * @param delegatee The address to delegate votes to\n     * @param amount The amount of votes to delegate\n     */\n    function _incrementDelegation(address delegator, address delegatee, uint256 amount) internal virtual {\n        // Require freeVotes exceed the delegation size\n        uint256 free = freeVotes(delegator);\n        if (delegatee == address(0) || free < amount || amount == 0) revert DelegationError();\n\n        bool newDelegate = _delegates[delegator].add(delegatee); // idempotent add\n        if (newDelegate && delegateCount(delegator) > maxDelegates && !canContractExceedMaxDelegates[delegator]) {\n            // if is a new delegate, exceeds max and is not approved to exceed, revert\n            revert DelegationError();\n        }\n\n        _delegatesVotesCount[delegator][delegatee] += amount;\n        userDelegatedVotes[delegator] += amount;\n\n        emit Delegation(delegator, delegatee, amount);\n        _writeCheckpoint(delegatee, _add, amount);\n    }\n\n    /**\n     * @notice Undelegates votes from `delegator` to `delegatee`\n     * @dev Reverts if delegatee does not have enough free votes\n     * @param delegator The address to undelegate votes from\n     * @param delegatee The address to undelegate votes to\n     * @param amount The amount of votes to undelegate\n     */\n    function _undelegate(address delegator, address delegatee, uint256 amount) internal virtual {\n        /**\n         * @dev delegatee needs to have sufficient free votes for delegator to undelegate.\n         *         Delegatee needs to be trusted, can be either a contract or an EOA.\n         *         If delegatee does not have any free votes and doesn't change their vote delegator won't be able to undelegate.\n         *         If it is a contract, a possible safety measure is to have an emergency clear votes.\n         */\n        if (userUnusedVotes(delegatee) < amount) revert UndelegationVoteError();\n\n        uint256 newDelegates = _delegatesVotesCount[delegator][delegatee] - amount;\n\n        if (newDelegates == 0) {\n            require(_delegates[delegator].remove(delegatee));\n        }\n\n        _delegatesVotesCount[delegator][delegatee] = newDelegates;\n        userDelegatedVotes[delegator] -= amount;\n\n        emit Undelegation(delegator, delegatee, amount);\n        _writeCheckpoint(delegatee, _subtract, amount);\n    }\n\n    /**\n     * @notice Writes a checkpoint for `delegatee` with `delta` votes\n     * @param delegatee The address to write a checkpoint for\n     * @param op The operation to perform on the checkpoint\n     * @param delta The difference in votes to write\n     */\n    function _writeCheckpoint(address delegatee, function(uint256, uint256) view returns (uint256) op, uint256 delta)\n        private\n    {\n        Checkpoint[] storage ckpts = _checkpoints[delegatee];\n\n        uint256 pos = ckpts.length;\n        uint256 oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        uint256 newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = newWeight.toUint224();\n        } else {\n            ckpts.push(Checkpoint({fromBlock: block.number.toUint32(), votes: newWeight.toUint224()}));\n        }\n        emit DelegateVotesChanged(delegatee, oldWeight, newWeight);\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires freeVotes(user) < amount.\n    /// _decrementVotesUntilFree is called as a greedy algorithm to free up votes.\n    /// It may be more gas efficient to free weight before burning or transferring tokens.\n\n    /**\n     * @notice Burns `amount` of tokens from `from` address.\n     * @dev Frees votes with a greedy algorithm if needed to burn tokens\n     * @param from The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address from,"
    }
  ]
}