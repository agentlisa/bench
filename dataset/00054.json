{
  "Title": "M-2: Integer overflow when calculating rewards",
  "Content": "# Issue M-2: Integer overflow when calculating rewards \n\nSource: https://github.com/sherlock-audit/2024-05-gamma-staking-judging/issues/207 \n\n## Found by \njoicygiore, pkqs90\n\n## Summary\n\nThe protocol uses a Sushi Masterchef like method for maintaining rewards for each user. The `cumulatedReward` variable is used for keeping track of the accumulated amount of assets per staking token. However, since `cumulatedReward` is scaled by 1e36, it may lead to overflow during reward calculation.\n\n## Vulnerability Detail\n\nLet's see how the reward is calculated:\n\n1. `cumulatedReward` is maintained as the cumulative asset/share ratio scaled by 1e36.\n2. Earned rewards and rewardDebt are calculated by `cumulatedReward` times the amount of shared token (with multiplier)\n\nThe issue here is `cumulatedReward` is scaled by 1e36, which is too large, and is susceptible to grief attacks. An example is:\n\n1. At the beginning of the Lock contract, attacker initially stakes 1 wei of staking token, and deposits 1e18 reward token.\n2. Attacker calls `notifyUnseenReward()` to accumulate the reward. The `cumulatedReward` is now 1e18 * 1e36 / 1 = 1e54.\n3. Then, when calculating the earned rewards, if anyone has 1e18 staking tokens, the reward calculation (and the reward debt) would be up to 1e54 * 1e18 = 1e72.\n\nNote that uint256.max is around 1e78, and the limit would be easily hit if the tokens in step 1 and step 3 is 1000e18 instead of 1e18.\n\n```solidity\n    function _notifyReward(address _rewardToken, uint256 reward) internal {\n        if (lockedSupplyWithMultiplier == 0)\n            return; // If there is no locked supply with multiplier, exit without adding rewards (prevents division by zero).\n\n        Reward storage r = rewardData[_rewardToken]; // Accesses the reward structure for the specified token.\n>       uint256 newReward = reward * 1e36 / lockedSupplyWithMultiplier; // Calculates the reward per token, scaled up for precision.\n>       r.cumulatedReward += newReward; // Updates the cumulative reward for the token.\n        r.lastUpdateTime = block.timestamp; // Sets the last update time to now.\n        r.balance += reward; // Increments the balance of the token by the new reward amount.\n    }\n\n    ...\n\n    function _earned(\n        address _user,\n        address _rewardToken\n    ) internal view returns (uint256 earnings) {\n        Reward memory rewardInfo = rewardData[_rewardToken]; // Retrieves reward data for the specified token.\n        Balances memory balance = balances[_user]; // Retrieves balance information for the user.\n>       earnings = rewardInfo.cumulatedReward * balance.lockedWithMultiplier - rewardDebt[_user][_rewardToken]; // Calculates earnings by considering the accumulated reward and the reward debt.\n    }\n\n```\n\n## Impact\n\nInteger overflow during reward calculation.\n\n## Code Snippet\n\n- https://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L493-L494\n- https://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L623\n\n## Tool used\n\nManual review\n\n## Recommendation\n\nCouple of ways for mitigation:\n\n1. Use 1e12 as scale factor (like in [Masterchef](https://github.com/sushiswap/masterchef/blob/master/contracts/MasterChef.sol#L56)) instead of 1e36.\n2. Since the staking token is always [GAMMA](https://etherscan.io/address/0x6bea7cfef803d1e3d5f7c0103f7ded065644e197) (which has 18 decimals) and is currently priced at $0.117, the `lockedSupplyWithMultiplier` can be initially set to 1e18 to avoid `cumulatedReward` to be too large. The loss is be negligible for initial stakers.\n3. Add a minimum staking amount limit (e.g. 1e18).\n\n\n\n## Discussion\n\n**santipu03**\n\nThis issue has been marked as invalid for the following reasons:\n1. Before users start staking, the admins have to set the staking token.\n2. Before anyone can send rewards to the contract, the admins have to set the reward tokens.\n3. For the reasons above, the admins can set the staking token first, wait for some stakers, and later set the reward tokens and send some to the contract. \n4. Even in the improbable case that this attack is successfully executed, because the only staker is the attacker, the admins can simply redeploy a new contract and stake a minimum amount first to avoid this issue again. If some users have started staking between the attack and the admin's action, they can simply withdraw their locks. \n\nIn conclusion, there won't be any loss of funds and the contract can simply be redeployed. \n\n**santipu03**\n\n@bjp333 What do you think about this issue?\n\n**bjp333**\n\nI think this issue is a bit of a stretch.  We will definitely have more than 1 wei staked prior to any distributions taking place.  \n\n**pkqs90**\n\nEscalate\n\nThe overflow scenario does not **only** occur during the beginning of the lock contract. As stated in the original issue, the beginning of the contract is only given as an example, since it is where this is likely to happen.\n\nThis issue may also occur when the contract has been active for a while. The reward tokens are already set, and due to users staking/unstaking, if there exists a moment where the `lockedSupplyWithMultiplier` is too little, this overflow issue will still occur.\n\nAlso, the original code itself handles the case where `lockedSupplyWithMultiplier` is zero, so it only makes sense that it should also handle where `lockedSupplyWithMultiplier` is 1 wei or 1e3 wei or something.\n\n```solidity\n    function _notifyReward(address _rewardToken, uint256 reward) internal {\n>       if (lockedSupplyWithMultiplier == 0)\n>           return; // If there is no locked supply with multiplier, exit without adding rewards (prevents division by zero).\n\n        Reward storage r = rewardData[_rewardToken]; // Accesses the reward structure for the specified token.\n        uint256 newReward = reward * 1e36 / lockedSupplyWithMultiplier; // Calculates the reward per token, scaled up for precision.\n        r.cumulatedReward += newReward; // Updates the cumulative reward for the token.\n        r.lastUpdateTime = block.timestamp; // Sets the last update time to now.\n        r.balance += reward; // Increments the balance of the token by the new reward amount.\n    }\n```\n\nNote that if this overflow issue happens, the entire protocol would brick. This is because reward calculation is used for all operations, including [staking](https://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L268), [early exiting](https://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L317), [late exiting](https://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L350), and [getting rewards](https://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L527). This means users would not be able to withdraw their staked tokens nor rewards once `cumulatedReward` overflows, which is a disaster.\n\nQuoting the definition of a medium severity issue, this issue would fall under \"cause loss of fund\" but \"requires certain external conditions or specific states\", and the loss itself definitely exceeds \"small, finite amount of funds\".\n\n> Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The losses must exceed small, finite amount of funds, and any amount relevant based on the precision or significance of the loss.\n\n**sherlock-admin3**\n\n> Escalate\n> \n> The overflow scenario does not **only** occur during the beginning of the lock contract. As stated in the original issue, the beginning of the contract is only given as an example, since it is where this is likely to happen.\n> \n> This issue may also occur when the contract has been active for a while. The reward tokens are already set, and due to users staking/unstaking, if there exists a moment where the `lockedSupplyWithMultiplier` is too little, this overflow issue will still occur.\n> \n> Also, the original code itself handles the case where `lockedSupplyWithMultiplier` is zero, so it only makes sense that it should also handle where `lockedSupplyWithMultiplier` is 1 wei or 1e3 wei or something.\n> \n> ```solidity\n>     function _notifyReward(address _rewardToken, uint256 reward) internal {\n> >       if (lockedSupplyWithMultiplier == 0)\n> >           return; // If there is no locked supply with multiplier, exit without adding rewards (prevents division by zero).\n> \n>         Reward storage r = rewardData[_rewardToken]; // Accesses the reward structure for the specified token.\n>         uint256 newReward = reward * 1e36 / lockedSupplyWithMultiplier; // Calculates the reward per token, scaled up for precision.\n>         r.cumulatedReward += newReward; // Updates the cumulative reward for the token.\n>         r.lastUpdateTime = block.timestamp; // Sets the last update time to now.\n>         r.balance += reward; // Increments the balance of the token by the new reward amount.\n>     }\n> ```\n> \n> Note that if this overflow issue happens, the entire protocol would brick. This is because reward calculation is used for all operations, including [staking](https://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L268), [early exiting](https://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L317), [late exiting](https://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L350), and [getting rewards](https://github.com/sherlock-audit/2024-05-gamma-staking/blob/main/StakingV2/src/Lock.sol#L527). This means users would not be able to withdraw their staked tokens nor rewards once `cumulatedReward` overflows, which is a disaster.\n> \n> Quoting the definition of a medium severity issue, this issue would fall under \"cause loss of fund\" but \"requires certain external conditions or specific states\", and the loss itself definitely exceeds \"small, finite amount of funds\".\n> \n> > Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The losses must exceed small, finite amount of funds, and any amount relevant based on the precision or significance of the loss.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**santipu03**\n\nEven though it is true that this issue can be triggered when the contract has been active for a while, it would require that the staked value is almost null, which is highly unlikely. Because the staking token is GAMMA, which is a token currently valued at ~0.14 USD and with 18 decimals, it's **almost impossible** that during the life of the contract, there are less than 1e18 tokens staked in total. \n\nIn a similar way, the classic vault inflation attack can always be triggered when `totalSupply` is 0, but the only real risk is when a Vault is deployed because it's the only realistic scenario where the total value deposited is strictly 0. \n\n**pkqs90**\n\nI agree that this is unlikely to happen. However,\n\n1. When talking about the severity of an issue, we should not talk about how likely it is to happen (some *almost impossible* examples that actually happened: the [Luna crash](https://rekt.news/venus-blizz-rekt/), or [USDC depeg](https://decrypt.co/123211/usdc-stablecoin-depegs-90-cents-circle-exposure-silicon-valley-bank)).\n2. The Sherlock rules also does not talk about the *possibility*, since it is impossible to quantify. The scenario described above is possible (however unlikely) and falls under \"certain external conditions or specific states\".\n\n> Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained. The losses must exceed small, finite amount of funds, and any amount relevant based on the precision or significance of the loss.\n\n**santipu03**\n\nAlso, take into account that there will be stakes locked for 720 days, which belong to the team and investors, so the requirements necessary for this bug to appear are not realistic at all. \n\nI don't believe it's fair to shield behind the expression _\"requires certain external conditions or specific states\"_ to defend issues that will never be triggered in reality. \n\n**pkqs90**\n\n> This issue has been marked as invalid for the following reasons:\n> \n> 1. Before users start staking, the admins have to set the staking token.\n> 2. Before anyone can send rewards to the contract, the admins have to set the reward tokens.\n> 3. For the reasons above, the admins can set the staking token first, wait for some stakers, and later set the reward tokens and send some to the contract.\n> 4. Even in the improbable case that this attack is successfully executed, because the only staker is the attacker, the admins can simply redeploy a new contract and stake a minimum amount first to avoid this issue again. If some users have started staking between the attack and the admin's action, they can simply withdraw their locks.\n> \n> In conclusion, there won't be any loss of funds and the contract can simply be redeployed.\n\nI'd also like to dispute the initial reasons for invalidating this issue.\n- For point 3, there would be no incentive for stakers if the reward token is not set. It is very likely that only *after* the admins set the reward token, would the users begin to stake.\n- For point 4, in order for the attacker to overflow `cumulatedReward`, he would have to be the first staker. He may even try to frontrun the original first staker. The point here is, after the attacker performs this attack, the staking of the following users would be affected. The admins can definitely just redeploy a new contract to fix this, but this would be unfair to users that has already staked in the original contract, and their tokens would be locked up for nothing.\n\n**santipu03**\n\n> - For point 3, there would be no incentive for stakers if the reward token is not set. It is very likely that only after the admins set the reward token, would the users begin to stake.\n\nHowever, before users would begin to stake, the developers would have already configured the locks for the team and investors, making it impossible to trigger this issue because many tokens are already staked. Realistically, the only moment an attacker can trigger this bug is at market deployment, but it won't be possible to execute the attack if the developers configure the contract correctly and set the locks for the team and investors before setting any reward tokens. \n\nEven under extreme circumstances where developers fail to configure the \"team and investor\" locks and deploy the contract, the worst outcome would necessitate redeploying the contract. If users have already staked in a compromised contract, admins could remove penalties, allowing users to withdraw their stakes early without consequences and reinvest in the new contract. Thus, even if this vulnerability were exploited, its actual impact would effectively be negligible.\n\n**nevillehuang**\n\nThis issue seems to be contigent on admin actions before the first notification of rewards. The difference between this and a first depositor inflation attack is the attack cannot immediately happen as long as the admin has taken the precautions (stake a minimum amount e.g. 1e18 before setting reward tokens), which is the case as well for ERC4626 vaults wherein a admin can deposit/mint a minimum amount of shares in deployment scripts\n\nI also note #72 and #313 as possible duplicates. Will discuss internally with lead judge. Historically based on my judging experience, first inflation attack and its mitigations must be explicitly stated as a known risk, so I am inclined to believe this issue is valid for now, although still considering the extensive admin actions required highlighted by lead judge before notification of rewards is allowed\n\ncc: @WangSecurity \n\n**0xRajkumar**\n\nConsidering all the points @santipu03 said, I would say the likelihood is very low. Therefore, I believe this is informational at best.\n\n**nevillehuang**\n\nI believe this issue to be valid with low likelihood and high impact because \n\n1. The admin actions to prevent this \"inflation attack\" is not highlighted in contest details and known risks + public discord channels\n2. The scenario of low amount of stakers resulting in extremely low lockedBalance while unlikely, is possible (if many users unstake), and will brick all subsequent stakers from getting rewards\n\nPlanning to accept escalation and [make issue and duplicates](https://github.com/sherlock-audit/2024-05-gamma-staking-judging/issues/207#issuecomment-2143105720) a valid medium severity. \n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [pkqs90](https://github.com/sherlock-audit/2024-05-gamma-staking-judging/issues/207/#issuecomment-2137430264): accepted\n\n**nevillehuang**\n\nConsidering issue #313 as the only duplicate of this issue asiIssue #72 fails to identify the correct attack path.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/330",
  "Code": [
    {
      "filename": "StakingV2/src/Lock.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {ILock, LockedBalance, Balances, Reward, RewardData} from \"./interfaces/ILock.sol\";\nimport {ILockList} from \"./interfaces/ILockList.sol\";\n\n/// @title Multi Fee Distribution Contract\n/// @author Gamma\n/// @dev All function calls are currently implemented without side effects\n\ncontract Lock is\n    ILock,\n    Initializable,\n    PausableUpgradeable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    // using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /********************** State Info ***********************/\n\n    uint256 public basePenaltyPercentage; //  15% - Represents the fixed penalty amount for unlocking early\n    uint256 public timePenaltyFraction; //  35% - Time-based penalty which decreases linearly with the passage of time\n    uint256 public constant WHOLE = 100000; // 100%\n    uint256 public defaultRelockTime;\n    bool public isEarlyExitDisabled;\n\n    /********************** Lock & Earn Info ***********************/\n\n    // Private mappings for balance data\n    mapping(address => Balances) private balances;\n\n    uint256 public lockedSupply;\n    uint256 public lockedSupplyWithMultiplier;\n\n    /********************** Reward Info ***********************/\n\n    address[] public rewardTokens;\n    mapping(address => bool) public rewardTokenAdded;\n    mapping(address => Reward) public rewardData;\n\n    uint256[] internal lockPeriod;\n    uint256[] internal rewardMultipliers;\n\n    /// @notice user -> reward token -> amount; reward amount for users\n    mapping(address => mapping(address => uint256)) public rewards;\n    /// @notice user -> reward token -> amount; paid reward amount for users\n    mapping(address => mapping(address => uint256)) public rewardPaid;\n    /// @notice user -> reward token -> amount; reward debt amount\n    mapping(address => mapping(address => uint256)) internal rewardDebt;\n\n\n    /********************** Other Info ***********************/\n\n    address public override stakingToken;\n    address public treasury;\n\n    /// @notice Users list\n    ILockList public locklist;\n\n\n    /// @notice Initializes contract with lock list, base penalty percentage, and time penalty fraction.\n    /// @dev Sets up the contract with initial configuration necessary for operation. This function acts as a substitute for a constructor in upgradeable contracts and can only be called once.\n    /// @param _locklist Address of the lock list contract, which manages lock details.\n    /// @param _basePenaltyPercentage The base penalty percentage applied for early exits, scaled by 100000 for precision.\n    /// @param _timePenaltyFraction The additional penalty fraction based on time, also scaled by 100000.\n\n    function initialize(\n        address _locklist,\n        uint128 _basePenaltyPercentage,\n        uint128 _timePenaltyFraction,\n        address _owner\n    ) public initializer {\n        __Ownable_init(_owner);\n        if (_locklist == address(0)) revert AddressZero();\n        if (_basePenaltyPercentage > WHOLE || _timePenaltyFraction > WHOLE)\n            revert WrongScaledPenaltyAmount();\n\n        locklist = ILockList(_locklist);\n        basePenaltyPercentage = _basePenaltyPercentage;\n        timePenaltyFraction = _timePenaltyFraction;\n        defaultRelockTime = 30 days;\n    }\n\n    /********************** Setters ***********************/\n\n\n    /// @notice Sets the base penalty percentage and time penalty fraction for early exits.\n    /// @dev This function can only be called by the owner of the contract and updates penalty attributes.\n    /// @param _basePenaltyPercentage The new base penalty percentage, scaled by 100000 for precision.\n    /// @param _timePenaltyFraction The new time penalty fraction, also scaled by 100000 for precision.\n    function setPenaltyCalcAttributes(uint256 _basePenaltyPercentage, uint256 _timePenaltyFraction) external onlyOwner {\n        if (_basePenaltyPercentage > WHOLE || _timePenaltyFraction > WHOLE)\n            revert WrongScaledPenaltyAmount();\n        basePenaltyPercentage = _basePenaltyPercentage;\n        timePenaltyFraction = _timePenaltyFraction;\n        emit SetPenaltyCalcAttribute(_basePenaltyPercentage, _timePenaltyFraction);\n    }\n\n    /// @notice Sets the minimum relock time after a late exit.\n    /// @dev This function can only be called by the contract owner and updates the default relock time.\n    /// @param _defaultRelockTime The new default relock time in seconds.\n    function setDefaultRelockTime(uint256 _defaultRelockTime) external onlyOwner {\n        defaultRelockTime = _defaultRelockTime;\n    }\n\n\n    /// @notice Enables or disables the ability for users to perform early exits from locks.\n    /// @dev This function can only be called by the contract owner and updates the state that controls early exits.\n    /// @param _isEarlyExitDisabled A boolean value indicating whether early exits should be disabled (`true` to disable, `false` to enable).\n    function setIsEarlyExitDisabled(bool _isEarlyExitDisabled) external onlyOwner {\n        isEarlyExitDisabled = _isEarlyExitDisabled;\n    }\n\n\n    /// @notice Configures lock periods and their corresponding reward multipliers for staking.\n    /// @dev This function can only be called by the contract owner and is used to set or update the lock periods and reward multipliers arrays.\n    /// @param _lockPeriod An array of lock periods in seconds.\n    /// @param _rewardMultipliers An array of multipliers corresponding to each lock period; these multipliers enhance the rewards for longer lock periods.\n    function setLockTypeInfo(\n        uint256[] calldata _lockPeriod,\n        uint256[] calldata _rewardMultipliers\n    ) external onlyOwner {\n        if (_lockPeriod.length != _rewardMultipliers.length)\n            revert InvalidLockPeriod();\n        delete lockPeriod;\n        delete rewardMultipliers;\n        uint256 length = _lockPeriod.length;\n        for (uint256 i; i < length; ) {\n            lockPeriod.push(_lockPeriod[i]);\n            rewardMultipliers.push(_rewardMultipliers[i]);\n            unchecked {\n                i++;\n            }\n        }\n\n        emit SetLockTypeInfo(lockPeriod, rewardMultipliers);\n    }\n\n\n    /// @notice Sets the token address that will be used for staking purposes.\n    /// @dev This function can only be called by the contract owner and will set the staking token \n    /// @param _stakingToken The address of the token to be used as the staking token.\n    function setStakingToken(address _stakingToken) external onlyOwner {\n        if (_stakingToken == address(0) || stakingToken != address(0)) revert AddressZero();\n        stakingToken = _stakingToken;\n\n        emit SetStakingToken(_stakingToken);\n    }\n\n\n    /// @notice Assigns the specified address as the treasury for the contract.\n    /// @dev This function can only be called by the contract owner to set the treasury address.\n    /// @param _treasury The address to be designated as the treasury.\n    function setTreasury(address _treasury) external onlyOwner {\n        treasury = _treasury;\n        emit SetTreasury(_treasury);\n    }\n\n\n    /// @notice Adds a new token to the list of reward tokens that will be distributed to stakers.\n    /// @dev This function can only be called by the contract owner and checks for validity of the reward token before adding.\n    /// @param _rewardToken The address of the token to be added as a reward token.\n    function addReward(address _rewardToken) external override onlyOwner {\n        if (_rewardToken == address(0)) revert InvalidBurn();\n        if (rewardData[_rewardToken].lastUpdateTime != 0) revert AlreadyAdded();\n        if (_rewardToken == stakingToken || rewardTokenAdded[_rewardToken]) revert InvalidRewardToken();\n        rewardTokens.push(_rewardToken);\n        rewardTokenAdded[_rewardToken] = true;\n\n        Reward storage reward = rewardData[_rewardToken];\n        reward.lastUpdateTime = block.timestamp;\n        emit AddReward(_rewardToken);\n    }\n\n    /********************** View functions ***********************/\n\n    /**\n     * @notice Return lock duration.\n     */\n    function getLockDurations() external view returns (uint256[] memory) {\n        return lockPeriod;\n    }\n\n    /**\n     * @notice Return reward multipliers.\n     */\n    function getLockMultipliers() external view returns (uint256[] memory) {\n        return rewardMultipliers;\n    }\n    /**\n     * @notice Total balance of an account, including unlocked, locked and earned tokens.\n     */\n    function getBalances(\n        address _user\n    ) external view returns (Balances memory) {\n        return balances[_user];\n    }\n\n\n    /// @notice Retrieves the address and claimable amount of all reward tokens for the specified account.\n    /// @dev This function computes claimable rewards based on stored reward balances and newly earned amounts.\n    /// @param account The address of the account for which reward information is being requested.\n    /// @return rewardsData An array of RewardData structs, each containing a token address and the amount claimable by the account.\n    function claimableRewards(\n        address account\n    )\n        external\n        view\n        override\n        returns (RewardData[] memory rewardsData)\n    {\n        uint256 length = rewardTokens.length;\n        rewardsData = new RewardData[](length);\n        for (uint256 i; i < length; ) {\n            rewardsData[i].token = rewardTokens[i];\n\n            rewardsData[i].amount = (_earned(\n                account,\n                rewardsData[i].token\n            ) + rewards[account][rewardTokens[i]]) / 1e36;\n            unchecked {\n                i++;\n            }\n        }\n        return rewardsData;\n    }\n\n    /********************** Operate functions ***********************/\n\n\n    /// @notice Allows a user to stake tokens on behalf of another address, specifying the lock type to determine reward eligibility and lock duration.\n    /// @dev Calls an internal function to handle the staking logic with `isRelock` set to `false`.\n    /// @param amount The amount of tokens to be staked.\n    /// @param onBehalfOf The address on behalf of which tokens are being staked. On frontend, this will be set to the msg.sender's address by default.\n    /// @param typeIndex An index referring to the type of lock to be applied, which affects reward calculations and lock duration.\n    function stake(\n        uint256 amount,\n        address onBehalfOf,\n        uint256 typeIndex\n    ) external override {\n        _stake(amount, onBehalfOf, typeIndex, false);\n    }\n\n    /// @notice Handles the internal logic for staking tokens, applying specified lock types and managing reward eligibility.\n    /// @dev This function updates rewards, manages balances, and logs the staking process through events.\n    ///      It ensures the amount and lock type are valid, adjusts token balances, and optionally handles token transfers for re-staking.\n    /// @param amount The amount of tokens to be staked.\n    /// @param onBehalfOf The address for which tokens are being staked.\n    /// @param typeIndex The index of the lock type to apply, affecting reward multipliers and lock durations.\n    /// @param isRelock Specifies whether the staking is for relocking already staked tokens.\n    function _stake(\n        uint256 amount,\n        address onBehalfOf,\n        uint256 typeIndex,\n        bool isRelock\n    ) internal whenNotPaused {\n        if (typeIndex >= lockPeriod.length || amount == 0) revert InvalidAmount();\n\n        _updateReward(onBehalfOf);\n        \n        Balances storage bal = balances[onBehalfOf];\n\n        bal.locked += amount;\n        lockedSupply += amount;\n\n        uint256 multiplier = rewardMultipliers[typeIndex];\n        bal.lockedWithMultiplier += amount * multiplier;\n        lockedSupplyWithMultiplier += amount * multiplier;\n        _updateRewardDebt(onBehalfOf);\n\n\n        locklist.addToList(\n            onBehalfOf, \n            LockedBalance({\n                lockId: 0, // This will be set inside the addToList function\n                amount: amount,\n                unlockTime: 0, \n                multiplier: multiplier,\n                lockTime: block.timestamp,\n                lockPeriod: lockPeriod[typeIndex],\n                exitedLate: false\n            })\n        );\n\n        if (!isRelock) {\n            IERC20(stakingToken).safeTransferFrom(\n                msg.sender,\n                address(this),\n                amount\n            );\n        }\n\n        emit Locked(\n            onBehalfOf,\n            amount,\n            balances[onBehalfOf].locked\n        );\n    }\n\n\n    /// @notice Allows a staker to perform an early exit from a locked position using the specified lock ID.\n    /// @dev This function handles the early exit process, calculating penalties, updating balances, and transferring funds.\n    /// @param lockId The unique identifier of the lock from which the user wishes to exit early.\n    function earlyExitById(uint256 lockId) external whenNotPaused {\n        if (isEarlyExitDisabled) {\n            revert EarlyExitDisabled();\n        }\n        _updateReward(msg.sender);\n\n        LockedBalance memory lock = locklist.getLockById(msg.sender, lockId);\n\n        if (lock.unlockTime != 0)\n            revert InvalidLockId();\n        uint256 coolDownSecs = calcRemainUnlockPeriod(lock);\n        lock.unlockTime = block.timestamp + coolDownSecs;\n        uint256 penaltyAmount = calcPenaltyAmount(lock);\n        locklist.removeFromList(msg.sender, lockId);\n        Balances storage bal = balances[msg.sender];\n        lockedSupplyWithMultiplier -= lock.amount * lock.multiplier;\n        lockedSupply -= lock.amount;\n        bal.locked -= lock.amount;\n        bal.lockedWithMultiplier -= lock.amount * lock.multiplier;\n\n        _updateRewardDebt(msg.sender);\n\n        if (lock.amount > penaltyAmount) {\n            IERC20(stakingToken).safeTransfer(msg.sender, lock.amount - penaltyAmount);\n            IERC20(stakingToken).safeTransfer(treasury, penaltyAmount);\n            emit EarlyExitById(lockId, msg.sender, lock.amount - penaltyAmount, penaltyAmount);\n        } else {\n            IERC20(stakingToken).safeTransfer(treasury, lock.amount);\n        emit EarlyExitById(lockId, msg.sender, 0, penaltyAmount);\n        }\n    }\n\n\n    /// @notice Allows a user to execute a late exit from a lock by specifying the lock ID, updating unlock times and reducing locked balances.\n    /// @dev This function adjusts the unlock time based on the remaining cooldown period, updates the locked balances, flags the lock as exited late, and logs the exit.\n    /// @param id The unique identifier of the lock from which the user wishes to exit late.\n    function exitLateById(uint256 id) external {\n        _updateReward(msg.sender); // Updates any pending rewards for the caller before proceeding.\n\n        LockedBalance memory lockedBalance = locklist.getLockById(msg.sender, id); // Retrieves the lock details from the lock list as a storage reference to modify.\n\n        // Calculate and set the new unlock time based on the remaining cooldown period.\n        uint256 coolDownSecs = calcRemainUnlockPeriod(lockedBalance);\n        locklist.updateUnlockTime(msg.sender, id, block.timestamp + coolDownSecs);\n\n        // Reduce the locked supply and the user's locked balance with and without multiplier.\n        uint256 multiplierBalance = lockedBalance.amount * lockedBalance.multiplier;\n        lockedSupplyWithMultiplier -= multiplierBalance;\n        lockedSupply -= lockedBalance.amount;\n        Balances storage bal = balances[msg.sender];\n        bal.lockedWithMultiplier -= multiplierBalance;\n        bal.locked -= lockedBalance.amount;\n\n        locklist.setExitedLateToTrue(msg.sender, id);\n\n        _updateRewardDebt(msg.sender); // Recalculates reward debt after changing the locked balance.\n\n        emit ExitLateById(id, msg.sender, lockedBalance.amount); // Emits an event logging the details of the late exit.\n    }\n\n\n    /// @notice Allows a user to restake funds after exiting late by mistake.\n    /// @dev Enforces restrictions on the new lock period based on the current lock period and default relock time.\n    /// @param id The ID of the lock that was exited late and needs to be re-staked.\n    /// @param typeIndex The new lock type index to apply for the restake.\n    function restakeAfterLateExit(uint256 id, uint256 typeIndex) external {\n        // Retrieve the lock details for the specified ID.\n        LockedBalance memory lockedBalance = locklist.getLockById(msg.sender, id);\n        require(lockedBalance.exitedLate, \"This lock was not exited late or is ineligible for restaking.\");\n\n        uint256 newLockPeriod = lockPeriod[typeIndex]; // Get the new lock period based on the type index.\n        uint256 currentLockPeriod = lockedBalance.lockPeriod;\n\n        // Enforce that the new lock period must be valid based on the current conditions.\n        if (currentLockPeriod <= defaultRelockTime || (block.timestamp - lockedBalance.lockTime) < currentLockPeriod) {\n            require(newLockPeriod >= currentLockPeriod, \"New lock period must be greater than or equal to the current lock period\");\n        } else {\n            require(newLockPeriod >= defaultRelockTime, \"New lock period must be greater than or equal to the default relock time\");\n        }\n\n        // Proceed to restake the funds using the new lock type.\n        _stake(lockedBalance.amount, msg.sender, typeIndex, true);\n\n        // Remove the old lock record to prevent any further operations on it.\n        locklist.removeFromList(msg.sender, id);\n\n        emit RestakedAfterLateExit(msg.sender, id, lockedBalance.amount, typeIndex);\n    }\n\n\n\n\n\n\n    /// @notice Withdraws all currently unlocked tokens where the unlock time has passed for the calling user.\n    /// @dev Iterates through the list of all locks for the user, checks if the unlock time has passed, and withdraws the total unlocked amount.\n    function withdrawAllUnlockedToken() external override nonReentrant {\n        uint256 lockCount = locklist.lockCount(msg.sender); // Fetch the total number of locks for the caller.\n        uint256 page;\n        uint256 limit;\n        uint256 totalUnlocked;\n        \n        while (limit < lockCount) {\n            LockedBalance[] memory lockedBals = locklist.getLocks(msg.sender, page, lockCount); // Retrieves a page of locks for the user.\n            for (uint256 i = 0; i < lockedBals.length; i++) {\n                if (lockedBals[i].unlockTime != 0 && lockedBals[i].unlockTime < block.timestamp) {\n                    totalUnlocked += lockedBals[i].amount; // Adds up the amount from all unlocked balances.\n                    locklist.removeFromList(msg.sender, lockedBals[i].lockId); // Removes the lock from the list.\n                }\n            }\n\n            limit += 10; // Moves to the next page of locks.\n            page++;\n        }\n\n        IERC20(stakingToken).safeTransfer(msg.sender, totalUnlocked); // Transfers the total unlocked amount to the user.\n        emit WithdrawAllUnlocked(msg.sender, totalUnlocked); // Emits an event logging the withdrawal.\n    }\n\n\n\n    /// @notice Withdraws a specific unlocked token amount using the given lock ID, if the unlock time has passed.\n    /// @dev Retrieves the lock details by ID, checks if it is unlocked, and transfers the unlocked amount to the user.\n    /// @param id The unique identifier of the lock to check for unlocked tokens.\n    function withdrawUnlockedTokenById(uint256 id) external nonReentrant {\n        LockedBalance memory lockedBal = locklist.getLockById(msg.sender, id); // Retrieves the lock details for the specified ID.\n        if (lockedBal.unlockTime != 0 && lockedBal.unlockTime < block.timestamp) {\n            IERC20(stakingToken).safeTransfer(msg.sender, lockedBal.amount); // Transfers the unlocked amount to the user.\n            locklist.removeFromList(msg.sender, id); // Removes the lock from the lock list.\n            emit WithdrawUnlockedById(id, msg.sender, lockedBal.amount); // Emits an event logging the withdrawal of the unlocked tokens.\n        }\n    }\n\n\n    /********************** Reward functions ***********************/\n\n\n    /// @notice Calculates the earnings accumulated for a given user and reward token.\n    /// @dev Calculates the net earnings by multiplying the accumulated reward with the userâ€™s locked multiplier and subtracting the reward debt.\n    /// @param _user The address of the user for whom to calculate earnings.\n    /// @param _rewardToken The token address for which earnings are calculated.\n    /// @return earnings The calculated amount of earnings for the user in terms of the specified reward token.\n    function _earned(\n        address _user,\n        address _rewardToken\n    ) internal view returns (uint256 earnings) {\n        Reward memory rewardInfo = rewardData[_rewardToken]; // Retrieves reward data for the specified token.\n        Balances memory balance = balances[_user]; // Retrieves balance information for the user.\n        earnings = rewardInfo.cumulatedReward * balance.lockedWithMultiplier - rewardDebt[_user][_rewardToken]; // Calculates earnings by considering the accumulated reward and the reward debt.\n    }\n\n\n\n    /// @notice Checks for and registers any rewards sent to the contract that have not yet been accounted for.\n    /// @dev This function is used to update the contract's state with rewards received but not yet recorded, \n    ///      for example, tokens sent directly to the contract's address \n    ///      It should be called periodically, ideally every 24 hours, to ensure all external rewards are captured.\n    /// @param token The address of the reward token to check for new, unseen rewards.\n    function _notifyUnseenReward(address token) internal {\n        if (token == address(0)) revert AddressZero(); // Ensures the token address is not zero.\n        Reward storage r = rewardData[token]; // Accesses the reward data for the given token.\n        uint256 unseen = IERC20(token).balanceOf(address(this)) - r.balance; // Calculates the amount of new, unseen rewards.\n\n        if (unseen > 0) {\n            _notifyReward(token, unseen); // Updates the reward data if there are new rewards.\n        }\n\n        emit NotifyUnseenReward(token, unseen); // Emits an event to log the notification of unseen rewards.\n    }\n\n\n    /// @notice Updates the reward data for a specific token with a new reward amount.\n    /// @dev Adds the specified reward to the cumulative reward for the token, adjusting for the total locked supply with multiplier.\n    /// @param _rewardToken The address of the reward token for which to update the reward data.\n    /// @param reward The amount of the new reward to be added.\n    function _notifyReward(address _rewardToken, uint256 reward) internal {\n        if (lockedSupplyWithMultiplier == 0)\n            return; // If there is no locked supply with multiplier, exit without adding rewards (prevents division by zero).\n\n        Reward storage r = rewardData[_rewardToken]; // Accesses the reward structure for the specified token.\n        uint256 newReward = reward * 1e36 / lockedSupplyWithMultiplier; // Calculates the reward per token, scaled up for precision.\n        r.cumulatedReward += newReward; // Updates the cumulative reward for the token.\n        r.lastUpdateTime = block.timestamp; // Sets the last update time to now.\n        r.balance += reward; // Increments the balance of the token by the new reward amount.\n    }\n\n\n\n    /// @notice Checks and updates unseen rewards for a list of reward tokens.\n    /// @dev Iterates through the provided list of reward tokens and triggers the _notifyUnseenReward function for each if it has been previously added to the contract.\n    /// @param _rewardTokens An array of reward token addresses to check and update for unseen rewards.\n    function notifyUnseenReward(address[] memory _rewardTokens) external {\n        uint256 length = rewardTokens.length; // Gets the number of reward tokens currently recognized by the contract.\n        for (uint256 i = 0; i < length; ++i) {\n            if (rewardTokenAdded[_rewardTokens[i]]) {\n                _notifyUnseenReward(_rewardTokens[i]); // Processes each token to update any unseen rewards.\n            }\n        }\n    }\n\n\n\n    /// @notice Retrieves and claims all pending staking rewards for the caller across all reward tokens.\n    /// @dev This function serves as a convenience wrapper around the `getReward` function, applying it to all reward tokens currently recognized by the contract.\n    function getAllRewards() external {\n        getReward(rewardTokens); // Calls the getReward function with the list of all reward tokens to claim all pending rewards.\n    }\n\n\n\n    /// @notice Claims pending staking rewards for the caller for specified reward tokens.\n    /// @dev Updates reward calculations for the caller, then processes claims for the provided list of reward tokens.\n    /// @param _rewardTokens An array of reward token addresses from which rewards are to be claimed.\n    function getReward(address[] memory _rewardTokens) public nonReentrant {\n        _updateReward(msg.sender); // Updates any accrued rewards up to the current point for the caller.\n        _getReward(msg.sender, _rewardTokens); // Calls the internal _getReward function to process the actual reward claim.\n    }\n\n\n\n    /// @notice Transfers accrued rewards for specified tokens to the user.\n    /// @dev Iterates through the list of reward tokens and transfers each accrued reward to the user's address, provided the reward amount is greater than zero.\n    ///      This function also updates the reward balances and logs the reward payments.\n    /// @param _user The address of the user receiving the rewards.\n    /// @param _rewardTokens An array of reward token addresses from which the user is claiming rewards.\n    function _getReward(\n        address _user,\n        address[] memory _rewardTokens\n    ) internal whenNotPaused {\n        uint256 length = _rewardTokens.length; // Get the number of reward tokens to process.\n        for (uint256 i = 0; i < length; ) {\n            address token = _rewardTokens[i]; // Get the current token address.\n\n            uint256 reward = rewards[_user][token]; // Retrieve the amount of reward due for the user and the token.\n            if (reward > 0) {\n                rewards[_user][token] = 0; // Reset the reward to zero after claiming.\n                rewardData[token].balance -= reward / 1e36; // Deduct the reward from the stored balance, adjusting for decimals.\n\n                IERC20(token).safeTransfer(_user, reward / 1e36); // Transfer the reward to the user.\n                rewardPaid[_user][token] += reward / 1e36; // Update the total reward paid to the user for this token.\n                emit RewardPaid(_user, token, reward / 1e36); // Emit an event documenting the reward payment.\n            }\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n\n    /********************** Eligibility + Disqualification ***********************/\n\n\n    /// @notice Calculates the penalty amount for an early exit from a locked position based on the remaining time until the scheduled unlock.\n    /// @dev The penalty is computed as a percentage of the locked amount, which is scaled by a base penalty percentage plus a time-dependent penalty fraction.\n    /// @param userLock A struct containing details about the user's locked balance, including the amount, lock period, and unlock time.\n    /// @return penaltyAmount The amount of penalty to be applied if the user decides to exit early from the lock.\n    function calcPenaltyAmount(LockedBalance memory userLock) public view returns (uint256 penaltyAmount) {\n        if (userLock.amount == 0) return 0; // Return zero if there is no amount locked to avoid unnecessary calculations.\n        uint256 unlockTime = userLock.unlockTime;\n        uint256 lockPeriod = userLock.lockPeriod;\n        uint256 penaltyFactor;\n\n\n        if (lockPeriod <= defaultRelockTime || (block.timestamp - userLock.lockTime) < lockPeriod) {\n\n            penaltyFactor = (unlockTime - block.timestamp) * timePenaltyFraction / lockPeriod + basePenaltyPercentage;\n        }\n        else {\n            penaltyFactor = (unlockTime - block.timestamp) * timePenaltyFraction / defaultRelockTime + basePenaltyPercentage;\n        }\n\n        // Apply the calculated penalty factor to the locked amount.\n        penaltyAmount = userLock.amount * penaltyFactor / WHOLE;\n    }\n\n\n\n    /// @notice Determines the remaining time until a user's locked balance can be unlocked.\n    /// @dev Calculates the remaining unlock period based on either the lock's specific period or the default relock time, depending on which is relevant.\n    ///      The function checks if the lock period is still applicable, or if the default relock time should be used instead.\n    ///      The lock period should always be the lesser of the user's own lock period or the default lock period.   \n    /// @param userLock A struct containing the lock's details, including the lock period, multiplier, and the timestamp when the lock was initiated.\n    /// @return uint256 of remaining time in seconds until the lock can be unlocked.\n    function calcRemainUnlockPeriod(LockedBalance memory userLock) public view returns (uint256) {\n        uint256 lockTime = userLock.lockTime;\n        uint256 lockPeriod = userLock.lockPeriod;\n        \n        if (lockPeriod <= defaultRelockTime || (block.timestamp - lockTime) < lockPeriod) {\n            // If the adjusted lock period is less than or equal to the default relock time, or if the current time is still within the adjusted lock period, return the remaining time based on the adjusted lock period.\n            return lockPeriod - (block.timestamp - lockTime) % lockPeriod;\n        } else {\n            // If the current time exceeds the adjusted lock period, return the remaining time based on the default relock time.\n            return defaultRelockTime - (block.timestamp - lockTime) % defaultRelockTime;\n        }\n    }\n\n\n\n    /// @notice Updates the accumulated rewards and reward debts for all tokens for a specific user account.\n    /// @dev Iterates over all reward tokens, updates each token's accrued rewards for the given account, and adjusts the reward debt accordingly.\n    /// @param account The address of the user for whom rewards are being updated.\n    function _updateReward(address account) internal {\n        uint256 length = rewardTokens.length; // Determine the number of reward tokens.\n        Balances storage bal = balances[account]; // Access the balance record for the user.\n\n        for (uint256 i = 0; i < length; ) {\n            address token = rewardTokens[i]; // Access each token.\n            Reward memory rewardInfo = rewardData[token]; // Get the reward data for the token.\n\n            rewards[account][token] += _earned(account, token); // Update the rewards for the user based on what has been earned so far.\n            rewardDebt[account][token] = rewardInfo.cumulatedReward * bal.lockedWithMultiplier; // Update the reward debt based on the latest reward information.\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n\n\n    /// @notice Updates the reward debt for all reward tokens based on the current cumulated rewards and the user's locked balances.\n    /// @dev Iterates over all reward tokens and recalculates the reward debt for the specified user, based on their locked balances multiplied by the accumulated rewards for each token.\n    /// @param _user The address of the user for whom the reward debt is being recalculated.\n    function _updateRewardDebt(address _user) internal {\n        Balances memory bal = balances[_user]; // Retrieve the current balance information for the user.\n\n        for (uint i = 0; i < rewardTokens.length; ++i) {\n            address rewardToken = rewardTokens[i]; // Access each reward token.\n            Reward memory rewardInfo = rewardData[rewardToken]; // Get the current reward data for each token.\n\n            // Recalculate the reward debt for the user based on their locked balances and the"
    }
  ]
}