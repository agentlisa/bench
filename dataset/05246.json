{
  "Title": "[M-14] Ballots not yet past their deadline are incorrectly looped too by tokenWhitelistingBallotWithTheMostVotes()",
  "Content": "\nInside `DAO.sol`, [\\_finalizeTokenWhitelisting()](https://github.com/code-423n4/2024-01-salty/blob/main/src/dao/DAO.sol#L250) before finalizing a token whitelisting proposal makes a check that it's the ballot with most votes:\n\n```js\n249\t\t\t// Fail to whitelist for now if this isn't the whitelisting proposal with the most votes - can try again later.\n250\t\t\tuint256 bestWhitelistingBallotID = proposals.tokenWhitelistingBallotWithTheMostVotes();\n251\t\t\trequire( bestWhitelistingBallotID == ballotID, \"Only the token whitelisting ballot with the most votes can be finalized\" );\n```\n\nThe [tokenWhitelistingBallotWithTheMostVotes()](https://github.com/code-423n4/2024-01-salty/blob/main/src/dao/Proposals.sol#L417) function however does not care if the other ballots being looped through are yet not past their deadline. This is an incorrect approach because a ballot which has more `Yes` votes at this point of time may well turn into a rejected ballot by its deadline timestamp if additional `No` votes are cast in coming days. Hence using its current state to deny whitelisting of a proposal past its deadline is unfair & only contributes to delaying the timelines, since this may happen again & again which would result in the protocol repeatedly pushing the finalization time further & further away into the future.<br>\n\n*   Either only ballots past their deadline should be considered, OR\n*   Only compare ballots which were created within a few hours of each other\n\nExplanation through an example scenario *(also provided in the form of a coded PoC in the next section)*:\n\n*   Dan, Alice and Bob stake some salt. Dan = `2,400,000`, Alice = `290,000` and Bob = `310,000`\n*   Hence, total staked salt = `6,000,000`\n*   Alice floats ProposalA for token whitelisting with deadline timestamp `t_a`\n*   Minimum quorum required is 20% of 6,000,000 = `600,000`\n*   ProposalA receives votes : `YES = 310,000; NO = 290,000`. Quorum reached.\n*   Just a day before `t_a`, Bob floats ProposalB for whitelisting with deadline timestamp `t_b`\n*   ProposalB receives votes : `YES = 600,000; NO = 0`. Quorum reached. Also, ProposalB has more `Yes` votes than ProposalA.\n*   At timestamp `t_a`, `finalizeBallot()` is called for ProposalA but it faces a `revert` on [L251](https://github.com/code-423n4/2024-01-salty/blob/main/src/dao/DAO.sol#L251) because ProposalB has greater `Yes` votes\n*   An hour before `t_b`, Dan casts his `No` vote for ProposalB which results in : `YES = 600,000; NO = 2,400,000` making it lose with overwhelming majority.\n*   Note that instead of the above step, another possibility is that some of the current 'Yes`voters change their vote to`No\\`.\n*   `finalizeBallot()` can be called again for ProposalA and it would pass now ***given that no other proposal has been floated meanwhile which has accumulated more votes***, else we could keep going through the above cycle once again.\n\n**This caused a delay of around 11 days in ProposalA's finalization.** This works as a good attack vector for a malicious staker who wishes to postpone someone's else proposal but does not have enough voting power to defeat it. With some positive votes coming their way from unsuspecting stakers, they can mount this attack. Here's how:\n\n*   Alice and Bob stake some salt. Alice = `290,000` and Bob = `310,000`. Bob is the malicious actor here.\n*   Remaining salt is staked by other normal users amounting to `2,400,000`\n*   Hence, total staked salt = `6,000,000`\n*   Alice floats ProposalA for token whitelisting with deadline timestamp `t_a`\n*   Minimum quorum required is 20% of 6,000,000 = `600,000`\n*   ProposalA receives votes : `YES = 315,000; NO = 310,000`. Quorum reached. Bob had voted `No`, but he could not overcome the `Yes` votes, getting beat by a small margin.\n*   Bob attempts his attack. A few days before `t_a`, Bob floats ProposalB for whitelisting with deadline timestamp `t_b` and votes `Yes` himself.\n*   Some unsuspecting users don't have anything against his proposal and choose to vote `Yes`. At timestamp `t_a` his vote tally turns out to be `YES = 320,000; NO = 319,990`. In spite of being very close to losing the ballot, he still has more `Yes` votes than ProposalA.\n*   At timestamp `t_a` when `finalizeBallot()` is called for ProposalA, it faces a `revert` due to having lesser votes. Bob successfully delayed ProposalA's finalization.\n*   Bob was never really interested in whitelisting any token, so upon reaching close to his deadline `t_b`, he can choose to change his votes to `No` and let the proposal fail.\n\n### Proof of Concept\n\nAdd the following tests inside `src/dao/tests/DAO.t.sol` and run via `COVERAGE=\"yes\" NETWORK=\"sep\" forge test -vv --rpc-url https://rpc.ankr.com/eth_sepolia --mt test_tokenWhitelistingDelayed` to see the test pass:\n\n<details>\n\n```js\n\tfunction test_tokenWhitelistingDelayed() public\n\t\t{\n\t\t// *************** Setup steps ***************\n        deal(address(salt), address(DEPLOYER), 2_400_000 ether);\n\t\tuint256 aliceStakedAmount = 290_000 ether;\n\t\tuint256 bobStakedAmount = 310_000 ether;\n        deal(address(salt), address(alice), aliceStakedAmount);\n        deal(address(salt), address(bob), bobStakedAmount);\n        deal(address(salt), address(dao), 5000000 ether);\n\n\t\tvm.prank(DEPLOYER);\n        staking.stakeSALT(2_400_000 ether);\n\t\tvm.startPrank(bob);\n\t\tsalt.approve(address(staking), bobStakedAmount);\n        staking.stakeSALT(bobStakedAmount);\n\t\tvm.stopPrank();\n\t\t// *********************************************\n\n        // Alice stakes her SALT to get voting power\n        vm.startPrank(alice);\n        staking.stakeSALT(aliceStakedAmount);\n\n\t\t// Propose a whitelisting ballot and cast vote\n\t\t// Quorum required = 20% of (2_400_000 + 290_000 + 310_000) = 600_000 \n\t\tuint256 ballotID = 1;\n\t\tIERC20 test = new TestERC20( \"TEST\", 18 );\n\t\tproposals.proposeTokenWhitelisting(test, \"url\", \"description\");\n\t\tproposals.castVote(ballotID, Vote.NO);\n\t\tvm.stopPrank();\n\t\tvm.prank(bob);\n\t\tproposals.castVote(ballotID, Vote.YES); // @audit-info : ballot_1 quorum reached\n\n\t\t// Increase block time to 1 hour before finalizing the ballot\n\t\tskip(daoConfig.ballotMinimumDuration() - 1 hours);\n\n\t\t// Bob proposes a whitelisting ballot and casts vote\n\t\tvm.startPrank(bob);\n\t\tIERC20 test2 = new TestERC20( \"TEST2\", 18 );\n\t\tproposals.proposeTokenWhitelisting(test2, \"url2\", \"description2\");\n\t\tproposals.castVote(ballotID + 1, Vote.YES);\n\t\tvm.stopPrank();\n\t\tvm.prank(alice);\n\t\tproposals.castVote(ballotID + 1, Vote.YES); // @audit-info : ballot_2 quorum reached; All YES votes; deadline still in the future\n\n\t\t// Increase block time to that of finalizing ballot_1\n\t\tskip(1 hours);\n\n\t\t// @audit : this would revert since Bob's ballot has more YES votes than Alice's\n\t\tvm.expectRevert(\"Only the token whitelisting ballot with the most votes can be finalized\");\n        dao.finalizeBallot(ballotID);\n\n\t\tskip(daoConfig.ballotMinimumDuration() - 2 hours);\n\t\t// more votes are cast for ballot_2\n\t\tvm.prank(DEPLOYER);\n\t\tproposals.castVote(ballotID + 1, Vote.NO); // @audit-info : ballot_2 now has NO > YES votes\n\n\t\t// @audit : this would pass now\n        dao.finalizeBallot(ballotID);\n\t\t// Check that the ballot is finalized\n        bool isBallotFinalized = !proposals.ballotForID(ballotID).ballotIsLive;\n        assertTrue(isBallotFinalized);\n    }\n```\n</details>\n\n### Tools used\n\nFoundry\n\n### Recommended Mitigation Steps\n\n*   Either only ballots past their deadline should be considered, OR\n*   Only compare ballots which were created within a few hours of each other.\n\nThe following diff uses the first option:\n\n<details>\n\n```diff\n\t// Returns the ballotID of the whitelisting ballot that currently has the most yes votes\n\t// Requires that the quorum has been reached and that the number of yes votes is greater than the number no votes\n\tfunction tokenWhitelistingBallotWithTheMostVotes() external view returns (uint256)\n\t\t{\n\t\tuint256 quorum = requiredQuorumForBallotType( BallotType.WHITELIST_TOKEN);\n\n\t\tuint256 bestID = 0;\n\t\tuint256 mostYes = 0;\n\t\tfor( uint256 i = 0; i < _openBallotsForTokenWhitelisting.length(); i++ )\n\t\t\t{\n\t\t\tuint256 ballotID = _openBallotsForTokenWhitelisting.at(i);\n+\t\t\tif (block.timestamp < ballots[ballotID].ballotMinimumEndTime)\n+\t\t\t    continue;\n\t\t\tuint256 yesTotal = _votesCastForBallot[ballotID][Vote.YES];\n\t\t\tuint256 noTotal = _votesCastForBallot[ballotID][Vote.NO];\n\n\t\t\tif ( (yesTotal + noTotal) >= quorum ) // Make sure that quorum has been reached\n\t\t\tif ( yesTotal > noTotal )  // Make sure the token vote is favorable\n\t\t\tif ( yesTotal > mostYes )  // Make sure these are the most yes votes seen\n\t\t\t\t{\n\t\t\t\tbestID = ballotID;\n\t\t\t\tmostYes = yesTotal;\n\t\t\t\t}\n\t\t\t}\n\n\t\treturn bestID;\n\t\t}\n```\n\n</details>\n\n\n**[othernet-global (Salty.IO) confirmed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/556#issuecomment-1960694992):**\n > Removed maxPendingTokensForWhitelisting.<br>\n> There is now no limit to the number of tokens that can be proposed for whitelisting.<br>\n> Also, any whitelisting proposal that has reached quorum with sufficient approval votes can be executed.\n\n>https://github.com/othernet-global/salty-io/commit/ccf4368\n\n**Status:** Mitigation confirmed. Full details in reports from [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/79), [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/97), and [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/7).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/dao/DAO.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../price_feed/interfaces/IPriceAggregator.sol\";\nimport \"../rewards/interfaces/IRewardsEmitter.sol\";\nimport \"../rewards/interfaces/IRewardsConfig.sol\";\nimport \"../stable/interfaces/IStableConfig.sol\";\nimport \"../stable/interfaces/ILiquidizer.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"../staking/interfaces/IStaking.sol\";\nimport \"../interfaces/IAccessManager.sol\";\nimport \"./interfaces/ICalledContract.sol\";\nimport \"./interfaces/IProposals.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"../pools/PoolUtils.sol\";\nimport \"./Parameters.sol\";\nimport \"../Upkeep.sol\";\n\n\n// Allows users to propose and vote on various governance actions such as changing parameters, whitelisting/unwhitelisting tokens, sending tokens, calling other contracts, and updating the website.\n// It handles proposing ballots, tracking votes, enforcing voting requirements, and executing approved proposals.\ncontract DAO is IDAO, Parameters, ReentrancyGuard\n    {\n\tevent BallotFinalized(uint256 indexed ballotID, Vote winningVote);\n    event SetContract(string indexed ballotName, address indexed contractAddress);\n    event SetWebsiteURL(string newURL);\n    event WhitelistToken(IERC20 indexed token);\n    event UnwhitelistToken(IERC20 indexed token);\n    event GeoExclusionUpdated(string country, bool excluded, uint256 geoVersion);\n    event ArbitrageProfitsWithdrawn(address indexed upkeepContract, IERC20 indexed weth, uint256 withdrawnAmount);\n    event SaltSent(address indexed to, uint256 amount);\n    event ContractCalled(address indexed contractAddress, uint256 indexed intArg);\n    event TeamRewardsTransferred(uint256 teamAmount);\n\n    event POLFormed(IERC20 indexed tokenA, IERC20 indexed tokenB, uint256 amountA, uint256 amountB);\n    event POLProcessed(uint256 claimedSALT);\n    event POLWithdrawn(IERC20 indexed tokenA, IERC20 indexed tokenB, uint256 withdrawnA, uint256 withdrawnB);\n\n\tusing SafeERC20 for ISalt;\n\tusing SafeERC20 for IERC20;\n\tusing SafeERC20 for IUSDS;\n\n\tIPools immutable public pools;\n\tIProposals immutable public proposals;\n\tIExchangeConfig immutable public exchangeConfig;\n\tIPoolsConfig immutable public poolsConfig;\n\tIStakingConfig immutable public stakingConfig;\n\tIRewardsConfig immutable public rewardsConfig;\n\tIStableConfig immutable public stableConfig;\n\tIDAOConfig immutable public daoConfig;\n\tIPriceAggregator immutable public priceAggregator;\n\tIRewardsEmitter immutable public liquidityRewardsEmitter;\n\tICollateralAndLiquidity immutable public collateralAndLiquidity;\n\tILiquidizer immutable public liquidizer;\n\n\tISalt immutable public salt;\n    IUSDS immutable public usds;\n\tIERC20 immutable public dai;\n\n\n\t// The default IPFS URL for the website content (can be changed with a setWebsiteURL proposal)\n\tstring public websiteURL;\n\n\t// Countries that have been excluded from access to the DEX (used by AccessManager.sol)\n\t// Keys as ISO 3166 Alpha-2 Codes\n\tmapping(string=>bool) public excludedCountries;\n\n\n    constructor( IPools _pools, IProposals _proposals, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig, IRewardsConfig _rewardsConfig, IStableConfig _stableConfig, IDAOConfig _daoConfig, IPriceAggregator _priceAggregator, IRewardsEmitter _liquidityRewardsEmitter, ICollateralAndLiquidity _collateralAndLiquidity )\n\t\t{\n\t\tpools = _pools;\n\t\tproposals = _proposals;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\t\trewardsConfig = _rewardsConfig;\n\t\tstableConfig = _stableConfig;\n\t\tdaoConfig = _daoConfig;\n\t\tpriceAggregator = _priceAggregator;\n        liquidityRewardsEmitter = _liquidityRewardsEmitter;\n        collateralAndLiquidity = _collateralAndLiquidity;\n \t\tliquidizer = collateralAndLiquidity.liquidizer();\n\n        usds = exchangeConfig.usds();\n        salt = exchangeConfig.salt();\n        dai = exchangeConfig.dai();\n\n\t\t// Gas saving approves for eventually forming Protocol Owned Liquidity\n\t\tsalt.approve(address(collateralAndLiquidity), type(uint256).max);\n\t\tusds.approve(address(collateralAndLiquidity), type(uint256).max);\n\t\tdai.approve(address(collateralAndLiquidity), type(uint256).max);\n\n\t\t// Excluded by default: United States, Canada, United Kingdom, China, India, Pakistan, Russia, Afghanistan, Cuba, Iran, North Korea, Syria, Venezuela\n\t\t// Note that the DAO can remove any of these exclusions - or open up access completely to the exchange as it sees fit.\n\t\texcludedCountries[\"US\"] = true;\n\t\texcludedCountries[\"CA\"] = true;\n\t\texcludedCountries[\"GB\"] = true;\n\t\texcludedCountries[\"CN\"] = true;\n\t\texcludedCountries[\"IN\"] = true;\n\t\texcludedCountries[\"PK\"] = true;\n\t\texcludedCountries[\"RU\"] = true;\n\t\texcludedCountries[\"AF\"] = true;\n\t\texcludedCountries[\"CU\"] = true;\n\t\texcludedCountries[\"IR\"] = true;\n\t\texcludedCountries[\"KP\"] = true;\n\t\texcludedCountries[\"SY\"] = true;\n\t\texcludedCountries[\"VE\"] = true;\n        }\n\n\n\t// Finalize the vote for a parameter ballot (increase, decrease or no_change) for a given parameter\n\tfunction _finalizeParameterBallot( uint256 ballotID ) internal\n\t\t{\n\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\tVote winningVote = proposals.winningParameterVote(ballotID);\n\n\t\tif ( winningVote == Vote.INCREASE )\n\t\t\t_executeParameterChange( ParameterTypes(ballot.number1), true, poolsConfig, stakingConfig, rewardsConfig, stableConfig, daoConfig, priceAggregator );\n\t\telse if ( winningVote == Vote.DECREASE )\n\t\t\t_executeParameterChange( ParameterTypes(ballot.number1), false, poolsConfig, stakingConfig, rewardsConfig, stableConfig, daoConfig, priceAggregator );\n\n\t\t// Finalize the ballot even if NO_CHANGE won\n\t\tproposals.markBallotAsFinalized(ballotID);\n\n\t\temit BallotFinalized(ballotID, winningVote);\n\t\t}\n\n\n\tfunction _executeSetContract( Ballot memory ballot ) internal\n\t\t{\n\t\tbytes32 nameHash = keccak256(bytes( ballot.ballotName ) );\n\n\t\tif ( nameHash == keccak256(bytes( \"setContract:priceFeed1_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 1, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:priceFeed2_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 2, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:priceFeed3_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 3, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:accessManager_confirm\" )) )\n\t\t\texchangeConfig.setAccessManager( IAccessManager(ballot.address1) );\n\n\t\temit SetContract(ballot.ballotName, ballot.address1);\n\t\t}\n\n\n\tfunction _executeSetWebsiteURL( Ballot memory ballot ) internal\n\t\t{\n\t\twebsiteURL = ballot.string1;\n\t\temit SetWebsiteURL(ballot.string1);\n\t\t}\n\n\n\tfunction _executeApproval( Ballot memory ballot ) internal\n\t\t{\n\t\tif ( ballot.ballotType == BallotType.UNWHITELIST_TOKEN )\n\t\t\t{\n\t\t\t// All tokens are paired with both WBTC and WETH so unwhitelist those pools\n\t\t\tpoolsConfig.unwhitelistPool( pools, IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tpoolsConfig.unwhitelistPool( pools, IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\temit UnwhitelistToken(IERC20(ballot.address1));\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.SEND_SALT )\n\t\t\t{\n\t\t\t// Make sure the contract has the SALT balance before trying to send it.\n\t\t\t// This should not happen but is here just in case - to prevent approved proposals from reverting on finalization.\n\t\t\tif ( exchangeConfig.salt().balanceOf(address(this)) >= ballot.number1 )\n\t\t\t\t{\n\t\t\t\tIERC20(exchangeConfig.salt()).safeTransfer( ballot.address1, ballot.number1 );\n\n\t\t\t\temit SaltSent(ballot.address1, ballot.number1);\n\t\t\t\t}\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.CALL_CONTRACT )\n\t\t\t{\n\t\t\tICalledContract(ballot.address1).callFromDAO( ballot.number1 );\n\n\t\t\temit ContractCalled(ballot.address1, ballot.number1);\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.INCLUDE_COUNTRY )\n\t\t\t{\n\t\t\texcludedCountries[ ballot.string1 ] = false;\n\n\t\t\temit GeoExclusionUpdated(ballot.string1, false, exchangeConfig.accessManager().geoVersion());\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.EXCLUDE_COUNTRY )\n\t\t\t{\n\t\t\texcludedCountries[ ballot.string1 ] = true;\n\n\t\t\t// If the AccessManager doesn't implement excludedCountriesUpdated, this will revert and countries will not be able to be excluded until the AccessManager is working properly.\n\t\t\texchangeConfig.accessManager().excludedCountriesUpdated();\n\n\t\t\temit GeoExclusionUpdated(ballot.string1, true, exchangeConfig.accessManager().geoVersion());\n\t\t\t}\n\n\t\t// Once an initial setContract proposal passes, it automatically starts a second confirmation ballot (to prevent last minute approvals)\n\t\telse if ( ballot.ballotType == BallotType.SET_CONTRACT )\n\t\t\tproposals.createConfirmationProposal( string.concat(ballot.ballotName, \"_confirm\"), BallotType.CONFIRM_SET_CONTRACT, ballot.address1, \"\", ballot.description );\n\n\t\t// Once an initial setWebsiteURL proposal passes, it automatically starts a second confirmation ballot (to prevent last minute approvals)\n\t\telse if ( ballot.ballotType == BallotType.SET_WEBSITE_URL )\n\t\t\tproposals.createConfirmationProposal( string.concat(ballot.ballotName, \"_confirm\"), BallotType.CONFIRM_SET_WEBSITE_URL, address(0), ballot.string1, ballot.description );\n\n\t\telse if ( ballot.ballotType == BallotType.CONFIRM_SET_CONTRACT )\n\t\t\t_executeSetContract( ballot );\n\n\t\telse if ( ballot.ballotType == BallotType.CONFIRM_SET_WEBSITE_URL )\n\t\t\t_executeSetWebsiteURL( ballot );\n\t\t}\n\n\n\t// Finalize the vote for an approval ballot (yes or no) for a given proposal\n\tfunction _finalizeApprovalBallot( uint256 ballotID ) internal\n\t\t{\n\t\tif ( proposals.ballotIsApproved(ballotID ) )\n\t\t\t{\n\t\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\t\t\t_executeApproval( ballot );\n\t\t\t}\n\n\t\tproposals.markBallotAsFinalized(ballotID);\n\t\t}\n\n\n\t// Finalize and execute a token whitelisting ballot.\n\t// If the proposal is currently the whitelisting proposal with the most yes votes then the token can be whitelisted.\n\t// Only the top voted whitelisting proposal can be finalized - as whitelisting requires bootstrapping rewards to be sent from the DAO.\n\t// If NO > YES than the proposal is removed immediately (quorum would already have been determined - in canFinalizeBallot as called from finalizeBallot).\n\tfunction _finalizeTokenWhitelisting( uint256 ballotID ) internal\n\t\t{\n\t\tif ( proposals.ballotIsApproved(ballotID ) )\n\t\t\t{\n\t\t\t// The ballot is approved. Any reversions below will allow the ballot to be attemped to be finalized later - as the ballot won't be finalized on reversion.\n\t\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\t\tuint256 bootstrappingRewards = daoConfig.bootstrappingRewards();\n\n\t\t\t// Make sure that the DAO contract holds the required amount of SALT for bootstrappingRewards.\n\t\t\t// Twice the bootstrapping rewards are needed (for both the token/WBTC and token/WETH pools)\n\t\t\tuint256 saltBalance = exchangeConfig.salt().balanceOf( address(this) );\n\t\t\trequire( saltBalance >= bootstrappingRewards * 2, \"Whitelisting is not currently possible due to insufficient bootstrapping rewards\" );\n\n\t\t\t// Fail to whitelist for now if this isn't the whitelisting proposal with the most votes - can try again later.\n\t\t\tuint256 bestWhitelistingBallotID = proposals.tokenWhitelistingBallotWithTheMostVotes();\n\t\t\trequire( bestWhitelistingBallotID == ballotID, \"Only the token whitelisting ballot with the most votes can be finalized\" );\n\n\t\t\t// All tokens are paired with both WBTC and WETH, so whitelist both pairings\n\t\t\tpoolsConfig.whitelistPool( pools,  IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tpoolsConfig.whitelistPool( pools,  IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\tbytes32 pool1 = PoolUtils._poolID( IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tbytes32 pool2 = PoolUtils._poolID( IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\t// Send the initial bootstrappingRewards to promote initial liquidity on these two newly whitelisted pools\n\t\t\tAddedReward[] memory addedRewards = new AddedReward[](2);\n\t\t\taddedRewards[0] = AddedReward( pool1, bootstrappingRewards );\n\t\t\taddedRewards[1] = AddedReward( pool2, bootstrappingRewards );\n\n\t\t\texchangeConfig.salt().approve( address(liquidityRewardsEmitter), bootstrappingRewards * 2 );\n\t\t\tliquidityRewardsEmitter.addSALTRewards( addedRewards );\n\n\t\t\temit WhitelistToken(IERC20(ballot.address1));\n\t\t\t}\n\n\t\t// Mark the ballot as finalized (which will also remove it from the list of open token whitelisting proposals)\n\t\tproposals.markBallotAsFinalized(ballotID);\n\t\t}\n\n\n\t// Finalize the vote on a specific ballot.\n\t// Can be called by anyone, but only actually finalizes the ballot if it can be finalized.\n\tfunction finalizeBallot( uint256 ballotID ) external nonReentrant\n\t\t{\n\t\t// Checks that ballot is live, and minimumEndTime and quorum have both been reached\n\t\trequire( proposals.canFinalizeBallot(ballotID), \"The ballot is not yet able to be finalized\" );\n\n\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\tif ( ballot.ballotType == BallotType.PARAMETER )\n\t\t\t_finalizeParameterBallot(ballotID);\n\t\telse if ( ballot.ballotType == BallotType.WHITELIST_TOKEN )\n\t\t\t_finalizeTokenWhitelisting(ballotID);\n\t\telse\n\t\t\t_finalizeApprovalBallot(ballotID);\n\t\t}\n\n\n\t// Withdraw the WETH arbitrage profits deposited in the Pools contract and send them to the caller (the Upkeep contract).\n\tfunction withdrawArbitrageProfits( IERC20 weth ) external returns (uint256 withdrawnAmount)\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.withdrawArbitrageProfits is only callable from the Upkeep contract\" );\n\n\t\t// The arbitrage profits are deposited in the Pools contract as WETH and owned by the DAO.\n\t\tuint256 depositedWETH = pools.depositedUserBalance(address(this), weth );\n\t\tif ( depositedWETH == 0 )\n\t\t\treturn 0;\n\n\t\tpools.withdraw( weth, depositedWETH );\n\n\t\t// Check the WETH balance - in case any WETH was accidentally sent here previously\n\t\twithdrawnAmount = weth.balanceOf( address(this) );\n\t\tweth.safeTransfer( msg.sender, withdrawnAmount );\n\n\t\temit ArbitrageProfitsWithdrawn(msg.sender, weth, withdrawnAmount);\n\t\t}\n\n\n\t// Form SALT/USDS or USDS/DAI Protocol Owned Liquidity using the given amount of specified tokens.\n\t// Assumes that the tokens have already been transferred to this contract.\n\tfunction formPOL( IERC20 tokenA, IERC20 tokenB, uint256 amountA, uint256 amountB ) external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.formPOL is only callable from the Upkeep contract\" );\n\n\t\t// Use zapping to form the liquidity so that all the specified tokens are used\n\t\tcollateralAndLiquidity.depositLiquidityAndIncreaseShare( tokenA, tokenB, amountA, amountB, 0, block.timestamp, true );\n\n\t\temit POLFormed(tokenA, tokenB, amountA, amountB);\n\t\t}\n\n\n\tfunction processRewardsFromPOL() external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.processRewardsFromPOL is only callable from the Upkeep contract\" );\n\n\t\t// The DAO owns SALT/USDS and USDS/DAI liquidity.\n\t\tbytes32[] memory poolIDs = new bytes32[](2);\n\t\tpoolIDs[0] = PoolUtils._poolID(salt, usds);\n\t\tpoolIDs[1] = PoolUtils._poolID(usds, dai);\n\n\t\tuint256 claimedSALT = collateralAndLiquidity.claimAllRewards(poolIDs);\n\t\tif ( claimedSALT == 0 )\n\t\t\treturn;\n\n\t\t// Send 10% of the rewards to the initial team\n\t\tuint256 amountToSendToTeam = claimedSALT / 10;\n\t\tsalt.safeTransfer( exchangeConfig.managedTeamWallet().mainWallet(), amountToSendToTeam );\n\t\temit TeamRewardsTransferred(amountToSendToTeam);\n\n\t\tuint256 remainingSALT = claimedSALT - amountToSendToTeam;\n\n\t\t// Burn a default 50% of the remaining SALT that was just claimed - the rest of the SALT stays in the DAO contract.\n\t\tuint256 saltToBurn = ( remainingSALT * daoConfig.percentPolRewardsBurned() ) / 100;\n\n\t\tsalt.safeTransfer( address(salt), saltToBurn );\n\t\tsalt.burnTokensInContract();\n\n\t\temit POLProcessed(claimedSALT);\n\t\t}\n\n\n\t// Withdraws the specified amount of the Protocol Owned Liquidity from the DAO and sends the underlying tokens to the Liquidizer to be burned as USDS as needed.\n\t// Called when the amount of recovered USDS from liquidating a user's WBTC/WETH collateral is insufficient to cover burning the USDS that they had borrowed.\n\t// Only callable from the Liquidizer contract.\n\tfunction withdrawPOL( IERC20 tokenA, IERC20 tokenB, uint256 percentToLiquidate ) external\n\t\t{\n\t\trequire(msg.sender == address(liquidizer), \"DAO.withdrawProtocolOwnedLiquidity is only callable from the Liquidizer contract\" );\n\n\t\tbytes32 poolID = PoolUtils._poolID(tokenA, tokenB);\n\t\tuint256 liquidityHeld = collateralAndLiquidity.userShareForPool( address(this), poolID );\n\t\tif ( liquidityHeld == 0 )\n\t\t\treturn;\n\n\t\tuint256 liquidityToWithdraw = (liquidityHeld * percentToLiquidate) / 100;\n\n\t\t// Withdraw the specified Protocol Owned Liquidity\n\t\t(uint256 reclaimedA, uint256 reclaimedB) = collateralAndLiquidity.withdrawLiquidityAndClaim(tokenA, tokenB, liquidityToWithdraw, 0, 0, block.timestamp );\n\n\t\t// Send the withdrawn tokens to the Liquidizer so that the tokens can be swapped to USDS and burned as needed.\n\t\ttokenA.safeTransfer( address(liquidizer), reclaimedA );\n\t\ttokenB.safeTransfer( address(liquidizer), reclaimedB );\n\n\t\temit POLWithdrawn(tokenA, tokenB, reclaimedA, reclaimedB);\n\t\t}\n\n\n\t// === VIEWS ===\n\n\tfunction countryIsExcluded( string calldata country ) external view returns (bool)\n\t\t{\n\t\treturn excludedCountries[country];\n\t\t}\n\t}"
    },
    {
      "filename": "src/dao/Proposals.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/Strings.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../staking/interfaces/IStaking.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IDAOConfig.sol\";\nimport \"./interfaces/IProposals.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"../pools/PoolUtils.sol\";\n\n\n// Allows SALT stakers to propose and vote on various types of ballots such as parameter changes, token whitelisting/unwhitelisting, sending tokens, calling contracts, and updating website URLs.\n// Ensures ballot uniqueness, tracks and validates user voting power, enforces quorums, and provides a mechanism for users to alter votes.\n\ncontract Proposals is IProposals, ReentrancyGuard\n    {\n    event ProposalCreated(uint256 indexed ballotID, BallotType ballotType, string ballotName);\n    event BallotFinalized(uint256 indexed ballotID);\n    event VoteCast(address indexed voter, uint256 indexed ballotID, Vote vote, uint256 votingPower);\n\n\tusing SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    IStaking immutable public staking;\n    IExchangeConfig immutable public exchangeConfig;\n    IPoolsConfig immutable public poolsConfig;\n    IDAOConfig immutable public daoConfig;\n    ISalt immutable public salt;\n\n\t// Mapping from ballotName to a currently open ballotID (zero if none).\n\t// Used to check for existing ballots by name so as to not allow duplicate ballots to be created.\n\tmapping(string=>uint256) public openBallotsByName;\n\n\t// Maps ballotID to the corresponding Ballot\n\tmapping(uint256=>Ballot) public ballots;\n\tuint256 public nextBallotID = 1;\n\n\t// All of the ballotIDs that are currently open for voting\n\tEnumerableSet.UintSet private _allOpenBallots;\n\n\t// The ballotIDs of the tokens currently being proposed for whitelisting\n\tEnumerableSet.UintSet private _openBallotsForTokenWhitelisting;\n\n\t// The number of votes cast for a given ballot by Vote type\n\tmapping(uint256=>mapping(Vote=>uint256)) private _votesCastForBallot;\n\n\t// The last vote cast by a user for a given ballot.\n\t// Allows users to change their vote - so that the previous vote can be undone before casting the new vote.\n\tmapping(uint256=>mapping(address=>UserVote)) private _lastUserVoteForBallot;\n\n\t// Which users currently have active proposals\n\t// Useful for checking that users are only able to create one active proposal at a time (to discourage spam proposals).\n\tmapping(address=>bool) private _userHasActiveProposal;\n\n\t// Which users proposed which ballots.\n\t// Useful when a ballot is finalized - so that the user that proposed it can have their _usersWithActiveProposals status cleared\n\tmapping(uint256=>address) private _usersThatProposedBallots;\n\n\t// The time at which the first proposal can be made (45 days after deployment).\n\t// This is to allow some time for users to start staking - as some percent of stake is required to propose ballots and if the total amount staked.\n\tuint256 immutable firstPossibleProposalTimestamp = block.timestamp + 45 days;\n\n\n    constructor( IStaking _staking, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IDAOConfig _daoConfig )\n\t\t{\n\t\tstaking = _staking;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\tdaoConfig = _daoConfig;\n\n\t\tsalt = exchangeConfig.salt();\n        }\n\n\n\tfunction _possiblyCreateProposal( string memory ballotName, BallotType ballotType, address address1, uint256 number1, string memory string1, string memory string2 ) internal returns (uint256 ballotID)\n\t\t{\n\t\trequire( block.timestamp >= firstPossibleProposalTimestamp, \"Cannot propose ballots within the first 45 days of deployment\" );\n\n\t\t// The DAO can create confirmation proposals which won't have the below requirements\n\t\tif ( msg.sender != address(exchangeConfig.dao() ) )\n\t\t\t{\n\t\t\t// Make sure that the sender has the minimum amount of xSALT required to make the proposal\n\t\t\tuint256 totalStaked = staking.totalShares(PoolUtils.STAKED_SALT);\n\t\t\tuint256 requiredXSalt = ( totalStaked * daoConfig.requiredProposalPercentStakeTimes1000() ) / ( 100 * 1000 );\n\n\t\t\trequire( requiredXSalt > 0, \"requiredXSalt cannot be zero\" );\n\n\t\t\tuint256 userXSalt = staking.userShareForPool( msg.sender, PoolUtils.STAKED_SALT );\n\t\t\trequire( userXSalt >= requiredXSalt, \"Sender does not have enough xSALT to make the proposal\" );\n\n\t\t\t// Make sure that the user doesn't already have an active proposal\n\t\t\trequire( ! _userHasActiveProposal[msg.sender], \"Users can only have one active proposal at a time\" );\n\t\t\t}\n\n\t\t// Make sure that a proposal of the same name is not already open for the ballot\n\t\trequire( openBallotsByName[ballotName] == 0, \"Cannot create a proposal similar to a ballot that is still open\" );\n\t\trequire( openBallotsByName[ string.concat(ballotName, \"_confirm\")] == 0, \"Cannot create a proposal for a ballot with a secondary confirmation\" );\n\n\t\tuint256 ballotMinimumEndTime = block.timestamp + daoConfig.ballotMinimumDuration();\n\n\t\t// Add the new Ballot to storage\n\t\tballotID = nextBallotID++;\n\t\tballots[ballotID] = Ballot( ballotID, true, ballotType, ballotName, address1, number1, string1, string2, ballotMinimumEndTime );\n\t\topenBallotsByName[ballotName] = ballotID;\n\t\t_allOpenBallots.add( ballotID );\n\n\t\t// Remember that the user made a proposal\n\t\t_userHasActiveProposal[msg.sender] = true;\n\t\t_usersThatProposedBallots[ballotID] = msg.sender;\n\n\t\temit ProposalCreated(ballotID, ballotType, ballotName);\n\t\t}\n\n\n\t// Create a confirmation proposal from the DAO\n\tfunction createConfirmationProposal( string calldata ballotName, BallotType ballotType, address address1, string calldata string1, string calldata description ) external returns (uint256 ballotID)\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.dao()), \"Only the DAO can create a confirmation proposal\" );\n\n\t\treturn _possiblyCreateProposal( ballotName, ballotType, address1, 0, string1, description );\n\t\t}\n\n\n\tfunction markBallotAsFinalized( uint256 ballotID ) external nonReentrant\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.dao()), \"Only the DAO can mark a ballot as finalized\" );\n\n\t\tBallot storage ballot = ballots[ballotID];\n\n\t\t// Remove finalized whitelist token ballots from the list of open whitelisting proposals\n\t\tif ( ballot.ballotType == BallotType.WHITELIST_TOKEN )\n\t\t\t_openBallotsForTokenWhitelisting.remove( ballotID );\n\n\t\t// Remove from the list of all open ballots\n\t\t_allOpenBallots.remove( ballotID );\n\n\t\tballot.ballotIsLive = false;\n\n\t\t// Indicate that the user who posted the proposal no longer has an active proposal\n\t\taddress userThatPostedBallot = _usersThatProposedBallots[ballotID];\n\t\t_userHasActiveProposal[userThatPostedBallot] = false;\n\n\t\tdelete openBallotsByName[ballot.ballotName];\n\n\t\temit BallotFinalized(ballotID);\n\t\t}\n\n\n\tfunction proposeParameterBallot( uint256 parameterType, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\tstring memory ballotName = string.concat(\"parameter:\", Strings.toString(parameterType) );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.PARAMETER, address(0), parameterType, \"\", description );\n\t\t}\n\n\n\tfunction proposeTokenWhitelisting( IERC20 token, string calldata tokenIconURL, string calldata description ) external nonReentrant returns (uint256 _ballotID)\n\t\t{\n\t\trequire( address(token) != address(0), \"token cannot be address(0)\" );\n\t\trequire( token.totalSupply() < type(uint112).max, \"Token supply cannot exceed uint112.max\" ); // 5 quadrillion max supply with 18 decimals of precision\n\n\t\trequire( _openBallotsForTokenWhitelisting.length() < daoConfig.maxPendingTokensForWhitelisting(), \"The maximum number of token whitelisting proposals are already pending\" );\n\t\trequire( poolsConfig.numberOfWhitelistedPools() < poolsConfig.maximumWhitelistedPools(), \"Maximum number of whitelisted pools already reached\" );\n\t\trequire( ! poolsConfig.tokenHasBeenWhitelisted(token, exchangeConfig.wbtc(), exchangeConfig.weth()), \"The token has already been whitelisted\" );\n\n\t\tstring memory ballotName = string.concat(\"whitelist:\", Strings.toHexString(address(token)) );\n\n\t\tuint256 ballotID = _possiblyCreateProposal( ballotName, BallotType.WHITELIST_TOKEN, address(token), 0, tokenIconURL, description );\n\t\t_openBallotsForTokenWhitelisting.add( ballotID );\n\n\t\treturn ballotID;\n\t\t}\n\n\n\tfunction proposeTokenUnwhitelisting( IERC20 token, string calldata tokenIconURL, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( poolsConfig.tokenHasBeenWhitelisted(token, exchangeConfig.wbtc(), exchangeConfig.weth()), \"Can only unwhitelist a whitelisted token\" );\n\t\trequire( address(token) != address(exchangeConfig.wbtc()), \"Cannot unwhitelist WBTC\" );\n\t\trequire( address(token) != address(exchangeConfig.weth()), \"Cannot unwhitelist WETH\" );\n\t\trequire( address(token) != address(exchangeConfig.dai()), \"Cannot unwhitelist DAI\" );\n\t\trequire( address(token) != address(exchangeConfig.usds()), \"Cannot unwhitelist USDS\" );\n\t\trequire( address(token) != address(exchangeConfig.salt()), \"Cannot unwhitelist SALT\" );\n\n\t\tstring memory ballotName = string.concat(\"unwhitelist:\", Strings.toHexString(address(token)) );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.UNWHITELIST_TOKEN, address(token), 0, tokenIconURL, description );\n\t\t}\n\n\n\t// Proposes sending a specified amount of SALT to a wallet or contract.\n\t// Only one sendSALT Ballot can be open at a time and the sending limit is 5% of the current SALT balance of the DAO.\n\tfunction proposeSendSALT( address wallet, uint256 amount, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( wallet != address(0), \"Cannot send SALT to address(0)\" );\n\n\t\t// Limit to 5% of current balance\n\t\tuint256 balance = exchangeConfig.salt().balanceOf( address(exchangeConfig.dao()) );\n\t\tuint256 maxSendable = balance * 5 / 100;\n\t\trequire( amount <= maxSendable, \"Cannot send more than 5% of the DAO SALT balance\" );\n\n\t\t// This ballotName is not unique for the receiving wallet and enforces the restriction of one sendSALT ballot at a time.\n\t\t// If more receivers are necessary at once, a splitter can be used.\n\t\tstring memory ballotName = \"sendSALT\";\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.SEND_SALT, wallet, amount, \"\", description );\n\t\t}\n\n\n\t// Proposes calling the callFromDAO(uint256) function on an arbitrary contract.\n\tfunction proposeCallContract( address contractAddress, uint256 number, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( contractAddress != address(0), \"Contract address cannot be address(0)\" );\n\n\t\tstring memory ballotName = string.concat(\"callContract:\", Strings.toHexString(address(contractAddress)) );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.CALL_CONTRACT, contractAddress, number, description, \"\" );\n\t\t}\n\n\n\tfunction proposeCountryInclusion( string calldata country, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( bytes(country).length == 2, \"Country must be an ISO 3166 Alpha-2 Code\" );\n\n\t\tstring memory ballotName = string.concat(\"include:\", country );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.INCLUDE_COUNTRY, address(0), 0, country, description );\n\t\t}\n\n\n\tfunction proposeCountryExclusion( string calldata country, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( bytes(country).length == 2, \"Country must be an ISO 3166 Alpha-2 Code\" );\n\n\t\tstring memory ballotName = string.concat(\"exclude:\", country );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.EXCLUDE_COUNTRY, address(0), 0, country, description );\n\t\t}\n\n\n\tfunction proposeSetContractAddress( string calldata contractName, address newAddress, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( newAddress != address(0), \"Proposed address cannot be address(0)\" );\n\n\t\tstring memory ballotName = string.concat(\"setContract:\", contractName );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.SET_CONTRACT, newAddress, 0, \"\", description );\n\t\t}\n\n\n\tfunction proposeWebsiteUpdate( string calldata newWebsiteURL, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( keccak256(abi.encodePacked(newWebsiteURL)) != keccak256(abi.encodePacked(\"\")), \"newWebsiteURL cannot be empty\" );\n\n\t\tstring memory ballotName = string.concat(\"setURL:\", newWebsiteURL );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.SET_WEBSITE_URL, address(0), 0, newWebsiteURL, description );\n\t\t}\n\n\n\t// Cast a vote on an open ballot\n\tfunction castVote( uint256 ballotID, Vote vote ) external nonReentrant\n\t\t{\n\t\tBallot memory ballot = ballots[ballotID];\n\n\t\t// Require that the ballot is actually live\n\t\trequire( ballot.ballotIsLive, \"The specified ballot is not open for voting\" );\n\n\t\t// Make sure that the vote type is valid for the given ballot\n\t\tif ( ballot.ballotType == BallotType.PARAMETER )\n\t\t\trequire( (vote == Vote.INCREASE) || (vote == Vote.DECREASE) || (vote == Vote.NO_CHANGE), \"Invalid VoteType for Parameter Ballot\" );\n\t\telse // If a Ballot is not a Parameter Ballot, it is an Approval ballot\n\t\t\trequire( (vote == Vote.YES) || (vote == Vote.NO), \"Invalid VoteType for Approval Ballot\" );\n\n\t\t// Make sure that the user has voting power before proceeding.\n\t\t// Voting power is equal to their userShare of STAKED_SALT.\n\t\t// If the user changes their stake after voting they will have to recast their vote.\n\n\t\tuint256 userVotingPower = staking.userShareForPool( msg.sender, PoolUtils.STAKED_SALT );\n\t\trequire( userVotingPower > 0, \"Staked SALT required to vote\" );\n\n\t\t// Remove any previous votes made by the user on the ballot\n\t\tUserVote memory lastVote = _lastUserVoteForBallot[ballotID][msg.sender];\n\n\t\t// Undo the last vote?\n\t\tif ( lastVote.votingPower > 0 )\n\t\t\t_votesCastForBallot[ballotID][lastVote.vote] -= lastVote.votingPower;\n\n\t\t// Update the votes cast for the ballot with the user's current voting power\n\t\t_votesCastForBallot[ballotID][vote] += userVotingPower;\n\n\t\t// Remember how the user voted in case they change their vote later\n\t\t_lastUserVoteForBallot[ballotID][msg.sender] = UserVote( vote, userVotingPower );\n\n\t\temit VoteCast(msg.sender, ballotID, vote, userVotingPower);\n\t\t}\n\n\n\t// === VIEWS ===\n\tfunction ballotForID( uint256 ballotID ) external view returns (Ballot memory)\n\t\t{\n\t\treturn ballots[ballotID];\n\t\t}\n\n\n\tfunction lastUserVoteForBallot( uint256 ballotID, address user ) external view returns (UserVote memory)\n\t\t{\n\t\treturn _lastUserVoteForBallot[ballotID][user];\n\t\t}\n\n\n\tfunction votesCastForBallot( uint256 ballotID, Vote vote ) external view returns (uint256)\n\t\t{\n\t\treturn _votesCastForBallot[ballotID][vote];\n\t\t}\n\n\n\t// The required quorum is normally a default 10% of the amount of SALT staked.\n\t// There is though a minimum of 0.50% of SALT.totalSupply (in the case that the amount of staked SALT is low - at launch for instance).\n\tfunction requiredQuorumForBallotType( BallotT"
    }
  ]
}