{
  "Title": "[N-03]  Events that mark critical parameter changes should contain both the old and the new value",
  "Content": "\nThis should especially be done if the new value is not required to be different from the old value\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: src/utils/MultiRewardEscrow.sol\n\n/// @audit setFees()\n214:        emit FeeSet(tokens[i], tokenFees[i]);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardEscrow.sol#L214\n\n```solidity\nFile: src/vault/Vault.sol\n\n/// @audit setQuitPeriod()\n635:          emit QuitPeriodSet(quitPeriod);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L635\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-01-popcorn",
  "Code": [
    {
      "filename": "src/utils/MultiRewardEscrow.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport { SafeERC20Upgradeable as SafeERC20 } from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IERC20Upgradeable as IERC20 } from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { Math } from \"openzeppelin-contracts/utils/math/Math.sol\";\nimport { Owned } from \"./Owned.sol\";\nimport { SafeCastLib } from \"solmate/utils/SafeCastLib.sol\";\nimport { Fee, Escrow } from \"../interfaces/IMultiRewardEscrow.sol\";\n\n/**\n * @title   MultiRewardEscrow\n * @author  RedVeil\n * @notice  Permissionlessly escrow tokens for a specific period of time.\n *\n * Anyone can create an escrow for any token and any user.\n * The owner can only decide to take fees on the creation of escrows with certain tokens.\n */\ncontract MultiRewardEscrow is Owned {\n  using SafeERC20 for IERC20;\n  using SafeCastLib for uint256;\n\n  /**\n   * @notice Constructor for the Escrow contract.\n   * @param _owner Owner of the contract. Controls management functions.\n   * @param _feeRecipient Receiver of all fees.\n   */\n  constructor(address _owner, address _feeRecipient) Owned(_owner) {\n    feeRecipient = _feeRecipient;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            GET ESCROW VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n  function getEscrowIdsByUser(address account) external view returns (bytes32[] memory) {\n    return userEscrowIds[account];\n  }\n\n  function getEscrowIdsByUserAndToken(address account, IERC20 token) external view returns (bytes32[] memory) {\n    return userEscrowIdsByToken[account][token];\n  }\n\n  /**\n   * @notice Returns an array of Escrows.\n   * @param escrowIds Array of escrow ids.\n   * @dev there is no check to ensure that all escrows are owned by the same account. Make sure to account for this either by only sending ids for a specific account or by filtering the Escrows by account later on.\n   */\n  function getEscrows(bytes32[] calldata escrowIds) external view returns (Escrow[] memory) {\n    Escrow[] memory selectedEscrows = new Escrow[](escrowIds.length);\n    for (uint256 i = 0; i < escrowIds.length; i++) {\n      selectedEscrows[i] = escrows[escrowIds[i]];\n    }\n    return selectedEscrows;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            LOCK LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  // EscrowId => Escrow\n  mapping(bytes32 => Escrow) public escrows;\n\n  // User => Escrows\n  mapping(address => bytes32[]) public userEscrowIds;\n  // User => RewardsToken => Escrows\n  mapping(address => mapping(IERC20 => bytes32[])) public userEscrowIdsByToken;\n\n  uint256 internal nonce;\n\n  event Locked(IERC20 indexed token, address indexed account, uint256 amount, uint32 duration, uint32 offset);\n\n  error ZeroAddress();\n  error ZeroAmount();\n\n  /**\n   * @notice Locks funds for escrow.\n   * @param token The token to be locked.\n   * @param account Recipient of the escrowed funds.\n   * @param amount Amount of tokens to be locked.\n   * @param duration Duration of the escrow. Every escrow unlocks token linearly.\n   * @param offset A cliff before the escrow starts.\n   * @dev This creates a separate escrow structure which can later be iterated upon to unlock the escrowed funds.\n   * @dev The Owner may decide to add a fee to the escrowed amount.\n   */\n  function lock(\n    IERC20 token,\n    address account,\n    uint256 amount,\n    uint32 duration,\n    uint32 offset\n  ) external {\n    if (token == IERC20(address(0))) revert ZeroAddress();\n    if (account == address(0)) revert ZeroAddress();\n    if (amount == 0) revert ZeroAmount();\n    if (duration == 0) revert ZeroAmount();\n\n    token.safeTransferFrom(msg.sender, address(this), amount);\n\n    nonce++;\n\n    bytes32 id = keccak256(abi.encodePacked(token, account, amount, nonce));\n\n    uint256 feePerc = fees[token].feePerc;\n    if (feePerc > 0) {\n      uint256 fee = Math.mulDiv(amount, feePerc, 1e18);\n\n      amount -= fee;\n      token.safeTransfer(feeRecipient, fee);\n    }\n\n    uint32 start = block.timestamp.safeCastTo32() + offset;\n\n    escrows[id] = Escrow({\n      token: token,\n      start: start,\n      end: start + duration,\n      lastUpdateTime: start,\n      initialBalance: amount,\n      balance: amount,\n      account: account\n    });\n\n    userEscrowIds[account].push(id);\n    userEscrowIdsByToken[account][token].push(id);\n\n    emit Locked(token, account, amount, duration, offset);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  event RewardsClaimed(IERC20 indexed token, address indexed account, uint256 amount);\n\n  error NotClaimable(bytes32 escrowId);\n\n  function isClaimable(bytes32 escrowId) external view returns (bool) {\n    return escrows[escrowId].lastUpdateTime != 0 && escrows[escrowId].balance > 0;\n  }\n\n  function getClaimableAmount(bytes32 escrowId) external view returns (uint256) {\n    return _getClaimableAmount(escrows[escrowId]);\n  }\n\n  /**\n   * @notice Claim rewards for multiple escrows.\n   * @param escrowIds Array of escrow ids.\n   * @dev Uses the `vaultIds` at the specified indices of `userEscrows`.\n   * @dev Prevention for gas overflow should be handled in the frontend\n   */\n  function claimRewards(bytes32[] memory escrowIds) external {\n    for (uint256 i = 0; i < escrowIds.length; i++) {\n      bytes32 escrowId = escrowIds[i];\n      Escrow memory escrow = escrows[escrowId];\n\n      uint256 claimable = _getClaimableAmount(escrow);\n      if (claimable == 0) revert NotClaimable(escrowId);\n\n      escrows[escrowId].balance -= claimable;\n      escrows[escrowId].lastUpdateTime = block.timestamp.safeCastTo32();\n\n      escrow.token.safeTransfer(escrow.account, claimable);\n      emit RewardsClaimed(escrow.token, escrow.account, claimable);\n    }\n  }\n\n  function _getClaimableAmount(Escrow memory escrow) internal view returns (uint256) {\n    if (\n      escrow.lastUpdateTime == 0 ||\n      escrow.end == 0 ||\n      escrow.balance == 0 ||\n      block.timestamp.safeCastTo32() < escrow.start\n    ) {\n      return 0;\n    }\n    return\n      Math.min(\n        (escrow.balance * (block.timestamp - uint256(escrow.lastUpdateTime))) /\n          (uint256(escrow.end) - uint256(escrow.lastUpdateTime)),\n        escrow.balance\n      );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            FEE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  address public feeRecipient;\n\n  // escrowToken => feeAmount\n  mapping(IERC20 => Fee) public fees;\n\n  event FeeSet(IERC20 indexed token, uint256 amount);\n\n  error ArraysNotMatching(uint256 length1, uint256 length2);\n  error DontGetGreedy(uint256 fee);\n  error NoFee(IERC20 token);\n\n  /**\n   * @notice Set fees for multiple tokens. Caller must be the owner.\n   * @param tokens Array of tokens.\n   * @param tokenFees Array of fees for `tokens` in 1e18. (1e18 = 100%, 1e14 = 1 BPS)\n   */\n  function setFees(IERC20[] memory tokens, uint256[] memory tokenFees) external onlyOwner {\n    if (tokens.length != tokenFees.length) revert ArraysNotMatching(tokens.length, tokenFees.length);\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      if (tokenFees[i] >= 1e17) revert DontGetGreedy(tokenFees[i]);\n\n      fees[tokens[i]].feePerc = tokenFees[i];\n      emit FeeSet(tokens[i], tokenFees[i]);\n    }\n  }\n}"
    },
    {
      "filename": "src/vault/Vault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport {SafeERC20Upgradeable as SafeERC20} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {IERC4626, IERC20} from \"../interfaces/vault/IERC4626.sol\";\nimport {IERC20Metadata} from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {VaultFees} from \"../interfaces/vault/IVault.sol\";\nimport {MathUpgradeable as Math} from \"openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {OwnedUpgradeable} from \"../utils/OwnedUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/**\n * @title   Vault\n * @author  RedVeil\n * @notice  See the following for the full EIP-4626 specification https://eips.ethereum.org/EIPS/eip-4626.\n *\n * A simple ERC4626-Implementation of a Vault.\n * The vault delegates any actual protocol interaction to an adapter.\n * It allows for multiple type of fees which are taken by issuing new vault shares.\n * Adapter and fees can be changed by the owner after a ragequit time.\n */\ncontract Vault is\n    ERC20Upgradeable,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable,\n    OwnedUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    uint256 constant SECONDS_PER_YEAR = 365.25 days;\n\n    IERC20 public asset;\n    uint8 internal _decimals;\n\n    bytes32 public contractName;\n\n    event VaultInitialized(bytes32 contractName, address indexed asset);\n\n    error InvalidAsset();\n    error InvalidAdapter();\n\n    /**\n     * @notice Initialize a new Vault.\n     * @param asset_ Underlying Asset which users will deposit.\n     * @param adapter_ Adapter which will be used to interact with the wrapped protocol.\n     * @param fees_ Desired fees in 1e18. (1e18 = 100%, 1e14 = 1 BPS)\n     * @param feeRecipient_ Recipient of all vault fees. (Must not be zero address)\n     * @param owner Owner of the contract. Controls management functions.\n     * @dev This function is called by the factory contract when deploying a new vault.\n     * @dev Usually the adapter should already be pre configured. Otherwise a new one can only be added after a ragequit time.\n     */\n    function initialize(\n        IERC20 asset_,\n        IERC4626 adapter_,\n        VaultFees calldata fees_,\n        address feeRecipient_,\n        address owner\n    ) external initializer {\n        __ERC20_init(\n            string.concat(\n                \"Popcorn \",\n                IERC20Metadata(address(asset_)).name(),\n                \" Vault\"\n            ),\n            string.concat(\"pop-\", IERC20Metadata(address(asset_)).symbol())\n        );\n        __Owned_init(owner);\n\n        if (address(asset_) == address(0)) revert InvalidAsset();\n        if (address(asset_) != adapter_.asset()) revert InvalidAdapter();\n\n        asset = asset_;\n        adapter = adapter_;\n\n        asset.approve(address(adapter_), type(uint256).max);\n\n        _decimals = IERC20Metadata(address(asset_)).decimals();\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n\n        feesUpdatedAt = block.timestamp;\n        fees = fees_;\n\n        if (feeRecipient_ == address(0)) revert InvalidFeeRecipient();\n        feeRecipient = feeRecipient_;\n\n        contractName = keccak256(\n            abi.encodePacked(\"Popcorn\", name(), block.timestamp, \"Vault\")\n        );\n\n        emit VaultInitialized(contractName, address(asset));\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    error InvalidReceiver();\n\n    function deposit(uint256 assets) public returns (uint256) {\n        return deposit(assets, msg.sender);\n    }\n\n    /**\n     * @notice Deposit exactly `assets` amount of tokens, issuing vault shares to `receiver`.\n     * @param assets Quantity of tokens to deposit.\n     * @param receiver Receiver of issued vault shares.\n     * @return shares Quantity of vault shares issued to `receiver`.\n     */\n    function deposit(uint256 assets, address receiver)\n        public\n        nonReentrant\n        whenNotPaused\n        syncFeeCheckpoint\n        returns (uint256 shares)\n    {\n        if (receiver == address(0)) revert InvalidReceiver();\n\n        uint256 feeShares = convertToShares(\n            assets.mulDiv(uint256(fees.deposit), 1e18, Math.Rounding.Down)\n        );\n\n        shares = convertToShares(assets) - feeShares;\n\n        if (feeShares > 0) _mint(feeRecipient, feeShares);\n\n        _mint(receiver, shares);\n\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        adapter.deposit(assets, address(this));\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function mint(uint256 shares) external returns (uint256) {\n        return mint(shares, msg.sender);\n    }\n\n    /**\n     * @notice Mint exactly `shares` vault shares to `receiver`, taking the necessary amount of `asset` from the caller.\n     * @param shares Quantity of shares to mint.\n     * @param receiver Receiver of issued vault shares.\n     * @return assets Quantity of assets deposited by caller.\n     */\n    function mint(uint256 shares, address receiver)\n        public\n        nonReentrant\n        whenNotPaused\n        syncFeeCheckpoint\n        returns (uint256 assets)\n    {\n        if (receiver == address(0)) revert InvalidReceiver();\n\n        uint256 depositFee = uint256(fees.deposit);\n\n        uint256 feeShares = shares.mulDiv(\n            depositFee,\n            1e18 - depositFee,\n            Math.Rounding.Down\n        );\n\n        assets = convertToAssets(shares + feeShares);\n\n        if (feeShares > 0) _mint(feeRecipient, feeShares);\n\n        _mint(receiver, shares);\n\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        adapter.deposit(assets, address(this));\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function withdraw(uint256 assets) public returns (uint256) {\n        return withdraw(assets, msg.sender, msg.sender);\n    }\n\n    /**\n     * @notice Burn shares from `owner` in exchange for `assets` amount of underlying token.\n     * @param assets Quantity of underlying `asset` token to withdraw.\n     * @param receiver Receiver of underlying token.\n     * @param owner Owner of burned vault shares.\n     * @return shares Quantity of vault shares burned in exchange for `assets`.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public nonReentrant syncFeeCheckpoint returns (uint256 shares) {\n        if (receiver == address(0)) revert InvalidReceiver();\n\n        shares = convertToShares(assets);\n\n        uint256 withdrawalFee = uint256(fees.withdrawal);\n\n        uint256 feeShares = shares.mulDiv(\n            withdrawalFee,\n            1e18 - withdrawalFee,\n            Math.Rounding.Down\n        );\n\n        shares += feeShares;\n\n        if (msg.sender != owner)\n            _approve(owner, msg.sender, allowance(owner, msg.sender) - shares);\n\n        _burn(owner, shares);\n\n        if (feeShares > 0) _mint(feeRecipient, feeShares);\n\n        adapter.withdraw(assets, receiver, address(this));\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n    }\n\n    function redeem(uint256 shares) external returns (uint256) {\n        return redeem(shares, msg.sender, msg.sender);\n    }\n\n    /**\n     * @notice Burn exactly `shares` vault shares from `owner` and send underlying `asset` tokens to `receiver`.\n     * @param shares Quantity of vault shares to exchange for underlying tokens.\n     * @param receiver Receiver of underlying tokens.\n     * @param owner Owner of burned vault shares.\n     * @return assets Quantity of `asset` sent to `receiver`.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public nonReentrant returns (uint256 assets) {\n        if (receiver == address(0)) revert InvalidReceiver();\n\n        if (msg.sender != owner)\n            _approve(owner, msg.sender, allowance(owner, msg.sender) - shares);\n\n        uint256 feeShares = shares.mulDiv(\n            uint256(fees.withdrawal),\n            1e18,\n            Math.Rounding.Down\n        );\n\n        assets = convertToAssets(shares - feeShares);\n\n        _burn(owner, shares);\n\n        if (feeShares > 0) _mint(feeRecipient, feeShares);\n\n        adapter.withdraw(assets, receiver, address(this));\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @return Total amount of underlying `asset` token managed by vault. Delegates to adapter.\n    function totalAssets() public view returns (uint256) {\n        return adapter.convertToAssets(adapter.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Amount of shares the vault would exchange for given amount of assets, in an ideal scenario.\n     * @param assets Exact amount of assets\n     * @return Exact amount of shares\n     */\n    function convertToShares(uint256 assets) public view returns (uint256) {\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return\n            supply == 0\n                ? assets\n                : assets.mulDiv(supply, totalAssets(), Math.Rounding.Down);\n    }\n\n    /**\n     * @notice Amount of assets the vault would exchange for given amount of shares, in an ideal scenario.\n     * @param shares Exact amount of shares\n     * @return Exact amount of assets\n     */\n    function convertToAssets(uint256 shares) public view returns (uint256) {\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return\n            supply == 0\n                ? shares\n                : shares.mulDiv(totalAssets(), supply, Math.Rounding.Down);\n    }\n\n    /**\n     * @notice Simulate the effects of a deposit at the current block, given current on-chain conditions.\n     * @param assets Exact amount of underlying `asset` token to deposit\n     * @return shares of the vault issued in exchange to the user for `assets`\n     * @dev This method accounts for issuance of accrued fee shares.\n     */\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        shares = adapter.previewDeposit(\n            assets -\n                assets.mulDiv(uint256(fees.deposit), 1e18, Math.Rounding.Down)\n        );\n    }\n\n    /**\n     * @notice Simulate the effects of a mint at the current block, given current on-chain conditions.\n     * @param shares Exact amount of vault shares to mint.\n     * @return assets quantity of underlying needed in exchange to mint `shares`.\n     * @dev This method accounts for issuance of accrued fee shares.\n     */\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        uint256 depositFee = uint256(fees.deposit);\n\n        shares += shares.mulDiv(\n            depositFee,\n            1e18 - depositFee,\n            Math.Rounding.Up\n        );\n\n        assets = adapter.previewMint(shares);\n    }\n\n    /**\n     * @notice Simulate the effects of a withdrawal at the current block, given current on-chain conditions.\n     * @param assets Exact amount of `assets` to withdraw\n     * @return shares to be burned in exchange for `assets`\n     * @dev This method accounts for both issuance of fee shares and withdrawal fee.\n     */\n    function previewWithdraw(uint256 assets)\n        external\n        view\n        returns (uint256 shares)\n    {\n        uint256 withdrawalFee = uint256(fees.withdrawal);\n\n        assets += assets.mulDiv(\n            withdrawalFee,\n            1e18 - withdrawalFee,\n            Math.Rounding.Up\n        );\n\n        shares = adapter.previewWithdraw(assets);\n    }\n\n    /**\n     * @notice Simulate the effects of a redemption at the current block, given current on-chain conditions.\n     * @param shares Exact amount of `shares` to redeem\n     * @return assets quantity of underlying returned in exchange for `shares`.\n     * @dev This method accounts for both issuance of fee shares and withdrawal fee.\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = adapter.previewRedeem(shares);\n\n        assets -= assets.mulDiv(\n            uint256(fees.withdrawal),\n            1e18,\n            Math.Rounding.Down\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @return Maximum amount of underlying `asset` token that may be deposited for a given address. Delegates to adapter.\n    function maxDeposit(address caller) public view returns (uint256) {\n        return adapter.maxDeposit(caller);\n    }\n\n    /// @return Maximum amount of vault shares that may be minted to given address. Delegates to adapter.\n    function maxMint(address caller) external view returns (uint256) {\n        return adapter.maxMint(caller);\n    }\n\n    /// @return Maximum amount of underlying `asset` token that can be withdrawn by `caller` address. Delegates to adapter.\n    function maxWithdraw(address caller) external view returns (uint256) {\n        return adapter.maxWithdraw(caller);\n    }\n\n    /// @return Maximum amount of shares that may be redeemed by `caller` address. Delegates to adapter.\n    function maxRedeem(address caller) external view returns (uint256) {\n        return adapter.maxRedeem(caller);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        FEE ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Management fee that has accrued since last fee harvest.\n     * @return Accrued management fee in underlying `asset` token.\n     * @dev Management fee is annualized per minute, based on 525,600 minutes per year. Total assets are calculated using\n     *  the average of their current value and the value at the previous fee harvest checkpoint. This method is similar to\n     *  calculating a definite integral using the trapezoid rule.\n     */\n    function accruedManagementFee() public view returns (uint256) {\n        uint256 managementFee = fees.management;\n        return\n            managementFee > 0\n                ? managementFee.mulDiv(\n                    totalAssets() * (block.timestamp - feesUpdatedAt),\n                    SECONDS_PER_YEAR,\n                    Math.Rounding.Down\n                ) / 1e18\n                : 0;\n    }\n\n    /**\n     * @notice Performance fee that has accrued since last fee harvest.\n     * @return Accrued performance fee in underlying `asset` token.\n     * @dev Performance fee is based on a high water mark value. If vault share value has increased above the\n     *   HWM in a fee period, issue fee shares to the vault equal to the performance fee.\n     */\n    function accruedPerformanceFee() public view returns (uint256) {\n        uint256 highWaterMark_ = highWaterMark;\n        uint256 shareValue = convertToAssets(1e18);\n        uint256 performanceFee = fees.performance;\n\n        return\n            performanceFee > 0 && shareValue > highWaterMark\n                ? performanceFee.mulDiv(\n                    (shareValue - highWaterMark) * totalSupply(),\n                    1e36,\n                    Math.Rounding.Down\n                )\n                : 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            FEE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public highWaterMark = 1e18;\n    uint256 public assetsCheckpoint;\n    uint256 public feesUpdatedAt;\n\n    error InsufficientWithdrawalAmount(uint256 amount);\n\n    /// @notice Minimal function to call `takeFees` modifier.\n    function takeManagementAndPerformanceFees()\n        external\n        nonReentrant\n        takeFees\n    {}\n\n    /// @notice Collect management and performance fees and update vault share high water mark.\n    modifier takeFees() {\n        uint256 managementFee = accruedManagementFee();\n        uint256 totalFee = managementFee + accruedPerformanceFee();\n        uint256 currentAssets = totalAssets();\n        uint256 shareValue = convertToAssets(1e18);\n\n        if (shareValue > highWaterMark) highWaterMark = shareValue;\n\n        if (managementFee > 0) feesUpdatedAt = block.timestamp;\n\n        if (totalFee > 0 && currentAssets > 0)\n            _mint(feeRecipient, convertToShares(totalFee));\n\n        _;\n    }\n\n    modifier syncFeeCheckpoint() {\n        _;\n        highWaterMark = convertToAssets(1e18);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            FEE MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    VaultFees public fees;\n\n    VaultFees public proposedFees;\n    uint256 public proposedFeeTime;\n\n    address public feeRecipient;\n\n    event NewFeesProposed(VaultFees newFees, uint256 timestamp);\n    event ChangedFees(VaultFees oldFees, VaultFees newFees);\n    event FeeRecipientUpdated(address oldFeeRecipient, address newFeeRecipient);\n\n    error InvalidVaultFees();\n    error InvalidFeeRecipient();\n    error NotPassedQuitPeriod(uint256 quitPeriod);\n\n    /**\n     * @notice Propose new fees for this vault. Caller must be owner.\n     * @param newFees Fees for depositing, withdrawal, management and performance in 1e18.\n     * @dev Fees can be 0 but never 1e18 (1e18 = 100%, 1e14 = 1 BPS)\n     */\n    function proposeFees(VaultFees calldata newFees) external onlyOwner {\n        if (\n            newFees.deposit >= 1e18 ||\n            newFees.withdrawal >= 1e18 ||\n            newFees.management >= 1e18 ||\n            newFees.performance >= 1e18\n        ) revert InvalidVaultFees();\n\n        proposedFees = newFees;\n        proposedFeeTime = block.timestamp;\n\n        emit NewFeesProposed(newFees, block.timestamp);\n    }\n\n    /// @notice Change fees to the previously proposed fees after the quit period has passed.\n    function changeFees() external {\n        if (block.timestamp < proposedFeeTime + quitPeriod)\n            revert NotPassedQuitPeriod(quitPeriod);\n\n        emit ChangedFees(fees, proposedFees);\n        fees = proposedFees;\n    }\n\n    /**\n     * @notice Change `feeRecipient`. Caller must be Owner.\n     * @param _feeRecipient The new fee recipient.\n     * @dev Accrued fees wont be transferred to the new feeRecipient.\n     */\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        if (_feeRecipient == address(0)) revert InvalidFeeRecipient();\n\n        emit FeeRecipientUpdated(feeRecipient, _feeRecipient);\n\n        feeRecipient = _feeRecipient;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          ADAPTER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    IERC4626 public adapter;\n    IERC4626 public proposedAdapter;\n    uint256 public proposedAdapterTime;\n\n    event NewAdapterProposed(IERC4626 newAdapter, uint256 timestamp);\n    event ChangedAdapter(IERC4626 oldAdapter, IERC4626 newAdapter);\n\n    error VaultAssetMismatchNewAdapterAsset();\n\n    /**\n     * @notice Propose a new adapter for this vault. Caller must be Owner.\n     * @param newAdapter A new ERC4626 that should be used as a yield adapter for this asset.\n     */\n    function proposeAdapter(IERC4626 newAdapter) external onlyOwner {\n        if (newAdapter.asset() != address(asset))\n            revert VaultAssetMismatchNewAdapterAsset();\n\n        proposedAdapter = newAdapter;\n        proposedAdapterTime = block.timestamp;\n\n        emit NewAdapterProposed(newAdapter, block.timestamp);\n    }\n\n    /**\n     * @notice Set a new Adapter for this Vault after the quit period has passed.\n     * @dev This migration function will remove all assets from the old Vault and move them into the new vault\n     * @dev Additionally it will zero old allowances and set new ones\n     * @dev Last we update HWM and assetsCheckpoint for fees to make sure they adjust to the new adapter\n     */\n    function changeAdapter() external takeFees {\n        if (block.timestamp < proposedAdapterTime + quitPeriod)\n            revert NotPassedQuitPeriod(quitPeriod);\n\n        adapter.redeem(\n            adapter.balanceOf(address(this)),\n            address(this),\n            address(this)\n        );\n\n        asset.approve(address(adapter), 0);\n\n        emit ChangedAdapter(adapter, proposedAdapter);\n\n        adapter = proposedAdapter;\n\n        asset.approve(address(adapter), type(uint256).max);\n\n        adapter.deposit(asset.balanceOf(address(this)), address(this));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          RAGE QUIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public quitPeriod = 3 days;\n\n    event QuitPeriodSet(uint256 quitPeriod);\n\n    error InvalidQuitPeriod();\n\n    /**\n     * @notice Set a quitPeriod for rage quitting after new adapter or fees are proposed. Caller must be Owner.\n     * @param _quitPeriod Time to rage quit after proposal.\n     */\n    function setQuitPeriod(uint256 _quitPeriod) external onlyOwner {\n        if (_quitPeriod < 1 days || _quitPeriod > 7 days)\n            revert InvalidQuitPeriod();\n\n        quitPeriod = _quitPeriod;\n\n        emit QuitPeriodSet(quitPeriod);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          PAUSING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Pause deposits. Caller must be Owner.\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Unpause deposits. Caller must be Owner.\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      EIP-2612 LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    //  EIP-2612 STORAGE\n    uint256 internal INITIAL_CHAIN_ID;\n    bytes32 internal INITIAL_DOMAIN_SEPARATOR;\n    mapping(address => uint256) public nonces;\n\n    error PermitDeadlineExpired(uint256 deadline);\n    error InvalidSigner(address signer);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (deadline < block.timestamp) revert PermitDeadlineExpired(deadline);\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            if (recoveredAddress == address(0) || recoveredAddress != owner)\n                revert InvalidSigner(recoveredAddress);\n\n            _approve(recoveredAddress, spender, value);\n        }\n    }\n\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        return\n            block.chainid == INITIAL_CHAIN_ID\n                ? INITIAL_DOMAIN_SEPARATOR\n                : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(str"
    }
  ]
}