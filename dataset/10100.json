{
  "Title": "[M-01] Wrong implementation of `CreditLimitByMedian.sol#getLockedAmount()` will lock a much bigger total amount of staked tokens than expected",
  "Content": "_Submitted by WatchPug, also found by itsmeSTYJ_\n\n\n[`CreditLimitByMedian.sol` L27-L63](https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/CreditLimitByMedian.sol#L27-L63)\n\n```solidity\nfunction getLockedAmount(\n    LockedInfo[] memory array,\n    address account,\n    uint256 amount,\n    bool isIncrease\n) public pure override returns (uint256) {\n    if (array.length == 0) return 0;\n\n    uint256 newLockedAmount;\n    if (isIncrease) {\n        for (uint256 i = 0; i < array.length; i++) {\n            uint256 remainingVouchingAmount;\n            if (array[i].vouchingAmount > array[i].lockedAmount) {\n                remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;\n            } else {\n                remainingVouchingAmount = 0;\n            }\n\n            if (remainingVouchingAmount > array[i].availableStakingAmount) {\n                if (array[i].availableStakingAmount > amount) {\n                    newLockedAmount = array[i].lockedAmount + amount;\n                } else {\n                    newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;\n                }\n            } else {\n                if (remainingVouchingAmount > amount) {\n                    newLockedAmount = array[i].lockedAmount + amount;\n                } else {\n                    newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;\n                }\n            }\n\n            if (account == array[i].staker) {\n                return newLockedAmount;\n            }\n        }\n    } else {\n    ...\n```\n\n`getLockedAmount()` is used by `UserManager.sol#updateLockedData()` to update locked amounts.\n\nThe current implementation is wrong and locks every staker for the amount of the borrowed amount or all the `vouchingAmount` if the `vouchingAmount` is smaller than the borrowed amount in `CreditLimitByMedian` model.\n\n##### PoC\n*   10 stakers each give `100` of `vouchingAmount` to Alice;\n*   Alice borrows `100`;\n\nThe protocol will now lock `100` of each of the 10 stakers, making the total locked amount being `1000`.\n\n\n**[kingjacob (Union) disputed](https://github.com/code-423n4/2021-10-union-findings/issues/81#issuecomment-953713681):**\n > This is as designed.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-union-findings/issues/81#issuecomment-966742505):**\n > With the evidence shown and the comment of the sponsor, it seems to me like this is a bad idea, the protocol will lock funds at a rate of N * X, where X was the original amount borrowed and N is the number of stakers that are covering for it.\n>\n> This seems to be a surefire way for griefing, DOS attacks, and potentially to block other people funds in the protocol\n>\n> I would highly recommend the sponsor to consider the possibility that this behaviour can be used against the users of the protocol and can potentially kill the protocol in it's infancy\n\n**[kingjacob (Union) commented](https://github.com/code-423n4/2021-10-union-findings/issues/81#issuecomment-966985653):**\n > While creditlimitbymedian seems inefficient from a capital locked per loans outstanding view, it is a valid if agressive model. We’ve run agent simulation on both it and sumoftrust and theres tradeoffs with both.\n>\n>  For clarity of whats deployed, we’ll be deleting creditlimitbymedian from the repo but it is a valid implementation.\n\n**[kingjacob (Union) commented](https://github.com/code-423n4/2021-10-union-findings/issues/81#issuecomment-967218554):**\n > @GalloDaSballo this issue id argue is invalid as the implementation is correct and locks funds as instructed by creditlimitbymedian. Which is as designed.\n>\n> Locking > \\$M in underwriting per \\$M in borrowed funds is also not a “loss of funds” its common practice in credit markets, and might actually end up be required if default rates are high enough. And in the above model, the only one who can lock funds is the person the user chose to give the right to borrow (and lock the funds). Which I’d argue is distinct from an actual grief or DoS. (Unless you had something else in mind?)\n>\n> But all thats a bit offtopic, as this issue is reporting a wrong implementation, not an inefficient underwriting  model.\n>\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-union-findings/issues/81#issuecomment-968193970):**\n > @kingjacob (Union) For the sake of understarding, let's assume I convince 10 people to each put 1MLN so I can borrow 1 MLN.\n> If I then run away with the money and default, their 10 MLN would get locked.\n>\n> What would happen after?\n\n**[kingjacob (Union) commented](https://github.com/code-423n4/2021-10-union-findings/issues/81#issuecomment-968202955):**\n > @GalloDaSballo nothing. Stake stays locked earning interest which slowly fills the whole left by the default. Unless one of the stakers calls writeoffdebt.\n>\n> We dont solve the problem of what if someone trusts someone they shouldnt. Email me at jacob@union.finance, can hop on a call to explain in more detail.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-union-findings/issues/81#issuecomment-969115108):**\n > Me and the sponsor have scheduled a clarification call, the conversation should help clarify our different opinions\n>\n> Before the call I'd like to record my current opinion:\n>\n> - The system does what the sponsor designed (locks funds on default)\n> - To my understanding the system will lock N times the tokens necessary (again by design)\n> - By my experience in DeFi this means that potentially a lot of people can get locked\n> - There is a technicality with the findings that says \"Wrong Implementation\", the implementation is as the sponsor specified, however, for a myriad of reasons, `wrong` is a synonym with \"fallacious\" / \"errouneous\", hence my interpretation of the finding at this time is that it's not a warning for the code not being to spec, but rather the code allowing for a risky situation (tons of people with funds locked)\n>\n> Ref: Google's synonims for `wrong`\n> <img width=\"700\" alt=\"Screenshot 2021-11-15 at 17 58 27\" src=\"https://user-images.githubusercontent.com/13383782/141822630-ca321ff5-52b6-4c3b-bd48-2a89f9c52ecc.png\">\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-union-findings/issues/81#issuecomment-969116616):**\n > Given the specifics of this risk I am conflicted between a High (can lock arbitrary funds for an arbitrary amount of people) and Medium (they agreed to the dynamic, the time being locked is proportional to yield, higher yield = less time) severity finding, however believe it is correct for me to talk with the sponsor to hear their side of the story\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-union-findings/issues/81#issuecomment-970423305):**\n > After the conversation and the clarifications from the sponsor we both agree that the finding is of medium severity.\n> Allowing someone to borrow is a situation closer to giving your allowance, more of a feature than a risk.\n> However, locking a disproportional amount of people on default can be problematic and I think there should be a cap on that.\n>\n> The sponsor will mitigate by removing `CrediLimitByMedian` from the codebase\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-union-findings/issues/81#issuecomment-970436329):**\n > For the sake of transparency, we have recorded the call here\n> https://us02web.zoom.us/rec/share/kx789PdETc3NqJ7J9gy1tNHazJAmYufFfwKD-ob_Ct6akpnC-sZPp84cLozLOlpm.khrAW4nfFCPxJZCx Passcode: 2A07bsS@\n>\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-union-findings/issues/81#issuecomment-970437434):**\n > I've re-rated the severity of the issue given the specifics of the risk, as per CodeArena docs:\n> 2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-10-union",
  "Code": [
    {
      "filename": "contracts/user/CreditLimitByMedian.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/ICreditLimitModel.sol\";\n\ncontract CreditLimitByMedian is Ownable, ICreditLimitModel {\n    using Math for uint256;\n\n    bool public constant override isCreditLimitModel = true;\n    uint256 public override effectiveNumber;\n\n    constructor(uint256 effectiveNumber_) {\n        effectiveNumber = effectiveNumber_;\n    }\n\n    function getCreditLimit(uint256[] memory vouchs) public view override returns (uint256) {\n        if (vouchs.length >= effectiveNumber) {\n            return _findMedian(vouchs);\n        } else {\n            return 0;\n        }\n    }\n\n    function getLockedAmount(\n        LockedInfo[] memory array,\n        address account,\n        uint256 amount,\n        bool isIncrease\n    ) public pure override returns (uint256) {\n        if (array.length == 0) return 0;\n\n        uint256 newLockedAmount;\n        if (isIncrease) {\n            for (uint256 i = 0; i < array.length; i++) {\n                uint256 remainingVouchingAmount;\n                if (array[i].vouchingAmount > array[i].lockedAmount) {\n                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;\n                } else {\n                    remainingVouchingAmount = 0;\n                }\n\n                if (remainingVouchingAmount > array[i].availableStakingAmount) {\n                    if (array[i].availableStakingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;\n                    }\n                } else {\n                    if (remainingVouchingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;\n                    }\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        } else {\n            for (uint256 i = 0; i < array.length; i++) {\n                if (array[i].lockedAmount > amount) {\n                    newLockedAmount = array[i].lockedAmount - 1;\n                } else {\n                    newLockedAmount = 0;\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    function setEffectNumber(uint256 number) external onlyOwner {\n        effectiveNumber = number;\n    }\n\n    /**\n     *  @dev Find median from uint array\n     *  @param array array\n     *  @return uint256\n     */\n    function _findMedian(uint256[] memory array) private pure returns (uint256) {\n        uint256[] memory arr = _sortArray(array);\n        if (arr.length == 0) return 0;\n\n        if (arr.length % 2 == 0) {\n            uint256 num1 = arr[arr.length >> 1];\n            uint256 num2 = arr[(arr.length >> 1) - 1];\n            return num1.average(num2);\n        } else {\n            return arr[arr.length >> 1];\n        }\n    }\n\n    /**\n     *  @dev Sort uint array\n     *  @param arr array\n     *  @return uint256 array\n     */\n    function _sortArray(uint256[] memory arr) private pure returns (uint256[] memory) {\n        uint256 length = arr.length;\n\n        for (uint256 i = 0; i < length; i++) {\n            for (uint256 j = i + 1; j < length; j++) {\n                if (arr[i] < arr[j]) {\n                    uint256 temp = arr[j];\n                    arr[j] = arr[i];\n                    arr[i] = temp;\n                }\n            }\n        }\n\n        return arr;\n    }\n}"
    }
  ]
}