{
  "Title": "Events are probably missing",
  "Content": "##### Description:\nAt the line https://github.com/orbxball/curve-voter-proxy/blob/78c92e4ffc0f76651914565744a3607d0248d254/contracts/Strategy.sol#L157 in method `setKeepCRV()` should probably emit an event `newKeepCRV`.\nAt the line https://github.com/orbxball/curve-voter-proxy/blob/78c92e4ffc0f76651914565744a3607d0248d254/contracts/Strategy.sol#L165 in method `switchDex()` should probably emit an event `newDex`.\n\n\n##### Recommendation\nIt is recommended to create new events.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Strategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {\n    BaseStrategy,\n    StrategyParams\n} from \"@yearnvaults/contracts/BaseStrategy.sol\";\nimport {\n    SafeERC20,\n    SafeMath,\n    IERC20,\n    Address\n} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ninterface IERC20Metadata {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\ninterface Uni {\n    function swapExactTokensForTokens(\n        uint256,\n        uint256,\n        address[] calldata,\n        address,\n        uint256\n    ) external;\n}\n\ninterface ICurveFi {\n    function add_liquidity(\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount,\n        bool _use_underlying\n    ) external payable returns (uint256);\n\n    function add_liquidity(\n        uint256[3] calldata amounts,\n        uint256 min_mint_amount,\n        bool _use_underlying\n    ) external payable returns (uint256);\n\n    function add_liquidity(\n        uint256[4] calldata amounts,\n        uint256 min_mint_amount,\n        bool _use_underlying\n    ) external payable returns (uint256);\n\n    function add_liquidity(\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount\n    ) external payable;\n\n    function add_liquidity(\n        uint256[3] calldata amounts,\n        uint256 min_mint_amount\n    ) external payable;\n\n    function add_liquidity(\n        uint256[4] calldata amounts,\n        uint256 min_mint_amount\n    ) external payable;\n\n    // crv.finance: Curve.fi Factory USD Metapool v2\n    function add_liquidity(\n        address pool,\n        uint256[4] calldata amounts,\n        uint256 min_mint_amount\n    ) external;\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function balances(int128) external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n}\n\ninterface IVoterProxy {\n    function withdraw(\n        address _gauge,\n        address _token,\n        uint256 _amount\n    ) external returns (uint256);\n    function balanceOf(address _gauge) external view returns (uint256);\n    function withdrawAll(address _gauge, address _token) external returns (uint256);\n    function deposit(address _gauge, address _token) external;\n    function harvest(address _gauge) external;\n    function lock() external;\n    function approveStrategy(address) external;\n    function revokeStrategy(address) external;\n}\n\n\nabstract contract CurveVoterProxy is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public constant voter = address(0xF147b8125d2ef93FB6965Db97D6746952a133934);\n\n    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant dai = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    address public constant weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address public constant wbtc = address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n\n    address public constant uniswap = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address public constant sushiswap = address(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n\n    uint256 public constant DENOMINATOR = 10000;\n\n    address public proxy;\n    address public dex;\n    address public curve;\n    address public gauge;\n    uint256 public keepCRV;\n\n    constructor(address _vault) public BaseStrategy(_vault) {\n        minReportDelay = 12 hours;\n        maxReportDelay = 3 days;\n        profitFactor = 1000;\n        debtThreshold = 1e24;\n        proxy = address(0x9a165622a744C20E3B2CB443AeD98110a33a231b);\n    }\n\n    function setKeepCRV(uint256 _keepCRV) external onlyGovernance {\n        keepCRV = _keepCRV;\n    }\n\n    function setProxy(address _proxy) external onlyGovernance {\n        proxy = _proxy;\n    }\n\n    function switchDex(bool isUniswap) external onlyAuthorized {\n        if (isUniswap) dex = uniswap;\n        else dex = sushiswap;\n    }\n\n    function name() external view override returns (string memory) {\n        return string(abi.encodePacked(\"Curve\", IERC20Metadata(address(want)).symbol(), \"VoterProxy\"));\n    }\n\n    function balanceOfWant() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    function balanceOfPool() public view returns (uint256) {\n        return IVoterProxy(proxy).balanceOf(gauge);\n    }\n\n    function estimatedTotalAssets() public view override returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    function adjustPosition(uint256 _debtOutstanding) internal override {\n        uint256 _want = want.balanceOf(address(this));\n        if (_want > 0) {\n            want.safeTransfer(proxy, _want);\n            IVoterProxy(proxy).deposit(gauge, address(want));\n        }\n    }\n\n    function _withdrawSome(uint256 _amount) internal returns (uint256) {\n        return IVoterProxy(proxy).withdraw(gauge, address(want), _amount);\n    }\n\n    function liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 _liquidatedAmount, uint256 _loss)\n    {\n        uint256 _balance = want.balanceOf(address(this));\n        if (_balance < _amountNeeded) {\n            _liquidatedAmount = _withdrawSome(_amountNeeded.sub(_balance));\n            _liquidatedAmount = _liquidatedAmount.add(_balance);\n            // _loss = _amountNeeded.sub(_liquidatedAmount);\n        }\n        else {\n            _liquidatedAmount = _amountNeeded;\n        }\n    }\n\n    function prepareMigration(address _newStrategy) internal override {\n        IVoterProxy(proxy).withdrawAll(gauge, address(want));\n    }\n}\n\ncontract Strategy is CurveVoterProxy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    constructor(address _vault) public CurveVoterProxy(_vault) {\n        dex = sushiswap; // by default use sushiswap\n        curve = address('[curve address]');\n        gauge = address('[gauge address]');\n        keepCRV = 1000; // by default is 10%\n        // put reward tokens here\n        // reward = address('[reward token address]')\n    }\n\n    /**\n     * @dev Customize the selling logic for crv & reward tokens\n     *\n     * default tokens: weth, wbtc, dai\n     * flexiblt enough to construct multipath swap\n    */\n    function prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        IVoterProxy(proxy).harvest(gauge);\n        uint256 _crv = IERC20(crv).balanceOf(address(this));\n        if (_crv > 0) {\n            uint256 _keepCRV = _crv.mul(keepCRV).div(DENOMINATOR);\n            IERC20(crv).safeTransfer(voter, _keepCRV);\n            _crv = _crv.sub(_keepCRV);\n\n            IERC20(crv).safeApprove(dex, 0);\n            IERC20(crv).safeApprove(dex, _crv);\n\n            address[] memory path = new address[](3);\n            path[0] = crv;\n            path[1] = weth;\n            path[2] = usdc;\n\n            Uni(dex).swapExactTokensForTokens(_crv, uint256(0), path, address(this), now);\n        }\n        // claim reward tokens\n        // if more than one reward tokens, adding them all here\n        IVoterProxy(proxy).claimRewards(gauge, reward);\n        uint256 _reward = IERC20(reward).balanceOf(address(this));\n        if (_reward > 0) {\n            IERC20(reward).safeApprove(uniswap, 0);\n            IERC20(reward).safeApprove(uniswap, _reward);\n\n            address[] memory path = new address[](3);\n            path[0] = reward;\n            path[1] = wbtc;\n            path[2] = usdc;\n\n            Uni(uniswap).swapExactTokensForTokens(_reward, uint256(0), path, address(this), now);\n        }\n        // flexible enough to customize unique path\n        uint256 _usdc = IERC20(usdc).balanceOf(address(this));\n        if (_usdc > 0) {\n            IERC20(usdc).safeApprove(curve, 0);\n            IERC20(usdc).safeApprove(curve, _usdc);\n            ICurveFi(curve).exchange(1, 0, _usdc, 0);\n        }\n        uint256 _target = IERC20(target).balanceOf(address(this));\n        if (_target > 0) {\n            IERC20(target).safeApprove(curve, 0);\n            IERC20(target).safeApprove(curve, _target);\n            ICurveFi(curve).add_liquidity([_target, 0, 0], 0);\n        }\n\n        _profit = want.balanceOf(address(this));\n\n        // normally, keep this default\n        if (_debtOutstanding > 0) {\n            _debtPayment = _withdrawSome(_debtOutstanding);\n        }\n    }\n\n    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary\n\n    function protectedTokens()\n        internal\n        view\n        override\n        returns (address[] memory)\n    {\n        address[] memory protected = new address[](2);\n        protected[0] = crv;\n        protected[1] = reward;\n        return protected;\n    }\n}"
    },
    {
      "filename": "contracts/Strategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {\n    BaseStrategy,\n    StrategyParams\n} from \"@yearnvaults/contracts/BaseStrategy.sol\";\nimport {\n    SafeERC20,\n    SafeMath,\n    IERC20,\n    Address\n} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ninterface IERC20Metadata {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\ninterface Uni {\n    function swapExactTokensForTokens(\n        uint256,\n        uint256,\n        address[] calldata,\n        address,\n        uint256\n    ) external;\n}\n\ninterface ICurveFi {\n    function add_liquidity(\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount,\n        bool _use_underlying\n    ) external payable returns (uint256);\n\n    function add_liquidity(\n        uint256[3] calldata amounts,\n        uint256 min_mint_amount,\n        bool _use_underlying\n    ) external payable returns (uint256);\n\n    function add_liquidity(\n        uint256[4] calldata amounts,\n        uint256 min_mint_amount,\n        bool _use_underlying\n    ) external payable returns (uint256);\n\n    function add_liquidity(\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount\n    ) external payable;\n\n    function add_liquidity(\n        uint256[3] calldata amounts,\n        uint256 min_mint_amount\n    ) external payable;\n\n    function add_liquidity(\n        uint256[4] calldata amounts,\n        uint256 min_mint_amount\n    ) external payable;\n\n    // crv.finance: Curve.fi Factory USD Metapool v2\n    function add_liquidity(\n        address pool,\n        uint256[4] calldata amounts,\n        uint256 min_mint_amount\n    ) external;\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function balances(int128) external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n}\n\ninterface IVoterProxy {\n    function withdraw(\n        address _gauge,\n        address _token,\n        uint256 _amount\n    ) external returns (uint256);\n    function balanceOf(address _gauge) external view returns (uint256);\n    function withdrawAll(address _gauge, address _token) external returns (uint256);\n    function deposit(address _gauge, address _token) external;\n    function harvest(address _gauge) external;\n    function lock() external;\n    function approveStrategy(address) external;\n    function revokeStrategy(address) external;\n}\n\n\nabstract contract CurveVoterProxy is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public constant voter = address(0xF147b8125d2ef93FB6965Db97D6746952a133934);\n\n    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant dai = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    address public constant weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address public constant wbtc = address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n\n    address public constant uniswap = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address public constant sushiswap = address(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n\n    uint256 public constant DENOMINATOR = 10000;\n\n    address public proxy;\n    address public dex;\n    address public curve;\n    address public gauge;\n    uint256 public keepCRV;\n\n    constructor(address _vault) public BaseStrategy(_vault) {\n        minReportDelay = 12 hours;\n        maxReportDelay = 3 days;\n        profitFactor = 1000;\n        debtThreshold = 1e24;\n        proxy = address(0x9a165622a744C20E3B2CB443AeD98110a33a231b);\n    }\n\n    function setKeepCRV(uint256 _keepCRV) external onlyGovernance {\n        keepCRV = _keepCRV;\n    }\n\n    function setProxy(address _proxy) external onlyGovernance {\n        proxy = _proxy;\n    }\n\n    function switchDex(bool isUniswap) external onlyAuthorized {\n        if (isUniswap) dex = uniswap;\n        else dex = sushiswap;\n    }\n\n    function name() external view override returns (string memory) {\n        return string(abi.encodePacked(\"Curve\", IERC20Metadata(address(want)).symbol(), \"VoterProxy\"));\n    }\n\n    function balanceOfWant() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    function balanceOfPool() public view returns (uint256) {\n        return IVoterProxy(proxy).balanceOf(gauge);\n    }\n\n    function estimatedTotalAssets() public view override returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    function adjustPosition(uint256 _debtOutstanding) internal override {\n        uint256 _want = want.balanceOf(address(this));\n        if (_want > 0) {\n            want.safeTransfer(proxy, _want);\n            IVoterProxy(proxy).deposit(gauge, address(want));\n        }\n    }\n\n    function _withdrawSome(uint256 _amount) internal returns (uint256) {\n        return IVoterProxy(proxy).withdraw(gauge, address(want), _amount);\n    }\n\n    function liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 _liquidatedAmount, uint256 _loss)\n    {\n        uint256 _balance = want.balanceOf(address(this));\n        if (_balance < _amountNeeded) {\n            _liquidatedAmount = _withdrawSome(_amountNeeded.sub(_balance));\n            _liquidatedAmount = _liquidatedAmount.add(_balance);\n            // _loss = _amountNeeded.sub(_liquidatedAmount);\n        }\n        else {\n            _liquidatedAmount = _amountNeeded;\n        }\n    }\n\n    function prepareMigration(address _newStrategy) internal override {\n        IVoterProxy(proxy).withdrawAll(gauge, address(want));\n    }\n}\n\ncontract Strategy is CurveVoterProxy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    constructor(address _vault) public CurveVoterProxy(_vault) {\n        dex = sushiswap; // by default use sushiswap\n        curve = address('[curve address]');\n        gauge = address('[gauge address]');\n        keepCRV = 1000; // by default is 10%\n        // put reward tokens here\n        // reward = address('[reward token address]')\n    }\n\n    /**\n     * @dev Customize the selling logic for crv & reward tokens\n     *\n     * default tokens: weth, wbtc, dai\n     * flexiblt enough to construct multipath swap\n    */\n    function prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        IVoterProxy(proxy).harvest(gauge);\n        uint256 _crv = IERC20(crv).balanceOf(address(this));\n        if (_crv > 0) {\n            uint256 _keepCRV = _crv.mul(keepCRV).div(DENOMINATOR);\n            IERC20(crv).safeTransfer(voter, _keepCRV);\n            _crv = _crv.sub(_keepCRV);\n\n            IERC20(crv).safeApprove(dex, 0);\n            IERC20(crv).safeApprove(dex, _crv);\n\n            address[] memory path = new address[](3);\n            path[0] = crv;\n            path[1] = weth;\n            path[2] = usdc;\n\n            Uni(dex).swapExactTokensForTokens(_crv, uint256(0), path, address(this), now);\n        }\n        // claim reward tokens\n        // if more than one reward tokens, adding them all here\n        IVoterProxy(proxy).claimRewards(gauge, reward);\n        uint256 _reward = IERC20(reward).balanceOf(address(this));\n        if (_reward > 0) {\n            IERC20(reward).safeApprove(uniswap, 0);\n            IERC20(reward).safeApprove(uniswap, _reward);\n\n            address[] memory path = new address[](3);\n            path[0] = reward;\n            path[1] = wbtc;\n            path[2] = usdc;\n\n            Uni(uniswap).swapExactTokensForTokens(_reward, uint256(0), path, address(this), now);\n        }\n        // flexible enough to customize unique path\n        uint256 _usdc = IERC20(usdc).balanceOf(address(this));\n        if (_usdc > 0) {\n            IERC20(usdc).safeApprove(curve, 0);\n            IERC20(usdc).safeApprove(curve, _usdc);\n            ICurveFi(curve).exchange(1, 0, _usdc, 0);\n        }\n        uint256 _target = IERC20(target).balanceOf(address(this));\n        if (_target > 0) {\n            IERC20(target).safeApprove(curve, 0);\n            IERC20(target).safeApprove(curve, _target);\n            ICurveFi(curve).add_liquidity([_target, 0, 0], 0);\n        }\n\n        _profit = want.balanceOf(address(this));\n\n        // normally, keep this default\n        if (_debtOutstanding > 0) {\n            _debtPayment = _withdrawSome(_debtOutstanding);\n        }\n    }\n\n    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary\n\n    function protectedTokens()\n        internal\n        view\n        override\n        returns (address[] memory)\n    {\n        address[] memory protected = new address[](2);\n        protected[0] = crv;\n        protected[1] = reward;\n        return protected;\n    }\n}"
    }
  ]
}