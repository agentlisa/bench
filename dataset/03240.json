{
  "Title": "Controller can be initialized several times",
  "Content": "##### Description\nIn contract `Controller` the `initialize` function can be called several times: https://github.com/mixbytes/lido-dot-ksm/blob/76a10efa5f223c4c613f26794802b8fb9bb188e1/contracts/Controller.sol#L140\n\n##### Recommendation\nWe recommend adding the `initializer` modifier.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Controller.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IRelayEncoder.sol\";\nimport \"../interfaces/IxTokens.sol\";\nimport \"../interfaces/IXcmTransactor.sol\";\nimport \"../interfaces/ILedger.sol\";\n\n\n\ncontract Controller {\n    // ledger controller account\n    uint16 public rootDerivativeIndex;\n\n    // relay side account id\n    bytes32 public relayAccount;\n\n    // vKSM precompile\n    IERC20 internal vKSM;\n\n    // relay call builder precompile\n    IRelayEncoder internal relayEncoder;\n\n    // xcm transactor precompile\n    IXcmTransactor internal xcmTransactor;\n\n    // xTokens precompile\n    IxTokens internal xTokens;\n\n    // Second layer derivative-proxy account to index\n    mapping(address => uint16) public senderToIndex;\n    mapping(uint16 => bytes32) public indexToAccount;\n\n    uint16 public tododelete;\n\n    enum WEIGHT {\n        AS_DERIVATIVE,              // 410_000_000\n        BOND_BASE,                  // 600_000_000\n        BOND_EXTRA_BASE,            // 1_100_000_000\n        UNBOND_BASE,                // 1_250_000_000\n        WITHDRAW_UNBONDED_BASE,     // 500_000_000\n        WITHDRAW_UNBONDED_PER_UNIT, // 60_000\n        REBOND_BASE,                // 1_200_000_000\n        REBOND_PER_UNIT,            // 40_000\n        CHILL_BASE,                 // 900_000_000\n        NOMINATE_BASE,              // 1_000_000_000\n        NOMINATE_PER_UNIT,          // 31_000_000\n        TRANSFER_TO_PARA_BASE,      // 700_000_000\n        TRANSFER_TO_RELAY_BASE      // 4_000_000_000\n    }\n\n    uint64 public MAX_WEIGHT;// = 1_835_300_000;\n\n    uint64[] public weights;\n\n    event WeightUpdated (\n        uint8 index,\n        uint64 newValue\n    );\n\n    event Bond (\n        address caller,\n        bytes32 stash,\n        bytes32 controller,\n        uint256 amount\n    );\n\n    event BondExtra (\n        address caller,\n        bytes32 stash,\n        uint256 amount\n    );\n\n    event Unbond (\n        address caller,\n        bytes32 stash,\n        uint256 amount\n    );\n\n    event Rebond (\n        address caller,\n        bytes32 stash,\n        uint256 amount\n    );\n\n    event Withdraw (\n        address caller,\n        bytes32 stash\n    );\n\n    event Nominate (\n        address caller,\n        bytes32 stash,\n        bytes32[] validators\n    );\n\n    event Chill (\n        address caller,\n        bytes32 stash\n    );\n\n    event TransferToRelaychain (\n        address from,\n        bytes32 to,\n        uint256 amount\n    );\n\n    event TransferToParachain (\n        bytes32 from,\n        address to,\n        uint256 amount\n    );\n\n\n    modifier onlyRegistred() {\n        require(senderToIndex[msg.sender] != 0, \"sender isn't registred\");\n        _;\n    }\n\n    function initialize() external {} //stub\n\n    /**\n    * @notice Initialize ledger contract.\n    * @param _rootDerivativeIndex - stash account id\n    * @param _relayAccount - controller account id\n    * @param _vKSM - vKSM contract address\n    * @param _relayEncoder - relayEncoder(relaychain calls builder) contract address\n    * @param _xcmTransactor - xcmTransactor(relaychain calls relayer) contract address\n    * @param _xTokens - minimal allowed nominator balance\n    */\n    function init(\n        uint16 _rootDerivativeIndex,\n        bytes32 _relayAccount,\n        address _vKSM,\n        address _relayEncoder,\n        address _xcmTransactor,\n        address _xTokens\n    ) external {\n        relayAccount = _relayAccount;\n        rootDerivativeIndex = _rootDerivativeIndex;\n\n        vKSM = IERC20(_vKSM);\n        relayEncoder = IRelayEncoder(_relayEncoder);\n        xcmTransactor = IXcmTransactor(_xcmTransactor);\n        xTokens = IxTokens(_xTokens);\n    }\n\n\n    function getWeight(WEIGHT weightType) public returns(uint64) {\n        return weights[uint256(weightType)];\n    }\n\n\n    function setMaxWeight(uint64 maxWeight) external {\n        MAX_WEIGHT = maxWeight;\n    }\n\n    function setWeights(\n        uint128[] calldata _weights\n    ) external {\n        require(_weights.length == uint256(type(WEIGHT).max) + 1, \"wrong weights size\");\n        for (uint256 i = 0; i < _weights.length; ++i) {\n            if ((_weights[i] >> 64) > 0) {\n                if (weights.length == i) {\n                    weights.push(0);\n                }\n\n                weights[i] = uint64(_weights[i]);\n                emit WeightUpdated(uint8(i), weights[i]);\n            }\n        }\n    }\n\n\n    function newSubAccount(uint16 index, bytes32 accountId, address paraAddress) external {\n        require(indexToAccount[index + 1] == bytes32(0), \"already registred\");\n\n        senderToIndex[paraAddress] = index + 1;\n        indexToAccount[index + 1] = accountId;\n    }\n\n\n    function nominate(bytes32[] calldata validators) external onlyRegistred {\n        uint256[] memory convertedValidators = new uint256[](validators.length);\n        for (uint256 i = 0; i < validators.length; ++i) {\n            convertedValidators[i] = uint256(validators[i]);\n        }\n        callThroughDerivative(\n            getSenderIndex(),\n            getWeight(WEIGHT.NOMINATE_BASE) + getWeight(WEIGHT.NOMINATE_PER_UNIT) * uint64(validators.length),\n            relayEncoder.encode_nominate(convertedValidators)\n        );\n\n        emit Nominate(msg.sender, getSenderAccount(), validators);\n    }\n\n    function bond(bytes32 controller, uint256 amount) external onlyRegistred {\n        callThroughDerivative(\n            getSenderIndex(),\n            getWeight(WEIGHT.BOND_BASE),\n            relayEncoder.encode_bond(uint256(controller), amount, bytes(hex\"00\"))\n        );\n\n        emit Bond(msg.sender, getSenderAccount(), controller, amount);\n    }\n\n    function bondExtra(uint256 amount) external onlyRegistred {\n        callThroughDerivative(\n            getSenderIndex(),\n            getWeight(WEIGHT.BOND_EXTRA_BASE),\n            relayEncoder.encode_bond_extra(amount)\n        );\n\n        emit BondExtra(msg.sender, getSenderAccount(), amount);\n    }\n\n    function unbond(uint256 amount) external onlyRegistred {\n        callThroughDerivative(\n            getSenderIndex(),\n            getWeight(WEIGHT.UNBOND_BASE),\n            relayEncoder.encode_unbond(amount)\n        );\n\n        emit Unbond(msg.sender, getSenderAccount(), amount);\n    }\n\n    function withdrawUnbonded() external onlyRegistred {\n        callThroughDerivative(\n            getSenderIndex(),\n            getWeight(WEIGHT.WITHDRAW_UNBONDED_BASE) + getWeight(WEIGHT.WITHDRAW_UNBONDED_PER_UNIT) * 10,\n            relayEncoder.encode_withdraw_unbonded(10/* TODO fix*/)\n        );\n\n        emit Withdraw(msg.sender, getSenderAccount());\n    }\n\n    function rebond(uint256 amount) external onlyRegistred {\n        callThroughDerivative(\n            getSenderIndex(),\n            getWeight(WEIGHT.REBOND_BASE) + getWeight(WEIGHT.REBOND_PER_UNIT) * 10 /*TODO fix*/,\n            relayEncoder.encode_rebond(amount)\n        );\n\n        emit Rebond(msg.sender, getSenderAccount(), amount);\n    }\n\n    function chill() external onlyRegistred {\n        callThroughDerivative(\n            getSenderIndex(),\n            getWeight(WEIGHT.CHILL_BASE),\n            relayEncoder.encode_chill()\n        );\n\n        emit Chill(msg.sender, getSenderAccount());\n    }\n\n    function transferToParachain(uint256 amount) external onlyRegistred {\n        // to - msg.sender, from - getSenderIndex()\n        callThroughDerivative(\n            getSenderIndex(),\n            getWeight(WEIGHT.TRANSFER_TO_PARA_BASE),\n            encodeReverseTransfer(msg.sender, amount)\n        );\n\n        emit TransferToParachain(getSenderAccount(), msg.sender, amount);\n    }\n\n    function transferToRelaychain(uint256 amount) external onlyRegistred {\n        // to - getSenderIndex(), from - msg.sender\n        vKSM.transferFrom(msg.sender, address(this), amount);\n        IxTokens.Multilocation memory destination;\n        destination.parents = 1;\n        destination.interior = new bytes[](1);\n        destination.interior[0] = bytes.concat(bytes1(hex\"01\"), getSenderAccount(), bytes1(hex\"00\")); // X2, NetworkId: Any\n        xTokens.transfer(address(vKSM), amount + 18900000000, destination, getWeight(WEIGHT.TRANSFER_TO_RELAY_BASE));\n\n        emit TransferToRelaychain(msg.sender, getSenderAccount(), amount);\n    }\n\n\n    function getSenderIndex() internal returns(uint16) {\n        return senderToIndex[msg.sender] - 1;\n    }\n\n    function getSenderAccount() internal returns(bytes32) {\n        return indexToAccount[senderToIndex[msg.sender]];\n    }\n\n    function callThroughDerivative(uint16 index, uint64 weight, bytes memory call) internal {\n        bytes memory le_index = new bytes(2);\n        le_index[0] = bytes1(uint8(index));\n        le_index[1] = bytes1(uint8(index >> 8));\n\n        uint64 total_weight = weight + getWeight(WEIGHT.AS_DERIVATIVE);\n        require(total_weight <= MAX_WEIGHT, \"too much weight\");\n\n        xcmTransactor.transact_through_derivative(0, rootDerivativeIndex, address(vKSM),\n            total_weight,\n            bytes.concat(hex\"1001\", le_index, call)\n        );\n    }\n\n    function encodeReverseTransfer(address to, uint256 amount) internal returns(bytes memory) {\n        return bytes.concat(\n            hex\"630201000100a10f0100010300\",\n            abi.encodePacked(to),\n            hex\"010400000000\",\n            scaleCompactUint(amount),\n            hex\"00000000\"\n        );\n    }\n\n    function toLeBytes(uint256 value, uint256 len) internal returns(bytes memory) {\n        bytes memory out = new bytes(len);\n        for (uint256 idx = 0; idx < len; ++idx) {\n            out[idx] = bytes1(uint8(value));\n            value = value >> 8;\n        }\n        return out;\n    }\n\n    function scaleCompactUint(uint256 value) internal returns(bytes memory) {\n        if (value < 1<<6) {\n            return toLeBytes(value << 2, 1);\n        }\n        else if(value < 1 << 14) {\n            return toLeBytes((value << 2) + 1, 2);\n        }\n        else if(value < 1 << 30) {\n            return toLeBytes((value << 2) + 2, 4);\n        }\n        else {\n            uint256 numBytes = 0;\n            {\n                uint256 m = value;\n                for (; numBytes < 256 && m != 0; ++numBytes) {\n                    m = m >> 8;\n                }\n            }\n\n            bytes memory out = new bytes(numBytes + 1);\n            out[0] = bytes1(uint8(((numBytes - 4) << 2) + 3));\n            for (uint256 i = 0; i < numBytes; ++i) {\n                out[i + 1] = bytes1(uint8(value & 0xFF));\n                value = value >> 8;\n            }\n            return out;\n        }\n    }\n}"
    }
  ]
}