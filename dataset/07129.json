{
  "Title": "[M-03] DOS risk if enough tokens are minted in Quest.claim can lead, at least, to transaction fee lost",
  "Content": "# Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L99\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L117-L133\n\n\n# Vulnerability details\n\n# DOS risk if enough tokens are minted in Quest.claim\n## Description\n```claim``` function can be summaraized in next steps:\n1. Check that the quest is active\n2. Check the contract is not paused\n3. Get tokens corresponding to msg.sender for ```questId``` using ```rabbitHoleReceiptContract.getOwnedTokenIdsOfQuest```: **DOS**\n4. Check that msg.sender owns at least one token\n5. Count non claimed tokens\n6. Check there is at least 1 unclaimed token\n7. Calculate redeemable rewards: ```_calculateRewards(redeemableTokenCount);```\n8. Set all token to claimed state\n9. Update ```redeemedTokens```\n10. Emit claim event\n\nThe problem with this functions relays in its dependency on ```RabbitHoleReceipt.getOwnedTokenIdsOfQuest```. It's behaviour can be summarized in next steps:\n1. Get queried balance (claimingAddress_)\n2. Get claimingAddress_ owned tokens \n3. Filter tokens corresponding to questId_\n4. Return token of claimingAddress_ corresponding to questId_\n\nIf a user takes part in many quests and gets lot's of tokens, the claim function will eventually reach block gas limit. Therefore, it will be unable to claim their tokens.\n\nIf a user actively participates in multiple quests and accumulates a large number of tokens, the claim function may eventually reach the block gas limit. As a result, the user may be unable to successfully claim their earned tokens.\n\n## Impact\nIt can be argued that function ```ERC721.burn``` can address the potential DOS risk in the claim process. However, it is important to note the following limitations and drawbacks associated with this approach:\n1. Utilizing ```ERC721.burn``` does not prevent the user from incurring network fees if a griefer, who has already claimed their rewards, sends their tokens to the user with the intent of causing a DOS and inducing loss of gas.\n1. If the user has not claimed any rewards from their accumulated tokens, they will still be forced to burn at least some of their tokens, resulting in a loss of these assets.\n\n\n## POC\n### Griefing\n1. Alice has took part in many quests, and want to recieve her rewards, so she call Quest.claim() function\n2. Bob also has already claimed many rewards from many quest, and decide to frontrun alice an send her all his tokens to DOS her\n3. Alice run out of gas, she lose transaction fees.\n\n### Lose of unclaimed rewards\n1. Alice always takes part in many quest, but never claim her rewards. She trust RabbitHole protocol and is waiting to have much more rewards to claim in order to save some transaction fees\n2. When Alice decide to call claim function she realize that she has run out of gas.\n\nThen, Alice can only burn her some of her tokens to claim at least some rewards.\n\n### Code\n[Code sample](https://gist.github.com/carlitox477/85e37d26c6f810304c849c93235ee99e)\n\n## Mittigation steps\nIf a user can sent a token list by parameter to claim function, then this vector attack can be mitigated.\n\nTo do this add next function to ```RabbitHoleReceipt.sol```:\n```solidity\nfunction checkTokenCorrespondToQuest(uint tokenId, string memory questId_) external view returns(bool){\n    return keccak256(bytes(questIdForTokenId[tokenId])) == keccak256(bytes(questId_));\n}\n```\n\nThen modify ```Quest.claim```: \n\n```diff\n// Quest.sol\n-   function claim() public virtual onlyQuestActive {\n+   function claim(uint[] memory tokens) public virtual onlyQuestActive {\n        if (isPaused) revert QuestPaused();\n\n-       uint[] memory tokens = rabbitHoleReceiptContract.getOwnedTokenIdsOfQuest(questId, msg.sender);\n\n        // require(tokens.length > 0)\n        if (tokens.length == 0) revert NoTokensToClaim();\n\n        uint256 redeemableTokenCount = 0;\n        for (uint i = 0; i < tokens.length; i++) {\n            // Check that the token correspond to this quest\n            require(rabbitHoleReceiptContract.checkTokenCorrespondToQuest(tokens[i],questId))\n\n-           if (!isClaimed(tokens[i])) {\n+           if (!isClaimed(tokens[i]) && rabbitHoleReceiptContract.checkTokenCorrespondToQuest(tokens[i],questId)) {\n                redeemableTokenCount++;\n            }\n        }\n\n        if (redeemableTokenCount == 0) revert AlreadyClaimed();\n\n        uint256 totalRedeemableRewards = _calculateRewards(redeemableTokenCount);\n        _setClaimed(tokens);\n        _transferRewards(totalRedeemableRewards);\n        redeemedTokens += redeemableTokenCount;\n\n        emit Claimed(msg.sender, totalRedeemableRewards);\n    }",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-rabbithole-quest-protocol-contest",
  "Code": [
    {
      "filename": "contracts/Quest.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IQuest} from './interfaces/IQuest.sol';\nimport {RabbitHoleReceipt} from './RabbitHoleReceipt.sol';\nimport {ECDSA} from '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\n\n/// @title Quest\n/// @author RabbitHole.gg\n/// @notice This contract is the base contract for all Quests. The Erc20Quest and Erc1155Quest contracts inherit from this contract.\ncontract Quest is Ownable, IQuest {\n    RabbitHoleReceipt public immutable rabbitHoleReceiptContract;\n    address public immutable rewardToken;\n    uint256 public immutable endTime;\n    uint256 public immutable startTime;\n    uint256 public immutable totalParticipants;\n    uint256 public immutable rewardAmountInWeiOrTokenId;\n    bool public hasStarted;\n    bool public isPaused;\n    string public questId;\n    uint256 public redeemedTokens;\n\n    mapping(uint256 => bool) private claimedList;\n\n    constructor(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountInWeiOrTokenId_,\n        string memory questId_,\n        address receiptContractAddress_\n    ) {\n        if (endTime_ <= block.timestamp) revert EndTimeInPast();\n        if (startTime_ <= block.timestamp) revert StartTimeInPast();\n        if (endTime_ <= startTime_) revert EndTimeLessThanOrEqualToStartTime();\n        endTime = endTime_;\n        startTime = startTime_;\n        rewardToken = rewardTokenAddress_;\n        totalParticipants = totalParticipants_;\n        rewardAmountInWeiOrTokenId = rewardAmountInWeiOrTokenId_;\n        questId = questId_;\n        rabbitHoleReceiptContract = RabbitHoleReceipt(receiptContractAddress_);\n        redeemedTokens = 0;\n    }\n\n    /// @notice Starts the Quest\n    /// @dev Only the owner of the Quest can call this function\n    function start() public virtual onlyOwner {\n        isPaused = false;\n        hasStarted = true;\n    }\n\n    /// @notice Pauses the Quest\n    /// @dev Only the owner of the Quest can call this function. Also requires that the Quest has started (not by date, but by calling the start function)\n    function pause() public onlyOwner onlyStarted {\n        isPaused = true;\n    }\n\n    /// @notice Unpauses the Quest\n    /// @dev Only the owner of the Quest can call this function. Also requires that the Quest has started (not by date, but by calling the start function)\n    function unPause() public onlyOwner onlyStarted {\n        isPaused = false;\n    }\n\n    /// @notice Marks token ids as claimed\n    /// @param tokenIds_ The token ids to mark as claimed\n    function _setClaimed(uint256[] memory tokenIds_) private {\n        for (uint i = 0; i < tokenIds_.length; i++) {\n            claimedList[tokenIds_[i]] = true;\n        }\n    }\n\n    /// @notice Prevents reward withdrawal until the Quest has ended\n    modifier onlyAdminWithdrawAfterEnd() {\n        if (block.timestamp < endTime) revert NoWithdrawDuringClaim();\n        _;\n    }\n\n    /// @notice Checks if the Quest has started at the function level\n    modifier onlyStarted() {\n        if (!hasStarted) revert NotStarted();\n        _;\n    }\n\n    /// @notice Checks if quest has started both at the function level and at the start time\n    modifier onlyQuestActive() {\n        if (!hasStarted) revert NotStarted();\n        if (block.timestamp < startTime) revert ClaimWindowNotStarted();\n        _;\n    }\n\n    /// @notice Allows user to claim the rewards entitled to them\n    /// @dev User can claim based on the (unclaimed) number of tokens they own of the Quest\n    function claim() public virtual onlyQuestActive {\n        if (isPaused) revert QuestPaused();\n\n        uint[] memory tokens = rabbitHoleReceiptContract.getOwnedTokenIdsOfQuest(questId, msg.sender);\n\n        if (tokens.length == 0) revert NoTokensToClaim();\n\n        uint256 redeemableTokenCount = 0;\n        for (uint i = 0; i < tokens.length; i++) {\n            if (!isClaimed(tokens[i])) {\n                redeemableTokenCount++;\n            }\n        }\n\n        if (redeemableTokenCount == 0) revert AlreadyClaimed();\n\n        uint256 totalRedeemableRewards = _calculateRewards(redeemableTokenCount);\n        _setClaimed(tokens);\n        _transferRewards(totalRedeemableRewards);\n        redeemedTokens += redeemableTokenCount;\n\n        emit Claimed(msg.sender, totalRedeemableRewards);\n    }\n\n    /// @notice Calculate the amount of rewards\n    /// @dev This function must be implemented in the child contracts\n    function _calculateRewards(uint256 redeemableTokenCount_) internal virtual returns (uint256) {\n        revert MustImplementInChild();\n    }\n\n    /// @notice Transfer the rewards to the user\n    /// @dev This function must be implemented in the child contracts\n    /// @param amount_ The amount of rewards to transfer\n    function _transferRewards(uint256 amount_) internal virtual {\n        revert MustImplementInChild();\n    }\n\n    /// @notice Checks if a Receipt token id has been used to claim a reward\n    /// @param tokenId_ The token id to check\n    function isClaimed(uint256 tokenId_) public view returns (bool) {\n        return claimedList[tokenId_] == true;\n    }\n\n    /// @dev Returns the reward amount\n    function getRewardAmount() public view returns (uint256) {\n        return rewardAmountInWeiOrTokenId;\n    }\n\n    /// @dev Returns the reward token address\n    function getRewardToken() public view returns (address) {\n        return rewardToken;\n    }\n\n    /// @notice Allows the owner of the Quest to withdraw any remaining rewards after the Quest has ended\n    function withdrawRemainingTokens(address to_) public virtual onlyOwner onlyAdminWithdrawAfterEnd {}\n}"
    },
    {
      "filename": "contracts/RabbitHoleReceipt.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/interfaces/IERC2981Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol';\nimport './ReceiptRenderer.sol';\nimport './interfaces/IQuestFactory.sol';\nimport './interfaces/IQuest.sol';\n\ncontract RabbitHoleReceipt is\n    Initializable,\n    ERC721Upgradeable,\n    ERC721EnumerableUpgradeable,\n    ERC721URIStorageUpgradeable,\n    OwnableUpgradeable,\n    IERC2981Upgradeable\n{\n    event RoyaltyFeeSet(uint256 indexed royaltyFee);\n    event MinterAddressSet(address indexed minterAddress);\n\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    CountersUpgradeable.Counter private _tokenIds;\n\n    // storage\n    mapping(uint => string) public questIdForTokenId;\n    address public royaltyRecipient;\n    address public minterAddress;\n    uint public royaltyFee;\n    mapping(uint => uint) public timestampForTokenId;\n    ReceiptRenderer public ReceiptRendererContract;\n    IQuestFactory public QuestFactoryContract;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address receiptRenderer_,\n        address royaltyRecipient_,\n        address minterAddress_,\n        uint royaltyFee_\n    ) public initializer {\n        __ERC721_init('RabbitHoleReceipt', 'RHR');\n        __ERC721URIStorage_init();\n        __Ownable_init();\n        royaltyRecipient = royaltyRecipient_;\n        minterAddress = minterAddress_;\n        royaltyFee = royaltyFee_;\n        ReceiptRendererContract = ReceiptRenderer(receiptRenderer_);\n    }\n\n    modifier onlyMinter() {\n        msg.sender == minterAddress;\n        _;\n    }\n\n    /// @dev set the receipt renderer contract\n    /// @param receiptRenderer_ the address of the receipt renderer contract\n    function setReceiptRenderer(address receiptRenderer_) public onlyOwner {\n        ReceiptRendererContract = ReceiptRenderer(receiptRenderer_);\n    }\n\n    /// @dev set the royalty recipient\n    /// @param royaltyRecipient_ the address of the royalty recipient\n    function setRoyaltyRecipient(address royaltyRecipient_) public onlyOwner {\n        royaltyRecipient = royaltyRecipient_;\n    }\n\n    /// @dev set the quest factory contract\n    /// @param questFactory_ the address of the quest factory contract\n    function setQuestFactory(address questFactory_) public onlyOwner {\n        QuestFactoryContract = IQuestFactory(questFactory_);\n    }\n\n    /// @dev set the minter address\n    /// @param minterAddress_ the address of the minter\n    function setMinterAddress(address minterAddress_) public onlyOwner {\n        minterAddress = minterAddress_;\n        emit MinterAddressSet(minterAddress_);\n    }\n\n    /// @dev set the royalty fee\n    /// @param royaltyFee_ the royalty fee\n    function setRoyaltyFee(uint256 royaltyFee_) public onlyOwner {\n        royaltyFee = royaltyFee_;\n        emit RoyaltyFeeSet(royaltyFee_);\n    }\n\n    /// @dev mint a receipt\n    /// @param to_ the address to mint to\n    /// @param questId_ the quest id\n    function mint(address to_, string memory questId_) public onlyMinter {\n        _tokenIds.increment();\n        uint newTokenID = _tokenIds.current();\n        questIdForTokenId[newTokenID] = questId_;\n        timestampForTokenId[newTokenID] = block.timestamp;\n        _safeMint(to_, newTokenID);\n    }\n\n    /// @dev get the token ids for a quest owned by an address\n    /// @param questId_ the quest id\n    /// @param claimingAddress_ the address claiming to own the tokens\n    function getOwnedTokenIdsOfQuest(\n        string memory questId_,\n        address claimingAddress_\n    ) public view returns (uint[] memory) {\n        uint msgSenderBalance = balanceOf(claimingAddress_);\n        uint[] memory tokenIdsForQuest = new uint[](msgSenderBalance);\n        uint foundTokens = 0;\n\n        for (uint i = 0; i < msgSenderBalance; i++) {\n            uint tokenId = tokenOfOwnerByIndex(claimingAddress_, i);\n            if (keccak256(bytes(questIdForTokenId[tokenId])) == keccak256(bytes(questId_))) {\n                tokenIdsForQuest[i] = tokenId;\n                foundTokens++;\n            }\n        }\n\n        uint[] memory filteredTokens = new uint[](foundTokens);\n        uint filterTokensIndexTracker = 0;\n\n        for (uint i = 0; i < msgSenderBalance; i++) {\n            if (tokenIdsForQuest[i] > 0) {\n                filteredTokens[filterTokensIndexTracker] = tokenIdsForQuest[i];\n                filterTokensIndexTracker++;\n            }\n        }\n        return filteredTokens;\n    }\n\n    /// @dev burn a receipt\n    /// @param tokenId_ the token id\n    function _burn(uint256 tokenId_) internal override(ERC721Upgradeable, ERC721URIStorageUpgradeable) {\n        super._burn(tokenId_);\n    }\n\n    /// @dev before token transfer hook, called before any token transfer\n    /// @param from_ the address from\n    /// @param to_ the address to\n    /// @param tokenId_ the token id\n    /// @param batchSize_ the batch size\n    function _beforeTokenTransfer(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 batchSize_\n    ) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {\n        super._beforeTokenTransfer(from_, to_, tokenId_, batchSize_);\n    }\n\n    /// @dev return the token uri, this delegates to the receipt renderer contract\n    function tokenURI(\n        uint tokenId_\n    ) public view virtual override(ERC721Upgradeable, ERC721URIStorageUpgradeable) returns (string memory) {\n        require(_exists(tokenId_), 'ERC721URIStorage: URI query for nonexistent token');\n        require(QuestFactoryContract != IQuestFactory(address(0)), 'QuestFactory not set');\n\n        string memory questId = questIdForTokenId[tokenId_];\n        (address questAddress, uint totalParticipants, ) = QuestFactoryContract.questInfo(questId);\n        IQuest questContract = IQuest(questAddress);\n\n        bool claimed = questContract.isClaimed(tokenId_);\n        uint rewardAmount = questContract.getRewardAmount();\n        address rewardAddress = questContract.getRewardToken();\n\n        return ReceiptRendererContract.generateTokenURI(tokenId_, questId, totalParticipants, claimed, rewardAmount, rewardAddress);\n    }\n\n    /// @dev See {IERC165-royaltyInfo}\n    /// @param tokenId_ the token id\n    /// @param salePrice_ the sale price\n    function royaltyInfo(\n        uint256 tokenId_,\n        uint256 salePrice_\n    ) external view override returns (address receiver, uint256 royaltyAmount) {\n        require(_exists(tokenId_), 'Nonexistent token');\n\n        uint256 royaltyPayment = (salePrice_ * royaltyFee) / 10_000;\n        return (royaltyRecipient, royaltyPayment);\n    }\n\n    /// @dev returns true if the supplied interface id is supported\n    /// @param interfaceId_ the interface id\n    function supportsInterface(\n        bytes4 interfaceId_\n    ) public view virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId_ == type(IERC2981Upgradeable).interfaceId || super.supportsInterface(interfaceId_);\n    }\n}"
    }
  ]
}