{
  "Title": "M-32: Allowances is double spent in BBLeverage's and SGLLeverage's `sellCollateral()`",
  "Content": "# Issue M-32: Allowances is double spent in BBLeverage's and SGLLeverage's `sellCollateral()` \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/141 \n\n## Found by \nhyh\n## Summary\n\nBoth `sellCollateral()` functions remove allowance twice, before and after target debt size control.\n\nThis way up to double allowance is removed each time: exactly double amount when repay amount is at or below the actual debt, somewhat less than double amount when repay amount is bigger than actual debt.\n\n## Vulnerability Detail\n\nBoth `_allowedBorrow()` and `_repay()` operations spend the allowance from the caller. In the `sellCollateral()` case it should be done once, before the operation, since collateral removal is unconditional. It is spend twice, on collateral removal, and then on debt repayment now instead.\n\n## Impact\n\nBBLeverage's and SGLLeverage's `sellCollateral()` callers lose the approximately double amount of collateral allowance on each call. The operations with correctly set allowance amounts will be denied.\n\nThere are no prerequisites, so the probability is high. As the allowances are material and extra amounts can be directly exploitted via collateral removal (i.e. any extra allowance can be instantly turned to the same amount of collateral as long as borrower's account is healthy enough), so having allowances lost is somewhat lower/equivalent severity to loss of funds, i.e. have medium/high severity.\n\nLikelihood: High + Impact: Medium/High = Severity: High.\n\n## Code Snippet\n\nThe allowance is double written off in BBLeverage's and SGLLeverage's `sellCollateral()`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol#L126-L162\n\n```solidity\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n>>      _allowedBorrow(from, share);\n        _removeCollateral(from, address(this), share);\n\n        _SellCollateralMemoryData memory memoryData;\n\n        (, memoryData.obtainedShare) =\n            yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, share);\n        memoryData.leverageAmount = yieldBox.toAmount(collateralId, memoryData.obtainedShare, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), memoryData.leverageAmount, from, data\n        );\n        memoryData.shareOut = yieldBox.toShare(assetId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, memoryData.shareOut); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        memoryData.partOwed = userBorrowPart[from];\n        memoryData.amountOwed = totalBorrow.toElastic(memoryData.partOwed, true);\n        memoryData.shareOwed = yieldBox.toShare(assetId, memoryData.amountOwed, true);\n        if (memoryData.shareOwed <= memoryData.shareOut) {\n>>          _repay(from, from, memoryData.partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n>>          _repay(from, from, partOut);\n        }\n    }\n```\n\n\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLLeverage.sol#L106-L148\n\n```solidity\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        // Stack too deep fix\n        _SellCollateralCalldata memory calldata_;\n        {\n            calldata_.from = from;\n            calldata_.share = share;\n            calldata_.data = data;\n        }\n\n>>      _allowedBorrow(calldata_.from, calldata_.share);\n        _removeCollateral(calldata_.from, address(this), calldata_.share);\n\n        yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, calldata_.share);\n        uint256 leverageAmount = yieldBox.toAmount(collateralId, calldata_.share, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), leverageAmount, calldata_.from, calldata_.data\n        );\n        uint256 shareOut = yieldBox.toShare(assetId, amountOut, false);\n\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(assetId, address(this), address(this), 0, shareOut);\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        uint256 partOwed = userBorrowPart[calldata_.from];\n        uint256 amountOwed = totalBorrow.toElastic(partOwed, true);\n        uint256 shareOwed = yieldBox.toShare(assetId, amountOwed, true);\n        if (shareOwed <= shareOut) {\n>>          _repay(calldata_.from, calldata_.from, false, partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n>>          _repay(calldata_.from, calldata_.from, false, partOut);\n        }\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding a flag to `_repay()`, indicating that allowance spending was already recorded.\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLendingCommon.sol#L107-L122\n\n```diff\n-   function _repay(address from, address to, uint256 part) internal returns (uint256 amount) {\n+   function _repay(address from, address to, uint256 part, bool checkAllowance) internal returns (uint256 amount) {\n        if (part > userBorrowPart[to]) {\n            part = userBorrowPart[to];\n        }\n        if (part == 0) revert NothingToRepay();\n\n        // @dev check allowance\n-       if (msg.sender != from) {\n+       if (checkAllowance && msg.sender != from) {\n            uint256 partInAmount;\n            Rebase memory _totalBorrow = totalBorrow;\n            (_totalBorrow, partInAmount) = _totalBorrow.sub(part, false);\n            uint256 allowanceShare =\n                _computeAllowanceAmountInAsset(to, exchangeRate, partInAmount, _safeDecimals(asset));\n            if (allowanceShare == 0) revert AllowanceNotValid();\n            _allowedBorrow(from, allowanceShare);\n        }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLLendingCommon.sol#L91-L106\n\n```diff\n-   function _repay(address from, address to, bool skim, uint256 part) internal returns (uint256 amount) {\n+   function _repay(address from, address to, bool skim, uint256 part, bool checkAllowance) internal returns (uint256 amount) {\n        if (part > userBorrowPart[to]) {\n            part = userBorrowPart[to];\n        }\n        if (part == 0) revert NothingToRepay();\n\n-       if (msg.sender != from) {\n+       if (checkAllowance && msg.sender != from) {\n            uint256 partInAmount;\n            Rebase memory _totalBorrow = totalBorrow;\n            (_totalBorrow, partInAmount) = _totalBorrow.sub(part, false);\n\n            uint256 allowanceShare =\n                _computeAllowanceAmountInAsset(to, exchangeRate, partInAmount, _safeDecimals(asset));\n            if (allowanceShare == 0) revert AllowanceNotValid();\n            _allowedBorrow(from, allowanceShare);\n        }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol#L126-L162\n\n```diff\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        ...\n    {\n        ...\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(this), share);\n\n        ...\n\n        memoryData.partOwed = userBorrowPart[from];\n        memoryData.amountOwed = totalBorrow.toElastic(memoryData.partOwed, true);\n        memoryData.shareOwed = yieldBox.toShare(assetId, memoryData.amountOwed, true);\n        if (memoryData.shareOwed <= memoryData.shareOut) {\n-           _repay(from, from, memoryData.partOwed);\n+           _repay(from, from, memoryData.partOwed, false);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n-           _repay(from, from, partOut);\n+           _repay(from, from, partOut, false);\n        }\n    }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLLeverage.sol#L106-L148\n\n```diff\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        ...\n    {\n        ...\n\n        _allowedBorrow(calldata_.from, calldata_.share);\n        _removeCollateral(calldata_.from, address(this), calldata_.share);\n\n        ...\n\n        uint256 partOwed = userBorrowPart[calldata_.from];\n        uint256 amountOwed = totalBorrow.toElastic(partOwed, true);\n        uint256 shareOwed = yieldBox.toShare(assetId, amountOwed, true);\n        if (shareOwed <= shareOut) {\n-           _repay(calldata_.from, calldata_.from, false, partOwed);\n+           _repay(calldata_.from, calldata_.from, false, partOwed, false);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n-           _repay(calldata_.from, calldata_.from, false, partOut);\n+           _repay(calldata_.from, calldata_.from, false, partOut, false);\n        }\n    }\n```\n\nAll other `_repay()` calls should by default use `checkAllowance == true`.\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**WangAudit** commented:\n> I believe it's low; don't think lost allowance is somewhat equivalent to loss of funds and I don't think how it actually harms anyone; plus can be mitigated by setting uint max allowance\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/368.\n\n**dmitriia**\n\nEscalate\nAllowance double spending without material prerequisites implies fund loss with a high probability. Allowance mechanics in question gives an ability to extract the collateral, i.e. is a direct equivalent of funds. On these grounds the issue should have high severity as described.\n\n**sherlock-admin2**\n\n> Escalate\n> Allowance double spending without material prerequisites implies fund loss with a high probability. Allowance mechanics in question gives an ability to extract the collateral, i.e. is a direct equivalent of funds. On these grounds the issue should have high severity as described.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\n@maarcweiss Could you let us know why you believe this issue should be medium severity?\n\n**cvetanovv**\n\nI agree with @dmitriia escalation. We can upgrade it to High.\n\n**huuducsc**\n\nI don't think this issue meets the criteria for High severity according to Sherlock's criteria. \n<img width=\"738\" alt=\"Screenshot 2024-04-12 at 04 57 16\" src=\"https://github.com/sherlock-audit/2024-02-tapioca-judging/assets/80202717/375e5904-e646-478d-aa34-956c0e96d35c\">\n\nIt involves the allowance of `calldata_.from` for the sender being spent twice, which doesn't directly result in a loss of funds. Instead, it causes the function to revert if the user approves the exact allowance they want to extract in correct behavior. While users may need to approve double allowance for the sender, which is risky, but it doesn't qualify as high severity since the sender is trusted by the user. I believe that the funds of users cannot be exploited without any external conditions, and the report didn't mention any attack path that could cause a loss.\n\n**maarcweiss**\n\nI agree with @huuducsc  on this one, losing allowance and/or reverting on a correct one is important though does not apply as direct loss of funds. I think it should stay as a med. \n\n**cvetanovv**\n\nI will agree with @maarcweiss and @huuducsc comments and reject the escalation and this issue will remain Medium.\n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [dmitriia](https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/141/#issuecomment-2034569524): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBLendingCommon} from \"./BBLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLeverage is BBLendingCommon {\n    using RebaseLibrary for Rebase;\n    using SafeApprove for address;\n    using BoringERC20 for IERC20;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error LeverageExecutorNotValid();\n    error CollateralShareNotValid();\n\n    struct _BuyCollateralCalldata {\n        address from;\n        uint256 borrowAmount;\n        uint256 supplyAmount;\n        bytes data;\n    }\n\n    struct _BuyCollateralMemoryData {\n        uint256 supplyShareToAmount;\n        uint256 borrowShareToAmount;\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n\n        // Stack too deep fix\n        _BuyCollateralCalldata memory calldata_;\n        _BuyCollateralMemoryData memory memoryData;\n        {\n            calldata_.from = from;\n            calldata_.borrowAmount = borrowAmount;\n            calldata_.supplyAmount = supplyAmount;\n            calldata_.data = data;\n        }\n\n        {\n            uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n            if (supplyShare > 0) {\n                (memoryData.supplyShareToAmount,) =\n                    yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n            }\n        }\n\n        {\n            (, uint256 borrowShare) = _borrow(\n                calldata_.from,\n                address(this),\n                calldata_.borrowAmount,\n                _computeVariableOpeningFee(calldata_.borrowAmount)\n            );\n            (memoryData.borrowShareToAmount,) =\n                yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        }\n        {\n            amountOut = leverageExecutor.getCollateral(\n                collateralId,\n                address(asset),\n                address(collateral),\n                memoryData.supplyShareToAmount + memoryData.borrowShareToAmount,\n                calldata_.from,\n                calldata_.data\n            );\n        }\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        _allowedBorrow(calldata_.from, collateralShare);\n        _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n\n    struct _SellCollateralMemoryData {\n        uint256 obtainedShare;\n        uint256 leverageAmount;\n        uint256 shareOut;\n        uint256 partOwed;\n        uint256 amountOwed;\n        uint256 shareOwed;\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(this), share);\n\n        _SellCollateralMemoryData memory memoryData;\n\n        (, memoryData.obtainedShare) =\n            yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, share);\n        memoryData.leverageAmount = yieldBox.toAmount(collateralId, memoryData.obtainedShare, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), memoryData.leverageAmount, from, data\n        );\n        memoryData.shareOut = yieldBox.toShare(assetId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, memoryData.shareOut); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        memoryData.partOwed = userBorrowPart[from];\n        memoryData.amountOwed = totalBorrow.toElastic(memoryData.partOwed, true);\n        memoryData.shareOwed = yieldBox.toShare(assetId, memoryData.amountOwed, true);\n        if (memoryData.shareOwed <= memoryData.shareOut) {\n            _repay(from, from, memoryData.partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, partOut);\n        }\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/SGLLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20, IERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\n\n// Tapioca\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {SGLLendingCommon} from \"./SGLLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLLeverage is SGLLendingCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n    using SafeApprove for address;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error LeverageExecutorNotValid();\n    error CollateralShareNotValid();\n\n    struct _BuyCollateralCalldata {\n        address from;\n        uint256 borrowAmount;\n        uint256 supplyAmount;\n        bytes data;\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        // Stack too deep fix\n        _BuyCollateralCalldata memory calldata_;\n        {\n            calldata_.from = from;\n            calldata_.borrowAmount = borrowAmount;\n            calldata_.supplyAmount = supplyAmount;\n            calldata_.data = data;\n        }\n\n        // Let this fail first to save gas:\n        uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n        uint256 supplyShareToAmount;\n        if (supplyShare > 0) {\n            (supplyShareToAmount,) =\n                yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n        }\n        (, uint256 borrowShare) = _borrow(calldata_.from, address(this), calldata_.borrowAmount);\n\n        (uint256 borrowShareToAmount,) =\n            yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        amountOut = leverageExecutor.getCollateral(\n            collateralId,\n            address(asset),\n            address(collateral),\n            supplyShareToAmount + borrowShareToAmount,\n            calldata_.from,\n            calldata_.data\n        );\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        _allowedBorrow(calldata_.from, collateralShare);\n        _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n\n    struct _SellCollateralCalldata {\n        address from;\n        uint256 share;\n        bytes data;\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        // Stack too deep fix\n        _SellCollateralCalldata memory calldata_;\n        {\n            calldata_.from = from;\n            calldata_.share = share;\n            calldata_.data = data;\n        }\n\n        _allowedBorrow(calldata_.from, calldata_.share);\n        _removeCollateral(calldata_.from, address(this), calldata_.share);\n\n        yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, calldata_.share);\n        uint256 leverageAmount = yieldBox.toAmount(collateralId, calldata_.share, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), leverageAmount, calldata_.from, calldata_.data\n        );\n        uint256 shareOut = yieldBox.toShare(assetId, amountOut, false);\n\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(assetId, address(this), address(this), 0, shareOut);\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        uint256 partOwed = userBorrowPart[calldata_.from];\n        uint256 amountOwed = totalBorrow.toElastic(partOwed, true);\n        uint256 shareOwed = yieldBox.toShare(assetId, amountOwed, true);\n        if (shareOwed <= shareOut) {\n            _repay(calldata_.from, calldata_.from, false, partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(calldata_.from, calldata_.from, false, partOut);\n        }\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLendingCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {IUsdo} from \"tapioca-periph/interfaces/oft/IUsdo.sol\";\nimport {BBCommon} from \"./BBCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLendingCommon is BBCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error BorrowCapReached();\n    error OracleCallFailed();\n    error NothingToRepay();\n    error RepayAmountNotValid();\n    error AllowanceNotValid();\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _addCollateral(address from, address to, bool skim, uint256 amount, uint256 share) internal {\n        if (share == 0) {\n            share = yieldBox.toShare(collateralId, amount, false);\n        }\n        userCollateralShare[to] += share;\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        totalCollateralShare = oldTotalCollateralShare + share;\n        _addTokens(from, collateralId, share, oldTotalCollateralShare, skim);\n        emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n    }\n\n    /// @dev Concrete implementation of `removeCollateral`.\n    function _removeCollateral(address from, address to, uint256 share) internal {\n        userCollateralShare[from] -= share;\n        totalCollateralShare -= share;\n        emit LogRemoveCollateral(from, to, share);\n        yieldBox.transfer(address(this), to, collateralId, share);\n    }\n\n    /// @dev Concrete implementation of `borrow`.\n    function _borrow(address from, address to, uint256 amount, uint256 feeAmount)\n        internal\n        returns (uint256 part, uint256 share)\n    {\n        (totalBorrow, part) = totalBorrow.add(amount + feeAmount, true);\n\n        if (totalBorrowCap > 0) {\n            if (totalBorrow.elastic > totalBorrowCap) revert BorrowCapReached();\n        }\n\n        userBorrowPart[from] += part;\n        emit LogBorrow(from, to, amount, feeAmount, part);\n\n        //mint USDO\n        IUsdo(address(asset)).mint(address(this), amount);\n\n        //deposit borrowed amount to user\n        share = _depositAmountToYb(asset, to, assetId, amount);\n    }\n\n    function _computeVariableOpeningFee(uint256 amount) internal returns (uint256) {\n        if (amount == 0) return 0;\n\n        //get asset <> USDC price ( USDO <> USDC )\n        (bool updated, uint256 _exchangeRate) = assetOracle.get(oracleData);\n        if (!updated) revert OracleCallFailed();\n\n        if (_exchangeRate >= minMintFeeStart) {\n            return (amount * minMintFee) / FEE_PRECISION;\n        }\n        if (_exchangeRate <= maxMintFeeStart) {\n            return (amount * maxMintFee) / FEE_PRECISION;\n        }\n\n        uint256 fee = maxMintFee\n            - (((_exchangeRate - maxMintFeeStart) * (maxMintFee - minMintFee)) / (minMintFeeStart - maxMintFeeStart));\n\n        if (fee > maxMintFee) return (amount * maxMintFee) / FEE_PRECISION;\n        if (fee < minMintFee) return (amount * minMintFee) / FEE_PRECISION;\n\n        if (fee > 0) {\n            return (amount * fee) / FEE_PRECISION;\n        }\n        return 0;\n    }\n\n    /// @dev Concrete implementation of `repay`.\n    function _repay(address from, address to, uint256 part) internal returns (uint256 amount) {\n        if (part > userBorrowPart[to]) {\n            part = userBorrowPart[to];\n        }\n        if (part == 0) revert NothingToRepay();\n\n        // @dev check allowance\n        if (msg.sender != from) {\n            uint256 partInAmount;\n            Rebase memory _totalBorrow = totalBorrow;\n            (_totalBorrow, partInAmount) = _totalBorrow.sub(part, false);\n            uint256 allowanceShare =\n                _computeAllowanceAmountInAsset(to, exchangeRate, partInAmount, _safeDecimals(asset));\n            if (allowanceShare == 0) revert AllowanceNotValid();\n            _allowedBorrow(from, allowanceShare);\n        }\n\n        // @dev sub `part` of totalBorrow\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\n        userBorrowPart[to] -= part;\n\n        // @dev amount includes the opening & accrued fees\n        yieldBox.withdraw(assetId, from, address(this), amount, 0);\n\n        // @dev burn USDO\n        IUsdo(address(asset)).burn(address(this), amount);\n\n        emit LogRepay(from, to, amount, part);\n    }\n\n    function _safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567)); //decimals() selector\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/SGLLendingCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20, IERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {SGLCommon} from \"./SGLCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLLendingCommon is SGLCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n    using SafeCast for uint256;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error BorrowCapReached();\n    error NothingToRepay();\n    error AllowanceNotValid();\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    /// @dev Concrete implementation of `addCollateral`.\n    function _addCollateral(address from, address to, bool skim, uint256 amount, uint256 share) internal {\n        if (share == 0) {\n            share = yieldBox.toShare(collateralId, amount, false);\n        }\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        userCollateralShare[to] += share;\n        totalCollateralShare = oldTotalCollateralShare + share;\n\n        _addTokens(from, to, collateralId, share, oldTotalCollateralShare, skim);\n\n        emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n    }\n\n    /// @dev Concrete implementation of `removeCollateral`.\n    function _removeCollateral(address from, address to, uint256 share) internal {\n        userCollateralShare[from] -= share;\n        totalCollateralShare -= share;\n        emit LogRemoveCollateral(from, to, share);\n        yieldBox.transfer(address(this), to, collateralId, share);\n    }\n\n    /// @dev Concrete implementation of `borrow`.\n    function _borrow(address from, address to, uint256 amount) internal returns (uint256 part, uint256 share) {\n        share = yieldBox.toShare(assetId, amount, true);\n        Rebase memory _totalAsset = totalAsset;\n        if (_totalAsset.base < 1000) revert MinLimit();\n\n        uint256 fullAssetAmountBefore = yieldBox.toAmount(assetId, _totalAsset.elastic, false) + totalBorrow.elastic;\n\n        _totalAsset.elastic -= share.toUint128();\n\n        uint256 feeAmount = (amount * borrowOpeningFee) / FEE_PRECISION; // A flat % fee is charged for any borrow\n\n        (totalBorrow, part) = totalBorrow.add(amount + feeAmount, true);\n        if (totalBorrowCap != 0) {\n            if (totalBorrow.elastic > totalBorrowCap) revert BorrowCapReached();\n        }\n        userBorrowPart[from] += part;\n        emit LogBorrow(from, to, amount, feeAmount, part);\n\n        if (feeAmount > 0) {\n            uint256 feeFraction = (feeAmount * _totalAsset.base) / fullAssetAmountBefore;\n            _totalAsset.base += feeFraction.toUint128();\n            balanceOf[address(penrose)] += feeFraction;\n        }\n\n        totalAsset = _totalAsset;\n\n        yieldBox.transfer(address(this), to, assetId, share);\n    }\n\n    /// @dev Concrete implementation of `repay`.\n    function _repay(address from, address to, bool skim, uint256 part) internal returns (uint256 amount) {\n        if (part > userBorrowPart[to]) {\n            part = userBorrowPart[to];\n        }\n        if (part == 0) revert NothingToRepay();\n\n        if (msg.sender != from) {\n            uint256 partInAmount;\n            Rebase memory _totalBorrow = totalBorrow;\n            (_totalBorrow, partInAmount) = _totalBorrow.sub(part, false);\n\n            uint256 allowanceShare =\n                _computeAllowanceAmountInAsset(to, exchangeRate, partInAmount, _safeDecimals(asset));\n            if (allowanceShare == 0) revert AllowanceNotValid();\n            _allowedBorrow(from, allowanceShare);\n        }\n        (totalBorrow, amount) = totalBorrow.sub(part, false);\n\n        userBorrowPart[to] -= part;\n\n        uint256 share = yieldBox.toShare(assetId, amount, true);\n        uint128 totalShare = totalAsset.elastic;\n        _addTokens(from, to, assetId, share, uint256(totalShare), skim);\n        totalAsset.elastic = totalShare + share.toUint128();\n\n        emit LogRepay(skim ? address(yieldBox) : from, to, amount, part);\n    }\n\n    function _safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567)); //decimals() selector\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\n// Tapioca\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {BBLendingCommon} from \"./BBLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract BBLeverage is BBLendingCommon {\n    using RebaseLibrary for Rebase;\n    using SafeApprove for address;\n    using BoringERC20 for IERC20;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error LeverageExecutorNotValid();\n    error CollateralShareNotValid();\n\n    struct _BuyCollateralCalldata {\n        address from;\n        uint256 borrowAmount;\n        uint256 supplyAmount;\n        bytes data;\n    }\n\n    struct _BuyCollateralMemoryData {\n        uint256 supplyShareToAmount;\n        uint256 borrowShareToAmount;\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n\n        // Stack too deep fix\n        _BuyCollateralCalldata memory calldata_;\n        _BuyCollateralMemoryData memory memoryData;\n        {\n            calldata_.from = from;\n            calldata_.borrowAmount = borrowAmount;\n            calldata_.supplyAmount = supplyAmount;\n            calldata_.data = data;\n        }\n\n        {\n            uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n            if (supplyShare > 0) {\n                (memoryData.supplyShareToAmount,) =\n                    yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n            }\n        }\n\n        {\n            (, uint256 borrowShare) = _borrow(\n                calldata_.from,\n                address(this),\n                calldata_.borrowAmount,\n                _computeVariableOpeningFee(calldata_.borrowAmount)\n            );\n            (memoryData.borrowShareToAmount,) =\n                yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        }\n        {\n            amountOut = leverageExecutor.getCollateral(\n                collateralId,\n                address(asset),\n                address(collateral),\n                memoryData.supplyShareToAmount + memoryData.borrowShareToAmount,\n                calldata_.from,\n                calldata_.data\n            );\n        }\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        _allowedBorrow(calldata_.from, collateralShare);\n        _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n\n    struct _SellCollateralMemoryData {\n        uint256 obtainedShare;\n        uint256 leverageAmount;\n        uint256 shareOut;\n        uint256 partOwed;\n        uint256 amountOwed;\n        uint256 shareOwed;\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual asset amount received in the sale\n    function sellCollateral(address from, uint256 share, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageSell)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        _allowedBorrow(from, share);\n        _removeCollateral(from, address(this), share);\n\n        _SellCollateralMemoryData memory memoryData;\n\n        (, memoryData.obtainedShare) =\n            yieldBox.withdraw(collateralId, address(this), address(leverageExecutor), 0, share);\n        memoryData.leverageAmount = yieldBox.toAmount(collateralId, memoryData.obtainedShare, false);\n        amountOut = leverageExecutor.getAsset(\n            assetId, address(collateral), address(asset), memoryData.leverageAmount, from, data\n        );\n        memoryData.shareOut = yieldBox.toShare(assetId, amountOut, false);\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, memoryData.shareOut); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        memoryData.partOwed = userBorrowPart[from];\n        memoryData.amountOwed = totalBorrow.toElastic(memoryData.partOwed, true);\n        memoryData.shareOwed = yieldBox.toShare(assetId, memoryData.amountOwed, true);\n        if (memoryData.shareOwed <= memoryData.shareOut) {\n            _repay(from, from, memoryData.partOwed);\n        } else {\n            //repay as much as we can\n            uint256 partOut = totalBorrow.toBase(amountOut, false);\n            _repay(from, from, partOut);\n        }\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/SGLLeverage.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20, IERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\n\n// Tapioca\nimport {SafeApprove} from \"../../libraries/SafeApprove.sol\";\nimport {SGLLendingCommon} from \"./SGLLendingCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLLeverage is SGLLendingCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n    using SafeApprove for address;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error LeverageExecutorNotValid();\n    error CollateralShareNotValid();\n\n    struct _BuyCollateralCalldata {\n        address from;\n        uint256 borrowAmount;\n        uint256 supplyAmount;\n        bytes data;\n    }\n\n    /// @notice Lever up: Borrow more and buy collateral with it.\n    /// @param from The user who buys\n    /// @param borrowAmount Amount of extra asset borrowed\n    /// @param supplyAmount Amount of asset supplied (down payment)\n    /// @param data LeverageExecutor data\n    /// @return amountOut Actual collateral amount purchased\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n        solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n    {\n        if (address(leverageExecutor) == address(0)) {\n            revert LeverageExecutorNotValid();\n        }\n        // Stack too deep fix\n        _BuyCollateralCalldata memory calldata_;\n        {\n            calldata_.from = from;\n            calldata_.borrowAmount = borrowAmount;\n            calldata_.supplyAmount = supplyAmount;\n            calldata_.data = data;\n        }\n\n        // Let this fail first to save gas:\n        uint256 supplyShare = yieldBox.toShare(assetId, calldata_.supplyAmount, true);\n        uint256 supplyShareToAmount;\n        if (supplyShare > 0) {\n            (supplyShareToAmount,) =\n                yieldBox.withdraw(assetId, calldata_.from, address(leverageExecutor), 0, supplyShare);\n        }\n        (, uint256 borrowShare) = _borrow(calldata_.from, address(this), calldata_.borrowAmount);\n\n        (uint256 borrowShareToAmount,) =\n            yieldBox.withdraw(assetId, address(this), address(leverageExecutor), 0, borrowShare);\n        amountOut = leverageExecutor.getCollateral(\n            collateralId,\n            address(asset),\n            address(collateral),\n            supplyShareToAmount + borrowShareToAmount,\n            calldata_.from,\n            calldata_.data\n        );\n        uint256 collateralShare = yieldBox.toShare(collateralId, amountOut, false);\n        if (collateralShare == 0) revert CollateralShareNotValid();\n        address(asset).safeApprove(address(yieldBox), type(uint256).max);\n        yieldBox.depositAsset(collateralId, address(this), address(this), 0, collateralShare); // TODO Check for rounding attack?\n        address(asset).safeApprove(address(yieldBox), 0);\n\n        _allowedBorrow(calldata_.from, collateralShare);\n        _addCollateral(calldata_.from, calldata_.from, false, 0, collateralShare);\n    }\n\n    struct _SellCollateralCalldata {\n        address from;\n        uint256 share;\n        bytes data;\n    }\n\n    /// @notice Lever down: Sell collateral to repay debt; excess goes to YB\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param data LeverageExe"
    }
  ]
}