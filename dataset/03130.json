{
  "Title": "Semantic overload",
  "Content": "The [`ScannerRegistryEnable` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L9) implements the functionality for enabling and disabling scanners, but it also [extends the functionality of the registration process](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L36).\n\n\nWhen registering a new scanner, the contract [checks if the minimum stake for the scanner type is greater than zero](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/scanners/ScannerRegistryEnable.sol#L37). This value is changed by the admin in the [`FortaStaking` contract](https://github.com/forta-protocol/forta-token/blob/92d7a7ddd6672a7530a4bfc532d0d697e7f12744/contracts/components/staking/FortaStaking.sol#L504) and it is meant to define a threshold value instead of an enabled status.\n\n\nThis is known as [Semantic Overload](https://forum.openzeppelin.com/t/watch-out-for-semantic-overloading/1088). If the multiple meanings of the variables and states are not totally clear when making changes to the code, it can introduce severe vulnerabilities. We strongly discourage its usage if possible.\n\n\nConsider explicitly setting independent flags to represent the state of the scanners instead of using the same variable for different purposes.\n\n\n***Update:** Fixed on [commit `1869a5ab8461c106e283a2d23e857d8435a8587b` in pull request 78](https://github.com/forta-protocol/forta-token/pull/78/commits/1869a5ab8461c106e283a2d23e857d8435a8587b). Now, the [scanner registration process checks](https://github.com/forta-protocol/forta-token/blob/27f795ef4748d460462f564427f17deebbada21a/contracts/components/scanners/ScannerRegistryCore.sol#L33) if a certain chain is activated by using an explicit flag.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/components/scanners/ScannerRegistryEnable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\n\nimport \"./ScannerRegistryManaged.sol\";\nimport \"../utils/StakeAware.sol\";\n\nabstract contract ScannerRegistryEnable is ScannerRegistryManaged, StakeAwareUpgradeable {\n    using BitMaps for BitMaps.BitMap;\n\n    enum Permission {\n        ADMIN,\n        SELF,\n        OWNER,\n        MANAGER,\n        length\n    }\n\n    mapping(uint256 => BitMaps.BitMap) private _disabled;\n\n    event ScannerEnabled(uint256 indexed scannerId, bool indexed enabled, Permission permission, bool value);\n\n    /**\n    * Check if scanner is enabled\n    * @param scannerId token Id\n    * @return true if the scanner is registered, has not been disabled, and is staked over minimum value.\n    * Returns false if otherwise\n    */\n    function isEnabled(uint256 scannerId) public view virtual returns (bool) {\n        return isRegistered(scannerId) &&\n            _getDisableFlags(scannerId) == 0 &&\n            _isStakedOverMin(SCANNER_SUBJECT, scannerId); \n    }\n\n    function register(address owner, uint256 chainId, string calldata metadata) virtual override public {\n        require(_getMinStake(SCANNER_SUBJECT) > 0, \"ScannerRegistryEnable: public registration available if staking activated\");\n        super.register(owner, chainId, metadata);\n    }\n\n    /**\n     * @dev Enable/Disable scaner\n     */\n    function enableScanner(uint256 scannerId, Permission permission) public virtual {\n        require(_isStakedOverMin(SCANNER_SUBJECT, scannerId), \"ScannerRegistryEnable: scanner staked under minimum\");\n        require(_hasPermission(scannerId, permission), \"ScannerRegistryEnable: invalid permission\");\n        _enable(scannerId, permission, true);\n    }\n\n    function disableScanner(uint256 scannerId, Permission permission) public virtual {\n        require(_hasPermission(scannerId, permission), \"ScannerRegistryEnable: invalid permission\");\n        _enable(scannerId, permission, false);\n    }\n\n    function _hasPermission(uint256 scannerId, Permission permission) internal view returns (bool) {\n        if (permission == Permission.ADMIN)   { return hasRole(SCANNER_ADMIN_ROLE, _msgSender()); }\n        if (permission == Permission.SELF)    { return uint256(uint160(_msgSender())) == scannerId; }\n        if (permission == Permission.OWNER)   { return _msgSender() == ownerOf(scannerId); }\n        if (permission == Permission.MANAGER) { return isManager(scannerId, _msgSender()); }\n        return false;\n    }\n\n    function _enable(uint256 scannerId, Permission permission, bool enable) internal {\n        _beforeScannerEnable(scannerId, permission, enable);\n        _scannerEnable(scannerId, permission, enable);\n        _afterScannerEnable(scannerId, permission, enable);\n    }\n\n    /**\n     * Get the disabled flags for an agentId. Permission (uint8) is used for indexing, so we don't\n     * need to loop. \n     * If not disabled, all flags will be 0\n     */\n    function _getDisableFlags(uint256 scannerId) internal view returns (uint256) {\n        return _disabled[scannerId]._data[0];\n    }\n\n    /**\n     * Hook: Scanner is enabled/disabled\n     */\n    function _beforeScannerEnable(uint256 scannerId, Permission permission, bool value) internal virtual {\n    }\n\n    function _scannerEnable(uint256 scannerId, Permission permission, bool value) internal virtual {\n        _disabled[scannerId].setTo(uint8(permission), !value);\n        emit ScannerEnabled(scannerId, isEnabled(scannerId), permission, value);\n    }\n\n    function _afterScannerEnable(uint256 scannerId, Permission permission, bool value) internal virtual {\n        _emitHook(abi.encodeWithSignature(\"hook_afterScannerEnable(uint256)\", scannerId));\n    }\n\n    function _msgSender() internal view virtual override(ContextUpgradeable, ScannerRegistryCore) returns (address sender) {\n        return super._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ContextUpgradeable, ScannerRegistryCore) returns (bytes calldata) {\n        return super._msgData();\n    }\n\n    uint256[49] private __gap;\n}"
    },
    {
      "filename": "contracts/components/scanners/ScannerRegistryEnable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\n\nimport \"./ScannerRegistryManaged.sol\";\nimport \"../utils/StakeAware.sol\";\n\nabstract contract ScannerRegistryEnable is ScannerRegistryManaged, StakeAwareUpgradeable {\n    using BitMaps for BitMaps.BitMap;\n\n    enum Permission {\n        ADMIN,\n        SELF,\n        OWNER,\n        MANAGER,\n        length\n    }\n\n    mapping(uint256 => BitMaps.BitMap) private _disabled;\n\n    event ScannerEnabled(uint256 indexed scannerId, bool indexed enabled, Permission permission, bool value);\n\n    /**\n    * Check if scanner is enabled\n    * @param scannerId token Id\n    * @return true if the scanner is registered, has not been disabled, and is staked over minimum value.\n    * Returns false if otherwise\n    */\n    function isEnabled(uint256 scannerId) public view virtual returns (bool) {\n        return isRegistered(scannerId) &&\n            _getDisableFlags(scannerId) == 0 &&\n            _isStakedOverMin(SCANNER_SUBJECT, scannerId); \n    }\n\n    function register(address owner, uint256 chainId, string calldata metadata) virtual override public {\n        require(_getMinStake(SCANNER_SUBJECT) > 0, \"ScannerRegistryEnable: public registration available if staking activated\");\n        super.register(owner, chainId, metadata);\n    }\n\n    /**\n     * @dev Enable/Disable scaner\n     */\n    function enableScanner(uint256 scannerId, Permission permission) public virtual {\n        require(_isStakedOverMin(SCANNER_SUBJECT, scannerId), \"ScannerRegistryEnable: scanner staked under minimum\");\n        require(_hasPermission(scannerId, permission), \"ScannerRegistryEnable: invalid permission\");\n        _enable(scannerId, permission, true);\n    }\n\n    function disableScanner(uint256 scannerId, Permission permission) public virtual {\n        require(_hasPermission(scannerId, permission), \"ScannerRegistryEnable: invalid permission\");\n        _enable(scannerId, permission, false);\n    }\n\n    function _hasPermission(uint256 scannerId, Permission permission) internal view returns (bool) {\n        if (permission == Permission.ADMIN)   { return hasRole(SCANNER_ADMIN_ROLE, _msgSender()); }\n        if (permission == Permission.SELF)    { return uint256(uint160(_msgSender())) == scannerId; }\n        if (permission == Permission.OWNER)   { return _msgSender() == ownerOf(scannerId); }\n        if (permission == Permission.MANAGER) { return isManager(scannerId, _msgSender()); }\n        return false;\n    }\n\n    function _enable(uint256 scannerId, Permission permission, bool enable) internal {\n        _beforeScannerEnable(scannerId, permission, enable);\n        _scannerEnable(scannerId, permission, enable);\n        _afterScannerEnable(scannerId, permission, enable);\n    }\n\n    /**\n     * Get the disabled flags for an agentId. Permission (uint8) is used for indexing, so we don't\n     * need to loop. \n     * If not disabled, all flags will be 0\n     */\n    function _getDisableFlags(uint256 scannerId) internal view returns (uint256) {\n        return _disabled[scannerId]._data[0];\n    }\n\n    /**\n     * Hook: Scanner is enabled/disabled\n     */\n    function _beforeScannerEnable(uint256 scannerId, Permission permission, bool value) internal virtual {\n    }\n\n    function _scannerEnable(uint256 scannerId, Permission permission, bool value) internal virtual {\n        _disabled[scannerId].setTo(uint8(permission), !value);\n        emit ScannerEnabled(scannerId, isEnabled(scannerId), permission, value);\n    }\n\n    function _afterScannerEnable(uint256 scannerId, Permission permission, bool value) internal virtual {\n        _emitHook(abi.encodeWithSignature(\"hook_afterScannerEnable(uint256)\", scannerId));\n    }\n\n    function _msgSender() internal view virtual override(ContextUpgradeable, ScannerRegistryCore) returns (address sender) {\n        return super._msgSender();\n    }\n\n    function _msgData() internal view virtual override(ContextUpgradeable, ScannerRegistryCore) returns (bytes calldata) {\n        return super._msgData();\n    }\n\n    uint256[49] private __gap;\n}"
    }
  ]
}