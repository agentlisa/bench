{
  "Title": "M-3: LibUbiquityPool::mintDollar/redeemDollar reliance on arbitrarily short TWAP oracle may be inefficient for preventing depeg",
  "Content": "# Issue M-3: LibUbiquityPool::mintDollar/redeemDollar reliance on arbitrarily short TWAP oracle may be inefficient for preventing depeg \n\nSource: https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/20 \n\n## Found by \n0xLogos, Arz, Coinstein, Krace, b0g0, cducrest-brainbot, cergyk, evmboi32, infect3d, nirohgo, rvierdiiev, the-first-elder\n## Summary\nThe ubiquity pool used for minting/burning uAD relies on a twap oracle which can be outdated because the underlying metapool is not updated when calling the ubiquity pool. This would mean that minting/burning will be enabled based on an outdated state when it should have been reverted and inversely \n\n## Vulnerability Detail\nWe can see that `LibTWAPOracle::consult` computes the average price for uAD on the metapool vs 3CRV. However since it uses the duration since last update as a TWAP duration, it will always get only the value of price at the previous block it was updated at;\nhttps://github.com/sherlock-audit/2023-12-ubiquity/blob/main/ubiquity-dollar/packages/contracts/src/dollar/libraries/LibTWAPOracle.sol#L80\n\nLet's consider the following example:\n\nmetapool initial state at block N:\nreserveA: 1000\nreserveB: 1000\n\nmetapool state at block N+1 (+12 seconds):\nreserveA: 1500\nreserveB: 500\n\nif we have executed the update at each of these blocks, this means that if we consult the twap at block N+2,\nwe have:\nts.priceCumulativeLast: `[A, B]` \npriceCumulative: `[A+1500*12, B+500*12]` (reserve * time_elapsed); \nblockTimestamp - ts.pricesBlockTimestampLast = 12;\n\nwhich means that when we call `get_twap_balances` the values returned are simply [1500, 500], which are the values of the previous block.\n\n## Impact\nA malicious user which can control two successive blocks (it is relatively feasible since the merge), can put the twap in any state for the next block:\n- Can Dos any minting/burning in the block after the ones he controls\n- Can unblock minting/burning for the next block, and depeg uAD further  \n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUse a fixed duration for the TWAP:\n```solidity\nuint256[2] memory twapBalances = IMetaPool(ts.pool)\n    .get_twap_balances(\n        ts.priceCumulativeLast,\n        priceCumulative,\n        15 MINUTES\n    );\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**auditsea** commented:\n> The issue describes about TWAP can be manipulated because `update` function can be called anytime and by anyone, thus TWAP period can be as short as 1 block. It seems like a valid issue but after caeful consideration, it's noticed that the TWAP issue does not come from its period but the logic itself is incorrect, thus marking this as Invalid\n\n\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**auditsea** commented:\n> The issue describes about TWAP can be manipulated because `update` function can be called anytime and by anyone, thus TWAP period can be as short as 1 block. It seems like a valid issue but after caeful consideration, it's noticed that the TWAP issue does not come from its period but the logic itself is incorrect, thus marking this as Invalid\n\n\n\n**gitcoindev**\n\n> 1 comment(s) were left on this issue during the judging contest.\n> \n> **auditsea** commented:\n> \n> > The issue describes about TWAP can be manipulated because `update` function can be called anytime and by anyone, thus TWAP period can be as short as 1 block. It seems like a valid issue but after caeful consideration, it's noticed that the TWAP issue does not come from its period but the logic itself is incorrect, thus marking this as Invalid\n\nAlso invalid then and 'Sponsor Disputed' label should be added? @rndquu @pavlovcik @molecula451 \n\n**pavlovcik**\n\nIt probably makes more sense to ask @auditsea (not sure if this is the corresponding GitHub handle.)\n\n**rndquu**\n\nYes, it is possible (especially in the early Dollar token stage when market activity is low) to skew the curve's TWAP value since our TWAP (in some cases) may simply take the latest block price thus TWAP can be manipulated with low effort.\n\nThis is not critical (i.e. medium severity seems to be valid) since TWAP's price is used only in `require()` statements on mint and redeem operations but must be fixed.\n\nNot sure what's the best possible solution but the following similar issues are worth to check:\n- https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/138\n- https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/175\n\n\n\n**gitcoindev**\n\n@rndquu just to double check, the solution is to set a constant time window for the TWAP price. \n\nA question to Sherlock: should the window be set to 15, 30 min or any other value?\n\n**pavlovcik**\n\nIn my experience with software development, anything time based is better implemented to be event based. Although unfortunately I'm not sure what events would make a great substitute in this case. What if we checked that they aren't consecutive blocks?\n\n**rndquu**\n\n> @rndquu just to double check, the solution is to set a constant time window for the TWAP price.\n> \n> A question to Sherlock: should the window be set to 15, 30 min or any other value?\n\n I think the solution is to use the latest curve's metapool with built-in TWAP oracle and adjustable time window as described [here](https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/201). \n \n > the solution is to set a constant time window for the TWAP price\n \n You're right, the solution is to increase it to 15 or 30 minutes.\n\n**rndquu**\n\nSince there is no direct loss of funds the \"high\" severity doesn't seem to be correct.\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/ubiquity/ubiquity-dollar/pull/893.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/138",
  "Code": [
    {
      "filename": "ubiquity-dollar/packages/contracts/src/dollar/libraries/LibTWAPOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {IMetaPool} from \"../../dollar/interfaces/IMetaPool.sol\";\nimport {LibAppStorage} from \"./LibAppStorage.sol\";\n\n/**\n * @notice Library used for Curve TWAP oracle in the Dollar MetaPool\n */\nlibrary LibTWAPOracle {\n    /// @notice Struct used as a storage for this library\n    struct TWAPOracleStorage {\n        address pool; // curve metapool address : Ubiquity Dollar <=> 3 Pool\n        // address token0; will always be address(this)\n        address token1; // curve 3pool LP token address\n        uint256 price0Average;\n        uint256 price1Average;\n        uint256 pricesBlockTimestampLast;\n        uint256[2] priceCumulativeLast;\n    }\n\n    /// @notice Storage slot used to store data for this library\n    bytes32 constant TWAP_ORACLE_STORAGE_POSITION =\n        bytes32(uint256(keccak256(\"diamond.standard.twap.oracle.storage\")) - 1);\n\n    /**\n     * @notice Sets Curve MetaPool to be used as a TWAP oracle\n     * @param _pool Curve MetaPool address, pool for 2 tokens [Dollar, 3CRV LP]\n     * @param _curve3CRVToken1 Curve 3Pool LP token address\n     */\n    function setPool(address _pool, address _curve3CRVToken1) internal {\n        require(\n            IMetaPool(_pool).coins(0) ==\n                LibAppStorage.appStorage().dollarTokenAddress,\n            \"TWAPOracle: FIRST_COIN_NOT_DOLLAR\"\n        );\n        TWAPOracleStorage storage ts = twapOracleStorage();\n\n        // coin at index 0 is Ubiquity Dollar and index 1 is 3CRV\n        require(\n            IMetaPool(_pool).coins(1) == _curve3CRVToken1,\n            \"TWAPOracle: COIN_ORDER_MISMATCH\"\n        );\n\n        uint256 _reserve0 = uint112(IMetaPool(_pool).balances(0));\n        uint256 _reserve1 = uint112(IMetaPool(_pool).balances(1));\n\n        // ensure that there's liquidity in the pair\n        require(_reserve0 != 0 && _reserve1 != 0, \"TWAPOracle: NO_RESERVES\");\n        // ensure that pair balance is perfect\n        require(_reserve0 == _reserve1, \"TWAPOracle: PAIR_UNBALANCED\");\n        ts.priceCumulativeLast = IMetaPool(_pool).get_price_cumulative_last();\n        ts.pricesBlockTimestampLast = IMetaPool(_pool).block_timestamp_last();\n        ts.pool = _pool;\n        // dollar token is inside the diamond\n        ts.token1 = _curve3CRVToken1;\n        ts.price0Average = 1 ether;\n        ts.price1Average = 1 ether;\n    }\n\n    /**\n     * @notice Updates the following state variables to the latest values from MetaPool:\n     * - Dollar / 3CRV LP quote\n     * - 3CRV LP / Dollar quote\n     * - cumulative prices\n     * - update timestamp\n     */\n    function update() internal {\n        TWAPOracleStorage storage ts = twapOracleStorage();\n        (\n            uint256[2] memory priceCumulative,\n            uint256 blockTimestamp\n        ) = currentCumulativePrices();\n        if (blockTimestamp - ts.pricesBlockTimestampLast > 0) {\n            // get the balances between now and the last price cumulative snapshot\n            uint256[2] memory twapBalances = IMetaPool(ts.pool)\n                .get_twap_balances(\n                    ts.priceCumulativeLast,\n                    priceCumulative,\n                    blockTimestamp - ts.pricesBlockTimestampLast\n                );\n\n            // price to exchange amountIn Ubiquity Dollar to 3CRV based on TWAP\n            ts.price0Average = IMetaPool(ts.pool).get_dy(\n                0,\n                1,\n                1 ether,\n                twapBalances\n            );\n\n            // price to exchange amountIn 3CRV to Ubiquity Dollar based on TWAP\n            ts.price1Average = IMetaPool(ts.pool).get_dy(\n                1,\n                0,\n                1 ether,\n                twapBalances\n            );\n            // we update the priceCumulative\n            ts.priceCumulativeLast = priceCumulative;\n            ts.pricesBlockTimestampLast = blockTimestamp;\n        }\n    }\n\n    /**\n     * @notice Returns the quote for the provided `token` address\n     * @notice If the `token` param is Dollar then returns 3CRV LP / Dollar quote\n     * @notice If the `token` param is 3CRV LP then returns Dollar / 3CRV LP quote\n     * @param token Token address\n     * @return amountOut Token price, Dollar / 3CRV LP or 3CRV LP / Dollar quote\n     */\n    function consult(address token) internal view returns (uint256 amountOut) {\n        TWAPOracleStorage memory ts = twapOracleStorage();\n\n        if (token == LibAppStorage.appStorage().dollarTokenAddress) {\n            // price to exchange 1 Ubiquity Dollar to 3CRV based on TWAP\n            amountOut = ts.price0Average;\n        } else {\n            require(token == ts.token1, \"TWAPOracle: INVALID_TOKEN\");\n            // price to exchange 1 3CRV to Ubiquity Dollar based on TWAP\n            amountOut = ts.price1Average;\n        }\n    }\n\n    /**\n     * @notice Returns current cumulative prices from metapool with updated timestamp\n     * @return priceCumulative Current cumulative prices for pool tokens\n     * @return blockTimestamp Current update timestamp\n     */\n    function currentCumulativePrices()\n        internal\n        view\n        returns (uint256[2] memory priceCumulative, uint256 blockTimestamp)\n    {\n        address metapool = twapOracleStorage().pool;\n        priceCumulative = IMetaPool(metapool).get_price_cumulative_last();\n        blockTimestamp = IMetaPool(metapool).block_timestamp_last();\n    }\n\n    /**\n     * @notice Returns struct used as a storage for this library\n     * @return ds Struct used as a storage\n     */\n    function twapOracleStorage()\n        internal\n        pure\n        returns (TWAPOracleStorage storage ds)\n    {\n        bytes32 position = TWAP_ORACLE_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /**\n     * @notice Returns current Dollar price\n     * @dev Returns 3CRV LP / Dollar quote, i.e. how many 3CRV LP tokens user will get for 1 Dollar\n     * @return Dollar price\n     */\n    function getTwapPrice() internal view returns (uint256) {\n        return\n            LibTWAPOracle.consult(\n                LibAppStorage.appStorage().dollarTokenAddress\n            );\n    }\n}"
    }
  ]
}