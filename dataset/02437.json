{
  "Title": "M-2: Broken Operator Mechanism: Just 1 malicious / compromised operator can permanently break functionality",
  "Content": "# Issue M-2: Broken Operator Mechanism: Just 1 malicious / compromised operator can permanently break functionality \n\nSource: https://github.com/sherlock-audit/2023-02-fair-funding-judging/issues/46 \n\n## Found by \nweeeh\\_, hickuphh3, ABA, 0xSmartContract, rvierdiiev, csanuragjain\n\n## Summary\nOperator access control isn't sufficiently resilient against a malicious or compromised actor.\n\n## Vulnerability Detail\nI understand that we can assume all privileged roles to be trusted, but this is about the access control structure for the vault operators. The key thing here is that you can have multiple operators who can add or remove each other. As the saying goes, _\"you are as strong as your weakest link\"_, so all it required is for 1 malicious or compromised operator to permanently break protocol functionality, with no possible remediation as he's able to kick out all other honest operators, _including himself_\n\nThe vault operator can do the following:\n1) Set the `alchemist` contract to any address (except null) of his choosing. He can therefore permanently brick the claiming and liquidation process, resulting in the permanent locking of token holders' funds in Alchemix.\n2) Steal last auction funds. WETH approval is given to the `alchemist` contract every time `register_deposit` is called, and with the fact that anyone can settle the contract, the malicious operator is able to do the following atomically:\n    - set the alchemist contract to a malicious implementation\n       - contract returns a no-op + arbitrary `shares_issued` value when the `depositUnderlying()` function is called\n    - settle the last auction (assuming it hasn't been)\n    - pull auction funds from approval given\n3) Do (1) and remove himself as an operator (ie. there are no longer any operators), permanently preventing any possible remediation.\n\n## Impact\nDoS / holding the users' funds hostage.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/Vault.vy#L292-L300\nhttps://github.com/sherlock-audit/2023-02-fair-funding/blob/main/fair-funding/contracts/Vault.vy#L589-L614\n\n## Tool used\nManual Review\n\n## Recommendation\nAdd an additional access control layer on top of operators: an `owner` that will be held by a multisig / DAO that's able to add / remove operators. \n\n## Discussion\n\n**Unstoppable-DeFi**\n\nhttps://github.com/Unstoppable-DeFi/fair-funding/pull/10\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/42",
  "Code": [
    {
      "filename": "fair-funding/contracts/Vault.vy",
      "content": "# @version 0.3.7\n\n\"\"\"\n@title Fair Funding Alchemix Vault\n@license GNU AGPLv3\n@author unstoppable.ooo\n\n@custom:security-contact team@unstoppable.com\n\n@notice\n    This vault manages a position on Alchemix.\n    Newly deposited WETH will be put into Alchemix and a corresponding\n    loan will be taken out and sent to the fund_receiver.\n\n    The Alchemix positions are governed by the referenced ERC721 tokens.\n\n    The owner of the token can at any point liquidate the underlying \n    Alchemix position and receive the remainder of their deposited funds\n    back.\n\n    Paid off debt on Alchemix (either manually repaid externally or by the\n    self-repaying feature of Alchemix) allows to withdraw parts of the \n    underlying collateral WETH as it becomes available.\n    This withdrawn ETH is marked as claimable and each token owner who \n    contributed to the position can claim his share of the unlocked WETH \n    up to the total amount that was initially deposited with this token.\n\n    Over time 100% of the initial collateral will become unlocked at \n    Alchemix and can be permissionlessly withdrawn by anyone to make it\n    claimable by the token holders.\n\n    Note:\n    We assume the LTV of Alchemix will not change and all positions can\n    be considered as having the same collateralisation / LTV.\n    In the unlikely case it does change, this contract will be re-deployed \n    with the updated collateralization value for new deposits.\n\n\"\"\"\n\nfrom vyper.interfaces import ERC721\nfrom vyper.interfaces import ERC20\n\ninterface IAlchemist:\n    def depositUnderlying(\n        _yield_token: address,\n        _amount: uint256,\n        _recipient: address,\n        _min_amount_out: uint256\n    ) -> uint256: nonpayable\n    def mint(\n        _amount: uint256,\n        _recipient: address\n    ): nonpayable\n    def withdrawUnderlying(\n        _yield_token: address,\n        _shares: uint256,\n        _recipient: address,\n        _min_amount_out: uint256\n    ) -> uint256: nonpayable\n    def liquidate(\n        _yield_token: address,\n        _shares: uint256,\n        _min_amount_out: uint256\n    ) -> uint256: nonpayable\n    def getUnderlyingTokensPerShare(\n        _yield_token: address\n    ) -> uint256: view\n    def totalValue(_owner: address) -> uint256: view\n    def minimumCollateralization() -> uint256: view\n    def accounts(_owner: address) -> (int256, DynArray[address, 8]): view\n    def positions(_owner: address, _yield_token: address) -> (uint256, uint256): view\n    def normalizeUnderlyingTokensToDebt(\n        _underlying_token: address, \n        _amount: uint256\n    ) -> uint256: view\n    def convertUnderlyingTokensToShares(\n        _yield_token: address, \n        _amount: uint256\n    ) -> uint256: view\n    def convertSharesToUnderlyingTokens(\n        _yield_token: address, \n        _shares: uint256\n    ) -> uint256: view\n\n\ninterface Migrator:\n    def migrate(): nonpayable\n\n\nPRECISION: constant(uint256) = 10**6\nDECIMALS: constant(uint256) = 10**18\n\nALCX_YVWETH: constant(address) = 0xa258C4606Ca8206D8aA700cE2143D7db854D168c\nWETH: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n\nNFT: public(immutable(address))\n\nalchemist: public(address)\nfund_receiver: public(address)\n\nstruct Position:\n    token_id: uint256\n    amount_deposited: uint256\n    amount_claimed: uint256\n    shares_owned: uint256\n    is_liquidated: bool\n\npositions: public(HashMap[uint256, Position])\ntotal_shares: public(uint256)\namount_claimable_per_share: public(uint256)\n\nis_operator: public(HashMap[address, bool])\nis_depositor: public(HashMap[address, bool])\n\n\nMIGRATION_TIMELOCK: constant(uint256) = 30 * 60 * 60 * 24  # 30 days in seconds\nmigration_admin: public(address)\nsuggested_migration_admin: public(address)\nmigration_active: public(uint256)\nmigrator: public(address)\nmigration_executed: public(bool)\n\nevent Deposit:\n    token_owner: indexed(address)\n    token_id: uint256\n    amount: uint256\n\nevent Funded:\n    receiver: indexed(address)\n    amount: uint256\n\nevent Liquidated:\n    token_id: uint256\n    token_owner: indexed(address)\n    amount: uint256\n\nevent Claimable:\n    amount: uint256\n\nevent Claimed:\n    token_id: uint256\n    token_owner: indexed(address)\n    amount: uint256\n\nevent AlchemistUpdated:\n    updater: indexed(address)\n    new_alchemist: indexed(address)\n\nevent FundReceiverUpdated:\n    updater: indexed(address)\n    new_fund_receiver: indexed(address)\n\nevent NewOperator:\n    new_operator: indexed(address)\n    promoted_by: indexed(address)\n\nevent OperatorRemoved:\n    removed: indexed(address)\n    removed_by: indexed(address)\n\nevent NewDepositor:\n    new_depositor: indexed(address)\n    promoted_by: indexed(address)\n\nevent DepositorRemoved:\n    removed: indexed(address)\n    removed_by: indexed(address)\n\nevent MigrationAdminTransferred:\n    new_admin: indexed(address)\n    promoted_by: indexed(address)\n\nevent NewMigrationAdminSuggested:\n    new_admin: indexed(address)\n    suggested_by: indexed(address)\n\nevent MigrationActivated:\n    migrator_address: address\n    active_at: uint256\n\nevent MigrationDeactivated: pass\n\n\n@external\ndef __init__(\n    _nft_address: address,\n):\n    assert _nft_address != empty(address), \"invalid nft address\"\n    NFT = _nft_address\n\n    self.is_operator[msg.sender] = True\n    self.fund_receiver = msg.sender\n\n    self.migration_active = max_value(uint256)\n    self.migration_admin = msg.sender\n\n\n@nonreentrant(\"lock\")\n@external\ndef register_deposit(_token_id: uint256, _amount: uint256):\n    \"\"\"\n    @notice\n        Registers a new deposit of _amount for _token_id.\n        _amount WETH is deposited into Alchemix and a corresponding\n        loan is taken out and sent to fund_receiver.\n    \"\"\"\n    assert self.is_depositor[msg.sender], \"not allowed\"\n    assert self._is_valid_token_id(_token_id)\n\n    position: Position = self.positions[_token_id]\n    assert position.is_liquidated == False, \"position already liquidated\"\n\n    position.token_id = _token_id\n    position.amount_deposited += _amount\n\n    # transfer WETH to self\n    ERC20(WETH).transferFrom(msg.sender, self, _amount)\n\n    # deposit WETH to Alchemix\n    shares_issued: uint256 = self._deposit_to_alchemist(_amount)\n    position.shares_owned += shares_issued\n    self.total_shares += shares_issued\n    \n    self.positions[_token_id] = position\n\n    # mint alchemix debt to fund_receiver\n    amount_to_mint: uint256 = self._calculate_amount_to_mint(shares_issued)\n    assert amount_to_mint > 0, \"cannot mint new Alchemix debt\"\n\n    self._mint_from_alchemix(amount_to_mint, self.fund_receiver)\n\n    log Deposit(msg.sender, _token_id, _amount)\n\n\n@internal\n@view\ndef _calculate_amount_to_mint(_amount_shares: uint256) -> uint256:\n    return min(self._calculate_mintable_amount(_amount_shares), self._calculate_max_mintable_amount())\n\n\n@internal\n@view\ndef _calculate_mintable_amount(_amount_shares: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Calculate the mintable amount of debt tokens given _amount_shares new\n        shares as collateral.\n        This function does not account for existing debts on Alchemix.\n    \"\"\"\n    min_collateralization: uint256 = IAlchemist(self.alchemist).minimumCollateralization()\n    amount_shares_collateralized: uint256 = _amount_shares * DECIMALS / min_collateralization\n    amount_underlying: uint256 = IAlchemist(self.alchemist).convertSharesToUnderlyingTokens(ALCX_YVWETH, amount_shares_collateralized)\n    mintable_debt: uint256 = IAlchemist(self.alchemist).normalizeUnderlyingTokensToDebt(WETH, amount_underlying)\n    if mintable_debt > 0:\n        mintable_debt -= 1 # to pass \"<\" collateralisation check on Alchemix\n    return mintable_debt\n\n\n\n@internal\n@view\ndef _calculate_max_mintable_amount() -> uint256:\n    \"\"\"\n    @notice\n        Calculate the maximum mintable amount of debt tokens given the current\n        collateral and existing debt on Alchemix.\n    \"\"\"\n    # Alchemist._validate(): uint256 collateralization = totalValue(owner) * 1e18 / uint256(debt);\n    current_debt: uint256 = convert(IAlchemist(self.alchemist).accounts(self)[0], uint256)\n    total_value: uint256 = IAlchemist(self.alchemist).totalValue(self)\n    min_collateralization: uint256 = IAlchemist(self.alchemist).minimumCollateralization()\n\n    max_mintable_debt: uint256 = total_value * DECIMALS / min_collateralization - current_debt\n\n    if max_mintable_debt > 0:\n        max_mintable_debt = max_mintable_debt - 1 # minus 1 for collat < min_collat check @ alchemist._validate\n    \n    return max_mintable_debt\n\n\n\n\n@internal\ndef _deposit_to_alchemist(_amount: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Deposits _amount WETH from this contract into the Alchemix ALCX_YVWETH\n        vault. \n    \"\"\"\n    assert self.alchemist != empty(address), \"invalid state, alchemist not set\"\n    \n    ERC20(WETH).approve(self.alchemist, _amount)\n    shares_issued: uint256 = IAlchemist(self.alchemist).depositUnderlying(\n        ALCX_YVWETH,     # yield_token\n        _amount,         # amount\n        self,            # recipient\n        1                # min_amount_out - cannot be frontrun in a significant way\n                         #                  so to reduce complexity we go with 1\n    )\n    return shares_issued\n\n\n@internal \ndef _mint_from_alchemix(_amount: uint256, _recipient: address):\n    \"\"\"\n    @notice\n        Takes on _amount of debt (in alETH) on Alchemix and transfers it to \n        _recipient.\n    \"\"\"\n    IAlchemist(self.alchemist).mint(\n        _amount,    # amount\n        _recipient  # recipient\n    )\n\n    log Funded(_recipient, _amount)\n\n\n@nonreentrant(\"lock\")\n@external\ndef liquidate(_token_id: uint256, _min_weth_out: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Liquidates the underlying debt of position[_token_id] by burning\n        a corresponding amount of shares.\n        Withdraws remaining value of shares as WETH to token_owner.\n        Reverts if owner would receive less than _min_weth_out.\n    \"\"\"\n    token_owner: address = ERC721(NFT).ownerOf(_token_id)\n    assert token_owner == msg.sender, \"only token owner can liquidate\"\n\n    position: Position = self.positions[_token_id]\n    assert position.is_liquidated == False, \"position already liquidated\"\n    \n    position.is_liquidated = True\n    self.positions[_token_id] = position\n    self.total_shares -= position.shares_owned\n\n    collateralisation: uint256 = self._latest_collateralisation()\n    shares_to_liquidate: uint256 = position.shares_owned * DECIMALS / collateralisation\n\n    amount_shares_liquidated: uint256 = IAlchemist(self.alchemist).liquidate(\n        ALCX_YVWETH,                 # _yield_token: address,\n        shares_to_liquidate,         # _shares: uint256,\n        1                            # _min_amount_out: uint256 -> covered by _min_weth_out\n    )\n\n    amount_to_withdraw: uint256 = position.shares_owned - amount_shares_liquidated\n    # _withdraw_underlying_from_alchemix reverts on < _min_weth_out\n    amount_withdrawn: uint256 = self._withdraw_underlying_from_alchemix(amount_to_withdraw, token_owner, _min_weth_out)\n\n    log Liquidated(_token_id, token_owner, amount_withdrawn)\n    return amount_withdrawn\n\n\n@internal\ndef _latest_collateralisation() -> uint256:\n    \"\"\"\n    @notice\n        Calculates the current collateral to debt ratio on Alchemix.\n        Reverts when there is no debt and collateralisation would be\n        infinite.\n    \"\"\"\n    # Alchemist._validate(): \n    # uint256 collateralization = totalValue(owner) * FIXED_POINT_SCALAR / uint256(debt);\n    current_debt: int256 = IAlchemist(self.alchemist).accounts(self)[0]\n    assert current_debt > 0, \"zero debt\"\n    \n    total_value: uint256 = IAlchemist(self.alchemist).totalValue(self)\n    debt: uint256 = convert(current_debt, uint256)\n    return total_value * DECIMALS / debt\n\n\n@internal\ndef _withdraw_underlying_from_alchemix(\n    _amount_shares: uint256, \n    _receiver: address,\n    _min_weth_out: uint256\n) -> uint256:\n    \"\"\"\n    @notice\n        Withdraws _amount_shares to _receiver expecting at least _min_weth_out\n    \"\"\"\n    amount_withdrawn: uint256 = IAlchemist(self.alchemist).withdrawUnderlying(\n        ALCX_YVWETH,    # _yield_token: address,\n        _amount_shares, # _shares: uint256,\n        _receiver,      # _recipient: address,\n        _min_weth_out   # _min_amount_out: uint256 \n    )\n    assert amount_withdrawn >= _min_weth_out, \"insufficient weth out\"\n    return amount_withdrawn\n\n\n@external\ndef withdraw_underlying_to_claim(_amount_shares: uint256, _min_weth_out: uint256):\n    \"\"\"\n    @notice\n        Withdraws _amount_shares and _min_weth_out from Alchemix to be distributed\n        to token holders.\n        The WETH is held in this contract until it is `claim`ed.\n    \"\"\"\n    amount_withdrawn: uint256 = self._withdraw_underlying_from_alchemix(_amount_shares, self, _min_weth_out)\n    self._mark_as_claimable(amount_withdrawn)\n\n    log Claimable(amount_withdrawn)\n\n\n@internal\ndef _mark_as_claimable(_amount: uint256):\n    \"\"\"\n    @notice\n        Marks _amount of WETH as claimable by token holders and\n        calculates the amount_claimable_per_share.\n    \"\"\"\n    if _amount == 0 or self.total_shares == 0:\n        return\n\n    assert ERC20(WETH).balanceOf(self) >= _amount\n\n    self.amount_claimable_per_share += _amount * PRECISION / self.total_shares\n    \n\n@view\n@external\ndef claimable_for_token(_token_id: uint256) -> uint256:\n    return self._claimable_for_token(_token_id)\n\n\n@view\n@internal\ndef _claimable_for_token(_token_id: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Calculates the pending WETH for a given token_id.\n    \"\"\"\n    position: Position = self.positions[_token_id]\n    if position.is_liquidated:\n        return 0\n    \n    total_claimable_for_position: uint256 = position.shares_owned * self.amount_claimable_per_share / PRECISION\n    return total_claimable_for_position - position.amount_claimed\n\n\n@external\ndef claim(_token_id: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Allows a token holder to claim his share of pending WETH.\n    \"\"\"\n    token_owner: address = ERC721(NFT).ownerOf(_token_id)\n    assert msg.sender == token_owner, \"only token owner can claim\"\n\n    amount: uint256 = self._claimable_for_token(_token_id)\n    assert amount > 0, \"nothing to claim\"\n\n    position: Position = self.positions[_token_id]\n    position.amount_claimed += amount\n    self.positions[_token_id] = position\n    \n    ERC20(WETH).transfer(token_owner, amount)\n\n    log Claimed(_token_id, token_owner, amount)\n    return amount\n\n\n@internal\ndef _is_valid_token_id(_token_id: uint256) -> bool:\n    \"\"\"\n    @notice\n        Checks if the given _token_id exists.\n        Reverts if token isn't minted.\n    \"\"\"\n    ERC721(NFT).ownerOf(_token_id) # reverts for invalid token_id according to spec\n    return True\n\n\n#######################\n#\n#        ADMIN\n#\n#######################\n\n@external\ndef set_alchemist(_addr: address):\n    \"\"\"\n    @notice\n        Sets the Alchemix Alchemist contract\n    \"\"\"\n    assert self.is_operator[msg.sender], \"unauthorized\"\n    assert _addr != empty(address), \"invalid alchemist address\"\n    assert _addr != self.alchemist, \"same as current\"\n\n    self.alchemist = _addr\n\n    log AlchemistUpdated(msg.sender, _addr)\n\n\n@external\ndef set_fund_receiver(_addr: address):\n    \"\"\"\n    @notice\n        Sets the fund_receiver address that will receive newly minted\n        alETH.\n    \"\"\"\n    assert self.is_operator[msg.sender], \"unauthorized\"\n    assert _addr != empty(address), \"invalid fund_receiver address\"\n    assert _addr != self.fund_receiver, \"same as current\"\n\n    self.fund_receiver = _addr\n\n    log FundReceiverUpdated(msg.sender, _addr)\n\n\n@external\ndef activate_migration(_migrator_addr: address):\n    \"\"\"\n    @notice\n        Sets a migration contract and starts the 30 day timelock before\n        migration can be performed.\n        Can only be called by the migration_admin.\n    \"\"\"\n    assert msg.sender == self.migration_admin, \"unauthorized\"\n    assert self.migrator == empty(address), \"cannot override active migration\"\n    assert _migrator_addr != empty(address), \"cannot set migrator to zero address\"\n\n    self.migrator = _migrator_addr\n    self.migration_active = block.timestamp + MIGRATION_TIMELOCK\n    self.migration_executed = False\n\n    log MigrationActivated(_migrator_addr, self.migration_active)\n\n\n@external\ndef deactivate_migration():\n    \"\"\"\n    @notice\n        Stops an activated migration and resets the migration values.\n    \"\"\"\n    assert msg.sender == self.migration_admin, \"unauthorized\"\n    self.migration_active = max_value(uint256)\n    self.migrator = empty(address)\n    \n    log MigrationDeactivated()\n\n\n@external\ndef migrate():\n    \"\"\"\n    @notice\n        Calls migrate function on the set migrator contract.\n        This is just in case there are severe changes in Alchemix that\n        require a full migration of the existing position.\n    \"\"\"\n    assert self.migration_active <= block.timestamp, \"migration not active\"\n    assert self.migration_executed == False, \"migration already executed\"\n    self.migration_executed = True\n    Migrator(self.migrator).migrate()\n\n\n@external\ndef suggest_migration_admin(_new_admin: address):\n    \"\"\"\n    @notice\n        Step 1 of the 2 step process to transfer migration admin.\n        Current owner suggests a new owner.\n        Requires the new admin to accept ownership in step 2.\n    @param _new_admin\n        The address of the new migration admin.\n    \"\"\"\n    assert msg.sender == self.migration_admin, \"unauthorized\"\n    assert _new_admin != empty(address), \"cannot set migration_admin to zero address\"\n    self.suggested_migration_admin = _new_admin\n    log NewMigrationAdminSuggested(_new_admin, msg.sender)\n\n\n@external\ndef accept_migration_admin():\n    \"\"\"\n    @notice\n        Step 2 of the 2 step process to transfer migration admin.\n        The suggested admin accepts the transfer and becomes the\n        new migration admin.\n    \"\"\"\n    assert msg.sender == self.suggested_migration_admin, \"unauthorized\"\n    prev_admin: address = self.migration_admin\n    self.migration_admin = self.suggested_migration_admin\n    log MigrationAdminTransferred(self.migration_admin, prev_admin)\n\n\n@external\ndef add_operator(_new_operator: address):\n    \"\"\"\n    @notice\n        Add a new address to the priviledged operators.\n    \"\"\"\n    assert self.is_operator[msg.sender], \"unauthorized\"\n    assert self.is_operator[_new_operator] == False, \"already operator\"\n\n    self.is_operator[_new_operator] = True\n\n    log NewOperator(_new_operator, msg.sender)\n\n\n@external\ndef remove_operator(_to_remove: address):\n    \"\"\"\n    @notice\n        Remove an existing operator from the priviledged addresses.\n    \"\"\"\n    assert self.is_operator[msg.sender], \"unauthorized\"\n    assert self.is_operator[_to_remove], \"not an operator\"\n\n    self.is_operator[_to_remove] = False\n\n    log OperatorRemoved(_to_remove, msg.sender)\n\n\n@external\ndef add_depositor(_new_depositor: address):\n    \"\"\"\n    @notice\n        Add a new address to the priviledged depositors.\n    \"\"\"\n    assert self.is_operator[msg.sender], \"unauthorized\"\n    assert self.is_depositor[_new_depositor] == False, \"already depositor\"\n\n    self.is_depositor[_new_depositor] = True\n\n    log NewDepositor(_new_depositor, msg.sender)\n\n\n@external\ndef remove_depositor(_to_remove: address):\n    \"\"\"\n    @notice\n        Remove an existing depositor from the priviledged addresses.\n    \"\"\"\n    assert self.is_operator[msg.sender], \"unauthorized\"\n    assert self.is_depositor[_to_remove], \"not an depositor\"\n\n    self.is_depositor[_to_remove] = False\n\n    log DepositorRemoved(_to_remove, msg.sender)"
    },
    {
      "filename": "fair-funding/contracts/Vault.vy",
      "content": "# @version 0.3.7\n\n\"\"\"\n@title Fair Funding Alchemix Vault\n@license GNU AGPLv3\n@author unstoppable.ooo\n\n@custom:security-contact team@unstoppable.com\n\n@notice\n    This vault manages a position on Alchemix.\n    Newly deposited WETH will be put into Alchemix and a corresponding\n    loan will be taken out and sent to the fund_receiver.\n\n    The Alchemix positions are governed by the referenced ERC721 tokens.\n\n    The owner of the token can at any point liquidate the underlying \n    Alchemix position and receive the remainder of their deposited funds\n    back.\n\n    Paid off debt on Alchemix (either manually repaid externally or by the\n    self-repaying feature of Alchemix) allows to withdraw parts of the \n    underlying collateral WETH as it becomes available.\n    This withdrawn ETH is marked as claimable and each token owner who \n    contributed to the position can claim his share of the unlocked WETH \n    up to the total amount that was initially deposited with this token.\n\n    Over time 100% of the initial collateral will become unlocked at \n    Alchemix and can be permissionlessly withdrawn by anyone to make it\n    claimable by the token holders.\n\n    Note:\n    We assume the LTV of Alchemix will not change and all positions can\n    be considered as having the same collateralisation / LTV.\n    In the unlikely case it does change, this contract will be re-deployed \n    with the updated collateralization value for new deposits.\n\n\"\"\"\n\nfrom vyper.interfaces import ERC721\nfrom vyper.interfaces import ERC20\n\ninterface IAlchemist:\n    def depositUnderlying(\n        _yield_token: address,\n        _amount: uint256,\n        _recipient: address,\n        _min_amount_out: uint256\n    ) -> uint256: nonpayable\n    def mint(\n        _amount: uint256,\n        _recipient: address\n    ): nonpayable\n    def withdrawUnderlying(\n        _yield_token: address,\n        _shares: uint256,\n        _recipient: address,\n        _min_amount_out: uint256\n    ) -> uint256: nonpayable\n    def liquidate(\n        _yield_token: address,\n        _shares: uint256,\n        _min_amount_out: uint256\n    ) -> uint256: nonpayable\n    def getUnderlyingTokensPerShare(\n        _yield_token: address\n    ) -> uint256: view\n    def totalValue(_owner: address) -> uint256: view\n    def minimumCollateralization() -> uint256: view\n    def accounts(_owner: address) -> (int256, DynArray[address, 8]): view\n    def positions(_owner: address, _yield_token: address) -> (uint256, uint256): view\n    def normalizeUnderlyingTokensToDebt(\n        _underlying_token: address, \n        _amount: uint256\n    ) -> uint256: view\n    def convertUnderlyingTokensToShares(\n        _yield_token: address, \n        _amount: uint256\n    ) -> uint256: view\n    def convertSharesToUnderlyingTokens(\n        _yield_token: address, \n        _shares: uint256\n    ) -> uint256: view\n\n\ninterface Migrator:\n    def migrate(): nonpayable\n\n\nPRECISION: constant(uint256) = 10**6\nDECIMALS: constant(uint256) = 10**18\n\nALCX_YVWETH: constant(address) = 0xa258C4606Ca8206D8aA700cE2143D7db854D168c\nWETH: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n\nNFT: public(immutable(address))\n\nalchemist: public(address)\nfund_receiver: public(address)\n\nstruct Position:\n    token_id: uint256\n    amount_deposited: uint256\n    amount_claimed: uint256\n    shares_owned: uint256\n    is_liquidated: bool\n\npositions: public(HashMap[uint256, Position])\ntotal_shares: public(uint256)\namount_claimable_per_share: public(uint256)\n\nis_operator: public(HashMap[address, bool])\nis_depositor: public(HashMap[address, bool])\n\n\nMIGRATION_TIMELOCK: constant(uint256) = 30 * 60 * 60 * 24  # 30 days in seconds\nmigration_admin: public(address)\nsuggested_migration_admin: public(address)\nmigration_active: public(uint256)\nmigrator: public(address)\nmigration_executed: public(bool)\n\nevent Deposit:\n    token_owner: indexed(address)\n    token_id: uint256\n    amount: uint256\n\nevent Funded:\n    receiver: indexed(address)\n    amount: uint256\n\nevent Liquidated:\n    token_id: uint256\n    token_owner: indexed(address)\n    amount: uint256\n\nevent Claimable:\n    amount: uint256\n\nevent Claimed:\n    token_id: uint256\n    token_owner: indexed(address)\n    amount: uint256\n\nevent AlchemistUpdated:\n    updater: indexed(address)\n    new_alchemist: indexed(address)\n\nevent FundReceiverUpdated:\n    updater: indexed(address)\n    new_fund_receiver: indexed(address)\n\nevent NewOperator:\n    new_operator: indexed(address)\n    promoted_by: indexed(address)\n\nevent OperatorRemoved:\n    removed: indexed(address)\n    removed_by: indexed(address)\n\nevent NewDepositor:\n    new_depositor: indexed(address)\n    promoted_by: indexed(address)\n\nevent DepositorRemoved:\n    removed: indexed(address)\n    removed_by: indexed(address)\n\nevent MigrationAdminTransferred:\n    new_admin: indexed(address)\n    promoted_by: indexed(address)\n\nevent NewMigrationAdminSuggested:\n    new_admin: indexed(address)\n    suggested_by: indexed(address)\n\nevent MigrationActivated:\n    migrator_address: address\n    active_at: uint256\n\nevent MigrationDeactivated: pass\n\n\n@external\ndef __init__(\n    _nft_address: address,\n):\n    assert _nft_address != empty(address), \"invalid nft address\"\n    NFT = _nft_address\n\n    self.is_operator[msg.sender] = True\n    self.fund_receiver = msg.sender\n\n    self.migration_active = max_value(uint256)\n    self.migration_admin = msg.sender\n\n\n@nonreentrant(\"lock\")\n@external\ndef register_deposit(_token_id: uint256, _amount: uint256):\n    \"\"\"\n    @notice\n        Registers a new deposit of _amount for _token_id.\n        _amount WETH is deposited into Alchemix and a corresponding\n        loan is taken out and sent to fund_receiver.\n    \"\"\"\n    assert self.is_depositor[msg.sender], \"not allowed\"\n    assert self._is_valid_token_id(_token_id)\n\n    position: Position = self.positions[_token_id]\n    assert position.is_liquidated == False, \"position already liquidated\"\n\n    position.token_id = _token_id\n    position.amount_deposited += _amount\n\n    # transfer WETH to self\n    ERC20(WETH).transferFrom(msg.sender, self, _amount)\n\n    # deposit WETH to Alchemix\n    shares_issued: uint256 = self._deposit_to_alchemist(_amount)\n    position.shares_owned += shares_issued\n    self.total_shares += shares_issued\n    \n    self.positions[_token_id] = position\n\n    # mint alchemix debt to fund_receiver\n    amount_to_mint: uint256 = self._calculate_amount_to_mint(shares_issued)\n    assert amount_to_mint > 0, \"cannot mint new Alchemix debt\"\n\n    self._mint_from_alchemix(amount_to_mint, self.fund_receiver)\n\n    log Deposit(msg.sender, _token_id, _amount)\n\n\n@internal\n@view\ndef _calculate_amount_to_mint(_amount_shares: uint256) -> uint256:\n    return min(self._calculate_mintable_amount(_amount_shares), self._calculate_max_mintable_amount())\n\n\n@internal\n@view\ndef _calculate_mintable_amount(_amount_shares: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Calculate the mintable amount of debt tokens given _amount_shares new\n        shares as collateral.\n        This function does not account for existing debts on Alchemix.\n    \"\"\"\n    min_collateralization: uint256 = IAlchemist(self.alchemist).minimumCollateralization()\n    amount_shares_collateralized: uint256 = _amount_shares * DECIMALS / min_collateralization\n    amount_underlying: uint256 = IAlchemist(self.alchemist).convertSharesToUnderlyingTokens(ALCX_YVWETH, amount_shares_collateralized)\n    mintable_debt: uint256 = IAlchemist(self.alchemist).normalizeUnderlyingTokensToDebt(WETH, amount_underlying)\n    if mintable_debt > 0:\n        mintable_debt -= 1 # to pass \"<\" collateralisation check on Alchemix\n    return mintable_debt\n\n\n\n@internal\n@view\ndef _calculate_max_mintable_amount() -> uint256:\n    \"\"\"\n    @notice\n        Calculate the maximum mintable amount of debt tokens given the current\n        collateral and existing debt on Alchemix.\n    \"\"\"\n    # Alchemist._validate(): uint256 collateralization = totalValue(owner) * 1e18 / uint256(debt);\n    current_debt: uint256 = convert(IAlchemist(self.alchemist).accounts(self)[0], uint256)\n    total_value: uint256 = IAlchemist(self.alchemist).totalValue(self)\n    min_collateralization: uint256 = IAlchemist(self.alchemist).minimumCollateralization()\n\n    max_mintable_debt: uint256 = total_value * DECIMALS / min_collateralization - current_debt\n\n    if max_mintable_debt > 0:\n        max_mintable_debt = max_mintable_debt - 1 # minus 1 for collat < min_collat check @ alchemist._validate\n    \n    return max_mintable_debt\n\n\n\n\n@internal\ndef _deposit_to_alchemist(_amount: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Deposits _amount WETH from this contract into the Alchemix ALCX_YVWETH\n        vault. \n    \"\"\"\n    assert self.alchemist != empty(address), \"invalid state, alchemist not set\"\n    \n    ERC20(WETH).approve(self.alchemist, _amount)\n    shares_issued: uint256 = IAlchemist(self.alchemist).depositUnderlying(\n        ALCX_YVWETH,     # yield_token\n        _amount,         # amount\n        self,            # recipient\n        1                # min_amount_out - cannot be frontrun in a significant way\n                         #                  so to reduce complexity we go with 1\n    )\n    return shares_issued\n\n\n@internal \ndef _mint_from_alchemix(_amount: uint256, _recipient: address):\n    \"\"\"\n    @notice\n        Takes on _amount of debt (in alETH) on Alchemix and transfers it to \n        _recipient.\n    \"\"\"\n    IAlchemist(self.alchemist).mint(\n        _amount,    # amount\n        _recipient  # recipient\n    )\n\n    log Funded(_recipient, _amount)\n\n\n@nonreentrant(\"lock\")\n@external\ndef liquidate(_token_id: uint256, _min_weth_out: uint256) -> uint256:\n    \"\"\"\n    @notice\n        Liquidates the underlying debt of position[_token_id] by burning\n        a corresponding amount of shares.\n        Withdraws remaining value of shares as WETH to token_owner.\n        Reverts if owner would receive less than _min_weth_out.\n    \"\"\"\n    token_owner: address = ERC721(NFT).ownerOf(_token_id)\n    assert token_owner == msg.sender, \"only token owner can liquidate\"\n\n    position: Position = self.positions[_token_id]\n    assert position.is_liquidated == False, \"position already liquidated\"\n    \n    position.is_liquidated = True\n    self.positions[_token_id] = position\n    self.total_shares -= position.shares_owned\n\n    collateralisation: uint256 = self._latest_collateralisation()\n    shares_to_liquidate: uint256 = position.shares_owned * DECIMALS / collateralisation\n\n    amount_shares_liquidated: uint256 = IAlchemist(self.alchemist).liquidate(\n        ALCX_YVWETH,                 # _yield_token: address,\n        shares_to_liquidate,         # _shares: uint256,\n        1                            # _min_amount_out: uint256 -> covered by _min_weth_out\n    )\n\n    amount_to_withdraw: uint256 = position.shares_owned - amount_shares_liquidated\n    # _withdraw_underlying_from_alchemix reverts on < _min_weth_out\n    amount_withdrawn: uint256 = self._withdraw_underlying_from_alchemix(amount_to_withdraw, token_owner, _min_weth_out)\n\n    log Liquidated(_token_id, token_owner, amount_withdrawn)\n    return amount_withdrawn\n\n\n@internal\ndef _latest_collateralisation() -> uint256:\n    \"\"\"\n    @notice\n        Calculates the current collateral to debt ratio on Alchemix.\n        Reverts when there is no debt and collateralisation would be\n        infinite.\n    \"\"\"\n    # Alchemist._validate(): \n    # uint256 collateralization = totalValue(owner) * FIXED_POINT_SCALAR / uint256(debt);\n    current_debt: int256 = IAlchemist(self.alchemist).accounts(self)[0]\n    assert current_debt > 0, \"zero debt\"\n    \n    total_value: uint256 = IAlchemist(self.alchemist).totalValue(self)\n    debt: uint256 = convert(current_debt, uint256)\n    return total_value * DECIMALS / debt\n\n\n@internal\ndef _withdraw_underlying_from_alchemix(\n    _amount_shares: uint256, \n    _receiver: address,\n    _min_weth_out: uint256\n) -> uint256:\n    \"\"\"\n    @notice\n        Withdraws _amount_shares to _receiver expecting at least _min_weth_out\n    \"\"\"\n    amount_withdrawn: uint256 = IAlchemist(self.alchemist).withdrawUnderlying(\n        ALCX_YVWETH,    # _yield_token: address,\n        _amount_shares, # _shares: uint256,\n        _receiver,      # _recipient: address,\n        _min_weth_out   # _min_amount_out: uint256 \n    )\n    assert amount_withdrawn >= _min_weth_out, \"insufficient weth out\"\n    return amount_withdrawn\n\n\n@external\ndef withdraw_underlying_to_claim(_amount_shares: uint256, _min_weth_out: uint256):\n    \"\"\"\n    @notice\n        Withdraws _amount_shares and _min_weth_out from Alchemix to be distributed\n        to token holders.\n        The WETH is held in this contract until it is `claim`ed.\n    \"\"\"\n    amount_withdrawn: uint256 = self._withdraw_underlying_from_alchemix(_amount_shares, self, _min_weth_out)\n    self._mark_as_claimable(amount_withdrawn)\n\n    log Claimable(amount_withdrawn)\n\n\n@internal\ndef _mark_as_claimable(_amount: uint256):\n    \"\"\"\n    @notice\n        Marks _amount of WETH as claimable by token holders and\n        calculates the amount_claimable_per_share.\n    \"\"\"\n    if _amount == 0 or self.total_shares == 0:\n        return\n\n    assert ERC20(WET"
    }
  ]
}