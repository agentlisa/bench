{
  "Title": "[M-07] [WP-M4] Unable to use `L2GatewayRouter` to withdraw LPT from L2 to L1, as `L2LPTGateway` does not implement `L2GatewayRouter` expected method",
  "Content": "_Submitted by WatchPug_.\n\nPer the document: <https://github.com/code-423n4/2022-01-livepeer#l2---l1-lpt-withdrawal>\n\n> The following occurs when LPT is withdrawn from L2 to L1:\n\n> The user initiates a withdrawal for X LPT. This can be done in two ways: a. Call outboundTransfer() on L2GatewayRouter which will call outboundTransfer() on L2LPTGateway b. Call outboundTransfer() directly on L2LPTGateway\n\nThe method (a) described above won't work in the current implementation due to the missing interface on `L2LPTGateway`.\n\nWhen initiate a withdraw from the Arbitrum Gateway Router, `L2GatewayRouter` will call `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` on `ITokenGateway(gateway)`:\n\n```solidity\nfunction outboundTransfer(\n    address _token,\n    address _to,\n    uint256 _amount,\n    uint256 _maxGas,\n    uint256 _gasPriceBid,\n    bytes calldata _data\n) external payable returns (bytes memory);\n```\n\n<https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/arbitrum/gateway/L2GatewayRouter.sol#L57-L64>\n\n```solidity\nfunction outboundTransfer(\n    address _l1Token,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n) public payable returns (bytes memory) {\n    return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data);\n}\n```\n\n<https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/libraries/gateway/GatewayRouter.sol#L78-L102>\n\n```solidity\nfunction outboundTransfer(\n    address _token,\n    address _to,\n    uint256 _amount,\n    uint256 _maxGas,\n    uint256 _gasPriceBid,\n    bytes calldata _data\n) public payable virtual override returns (bytes memory) {\n    address gateway = getGateway(_token);\n    bytes memory gatewayData = GatewayMessageHandler.encodeFromRouterToGateway(\n        msg.sender,\n        _data\n    );\n\n    emit TransferRouted(_token, msg.sender, _to, gateway);\n    return\n        ITokenGateway(gateway).outboundTransfer{ value: msg.value }(\n            _token,\n            _to,\n            _amount,\n            _maxGas,\n            _gasPriceBid,\n            gatewayData\n        );\n}\n```\n\nHowever, `L2LPTGateway` dose not implement `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` but only `outboundTransfer(address,address,uint256,bytes)`:\n\n<https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTGateway.sol#L65-L89>\n\n```solidity\nfunction outboundTransfer(\n    address _l1Token,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n) public override whenNotPaused returns (bytes memory res) {\n    // ...\n}\n```\n\nTherefore, the desired feature to withdraw LPT from L2 to L1 via Arbitrum Router will not be working properly.\n\n#### Recommendation\n\nConsider implementing the method used by  Arbitrum Router.\n\nSee also the implementation of L2DaiGateway by arbitrum-dai-bridge: <https://github.com/makerdao/arbitrum-dai-bridge/blob/master/contracts/l2/L2DaiGateway.sol#L88-L95>\n\n**[yondonfu (Livepeer) confirmed and resolved](https://github.com/code-423n4/2022-01-livepeer-findings/issues/202#issuecomment-1026222951):**\n > Fixed in https://github.com/livepeer/arbitrum-lpt-bridge/pull/57\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-01-livepeer",
  "Code": [
    {
      "filename": "contracts/L2/gateway/L2LPTGateway.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ControlledGateway} from \"../../ControlledGateway.sol\";\nimport {L2ArbitrumMessenger} from \"./L2ArbitrumMessenger.sol\";\nimport {IL2LPTGateway} from \"./IL2LPTGateway.sol\";\nimport {IL1LPTGateway} from \"../../L1/gateway/IL1LPTGateway.sol\";\n\ninterface Mintable {\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n}\n\ninterface IL2LPTDataCache {\n    function increaseL2SupplyFromL1(uint256 _amount) external;\n\n    function decreaseL2SupplyFromL1(uint256 _amount) external;\n}\n\n/**\n * @title L1LPTGateway\n * @notice Manages inbound and outbound transfers of LPT between Arbitrum Rollup and L1\n * @dev the contract can be paused by the governor which will prevent any outbound transfers\n * but pausing the contract does not affect inbound transfers (tokens coming from L1)\n */\ncontract L2LPTGateway is IL2LPTGateway, ControlledGateway, L2ArbitrumMessenger {\n    address public immutable l2Router;\n    address public immutable l2LPTDataCache;\n\n    address public l1Counterpart;\n\n    constructor(\n        address _l2Router,\n        address _l1Lpt,\n        address _l2Lpt,\n        address _l2LPTDataCache\n    ) ControlledGateway(_l1Lpt, _l2Lpt) {\n        l2Router = _l2Router;\n        l2LPTDataCache = _l2LPTDataCache;\n    }\n\n    /**\n     * @notice Sets address of companion L1LPTGateway\n     * @dev Only address with the governor role is allowed to change the value of l1Counterpart\n     * @param _l1Counterpart L1 Address of the counterpart\n     */\n    function setCounterpart(address _l1Counterpart)\n        external\n        onlyRole(GOVERNOR_ROLE)\n    {\n        l1Counterpart = _l1Counterpart;\n    }\n\n    /**\n     * @notice Burns L2 tokens and sends a message to L1\n     * The tokens will be received on L1 only after the wait period (7 days) is over\n     * @dev no additional callhook data is allowed\n     * @param _l1Token L1 Address of LPT\n     * @param _to Recepient address on L1\n     * @param _amount Amount of tokens to burn\n     * @param _data Contains sender and additional data to send to L1\n     * @return res ID of the withdraw tx\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public override whenNotPaused returns (bytes memory res) {\n        require(_l1Token == l1Lpt, \"TOKEN_NOT_LPT\");\n\n        (address from, bytes memory extraData) = parseOutboundData(_data);\n        require(extraData.length == 0, \"CALL_HOOK_DATA_NOT_ALLOWED\");\n\n        Mintable(l2Lpt).burn(from, _amount);\n        IL2LPTDataCache(l2LPTDataCache).decreaseL2SupplyFromL1(_amount);\n\n        uint256 id = sendTxToL1(\n            from,\n            l1Counterpart,\n            getOutboundCalldata(_l1Token, from, _to, _amount, extraData)\n        );\n\n        // we don't need to track exitNums (b/c we have no fast exits) so we always use 0\n        emit WithdrawalInitiated(_l1Token, from, _to, id, 0, _amount);\n\n        return abi.encode(id);\n    }\n\n    /**\n     * @notice Receives token amount from L1 and mints the equivalent tokens to the receiving address\n     * @dev can only accept txs coming directly from L1 LPT Gateway\n     * data param is unused because no additional data is allowed from L1\n     * @param _l1Token L1 Address of LPT\n     * @param _from Address of the sender on L1\n     * @param _to Recepient address on L2\n     * @param _amount Amount of tokens transferred\n     */\n    function finalizeInboundTransfer(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata // data -- unused\n    ) external override onlyL1Counterpart(l1Counterpart) {\n        require(_l1Token == l1Lpt, \"TOKEN_NOT_LPT\");\n\n        Mintable(l2Lpt).mint(_to, _amount);\n        IL2LPTDataCache(l2LPTDataCache).increaseL2SupplyFromL1(_amount);\n\n        emit DepositFinalized(_l1Token, _from, _to, _amount);\n    }\n\n    /**\n     * @notice Decodes calldata required for migration of tokens\n     * @dev extraData can be left empty\n     * @param data Encoded callhook data\n     * @return from Sender of the tx\n     * @return extraData Any other data sent to L1\n     */\n    function parseOutboundData(bytes memory data)\n        internal\n        view\n        returns (address from, bytes memory extraData)\n    {\n        if (msg.sender == l2Router) {\n            (from, extraData) = abi.decode(data, (address, bytes));\n        } else {\n            from = msg.sender;\n            extraData = data;\n        }\n    }\n\n    /**\n     * @notice returns address of L1 LPT Gateway\n     */\n    function counterpartGateway() external view override returns (address) {\n        return l1Counterpart;\n    }\n\n    /**\n     * @notice returns address of L2 version of LPT\n     */\n    function calculateL2TokenAddress(address l1Token)\n        external\n        view\n        override\n        returns (address)\n    {\n        if (l1Token != l1Lpt) {\n            return address(0);\n        }\n\n        return l2Lpt;\n    }\n\n    /**\n     * @notice Creates calldata required to send tx to L1\n     * @dev encodes the target function with its params which\n     * will be called on L1 when the message is received on L1\n     */\n    function getOutboundCalldata(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data\n    ) public pure returns (bytes memory outboundCalldata) {\n        outboundCalldata = abi.encodeWithSelector(\n            IL1LPTGateway.finalizeInboundTransfer.selector,\n            token,\n            from,\n            to,\n            amount,\n            abi.encode(0, data) // we don't need to track exitNums (b/c we have no fast exits) so we always use 0\n        );\n\n        return outboundCalldata;\n    }\n}"
    },
    {
      "filename": "contracts/l2/L2DaiGateway.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.11;\n\nimport \"./L2ITokenGateway.sol\";\nimport \"../l1/L1ITokenGateway.sol\";\nimport \"./L2CrossDomainEnabled.sol\";\n\ninterface Mintable {\n  function mint(address usr, uint256 wad) external;\n\n  function burn(address usr, uint256 wad) external;\n}\n\ncontract L2DaiGateway is L2CrossDomainEnabled, L2ITokenGateway {\n  // --- Auth ---\n  mapping(address => uint256) public wards;\n\n  function rely(address usr) external auth {\n    wards[usr] = 1;\n    emit Rely(usr);\n  }\n\n  function deny(address usr) external auth {\n    wards[usr] = 0;\n    emit Deny(usr);\n  }\n\n  modifier auth() {\n    require(wards[msg.sender] == 1, \"L2DaiGateway/not-authorized\");\n    _;\n  }\n\n  event Rely(address indexed usr);\n  event Deny(address indexed usr);\n\n  address public immutable l1Dai;\n  address public immutable l2Dai;\n  address public immutable l1Counterpart;\n  address public immutable l2Router;\n  uint256 public isOpen = 1;\n\n  event Closed();\n\n  constructor(\n    address _l1Counterpart,\n    address _l2Router,\n    address _l1Dai,\n    address _l2Dai\n  ) public {\n    wards[msg.sender] = 1;\n    emit Rely(msg.sender);\n\n    l1Dai = _l1Dai;\n    l2Dai = _l2Dai;\n    l1Counterpart = _l1Counterpart;\n    l2Router = _l2Router;\n  }\n\n  function close() external auth {\n    isOpen = 0;\n\n    emit Closed();\n  }\n\n  function outboundTransfer(\n    address l1Token,\n    address to,\n    uint256 amount,\n    bytes calldata data\n  ) external returns (bytes memory) {\n    return outboundTransfer(l1Token, to, amount, 0, 0, data);\n  }\n\n  function outboundTransfer(\n    address l1Token,\n    address to,\n    uint256 amount,\n    uint256, // maxGas\n    uint256, // gasPriceBid\n    bytes calldata data\n  ) public override returns (bytes memory res) {\n    require(isOpen == 1, \"L2DaiGateway/closed\");\n    require(l1Token == l1Dai, \"L2DaiGateway/token-not-dai\");\n\n    (address from, bytes memory extraData) = parseOutboundData(data);\n    require(extraData.length == 0, \"L2DaiGateway/call-hook-data-not-allowed\");\n\n    Mintable(l2Dai).burn(from, amount);\n\n    uint256 id = sendTxToL1(\n      from,\n      l1Counterpart,\n      getOutboundCalldata(l1Token, from, to, amount, extraData)\n    );\n\n    // we don't need to track exitNums (b/c we have no fast exits) so we always use 0\n    emit WithdrawalInitiated(l1Token, from, to, id, 0, amount);\n\n    return abi.encode(id);\n  }\n\n  function getOutboundCalldata(\n    address token,\n    address from,\n    address to,\n    uint256 amount,\n    bytes memory data\n  ) public pure returns (bytes memory outboundCalldata) {\n    outboundCalldata = abi.encodeWithSelector(\n      L1ITokenGateway.finalizeInboundTransfer.selector,\n      token,\n      from,\n      to,\n      amount,\n      abi.encode(0, data) // we don't need to track exitNums (b/c we have no fast exits) so we always use 0\n    );\n\n    return outboundCalldata;\n  }\n\n  function finalizeInboundTransfer(\n    address l1Token,\n    address from,\n    address to,\n    uint256 amount,\n    bytes calldata // data -- unsused\n  ) external override onlyL1Counterpart(l1Counterpart) {\n    require(l1Token == l1Dai, \"L2DaiGateway/token-not-dai\");\n\n    Mintable(l2Dai).mint(to, amount);\n\n    emit DepositFinalized(l1Token, from, to, amount);\n  }\n\n  function calculateL2TokenAddress(address l1Token) external view override returns (address) {\n    if (l1Token != l1Dai) {\n      return address(0);\n    }\n\n    return l2Dai;\n  }\n\n  function parseOutboundData(bytes memory data)\n    internal\n    view\n    returns (address from, bytes memory extraData)\n  {\n    if (msg.sender == l2Router) {\n      (from, extraData) = abi.decode(data, (address, bytes));\n    } else {\n      from = msg.sender;\n      extraData = data;\n    }\n  }\n\n  function counterpartGateway() external view override returns (address) {\n    return l1Counterpart;\n  }\n}"
    }
  ]
}