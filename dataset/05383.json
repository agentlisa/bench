{
  "Title": "[10] `ECDSA.recover` over `ecrecover`",
  "Content": "One of the most critical aspects to note about `ecrecover` is its vulnerability to malleable signatures. This means that a valid signature can be transformed into a different valid signature without needing access to the private key. Where possible, adopt `ECDSA.recover` as commented by the imported `EIP712Upgradeable` in CultureIndex.sol.\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/utils/cryptography/EIP712Upgradeable.sol#L93-L110\n\n```solidity\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n``` \nHere's a specific instance entailed:\n\nhttps://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/CultureIndex.sol#L435\n\n```solidity\n        address recoveredAddress = ecrecover(digest, v, r, s);\n```\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "contracts/utils/cryptography/EIP712Upgradeable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {IERC5267} from \"@openzeppelin/contracts/interfaces/IERC5267.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP-712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP-712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267 {\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.EIP712\n    struct EIP712Storage {\n        /// @custom:oz-renamed-from _HASHED_NAME\n        bytes32 _hashedName;\n        /// @custom:oz-renamed-from _HASHED_VERSION\n        bytes32 _hashedVersion;\n\n        string _name;\n        string _version;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.EIP712\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP-712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n\n        // Reset prior values in storage if upgrading\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require($._hashedName == 0 && $._hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/CultureIndex.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\nimport { ERC20VotesUpgradeable } from \"./base/erc20/ERC20VotesUpgradeable.sol\";\nimport { MaxHeap } from \"./MaxHeap.sol\";\nimport { ICultureIndex } from \"./interfaces/ICultureIndex.sol\";\n\nimport { ERC721CheckpointableUpgradeable } from \"./base/ERC721CheckpointableUpgradeable.sol\";\nimport { EIP712Upgradeable } from \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract CultureIndex is\n    ICultureIndex,\n    VersionedContract,\n    UUPS,\n    Ownable2StepUpgradeable,\n    ReentrancyGuardUpgradeable,\n    EIP712Upgradeable\n{\n    /// @notice The EIP-712 typehash for gasless votes\n    bytes32 public constant VOTE_TYPEHASH =\n        keccak256(\"Vote(address from,uint256[] pieceIds,uint256 nonce,uint256 deadline)\");\n\n    /// @notice An account's nonce for gasless votes\n    mapping(address => uint256) public nonces;\n\n    // The MaxHeap data structure used to keep track of the top-voted piece\n    MaxHeap public maxHeap;\n\n    // The ERC20 token used for voting\n    ERC20VotesUpgradeable public erc20VotingToken;\n\n    // The ERC721 token used for voting\n    ERC721CheckpointableUpgradeable public erc721VotingToken;\n\n    // The weight of the 721 voting token\n    uint256 public erc721VotingTokenWeight;\n\n    /// @notice The maximum settable quorum votes basis points\n    uint256 public constant MAX_QUORUM_VOTES_BPS = 6_000; // 6,000 basis points or 60%\n\n    /// @notice The minimum vote weight required in order to vote\n    uint256 public minVoteWeight;\n\n    /// @notice The basis point number of votes in support of a art piece required in order for a quorum to be reached and for an art piece to be dropped.\n    uint256 public quorumVotesBPS;\n\n    /// @notice The name of the culture index\n    string public name;\n\n    /// @notice A description of the culture index - can include rules or guidelines\n    string public description;\n\n    // The list of all pieces\n    mapping(uint256 => ArtPiece) public pieces;\n\n    // The internal piece ID tracker\n    uint256 public _currentPieceId;\n\n    // The mapping of all votes for a piece\n    mapping(uint256 => mapping(address => Vote)) public votes;\n\n    // The total voting weight for a piece\n    mapping(uint256 => uint256) public totalVoteWeights;\n\n    // Constant for max number of creators\n    uint256 public constant MAX_NUM_CREATORS = 100;\n\n    // The address that is allowed to drop art pieces\n    address public dropperAdmin;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initializes a token's metadata descriptor\n     * @param _erc20VotingToken The address of the ERC20 voting token, commonly referred to as \"points\"\n     * @param _erc721VotingToken The address of the ERC721 voting token, commonly the dropped art pieces\n     * @param _initialOwner The owner of the contract, allowed to drop pieces. Commonly updated to the AuctionHouse\n     * @param _maxHeap The address of the max heap contract\n     * @param _dropperAdmin The address that can drop new art pieces\n     * @param _cultureIndexParams The CultureIndex settings\n     */\n    function initialize(\n        address _erc20VotingToken,\n        address _erc721VotingToken,\n        address _initialOwner,\n        address _maxHeap,\n        address _dropperAdmin,\n        IRevolutionBuilder.CultureIndexParams memory _cultureIndexParams\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        require(_cultureIndexParams.quorumVotesBPS <= MAX_QUORUM_VOTES_BPS, \"invalid quorum bps\");\n        require(_cultureIndexParams.erc721VotingTokenWeight > 0, \"invalid erc721 voting token weight\");\n        require(_erc721VotingToken != address(0), \"invalid erc721 voting token\");\n        require(_erc20VotingToken != address(0), \"invalid erc20 voting token\");\n\n        // Setup ownable\n        __Ownable_init(_initialOwner);\n\n        // Initialize EIP-712 support\n        __EIP712_init(string.concat(_cultureIndexParams.name, \" CultureIndex\"), \"1\");\n\n        __ReentrancyGuard_init();\n\n        erc20VotingToken = ERC20VotesUpgradeable(_erc20VotingToken);\n        erc721VotingToken = ERC721CheckpointableUpgradeable(_erc721VotingToken);\n        erc721VotingTokenWeight = _cultureIndexParams.erc721VotingTokenWeight;\n        name = _cultureIndexParams.name;\n        description = _cultureIndexParams.description;\n        quorumVotesBPS = _cultureIndexParams.quorumVotesBPS;\n        minVoteWeight = _cultureIndexParams.minVoteWeight;\n        dropperAdmin = _dropperAdmin;\n\n        emit QuorumVotesBPSSet(quorumVotesBPS, _cultureIndexParams.quorumVotesBPS);\n\n        // Create maxHeap\n        maxHeap = MaxHeap(_maxHeap);\n    }\n\n    ///                                                          ///\n    ///                         MODIFIERS                        ///\n    ///                                                          ///\n\n    /**\n     *  Validates the media type and associated data.\n     * @param metadata The metadata associated with the art piece.\n     *\n     * Requirements:\n     * - The media type must be one of the defined types in the MediaType enum.\n     * - The corresponding media data must not be empty.\n     */\n    function validateMediaType(ArtPieceMetadata calldata metadata) internal pure {\n        require(uint8(metadata.mediaType) > 0 && uint8(metadata.mediaType) <= 5, \"Invalid media type\");\n\n        if (metadata.mediaType == MediaType.IMAGE)\n            require(bytes(metadata.image).length > 0, \"Image URL must be provided\");\n        else if (metadata.mediaType == MediaType.ANIMATION)\n            require(bytes(metadata.animationUrl).length > 0, \"Animation URL must be provided\");\n        else if (metadata.mediaType == MediaType.TEXT)\n            require(bytes(metadata.text).length > 0, \"Text must be provided\");\n    }\n\n    /**\n     * @notice Checks the total basis points from an array of creators and returns the length\n     * @param creatorArray An array of Creator structs containing address and basis points.\n     * @return Returns the total basis points calculated from the array of creators.\n     *\n     * Requirements:\n     * - The `creatorArray` must not contain any zero addresses.\n     * - The function will return the length of the `creatorArray`.\n     */\n    function validateCreatorsArray(CreatorBps[] calldata creatorArray) internal pure returns (uint256) {\n        uint256 creatorArrayLength = creatorArray.length;\n        //Require that creatorArray is not more than MAX_NUM_CREATORS to prevent gas limit issues\n        require(creatorArrayLength <= MAX_NUM_CREATORS, \"Creator array must not be > MAX_NUM_CREATORS\");\n\n        uint256 totalBps;\n        for (uint i; i < creatorArrayLength; i++) {\n            require(creatorArray[i].creator != address(0), \"Invalid creator address\");\n            totalBps += creatorArray[i].bps;\n        }\n\n        require(totalBps == 10_000, \"Total BPS must sum up to 10,000\");\n\n        return creatorArrayLength;\n    }\n\n    /**\n     * @notice Creates a new piece of art with associated metadata and creators.\n     * @param metadata The metadata associated with the art piece, including name, description, image, and optional animation URL.\n     * @param creatorArray An array of creators who contributed to the piece, along with their respective basis points that must sum up to 10,000.\n     * @return Returns the unique ID of the newly created art piece.\n     *\n     * Emits a {PieceCreated} event for the newly created piece.\n     * Emits a {PieceCreatorAdded} event for each creator added to the piece.\n     *\n     * Requirements:\n     * - `metadata` must include name, description, and image. Animation URL is optional.\n     * - `creatorArray` must not contain any zero addresses.\n     * - The sum of basis points in `creatorArray` must be exactly 10,000.\n     */\n    function createPiece(\n        ArtPieceMetadata calldata metadata,\n        CreatorBps[] calldata creatorArray\n    ) public returns (uint256) {\n        uint256 creatorArrayLength = validateCreatorsArray(creatorArray);\n\n        // Validate the media type and associated data\n        validateMediaType(metadata);\n\n        uint256 pieceId = _currentPieceId++;\n\n        /// @dev Insert the new piece into the max heap\n        maxHeap.insert(pieceId, 0);\n\n        ArtPiece storage newPiece = pieces[pieceId];\n\n        newPiece.pieceId = pieceId;\n        newPiece.totalVotesSupply = _calculateVoteWeight(\n            erc20VotingToken.totalSupply(),\n            erc721VotingToken.totalSupply()\n        );\n        newPiece.totalERC20Supply = erc20VotingToken.totalSupply();\n        newPiece.metadata = metadata;\n        newPiece.sponsor = msg.sender;\n        newPiece.creationBlock = block.number;\n        newPiece.quorumVotes = (quorumVotesBPS * newPiece.totalVotesSupply) / 10_000;\n\n        for (uint i; i < creatorArrayLength; i++) {\n            newPiece.creators.push(creatorArray[i]);\n        }\n\n        emit PieceCreated(pieceId, msg.sender, metadata, newPiece.quorumVotes, newPiece.totalVotesSupply);\n\n        // Emit an event for each creator\n        for (uint i; i < creatorArrayLength; i++) {\n            emit PieceCreatorAdded(pieceId, creatorArray[i].creator, msg.sender, creatorArray[i].bps);\n        }\n\n        return newPiece.pieceId;\n    }\n\n    /**\n     * @notice Checks if a specific voter has already voted for a given art piece.\n     * @param pieceId The ID of the art piece.\n     * @param voter The address of the voter.\n     * @return A boolean indicating if the voter has voted for the art piece.\n     */\n    function hasVoted(uint256 pieceId, address voter) external view returns (bool) {\n        return votes[pieceId][voter].voterAddress != address(0);\n    }\n\n    /**\n     * @notice Returns the voting power of a voter at the current block.\n     * @param account The address of the voter.\n     * @return The voting power of the voter.\n     */\n    function getVotes(address account) external view override returns (uint256) {\n        return _getVotes(account);\n    }\n\n    /**\n     * @notice Returns the voting power of a voter at the current block.\n     * @param account The address of the voter.\n     * @return The voting power of the voter.\n     */\n    function getPastVotes(address account, uint256 blockNumber) external view override returns (uint256) {\n        return _getPastVotes(account, blockNumber);\n    }\n\n    /**\n     * @notice Calculates the vote weight of a voter.\n     * @param erc20Balance The ERC20 balance of the voter.\n     * @param erc721Balance The ERC721 balance of the voter.\n     * @return The vote weight of the voter.\n     */\n    function _calculateVoteWeight(uint256 erc20Balance, uint256 erc721Balance) internal view returns (uint256) {\n        return erc20Balance + (erc721Balance * erc721VotingTokenWeight * 1e18);\n    }\n\n    function _getVotes(address account) internal view returns (uint256) {\n        return _calculateVoteWeight(erc20VotingToken.getVotes(account), erc721VotingToken.getVotes(account));\n    }\n\n    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256) {\n        return\n            _calculateVoteWeight(\n                erc20VotingToken.getPastVotes(account, blockNumber),\n                erc721VotingToken.getPastVotes(account, blockNumber)\n            );\n    }\n\n    /**\n     * @notice Cast a vote for a specific ArtPiece.\n     * @param pieceId The ID of the ArtPiece to vote for.\n     * @param voter The address of the voter.\n     * @dev Requires that the pieceId is valid, the voter has not already voted on this piece, and the weight is greater than the minimum vote weight.\n     * Emits a VoteCast event upon successful execution.\n     */\n    function _vote(uint256 pieceId, address voter) internal {\n        require(pieceId < _currentPieceId, \"Invalid piece ID\");\n        require(voter != address(0), \"Invalid voter address\");\n        require(!pieces[pieceId].isDropped, \"Piece has already been dropped\");\n        require(!(votes[pieceId][voter].voterAddress != address(0)), \"Already voted\");\n\n        uint256 weight = _getPastVotes(voter, pieces[pieceId].creationBlock);\n        require(weight > minVoteWeight, \"Weight must be greater than minVoteWeight\");\n\n        votes[pieceId][voter] = Vote(voter, weight);\n        totalVoteWeights[pieceId] += weight;\n\n        uint256 totalWeight = totalVoteWeights[pieceId];\n\n        // TODO add security consideration here based on block created to prevent flash attacks on drops?\n        maxHeap.updateValue(pieceId, totalWeight);\n        emit VoteCast(pieceId, voter, weight, totalWeight);\n    }\n\n    /**\n     * @notice Cast a vote for a specific ArtPiece.\n     * @param pieceId The ID of the ArtPiece to vote for.\n     * @dev Requires that the pieceId is valid, the voter has not already voted on this piece, and the weight is greater than the minimum vote weight.\n     * Emits a VoteCast event upon successful execution.\n     */\n    function vote(uint256 pieceId) public nonReentrant {\n        _vote(pieceId, msg.sender);\n    }\n\n    /**\n     * @notice Cast a vote for a list of ArtPieces.\n     * @param pieceIds The IDs of the ArtPieces to vote for.\n     * @dev Requires that the pieceIds are valid, the voter has not already voted on this piece, and the weight is greater than the minimum vote weight.\n     * Emits a series of VoteCast event upon successful execution.\n     */\n    function voteForMany(uint256[] calldata pieceIds) public nonReentrant {\n        _voteForMany(pieceIds, msg.sender);\n    }\n\n    /**\n     * @notice Cast a vote for a list of ArtPieces pieceIds.\n     * @param pieceIds The IDs of the ArtPieces to vote for.\n     * @param from The address of the voter.\n     * @dev Requires that the pieceIds are valid, the voter has not already voted on this piece, and the weight is greater than the minimum vote weight.\n     * Emits a series of VoteCast event upon successful execution.\n     */\n    function _voteForMany(uint256[] calldata pieceIds, address from) internal {\n        uint256 len = pieceIds.length;\n        for (uint256 i; i < len; i++) {\n            _vote(pieceIds[i], from);\n        }\n    }\n\n    /// @notice Execute a vote via signature\n    /// @param from Vote from this address\n    /// @param pieceIds Vote on this list of pieceIds\n    /// @param deadline Deadline for the signature to be valid\n    /// @param v V component of signature\n    /// @param r R component of signature\n    /// @param s S component of signature\n    function voteForManyWithSig(\n        address from,\n        uint256[] calldata pieceIds,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant {\n        bool success = _verifyVoteSignature(from, pieceIds, deadline, v, r, s);\n\n        if (!success) revert INVALID_SIGNATURE();\n\n        _voteForMany(pieceIds, from);\n    }\n\n    /// @notice Execute a batch of votes via signature, each with their own signature\n    /// @param from Vote from these addresses\n    /// @param pieceIds Vote on these lists of pieceIds\n    /// @param deadline Deadlines for the signature to be valid\n    /// @param v V component of signatures\n    /// @param r R component of signatures\n    /// @param s S component of signatures\n    function batchVoteForManyWithSig(\n        address[] memory from,\n        uint256[][] calldata pieceIds,\n        uint256[] memory deadline,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    ) external nonReentrant {\n        uint256 len = from.length;\n        require(\n            len == pieceIds.length && len == deadline.length && len == v.length && len == r.length && len == s.length,\n            \"Array lengths must match\"\n        );\n\n        for (uint256 i; i < len; i++) {\n            if (!_verifyVoteSignature(from[i], pieceIds[i], deadline[i], v[i], r[i], s[i])) revert INVALID_SIGNATURE();\n        }\n\n        for (uint256 i; i < len; i++) {\n            _voteForMany(pieceIds[i], from[i]);\n        }\n    }\n\n    /// @notice Utility function to verify a signature for a specific vote\n    /// @param from Vote from this address\n    /// @param pieceIds Vote on this pieceId\n    /// @param deadline Deadline for the signature to be valid\n    /// @param v V component of signature\n    /// @param r R component of signature\n    /// @param s S component of signature\n    function _verifyVoteSignature(\n        address from,\n        uint256[] calldata pieceIds,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal returns (bool success) {\n        require(deadline >= block.timestamp, \"Signature expired\");\n\n        bytes32 voteHash;\n\n        voteHash = keccak256(abi.encode(VOTE_TYPEHASH, from, pieceIds, nonces[from]++, deadline));\n\n        bytes32 digest = _hashTypedDataV4(voteHash);\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n\n        // Ensure to address is not 0\n        if (from == address(0)) revert ADDRESS_ZERO();\n\n        // Ensure signature is valid\n        if (recoveredAddress == address(0) || recoveredAddress != from) revert INVALID_SIGNATURE();\n\n        return true;\n    }\n\n    /**\n     * @notice Fetch an art piece by its ID.\n     * @param pieceId The ID of the art piece.\n     * @return The ArtPiece struct associated with the given ID.\n     */\n    function getPieceById(uint256 pieceId) public view returns (ArtPiece memory) {\n        require(pieceId < _currentPieceId, \"Invalid piece ID\");\n        return pieces[pieceId];\n    }\n\n    /**\n     * @notice Fetch the list of votes for a given art piece.\n     * @param pieceId The ID of the art piece.\n     * @return An array of Vote structs for the given art piece ID.\n     */\n    function getVote(uint256 pieceId, address voter) public view returns (Vote memory) {\n        require(pieceId < _currentPieceId, \"Invalid piece ID\");\n        return votes[pieceId][voter];\n    }\n\n    /**\n     * @notice Fetch the top-voted art piece.\n     * @return The ArtPiece struct of the top-voted art piece.\n     */\n    function getTopVotedPiece() public view returns (ArtPiece memory) {\n        return pieces[topVotedPieceId()];\n    }\n\n    /**\n     * @notice Fetch the number of pieces\n     * @return The number of pieces\n     */\n    function pieceCount() external view returns (uint256) {\n        return _currentPieceId;\n    }\n\n    /**\n     * @notice Fetch the top-voted pieceId\n     * @return The top-voted pieceId\n     */\n    function topVotedPieceId() public view returns (uint256) {\n        require(maxHeap.size() > 0, \"Culture index is empty\");\n        //slither-disable-next-line unused-return\n        (uint256 pieceId, ) = maxHeap.getMax();\n        return pieceId;\n    }\n\n    /**\n     * @notice Admin function for setting the quorum votes basis points\n     * @dev newQuorumVotesBPS must be greater than the hardcoded min\n     * @param newQuorumVotesBPS new art piece drop threshold\n     */\n    function _setQuorumVotesBPS(uint256 newQuorumVotesBPS) external onlyOwner {\n        require(newQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS, \"CultureIndex::_setQuorumVotesBPS: invalid quorum bps\");\n        emit QuorumVotesBPSSet(quorumVotesBPS, newQuorumVotesBPS);\n\n        quorumVotesBPS = newQuorumVotesBPS;\n    }\n\n    /**\n     * @notice Current quorum votes using ERC721 Total Supply, ERC721 Vote Weight, and ERC20 Total Supply\n     * Differs from `GovernerBravo` which uses fixed amount\n     */\n    function quorumVotes() public view returns (uint256) {\n        return\n            (quorumVotesBPS * _calculateVoteWeight(erc20VotingToken.totalSupply(), erc721VotingToken.totalSupply())) /\n            10_000;\n    }\n\n    /**\n     * @notice Pulls and drops the top-voted piece.\n     * @return The top voted piece\n     */\n    function dropTopVotedPiece() public nonReentrant returns (ArtPiece memory) {\n        require(msg.sender == dropperAdmin, \"Only dropper can drop pieces\");\n\n        ICultureIndex.ArtPiece memory piece = getTopVotedPiece();\n        require(totalVoteWeights[piece.pieceId] >= piece.quorumVotes, \"Does not meet quorum votes to be dropped.\");\n\n        //set the piece as dropped\n        pieces[piece.pieceId].isDropped = true;\n\n        //slither-disable-next-line unused-return\n        maxHeap.extractMax();\n\n        emit PieceDropped(piece.pieceId, msg.sender);\n\n        return pieces[piece.pieceId];\n    }\n\n    ///                                                          ///\n    ///                   CULTURE INDEX UPGRADE                  ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    }
  ]
}