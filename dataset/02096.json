{
  "Title": "M-11: Positions can still be liquidated even if orders to prevent it can't execute",
  "Content": "# Issue M-11: Positions can still be liquidated even if orders to prevent it can't execute \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/168 \n\n## Found by \nIllIllI\n\n## Summary\n\nPositions can still be liquidated even if orders to close positions or add collateral can't execute, because liquidation does not transfer tokens\n\n\n## Vulnerability Detail\n\nLiquidation orders do not transfer tokens - they just use the `increment*()`/`applyDelta*()` functions to update the portions allotted to the various parties. Orders to close positions, on the other hand, actually transfer the tokens so if the transfer reverts, the position can't be closed. If the collateral token is paused (e.g. USDC), a user won't be able to close their position, or add collateral to it, in order to prevent it from being liquidated, but the liquidation keeper will be able to liquidate without any issue.\n\n\n## Impact\n\nUsers will be liquidated without being able to prevent it\n\n\n## Code Snippet\n\nLiquidation doesn't actually transfer any funds - it just updates who got what:\n```solidity\n// File: gmx-synthetics/contracts/position/DecreasePositionCollateralUtils.sol : DecreasePositionCollateralUtils.getLiquidationValues()   #1\n\n346            } else {\n347 @>             values.pnlAmountForPool = (params.position.collateralAmount() - fees.funding.fundingFeeAmount).toInt256();\n348            }\n349    \n350            PositionPricingUtils.PositionFees memory _fees;\n351    \n352            PositionUtils.DecreasePositionCollateralValues memory _values = PositionUtils.DecreasePositionCollateralValues(\n353                values.pnlTokenForPool,\n354 @>             values.executionPrice, // executionPrice\n355                0, // remainingCollateralAmount\n356                values.positionPnlUsd, // positionPnlUsd\n357                values.pnlAmountForPool, // pnlAmountForPool\n358                0, // pnlAmountForUser\n359                values.sizeDeltaInTokens, // sizeDeltaInTokens\n360                values.priceImpactAmount, // priceImpactAmount\n361                0, // priceImpactDiffUsd\n362                0, // priceImpactDiffAmount\n363                PositionUtils.DecreasePositionCollateralValuesOutput(\n364:                   address(0),\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/position/DecreasePositionCollateralUtils.sol#L344-L364\n\nAnd then [increments](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/position/DecreasePositionUtils.sol#L198)/[applies delta](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/position/DecreasePositionUtils.sol#L230-L259) to the accounting.\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nKeep user collateral at a separate address from the pool address, so that liquidations have to do an actual transfer which may revert, rather than just updating internal accounting\n\n\n\n## Discussion\n\n**xvi10**\n\nThis should be a very rare case, we believe that it may not make sense to force doing a transfer to handle this case, liquidations should instead be manually disabled if this were to happen, it may also be possible to do this automatically with a contract function that anyone can invoke and if transfers are verified to not be working then the contract has access to disable liquidations for that market, for the current scope this feature will not be added \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/position/DecreasePositionCollateralUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Precision.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../pricing/PositionPricingUtils.sol\";\n\nimport \"./Position.sol\";\nimport \"./PositionEventUtils.sol\";\nimport \"./PositionStoreUtils.sol\";\nimport \"./PositionUtils.sol\";\nimport \"../order/BaseOrderUtils.sol\";\nimport \"../order/OrderEventUtils.sol\";\n\nimport \"../swap/SwapUtils.sol\";\n\n// @title DecreasePositionCollateralUtils\n// @dev Library for functions to help with the calculations when decreasing a position\nlibrary DecreasePositionCollateralUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    error InsufficientCollateral(int256 remainingCollateralAmount);\n    error InvalidOutputToken(address tokenOut, address expectedTokenOut);\n\n    struct ProcessCollateralCache {\n        int256 adjustedPositionPnlUsd;\n        uint256 adjustedPriceImpactDiffUsd;\n        uint256 adjustedPriceImpactDiffAmount;\n        uint256 pnlDiffAmount;\n    }\n\n    // @dev handle the collateral changes of the position\n    // @param params PositionUtils.UpdatePositionParams\n    // @param cache DecreasePositionCache\n    // @return (PositionUtils.DecreasePositionCollateralValues, PositionPricingUtils.PositionFees)\n    function processCollateral(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionUtils.DecreasePositionCache memory cache\n    ) external returns (\n        PositionUtils.DecreasePositionCollateralValues memory,\n        PositionPricingUtils.PositionFees memory\n    ) {\n        ProcessCollateralCache memory collateralCache;\n        PositionUtils.DecreasePositionCollateralValues memory values;\n        values.remainingCollateralAmount = cache.initialCollateralAmount.toInt256();\n\n        Price.Props memory collateralTokenPrice = MarketUtils.getCachedTokenPrice(params.order.initialCollateralToken(), params.market, cache.prices);\n\n        (values.executionPrice, values.priceImpactAmount, values.priceImpactDiffUsd) = getExecutionPrice(params, cache.prices, params.order.sizeDeltaUsd());\n\n        (values.positionPnlUsd, values.sizeDeltaInTokens) = PositionUtils.getPositionPnlUsd(\n            params.contracts.dataStore,\n            params.market,\n            cache.prices,\n            params.position,\n            values.executionPrice,\n            params.order.sizeDeltaUsd()\n        );\n\n        collateralCache.adjustedPositionPnlUsd = values.positionPnlUsd;\n        collateralCache.adjustedPriceImpactDiffUsd = values.priceImpactDiffUsd;\n\n        if (values.positionPnlUsd > 0 && values.priceImpactDiffUsd > 0) {\n            if (values.positionPnlUsd > values.priceImpactDiffUsd.toInt256()) {\n                collateralCache.adjustedPositionPnlUsd = values.positionPnlUsd - values.priceImpactDiffUsd.toInt256();\n                collateralCache.adjustedPriceImpactDiffUsd = 0;\n            } else {\n                collateralCache.adjustedPositionPnlUsd = 0;\n                collateralCache.adjustedPriceImpactDiffUsd = values.priceImpactDiffUsd - values.positionPnlUsd.toUint256();\n            }\n        }\n\n        collateralCache.adjustedPriceImpactDiffAmount = collateralCache.adjustedPriceImpactDiffUsd / collateralTokenPrice.max;\n\n        if (collateralCache.adjustedPriceImpactDiffUsd > 0 && params.order.initialCollateralDeltaAmount() > 0) {\n            uint256 initialCollateralDeltaAmount = params.order.initialCollateralDeltaAmount();\n\n            if (collateralCache.adjustedPriceImpactDiffAmount > params.order.initialCollateralDeltaAmount()) {\n                params.order.setInitialCollateralDeltaAmount(0);\n            } else {\n                params.order.setInitialCollateralDeltaAmount(params.order.initialCollateralDeltaAmount() - collateralCache.adjustedPriceImpactDiffAmount);\n            }\n\n            OrderEventUtils.emitOrderCollateralDeltaAmountAutoUpdated(\n                params.contracts.eventEmitter,\n                params.orderKey,\n                initialCollateralDeltaAmount,\n                params.order.initialCollateralDeltaAmount()\n            );\n        }\n\n        values.remainingCollateralAmount -= params.order.initialCollateralDeltaAmount().toInt256();\n        values.output.outputToken = params.position.collateralToken();\n        values.output.outputAmount = params.order.initialCollateralDeltaAmount();\n        values.output.secondaryOutputToken = cache.pnlToken;\n\n        if (collateralCache.adjustedPositionPnlUsd < 0) {\n            // position realizes a loss\n            // deduct collateral from user, transfer it to the pool\n            values.pnlTokenForPool = params.position.collateralToken();\n            values.pnlAmountForPool = -values.positionPnlUsd / collateralTokenPrice.min.toInt256();\n            values.remainingCollateralAmount -= values.pnlAmountForPool;\n        } else {\n            // position realizes a profit\n            // deduct the pnl from the pool\n            values.pnlTokenForPool = cache.pnlToken;\n            values.pnlAmountForPool = -values.positionPnlUsd / cache.pnlTokenPrice.max.toInt256();\n            values.pnlAmountForUser = collateralCache.adjustedPositionPnlUsd.toUint256() / cache.pnlTokenPrice.max;\n\n            // if the price impact was capped send the difference to a holding area\n            collateralCache.pnlDiffAmount = (-values.pnlAmountForPool - values.pnlAmountForUser.toInt256()).toUint256();\n            if (collateralCache.pnlDiffAmount > 0) {\n                MarketUtils.incrementClaimableCollateralAmount(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.market.marketToken,\n                    cache.pnlToken,\n                    params.order.receiver(),\n                    collateralCache.pnlDiffAmount\n                );\n            }\n\n            // swap profit to the collateral token here so that the profit can be used\n            // to pay for the totalNetCostAmount from the fees\n            (bool wasSwapped, uint256 swapOutputAmount) = swapProfitToCollateralToken(\n                params,\n                cache.pnlToken,\n                values.pnlAmountForUser\n            );\n\n            if (wasSwapped) {\n                values.output.outputAmount += swapOutputAmount;\n            } else {\n                if (params.position.collateralToken() == cache.pnlToken) {\n                    values.output.outputAmount += values.pnlAmountForUser;\n                } else {\n                    // store the pnlAmountForUser separately as it differs from the collateralToken\n                    values.output.secondaryOutputAmount = values.pnlAmountForUser;\n                }\n            }\n        }\n\n        PositionPricingUtils.PositionFees memory fees = PositionPricingUtils.getPositionFees(\n            params.contracts.dataStore,\n            params.contracts.referralStorage,\n            params.position,\n            collateralTokenPrice,\n            params.market.longToken,\n            params.market.shortToken,\n            params.order.sizeDeltaUsd()\n        );\n\n        // if there is a positive outputAmount, use the outputAmount to pay for fees and price impact\n        // the values.output.outputToken should be the same as the position.collateralToken at this point\n        if (values.output.outputToken == params.position.collateralToken() && values.output.outputAmount > 0) {\n            if (values.output.outputAmount > fees.totalNetCostAmount) {\n                values.output.outputAmount -= fees.totalNetCostAmount;\n                fees.totalNetCostAmount = 0;\n            } else {\n                fees.totalNetCostAmount -= values.output.outputAmount;\n                values.output.outputAmount = 0;\n            }\n        }\n\n        // deduct remaining fees from the position's collateral\n        values.remainingCollateralAmount -= fees.totalNetCostAmount.toInt256();\n\n        // if there is insufficient collateral remaining then prioritize using the collateral to pay\n        // funding fees, the rest of the collateral is sent to the pool\n        // paying of closing fees should be safe to skip\n        // any difference in the paying of borrowing fees should be accounted for\n        // from the transfer of collateral to the pool and by the update of the\n        // pending borrowing fees\n        // any difference in pending negative PnL should similarly be accounted for\n        // through the transfer fo collateral to the pool and by the update of the\n        // pending pnl\n        // paying of price impact should also be safe to skip, it would be the same as\n        // closing the position with zero price impact, just that if there were any collateral that could\n        // partially pay for negative price impact, it would be sent to the pool instead\n        if (BaseOrderUtils.isLiquidationOrder(params.order.orderType()) && values.remainingCollateralAmount < 0) {\n            PositionPricingUtils.emitPositionFeesInfo(\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.position.collateralToken(),\n                false,\n                fees\n            );\n\n            PositionEventUtils.emitLiquidationInfo(\n                params.contracts.eventEmitter,\n                params.orderKey,\n                params.position.collateralAmount(),\n                values.positionPnlUsd,\n                values.remainingCollateralAmount\n            );\n\n            return getLiquidationValues(params, values, fees);\n        }\n\n        if (values.remainingCollateralAmount < 0) {\n            revert InsufficientCollateral(values.remainingCollateralAmount);\n        }\n\n        // if there is a positive impact, the impact pool amount should be reduced\n        // if there is a negative impact, the impact pool amount should be increased\n        MarketUtils.applyDeltaToPositionImpactPool(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            -values.priceImpactAmount\n        );\n\n        // if the price impact was capped, deduct the difference from the collateral\n        // and send it to a holding area\n        if (collateralCache.adjustedPriceImpactDiffAmount > 0) {\n            if (values.remainingCollateralAmount.toUint256() < collateralCache.adjustedPriceImpactDiffAmount) {\n                collateralCache.adjustedPriceImpactDiffAmount = values.remainingCollateralAmount.toUint256();\n            }\n\n            values.remainingCollateralAmount -= collateralCache.adjustedPriceImpactDiffAmount.toInt256();\n\n            MarketUtils.incrementClaimableCollateralAmount(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.position.collateralToken(),\n                params.order.receiver(),\n                collateralCache.adjustedPriceImpactDiffAmount\n            );\n        }\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            params.position.collateralToken(),\n            fees.feeReceiverAmount,\n            Keys.POSITION_FEE\n        );\n\n        return (values, fees);\n    }\n\n    function getExecutionPrice(\n        PositionUtils.UpdatePositionParams memory params,\n        MarketUtils.MarketPrices memory prices,\n        uint256 sizeDeltaUsd\n    ) internal view returns (uint256, int256, uint256) {\n        int256 priceImpactUsd = PositionPricingUtils.getPriceImpactUsd(\n            PositionPricingUtils.GetPriceImpactUsdParams(\n                params.contracts.dataStore,\n                params.market.marketToken,\n                params.market.indexToken,\n                params.market.longToken,\n                params.market.shortToken,\n                -sizeDeltaUsd.toInt256(),\n                params.order.isLong()\n            )\n        );\n\n        priceImpactUsd = MarketUtils.getCappedPositionImpactUsd(\n            params.contracts.dataStore,\n            params.market.marketToken,\n            prices.indexTokenPrice,\n            priceImpactUsd,\n            sizeDeltaUsd\n        );\n\n        uint256 priceImpactDiffUsd;\n        if (priceImpactUsd < 0) {\n            uint256 maxPriceImpactFactor = MarketUtils.getMaxPositionImpactFactor(\n                params.contracts.dataStore,\n                params.market.marketToken,\n                false\n            );\n\n            // convert the max price impact to the min negative value\n            int256 minPriceImpactUsd = -Precision.applyFactor(sizeDeltaUsd, maxPriceImpactFactor).toInt256();\n\n            if (priceImpactUsd < minPriceImpactUsd) {\n                priceImpactDiffUsd = (minPriceImpactUsd - priceImpactUsd).toUint256();\n                priceImpactUsd = minPriceImpactUsd;\n            }\n        }\n\n        uint256 executionPrice = BaseOrderUtils.getExecutionPrice(\n            params.contracts.oracle.getCustomPrice(params.market.indexToken),\n            sizeDeltaUsd,\n            priceImpactUsd,\n            params.order.acceptablePrice(),\n            params.position.isLong(),\n            false\n        );\n\n        int256 priceImpactAmount = PositionPricingUtils.getPriceImpactAmount(\n            sizeDeltaUsd,\n            executionPrice,\n            prices.indexTokenPrice,\n            params.position.isLong(),\n            false\n        );\n\n        return (executionPrice, priceImpactAmount, priceImpactDiffUsd);\n    }\n\n    function getLiquidationValues(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionUtils.DecreasePositionCollateralValues memory values,\n        PositionPricingUtils.PositionFees memory fees\n    ) internal returns (\n        PositionUtils.DecreasePositionCollateralValues memory,\n        PositionPricingUtils.PositionFees memory\n    ) {\n        if (fees.funding.fundingFeeAmount > params.position.collateralAmount()) {\n            values.pnlAmountForPool = 0;\n            // the case where this is insufficient collateral to pay funding fees\n            // should be rare, and the difference should be small\n            // in case it happens, the pool should be topped up with the required amount using\n            // an insurance fund or similar mechanism\n            PositionEventUtils.emitInsufficientFundingFeePayment(\n                params.contracts.eventEmitter,\n                params.market.marketToken,\n                params.position.collateralToken(),\n                fees.funding.fundingFeeAmount,\n                params.position.collateralAmount()\n            );\n        } else {\n            values.pnlAmountForPool = (params.position.collateralAmount() - fees.funding.fundingFeeAmount).toInt256();\n        }\n\n        PositionPricingUtils.PositionFees memory _fees;\n\n        PositionUtils.DecreasePositionCollateralValues memory _values = PositionUtils.DecreasePositionCollateralValues(\n            values.pnlTokenForPool,\n            values.executionPrice, // executionPrice\n            0, // remainingCollateralAmount\n            values.positionPnlUsd, // positionPnlUsd\n            values.pnlAmountForPool, // pnlAmountForPool\n            0, // pnlAmountForUser\n            values.sizeDeltaInTokens, // sizeDeltaInTokens\n            values.priceImpactAmount, // priceImpactAmount\n            0, // priceImpactDiffUsd\n            0, // priceImpactDiffAmount\n            PositionUtils.DecreasePositionCollateralValuesOutput(\n                address(0),\n                0,\n                address(0),\n                0\n            )\n        );\n\n        return (_values, _fees);\n    }\n\n    // swap the withdrawn collateral from collateralToken to pnlToken if needed\n    function swapWithdrawnCollateralToPnlToken(\n        PositionUtils.UpdatePositionParams memory params,\n        PositionUtils.DecreasePositionCollateralValues memory values\n    ) external returns (PositionUtils.DecreasePositionCollateralValues memory) {\n        if (params.order.decreasePositionSwapType() == Order.DecreasePositionSwapType.SwapCollateralTokenToPnlToken) {\n            Market.Props[] memory swapPathMarkets = new Market.Props[](1);\n            swapPathMarkets[0] = params.market;\n\n            try params.contracts.swapHandler.swap(\n                SwapUtils.SwapParams(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.contracts.oracle,\n                    Bank(payable(params.market.marketToken)),\n                    params.position.collateralToken(), // tokenIn\n                    values.output.outputAmount, // amountIn\n                    swapPathMarkets, // markets\n                    0, // minOutputAmount\n                    params.market.marketToken, // receiver\n                    false // shouldUnwrapNativeToken\n                )\n            ) returns (address tokenOut, uint256 swapOutputAmount) {\n                if (tokenOut != values.output.secondaryOutputToken) {\n                    revert InvalidOutputToken(tokenOut, values.output.secondaryOutputToken);\n                }\n                // combine the values into outputToken and outputAmount\n                values.output.outputToken = tokenOut;\n                values.output.outputAmount = values.output.secondaryOutputAmount + swapOutputAmount;\n                values.output.secondaryOutputAmount = 0;\n            } catch Error(string memory reason) {\n                emit SwapUtils.SwapReverted(reason, \"\");\n            } catch (bytes memory reasonBytes) {\n                (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n                emit SwapUtils.SwapReverted(reason, reasonBytes);\n            }\n        }\n\n        return values;\n    }\n\n    // swap the realized profit from the pnlToken to the collateralToken if needed\n    function swapProfitToCollateralToken(\n        PositionUtils.UpdatePositionParams memory params,\n        address pnlToken,\n        uint256 profitAmount\n    ) internal returns (bool, uint256) {\n        if (params.order.decreasePositionSwapType() == Order.DecreasePositionSwapType.SwapPnlTokenToCollateralToken) {\n            Market.Props[] memory swapPathMarkets = new Market.Props[](1);\n            swapPathMarkets[0] = params.market;\n\n            try params.contracts.swapHandler.swap(\n                SwapUtils.SwapParams(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.contracts.oracle,\n                    Bank(payable(params.market.marketToken)),\n                    pnlToken, // tokenIn\n                    profitAmount, // amountIn\n                    swapPathMarkets, // markets\n                    0, // minOutputAmount\n                    params.market.marketToken, // receiver\n                    false // shouldUnwrapNativeToken\n                )\n            ) returns (address /* tokenOut */, uint256 swapOutputAmount) {\n                return (true, swapOutputAmount);\n            } catch Error(string memory reason) {\n                emit SwapUtils.SwapReverted(reason, \"\");\n            } catch (bytes memory reasonBytes) {\n                (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n                emit SwapUtils.SwapReverted(reason, reasonBytes);\n            }\n        }\n\n        return (false, 0);\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/position/DecreasePositionUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Precision.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../pricing/PositionPricingUtils.sol\";\n\nimport \"./Position.sol\";\nimport \"./PositionStoreUtils.sol\";\nimport \"./PositionUtils.sol\";\nimport \"./PositionEventUtils.sol\";\nimport \"../order/BaseOrderUtils.sol\";\nimport \"../order/OrderEventUtils.sol\";\n\nimport \"./DecreasePositionCollateralUtils.sol\";\n\n// @title DecreasePositionUtils\n// @dev Library for functions to help with decreasing a position\nlibrary DecreasePositionUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    // @dev DecreasePositionResult struct for the results of decreasePosition\n    // @param outputToken the output token\n    // @param outputAmount the output amount\n    // @param secondaryOutputToken the secondary output token\n    // @param secondaryOutputAmount the secondary output amount\n    struct DecreasePositionResult {\n        address outputToken;\n        uint256 outputAmount;\n        address secondaryOutputToken;\n        uint256 secondaryOutputAmount;\n    }\n\n    error InvalidDecreaseOrderSize(uint256 sizeDeltaUsd, uint256 positionSizeInUsd);\n    error UnableToWithdrawCollateralDueToLeverage(int256 estimatedRemainingCollateralUsd);\n    error InvalidDecreasePositionSwapType(Order.DecreasePositionSwapType decreasePositionSwapType);\n    error PositionShouldNotBeLiquidated();\n\n    // @dev decreases a position\n    // The decreasePosition function decreases the size of an existing position\n    // in a market. It takes a PositionUtils.UpdatePositionParams object as an input, which\n    // includes information about the position to be decreased, the market in\n    // which the position exists, and the order that is being used to decrease the position.\n    //\n    // The function first calculates the prices of the tokens in the market, and then\n    // checks whether the position is liquidatable based on the current market prices.\n    // If the order is a liquidation order and the position is not liquidatable, the function reverts.\n    //\n    // If there is not enough collateral in the position to complete the decrease,\n    // the function reverts. Otherwise, the function updates the position's size and\n    // collateral amount, and increments the claimable funding amount for\n    // the market if necessary.\n    //\n    // Finally, the function returns a DecreasePositionResult object containing\n    // information about the outcome of the decrease operation, including the amount\n    // of collateral removed from the position and any fees that were paid.\n    // @param params PositionUtils.UpdatePositionParams\n    function decreasePosition(\n        PositionUtils.UpdatePositionParams memory params\n    ) external returns (DecreasePositionResult memory) {\n        PositionUtils.DecreasePositionCache memory cache;\n\n        cache.prices = MarketUtils.getMarketPricesForPosition(\n            params.contracts.oracle,\n            params.market\n        );\n\n        // cap the order size to the position size\n        if (params.order.sizeDeltaUsd() > params.position.sizeInUsd()) {\n            if (params.order.orderType() == Order.OrderType.LimitDecrease ||\n                params.order.orderType() == Order.OrderType.StopLossDecrease) {\n\n                OrderEventUtils.emitOrderSizeDeltaAutoUpdated(\n                    params.contracts.eventEmitter,\n                    params.orderKey,\n                    params.order.sizeDeltaUsd(),\n                    params.position.sizeInUsd()\n                );\n\n                params.order.setSizeDeltaUsd(params.position.sizeInUsd());\n            } else {\n                revert InvalidDecreaseOrderSize(params.order.sizeDeltaUsd(), params.position.sizeInUsd());\n            }\n        }\n\n        if (params.order.sizeDeltaUsd() < params.position.sizeInUsd() && params.order.initialCollateralDeltaAmount() > 0) {\n            // estimate pnl based on indexTokenPrice\n            (cache.estimatedPositionPnlUsd, /* uint256 sizeDeltaInTokens */) = PositionUtils.getPositionPnlUsd(\n                params.contracts.dataStore,\n                params.market,\n                cache.prices,\n                params.position,\n                cache.prices.indexTokenPrice.midPrice(),\n                params.position.sizeInUsd()\n            );\n\n            cache.estimatedRealizedPnlUsd = cache.estimatedPositionPnlUsd * params.order.sizeDeltaUsd().toInt256() / params.position.sizeInUsd().toInt256();\n            cache.estimatedRemainingPnlUsd = cache.estimatedPositionPnlUsd - cache.estimatedRealizedPnlUsd;\n\n            PositionUtils.WillPositionCollateralBeSufficientValues memory positionValues = PositionUtils.WillPositionCollateralBeSufficientValues(\n                params.position.sizeInUsd() - params.order.sizeDeltaUsd(), // positionSizeInUsd\n                params.position.collateralAmount() - params.order.initialCollateralDeltaAmount(), // positionCollateralAmount\n                cache.estimatedRemainingPnlUsd, // positionPnlUsd\n                cache.estimatedRealizedPnlUsd,  // realizedPnlUsd\n                -params.order.sizeDeltaUsd().toInt256() // openInterestDelta\n            );\n\n            (bool willBeSufficient, int256 estimatedRemainingCollateralUsd) = PositionUtils.willPositionCollateralBeSufficient(\n                params.contracts.dataStore,\n                params.market,\n                cache.prices,\n                params.position.collateralToken(),\n                params.position.isLong(),\n                positionValues\n            );\n\n            if (!willBeSufficient) {\n                if (params.order.sizeDeltaUsd() == 0) {\n                    revert UnableToWithdrawCollateralDueToLeverage(estimatedRemainingCollateralUsd);\n                }\n\n                OrderEventUtils.emitOrderCollateralDeltaAmountAutoUpdated(\n                    params.contracts.eventEmitter,\n                    params.orderKey,\n                    params.order.initialCollateralDeltaAmount(),\n                    0\n                );\n\n                params.order.setInitialCollateralDeltaAmount(0);\n            }\n\n            // if the remaining collateral will be below the min collateral usd value, then close the position\n            if (estimatedRemainingCollateralUsd < params.contracts.dataStore.getUint(Keys.MIN_COLLATERAL_USD).toInt256()) {\n                params.order.setSizeDeltaUsd(params.position.sizeInUsd());\n            }\n        }\n\n        // if the position will be closed, set the initial collateral delta amount\n        // to zero to help ensure that the order can be executed\n        if (params.order.sizeDeltaUsd() == params.position.sizeInUsd() && params.order.initialCollateralDeltaAmount() > 0) {\n            params.order.setInitialCollateralDeltaAmount(0);\n        }\n\n        cache.pnlToken = params.position.isLong() ? params.market.longToken : params.market.shortToken;\n        cache.pnlTokenPrice = params.position.isLong() ? cache.prices.longTokenPrice : cache.prices.shortTokenPrice;\n\n        if (params.order.decreasePositionSwapType() != Order.DecreasePositionSwapType.NoSwap &&\n            cache.pnlToken == params.position.collateralToken()) {\n            revert InvalidDecreasePositionSwapType(params.order.decreasePositionSwapType());\n        }\n\n        if (BaseOrderUtils.isLiquidationOrder(params.order.orderType()) && !PositionUtils.isPositionLiquidatable(\n            params.contracts.dataStore,\n            params.contracts.referralStorage,\n            params.position,\n            params.market,\n            cache.prices,\n            true\n        )) {\n            revert PositionShouldNotBeLiquidated();\n        }\n\n        PositionUtils.updateFundingAndBorrowingState(params, cache.prices);\n\n        cache.initialCollateralAmount = params.position.collateralAmount();\n        (\n            PositionUtils.DecreasePositionCollateralValues memory values,\n            PositionPricingUtils.PositionFees memory fees\n        ) = DecreasePositionCollateralUtils.processCollateral(\n            params,\n            cache\n        );\n\n        cache.nextPositionSizeInUsd = params.position.sizeInUsd() - params.order.sizeDeltaUsd();\n        cache.nextPositionBorrowingFactor = MarketUtils.getCumulativeBorrowingFactor(params.contracts.dataStore, params.market.marketToken, params.position.isLong());\n\n        PositionUtils.updateTotalBorrowing(\n            params,\n            cache.nextPositionSizeInUsd,\n            cache.nextPositionBorrowingFactor\n        );\n\n        params.position.setSizeInUsd(cache.nextPositionSizeInUsd);\n        params.position.setSizeInTokens(params.position.sizeInTokens() - values.sizeDeltaInTokens);\n        params.position.setCollateralAmount(values.remainingCollateralAmount.toUint256());\n        params.position.setDecreasedAtBlock(Chain.currentBlockNumber());\n\n        PositionUtils.incrementClaimableFundingAmount(params, fees);\n\n        if (params.position.sizeInUsd() == 0 || params.position.sizeInTokens() == 0) {\n            // withdraw all collateral if the position will be closed\n            values.output.outputAmount += params.position.collateralAmount();\n\n            params.position.setSizeInUsd(0);\n            params.position.setSizeInTokens(0);\n            params.position.setCollateralAmount(0);\n\n            PositionStoreUtils.remove(params.contracts.dataStore, params.positionKey, params.order.account());\n        } else {\n            if (!fees.funding.hasPendingLongTokenFundingFee) {\n                params.position.setLongTokenFundingAmountPerSize(fees.funding.latestLongTokenFundingAmountPerSize);\n            }\n            if (!fees.funding.hasPendingShortTokenFundingFee) {\n                params.position.setShortTokenFundingAmountPerSize(fees.funding.latestShortTokenFundingAmountPerSize);\n            }\n            params.position.setBorrowingFactor(cache.nextPositionBorrowingFactor);\n\n            PositionUtils.validatePosition(\n                params.contracts.dataStore,\n                params.contracts.referralStorage,\n                params.position,\n                params.market,\n                cache.prices,\n                false\n            );\n\n            PositionStoreUtils.set(params.contracts.dataStore, params.positionKey, params.position);\n        }\n\n        MarketUtils.applyDeltaToCollateralSum(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.position.market(),\n            params.position.collateralToken(),\n            params.position.isLong(),\n            -(cache.initialCollateralAmount - params.position.collateralAmount()).toInt256()\n        );\n\n        PositionUtils.updateOpenInterest(\n            params,\n            -params.order.sizeDeltaUsd().toInt256(),\n            -values.sizeDeltaInTokens.toInt256()\n        );\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            values.pnlTokenForPool,\n            values.pnlAmountForPool\n        );\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            params.position.collateralToken(),\n            fees.feeAmountForPool.toInt256()\n        );\n\n        PositionUtils.handleReferral(params, fees);\n\n        PositionPricingUtils.emitPositionFeesCollected(\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            params.position.collateralToken(),\n            false,\n            fees\n        );\n\n        PositionEventUtils.emitPositionDecrease(\n            params.contracts.eventEmitter,\n            params.positionKey,\n            params.position,\n            params.order.sizeDeltaUsd(),\n            cache.initialCollateralAmount - params.position.collateralAmount(),\n            params.order.orderType(),\n            values\n        );\n\n        values = DecreasePositionCollateralUtils.swapWithdrawnCollateralToPnlToken(params, values);\n\n        return DecreasePositionResult(\n            values.output.outputToken,\n            values.output.outputAmount,\n            values.output.secondaryOutputToken,\n            values.output.secondaryOutputAmount\n        );\n    }\n}"
    }
  ]
}