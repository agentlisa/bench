{
  "Title": "H-1: attackers will keep stealing the `rewards` from Convex SPELL",
  "Content": "# Issue H-1: attackers will keep stealing the `rewards` from Convex SPELL \n\nSource: https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/101 \n\n## Found by \nBauer, Ch\\_301\n## Summary\nOn [WConvexPools.burn()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235) transfer [CRV + CVX + the extra rewards](https://docs.convexfinance.com/convexfinance/general-information/why-convex/convex-for-liquidity-providers) to Convex SPELL \n\n\n## Vulnerability Detail\nBut [ConvexSpell.openPositionFarm()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#L67-L138) only refund CVX to the user.\nSo the rest rewards will stay in the SPELL intel if someone (could be an attacker) invokes `_doRefund()` within `closePositionFarm()` with the same address tokens \n\n## Impact\n- Convex SPELL steals the user rewards \n- the protocol will lose some fees \n- attackers will keep stealing the rewards from Convex SPELL\n\n## Code Snippet\n`WConvexPools.burn()` transfer CRV + CVX + the extra rewards\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235\n```solidity\n        // Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        // Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n        }\n```\n\nonly refund CVX to the user\nhttps://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/spell/ConvexSpell.sol#LL127C1-L138C10\n```solidity\n        // 6. Take out existing collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wConvexPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wConvexPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wConvexPools.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(CVX);\n        }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nyou should Refund all Rewards (CRV + CVX + the extra rewards)\n\n\n\n## Discussion\n\n**Ch-301**\n\nEscalate for 10 USDC\n\nConvex docs are confirming this point \n\n```diff\nConvex allows liquidity providers to earn trading fees and claim boosted CRV without locking CRV themselves. Liquidity providers can receive boosted CRV and liquidity mining rewards with minimal effort:\nEarn claimable CRV with a high boost without locking any CRV\nEarn CVX rewards\nZero deposit and withdraw fees\nZero fees on extra incentive tokens (SNX, etc)\n```\nand [WConvexPools.burn()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235) handle this properly\n\nso Convex SPELL should refund all the rewards\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Convex docs are confirming this point \n> \n> ```diff\n> Convex allows liquidity providers to earn trading fees and claim boosted CRV without locking CRV themselves. Liquidity providers can receive boosted CRV and liquidity mining rewards with minimal effort:\n> Earn claimable CRV with a high boost without locking any CRV\n> Earn CVX rewards\n> Zero deposit and withdraw fees\n> Zero fees on extra incentive tokens (SNX, etc)\n> ```\n> and [WConvexPools.burn()](https://github.com/sherlock-audit/2023-04-blueberry/blob/main/blueberry-core/contracts/wrapper/WConvexPools.sol#L201-L235) handle this properly\n> \n> so Convex SPELL should refund all the rewards\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nSenior watson's comment:\n\nsame as\nhttps://github.com/sherlock-audit/2023-05-blueberry-judging/issues/29 \n\n**hrishibhat**\n\nEscalation accepted\n\nValid high \nThis issue is a valid high along with another duplicate #42\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Valid high \n> This issue is a valid high along with another duplicate #42\n\n    This issue's escalations have been accepted!\n\n    Contestants' payouts and scores will be updated according to the changes made on this issue.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/69",
  "Code": [
    {
      "filename": "blueberry-core/contracts/wrapper/WConvexPools.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IWConvexPools.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/convex/IRewarder.sol\";\n\n/**\n * @title WConvexPools\n * @author BlueberryProtocol\n * @notice Wrapped Convex Pools is the wrapper of LP positions\n * @dev Leveraged LP Tokens will be wrapped here and be held in BlueberryBank \n *      and do not generate yields. LP Tokens are identified by tokenIds \n *      encoded from lp token address.\n */\ncontract WConvexPools is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    EnsureApprove,\n    IERC20Wrapper,\n    IWConvexPools\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev Address to Convex Pools contract\n    ICvxPools public cvxPools;\n    /// @dev Address to CVX token\n    IERC20Upgradeable public CVX;\n    /// @dev Mapping from gauge id to accCrvPerShare\n    mapping(uint256 => uint256) public accCrvPerShares;\n    /// @dev Mapping from token id to accExtPerShare\n    mapping(uint256 => uint256[]) public accExtPerShare;\n\n    // /// @dev Mapping from tokenId to\n    // mapping(uint256 => uint256) public\n\n    function initialize(address cvx_, address cvxPools_) external initializer {\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WConvexPools\");\n        CVX = IERC20Upgradeable(cvx_);\n        cvxPools = ICvxPools(cvxPools_);\n    }\n\n    /// @notice Encode pid, cvxPerShare to ERC1155 token id\n    /// @param pid Pool id (16-bit)\n    /// @param cvxPerShare CVX amount per share, multiplied by 1e18 (240-bit)\n    function encodeId(\n        uint256 pid,\n        uint256 cvxPerShare\n    ) public pure returns (uint256 id) {\n        if (pid >= (1 << 16)) revert Errors.BAD_PID(pid);\n        if (cvxPerShare >= (1 << 240))\n            revert Errors.BAD_REWARD_PER_SHARE(cvxPerShare);\n        return (pid << 240) | cvxPerShare;\n    }\n\n    /// @notice Decode ERC1155 token id to pid, cvxPerShare\n    /// @param id Token id\n    function decodeId(\n        uint256 id\n    ) public pure returns (uint256 gid, uint256 cvxPerShare) {\n        gid = id >> 240; // First 16 bits\n        cvxPerShare = id & ((1 << 240) - 1); // Last 240 bits\n    }\n\n    /// @notice Get underlying ERC20 token of ERC1155 given token id\n    /// @param id Token id\n    function getUnderlyingToken(\n        uint256 id\n    ) external view override returns (address uToken) {\n        (uint256 pid, ) = decodeId(id);\n        (uToken, , , , , ) = getPoolInfoFromPoolId(pid);\n    }\n\n    function getPoolInfoFromPoolId(\n        uint256 pid\n    )\n        public\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        )\n    {\n        return cvxPools.poolInfo(pid);\n    }\n\n    function _getPendingReward(\n        uint stRewardPerShare,\n        address rewarder,\n        uint amount,\n        uint lpDecimals\n    ) internal view returns (uint rewards) {\n        uint256 enRewardPerShare = IRewarder(rewarder).rewardPerToken();\n        uint256 share = enRewardPerShare > stRewardPerShare\n            ? enRewardPerShare - stRewardPerShare\n            : 0;\n        rewards = (share * amount) / (10 ** lpDecimals);\n    }\n\n    /// @notice Return pending rewards from the farming pool\n    /// @dev Reward tokens can be multiple tokens\n    /// @param tokenId Token Id\n    /// @param amount amount of share\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {\n        (uint256 pid, uint256 stCrvPerShare) = decodeId(tokenId);\n        (address lpToken, , , address crvRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        uint256 lpDecimals = IERC20MetadataUpgradeable(lpToken).decimals();\n        uint extraRewardsCount = IRewarder(crvRewarder).extraRewardsLength();\n        tokens = new address[](extraRewardsCount + 1);\n        rewards = new uint256[](extraRewardsCount + 1);\n\n        tokens[0] = IRewarder(crvRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            crvRewarder,\n            amount,\n            lpDecimals\n        );\n\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address rewarder = IRewarder(crvRewarder).extraRewards(i);\n            uint256 stRewardPerShare = accExtPerShare[tokenId][i];\n            tokens[i + 1] = IRewarder(rewarder).rewardToken();\n            rewards[i + 1] = _getPendingReward(\n                stRewardPerShare,\n                rewarder,\n                amount,\n                lpDecimals\n            );\n        }\n    }\n\n    /// @notice Mint ERC1155 token for the given LP token\n    /// @param pid Convex Pool id\n    /// @param amount Token amount to wrap\n    function mint(\n        uint256 pid,\n        uint256 amount\n    ) external nonReentrant returns (uint256 id) {\n        (address lpToken, , , address crvRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        _ensureApprove(lpToken, address(cvxPools), amount);\n        cvxPools.deposit(pid, amount, true);\n\n        uint256 crvRewardPerToken = IRewarder(crvRewarder).rewardPerToken();\n        id = encodeId(pid, crvRewardPerToken);\n        _mint(msg.sender, id, amount, \"\");\n        // Store extra rewards info\n        uint extraRewardsCount = IRewarder(crvRewarder).extraRewardsLength();\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address extraRewarder = IRewarder(crvRewarder).extraRewards(i);\n            uint rewardPerToken = IRewarder(extraRewarder).rewardPerToken();\n            accExtPerShare[id].push(rewardPerToken);\n        }\n    }\n\n    /// @notice Burn ERC1155 token to redeem ERC20 token back\n    /// @param id Token id to burn\n    /// @param amount Token amount to burn\n    /// @return rewardTokens Reward tokens rewards harvested\n    function burn(\n        uint256 id,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        returns (address[] memory rewardTokens, uint256[] memory rewards)\n    {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, ) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        (address lpToken, , , address crvRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        // Claim Rewards\n        IRewarder(crvRewarder).withdraw(amount, true);\n        // Withdraw LP\n        cvxPools.withdraw(pid, amount);\n\n        // Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        // Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n        }\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/spell/ConvexSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/IWConvexPools.sol\";\nimport \"../interfaces/curve/ICurvePool.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Router02.sol\";\n\n/**\n * @title ConvexSpell\n * @author BlueberryProtocol\n * @notice ConvexSpell is the factory contract that\n * defines how Blueberry Protocol interacts with Convex pools\n */\ncontract ConvexSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev Address to Wrapped Convex Pools\n    IWConvexPools public wConvexPools;\n    /// @dev address of CurveOracle\n    ICurveOracle public crvOracle;\n    /// @dev address of CVX token\n    address public CVX;\n\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wConvexPools_,\n        address crvOracle_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wConvexPools_ == address(0) || crvOracle_ == address(0))\n            revert Errors.ZERO_ADDRESS();\n\n        wConvexPools = IWConvexPools(wConvexPools_);\n        CVX = address(wConvexPools.CVX());\n        crvOracle = ICurveOracle(crvOracle_);\n        IWConvexPools(wConvexPools_).setApprovalForAll(address(bank_), true);\n    }\n\n    /**\n     * @notice Add strategy to the spell\n     * @param crvLp Address of crv lp token for given strategy\n     * @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n     */\n    function addStrategy(address crvLp, uint256 maxPosSize) external onlyOwner {\n        _addStrategy(crvLp, maxPosSize);\n    }\n\n    /**\n     * @notice Add liquidity to Curve pool with 2 underlying tokens, with staking to Curve gauge\n     * @param minLPMint Desired LP token amount (slippage control)\n     */\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minLPMint\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        (address lpToken, , , , , ) = wConvexPools.getPoolInfoFromPoolId(\n            param.farmingPoolId\n        );\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        // 3. Add liquidity on curve, get crvLp\n        (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(\n            lpToken\n        );\n        _ensureApprove(param.borrowToken, pool, borrowBalance);\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i = 0; i < 2; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 3) {\n            uint256[3] memory suppliedAmts;\n            for (uint256 i = 0; i < 3; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 4) {\n            uint256[4] memory suppliedAmts;\n            for (uint256 i = 0; i < 4; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        }\n\n        // 4. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        // 5. Validate Max Pos Size\n        _validateMaxPosSize(param.strategyId);\n\n        // 6. Take out existing collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wConvexPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wConvexPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wConvexPools.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(CVX);\n        }\n\n        // 7. Deposit on Convex Pool, Put wrapped collateral tokens on Blueberry Bank\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wConvexPools), lpAmount);\n        uint256 id = wConvexPools.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wConvexPools), id, lpAmount);\n    }\n\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        IUniswapV2Router02 swapRouter,\n        address[][] calldata swapPath\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address crvLp = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collToken != address(wConvexPools))\n            revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n        if (wConvexPools.getUnderlyingToken(pos.collId) != crvLp)\n            revert Errors.INCORRECT_UNDERLYING(crvLp);\n\n        // 1. Take out collateral - Burn wrapped tokens, receive crv lp tokens and harvest CRV\n        bank.takeCollateral(param.amountPosRemove);\n        (address[] memory rewardTokens, ) = wConvexPools.burn(\n            pos.collId,\n            param.amountPosRemove\n        );\n\n        // 2. Swap rewards tokens to debt token\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 rewards = _doCutRewardsFee(rewardTokens[i]);\n            _ensureApprove(rewardTokens[i], address(swapRouter), rewards);\n            swapRouter.swapExactTokensForTokens(\n                rewards,\n                0,\n                swapPath[i],\n                address(this),\n                type(uint256).max\n            );\n        }\n\n        {\n            (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(\n                crvLp\n            );\n            // 3. Calculate actual amount to remove\n            uint256 amountPosRemove = param.amountPosRemove;\n            if (amountPosRemove == type(uint256).max) {\n                amountPosRemove = IERC20Upgradeable(crvLp).balanceOf(\n                    address(this)\n                );\n            }\n\n            // 4. Remove liquidity\n            int128 tokenIndex;\n            for (uint256 i = 0; i < tokens.length; i++) {\n                if (tokens[i] == pos.debtToken) {\n                    tokenIndex = int128(uint128(i));\n                    break;\n                }\n            }\n\n            ICurvePool(pool).remove_liquidity_one_coin(\n                amountPosRemove,\n                int128(tokenIndex),\n                0\n            );\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 6. Repay\n        {\n            // Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        // 7. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n        _doRefund(CVX);\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/wrapper/WConvexPools.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IWConvexPools.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/convex/IRewarder.sol\";\n\n/**\n * @title WConvexPools\n * @author BlueberryProtocol\n * @notice Wrapped Convex Pools is the wrapper of LP positions\n * @dev Leveraged LP Tokens will be wrapped here and be held in BlueberryBank \n *      and do not generate yields. LP Tokens are identified by tokenIds \n *      encoded from lp token address.\n */\ncontract WConvexPools is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    EnsureApprove,\n    IERC20Wrapper,\n    IWConvexPools\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev Address to Convex Pools contract\n    ICvxPools public cvxPools;\n    /// @dev Address to CVX token\n    IERC20Upgradeable public CVX;\n    /// @dev Mapping from gauge id to accCrvPerShare\n    mapping(uint256 => uint256) public accCrvPerShares;\n    /// @dev Mapping from token id to accExtPerShare\n    mapping(uint256 => uint256[]) public accExtPerShare;\n\n    // /// @dev Mapping from tokenId to\n    // mapping(uint256 => uint256) public\n\n    function initialize(address cvx_, address cvxPools_) external initializer {\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WConvexPools\");\n        CVX = IERC20Upgradeable(cvx_);\n        cvxPools = ICvxPools(cvxPools_);\n    }\n\n    /// @notice Encode pid, cvxPerShare to ERC1155 token id\n    /// @param pid Pool id (16-bit)\n    /// @param cvxPerShare CVX amount per share, multiplied by 1e18 (240-bit)\n    function encodeId(\n        uint256 pid,\n        uint256 cvxPerShare\n    ) public pure returns (uint256 id) {\n        if (pid >= (1 << 16)) revert Errors.BAD_PID(pid);\n        if (cvxPerShare >= (1 << 240))\n            revert Errors.BAD_REWARD_PER_SHARE(cvxPerShare);\n        return (pid << 240) | cvxPerShare;\n    }\n\n    /// @notice Decode ERC1155 token id to pid, cvxPerShare\n    /// @param id Token id\n    function decodeId(\n        uint256 id\n    ) public pure returns (uint256 gid, uint256 cvxPerShare) {\n        gid = id >> 240; // First 16 bits\n        cvxPerShare = id & ((1 << 240) - 1); // Last 240 bits\n    }\n\n    /// @notice Get underlying ERC20 token of ERC1155 given token id\n    /// @param id Token id\n    function getUnderlyingToken(\n        uint256 id\n    ) external view override returns (address uToken) {\n        (uint256 pid, ) = decodeId(id);\n        (uToken, , , , , ) = getPoolInfoFromPoolId(pid);\n    }\n\n    function getPoolInfoFromPoolId(\n        uint256 pid\n    )\n        public\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        )\n    {\n        return cvxPools.poolInfo(pid);\n    }\n\n    function _getPendingReward(\n        uint stRewardPerShare,\n        address rewarder,\n        uint amount,\n        uint lpDecimals\n    ) internal view returns (uint rewards) {\n        uint256 enRewardPerShare = IRewarder(rewarder).rewardPerToken();\n        uint256 share = enRewardPerShare > stRewardPerShare\n            ? enRewardPerShare - stRewardPerShare\n            : 0;\n        rewards = (share * amount) / (10 ** lpDecimals);\n    }\n\n    /// @notice Return pending rewards from the farming pool\n    /// @dev Reward tokens can be multiple tokens\n    /// @param tokenId Token Id\n    /// @param amount amount of share\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {\n        (uint256 pid, uint256 stCrvPerShare) = decodeId(tokenId);\n        (address lpToken, , , address crvRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        uint256 lpDecimals = IERC20MetadataUpgradeable(lpToken).decimals();\n        uint extraRewardsCount = IRewarder(crvRewarder).extraRewardsLength();\n        tokens = new address[](extraRewardsCount + 1);\n        rewards = new uint256[](extraRewardsCount + 1);\n\n        tokens[0] = IRewarder(crvRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            crvRewarder,\n            amount,\n            lpDecimals\n        );\n\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address rewarder = IRewarder(crvRewarder).extraRewards(i);\n            uint256 stRewardPerShare = accExtPerShare[tokenId][i];\n            tokens[i + 1] = IRewarder(rewarder).rewardToken();\n            rewards[i + 1] = _getPendingReward(\n                stRewardPerShare,\n                rewarder,\n                amount,\n                lpDecimals\n            );\n        }\n    }\n\n    /// @notice Mint ERC1155 token for the given LP token\n    /// @param pid Convex Pool id\n    /// @param amount Token amount to wrap\n    function mint(\n        uint256 pid,\n        uint256 amount\n    ) external nonReentrant returns (uint256 id) {\n        (address lpToken, , , address crvRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        _ensureApprove(lpToken, address(cvxPools), amount);\n        cvxPools.deposit(pid, amount, true);\n\n        uint256 crvRewardPerToken = IRewarder(crvRewarder).rewardPerToken();\n        id = encodeId(pid, crvRewardPerToken);\n        _mint(msg.sender, id, amount, \"\");\n        // Store extra rewards info\n        uint extraRewardsCount = IRewarder(crvRewarder).extraRewardsLength();\n        for (uint i = 0; i < extraRewardsCount; i++) {\n            address extraRewarder = IRewarder(crvRewarder).extraRewards(i);\n            uint rewardPerToken = IRewarder(extraRewarder).rewardPerToken();\n            accExtPerShare[id].push(rewardPerToken);\n        }\n    }\n\n    /// @notice Burn ERC1155 token to redeem ERC20 token back\n    /// @param id Token id to burn\n    /// @param amount Token amount to burn\n    /// @return rewardTokens Reward tokens rewards harvested\n    function burn(\n        uint256 id,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        returns (address[] memory rewardTokens, uint256[] memory rewards)\n    {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, ) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        (address lpToken, , , address crvRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        // Claim Rewards\n        IRewarder(crvRewarder).withdraw(amount, true);\n        // Withdraw LP\n        cvxPools.withdraw(pid, amount);\n\n        // Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        // Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n        }\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/spell/ConvexSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/IWConvexPools.sol\";\nimport \"../interfaces/curve/ICurvePool.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Router02.sol\";\n\n/**\n * @title ConvexSpell\n * @author BlueberryProtocol\n * @notice ConvexSpell is the factory contract that\n * defines how Blueberry Protocol interacts with Convex pools\n */\ncontract ConvexSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev Address to Wrapped Convex Pools\n    IWConvexPools public wConvexPools;\n    /// @dev address of CurveOracle\n    ICurveOracle public crvOracle;\n    /// @dev address of CVX token\n    address public CVX;\n\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wConvexPools_,\n        address crvOracle_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wConvexPools_ == address(0) || crvOracle_ == address(0))\n            revert Errors.ZERO_ADDRESS();\n\n        wConvexPools = IWConvexPools(wConvexPools_);\n        CVX = address(wConvexPools.CVX());\n        crvOracle = ICurveOracle(crvOracle_);\n        IWConvexPools(wConvexPools_).setApprovalForAll(address(bank_), true);\n    }\n\n    /**\n     * @notice Add strategy to the spell\n     * @param crvLp Address of crv lp token for given strategy\n     * @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n     */\n    function addStrategy(address crvLp, uint256 maxPosSize) external onlyOwner {\n        _addStrategy(crvLp, maxPosSize);\n    }\n\n    /**\n     * @notice Add liquidity to Curve pool with 2 underlying tokens, with staking to Curve gauge\n     * @param minLPMint Desired LP token amount (slippage control)\n     */\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minLPMint\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        (address lpToken, , , , , ) = wConvexPools.getPoolInfoFromPoolId(\n            param.farmingPoolId\n        );\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        // 3. Add liquidity on curve, get crvLp\n        (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(\n            lpToken\n        );\n        _ensureApprove(param.borrowToken, pool, borrowBalance);\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i = 0; i < 2; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 3) {\n            uint256[3] memory suppliedAmts;\n            for (uint256 i = 0; i < 3; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 4) {\n            uint256[4] memory suppliedAmts;\n            for (uint256 i = 0; i < 4; i++) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        }\n\n        // 4. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        // 5. Validate Max Pos Size\n        _validateMaxPosSize(param.strategyId);\n\n        // 6. Take out existing collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wConvexPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wConvexPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wConvexPools.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(CVX);\n        }\n\n        // 7. Deposit on Convex Pool, Put wrapped collateral tokens on Blueberry Bank\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wConvexPools), lpAmount);\n        uint256 id = wConvexPools.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wConvexPools), id, lpAmount);\n    }\n\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        IUniswapV2Router02 swapRouter,\n        address[][] calldata swapPath\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address crvLp = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collToken != address(wConvexPools))\n            revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n        if (wConvexPools.getUnderlyingToken(pos.collId) != crvLp)\n            revert Errors.INCORRECT_UNDERLYING(crvLp);\n\n        // 1. Take out collateral - Burn wrapped tokens, receive crv lp tokens and harvest CRV\n        bank.takeCollateral(param.amountPosRemove);\n        (address[] memory rewardTokens, ) = wConvexPools.burn(\n            pos.collId,\n            param.amountPosRemove\n        );\n\n        // 2. Swap rewards tokens to debt token\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\n            uint256 rewards = _doCutRewardsFee(rewardTokens[i]);\n            _ensureApprove(rewardTokens[i], address(swapRouter), rewards);\n            swapRouter.swapExactTokensForTokens(\n                rewards,\n                0,\n                swapPath[i],\n                address(this),\n                type(uint256).max\n            );\n        }\n\n        {\n            (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(\n                crvLp\n            );\n            // 3. Calculate actual amount to remove\n            uint256 amountPosRemove = param.amountPosRemove;\n            if (amountPosRemove == type(uint256).max) {\n                amountPosRemove = IERC20Upgradeable(crvLp).balanceOf(\n                    address(this)\n                );\n            }\n\n            // 4. Remove liquidity\n            int128 tokenIndex;\n            for (uint256 i = 0; i < tokens.length; i++) {\n                if (tokens[i] == pos.debtToken) {\n                    tokenIndex = int128(uint128(i));\n                    break;\n                }\n            }\n\n            ICurvePool(pool).remove_liquidity_one_coin(\n                amountPosRemove,\n                int128(tokenIndex),\n                0\n            );\n        }\n\n        // 5. Withdraw isolated collateral"
    }
  ]
}