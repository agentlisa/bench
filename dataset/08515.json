{
  "Title": "[N-11] Public functions can be external",
  "Content": "\nIt is good practice to mark functions as `external` instead of `public` if they are not called by the contract where they are defined.\n\n### Proof of Concept\n\n1 instance:\n\n#### MarketPlace.sol\n\n[function authRedeem(uint8 p, address u, uint256 m, address f, address t, uint256 a) public](https://github.com/code-423n4/2022-07-swivel/blob/daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c/Marketplace/MarketPlace.sol#L148)\n\n### Recommended Mitigation Steps\n\nDeclare it as `external` instead of `public`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-07-swivel",
  "Code": [
    {
      "filename": "Marketplace/MarketPlace.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './Compounding.sol';\n\ncontract MarketPlace {\n  /// @dev A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n\n  struct Market {\n    address cTokenAddr;\n    address zcToken;\n    address vaultTracker;\n    uint256 maturityRate;\n  }\n\n  mapping (uint8 => mapping (address => mapping (uint256 => Market))) public markets;\n  mapping (uint8 => bool) public paused;\n\n  address public admin;\n  address public swivel;\n  address public immutable creator;\n\n  event Create(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address cToken, address zcToken, address vaultTracker);\n  event Mature(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, uint256 maturityRate, uint256 matured);\n  event RedeemZcToken(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address sender, uint256 amount);\n  event RedeemVaultInterest(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address sender);\n  event CustodialInitiate(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address zcTarget, address nTarget, uint256 amount);\n  event CustodialExit(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address zcTarget, address nTarget, uint256 amount);\n  event P2pZcTokenExchange(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);\n  event P2pVaultExchange(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);\n  event TransferVaultNotional(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);\n\n  constructor(address c) {\n    admin = msg.sender;\n    creator = c;\n  }\n\n  /// @param s Address of the deployed swivel contract\n  /// @notice We only allow this to be set once\n  function setSwivel(address s) external authorized(admin) returns (bool) {\n    if (swivel != address(0)) { revert Exception(20, 0, 0, swivel, address(0));  }\n\n    swivel = s;\n    return true;\n  }\n\n  /// @param a Address of a new admin\n  function setAdmin(address a) external authorized(admin) returns (bool) {\n    admin = a;\n    return true;\n  }\n\n  /// @notice Allows the owner to create new markets\n  /// @param p Protocol associated with the new market\n  /// @param m Maturity timestamp of the new market\n  /// @param c Compounding Token address associated with the new market\n  /// @param n Name of the new market zcToken\n  /// @param s Symbol of the new market zcToken\n  function createMarket(\n    uint8 p,\n    uint256 m,\n    address c,\n    string memory n,\n    string memory s\n  ) external authorized(admin) unpaused(p) returns (bool) {\n    if (swivel == address(0)) { revert Exception(21, 0, 0, address(0), address(0)); }\n\n    address underAddr = Compounding.underlying(p, c);\n\n    if (markets[p][underAddr][m].vaultTracker != address(0)) { revert Exception(22, 0, 0, address(0), address(0)); }\n\n    (address zct, address tracker) = ICreator(creator).create(p, underAddr, m, c, swivel, n, s, IErc20(underAddr).decimals()) ;\n\n    markets[p][underAddr][m] = Market(c, zct, tracker, 0);\n\n    emit Create(p, underAddr, m, c, zct, tracker);\n\n    return true;\n  }\n\n  /// @notice Can be called after maturity, allowing all of the zcTokens to earn floating interest on Compound until they release their funds\n  /// @param p Protocol Enum value associated with the market being matured\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function matureMarket(uint8 p, address u, uint256 m) public unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n\n    if (market.maturityRate != 0) { revert Exception(23, market.maturityRate, 0, address(0), address(0)); }\n\n    if (block.timestamp < m) { revert Exception(24, block.timestamp, m, address(0), address(0)); }\n\n    // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate\n    uint256 exchangeRate = Compounding.exchangeRate(p, market.cTokenAddr);\n    markets[p][u][m].maturityRate = exchangeRate;\n\n    // NOTE we don't check the return of this simple operation\n    IVaultTracker(market.vaultTracker).matureVault(exchangeRate);\n\n    emit Mature(p, u, m, exchangeRate, block.timestamp);\n\n    return true;\n  }\n\n  /// @notice Allows Swivel caller to deposit their underlying, in the process splitting it - minting both zcTokens and vault notional.\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Address of the depositing user\n  /// @param a Amount of notional being added\n  function mintZcTokenAddingNotional(uint8 p, address u, uint256 m, address t, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n\n    if (!IZcToken(market.zcToken).mint(t, a)) { revert Exception(28, 0, 0, address(0), address(0)); }\n\n    if (!IVaultTracker(market.vaultTracker).addNotional(t, a)) { revert Exception(25, 0, 0, address(0), address(0)); }\n    \n    return true;\n  }\n\n  /// @notice Allows Swivel caller to deposit/burn both zcTokens + vault notional. This process is \"combining\" the two and redeeming underlying.\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Address of the combining/redeeming user\n  /// @param a Amount of zcTokens being burned\n  function burnZcTokenRemovingNotional(uint8 p, address u, uint256 m, address t, uint256 a) external authorized(swivel) unpaused(p) returns(bool) {\n    Market memory market = markets[p][u][m];\n\n    if (!IZcToken(market.zcToken).burn(t, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n    if (!IVaultTracker(market.vaultTracker).removeNotional(t, a)) { revert Exception(26, 0, 0, address(0), address(0)); }\n    \n    return true;\n  }\n\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param f Address of the user having their zcTokens burned\n  /// @param t Address of the user receiving underlying\n  /// @param a Amount of zcTokens being redeemed\n  /// @return underlyingAmount Amount of underlying being withdrawn (needed for 5095 return)\n  function authRedeem(uint8 p, address u, uint256 m, address f, address t, uint256 a) public authorized(markets[p][u][m].zcToken) returns (uint256 underlyingAmount) {\n    Market memory market = markets[p][u][m];\n    // if the market has not matured, mature it...\n    if (market.maturityRate == 0) {\n      if (!matureMarket(p, u, m)) { revert Exception(30, 0, 0, address(0), address(0)); }\n\n      if (!IZcToken(market.zcToken).burn(f, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n      ISwivel(swivel).authRedeem(p, u, market.cTokenAddr, t, a);\n\n      return (a);\n    } else {\n\n      if (!IZcToken(market.zcToken).burn(f, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n      uint256 amount = calculateReturn(p, u, m, a);\n      ISwivel(swivel).authRedeem(p, u, market.cTokenAddr, t, amount);\n\n      return (amount);\n    }\n  }\n\n  /// @notice Allows (via swivel) zcToken holders to redeem their tokens for underlying tokens after maturity has been reached.\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Address of the redeeming user\n  /// @param a Amount of zcTokens being redeemed\n  function redeemZcToken(uint8 p, address u, uint256 m, address t, uint256 a) external authorized(swivel) unpaused(p) returns (uint256) {\n    Market memory market = markets[p][u][m];\n\n    // if the market has not matured, mature it and redeem exactly the amount\n    if (market.maturityRate == 0) {\n      if (!matureMarket(p, u, m)) { revert Exception(30, 0, 0, address(0), address(0)); }\n    }\n\n    if (!IZcToken(market.zcToken).burn(t, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n    emit RedeemZcToken(p, u, m, t, a);\n\n    if (market.maturityRate == 0) {\n      return a;\n    } else { \n      // if the market was already mature the return should include the amount + marginal floating interest generated on Compound since maturity\n      return calculateReturn(p, u, m, a);\n    }\n  }\n\n  /// @notice Allows Vault owners (via Swivel) to redeem any currently accrued interest\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Address of the redeeming user\n  function redeemVaultInterest(uint8 p, address u, uint256 m, address t) external authorized(swivel) unpaused(p) returns (uint256) {\n    // call to the floating market contract to release the position and calculate the interest generated\n    uint256 interest = IVaultTracker(markets[p][u][m].vaultTracker).redeemInterest(t);\n\n    emit RedeemVaultInterest(p, u, m, t);\n\n    return interest;\n  }\n\n  /// @notice Calculates the total amount of underlying returned including interest generated since the `matureMarket` function has been called\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of zcTokens being redeemed\n  function calculateReturn(uint8 p, address u, uint256 m, uint256 a) internal view returns (uint256) {\n    Market memory market = markets[p][u][m];\n\n    uint256 exchangeRate = Compounding.exchangeRate(p, market.cTokenAddr);\n\n    return (a * exchangeRate) / market.maturityRate;\n  }\n\n  /// @notice Return the compounding token address for a given market\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function cTokenAddress(uint8 p, address u, uint256 m) external view returns (address) {\n    Market memory market = markets[p][u][m];\n    return market.cTokenAddr;\n  }\n\n  /// @notice Return the exchangeRate for a given protocol's compounding token\n  /// @param p Protocol Enum value associated with this market\n  /// @param c Compounding token address associated with the market\n  function getExchangeRate(uint8 p, address c) external view returns (uint256) {\n      return Compounding.exchangeRate(p, c);\n  }\n\n  /// @notice Called by swivel IVFZI && IZFVI\n  /// @dev Call with protocol, underlying, maturity, mint-target, add-notional-target and an amount\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param z Recipient of the minted zcToken\n  /// @param n Recipient of the added notional\n  /// @param a Amount of zcToken minted and notional added\n  function custodialInitiate(uint8 p, address u, uint256 m, address z, address n, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n    if (!IZcToken(market.zcToken).mint(z, a)) { revert Exception(28, 0, 0, address(0), address(0)); }\n\n    if (!IVaultTracker(market.vaultTracker).addNotional(n, a)) { revert Exception(25, 0, 0, address(0), address(0)); }\n\n    emit CustodialInitiate(p, u, m, z, n, a);\n    return true;\n  }\n\n  /// @notice Called by swivel EVFZE FF EZFVE\n  /// @dev Call with protocol, underlying, maturity, burn-target, remove-notional-target and an amount\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param z Owner of the zcToken to be burned\n  /// @param n Target to remove notional from\n  /// @param a Amount of zcToken burned and notional removed\n  function custodialExit(uint8 p, address u, uint256 m, address z, address n, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n    if (!IZcToken(market.zcToken).burn(z, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n    if (!IVaultTracker(market.vaultTracker).removeNotional(n, a)) { revert Exception(26, 0, 0, address(0), address(0)); }\n\n    emit CustodialExit(p, u, m, z, n, a);\n    return true;\n  }\n\n  /// @notice Called by swivel IZFZE, EZFZI\n  /// @dev Call with underlying, maturity, transfer-from, transfer-to, amount\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param f Owner of the zcToken to be burned\n  /// @param t Target to be minted to\n  /// @param a Amount of zcToken transfer\n  function p2pZcTokenExchange(uint8 p, address u, uint256 m, address f, address t, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n    if (!IZcToken(market.zcToken).burn(f, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n    if (!IZcToken(market.zcToken).mint(t, a)) { revert Exception(28, 0, 0, address(0), address(0)); }\n\n    emit P2pZcTokenExchange(p, u, m, f, t, a);\n    return true;\n  }\n\n  /// @notice Called by swivel IVFVE, EVFVI\n  /// @dev Call with protocol, underlying, maturity, remove-from, add-to, amount\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param f Owner of the notional to be transferred\n  /// @param t Target to be transferred to\n  /// @param a Amount of notional transfer\n  function p2pVaultExchange(uint8 p, address u, uint256 m, address f, address t, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    if (!IVaultTracker(markets[p][u][m].vaultTracker).transferNotionalFrom(f, t, a)) { revert Exception(27, 0, 0, address(0), address(0)); }\n\n    emit P2pVaultExchange(p, u, m, f, t, a);\n    return true;\n  }\n\n  /// @notice External method giving access to this functionality within a given vault\n  /// @dev Note that this method calculates yield and interest as well\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Target to be transferred to\n  /// @param a Amount of notional to be transferred\n  function transferVaultNotional(uint8 p, address u, uint256 m, address t, uint256 a) external unpaused(p) returns (bool) {\n    if (!IVaultTracker(markets[p][u][m].vaultTracker).transferNotionalFrom(msg.sender, t, a)) { revert Exception(27, 0, 0, address(0), address(0)); }\n\n    emit TransferVaultNotional(p, u, m, msg.sender, t, a);\n    return true;\n  }\n\n  /// @notice Transfers notional fee to the Swivel contract without recalculating marginal interest for from\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param f Owner of the amount\n  /// @param a Amount to transfer\n  function transferVaultNotionalFee(uint8 p, address u, uint256 m, address f, uint256 a) external authorized(swivel) returns (bool) {\n    IVaultTracker(markets[p][u][m].vaultTracker).transferNotionalFee(f, a);\n    return true;\n  }\n\n  /// @notice Called by admin at any point to pause / unpause market transactions in a specified protocol\n  /// @param p Protocol Enum value of the protocol to be paused\n  /// @param b Boolean which indicates the (protocol) markets paused status\n  function pause(uint8 p, bool b) external authorized(admin) returns (bool) {\n    paused[p] = b;\n    return true;\n  }\n\n  modifier authorized(address a) {\n    if(msg.sender != a) { revert Exception(0, 0, 0, msg.sender, a); }\n    _;\n  }\n\n  modifier unpaused(uint8 p) {\n    if(paused[p]) { revert Exception(1, 0, 0, address(0), address(0)); }\n    _;\n  }\n}"
    }
  ]
}