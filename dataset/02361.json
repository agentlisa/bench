{
  "Title": "Unsafe ABI encoding",
  "Content": "It is not an uncommon practice to use `abi.encodeWithSignature` or `abi.encodeWithSelector` to generate calldata for a low-level call. However, the first option is not safe from typographical errors, and the second option is not type-safe. The result is that both of these methods are error-prone and should be considered unsafe.\n\n\nWithin [`EIP4337Manager.sol`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Manager.sol), there are some occurrences of unsafe ABI encodings being used:\n\n\n* On [line 119](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Manager.sol#L119)\n* On [line 144](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Manager.sol#L144)\n\n\nConsider replacing all occurrences of unsafe ABI encodings with `abi.encodeCall`, which checks whether the supplied values actually match the types expected by the called function, and also avoids typographical errors.\n\n\nNote that a [bug](https://blog.soliditylang.org/2022/03/16/encodecall-bug/) related to the use of string literals as inputs to `abi.encodeCall` was fixed in version 0.8.13, so developers should exercise caution when using this function with earlier versions of Solidity.\n\n\n***Update:** Resolved in [pull request #220](https://github.com/eth-infinitism/account-abstraction/pull/220) and merged at commit [`c0a69bf`](https://github.com/eth-infinitism/account-abstraction/commit/c0a69bf34077e461f12e4d7e2146b52e7b59553b). The first example is an invalid recommendation because it is encoding an error.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/gnosis/EIP4337Manager.sol",
      "content": "//SPDX-License-Identifier: GPL\npragma solidity ^0.8.7;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol\";\nimport \"./EIP4337Fallback.sol\";\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\n\n    using ECDSA for bytes32;\n\n/**\n * Main EIP4337 module.\n * Called (through the fallback module) using \"delegate\" from the GnosisSafe as an \"IAccount\",\n * so must implement validateUserOp\n * holds an immutable reference to the EntryPoint\n * Inherits GnosisSafeStorage so that it can reference the memory storage\n */\ncontract EIP4337Manager is GnosisSafe, IAccount {\n\n    address public immutable eip4337Fallback;\n    address public immutable entryPoint;\n\n    constructor(address anEntryPoint) {\n        entryPoint = anEntryPoint;\n        eip4337Fallback = address(new EIP4337Fallback(address(this)));\n    }\n\n    /**\n     * delegate-called (using execFromModule) through the fallback, so \"real\" msg.sender is attached as last 20 bytes\n     */\n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, address /*aggregator*/, uint256 missingAccountFunds)\n    external override returns (uint256 sigTimeRange) {\n        address _msgSender = address(bytes20(msg.data[msg.data.length - 20 :]));\n        require(_msgSender == entryPoint, \"account: not from entrypoint\");\n\n        GnosisSafe pThis = GnosisSafe(payable(address(this)));\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        address recovered = hash.recover(userOp.signature);\n        require(threshold == 1, \"account: only threshold 1\");\n        require(pThis.isOwner(recovered), \"account: wrong signature\");\n\n        if (userOp.initCode.length == 0) {\n            require(nonce++ == userOp.nonce, \"account: invalid nonce\");\n        }\n\n        if (missingAccountFunds > 0) {\n            //TODO: MAY pay more than the minimum, to deposit for future transactions\n            (bool success,) = payable(_msgSender).call{value : missingAccountFunds}(\"\");\n            (success);\n            //ignore failure (its EntryPoint's job to verify, not account.)\n        }\n        return 0;\n    }\n\n    /**\n     * set up a safe as EIP-4337 enabled.\n     * called from the GnosisSafeAccountFactory during construction time\n     * - enable 3 modules (this module, fallback and the entrypoint)\n     * - this method is called with delegateCall, so the module (usually itself) is passed as parameter, and \"this\" is the safe itself\n     */\n    function setup4337Modules(\n        EIP4337Manager manager //the manager (this contract)\n    ) external {\n        GnosisSafe safe = GnosisSafe(payable(this));\n        safe.enableModule(manager.entryPoint());\n        safe.enableModule(manager.eip4337Fallback());\n    }\n\n    /**\n     * replace EIP4337 module, to support a new EntryPoint.\n     * must be called using execTransaction and Enum.Operation.DelegateCall\n     * @param prevModule returned by getCurrentEIP4337Manager\n     * @param oldManager the old EIP4337 manager to remove, returned by getCurrentEIP4337Manager\n     * @param newManager the new EIP4337Manager, usually with a new EntryPoint\n     */\n    function replaceEIP4337Manager(address prevModule, EIP4337Manager oldManager, EIP4337Manager newManager) public {\n\n        GnosisSafe pThis = GnosisSafe(payable(address(this)));\n        address oldFallback = oldManager.eip4337Fallback();\n        require(pThis.isModuleEnabled(oldFallback), \"replaceEIP4337Manager: oldManager is not active\");\n        pThis.disableModule(oldFallback, oldManager.entryPoint());\n        pThis.disableModule(prevModule, oldFallback);\n\n        address eip4337fallback = newManager.eip4337Fallback();\n\n        pThis.enableModule(newManager.entryPoint());\n        pThis.enableModule(eip4337fallback);\n\n        pThis.setFallbackHandler(eip4337fallback);\n\n        validateEip4337(pThis, newManager);\n    }\n\n    /**\n     * Validate this gnosisSafe is callable through the EntryPoint.\n     * the test is might be incomplete: we check that we reach our validateUserOp and fail on signature.\n     *  we don't test full transaction\n     */\n    function validateEip4337(GnosisSafe safe, EIP4337Manager manager) public {\n\n        // this prevent mistaken replaceEIP4337Manager to disable the module completely.\n        // minimal signature that pass \"recover\"\n        bytes memory sig = new bytes(65);\n        sig[64] = bytes1(uint8(27));\n        sig[2] = bytes1(uint8(1));\n        sig[35] = bytes1(uint8(1));\n        UserOperation memory userOp = UserOperation(address(safe), 0, \"\", \"\", 0, 1000000, 0, 0, 0, \"\", sig);\n        UserOperation[] memory userOps = new UserOperation[](1);\n        userOps[0] = userOp;\n        IEntryPoint _entryPoint = IEntryPoint(payable(manager.entryPoint()));\n        try _entryPoint.handleOps(userOps, payable(msg.sender)) {\n            revert(\"validateEip4337: handleOps must fail\");\n        } catch (bytes memory error) {\n            if (keccak256(error) != keccak256(abi.encodeWithSignature(\"FailedOp(uint256,address,string)\", 0, address(0), \"account: wrong signature\"))) {\n                revert(string(error));\n            }\n        }\n    }\n\n    function delegateCall(address to, bytes memory data) internal {\n        bool success;\n        assembly {\n            success := delegatecall(sub(0, 1), to, add(data, 0x20), mload(data), 0, 0)\n        }\n        require(success, \"delegate failed\");\n    }\n\n    /**\n     * enumerate modules, and find the currently active EIP4337 manager (and previous module)\n     * @return prev prev module, needed by replaceEIP4337Manager\n     * @return manager the current active EIP4337Manager\n     */\n    function getCurrentEIP4337Manager(GnosisSafe safe) public view returns (address prev, address manager) {\n\n        prev = address(SENTINEL_MODULES);\n        (address[] memory modules,) = safe.getModulesPaginated(SENTINEL_MODULES, 100);\n        for (uint i = 0; i < modules.length; i++) {\n            address module = modules[i];\n            (bool success,bytes memory ret) = module.staticcall(abi.encodeWithSignature(\"eip4337manager()\"));\n            if (success) {\n                manager = abi.decode(ret, (address));\n                return (prev, manager);\n            }\n            prev = module;\n        }\n        return (address(0), address(0));\n    }\n}"
    },
    {
      "filename": "contracts/gnosis/EIP4337Manager.sol",
      "content": "//SPDX-License-Identifier: GPL\npragma solidity ^0.8.7;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol\";\nimport \"./EIP4337Fallback.sol\";\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\n\n    using ECDSA for bytes32;\n\n/**\n * Main EIP4337 module.\n * Called (through the fallback module) using \"delegate\" from the GnosisSafe as an \"IAccount\",\n * so must implement validateUserOp\n * holds an immutable reference to the EntryPoint\n * Inherits GnosisSafeStorage so that it can reference the memory storage\n */\ncontract EIP4337Manager is GnosisSafe, IAccount {\n\n    address public immutable eip4337Fallback;\n    address public immutable entryPoint;\n\n    constructor(address anEntryPoint) {\n        entryPoint = anEntryPoint;\n        eip4337Fallback = address(new EIP4337Fallback(address(this)));\n    }\n\n    /**\n     * delegate-called (using execFromModule) through the fallback, so \"real\" msg.sender is attached as last 20 bytes\n     */\n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, address /*aggregator*/, uint256 missingAccountFunds)\n    external override returns (uint256 sigTimeRange) {\n        address _msgSender = address(bytes20(msg.data[msg.data.length - 20 :]));\n        require(_msgSender == entryPoint, \"account: not from entrypoint\");\n\n        GnosisSafe pThis = GnosisSafe(payable(address(this)));\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        address recovered = hash.recover(userOp.signature);\n        require(threshold == 1, \"account: only threshold 1\");\n        require(pThis.isOwner(recovered), \"account: wrong signature\");\n\n        if (userOp.initCode.length == 0) {\n            require(nonce++ == userOp.nonce, \"account: invalid nonce\");\n        }\n\n        if (missingAccountFunds > 0) {\n            //TODO: MAY pay more than the minimum, to deposit for future transactions\n            (bool success,) = payable(_msgSender).call{value : missingAccountFunds}(\"\");\n            (success);\n            //ignore failure (its EntryPoint's job to verify, not account.)\n        }\n        return 0;\n    }\n\n    /**\n     * set up a safe as EIP-4337 enabled.\n     * called from the GnosisSafeAccountFactory during construction time\n     * - enable 3 modules (this module, fallback and the entrypoint)\n     * - this method is called with delegateCall, so the module (usually itself) is passed as parameter, and \"this\" is the safe itself\n     */\n    function setup4337Modules(\n        EIP4337Manager manager //the manager (this contract)\n    ) external {\n        GnosisSafe safe = GnosisSafe(payable(this));\n        safe.enableModule(manager.entryPoint());\n        safe.enableModule(manager.eip4337Fallback());\n    }\n\n    /**\n     * replace EIP4337 module, to support a new EntryPoint.\n     * must be called using execTransaction and Enum.Operation.DelegateCall\n     * @param prevModule returned by getCurrentEIP4337Manager\n     * @param oldManager the old EIP4337 manager to remove, returned by getCurrentEIP4337Manager\n     * @param newManager the new EIP4337Manager, usually with a new EntryPoint\n     */\n    function replaceEIP4337Manager(address prevModule, EIP4337Manager oldManager, EIP4337Manager newManager) public {\n\n        GnosisSafe pThis = GnosisSafe(payable(address(this)));\n        address oldFallback = oldManager.eip4337Fallback();\n        require(pThis.isModuleEnabled(oldFallback), \"replaceEIP4337Manager: oldManager is not active\");\n        pThis.disableModule(oldFallback, oldManager.entryPoint());\n        pThis.disableModule(prevModule, oldFallback);\n\n        address eip4337fallback = newManager.eip4337Fallback();\n\n        pThis.enableModule(newManager.entryPoint());\n        pThis.enableModule(eip4337fallback);\n\n        pThis.setFallbackHandler(eip4337fallback);\n\n        validateEip4337(pThis, newManager);\n    }\n\n    /**\n     * Validate this gnosisSafe is callable through the EntryPoint.\n     * the test is might be incomplete: we check that we reach our validateUserOp and fail on signature.\n     *  we don't test full transaction\n     */\n    function validateEip4337(GnosisSafe safe, EIP4337Manager manager) public {\n\n        // this prevent mistaken replaceEIP4337Manager to disable the module completely.\n        // minimal signature that pass \"recover\"\n        bytes memory sig = new bytes(65);\n        sig[64] = bytes1(uint8(27));\n        sig[2] = bytes1(uint8(1));\n        sig[35] = bytes1(uint8(1));\n        UserOperation memory userOp = UserOperation(address(safe), 0, \"\", \"\", 0, 1000000, 0, 0, 0, \"\", sig);\n        UserOperation[] memory userOps = new UserOperation[](1);\n        userOps[0] = userOp;\n        IEntryPoint _entryPoint = IEntryPoint(payable(manager.entryPoint()));\n        try _entryPoint.handleOps(userOps, payable(msg.sender)) {\n            revert(\"validateEip4337: handleOps must fail\");\n        } catch (bytes memory error) {\n            if (keccak256(error) != keccak256(abi.encodeWithSignature(\"FailedOp(uint256,address,string)\", 0, address(0), \"account: wrong signature\"))) {\n                revert(string(error));\n            }\n        }\n    }\n\n    function delegateCall(address to, bytes memory data) internal {\n        bool success;\n        assembly {\n            success := delegatecall(sub(0, 1), to, add(data, 0x20), mload(data), 0, 0)\n        }\n        require(success, \"delegate failed\");\n    }\n\n    /**\n     * enumerate modules, and find the currently active EIP4337 manager (and previous module)\n     * @return prev prev module, needed by replaceEIP4337Manager\n     * @return manager the current active EIP4337Manager\n     */\n    function getCurrentEIP4337Manager(GnosisSafe safe) public view returns (address prev, address manager) {\n\n        prev = address(SENTINEL_MODULES);\n        (address[] memory modules,) = safe.getModulesPaginated(SENTINEL_MODULES, 100);\n        for (uint i = 0; i < modules.length; i++) {\n            address module = modules[i];\n            (bool success,bytes memory ret) = module.staticcall(abi.encodeWithSignature(\"eip4337manager()\"));\n            if (success) {\n                manager = abi.decode(ret, (address));\n                return (prev, manager);\n            }\n            prev = module;\n        }\n        return (address(0), address(0));\n    }\n}"
    }
  ]
}