{
  "Title": "[L-01]",
  "Content": "<h2 id=\"l-01\" style=\"position:relative;\"><a href=\"#l-01\" aria-label=\"l 01 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-01]</h2>\n<p>It’s possible to call the method <a href=\"https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/AssetsRegistry.sol#L60\">addAsset</a> multiple times with the same <code>_underlying</code>, if you call <code>addAsset</code> with empty <code>symbol</code> it will bypass the <a href=\"https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/AssetsRegistry.sol#L37\">validAsset</a> modifier, and it will be possible to call again the <code>addAsset</code> with different values. It will produce a mismatch with the reality and <code>getAssetsLength</code>.</p>\n<p>This could cause a loss of funds if it is not verified before that this <code>symbol</code> is other than empty. It is mandatory to add a require to verify that the <code>symbol</code> is not empty. It’s also recommended to add a require in <a href=\"https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L24\">_assetSymbol</a> to ensure non-existence tokens are returned.</p>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-03-rolla-contest",
  "Code": [
    {
      "filename": "quant-protocol/contracts/options/AssetsRegistry.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IQuantConfig.sol\";\nimport \"../interfaces/IAssetsRegistry.sol\";\n\n/// @title For managing assets supported as underlying for options in the Quant Protocol\n/// @author Rolla\ncontract AssetsRegistry is IAssetsRegistry {\n    struct AssetProperties {\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n\n    IQuantConfig private _quantConfig;\n\n    /// @inheritdoc IAssetsRegistry\n    mapping(address => AssetProperties) public override assetProperties;\n\n    /// @inheritdoc IAssetsRegistry\n    address[] public override registeredAssets;\n\n    /// @dev Checks that the `msg.sender` has permission to add assets to the registry.\n    /// @dev Also checks that the asset had not been added before.\n    modifier validAsset(address _underlying) {\n        require(\n            _quantConfig.hasRole(\n                _quantConfig.quantRoles(\"ASSETS_REGISTRY_MANAGER_ROLE\"),\n                msg.sender\n            ),\n            \"AssetsRegistry: only asset registry managers can add assets\"\n        );\n\n        require(\n            bytes(assetProperties[_underlying].symbol).length == 0,\n            \"AssetsRegistry: asset already added\"\n        );\n\n        _;\n    }\n\n    /// @param quantConfig_ address of the Quant central configuration contract\n    constructor(address quantConfig_) {\n        require(\n            quantConfig_ != address(0),\n            \"AssetsRegistry: invalid QuantConfig address\"\n        );\n\n        _quantConfig = IQuantConfig(quantConfig_);\n    }\n\n    /// @inheritdoc IAssetsRegistry\n    function addAsset(\n        address _underlying,\n        string calldata _name,\n        string calldata _symbol,\n        uint8 _decimals\n    ) external override validAsset(_underlying) {\n        assetProperties[_underlying] = AssetProperties(\n            _name,\n            _symbol,\n            _decimals\n        );\n\n        registeredAssets.push(_underlying);\n\n        emit AssetAdded(_underlying, _name, _symbol, _decimals);\n    }\n\n    /// @inheritdoc IAssetsRegistry\n    function addAssetWithOptionalERC20Methods(address _underlying)\n        external\n        override\n        validAsset(_underlying)\n    {\n        string memory name = ERC20(_underlying).name();\n        require(bytes(name).length > 0, \"AssetsRegistry: invalid empty name\");\n\n        string memory symbol = ERC20(_underlying).symbol();\n        require(\n            bytes(symbol).length > 0,\n            \"AssetsRegistry: invalid empty symbol\"\n        );\n\n        uint8 decimals = ERC20(_underlying).decimals();\n        require(decimals > 0, \"AssetsRegistry: invalid zero decimals\");\n\n        assetProperties[_underlying] = AssetProperties(name, symbol, decimals);\n\n        registeredAssets.push(_underlying);\n\n        emit AssetAdded(_underlying, name, symbol, decimals);\n    }\n\n    /// @inheritdoc IAssetsRegistry\n    function getAssetsLength() external view override returns (uint256) {\n        return registeredAssets.length;\n    }\n}"
    },
    {
      "filename": "quant-protocol/contracts/options/QTokenStringUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@quant-finance/solidity-datetime/contracts/DateTime.sol\";\nimport \"../interfaces/IAssetsRegistry.sol\";\nimport \"../interfaces/IQuantConfig.sol\";\nimport \"../libraries/ProtocolValue.sol\";\n\nabstract contract QTokenStringUtils {\n    /// @notice get the ERC20 token symbol from the AssetsRegistry\n    /// @dev the asset is assumed to be in the AssetsRegistry since QTokens\n    /// must be created through the OptionsFactory, which performs that check\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _asset address of the asset in the AssetsRegistry\n    /// @return assetSymbol string stored as the ERC20 token symbol\n    function _assetSymbol(address _quantConfig, address _asset)\n        internal\n        view\n        virtual\n        returns (string memory assetSymbol)\n    {\n        (, assetSymbol, ) = IAssetsRegistry(\n            IQuantConfig(_quantConfig).protocolAddresses(\n                ProtocolValue.encode(\"assetsRegistry\")\n            )\n        ).assetProperties(_asset);\n    }\n\n    /// @notice generates the name for an option\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _underlyingAsset asset that the option references\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _isCall true if it's a call option, false if it's a put option\n    /// @return tokenName name string for the QToken\n    function _qTokenName(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenName) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\n        // convert the expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(\n            _expiryTime\n        );\n\n        // get option type string\n        (, string memory typeFull) = _getOptionType(_isCall);\n\n        // get option month string\n        (, string memory monthFull) = _getMonth(month);\n\n        /// concatenated name string\n        tokenName = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \" \",\n                underlying,\n                \" \",\n                _uintToChars(day),\n                \"-\",\n                monthFull,\n                \"-\",\n                Strings.toString(year),\n                \" \",\n                displayStrikePrice,\n                \" \",\n                typeFull\n            )\n        );\n    }\n\n    /// @notice generates the symbol for an option\n    /// @param _underlyingAsset asset that the option references\n    /// @param _quantConfig address of the Quant system configuration contract\n    /// @param _strikePrice strike price with as many decimals in the strike asset\n    /// @param _expiryTime expiration timestamp as a unix timestamp\n    /// @param _isCall true if it's a call option, false if it's a put option\n    /// @return tokenSymbol symbol string for the QToken\n    function _qTokenSymbol(\n        address _quantConfig,\n        address _underlyingAsset,\n        address _strikeAsset,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        bool _isCall\n    ) internal view virtual returns (string memory tokenSymbol) {\n        string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);\n        string memory displayStrikePrice = _displayedStrikePrice(\n            _strikePrice,\n            _strikeAsset\n        );\n\n        // convert the expiry to a readable string\n        (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(\n            _expiryTime\n        );\n\n        // get option type string\n        (string memory typeSymbol, ) = _getOptionType(_isCall);\n\n        // get option month string\n        (string memory monthSymbol, ) = _getMonth(month);\n\n        /// concatenated symbol string\n        tokenSymbol = string(\n            abi.encodePacked(\n                \"ROLLA\",\n                \"-\",\n                underlying,\n                \"-\",\n                _uintToChars(day),\n                monthSymbol,\n                _uintToChars(year),\n                \"-\",\n                displayStrikePrice,\n                \"-\",\n                typeSymbol\n            )\n        );\n    }\n\n    /// @dev convert the option strike price scaled to a human readable value\n    /// @param _strikePrice the option strike price scaled by 1e20\n    /// @return strike price string\n    function _displayedStrikePrice(uint256 _strikePrice, address _strikeAsset)\n        internal\n        view\n        virtual\n        returns (string memory)\n    {\n        uint256 strikePriceDigits = ERC20(_strikeAsset).decimals();\n        uint256 strikePriceScale = 10**strikePriceDigits;\n        uint256 remainder = _strikePrice % strikePriceScale;\n        uint256 quotient = _strikePrice / strikePriceScale;\n        string memory quotientStr = Strings.toString(quotient);\n\n        if (remainder == 0) {\n            return quotientStr;\n        }\n\n        uint256 trailingZeroes;\n        while (remainder % 10 == 0) {\n            remainder /= 10;\n            trailingZeroes++;\n        }\n\n        // pad the number with \"1 + starting zeroes\"\n        remainder += 10**(strikePriceDigits - trailingZeroes);\n\n        string memory tmp = Strings.toString(remainder);\n        tmp = _slice(tmp, 1, (1 + strikePriceDigits) - trailingZeroes);\n\n        return string(abi.encodePacked(quotientStr, \".\", tmp));\n    }\n\n    /// @dev get the string representation of the option type\n    /// @return a 1 character representation of the option type\n    /// @return a full length string of the option type\n    function _getOptionType(bool _isCall)\n        internal\n        pure\n        virtual\n        returns (string memory, string memory)\n    {\n        return _isCall ? (\"C\", \"Call\") : (\"P\", \"Put\");\n    }\n\n    /// @dev get the representation of a number using 2 characters, adding a leading 0 if it's one digit,\n    /// and two trailing digits if it's a 3 digit number\n    /// @return 2 characters that correspond to a number\n    function _uintToChars(uint256 _number)\n        internal\n        pure\n        virtual\n        returns (string memory)\n    {\n        if (_number > 99) {\n            _number %= 100;\n        }\n\n        string memory str = Strings.toString(_number);\n\n        if (_number < 10) {\n            return string(abi.encodePacked(\"0\", str));\n        }\n\n        return str;\n    }\n\n    /// @dev cut a string into string[start:end]\n    /// @param _s string to cut\n    /// @param _start the starting index\n    /// @param _end the ending index (not inclusive)\n    /// @return the indexed string\n    function _slice(\n        string memory _s,\n        uint256 _start,\n        uint256 _end\n    ) internal pure virtual returns (string memory) {\n        uint256 range = _end - _start;\n        bytes memory slice = new bytes(range);\n        for (uint256 i = 0; i < range; ) {\n            slice[i] = bytes(_s)[_start + 1];\n            unchecked {\n                ++i;\n            }\n        }\n\n        return string(slice);\n    }\n\n    /// @dev get the string representations of a month\n    /// @return a 3 character representation\n    /// @return a full length string representation\n    function _getMonth(uint256 _month)\n        internal\n        pure\n        virtual\n        returns (string memory, string memory)\n    {\n        if (_month == 1) {\n            return (\"JAN\", \"January\");\n        } else if (_month == 2) {\n            return (\"FEB\", \"February\");\n        } else if (_month == 3) {\n            return (\"MAR\", \"March\");\n        } else if (_month == 4) {\n            return (\"APR\", \"April\");\n        } else if (_month == 5) {\n            return (\"MAY\", \"May\");\n        } else if (_month == 6) {\n            return (\"JUN\", \"June\");\n        } else if (_month == 7) {\n            return (\"JUL\", \"July\");\n        } else if (_month == 8) {\n            return (\"AUG\", \"August\");\n        } else if (_month == 9) {\n            return (\"SEP\", \"September\");\n        } else if (_month == 10) {\n            return (\"OCT\", \"October\");\n        } else if (_month == 11) {\n            return (\"NOV\", \"November\");\n        } else {\n            return (\"DEC\", \"December\");\n        }\n    }\n}"
    }
  ]
}