{
  "Title": "[M-02] Minter / Staker / Spender roles can never be revoked",
  "Content": "\nFrom [Neuron::addMinter](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/Neuron.sol#L93-L96) and [AccessControl::setupRole](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ecd2ca2cd7cac116f7a37d0e474bbb3d7d5e1c4d/contracts/access/AccessControl.sol#L194-L207)\n\n```solidity\n    function addMinter(address newMinterAddress) external {\n        require(msg.sender == _ownerAddress);\n        _setupRole(MINTER_ROLE, newMinterAddress);\n    }\n\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n```\n\n*   Roles of minter, staker, spender can never be revoked due to missing default admin implementation. The `DEFAULT_ADMIN_ROLE` = 0x00 which is default role which is admin to all the roles, and the real contract owner should  own this role, since it is not granted, the owner cannot govern the roles.\n\n*   Another wrong implemnatation is using `_setupRole` to grant roles intead of using `_grantRole`, because of the warnings in the library contract.\n\nFrom [Openzeppelin::AccessControl](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ecd2ca2cd7cac116f7a37d0e474bbb3d7d5e1c4d/contracts/access/AccessControl.sol#L40-L47) and [AccessControl::setupRole](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ecd2ca2cd7cac116f7a37d0e474bbb3d7d5e1c4d/contracts/access/AccessControl.sol#L194-L207)\n\n```solidity\n\n* [WARNING]\n    * ====\n    * This function should only be called from the constructor when setting\n    * up the initial roles for the system.\n    *\n    * Using this function in any other way is effectively circumventing the admin\n    * system imposed by {AccessControl}.\n    * ====\n    *\n    * NOTE: This function is deprecated in favor of {_grantRole}.\n    */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    * Roles can be granted and revoked dynamically via the {grantRole} and\n    * {revokeRole} functions. Each role has an associated admin role, and only\n    * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n    *\n    * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n    * that only accounts with this role will be able to grant or revoke other\n    * roles. More complex role relationships can be created by using\n    * {_setRoleAdmin}.\n    *\n    * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n    * grant and revoke this role. Extra precautions should be taken to secure\n    * accounts that have been granted it.\n    */\n\n```\n\n### Proof of Concept\n\n*   As you can see the owner cannot revoke becasue there is no admin for that role, owner should be a default admin for all the roles granted.\n\n```\n[PASS] test_POC_Revoke() (gas: 72392)\nTraces:\n  [72392] NeuronTest::test_POC_Revoke() \n    ├─ [27181] Neuron::addMinter(NeuronTest: [0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496]) \n    │   ├─ emit RoleGranted(role: 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6, account: NeuronTest: [0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496], sender: NeuronTest: [0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496])\n    │   └─ ← ()\n    ├─ [0] VM::expectRevert() \n    │   └─ ← ()\n    ├─ [34420] Neuron::revokeRole(0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6, NeuronTest: [0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496]) \n    │   └─ ← \"AccessControl: account 0x7fa9385be102ac3eac297483dd6233d62b3e1496 is missing role 0x0000000000000000000000000000000000000000000000000000000000000000\"\n    └─ ← ()\n```\n\n- Now paste the below POC into [test/Neuron.t.sol](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/test/Neuron.t.sol#L39) and run `forge t --mt test_POC_Revoke -vvvv`.\n\n```solidity\n\n    function test_POC_Revoke() external {\n        _neuronContract.addMinter(_ownerAddress);\n\n        vm.expectRevert();\n        _neuronContract.revokeRole(keccak256(\"MINTER_ROLE\"), _ownerAddress);\n    }\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nModify the constructor on [Neuron.sol](https://github.com/code-423n4/2024-02-ai-arena/blob/cd1a0e6d1b40168657d1aaee8223dc050e15f8cc/src/Neuron.sol#L68-L77) to grant default admin role to owner.\n\n```diff\n    constructor(address ownerAddress, address treasuryAddress_, address contributorAddress)\n        ERC20(\"Neuron\", \"NRN\")\n    {\n        _ownerAddress = ownerAddress;\n        treasuryAddress = treasuryAddress_;\n        isAdmin[_ownerAddress] = true;\n        _mint(treasuryAddress, INITIAL_TREASURY_MINT);\n        _mint(contributorAddress, INITIAL_CONTRIBUTOR_MINT);\n\n+       _grantRole(DEFAULT_ADMIN_ROLE, _ownerAddress);\n    }\n```\n\n**[hickuphh3 (judge) commented](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1507#issuecomment-1978135833):**\n > Selecting as best report because it also mentions that `_grantRole` should be used instead of `_setupRole`.\n > \n > I'm excluding admin error in this. Simply about functionality: not being able to revoke roles might be problematic for deprecation / migration purposes.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-ai-arena",
  "Code": [
    {
      "filename": "src/Neuron.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/// @title Neuron\n/// @author ArenaX Labs Inc.\n/// @notice ERC20 token contract representing Neuron (NRN) tokens.\n/// @dev The Neuron token is used for AI Arena's in-game economy.\ncontract Neuron is ERC20, AccessControl {\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when tokens are claimed.\n    event TokensClaimed(address user, uint256 amount);\n\n    /// @notice Event emitted when tokens are minted.\n    event TokensMinted(address user, uint256 amount);    \n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Role for minting tokens.\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    /// @notice Role for spending tokens.\n    bytes32 public constant SPENDER_ROLE = keccak256(\"SPENDER_ROLE\");\n    \n    /// @notice Role for staking tokens.\n    bytes32 public constant STAKER_ROLE = keccak256(\"STAKER_ROLE\");\n\n    /// @notice Initial supply of NRN tokens to be minted to the treasury.\n    uint256 public constant INITIAL_TREASURY_MINT = 10**18 * 10**8 * 2;\n\n    /// @notice Initial supply of NRN tokens to be minted and distributed to contributors.\n    uint256 public constant INITIAL_CONTRIBUTOR_MINT = 10**18 * 10**8 * 5;\n\n    /// @notice Maximum supply of NRN tokens.\n    uint256 public constant MAX_SUPPLY = 10**18 * 10**9;\n\n    /// @notice The address of treasury.\n    address public treasuryAddress;\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping of address to admin status.\n    mapping(address => bool) public isAdmin;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Grants roles to the ranked battle contract. \n    /// @notice Mints the initial supply of tokens.\n    /// @param ownerAddress The address of the owner who deploys the contract\n    /// @param treasuryAddress_ The address of the community treasury\n    /// @param contributorAddress The address that will distribute NRNs to early contributors when \n    /// the initial supply is minted.\n    constructor(address ownerAddress, address treasuryAddress_, address contributorAddress)\n        ERC20(\"Neuron\", \"NRN\")\n    {\n        _ownerAddress = ownerAddress;\n        treasuryAddress = treasuryAddress_;\n        isAdmin[_ownerAddress] = true;\n        _mint(treasuryAddress, INITIAL_TREASURY_MINT);\n        _mint(contributorAddress, INITIAL_CONTRIBUTOR_MINT);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Adds a new address to the minter role.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newMinterAddress The address to be added as a minter\n    function addMinter(address newMinterAddress) external {\n        require(msg.sender == _ownerAddress);\n        _setupRole(MINTER_ROLE, newMinterAddress);\n    }\n\n    /// @notice Adds a new address to the staker role.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newStakerAddress The address to be added as a staker\n    function addStaker(address newStakerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _setupRole(STAKER_ROLE, newStakerAddress);\n    }\n\n    /// @notice Adds a new address to the spender role.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newSpenderAddress The address to be added as a spender\n    function addSpender(address newSpenderAddress) external {\n        require(msg.sender == _ownerAddress);\n        _setupRole(SPENDER_ROLE, newSpenderAddress);\n    }\n\n    /// @notice Adjusts admin access for a user.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param adminAddress The address of the admin.\n    /// @param access Whether the address has admin access or not.\n    function adjustAdminAccess(address adminAddress, bool access) external {\n        require(msg.sender == _ownerAddress);\n        isAdmin[adminAddress] = access;\n    }  \n\n    /// @notice Sets up the allowance from the treasury address to transfer to each recipient address.\n    /// @dev Only admins are authorized to call this function.\n    /// @param recipients The array of recipient addresses\n    /// @param amounts The array of corresponding amounts for each recipient\n    function setupAirdrop(address[] calldata recipients, uint256[] calldata amounts) external {\n        require(isAdmin[msg.sender]);\n        require(recipients.length == amounts.length);\n        uint256 recipientsLength = recipients.length;\n        for (uint32 i = 0; i < recipientsLength; i++) {\n            _approve(treasuryAddress, recipients[i], amounts[i]);\n        }\n    }\n\n    /// @notice Claims the specified amount of tokens from the treasury address to the caller's address.\n    /// @param amount The amount to be claimed\n    function claim(uint256 amount) external {\n        require(\n            allowance(treasuryAddress, msg.sender) >= amount, \n            \"ERC20: claim amount exceeds allowance\"\n        );\n        transferFrom(treasuryAddress, msg.sender, amount);\n        emit TokensClaimed(msg.sender, amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mints the specified amount of tokens to the given address.\n    /// @dev The caller must have the minter role.\n    /// @param to The address to which the tokens will be minted.\n    /// @param amount The amount of tokens to be minted.\n    function mint(address to, uint256 amount) public virtual {\n        require(totalSupply() + amount < MAX_SUPPLY, \"Trying to mint more than the max supply\");\n        require(hasRole(MINTER_ROLE, msg.sender), \"ERC20: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /// @notice Burns the specified amount of tokens from the caller's address.\n    /// @param amount The amount of tokens to be burned.\n    function burn(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n    }\n\n    /// @notice Approves the specified amount of tokens for the spender address.\n    /// @dev The caller must have the spender role.\n    /// @param account The account for which to approve the allowance.\n    /// @param amount The amount of tokens to be approved.\n    function approveSpender(address account, uint256 amount) public {\n        require(\n            hasRole(SPENDER_ROLE, msg.sender), \n            \"ERC20: must have spender role to approve spending\"\n        );\n        _approve(account, msg.sender, amount);\n    }\n\n    /// @notice Approves the specified amount of tokens for the staker address.\n    /// @dev The caller must have the staker role.\n    /// @param owner The owner of the tokens.\n    /// @param spender The address for which to approve the allowance.\n    /// @param amount The amount of tokens to be approved.\n    function approveStaker(address owner, address spender, uint256 amount) public {\n        require(\n            hasRole(STAKER_ROLE, msg.sender), \n            \"ERC20: must have staker role to approve staking\"\n        );\n        _approve(owner, spender, amount);\n    }\n\n    /// @notice Burns the specified amount of tokens from the account address.\n    /// The caller must have an allowance greater than or equal to the amount.\n    /// @param account The account from which to burn the tokens\n    /// @param amount The amount of tokens to be burned\n    function burnFrom(address account, uint256 amount) public virtual {\n        require(\n            allowance(account, msg.sender) >= amount, \n            \"ERC20: burn amount exceeds allowance\"\n        );\n        uint256 decreasedAllowance = allowance(account, msg.sender) - amount;\n        _burn(account, amount);\n        _approve(account, msg.sender, decreasedAllowance);\n    }\n \n}"
    },
    {
      "filename": "contracts/access/AccessControl.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}"
    },
    {
      "filename": "test/Neuron.t.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {Test, console} from \"forge-std/Test.sol\";\nimport {Vm} from \"forge-std/Vm.sol\";\nimport {FighterFarm} from \"../src/FighterFarm.sol\";\nimport {Neuron} from \"../src/Neuron.sol\";\nimport {AAMintPass} from \"../src/AAMintPass.sol\";\nimport {MergingPool} from \"../src/MergingPool.sol\";\nimport {RankedBattle} from \"../src/RankedBattle.sol\";\nimport {VoltageManager} from \"../src/VoltageManager.sol\";\nimport {GameItems} from \"../src/GameItems.sol\";\nimport {AiArenaHelper} from \"../src/AiArenaHelper.sol\";\n\ncontract NeuronTest is Test {\n    /*//////////////////////////////////////////////////////////////\n                                CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n    address internal constant _DELEGATED_ADDRESS = 0x22F4441ad6DbD602dFdE5Cd8A38F6CAdE68860b0;\n    address internal _ownerAddress;\n    address internal _treasuryAddress;\n    address internal _neuronContributorAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                             CONTRACT INSTANCES\n    //////////////////////////////////////////////////////////////*/\n    Neuron internal _neuronContract;\n\n    /*//////////////////////////////////////////////////////////////\n                                SETUP\n    //////////////////////////////////////////////////////////////*/\n\n    function setUp() public {\n        _ownerAddress = address(this);\n        _treasuryAddress = vm.addr(1);\n        _neuronContributorAddress = vm.addr(2);\n        _neuronContract = new Neuron(_ownerAddress, _treasuryAddress, _neuronContributorAddress);\n    }\n\n    /// @notice Test owner transferring ownership and new owner calling only owner functions.\n    function testTransferOwnershipFromOwner() public {\n        _neuronContract.transferOwnership(_DELEGATED_ADDRESS);\n        vm.prank(_DELEGATED_ADDRESS);\n        _neuronContract.addMinter(_DELEGATED_ADDRESS);\n        assertEq(_neuronContract.hasRole(keccak256(\"MINTER_ROLE\"), _DELEGATED_ADDRESS), true);\n    }\n\n    /// @notice Test transferring ownership from an non owner account.\n    function testRevertTransferOwnershipFromNonOwner() public {\n        vm.prank(msg.sender);\n        vm.expectRevert();\n        _neuronContract.transferOwnership(msg.sender);\n    }\n\n    /// @notice Test owner adding MINTER_ROLE to an address.\n    function testAddMinterFromOwner() public {\n        _neuronContract.addMinter(_DELEGATED_ADDRESS);\n        assertEq(_neuronContract.hasRole(keccak256(\"MINTER_ROLE\"), _DELEGATED_ADDRESS), true);\n    }\n\n    /// @notice Test an non owner, adding MINTER_ROLE to an address failing.\n    function testRevertAddMinterFromNonOwner() public {\n        vm.prank(msg.sender);\n        vm.expectRevert();\n        _neuronContract.addMinter(_DELEGATED_ADDRESS);\n        assertEq(_neuronContract.hasRole(keccak256(\"MINTER_ROLE\"), _DELEGATED_ADDRESS), false);\n    }\n\n    /// @notice Test owner adding STAKER_ROLE to an address.\n    function testAddStakerFromOwner() public {\n        _neuronContract.addStaker(_DELEGATED_ADDRESS);\n        assertEq(_neuronContract.hasRole(keccak256(\"STAKER_ROLE\"), _DELEGATED_ADDRESS), true);\n    }\n\n    /// @notice Test an non owner, adding STAKER_ROLE to an address failing.\n    function testRevertAddStakerFromNonOwner() public {\n        vm.prank(msg.sender);\n        vm.expectRevert();\n        _neuronContract.addStaker(_DELEGATED_ADDRESS);\n        assertEq(_neuronContract.hasRole(keccak256(\"STAKER_ROLE\"), _DELEGATED_ADDRESS), false);\n    }\n\n    /// @notice Test owner adding SPENDER_ROLE to an address.\n    function testAddSpenderFromOwner() public {\n        _neuronContract.addSpender(_DELEGATED_ADDRESS);\n        assertEq(_neuronContract.hasRole(keccak256(\"SPENDER_ROLE\"), _DELEGATED_ADDRESS), true);\n    }\n\n    /// @notice Test an non owner, adding SPENDER_ROLE to an address failing.\n    function testRevertAddSpenderFromNonOwner() public {\n        vm.prank(msg.sender);\n        vm.expectRevert();\n        _neuronContract.addSpender(_DELEGATED_ADDRESS);\n        assertEq(_neuronContract.hasRole(keccak256(\"SPENDER_ROLE\"), _DELEGATED_ADDRESS), false);\n    }\n\n    /// @notice Test adjusting admin access from owner.\n    function testAdjustAdminAccessFromOwner() public {\n        _neuronContract.adjustAdminAccess(_DELEGATED_ADDRESS, true);\n        assertEq(_neuronContract.isAdmin(_DELEGATED_ADDRESS), true);\n    }\n\n    /// @notice Test adjusting admin access from a non owner account failing.\n    function testAdjustAdminAccessFromNonOwner() public {\n        vm.startPrank(msg.sender);\n        vm.expectRevert();\n        _neuronContract.adjustAdminAccess(_DELEGATED_ADDRESS, true);\n        assertEq(_neuronContract.isAdmin(_DELEGATED_ADDRESS), false);\n    }\n\n    /// @notice Test admin setting up airdrop and checking if the correct allowances were set.\n    function testSetupAirdropFromAdmin() public {\n        address[] memory recipients = new address[](2);\n        recipients[0] = vm.addr(3);\n        recipients[1] = vm.addr(4);\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 1_000 * 10 ** 18;\n        amounts[1] = amounts[0];\n        _neuronContract.setupAirdrop(recipients, amounts);\n        uint256 firstRecipient = _neuronContract.allowance(_treasuryAddress, recipients[0]);\n        uint256 secondRecipient = _neuronContract.allowance(_treasuryAddress, recipients[1]);\n        assertEq(firstRecipient, amounts[0]);\n        assertEq(secondRecipient, amounts[0]);\n    }\n\n    /// @notice Test a non admin setting up airdrop reverting.\n    function testRevertSetupAirdropFromNonAdmin() public {\n        address[] memory recipients = new address[](1);\n        recipients[0] = vm.addr(3);\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = 1_000 * 10 ** 18;\n        vm.startPrank(msg.sender);\n        vm.expectRevert();\n        _neuronContract.setupAirdrop(recipients, amounts);\n        uint256 allowance = _neuronContract.allowance(_treasuryAddress, recipients[0]);\n        assertEq(allowance, 0);\n    }\n\n    /// @notice Test claiming an airdrop from an account that has an valid allowance.\n    function testClamAirdropAccountWithAllowance() public {\n        address[] memory recipients = new address[](1);\n        recipients[0] = vm.addr(3);\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = 1_000 * 10 ** 18;\n        _neuronContract.setupAirdrop(recipients, amounts);\n        uint256 allowance = _neuronContract.allowance(_treasuryAddress, recipients[0]);\n        assertEq(allowance, amounts[0]);\n        vm.prank(recipients[0]);\n        _neuronContract.claim(amounts[0]);\n        uint256 newAllowance = _neuronContract.allowance(_treasuryAddress, recipients[0]);\n        assertEq(newAllowance, 0);\n        uint256 neuronBalance = _neuronContract.balanceOf(recipients[0]);\n        assertEq(neuronBalance, amounts[0]);\n    }\n\n    /// @notice Test claiming an airdrop from an account with an invalid allowance.\n    function testRevertClamAirdropAccountWithNoAllowance() public {\n        vm.expectRevert(\"ERC20: claim amount exceeds allowance\");\n        _neuronContract.claim(1_000 * 10 ** 18);\n        assertEq(_neuronContract.balanceOf(_ownerAddress), 0);\n        assertEq(_neuronContract.allowance(_treasuryAddress, _ownerAddress), 0);\n    }\n\n    /// @notice Test owner adding a minter and minter minting 100 million tokens.\n    function testMintWithMinterRole() public {\n        address minter = vm.addr(3);\n        _neuronContract.addMinter(minter);\n        vm.prank(minter);\n        _neuronContract.mint(minter, 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.balanceOf(minter), 100_000_000 * 10 ** 18);\n    }\n\n    /// @notice Test owner without MINTER_ROLE minting 100 million tokens.\n    function testRevertMintWithoutMinterRole() public {\n        vm.expectRevert(\"ERC20: must have minter role to mint\");\n        _neuronContract.mint(_ownerAddress, 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.balanceOf(_ownerAddress), 0);\n    }\n\n    /// @notice Test owner with MINTER_ROLE minting max supply reverting.\n    function testRevertMintWithMinterRoleExceedsMaxSupply() public {\n        uint256 maxSupply = _neuronContract.MAX_SUPPLY();\n        address minter = vm.addr(3);\n        _neuronContract.addMinter(minter);\n        vm.prank(minter);\n        vm.expectRevert(\"Trying to mint more than the max supply\");\n        _neuronContract.mint(minter, maxSupply);\n    }\n\n    /// @notice Test owner minting 100 million tokens and burning 100 million tokens.\n    function testBurn() public {\n        _neuronContract.addMinter(_ownerAddress);\n        _neuronContract.mint(_ownerAddress, 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.balanceOf(_ownerAddress), 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.totalSupply(), 800_000_000 * 10 ** 18);\n        _neuronContract.burn(100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.totalSupply(), 700_000_000 * 10 ** 18);\n    }\n\n    /// @notice Test owner burning more tokens than in it's balance.\n    function testRevertBurnExceedsBalance() public {\n        _neuronContract.addMinter(_ownerAddress);\n        _neuronContract.mint(_ownerAddress, 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.balanceOf(_ownerAddress), 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.totalSupply(), 800_000_000 * 10 ** 18);\n        vm.expectRevert(\"ERC20: burn amount exceeds balance\");\n        _neuronContract.burn(200_000_000 * 10 ** 18);\n        assertEq(_neuronContract.totalSupply(), 800_000_000 * 10 ** 18);\n    }\n\n    /// @notice Test owner approving a spender over an allowance.\n    function testApproveSpenderWithSpenderRole() public {\n        address spender = vm.addr(3);\n        _neuronContract.addMinter(_ownerAddress);\n        _neuronContract.mint(_ownerAddress, 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.balanceOf(_ownerAddress), 100_000_000 * 10 ** 18);\n        _neuronContract.addSpender(spender);\n        emit log_address(_ownerAddress);\n        emit log_address(spender);\n        vm.prank(spender);\n        _neuronContract.approveSpender(_ownerAddress, 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.allowance(_ownerAddress, spender), 100_000_000 * 10 ** 18);\n    }\n\n    /// @notice Test owner approving a spender over an allowance without having the SPENDER_ROLE.\n    function testRevertApproveSpenderWithoutSpenderRole() public {\n        address spender = vm.addr(3);\n        _neuronContract.addMinter(_ownerAddress);\n        _neuronContract.mint(_ownerAddress, 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.balanceOf(_ownerAddress), 100_000_000 * 10 ** 18);\n        vm.prank(spender);\n        vm.expectRevert(\"ERC20: must have spender role to approve spending\");\n        _neuronContract.approveSpender(_ownerAddress, 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.allowance(_ownerAddress, spender), 0);\n    }\n\n    /// @notice Test owner approving a staker over an amount.\n    function testApproveStakeWithStakerRole() public {\n        address staker = vm.addr(3);\n        _neuronContract.addMinter(_ownerAddress);\n        _neuronContract.mint(_ownerAddress, 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.balanceOf(_ownerAddress), 100_000_000 * 10 ** 18);\n        _neuronContract.addStaker(staker);\n        vm.prank(staker);\n        _neuronContract.approveStaker(_ownerAddress, staker, 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.allowance(_ownerAddress, staker), 100_000_000 * 10 ** 18);\n    }\n\n    /// @notice Test owner approving a staker over an amount without having STAKER_ROLE.\n    function testRevertApproveStakeWithoutStakerRole() public {\n        address staker = vm.addr(3);\n        _neuronContract.addMinter(_ownerAddress);\n        _neuronContract.mint(_ownerAddress, 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.balanceOf(_ownerAddress), 100_000_000 * 10 ** 18);\n        vm.prank(staker);\n        vm.expectRevert(\"ERC20: must have staker role to approve staking\");\n        _neuronContract.approveStaker(_ownerAddress, staker, 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.allowance(_ownerAddress, staker), 0);\n    }\n\n    /// @notice  Test owner approving a spender over an allowance.\n    function testBurnFrom() public {\n        address spender = vm.addr(3);\n        _neuronContract.addMinter(_ownerAddress);\n        _neuronContract.mint(_ownerAddress, 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.balanceOf(_ownerAddress), 100_000_000 * 10 ** 18);\n        _neuronContract.addSpender(spender);\n        emit log_address(_ownerAddress);\n        emit log_address(spender);\n        vm.prank(spender);\n        _neuronContract.approveSpender(_ownerAddress, 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.allowance(_ownerAddress, spender), 100_000_000 * 10 ** 18);\n        vm.prank(spender);\n        _neuronContract.burnFrom(_ownerAddress, 100_000_000 * 10 ** 18);\n        assertEq(_neuronContract.allowance(_ownerAddress, spender), 0);\n        assertEq(_neuronContract.balanceOf(_ownerAddress), 0);\n    }\n}"
    },
    {
      "filename": "src/Neuron.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/// @title Neuron\n/// @author ArenaX Labs Inc.\n/// @notice ERC20 token contract representing Neuron (NRN) tokens.\n/// @dev The Neuron token is used for AI Arena's in-game economy.\ncontract Neuron is ERC20, AccessControl {\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when tokens are claimed.\n    event TokensClaimed(address user, uint256 amount);\n\n    /// @notice Event emitted when tokens are minted.\n    event TokensMinted(address user, uint256 amount);    \n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Role for minting tokens.\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    /// @notice Role for spending tokens.\n    bytes32 public constant SPENDER_ROLE = keccak256(\"SPENDER_ROLE\");\n    \n    /// @notice Role for staking tokens.\n    bytes32 public constant STAKER_ROLE = keccak256(\"STAKER_ROLE\");\n\n    /// @notice Initial supply of NRN tokens to be minted to the treasury.\n    uint256 public constant INITIAL_TREASURY_MINT = 10**18 * 10**8 * 2;\n\n    /// @notice Initial supply of NRN tokens to be minted and distributed to contributors.\n    uint256 public constant INITIAL_CONTRIBUTOR_MINT = 10**18 * 10**8 * 5;\n\n    /// @notice Maximum supply of NRN tokens.\n    uint256 public constant MAX_SUPPLY = 10**18 * 10**9;\n\n    /// @notice The address of treasury.\n    address public treasuryAddress;\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping of address to admin status.\n    mapping(address => bool) public isAdmin;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    ////////"
    }
  ]
}