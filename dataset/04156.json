{
  "Title": "[M02] Cannot decrease allowance to non-zero value",
  "Content": "The `uniApprove` function of the `UniERC20` library can be used to change the token allowance granted to a specified address. However, if the new value is non-zero and [the existing allowance is greater than the new value](https://github.com/1inch-exchange/1inch-v2-contracts/blob/72f2812837fdd73ec2d32c8988811df361e80985/contracts/helpers/UniERC20.sol#L46), the request is discarded. This means the token allowance cannot be decreased to a non-zero value, which differs from the typical ERC20 `approve` behavior. Consider introducing a `decreaseAllowance` function to handle this case, or documenting the new behavior and its rationale in the function comments.\n\n\nThis issue is related to [**[ M03 ] Incorrect safeApprove usage**](#m03) and any mitigation should consider both simultaneously.\n\n\n**Update**: *Fixed in [commit bdbda2c7](https://github.com/1inch-exchange/1inch-v2-contracts/commit/bdbda2c74b772e99687200f487f687cc96e5a26d). The function replicates standard `approve` functionality, whether or not the token prevents changing allowances between non-zero values. The code intentionally disregards the possible frontrunning attack in the interest of universal applicability.*\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/helpers/UniERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n\nlibrary UniERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    IERC20 private constant _ZERO_ADDRESS = IERC20(0);\n\n    function isETH(IERC20 token) internal pure returns (bool) {\n        return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);\n    }\n\n    function uniBalanceOf(IERC20 token, address account) internal view returns (uint256) {\n        if (isETH(token)) {\n            return account.balance;\n        } else {\n            return token.balanceOf(account);\n        }\n    }\n\n    function uniTransfer(IERC20 token, address payable to, uint256 amount) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                to.transfer(amount);\n            } else {\n                token.safeTransfer(to, amount);\n            }\n        }\n    }\n\n    function uniApprove(IERC20 token, address to, uint256 amount) internal {\n        require(!isETH(token), \"Approve called on ETH\");\n\n        if (amount == 0) {\n            token.safeApprove(to, 0);\n        } else {\n            uint256 allowance = token.allowance(address(this), to);\n            if (allowance < amount) {\n                if (allowance > 0) {\n                    token.safeApprove(to, 0);\n                }\n                token.safeApprove(to, amount);\n            }\n        }\n    }\n}"
    }
  ]
}