{
  "Title": "Constructors may use `_disableInitializers()` instead of initialization routine",
  "Content": "##### Description\nThe constructors of the contracts listed below use a call to their initialization routine to avoid a problem known as unauthorized initialization of the implementation. Generally, this is a usable solution; however, the OpenZeppelin project offers a more elegant way to disable initialization.\n\n- CorePrimary: https://github.com/aspidanet/aspida-contract/blob/a94928e27a72baabb8c73b42634350ca934b3353/contracts/CorePrimary.sol#L63\n- dETH: https://github.com/aspidanet/aspida-contract/blob/a94928e27a72baabb8c73b42634350ca934b3353/contracts/dETH.sol#L31\n- RewardOracle: https://github.com/aspidanet/aspida-contract/blob/a94928e27a72baabb8c73b42634350ca934b3353/contracts/RewardOracle.sol#L61\n- StETHMinter: https://github.com/aspidanet/aspida-contract/blob/a94928e27a72baabb8c73b42634350ca934b3353/contracts/StETHMinter.sol#L22\n\n##### Recommendation\nWe recommend using `_disableInitializers()` in the constructors instead of calling the initialization routine.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/CorePrimary.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./library/PauseGuardian.sol\";\nimport \"./library/Manable.sol\";\nimport \"./core/ActionControl.sol\";\nimport \"./core/CoreTreasury.sol\";\nimport \"./core/CoreStrategy.sol\";\nimport \"./core/StakingModel.sol\";\nimport \"./core/Submit.sol\";\nimport \"./core/WithdrawalQueue.sol\";\n\nimport \"./interface/IRewardOracle.sol\";\n\n/**\n * @title Aspida's ETH 2.0 staking Core(primary)\n * @author Aspida engineer\n * @notice This contract is the primary contract for Aspida's ETH 2.0 staking Core.\n *         It inherits from several other contracts and contains various functions for managing the Core.\n * @dev This contract is implemented using the OpenZeppelin library.\n *      It is used for staking ETH 2.0 and managing the Core's treasury, strategies, and actions.\n *      It also contains functions for submitting and withdrawing ETH, as well as managing the withdrawal queue.\n */\ncontract CorePrimary is\n    Ownable2StepUpgradeable,\n    PauseGuardian,\n    ReentrancyGuardUpgradeable,\n    Manable,\n    ActionControl,\n    CoreTreasury,\n    CoreStrategy,\n    Submit,\n    StakingModel,\n    WithdrawalQueue\n{\n    address internal rewardOracle_;\n\n    uint256 internal received_;\n\n    event SetRewardOracle(address rewardOracle);\n    event Received(uint256 _ethValue);\n\n    /**\n     * @dev Throws if called by any account other than the rewardOracle.\n     */\n    modifier onlyRewardOracle() {\n        require(rewardOracle_ == msg.sender, \"onlyRewardOracle: caller is not the rewardOracle\");\n        _;\n    }\n\n    /**\n     * @notice Only for the implementation contract, as for the proxy pattern,\n     *            should call `initialize()` separately.\n     */\n    constructor(\n        IDepositContract _depositContract,\n        IdETH _dETH,\n        IsdETH _sdETH\n    ) StakingModel(_depositContract) Submit(_dETH, _sdETH) {\n        initialize();\n    }\n\n    /**\n     * @notice Expects to call only once to initialize CorePrimary.\n     */\n    function initialize() public initializer {\n        __Ownable2Step_init();\n        _setTreasuryInternal(owner());\n        _setWithdrawalCredentialsInternal(_addressToWithdrawalCredentials(address(this)));\n    }\n\n    /**\n     * @notice Receives ETH sent to the contract.\n     */\n    receive() external payable {\n        received_ += msg.value;\n        emit Received(msg.value);\n    }\n\n    /**\n     * @dev Unpause when Core is paused.\n     */\n    function _open() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @dev Pause Core.\n     */\n    function _close() external onlyPauseGuardian {\n        _pause();\n    }\n\n    /**\n     * @notice Adds a new pause guardian to the Core.\n     * @param _pauseGuardian The address of the new pause guardian.\n     */\n    function _addPauseGuardian(address _pauseGuardian) external onlyOwner {\n        _addPauseGuardianInternal(_pauseGuardian);\n    }\n\n    /**\n     * @notice Removes a pause guardian from the Core.\n     * @param _pauseGuardian The address of the pause guardian to remove.\n     */\n    function _removePauseGuardian(address _pauseGuardian) external onlyOwner {\n        _removePauseGuardianInternal(_pauseGuardian);\n    }\n\n    /**\n     * @notice Adds a new manager to the Core.\n     * @param _manager The address of the new manager.\n     */\n    function _addManager(address _manager) external onlyOwner {\n        _addManagerInternal(_manager);\n    }\n\n    /**\n     * @notice Removes a manager from the Core.\n     * @param _manager The address of the manager to remove.\n     */\n    function _removeManager(address _manager) external onlyOwner {\n        _removeManagerInternal(_manager);\n    }\n\n    /**\n     * @notice Sets the treasury address.\n     * @param _treasury The address of the new treasury.\n     */\n    function _setTreasury(address _treasury) external onlyOwner {\n        _setTreasuryInternal(_treasury);\n    }\n\n    /**\n     * @notice Sets the treasury ratio.\n     * @param _treasuryRatio The new treasury ratio.\n     */\n    function _setTreasuryRatio(uint256 _treasuryRatio) external onlyOwner {\n        _setTreasuryRatioInternal(_treasuryRatio);\n    }\n\n    /**\n     * @notice Sets the action limit.\n     * @param _actionId The action ID.\n     * @param _limit The new limit.\n     */\n    function _setActionLimit(Action _actionId, uint256 _limit) external onlyOwner {\n        _setActionLimitInternal(_actionId, _limit);\n    }\n\n    /**\n     * @notice Sets the action threshold.\n     * @param _actionId The action ID.\n     * @param _threshold The new threshold.\n     */\n    function _setActionThreshold(Action _actionId, uint256 _threshold) external onlyOwner {\n        _setActionThresholdInternal(_actionId, _threshold);\n    }\n\n    /**\n     * @notice Sets the reserve ratio.\n     * @param _reserveRatio The new reserve ratio.\n     */\n    function _setReserveRatio(uint256 _reserveRatio) external onlyOwner {\n        _setReserveRatioInternal(_reserveRatio);\n    }\n\n    /**\n     * @notice Adds a new strategy.\n     * @param _strategy The address of the new strategy.\n     */\n    function _addStrategy(address _strategy) external onlyOwner {\n        _addStrategyInternal(_strategy);\n    }\n\n    /**\n     * @notice Removes a strategy.\n     * @param _strategy The address of the strategy to remove.\n     */\n    function _removeStrategy(address _strategy) external onlyOwner {\n        _removeStrategyInternal(_strategy);\n    }\n\n    /**\n     * @notice Releases the strategy reserve.\n     * @param _releaseAmount The amount to release.\n     */\n    function _releaseStrategyReserve(uint256 _releaseAmount) external onlyOwner {\n        _decreaseStrategyReserve(_releaseAmount);\n    }\n\n    /**\n     * @notice Sets the reward oracle address.\n     * @param _rewardOracle The address of the new reward oracle.\n     */\n    function _setRewardOracle(address _rewardOracle) external onlyOwner {\n        require(\n            _rewardOracle != rewardOracle_ && IRewardOracle(_rewardOracle).core() == address(this),\n            \"_setRewardOracle: Invalid reward oracle address\"\n        );\n        rewardOracle_ = _rewardOracle;\n        emit SetRewardOracle(_rewardOracle);\n    }\n\n    /**\n     * @notice Disables the reward oracle.\n     */\n    function _disableRewardOracle() external onlyOwner {\n        rewardOracle_ = address(0);\n        emit SetRewardOracle(address(0));\n    }\n\n    /**\n     * @notice Deposits ETH into a strategy.\n     * @param _strategy The address of the strategy.\n     * @param _ethAmount The amount of ETH to deposit.\n     */\n    function _depositIntoStrategy(address _strategy, uint256 _ethAmount) external onlyOwner {\n        _depositIntoStrategyInternal(_strategy, _ethAmount);\n    }\n\n    /**\n     * @notice Deposits ETH into the contract for staking.\n     * @param _validators The array of validators to deposit.\n     */\n    function deposit(Validator[] calldata _validators) external whenNotPaused nonReentrant onlyManager {\n        require(\n            (address(this).balance - strategyReserve_ - pendingClaimAmount_) / DEPOSIT_SIZE >= _validators.length,\n            \"deposit: Not enough ETH\"\n        );\n\n        _deposit(_validators);\n    }\n\n    /**\n     * @notice Supplies reward.\n     * @param _amount The amount to supply.\n     */\n    function supplyReward(uint256 _amount) external whenNotPaused onlyRewardOracle {\n        require(_amount != 0, \"supplyReward: Amount cannot be 0\");\n\n        uint256 _treasuryAmount = _getTreasuryAmount(_amount);\n        if (_treasuryAmount > 0) DETH.mint(treasury_, _treasuryAmount);\n\n        uint256 _reward = _amount - _treasuryAmount;\n        if (_reward > 0) DETH.mint(address(SDETH), _reward);\n    }\n\n    /**\n     * @notice Mints DETH to the specified receiver.\n     * @param _receiver The address of the receiver.\n     * @param _amount The amount of DETH to mint.\n     */\n    function strategyMinting(address _receiver, uint256 _amount) external whenNotPaused isStrategy(msg.sender) {\n        DETH.mint(_receiver, _amount);\n    }\n\n    /**\n     * @notice Receives earnings from a strategy.\n     */\n    function receiveStrategyEarning() external payable {\n        _receiveStrategyEarning(msg.sender);\n    }\n\n    /**\n     * @notice Submits a transaction to the CorePrimary contract.\n     * @dev This function is called internally when a user submits a transaction.\n     * @param _receiver The address of the receiver of the transaction.\n     */\n    function _submit(address _receiver) internal override whenNotPaused nonReentrant {\n        uint256 _ethValue = msg.value;\n        _checkActionLimit(Action.submit, block.timestamp / 1 days, _ethValue, submitted_);\n        _increaseReservesByRatio(_ethValue);\n        Submit._submit(_receiver);\n    }\n\n    /**\n     * @dev Internal function to withdraw funds from the contract.\n     * @param _sender The address of the sender.\n     * @param _receiver The address of the receiver.\n     * @param _amount The amount to withdraw.\n     */\n    function _withdraw(\n        address _sender,\n        address _receiver,\n        uint256 _amount\n    ) internal override whenNotPaused nonReentrant {\n        _checkAction(\n            Action.withdraw,\n            block.timestamp / 1 days,\n            _amount,\n            totalWithdrawn_ + pendingClaimAmount_ + totalClaimed_\n        );\n        DETH.burnFrom(_sender, _amount);\n        WithdrawalQueue._withdraw(_sender, _receiver, _amount);\n    }\n\n    /**\n     * @notice Claims the rewards by queue ID.\n     * @param _sender The address of the sender.\n     * @param _receiver The address of the receiver.\n     * @param _queueIds The array of queue IDs.\n     * @param _userQueueIds The set of user queue IDs.\n     */\n    function _claimByQueueId(\n        address _sender,\n        address _receiver,\n        uint256[] memory _queueIds,\n        EnumerableSet.UintSet storage _userQueueIds\n    ) internal override whenNotPaused nonReentrant {\n        WithdrawalQueue._claimByQueueId(_sender, _receiver, _queueIds, _userQueueIds);\n    }\n\n    /**\n     * @dev Returns the amount of ETH that can be withdrawn from the contract.\n     * @return _availableAmount The available amount of ETH that can be withdrawn.\n     */\n    function _withdrawableAmount() internal view override returns (uint256 _availableAmount) {\n        uint256 _balance = address(this).balance;\n        uint256 _locked = pendingClaimAmount_ + strategyReserve_;\n        if (_balance > _locked) {\n            _availableAmount = _balance - _locked;\n        }\n    }\n\n    /**\n     * @dev Returns the amount of ETH that can be claimed from the contract.\n     * @return _claimableAmount The amount of ETH that can be claimed.\n     */\n    function _claimableAmount() internal view override returns (uint256) {\n        return address(this).balance - strategyReserve_ + totalClaimed_;\n    }\n\n    /**\n     * @notice Withdraws a specified amount of tokens with permit functionality.\n     * @param _amount The amount of tokens to withdraw.\n     * @param _receiver The address to receive the tokens.\n     * @param _deadline The deadline for the permit.\n     * @param _approveMax Boolean indicating whether to approve the maximum amount.\n     * @param _v The recovery id of the permit signature.\n     * @param _r The R value of the permit signature.\n     * @param _s The S value of the permit signature.\n     */\n    function withdrawWithPermit(\n        uint256 _amount,\n        address _receiver,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        // Determine the value to be approved\n        uint256 _value = _approveMax ? type(uint256).max : _amount;\n\n        // Call the permit function of the token contract\n        DETH.permit(msg.sender, address(this), _value, _deadline, _v, _r, _s);\n\n        // Withdraw the specified amount of tokens\n        _withdraw(msg.sender, _receiver, _amount);\n    }\n\n    /**\n     * @notice Redeems a specified amount of sdETH and withdraws the underlying ETH.\n     * @param _sdETHAmount The amount of sdETH to redeem.\n     */\n    function redeemAndWithdraw(uint256 _sdETHAmount) external {\n        address _sender = msg.sender;\n        uint256 _amount = SDETH.redeem(_sdETHAmount, address(this), _sender);\n        _withdraw(address(this), _sender, _amount);\n    }\n\n    /**\n     * @notice Withdraws a specified amount of underlying ETH and sdETH.\n     * @param _amount The amount of underlying ETH to withdraw.\n     */\n    function redeemUnderlyingAndWithdraw(uint256 _amount) external {\n        address _sender = msg.sender;\n        SDETH.withdraw(_amount, address(this), _sender);\n        _withdraw(address(this), _sender, _amount);\n    }\n\n    /**\n     * @dev Returns the address of the reward oracle.\n     * @return The address of the reward oracle.\n     */\n    function rewardOracle() external view returns (address) {\n        return rewardOracle_;\n    }\n\n    /**\n     * @dev Returns the amount of ETH received by the contract.\n     * @return The amount of ETH received by the contract.\n     */\n    function received() external view returns (uint256) {\n        return received_;\n    }\n\n    /**\n     * @dev Returns the remaining amount of ETH that can be submitted for the current day.\n     * @return The remaining amount of ETH that can be submitted for the current day.\n     */\n    function submitRemaining() external view returns (uint256) {\n        return actionRemaining(Action.submit, block.timestamp / 1 days, submitted_);\n    }\n\n    /**\n     * @dev Returns the remaining amount of ETH that can be withdrawn for the current day.\n     * @return The remaining amount of ETH that can be withdrawn for the current day.\n     */\n    function withdrawRemaining() external view returns (uint256) {\n        return\n            actionRemaining(\n                Action.withdraw,\n                block.timestamp / 1 days,\n                totalWithdrawn_ + pendingClaimAmount_ + totalClaimed_\n            );\n    }\n\n    /**\n     * @dev Returns the withdraw threshold.\n     * @return The withdraw threshold.\n     */\n    function withdrawThreshold() external view returns (uint256) {\n        return actionDatas_[Action.withdraw].threshold;\n    }\n\n    /**\n     * @dev Returns whether the given address is a pause guardian.\n     * @param _pauseGuardian The address to check.\n     * @return Whether the given address is a pause guardian.\n     */\n    function isPauseGuardian(address _pauseGuardian) public view override returns (bool) {\n        return PauseGuardian.isPauseGuardian(_pauseGuardian) || _pauseGuardian == owner();\n    }\n\n    /**\n     * @dev Returns the staking reward.\n     * @param _deposited The amount deposited.\n     * @param _exited The amount exited.\n     * @return _stakingReward The staking reward.\n     */\n    function stakingReward(uint256 _deposited, uint256 _exited) external view returns (uint256 _stakingReward) {\n        uint256 _minuend = address(this).balance +\n            totalWithdrawn_ +\n            totalClaimed_ +\n            depositStrategy_ +\n            _deposited *\n            DEPOSIT_SIZE;\n        uint256 _subtrahend = submitted_ + received_ + receiveStrategy_ + _exited * DEPOSIT_SIZE;\n        if (_minuend > _subtrahend) _stakingReward = _minuend - _subtrahend;\n    }\n}"
    },
    {
      "filename": "contracts/dETH.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\n\nimport \"./library/PauseGuardian.sol\";\nimport \"./library/Manable.sol\";\nimport \"./library/Minter.sol\";\n\n/**\n * @title Aspida's ether pegged ERC20 token\n * @notice This contract is used to create an ether pegged ERC20 token\n * @dev This contract extends multiple OpenZeppelin contracts to add additional functionality.\n * @author Aspida engineer\n */\ncontract dETH is\n    Ownable2StepUpgradeable,\n    PauseGuardian,\n    ERC20BurnableUpgradeable,\n    ERC20PermitUpgradeable,\n    Manable,\n    Minter\n{\n    /**\n     * @notice Only for the implementation contract, as for the proxy pattern,\n     *            should call `initialize()` separately.\n     */\n    constructor() {\n        initialize();\n    }\n\n    /**\n     * @notice Initializes the dETH contract.\n     * @dev This function should be called only once to initialize dETH.\n     */\n    function initialize() public initializer {\n        string memory _tokenName = \"Aspida Ether\";\n        string memory _tokenSymbol = \"dETH\";\n        __Ownable2Step_init();\n        __ERC20_init(_tokenName, _tokenSymbol);\n        __ERC20Permit_init(_tokenName);\n    }\n\n    /**\n     * @dev Unpauses the dETH contract.\n     * @notice This function can only be called by the contract owner.\n     */\n    function _open() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @dev Pauses the dETH contract.\n     * @notice This function can only be called by the pause guardian.\n     */\n    function _close() external onlyPauseGuardian {\n        _pause();\n    }\n\n    /**\n     * @dev Adds a new pause guardian.\n     * @param _pauseGuardian The address of the pause guardian to be added.\n     * @notice This function can only be called by the contract owner.\n     */\n    function _addPauseGuardian(address _pauseGuardian) external onlyOwner {\n        _addPauseGuardianInternal(_pauseGuardian);\n    }\n\n    /**\n     * @dev Removes a pause guardian.\n     * @param _pauseGuardian The address of the pause guardian to be removed.\n     * @notice This function can only be called by the contract owner.\n     */\n    function _removePauseGuardian(address _pauseGuardian) external onlyOwner {\n        _removePauseGuardianInternal(_pauseGuardian);\n    }\n\n    /**\n     * @notice Adds a new manager.\n     * @param _manager The address of the manager to be added.\n     * @dev If the manager has not been added before, emits a `ManagerAdded` event.\n     * @notice This function can only be called by the contract owner.\n     */\n    function _addManager(address _manager) external onlyOwner {\n        _addManagerInternal(_manager);\n    }\n\n    /**\n     * @notice Removes a manager.\n     * @param _manager The address of the manager to be removed.\n     * @dev If the manager is currently a manager, emits a `ManagerRemoved` event.\n     * @notice This function can only be called by the contract owner.\n     */\n    function _removeManager(address _manager) external onlyOwner {\n        _removeManagerInternal(_manager);\n    }\n\n    /**\n     * @notice Sets the minting cap for a minter.\n     * @param _minter The address of the minter.\n     * @param _mintCap The new minting cap for the minter.\n     * @notice This function can only be called by the contract owner.\n     */\n    function _setMinterCap(address _minter, uint256 _mintCap) external onlyOwner {\n        _setMinterCapInternal(_minter, _mintCap);\n    }\n\n    /**\n     * @dev Hook function called before any token transfer.\n     * @param from The address transferring the tokens.\n     * @param to The address receiving the tokens.\n     * @param amount The amount of tokens being transferred.\n     * @notice This function checks if the token is paused before allowing the transfer.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        require(!paused(), \"_beforeTokenTransfer: token transfer while paused\");\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    /**\n     * @notice Mints new tokens and assigns them to the specified receiver.\n     * @param _receiver The address to receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @notice This function can only be called by a manager.\n     */\n    function mint(address _receiver, uint256 _amount) external onlyManager {\n        _mint(_receiver, _amount);\n    }\n\n    /**\n     * @notice Mints new tokens and assigns them to the specified receiver.\n     * @param _receiver The address to receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @dev This function checks if the minting cap is not exceeded before minting.\n     */\n    function minterMint(address _receiver, uint256 _amount) external checkMintCap(_amount) {\n        _increaseMintAmount(msg.sender, _amount);\n        _mint(_receiver, _amount);\n    }\n\n    /**\n     * @notice Burns tokens from the sender's balance.\n     * @param _amount The amount of tokens to burn.\n     * @dev This function decreases the minting amount for the sender before burning.\n     */\n    function minterBurn(uint256 _amount) external {\n        _decreaseMintAmount(msg.sender, _amount);\n        _burn(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Burns tokens from a specified account.\n     * @param _account The account to burn tokens from.\n     * @param _amount The amount of tokens to burn.\n     * @dev This function allows burning tokens from another account if the sender has the necessary allowance.\n     */\n    function burnFrom(address _account, uint256 _amount) public override {\n        address _sender = msg.sender;\n        if (_sender != _account) _spendAllowance(_account, _sender, _amount);\n        _burn(_account, _amount);\n    }\n\n    /**\n     * @notice Checks if an address is a pause guardian.\n     * @param _pauseGuardian The address to check.\n     * @return A boolean indicating whether the address is a pause guardian.\n     */\n    function isPauseGuardian(address _pauseGuardian) public view override returns (bool) {\n        return PauseGuardian.isPauseGuardian(_pauseGuardian) || _pauseGuardian == owner();\n    }\n}"
    },
    {
      "filename": "contracts/RewardOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\nimport \"./library/PauseGuardian.sol\";\nimport \"./library/Manable.sol\";\n\nimport \"./interface/ICore.sol\";\n\n/**\n * @title Aspida's ETH 2.0 staking reward oracle\n * @dev This contract serves as a reward oracle for ETH 2.0 staking. It calculates and updates the epoch reward based on various parameters.\n * @author Aspida engineer\n */\ncontract RewardOracle is Ownable2StepUpgradeable, PauseGuardian, Manable {\n    uint256 internal constant BASE = 1e18;\n    uint256 internal constant SECONDS_PER_SLOT = 12 seconds;\n    uint256 internal constant SLOT_PER_EPOCH = 32;\n    uint256 internal constant EPOCH_PER_YEAR = 365 days / (SECONDS_PER_SLOT * SLOT_PER_EPOCH);\n    uint256 internal constant EPOCH_INTEREST_RATE_MAX = BASE / EPOCH_PER_YEAR;\n\n    uint256 internal constant DEPOSIT_SIZE = 32 ether; // The deposit size for validators\n\n    ICore internal immutable CORE; // The interface for the core contract\n\n    uint256 internal interestRateLimitPerEpoch_; // The interest rate limit per epoch\n    uint256 internal validatorLimitPerEpoch_; // The validator limit per epoch\n\n    uint256 internal lastEpochId_; // The last epoch ID\n    uint256 internal lastActivatedValidatorCount_; // The last activated validator count\n\n    /**\n     * @dev Emitted when the interest rate limit per epoch is set\n     */\n    event SetInterestRateLimitPerEpoch(uint256 interestRateLimitPerEpoch);\n\n    /**\n     * @dev Emitted when the validator limit per epoch is set\n     */\n    event SetValidatorLimitPerEpoch(uint256 validatorLimitPerEpoch);\n\n    /**\n     * @dev Emitted when the epoch reward is updated\n     */\n    event UpdateEpochReward(\n        uint256 lastEpochId,\n        uint256 submitEpochId,\n        uint256 lastActivatedValidatorCount,\n        uint256 activatedValidatorCount,\n        uint256 rewardIncrement\n    );\n\n    /**\n     * @notice Only for the implementation contract, as for the proxy pattern,\n     *            should call `initialize()` separately.\n     * @param _core The interface for the core contract\n     */\n    constructor(ICore _core) {\n        CORE = _core;\n        initialize();\n    }\n\n    /**\n     * @notice Expects to call only once to initialize RewardOracle.\n     */\n    function initialize() public initializer {\n        __Ownable2Step_init();\n        _setInterestRateLimitPerEpoch(BASE);\n    }\n\n    /**\n     * @dev Unpause when RewardOracle is paused.\n     */\n    function _open() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @dev Pause RewardOracle.\n     */\n    function _close() external onlyPauseGuardian {\n        _pause();\n    }\n\n    /**\n     * @notice Add `_pauseGuardian` into pause guardians.\n     * @param _pauseGuardian The address of the pause guardian to add\n     */\n    function _addPauseGuardian(address _pauseGuardian) external onlyOwner {\n        _addPauseGuardianInternal(_pauseGuardian);\n    }\n\n    /**\n     * @notice Remove `_pauseGuardian` from pause guardians.\n     * @param _pauseGuardian The address of the pause guardian to remove\n     */\n    function _removePauseGuardian(address _pauseGuardian) external onlyOwner {\n        _removePauseGuardianInternal(_pauseGuardian);\n    }\n\n    /**\n     * @notice Add `_manager` into managers.\n     * If `_manager` have not been a manager, emits a `ManagerAdded` event.\n     *\n     * @param _manager The manager to add\n     *\n     * Requirements:\n     * - the caller must be `owner`.\n     */\n    function _addManager(address _manager) external onlyOwner {\n        _addManagerInternal(_manager);\n    }\n\n    /**\n     * @notice Remove `_manager` from managers.\n     * If `_manager` is a manager, emits a `ManagerRemoved` event.\n     *\n     * @param _manager The manager to remove\n     *\n     * Requirements:\n     * - the caller must be `owner`.\n     */\n    function _removeManager(address _manager) external onlyOwner {\n        _removeManagerInternal(_manager);\n    }\n\n    /**\n     * @notice Set the interest rate limit per epoch.\n     * @param _annualInterestRate The annual interest rate\n     *\n     * Requirements:\n     * - the caller must be `owner`.\n     * - the interest rate must not be too large.\n     * - the interest rate cannot be set to the same value.\n     */\n    function _setInterestRateLimitPerEpoch(uint256 _annualInterestRate) public onlyOwner {\n        uint256 _interestRateLimitPerEpoch = _annualInterestRate / EPOCH_PER_YEAR;\n        require(\n            _interestRateLimitPerEpoch <= EPOCH_INTEREST_RATE_MAX,\n            \"_setInterestRateLimitPerEpoch: Interest rate too large\"\n        );\n        require(\n            _interestRateLimitPerEpoch != interestRateLimitPerEpoch_,\n            \"_setInterestRateLimitPerEpoch: Cannot set the same value\"\n        );\n        interestRateLimitPerEpoch_ = _interestRateLimitPerEpoch;\n        emit SetInterestRateLimitPerEpoch(_interestRateLimitPerEpoch);\n    }\n\n    /**\n     * @notice Set the validator limit per epoch.\n     * @param _validatorLimitPerEpoch The validator limit per epoch\n     *\n     * Requirements:\n     * - the caller must be `owner`.\n     * - the validator limit cannot be set to the same value.\n     */\n    function _setValidatorLimitPerEpoch(uint256 _validatorLimitPerEpoch) public onlyOwner {\n        require(\n            _validatorLimitPerEpoch != validatorLimitPerEpoch_,\n            \"_setValidatorLimitPerEpoch: Cannot set the same value\"\n        );\n        validatorLimitPerEpoch_ = _validatorLimitPerEpoch;\n        emit SetValidatorLimitPerEpoch(_validatorLimitPerEpoch);\n    }\n\n    /**\n     * @notice Calculate the epoch interest rate.\n     * @param _epochCount The number of epochs\n     * @param _activatedValidatorCount The number of activated validators\n     * @param _rewardIncrement The reward increment\n     * @return The epoch interest rate\n     */\n    function _calculateEpochInterestRate(\n        uint256 _epochCount,\n        uint256 _activatedValidatorCount,\n        uint256 _rewardIncrement\n    ) internal pure returns (uint256) {\n        uint256 _principal = _epochCount * _activatedValidatorCount * DEPOSIT_SIZE;\n        return (_rewardIncrement * BASE + _principal - 1) / _principal;\n    }\n\n    /**\n     * @notice Update the epoch reward.\n     * @param _epochId The epoch ID\n     * @param _activatedValidatorCount The number of activated validators\n     * @param _rewardIncrement The reward increment\n     *\n     * Requirements:\n     * - the active validators must not be 0.\n     * - the epoch ID must increase.\n     * - the epoch interest rate must be valid.\n     * - the validator limit must not be exceeded.\n     */\n    function _updateEpochReward(uint256 _epochId, uint256 _activatedValidatorCount, uint256 _rewardIncrement) internal {\n        require(_activatedValidatorCount > 0, \"_updateEpochReward: Active validators must not be 0\");\n\n        uint256 _lastEpochId = lastEpochId_;\n        require(_epochId > _lastEpochId, \"_updateEpochReward: Epoch id must increase\");\n\n        uint256 _epochCount = _epochId - _lastEpochId;\n        uint256 _epochInterestRate = _calculateEpochInterestRate(\n            _epochCount,\n            _activatedValidatorCount,\n            _rewardIncrement\n        );\n        require(_epochInterestRate <= interestRateLimitPerEpoch_, \"_updateEpochReward: Invalid epoch interest rate\");\n\n        uint256 _lastActivatedValidatorCount = lastActivatedValidatorCount_;\n        if (_activatedValidatorCount > _lastActivatedValidatorCount) {\n            require(\n                (_activatedValidatorCount - _lastActivatedValidatorCount + _epochCount - 1) / _epochCount <=\n                    validatorLimitPerEpoch_,\n                \"_updateEpochReward: Validator out of increment per epoch\"\n            );\n        }\n\n        lastEpochId_ = _epochId;\n        lastActivatedValidatorCount_ = _activatedValidatorCount;\n        emit UpdateEpochReward(\n            _lastEpochId,\n            _epochId,\n            _lastActivatedValidatorCount,\n            _activatedValidatorCount,\n            _rewardIncrement\n        );\n    }\n\n    /**\n     * @notice Submit the epoch reward.\n     * @param _epochId The epoch ID\n     * @param _activatedValidatorCount The number of activated validators\n     * @param _rewardIncrement The reward increment\n     *\n     * Requirements:\n     * - the caller must be the `manager`.\n     * - the contract must not be paused.\n     */\n    function submitEpochReward(\n        uint256 _epochId,\n        uint256 _activatedValidatorCount,\n        uint256 _rewardIncrement\n    ) external whenNotPaused onlyManager {\n        _updateEpochReward(_epochId, _activatedValidatorCount, _rewardIncrement);\n        CORE.supplyReward(_rewardIncrement);\n    }\n\n    /**\n     * @notice Get the CORE contract.\n     * @return The CORE contract.\n     */\n    function core() external view returns (ICore) {\n        return CORE;\n    }\n\n    /**\n     * @notice Get the interest rate limit per epoch.\n     * @return The interest rate limit per epoch.\n     */\n    function interestRateLimitPerEpoch() external view returns (uint256) {\n        return interestRateLimitPerEpoch_;\n    }\n\n    /**\n     * @notice Get the validator limit per epoch.\n     * @return The validator limit per epoch.\n     */\n    function validatorLimitPerEpoch() external view returns (uint256) {\n        return validatorLimitPerEpoch_;\n    }\n\n    /**\n     * @notice Get the last epoch ID.\n     * @return The last epoch ID.\n     */\n    function lastEpochId() external view returns (uint256) {\n        return lastEpochId_;\n    }\n\n    /**\n     * @notice Get the last activated validator count.\n     * @return The last activated validator count.\n     */\n    function lastActivatedValidatorCount() external view returns (uint256) {\n        return lastActivatedValidatorCount_;\n    }\n\n    /**\n     * @notice Check if an address is a pause guardian.\n     * @param _pauseGuardian The address to check.\n     * @return True if the address is a pause guardian or the owner, false otherwise.\n     */\n    function isPauseGuardian(address _pauseGuardian) public view override returns (bool) {\n        return PauseGuardian.isPauseGuardian(_pauseGuardian) || _pauseGuardian == owner();\n    }\n}"
    },
    {
      "filename": "contracts/StETHMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\nimport \"./library/PauseGuardian.sol\";\nimport \"./strategy/model/dETHMinter.sol\";\n\nimport \"./interface/IdETH.sol\";\nimport \"./interface/ILido.sol\";\n\n/**\n * @title StETHMinter contract for Aspida's Lido\n * @author Aspida engineer\n */\ncontract StETHMinter is Ownable2StepUpgradeable, PauseGuardian, dETHMinter {\n    using TransferHelper for address;\n    address internal immutable STETH;\n\n    constructor(IdETH _dETH, address _stETH) dETHMinter(_dETH) {\n        STETH = _stETH;\n        initialize();\n    }\n\n    /**\n     * @notice Initializes StETHMinter contract\n     * @dev Expects to call only once to init"
    }
  ]
}