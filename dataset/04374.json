{
  "Title": "[L07] REP token allows migration of legacy tokens after universe fork",
  "Content": "The `ReputationToken` contract implements the [`migrateFromLegacyReputationToken`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L183) function that allows users to migrate [legacy reputation tokens](https://docs.augur.net/#legacy-rep) in. However, there is no validation in place to prevent this migration from occurring in a REP token whose universe has forked and that fork has already finished.\n\n\nTo prevent unexpected locking and loss of tokens, consider implementing the necessary validations in the `migrateFromLegacyReputationToken` function to ensure no legacy tokens can be migrated to a REP token of a locked universe whose fork period has finished.\n\n\n***Update****: this has been identified as a non-issue by the Augur team, since even after a fork users should be able to migrate to the Genesis universe. Yet, our report led the Augur team to uncover a serious vulnerability which we included in this report, for the sake of completeness and transparency, in the new* ***“[H06] Legacy REP tokens can be migrated to child universes”*** *issue.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/augur-core/source/contracts/reporting/ReputationToken.sol",
      "content": "pragma solidity 0.5.4;\n\nimport 'ROOT/libraries/IERC820Registry.sol';\nimport 'ROOT/reporting/IV2ReputationToken.sol';\nimport 'ROOT/libraries/ITyped.sol';\nimport 'ROOT/libraries/token/VariableSupplyToken.sol';\nimport 'ROOT/libraries/token/ERC20Token.sol';\nimport 'ROOT/reporting/IUniverse.sol';\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/reporting/Reporting.sol';\nimport 'ROOT/reporting/IDisputeWindow.sol';\nimport 'ROOT/reporting/IDisputeCrowdsourcer.sol';\nimport 'ROOT/libraries/math/SafeMathUint256.sol';\n\n\ncontract ReputationToken is ITyped, VariableSupplyToken, IV2ReputationToken {\n    using SafeMathUint256 for uint256;\n\n    string constant public name = \"Reputation\";\n    string constant public symbol = \"REP\";\n    IUniverse internal universe;\n    IUniverse internal parentUniverse;\n    uint256 internal totalMigrated;\n    uint256 internal totalTheoreticalSupply;\n    ERC20Token public legacyRepToken;\n    IAugur public augur;\n\n    constructor(IAugur _augur, IUniverse _universe, IUniverse _parentUniverse, address _erc820RegistryAddress) public {\n        require(_universe != IUniverse(0));\n        augur = _augur;\n        universe = _universe;\n        parentUniverse = _parentUniverse;\n        legacyRepToken = ERC20Token(augur.lookup(\"LegacyReputationToken\"));\n        updateTotalTheoreticalSupply();\n        erc820Registry = IERC820Registry(_erc820RegistryAddress);\n        initialize820InterfaceImplementations();\n    }\n\n    function migrateOutByPayout(uint256[] memory _payoutNumerators, uint256 _attotokens) public returns (bool) {\n        require(_attotokens > 0);\n        IUniverse _destinationUniverse = universe.createChildUniverse(_payoutNumerators);\n        IReputationToken _destination = _destinationUniverse.getReputationToken();\n        burn(msg.sender, _attotokens);\n        _destination.migrateIn(msg.sender, _attotokens);\n        return true;\n    }\n\n    function migrateOut(IReputationToken _destination, uint256 _attotokens) public returns (bool) {\n        require(_attotokens > 0);\n        assertReputationTokenIsLegitSibling(_destination);\n        burn(msg.sender, _attotokens);\n        _destination.migrateIn(msg.sender, _attotokens);\n        return true;\n    }\n\n    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool) {\n        IUniverse _parentUniverse = universe.getParentUniverse();\n        require(ReputationToken(msg.sender) == _parentUniverse.getReputationToken());\n        require(augur.getTimestamp() < _parentUniverse.getForkEndTime());\n        mint(_reporter, _attotokens);\n        totalMigrated += _attotokens;\n        // Update the fork tenative winner and finalize if we can\n        if (!_parentUniverse.getForkingMarket().isFinalized()) {\n            _parentUniverse.updateTentativeWinningChildUniverse(universe.getParentPayoutDistributionHash());\n        }\n        return true;\n    }\n\n    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool) {\n        IUniverse _parentUniverse = universe.getParentUniverse();\n        IReportingParticipant _reportingParticipant = IReportingParticipant(msg.sender);\n        require(_parentUniverse.isContainerForReportingParticipant(_reportingParticipant));\n        uint256 _bonus = _amountMigrated.mul(2) / 5;\n        mint(address(_reportingParticipant), _bonus);\n        return true;\n    }\n\n    function mintForAuction(uint256 _amountToMint) public returns (bool) {\n        require(universe.getAuction() == IAuction(msg.sender));\n        mint(msg.sender, _amountToMint);\n        return true;\n    }\n\n    function burnForAuction(uint256 _amountToBurn) public returns (bool) {\n        require(universe.getAuction() == IAuction(msg.sender));\n        burn(msg.sender, _amountToBurn);\n        return true;\n    }\n\n    function burnForMarket(uint256 _amountToBurn) public returns (bool) {\n        require(universe.isContainerForMarket(IMarket(msg.sender)));\n        burn(msg.sender, _amountToBurn);\n        return true;\n    }\n\n    function transfer(address _to, uint _value) public returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(IUniverse(msg.sender) == universe);\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForMarket(IMarket(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForReportingParticipant(IReportingParticipant(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedAuctionTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.getAuction() == (IAuction(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedDisputeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForDisputeWindow(IDisputeWindow(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function assertReputationTokenIsLegitSibling(IReputationToken _shadyReputationToken) private view returns (bool) {\n        IUniverse _shadyUniverse = _shadyReputationToken.getUniverse();\n        require(universe.isParentOf(_shadyUniverse));\n        IUniverse _legitUniverse = _shadyUniverse;\n        require(_legitUniverse.getReputationToken() == _shadyReputationToken);\n        return true;\n    }\n\n    function getTypeName() public view returns (bytes32) {\n        return \"ReputationToken\";\n    }\n\n    function getUniverse() public view returns (IUniverse) {\n        return universe;\n    }\n\n    function getTotalMigrated() public view returns (uint256) {\n        return totalMigrated;\n    }\n\n    function getLegacyRepToken() public view returns (ERC20Token) {\n        return legacyRepToken;\n    }\n\n    function updateTotalTheoreticalSupply() public returns (bool) {\n        if (parentUniverse == IUniverse(0)) {\n            totalTheoreticalSupply = Reporting.getInitialREPSupply();\n        } else if (augur.getTimestamp() >= parentUniverse.getForkEndTime()) {\n            totalTheoreticalSupply = totalSupply();\n        } else {\n            totalTheoreticalSupply = totalSupply() + parentUniverse.getReputationToken().totalSupply();\n        }\n        return true;\n    }\n\n    function getTotalTheoreticalSupply() public view returns (uint256) {\n        return totalTheoreticalSupply;\n    }\n\n    function onTokenTransfer(address _from, address _to, uint256 _value) internal returns (bool) {\n        augur.logReputationTokensTransferred(universe, _from, _to, _value, balances[_from], balances[_to]);\n        return true;\n    }\n\n    function onMint(address _target, uint256 _amount) internal returns (bool) {\n        augur.logReputationTokensMinted(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function onBurn(address _target, uint256 _amount) internal returns (bool) {\n        augur.logReputationTokensBurned(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function migrateFromLegacyReputationToken() public returns (bool) {\n        uint256 _legacyBalance = legacyRepToken.balanceOf(msg.sender);\n        require(legacyRepToken.transferFrom(msg.sender, address(0), _legacyBalance));\n        mint(msg.sender, _legacyBalance);\n        return true;\n    }\n}"
    }
  ]
}