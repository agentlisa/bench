{
  "Title": "M-11: Leveraged trader with small collateral can create a riskless position until settlement",
  "Content": "# Issue M-11: Leveraged trader with small collateral can create a riskless position until settlement \n\nSource: https://github.com/sherlock-audit/2023-05-perennial-judging/issues/104 \n\n## Found by \ncergyk\n## Summary\nA highly leveraged trader (around max leverage) with small collateral can autoliquidate position to create a riskless position\n\n## Vulnerability Detail\nAs we can see in closeTake function:\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/product/Product.sol#L246-L256\n\n- maintenanceInvariant is not enforced, meaning that extraction of `takerFee` can make the position go unhealthy\n\nAnd in `liquidate`:\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/collateral/Collateral.sol#L128-L129\n\n- minimum liquidation incentive equals `liquidationFee*minCollateral`.\nWhich is constant and equal to 0.5 DSU on arbitrum products such as:\nhttps://arbiscan.io/address/0x5E660B7B8357059241EAEc143e1e68A5A108D035\n\nWe can deduce that a highly leveraged trader, with very small collateral (0.5 DSU) can create a riskless position lasting until next settlement by auto liquidating.\n\nExample:\nMaintenance factor is 2%\nLiquidation fee is 5%\nTaker fee is 0.1%\nFunding fee is 0%\n\nAlice has a 50x leverage `taker` position opened as authorized per maintenance invariant:\n\nAlice collateral: 0.5 DSU\nAlice taker position: notional of 25 DSU\n\nTo create the riskless position Alice does in the same tx:\n- closes the taker position (and by paying the `takerFee` makes her position instantly liquidatable)\n- liquidates her position withdrawing the whole 0.5 DSU collateral\n\nFor the rest of the oracle version Alice has a 25 DSU position with 0 collateral. \nWhich means that in the end of the period: \n- if positive Pnl: \n    Alice gets it added to her collateral, and can withdraw some gains\n- if negative Pnl:\n    It gets induced upon the protocol as shortfall:\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial/contracts/collateral/types/OptimisticLedger.sol#L62-L73\n\nIf Alice has multiple such positions on multiple accounts, considerable amounts can be stolen this way from the protocol.\n\n## Impact\nAlice obtains a riskless position, inducing potential shortfall on the protocol\n\n## Code Snippet\n\n## Tool used\nManual Review\n\n## Recommendation\nDo not add positive Pnl to the collateral of an account if it does not have any collateral (to enforce the invariant: A position can not be without risk)\n\n\n\n## Discussion\n\n**SergeKireev**\n\nEscalate for 10 USDC\n\nIt seems this issue has been deemed non-valid because of the minCollateral requirement.\n\nHowever in current setup on arbitrum (funding fees == 0), it is actually easy to create two opposite positions (one long and one short) with exactly `MIN_COLLATERAL`, such that the sum of the values stays constant. \nOne of these is very likely to end up close to 10% of MIN_COLLATERAL (since when one position increases collateral, the other decreases collateral).\n\nWhen that happens, the attacker can use the technique described in this report to create a riskless position until next settlement and effectively steal from other users of the market\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> It seems this issue has been deemed non-valid because of the minCollateral requirement.\n> \n> However in current setup on arbitrum (funding fees == 0), it is actually easy to create two opposite positions (one long and one short) with exactly `MIN_COLLATERAL`, such that the sum of the values stays constant. \n> One of these is very likely to end up close to 10% of MIN_COLLATERAL (since when one position increases collateral, the other decreases collateral).\n> \n> When that happens, the attacker can use the technique described in this report to create a riskless position until next settlement and effectively steal from other users of the market\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**KenzoAgada**\n\n@arjun-io can you please read and share your perspective?\n\n**arjun-io**\n\nThis does appear to be possible, although the work required here to get the position at minCollateral is quite a bit. The attacker will be paying 4x open/close fees in order to get their position into this state - and the most efficient way to get to this sub-minCollateral position is by opening opening highly levered positions which will increase the fee \n\nI would consider this a valid medium \n\n**jacksanford1**\n\nSince protocol team validates it as possible, seems like this should be a valid Medium. Funds are risk seems potentially too small, but this type of attack could cause a chain reaction once everyone else realizes they are losing small amounts of funds quickly. \n\n**jacksanford1**\n\nResult:\nMedium\nUnique\nValid Medium based on Arjun's last comment. This issue is very similar to #103 but I could not make quite enough of a case to duplicate them. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [SergeKireev](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/104/#issuecomment-1612729627): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/79",
  "Code": [
    {
      "filename": "perennial-mono/packages/perennial/contracts/product/Product.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@equilibria/root/control/unstructured/UInitializable.sol\";\nimport \"@equilibria/root/control/unstructured/UReentrancyGuard.sol\";\nimport \"../controller/UControllerProvider.sol\";\nimport \"./UPayoffProvider.sol\";\nimport \"./UParamProvider.sol\";\nimport \"./types/position/AccountPosition.sol\";\nimport \"./types/accumulator/AccountAccumulator.sol\";\n\n/**\n * @title Product\n * @notice Manages logic and state for a single product market.\n * @dev Cloned by the Controller contract to launch new product markets.\n */\ncontract Product is IProduct, UInitializable, UParamProvider, UPayoffProvider, UReentrancyGuard {\n    /// @dev Whether or not the product is closed\n    BoolStorage private constant _closed = BoolStorage.wrap(keccak256(\"equilibria.perennial.Product.closed\"));\n\n    function closed() public view returns (bool) {\n        return _closed.read();\n    }\n\n    /// @dev The name of the product\n    string public name;\n\n    /// @dev The symbol of the product\n    string public symbol;\n\n    /// @dev The individual position state for each account\n    mapping(address => AccountPosition) private _positions;\n\n    /// @dev The global position state for the product\n    VersionedPosition private _position;\n\n    /// @dev The individual accumulator state for each account\n    mapping(address => AccountAccumulator) private _accumulators;\n\n    /// @dev The global accumulator state for the product\n    VersionedAccumulator private _accumulator;\n\n    /**\n     * @notice Initializes the contract state\n     * @param productInfo_ Product initialization params\n     */\n    function initialize(ProductInfo calldata productInfo_) external initializer(1) {\n        __UControllerProvider__initialize(IController(msg.sender));\n        __UPayoffProvider__initialize(productInfo_.oracle, productInfo_.payoffDefinition);\n        __UReentrancyGuard__initialize();\n        __UParamProvider__initialize(\n            productInfo_.maintenance,\n            productInfo_.fundingFee,\n            productInfo_.makerFee,\n            productInfo_.takerFee,\n            productInfo_.positionFee,\n            productInfo_.makerLimit,\n            productInfo_.utilizationCurve\n        );\n\n        name = productInfo_.name;\n        symbol = productInfo_.symbol;\n    }\n\n    /**\n     * @notice Surfaces global settlement externally\n     */\n    function settle() external nonReentrant notPaused {\n        _settle();\n    }\n\n    /**\n     * @notice Core global settlement flywheel\n     * @dev\n     *  a) last settle oracle version\n     *  b) latest pre position oracle version\n     *  c) current oracle version\n     *\n     *  Settles from a->b then from b->c if either interval is non-zero to account for a change\n     *  in position quantity at (b).\n     *\n     *  Syncs each to instantaneously after the oracle update.\n     */\n    function _settle() private returns (IOracleProvider.OracleVersion memory currentOracleVersion) {\n        IController _controller = controller();\n\n        // Get current oracle version\n        currentOracleVersion = _sync();\n\n        // Get latest oracle version\n        uint256 _latestVersion = latestVersion();\n        if (_latestVersion == currentOracleVersion.version) return currentOracleVersion; // short circuit entirely if a == c\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(_latestVersion);\n\n        // Get settle oracle version\n        uint256 _settleVersion = _position.pre.settleVersion(currentOracleVersion.version);\n        IOracleProvider.OracleVersion memory settleOracleVersion = _settleVersion == currentOracleVersion.version\n            ? currentOracleVersion // if b == c, don't re-call provider for oracle version\n            : atVersion(_settleVersion);\n\n        // Initiate\n        _controller.incentivizer().sync(currentOracleVersion);\n        UFixed18 boundedFundingFee = _boundedFundingFee();\n\n        // value a->b\n        UFixed18 accumulatedFee = _accumulator.accumulate(\n            boundedFundingFee, _position, latestOracleVersion, settleOracleVersion);\n\n        // position a->b\n        _position.settle(_latestVersion, settleOracleVersion);\n\n        // Apply any pending fee updates if present\n        _settleFeeUpdates();\n\n        // short-circuit from a->c if b == c\n        if (settleOracleVersion.version != currentOracleVersion.version) {\n            // value b->c\n            accumulatedFee = accumulatedFee.add(\n                _accumulator.accumulate(boundedFundingFee, _position, settleOracleVersion, currentOracleVersion)\n            );\n\n            // position b->c (every accumulator version needs a position stamp)\n            _position.settle(settleOracleVersion.version, currentOracleVersion);\n        }\n\n        // settle collateral\n        _controller.collateral().settleProduct(accumulatedFee);\n\n        emit Settle(settleOracleVersion.version, currentOracleVersion.version);\n    }\n\n    /**\n     * @notice Surfaces account settlement externally\n     * @param account Account to settle\n     */\n    function settleAccount(address account) external nonReentrant notPaused {\n        IOracleProvider.OracleVersion memory currentOracleVersion = _settle();\n        _settleAccount(account, currentOracleVersion);\n    }\n\n    /**\n     * @notice Core account settlement flywheel\n     * @param account Account to settle\n     * @dev\n     *  a) last settle oracle version\n     *  b) latest pre position oracle version\n     *  c) current oracle version\n     *\n     *  Settles from a->b then from b->c if either interval is non-zero to account for a change\n     *  in position quantity at (b).\n     *\n     *  Syncs each to instantaneously after the oracle update.\n     */\n    function _settleAccount(address account, IOracleProvider.OracleVersion memory currentOracleVersion) private {\n        IController _controller = controller();\n\n        // Get latest oracle version\n        if (latestVersion(account) == currentOracleVersion.version) return; // short circuit entirely if a == c\n\n        // Get settle oracle version\n        uint256 _settleVersion = _positions[account].pre.settleVersion(currentOracleVersion.version);\n        IOracleProvider.OracleVersion memory settleOracleVersion = _settleVersion == currentOracleVersion.version\n            ? currentOracleVersion // if b == c, don't re-call provider for oracle version\n            : atVersion(_settleVersion);\n\n        // sync incentivizer before accumulator\n        _controller.incentivizer().syncAccount(account, settleOracleVersion);\n\n        // value a->b\n        Fixed18 accumulated = _accumulators[account].syncTo(\n            _accumulator, _positions[account], settleOracleVersion.version).sum();\n\n        // position a->b\n        _positions[account].settle(settleOracleVersion);\n\n        // short-circuit from a->c if b == c\n        if (settleOracleVersion.version != currentOracleVersion.version) {\n            // sync incentivizer before accumulator\n            _controller.incentivizer().syncAccount(account, currentOracleVersion);\n\n            // value b->c\n            accumulated = accumulated.add(\n                _accumulators[account].syncTo(_accumulator, _positions[account], currentOracleVersion.version).sum()\n            );\n        }\n\n        // settle collateral\n        _controller.collateral().settleAccount(account, accumulated);\n\n        emit AccountSettle(account, settleOracleVersion.version, currentOracleVersion.version);\n    }\n\n    /**\n     * @notice Opens a taker position for `msg.sender`\n     * @param amount Amount of the position to open\n     */\n    function openTake(UFixed18 amount) external {\n        openTakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Opens a taker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to open the position for\n     * @param amount Amount of the position to open\n     */\n    function openTakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        notClosed\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        maxUtilizationInvariant\n        positionInvariant(account)\n        liquidationInvariant(account)\n        maintenanceInvariant(account)\n    {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.openTake(latestOracleVersion.version, amount);\n        _position.pre.openTake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(takerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit TakeOpened(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes a taker position for `msg.sender`\n     * @param amount Amount of the position to close\n     */\n    function closeTake(UFixed18 amount) external {\n        closeTakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Closes a taker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to close the position for\n     * @param amount Amount of the position to close\n     */\n    function closeTakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        closeInvariant(account)\n        liquidationInvariant(account)\n    {\n        _closeTake(account, amount);\n    }\n\n    function _closeTake(address account, UFixed18 amount) private {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.closeTake(latestOracleVersion.version, amount);\n        _position.pre.closeTake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(takerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit TakeClosed(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Opens a maker position for `msg.sender`\n     * @param amount Amount of the position to open\n     */\n    function openMake(UFixed18 amount) external {\n        openMakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Opens a maker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to open position for\n     * @param amount Amount of the position to open\n     */\n    function openMakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        notClosed\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        nonZeroVersionInvariant\n        makerInvariant\n        positionInvariant(account)\n        liquidationInvariant(account)\n        maintenanceInvariant(account)\n    {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.openMake(latestOracleVersion.version, amount);\n        _position.pre.openMake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(makerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit MakeOpened(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes a maker position for `msg.sender`\n     * @param amount Amount of the position to close\n     */\n    function closeMake(UFixed18 amount) external {\n        closeMakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Closes a maker position for `account`. Deducts position fee based on notional value at `latestVersion`\n     * @param account Account to close the position for\n     * @param amount Amount of the position to close\n     */\n    function closeMakeFor(address account, UFixed18 amount)\n        public\n        nonReentrant\n        notPaused\n        onlyAccountOrMultiInvoker(account)\n        settleForAccount(account)\n        takerInvariant\n        closeInvariant(account)\n        liquidationInvariant(account)\n    {\n        _closeMake(account, amount);\n    }\n\n    function _closeMake(address account, UFixed18 amount) private {\n        IOracleProvider.OracleVersion memory latestOracleVersion = atVersion(latestVersion());\n\n        _positions[account].pre.closeMake(latestOracleVersion.version, amount);\n        _position.pre.closeMake(latestOracleVersion.version, amount);\n\n        UFixed18 positionFee = amount.mul(latestOracleVersion.price.abs()).mul(makerFee());\n        if (!positionFee.isZero()) {\n            controller().collateral().settleAccount(account, Fixed18Lib.from(-1, positionFee));\n            emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        }\n\n        emit PositionFeeCharged(account, latestOracleVersion.version, positionFee);\n        emit MakeClosed(account, latestOracleVersion.version, amount);\n    }\n\n    /**\n     * @notice Closes all open and pending positions, locking for liquidation\n     * @dev Only callable by the Collateral contract as part of the liquidation flow\n     * @param account Account to close out\n     */\n    function closeAll(address account) external onlyCollateral notClosed settleForAccount(account) {\n        AccountPosition storage accountPosition = _positions[account];\n        Position memory p = accountPosition.position.next(_positions[account].pre);\n\n        // Close all positions\n        _closeMake(account, p.maker);\n        _closeTake(account, p.taker);\n\n        // Mark liquidation to lock position\n        accountPosition.liquidation = true;\n    }\n\n    /**\n     * @notice Returns the maintenance requirement for `account`\n     * @param account Account to return for\n     * @return The current maintenance requirement\n     */\n    function maintenance(address account) external view returns (UFixed18) {\n        return _positions[account].maintenance();\n    }\n\n    /**\n     * @notice Returns the maintenance requirement for `account` after next settlement\n     * @dev Assumes no price change and no funding, used to protect user from over-opening\n     * @param account Account to return for\n     * @return The next maintenance requirement\n     */\n    function maintenanceNext(address account) external view returns (UFixed18) {\n        return _positions[account].maintenanceNext();\n    }\n\n    /**\n     * @notice Returns whether `account` has a completely zero'd position\n     * @param account Account to return for\n     * @return The the account is closed\n     */\n    function isClosed(address account) external view returns (bool) {\n        return _positions[account].isClosed();\n    }\n\n    /**\n     * @notice Returns whether `account` is currently locked for an in-progress liquidation\n     * @param account Account to return for\n     * @return Whether the account is in liquidation\n     */\n    function isLiquidating(address account) external view returns (bool) {\n        return _positions[account].liquidation;\n    }\n\n    /**\n     * @notice Returns `account`'s current position\n     * @param account Account to return for\n     * @return Current position of the account\n     */\n    function position(address account) external view returns (Position memory) {\n        return _positions[account].position;\n    }\n\n    /**\n     * @notice Returns `account`'s current pending-settlement position\n     * @param account Account to return for\n     * @return Current pre-position of the account\n     */\n    function pre(address account) external view returns (PrePosition memory) {\n        return _positions[account].pre;\n    }\n\n    /**\n     * @notice Returns the global latest settled oracle version\n     * @return Latest settled oracle version of the product\n     */\n    function latestVersion() public view returns (uint256) {\n        return _accumulator.latestVersion;\n    }\n\n    /**\n     * @notice Returns the global position at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global position at oracle version\n     */\n    function positionAtVersion(uint256 oracleVersion) public view returns (Position memory) {\n        return _position.positionAtVersion(oracleVersion);\n    }\n\n    /**\n     * @notice Returns the current global pending-settlement position\n     * @return Global pending-settlement position\n     */\n    function pre() external view returns (PrePosition memory) {\n        return _position.pre;\n    }\n\n    /**\n     * @notice Returns the global accumulator value at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global accumulator value at oracle version\n     */\n    function valueAtVersion(uint256 oracleVersion) external view returns (Accumulator memory) {\n        return _accumulator.valueAtVersion(oracleVersion);\n    }\n\n    /**\n     * @notice Returns the global accumulator share at oracleVersion `oracleVersion`\n     * @dev Only valid for the version at which a global settlement occurred\n     * @param oracleVersion Oracle version to return for\n     * @return Global accumulator share at oracle version\n     */\n    function shareAtVersion(uint256 oracleVersion) external view returns (Accumulator memory) {\n        return _accumulator.shareAtVersion(oracleVersion);\n    }\n\n    /**\n     * @notice Returns `account`'s latest settled oracle version\n     * @param account Account to return for\n     * @return Latest settled oracle version of the account\n     */\n    function latestVersion(address account) public view returns (uint256) {\n        return _accumulators[account].latestVersion;\n    }\n\n    /**\n     * @notice Returns The per-second rate based on the provided `position`\n     * @dev Handles 0-maker/taker edge cases\n     * @param position_ Position to base utilization on\n     * @return The per-second rate\n     */\n    function rate(Position calldata position_) public view returns (Fixed18) {\n        UFixed18 utilization = position_.taker.unsafeDiv(position_.maker);\n        Fixed18 annualizedRate = utilizationCurve().compute(utilization);\n        return annualizedRate.div(Fixed18Lib.from(365 days));\n    }\n\n    /**\n     * @notice Returns the minimum funding fee parameter with a capped range for safety\n     * @dev Caps controller.minFundingFee() <= fundingFee() <= 1\n     * @return Safe minimum funding fee parameter\n     */\n    function _boundedFundingFee() private view returns (UFixed18) {\n        return fundingFee().max(controller().minFundingFee());\n    }\n\n    /**\n     * @notice Updates product closed state\n     * @dev only callable by product owner. Settles the product before flipping the flag\n     * @param newClosed new closed value\n     */\n    function updateClosed(bool newClosed) external nonReentrant notPaused onlyProductOwner {\n        IOracleProvider.OracleVersion memory oracleVersion = _settle();\n        _closed.store(newClosed);\n        emit ClosedUpdated(newClosed, oracleVersion.version);\n    }\n\n    /**\n     * @notice Updates underlying product oracle\n     * @dev only callable by product owner\n     * @param newOracle new oracle address\n     */\n    function updateOracle(IOracleProvider newOracle) external onlyProductOwner {\n        _updateOracle(address(newOracle), latestVersion());\n    }\n\n    /// @dev Limit total maker for guarded rollouts\n    modifier makerInvariant() {\n        _;\n\n        Position memory next = positionAtVersion(latestVersion()).next(_position.pre);\n\n        if (next.maker.gt(makerLimit())) revert ProductMakerOverLimitError();\n    }\n\n    /// @dev Limit maker short exposure to the range 0.0-1.0x of their position. Does not apply when in closeOnly state\n    modifier takerInvariant() {\n        _;\n\n        if (closed()) return;\n\n        Position memory next = positionAtVersion(latestVersion()).next(_position.pre);\n        UFixed18 socializationFactor = next.socializationFactor();\n\n        if (socializationFactor.lt(UFixed18Lib.ONE)) revert ProductInsufficientLiquidityError(socializationFactor);\n    }\n\n    /// @dev Limit utilization to (1 - utilizationBuffer)\n    modifier maxUtilizationInvariant() {\n        _;\n\n        if (closed()) return;\n\n        Position memory next = positionAtVersion(latestVersion()).next(_position.pre);\n        UFixed18 utilization = next.taker.unsafeDiv(next.maker);\n        if (utilization.gt(UFixed18Lib.ONE.sub(utilizationBuffer())))\n            revert ProductInsufficientLiquidityError(utilization);\n    }\n\n    /// @dev Ensure that the user has only taken a maker or taker position, but not both\n    modifier positionInvariant(address account) {\n        _;\n\n        if (_positions[account].isDoubleSided()) revert ProductDoubleSidedError();\n    }\n\n    /// @dev Ensure that the user hasn't closed more than is open\n    modifier closeInvariant(address account) {\n        _;\n\n        if (_positions[account].isOverClosed()) revert ProductOverClosedError();\n    }\n\n    /// @dev Ensure that the user will have sufficient margin for maintenance after next settlement\n    modifier maintenanceInvariant(address account) {\n        _;\n\n        if (controller().collateral().liquidatableNext(account, IProduct(this)))\n            revert ProductInsufficientCollateralError();\n    }\n\n    /// @dev Ensure that the user is not currently being liquidated\n    modifier liquidationInvariant(address account) {\n        if (_positions[account].liquidation) revert ProductInLiquidationError();\n\n        _;\n    }\n\n    /// @dev Helper to fully settle an account's state\n    modifier settleForAccount(address account) {\n        IOracleProvider.OracleVersion memory _currentVersion = _settle();\n        _settleAccount(account, _currentVersion);\n\n        _;\n    }\n\n    /// @dev Ensure we have bootstraped the oracle before creating positions\n    modifier nonZeroVersionInvariant() {\n        if (latestVersion() == 0) revert ProductOracleBootstrappingError();\n\n        _;\n    }\n\n    /// @dev Ensure the product is not closed\n    modifier notClosed() {\n        if (closed()) revert ProductClosedError();\n\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-mono/packages/perennial/contracts/collateral/Collateral.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\nimport \"@equilibria/root/control/unstructured/UInitializable.sol\";\nimport \"@equilibria/root/control/unstructured/UReentrancyGuard.sol\";\nimport \"../interfaces/ICollateral.sol\";\nimport \"./types/OptimisticLedger.sol\";\nimport \"../controller/UControllerProvider.sol\";\n\n/**\n * @title Collateral\n * @notice Manages logic and state for all collateral accounts in the protocol.\n */\ncontract Collateral is ICollateral, UInitializable, UControllerProvider, UReentrancyGuard {\n    /// @dev ERC20 stablecoin for collateral\n    Token18 public immutable token;\n\n    /// @dev Per product collateral state\n    mapping(IProduct => OptimisticLedger) private _products;\n\n    /// @dev Protocol and product fees collected, but not yet claimed\n    mapping(address => UFixed18) public fees;\n\n    /**\n     * @notice Initializes the immutable contract state\n     * @dev Called at implementation instantiate and constant for that implementation.\n     * @param token_ Collateral ERC20 stablecoin address\n     */\n    constructor(Token18 token_) {\n        token = token_;\n    }\n\n    /**\n     * @notice Initializes the contract state\n     * @dev Must be called atomically as part of the upgradeable proxy deployment to\n     *      avoid front-running\n     * @param controller_ Factory contract address\n     */\n    function initialize(IController controller_) external initializer(1) {\n        __UControllerProvider__initialize(controller_);\n        __UReentrancyGuard__initialize();\n    }\n\n    /**\n     * @notice Deposits `amount` collateral from `msg.sender` to `account`'s `product`\n     *         account\n     * @param account Account to deposit the collateral for\n     * @param product Product to credit the collateral to\n     * @param amount Amount of collateral to deposit\n     */\n    function depositTo(address account, IProduct product, UFixed18 amount)\n    external\n    nonReentrant\n    notPaused\n    notZeroAddress(account)\n    isProduct(product)\n    collateralInvariant(account, product)\n    {\n        _products[product].creditAccount(account, amount);\n        token.pull(msg.sender, amount);\n\n        emit Deposit(account, product, amount);\n    }\n\n    /**\n     * @notice Withdraws `amount` collateral from `msg.sender`'s `product` account\n     *         and sends it to `receiver`\n     * @param receiver Account to withdraw the collateral to\n     * @param product Product to withdraw the collateral from\n     * @param amount Amount of collateral to withdraw\n     */\n    function withdrawTo(address receiver, IProduct product, UFixed18 amount) external {\n        withdrawFrom(msg.sender, receiver, product, amount);\n    }\n\n    /**\n     * @notice Withdraws `amount` collateral from `account`'s `product` account\n     *         and sends it to `receiver`\n     * @param account Account to withdraw the collateral from\n     * @param receiver Account to withdraw the collateral to\n     * @param product Product to withdraw the collateral from\n     * @param amount Amount of collateral to withdraw\n     */\n    function withdrawFrom(address account, address receiver, IProduct product, UFixed18 amount)\n    public\n    nonReentrant\n    notPaused\n    notZeroAddress(receiver)\n    isProduct(product)\n    onlyAccountOrMultiInvoker(account)\n    settleForAccount(account, product)\n    collateralInvariant(account, product)\n    maintenanceInvariant(account, product)\n    {\n        amount = amount.eq(UFixed18Lib.MAX) ? collateral(account, product) : amount;\n        _products[product].debitAccount(account, amount);\n        token.push(receiver, amount);\n\n        emit Withdrawal(account, product, amount);\n    }\n\n    /**\n     * @notice Liquidates `account`'s `product` collateral account\n     * @dev Account must be under-collateralized, fee returned immediately to `msg.sender`\n     * @param account Account to liquidate\n     * @param product Product to liquidate for\n     */\n    function liquidate(address account, IProduct product)\n    external\n    nonReentrant\n    notPaused\n    isProduct(product)\n    settleForAccount(account, product)\n    {\n        if (product.isLiquidating(account)) revert CollateralAccountLiquidatingError(account);\n\n        UFixed18 totalMaintenance = product.maintenance(account);\n        UFixed18 totalCollateral = collateral(account, product);\n\n        if (!totalMaintenance.gt(totalCollateral))\n            revert CollateralCantLiquidate(totalMaintenance, totalCollateral);\n\n        product.closeAll(account);\n\n        // claim fee\n        UFixed18 liquidationFee = controller().liquidationFee();\n        // If maintenance is less than minCollateral, use minCollateral for fee amount\n        UFixed18 collateralForFee = UFixed18Lib.max(totalMaintenance, controller().minCollateral());\n        UFixed18 fee = UFixed18Lib.min(totalCollateral, collateralForFee.mul(liquidationFee));\n\n        _products[product].debitAccount(account, fee);\n        token.push(msg.sender, fee);\n\n        emit Liquidation(account, product, msg.sender, fee);\n    }\n\n    /**\n     * @notice Credits `amount` to `account`'s collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel.\n     *      Moves collateral within a product, any collateral leaving the product due to\n     *      fees has already been accounted for in the settleProduct flywheel.\n     *      Debits in excess of the account balance get recorded as shortfall, and can be\n     *      resolved by the product owner as needed.\n     * @param account Account to credit\n     * @param amount Amount to credit the account (can be negative)\n     */\n    function settleAccount(address account, Fixed18 amount) external onlyProduct {\n        IProduct product = IProduct(msg.sender);\n\n        UFixed18 newShortfall = _products[product].settleAccount(account, amount);\n\n        emit AccountSettle(product, account, amount, newShortfall);\n    }\n\n    /**\n     * @notice Debits `amount` from product's total collateral account\n     * @dev Callable only by the corresponding product as part of the settlement flywheel\n     *      Removes collateral from the product as fees.\n     * @param amount Amount to debit from the account\n     */\n    function settleProduct(UFixed18 amount) external onlyProduct {\n        (IProduct product, IController controller) = (IProduct(msg.sender), controller());\n\n        address protocolTreasury = controller.treasury();\n        address productTreasury = controller.treasury(product);\n\n        UFixed18 protocolFee = amount.mul(controller.protocolFee());\n        UFixed18 productFee = amount.sub(protocolFee);\n\n        _products[product].debit(amount);\n        fees[protocolTreasury] = fees[protocolTreasury].add(protocolFee);\n        fees[productTreasury] = fees[productTreasury].add(productFee);\n\n        emit ProductSettle(product, protocolFee, productFee);\n    }\n\n    /**\n     * @notice Returns the balance of `account`'s `product` collateral account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return The balance of the collateral account\n     */\n    function collateral(address account, IProduct product) public view returns (UFixed18) {\n        return _products[product].balances[account];\n    }\n\n    /**\n     * @notice Returns the total balance of `product`'s collateral\n     * @param product Product to return for\n     * @return The total balance of collateral in the product\n     */\n    function collateral(IProduct product) external view returns (UFixed18) {\n        return _products[product].total;\n    }\n\n    /**\n     * @notice Returns the current shortfall of `product`'s collateral\n     * @param product Product to return for\n     * @return The current shortfall of the product\n     */\n    function shortfall(IProduct product) external view returns (UFixed18) {\n        return _products[product].shortfall;\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatable(address account, IProduct product) external view returns (bool) {\n        if (product.isLiquidating(account)) return false;\n\n        return product.maintenance(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Returns whether `account`'s `product` collateral account can be liquidated\n     *         after the next oracle version settlement\n     * @dev Takes into account the current pre-position on the account\n     * @param account Account to return for\n     * @param product Product to return for\n     * @return Whether the account can be liquidated\n     */\n    function liquidatableNext(address account, IProduct product) external view returns (bool) {\n        return product.maintenanceNext(account).gt(collateral(account, product));\n    }\n\n    /**\n     * @notice Injects additional collateral into a product to resolve shortfall\n     * @dev Shortfall is a measure of settled insolvency in the market\n     *      This hook can be used by the product owner or an insurance fund to re-capitalize an insolvent market\n     * @param product Product to resolve shortfall for\n     * @param amount Amount of shortfall to resolve\n     */\n    function resolveShortfall(IProduct product, UFixed18 amount) external isProduct(product) notPaused {\n        _products[product].resolve(amount);\n        token.pull(msg.sender, amount);\n\n        emit ShortfallResolution(product, amount);\n    }\n\n    /**\n     * @notice Claims all of `msg.sender`'s fees\n     */\n    function claimFee() external notPaused {\n        UFixed"
    }
  ]
}