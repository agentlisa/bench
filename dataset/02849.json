{
  "Title": "H-10: `LienToken.buyoutLien` will always revert",
  "Content": "# Issue H-10: `LienToken.buyoutLien` will always revert \n\nSource: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/196 \n\n## Found by \nyixxas, ctf\\_sec, neila, 0xRajeev, supernova, rvierdiiev, zzykxx, 8olidity, cccz\n\n## Summary\n\n`buyoutLien()` will always revert, preventing the borrower from refinancing.\n\n## Vulnerability Detail\n\n`buyoutFeeDenominator` is `0` without a setter which will cause `getBuyoutFee()` to revert in the `buyoutLien()` flow. \n\n## Impact\n\nRefinancing is a crucial feature of the protocol to allow a borrower to refinance their loan if a certain minimum improvement of interest rate or duration is offered. The reverting `buyoutLien()` flow will prevent the borrower from refinancing and effectively lead to loss of their funds due to lock-in into currently held loans when better terms are available.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L71\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L456\n3. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L377\n4. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L132\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInitialize the buyout fee numerator and denominator in `AstariaRouter` and add their setters to `file()`.\n\n## Discussion\n\n**secureum**\n\nEscalate for 2 USDC.\n\nGiven the potential impact to different flows/contexts, we still think this is a high-severity impact (not Medium as judged). A majority of the dups (while some are dups of a different but related issue) also reported this as a High.\n\ncc @berndartmueller @lucyoa\n\n**sherlock-admin**\n\n > Escalate for 2 USDC.\n> \n> Given the potential impact to different flows/contexts, we still think this is a high-severity impact (not Medium as judged). A majority of the dups (while some are dups of a different but related issue) also reported this as a High.\n> \n> cc @berndartmueller @lucyoa\n\nYou've created a valid escalation for 2 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/8",
  "Code": [
    {
      "filename": "src/AstariaRouter.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IAuctionHouse} from \"gpl/interfaces/IAuctionHouse.sol\";\nimport {IERC721} from \"gpl/interfaces/IERC721.sol\";\nimport {ITransferProxy} from \"gpl/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {CollateralLookup} from \"./libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"./interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"./interfaces/ICollateralToken.sol\";\nimport {ILienBase, ILienToken} from \"./interfaces/ILienToken.sol\";\nimport {IStrategyValidator} from \"./interfaces/IStrategyValidator.sol\";\n\nimport {IPublicVault, PublicVault} from \"./PublicVault.sol\";\nimport {IVault, VaultImplementation} from \"./VaultImplementation.sol\";\nimport {LiquidationAccountant} from \"./LiquidationAccountant.sol\";\n\nimport {MerkleProof} from \"./utils/MerkleProof.sol\";\nimport {Pausable} from \"./utils/Pausable.sol\";\n\n/**\n * @title AstariaRouter\n * @notice This contract manages the deployment of Vaults and universal Astaria actions.\n */\ncontract AstariaRouter is Auth, Pausable, IAstariaRouter {\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n\n  ERC20 public immutable WETH;\n  ICollateralToken public immutable COLLATERAL_TOKEN;\n  ILienToken public immutable LIEN_TOKEN;\n  ITransferProxy public immutable TRANSFER_PROXY;\n\n  address public LIQUIDATION_IMPLEMENTATION;\n  address public SOLO_IMPLEMENTATION;\n  address public VAULT_IMPLEMENTATION;\n  address public WITHDRAW_IMPLEMENTATION;\n  address public feeTo;\n  uint256 public liquidationFeePercent;\n  uint256 public maxInterestRate;\n  uint256 public maxEpochLength;\n  uint256 public minEpochLength;\n  uint256 public minInterestBPS; // was uint64\n  uint256 public protocolFeeNumerator;\n  uint256 public protocolFeeDenominator;\n  uint256 public strategistFeeNumerator;\n  uint256 public strategistFeeDenominator;\n  uint256 public buyoutFeeNumerator;\n  uint256 public buyoutFeeDenominator;\n  uint32 public minDurationIncrease;\n  uint32 public buyoutInterestWindow;\n\n  //A strategist can have many deployed vaults\n  mapping(address => address) public vaults;\n  mapping(address => uint256) public strategistNonce;\n  mapping(uint16 => address) public strategyValidators;\n\n  /**\n   * @dev Setup transfer authority and set up addresses for deployed CollateralToken, LienToken, TransferProxy contracts, as well as PublicVault and SoloVault implementations to clone.\n   * @param _AUTHORITY The authority manager.\n   * @param _WETH The WETH address to use for transfers.\n   * @param _COLLATERAL_TOKEN The address of the deployed CollateralToken contract.\n   * @param _LIEN_TOKEN The address of the deployed LienToken contract.\n   * @param _TRANSFER_PROXY The address of the deployed TransferProxy contract.\n   * @param _VAULT_IMPL The address of a base implementation of VaultImplementation for cloning.\n   * @param _SOLO_IMPL The address of a base implementation of a PrivateVault for cloning.\n   */\n  constructor(\n    Authority _AUTHORITY,\n    address _WETH,\n    ICollateralToken _COLLATERAL_TOKEN,\n    ILienToken _LIEN_TOKEN,\n    ITransferProxy _TRANSFER_PROXY,\n    address _VAULT_IMPL,\n    address _SOLO_IMPL\n  ) Auth(address(msg.sender), _AUTHORITY) {\n    WETH = ERC20(_WETH);\n    COLLATERAL_TOKEN = _COLLATERAL_TOKEN;\n    LIEN_TOKEN = _LIEN_TOKEN;\n    TRANSFER_PROXY = _TRANSFER_PROXY;\n    VAULT_IMPLEMENTATION = _VAULT_IMPL;\n    SOLO_IMPLEMENTATION = _SOLO_IMPL;\n    liquidationFeePercent = 13;\n    minInterestBPS = uint256(0.0005 ether) / uint256(365 days); //5 bips / second\n    minEpochLength = 7 days;\n    maxEpochLength = 45 days;\n    maxInterestRate = 63419583966; // 200% apy / second\n    strategistFeeNumerator = 200;\n    strategistFeeDenominator = 1000;\n    minDurationIncrease = 14 days;\n    buyoutInterestWindow = 60 days;\n  }\n\n  /**\n   * @dev Enables _pause, freezing functions with the whenNotPaused modifier.\n   */\n  function __emergencyPause() external requiresAuth whenNotPaused {\n    _pause();\n  }\n\n  /**\n   * @dev Disables _pause, un-freezing functions with the whenNotPaused modifier.\n   */\n  function __emergencyUnpause() external requiresAuth whenPaused {\n    _unpause();\n  }\n\n  function incrementNonce() external {\n    strategistNonce[msg.sender]++;\n  }\n\n  /**\n   * @notice Sets universal protocol parameters or changes the addresses for deployed contracts.\n   * @param what The identifier for what is being filed.\n   * @param data The encoded address data to be decoded and filed.\n   */\n  function fileBatch(bytes32[] memory what, bytes[] calldata data)\n    external\n    requiresAuth\n  {\n    require(what.length == data.length, \"data length mismatch\");\n    for (uint256 i = 0; i < what.length; i++) {\n      file(what[i], data[i]);\n    }\n  }\n\n  function file(bytes32 what, bytes calldata data) public requiresAuth {\n    if (what == \"LIQUIDATION_FEE_PERCENT\") {\n      uint256 value = abi.decode(data, (uint256));\n      liquidationFeePercent = value;\n    } else if (what == \"MIN_INTEREST_BPS\") {\n      uint256 value = abi.decode(data, (uint256));\n      minInterestBPS = uint256(value);\n    } else if (what == \"APPRAISER_NUMERATOR\") {\n      uint256 value = abi.decode(data, (uint256));\n      strategistFeeNumerator = value;\n    } else if (what == \"APPRAISER_ORIGINATION_FEE_BASE\") {\n      uint256 value = abi.decode(data, (uint256));\n      strategistFeeDenominator = value;\n    } else if (what == \"MIN_DURATION_INCREASE\") {\n      uint256 value = abi.decode(data, (uint256));\n      minDurationIncrease = value.safeCastTo32();\n    } else if (what == \"WITHDRAW_IMPLEMENTATION\") {\n      address addr = abi.decode(data, (address));\n      WITHDRAW_IMPLEMENTATION = addr;\n    } else if (what == \"LIQUIDATION_IMPLEMENTATION\") {\n      address addr = abi.decode(data, (address));\n      LIQUIDATION_IMPLEMENTATION = addr;\n    } else if (what == \"VAULT_IMPLEMENTATION\") {\n      address addr = abi.decode(data, (address));\n      VAULT_IMPLEMENTATION = addr;\n    } else if (what == \"SOLO_IMPLEMENTATION\") {\n      address addr = abi.decode(data, (address));\n      SOLO_IMPLEMENTATION = addr;\n    } else if (what == \"MIN_EPOCH_LENGTH\") {\n      minEpochLength = abi.decode(data, (uint256));\n    } else if (what == \"MAX_EPOCH_LENGTH\") {\n      maxEpochLength = abi.decode(data, (uint256));\n    } else if (what == \"MAX_INTEREST_RATE\") {\n      maxInterestRate = abi.decode(data, (uint256));\n    } else if (what == \"feeTo\") {\n      address addr = abi.decode(data, (address));\n      feeTo = addr;\n    } else if (what == \"setBuyoutInterestWindow\") {\n      uint256 value = abi.decode(data, (uint256));\n      buyoutInterestWindow = value.safeCastTo32();\n    } else if (what == \"setStrategyValidator\") {\n      (uint8 TYPE, address addr) = abi.decode(data, (uint8, address));\n      strategyValidators[TYPE] = addr;\n    } else {\n      revert(\"unsupported/file\");\n    }\n  }\n\n  // MODIFIERS\n  modifier onlyVaults() {\n    require(\n      vaults[msg.sender] != address(0),\n      \"this vault has not been initialized\"\n    );\n    _;\n  }\n\n  //PUBLIC\n\n  function validateCommitment(IAstariaRouter.Commitment calldata commitment)\n    public\n    returns (bool valid, IAstariaRouter.LienDetails memory ld)\n  {\n    require(\n      commitment.lienRequest.strategy.deadline >= block.timestamp,\n      \"deadline passed\"\n    );\n\n    require(\n      strategyValidators[commitment.lienRequest.nlrType] != address(0),\n      \"invalid strategy type\"\n    );\n\n    bytes32 leaf;\n    (leaf, ld) = IStrategyValidator(\n      strategyValidators[commitment.lienRequest.nlrType]\n    ).validateAndParse(\n        commitment.lienRequest,\n        COLLATERAL_TOKEN.ownerOf(\n          commitment.tokenContract.computeId(commitment.tokenId)\n        ),\n        commitment.tokenContract,\n        commitment.tokenId\n      );\n\n    return (\n      MerkleProof.verifyCalldata(\n        commitment.lienRequest.merkle.proof,\n        commitment.lienRequest.merkle.root,\n        leaf\n      ),\n      ld\n    );\n  }\n\n  /**\n   * @notice Deposits collateral and requests loans for multiple NFTs at once.\n   * @param commitments The commitment proofs and requested loan data for each loan.\n   * @return totalBorrowed The total amount borrowed by the requested loans.\n   */\n  function commitToLiens(IAstariaRouter.Commitment[] calldata commitments)\n    external\n    whenNotPaused\n    returns (uint256 totalBorrowed)\n  {\n    totalBorrowed = 0;\n    for (uint256 i = 0; i < commitments.length; ++i) {\n      _transferAndDepositAsset(\n        commitments[i].tokenContract,\n        commitments[i].tokenId\n      );\n      totalBorrowed += _executeCommitment(commitments[i]);\n\n      uint256 collateralId = commitments[i].tokenContract.computeId(\n        commitments[i].tokenId\n      );\n      _returnCollateral(collateralId, address(msg.sender));\n    }\n    WETH.safeApprove(address(TRANSFER_PROXY), totalBorrowed);\n    TRANSFER_PROXY.tokenTransferFrom(\n      address(WETH),\n      address(this),\n      address(msg.sender),\n      totalBorrowed\n    );\n  }\n\n  /**\n   * @notice Deploys a new PrivateVault.\n   * @return The address of the new PrivateVault.\n   */\n  function newVault(address delegate) external whenNotPaused returns (address) {\n    return _newVault(uint256(0), delegate, uint256(0));\n  }\n\n  /**\n   * @notice Deploys a new PublicVault.\n   * @param epochLength The length of each epoch for the new PublicVault.\n   */\n  function newPublicVault(\n    uint256 epochLength,\n    address delegate,\n    uint256 vaultFee\n  ) external whenNotPaused returns (address) {\n    return _newVault(epochLength, delegate, vaultFee);\n  }\n\n  /**\n   * @notice Create a new lien against a CollateralToken.\n   * @param terms the decoded lien details from the commitment\n   * @param params The valid proof and lien details for the new loan.\n   * @return The ID of the created lien.\n   */\n  function requestLienPosition(\n    IAstariaRouter.LienDetails memory terms,\n    IAstariaRouter.Commitment calldata params\n  ) external whenNotPaused onlyVaults returns (uint256) {\n    return\n      LIEN_TOKEN.createLien(\n        ILienBase.LienActionEncumber({\n          tokenContract: params.tokenContract,\n          tokenId: params.tokenId,\n          terms: terms,\n          strategyRoot: params.lienRequest.merkle.root,\n          amount: params.lienRequest.amount,\n          vault: address(msg.sender)\n        })\n      );\n  }\n\n  /**\n   * @notice Lend to a PublicVault.\n   * @param vault The address of the PublicVault.\n   * @param amount The amount to lend.\n   */\n  function lendToVault(IVault vault, uint256 amount) external whenNotPaused {\n    TRANSFER_PROXY.tokenTransferFrom(\n      address(WETH),\n      address(msg.sender),\n      address(this),\n      amount\n    );\n\n    require(\n      vaults[address(vault)] != address(0),\n      \"lendToVault: vault doesn't exist\"\n    );\n    WETH.safeApprove(address(vault), amount);\n    vault.deposit(amount, address(msg.sender));\n  }\n\n  /**\n   * @notice Returns whether a specific lien can be liquidated.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param position The specified lien position.\n   * @return A boolean value indicating whether the specified lien can be liquidated.\n   */\n  function canLiquidate(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (bool)\n  {\n    ILienToken.Lien memory lien = LIEN_TOKEN.getLien(collateralId, position);\n\n    return (lien.start + lien.duration <= block.timestamp && lien.amount > 0);\n  }\n\n  /**\n   * @notice Liquidate a CollateralToken that has defaulted on one of its liens.\n   * @param collateralId The ID of the CollateralToken.\n   * @param position The position of the defaulted lien.\n   * @return reserve The amount owed on all liens for against the collateral being liquidated, including accrued interest.\n   */\n  function liquidate(uint256 collateralId, uint256 position)\n    external\n    returns (uint256 reserve)\n  {\n    require(\n      canLiquidate(collateralId, position),\n      \"liquidate: borrow is healthy\"\n    );\n\n    // if expiration will be past epoch boundary, then create a LiquidationAccountant\n\n    uint256[] memory liens = LIEN_TOKEN.getLiens(collateralId);\n    for (uint256 i = 0; i < liens.length; ++i) {\n      uint256 currentLien = liens[i];\n\n      ILienToken.Lien memory lien = LIEN_TOKEN.getLien(currentLien);\n\n      address owner = LIEN_TOKEN.ownerOf(currentLien);\n      if (\n        IPublicVault(owner).supportsInterface(type(IPublicVault).interfaceId)\n      ) {\n        // subtract slope from PublicVault\n\n        PublicVault(owner).updateVaultAfterLiquidation(\n          LIEN_TOKEN.calculateSlope(currentLien)\n        );\n        if (\n          PublicVault(owner).timeToEpochEnd() <=\n          COLLATERAL_TOKEN.auctionWindow()\n        ) {\n          uint64 currentEpoch = PublicVault(owner).getCurrentEpoch();\n          address accountant = PublicVault(owner).getLiquidationAccountant(\n            currentEpoch\n          );\n          uint256 lienEpoch = PublicVault(owner).getLienEpoch(\n            lien.start + lien.duration\n          );\n          PublicVault(owner).decreaseEpochLienCount(lienEpoch);\n\n          // only deploy a LiquidationAccountant for the next set of withdrawing LPs if the previous set of LPs have been repaid\n          if (PublicVault(owner).withdrawReserve() == 0) {\n            if (accountant == address(0)) {\n              accountant = PublicVault(owner).deployLiquidationAccountant();\n            }\n            LIEN_TOKEN.setPayee(currentLien, accountant);\n            LiquidationAccountant(accountant).handleNewLiquidation(\n              lien.amount,\n              COLLATERAL_TOKEN.auctionWindow() + 1 days\n            );\n            PublicVault(owner).increaseLiquidationsExpectedAtBoundary(\n              lien.amount\n            );\n          }\n        }\n      }\n    }\n\n    reserve = COLLATERAL_TOKEN.auctionVault(\n      collateralId,\n      address(msg.sender),\n      liquidationFeePercent\n    );\n\n    emit Liquidation(collateralId, position, reserve);\n  }\n\n  /**\n   * @notice Retrieves the fee PublicVault strategists earn on loan origination.\n   * @return The numerator and denominator used to compute the percentage fee strategists earn by receiving minted vault shares.\n   */\n  function getStrategistFee(uint256 amountIn) external view returns (uint256) {\n    return\n      amountIn.mulDivDown(strategistFeeNumerator, strategistFeeDenominator);\n  }\n\n  /**\n   * @notice Retrieves the fee the protocol earns on loan origination.\n   * @return The numerator and denominator used to compute the percentage fee taken by the protocol\n   */\n  function getProtocolFee(uint256 amountIn) external view returns (uint256) {\n    return amountIn.mulDivDown(protocolFeeNumerator, protocolFeeDenominator);\n  }\n\n  /**\n   * @notice Retrieves the fee the protocol earns on loan origination.\n   * @return The numerator and denominator used to compute the percentage fee taken by the protocol\n   */\n\n  function getBuyoutFee(uint256 remainingInterestIn)\n    external\n    view\n    returns (uint256)\n  {\n    return\n      remainingInterestIn.mulDivDown(buyoutFeeNumerator, buyoutFeeDenominator);\n  }\n\n  /**\n   * @notice Retrieves the time window for computing maxbuyout costs\n   * @return The numerator and denominator used to compute the percentage fee taken by the protocol\n   */\n  function getBuyoutInterestWindow() external view returns (uint32) {\n    return buyoutInterestWindow;\n  }\n\n  /**\n   * @notice Returns whether a given address is that of a Vault.\n   * @param vault The Vault address.\n   * @return A boolean representing whether the address exists as a Vault.\n   */\n  function isValidVault(address vault) external view returns (bool) {\n    return vaults[vault] != address(0);\n  }\n\n  /**\n   * @notice Determines whether a potential refinance meets the minimum requirements for replacing a lien.\n   * @param lien The Lien to be refinanced.\n   * @param newLien The new Lien to replace the existing one.\n   * @return A boolean representing whether the potential refinance is valid.\n   */\n  function isValidRefinance(\n    ILienToken.Lien memory lien,\n    LienDetails memory newLien\n  ) external view returns (bool) {\n    uint256 minNewRate = uint256(lien.rate) - minInterestBPS;\n\n    return (newLien.rate >= minNewRate &&\n      ((block.timestamp + newLien.duration - lien.start - lien.duration) >=\n        minDurationIncrease));\n  }\n\n  //INTERNAL FUNCS\n\n  /**\n   * @dev Deploys a new PublicVault.\n   * @param epochLength The length of each epoch for the new PublicVault.\n   * @return The address for the new PublicVault.\n   */\n  function _newVault(\n    uint256 epochLength,\n    address delegate,\n    uint256 vaultFee\n  ) internal returns (address) {\n    uint8 vaultType;\n\n    address implementation;\n    if (epochLength > uint256(0)) {\n      require(\n        epochLength >= minEpochLength && epochLength <= maxEpochLength,\n        \"epochLength must be greater than or equal to MIN_EPOCH_LENGTH and less than MAX_EPOCH_LENGTH\"\n      );\n      implementation = VAULT_IMPLEMENTATION;\n      vaultType = uint8(VaultType.PUBLIC);\n    } else {\n      implementation = SOLO_IMPLEMENTATION;\n      vaultType = uint8(VaultType.SOLO);\n    }\n\n    //immutable data\n    address vaultAddr = ClonesWithImmutableArgs.clone(\n      implementation,\n      abi.encodePacked(\n        address(msg.sender),\n        address(WETH),\n        address(COLLATERAL_TOKEN),\n        address(this),\n        address(COLLATERAL_TOKEN.AUCTION_HOUSE()),\n        block.timestamp,\n        epochLength,\n        vaultType,\n        vaultFee\n      )\n    );\n\n    //mutable data\n    VaultImplementation(vaultAddr).init(\n      VaultImplementation.InitParams(delegate)\n    );\n\n    vaults[vaultAddr] = msg.sender;\n\n    emit NewVault(msg.sender, vaultAddr);\n\n    return vaultAddr;\n  }\n\n  /**\n   * @dev validates msg sender is owner\n   * @param c The commitment Data\n   * @return the amount borrowed\n   */\n  function _executeCommitment(IAstariaRouter.Commitment memory c)\n    internal\n    returns (uint256)\n  {\n    uint256 collateralId = c.tokenContract.computeId(c.tokenId);\n    require(\n      msg.sender == COLLATERAL_TOKEN.ownerOf(collateralId),\n      \"invalid sender for collateralId\"\n    );\n    return _borrow(c, address(this));\n  }\n\n  function _borrow(IAstariaRouter.Commitment memory c, address receiver)\n    internal\n    returns (uint256)\n  {\n    //router must be approved for the collateral to take a loan,\n    VaultImplementation(c.lienRequest.strategy.vault).commitToLien(c, receiver);\n    if (receiver == address(this)) {\n      return c.lienRequest.amount;\n    } else {\n      return uint256(0);\n    }\n  }\n\n  function _transferAndDepositAsset(address tokenContract, uint256 tokenId)\n    internal\n  {\n    IERC721(tokenContract).safeTransferFrom(\n      address(msg.sender),\n      address(COLLATERAL_TOKEN),\n      tokenId,\n      \"\"\n    );\n  }\n\n  function _returnCollateral(uint256 collateralId, address receiver) internal {\n    COLLATERAL_TOKEN.transferFrom(address(this), receiver, collateralId);\n  }\n}"
    },
    {
      "filename": "src/AstariaRouter.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IAuctionHouse} from \"gpl/interfaces/IAuctionHouse.sol\";\nimport {IERC721} from \"gpl/interfaces/IERC721.sol\";\nimport {ITransferProxy} from \"gpl/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {CollateralLookup} from \"./libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"./interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"./interfaces/ICollateralToken.sol\";\nimport {ILienBase, ILienToken} from \"./interfaces/ILienToken.sol\";\nimport {IStrategyValidator} from \"./interfaces/IStrategyValidator.sol\";\n\nimport {IPublicVault, PublicVault} from \"./PublicVault.sol\";\nimport {IVault, VaultImplementation} from \"./VaultImplementation.sol\";\nimport {LiquidationAccountant} from \"./LiquidationAccountant.sol\";\n\nimport {MerkleProof} from \"./utils/MerkleProof.sol\";\nimport {Pausable} from \"./utils/Pausable.sol\";\n\n/**\n * @title AstariaRouter\n * @notice This contract manages the deployment of Vaults and universal Astaria actions.\n */\ncontract AstariaRouter is Auth, Pausable, IAstariaRouter {\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n\n  ERC20 public immutable WETH;\n  ICollateralToken public immutable COLLATERAL_TOKEN;\n  ILienToken public immutable LIEN_TOKEN;\n  ITransferProxy public immutable TRANSFER_PROXY;\n\n  address public LIQUIDATION_IMPLEMENTATION;\n  address public SOLO_IMPLEMENTATION;\n  address public VAULT_IMPLEMENTATION;\n  address public WITHDRAW_IMPLEMENTATION;\n  address public feeTo;\n  uint256 public liquidationFeePercent;\n  uint256 public maxInterestRate;\n  uint256 public maxEpochLength;\n  uint256 public minEpochLength;\n  uint256 public minInterestBPS; // was uint64\n  uint256 public protocolFeeNumerator;\n  uint256 public protocolFeeDenominator;\n  uint256 public strategistFeeNumerator;\n  uint256 public strategistFeeDenominator;\n  uint256 public buyoutFeeNumerator;\n  uint256 public buyoutFeeDenominator;\n  uint32 public minDurationIncrease;\n  uint32 public buyoutInterestWindow;\n\n  //A strategist can have many deployed vaults\n  mapping(address => address) public vaults;\n  mapping(address => uint256) public strategistNonce;\n  mapping(uint16 => address) public strategyValidators;\n\n  /**\n   * @dev Setup transfer authority and set up addresses for deployed CollateralToken, LienToken, TransferProxy contracts, as well as PublicVault and SoloVault implementations to clone.\n   * @param _AUTHORITY The authority manager.\n   * @param _WETH The WETH address to use for transfers.\n   * @param _COLLATERAL_TOKEN The address of the deployed CollateralToken contract.\n   * @param _LIEN_TOKEN The address of the deployed LienToken contract.\n   * @param _TRANSFER_PROXY The address of the deployed TransferProxy contract.\n   * @param _VAULT_IMPL The address of a base implementation of VaultImplementation for cloning.\n   * @param _SOLO_IMPL The address of a base implementation of a PrivateVault for cloning.\n   */\n  constructor(\n    Authority _AUTHORITY,\n    address _WETH,\n    ICollateralToken _COLLATERAL_TOKEN,\n    ILienToken _LIEN_TOKEN,\n    ITransferProxy _TRANSFER_PROXY,\n    address _VAULT_IMPL,\n    address _SOLO_IMPL\n  ) Auth(address(msg.sender), _AUTHORITY) {\n    WETH = ERC20(_WETH);\n    COLLATERAL_TOKEN = _COLLATERAL_TOKEN;\n    LIEN_TOKEN = _LIEN_TOKEN;\n    TRANSFER_PROXY = _TRANSFER_PROXY;\n    VAULT_IMPLEMENTATION = _VAULT_IMPL;\n    SOLO_IMPLEMENTATION = _SOLO_IMPL;\n    liquidationFeePercent = 13;\n    minInterestBPS = uint256(0.0005 ether) / uint256(365 days); //5 bips / second\n    minEpochLength = 7 days;\n    maxEpochLength = 45 days;\n    maxInterestRate = 63419583966; // 200% apy / second\n    strategistFeeNumerator = 200;\n    strategistFeeDenominator = 1000;\n    minDurationIncrease = 14 days;\n    buyoutInterestWindow = 60 days;\n  }\n\n  /**\n   * @dev Enables _pause, freezing functions with the whenNotPaused modifier.\n   */\n  function __emergencyPause() external requiresAuth whenNotPaused {\n    _pause();\n  }\n\n  /**\n   * @dev Disables _pause, un-freezing functions with the whenNotPaused modifier.\n   */\n  function __emergencyUnpause() external requiresAuth whenPaused {\n    _unpause();\n  }\n\n  function incrementNonce() external {\n    strategistNonce[msg.sender]++;\n  }\n\n  /**\n   * @notice Sets universal protocol parameters or changes the addresses for deployed contracts.\n   * @param what The identifier for what is being filed.\n   * @param data The encoded address data to be decoded and filed.\n   */\n  function fileBatch(bytes32[] memory what, bytes[] calldata data)\n    external\n    requiresAuth\n  {\n    require(what.length == data.length, \"data length mismatch\");\n    for (uint256 i = 0; i < what.length; i++) {\n      file(what[i], data[i]);\n    }\n  }\n\n  function file(bytes32 what, bytes calldata data) public requiresAuth {\n    if (what == \"LIQUIDATION_FEE_PERCENT\") {\n      uint256 value = abi.decode(data, (uint256));\n      liquidationFeePercent = value;\n    } else if (what == \"MIN_INTEREST_BPS\") {\n      uint256 value = abi.decode(data, (uint256));\n      minInterestBPS = uint256(value);\n    } else if (what == \"APPRAISER_NUMERATOR\") {\n      uint256 value = abi.decode(data, (uint256));\n      strategistFeeNumerator = value;\n    } else if (what == \"APPRAISER_ORIGINATION_FEE_BASE\") {\n      uint256 value = abi.decode(data, (uint256));\n      strategistFeeDenominator = value;\n    } else if (what == \"MIN_DURATION_INCREASE\") {\n      uint256 value = abi.decode(data, (uint256));\n      minDurationIncrease = value.safeCastTo32();\n    } else if (what == \"WITHDRAW_IMPLEMENTATION\") {\n      address addr = abi.decode(data, (address));\n      WITHDRAW_IMPLEMENTATION = addr;\n    } else if (what == \"LIQUIDATION_IMPLEMENTATION\") {\n      address addr = abi.decode(data, (address));\n      LIQUIDATION_IMPLEMENTATION = addr;\n    } else if (what == \"VAULT_IMPLEMENTATION\") {\n      address addr = abi.decode(data, (address));\n      VAULT_IMPLEMENTATION = addr;\n    } else if (what == \"SOLO_IMPLEMENTATION\") {\n      address addr = abi.decode(data, (address));\n      SOLO_IMPLEMENTATION = addr;\n    } else if (what == \"MIN_EPOCH_LENGTH\") {\n      minEpochLength = abi.decode(data, (uint256));\n    } else if (what == \"MAX_EPOCH_LENGTH\") {\n      maxEpochLength = abi.decode(data, (uint256));\n    } else if (what == \"MAX_INTEREST_RATE\") {\n      maxInterestRate = abi.decode(data, (uint256));\n    } else if (what == \"feeTo\") {\n      address addr = abi.decode(data, (address));\n      feeTo = addr;\n    } else if (what == \"setBuyoutInterestWindow\") {\n      uint256 value = abi.decode(data, (uint256));\n      buyoutInterestWindow = value.safeCastTo32();\n    } else if (what == \"setStrategyValidator\") {\n      (uint8 TYPE, address addr) = abi.decode(data, (uint8, address));\n      strategyValidators[TYPE] = addr;\n    } else {\n      revert(\"unsupported/file\");\n    }\n  }\n\n  // MODIFIERS\n  modifier onlyVaults() {\n    require(\n      vaults[msg.sender] != address(0),\n      \"this vault has not been initialized\"\n    );\n    _;\n  }\n\n  //PUBLIC\n\n  function validateCommitment(IAstariaRouter.Commitment calldata commitment)\n    public\n    returns (bool valid, IAstariaRouter.LienDetails memory ld)\n  {\n    require(\n      commitment.lienRequest.strategy.deadline >= block.timestamp,\n      \"deadline passed\"\n    );\n\n    require(\n      strategyValidators[commitment.lienRequest.nlrType] != address(0),\n      \"invalid strategy type\"\n    );\n\n    bytes32 leaf;\n    (leaf, ld) = IStrategyValidator(\n      strategyValidators[commitment.lienRequest.nlrType]\n    ).validateAndParse(\n        commitment.lienRequest,\n        COLLATERAL_TOKEN.ownerOf(\n          commitment.tokenContract.computeId(commitment.tokenId)\n        ),\n        commitment.tokenContract,\n        commitment.tokenId\n      );\n\n    return (\n      MerkleProof.verifyCalldata(\n        commitment.lienRequest.merkle.proof,\n        commitment.lienRequest.merkle.root,\n        leaf\n      ),\n      ld\n    );\n  }\n\n  /**\n   * @notice Deposits collateral and requests loans for multiple NFTs at once.\n   * @param commitments The commitment proofs and requested loan data for each loan.\n   * @return totalBorrowed The total amount borrowed by the requested loans.\n   */\n  function commitToLiens(IAstariaRouter.Commitment[] calldata commitments)\n    external\n    whenNotPaused\n    returns (uint256 totalBorrowed)\n  {\n    totalBorrowed = 0;\n    for (uint256 i = 0; i < commitments.length; ++i) {\n      _transferAndDepositAsset(\n        commitments[i].tokenContract,\n        commitments[i].tokenId\n      );\n      totalBorrowed += _executeCommitment(commitments[i]);\n\n      uint256 collateralId = commitments[i].tokenContract.computeId(\n        commitments[i].tokenId\n      );\n      _returnCollateral(collateralId, address(msg.sender));\n    }\n    WETH.safeApprove(address(TRANSFER_PROXY), totalBorrowed);\n    TRANSFER_PROXY.tokenTransferFrom(\n      address(WETH),\n      address(this),\n      address(msg.sender),\n      totalBorrowed\n    );\n  }\n\n  /**\n   * @notice Deploys a new PrivateVault.\n   * @return The address of the new PrivateVault.\n   */\n  function newVault(address delegate) external whenNotPaused returns (address) {\n    return _newVault(uint256(0), delegate, uint256(0));\n  }\n\n  /**\n   * @notice Deploys a new PublicVault.\n   * @param epochLength The length of each epoch for the new PublicVault.\n   */\n  function newPublicVault(\n    uint256 epochLength,\n    address delegate,\n    uint256 vaultFee\n  ) external whenNotPaused returns (address) {\n    return _newVault(epochLength, delegate, vaultFee);\n  }\n\n  /**\n   * @notice Create a new lien against a CollateralToken.\n   * @param terms the decoded lien details from the commitment\n   * @param params The valid proof and lien details for the new loan.\n   * @return The ID of the created lien.\n   */\n  function requestLienPosition(\n    IAstariaRouter.LienDetails memory terms,\n    IAstariaRouter.Commitment calldata params\n  ) external whenNotPaused onlyVaults returns (uint256) {\n    return\n      LIEN_TOKEN.createLien(\n        ILienBase.LienActionEncumber({\n          tokenContract: params.tokenContract,\n          tokenId: params.tokenId,\n          terms: terms,\n          strategyRoot: params.lienRequest.merkle.root,\n          amount: params.lienRequest.amount,\n          vault: address(msg.sender)\n        })\n      );\n  }\n\n  /**\n   * @notice Lend to a PublicVault.\n   * @param vault The address of the PublicVault.\n   * @param amount The amount to lend.\n   */\n  function lendToVault(IVault vault, uint256 amount) external whenNotPaused {\n    TRANSFER_PROXY.tokenTransferFrom(\n      address(WETH),\n      address(msg.sender),\n      address(this),\n      amount\n    );\n\n    require(\n      vaults[address(vault)] != address(0),\n      \"lendToVault: vault doesn't exist\"\n    );\n    WETH.safeApprove(address(vault), amount);\n    vault.deposit(amount, address(msg.sender));\n  }\n\n  /**\n   * @notice Returns whether a specific lien can be liquidated.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param position The specified lien position.\n   * @return A boolean value indicating whether the specified lien can be liquidated.\n   */\n  function canLiquidate(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (bool)\n  {\n    ILienToken.Lien memory lien = LIEN_TOKEN.getLien(collateralId, position);\n\n    return (lien.start + lien.duration <= block.timestamp && lien.amount > 0);\n  }\n\n  /**\n   * @notice Liquidate a CollateralToken that has defaulted on one of its liens.\n   * @param collateralId The ID of the CollateralToken.\n   * @param position The position of the defaulted lien.\n   * @return reserve The amount owed on all liens for against the collateral being liquidated, including accrued interest.\n   */\n  function liquidate(uint256 collateralId, uint256 position)\n    external\n    returns (uint256 reserve)\n  {\n    require(\n      canLiquidate(collateralId, position),\n      \"liquidate: borrow is healthy\"\n    );\n\n    // if expiration will be past epoch boundary, then create a LiquidationAccountant\n\n    uint256[] memory liens = LIEN_TOKEN.getLiens(collateralId);\n    for (uint256 i = 0; i < liens.length; ++i) {\n      uint256 currentLien = liens[i];\n\n      ILienToken.Lien memory lien = LIEN_TOKEN.getLien(currentLien);\n\n      address owner = LIEN_TOKEN.ownerOf(currentLien);\n      if (\n        IPublicVault(owner).supportsInterface(type(IPublicVault).interfaceId)\n      ) {\n        // subtract slope from PublicVault\n\n        PublicVault(owner).updateVaultAfterLiquidation(\n          LIEN_TOKEN.calculateSlope(currentLien)\n        );\n        if (\n          PublicVault(owner).timeToEpochEnd() <=\n          COLLATERAL_TOKEN.au"
    }
  ]
}