{
  "Title": "[M-01] Missing check in the `updateValset` function",
  "Content": "\n[Gravity.sol#L276-L358](https://github.com/code-423n4/2022-05-cudos/blob/de39cf3cd1f1e1cf211819b06d4acf6a043acda0/solidity/contracts/Gravity.sol#L276-L358)<br>\n\nThe `updateValset` function don't check that the sum of the powers of the new validators in the new valset is greater than the threshold, which can lead to unwanted behavior.\n\nThere are 2 main problems that can occur in that situation:\n\n1.  The sum of the new validators' powers will be lower than the `state_powerThreshold`\n2.  The sum of the new validators' power will overflow and become lower than the `state_powerThreshold`\n\nThe second case is less dangerous, because it won't stuck the system in every case (only in specific cases where every sum of validators' power is less than the threshold). The first case is very dangerous though. It can lead to the system becoming stuck and to all of the tokens on the cudos chain to become locked for users, because the validators won't have enough power to approve any operation - whether it is transferring tokens or updating the valset.\n\n### Proof of Concept\n\nFor the first case, consider the current validators set containing 100 validators with each ones power being equal to 10, and the threshold is 900 (91+ validators are needed for approvement). Now the `updateValset` function is being called with 100 validators with each ones power being equal to 1. This will lead to a state where no matter how much validators have signed a message, the sum of the powers won't pass the threshold and the action won't be able to be executed. This will cause all the tokens in the cudos blockchain become locked, and will DoS all the actions of the gravity contract - including updating the valset.\n\nFor the second case, consider the new validators set will have 128 validators, each validator's power is equal to `2**249` and `_powerThreshold = 2**256 - 1`. In this case the system will be stuck too, because every sum of validators' power won't pass the threshold.\n\n### Tools Used\n\nRemix and VS Code\n\n### Recommended Mitigation Steps\n\nAdd a check in the `updateValset` to assure that the sum of the new powers is greater than the threshold.\n\n**[V-Staykov (Cudos) disputed and commented](https://github.com/code-423n4/2022-05-cudos-findings/issues/123#issuecomment-1123596915):**\n > This check is done on the Gravity module side and since the message is also signed there by the validators, we can consider it to be always as per the module, unless there are malicious validators with more voting power than the threshold.\n> \n> If the message is considered correct this means that the values of the power are normalized which is in the core of the power threshold calculation. When they are normalized this means that the sum of the validator set will always equal 100% of the power which is more than the threshold.\n> \n> Here is a [link](https://github.com/code-423n4/2022-05-cudos/blob/main/module/x/gravity/keeper/keeper_valset.go#L206) to the power normalization in the Gravity module side.\n\n**[Albert Chon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-cudos-findings/issues/123#issuecomment-1128642000):**\n > Agreed with @V-Staykov - this would only fail if 2/3+ of the validator stake weight were controlled by malicious validators, at which point all bets are off.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-cudos-contest",
  "Code": [
    {
      "filename": "solidity/contracts/Gravity.sol",
      "content": "pragma solidity ^0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./CosmosToken.sol\";\nimport \"./CudosAccessControls.sol\";\n\npragma experimental ABIEncoderV2;\n\n// This is being used purely to avoid stack too deep errors\nstruct LogicCallArgs {\n\t// Transfers out to the logic contract\n\tuint256[] transferAmounts;\n\taddress[] transferTokenContracts;\n\t// The fees (transferred to msg.sender)\n\tuint256[] feeAmounts;\n\taddress[] feeTokenContracts;\n\t// The arbitrary logic call\n\taddress logicContractAddress;\n\tbytes payload;\n\t// Invalidation metadata\n\tuint256 timeOut;\n\tbytes32 invalidationId;\n\tuint256 invalidationNonce;\n}\n\n// This is used purely to avoid stack too deep errors\n// represents everything about a given validator set\nstruct ValsetArgs {\n\t// the validators in this set, represented by an Ethereum address\n\taddress[] validators;\n\t// the powers of the given validators in the same order as above\n\tuint256[] powers;\n\t// the nonce of this validator set\n\tuint256 valsetNonce;\n\t// the reward amount denominated in the below reward token, can be\n\t// set to zero\n\tuint256 rewardAmount;\n\t// the reward token, should be set to the zero address if not being used\n\taddress rewardToken;\n}\n\ncontract Gravity is ReentrancyGuard {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\n\t// These are updated often\n\tbytes32 public state_lastValsetCheckpoint;\n\tmapping(address => uint256) public state_lastBatchNonces;\n\tmapping(bytes32 => uint256) public state_invalidationMapping;\n\tuint256 public state_lastValsetNonce = 0;\n\t// event nonce zero is reserved by the Cosmos module as a special\n\t// value indicating that no events have yet been submitted\n\tuint256 public state_lastEventNonce = 1;\n\n\t// These are set once at initialization\n\tbytes32 public state_gravityId;\n\tuint256 public state_powerThreshold;\n\n\tCudosAccessControls public cudosAccessControls;\n\n\tmapping(address => bool) public whitelisted;\n\n\t// TransactionBatchExecutedEvent and SendToCosmosEvent both include the field _eventNonce.\n\t// This is incremented every time one of these events is emitted. It is checked by the\n\t// Cosmos module to ensure that all events are received in order, and that none are lost.\n\t//\n\t// ValsetUpdatedEvent does not include the field _eventNonce because it is never submitted to the Cosmos\n\t// module. It is purely for the use of relayers to allow them to successfully submit batches.\n\tevent TransactionBatchExecutedEvent(\n\t\tuint256 indexed _batchNonce,\n\t\taddress indexed _token,\n\t\tuint256 _eventNonce\n\t);\n\tevent SendToCosmosEvent(\n\t\taddress indexed _tokenContract,\n\t\taddress indexed _sender,\n\t\tbytes32 indexed _destination,\n\t\tuint256 _amount,\n\t\tuint256 _eventNonce\n\t);\n\tevent ERC20DeployedEvent(\n\t\t// FYI: Can't index on a string without doing a bunch of weird stuff\n\t\tstring _cosmosDenom,\n\t\taddress indexed _tokenContract,\n\t\tstring _name,\n\t\tstring _symbol,\n\t\tuint8 _decimals,\n\t\tuint256 _eventNonce\n\t);\n\tevent ValsetUpdatedEvent(\n\t\tuint256 indexed _newValsetNonce,\n\t\tuint256 _eventNonce,\n\t\tuint256 _rewardAmount,\n\t\taddress _rewardToken,\n\t\taddress[] _validators,\n\t\tuint256[] _powers\n\t);\n\tevent LogicCallEvent(\n\t\tbytes32 _invalidationId,\n\t\tuint256 _invalidationNonce,\n\t\tbytes _returnData,\n\t\tuint256 _eventNonce\n\t);\n\n\tevent WhitelistedStatusModified(\n\t\taddress _sender,\n\t\taddress[] _users,\n\t\tbool _isWhitelisted\n\t);\n\n\n\tmodifier onlyWhitelisted() {\n\t\t require(\n            whitelisted[msg.sender] || cudosAccessControls.hasAdminRole(msg.sender) ,\n            \"The caller is not whitelisted for this operation\"\n        );\n\t\t_;\n\t}\n\n\tfunction manageWhitelist(\n\t\taddress[] memory _users,\n\t\tbool _isWhitelisted\n\t\t) public onlyWhitelisted {\n\t\t for (uint256 i = 0; i < _users.length; i++) {\n            require(\n                _users[i] != address(0),\n                \"User is the zero address\"\n            );\n            whitelisted[_users[i]] = _isWhitelisted;\n        }\n        emit WhitelistedStatusModified(msg.sender, _users, _isWhitelisted);\n\t}\n\n\t// TEST FIXTURES\n\t// These are here to make it easier to measure gas usage. They should be removed before production\n\tfunction testMakeCheckpoint(ValsetArgs memory _valsetArgs, bytes32 _gravityId) public pure {\n\t\tmakeCheckpoint(_valsetArgs, _gravityId);\n\t}\n\n\tfunction testCheckValidatorSignatures(\n\t\taddress[] memory _currentValidators,\n\t\tuint256[] memory _currentPowers,\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\tbytes32 _theHash,\n\t\tuint256 _powerThreshold\n\t) public pure {\n\t\tcheckValidatorSignatures(\n\t\t\t_currentValidators,\n\t\t\t_currentPowers,\n\t\t\t_v,\n\t\t\t_r,\n\t\t\t_s,\n\t\t\t_theHash,\n\t\t\t_powerThreshold\n\t\t);\n\t}\n\n\t// END TEST FIXTURES\n\n\tfunction lastBatchNonce(address _erc20Address) public view returns (uint256) {\n\t\treturn state_lastBatchNonces[_erc20Address];\n\t}\n\n\tfunction lastLogicCallNonce(bytes32 _invalidation_id) public view returns (uint256) {\n\t\treturn state_invalidationMapping[_invalidation_id];\n\t}\n\n\t// Utility function to verify geth style signatures\n\tfunction verifySig(\n\t\taddress _signer,\n\t\tbytes32 _theHash,\n\t\tuint8 _v,\n\t\tbytes32 _r,\n\t\tbytes32 _s\n\t) private pure returns (bool) {\n\t\tbytes32 messageDigest = keccak256(\n\t\t\tabi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _theHash)\n\t\t);\n\t\treturn _signer == ecrecover(messageDigest, _v, _r, _s);\n\t}\n\n\t// Make a new checkpoint from the supplied validator set\n\t// A checkpoint is a hash of all relevant information about the valset. This is stored by the contract,\n\t// instead of storing the information directly. This saves on storage and gas.\n\t// The format of the checkpoint is:\n\t// h(gravityId, \"checkpoint\", valsetNonce, validators[], powers[])\n\t// Where h is the keccak256 hash function.\n\t// The validator powers must be decreasing or equal. This is important for checking the signatures on the\n\t// next valset, since it allows the caller to stop verifying signatures once a quorum of signatures have been verified.\n\tfunction makeCheckpoint(ValsetArgs memory _valsetArgs, bytes32 _gravityId)\n\t\tprivate\n\t\tpure\n\t\treturns (bytes32)\n\t{\n\t\t// bytes32 encoding of the string \"checkpoint\"\n\t\tbytes32 methodName = 0x636865636b706f696e7400000000000000000000000000000000000000000000;\n\n\t\tbytes32 checkpoint = keccak256(\n\t\t\tabi.encode(\n\t\t\t\t_gravityId,\n\t\t\t\tmethodName,\n\t\t\t\t_valsetArgs.valsetNonce,\n\t\t\t\t_valsetArgs.validators,\n\t\t\t\t_valsetArgs.powers,\n\t\t\t\t_valsetArgs.rewardAmount,\n\t\t\t\t_valsetArgs.rewardToken\n\t\t\t)\n\t\t);\n\n\t\treturn checkpoint;\n\t}\n\n\tfunction checkValidatorSignatures(\n\t\t// The current validator set and their powers\n\t\taddress[] memory _currentValidators,\n\t\tuint256[] memory _currentPowers,\n\t\t// The current validator's signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\t// This is what we are checking they have signed\n\t\tbytes32 _theHash,\n\t\tuint256 _powerThreshold\n\t) private pure {\n\t\tuint256 cumulativePower = 0;\n\n\t\tfor (uint256 i = 0; i < _currentValidators.length; i++) {\n\t\t\t// If v is set to 0, this signifies that it was not possible to get a signature from this validator and we skip evaluation\n\t\t\t// (In a valid signature, it is either 27 or 28)\n\t\t\tif (_v[i] != 0) {\n\t\t\t\t// Check that the current validator has signed off on the hash\n\t\t\t\trequire(\n\t\t\t\t\tverifySig(_currentValidators[i], _theHash, _v[i], _r[i], _s[i]),\n\t\t\t\t\t\"Validator signature does not match.\"\n\t\t\t\t);\n\n\t\t\t\t// Sum up cumulative power\n\t\t\t\tcumulativePower = cumulativePower + _currentPowers[i];\n\n\t\t\t\t// Break early to avoid wasting gas\n\t\t\t\tif (cumulativePower > _powerThreshold) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check that there was enough power\n\t\trequire(\n\t\t\tcumulativePower > _powerThreshold,\n\t\t\t\"Submitted validator set signatures do not have enough power.\"\n\t\t);\n\t\t// Success\n\t}\n\n\tfunction isOrchestrator(ValsetArgs memory _newValset, address _sender) private pure returns(bool) {\n\n\t\tfor (uint256 i = 0; i < _newValset.validators.length; i++) {\n\t\t\tif(_newValset.validators[i] == _sender) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// This updates the valset by checking that the validators in the current valset have signed off on the\n\t// new valset. The signatures supplied are the signatures of the current valset over the checkpoint hash\n\t// generated from the new valset.\n\t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\n\t// the new valset.\n\tfunction updateValset(\n\t\t// The new version of the validator set\n\t\tValsetArgs memory _newValset,\n\t\t// The current validators that approve the change\n\t\tValsetArgs memory _currentValset,\n\t\t// These are arrays of the parts of the current validator's signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s\n\t) public nonReentrant {\n\t\t// CHECKS\n\n\t\t// Check that the valset nonce is greater than the old one\n\t\trequire(\n\t\t\t_newValset.valsetNonce > _currentValset.valsetNonce,\n\t\t\t\"New valset nonce must be greater than the current nonce\"\n\t\t);\n\n\t\t// Check that new validators and powers set is well-formed\n\t\trequire(\n\t\t\t_newValset.validators.length == _newValset.powers.length,\n\t\t\t\"Malformed new validator set\"\n\t\t);\n\n\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\trequire(\n\t\t\t_currentValset.validators.length == _currentValset.powers.length &&\n\t\t\t\t_currentValset.validators.length == _v.length &&\n\t\t\t\t_currentValset.validators.length == _r.length &&\n\t\t\t\t_currentValset.validators.length == _s.length,\n\t\t\t\"Malformed current validator set\"\n\t\t);\n\n\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\trequire(\n\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,\n\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t);\n\n\t\trequire(\n\t\t\tisOrchestrator(_currentValset, msg.sender),\n\t\t\t\"The sender of the transaction is not validated orchestrator\"\n\t\t);\n\n\t\t// Check that enough current validators have signed off on the new validator set\n\t\tbytes32 newCheckpoint = makeCheckpoint(_newValset, state_gravityId);\n\n\t\tcheckValidatorSignatures(\n\t\t\t_currentValset.validators,\n\t\t\t_currentValset.powers,\n\t\t\t_v,\n\t\t\t_r,\n\t\t\t_s,\n\t\t\tnewCheckpoint,\n\t\t\tstate_powerThreshold\n\t\t);\n\n\t\t// ACTIONS\n\n\t\t// Stored to be used next time to validate that the valset\n\t\t// supplied by the caller is correct.\n\t\tstate_lastValsetCheckpoint = newCheckpoint;\n\n\t\t// Store new nonce\n\t\tstate_lastValsetNonce = _newValset.valsetNonce;\n\n\t\t// Send submission reward to msg.sender if reward token is a valid value\n\t\tif (_newValset.rewardToken != address(0) && _newValset.rewardAmount != 0) {\n\t\t\tIERC20(_newValset.rewardToken).safeTransfer(msg.sender, _newValset.rewardAmount);\n\t\t}\n\n\t\t// LOGS\n\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit ValsetUpdatedEvent(\n\t\t\t_newValset.valsetNonce,\n\t\t\tstate_lastEventNonce,\n\t\t\t_newValset.rewardAmount,\n\t\t\t_newValset.rewardToken,\n\t\t\t_newValset.validators,\n\t\t\t_newValset.powers\n\t\t);\n\t}\n\n\t// submitBatch processes a batch of Cosmos -> Ethereum transactions by sending the tokens in the transactions\n\t// to the destination addresses. It is approved by the current Cosmos validator set.\n\t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\n\t// the batch.\n\tfunction submitBatch (\n\t\t// The validators that approve the batch\n\t\tValsetArgs memory _currentValset,\n\t\t// These are arrays of the parts of the validators signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\t// The batch of transactions\n\t\tuint256[] memory _amounts,\n\t\taddress[] memory _destinations,\n\t\tuint256[] memory _fees,\n\t\tuint256 _batchNonce,\n\t\taddress _tokenContract,\n\t\t// a block height beyond which this batch is not valid\n\t\t// used to provide a fee-free timeout\n\t\tuint256 _batchTimeout\n\t) public nonReentrant {\n\t\t// CHECKS scoped to reduce stack depth\n\t\t{\n\t\t\t// Check that the batch nonce is higher than the last nonce for this token\n\t\t\trequire(\n\t\t\t\tstate_lastBatchNonces[_tokenContract] < _batchNonce,\n\t\t\t\t\"New batch nonce must be greater than the current nonce\"\n\t\t\t);\n\n\t\t\t// Check that the block height is less than the timeout height\n\t\t\trequire(\n\t\t\t\tblock.number < _batchTimeout,\n\t\t\t\t\"Batch timeout must be greater than the current block height\"\n\t\t\t);\n\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\t\trequire(\n\t\t\t\t_currentValset.validators.length == _currentValset.powers.length &&\n\t\t\t\t\t_currentValset.validators.length == _v.length &&\n\t\t\t\t\t_currentValset.validators.length == _r.length &&\n\t\t\t\t\t_currentValset.validators.length == _s.length,\n\t\t\t\t\"Malformed current validator set\"\n\t\t\t);\n\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\t\trequire(\n\t\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,\n\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t\t);\n\n\t\t\t// Check that the transaction batch is well-formed\n\t\t\trequire(\n\t\t\t\t_amounts.length == _destinations.length && _amounts.length == _fees.length,\n\t\t\t\t\"Malformed batch of transactions\"\n\t\t\t);\n\n\t\t\trequire(\n\t\t\t\tisOrchestrator(_currentValset, msg.sender),\n\t\t\t\t\"The sender of the transaction is not validated orchestrator\"\n\t\t\t);\n\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n\t\t\tcheckValidatorSignatures(\n\t\t\t\t_currentValset.validators,\n\t\t\t\t_currentValset.powers,\n\t\t\t\t_v,\n\t\t\t\t_r,\n\t\t\t\t_s,\n\t\t\t\t// Get hash of the transaction batch and checkpoint\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encode(\n\t\t\t\t\t\tstate_gravityId,\n\t\t\t\t\t\t// bytes32 encoding of \"transactionBatch\"\n\t\t\t\t\t\t0x7472616e73616374696f6e426174636800000000000000000000000000000000,\n\t\t\t\t\t\t_amounts,\n\t\t\t\t\t\t_destinations,\n\t\t\t\t\t\t_fees,\n\t\t\t\t\t\t_batchNonce,\n\t\t\t\t\t\t_tokenContract,\n\t\t\t\t\t\t_batchTimeout\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tstate_powerThreshold\n\t\t\t);\n\n\t\t\t// ACTIONS\n\n\t\t\t// Store batch nonce\n\t\t\tstate_lastBatchNonces[_tokenContract] = _batchNonce;\n\n\t\t\t{\n\t\t\t\t// Send transaction amounts to destinations\n\t\t\t\tuint256 totalFee;\n\t\t\t\tfor (uint256 i = 0; i < _amounts.length; i++) {\n\t\t\t\t\tIERC20(_tokenContract).safeTransfer(_destinations[i], _amounts[i]);\n\t\t\t\t\ttotalFee = totalFee.add(_fees[i]);\n\t\t\t\t}\n\n\t\t\t\t// Send transaction fees to msg.sender\n\t\t\t\tIERC20(_tokenContract).safeTransfer(msg.sender, totalFee);\n\t\t\t}\n\t\t}\n\n\t\t// LOGS scoped to reduce stack depth\n\t\t{\n\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\t\temit TransactionBatchExecutedEvent(_batchNonce, _tokenContract, state_lastEventNonce);\n\t\t}\n\t}\n\n\t// This makes calls to contracts that execute arbitrary logic\n\t// First, it gives the logic contract some tokens\n\t// Then, it gives msg.senders tokens for fees\n\t// Then, it calls an arbitrary function on the logic contract\n\t// invalidationId and invalidationNonce are used for replay prevention.\n\t// They can be used to implement a per-token nonce by setting the token\n\t// address as the invalidationId and incrementing the nonce each call.\n\t// They can be used for nonce-free replay prevention by using a different invalidationId\n\t// for each call.\n\tfunction submitLogicCall(\n\t\t// The validators that approve the call\n\t\tValsetArgs memory _currentValset,\n\t\t// These are arrays of the parts of the validators signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\tLogicCallArgs memory _args\n\t) public nonReentrant {\n\t\t// CHECKS scoped to reduce stack depth\n\t\t{\n\t\t\t// Check that the call has not timed out\n\t\t\trequire(block.number < _args.timeOut, \"Timed out\");\n\n\t\t\t// Check that the invalidation nonce is higher than the last nonce for this invalidation Id\n\t\t\trequire(\n\t\t\t\tstate_invalidationMapping[_args.invalidationId] < _args.invalidationNonce,\n\t\t\t\t\"New invalidation nonce must be greater than the current nonce\"\n\t\t\t);\n\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\t\trequire(\n\t\t\t\t_currentValset.validators.length == _currentValset.powers.length &&\n\t\t\t\t\t_currentValset.validators.length == _v.length &&\n\t\t\t\t\t_currentValset.validators.length == _r.length &&\n\t\t\t\t\t_currentValset.validators.length == _s.length,\n\t\t\t\t\"Malformed current validator set\"\n\t\t\t);\n\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\t\trequire(\n\t\t\t\tmakeCheckpoint(_currentValset, state_gravityId) == state_lastValsetCheckpoint,\n\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t\t);\n\n\t\t\t// Check that the token transfer list is well-formed\n\t\t\trequire(\n\t\t\t\t_args.transferAmounts.length == _args.transferTokenContracts.length,\n\t\t\t\t\"Malformed list of token transfers\"\n\t\t\t);\n\n\t\t\t// Check that the fee list is well-formed\n\t\t\trequire(\n\t\t\t\t_args.feeAmounts.length == _args.feeTokenContracts.length,\n\t\t\t\t\"Malformed list of fees\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\tisOrchestrator(_currentValset, msg.sender),\n\t\t\t\t\"The sender of the transaction is not validated orchestrator\"\n\t\t\t);\n\t\t}\n\n\t\tbytes32 argsHash = keccak256(\n\t\t\tabi.encode(\n\t\t\t\tstate_gravityId,\n\t\t\t\t// bytes32 encoding of \"logicCall\"\n\t\t\t\t0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n\t\t\t\t_args.transferAmounts,\n\t\t\t\t_args.transferTokenContracts,\n\t\t\t\t_args.feeAmounts,\n\t\t\t\t_args.feeTokenContracts,\n\t\t\t\t_args.logicContractAddress,\n\t\t\t\t_args.payload,\n\t\t\t\t_args.timeOut,\n\t\t\t\t_args.invalidationId,\n\t\t\t\t_args.invalidationNonce\n\t\t\t)\n\t\t);\n\n\t\t{\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n\t\t\tcheckValidatorSignatures(\n\t\t\t\t_currentValset.validators,\n\t\t\t\t_currentValset.powers,\n\t\t\t\t_v,\n\t\t\t\t_r,\n\t\t\t\t_s,\n\t\t\t\t// Get hash of the transaction batch and checkpoint\n\t\t\t\targsHash,\n\t\t\t\tstate_powerThreshold\n\t\t\t);\n\t\t}\n\n\t\t// ACTIONS\n\n\t\t// Update invaldiation nonce\n\t\tstate_invalidationMapping[_args.invalidationId] = _args.invalidationNonce;\n\n\t\t// Send tokens to the logic contract\n\t\tfor (uint256 i = 0; i < _args.transferAmounts.length; i++) {\n\t\t\tIERC20(_args.transferTokenContracts[i]).safeTransfer(\n\t\t\t\t_args.logicContractAddress,\n\t\t\t\t_args.transferAmounts[i]\n\t\t\t);\n\t\t}\n\n\t\t// Make call to logic contract\n\t\tbytes memory returnData = Address.functionCall(_args.logicContractAddress, _args.payload);\n\n\t\t// Send fees to msg.sender\n\t\tfor (uint256 i = 0; i < _args.feeAmounts.length; i++) {\n\t\t\tIERC20(_args.feeTokenContracts[i]).safeTransfer(msg.sender, _args.feeAmounts[i]);\n\t\t}\n\n\t\t// LOGS scoped to reduce stack depth\n\t\t{\n\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\t\temit LogicCallEvent(\n\t\t\t\t_args.invalidationId,\n\t\t\t\t_args.invalidationNonce,\n\t\t\t\treturnData,\n\t\t\t\tstate_lastEventNonce\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction sendToCosmos(\n\t\taddress _tokenContract,\n\t\tbytes32 _destination,\n\t\tuint256 _amount\n\t) public nonReentrant  {\n\t\tIERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit SendToCosmosEvent(\n\t\t\t_tokenContract,\n\t\t\tmsg.sender,\n\t\t\t_destination,\n\t\t\t_amount,\n\t\t\tstate_lastEventNonce\n\t\t);\n\t}\n\n\tfunction deployERC20(\n\t\tstring memory _cosmosDenom,\n\t\tstring memory _name,\n\t\tstring memory _symbol,\n\t\tuint8 _decimals\n\t) public {\n\t\t// Deploy an ERC20 with entire supply granted to Gravity.sol\n\t\tCosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);\n\n\t\t// Fire an event to let the Cosmos module know\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit ERC20DeployedEvent(\n\t\t\t_cosmosDenom,\n\t\t\taddress(erc20),\n\t\t\t_name,\n\t\t\t_symbol,\n\t\t\t_decimals,\n\t\t\tstate_lastEventNonce\n\t\t);\n\t}\n\n\tfunction withdrawERC20(\n\t\taddress _tokenAddress) \n\t\texternal {\n\t\trequire(cudosAccessControls.hasAdminRole(msg.sender), \"Recipient is not an admin\");\n\t\tuint256 totalBalance = IERC20(_tokenAddress).balanceOf(address(this));\n\t\tIERC20(_tokenAddress).safeTransfer(msg.sender , totalBalance);\n\t}\n\n\tconstructor(\n\t\t// A unique identifier for this gravity instance to use in signatures\n\t\tbytes32 _gravityId,\n\t\t// How much voting power is needed to approve operations\n\t\tuint256 _powerThreshold,\n\t\t// The validator set, not in valset args format since many of it's\n\t\t// arguments would never be used in this case\n\t\taddress[] memory _validators,\n    uint256[] memory _powers,\n\t\tCudosAccessControls _cudosAccessControls\n\t) public {\n\t\t// CHECKS\n\n\t\t// Check that validators, powers, and signatures (v,r,s) set is well-formed\n\t\trequire(_validators.length == _powers.length, \"Malformed current validator set\");\n\t\trequire(address(_cudosAccessControls) != address(0), \"Access control contract address is incorrect\");\n\n\t\t// Check cumulative power to ensure the contract has sufficient power to actually\n\t\t// pass a vote\n\t\tuint256 cumulativePower = 0;\n\t\tfor (uint256 i = 0; i < _powers.length; i++) {\n\t\t\tcumulativePower = cumulativePower + _powers[i];\n\t\t\tif (cumulativePower > _powerThreshold) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequire(\n\t\t\tcumulativePower > _powerThreshold,\n\t\t\t\"Submitted validator set signatures do not have enough power.\"\n\t\t);\n\n\t\tValsetArgs memory _valset;\n\t\t_valset = ValsetArgs(_validators, _powers, 0, 0, address(0));\n\n\t\tbytes32 newCheckpoint = makeCheckpoint(_valset, _gravityId);\n\n\t\t// ACTIONS\n\n\t\tstate_gravityId = _gravityId;\n\t\tstate_powerThreshold = _powerThreshold;\n\t\tstate_lastValsetCheckpoint = newCheckpoint;\n\n\t\tcudosAccessControls = _cudosAccessControls;\n\n\t\t// LOGS\n\n\t\temit ValsetUpdatedEvent(\n\t\t\tstate_lastValsetNonce,\n\t\t\tstate_lastEventNonce,\n\t\t\t0,\n\t\t\taddress(0),\n\t\t\t_validators,\n\t\t\t_powers\n\t\t);\n\t}\n}"
    },
    {
      "filename": "module/x/gravity/keeper/keeper_valset.go",
      "content": "package keeper\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"sort\"\n\t\"strconv\"\n\n\t\"github.com/cosmos/cosmos-sdk/store/prefix\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\n\t\"github.com/althea-net/cosmos-gravity-bridge/module/x/gravity/types\"\n)\n\n/////////////////////////////\n//     VALSET REQUESTS     //\n/////////////////////////////\n\n// SetValsetRequest returns a new instance of the Gravity BridgeValidatorSet\n// by taking a snapshot of the current set\n// i.e. {\"nonce\": 1, \"memebers\": [{\"eth_addr\": \"foo\", \"power\": 11223}]}\nfunc (k Keeper) SetValsetRequest(ctx sdk.Context) *types.Valset {\n\tvalset := k.GetCurrentValset(ctx)\n\tk.StoreValset(ctx, valset)\n\n\t// Store the checkpoint as a legit past valset, this is only for evidence\n\t// based slashing. We are storing the checkpoint that will be signed with\n\t// the validators Etheruem keys so that we know not to slash them if someone\n\t// attempts to submit the signature of this validator set as evidence of bad behavior\n\tcheckpoint := valset.GetCheckpoint(k.GetGravityID(ctx))\n\tk.SetPastEthSignatureCheckpoint(ctx, checkpoint)\n\n\tbridgeAddr := k.GetBridgeContractAddress(ctx)\n\tctx.EventManager().EmitEvent(\n\t\tsdk.NewEvent(\n\t\t\ttypes.EventTypeMultisigUpdateRequest,\n\t\t\tsdk.NewAttribute(sdk.AttributeKeyModule, types.ModuleName),\n\t\t\tsdk.NewAttribute(types.AttributeKeyContract, bridgeAddr.GetAddress()),\n\t\t\tsdk.NewAttribute(types.AttributeKeyBridgeChainID, strconv.Itoa(int(k.GetBridgeChainID(ctx)))),\n\t\t\tsdk.NewAttribute(types.AttributeKeyMultisigID, fmt.Sprint(valset.Nonce)),\n\t\t\tsdk.NewAttribute(types.AttributeKeyNonce, fmt.Sprint(valset.Nonce)),\n\t\t),\n\t)\n\n\treturn valset\n}\n\n// StoreValset is for storing a valiator set at a given height\nfunc (k Keeper) StoreValset(ctx sdk.Context, valset *types.Valset) {\n\tstore := ctx.KVStore(k.storeKey)\n\tvalset.Height = uint64(ctx.BlockHeight())\n\tstore.Set(types.GetValsetKey(valset.Nonce), k.cdc.MustMarshal(valset))\n\tk.SetLatestValsetNonce(ctx, valset.Nonce)\n}\n\n// StoreValsetUnsafe is for storing a valiator set at a given height\nfunc (k Keeper) StoreValsetUnsafe(ctx sdk.Context, valset *types.Valset) {\n\tstore := ctx.KVStore(k.storeKey)\n\tstore.Set(types.GetValsetKey(valset.Nonce), k.cdc.MustMarshal(valset))\n\tk.SetLatestValsetNonce(ctx, valset.Nonce)\n}\n\n// HasValsetRequest returns true if a valset defined by a nonce exists\nfunc (k Keeper) HasValsetRequest(ctx sdk.Context, nonce uint64) bool {\n\tstore := ctx.KVStore(k.storeKey)\n\treturn store.Has(types.GetValsetKey(nonce))\n}\n\n// DeleteValset deletes the valset at a given nonce from state\nfunc (k Keeper) DeleteValset(ctx sdk.Context, nonce uint64) {\n\tctx.KVStore(k.storeKey).Delete(types.GetValsetKey(nonce))\n}\n\n// GetLatestValsetNonce returns the latest valset nonce\nfunc (k Keeper) GetLatestValsetNonce(ctx sdk.Context) uint64 {\n\tstore := ctx.KVStore(k.storeKey)\n\tbytes := store.Get(types.LatestValsetNonce)\n\n\tif len(bytes) == 0 {\n\t\treturn 0\n\t}\n\treturn types.UInt64FromBytes(bytes)\n}\n\n//  SetLatestValsetNonce sets the latest valset nonce\nfunc (k Keeper) SetLatestValsetNonce(ctx sdk.Context, nonce uint64) {\n\tstore := ctx.KVStore(k.storeKey)\n\tstore.Set(types.LatestValsetNonce, types.UInt64Bytes(nonce))\n}\n\n// GetValset returns a valset by nonce\nfunc (k Keeper) GetValset(ctx sdk.Context, nonce uint64) *types.Valset {\n\tstore := ctx.KVStore(k.storeKey)\n\tbz := store.Get(types.GetValsetKey(nonce))\n\tif bz == nil {\n\t\treturn nil\n\t}\n\tvar valset types.Valset\n\tk.cdc.MustUnmarshal(bz, &valset)\n\treturn &valset\n}\n\n// IterateValsets retruns all valsetRequests\nfunc (k Keeper) IterateValsets(ctx sdk.Context, cb func(key []byte, val *types.Valset) bool) {\n\tprefixStore := prefix.NewStore(ctx.KVStore(k.storeKey), types.ValsetRequestKey)\n\titer := prefixStore.ReverseIterator(nil, nil)\n\tdefer iter.Close()\n\tfor ; iter.Valid(); iter.Next() {\n\t\tvar valset types.Valset\n\t\tk.cdc.MustUnmarshal(iter.Value(), &valset)\n\t\t// cb returns true to stop early\n\t\tif cb(iter.Key(), &valset) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// GetValsets returns all the validator sets in state\nfunc (k Keeper) GetValsets(ctx sdk.Context) (out []*types.Valset) {\n\tk.IterateValsets(ctx, func(_ []byte, val *types.Valset) bool {\n\t\tout = append(out, val)\n\t\treturn false\n\t})\n\tsort.Sort(types.Valsets(out))\n\treturn\n}\n\n// GetLatestValset returns the latest validator set in store. This is different\n// from the CurrrentValset because this one has been saved and is therefore *the* valset\n// for this nonce. GetCurrentValset shows you what could be, if you chose to save it, this function\n// shows you what is the latest valset that was saved.\nfunc (k Keeper) GetLatestValset(ctx sdk.Context) (out *types.Valset) {\n\tlatestValsetNonce := k.GetLatestValsetNonce(ctx)\n\tout = k.GetValset(ctx, latestValsetNonce)\n\treturn\n}\n\n// setLastSlashedValsetNonce sets the latest slashed valset nonce\nfunc (k Keeper) SetLastSlashedValsetNonce(ctx sdk.Context, nonce uint64) {\n\tstore := ctx.KVStore(k.storeKey)\n\tstore.Set(types.LastSlashedValsetNonce, types.UInt64Bytes(nonce))\n}\n\n// GetLastSlashedValsetNonce returns the latest slashed valset nonce\nfunc (k Keeper) GetLastSlashedValsetNonce(ctx sdk.Context) uint64 {\n\tstore := ctx.KVStore(k.storeKey)\n\tbytes := store.Get(types.LastSlashedValsetNonce)\n\n\tif len(bytes) == 0 {\n\t\treturn 0\n\t}\n\treturn types.UInt64FromBytes(bytes)\n}\n\n// SetLastUnBondingBlockHeight sets the last unbonding block height\nfunc (k Keeper) SetLastUnBondingBlockHeight(ctx sdk.Context, unbondingBlockHeight uint64) {\n\tstore := ctx.KVStore(k.storeKey)\n\tstore.Set(types.LastUnBondingBlockHeight, types.UInt64Bytes(unbondingBlockHeight))\n}\n\n// GetLastUnBondingBlockHeight returns the last unbonding block height\nfunc (k Keeper) GetLastUnBondingBlockHeight(ctx sdk.Context) uint64 {\n\tstore := ctx.KVStore(k.storeKey)\n\tbytes := store.Get(types.LastUnBondingBlockHeight)\n\n\tif len(bytes) == 0 {\n\t\treturn 0\n\t}\n\treturn types.UInt64FromBytes(bytes)\n}\n\n// GetUnSlashedValsets returns all the \"ready-to-slash\" unslashed validator sets in state (valsets at least signedValsetsWindow blocks old)\nfunc (k Keeper) GetUnSlashedValsets(ctx sdk.Context, signedValsetsWindow uint64) (out []*types.Valset) {\n\tlastSlashedValsetNonce := k.GetLastSlashedValsetNonce(ctx)\n\tblockHeight := uint64(ctx.BlockHeight())\n\tk.IterateValsetBySlashedValsetNonce(ctx, lastSlashedValsetNonce, func(_ []byte, valset *types.Valset) bool {\n\t\t// Implicitly the unslashed valsets appear after the last slashed valset,\n\t\t// however not all valsets are ready-to-slash since validators have a window\n\t\tif valset.Nonce > lastSlashedValsetNonce && !(blockHeight < valset.Height+signedValsetsWindow) {\n\t\t\tout = append(out, valset)\n\t\t}\n\t\treturn false\n\t})\n\treturn\n}\n\n// IterateValsetBySlashedValsetNonce iterates through all valset by last slashed valset nonce in ASC order\nfunc (k Keeper) IterateValsetBySlashedValsetNonce(ctx sdk.Context, lastSlashedValsetNonce uint64, cb func([]byte, *types.Valset) bool) {\n\tprefixStore := prefix.NewStore(ctx.KVStore(k.storeKey), types.ValsetRequestKey)\n\t// Consider all valsets, including the most recent one\n\tcutoffNonce := k.GetLatestValsetNonce(ctx) + 1\n\titer := prefixStore.Iterator(types.UInt64Bytes(lastSlashedValsetNonce), types.UInt64Bytes(cutoffNonce))\n\tdefer iter.Close()\n\n\tfor ; iter.Valid(); iter.Next() {\n\t\tvar valset types.Valset\n\t\tk.cdc.MustUnmarshal(iter.Value(), &valset)\n\t\t// cb returns true to stop early\n\t\tif cb(iter.Key(), &valset) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// GetCurrentValset gets powers from the store and normalizes them\n// into an integer percentage with a resolution of uint32 Max meaning\n// a given validators 'gravity power' is computed as\n// Cosmos power for that validator / total cosmos power = x / uint32 Max\n// where x is the voting power on the gravity contract. This allows us\n// to only use integer division which produces a known rounding error\n// from truncation equal to the ratio of the validators\n// Cosmos power / total cosmos power ratio, leaving us at uint32 Max - 1\n// total voting power. This is an acceptable rounding error since floating\n// point may cause consensus problems if different floating point unit\n// implementations are involved.\n//\n// 'total cosmos power' has an edge case, if a validator has not set their\n// Ethereum key they are not included in the total. If they where control\n// of the bridge could be lost in the following situation.\n//\n// If we have 100 total power, and 100 total power joins the validator set\n// the new validators hold more than 33% of the bridge power, if we generate\n// and submit a valset and they don't have their eth keys set they can never\n// update the validator set again and the bridge and all its' funds are lost.\n// For this reason we exclude validators with unset eth keys from validator sets\n//\n// The function is intended to return what the valset would look like if you made one now\n// you should call this function, evaluate if you want to save this new valset, and discard\n// it or save\nfunc (k Keeper) GetCurrentValset(ctx sdk.Context) *types.Valset {\n\tvalidators := k.StakingKeeper.GetBondedValidatorsByPower(ctx)\n\tstaticValOperAddrsMap := k.GetStaticValOperAddrsAsMap(ctx)\n\t// allocate enough space for all validators, but len zero, we then append\n\t// so that we have an array with extra capacity but the correct length depending\n\t// on how many validators have keys set.\n\tbridgeValidators := make([]*types.InternalBridgeValidator, 0, len(validators))\n\tvar totalPower uint64\n\t// TODO someone with in depth info on Cosmos staking should determine\n\t// if this is doing what I think it's doing\n\n\t// ctx.Logger().Error(\"Debug Keeper_valset\", \"staticValOperAddrsMap\", staticValOperAddrsMap)\n\tfor _, validator := range validators {\n\t\tval := validator.GetOperator()\n\n\t\t// ctx.Logger().Error(\"Debug Keeper_valset\", \"Check Validator\", validator.OperatorAddress)\n\t\tif _, found := staticValOperAddrsMap[validator.OperatorAddress]; !found {\n\t\t\tcontinue\n\t\t}\n\t\t// ctx.Logger().Error(\"Debug Keeper_valset\", \"Static Validator\", validator.OperatorAddress)\n\n\t\tp := uint64(k.StakingKeeper.GetLastValidatorPower(ctx, val))\n\n\t\tif ethAddr, found := k.GetEthAddressByValidator(ctx, val); found {\n\t\t\tbv := types.BridgeValidator{Power: p, EthereumAddress: ethAddr.GetAddress()}\n\t\t\tibv, err := types.NewInternalBridgeValidator(bv)\n\t\t\tif err != nil {\n\t\t\t\tpanic(sdkerrors.Wrapf(err, \"discovered invalid eth address stored for validator %v\", val))\n\t\t\t}\n\t\t\tbridgeValidators = append(bridgeValidators, ibv)\n\t\t\ttotalPower += p\n\t\t}\n\t}\n\t// normalize power values\n\tfor i := range bridgeValidators {\n\t\tbridgeValidators[i].Power = sdk.NewUint(bridgeValidators[i].Power).MulUint64(math.MaxUint32).QuoUint64(totalPower).Uint64()\n\t}\n\n\t// get the reward from the params store\n\treward := k.GetParams(ctx).ValsetReward\n\tvar rewardToken *types.EthAddress\n\tvar rewardAmount sdk.Int\n\tif !reward.IsValid() || reward.IsZero() {\n\t\t// the case where a validator has 'no reward'. The 'no reward' value is interpreted as having a zero\n\t\t// address for the ERC20 token and a zero value for the reward amount. Since we store a coin with the\n\t\t// params, a coin with a blank denom and/or zero amount is interpreted in this way.\n\t\trewardToken = types.ZeroAddress()\n\t\trewardAmount = sdk.NewIntFromUint64(0)\n\n\t} else {\n\t\trewardToken, rewardAmount = k.RewardToERC20Lookup(ctx, reward)\n\t}\n\n\t// increment the nonce, since this potential future valset should be after the current valset\n\tvalsetNonce :="
    }
  ]
}