{
  "Title": "M-2: Inconsistency in BunniToken Price Calculation",
  "Content": "# Issue M-2: Inconsistency in BunniToken Price Calculation \n\nSource: https://github.com/sherlock-audit/2023-11-olympus-judging/issues/49 \n\n## Found by \nArabadzhiev, KupiaSec, dany.armstrong90, hash, lil.eth, rvierdiiev\n## Summary\nThe deviation check (`_validateReserves()`) from BunniPrice.sol considers both position reserves and uncollected fees when validating the deviation with TWAP, while the final price calculation (`_getTotalValue()`) only accounts for position reserves, excluding uncollected fees. \n\nThe same is applied to BunniSupply.sol where `getProtocolOwnedLiquidityOhm()` validates reserves + fee deviation from TWAP and then returns only Ohm reserves using `lens_.getReserves(key_)` \n\nNote that `BunniSupply.sol#getProtocolOwnedLiquidityReserves()` validates deviation using reserves+fees with TWAP and then return reserves+fees in a good way without discrepancy.\n\nBut this could lead to a misalignment between the deviation check and actual price computation.\n\n## Vulnerability Detail\n\n1. Deviation Check : `_validateReserves` Function:\n```solidity\n### BunniPrice.sol and BunniSupply.sol : \n    function _validateReserves( BunniKey memory key_,BunniLens lens_,uint16 twapMaxDeviationBps_,uint32 twapObservationWindow_) internal view \n        {\n        uint256 reservesTokenRatio = BunniHelper.getReservesRatio(key_, lens_);\n        uint256 twapTokenRatio = UniswapV3OracleHelper.getTWAPRatio(address(key_.pool),twapObservationWindow_);\n\n        // Revert if the relative deviation is greater than the maximum.\n        if (\n            // `isDeviatingWithBpsCheck()` will revert if `deviationBps` is invalid.\n            Deviation.isDeviatingWithBpsCheck(\n                reservesTokenRatio,\n                twapTokenRatio,\n                twapMaxDeviationBps_,\n                TWAP_MAX_DEVIATION_BASE\n            )\n        ) {\n            revert BunniPrice_PriceMismatch(address(key_.pool), twapTokenRatio, reservesTokenRatio);\n        }\n    }\n\n### BunniHelper.sol : \n    function getReservesRatio(BunniKey memory key_, BunniLens lens_) public view returns (uint256) {\n        IUniswapV3Pool pool = key_.pool;\n        uint8 token0Decimals = ERC20(pool.token0()).decimals();\n\n        (uint112 reserve0, uint112 reserve1) = lens_.getReserves(key_);\n        \n        //E compute fees and return values \n        (uint256 fee0, uint256 fee1) = lens_.getUncollectedFees(key_);\n        \n        //E calculates ratio of token1 in token0\n        return (reserve1 + fee1).mulDiv(10 ** token0Decimals, reserve0 + fee0);\n    }\n\n### UniswapV3OracleHelper.sol : \n    //E Returns the ratio of token1 to token0 in token1 decimals based on the TWAP\n        //E used in bophades/src/modules/PRICE/submodules/feeds/BunniPrice.sol, and SPPLY/submodules/BunniSupply.sol\n    function getTWAPRatio(\n        address pool_, \n        uint32 period_ //E period of the TWAP in seconds \n    ) public view returns (uint256) \n    {\n        //E return the time-weighted tick from period_ to now\n        int56 timeWeightedTick = getTimeWeightedTick(pool_, period_);\n\n        IUniswapV3Pool pool = IUniswapV3Pool(pool_);\n        ERC20 token0 = ERC20(pool.token0());\n        ERC20 token1 = ERC20(pool.token1());\n\n        // Quantity of token1 for 1 unit of token0 at the time-weighted tick\n        // Scale: token1 decimals\n        uint256 baseInQuote = OracleLibrary.getQuoteAtTick(\n            int24(timeWeightedTick),\n            uint128(10 ** token0.decimals()), // 1 unit of token0 => baseAmount\n            address(token0),\n            address(token1)\n        );\n        return baseInQuote;\n    }\n```\nYou can see that the deviation check includes uncollected fees in the `reservesTokenRatio`, potentially leading to a higher or more volatile ratio compared to the historical `twapTokenRatio`.\n\n2. Final Price Calculation in `BunniPrice.sol#_getTotalValue()` : \n```solidity\n    function _getTotalValue(\n        BunniToken token_,\n        BunniLens lens_,\n        uint8 outputDecimals_\n    ) internal view returns (uint256) {\n        (address token0, uint256 reserve0, address token1, uint256 reserve1) = _getBunniReserves(\n            token_,\n            lens_,\n            outputDecimals_\n        );\n        uint256 outputScale = 10 ** outputDecimals_;\n\n        // Determine the value of each reserve token in USD\n        uint256 totalValue;\n        totalValue += _PRICE().getPrice(token0).mulDiv(reserve0, outputScale);\n        totalValue += _PRICE().getPrice(token1).mulDiv(reserve1, outputScale);\n\n        return totalValue;\n    }\n```\nYou can see that this function (`_getTotalValue()`) excludes uncollected fees in the final valuation, potentially overestimating the total value within deviation check process, meaning the check could pass in certain conditions whereas it could have not pass if fees where not accounted on the deviation check.\nMoreover the below formula used : \n\n$$\nprice_{LP} = {reserve_0 \\times price_0 + reserve_1 \\times price_1}\n$$\n\nwhere $reserve_i$ is token $i$ reserve amount, $price_i$ is the price of token $i$ \n\nIn short, it is calculated by getting all underlying balances, multiplying those by their market prices\n\nHowever, this approach of directly computing the price of LP tokens via spot reserves is well-known to be vulnerable to manipulation, even if TWAP Deviation is checked, the above summary proved that this method is not 100% bullet proof as there are discrepancy on what is mesured.\nTaken into the fact that the process to check deviation is not that good plus the fact that methodology used to compute price is bad, the impact of this is high\n\n4. The same can be found in BunnySupply.sol `getProtocolOwnedLiquidityReserves()` : \n```solidity\n    function getProtocolOwnedLiquidityReserves()\n        external\n        view\n        override\n        returns (SPPLYv1.Reserves[] memory)\n    {\n        // Iterate through tokens and total up the reserves of each pool\n        uint256 len = bunniTokens.length;\n        SPPLYv1.Reserves[] memory reserves = new SPPLYv1.Reserves[](len);\n        for (uint256 i; i < len; ) {\n            TokenData storage tokenData = bunniTokens[i];\n            BunniToken token = tokenData.token;\n            BunniLens lens = tokenData.lens;\n            BunniKey memory key = _getBunniKey(token);\n            (\n                address token0,\n                address token1,\n                uint256 reserve0,\n                uint256 reserve1\n            ) = _getReservesWithFees(key, lens);\n\n            // Validate reserves\n            _validateReserves(\n                key,\n                lens,\n                tokenData.twapMaxDeviationBps,\n                tokenData.twapObservationWindow\n            );\n\n            address[] memory underlyingTokens = new address[](2);\n            underlyingTokens[0] = token0;\n            underlyingTokens[1] = token1;\n            uint256[] memory underlyingReserves = new uint256[](2);\n            underlyingReserves[0] = reserve0;\n            underlyingReserves[1] = reserve1;\n\n            reserves[i] = SPPLYv1.Reserves({\n                source: address(token),\n                tokens: underlyingTokens,\n                balances: underlyingReserves\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return reserves;\n    }\n```\nWhere returned value does not account for uncollected fees whereas deviation check was accounting for it\n\n## Impact\n\n`_getTotalValue()` from BunniPrice.sol and `getProtocolOwnedLiquidityReserves()` from BunniSupply.sol have both ratio computation that includes uncollected fees to compare with TWAP ratio, potentially overestimating the total value compared to what these functions are aim to, which is returning only the reserves or LP Prices by only taking into account the reserves of the pool.\nMeaning the check could pass in certain conditions where fees are included in the ratio computation and the deviation check process whereas the deviation check should not have pass without the fees accounted.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-11-olympus/blob/main/bophades/src/modules/SPPLY/submodules/BunniSupply.sol#L212-L260\nhttps://github.com/sherlock-audit/2023-11-olympus/blob/main/bophades/src/modules/PRICE/submodules/feeds/BunniPrice.sol#L110\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAlign the methodology used in both the deviation check and the final price computation. This could involve either including the uncollected fees in both calculations or excluding them in both.\n\nIt's ok for BunniSupply as there are 2 functions handling both reserves and reserves+fees but change deviation check process on the second one to include only reserves when checking deviation twap ratio\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**nirohgo** commented:\n> True observation but the effect on deviation is miniscule and no viable scenario has been shown that leads to a loss of material amounts.\n\n\n\n**0xJem**\n\nAccurate that uncollected fees are excluded from the TWAP check but included in the reserves check, which could lead to inconsistencies. This has been made consistent now.\n\n> this approach of directly computing the price of LP tokens via spot reserves is well-known to be vulnerable to manipulation\n\nWe are aware, hence the reserves & TWAP check, plus re-entrancy check.\n\n**0xrusowsky**\n\nhttps://github.com/OlympusDAO/bophades/pull/244\nhttps://github.com/OlympusDAO/bophades/pull/246\n\n**IAm0x52**\n\nFix looks good. Fees are now included in determining bunni token price. Fees are now not considered in BunniHelper#getFullRangeBunniKey\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/128",
  "Code": [
    {
      "filename": "bophades/src/modules/SPPLY/submodules/BunniSupply.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\n// Bophades modules\nimport \"modules/SPPLY/SPPLY.v1.sol\";\n\n// Bunni contracts\nimport {BunniLens} from \"src/external/bunni/BunniLens.sol\";\nimport {BunniToken} from \"src/external/bunni/BunniToken.sol\";\nimport {BunniKey} from \"src/external/bunni/base/Structs.sol\";\nimport {IBunniHub} from \"src/external/bunni/interfaces/IBunniHub.sol\";\n\n// Standard libraries\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// Uniswap V3\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {OracleLibrary} from \"@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol\";\n\n// Libraries\nimport {FullMath} from \"libraries/FullMath.sol\";\nimport {Deviation} from \"libraries/Deviation.sol\";\nimport {UniswapV3OracleHelper} from \"libraries/UniswapV3/Oracle.sol\";\nimport {BunniHelper} from \"libraries/UniswapV3/BunniHelper.sol\";\n\n/// @title      BunniSupply\n/// @author     0xJem\n/// @notice     A SPPLY submodule that provides data on OHM deployed into Uniswap V3 pools that\n/// @notice     are managed by the BunniManager policy and its associated BunniHub.\ncontract BunniSupply is SupplySubmodule {\n    using FullMath for uint256;\n\n    // ========== ERRORS ========== //\n\n    /// @notice             The specified token is not a valid BunniToken\n    ///\n    /// @param token_       The address of the token\n    error BunniSupply_Params_InvalidBunniToken(address token_);\n\n    /// @notice             The specified lens is not a valid BunniLens\n    ///\n    /// @param lens_        The address of the lens\n    error BunniSupply_Params_InvalidBunniLens(address lens_);\n\n    /// @notice             The token and lens do not have the same BunniHub address\n    ///\n    /// @param tokenHub_    The BunniHub address of the token\n    /// @param lensHub_     The BunniHub address of the lens\n    error BunniSupply_Params_HubMismatch(address tokenHub_, address lensHub_);\n\n    /// @notice                     The specified maximum deviation from the TWAP is invalid\n    ///\n    /// @param token_               The address of the token\n    /// @param maximumDeviationBps_ The maximum allowed value\n    /// @param actualDeviationBps_  The maximum deviation from the TWAP in basis points\n    error BunniSupply_Params_InvalidTwapMaxDeviationBps(\n        address token_,\n        uint16 maximumDeviationBps_,\n        uint16 actualDeviationBps_\n    );\n\n    /// @notice                             The specified observation window for the TWAP is invalid\n    ///\n    /// @param token_                       The address of the token\n    /// @param minimumObservationWindow_    The minimum value of the observation window\n    /// @param actualObservationWindow_     The actual value of the observation window\n    error BunniSupply_Params_InvalidTwapObservationWindow(\n        address token_,\n        uint56 minimumObservationWindow_,\n        uint56 actualObservationWindow_\n    );\n\n    /// @notice                   The calculated pool price deviates from the TWAP by more than the maximum deviation.\n    ///\n    /// @param pool_              The address of the pool\n    /// @param baseInQuoteTWAP_   The calculated TWAP price in terms of the quote token\n    /// @param baseInQuotePrice_  The calculated current price in terms of the quote token\n    error BunniSupply_PriceMismatch(\n        address pool_,\n        uint256 baseInQuoteTWAP_,\n        uint256 baseInQuotePrice_\n    );\n\n    // ========== EVENTS ========== //\n\n    /// @notice             Emitted when a new BunniToken is added\n    /// @param token_       The address of the BunniToken contract\n    /// @param bunniLens_   The address of the BunniLens contract\n    event BunniTokenAdded(address token_, address bunniLens_);\n\n    /// @notice             Emitted when a BunniToken is removed\n    /// @param token_       The address of the BunniToken contract\n    event BunniTokenRemoved(address token_);\n\n    // ========== DATA STRUCTURES ========== //\n\n    struct TokenData {\n        BunniToken token;\n        BunniLens lens;\n        uint16 twapMaxDeviationBps;\n        uint32 twapObservationWindow;\n    }\n\n    // ========== STATE VARIABLES ========== //\n\n    /// @notice     The BunniTokens that are being monitored\n    TokenData[] public bunniTokens;\n\n    /// @notice     The number of BunniTokens that are being monitored\n    uint256 public bunniTokenCount;\n\n    /// @notice     The address of the OHM token\n    /// @dev        Set at deployment-time\n    address internal immutable ohm;\n\n    uint16 internal constant TWAP_MAX_DEVIATION_BASE = 10_000; // 100%\n\n    // ========== CONSTRUCTOR ========== //\n\n    /// @notice                 Initialize the submodule\n    ///\n    /// @param parent_          The parent module (SPPLY)\n    constructor(Module parent_) Submodule(parent_) {\n        ohm = address(SPPLYv1(address(parent_)).ohm());\n    }\n\n    // ========== SUBMODULE SETUP ========== //\n\n    /// @inheritdoc Submodule\n    function SUBKEYCODE() public pure override returns (SubKeycode) {\n        return toSubKeycode(\"SPPLY.BNI\");\n    }\n\n    /// @inheritdoc Submodule\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        major = 1;\n        minor = 0;\n    }\n\n    /// @inheritdoc Submodule\n    function INIT() external override onlyParent {}\n\n    // ========== DATA FUNCTIONS ========== //\n\n    /// @inheritdoc SupplySubmodule\n    function getSourceCount() external view override returns (uint256) {\n        return bunniTokens.length;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    /// @dev        Not applicable for Uniswap V3 pools managed by BunniHub\n    function getCollateralizedOhm() external pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    /// @dev        Not applicable for Uniswap V3 pools managed by BunniHub\n    function getProtocolOwnedBorrowableOhm() external pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    /// @dev        Returns the total of OHM in all of the registered tokens representing Uniswap V3 pools\n    ///\n    /// @dev        This function accesses the reserves of the registered\n    /// @dev        Uniswap V3 pools, and can be susceptible to re-entrancy attacks.\n    /// @dev        The BunniLens contract used by this Submodule performs a re-entrancy check.\n    ///\n    /// @dev        Additionally, the reserves and TWAP are compared to ensure that the reserves\n    /// @dev        have not been manipulated.\n    function getProtocolOwnedLiquidityOhm() external view override returns (uint256) {\n        // Iterate through tokens and total up the pool OHM reserves as the POL supply\n        uint256 len = bunniTokens.length;\n        uint256 total;\n        for (uint256 i; i < len; ) {\n            TokenData storage tokenData = bunniTokens[i];\n            BunniLens lens = tokenData.lens;\n            BunniKey memory key = _getBunniKey(tokenData.token);\n\n            // Validate reserves\n            _validateReserves(\n                key,\n                lens,\n                tokenData.twapMaxDeviationBps,\n                tokenData.twapObservationWindow\n            );\n\n            total += _getOhmReserves(key, lens);\n            unchecked {\n                ++i;\n            }\n        }\n\n        return total;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    function getProtocolOwnedTreasuryOhm() external pure override returns (uint256) {\n        // POTO is always zero for BunniTokens\n        return 0;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    /// @dev        Returns the total of OHM and non-OHM reserves in the submodule\n    ///\n    /// @dev        This function accesses the reserves of the registered\n    /// @dev        Uniswap V3 pools, and can be susceptible to re-entrancy attacks.\n    /// @dev        The BunniLens contract used by this Submodule performs a re-entrancy check.\n    ///\n    /// @dev        Additionally, the reserves and TWAP are compared to ensure that the reserves\n    /// @dev        have not been manipulated.\n    function getProtocolOwnedLiquidityReserves()\n        external\n        view\n        override\n        returns (SPPLYv1.Reserves[] memory)\n    {\n        // Iterate through tokens and total up the reserves of each pool\n        uint256 len = bunniTokens.length;\n        SPPLYv1.Reserves[] memory reserves = new SPPLYv1.Reserves[](len);\n        for (uint256 i; i < len; ) {\n            TokenData storage tokenData = bunniTokens[i];\n            BunniToken token = tokenData.token;\n            BunniLens lens = tokenData.lens;\n            BunniKey memory key = _getBunniKey(token);\n            (\n                address token0,\n                address token1,\n                uint256 reserve0,\n                uint256 reserve1\n            ) = _getReservesWithFees(key, lens);\n\n            // Validate reserves\n            _validateReserves(\n                key,\n                lens,\n                tokenData.twapMaxDeviationBps,\n                tokenData.twapObservationWindow\n            );\n\n            address[] memory underlyingTokens = new address[](2);\n            underlyingTokens[0] = token0;\n            underlyingTokens[1] = token1;\n            uint256[] memory underlyingReserves = new uint256[](2);\n            underlyingReserves[0] = reserve0;\n            underlyingReserves[1] = reserve1;\n\n            reserves[i] = SPPLYv1.Reserves({\n                source: address(token),\n                tokens: underlyingTokens,\n                balances: underlyingReserves\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return reserves;\n    }\n\n    /// @notice         Determines whether `token_` has been registered\n    ///\n    /// @param token_   The address of the token\n    /// @return         True if the token has been registered, otherwise false\n    function hasBunniToken(address token_) external view returns (bool) {\n        if (token_ == address(0) || !_inTokenArray(token_)) return false;\n\n        return true;\n    }\n\n    // =========== ADMIN FUNCTIONS =========== //\n\n    /// @notice                         Adds a deployed BunniToken address to the list of monitored tokens\n    /// @dev                            Reverts if:\n    /// @dev                            - The address is the zero address\n    /// @dev                            - The address is already managed\n    /// @dev                            - The caller is not the parent module\n    /// @dev                            - `token_` does not adhere to the IBunniToken interface\n    /// @dev                            - `bunniLens_` does not adhere to the IBunniLens interface\n    /// @dev                            - `token_` and `bunniLens_` do not have the same BunniHub address\n    ///\n    /// @param token_                   The address of the BunniToken contract\n    /// @param bunniLens_               The address of the BunniLens contract\n    /// @param twapMaxDeviationBps_     The maximum deviation from the TWAP in basis points\n    /// @param twapObservationWindow_   The TWAP observation window in seconds\n    function addBunniToken(\n        address token_,\n        address bunniLens_,\n        uint16 twapMaxDeviationBps_,\n        uint32 twapObservationWindow_\n    ) external onlyParent {\n        if (token_ == address(0) || _inTokenArray(token_))\n            revert BunniSupply_Params_InvalidBunniToken(token_);\n\n        if (twapMaxDeviationBps_ > TWAP_MAX_DEVIATION_BASE)\n            revert BunniSupply_Params_InvalidTwapMaxDeviationBps(\n                token_,\n                TWAP_MAX_DEVIATION_BASE,\n                twapMaxDeviationBps_\n            );\n\n        if (twapObservationWindow_ < UniswapV3OracleHelper.TWAP_MIN_OBSERVATION_WINDOW)\n            revert BunniSupply_Params_InvalidTwapObservationWindow(\n                token_,\n                UniswapV3OracleHelper.TWAP_MIN_OBSERVATION_WINDOW,\n                twapObservationWindow_\n            );\n\n        if (bunniLens_ == address(0)) revert BunniSupply_Params_InvalidBunniLens(bunniLens_);\n\n        // Validate the token\n        BunniToken token = BunniToken(token_);\n        address tokenHub;\n        try token.hub() returns (IBunniHub tokenHub_) {\n            tokenHub = address(tokenHub_);\n        } catch (bytes memory) {\n            revert BunniSupply_Params_InvalidBunniToken(token_);\n        }\n\n        // Validate the lens\n        BunniLens lens = BunniLens(bunniLens_);\n        address lensHub;\n        try lens.hub() returns (IBunniHub lensHub_) {\n            lensHub = address(lensHub_);\n        } catch (bytes memory) {\n            revert BunniSupply_Params_InvalidBunniLens(bunniLens_);\n        }\n\n        // Check that the hub matches\n        if (tokenHub != lensHub) revert BunniSupply_Params_HubMismatch(tokenHub, lensHub);\n\n        bunniTokens.push(\n            TokenData({\n                token: token,\n                lens: lens,\n                twapMaxDeviationBps: twapMaxDeviationBps_,\n                twapObservationWindow: twapObservationWindow_\n            })\n        );\n        bunniTokenCount++;\n\n        emit BunniTokenAdded(token_, bunniLens_);\n    }\n\n    /// @notice                 Remove a deployed BunniToken address from the list of monitored tokens\n    /// @dev                    Reverts if:\n    /// @dev                    - The address is the zero address\n    /// @dev                    - The address is not managed\n    /// @dev                    - The caller is not the parent module\n    ///\n    /// @param token_           The address of the BunniToken contract\n    function removeBunniToken(address token_) external onlyParent {\n        if (token_ == address(0) || !_inTokenArray(token_))\n            revert BunniSupply_Params_InvalidBunniToken(token_);\n\n        uint256 len = bunniTokens.length;\n        uint256 bunniTokenIndex = type(uint256).max;\n        // Remove the token first\n        for (uint256 i; i < len; ) {\n            address tokenAddress = address(bunniTokens[i].token);\n            if (token_ == tokenAddress) {\n                bunniTokens[i] = bunniTokens[len - 1];\n                bunniTokens.pop();\n                bunniTokenIndex = i;\n                break;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        bunniTokenCount--;\n\n        emit BunniTokenRemoved(token_);\n    }\n\n    // =========== INTERNAL FUNCTIONS =========== //\n\n    /// @notice         Returns the BunniKey for the pool repesented by `token_` and the full-range ticks\n    ///\n    /// @param token_   The address of the BunniToken contract\n    /// @return         The BunniKey for the pool\n    function _getBunniKey(BunniToken token_) internal view returns (BunniKey memory) {\n        return\n            BunniKey({\n                pool: token_.pool(),\n                tickLower: token_.tickLower(),\n                tickUpper: token_.tickUpper()\n            });\n    }\n\n    /// @notice         Returns the OHM reserves for the pool represented by `key_`\n    ///\n    /// @param key_     The BunniKey for the pool\n    /// @param lens_    The BunniLens contract\n    /// @return         The OHM reserves for the pool\n    function _getOhmReserves(\n        BunniKey memory key_,\n        BunniLens lens_\n    ) internal view returns (uint256) {\n        (uint112 reserve0, uint112 reserve1) = lens_.getReserves(key_);\n        if (key_.pool.token0() == ohm) {\n            return reserve0;\n        } else {\n            return reserve1;\n        }\n    }\n\n    /// @notice         Returns the reserves for the pool represented by `key_`\n    /// @dev            Includes uncollected fees\n    ///\n    /// @param key_     The BunniKey for the pool\n    /// @param lens_    The BunniLens contract\n    /// @return         The reserves for the pool in the order of (token0, token1, reserve0, reserv1)\n    function _getReservesWithFees(\n        BunniKey memory key_,\n        BunniLens lens_\n    ) internal view returns (address, address, uint256, uint256) {\n        (uint112 reserve0, uint112 reserve1) = lens_.getReserves(key_);\n        (uint256 fee0, uint256 fee1) = lens_.getUncollectedFees(key_);\n\n        return (key_.pool.token0(), key_.pool.token1(), reserve0 + fee0, reserve1 + fee1);\n    }\n\n    /// @notice         Determines whether `token_` is in the `bunniTokens` array\n    ///\n    /// @param token_   The address of the token\n    /// @return         True if the token is in the array, otherwise false\n    function _inTokenArray(address token_) internal view returns (bool) {\n        uint256 len = bunniTokens.length;\n        for (uint256 i; i < len; ) {\n            address tokenAddress = address(bunniTokens[i].token);\n            if (token_ == tokenAddress) {\n                return true;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return false;\n    }\n\n    /// @notice                         Validates that the reserves of the pool represented by `key_` are within\n    /// @notice                         the maximum deviation from the pool's TWAP.\n    ///\n    /// @param key_                     The BunniKey for the pool\n    /// @param lens_                    The BunniLens contract\n    /// @param twapMaxDeviationBps_     The maximum deviation from the TWAP in basis points\n    /// @param twapObservationWindow_   The TWAP observation window in seconds\n    function _validateReserves(\n        BunniKey memory key_,\n        BunniLens lens_,\n        uint16 twapMaxDeviationBps_,\n        uint32 twapObservationWindow_\n    ) internal view {\n        uint256 reservesTokenRatio = BunniHelper.getReservesRatio(key_, lens_);\n        uint256 twapTokenRatio = UniswapV3OracleHelper.getTWAPRatio(\n            address(key_.pool),\n            twapObservationWindow_\n        );\n\n        // Revert if the relative deviation is greater than the maximum\n        if (\n            // Not necessary to use `isDeviatingWithBpsCheck()` as the checked is already performed in `addBunniToken`\n            Deviation.isDeviating(\n                reservesTokenRatio,\n                twapTokenRatio,\n                twapMaxDeviationBps_,\n                TWAP_MAX_DEVIATION_BASE\n            )\n        ) {\n            revert BunniSupply_PriceMismatch(\n                address(key_.pool),\n                twapTokenRatio,\n                reservesTokenRatio\n            );\n        }\n    }\n}"
    },
    {
      "filename": "bophades/src/modules/PRICE/submodules/feeds/BunniPrice.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\n// Bophades modules\nimport \"modules/PRICE/PRICE.v2.sol\";\n\n// Bunni contracts\nimport {BunniLens} from \"src/external/bunni/BunniLens.sol\";\nimport {BunniToken} from \"src/external/bunni/BunniToken.sol\";\nimport {BunniKey} from \"src/external/bunni/base/Structs.sol\";\nimport {IBunniHub} from \"src/external/bunni/interfaces/IBunniHub.sol\";\n\n// Standard libraries\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n// Libraries\nimport {FullMath} from \"libraries/FullMath.sol\";\nimport {Deviation} from \"libraries/Deviation.sol\";\nimport {UniswapV3OracleHelper} from \"libraries/UniswapV3/Oracle.sol\";\nimport {BunniHelper} from \"libraries/UniswapV3/BunniHelper.sol\";\n\n/// @title      BunniPrice\n/// @author     0xJem\n/// @notice     A PRICE submodule that provides data on OHM deployed into Uniswap V3 pools that\n/// @notice     are managed by the BunniManager policy and its associated BunniHub.\ncontract BunniPrice is PriceSubmodule {\n    using FullMath for uint256;\n\n    // ========== CONSTANTS ========== //\n\n    /// @notice     Struct containing parameters for the submodule\n    struct BunniParams {\n        address bunniLens;\n        uint16 twapMaxDeviationsBps;\n        uint32 twapObservationWindow;\n    }\n\n    // ========== ERRORS ========== //\n\n    /// @notice             `bunniToken_` is not a valid BunniToken\n    /// @param bunniToken_  The invalid token\n    error BunniPrice_Params_InvalidBunniToken(address bunniToken_);\n\n    /// @notice             `bunniLens_` is not a valid BunniLens\n    /// @param bunniLens_   The invalid BunniLens\n    error BunniPrice_Params_InvalidBunniLens(address bunniLens_);\n\n    /// @notice                 The BunniHub does not match between the BunniToken and BunniLens\n    /// @param bunniTokenHub_   The address of the BunniHub configured in the BunniToken\n    /// @param bunniLensHub_    The address of the BunniHub configured in the BunniLens\n    error BunniPrice_Params_HubMismatch(address bunniTokenHub_, address bunniLensHub_);\n\n    /// @notice                   The calculated pool price deviates from the TWAP by more than the maximum deviation.\n    ///\n    /// @param pool_              The address of the pool\n    /// @param baseInQuoteTWAP_   The calculated TWAP price in terms of the quote token\n    /// @param baseInQuotePrice_  The calculated current price in terms of the quote token\n    error BunniPrice_PriceMismatch(\n        address pool_,\n        uint256 baseInQuoteTWAP_,\n        uint256 baseInQuotePrice_\n    );\n\n    // ========== STATE VARIABLES ========== //\n\n    uint16 internal constant TWAP_MAX_DEVIATION_BASE = 10_000; // 100%\n\n    // ========== CONSTRUCTOR ========== //\n\n    constructor(Module parent_) Submodule(parent_) {}\n\n    // ========== SUBMODULE FUNCTIONS =========== //\n\n    /// @inheritdoc     Submodule\n    function SUBKEYCODE() public pure override returns (SubKeycode) {\n        return toSubKeycode(\"PRICE.BNI\");\n    }\n\n    /// @inheritdoc     Submodule\n    function VERSION() public pure override returns (uint8 major, uint8 minor) {\n        major = 1;\n        minor = 0;\n    }\n\n    // ========== TOKEN PRICE FUNCTIONS ========== //\n\n    /// @notice                 Determines the price of `bunniToken_` (representing a Uniswap V3 pool) in USD\n    /// @dev                    This function performs the following:\n    /// @dev                    - Decodes the parameters\n    /// @dev                    - Check that the token is a valid BunniToken\n    /// @dev                    - Check that the lens is a valid BunniLens\n    /// @dev                    - Check that the token and lens have the same BunniHub address\n    /// @dev                    - Fetches the reserves contained in the Uniswap V3 position\n    /// @dev                    - Determines the value of each reserve token in USD\n    ///\n    /// @dev                    This function accesses the reserves of the registered\n    /// @dev                    Uniswap V3 pools, and can be susceptible to re-entrancy attacks.\n    /// @dev                    The BunniLens contract used by this Submodule performs a re-entrancy check.\n    ///\n    /// @dev                    This function reverts if:\n    /// @dev                    - The token is not a valid BunniToken\n    /// @dev                    - The lens (from `params_`) is not a valid BunniLens\n    /// @dev                    - The token and lens do not have the same BunniHub address\n    /// @dev                    - The reserves of the pool deviate from the TWAP by more than the maximum deviation\n    /// @dev                    - Any of the reserve assets are not defined as assets in PRICE\n    ///\n    /// @param bunniToken_      The address of the BunniToken contract\n    /// @param outputDecimals_  The number of decimals to use for the output price\n    /// @param params_          The encoded parameters for the function call\n    function getBunniTokenPrice(\n        address bunniToken_,\n        uint8 outputDecimals_,\n        bytes calldata params_\n    ) external view returns (uint256) {\n        // Decode the parameters\n        BunniParams memory params;\n        {\n            params = abi.decode(params_, (BunniParams));\n            if (params.bunniLens == address(0)) {\n                revert BunniPrice_Params_InvalidBunniLens(params.bunniLens);\n            }\n\n            // Check for invalid bunniToken_\n            if (bunniToken_ == address(0)) {\n                revert BunniPrice_Params_InvalidBunniToken(bunniToken_);\n            }\n        }\n\n        // Validate the token\n        BunniToken token = BunniToken(bunniToken_);\n        BunniLens lens = BunniLens(params.bunniLens);\n        {\n            address tokenHub;\n            try token.hub() returns (IBunniHub tokenHub_) {\n                tokenHub = address(tokenHub_);\n            } catch (bytes memory) {\n                revert BunniPrice_Params_InvalidBunniToken(bunniToken_);\n            }\n\n            // Validate the lens\n            address lensHub;\n            try lens.hub() returns (IBunniHub lensHub_) {\n                lensHub = address(lensHub_);\n            } catch (bytes memory) {\n                revert BunniPrice_Params_InvalidBunniLens(params.bunniLens);\n            }\n\n            // Check that the hub matches\n            if (tokenHub != lensHub) {\n                revert BunniPrice_Params_HubMismatch(tokenHub, lensHub);\n            }\n        }\n\n        // Validate reserves\n        _validateReserves(\n            _getBunniKey(token),\n            lens,\n            params.twapMaxDeviationsBps,\n            params.twapObservationWindow\n        );\n\n        // Fetch the reserves\n        uint256 totalValue = _getTotalValue(token, lens, outputDecimals_);\n\n        return totalValue;\n    }\n\n    // ========== INTERNAL FUNCTIONS ========== //\n\n    /// @notice         Returns the BunniKey for the pool repesented by `token_` and the full-range ticks\n    ///\n    /// @param token_   The address of the BunniToken contract\n    /// @return         The BunniKey for the pool\n    function _getBunniKey(BunniToken token_) internal view returns (BunniKey memory) {\n        return\n            BunniKey({\n                pool: token_.pool(),\n                tickLower: token_.tickLower(),\n                tickUpper: token_.tickUpper()\n            });\n    }\n\n    /// @notice                 Fetches the reserves of a Uniswap V3 position\n    ///\n    /// @param token_           The address of the BunniToken contract\n    /// @param lens_            The address of the BunniLens contract\n    /// @param outputDecimals_  The number of decimals to use for the output price\n    /// @return token0          The address of the first reserve token\n    /// @return reserve0        The amount of the first reserve token (in `outputDecimals_`)\n    /// @return token1          The address of the second reserve token\n    /// @return reserve1        The amount of the second reserve token (in `outputDecimals_`)\n    function _getBunniReserves(\n        BunniToken token_,\n        BunniLens lens_,\n        uint8 outputDecimals_\n    ) internal view returns (address token0, uint256 reserve0, address token1, uint256 reserve1) {\n        BunniKey memory key = _getBunniKey(token_);\n        (uint112 reserve0_, uint112 reserve1_) = lens_.getReserves(key);\n\n        // Get the token addresses\n        token0 = key.pool.token0();\n        token1 = key.pool.token1();\n        uint8 token0Decimals = ERC20(token0).decimals();\n        uint8 token1Decimals = ERC20(token1).decimals();\n        reserve0 = uint256(reserve0_).mulDiv(10 ** outputDecimals_, 10 ** token0Decimals);\n        reserve1 = uint256(reserve1_).mulDiv(10 ** outputDecimals_, 10 ** token1Decimals);\n    }\n\n    /// @notice                 Determines the total value of the Uniswap V3 position represented by `token_`\n    ///\n    /// @param token_           The BunniToken representing the Uniswap V3 position\n    /// @param lens_            The BunniLens to use for determining reserves\n    /// @param outputDecimals_  The decimal scale to use\n    /// @return                 The total value of the position in USD in the scale of `outputDecimals_`\n    function _getTotalValue(\n        BunniToken token_,\n        BunniLens lens_,\n        uint8 outputDecimals_\n    ) internal view returns (uint256) {\n        (address token0, uint256 reserve0, address token1, uint256 reserve1) = _getBunniReserves(\n            token_,\n            lens_,\n            outputDecimals_\n        );\n        uint256 outputScale = 10 ** outputDecimals_;\n\n        // Determine the value of each reserve token in USD\n        uint256 totalValue;\n        totalValue += _PRICE().getPrice(token0).mulDiv(reserve0, outputScale);\n        totalValue += _PRICE().getPrice(token1).mulDiv(reserve1, outputScale);\n\n        return totalValue;\n    }\n\n    /// @notice                         Validates that the reserves of the pool represented by `key_` are within\n    /// @notice                         the maximum deviation from the pool's TWAP.\n    ///\n    /// @param key_                     The BunniKey for the pool\n    /// @param lens_                    The BunniLens contract\n    /// @param twapMaxDeviationBps_     The maximum deviation from the TWAP in basis points\n    /// @param twapObservationWindow_   The TWAP observation window in seconds\n    function _validateReserves(\n        BunniKey memory key_,\n        BunniLens lens_,\n        uint16 twapMaxDeviationBps_,\n        uint32 twapObservationWindow_\n    ) internal view {\n        uint256 reservesTokenRatio = BunniHelper.getReservesRatio(key_, lens_);\n        uint256 twapTokenRatio = UniswapV3OracleHelper.getTWAPRatio(\n            address(key_.pool),\n            twapObservationWindow_\n        );\n\n        // Revert if the relative deviation is greater than the maximum.\n        if (\n            // `isDeviatingWithBpsCheck()` will revert if `deviationBps` is invalid.\n            Deviation.isDeviatingWithBpsCheck(\n                reservesTokenRatio,\n                twapTokenRatio,\n                twapMaxDeviationBps_,\n                TWAP_MAX_DEVIATION_BASE\n            )\n        ) {\n            revert BunniPrice_PriceMismatch(address(key_.pool), twapTokenRatio, reservesTokenRatio);\n        }\n    }\n}"
    }
  ]
}