{
  "Title": "[M-31] Vaults can be griefed to not be able to be used for deposits",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L111\n\n\n# Vulnerability details\n\n## Description\n\nInteraction with SavETHVault and StakingFundsVault require a minimum amount of MIN_STAKING_AMOUNT. In order to be used for staking, there needs to be 24 ETH or 4 ETH for the desired BLS public key in those vaults. The issue is that vaults can be griefed and made impossible to use for depositing by constantly making sure the *remaining* amount to be added to complete the deposit to the maxStakingAmountPerValidator, is under MIN_STAKING_AMOUNT.\n\nIn \\_depositETHForStaking:\n```\nfunction _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {\n    require(_amount >= MIN_STAKING_AMOUNT, \"Min amount not reached\");\n    require(_blsPublicKeyOfKnot.length == 48, \"Invalid BLS public key\");\n    // LP token issued for the KNOT\n    // will be zero for a new KNOT because the mapping doesn't exist\n    LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];\n    if(address(lpToken) != address(0)) {\n        // KNOT and it's LP token is already registered\n        // mint the respective LP tokens for the user\n        // total supply after minting the LP token must not exceed maximum staking amount per validator\n        require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n        // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n        lpToken.mint(msg.sender, _amount);\n        emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);\n    }\n    else {\n\t\n        // check that amount doesn't exceed max staking amount per validator\n        require(_amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n    ...    \n\n```\n\n\nMED - Can grief vaults (SavETHVault, StakingFundsVault) and make them not able to be used for staking by depositing so that left to stake is < MIN_STAKING_AMOUNT. Then it will fail maxStakingAmount check @ _depositEthForStaking\n\n## Impact\n\nVaults can be griefed to not be able to be used for deposits\n\n## Proof of Concept\n\n1. savETHVault has 22 ETH for some validator\n2. Attacker deposits 1.9991 ETH to the savETHVault\n3. vault now has 23.9991 ETH. The remaining to complete to 24 is 0.0009 ETH which is under 0.001 ether, min staking amount\n4. No one can complete the staking\n\nNote that depositers may try to remove their ETH and redeposit it to complete the deposit to 24. However attack may still keep the delta just under MIN_STAKING_AMOUNT.\n\n## Tools Used\n\nManual audit\n\n## Recommended Mitigation Steps\n\nHandle the case where the remaining amount to be completed is smaller than MIN_STAKING_AMOUNT, and allow the deposit in that case.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-lsd-network-stakehouse-contest",
  "Code": [
    {
      "filename": "contracts/liquid-staking/ETHPoolLPFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\n\n/// @dev For pools accepting ETH for validator staking, this contract will manage issuing LPs for deposits\nabstract contract ETHPoolLPFactory is StakehouseAPI {\n\n    /// @notice signalize withdrawing of ETH by depositor\n    event ETHWithdrawnByDepositor(address depositor, uint256 amount);\n\n    /// @notice signalize burning of LP token\n    event LPTokenBurnt(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @notice signalize issuance of new LP token\n    event NewLPTokenIssued(bytes blsPublicKeyOfKnot, address token, address firstDepositor, uint256 amount);\n\n    /// @notice signalize issuance of existing LP token\n    event LPTokenMinted(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @dev Base name and symbol used for deploying new LP tokens per KNOT\n    string internal baseLPTokenName;\n    string internal baseLPTokenSymbol;\n\n    /// @notice count of unique LP tokens issued for ETH deposits\n    uint256 public numberOfLPTokensIssued;\n\n    /// @notice Maximum amount that can be staked per validator in WEI\n    uint256 public maxStakingAmountPerValidator;\n\n    /// @notice Minimum amount that can be staked per validator in WEI\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Factory for the deployment of KNOT<>LP Tokens that can be used to redeem dETH\n    LPTokenFactory public lpTokenFactory;\n\n    /// @notice LP token address deployed for a KNOT's BLS public key\n    mapping(bytes => LPToken) public lpTokenForKnot;\n\n    /// @notice KNOT BLS public key associated with the LP token\n    mapping(LPToken => bytes) public KnotAssociatedWithLPToken;\n\n    /// @notice Allow users to rotate the ETH from many LP to another in the event that a BLS key is never staked\n    /// @param _oldLPTokens Array of old LP tokens to be burnt\n    /// @param _newLPTokens Array of new LP tokens to be minted in exchange of old LP tokens\n    /// @param _amounts Array of amount of tokens to be exchanged\n    function batchRotateLPTokens(\n        LPToken[] calldata _oldLPTokens,\n        LPToken[] calldata _newLPTokens,\n        uint256[] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _oldLPTokens.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n\n        for (uint256 i; i < numOfRotations; ++i) {\n            rotateLPTokens(\n                _oldLPTokens[i],\n                _newLPTokens[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow users to rotate the ETH from one LP token to another in the event that the BLS key is never staked\n    /// @param _oldLPToken Instance of the old LP token (to be burnt)\n    /// @param _newLPToken Instane of the new LP token (to be minted)\n    /// @param _amount Amount of LP tokens to be rotated/converted from old to new\n    function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {\n        require(address(_oldLPToken) != address(0), \"Zero address\");\n        require(address(_newLPToken) != address(0), \"Zero address\");\n        require(_oldLPToken != _newLPToken, \"Incorrect rotation to same token\");\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _oldLPToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(_oldLPToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Liquidity is still fresh\");\n        require(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\");\n\n        bytes memory blsPublicKeyOfPreviousKnot = KnotAssociatedWithLPToken[_oldLPToken];\n        bytes memory blsPublicKeyOfNewKnot = KnotAssociatedWithLPToken[_newLPToken];\n\n        require(blsPublicKeyOfPreviousKnot.length == 48, \"Incorrect BLS public key\");\n        require(blsPublicKeyOfNewKnot.length == 48, \"Incorrect BLS public key\");\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfPreviousKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfNewKnot) ==IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        // burn old tokens and mint new ones\n        _oldLPToken.burn(msg.sender, _amount);\n        emit LPTokenBurnt(blsPublicKeyOfPreviousKnot, address(_oldLPToken), msg.sender, _amount);\n\n        _newLPToken.mint(msg.sender, _amount);\n        emit LPTokenMinted(KnotAssociatedWithLPToken[_newLPToken], address(_newLPToken), msg.sender, _amount);\n    }\n\n    /// @dev Internal business logic for processing staking deposits for single or batch deposits\n    function _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Min amount not reached\");\n        require(_blsPublicKeyOfKnot.length == 48, \"Invalid BLS public key\");\n\n        // LP token issued for the KNOT\n        // will be zero for a new KNOT because the mapping doesn't exist\n        LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];\n        if(address(lpToken) != address(0)) {\n            // KNOT and it's LP token is already registered\n            // mint the respective LP tokens for the user\n\n            // total supply after minting the LP token must not exceed maximum staking amount per validator\n            require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n\n            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n            lpToken.mint(msg.sender, _amount);\n            emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);\n        }\n        else {\n            // check that amount doesn't exceed max staking amount per validator\n            require(_amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n            \n            // mint new LP tokens for the new KNOT\n            // add the KNOT in the mapping\n            string memory tokenNumber = Strings.toString(numberOfLPTokensIssued);\n            string memory tokenName = string(abi.encodePacked(baseLPTokenName, tokenNumber));\n            string memory tokenSymbol = string(abi.encodePacked(baseLPTokenSymbol, tokenNumber));\n\n            // deploy new LP token and optionally enable transfer notifications\n            LPToken newLPToken = _enableTransferHook ?\n                             LPToken(lpTokenFactory.deployLPToken(address(this), address(this), tokenSymbol, tokenName)) :\n                             LPToken(lpTokenFactory.deployLPToken(address(this), address(0), tokenSymbol, tokenName));\n\n            // increase the count of LP tokens\n            numberOfLPTokensIssued++;\n\n            // register the BLS Public Key with the LP token\n            lpTokenForKnot[_blsPublicKeyOfKnot] = newLPToken;\n            KnotAssociatedWithLPToken[newLPToken] = _blsPublicKeyOfKnot;\n\n            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n            newLPToken.mint(msg.sender, _amount);\n            emit NewLPTokenIssued(_blsPublicKeyOfKnot, address(newLPToken), msg.sender, _amount);\n        }\n    }\n}"
    }
  ]
}