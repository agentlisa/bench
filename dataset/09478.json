{
  "Title": "[L-03] Unsafe calls to optional ERC20 functions",
  "Content": "\n`decimals()`, `name()` and `symbol()` are optional parts of the ERC20 specification, so there are tokens that do not implement them. It's not safe to cast arbitrary token addresses in order to call these functions. If `IERC20Metadata` is to be relied on, that should be the variable type of the token variable, rather than it being `address`, so the compiler can verify that types correctly match, rather than this being a runtime failure. See [this](https://github.com/code-423n4/2021-05-yield-findings/issues/32) prior instance of this issue which was marked as Low risk. Do [this](https://github.com/boringcrypto/BoringSolidity/blob/c73ed73afa9273fbce93095ef177513191782254/contracts/libraries/BoringERC20.sol#L49-L55) to resolve the issue.\n\n1.  File: src/interfaces/erc20/IERC20.sol (lines [14-18](https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/interfaces/erc20/IERC20.sol#L14-L18))\n\n```solidity\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n```\n\n2.  File: src/KnightingRound.sol (line [148](https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/KnightingRound.sol#L148))\n\n```solidity\n        tokenInNormalizationValue = 10**tokenIn.decimals();\n```\n\n3.  File: src/StakedCitadel.sol (line [218](https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadel.sol#L218))\n\n```solidity\n                abi.encodePacked(_defaultNamePrefix, namedToken.name())\n```\n\n4.  File: src/StakedCitadel.sol (line [226](https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/StakedCitadel.sol#L226))\n\n```solidity\n                abi.encodePacked(_symbolSymbolPrefix, namedToken.symbol())\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-04-badger-citadel-contest",
  "Code": [
    {
      "filename": "src/interfaces/erc20/IERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >= 0.5.0 <= 0.9.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}"
    },
    {
      "filename": "src/KnightingRound.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./interfaces/badger/IBadgerVipGuestlist.sol\";\nimport \"./lib/GlobalAccessControlManaged.sol\";\n\n/**\n * @title Citadel Knighting Round\n * @notice Sells citadel at a predetermined price to whitelisted buyers. Citadel tokens are not distributed until the finalize event.\n * TODO: Better revert strings\n */\ncontract KnightingRound is GlobalAccessControlManaged, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for ERC20Upgradeable;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant TREASURY_GOVERNANCE_ROLE =\n        keccak256(\"TREASURY_GOVERNANCE_ROLE\");\n\n    bytes32 public constant TECH_OPERATIONS_ROLE =\n        keccak256(\"TECH_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_OPERATIONS_ROLE =\n        keccak256(\"TREASURY_OPERATIONS_ROLE\");\n\n    /// token to give out (CTDL)\n    ERC20Upgradeable public tokenOut;\n    /// token to take in WBTC / bibbtc LP / CVX / bveCVX\n    ERC20Upgradeable public tokenIn;\n    /// time when tokens can be first purchased\n    uint256 public saleStart;\n    /// duration of the token sale, cannot purchase afterwards\n    uint256 public saleDuration;\n    /// address receiving the proceeds of the sale - will be citadel multisig\n    address public saleRecipient;\n    /// whether the sale has been finalized\n    bool public finalized;\n\n    /// tokenIn per tokenOut price\n    /// eg. 1 WBTC (8 decimals) = 40,000 CTDL ==> price = 10^8 / 40,000\n    uint256 public tokenOutPrice;\n\n    /// Amounts bought by accounts\n    mapping(address => uint256) public boughtAmounts;\n    /// Whether an account has claimed tokens\n    /// NOTE: can reset boughtAmounts after a claim to optimize gas\n    ///       but we need to persist boughtAmounts\n    mapping(address => bool) public hasClaimed;\n\n    /// Amount of `tokenIn` taken in\n    uint256 public totalTokenIn;\n    /// Amount of `tokenOut` sold\n    uint256 public totalTokenOutBought;\n    /// Amount of `tokenOut` claimed\n    uint256 public totalTokenOutClaimed;\n\n    /// Max tokenIn that can be taken by the contract (defines the cap for tokenOut sold)\n    uint256 public tokenInLimit;\n\n    uint256 public tokenInNormalizationValue;\n\n    /// Whitelist\n    IBadgerVipGuestlist public guestlist;\n\n    /// Amount vote for each DAO\n    mapping(uint8 => uint256) public daoCommitments;\n    mapping(address => uint8) public daoVotedFor;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event Sale(\n        address indexed buyer,\n        uint8 indexed daoId,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    event Claim(address indexed claimer, uint256 amount);\n    event Finalized();\n\n    event SaleStartUpdated(uint256 saleStart);\n    event SaleDurationUpdated(uint256 saleDuration);\n    event TokenOutPriceUpdated(uint256 tokenOutPrice);\n    event SaleRecipientUpdated(address indexed recipient);\n    event GuestlistUpdated(address indexed guestlist);\n    event TokenInLimitUpdated(uint256 tokenInLimit);\n\n    event Sweep(address indexed token, uint256 amount);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer.\n     * @param _tokenOut The token this contract will return in a trade (citadel)\n     * @param _tokenIn The token this contract will receive in a trade\n     * @param _saleStart The time when tokens can be first purchased\n     * @param _saleDuration The duration of the token sale\n     * @param _tokenOutPrice The tokenOut per tokenIn price\n     * @param _saleRecipient The address receiving the proceeds of the sale - will be citadel multisig\n     * @param _guestlist Address that will manage auction approvals\n     * @param _tokenInLimit The max tokenIn that the contract can take\n     */\n    function initialize(\n        address _globalAccessControl,\n        address _tokenOut,\n        address _tokenIn,\n        uint256 _saleStart,\n        uint256 _saleDuration,\n        uint256 _tokenOutPrice,\n        address _saleRecipient,\n        address _guestlist,\n        uint256 _tokenInLimit\n    ) external initializer {\n        require(\n            _saleStart >= block.timestamp,\n            \"KnightingRound: start date may not be in the past\"\n        );\n        require(\n            _saleDuration > 0,\n            \"KnightingRound: the sale duration must not be zero\"\n        );\n        require(\n            _tokenOutPrice > 0,\n            \"KnightingRound: the price must not be zero\"\n        );\n        require(\n            _saleRecipient != address(0),\n            \"KnightingRound: sale recipient should not be zero\"\n        );\n\n        __GlobalAccessControlManaged_init(_globalAccessControl);\n\n        tokenOut = ERC20Upgradeable(_tokenOut);\n        tokenIn = ERC20Upgradeable(_tokenIn);\n        saleStart = _saleStart;\n        saleDuration = _saleDuration;\n        tokenOutPrice = _tokenOutPrice;\n        saleRecipient = _saleRecipient;\n        guestlist = IBadgerVipGuestlist(_guestlist);\n        tokenInLimit = _tokenInLimit;\n\n        tokenInNormalizationValue = 10**tokenIn.decimals();\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Exchange `_tokenInAmount` of `tokenIn` for `tokenOut`\n     * @param _tokenInAmount Amount of `tokenIn` to give\n     * @param _daoId ID of DAO to vote for\n     * @param _proof Merkle proof for the guestlist. Use `new bytes32[](0)` if there's no guestlist\n     * @return tokenOutAmount_ Amount of `tokenOut` bought\n     */\n    function buy(\n        uint256 _tokenInAmount,\n        uint8 _daoId,\n        bytes32[] calldata _proof\n    ) external gacPausable returns (uint256 tokenOutAmount_) {\n        require(saleStart <= block.timestamp, \"KnightingRound: not started\");\n        require(\n            block.timestamp < saleStart + saleDuration,\n            \"KnightingRound: already ended\"\n        );\n        require(_tokenInAmount > 0, \"_tokenInAmount should be > 0\");\n        require(\n            totalTokenIn + _tokenInAmount <= tokenInLimit,\n            \"total amount exceeded\"\n        );\n\n        if (address(guestlist) != address(0)) {\n            require(guestlist.authorized(msg.sender, _proof), \"not authorized\");\n        }\n\n        uint256 boughtAmountTillNow = boughtAmounts[msg.sender];\n\n        if (boughtAmountTillNow > 0) {\n            require(\n                _daoId == daoVotedFor[msg.sender],\n                \"can't vote for multiple daos\"\n            );\n        } else {\n            daoVotedFor[msg.sender] = _daoId;\n        }\n\n        tokenOutAmount_ = getAmountOut(_tokenInAmount);\n\n        boughtAmounts[msg.sender] = boughtAmountTillNow + tokenOutAmount_;\n        daoCommitments[_daoId] = daoCommitments[_daoId] + tokenOutAmount_;\n\n        totalTokenIn = totalTokenIn + _tokenInAmount;\n        totalTokenOutBought = totalTokenOutBought + tokenOutAmount_;\n\n        tokenIn.safeTransferFrom(msg.sender, saleRecipient, _tokenInAmount);\n\n        emit Sale(msg.sender, _daoId, _tokenInAmount, tokenOutAmount_);\n    }\n\n    /**\n     * @notice Claim bought tokens after sale has been finalized\n     */\n    function claim() external gacPausable returns (uint256 tokenOutAmount_) {\n        require(finalized, \"sale not finalized\");\n        require(!hasClaimed[msg.sender], \"already claimed\");\n\n        tokenOutAmount_ = boughtAmounts[msg.sender];\n\n        require(tokenOutAmount_ > 0, \"nothing to claim\");\n\n        hasClaimed[msg.sender] = true;\n        totalTokenOutClaimed = totalTokenOutClaimed + tokenOutAmount_;\n\n        tokenOut.safeTransfer(msg.sender, tokenOutAmount_);\n\n        emit Claim(msg.sender, tokenOutAmount_);\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Get the amount received when exchanging `tokenIn`\n     * @param _tokenInAmount Amount of `tokenIn` to exchange\n     * @return tokenOutAmount_ Amount of `tokenOut` received\n     */\n    function getAmountOut(uint256 _tokenInAmount)\n        public\n        view\n        returns (uint256 tokenOutAmount_)\n    {\n        tokenOutAmount_ =\n            (_tokenInAmount * tokenOutPrice) /\n            tokenInNormalizationValue;\n    }\n\n    /**\n     * @notice Check how much `tokenIn` can still be taken in\n     * @return limitLeft_ Amount of `tokenIn` that can still be exchanged\n     */\n    function getTokenInLimitLeft() external view returns (uint256 limitLeft_) {\n        if (totalTokenIn < tokenInLimit) {\n            limitLeft_ = tokenInLimit - totalTokenIn;\n        }\n    }\n\n    /**\n     * @notice Check if the sale has ended\n     * @return hasEnded_ True if the sale has ended\n     */\n    function saleEnded() public view returns (bool hasEnded_) {\n        hasEnded_ =\n            (block.timestamp >= saleStart + saleDuration) ||\n            (totalTokenIn >= tokenInLimit);\n    }\n\n    /// ====================================\n    /// ===== Permissioned: governance =====\n    /// ====================================\n\n    /**\n     * @notice Finalize the sale after sale duration. Can only be called by owner\n       @dev Ensure contract has enough `tokenOut` before calling\n     */\n    function finalize() external onlyRole(CONTRACT_GOVERNANCE_ROLE) {\n        require(!finalized, \"KnightingRound: already finalized\");\n        require(saleEnded(), \"KnightingRound: not finished\");\n        require(\n            tokenOut.balanceOf(address(this)) >= totalTokenOutBought,\n            \"KnightingRound: not enough balance\"\n        );\n\n        finalized = true;\n\n        emit Finalized();\n    }\n\n    /**\n     * @notice Update the sale start time. Can only be called by owner\n     * @param _saleStart New start time\n     */\n    function setSaleStart(uint256 _saleStart)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleStart >= block.timestamp,\n            \"KnightingRound: start date may not be in the past\"\n        );\n        require(!finalized, \"KnightingRound: already finalized\");\n\n        saleStart = _saleStart;\n\n        emit SaleStartUpdated(_saleStart);\n    }\n\n    /**\n     * @notice Update sale duration. Can only be called by owner\n     * @param _saleDuration New duration\n     */\n    function setSaleDuration(uint256 _saleDuration)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleDuration > 0,\n            \"KnightingRound: the sale duration must not be zero\"\n        );\n        require(!finalized, \"KnightingRound: already finalized\");\n\n        saleDuration = _saleDuration;\n\n        emit SaleDurationUpdated(_saleDuration);\n    }\n\n    /**\n     * @notice Modify the tokenOut price in. Can only be called by owner\n     * @param _tokenOutPrice New tokenOut price\n     */\n    function setTokenOutPrice(uint256 _tokenOutPrice)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _tokenOutPrice > 0,\n            \"KnightingRound: the price must not be zero\"\n        );\n\n        tokenOutPrice = _tokenOutPrice;\n\n        emit TokenOutPriceUpdated(_tokenOutPrice);\n    }\n\n    /**\n     * @notice Update the `tokenIn` receipient address. Can only be called by owner\n     * @param _saleRecipient New recipient address\n     */\n    function setSaleRecipient(address _saleRecipient)\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n    {\n        require(\n            _saleRecipient != address(0),\n            \"KnightingRound: sale recipient should not be zero\"\n        );\n\n        saleRecipient = _saleRecipient;\n\n        emit SaleRecipientUpdated(_saleRecipient);\n    }\n\n    /// ============================\n    /// ===== Tech ops actions =====\n    /// ============================\n\n    /**\n     * @notice Update the guestlist address. Can only be called by owner\n     * @param _guestlist New guestlist address\n     */\n    function setGuestlist(address _guestlist)\n        external\n        onlyRole(TECH_OPERATIONS_ROLE)\n    {\n        guestlist = IBadgerVipGuestlist(_guestlist);\n\n        emit GuestlistUpdated(_guestlist);\n    }\n\n    /**\n     * @notice Modify the max tokenIn that this contract can take. Can only be called by owner\n     * @param _tokenInLimit New max amountIn\n     */\n    function setTokenInLimit(uint256 _tokenInLimit)\n        external\n        onlyRole(TECH_OPERATIONS_ROLE)\n    {\n        require(!finalized, \"KnightingRound: already finalized\");\n\n        tokenInLimit = _tokenInLimit;\n\n        emit TokenInLimitUpdated(_tokenInLimit);\n    }\n\n    /// ================================\n    /// ===== Treasury Ops actions =====\n    /// ================================\n\n    /**\n     * @notice Transfers out any tokens accidentally sent to the contract. Can only be called by owner\n     * @dev The contract transfers all `tokenIn` directly to `saleRecipient` during a sale so it's safe\n     *      to sweep `tokenIn`. For `tokenOut`, the function only sweeps the extra amount\n     *      (current contract balance - amount left to be claimed)\n     * @param _token The token to sweep\n     */\n    function sweep(address _token) external gacPausable nonReentrant onlyRole(TREASURY_OPERATIONS_ROLE) {\n        uint256 amount = ERC20Upgradeable(_token).balanceOf(address(this));\n\n        if (_token == address(tokenOut)) {\n            uint256 amountLeftToBeClaimed = totalTokenOutBought -\n                totalTokenOutClaimed;\n            amount = amount - amountLeftToBeClaimed;\n        }\n\n        require(amount > 0, \"nothing to sweep\");\n\n        emit Sweep(_token, amount);\n        ERC20Upgradeable(_token).safeTransfer(saleRecipient, amount);\n    }\n}"
    },
    {
      "filename": "src/StakedCitadel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {AddressUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./lib/SettAccessControl.sol\";\n\nimport {IVault} from \"./interfaces/badger/IVault.sol\";\nimport {IVesting} from \"./interfaces/citadel/IVesting.sol\";\nimport {IStrategy} from \"./interfaces/badger/IStrategy.sol\";\nimport {IERC20} from \"./interfaces/erc20/IERC20.sol\";\nimport {IBadgerGuestlist} from \"./interfaces/badger/IBadgerGuestlist.sol\";\n\n/*\n    Source: https://github.com/iearn-finance/yearn-protocol/blob/develop/contracts/vaults/yVault.sol\n    \n    Changelog:\n\n    V1.1\n    * Strategist no longer has special function calling permissions\n    * Version function added to contract\n    * All write functions, with the exception of transfer, are pausable\n    * Keeper or governance can pause\n    * Only governance can unpause\n\n    V1.2\n    * Transfer functions are now pausable along with all other non-permissioned write functions\n    * All permissioned write functions, with the exception of pause() & unpause(), are pausable as well\n\n    V1.3\n    * Add guest list functionality\n    * All deposits can be optionally gated by external guestList approval logic on set guestList contract\n\n    V1.4\n    * Add depositFor() to deposit on the half of other users. That user will then be blockLocked.\n\n    V1.5\n    * Removed Controller\n        - Removed harvest from vault (only on strategy)\n    * Params added to track autocompounded rewards (lifeTimeEarned, lastHarvestedAt, lastHarvestAmount, assetsAtLastHarvest)\n      this would work in sync with autoCompoundRatio to help us track harvests better.\n    * Fees\n        - Strategy would report the autocompounded harvest amount to the vault\n        - Calculation performanceFeeGovernance, performanceFeeStrategist, withdrawalFee, managementFee moved to the vault.\n        - Vault mints shares for performanceFees and managementFee to the respective recipient (treasury, strategist)\n        - withdrawal fees is transferred to the rewards address set\n    * Permission:\n        - Strategist can now set performance, withdrawal and management fees\n        - Governance will determine maxPerformanceFee, maxWithdrawalFee, maxManagementFee that can be set to prevent rug of funds.\n    * Strategy would take the actors from the vault it is connected to\n    * All governance related fees goes to treasury\n*/\n\ncontract StakedCitadel is\n    ERC20Upgradeable,\n    SettAccessControl,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n\n    uint256 constant ONE_ETH = 1e18;\n\n    /// ===== Storage Variables ====\n\n    IERC20Upgradeable public token; // Token used for deposits\n    IBadgerGuestlist public guestList; // guestlist when vault is in experiment/ guarded state\n\n    bool public pausedDeposit; // false by default Allows to only block deposits, use pause for the normal pause state\n\n    address public strategy; // address of the strategy connected to the vault\n    address public guardian; // guardian of vault and strategy\n    address public treasury; // set by governance ... any fees go there\n\n    address public badgerTree; // Address we send tokens too via reportAdditionalTokens\n    address public vesting; // Address of the vesting contract where after withdrawal we send CTDL to vest for 21 days\n\n    /// @dev name and symbol prefixes for lpcomponent token of vault\n    string internal constant _defaultNamePrefix = \"Staked \";\n    string internal constant _symbolSymbolPrefix = \"x\";\n\n    /// Params to track autocompounded rewards\n    uint256 public lifeTimeEarned; // keeps track of total earnings\n    uint256 public lastHarvestedAt; // timestamp of the last harvest\n    uint256 public lastHarvestAmount; // amount harvested during last harvest\n    uint256 public assetsAtLastHarvest; // assets for which the harvest took place.\n\n    mapping(address => uint256) public additionalTokensEarned;\n    mapping(address => uint256) public lastAdditionalTokenAmount;\n\n    /// Fees ///\n    /// @notice all fees will be in bps\n    uint256 public performanceFeeGovernance; // Perf fee sent to `treasury`\n    uint256 public performanceFeeStrategist; // Perf fee sent to `strategist`\n    uint256 public withdrawalFee; // fee issued to `treasury` on withdrawal\n    uint256 public managementFee; // fee issued to `treasury` on report (typically on harvest, but only if strat is autocompounding)\n\n    uint256 public maxPerformanceFee; // maximum allowed performance fees\n    uint256 public maxWithdrawalFee; // maximum allowed withdrawal fees\n    uint256 public maxManagementFee; // maximum allowed management fees\n\n    uint256 public toEarnBps; // NOTE: in BPS, minimum amount of token to deposit into strategy when earn is called\n\n    /// ===== Constants ====\n\n    uint256 public constant MAX_BPS = 10_000;\n    uint256 public constant SECS_PER_YEAR = 31_556_952; // 365.2425 days\n\n    uint256 public constant WITHDRAWAL_FEE_HARD_CAP = 200; // Never higher than 2%\n    uint256 public constant PERFORMANCE_FEE_HARD_CAP = 3_000; // Never higher than 30% // 30% maximum performance fee // We usually do 20, so this is insanely high already\n    uint256 public constant MANAGEMENT_FEE_HARD_CAP = 200; // Never higher than 2%\n\n    /// ===== Events ====\n\n    // Emitted when a token is sent to the badgerTree for emissions\n    event TreeDistribution(\n        address indexed token,\n        uint256 amount,\n        uint256 indexed blockNumber,\n        uint256 timestamp\n    );\n\n    // Emitted during a report, when there has been an increase in pricePerFullShare (ppfs)\n    event Harvested(\n        address indexed token,\n        uint256 amount,\n        uint256 indexed blockNumber,\n        uint256 timestamp\n    );\n\n    event SetTreasury(address indexed newTreasury);\n    event SetStrategy(address indexed newStrategy);\n    event SetToEarnBps(uint256 newEarnToBps);\n    event SetMaxWithdrawalFee(uint256 newMaxWithdrawalFee);\n    event SetMaxPerformanceFee(uint256 newMaxPerformanceFee);\n    event SetMaxManagementFee(uint256 newMaxManagementFee);\n    event SetGuardian(address indexed newGuardian);\n    event SetVesting(address indexed newVesting);\n    event SetGuestList(address indexed newGuestList);\n    event SetWithdrawalFee(uint256 newWithdrawalFee);\n    event SetPerformanceFeeStrategist(uint256 newPerformanceFeeStrategist);\n    event SetPerformanceFeeGovernance(uint256 newPerformanceFeeGovernance);\n    event SetManagementFee(uint256 newManagementFee);\n\n    event PauseDeposits(address indexed pausedBy);\n    event UnpauseDeposits(address indexed pausedBy);\n\n    /// @notice Initializes the Sett. Can only be called once, ideally when the contract is deployed.\n    /// @param _token Address of the token that can be deposited into the sett.\n    /// @param _governance Address authorized as governance.\n    /// @param _keeper Address authorized as keeper.\n    /// @param _guardian Address authorized as guardian.\n    /// @param _treasury Address to distribute governance fees/rewards to.\n    /// @param _strategist Address authorized as strategist.\n    /// @param _badgerTree Address of badgerTree used for emissions.\n    /// @param _name Specify a custom sett name. Leave empty for default value.\n    /// @param _symbol Specify a custom sett symbol. Leave empty for default value.\n    /// @param _feeConfig Values for the 4 different types of fees charges by the sett\n    ///         [performanceFeeGovernance, performanceFeeStrategist, withdrawToVault, managementFee]\n    ///         Each fee should be less than the constant hard-caps defined above.\n    function initialize(\n        address _token,\n        address _governance,\n        address _keeper,\n        address _guardian,\n        address _treasury,\n        address _strategist,\n        address _badgerTree,\n        address _vesting,\n        string memory _name,\n        string memory _symbol,\n        uint256[4] memory _feeConfig\n    ) public initializer whenNotPaused {\n        require(_token != address(0)); // dev: _token address should not be zero\n        require(_governance != address(0)); // dev: _governance address should not be zero\n        require(_keeper != address(0)); // dev: _keeper address should not be zero\n        require(_guardian != address(0)); // dev: _guardian address should not be zero\n        require(_treasury != address(0)); // dev: _treasury address should not be zero\n        require(_strategist != address(0)); // dev: _strategist address should not be zero\n        require(_badgerTree != address(0)); // dev: _badgerTree address should not be zero\n        require(_vesting != address(0)); // dev: _vesting address should not be zero\n\n        // Check for fees being reasonable (see below for interpretation)\n        require(\n            _feeConfig[0] <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeGovernance too high\"\n        );\n        require(\n            _feeConfig[1] <= PERFORMANCE_FEE_HARD_CAP,\n            \"performanceFeeStrategist too high\"\n        );\n        require(\n            _feeConfig[2] <= WITHDRAWAL_FEE_HARD_CAP,\n            \"withdrawalFee too high\"\n        );\n        require(\n            _feeConfig[3] <= MANAGEMENT_FEE_HARD_CAP,\n            \"managementFee too high\"\n        );\n\n        string memory name;\n        string memory symbol;\n\n        // If they are non empty string we'll use the custom names\n        // Else just add the default prefix\n        IERC20 namedToken = IERC20(_token);\n\n        if (keccak256(abi.encodePacked(_name)) != keccak256(\"\")) {\n            name = _name;\n        } else {\n            name = string(\n                abi.encodePacked(_defaultNamePrefix, namedToken.name())\n            );\n        }\n\n        if (keccak256(abi.encodePacked(_symbol)) != keccak256(\"\")) {\n            symbol = _symbol;\n        } else {\n            symbol = string(\n                abi.encodePacked(_symbolSymbolPrefix, namedToken.symbol())\n            );\n        }\n\n        // Initializing the lpcomponent token\n        __ERC20_init(name, symbol);\n        // Initialize the other contracts\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        token = IERC20Upgradeable(_token);\n        governance = _governance;\n        treasury = _treasury;\n        strategist = _strategist;\n        keeper = _keeper;\n        guardian = _guardian;\n        badgerTree = _badgerTree;\n        vesting = _vesting;\n\n        lastHarvestedAt = block.timestamp; // setting initial value to the time when the vault was deployed\n\n        performanceFeeGovernance = _feeConfig[0];\n        performanceFeeStrategist = _feeConfig[1];\n        withdrawalFee = _feeConfig[2];\n        managementFee = _feeConfig[3];\n        maxPerformanceFee = PERFORMANCE_FEE_HARD_CAP; // 30% max performance fee\n        maxWithdrawalFee = WITHDRAWAL_FEE_HARD_CAP; // 2% maximum withdrawal fee\n        maxManagementFee = MANAGEMENT_FEE_HARD_CAP; // 2% maximum management fee\n\n        toEarnBps = 9_500; // initial value of toEarnBps // 95% is invested to the strategy, 5% for cheap withdrawals\n    }\n\n    /// ===== Modifiers ====\n\n    /// @notice Checks whether a call is from guardian or governance.\n    function _onlyAuthorizedPausers() internal view {\n        require(\n            msg.sender == guardian || msg.sender == governance,\n            \"onlyPausers\"\n        );\n    }\n\n    /// @notice Checks whether a call is from the strategy.\n    function _onlyStrategy() internal view {\n        require(msg.sender == strategy, \"onlyStrategy\");\n    }\n\n    /// ===== View Functions =====\n\n    /// @notice Used to track the deployed version of the contract.\n    /// @return Current version of the contract.\n    function version() external pure returns (string memory) {\n        return \"1.5\";\n    }\n\n    /// @notice Gives the price for a single Sett share.\n    /// @dev Sett starts with a price per share of 1.\n    /// @return Value of a single share.\n    function getPricePerFullShare() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return ONE_ETH;\n        }\n        return (balance() * ONE_ETH) / totalSupply();\n    }\n\n    /// @notice Gives the total balance of the underlying token within the sett and strategy system.\n    /// @return Balance of token handled by the sett.\n    function balance() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Defines how much of the Setts' underlying is available for strategy to borrow.\n    /// @return Amount of tokens that the sett can provide to the strategy.\n    function available() public view returns (uint256) {\n        return (token.balanceOf(address(this)) * toEarnBps) / MAX_BPS;\n    }\n\n    /// ===== Public Actions =====\n\n    /// @notice Deposits `_amount` tokens, issuing shares.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    /// @param _amount Quantity of tokens to deposit.\n    function deposit(uint256 _amount) external whenNotPaused {\n        _depositWithAuthorization(_amount, new bytes32[](0));\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares.\n    ///         Checks the guestlist to verify that the calling account is authorized to make a deposit for the specified `_amount`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param _amount Quantity of tokens to deposit.\n    /// @param proof Merkle proof to validate in the guestlist.\n    function deposit(uint256 _amount, bytes32[] memory proof)\n        external\n        whenNotPaused\n    {\n        _depositWithAuthorization(_amount, proof);\n    }\n\n    /// @notice Deposits all tokens, issuing shares.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    function depositAll() external whenNotPaused {\n        _depositWithAuthorization(\n            token.balanceOf(msg.sender),\n            new bytes32[](0)\n        );\n    }\n\n    /// @notice Deposits all tokens, issuing shares.\n    ///         Checks the guestlist to verify that the calling is authorized to make a full deposit.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositForWithAuthorization` for details on guestlist authorization.\n    /// @param proof Merkle proof to validate in the guestlist.\n    function depositAll(bytes32[] memory proof) external whenNotPaused {\n        _depositWithAuthorization(token.balanceOf(msg.sender), proof);\n    }\n\n    /// @notice Deposits `_amount` tokens, issuing shares to `recipient`.\n    ///         Note that deposits are not accepted when the Sett is paused or when `pausedDeposit` is true.\n    /// @dev See `_depositFor` for details on how deposit is implemented.\n    /// @param _recipient"
    }
  ]
}