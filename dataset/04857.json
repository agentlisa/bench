{
  "Title": "[G-25] Use de Morgan's laws to reduce number of negations",
  "Content": "\n**File:** `DiamondProxy.sol`\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/DiamondProxy.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/DiamondProxy.sol#L31)\n```solidity\n31:         require(!diamondStorage.isFrozen || !facet.isFreezable, \"q1\"); // Facet is frozen\n```\n\nAccording to de Morgan's laws: `!A || !B <=> !(A & B)`, which means we can reduce one negation and rewrite above line to:\n\n```\nrequire(!(diamondStorage.isFrozen && facet.isFreezable), \"q1\"); // Facet is frozen\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/chain-deps/DiamondProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Diamond} from \"../libraries/Diamond.sol\";\n\n/// @title Diamond Proxy Contract (EIP-2535)\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract DiamondProxy {\n    constructor(uint256 _chainId, Diamond.DiamondCutData memory _diamondCut) {\n        // Check that the contract is deployed on the expected chain.\n        // Thus, the contract deployed by the same Create2 factory on the different chain will have different addresses!\n        require(_chainId == block.chainid, \"pr\");\n        Diamond.diamondCut(_diamondCut);\n    }\n\n    /// @dev 1. Find the facet for the function that is called.\n    /// @dev 2. Delegate the execution to the found facet via `delegatecall`.\n    fallback() external payable {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n        // Check whether the data contains a \"full\" selector or it is empty.\n        // Required because Diamond proxy finds a facet by function signature,\n        // which is not defined for data length in range [1, 3].\n        require(msg.data.length >= 4 || msg.data.length == 0, \"Ut\");\n        // Get facet from function selector\n        Diamond.SelectorToFacet memory facet = diamondStorage.selectorToFacet[msg.sig];\n        address facetAddress = facet.facetAddress;\n\n        require(facetAddress != address(0), \"F\"); // Proxy has no facet for this selector\n        require(!diamondStorage.isFrozen || !facet.isFreezable, \"q1\"); // Facet is frozen\n\n        assembly {\n            // The pointer to the free memory slot\n            let ptr := mload(0x40)\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\n            calldatacopy(ptr, 0, calldatasize())\n            // Delegatecall method of the implementation contract returns 0 on error\n            let result := delegatecall(gas(), facetAddress, ptr, calldatasize(), 0, 0)\n            // Get the size of the last return data\n            let size := returndatasize()\n            // Copy the size length of bytes from return data at zero position to pointer position\n            returndatacopy(ptr, 0, size)\n            // Depending on the result value\n            switch result\n            case 0 {\n                // End execution and revert state changes\n                revert(ptr, size)\n            }\n            default {\n                // Return data with length of size at pointers position\n                return(ptr, size)\n            }\n        }\n    }\n}"
    }
  ]
}