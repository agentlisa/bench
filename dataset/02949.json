{
  "Title": "Incorrect NPM threshold",
  "Content": "Some operations require an NPM stake that must not exceed [a threshold](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/libraries/ProtoUtilV1.sol#L20), currently set to 10 billion. However, the total NPM supply [cannot exceed 1 billion](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/token/NPM.sol#L10), making the threshold non-functional. The Neptune team indicated the threshold should only be 10 million. Consider updating the constant accordingly.\n\n\n**Update:** *Fixed as of commit `78fafa7314793a3b6b5fe40e1c9129c8f8c4f813` in [pull request #164](https://github.com/neptune-mutual-blue/protocol/pull/164).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/ProtoUtilV1.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"./StoreKeyUtil.sol\";\nimport \"../interfaces/IStore.sol\";\nimport \"../interfaces/IProtocol.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\n\nlibrary ProtoUtilV1 {\n  using StoreKeyUtil for IStore;\n\n  // Magic numbers\n  uint256 public constant MAX_POLICY_DURATION = 3;\n  bytes32 public constant KEY_INTENTIONALLY_EMPTY = 0;\n  bytes32 public constant PRODUCT_KEY_INTENTIONALLY_EMPTY = 0;\n  uint256 public constant MULTIPLIER = 10_000;\n  uint256 public constant MAX_LIQUIDITY = 10_000_000_000;\n  uint256 public constant MAX_PROPOSAL_AMOUNT = 10_000_000_000;\n  uint256 public constant MAX_NPM_STAKE = 10_000_000_000;\n  uint256 public constant NPM_PRECISION = 1 ether;\n  uint256 public constant CXTOKEN_PRECISION = 1 ether;\n  uint256 public constant POD_PRECISION = 1 ether;\n\n  /// @dev Protocol contract namespace\n  bytes32 public constant CNS_CORE = \"cns:core\";\n\n  /// @dev The address of NPM token available in this blockchain\n  bytes32 public constant CNS_NPM = \"cns:core:npm:instance\";\n\n  /// @dev Key prefix for creating a new cover product on chain\n  bytes32 public constant CNS_COVER = \"cns:cover\";\n\n  bytes32 public constant CNS_UNISWAP_V2_ROUTER = \"cns:core:uni:v2:router\";\n  bytes32 public constant CNS_UNISWAP_V2_FACTORY = \"cns:core:uni:v2:factory\";\n  bytes32 public constant CNS_PRICE_DISCOVERY = \"cns:core:price:discovery\";\n  bytes32 public constant CNS_TREASURY = \"cns:core:treasury\";\n  bytes32 public constant CNS_NPM_PRICE_ORACLE = \"cns:core:npm:price:oracle\";\n  bytes32 public constant CNS_COVER_REASSURANCE = \"cns:cover:reassurance\";\n  bytes32 public constant CNS_POOL_BOND = \"cns:pool:bond\";\n  bytes32 public constant CNS_COVER_POLICY = \"cns:cover:policy\";\n  bytes32 public constant CNS_COVER_POLICY_MANAGER = \"cns:cover:policy:manager\";\n  bytes32 public constant CNS_COVER_POLICY_ADMIN = \"cns:cover:policy:admin\";\n  bytes32 public constant CNS_COVER_STAKE = \"cns:cover:stake\";\n  bytes32 public constant CNS_COVER_VAULT = \"cns:cover:vault\";\n  bytes32 public constant CNS_COVER_VAULT_DELEGATE = \"cns:cover:vault:delegate\";\n  bytes32 public constant CNS_COVER_STABLECOIN = \"cns:cover:sc\";\n  bytes32 public constant CNS_COVER_CXTOKEN_FACTORY = \"cns:cover:cxtoken:factory\";\n  bytes32 public constant CNS_COVER_VAULT_FACTORY = \"cns:cover:vault:factory\";\n  bytes32 public constant CNS_BOND_POOL = \"cns:pools:bond\";\n  bytes32 public constant CNS_STAKING_POOL = \"cns:pools:staking\";\n  bytes32 public constant CNS_LIQUIDITY_ENGINE = \"cns:liquidity:engine\";\n  bytes32 public constant CNS_STRATEGY_AAVE = \"cns:strategy:aave\";\n  bytes32 public constant CNS_STRATEGY_COMPOUND = \"cns:strategy:compound\";\n\n  /// @dev Governance contract address\n  bytes32 public constant CNS_GOVERNANCE = \"cns:gov\";\n\n  /// @dev Governance:Resolution contract address\n  bytes32 public constant CNS_GOVERNANCE_RESOLUTION = \"cns:gov:resolution\";\n\n  /// @dev Claims processor contract address\n  bytes32 public constant CNS_CLAIM_PROCESSOR = \"cns:claim:processor\";\n\n  /// @dev The address where `burn tokens` are sent or collected.\n  /// The collection behavior (collection) is required if the protocol\n  /// is deployed on a sidechain or a layer-2 blockchain.\n  /// &nbsp;\\n\n  /// The collected NPM tokens are will be periodically bridged back to Ethereum\n  /// and then burned.\n  bytes32 public constant CNS_BURNER = \"cns:core:burner\";\n\n  /// @dev Namespace for all protocol members.\n  bytes32 public constant NS_MEMBERS = \"ns:members\";\n\n  /// @dev Namespace for protocol contract members.\n  bytes32 public constant NS_CONTRACTS = \"ns:contracts\";\n\n  /// @dev Key prefix for creating a new cover product on chain\n  bytes32 public constant NS_COVER = \"ns:cover\";\n  bytes32 public constant NS_COVER_PRODUCT = \"ns:cover:product\";\n  bytes32 public constant NS_COVER_PRODUCT_EFFICIENCY = \"ns:cover:product:efficiency\";\n\n  bytes32 public constant NS_COVER_CREATION_DATE = \"ns:cover:creation:date\";\n  bytes32 public constant NS_COVER_CREATION_FEE = \"ns:cover:creation:fee\";\n  bytes32 public constant NS_COVER_CREATION_MIN_STAKE = \"ns:cover:creation:min:stake\";\n  bytes32 public constant NS_COVER_REASSURANCE = \"ns:cover:reassurance\";\n  bytes32 public constant NS_COVER_REASSURANCE_PAYOUT = \"ns:cover:reassurance:payout\";\n  bytes32 public constant NS_COVER_REASSURANCE_WEIGHT = \"ns:cover:reassurance:weight\";\n  bytes32 public constant NS_COVER_REASSURANCE_RATE = \"ns:cover:reassurance:rate\";\n  bytes32 public constant NS_COVER_LEVERAGE_FACTOR = \"ns:cover:leverage:factor\";\n  bytes32 public constant NS_COVER_CREATION_FEE_EARNING = \"ns:cover:creation:fee:earning\";\n  bytes32 public constant NS_COVER_INFO = \"ns:cover:info\";\n  bytes32 public constant NS_COVER_OWNER = \"ns:cover:owner\";\n  bytes32 public constant NS_COVER_SUPPORTS_PRODUCTS = \"ns:cover:supports:products\";\n\n  bytes32 public constant NS_VAULT_STRATEGY_OUT = \"ns:vault:strategy:out\";\n  bytes32 public constant NS_VAULT_LENDING_INCOMES = \"ns:vault:lending:incomes\";\n  bytes32 public constant NS_VAULT_LENDING_LOSSES = \"ns:vault:lending:losses\";\n  bytes32 public constant NS_VAULT_DEPOSIT_HEIGHTS = \"ns:vault:deposit:heights\";\n  bytes32 public constant NS_COVER_LIQUIDITY_LENDING_PERIOD = \"ns:cover:liquidity:len:p\";\n  bytes32 public constant NS_COVER_LIQUIDITY_MAX_LENDING_RATIO = \"ns:cover:liquidity:max:lr\";\n  bytes32 public constant NS_COVER_LIQUIDITY_WITHDRAWAL_WINDOW = \"ns:cover:liquidity:ww\";\n  bytes32 public constant NS_COVER_LIQUIDITY_MIN_STAKE = \"ns:cover:liquidity:min:stake\";\n  bytes32 public constant NS_COVER_LIQUIDITY_STAKE = \"ns:cover:liquidity:stake\";\n  bytes32 public constant NS_COVER_LIQUIDITY_COMMITTED = \"ns:cover:liquidity:committed\";\n  bytes32 public constant NS_COVER_STABLECOIN_NAME = \"ns:cover:stablecoin:name\";\n  bytes32 public constant NS_COVER_REQUIRES_WHITELIST = \"ns:cover:requires:whitelist\";\n\n  bytes32 public constant NS_COVER_HAS_FLASH_LOAN = \"ns:cover:has:fl\";\n  bytes32 public constant NS_COVER_LIQUIDITY_FLASH_LOAN_FEE = \"ns:cover:liquidity:fl:fee\";\n  bytes32 public constant NS_COVER_LIQUIDITY_FLASH_LOAN_FEE_PROTOCOL = \"ns:proto:cover:liquidity:fl:fee\";\n\n  bytes32 public constant NS_COVERAGE_LAG = \"ns:coverage:lag\";\n  bytes32 public constant NS_COVER_POLICY_RATE_FLOOR = \"ns:cover:policy:rate:floor\";\n  bytes32 public constant NS_COVER_POLICY_RATE_CEILING = \"ns:cover:policy:rate:ceiling\";\n  bytes32 public constant NS_POLICY_DISABLED = \"ns:policy:disabled\";\n\n  bytes32 public constant NS_COVER_STAKE = \"ns:cover:stake\";\n  bytes32 public constant NS_COVER_STAKE_OWNED = \"ns:cover:stake:owned\";\n  bytes32 public constant NS_COVER_STATUS = \"ns:cover:status\";\n  bytes32 public constant NS_COVER_CXTOKEN = \"ns:cover:cxtoken\";\n  bytes32 public constant NS_VAULT_TOKEN_NAME = \"ns:vault:token:name\";\n  bytes32 public constant NS_VAULT_TOKEN_SYMBOL = \"ns:vault:token:symbol\";\n  bytes32 public constant NS_COVER_CREATOR_WHITELIST = \"ns:cover:creator:whitelist\";\n  bytes32 public constant NS_COVER_USER_WHITELIST = \"ns:cover:user:whitelist\";\n  bytes32 public constant NS_COVER_CLAIM_BLACKLIST = \"ns:cover:claim:blacklist\";\n\n  /// @dev Resolution timestamp = timestamp of first reporting + reporting period\n  bytes32 public constant NS_GOVERNANCE_RESOLUTION_TS = \"ns:gov:resolution:ts\";\n\n  /// @dev The timestamp when a tokenholder withdraws their reporting stake\n  bytes32 public constant NS_GOVERNANCE_UNSTAKEN = \"ns:gov:unstaken\";\n\n  /// @dev The timestamp when a tokenholder withdraws their reporting stake\n  bytes32 public constant NS_GOVERNANCE_UNSTAKE_TS = \"ns:gov:unstake:ts\";\n\n  /// @dev The reward received by the winning camp\n  bytes32 public constant NS_GOVERNANCE_UNSTAKE_REWARD = \"ns:gov:unstake:reward\";\n\n  /// @dev The stakes burned during incident resolution\n  bytes32 public constant NS_GOVERNANCE_UNSTAKE_BURNED = \"ns:gov:unstake:burned\";\n\n  /// @dev The stakes burned during incident resolution\n  bytes32 public constant NS_GOVERNANCE_UNSTAKE_REPORTER_FEE = \"ns:gov:unstake:rep:fee\";\n\n  bytes32 public constant NS_GOVERNANCE_REPORTING_MIN_FIRST_STAKE = \"ns:gov:rep:min:first:stake\";\n\n  /// @dev An approximate date and time when trigger event or cover incident occurred\n  bytes32 public constant NS_GOVERNANCE_REPORTING_INCIDENT_DATE = \"ns:gov:rep:incident:date\";\n\n  /// @dev A period (in solidity timestamp) configurable by cover creators during\n  /// when NPM tokenholders can vote on incident reporting proposals\n  bytes32 public constant NS_GOVERNANCE_REPORTING_PERIOD = \"ns:gov:rep:period\";\n\n  /// @dev Used as key element in a couple of places:\n  /// 1. For uint256 --> Sum total of NPM witnesses who saw incident to have happened\n  /// 2. For address --> The address of the first reporter\n  bytes32 public constant NS_GOVERNANCE_REPORTING_WITNESS_YES = \"ns:gov:rep:witness:yes\";\n\n  /// @dev Used as key to flag if a cover was disputed. Cleared when a cover is finalized.\n  bytes32 public constant NS_GOVERNANCE_REPORTING_HAS_A_DISPUTE = \"ns:gov:rep:has:dispute\";\n\n  /// @dev Used as key element in a couple of places:\n  /// 1. For uint256 --> Sum total of NPM witnesses who disagreed with and disputed an incident reporting\n  /// 2. For address --> The address of the first disputing reporter (disputer / candidate reporter)\n  bytes32 public constant NS_GOVERNANCE_REPORTING_WITNESS_NO = \"ns:gov:rep:witness:no\";\n\n  /// @dev Stakes guaranteed by an individual witness supporting the \"incident happened\" camp\n  bytes32 public constant NS_GOVERNANCE_REPORTING_STAKE_OWNED_YES = \"ns:gov:rep:stake:owned:yes\";\n\n  /// @dev Stakes guaranteed by an individual witness supporting the \"false reporting\" camp\n  bytes32 public constant NS_GOVERNANCE_REPORTING_STAKE_OWNED_NO = \"ns:gov:rep:stake:owned:no\";\n\n  /// @dev The percentage rate (x MULTIPLIER) of amount of reporting/unstake reward to burn.\n  /// @custom:note that the reward comes from the losing camp after resolution is achieved.\n  bytes32 public constant NS_GOVERNANCE_REPORTING_BURN_RATE = \"ns:gov:rep:burn:rate\";\n\n  /// @dev The percentage rate (x MULTIPLIER) of amount of reporting/unstake\n  /// reward to provide to the final reporter.\n  bytes32 public constant NS_GOVERNANCE_REPORTER_COMMISSION = \"ns:gov:reporter:commission\";\n\n  bytes32 public constant NS_CLAIM_PERIOD = \"ns:claim:period\";\n\n  bytes32 public constant NS_CLAIM_PAYOUTS = \"ns:claim:payouts\";\n\n  /// @dev A 24-hour delay after a governance agent \"resolves\" an actively reported cover.\n  bytes32 public constant NS_CLAIM_BEGIN_TS = \"ns:claim:begin:ts\";\n\n  /// @dev Claim expiry date = Claim begin date + claim duration\n  bytes32 public constant NS_CLAIM_EXPIRY_TS = \"ns:claim:expiry:ts\";\n\n  bytes32 public constant NS_RESOLUTION_DEADLINE = \"ns:resolution:deadline\";\n\n  /// @dev Claim expiry date = Claim begin date + claim duration\n  bytes32 public constant NS_RESOLUTION_COOL_DOWN_PERIOD = \"ns:resolution:cdp\";\n\n  /// @dev The percentage rate (x MULTIPLIER) of amount deducted by the platform\n  /// for each successful claims payout\n  bytes32 public constant NS_COVER_PLATFORM_FEE = \"ns:cover:platform:fee\";\n\n  /// @dev The percentage rate (x MULTIPLIER) of amount provided to the first reporter\n  /// upon favorable incident resolution. This amount is a commission of the\n  /// 'ns:claim:platform:fee'\n  bytes32 public constant NS_CLAIM_REPORTER_COMMISSION = \"ns:claim:reporter:commission\";\n\n  bytes32 public constant NS_LAST_LIQUIDITY_STATE_UPDATE = \"ns:last:snl:update\";\n  bytes32 public constant NS_LIQUIDITY_STATE_UPDATE_INTERVAL = \"ns:snl:update:interval\";\n  bytes32 public constant NS_LENDING_STRATEGY_ACTIVE = \"ns:lending:strategy:active\";\n  bytes32 public constant NS_LENDING_STRATEGY_DISABLED = \"ns:lending:strategy:disabled\";\n  bytes32 public constant NS_LENDING_STRATEGY_WITHDRAWAL_START = \"ns:lending:strategy:w:start\";\n  bytes32 public constant NS_ACCRUAL_INVOCATION = \"ns:accrual:invocation\";\n  bytes32 public constant NS_LENDING_STRATEGY_WITHDRAWAL_END = \"ns:lending:strategy:w:end\";\n\n  bytes32 public constant CNAME_PROTOCOL = \"Neptune Mutual Protocol\";\n  bytes32 public constant CNAME_TREASURY = \"Treasury\";\n  bytes32 public constant CNAME_POLICY = \"Policy\";\n  bytes32 public constant CNAME_POLICY_ADMIN = \"Policy Admin\";\n  bytes32 public constant CNAME_POLICY_MANAGER = \"Policy Manager\";\n  bytes32 public constant CNAME_BOND_POOL = \"BondPool\";\n  bytes32 public constant CNAME_STAKING_POOL = \"Staking Pool\";\n  bytes32 public constant CNAME_POD_STAKING_POOL = \"PODStaking Pool\";\n  bytes32 public constant CNAME_CLAIMS_PROCESSOR = \"Claims Processor\";\n  bytes32 public constant CNAME_COVER = \"Cover\";\n  bytes32 public constant CNAME_GOVERNANCE = \"Governance\";\n  bytes32 public constant CNAME_RESOLUTION = \"Resolution\";\n  bytes32 public constant CNAME_VAULT_FACTORY = \"Vault Factory\";\n  bytes32 public constant CNAME_CXTOKEN_FACTORY = \"cxToken Factory\";\n  bytes32 public constant CNAME_COVER_STAKE = \"Cover Stake\";\n  bytes32 public constant CNAME_COVER_REASSURANCE = \"Cover Reassurance\";\n  bytes32 public constant CNAME_LIQUIDITY_VAULT = \"Vault\";\n  bytes32 public constant CNAME_VAULT_DELEGATE = \"Vault Delegate\";\n  bytes32 public constant CNAME_LIQUIDITY_ENGINE = \"Liquidity Engine\";\n  bytes32 public constant CNAME_STRATEGY_AAVE = \"Aave Strategy\";\n  bytes32 public constant CNAME_STRATEGY_COMPOUND = \"Compound Strategy\";\n\n  function getProtocol(IStore s) external view returns (IProtocol) {\n    return IProtocol(getProtocolAddress(s));\n  }\n\n  function getProtocolAddress(IStore s) public view returns (address) {\n    return s.getAddressByKey(CNS_CORE);\n  }\n\n  function getContract(\n    IStore s,\n    bytes32 name,\n    bytes32 key\n  ) public view returns (address) {\n    if (key > 0) {\n      return s.getAddressByKeys(NS_CONTRACTS, name, key);\n    }\n\n    return s.getAddressByKeys(NS_CONTRACTS, name);\n  }\n\n  function isProtocolMember(IStore s, address contractAddress) public view returns (bool) {\n    return s.getBoolByKeys(ProtoUtilV1.NS_MEMBERS, contractAddress);\n  }\n\n  /**\n   * @dev Reverts if the caller is one of the protocol members.\n   */\n  function mustBeProtocolMember(IStore s, address contractAddress) external view {\n    bool isMember = isProtocolMember(s, contractAddress);\n    require(isMember, \"Not a protocol member\");\n  }\n\n  /**\n   * @dev Ensures that the sender matches with the exact contract having the specified name.\n   * @param name Enter the name of the contract\n   * @param sender Enter the `msg.sender` value\n   */\n  function mustBeExactContract(\n    IStore s,\n    bytes32 name,\n    bytes32 key,\n    address sender\n  ) public view {\n    address contractAddress = getContract(s, name, key);\n    require(sender == contractAddress, \"Access denied\");\n  }\n\n  /**\n   * @dev Ensures that the sender matches with the exact contract having the specified name.\n   * @param name Enter the name of the contract\n   */\n  function senderMustBeExactContract(IStore s, bytes32 name) external view {\n    return callerMustBeExactContract(s, name, msg.sender);\n  }\n\n  /**\n   * @dev Ensures that the sender matches with the exact contract having the specified name.\n   * @param name Enter the name of the contract\n   */\n  function callerMustBeExactContract(\n    IStore s,\n    bytes32 name,\n    address caller\n  ) public view {\n    return mustBeExactContract(s, name, ProtoUtilV1.KEY_INTENTIONALLY_EMPTY, caller);\n  }\n\n  function npmToken(IStore s) external view returns (IERC20) {\n    return IERC20(getNpmTokenAddress(s));\n  }\n\n  function getNpmTokenAddress(IStore s) public view returns (address) {\n    address npm = s.getAddressByKey(CNS_NPM);\n    return npm;\n  }\n\n  function getUniswapV2Router(IStore s) external view returns (address) {\n    return s.getAddressByKey(CNS_UNISWAP_V2_ROUTER);\n  }\n\n  function getUniswapV2Factory(IStore s) external view returns (address) {\n    return s.getAddressByKey(CNS_UNISWAP_V2_FACTORY);\n  }\n\n  function getNpmPriceOracle(IStore s) external view returns (address) {\n    return s.getAddressByKey(CNS_NPM_PRICE_ORACLE);\n  }\n\n  function getTreasury(IStore s) external view returns (address) {\n    return s.getAddressByKey(CNS_TREASURY);\n  }\n\n  function getStablecoin(IStore s) public view returns (address) {\n    return s.getAddressByKey(CNS_COVER_STABLECOIN);\n  }\n\n  function getStablecoinPrecision(IStore s) external view returns (uint256) {\n    return 10**IERC20Detailed(getStablecoin(s)).decimals();\n  }\n\n  function getBurnAddress(IStore s) external view returns (address) {\n    return s.getAddressByKey(CNS_BURNER);\n  }\n}"
    }
  ]
}