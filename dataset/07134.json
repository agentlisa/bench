{
  "Title": "[M-08] Buyer on secondary NFT market can lose fund if they buy a NFT that is already used to claim the reward",
  "Content": "# Lines of code\n\nhttps://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L113\n\n\n# Vulnerability details\n\n## Impact\n\nBuyer on secondary NFT market can lose fund if they buy a NFT that is already used to claim the reward\n\n## Proof of Concept\n\nLet us look closely into the Quest.sol#claim function\n\n```solidity\n/// @notice Allows user to claim the rewards entitled to them\n/// @dev User can claim based on the (unclaimed) number of tokens they own of the Quest\nfunction claim() public virtual onlyQuestActive {\n\tif (isPaused) revert QuestPaused();\n\n\tuint[] memory tokens = rabbitHoleReceiptContract.getOwnedTokenIdsOfQuest(questId, msg.sender);\n\n\tif (tokens.length == 0) revert NoTokensToClaim();\n\n\tuint256 redeemableTokenCount = 0;\n\tfor (uint i = 0; i < tokens.length; i++) {\n\t\tif (!isClaimed(tokens[i])) {\n\t\t\tredeemableTokenCount++;\n\t\t}\n\t}\n\n\tif (redeemableTokenCount == 0) revert AlreadyClaimed();\n\n\tuint256 totalRedeemableRewards = _calculateRewards(redeemableTokenCount);\n\t_setClaimed(tokens);\n\t_transferRewards(totalRedeemableRewards);\n\tredeemedTokens += redeemableTokenCount;\n\n\temit Claimed(msg.sender, totalRedeemableRewards);\n}\n```\n\nAfter the NFT is used to claim, the _setClaimed(token) is called to mark the NFT as used to prevent double claiming.\n\n```solidity\n/// @notice Marks token ids as claimed\n/// @param tokenIds_ The token ids to mark as claimed\nfunction _setClaimed(uint256[] memory tokenIds_) private {\n\tfor (uint i = 0; i < tokenIds_.length; i++) {\n\t\tclaimedList[tokenIds_[i]] = true;\n\t}\n}\n```\n\nThe NFT is also tradeable in the secondary marketplace, I woud like to make a reasonable assumption that user wants to buy the NFT because they can use the NFT to claim the reward, which means after the reward is claimed, the NFT lose value.\n\nConsider the case below:\n\n1. User A has 1 NFT, has he can use the NFT to claim 1 ETH reward.\n2. User A place a sell order in opensea and sell the NFT for 0.9 ETH.\n3. User B see the sell order and find it a good trae, he wants to buy the NFT.\n4. User B submit a buy order, User A at the same time submit the claimReward transaction.\n5. User A's transaction executed first, reward goes to User A, then User B transaction executed, NFT ownership goes to User B, but user B find out that the he cannot claim the reward becasue the reward is already claimed by User A.\n\nUser A can intentionally front-run User B's buy transaction by monitoring the mempool\nin polygon using the service\n\nhttps://www.blocknative.com/blog/polygon-mempool\n\nOr it could be just two user submit transaction at the same and User A's claim transaction happens to execute first.\n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nDisable NFT transfer and trade once the NFT is used to claim the reward.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-rabbithole-quest-protocol-contest",
  "Code": [
    {
      "filename": "contracts/Quest.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {IQuest} from './interfaces/IQuest.sol';\nimport {RabbitHoleReceipt} from './RabbitHoleReceipt.sol';\nimport {ECDSA} from '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\n\n/// @title Quest\n/// @author RabbitHole.gg\n/// @notice This contract is the base contract for all Quests. The Erc20Quest and Erc1155Quest contracts inherit from this contract.\ncontract Quest is Ownable, IQuest {\n    RabbitHoleReceipt public immutable rabbitHoleReceiptContract;\n    address public immutable rewardToken;\n    uint256 public immutable endTime;\n    uint256 public immutable startTime;\n    uint256 public immutable totalParticipants;\n    uint256 public immutable rewardAmountInWeiOrTokenId;\n    bool public hasStarted;\n    bool public isPaused;\n    string public questId;\n    uint256 public redeemedTokens;\n\n    mapping(uint256 => bool) private claimedList;\n\n    constructor(\n        address rewardTokenAddress_,\n        uint256 endTime_,\n        uint256 startTime_,\n        uint256 totalParticipants_,\n        uint256 rewardAmountInWeiOrTokenId_,\n        string memory questId_,\n        address receiptContractAddress_\n    ) {\n        if (endTime_ <= block.timestamp) revert EndTimeInPast();\n        if (startTime_ <= block.timestamp) revert StartTimeInPast();\n        if (endTime_ <= startTime_) revert EndTimeLessThanOrEqualToStartTime();\n        endTime = endTime_;\n        startTime = startTime_;\n        rewardToken = rewardTokenAddress_;\n        totalParticipants = totalParticipants_;\n        rewardAmountInWeiOrTokenId = rewardAmountInWeiOrTokenId_;\n        questId = questId_;\n        rabbitHoleReceiptContract = RabbitHoleReceipt(receiptContractAddress_);\n        redeemedTokens = 0;\n    }\n\n    /// @notice Starts the Quest\n    /// @dev Only the owner of the Quest can call this function\n    function start() public virtual onlyOwner {\n        isPaused = false;\n        hasStarted = true;\n    }\n\n    /// @notice Pauses the Quest\n    /// @dev Only the owner of the Quest can call this function. Also requires that the Quest has started (not by date, but by calling the start function)\n    function pause() public onlyOwner onlyStarted {\n        isPaused = true;\n    }\n\n    /// @notice Unpauses the Quest\n    /// @dev Only the owner of the Quest can call this function. Also requires that the Quest has started (not by date, but by calling the start function)\n    function unPause() public onlyOwner onlyStarted {\n        isPaused = false;\n    }\n\n    /// @notice Marks token ids as claimed\n    /// @param tokenIds_ The token ids to mark as claimed\n    function _setClaimed(uint256[] memory tokenIds_) private {\n        for (uint i = 0; i < tokenIds_.length; i++) {\n            claimedList[tokenIds_[i]] = true;\n        }\n    }\n\n    /// @notice Prevents reward withdrawal until the Quest has ended\n    modifier onlyAdminWithdrawAfterEnd() {\n        if (block.timestamp < endTime) revert NoWithdrawDuringClaim();\n        _;\n    }\n\n    /// @notice Checks if the Quest has started at the function level\n    modifier onlyStarted() {\n        if (!hasStarted) revert NotStarted();\n        _;\n    }\n\n    /// @notice Checks if quest has started both at the function level and at the start time\n    modifier onlyQuestActive() {\n        if (!hasStarted) revert NotStarted();\n        if (block.timestamp < startTime) revert ClaimWindowNotStarted();\n        _;\n    }\n\n    /// @notice Allows user to claim the rewards entitled to them\n    /// @dev User can claim based on the (unclaimed) number of tokens they own of the Quest\n    function claim() public virtual onlyQuestActive {\n        if (isPaused) revert QuestPaused();\n\n        uint[] memory tokens = rabbitHoleReceiptContract.getOwnedTokenIdsOfQuest(questId, msg.sender);\n\n        if (tokens.length == 0) revert NoTokensToClaim();\n\n        uint256 redeemableTokenCount = 0;\n        for (uint i = 0; i < tokens.length; i++) {\n            if (!isClaimed(tokens[i])) {\n                redeemableTokenCount++;\n            }\n        }\n\n        if (redeemableTokenCount == 0) revert AlreadyClaimed();\n\n        uint256 totalRedeemableRewards = _calculateRewards(redeemableTokenCount);\n        _setClaimed(tokens);\n        _transferRewards(totalRedeemableRewards);\n        redeemedTokens += redeemableTokenCount;\n\n        emit Claimed(msg.sender, totalRedeemableRewards);\n    }\n\n    /// @notice Calculate the amount of rewards\n    /// @dev This function must be implemented in the child contracts\n    function _calculateRewards(uint256 redeemableTokenCount_) internal virtual returns (uint256) {\n        revert MustImplementInChild();\n    }\n\n    /// @notice Transfer the rewards to the user\n    /// @dev This function must be implemented in the child contracts\n    /// @param amount_ The amount of rewards to transfer\n    function _transferRewards(uint256 amount_) internal virtual {\n        revert MustImplementInChild();\n    }\n\n    /// @notice Checks if a Receipt token id has been used to claim a reward\n    /// @param tokenId_ The token id to check\n    function isClaimed(uint256 tokenId_) public view returns (bool) {\n        return claimedList[tokenId_] == true;\n    }\n\n    /// @dev Returns the reward amount\n    function getRewardAmount() public view returns (uint256) {\n        return rewardAmountInWeiOrTokenId;\n    }\n\n    /// @dev Returns the reward token address\n    function getRewardToken() public view returns (address) {\n        return rewardToken;\n    }\n\n    /// @notice Allows the owner of the Quest to withdraw any remaining rewards after the Quest has ended\n    function withdrawRemainingTokens(address to_) public virtual onlyOwner onlyAdminWithdrawAfterEnd {}\n}"
    }
  ]
}