{
  "Title": "[N-03] The `getTranche` function should be created in the `poolManager` contract and used to get the `tranche` from the storage by specifying the `poolId` and `trancheId`",
  "Content": "\nhttps://github.com/code-423n4/2023-09-centrifuge/blob/512e7a71ebd9ae76384f837204216f26380c9f91/src/PoolManager.sol#L308\n\nThe function `getTranche()` will increase the simplicity and the modularity of the code instead of get the tranche from the storage each time in different functions.\n```solidity\nfunction getTranche (uint64 poolId , bytes16 trancheId) private returns ( Tranche storage tranche ){\n          tranche =  pools[poolId].tranches[trancheId];\n```\nThis function can be used instead of the line of code in the poolManager.\n```solidity \n        Tranche storage tranche = pools[poolId].tranches[trancheId];\n\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-centrifuge",
  "Code": [
    {
      "filename": "src/PoolManager.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.21;\n\nimport {TrancheTokenFactoryLike, LiquidityPoolFactoryLike} from \"./util/Factory.sol\";\nimport {TrancheTokenLike} from \"./token/Tranche.sol\";\nimport {MemberlistLike} from \"./token/RestrictionManager.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {Auth} from \"./util/Auth.sol\";\nimport {SafeTransferLib} from \"./util/SafeTransferLib.sol\";\n\ninterface GatewayLike {\n    function transferTrancheTokensToCentrifuge(\n        uint64 poolId,\n        bytes16 trancheId,\n        address sender,\n        bytes32 destinationAddress,\n        uint128 amount\n    ) external;\n    function transferTrancheTokensToEVM(\n        uint64 poolId,\n        bytes16 trancheId,\n        address sender,\n        uint64 destinationChainId,\n        address destinationAddress,\n        uint128 amount\n    ) external;\n    function transfer(uint128 currency, address sender, bytes32 recipient, uint128 amount) external;\n}\n\ninterface LiquidityPoolLike {\n    function hasMember(address) external returns (bool);\n}\n\ninterface InvestmentManagerLike {\n    function liquidityPools(uint64 poolId, bytes16 trancheId, address currency) external returns (address);\n    function getTrancheToken(uint64 _poolId, bytes16 _trancheId) external view returns (address);\n    function userEscrow() external view returns (address);\n}\n\ninterface EscrowLike {\n    function approve(address token, address spender, uint256 value) external;\n}\n\ninterface ERC2771Like {\n    function addLiquidityPool(address forwarder) external;\n}\n\ninterface AuthLike {\n    function rely(address usr) external;\n}\n\n/// @dev Centrifuge pools\nstruct Pool {\n    uint64 poolId;\n    uint256 createdAt;\n    mapping(bytes16 => Tranche) tranches;\n    mapping(address => bool) allowedCurrencies;\n}\n\n/// @dev Each Centrifuge pool is associated to 1 or more tranches\nstruct Tranche {\n    address token;\n    uint64 poolId;\n    bytes16 trancheId;\n    // important: the decimals of the leading pool currency. Liquidity Pool shares have to be denomatimated with the same precision.\n    uint8 decimals;\n    uint256 createdAt;\n    string tokenName;\n    string tokenSymbol;\n    /// @dev Each tranche can have multiple liquidity pools deployed,\n    /// each linked to a unique investment currency (asset)\n    mapping(address => address) liquidityPools; // currency -> liquidity pool address\n}\n\n/// @title  Pool Manager\n/// @notice This contract manages which pools & tranches exist,\n///         as well as managing allowed pool currencies, and incoming and outgoing transfers.\ncontract PoolManager is Auth {\n    uint8 internal constant MAX_CURRENCY_DECIMALS = 18;\n\n    EscrowLike public immutable escrow;\n    LiquidityPoolFactoryLike public immutable liquidityPoolFactory;\n    TrancheTokenFactoryLike public immutable trancheTokenFactory;\n\n    GatewayLike public gateway;\n    InvestmentManagerLike public investmentManager;\n\n    mapping(uint64 => Pool) public pools;\n\n    /// @dev Chain agnostic currency id -> evm currency address and reverse mapping\n    mapping(uint128 => address) public currencyIdToAddress;\n    mapping(address => uint128) public currencyAddressToId;\n\n    // --- Events ---\n    event File(bytes32 indexed what, address data);\n    event PoolAdded(uint64 indexed poolId);\n    event PoolCurrencyAllowed(uint128 indexed currency, uint64 indexed poolId);\n    event TrancheAdded(uint64 indexed poolId, bytes16 indexed trancheId);\n    event TrancheDeployed(uint64 indexed poolId, bytes16 indexed trancheId, address indexed token);\n    event CurrencyAdded(uint128 indexed currency, address indexed currencyAddress);\n    event LiquidityPoolDeployed(uint64 indexed poolId, bytes16 indexed trancheId, address indexed liquidityPoool);\n    event TrancheTokenDeployed(uint64 indexed poolId, bytes16 indexed trancheId);\n\n    constructor(address escrow_, address liquidityPoolFactory_, address trancheTokenFactory_) {\n        escrow = EscrowLike(escrow_);\n        liquidityPoolFactory = LiquidityPoolFactoryLike(liquidityPoolFactory_);\n        trancheTokenFactory = TrancheTokenFactoryLike(trancheTokenFactory_);\n\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    /// @dev Gateway must be msg.sender for incoming message handling.\n    modifier onlyGateway() {\n        require(msg.sender == address(gateway), \"PoolManager/not-the-gateway\");\n        _;\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, address data) external auth {\n        if (what == \"gateway\") gateway = GatewayLike(data);\n        else if (what == \"investmentManager\") investmentManager = InvestmentManagerLike(data);\n        else revert(\"PoolManager/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    // --- Outgoing message handling ---\n    function transfer(address currencyAddress, bytes32 recipient, uint128 amount) public {\n        uint128 currency = currencyAddressToId[currencyAddress];\n        require(currency != 0, \"PoolManager/unknown-currency\");\n\n        SafeTransferLib.safeTransferFrom(currencyAddress, msg.sender, address(escrow), amount);\n        gateway.transfer(currency, msg.sender, recipient, amount);\n    }\n\n    function transferTrancheTokensToCentrifuge(\n        uint64 poolId,\n        bytes16 trancheId,\n        bytes32 destinationAddress,\n        uint128 amount\n    ) public {\n        TrancheTokenLike trancheToken = TrancheTokenLike(getTrancheToken(poolId, trancheId));\n        require(address(trancheToken) != address(0), \"PoolManager/unknown-token\");\n\n        trancheToken.burn(msg.sender, amount);\n        gateway.transferTrancheTokensToCentrifuge(poolId, trancheId, msg.sender, destinationAddress, amount);\n    }\n\n    function transferTrancheTokensToEVM(\n        uint64 poolId,\n        bytes16 trancheId,\n        uint64 destinationChainId,\n        address destinationAddress,\n        uint128 amount\n    ) public {\n        TrancheTokenLike trancheToken = TrancheTokenLike(getTrancheToken(poolId, trancheId));\n        require(address(trancheToken) != address(0), \"PoolManager/unknown-token\");\n\n        trancheToken.burn(msg.sender, amount);\n        gateway.transferTrancheTokensToEVM(\n            poolId, trancheId, msg.sender, destinationChainId, destinationAddress, amount\n        );\n    }\n\n    // --- Incoming message handling ---\n    /// @notice    New pool details from an existing Centrifuge pool are added.\n    /// @dev       The function can only be executed by the gateway contract.\n    function addPool(uint64 poolId) public onlyGateway {\n        Pool storage pool = pools[poolId];\n        require(pool.createdAt == 0, \"PoolManager/pool-already-added\");\n        pool.poolId = poolId;\n        pool.createdAt = block.timestamp;\n        emit PoolAdded(poolId);\n    }\n\n    /// @notice     Centrifuge pools can support multiple currencies for investing. this function adds a new supported currency to the pool details.\n    ///             Adding new currencies allow the creation of new liquidity pools for the underlying Centrifuge pool.\n    /// @dev        The function can only be executed by the gateway contract.\n    function allowPoolCurrency(uint64 poolId, uint128 currency) public onlyGateway {\n        Pool storage pool = pools[poolId];\n        require(pool.createdAt != 0, \"PoolManager/invalid-pool\");\n\n        address currencyAddress = currencyIdToAddress[currency];\n        require(currencyAddress != address(0), \"PoolManager/unknown-currency\");\n\n        pools[poolId].allowedCurrencies[currencyAddress] = true;\n        emit PoolCurrencyAllowed(currency, poolId);\n    }\n\n    /// @notice     New tranche details from an existng Centrifuge pool are added.\n    /// @dev        The function can only be executed by the gateway contract.\n    function addTranche(\n        uint64 poolId,\n        bytes16 trancheId,\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 decimals\n    ) public onlyGateway {\n        Pool storage pool = pools[poolId];\n        require(pool.createdAt != 0, \"PoolManager/invalid-pool\");\n        Tranche storage tranche = pool.tranches[trancheId];\n        require(tranche.createdAt == 0, \"PoolManager/tranche-already-exists\");\n\n        tranche.poolId = poolId;\n        tranche.trancheId = trancheId;\n        tranche.decimals = decimals;\n        tranche.tokenName = tokenName;\n        tranche.tokenSymbol = tokenSymbol;\n        tranche.createdAt = block.timestamp;\n\n        emit TrancheAdded(poolId, trancheId);\n    }\n\n    function updateTrancheTokenMetadata(\n        uint64 poolId,\n        bytes16 trancheId,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) public onlyGateway {\n        TrancheTokenLike trancheToken = TrancheTokenLike(getTrancheToken(poolId, trancheId));\n        require(address(trancheToken) != address(0), \"PoolManager/unknown-token\");\n\n        trancheToken.file(\"name\", tokenName);\n        trancheToken.file(\"symbol\", tokenSymbol);\n    }\n\n    function updateMember(uint64 poolId, bytes16 trancheId, address user, uint64 validUntil) public onlyGateway {\n        TrancheTokenLike trancheToken = TrancheTokenLike(getTrancheToken(poolId, trancheId));\n        require(address(trancheToken) != address(0), \"PoolManager/unknown-token\");\n\n        MemberlistLike memberlist = MemberlistLike(address(trancheToken.restrictionManager()));\n        memberlist.updateMember(user, validUntil);\n    }\n\n    /// @notice A global chain agnostic currency index is maintained on Centrifuge. This function maps a currency from the Centrifuge index to its corresponding address on the evm chain.\n    ///         The chain agnostic currency id has to be used to pass currency information to the Centrifuge.\n    /// @dev    This function can only be executed by the gateway contract.\n    function addCurrency(uint128 currency, address currencyAddress) public onlyGateway {\n        // Currency index on the Centrifuge side should start at 1\n        require(currency != 0, \"PoolManager/currency-id-has-to-be-greater-than-0\");\n        require(currencyIdToAddress[currency] == address(0), \"PoolManager/currency-id-in-use\");\n        require(currencyAddressToId[currencyAddress] == 0, \"PoolManager/currency-address-in-use\");\n        require(IERC20(currencyAddress).decimals() <= MAX_CURRENCY_DECIMALS, \"PoolManager/too-many-currency-decimals\");\n\n        currencyIdToAddress[currency] = currencyAddress;\n        currencyAddressToId[currencyAddress] = currency;\n\n        // Enable taking the currency out of escrow in case of redemptions\n        EscrowLike(escrow).approve(currencyAddress, investmentManager.userEscrow(), type(uint256).max);\n\n        // Enable taking the currency out of escrow in case of decrease invest orders\n        EscrowLike(escrow).approve(currencyAddress, address(investmentManager), type(uint256).max);\n\n        emit CurrencyAdded(currency, currencyAddress);\n    }\n\n    function handleTransfer(uint128 currency, address recipient, uint128 amount) public onlyGateway {\n        address currencyAddress = currencyIdToAddress[currency];\n        require(currencyAddress != address(0), \"PoolManager/unknown-currency\");\n\n        EscrowLike(escrow).approve(currencyAddress, address(this), amount);\n        SafeTransferLib.safeTransferFrom(currencyAddress, address(escrow), recipient, amount);\n    }\n\n    function handleTransferTrancheTokens(uint64 poolId, bytes16 trancheId, address destinationAddress, uint128 amount)\n        public\n        onlyGateway\n    {\n        TrancheTokenLike trancheToken = TrancheTokenLike(getTrancheToken(poolId, trancheId));\n        require(address(trancheToken) != address(0), \"PoolManager/unknown-token\");\n\n        require(\n            MemberlistLike(address(trancheToken.restrictionManager())).hasMember(destinationAddress),\n            \"PoolManager/not-a-member\"\n        );\n        trancheToken.mint(destinationAddress, amount);\n    }\n\n    // --- Public functions ---\n    function deployTranche(uint64 poolId, bytes16 trancheId) public returns (address) {\n        Tranche storage tranche = pools[poolId].tranches[trancheId];\n        require(tranche.token == address(0), \"PoolManager/tranche-already-deployed\");\n        require(tranche.createdAt != 0, \"PoolManager/tranche-not-added\");\n\n        address[] memory trancheTokenWards = new address[](2);\n        trancheTokenWards[0] = address(investmentManager);\n        trancheTokenWards[1] = address(this);\n\n        address[] memory memberlistWards = new address[](1);\n        memberlistWards[0] = address(this);\n\n        address token = trancheTokenFactory.newTrancheToken(\n            poolId,\n            trancheId,\n            tranche.tokenName,\n            tranche.tokenSymbol,\n            tranche.decimals,\n            trancheTokenWards,\n            memberlistWards\n        );\n\n        tranche.token = token;\n        emit TrancheTokenDeployed(poolId, trancheId);\n        return token;\n    }\n\n    function deployLiquidityPool(uint64 poolId, bytes16 trancheId, address currency) public returns (address) {\n        Tranche storage tranche = pools[poolId].tranches[trancheId];\n        require(tranche.token != address(0), \"PoolManager/tranche-does-not-exist\"); // Tranche must have been added\n        require(isAllowedAsPoolCurrency(poolId, currency), \"PoolManager/currency-not-supported\"); // Currency must be supported by pool\n\n        address liquidityPool = tranche.liquidityPools[currency];\n        require(liquidityPool == address(0), \"PoolManager/liquidityPool-already-deployed\");\n        require(pools[poolId].createdAt != 0, \"PoolManager/pool-does-not-exist\");\n\n        address[] memory liquidityPoolWards = new address[](1);\n        liquidityPoolWards[0] = address(investmentManager);\n        liquidityPool = liquidityPoolFactory.newLiquidityPool(\n            poolId, trancheId, currency, tranche.token, address(investmentManager), liquidityPoolWards\n        );\n\n        tranche.liquidityPools[currency] = liquidityPool;\n        AuthLike(address(investmentManager)).rely(liquidityPool);\n\n        // Enable LP to take the tranche tokens out of escrow in case if investments\n        AuthLike(tranche.token).rely(liquidityPool); // Add liquidityPool as ward on tranche token\n        ERC2771Like(tranche.token).addLiquidityPool(liquidityPool);\n        EscrowLike(escrow).approve(liquidityPool, address(investmentManager), type(uint256).max); // Approve investment manager on tranche token for coordinating transfers\n        EscrowLike(escrow).approve(liquidityPool, liquidityPool, type(uint256).max); // Approve liquidityPool on tranche token to be able to burn\n\n        emit LiquidityPoolDeployed(poolId, trancheId, liquidityPool);\n        return liquidityPool;\n    }\n\n    // --- Helpers ---\n    function getTrancheToken(uint64 poolId, bytes16 trancheId) public view returns (address) {\n        Tranche storage tranche = pools[poolId].tranches[trancheId];\n        return tranche.token;\n    }\n\n    function getLiquidityPool(uint64 poolId, bytes16 trancheId, address currency) public view returns (address) {\n        return pools[poolId].tranches[trancheId].liquidityPools[currency];\n    }\n\n    function isAllowedAsPoolCurrency(uint64 poolId, address currencyAddress) public view returns (bool) {\n        uint128 currency = currencyAddressToId[currencyAddress];\n        require(currency != 0, \"PoolManager/unknown-currency\"); // Currency index on the Centrifuge side should start at 1\n        require(pools[poolId].allowedCurrencies[currencyAddress], \"PoolManager/pool-currency-not-allowed\");\n        return true;\n    }\n}"
    }
  ]
}