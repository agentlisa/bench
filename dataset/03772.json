{
  "Title": "[M04] Orders registration can be frontrun",
  "Content": "The governance can call the `ReserveSwapper` contract [to register a market order for a token pair](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveSwapper.sol#L57). Once the order is registered, users can start calling the [`swap`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/reserve/ReserveSwapper.sol#L74) function and exchange one token for the other.\n\n\nIf the governance tries to update an already existing order, an order with a limited amount of tokens, that call can be frontrun by a malicious actor, which can call the `swap` function for the same token pair, zeroing the order amount in the accounting balance.\n\n\nIf this happens, after the new governance order has been mined, any further call to the `swap` function can unexpectedly fail in transferring the tokens, since the actual balances of the contract are not taken into account when registering the order’s amount.\n\n\nConsider checking if the contract has enough balance of the respective tokens before setting any non-limited order amount.\n\n\n***Update**: Acknowledged. The EmptySetSquad team statement for this issue:*\n\n\n\n> \n> *Won’t fix – generally speaking, this module is meant to be holdover until we can create a more robust DAO treasury management system as part of a larger effort. Included note in [governance](https://emptysetsquad.gitbook.io/continuous-esd/governance) on how to properly account for these limitations.*\n> \n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/src/reserve/ReserveSwapper.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../Interfaces.sol\";\nimport \"./ReserveComptroller.sol\";\nimport \"./ReserveState.sol\";\n\n/**\n * @title ReserveSwapper\n * @notice Logic for managing outstanding limit orders, allow the reserve to swap its held tokens\n */\ncontract ReserveSwapper is ReentrancyGuard, ReserveComptroller {\n    using SafeMath for uint256;\n    using Decimal for Decimal.D256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Emitted when `amount` of the `makerToken`-`takerToken` order is registered with price `price`\n     */\n    event OrderRegistered(address indexed makerToken, address indexed takerToken, uint256 price, uint256 amount);\n\n    /**\n     * @notice Emitted when the reserve pays `takerAmount` of `takerToken` in exchange for `makerAmount` of `makerToken`\n     */\n    event Swap(address indexed makerToken, address indexed takerToken, uint256 takerAmount, uint256 makerAmount);\n\n    /**\n     * @notice Sets the `price` and `amount` of the specified `makerToken`-`takerToken` order\n     * @dev Owner only - governance hook\n     *      uint256(-1) indicates an unlimited order amount\n     * @param makerToken Token that the reserve wishes to sell\n     * @param takerToken Token that the reserve wishes to buy\n     * @param price Price as a ratio of takerAmount:makerAmount times 10^18\n     * @param amount Amount to decrement in ESD\n     */\n    function registerOrder(address makerToken, address takerToken, uint256 price, uint256 amount) external onlyOwner {\n        _updateOrder(makerToken, takerToken, price, amount);\n\n        emit OrderRegistered(makerToken, takerToken, price, amount);\n    }\n\n    /**\n     * @notice Purchases `makerToken` from the reserve in exchange for `takerAmount` of `takerToken`\n     * @dev Non-reentrant\n     *      Uses the state-defined price for the `makerToken`-`takerToken` order\n     *      Maker and taker tokens must be different\n     *      Cannot swap ESD\n     *      uint256(-1) indicates an unlimited order amount\n     * @param makerToken Token that the caller wishes to buy\n     * @param takerToken Token that the caller wishes to sell\n     * @param takerAmount Amount of takerToken to sell\n     */\n    function swap(address makerToken, address takerToken, uint256 takerAmount) external nonReentrant {\n        address dollar = registry().dollar();\n        require(makerToken != dollar, \"ReserveSwapper: unsupported token\");\n        require(takerToken != dollar, \"ReserveSwapper: unsupported token\");\n        require(makerToken != takerToken, \"ReserveSwapper: tokens equal\");\n\n        ReserveTypes.Order memory order = order(makerToken, takerToken);\n        uint256 makerAmount = Decimal.from(takerAmount).div(order.price, \"ReserveSwapper: no order\").asUint256();\n\n        if (order.amount != uint256(-1))\n            _decrementOrderAmount(makerToken, takerToken, makerAmount, \"ReserveSwapper: insufficient amount\");\n\n        _transferFrom(takerToken, msg.sender, address(this), takerAmount);\n        _transfer(makerToken, msg.sender, makerAmount);\n\n        emit Swap(makerToken, takerToken, takerAmount, makerAmount);\n    }\n}"
    }
  ]
}