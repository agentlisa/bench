{
  "Title": "[G-16]  `require()` or `revert()` statements that check input arguments should be at the top of the function",
  "Content": "Checks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (**2100 gas***) in a function that may ultimately revert in the unhappy case.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/protocol/pool/PoolParameters.sol\n\n/// @audit expensive op on line 212\n214:          require(value != 0, Errors.INVALID_AMOUNT);\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/pool/PoolParameters.sol#L214\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-11-paraspace",
  "Code": [
    {
      "filename": "paraspace-core/contracts/protocol/pool/PoolParameters.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {ParaVersionedInitializable} from \"../libraries/paraspace-upgradeability/ParaVersionedInitializable.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {PoolLogic} from \"../libraries/logic/PoolLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {MarketplaceLogic} from \"../libraries/logic/MarketplaceLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidationLogic} from \"../libraries/logic/LiquidationLogic.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {IERC20WithPermit} from \"../../interfaces/IERC20WithPermit.sol\";\nimport {IPoolAddressesProvider} from \"../../interfaces/IPoolAddressesProvider.sol\";\nimport {IPoolParameters} from \"../../interfaces/IPoolParameters.sol\";\nimport {INToken} from \"../../interfaces/INToken.sol\";\nimport {IACLManager} from \"../../interfaces/IACLManager.sol\";\nimport {PoolStorage} from \"./PoolStorage.sol\";\nimport {FlashClaimLogic} from \"../libraries/logic/FlashClaimLogic.sol\";\nimport {Address} from \"../../dependencies/openzeppelin/contracts/Address.sol\";\nimport {IERC721Receiver} from \"../../dependencies/openzeppelin/contracts/IERC721Receiver.sol\";\nimport {IMarketplace} from \"../../interfaces/IMarketplace.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {ParaReentrancyGuard} from \"../libraries/paraspace-upgradeability/ParaReentrancyGuard.sol\";\nimport {IAuctionableERC721} from \"../../interfaces/IAuctionableERC721.sol\";\nimport {IReserveAuctionStrategy} from \"../../interfaces/IReserveAuctionStrategy.sol\";\n\n/**\n * @title Pool Parameters contract\n *\n * @notice Main point of interaction with an ParaSpace protocol's market\n * - Users can:\n *   - mintToTreasury\n *   - ...\n * @dev To be covered by a proxy contract, owned by the PoolAddressesProvider of the specific market\n * @dev All admin functions are callable by the PoolConfigurator contract defined also in the\n *   PoolAddressesProvider\n **/\ncontract PoolParameters is\n    ParaVersionedInitializable,\n    ParaReentrancyGuard,\n    PoolStorage,\n    IPoolParameters\n{\n    using ReserveLogic for DataTypes.ReserveData;\n\n    IPoolAddressesProvider internal immutable ADDRESSES_PROVIDER;\n    uint256 internal constant POOL_REVISION = 1;\n    uint256 internal constant MAX_AUCTION_HEALTH_FACTOR = 2e18;\n    uint256 internal constant MIN_AUCTION_HEALTH_FACTOR = 1e18;\n\n    /**\n     * @dev Only pool configurator can call functions marked by this modifier.\n     **/\n    modifier onlyPoolConfigurator() {\n        _onlyPoolConfigurator();\n        _;\n    }\n\n    /**\n     * @dev Only pool admin can call functions marked by this modifier.\n     **/\n    modifier onlyPoolAdmin() {\n        _onlyPoolAdmin();\n        _;\n    }\n\n    function _onlyPoolConfigurator() internal view virtual {\n        require(\n            ADDRESSES_PROVIDER.getPoolConfigurator() == msg.sender,\n            Errors.CALLER_NOT_POOL_CONFIGURATOR\n        );\n    }\n\n    function _onlyPoolAdmin() internal view virtual {\n        require(\n            IACLManager(ADDRESSES_PROVIDER.getACLManager()).isPoolAdmin(\n                msg.sender\n            ),\n            Errors.CALLER_NOT_POOL_ADMIN\n        );\n    }\n\n    /**\n     * @dev Constructor.\n     * @param provider The address of the PoolAddressesProvider contract\n     */\n    constructor(IPoolAddressesProvider provider) {\n        ADDRESSES_PROVIDER = provider;\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return POOL_REVISION;\n    }\n\n    /// @inheritdoc IPoolParameters\n    function mintToTreasury(address[] calldata assets)\n        external\n        virtual\n        override\n        nonReentrant\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        PoolLogic.executeMintToTreasury(ps._reserves, assets);\n    }\n\n    /// @inheritdoc IPoolParameters\n    function initReserve(\n        address asset,\n        address xTokenAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress,\n        address auctionStrategyAddress\n    ) external virtual override onlyPoolConfigurator {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        if (\n            PoolLogic.executeInitReserve(\n                ps._reserves,\n                ps._reservesList,\n                DataTypes.InitReserveParams({\n                    asset: asset,\n                    xTokenAddress: xTokenAddress,\n                    variableDebtAddress: variableDebtAddress,\n                    interestRateStrategyAddress: interestRateStrategyAddress,\n                    auctionStrategyAddress: auctionStrategyAddress,\n                    reservesCount: ps._reservesCount,\n                    maxNumberReserves: ReserveConfiguration.MAX_RESERVES_COUNT\n                })\n            )\n        ) {\n            ps._reservesCount++;\n        }\n    }\n\n    /// @inheritdoc IPoolParameters\n    function dropReserve(address asset)\n        external\n        virtual\n        override\n        onlyPoolConfigurator\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        PoolLogic.executeDropReserve(ps._reserves, ps._reservesList, asset);\n    }\n\n    /// @inheritdoc IPoolParameters\n    function setReserveInterestRateStrategyAddress(\n        address asset,\n        address rateStrategyAddress\n    ) external virtual override onlyPoolConfigurator {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n        require(\n            ps._reserves[asset].id != 0 || ps._reservesList[0] == asset,\n            Errors.ASSET_NOT_LISTED\n        );\n        ps._reserves[asset].interestRateStrategyAddress = rateStrategyAddress;\n    }\n\n    /// @inheritdoc IPoolParameters\n    function setReserveAuctionStrategyAddress(\n        address asset,\n        address auctionStrategyAddress\n    ) external virtual override onlyPoolConfigurator {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n        require(\n            ps._reserves[asset].id != 0 || ps._reservesList[0] == asset,\n            Errors.ASSET_NOT_LISTED\n        );\n        ps._reserves[asset].auctionStrategyAddress = auctionStrategyAddress;\n    }\n\n    /// @inheritdoc IPoolParameters\n    function setConfiguration(\n        address asset,\n        DataTypes.ReserveConfigurationMap calldata configuration\n    ) external virtual override onlyPoolConfigurator {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        require(asset != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n        require(\n            ps._reserves[asset].id != 0 || ps._reservesList[0] == asset,\n            Errors.ASSET_NOT_LISTED\n        );\n        ps._reserves[asset].configuration = configuration;\n    }\n\n    /// @inheritdoc IPoolParameters\n    function rescueTokens(\n        DataTypes.AssetType assetType,\n        address token,\n        address to,\n        uint256 amountOrTokenId\n    ) external virtual override onlyPoolAdmin {\n        PoolLogic.executeRescueTokens(assetType, token, to, amountOrTokenId);\n    }\n\n    /// @inheritdoc IPoolParameters\n    function setAuctionRecoveryHealthFactor(uint64 value)\n        external\n        virtual\n        override\n        onlyPoolConfigurator\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        require(value != 0, Errors.INVALID_AMOUNT);\n\n        require(\n            value > MIN_AUCTION_HEALTH_FACTOR &&\n                value <= MAX_AUCTION_HEALTH_FACTOR,\n            Errors.INVALID_AMOUNT\n        );\n\n        ps._auctionRecoveryHealthFactor = value;\n    }\n\n    /// @inheritdoc IPoolParameters\n    function getUserAccountData(address user)\n        external\n        view\n        virtual\n        override\n        returns (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase,\n            uint256 availableBorrowsBase,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor,\n            uint256 erc721HealthFactor\n        )\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        return\n            PoolLogic.executeGetUserAccountData(\n                user,\n                ps,\n                ADDRESSES_PROVIDER.getPriceOracle()\n            );\n    }\n\n    function getAssetLtvAndLT(address asset, uint256 tokenId)\n        external\n        view\n        virtual\n        override\n        returns (uint256 ltv, uint256 lt)\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n        return PoolLogic.executeGetAssetLtvAndLT(ps, asset, tokenId);\n    }\n\n    /// @inheritdoc IPoolParameters\n    function setAuctionValidityTime(address user)\n        external\n        virtual\n        override\n        nonReentrant\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        require(user != address(0), Errors.ZERO_ADDRESS_NOT_VALID);\n        DataTypes.UserConfigurationMap storage userConfig = ps._usersConfig[\n            user\n        ];\n        (, , , , , , uint256 erc721HealthFactor) = PoolLogic\n            .executeGetUserAccountData(\n                user,\n                ps,\n                ADDRESSES_PROVIDER.getPriceOracle()\n            );\n        require(\n            erc721HealthFactor > ps._auctionRecoveryHealthFactor,\n            Errors.ERC721_HEALTH_FACTOR_NOT_ABOVE_THRESHOLD\n        );\n        userConfig.auctionValidityTime = block.timestamp;\n    }\n}"
    }
  ]
}