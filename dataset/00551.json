{
  "Title": "Repricing with small rewards results in an invalid state where `ETH` reserves increase, `swETH to ETH` exchange rate increases, but no rewards are paid out to operators or treasury",
  "Content": "**Description:** Invariant fuzzing used repricings with small rewards to reach an invalid state where `ETH` reserves increase, `swETH : ETH` exchange rate increases, but no rewards are paid out to operators or treasury.\n\n**Proof of Concept:** During repricing:\n1) there is no minimum value enforced by either `RepricingOracle` for [`_snapshot.rewardsPayableForFees`](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/RepricingOracle.sol#L227) or `swETH::reprice` for `_newETHRewards`\n2) in `swETH::reprice` there is no check for rounding down to zero precision loss when [calculating](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L239-L241) `rewardsInSwETH`\n\nThis results in the fuzzer reaching an invalid state where:\n1) by calling `RepricingOracle::submitSnapshotV2` with small values for `_snapshot.rewardsPayableForFees`, this results in `swETH::reprice` being called with small `_newETHRewards`\n2) inside `swETH::reprice` the small `_newETHRewards` triggers a rounding down to zero precision loss in the rewards calculation of `rewardsInSwETH` so [rewards are never distributed](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L278)\n3) however `swETH::reprice` does [update](https://github.com/SwellNetwork/v3-contracts-lst/blob/a95ea7942ba895ae84845ab7fec1163d667bee38/contracts/implementations/swETH.sol#L337) `lastRepriceETHReserves` using the small positive `_newETHRewards` value and the transaction completes successfully.\n\nThis results in an invalid state where:\n\n1) `swETH::lastRepriceETHReserves` increases\n2) `swETH : ETH` exchange rate increases\n3) no rewards are being paid out to operators/treasury\n\nThis simplified PoC can be added to `reprice.test.ts`:\n```typescript\n    it(\"audit small rewards not distributed while reserves and exchange rate increasing\", async () => {\n      const swellTreasuryRewardPercentage = parseEther(\"0.1\");\n\n      await swETH_Deployer.setSwellTreasuryRewardPercentage(\n        swellTreasuryRewardPercentage\n      );\n\n      await swETH_Deployer.deposit({\n        value: parseEther(\"1000\"),\n      });\n      const preRewardETHReserves = parseEther(\"1100\");\n\n      const swETHSupply = parseEther(\"1000\");\n\n      const ethRewards = parseUnits(\"1\", \"wei\");\n\n      const swellTreasuryPre = await swETH_Deployer.balanceOf(SwellTreasury.address);\n      const ethReservesPre = await swETH_Deployer.lastRepriceETHReserves();\n      const rateBefore = await swETH_Deployer.swETHToETHRate();\n\n      swETH_Bot.reprice(\n          preRewardETHReserves,\n          ethRewards,\n          swETH_Deployer.totalSupply());\n\n      const swellTreasuryPost = await swETH_Deployer.balanceOf(SwellTreasury.address);\n      const ethReservesPost = await swETH_Deployer.lastRepriceETHReserves();\n      const rateAfter = await swETH_Deployer.swETHToETHRate();\n\n      // no rewards distributed to treasury\n      expect(swellTreasuryPre).eq(swellTreasuryPost);\n\n      // exchange rate increases\n      expect(rateBefore).lt(rateAfter);\n\n      // reserves increase\n      expect(ethReservesPre).lt(ethReservesPost);\n\n      // repricing using small `_newETHRewards` can lead to increasing reserves\n      // and increasing exchange rate without reward payouts\n    });\n```\n\nThis was not introduced in the new changes but is present in the current mainnet code [[1](https://github.com/SwellNetwork/v3-core-public/blob/master/contracts/lst/contracts/implementations/swETH.sol#L264), [2](https://github.com/SwellNetwork/v3-core-public/blob/master/contracts/lst/contracts/implementations/swETH.sol#L323-L325)].\n\n**Swell:** Acknowledged.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/lst/contracts/implementations/swETH.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\nimport {UD60x18, wrap} from \"@prb/math/src/UD60x18.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {EnumerableSetUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {Whitelist} from \"./Whitelist.sol\";\n\nimport {SwellLib} from \"../libraries/SwellLib.sol\";\n\nimport {IswETH} from \"../interfaces/IswETH.sol\";\nimport {IAccessControlManager} from \"../interfaces/IAccessControlManager.sol\";\nimport {INodeOperatorRegistry} from \"../interfaces/INodeOperatorRegistry.sol\";\nimport {IRateProvider} from \"../vendors/IRateProvider.sol\";\n\n/**\n * @title swETH\n * @notice Contract for handling user deposits in ETH in exchange for swETH at the stored rate. Also handles the rate updates from the BOT wallet which will occur at a fixed interval.\n * @author https://github.com/max-taylor\n * @dev This contract inherits the Whitelist contract which holds the Access control manager state variable and the checkRole modifier\n */\ncontract swETH is\n  Initializable,\n  Whitelist,\n  IswETH,\n  IRateProvider,\n  ERC20Upgradeable\n{\n  using SafeERC20 for IERC20;\n  using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n  uint256 public override lastRepriceETHReserves;\n  uint256 private swETHToETHRateFixed;\n\n  uint256 public override swellTreasuryRewardPercentage;\n  uint256 public override nodeOperatorRewardPercentage;\n\n  uint256 public override lastRepriceUNIX;\n\n  uint256 public override totalETHDeposited;\n\n  uint256 public override minimumRepriceTime;\n  uint256 public override maximumRepriceDifferencePercentage;\n  uint256 public override maximumRepriceswETHDifferencePercentage;\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  fallback() external {\n    revert SwellLib.InvalidMethodCall();\n  }\n\n  function initialize(\n    IAccessControlManager _accessControlManager\n  ) external initializer checkZeroAddress(address(_accessControlManager)) {\n    __ERC20_init(\"swETH\", \"swETH\");\n\n    __Whitelist_init(_accessControlManager);\n  }\n\n  // ************************************\n  // ***** External methods ******\n\n  function withdrawERC20(\n    IERC20 _token\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\n    uint256 contractBalance = _token.balanceOf(address(this));\n    if (contractBalance == 0) {\n      revert SwellLib.NoTokensToWithdraw();\n    }\n\n    _token.safeTransfer(msg.sender, contractBalance);\n  }\n\n  function setSwellTreasuryRewardPercentage(\n    uint256 _newSwellTreasuryRewardPercentage\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\n    // Joined percentage total cannot exeed 100% (1 ether)\n    if (\n      nodeOperatorRewardPercentage + _newSwellTreasuryRewardPercentage > 1 ether\n    ) {\n      revert RewardPercentageTotalOverflow();\n    }\n\n    emit SwellTreasuryRewardPercentageUpdate(\n      swellTreasuryRewardPercentage,\n      _newSwellTreasuryRewardPercentage\n    );\n\n    swellTreasuryRewardPercentage = _newSwellTreasuryRewardPercentage;\n  }\n\n  function setNodeOperatorRewardPercentage(\n    uint256 _newNodeOperatorRewardPercentage\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\n    // Joined percentage total cannot exeed 100% (1 ether)\n    if (\n      swellTreasuryRewardPercentage + _newNodeOperatorRewardPercentage > 1 ether\n    ) {\n      revert RewardPercentageTotalOverflow();\n    }\n\n    emit NodeOperatorRewardPercentageUpdate(\n      nodeOperatorRewardPercentage,\n      _newNodeOperatorRewardPercentage\n    );\n\n    nodeOperatorRewardPercentage = _newNodeOperatorRewardPercentage;\n  }\n\n  function setMinimumRepriceTime(\n    uint256 _minimumRepriceTime\n  ) external checkRole(SwellLib.PLATFORM_ADMIN) {\n    emit MinimumRepriceTimeUpdated(minimumRepriceTime, _minimumRepriceTime);\n\n    minimumRepriceTime = _minimumRepriceTime;\n  }\n\n  function setMaximumRepriceswETHDifferencePercentage(\n    uint256 _maximumRepriceswETHDifferencePercentage\n  ) external checkRole(SwellLib.PLATFORM_ADMIN) {\n    emit MaximumRepriceswETHDifferencePercentageUpdated(\n      maximumRepriceswETHDifferencePercentage,\n      _maximumRepriceswETHDifferencePercentage\n    );\n\n    maximumRepriceswETHDifferencePercentage = _maximumRepriceswETHDifferencePercentage;\n  }\n\n  function setMaximumRepriceDifferencePercentage(\n    uint256 _maximumRepriceDifferencePercentage\n  ) external checkRole(SwellLib.PLATFORM_ADMIN) {\n    emit MaximumRepriceDifferencePercentageUpdated(\n      maximumRepriceDifferencePercentage,\n      _maximumRepriceDifferencePercentage\n    );\n\n    maximumRepriceDifferencePercentage = _maximumRepriceDifferencePercentage;\n  }\n\n  function swETHToETHRate() external view override returns (uint256) {\n    return _swETHToETHRate().unwrap();\n  }\n\n  function ethToSwETHRate() external view override returns (uint256) {\n    return _ethToSwETHRate().unwrap();\n  }\n\n  function getRate() external view override returns (uint256) {\n    // This method is identical to swETHToETHRate but is required for the Balancer Metastable pools. Keeping this and the swETHToETHRate method because the swETHToETHRate method is more readable for integrations.\n    return _swETHToETHRate().unwrap();\n  }\n\n  function _deposit(address referral) internal checkWhitelist(msg.sender) {\n    if (AccessControlManager.coreMethodsPaused()) {\n      revert SwellLib.CoreMethodsPaused();\n    }\n\n    if (msg.value == 0) {\n      revert SwellLib.InvalidETHDeposit();\n    }\n\n    uint256 swETHAmount = wrap(msg.value)\n      .mul(wrap(1 ether))\n      .div(_swETHToETHRate())\n      .unwrap();\n\n    _mint(msg.sender, swETHAmount);\n\n    totalETHDeposited += msg.value;\n\n    AddressUpgradeable.sendValue(\n      payable(address(AccessControlManager.DepositManager())),\n      msg.value\n    );\n\n    emit ETHDepositReceived(\n      msg.sender,\n      msg.value,\n      swETHAmount,\n      totalETHDeposited,\n      referral\n    );\n  }\n\n  function deposit() external payable override {\n    _deposit(address(0));\n  }\n\n  function depositWithReferral(address referral) external payable override {\n    if (msg.sender == referral) {\n      revert SwellLib.CannotReferSelf();\n    }\n    _deposit(referral);\n  }\n\n  function reprice(\n    uint256 _preRewardETHReserves,\n    uint256 _newETHRewards,\n    uint256 _swETHTotalSupply\n  ) external override checkRole(SwellLib.REPRICER) {\n    uint256 currSupply = totalSupply();\n\n    if (_swETHTotalSupply == 0 || currSupply == 0) {\n      revert CannotRepriceWithZeroSwETHSupply();\n    }\n\n    if (_preRewardETHReserves == 0) {\n      revert InvalidPreRewardETHReserves();\n    }\n\n    uint256 cachedLastRepriceUNIX = lastRepriceUNIX;\n\n    uint256 timeSinceLastReprice = block.timestamp - cachedLastRepriceUNIX;\n    uint256 cachedMinimumRepriceTime = minimumRepriceTime;\n\n    if (timeSinceLastReprice < cachedMinimumRepriceTime) {\n      revert NotEnoughTimeElapsedForReprice(\n        cachedMinimumRepriceTime - timeSinceLastReprice\n      );\n    }\n\n    uint256 totalReserves = _preRewardETHReserves + _newETHRewards;\n\n    uint256 cachedNodeOperatorRewardPercentage = nodeOperatorRewardPercentage;\n\n    uint256 rewardPercentageTotal = swellTreasuryRewardPercentage +\n      cachedNodeOperatorRewardPercentage;\n\n    UD60x18 rewardsInETH = wrap(_newETHRewards).mul(\n      wrap(rewardPercentageTotal)\n    );\n\n    UD60x18 rewardsInSwETH = wrap(_swETHTotalSupply).mul(rewardsInETH).div(\n      wrap(totalReserves - rewardsInETH.unwrap())\n    );\n\n    // Also including the amount of new swETH that was minted alongside the provided swETH total supply\n    uint256 updatedSwETHToETHRateFixed = wrap(totalReserves)\n      .div(wrap(_swETHTotalSupply + rewardsInSwETH.unwrap()))\n      .unwrap();\n\n    // Ensure that the reprice differences are within expected ranges, only if the reprice method has been called before\n    if (cachedLastRepriceUNIX != 0) {\n      uint256 cachedSwETHToETHRateFixed = swETHToETHRateFixed;\n      // Check repricing rate difference\n      uint256 repriceDiff = _absolute(\n        updatedSwETHToETHRateFixed,\n        cachedSwETHToETHRateFixed\n      );\n\n      uint256 maximumRepriceDiff = wrap(cachedSwETHToETHRateFixed)\n        .mul(wrap(maximumRepriceDifferencePercentage))\n        .unwrap();\n\n      if (repriceDiff > maximumRepriceDiff) {\n        revert RepriceDifferenceTooLarge(repriceDiff, maximumRepriceDiff);\n      }\n    }\n\n    // Check swETH supply provided with actual current supply\n    uint256 swETHSupplyDiff = _absolute(currSupply, _swETHTotalSupply);\n\n    uint256 maximumswETHDiff = (currSupply *\n      maximumRepriceswETHDifferencePercentage) / 1 ether;\n\n    if (swETHSupplyDiff > maximumswETHDiff) {\n      revert RepriceswETHDifferenceTooLarge(swETHSupplyDiff, maximumswETHDiff);\n    }\n\n    uint256 nodeOperatorRewards;\n    uint256 swellTreasuryRewards;\n\n    if (rewardsInSwETH.unwrap() != 0) {\n      UD60x18 nodeOperatorRewardPortion = wrap(\n        cachedNodeOperatorRewardPercentage\n      ).div(wrap(rewardPercentageTotal));\n\n      nodeOperatorRewards = nodeOperatorRewardPortion\n        .mul(rewardsInSwETH)\n        .unwrap();\n\n      INodeOperatorRegistry nodeOperatorRegistry = AccessControlManager\n        .NodeOperatorRegistry();\n\n      uint256 totalActiveValidators = nodeOperatorRegistry\n        .getPoRAddressListLength();\n\n      if (totalActiveValidators == 0) {\n        nodeOperatorRewards = 0;\n      } else if (nodeOperatorRewards != 0) {\n        uint128 totalOperators = nodeOperatorRegistry.numOperators();\n\n        UD60x18 rewardsPerValidator = wrap(nodeOperatorRewards).div(\n          wrap(totalActiveValidators)\n        );\n\n        // Operator Id's start at 1\n        for (uint128 i = 1; i <= totalOperators; ) {\n          (\n            address rewardAddress,\n            uint256 operatorActiveValidators\n          ) = nodeOperatorRegistry.getRewardDetailsForOperatorId(i);\n\n          if (operatorActiveValidators != 0) {\n            uint256 operatorsRewardShare = rewardsPerValidator\n              .mul(wrap(operatorActiveValidators))\n              .unwrap();\n\n            _mint(rewardAddress, operatorsRewardShare);\n          }\n\n          // Will never overflow as the total operators are capped at uint128\n          unchecked {\n            ++i;\n          }\n        }\n      }\n\n      // Transfer the remaining rewards to the treasury\n      swellTreasuryRewards = rewardsInSwETH.unwrap() - nodeOperatorRewards;\n\n      if (swellTreasuryRewards != 0) {\n        _mint(AccessControlManager.SwellTreasury(), swellTreasuryRewards);\n      }\n    }\n\n    lastRepriceETHReserves = totalReserves;\n    lastRepriceUNIX = block.timestamp;\n    swETHToETHRateFixed = updatedSwETHToETHRateFixed;\n\n    emit Reprice(\n      totalReserves,\n      updatedSwETHToETHRateFixed,\n      nodeOperatorRewards,\n      swellTreasuryRewards,\n      totalETHDeposited\n    );\n  }\n\n  function burn(uint256 amount) external override {\n    if (amount == 0) {\n      revert CannotBurnZeroSwETH();\n    }\n\n    _burn(msg.sender, amount);\n  }\n\n  // ************************************\n  // ***** Internal methods ******\n\n  /**\n   * @dev Returns the ETH -> swETH rate, if no PoR reading has come through the rate is 1:1\n   * @return The rate as a fixed-point type\n   */\n  function _ethToSwETHRate() internal view returns (UD60x18) {\n    return wrap(1 ether).div(_swETHToETHRate());\n  }\n\n  /**\n   * @dev Returns the swETH -> ETH rate, if no PoR reading has come in the rate is 1:1\n   * @return The rate as a fixed-point type\n   */\n  function _swETHToETHRate() internal view returns (UD60x18) {\n    uint256 cachedSwETHToETHRateFixed = swETHToETHRateFixed;\n\n    if (cachedSwETHToETHRateFixed == 0) {\n      return wrap(1 ether);\n    }\n\n    return wrap(cachedSwETHToETHRateFixed);\n  }\n\n  /**\n   * @dev Returns the absolute difference between two uint256 values\n   */\n  function _absolute(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    if (_a < _b) {\n      return _b - _a;\n    }\n\n    return _a - _b;\n  }\n}"
    }
  ]
}