{
  "Title": "M-12: Partial withdrawals by AssetManager lead to user funds freeze",
  "Content": "# Issue M-12: Partial withdrawals by AssetManager lead to user funds freeze \n\nSource: https://github.com/sherlock-audit/2022-10-union-finance-judging/issues/50 \n\n## Found by \nhyh, Jeiwan\n\n## Summary\n\nAssetManager's withdraw() doesn't guarantee the retrieval of the full requested amount. However, all dependant function always treat such withdrawal call as if full amount was successfully sent to a recipient.\n\n## Vulnerability Detail\n\nPartial withdrawals by AssetManager are unaccounted in all withdraw initiating functions: user-facing UserManager's unstake(), UToken's borrow() and redeem(). This way the `remaining` amount withdraw() failed to obtain from the adapters is permanently lost for the withdrawal recipient as full amount is accounted each time.\n\nStrategies AssetManager utilize via adapters can have temporal funds unavailability, say Aave and Compound can have liquidity squeezes. If a particular lending pool has liquidity shortage, i.e. almost all underlying is lent out, full withdrawal of the requested underlying token amount will not be possible at the moment. It doesn't mean the funds are lost, so writing the full amount off for a recipient isn't correct and is equivalent to user's fund freeze in the system.\n\n## Impact\n\nNet impact is permanent fund freeze for the users who were recipients for such withdrawals. I.e. when `remaining` funds become available later, there is no way to receive them for the users as their accounting was updated by full amounts already. This way such remaining funds were de facto wrote down for the users and became excess unallocated funds of a Strategy, i.e. profit for the system from AssetManager's funds allocation.\n\nAs this permanent fund freeze is conditional on Strategy liquidity squeeze, which is medium probability event, being a part of normal activity for lending protocols, setting the severity to be **medium**.\n\n## Code Snippet\n\nAccounting discrepancy is introduced each time as AssetManager's withdraw() do not guarantee full `amount` retrieval, always returns true and reduces the balances by `amount - remaining`:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/asset/AssetManager.sol#L328-L369\n\n```solidity\n    function withdraw(\n        address token,\n        address account,\n        uint256 amount\n    ) external override whenNotPaused nonReentrant onlyAuth(token) returns (bool) {\n        if (!_checkSenderBalance(msg.sender, token, amount)) revert InsufficientBalance();\n\n        uint256 remaining = amount;\n\n        // If there are tokens in Asset Manager then transfer them on priority\n        uint256 selfBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        if (selfBalance > 0) {\n            uint256 withdrawAmount = selfBalance < remaining ? selfBalance : remaining;\n            remaining -= withdrawAmount;\n            IERC20Upgradeable(token).safeTransfer(account, withdrawAmount);\n        }\n\n        if (isMarketSupported(token)) {\n            uint256 withdrawSeqLength = withdrawSeq.length;\n            // iterate markets according to defined sequence and withdraw\n            for (uint256 i = 0; i < withdrawSeqLength && remaining > 0; i++) {\n                IMoneyMarketAdapter moneyMarket = moneyMarkets[withdrawSeq[i]];\n                if (!moneyMarket.supportsToken(token)) continue;\n\n                uint256 supply = moneyMarket.getSupply(token);\n                if (supply == 0) continue;\n\n                uint256 withdrawAmount = supply < remaining ? supply : remaining;\n                remaining -= withdrawAmount;\n                moneyMarket.withdraw(token, account, withdrawAmount);\n            }\n        }\n\n        if (!_isUToken(msg.sender, token)) {\n            balances[msg.sender][token] = balances[msg.sender][token] - amount + remaining;\n            totalPrincipal[token] = totalPrincipal[token] - amount + remaining;\n        }\n\n        emit LogWithdraw(token, account, amount, remaining);\n\n        return true;\n    }\n```\n\nThe functions that use withdraw() treat it differently, always assuming that the whole amount is successfully retrieved.\n\nI.e. UserManager's balance in AssetManager will be reduced less than user's balance in UserManager as UserManager's unstake() always removes the full `amount` from `staker.stakedAmount` and `totalStaked`:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L691-L705\n\n```solidity\n    function unstake(uint96 amount) external whenNotPaused nonReentrant {\n        Staker storage staker = stakers[msg.sender];\n\n        // Stakers can only unstaked stake balance that is unlocked. Stake balance\n        // becomes locked when it is used to underwrite a borrow.\n        if (staker.stakedAmount - staker.locked < amount) revert InsufficientBalance();\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        staker.stakedAmount -= amount;\n        totalStaked -= amount;\n\n        if (!IAssetManager(assetManager).withdraw(stakingToken, msg.sender, amount)) {\n            revert AssetManagerWithdrawFailed();\n        }\n```\n\nUToken's borrow() also always assumes that full `amount` is retrieved to the borrower, adding full `amount` to `accountBorrows` entry:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/market/UToken.sol#L512-L555\n\n```solidity\n    function borrow(address to, uint256 amount) external override onlyMember(msg.sender) whenNotPaused nonReentrant {\n        IAssetManager assetManagerContract = IAssetManager(assetManager);\n        if (amount < minBorrow) revert AmountLessMinBorrow();\n        if (amount > getRemainingDebtCeiling()) revert AmountExceedGlobalMax();\n\n        ...\n\n        uint256 accountBorrowsNew = borrowedAmount + amount + fee;\n        uint256 totalBorrowsNew = totalBorrows + amount + fee;\n\n        // Update internal balances\n        accountBorrows[msg.sender].principal += amount + fee;\n\n        ...\n\n        // Withdraw the borrowed amount of tokens from the assetManager and send them to the borrower\n        if (!assetManagerContract.withdraw(underlying, to, amount)) revert WithdrawFailed();\n\n        // Call update locked on the userManager to lock this borrowers stakers. This function\n        // will revert if the account does not have enough vouchers to cover the borrow amount. ie\n        // the borrower is trying to borrow more than is able to be underwritten\n        IUserManager(userManager).updateLocked(msg.sender, uint96(amount + fee), true);\n\n        emit LogBorrow(msg.sender, to, amount, fee);\n    }\n```\n\nUToken's redeem() similarly always burns full `uTokenAmount` corresponding to `underlyingAmount` requested from AssetManager:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/market/UToken.sol#L707-L740\n\n```solidity\n    function redeem(uint256 amountIn, uint256 amountOut) external override whenNotPaused nonReentrant {\n        if (!accrueInterest()) revert AccrueInterestFailed();\n        if (amountIn != 0 && amountOut != 0) revert AmountZero();\n\n        uint256 exchangeRate = exchangeRateStored();\n\n        // Amount of the uToken to burn\n        uint256 uTokenAmount;\n\n        // Amount of the underlying token to redeem\n        uint256 underlyingAmount;\n\n        if (amountIn > 0) {\n            // We calculate the exchange rate and the amount of underlying to be redeemed:\n            // uTokenAmount = amountIn\n            // underlyingAmount = amountIn x exchangeRateCurrent\n            uTokenAmount = amountIn;\n            underlyingAmount = (amountIn * exchangeRate) / WAD;\n        } else {\n            // We get the current exchange rate and calculate the amount to be redeemed:\n            // uTokenAmount = amountOut / exchangeRate\n            // underlyingAmount = amountOut\n            uTokenAmount = (amountOut * WAD) / exchangeRate;\n            underlyingAmount = amountOut;\n        }\n\n        totalRedeemable -= underlyingAmount;\n        _burn(msg.sender, uTokenAmount);\n\n        IAssetManager assetManagerContract = IAssetManager(assetManager);\n        if (!assetManagerContract.withdraw(underlying, msg.sender, underlyingAmount)) revert WithdrawFailed();\n\n        emit LogRedeem(msg.sender, amountIn, amountOut, underlyingAmount);\n    }\n```\n\nSame approach is in administrative removeReserves():\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/market/UToken.sol#L770-L784\n\n```solidity\n    function removeReserves(address receiver, uint256 reduceAmount)\n        external\n        override\n        whenNotPaused\n        nonReentrant\n        onlyAdmin\n    {\n        if (!accrueInterest()) revert AccrueInterestFailed();\n\n        totalReserves -= reduceAmount;\n\n        if (!IAssetManager(assetManager).withdraw(underlying, receiver, reduceAmount)) revert WithdrawFailed();\n\n        emit LogReservesReduced(receiver, reduceAmount, totalReserves);\n    }\n```\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider:\n\n* either accounting for the actual amount withdrawn, i.e. return actual retrieved amount from withdraw(), move `IAssetManager(assetManager).withdraw` before other logic and operate this amount returned by withdraw() instead of `amount` initially requested in all the accounting logics above,\n\n* or just require in withdraw() that actual amount withdrawn be equal to the requested one.\n\nFor the second option as fee on transfer tokens aren't in the main scope for credit lines functionality UNION covers, such a requirement will mean that if the `amount` is lacking the corresponding logic needs to be run again with a smaller one. But only amount actually withdrawn be accounted for, so the discrepancies be avoided:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/asset/AssetManager.sol#L366-L369\n\n```solidity\n        emit LogWithdraw(token, account, amount, remaining);\n\n\n+       return remaining < (dustThreshold * amount) / WAD;\n-       return true;\n    }\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/11",
  "Code": [
    {
      "filename": "union-v2-contracts/contracts/asset/AssetManager.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {Controller} from \"../Controller.sol\";\nimport {IAssetManager} from \"../interfaces/IAssetManager.sol\";\nimport {IMarketRegistry} from \"../interfaces/IMarketRegistry.sol\";\nimport {IMoneyMarketAdapter} from \"../interfaces/IMoneyMarketAdapter.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/**\n *  @title AssetManager\n *  @author Union\n *  @dev  Manage the token assets deposited by components and admins, and invest\n *        tokens to the integrated underlying lending protocols.\n */\ncontract AssetManager is Controller, ReentrancyGuardUpgradeable, IAssetManager {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Address of market registry\n     */\n    address public marketRegistry;\n\n    /**\n     * @dev Withdraw Seuqence\n     * @dev Priority sequence of money market indices for processing withdraws\n     */\n    uint256[] public withdrawSeq;\n\n    /**\n     * @dev Record admin or userManager balance\n     * @dev Maps user to token to balance\n     */\n    mapping(address => mapping(address => uint256)) public balances;\n\n    /**\n     * @dev Total balance of a token\n     * @dev Maps token to balance (deposited)\n     */\n    mapping(address => uint256) public totalPrincipal;\n\n    /**\n     * @dev Supported markets\n     * @dev Mapping of tokens to boolean (isSupported)\n     */\n    mapping(address => bool) public supportedMarkets;\n\n    /**\n     * @dev Money Market Adapters\n     */\n    IMoneyMarketAdapter[] public moneyMarkets;\n\n    /**\n     * @dev Supported tokens\n     */\n    address[] public supportedTokensList;\n\n    /* -------------------------------------------------------------------\n      Events \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Emit when making a deposit\n     *  @param token Depositing token address\n     *  @param account Account address\n     *  @param amount Deposit amount, in wei\n     */\n    event LogDeposit(address indexed token, address indexed account, uint256 amount);\n    /**\n     *  @dev Emit when withdrawing from AssetManager\n     *  @param token Depositing token address\n     *  @param account Account address\n     *  @param amount Withdraw amount, in wei\n     *  @param remaining The amount cannot be withdrawn\n     */\n    event LogWithdraw(address indexed token, address indexed account, uint256 amount, uint256 remaining);\n    /**\n     *  @dev Emit when rebalancing among the integrated money markets\n     *  @param tokenAddress The address of the token to be rebalanced\n     *  @param percentages Array of the percentages of the tokens to deposit to the money markets\n     */\n    event LogRebalance(address tokenAddress, uint256[] percentages);\n\n    /* -------------------------------------------------------------------\n      Errors \n    ------------------------------------------------------------------- */\n\n    error UnsupportedToken();\n    error AuthFailed();\n    error NotParity();\n    error AmountZero();\n    error InsufficientBalance();\n    error TokenExists();\n\n    /* -------------------------------------------------------------------\n      Constructor/Initializer \n    ------------------------------------------------------------------- */\n\n    function __AssetManager_init(address _marketRegistry) external initializer {\n        Controller.__Controller_init(msg.sender);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        marketRegistry = _marketRegistry;\n    }\n\n    /* -------------------------------------------------------------------\n      Modifiers \n    ------------------------------------------------------------------- */\n\n    modifier checkMarketSupported(address token) {\n        if (!isMarketSupported(token)) revert UnsupportedToken();\n        _;\n    }\n\n    modifier onlyAuth(address token) {\n        if (!(_isUToken(msg.sender, token) || _isUserManager(msg.sender, token))) revert AuthFailed();\n        _;\n    }\n\n    /* -------------------------------------------------------------------\n      Setters \n    ------------------------------------------------------------------- */\n\n    function setMarketRegistry(address _marketRegistry) external onlyAdmin {\n        marketRegistry = _marketRegistry;\n    }\n\n    /**\n     *  @dev Set withdraw sequence\n     *  @param newSeq priority sequence of money market indices to be used while withdrawing\n     */\n    function setWithdrawSequence(uint256[] calldata newSeq) external override onlyAdmin {\n        if (newSeq.length != withdrawSeq.length) revert NotParity();\n        withdrawSeq = newSeq;\n    }\n\n    /* -------------------------------------------------------------------\n      View Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Get the balance of asset manager, plus the total amount of tokens deposited to all the underlying lending protocols\n     *  @param tokenAddress ERC20 token address\n     *  @return Pool balance\n     */\n    function getPoolBalance(address tokenAddress) public view override returns (uint256) {\n        IERC20Upgradeable poolToken = IERC20Upgradeable(tokenAddress);\n        uint256 balance = poolToken.balanceOf(address(this));\n        if (isMarketSupported(tokenAddress)) {\n            return totalSupplyView(tokenAddress) + balance;\n        } else {\n            return balance;\n        }\n    }\n\n    /**\n     *  @dev Returns the amount of the lending pool balance minus the amount of total staked.\n     *  @param tokenAddress ERC20 token address\n     *  @return loanAmount Amount can be borrowed\n     */\n    function getLoanableAmount(address tokenAddress) public view override returns (uint256) {\n        uint256 poolBalance = getPoolBalance(tokenAddress);\n        return poolBalance > totalPrincipal[tokenAddress] ? poolBalance - totalPrincipal[tokenAddress] : 0;\n    }\n\n    /**\n     *  @dev Get the total amount of tokens deposited to all the integrated underlying protocols without side effects.\n     *  @param tokenAddress ERC20 token address\n     *  @return tokenSupply Total market balance\n     */\n    function totalSupply(address tokenAddress) external override returns (uint256) {\n        uint256 tokenSupply = 0;\n        if (isMarketSupported(tokenAddress)) {\n            uint256 moneyMarketsLength = moneyMarkets.length;\n            for (uint256 i = 0; i < moneyMarketsLength; i++) {\n                if (moneyMarkets[i].supportsToken(tokenAddress)) {\n                    tokenSupply += moneyMarkets[i].getSupply(tokenAddress);\n                }\n            }\n        }\n        return tokenSupply;\n    }\n\n    /**\n     *  @dev Get the total amount of tokens deposited to all the integrated underlying protocols, but without side effects. Safe to call anytime, but may not get the most updated number for the current block. Call totalSupply() for that purpose.\n     *  @param tokenAddress ERC20 token address\n     *  @return tokenSupply Total market balance\n     */\n    function totalSupplyView(address tokenAddress) public view override returns (uint256) {\n        uint256 tokenSupply = 0;\n        if (isMarketSupported(tokenAddress)) {\n            uint256 moneyMarketsLength = moneyMarkets.length;\n            for (uint256 i = 0; i < moneyMarketsLength; i++) {\n                if (moneyMarkets[i].supportsToken(tokenAddress)) {\n                    tokenSupply += moneyMarkets[i].getSupplyView(tokenAddress);\n                }\n            }\n        }\n        return tokenSupply;\n    }\n\n    /**\n     *  @dev Check if there is an underlying protocol available for the given ERC20 token.\n     *  @param tokenAddress ERC20 token address\n     *  @return Whether is supported\n     */\n    function isMarketSupported(address tokenAddress) public view override returns (bool) {\n        return supportedMarkets[tokenAddress];\n    }\n\n    /**\n     *  @dev Get the number of supported underlying protocols.\n     *  @return MoneyMarkets length\n     */\n    function moneyMarketsCount() external view override returns (uint256) {\n        return moneyMarkets.length;\n    }\n\n    /**\n     *  @dev Get the count of supported tokens\n     *  @return Number of supported tokens\n     */\n    function supportedTokensCount() external view override returns (uint256) {\n        return supportedTokensList.length;\n    }\n\n    /**\n     *  @dev Get the supported lending protocol\n     *  @param tokenAddress ERC20 token address\n     *  @param marketId MoneyMarkets array index\n     *  @return rate tokenSupply, rate(compound is supplyRatePerBlock 1e18, aave is supplyRatePerYear 1e27)\n     */\n    function getMoneyMarket(address tokenAddress, uint256 marketId)\n        external\n        view\n        override\n        returns (uint256 rate, uint256 tokenSupply)\n    {\n        rate = moneyMarkets[marketId].getRate(tokenAddress);\n        tokenSupply += moneyMarkets[marketId].getSupplyView(tokenAddress);\n    }\n\n    /* -------------------------------------------------------------------\n      Core Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev  Deposit tokens to AssetManager, and those tokens will be passed along to\n     *        adapters to deposit to integrated asset protocols if any is available.\n     *  @param token ERC20 token address\n     *  @param amount ERC20 token address\n     *  @return Deposited amount\n     */\n    function deposit(address token, uint256 amount)\n        external\n        override\n        whenNotPaused\n        onlyAuth(token)\n        nonReentrant\n        returns (bool)\n    {\n        IERC20Upgradeable poolToken = IERC20Upgradeable(token);\n        if (amount == 0) revert AmountZero();\n\n        if (!_isUToken(msg.sender, token)) {\n            balances[msg.sender][token] += amount;\n            totalPrincipal[token] += amount;\n        }\n\n        bool remaining = true;\n        if (isMarketSupported(token)) {\n            uint256 moneyMarketsLength = moneyMarkets.length;\n            // assumption: markets are arranged in order of decreasing liquidity\n            // iterate markets till floors are filled\n            // floors define minimum amount to maintain confidence in liquidity\n            for (uint256 i = 0; i < moneyMarketsLength && remaining; i++) {\n                IMoneyMarketAdapter moneyMarket = moneyMarkets[i];\n\n                if (!moneyMarket.supportsToken(token)) continue;\n                if (moneyMarket.floorMap(token) <= moneyMarket.getSupply(token)) continue;\n\n                poolToken.safeTransferFrom(msg.sender, address(moneyMarket), amount);\n                moneyMarket.deposit(token);\n                remaining = false;\n            }\n\n            // assumption: less liquid markets provide more yield\n            // iterate markets in reverse to optimize for yield\n            // do this only if floors are filled i.e. min liquidity satisfied\n            // deposit in the market where ceiling is not being exceeded\n            for (uint256 j = moneyMarketsLength; j > 0 && remaining; j--) {\n                IMoneyMarketAdapter moneyMarket = moneyMarkets[j - 1];\n                if (!moneyMarket.supportsToken(token)) continue;\n\n                uint256 supply = moneyMarket.getSupply(token);\n                uint256 ceiling = moneyMarket.ceilingMap(token);\n                if (supply + amount > ceiling) continue;\n\n                poolToken.safeTransferFrom(msg.sender, address(moneyMarket), amount);\n                moneyMarket.deposit(token);\n                remaining = false;\n            }\n        }\n\n        if (remaining) {\n            poolToken.safeTransferFrom(msg.sender, address(this), amount);\n        }\n\n        emit LogDeposit(token, msg.sender, amount);\n\n        return true;\n    }\n\n    /**\n     *  @dev Withdraw from AssetManager\n     *  @param token ERC20 token address\n     *  @param account User address\n     *  @param amount ERC20 token address\n     *  @return Withdraw amount\n     */\n    function withdraw(\n        address token,\n        address account,\n        uint256 amount\n    ) external override whenNotPaused nonReentrant onlyAuth(token) returns (bool) {\n        if (!_checkSenderBalance(msg.sender, token, amount)) revert InsufficientBalance();\n\n        uint256 remaining = amount;\n\n        // If there are tokens in Asset Manager then transfer them on priority\n        uint256 selfBalance = IERC20Upgradeable(token).balanceOf(address(this));\n        if (selfBalance > 0) {\n            uint256 withdrawAmount = selfBalance < remaining ? selfBalance : remaining;\n            remaining -= withdrawAmount;\n            IERC20Upgradeable(token).safeTransfer(account, withdrawAmount);\n        }\n\n        if (isMarketSupported(token)) {\n            uint256 withdrawSeqLength = withdrawSeq.length;\n            // iterate markets according to defined sequence and withdraw\n            for (uint256 i = 0; i < withdrawSeqLength && remaining > 0; i++) {\n                IMoneyMarketAdapter moneyMarket = moneyMarkets[withdrawSeq[i]];\n                if (!moneyMarket.supportsToken(token)) continue;\n\n                uint256 supply = moneyMarket.getSupply(token);\n                if (supply == 0) continue;\n\n                uint256 withdrawAmount = supply < remaining ? supply : remaining;\n                remaining -= withdrawAmount;\n                moneyMarket.withdraw(token, account, withdrawAmount);\n            }\n        }\n\n        if (!_isUToken(msg.sender, token)) {\n            balances[msg.sender][token] = balances[msg.sender][token] - amount + remaining;\n            totalPrincipal[token] = totalPrincipal[token] - amount + remaining;\n        }\n\n        emit LogWithdraw(token, account, amount, remaining);\n\n        return true;\n    }\n\n    /**\n     * @dev Write of Debt\n     */\n    function debtWriteOff(address token, uint256 amount) external override {\n        if (balances[msg.sender][token] < amount) revert InsufficientBalance();\n        balances[msg.sender][token] -= amount;\n        totalPrincipal[token] -= amount;\n    }\n\n    /**\n     *  @dev Add a new ERC20 token to support in AssetManager\n     *  @param tokenAddress ERC20 token address\n     */\n    function addToken(address tokenAddress) external override onlyAdmin {\n        if (supportedMarkets[tokenAddress]) revert TokenExists();\n        supportedTokensList.push(tokenAddress);\n        supportedMarkets[tokenAddress] = true;\n\n        approveAllMarketsMax(tokenAddress);\n    }\n\n    /**\n     *  @dev Remove a ERC20 token to support in AssetManager\n     *  @param tokenAddress ERC20 token address\n     */\n    function removeToken(address tokenAddress) external override onlyAdmin {\n        bool isExist = false;\n        uint256 index;\n        uint256 supportedTokensLength = supportedTokensList.length;\n\n        for (uint256 i = 0; i < supportedTokensLength; i++) {\n            if (tokenAddress == address(supportedTokensList[i])) {\n                isExist = true;\n                index = i;\n                break;\n            }\n        }\n\n        if (isExist) {\n            supportedTokensList[index] = supportedTokensList[supportedTokensLength - 1];\n            supportedTokensList.pop();\n            supportedMarkets[tokenAddress] = false;\n        }\n    }\n\n    /**\n     *  @dev Add a new adapter for the underlying lending protocol\n     *  @param adapterAddress adapter address\n     */\n    function addAdapter(address adapterAddress) external override onlyAdmin {\n        bool isExist = false;\n        uint256 moneyMarketsLength = moneyMarkets.length;\n\n        for (uint256 i = 0; i < moneyMarketsLength; i++) {\n            if (adapterAddress == address(moneyMarkets[i])) isExist = true;\n        }\n\n        if (!isExist) {\n            moneyMarkets.push(IMoneyMarketAdapter(adapterAddress));\n            withdrawSeq.push(moneyMarkets.length - 1);\n        }\n\n        approveAllTokensMax(adapterAddress);\n    }\n\n    /**\n     *  @dev Remove a adapter for the underlying lending protocol\n     *  @param adapterAddress adapter address\n     */\n    function removeAdapter(address adapterAddress) external override onlyAdmin {\n        bool isExist = false;\n        uint256 index;\n        uint256 moneyMarketsLength = moneyMarkets.length;\n\n        for (uint256 i = 0; i < moneyMarketsLength; i++) {\n            if (adapterAddress == address(moneyMarkets[i])) {\n                isExist = true;\n                index = i;\n                break;\n            }\n        }\n\n        if (isExist) {\n            moneyMarkets[index] = moneyMarkets[moneyMarketsLength - 1];\n            moneyMarkets.pop();\n        }\n    }\n\n    /**\n     *  @dev For a give token set allowance for all integrated money markets\n     *  @param tokenAddress ERC20 token address\n     */\n    function approveAllMarketsMax(address tokenAddress) public override onlyAdmin {\n        IERC20Upgradeable poolToken = IERC20Upgradeable(tokenAddress);\n        uint256 moneyMarketsLength = moneyMarkets.length;\n        for (uint256 i = 0; i < moneyMarketsLength; i++) {\n            poolToken.safeApprove(address(moneyMarkets[i]), 0);\n            poolToken.safeApprove(address(moneyMarkets[i]), type(uint256).max);\n        }\n    }\n\n    /**\n     *  @dev For a give moeny market set allowance for all underlying tokens\n     *  @param adapterAddress Address of adaptor for money market\n     */\n    function approveAllTokensMax(address adapterAddress) public override onlyAdmin {\n        uint256 supportedTokensLength = supportedTokensList.length;\n        for (uint256 i = 0; i < supportedTokensLength; i++) {\n            IERC20Upgradeable poolToken = IERC20Upgradeable(supportedTokensList[i]);\n            poolToken.safeApprove(adapterAddress, 0);\n            poolToken.safeApprove(adapterAddress, type(uint256).max);\n        }\n    }\n\n    /**\n     * @dev Take all the supply of `tokenAddress` and redistribute it according to `percentages`.\n     *\n     * Rejects if the token is not supported.\n     *\n     * @param tokenAddress Address of the token that is going to be rebalanced\n     * @param percentages A list of percentages, expressed as units in 10000, indicating how to deposit the tokens in\n     * each underlying money market. The length of this array is one less than the amount of money markets: the last\n     * money market will receive the remaining tokens. For example, if there are 3 money markets, and you want to\n     * rebalance so that the first one has 10.5% of the tokens, the second one 55%, and the third one 34.5%, this param\n     * will be [1050, 5500].\n     */\n    function rebalance(address tokenAddress, uint256[] calldata percentages)\n        external\n        override\n        onlyAdmin\n        checkMarketSupported(tokenAddress)\n    {\n        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n        uint256 moneyMarketsLength = moneyMarkets.length;\n        uint256 percentagesLength = percentages.length;\n\n        IMoneyMarketAdapter[] memory supportedMoneyMarkets = new IMoneyMarketAdapter[](moneyMarketsLength);\n        uint256 supportedMoneyMarketsSize;\n\n        // Loop through each money market and withdraw all the tokens\n        for (uint256 i = 0; i < moneyMarketsLength; i++) {\n            IMoneyMarketAdapter moneyMarket = moneyMarkets[i];\n            if (!moneyMarket.supportsToken(tokenAddress)) continue;\n            moneyMarket.withdrawAll(tokenAddress, address(this));\n\n            supportedMoneyMarkets[supportedMoneyMarketsSize] = moneyMarket;\n            supportedMoneyMarketsSize++;\n        }\n\n        if (percentagesLength + 1 != supportedMoneyMarketsSize) revert NotParity();\n\n        uint256 tokenSupply = token.balanceOf(address(this));\n\n        for (uint256 i = 0; i < percentagesLength; i++) {\n            IMoneyMarketAdapter moneyMarket = supportedMoneyMarkets[i];\n            uint256 amountToDeposit = (tokenSupply * percentages[i]) / 10000;\n            if (amountToDeposit == 0) continue;\n            token.safeTransfer(address(moneyMarket), amountToDeposit);\n            moneyMarket.deposit(tokenAddress);\n        }\n\n        uint256 remainingTokens = token.balanceOf(address(this));\n\n        IMoneyMarketAdapter lastMoneyMarket = supportedMoneyMarkets[supportedMoneyMarketsSize - 1];\n        if (remainingTokens > 0) {\n            token.safeTransfer(address(lastMoneyMarket), remainingTokens);\n            lastMoneyMarket.deposit(tokenAddress);\n        }\n\n        emit LogRebalance(tokenAddress, percentages);\n    }\n\n    /* -------------------------------------------------------------------\n      Internal Functions \n    ------------------------------------------------------------------- */\n\n    function _checkSenderBalance(\n        address sender,\n        address tokenAddress,\n        uint256 amount\n    ) private view returns (bool) {\n        if (_isUToken(sender, tokenAddress)) {\n            // For all the lending markets, which have no deposits, return the tokens from the pool\n            return getLoanableAmount(tokenAddress) >= amount;\n        }\n\n        return balances[sender][tokenAddress] >= amount;\n    }\n\n    function _isUToken(address sender, address token) private view returns (bool) {\n        return IMarketRegistry(marketRegistry).uTokens(token) == sender;\n    }\n\n    function _isUserManager(address sender, address token) private view returns (bool) {\n        return IMarketRegistry(marketRegistry).userManagers(token) == sender;\n    }\n}"
    },
    {
      "filename": "union-v2-contracts/contracts/user/UserManager.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {Controller} from \"../Controller.sol\";\nimport {IAssetManager} from \"../interfaces/IAssetManager.sol\";\nimport {IUserManager} from \"../interfaces/IUserManager.sol\";\nimport {IComptroller} from \"../interfaces/IComptroller.sol\";\nimport {IUnionToken} from \"../interfaces/IUnionToken.sol\";\nimport {IUToken} from \"../interfaces/IUToken.sol\";\n\n/**\n * @title UserManager Contract\n * @dev Manages the Union members stake and vouches.\n */\ncontract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /* -------------------------------------------------------------------\n      Types \n    ------------------------------------------------------------------- */\n\n    struct Vouch {\n        // staker recieveing the vouch\n        address staker;\n        // trust amount\n        uint96 trust;\n        // amount of stake locked by this vouch\n        uint96 locked;\n        // block number of last update\n        uint64 lastUpdated;\n    }\n\n    struct Staker {\n        bool isMember;\n        uint96 stakedAmount;\n        uint96 locked;\n    }\n\n    struct Index {\n        bool isSet;\n        uint128 idx;\n    }\n\n    struct Vouchee {\n        address borrower;\n        uint96 voucherIndex;\n    }\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Max amount that can be staked of the staking token\n     */\n    uint96 public maxStakeAmount;\n\n    /**\n     *  @dev The staking token that is staked in the comptroller\n     */\n    address public stakingToken;\n\n    /**\n     *  @dev Address of the UNION token contract\n     */\n    address public unionToken;\n\n    /**\n     *  @dev Address of the asset manager contract\n     */\n    address public assetManager;\n\n    /**\n     *  @dev uToken contract\n     */\n    IUToken public uToken;\n\n    /**\n     *  @dev Comptroller contract\n     */\n    IComptroller public comptroller;\n\n    /**\n     * @dev Number of vouches needed to become a member\n     */\n    uint256 public effectiveCount;\n\n    /**\n     *  @dev New member fee\n     */\n    uint256 public newMemberFee;\n\n    /**\n     *  @dev Total amount of staked staked token\n     */\n    uint256 public totalStaked;\n\n    /**\n     *  @dev Total amount of stake frozen\n     */\n    uint256 public totalFrozen;\n\n    /**\n     *  @dev Max blocks can be overdue for\n     */\n    uint256 public maxOverdueBlocks;\n\n    /**\n     * @dev Max voucher limit\n     */\n    uint256 public maxVouchers;\n\n    /**\n     *  @dev Union Stakers\n     */\n    mapping(address => Staker) public stakers;\n\n    /**\n     *  @dev Staker (borrower) mapped to recieved vouches (staker)\n     */\n    mapping(address => Vouch[]) public vouchers;\n\n    /**\n     * @dev Borrower mapped to Staker mapped to index in vouchers array\n     */\n    mapping(address => mapping(address => Index)) public voucherIndexes;\n\n    /**\n     *  @dev Staker (staker) mapped to vouches given (borrower)\n     */\n    mapping(address => Vouchee[]) public vouchees;\n\n    /**\n     * @dev Borrower mapped to Staker mapped to index in vochee array\n     */\n    mapping(address => mapping(address => Index)) public voucheeIndexes;\n\n    /**\n     * @dev Stakers frozen amounts\n     */\n    mapping(address => uint256) public memberFrozen;\n\n    /* -------------------------------------------------------------------\n      Errors \n    ------------------------------------------------------------------- */\n\n    error AuthFailed();\n    error ErrorSelfVouching();\n    error TrustAmountLtLocked();\n    error NoExistingMember();\n    error NotEnoughStakers();\n    error StakeLimitReached();\n    error AssetManagerDepositFailed();\n    error AssetManagerWithdrawFailed();\n    error InsufficientBalance();\n    error LockedStakeNonZero();\n    error NotOverdue();\n    error ExceedsLocked();\n    error AmountZero();\n    error LockedRemaining();\n    error VoucherNotFound();\n    error VouchWhenOverdue();\n    error MaxVouchees();\n    error InvalidParams();\n\n    /* -------------------------------------------------------------------\n      Events \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Add new member event\n     *  @param member New member address\n     */\n    event LogAddMember(address member);\n\n    /**\n     *  @dev Update vouch for existing member event\n     *  @param staker Trustee address\n     *  @param borrower The address gets vouched for\n     *  @param trustAmount Vouch amount\n     */\n    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);\n\n    /**\n     *  @dev New member application event\n     *  @param account New member's voucher address\n     *  @param borrower New member address\n     */\n    event LogRegisterMember(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Cancel vouching for other member event\n     *  @param account New member's voucher address\n     *  @param borrower The address gets vouched for\n     */\n    event LogCancelVouch(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Stake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to stake\n     */\n    event LogStake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev Unstake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to unstake\n     */\n    event LogUnstake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev DebtWriteOff event\n     *  @param staker The staker's address\n     *  @param borrower The borrower's address\n     *  @param amount The amount of write off\n     */\n    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);\n\n    /**\n     *  @dev set utoken address\n     *  @param uToken new uToken address\n     */\n    event LogSetUToken(address uToken);\n\n    /**\n     *  @dev set new member fee\n     *  @param oldMemberFee old member fee\n     *  @param newMemberFee new member fee\n     */\n    event LogSetNewMemberFee(uint256 oldMemberFee, uint256 newMemberFee);\n\n    /**\n     *  @dev set max stake amount\n     *  @param oldMaxStakeAmount Old amount\n     *  @param newMaxStakeAmount New amount\n     */\n    event LogSetMaxStakeAmount(uint256 oldMaxStakeAmount, uint256 newMaxStakeAmount);\n\n    /**\n     *  @dev set max overdue blocks\n     *  @param oldMaxOverdueBlocks Old value\n     *  @param newMaxOverdueBlocks New value\n     */\n    event LogSetMaxOverdueBlocks(uint256 oldMaxOverdueBlocks, uint256 newMaxOverdueBlocks);\n\n    /**\n     *  @dev set effective count\n     *  @param oldEffectiveCount Old value\n     *  @param newEffectiveCount New value\n     */\n    event LogSetEffectiveCount(uint256 oldEffectiveCount, uint256 newEffectiveCount);\n\n    /**\n     * @dev Set max voucher\n     * @param maxVouchers new max voucher limit\n     */\n    event LogSetMaxVouchers(uint256 maxVouchers);\n\n    /* -------------------------------------------------------------------\n      Constructor/Initializer \n    ------------------------------------------------------------------- */\n\n    function __UserManager_init(\n        address assetManager_,\n        address unionToken_,\n        address stakingToken_,\n        address comptroller_,\n        address admin_,\n        uint256 maxOverdueBlocks_,\n        uint256 effectiveCount_,\n        uint256 maxVouchers_\n    ) public initializer {\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        comptroller = IComptroller(comptroller_);\n        assetManager = assetManager_;\n        unionToken = unionToken_;\n        stakingToken = stakingToken_;\n        newMemberFee = 1 ether;\n        maxStakeAmount = 10_000e18;\n        maxOverdueBlocks = maxOverdueBlocks_;\n        effectiveCount = effectiveCount_;\n        maxVouchers = maxVouchers_;\n    }\n\n    /* -------------------------------------------------------------------\n      Modifiers \n    ------------------------------------------------------------------- */\n\n    modifier onlyMember(address account) {\n        if (!checkIsMember(account)) revert AuthFailed();\n        _;\n    }\n\n    modifier onlyMarket() {\n        if (address(uToken) != msg.sender) revert AuthFailed();\n        _;\n    }\n\n    modifier onlyComptroller() {\n        if (address(comptroller) != msg.sender) revert AuthFailed();\n        _;\n    }\n\n    /* -------------------------------------------------------------------\n      Setters \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Set the max amount that a user can stake\n     * Emits {LogSetMaxStakeAmount} event\n     * @param maxStakeAmount_ The max stake amount\n     */\n    function setMaxStakeAmount(uint96 maxStakeAmount_) external onlyAdmin {\n        uint96 oldMaxStakeAmount = maxStakeAmount;\n        maxStakeAmount = maxStakeAmount_;\n        emit LogSetMaxStakeAmount(uint256(oldMaxStakeAmount), uint256(maxStakeAmount));\n    }\n\n    /**\n     * @dev set the UToken contract address\n     * Emits {LogSetUToken} event\n     * @param uToken_ UToken contract address\n     */\n    function setUToken(address uToken_) external onlyAdmin {\n        uToken = IUToken(uToken_);\n        emit LogSetUToken(uToken_);\n    }\n\n    /**\n     * @dev set New Member fee\n     * @dev The amount of UNION an account must burn to become a member\n     * Emits {LogSetNewMemberFee} event\n     * @param amount New member fee amount\n     */\n    function setNewMemberFee(uint256 amount) external onlyAdmin {\n        uint256 oldMemberFee = newMemberFee;\n        newMemberFee = amount;\n        emit LogSetNewMemberFee(oldMemberFee, amount);\n    }\n\n    /**\n     * @dev set New max overdue blocks\n     * Emits {LogSetMaxOverdueBlocks} event\n     * @param _maxOverdueBlocks New maxOverdueBlocks value\n     */\n    function setMaxOverdueBlocks(uint256 _maxOverdueBlocks) external onlyAdmin {\n        uint256 oldMaxOverdueBlocks = maxOverdueBlocks;\n        maxOverdueBlocks = _maxOverdueBlocks;\n        emit LogSetMaxOverdueBlocks(oldMaxOverdueBlocks, _maxOverdueBlocks);\n    }\n\n    /**\n     * @dev set New effective count\n     * @dev this is the number of vouches an account needs in order\n     *      to register as a member\n     * Emits {LogSetEffectiveCount} event\n     * @param _effectiveCount New effectiveCount value\n     */\n    functi"
    }
  ]
}