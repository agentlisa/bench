{
  "Title": "H-6: Protocol unable to get extra Rewards in OCY_Convex_C",
  "Content": "# Issue H-6: Protocol unable to get extra Rewards in OCY_Convex_C \n\nSource: https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/477 \n\n## Found by \nBoRonGod, cergyk\n## Summary\n\nConvex would wrap `rewardToken` for pools with IDs 151+, but the counting logic in `OCY_Convex_C.sol` makes it impossible for zivoe to forward yield.\n\n## Vulnerability Detail\n\nIn `OCY_Convex_C.sol `, A convex pool with id `270` is used: \n\n    /// @dev Convex information.\n    address public convexDeposit = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31;\n    address public convexPoolToken = 0x383E6b4437b59fff47B619CBA855CA29342A8559;\n    address public convexRewards = 0xc583e81bB36A1F620A804D8AF642B63b0ceEb5c0;\n\n    uint256 public convexPoolID = 270;\n\nIn the following logic, `rewardContract` is defaulted to the address of extraRewards. This assumption is fine for pools with PoolId < 150, but would not work for IDs 151+.\n\n    /// @notice Claims rewards and forward them to the OCT_YDL.\n    /// @param extra Flag for claiming extra rewards.\n    function claimRewards(bool extra) public nonReentrant {\n        IBaseRewardPool_OCY_Convex_C(convexRewards).getReward();\n\n        // Native Rewards (CRV, CVX)\n        uint256 rewardsCRV = IERC20(CRV).balanceOf(address(this));\n        uint256 rewardsCVX = IERC20(CVX).balanceOf(address(this));\n        if (rewardsCRV > 0) { IERC20(CRV).safeTransfer(OCT_YDL, rewardsCRV); }\n        if (rewardsCVX > 0) { IERC20(CVX).safeTransfer(OCT_YDL, rewardsCVX); }\n\n        // Extra Rewards\n        if (extra) {\n            uint256 extraRewardsLength = IBaseRewardPool_OCY_Convex_C(convexRewards).extraRewardsLength();\n            for (uint256 i = 0; i < extraRewardsLength; i++) {\n                address rewardContract = IBaseRewardPool_OCY_Convex_C(convexRewards).extraRewards(i); \n                //@Audit incorrect here!\n                uint256 rewardAmount = IBaseRewardPool_OCY_Convex_C(rewardContract).rewardToken().balanceOf(address(this));\n                if (rewardAmount > 0) { IERC20(rewardContract).safeTransfer(OCT_YDL, rewardAmount); }\n            }\n        }\n    }\n\n\nAccording to [convex doc](https://docs.convexfinance.com/convexfinanceintegration/baserewardpool#:~:text=Important%20for%20pools,wrappers/ConvexStakingWrapper.sol), \n\n> for pools with IDs 151+:\n> VirtualBalanceRewardPool's rewardToken points to a wrapped version of the underlying token.  This Token implementation can be found here: https://github.com/convex-eth/platform/blob/main/contracts/contracts/StashTokenWrapper.sol\n\nJust check `convexRewards` of pool 270: \n\nhttps://etherscan.io/address/0xc583e81bB36A1F620A804D8AF642B63b0ceEb5c0#readContract#F5\n\nFor index 0, it returns a [`VirtualBalanceRewardPool`](https://etherscan.io/address/0x22A0a706Aa423E2257e4217be2268e0374b9229f) with [rewardtoken](https://etherscan.io/address/0xc583e81bB36A1F620A804D8AF642B63b0ceEb5c0#readContract#F19) = 0x85D81Ee851D36423A5784CD3Cb6f1a1193Cb5978. This contract is a `StashTokenWrapper`, which is consistent with what the convex documentation says.\n\nAnd, when `IBaseRewardPool_OCY_Convex_C(convexRewards).getReward();` is triggered, reward tokens will be unwrapped and send to caller, so rewardAmount will always return 0, means such yield cannot be claimed for zivoe.\n\n                address rewardContract = IBaseRewardPool_OCY_Convex_C(convexRewards).extraRewards(i); \n\n                //@Audit incorrect here! `rewardToken` is a `StashTokenWrapper`, not the reward token!\n\n                uint256 rewardAmount = IBaseRewardPool_OCY_Convex_C(rewardContract).rewardToken().balanceOf(address(this));\n                if (rewardAmount > 0) { IERC20(rewardContract).safeTransfer(OCT_YDL, rewardAmount); }\n\n## Impact\n\nUsers will lose extra rewards from convex pools with IDs 151+.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-03-zivoe/blob/main/zivoe-core-foundry/src/lockers/OCY/OCY_Convex_C.sol#L210-L219\nhttps://docs.convexfinance.com/convexfinanceintegration/baserewardpool\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the logic above to:\n\n                uint256 rewardAmount = IBaseRewardPool_OCY_Convex_C(rewardContract).rewardToken().token().balanceOf(address(this));\n                if (rewardAmount > 0) { IERC20(rewardContract).safeTransfer(OCT_YDL, rewardAmount); }\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> high, loss of additional reward from convex. Since it accumulates over 30-days period, the loss will be significant. Both `balanceOf` and `safeTransfer` are incorrect - they should be called on `rewardToken().token()`. Different dups of this mention either `balanceOf` or `safeTransfer`, #294 mentions both (but this one is more detailed), but I consider them to be the same root cause, so all are dups.\n\n\n\n**RealLTDingZhen**\n\nescalate \n\nI would escalate this to a solo issue.\n\nLets compare this one with #479 (and all current dups):\n\n#477 only works with convex pool id 151+ , so only `OCY_Convex_C` is affected.\n#479 works with ALL three `OCY_Convex`.\n\n#477 points out a incorrect external call with convex's `StashTokenWrapper`.\n#479 points out a incorrect external call with convex's `VirtualBalanceRewardPool`.\n\n#477 and #479 have different fixes. The fix for one cannot fix the other.\n\n#477 and #479 have different impacts. \n\n- If we fix 479 , In 477 , claimRewards will still not forward any extrareward to YDL.\n- If we fix 477 , In 479 , claimRewards will still always revert.\n\n#477 and #479 happens on different lines in `OCY_Convex_C`, with different external calls.\n\n    //#477 root cause: convex would wrap rewards into a StashTokenWrapper\n    uint256 rewardAmount = IBaseRewardPool_OCY_Convex_C(rewardContract).rewardToken().balanceOf(address(this));\n\n    //#479 and all dups root cause: convex rewardContract is a VirtualBalanceRewardPool\n    if (rewardAmount > 0) { IERC20(rewardContract).safeTransfer(OCT_YDL, rewardAmount); }\n\nSo, why should we duplicate two valid issues **when they have different root causes, different fixes, different impacts, and the root cause of both issues do not have any code reuse?**\n\nI believe Lead judge's statement \n\n> The core reason is still incorrect address for these functions.\n\nshould not be the reason to duplicate this issue. These two different incorrect addresses are obtained through different improper external calls towards different external contracts. I don't understand why this issue was considered as dup of #479.\n\n\n\n\n**sherlock-admin3**\n\n> escalate \n> \n> I would escalate this to a solo issue.\n> \n> Lets compare this one with #479 (and all current dups):\n> \n> #477 only works with convex pool id 151+ , so only `OCY_Convex_C` is affected.\n> #479 works with ALL three `OCY_Convex`.\n> \n> #477 points out a incorrect external call with convex's `StashTokenWrapper`.\n> #479 points out a incorrect external call with convex's `VirtualBalanceRewardPool`.\n> \n> #477 and #479 have different fixes. The fix for one cannot fix the other.\n> \n> #477 and #479 have different impacts. \n> \n> - If we fix 479 , In 477 , claimRewards will still not forward any extrareward to YDL.\n> - If we fix 477 , In 479 , claimRewards will still always revert.\n> \n> #477 and #479 happens on different lines in `OCY_Convex_C`, with different external calls.\n> \n>     //#477 root cause: convex would wrap rewards into a StashTokenWrapper\n>     uint256 rewardAmount = IBaseRewardPool_OCY_Convex_C(rewardContract).rewardToken().balanceOf(address(this));\n> \n>     //#479 and all dups root cause: convex rewardContract is a VirtualBalanceRewardPool\n>     if (rewardAmount > 0) { IERC20(rewardContract).safeTransfer(OCT_YDL, rewardAmount); }\n> \n> So, why should we duplicate two valid issues **when they have different root causes, different fixes, different impacts, and the root cause of both issues do not have any code reuse?**\n> \n> I believe Lead judge's statement \n> \n> > The core reason is still incorrect address for these functions.\n> \n> should not be the reason to duplicate this issue. These two different incorrect addresses are obtained through different improper external calls towards different external contracts. I don't understand why this issue was considered as dup of #479.\n> \n> \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**panprog**\n\nThe core reason is still incorrect address for these functions. The fix is different for different contracts, some issues describe it in more details, some in less. Since `balanceOf` and `transfer` have to happen on the same address, I don't think separate issues for `balanceOf` or `transfer` warrant it being a separate group. The same with _A or _C - it's basically the same, even if the fix in each of them is different.\nI agree that your issue describes everything much better and the recommendation is more correct compared to dups, but still the core reason is the same. If these nuances warrant a separate group - this will have to be decided by Sherlock. I keep my decision here.\n\nAs for the severity: DAO can't pull these tokens, because the only function to pull tokens is overriden for this locker and only allows to pull convex pool token and nothing else.\n\n**pseudonaut**\n\nI'm confused by the final recommendation for fixes here, can someone provide detailed explanation of fixes for appropriate contracts based on all findings?\n\n**panprog**\n\n> I'm confused by the final recommendation for fixes here, can someone provide detailed explanation of fixes for appropriate contracts based on all findings?\n\n@pseudonaut , the address of the extra reward token is:\n- for convex pools < 151 (OCY_Convex_A): `address = IBaseRewardPool_OCY_Convex_A(rewardContract).rewardToken()`\n- for convex pools >= 151 (OCY_Convex_C): `address = IBaseRewardPool_OCY_Convex_A(rewardContract).rewardToken().token()` (you'll need to add token() in the reward token interface)\n\nBoth `balanceOf` and `safeTransfer` should be done on this address. Something like\n```solidity\n        if (extra) {\n            uint256 extraRewardsLength = IBaseRewardPool_OCY_Convex_A(convexRewards).extraRewardsLength();\n            for (uint256 i = 0; i < extraRewardsLength; i++) {\n                address rewardContract = IBaseRewardPool_OCY_Convex_A(convexRewards).extraRewards(i);\n                IERC20 rewardToken = convexPoolID < 151 ? IBaseRewardPool_OCY_Convex_A(rewardContract).rewardToken() : IBaseRewardPool_OCY_Convex_A(rewardContract).rewardToken().token();\n                uint256 rewardAmount = rewardToken.balanceOf(\n                    address(this)\n                );\n                if (rewardAmount > 0) { IERC20(rewardToken).safeTransfer(OCT_YDL, rewardAmount); }\n            }\n        }\n```\n\n**WangSecurity**\n\nFirstly, I agree there are two issues:\n1. `rewardAmount` is called on the `rewardToken`, when it should be called on `rewardToken().token`\n2. `safeTransfer` is called on `rewardContract` when it should be called on `rewardToken`.\n\nFixing one, doesn't fix the other. I agree that general core issue is in fact using the wrong address, but the fixes and impacts are different (for 1 is not paying out the extra rewards and they're kept in the contract, for 2 is the revert of the call). Hence, I believe they should be treated separately. There is only 1 report that describes both of these vulnerabilities, which is #294, therefore, I believe it would be fair to make the following issue families:\n\n1. Getting `rewardAmount` on `rewardToken`:\n- #294 \n- #477 (this one) - best\n\n2. Calling `safeTransfer` on `rewardContract`:\n- #161 \n- #222 \n- #277 \n- #391 \n- #399 \n- #444 \n- #447 \n- #479 - best\n\nThe reason why #294 is in the 1st family is because it mentions both issues, but since one report cannot get 2 rewards, it'll be fair to include it in the family with less reports.\n\nLastly, I believe in both situations there are no extensive external limitations leading to a loss of funds. Please correct me if any assumption above is wrong.\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Zivoe/zivoe-core-foundry/pull/273\n\n\n**panprog**\n\n@WangSecurity \nAgree with your decision. Keeping #294 a dup of this also looks correct.\n\n**Evert0x**\n\nResult:\nHigh\nHas duplicates\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [RealLTDingZhen](https://github.com/sherlock-audit/2024-03-zivoe-judging/issues/477/#issuecomment-2105666150): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/280",
  "Code": [
    {
      "filename": "zivoe-core-foundry/src/lockers/OCY/OCY_Convex_C.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport \"../../ZivoeLocker.sol\";\n\nimport \"../../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\ninterface IBasePool_OCY_Convex_C {\n    function add_liquidity(uint256[] memory _amounts, uint256 _min_mint_amount) external;\n    function remove_liquidity(uint256 _amount, uint256[] memory min_amounts) external;\n}\n\ninterface IBaseRewardPool_OCY_Convex_C {\n    function extraRewards(uint256 index) external view returns(address);\n    function extraRewardsLength() external view returns(uint256);\n    function rewardToken() external view returns(IERC20);\n    function getReward() external returns(bool);\n    function withdrawAndUnwrap(uint256 _amount, bool _claim) external returns(bool);\n}\n\ninterface IBooster_OCY_Convex_C {\n    function deposit(uint256 _pid, uint256 _amount, bool _stake) external returns(bool);\n    function withdraw(uint256 _pid, uint256 _amount) external returns(bool);\n}\n\ninterface IZivoeGlobals_OCY_Convex_C {\n    /// @notice Returns the address of the Zivoe Laboratory.\n    function ZVL() external view returns (address);\n}\n\n\n\n/// @notice This contract allocates stablecoins to the PYUSD/USDC base-pool and stakes the LP tokens on Convex.\ncontract OCY_Convex_C is ZivoeLocker, ReentrancyGuard {\n    \n    using SafeERC20 for IERC20;\n\n    // ---------------------\n    //    State Variables\n    // ---------------------\n\n    address public immutable GBL;                   /// @dev The ZivoeGlobals contract.\n\n    address public OCT_YDL;                         /// @dev The OCT_YDL contract.\n\n    /// @dev Tokens.\n    address public constant PYUSD = 0x6c3ea9036406852006290770BEdFcAbA0e23A0e8; /// @dev Index 0, BasePool\n    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;  /// @dev Index 1, BasePool\n\n    address public constant CRV = 0xD533a949740bb3306d119CC777fa900bA034cd52;   /// @dev Native Reward #1\n    address public constant CVX = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;   /// @dev Native Reward #2\n\n    /// @dev Convex information.\n    address public convexDeposit = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31;\n    address public convexPoolToken = 0x383E6b4437b59fff47B619CBA855CA29342A8559;\n    address public convexRewards = 0xc583e81bB36A1F620A804D8AF642B63b0ceEb5c0;\n\n    uint256 public convexPoolID = 270;\n\n    /// @dev Curve information.\n    address public curveBasePool = 0x383E6b4437b59fff47B619CBA855CA29342A8559;\n    address public curveBasePoolToken = 0x383E6b4437b59fff47B619CBA855CA29342A8559;\n\n\n\n    // -----------------\n    //    Constructor\n    // -----------------\n\n    /// @notice Initializes the OCY_OUSD contract.\n    /// @param  DAO The administrator of this contract (intended to be ZivoeDAO).\n    /// @param  _GBL The ZivoeGlobals contract.\n    /// @param  _OCT_YDL The OCT_YDL (Treasury and ZivoeSwapper) contract.\n    constructor(address DAO, address _GBL, address _OCT_YDL) {\n        transferOwnershipAndLock(DAO);\n        GBL = _GBL;\n        OCT_YDL = _OCT_YDL;\n    }\n\n\n\n    // ------------\n    //    Events\n    // ------------\n\n    /// @notice Emitted during updateOCTYDL().\n    /// @param  newOCT The new OCT_YDL contract.\n    /// @param  oldOCT The old OCT_YDL contract.\n    event UpdatedOCTYDL(address indexed newOCT, address indexed oldOCT);\n\n\n\n    // ---------------\n    //    Functions\n    // ---------------\n\n    /// @notice Permission for owner to call pushToLocker().\n    function canPush() public pure override returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pullFromLocker().\n    function canPull() public pure override returns (bool) { return true; }\n\n    /// @notice Permission for owner to call pushToLockerPartial().\n    function canPullPartial() public override pure returns (bool) { return true; }\n\n    /// @notice Migrates specific amount of ERC20 from owner() to locker.\n    /// @param  asset The asset to migrate.\n    /// @param  amount The amount of \"asset\" to migrate.\n    /// @param  data Accompanying transaction data.\n    function pushToLocker(address asset, uint256 amount, bytes calldata data) external override onlyOwner {\n        require(\n            asset == PYUSD || asset == USDC,\n            \"OCY_Convex_C::pushToLocker() asset != PYUSD && asset != USDC\"\n        );\n        IERC20(asset).safeTransferFrom(owner(), address(this), amount);\n\n        (uint _min_mint_amountBP) = abi.decode(data, (uint));\n\n        if (asset == PYUSD) {\n            // Allocate PYUSD to Curve BasePool\n            IERC20(PYUSD).safeIncreaseAllowance(curveBasePool, amount);\n            uint256[] memory _amounts = new uint[](2);\n            _amounts[0] = amount;\n            IBasePool_OCY_Convex_C(curveBasePool).add_liquidity(_amounts, _min_mint_amountBP);\n            assert(IERC20(PYUSD).allowance(address(this), curveBasePool) == 0);\n        }\n        else {\n            // Allocate USDC to Curve BasePool\n            IERC20(USDC).safeIncreaseAllowance(curveBasePool, amount);\n            uint256[] memory _amounts = new uint[](2);\n            _amounts[1] = amount;\n            IBasePool_OCY_Convex_C(curveBasePool).add_liquidity(_amounts, _min_mint_amountBP);\n            assert(IERC20(USDC).allowance(address(this), curveBasePool) == 0);\n        }\n\n        // Stake CurveLP tokens to Convex\n        uint balCurveBasePoolToken = IERC20(curveBasePoolToken).balanceOf(address(this));\n        IERC20(curveBasePoolToken).safeIncreaseAllowance(convexDeposit, balCurveBasePoolToken);\n        IBooster_OCY_Convex_C(convexDeposit).deposit(convexPoolID, balCurveBasePoolToken, true);\n        assert(IERC20(curveBasePoolToken).allowance(address(this), convexDeposit) == 0);\n    }\n\n    /// @notice Migrates entire ERC20 balance from locker to owner().\n    /// @param  asset The asset to migrate.\n    /// @param  data Accompanying transaction data.\n    function pullFromLocker(address asset, bytes calldata data) external override onlyOwner {\n        require(asset == convexPoolToken, \"OCY_Convex_C::pullFromLocker() asset != convexPoolToken\");\n        \n        claimRewards(false);\n\n        // Withdraw from ConvexRewards and unstake CurveLP tokens from ConvexBooster\n        IBaseRewardPool_OCY_Convex_C(convexRewards).withdrawAndUnwrap(\n            IERC20(convexRewards).balanceOf(address(this)), false\n        );\n        \n        (uint _bp_min0, uint _bp_min1) = abi.decode(data, (uint, uint));\n        \n        // Burn BasePool Tokens\n        uint256[] memory _min_amounts_bp = new uint[](2);\n        _min_amounts_bp[0] = _bp_min0;\n        _min_amounts_bp[1] = _bp_min1;\n        IBasePool_OCY_Convex_C(curveBasePool).remove_liquidity(\n            IERC20(curveBasePoolToken).balanceOf(address(this)), _min_amounts_bp\n        );\n\n        // Return tokens to DAO\n        IERC20(PYUSD).safeTransfer(owner(), IERC20(PYUSD).balanceOf(address(this)));\n        IERC20(USDC).safeTransfer(owner(), IERC20(USDC).balanceOf(address(this)));\n    }\n\n    /// @notice Migrates specific amount of ERC20 from locker to owner().\n    /// @param  asset The asset to migrate.\n    /// @param  amount The amount of \"asset\" to migrate.\n    /// @param  data Accompanying transaction data.\n    function pullFromLockerPartial(address asset, uint256 amount, bytes calldata data) external override onlyOwner {\n        require(asset == convexPoolToken, \"OCY_Convex_C::pullFromLockerPartial() asset != convexPoolToken\");\n        \n        claimRewards(false);\n\n        // Withdraw from ConvexRewards and unstake CurveLP tokens from ConvexBooster\n        IBaseRewardPool_OCY_Convex_C(convexRewards).withdrawAndUnwrap(amount, false);\n        \n        (uint _bp_min0, uint _bp_min1) = abi.decode(data, (uint, uint));\n        \n        // Burn BasePool Tokens\n        uint256[] memory _min_amounts_bp = new uint[](2);\n        _min_amounts_bp[0] = _bp_min0;\n        _min_amounts_bp[1] = _bp_min1;\n        IBasePool_OCY_Convex_C(curveBasePool).remove_liquidity(\n            IERC20(curveBasePoolToken).balanceOf(address(this)), _min_amounts_bp\n        );\n\n        // Return tokens to DAO\n        IERC20(PYUSD).safeTransfer(owner(), IERC20(PYUSD).balanceOf(address(this)));\n        IERC20(USDC).safeTransfer(owner(), IERC20(USDC).balanceOf(address(this)));\n    }\n\n    /// @notice Claims rewards and forward them to the OCT_YDL.\n    /// @param extra Flag for claiming extra rewards.\n    function claimRewards(bool extra) public nonReentrant {\n        IBaseRewardPool_OCY_Convex_C(convexRewards).getReward();\n\n        // Native Rewards (CRV, CVX)\n        uint256 rewardsCRV = IERC20(CRV).balanceOf(address(this));\n        uint256 rewardsCVX = IERC20(CVX).balanceOf(address(this));\n        if (rewardsCRV > 0) { IERC20(CRV).safeTransfer(OCT_YDL, rewardsCRV); }\n        if (rewardsCVX > 0) { IERC20(CVX).safeTransfer(OCT_YDL, rewardsCVX); }\n\n        // Extra Rewards\n        if (extra) {\n            uint256 extraRewardsLength = IBaseRewardPool_OCY_Convex_C(convexRewards).extraRewardsLength();\n            for (uint256 i = 0; i < extraRewardsLength; i++) {\n                address rewardContract = IBaseRewardPool_OCY_Convex_C(convexRewards).extraRewards(i);\n                uint256 rewardAmount = IBaseRewardPool_OCY_Convex_C(rewardContract).rewardToken().balanceOf(\n                    address(this)\n                );\n                if (rewardAmount > 0) { IERC20(rewardContract).safeTransfer(OCT_YDL, rewardAmount); }\n            }\n        }\n    }\n\n    /// @notice Update the OCT_YDL endpoint.\n    /// @dev    This function MUST only be called by ZVL().\n    /// @param  _OCT_YDL The new address for OCT_YDL.\n    function updateOCTYDL(address _OCT_YDL) external {\n        require(\n            _msgSender() == IZivoeGlobals_OCY_Convex_C(GBL).ZVL(), \n            \"OCY_Convex_C::updateOCTYDL() _msgSender() != IZivoeGlobals_OCY_Convex_C(GBL).ZVL()\"\n        );\n        require(_OCT_YDL != address(0), \"OCY_Convex_C::updateOCTYDL() _OCT_YDL == address(0)\");\n        emit UpdatedOCTYDL(_OCT_YDL, OCT_YDL);\n        OCT_YDL = _OCT_YDL;\n    }\n\n}"
    }
  ]
}