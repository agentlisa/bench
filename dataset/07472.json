{
  "Title": "[H-07] reentrancy attack during mint() function in Position contract which can lead to removing of the other userâ€™s limit orders or stealing contract funds because initId is set low value",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Position.sol#L126-L161\n\n\n# Vulnerability details\n\n## Impact\nFunction `Position.mint()` has been used in `initiateLimitOrder()` and `initiateMarketOrder()` and it doesn't follow check-effect-interaction pattern and code updates the values of `_limitOrders`, `initId`, `_openPositions` and `position _tokenIds` variables after making external call by using `safeMint()`. This would give attacker opportunity to reenter the Trading contract logics and perform malicious action while contract storage state is wrong. the only limitation of the attacker is that he need to bypass `_checkDelay()` checks. attacker can perform this action:\n1. call `initiateLimitOrder()` and create limit order with id equal to ID1 reenter (while `_limitOrders` for ID1 is not yet settled) with `cancelLimitOrder(ID1)` (no `checkDelay()` check) and remove other users limit orders because code would try to remove `_limitOrderIndexes[_asset][ID1]` position but the value is 0 and code would remove limit order in the index 0 which belongs to another user in the `Position.burn()` code.\n2. call `initiateMarketOrder()` and create a position with ID1 and while `initId[ID1]` has not yet settled reenter the Trading with `addToPosition(ID1)` function (bypass `checkDelay()` because both action is opening) and increase the position size which would set `initId[ID1]` according to new position values but then when code execution returns to rest of `mint()` logic `initId[ID1]` would set by initial values of the positions which is very lower than what it should be and `initId[ID1]` has been used for calculating `accuredInterest` of the position which is calculated for profit and loss of position and contract would calculate more profit for position and would pay attacker more profit from contract balances.\n\n## Proof of Concept\nThis is `mint()` code in Position contract:\n```\n    function mint(\n        MintTrade memory _mintTrade\n    ) external onlyMinter {\n        uint newTokenID = _tokenIds.current();\n\n        Trade storage newTrade = _trades[newTokenID];\n        newTrade.margin = _mintTrade.margin;\n        newTrade.leverage = _mintTrade.leverage;\n        newTrade.asset = _mintTrade.asset;\n        newTrade.direction = _mintTrade.direction;\n        newTrade.price = _mintTrade.price;\n        newTrade.tpPrice = _mintTrade.tp;\n        newTrade.slPrice = _mintTrade.sl;\n        newTrade.orderType = _mintTrade.orderType;\n        newTrade.id = newTokenID;\n        newTrade.tigAsset = _mintTrade.tigAsset;\n\n        _safeMint(_mintTrade.account, newTokenID);   // make external call because of safeMint() usage\n        if (_mintTrade.orderType > 0) { // update the values of some storage functions\n            _limitOrders[_mintTrade.asset].push(newTokenID);\n            _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;\n        } else {\n            initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;\n            _openPositions.push(newTokenID);\n            _openPositionsIndexes[newTokenID] = _openPositions.length-1;\n\n            _assetOpenPositions[_mintTrade.asset].push(newTokenID);\n            _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;\n        }\n        _tokenIds.increment();\n    }\n```\nAs you can see by calling `_safeMint()` code would make external call to `onERC721Received()` function of the account address and the code sets the values for `_limitOrders[]`, `_limitOrderIndexes[]`, `initId[]`, `_openPositions[]`, `_openPositionsIndexes[]`, `_assetOpenPositions[]`, `_assetOpenPositionsIndexes[]` and `_tokenIds`. so code don't follow check-effect-interaction pattern and it's possible to perform reentrancy attack.\nthere could be multiple scenarios that attacker can perform the attack and do some damage. two of them are:\n\n\n**scenario #1 where attacker remove other users limit orders and create broken storage state**\n1. attacker contract would call `initiateLimitOrder()` and code would create the limit order and mint it in the `Position._safeMint()` with ID1.\n2. then code would call attacker address in `_safeMint()` function because of the `onERC721Received()` call check.\n3. variables `_limitOrders[]`, `_limitOrderIndexes[ID1]` are not yet updated for ID1 and `_limitOrderIndexes[ID1]` is 0x0 and ID1 is not in `_limitOrder[]` list.\n4. attacker contract would reenter the Trading contract by calling `cancelLimitOrder(ID1)`.\n5. `cancelLimitOrder()` checks would pass and would tries to call `Position.burn(ID1)`.\n6. `burn()` function would tries to remove ID1 from `_limitOrders[]` list but because `_limitOrderIndexes[ID1]` is 0 so code would remove the 0 index limit order which is belongs to another user.\n7. execution would return to `Position.mint()` logic and code would add burned id token to `_limitOrder[]` list.\n\nso there is two impact here, first other users limit order got removed and the second is that contract storage had bad state and burned tokens get stock in the list.\n\n\n**scenario #2 where attacker steal contract/users funds by wrong profit calculation**\n1. attacker's contract would call `initiateMarketOrder(lowMargin)` to create position with ID1 while the margin is low.\n2. code would mint position token for attacker and in `_safeMint()` would make external call and call `onERC721Received()` function of attacker address.\n3. the value of `initId[ID1]` is not yet set for ID1.\n4. attacker contract would call `addToPosition(ID1, bigMargin)` to increase the margin of the position the `_checkDelay()` check would pass because both actions are opening position.\n5. code would increase the margin of the position and set the value of the `initId[ID1]` by calling `position.addToPosition()` and the value were be based on the `newMargin`.\n6. the execution flow would receive the rest of `Position.mint()` function and code would set `initId[ID1]` based on old margin value.\n7. then the value of `initId[ID1]` for attacker position would be very low which would cause `accInterest` to be very higher than it supposed to be for position(in `Position.trades()` function calculations ) and would cause `_payout` value to be very high (in `pnl()` function's calculations) and when attacker close position ID1 attacker would receive a lot more profit from it.\n\nso attacker created a position with a lot of profit by reentering the logics and manipulating calculation of the profits for the position.\n\nthere can be other scenarios possible to perform and damage the protocol or users because there is no reentrancy protection mechanism and attacker only need to bypass validity checks of functions.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\nfollow the check-effect-interaction pattern.",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-12-tigris-trade-contest",
  "Code": [
    {
      "filename": "contracts/Position.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/IPosition.sol\";\n\ncontract Position is ERC721Enumerable, MetaContext, IPosition {\n\n    function ownerOf(uint _id) public view override(ERC721, IERC721, IPosition) returns (address) {\n        return ERC721.ownerOf(_id);\n    }\n\n    using Counters for Counters.Counter;\n    uint constant public DIVISION_CONSTANT = 1e10; // 100%\n\n    mapping(uint => mapping(address => uint)) public vaultFundingPercent;\n\n    mapping(address => bool) private _isMinter; // Trading contract should be minter\n    mapping(uint256 => Trade) private _trades; // NFT id to Trade\n\n    uint256[] private _openPositions;\n    mapping(uint256 => uint256) private _openPositionsIndexes;\n\n    mapping(uint256 => uint256[]) private _assetOpenPositions;\n    mapping(uint256 => mapping(uint256 => uint256)) private _assetOpenPositionsIndexes;\n\n    mapping(uint256 => uint256[]) private _limitOrders; // List of limit order nft ids per asset\n    mapping(uint256 => mapping(uint256 => uint256)) private _limitOrderIndexes; // Keeps track of asset -> id -> array index\n\n    // Funding\n    mapping(uint256 => mapping(address => int256)) public fundingDeltaPerSec;\n    mapping(uint256 => mapping(address => mapping(bool => int256))) private accInterestPerOi;\n    mapping(uint256 => mapping(address => uint256)) private lastUpdate;\n    mapping(uint256 => int256) private initId;\n    mapping(uint256 => mapping(address => uint256)) private longOi;\n    mapping(uint256 => mapping(address => uint256)) private shortOi;\n\n    function isMinter(address _address) public view returns (bool) { return _isMinter[_address]; }\n    function trades(uint _id) public view returns (Trade memory) {\n        Trade memory _trade = _trades[_id];\n        _trade.trader = ownerOf(_id);\n        if (_trade.orderType > 0) return _trade;\n        \n        int256 _pendingFunding;\n        if (_trade.direction && longOi[_trade.asset][_trade.tigAsset] > 0) {\n            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(longOi[_trade.asset][_trade.tigAsset]);\n            if (longOi[_trade.asset][_trade.tigAsset] > shortOi[_trade.asset][_trade.tigAsset]) {\n                _pendingFunding = -_pendingFunding;\n            } else {\n                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;\n            }\n        } else if (shortOi[_trade.asset][_trade.tigAsset] > 0) {\n            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(shortOi[_trade.asset][_trade.tigAsset]);\n            if (shortOi[_trade.asset][_trade.tigAsset] > longOi[_trade.asset][_trade.tigAsset]) {\n                _pendingFunding = -_pendingFunding;\n            } else {\n                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;\n            }\n        }\n        _trade.accInterest += (int256(_trade.margin*_trade.leverage/1e18)*(accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]+_pendingFunding)/1e18)-initId[_id];\n        \n        return _trade;\n    }\n    function openPositions() public view returns (uint256[] memory) { return _openPositions; }\n    function openPositionsIndexes(uint _id) public view returns (uint256) { return _openPositionsIndexes[_id]; }\n    function assetOpenPositions(uint _asset) public view returns (uint256[] memory) { return _assetOpenPositions[_asset]; }\n    function assetOpenPositionsIndexes(uint _asset, uint _id) public view returns (uint256) { return _assetOpenPositionsIndexes[_asset][_id]; }\n    function limitOrders(uint _asset) public view returns (uint256[] memory) { return _limitOrders[_asset]; }\n    function limitOrderIndexes(uint _asset, uint _id) public view returns (uint256) { return _limitOrderIndexes[_asset][_id]; }\n\n    Counters.Counter private _tokenIds;\n    string public baseURI;\n\n    constructor(string memory _setBaseURI, string memory _name, string memory _symbol) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n        _tokenIds.increment();\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    /**\n    * @notice Update funding rate after open interest change\n    * @dev only callable by minter\n    * @param _asset pair id\n    * @param _tigAsset tigAsset token address\n    * @param _longOi long open interest\n    * @param _shortOi short open interest\n    * @param _baseFundingRate base funding rate of a pair\n    * @param _vaultFundingPercent percent of earned funding going to the stablevault\n    */\n    function updateFunding(uint256 _asset, address _tigAsset, uint256 _longOi, uint256 _shortOi, uint256 _baseFundingRate, uint _vaultFundingPercent) external onlyMinter {\n        if(longOi[_asset][_tigAsset] < shortOi[_asset][_tigAsset]) {\n            if (longOi[_asset][_tigAsset] > 0) {\n                accInterestPerOi[_asset][_tigAsset][true] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;\n            }\n            accInterestPerOi[_asset][_tigAsset][false] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]);\n\n        } else if(longOi[_asset][_tigAsset] > shortOi[_asset][_tigAsset]) {\n            accInterestPerOi[_asset][_tigAsset][true] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]);\n            if (shortOi[_asset][_tigAsset] > 0) {\n                accInterestPerOi[_asset][_tigAsset][false] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;\n            }\n        }\n        lastUpdate[_asset][_tigAsset] = block.timestamp;\n        int256 _oiDelta;\n        if (_longOi > _shortOi) {\n            _oiDelta = int256(_longOi)-int256(_shortOi);\n        } else {\n            _oiDelta = int256(_shortOi)-int256(_longOi);\n        }\n        \n        fundingDeltaPerSec[_asset][_tigAsset] = (_oiDelta*int256(_baseFundingRate)/int256(DIVISION_CONSTANT))/31536000;\n        longOi[_asset][_tigAsset] = _longOi;\n        shortOi[_asset][_tigAsset] = _shortOi;\n        vaultFundingPercent[_asset][_tigAsset] = _vaultFundingPercent;\n    }\n\n    /**\n    * @notice mint a new position nft\n    * @dev only callable by minter\n    * @param _mintTrade New trade params in struct\n    */\n    function mint(\n        MintTrade memory _mintTrade\n    ) external onlyMinter {\n        uint newTokenID = _tokenIds.current();\n\n        Trade storage newTrade = _trades[newTokenID];\n        newTrade.margin = _mintTrade.margin;\n        newTrade.leverage = _mintTrade.leverage;\n        newTrade.asset = _mintTrade.asset;\n        newTrade.direction = _mintTrade.direction;\n        newTrade.price = _mintTrade.price;\n        newTrade.tpPrice = _mintTrade.tp;\n        newTrade.slPrice = _mintTrade.sl;\n        newTrade.orderType = _mintTrade.orderType;\n        newTrade.id = newTokenID;\n        newTrade.tigAsset = _mintTrade.tigAsset;\n\n        _safeMint(_mintTrade.account, newTokenID);\n        if (_mintTrade.orderType > 0) {\n            _limitOrders[_mintTrade.asset].push(newTokenID);\n            _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;\n        } else {\n            initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;\n            _openPositions.push(newTokenID);\n            _openPositionsIndexes[newTokenID] = _openPositions.length-1;\n\n            _assetOpenPositions[_mintTrade.asset].push(newTokenID);\n            _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;\n        }\n        _tokenIds.increment();\n    }\n\n    /**\n     * @param _id id of the position NFT\n     * @param _price price used for execution\n     * @param _newMargin margin after fees\n     */\n    function executeLimitOrder(uint256 _id, uint256 _price, uint256 _newMargin) external onlyMinter {\n        Trade storage _trade = _trades[_id];\n        if (_trade.orderType == 0) {\n            return;\n        }\n        _trade.orderType = 0;\n        _trade.price = _price;\n        _trade.margin = _newMargin;\n        uint _asset = _trade.asset;\n        _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];\n        _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n        delete _limitOrderIndexes[_asset][_id];\n        _limitOrders[_asset].pop();\n\n        _openPositions.push(_id);\n        _openPositionsIndexes[_id] = _openPositions.length-1;\n        _assetOpenPositions[_asset].push(_id);\n        _assetOpenPositionsIndexes[_asset][_id] = _assetOpenPositions[_asset].length-1;\n\n        initId[_id] = accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]*int256(_trade.margin*_trade.leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice modifies margin and leverage\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _newMargin new margin amount\n    * @param _newLeverage new leverage amount\n    */\n    function modifyMargin(uint256 _id, uint256 _newMargin, uint256 _newLeverage) external onlyMinter {\n        _trades[_id].margin = _newMargin;\n        _trades[_id].leverage = _newLeverage;\n    }\n\n    /**\n    * @notice modifies margin and entry price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _newMargin new margin amount\n    * @param _newPrice new entry price\n    */\n    function addToPosition(uint256 _id, uint256 _newMargin, uint256 _newPrice) external onlyMinter {\n        _trades[_id].margin = _newMargin;\n        _trades[_id].price = _newPrice;\n        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_newMargin*_trades[_id].leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice Called before updateFunding for reducing position or adding to position, to store accumulated funding\n    * @dev only callable by minter\n    * @param _id position id\n    */\n    function setAccInterest(uint256 _id) external onlyMinter {\n        _trades[_id].accInterest = trades(_id).accInterest;\n    }\n\n    /**\n    * @notice Reduces position size by %\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _percent percent of a position being closed\n    */\n    function reducePosition(uint256 _id, uint256 _percent) external onlyMinter {\n        _trades[_id].accInterest -= _trades[_id].accInterest*int256(_percent)/int256(DIVISION_CONSTANT);\n        _trades[_id].margin -= _trades[_id].margin*_percent/DIVISION_CONSTANT;\n        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_trades[_id].margin*_trades[_id].leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice change a position tp price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _tpPrice tp price\n    */\n    function modifyTp(uint _id, uint _tpPrice) external onlyMinter {\n        _trades[_id].tpPrice = _tpPrice;\n    }\n\n    /**\n    * @notice change a position sl price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _slPrice sl price\n    */\n    function modifySl(uint _id, uint _slPrice) external onlyMinter {\n        _trades[_id].slPrice = _slPrice;\n    }\n\n    /**\n    * @dev Burns an NFT and it's data\n    * @param _id ID of the trade\n    */\n    function burn(uint _id) external onlyMinter {\n        _burn(_id);\n        uint _asset = _trades[_id].asset;\n        if (_trades[_id].orderType > 0) {\n            _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];\n            _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n            delete _limitOrderIndexes[_asset][_id];\n            _limitOrders[_asset].pop();            \n        } else {\n            _assetOpenPositionsIndexes[_asset][_assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1]] = _assetOpenPositionsIndexes[_asset][_id];\n            _assetOpenPositions[_asset][_assetOpenPositionsIndexes[_asset][_id]] = _assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1];\n            delete _assetOpenPositionsIndexes[_asset][_id];\n            _assetOpenPositions[_asset].pop();  \n\n            _openPositionsIndexes[_openPositions[_openPositions.length-1]] = _openPositionsIndexes[_id];\n            _openPositions[_openPositionsIndexes[_id]] = _openPositions[_openPositions.length-1];\n            delete _openPositionsIndexes[_id];\n            _openPositions.pop();              \n        }\n        delete _trades[_id];\n    }\n\n    function assetOpenPositionsLength(uint _asset) external view returns (uint256) {\n        return _assetOpenPositions[_asset].length;\n    }\n\n    function limitOrdersLength(uint _asset) external view returns (uint256) {\n        return _limitOrders[_asset].length;\n    }\n\n    function getCount() external view returns (uint) {\n        return _tokenIds.current();\n    }\n\n    function userTrades(address _user) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = tokenOfOwnerByIndex(_user, i);\n        }\n        return _ids;\n    }\n\n    function openPositionsSelection(uint _from, uint _to) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](_to-_from);\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = _openPositions[i+_from];\n        }\n        return _ids;\n    }\n\n    function setMinter(address _minter, bool _bool) external onlyOwner {\n        _isMinter[_minter] = _bool;\n    }    \n\n    modifier onlyMinter() {\n        require(_isMinter[_msgSender()], \"!Minter\");\n        _;\n    }\n\n    // META-TX\n    function _msgSender() internal view override(Context, MetaContext) returns (address sender) {\n        return MetaContext._msgSender();\n    }\n    function _msgData() internal view override(Context, MetaContext) returns (bytes calldata) {\n        return MetaContext._msgData();\n    }\n}"
    }
  ]
}