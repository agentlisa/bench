{
  "Title": "[G-01] Using immutable on variables that are only set in the constructor and never after (Save 16.8K gas)",
  "Content": "\nUse immutable if you want to assign a permanent value at construction. Use constants if you already know the permanent value. Both get directly embedded in bytecode, saving SLOAD.\n\nVariables only set in the constructor and never edited afterwards should be marked as immutable, as it would avoid the expensive storage-writing operation in the constructor (around 20 000 gas per variable) and replace the expensive storage-reading operations (around 2100 gas per reading) to a less expensive value reading (3 gas).\n\n`Gas Per variable: 2.1k`\n\n`Total Instances: 8 `\n\n**`Gas Saved: 8 * 2.1k=16.8k`**\n\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardEscrow.sol#L191\n```solidity\nFile: /src/utils/MultiRewardEscrow.sol\n191:  address public feeRecipient;\n```\n\n```diff\ndiff --git a/src/utils/MultiRewardEscrow.sol b/src/utils/MultiRewardEscrow.sol\nindex cf50b08..67744e0 100644\n--- a/src/utils/MultiRewardEscrow.sol\n+++ b/src/utils/MultiRewardEscrow.sol\n@@ -188,7 +188,7 @@ contract MultiRewardEscrow is Owned {\n                             FEE LOGIC\n     //////////////////////////////////////////////////////////////*/\n\n-  address public feeRecipient;\n+  address public immutable feeRecipient;\n```\n\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/DeploymentController.sol#L23-L25\n\n```solidity\nFile: /src/vault/DeploymentController.sol\n23:  ICloneFactory public cloneFactory;\n24:  ICloneRegistry public cloneRegistry;\n25:  ITemplateRegistry public templateRegistry;\n```\n\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L535\n```solidity\nFile: /src/vault/VaultController.sol\n535:  IMultiRewardEscrow public escrow;\n```\n\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L717\n```solidity\nFile: /src/vault/VaultController.sol\n717:  IAdminProxy public adminProxy;\n```\n\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L387\n```solidity\nFile: /src/vault/VaultController.sol\n387:  IVaultRegistry public vaultRegistry;\n```\n\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L822\n```solidity\nFile: /src/vault/VaultController.sol\n822:  IPermissionRegistry public permissionRegistry;\n```\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-popcorn",
  "Code": [
    {
      "filename": "src/utils/MultiRewardEscrow.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport { SafeERC20Upgradeable as SafeERC20 } from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IERC20Upgradeable as IERC20 } from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { Math } from \"openzeppelin-contracts/utils/math/Math.sol\";\nimport { Owned } from \"./Owned.sol\";\nimport { SafeCastLib } from \"solmate/utils/SafeCastLib.sol\";\nimport { Fee, Escrow } from \"../interfaces/IMultiRewardEscrow.sol\";\n\n/**\n * @title   MultiRewardEscrow\n * @author  RedVeil\n * @notice  Permissionlessly escrow tokens for a specific period of time.\n *\n * Anyone can create an escrow for any token and any user.\n * The owner can only decide to take fees on the creation of escrows with certain tokens.\n */\ncontract MultiRewardEscrow is Owned {\n  using SafeERC20 for IERC20;\n  using SafeCastLib for uint256;\n\n  /**\n   * @notice Constructor for the Escrow contract.\n   * @param _owner Owner of the contract. Controls management functions.\n   * @param _feeRecipient Receiver of all fees.\n   */\n  constructor(address _owner, address _feeRecipient) Owned(_owner) {\n    feeRecipient = _feeRecipient;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            GET ESCROW VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n  function getEscrowIdsByUser(address account) external view returns (bytes32[] memory) {\n    return userEscrowIds[account];\n  }\n\n  function getEscrowIdsByUserAndToken(address account, IERC20 token) external view returns (bytes32[] memory) {\n    return userEscrowIdsByToken[account][token];\n  }\n\n  /**\n   * @notice Returns an array of Escrows.\n   * @param escrowIds Array of escrow ids.\n   * @dev there is no check to ensure that all escrows are owned by the same account. Make sure to account for this either by only sending ids for a specific account or by filtering the Escrows by account later on.\n   */\n  function getEscrows(bytes32[] calldata escrowIds) external view returns (Escrow[] memory) {\n    Escrow[] memory selectedEscrows = new Escrow[](escrowIds.length);\n    for (uint256 i = 0; i < escrowIds.length; i++) {\n      selectedEscrows[i] = escrows[escrowIds[i]];\n    }\n    return selectedEscrows;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            LOCK LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  // EscrowId => Escrow\n  mapping(bytes32 => Escrow) public escrows;\n\n  // User => Escrows\n  mapping(address => bytes32[]) public userEscrowIds;\n  // User => RewardsToken => Escrows\n  mapping(address => mapping(IERC20 => bytes32[])) public userEscrowIdsByToken;\n\n  uint256 internal nonce;\n\n  event Locked(IERC20 indexed token, address indexed account, uint256 amount, uint32 duration, uint32 offset);\n\n  error ZeroAddress();\n  error ZeroAmount();\n\n  /**\n   * @notice Locks funds for escrow.\n   * @param token The token to be locked.\n   * @param account Recipient of the escrowed funds.\n   * @param amount Amount of tokens to be locked.\n   * @param duration Duration of the escrow. Every escrow unlocks token linearly.\n   * @param offset A cliff before the escrow starts.\n   * @dev This creates a separate escrow structure which can later be iterated upon to unlock the escrowed funds.\n   * @dev The Owner may decide to add a fee to the escrowed amount.\n   */\n  function lock(\n    IERC20 token,\n    address account,\n    uint256 amount,\n    uint32 duration,\n    uint32 offset\n  ) external {\n    if (token == IERC20(address(0))) revert ZeroAddress();\n    if (account == address(0)) revert ZeroAddress();\n    if (amount == 0) revert ZeroAmount();\n    if (duration == 0) revert ZeroAmount();\n\n    token.safeTransferFrom(msg.sender, address(this), amount);\n\n    nonce++;\n\n    bytes32 id = keccak256(abi.encodePacked(token, account, amount, nonce));\n\n    uint256 feePerc = fees[token].feePerc;\n    if (feePerc > 0) {\n      uint256 fee = Math.mulDiv(amount, feePerc, 1e18);\n\n      amount -= fee;\n      token.safeTransfer(feeRecipient, fee);\n    }\n\n    uint32 start = block.timestamp.safeCastTo32() + offset;\n\n    escrows[id] = Escrow({\n      token: token,\n      start: start,\n      end: start + duration,\n      lastUpdateTime: start,\n      initialBalance: amount,\n      balance: amount,\n      account: account\n    });\n\n    userEscrowIds[account].push(id);\n    userEscrowIdsByToken[account][token].push(id);\n\n    emit Locked(token, account, amount, duration, offset);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  event RewardsClaimed(IERC20 indexed token, address indexed account, uint256 amount);\n\n  error NotClaimable(bytes32 escrowId);\n\n  function isClaimable(bytes32 escrowId) external view returns (bool) {\n    return escrows[escrowId].lastUpdateTime != 0 && escrows[escrowId].balance > 0;\n  }\n\n  function getClaimableAmount(bytes32 escrowId) external view returns (uint256) {\n    return _getClaimableAmount(escrows[escrowId]);\n  }\n\n  /**\n   * @notice Claim rewards for multiple escrows.\n   * @param escrowIds Array of escrow ids.\n   * @dev Uses the `vaultIds` at the specified indices of `userEscrows`.\n   * @dev Prevention for gas overflow should be handled in the frontend\n   */\n  function claimRewards(bytes32[] memory escrowIds) external {\n    for (uint256 i = 0; i < escrowIds.length; i++) {\n      bytes32 escrowId = escrowIds[i];\n      Escrow memory escrow = escrows[escrowId];\n\n      uint256 claimable = _getClaimableAmount(escrow);\n      if (claimable == 0) revert NotClaimable(escrowId);\n\n      escrows[escrowId].balance -= claimable;\n      escrows[escrowId].lastUpdateTime = block.timestamp.safeCastTo32();\n\n      escrow.token.safeTransfer(escrow.account, claimable);\n      emit RewardsClaimed(escrow.token, escrow.account, claimable);\n    }\n  }\n\n  function _getClaimableAmount(Escrow memory escrow) internal view returns (uint256) {\n    if (\n      escrow.lastUpdateTime == 0 ||\n      escrow.end == 0 ||\n      escrow.balance == 0 ||\n      block.timestamp.safeCastTo32() < escrow.start\n    ) {\n      return 0;\n    }\n    return\n      Math.min(\n        (escrow.balance * (block.timestamp - uint256(escrow.lastUpdateTime))) /\n          (uint256(escrow.end) - uint256(escrow.lastUpdateTime)),\n        escrow.balance\n      );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            FEE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  address public feeRecipient;\n\n  // escrowToken => feeAmount\n  mapping(IERC20 => Fee) public fees;\n\n  event FeeSet(IERC20 indexed token, uint256 amount);\n\n  error ArraysNotMatching(uint256 length1, uint256 length2);\n  error DontGetGreedy(uint256 fee);\n  error NoFee(IERC20 token);\n\n  /**\n   * @notice Set fees for multiple tokens. Caller must be the owner.\n   * @param tokens Array of tokens.\n   * @param tokenFees Array of fees for `tokens` in 1e18. (1e18 = 100%, 1e14 = 1 BPS)\n   */\n  function setFees(IERC20[] memory tokens, uint256[] memory tokenFees) external onlyOwner {\n    if (tokens.length != tokenFees.length) revert ArraysNotMatching(tokens.length, tokenFees.length);\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      if (tokenFees[i] >= 1e17) revert DontGetGreedy(tokenFees[i]);\n\n      fees[tokens[i]].feePerc = tokenFees[i];\n      emit FeeSet(tokens[i], tokenFees[i]);\n    }\n  }\n}"
    },
    {
      "filename": "src/vault/DeploymentController.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport { Owned } from \"../utils/Owned.sol\";\nimport { IOwned } from \"../interfaces/IOwned.sol\";\nimport { ICloneFactory } from \"../interfaces/vault/ICloneFactory.sol\";\nimport { ICloneRegistry } from \"../interfaces/vault/ICloneRegistry.sol\";\nimport { ITemplateRegistry, Template } from \"../interfaces/vault/ITemplateRegistry.sol\";\n\n/**\n * @title   DeploymentController\n * @author  RedVeil\n * @notice  Bundles contracts for creating and registering clones.\n * @dev     Allows interacting with them via a single transaction.\n */\ncontract DeploymentController is Owned {\n  /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n  ICloneFactory public cloneFactory;\n  ICloneRegistry public cloneRegistry;\n  ITemplateRegistry public templateRegistry;\n\n  /**\n   * @notice Creates `DeploymentController`\n   * @param _owner `AdminProxy`\n   * @param _cloneFactory Creates clones.\n   * @param _cloneRegistry Keeps track of new clones.\n   * @param _templateRegistry Registry of templates used for deployments.\n   * @dev Needs to call `acceptDependencyOwnership()` after the deployment.\n   */\n  constructor(\n    address _owner,\n    ICloneFactory _cloneFactory,\n    ICloneRegistry _cloneRegistry,\n    ITemplateRegistry _templateRegistry\n  ) Owned(_owner) {\n    cloneFactory = _cloneFactory;\n    cloneRegistry = _cloneRegistry;\n    templateRegistry = _templateRegistry;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          TEMPLATE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Adds a new category for templates. Caller must be owner. (`VaultController` via `AdminProxy`)\n   * @param templateCategory A new template category.\n   * @dev (See TemplateRegistry for more details)\n   */\n  function addTemplateCategory(bytes32 templateCategory) external onlyOwner {\n    templateRegistry.addTemplateCategory(templateCategory);\n  }\n\n  /**\n   * @notice Adds a new category for templates. Caller must be owner. (`VaultController` via `AdminProxy`)\n   * @param templateCategory Category of the new template.\n   * @param templateId Unique Id of the new template.\n   * @param template New template (See ITemplateRegistry for more details)\n   * @dev (See TemplateRegistry for more details)\n   */\n  function addTemplate(\n    bytes32 templateCategory,\n    bytes32 templateId,\n    Template calldata template\n  ) external {\n    templateRegistry.addTemplate(templateCategory, templateId, template);\n  }\n\n  /**\n   * @notice Toggles the endorsement of a template. Caller must be owner. (`VaultController` via `AdminProxy`)\n   * @param templateCategory TemplateCategory of the template to endorse.\n   * @param templateId TemplateId of the template to endorse.\n   * @dev (See TemplateRegistry for more details)\n   */\n  function toggleTemplateEndorsement(bytes32 templateCategory, bytes32 templateId) external onlyOwner {\n    templateRegistry.toggleTemplateEndorsement(templateCategory, templateId);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          DEPLOY LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  error NotEndorsed(bytes32 templateId);\n\n  /**\n   * @notice Clones an implementation and initializes the clone. Caller must be owner.  (`VaultController` via `AdminProxy`)\n   * @param templateCategory Category of the template to use.\n   * @param templateId Unique Id of the template to use.\n   * @param data The data to pass to the clone's initializer.\n   * @dev Uses a template from `TemplateRegistry`. The template must be endorsed.\n   * @dev Deploys and initializes a clone using `CloneFactory`.\n   * @dev Registers the clone in `CloneRegistry`.\n   */\n  function deploy(\n    bytes32 templateCategory,\n    bytes32 templateId,\n    bytes calldata data\n  ) external onlyOwner returns (address clone) {\n    Template memory template = templateRegistry.getTemplate(templateCategory, templateId);\n\n    if (!template.endorsed) revert NotEndorsed(templateId);\n\n    clone = cloneFactory.deploy(template, data);\n\n    cloneRegistry.addClone(templateCategory, templateId, clone);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Nominates a new owner for dependency contracts. Caller must be owner. (`VaultController` via `AdminProxy`)\n   * @param _owner The new `DeploymentController` implementation\n   */\n  function nominateNewDependencyOwner(address _owner) external onlyOwner {\n    IOwned(address(cloneFactory)).nominateNewOwner(_owner);\n    IOwned(address(cloneRegistry)).nominateNewOwner(_owner);\n    IOwned(address(templateRegistry)).nominateNewOwner(_owner);\n  }\n\n  /**\n   * @notice Accept ownership of dependency contracts.\n   * @dev Must be called after construction.\n   */\n  function acceptDependencyOwnership() external {\n    IOwned(address(cloneFactory)).acceptOwnership();\n    IOwned(address(cloneRegistry)).acceptOwnership();\n    IOwned(address(templateRegistry)).acceptOwnership();\n  }\n}"
    },
    {
      "filename": "src/vault/VaultController.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\npragma solidity ^0.8.15;\n\nimport { SafeERC20Upgradeable as SafeERC20 } from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { Owned } from \"../utils/Owned.sol\";\nimport { IVault, VaultInitParams, VaultFees } from \"../interfaces/vault/IVault.sol\";\nimport { IMultiRewardStaking } from \"../interfaces/IMultiRewardStaking.sol\";\nimport { IMultiRewardEscrow } from \"../interfaces/IMultiRewardEscrow.sol\";\nimport { IDeploymentController, ICloneRegistry } from \"../interfaces/vault/IDeploymentController.sol\";\nimport { ITemplateRegistry, Template } from \"../interfaces/vault/ITemplateRegistry.sol\";\nimport { IPermissionRegistry, Permission } from \"../interfaces/vault/IPermissionRegistry.sol\";\nimport { IVaultRegistry, VaultMetadata } from \"../interfaces/vault/IVaultRegistry.sol\";\nimport { IAdminProxy } from \"../interfaces/vault/IAdminProxy.sol\";\nimport { IERC4626, IERC20 } from \"../interfaces/vault/IERC4626.sol\";\nimport { IStrategy } from \"../interfaces/vault/IStrategy.sol\";\nimport { IAdapter } from \"../interfaces/vault/IAdapter.sol\";\nimport { IPausable } from \"../interfaces/IPausable.sol\";\nimport { DeploymentArgs } from \"../interfaces/vault/IVaultController.sol\";\n\n/**\n * @title   VaultController\n * @author  RedVeil\n * @notice  Admin contract for the vault ecosystem.\n *\n * Deploys Vaults, Adapter, Strategies and Staking contracts.\n * Calls admin functions on deployed contracts.\n */\ncontract VaultController is Owned {\n  using SafeERC20 for IERC20;\n\n  /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n  bytes32 public immutable VAULT = \"Vault\";\n  bytes32 public immutable ADAPTER = \"Adapter\";\n  bytes32 public immutable STRATEGY = \"Strategy\";\n  bytes32 public immutable STAKING = \"Staking\";\n  bytes4 internal immutable DEPLOY_SIG = bytes4(keccak256(\"deploy(bytes32,bytes32,bytes)\"));\n\n  error UnderlyingError(bytes revertReason);\n\n  /**\n   * @notice Constructor of this contract.\n   * @param _owner Owner of the contract. Controls management functions.\n   * @param _adminProxy `AdminProxy` ownes contracts in the vault ecosystem.\n   * @param _deploymentController `DeploymentController` with auxiliary deployment contracts.\n   * @param _vaultRegistry `VaultRegistry` to safe vault metadata.\n   * @param _permissionRegistry `permissionRegistry` to add endorsements and rejections.\n   * @param _escrow `MultiRewardEscrow` To escrow rewards of staking contracts.\n   */\n  constructor(\n    address _owner,\n    IAdminProxy _adminProxy,\n    IDeploymentController _deploymentController,\n    IVaultRegistry _vaultRegistry,\n    IPermissionRegistry _permissionRegistry,\n    IMultiRewardEscrow _escrow\n  ) Owned(_owner) {\n    adminProxy = _adminProxy;\n    vaultRegistry = _vaultRegistry;\n    permissionRegistry = _permissionRegistry;\n    escrow = _escrow;\n\n    _setDeploymentController(_deploymentController);\n\n    activeTemplateId[STAKING] = \"MultiRewardStaking\";\n    activeTemplateId[VAULT] = \"V1\";\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          VAULT DEPLOYMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  event VaultDeployed(address indexed vault, address indexed staking, address indexed adapter);\n\n  /**\n   * @notice Deploy a new Vault. Optionally with an Adapter and Staking. Caller must be owner.\n   * @param vaultData Vault init params.\n   * @param adapterData Encoded adapter init data.\n   * @param strategyData Encoded strategy init data.\n   * @param staking Address of staking contract to use for the vault. If 0, a new staking contract will be deployed.\n   * @param rewardsData Encoded data to add a rewards to the staking contract\n   * @param metadata Vault metadata for the `VaultRegistry` (Will be used by the frontend for additional informations)\n   * @param initialDeposit Initial deposit to the vault. If 0, no deposit will be made.\n   * @dev This function is the one stop solution to create a new vault with all necessary admin functions or auxiliery contracts.\n   */\n  function deployVault(\n    VaultInitParams memory vaultData,\n    DeploymentArgs memory adapterData,\n    DeploymentArgs memory strategyData,\n    address staking,\n    bytes memory rewardsData,\n    VaultMetadata memory metadata,\n    uint256 initialDeposit\n  ) external canCreate returns (address vault) {\n    IDeploymentController _deploymentController = deploymentController;\n\n    _verifyToken(address(vaultData.asset));\n    _verifyAdapterConfiguration(address(vaultData.adapter), adapterData.id);\n\n    if (adapterData.id > 0)\n      vaultData.adapter = IERC4626(_deployAdapter(vaultData.asset, adapterData, strategyData, _deploymentController));\n\n    vault = _deployVault(vaultData, _deploymentController);\n\n    if (staking == address(0)) staking = _deployStaking(IERC20(address(vault)), _deploymentController);\n\n    _registerCreatedVault(vault, staking, metadata);\n\n    if (rewardsData.length > 0) _handleVaultStakingRewards(vault, rewardsData);\n\n    emit VaultDeployed(vault, staking, address(vaultData.adapter));\n\n    _handleInitialDeposit(initialDeposit, IERC20(vaultData.asset), IERC4626(vault));\n  }\n\n  /// @notice Deploys a new vault contract using the `activeTemplateId`.\n  function _deployVault(VaultInitParams memory vaultData, IDeploymentController _deploymentController)\n    internal\n    returns (address vault)\n  {\n    vaultData.owner = address(adminProxy);\n\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(\n        DEPLOY_SIG,\n        VAULT,\n        activeTemplateId[VAULT],\n        abi.encodeWithSelector(IVault.initialize.selector, vaultData)\n      )\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    vault = abi.decode(returnData, (address));\n  }\n\n  /// @notice Registers newly created vault metadata.\n  function _registerCreatedVault(\n    address vault,\n    address staking,\n    VaultMetadata memory metadata\n  ) internal {\n    metadata.vault = vault;\n    metadata.staking = staking;\n    metadata.creator = msg.sender;\n\n    _registerVault(vault, metadata);\n  }\n\n  /// @notice Prepares and calls `addStakingRewardsTokens` for the newly created staking contract.\n  function _handleVaultStakingRewards(address vault, bytes memory rewardsData) internal {\n    address[] memory vaultContracts = new address[](1);\n    bytes[] memory rewardsDatas = new bytes[](1);\n\n    vaultContracts[0] = vault;\n    rewardsDatas[0] = rewardsData;\n\n    addStakingRewardsTokens(vaultContracts, rewardsDatas);\n  }\n\n  function _handleInitialDeposit(\n    uint256 initialDeposit,\n    IERC20 asset,\n    IERC4626 target\n  ) internal {\n    if (initialDeposit > 0) {\n      asset.safeTransferFrom(msg.sender, address(this), initialDeposit);\n      asset.approve(address(target), initialDeposit);\n      target.deposit(initialDeposit, msg.sender);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      ADAPTER DEPLOYMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Deploy a new Adapter with our without a strategy. Caller must be owner.\n   * @param asset Asset which will be used by the adapter.\n   * @param adapterData Encoded adapter init data.\n   * @param strategyData Encoded strategy init data.\n   */\n  function deployAdapter(\n    IERC20 asset,\n    DeploymentArgs memory adapterData,\n    DeploymentArgs memory strategyData,\n    uint256 initialDeposit\n  ) external canCreate returns (address adapter) {\n    _verifyToken(address(asset));\n\n    adapter = _deployAdapter(asset, adapterData, strategyData, deploymentController);\n\n    _handleInitialDeposit(initialDeposit, asset, IERC4626(adapter));\n  }\n\n  /**\n   * @notice Deploys an adapter and optionally a strategy.\n   * @dev Adds the newly deployed strategy to the adapter.\n   */\n  function _deployAdapter(\n    IERC20 asset,\n    DeploymentArgs memory adapterData,\n    DeploymentArgs memory strategyData,\n    IDeploymentController _deploymentController\n  ) internal returns (address) {\n    address strategy;\n    bytes4[8] memory requiredSigs;\n    if (strategyData.id > 0) {\n      strategy = _deployStrategy(strategyData, _deploymentController);\n      requiredSigs = templateRegistry.getTemplate(STRATEGY, strategyData.id).requiredSigs;\n    }\n\n    return\n      __deployAdapter(\n        adapterData,\n        abi.encode(asset, address(adminProxy), IStrategy(strategy), harvestCooldown, requiredSigs, strategyData.data),\n        _deploymentController\n      );\n  }\n\n  /// @notice Deploys an adapter and sets the management fee via `AdminProxy`\n  function __deployAdapter(\n    DeploymentArgs memory adapterData,\n    bytes memory baseAdapterData,\n    IDeploymentController _deploymentController\n  ) internal returns (address adapter) {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(DEPLOY_SIG, ADAPTER, adapterData.id, _encodeAdapterData(adapterData, baseAdapterData))\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    adapter = abi.decode(returnData, (address));\n\n    adminProxy.execute(adapter, abi.encodeWithSelector(IAdapter.setPerformanceFee.selector, performanceFee));\n  }\n\n  /// @notice Encodes adapter init call. Was moved into its own function to fix \"stack too deep\" error.\n  function _encodeAdapterData(DeploymentArgs memory adapterData, bytes memory baseAdapterData)\n    internal\n    returns (bytes memory)\n  {\n    return\n      abi.encodeWithSelector(\n        IAdapter.initialize.selector,\n        baseAdapterData,\n        templateRegistry.getTemplate(ADAPTER, adapterData.id).registry,\n        adapterData.data\n      );\n  }\n\n  /// @notice Deploys a new strategy contract.\n  function _deployStrategy(DeploymentArgs memory strategyData, IDeploymentController _deploymentController)\n    internal\n    returns (address strategy)\n  {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(DEPLOY_SIG, STRATEGY, strategyData.id, \"\")\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    strategy = abi.decode(returnData, (address));\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    STAKING DEPLOYMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Deploy a new staking contract. Caller must be owner.\n   * @param asset The staking token for the new contract.\n   * @dev Deploys `MultiRewardsStaking` based on the latest templateTemplateKey.\n   */\n  function deployStaking(IERC20 asset) external canCreate returns (address) {\n    _verifyToken(address(asset));\n    return _deployStaking(asset, deploymentController);\n  }\n\n  /// @notice Deploys a new staking contract using the activeTemplateId.\n  function _deployStaking(IERC20 asset, IDeploymentController _deploymentController)\n    internal\n    returns (address staking)\n  {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(\n        DEPLOY_SIG,\n        STAKING,\n        activeTemplateId[STAKING],\n        abi.encodeWithSelector(IMultiRewardStaking.initialize.selector, asset, escrow, adminProxy)\n      )\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    staking = abi.decode(returnData, (address));\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    VAULT MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  error DoesntExist(address adapter);\n\n  /**\n   * @notice Propose a new Adapter. Caller must be creator of the vaults.\n   * @param vaults Vaults to propose the new adapter for.\n   * @param newAdapter New adapters to propose.\n   */\n  function proposeVaultAdapters(address[] calldata vaults, IERC4626[] calldata newAdapter) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, newAdapter.length);\n\n    ICloneRegistry _cloneRegistry = cloneRegistry;\n    for (uint8 i = 0; i < len; i++) {\n      _verifyCreator(vaults[i]);\n      if (!_cloneRegistry.cloneExists(address(newAdapter[i]))) revert DoesntExist(address(newAdapter[i]));\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.proposeAdapter.selector, newAdapter[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Change adapter of a vault to the previously proposed adapter.\n   * @param vaults Addresses of the vaults to change\n   */\n  function changeVaultAdapters(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint8 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.changeAdapter.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Sets new fees per vault. Caller must be creator of the vaults.\n   * @param vaults Addresses of the vaults to change\n   * @param fees New fee structures for these vaults\n   * @dev Value is in 1e18, e.g. 100% = 1e18 - 1 BPS = 1e12\n   */\n  function proposeVaultFees(address[] calldata vaults, VaultFees[] calldata fees) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, fees.length);\n\n    for (uint8 i = 0; i < len; i++) {\n      _verifyCreator(vaults[i]);\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.proposeFees.selector, fees[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Change adapter of a vault to the previously proposed adapter.\n   * @param vaults Addresses of the vaults\n   */\n  function changeVaultFees(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint8 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.changeFees.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          REGISTER VAULT\n    //////////////////////////////////////////////////////////////*/\n\n  IVaultRegistry public vaultRegistry;\n\n  /// @notice Call the `VaultRegistry` to register a vault via `AdminProxy`\n  function _registerVault(address vault, VaultMetadata memory metadata) internal {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(vaultRegistry),\n      abi.encodeWithSelector(IVaultRegistry.registerVault.selector, metadata)\n    );\n    if (!success) revert UnderlyingError(returnData);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    ENDORSEMENT / REJECTION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Set permissions for an array of target. Caller must be owner.\n   * @param targets `AdminProxy`\n   * @param newPermissions An array of permissions to set for the targets.\n   * @dev See `PermissionRegistry` for more details\n   */\n  function setPermissions(address[] calldata targets, Permission[] calldata newPermissions) external onlyOwner {\n    // No need to check matching array length since its already done in the permissionRegistry\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(permissionRegistry),\n      abi.encodeWithSelector(IPermissionRegistry.setPermissions.selector, targets, newPermissions)\n    );\n    if (!success) revert UnderlyingError(returnData);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      STAKING MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n  /**\n   * @notice Adds a new rewardToken which can be earned via staking. Caller must be creator of the Vault or owner.\n   * @param vaults Vaults of which the staking contracts should be targeted\n   * @param rewardTokenData Token that can be earned by staking.\n   * @dev `rewardToken` - Token that can be earned by staking.\n   * @dev `rewardsPerSecond` - The rate in which `rewardToken` will be accrued.\n   * @dev `amount` - Initial funding amount for this reward.\n   * @dev `useEscrow Bool` - if the rewards should be escrowed on claim.\n   * @dev `escrowPercentage` - The percentage of the reward that gets escrowed in 1e18. (1e18 = 100%, 1e14 = 1 BPS)\n   * @dev `escrowDuration` - The duration of the escrow.\n   * @dev `offset` - A cliff after claim before the escrow starts.\n   * @dev See `MultiRewardsStaking` for more details.\n   */\n  function addStakingRewardsTokens(address[] memory vaults, bytes[] memory rewardTokenData) public {\n    _verifyEqualArrayLength(vaults.length, rewardTokenData.length);\n    address staking;\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      (\n        address rewardsToken,\n        uint160 rewardsPerSecond,\n        uint256 amount,\n        bool useEscrow,\n        uint224 escrowDuration,\n        uint24 escrowPercentage,\n        uint256 offset\n      ) = abi.decode(rewardTokenData[i], (address, uint160, uint256, bool, uint224, uint24, uint256));\n      _verifyToken(rewardsToken);\n      staking = _verifyCreatorOrOwner(vaults[i]).staking;\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        rewardsToken,\n        abi.encodeWithSelector(IERC20.approve.selector, staking, type(uint256).max)\n      );\n      if (!success) revert UnderlyingError(returnData);\n\n      IERC20(rewardsToken).approve(staking, type(uint256).max);\n      IERC20(rewardsToken).transferFrom(msg.sender, address(adminProxy), amount);\n\n      (success, returnData) = adminProxy.execute(\n        staking,\n        abi.encodeWithSelector(\n          IMultiRewardStaking.addRewardToken.selector,\n          rewardsToken,\n          rewardsPerSecond,\n          amount,\n          useEscrow,\n          escrowDuration,\n          escrowPercentage,\n          offset\n        )\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Changes rewards speed for a rewardToken. This works only for rewards that accrue over time. Caller must be creator of the Vault.\n   * @param vaults Vaults of which the staking contracts should be targeted\n   * @param rewardTokens Token that can be earned by staking.\n   * @param rewardsSpeeds The rate in which `rewardToken` will be accrued.\n   * @dev See `MultiRewardsStaking` for more details.\n   */\n  function changeStakingRewardsSpeeds(\n    address[] calldata vaults,\n    IERC20[] calldata rewardTokens,\n    uint160[] calldata rewardsSpeeds\n  ) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, rewardTokens.length);\n    _verifyEqualArrayLength(len, rewardsSpeeds.length);\n\n    address staking;\n    for (uint256 i = 0; i < len; i++) {\n      staking = _verifyCreator(vaults[i]).staking;\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        staking,\n        abi.encodeWithSelector(IMultiRewardStaking.changeRewardSpeed.selector, rewardTokens[i], rewardsSpeeds[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Funds rewards for a rewardToken.\n   * @param vaults Vaults of which the staking contracts should be targeted\n   * @param rewardTokens Token that can be earned by staking.\n   * @param amounts The amount of rewardToken that will fund this reward.\n   * @dev See `MultiRewar"
    }
  ]
}