{
  "Title": "M-27: Virtual impacts can be trivially bypassed via structuring",
  "Content": "# Issue M-27: Virtual impacts can be trivially bypassed via structuring \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/145 \n\n## Found by \nIllIllI\n\n## Summary\n\nVirtual impacts can be trivially bypassed by chopping large orders into multiple smaller ones\n\n\n## Vulnerability Detail\n\nVirtual price impacts are meant to ensure that even if a user spreads their orders over multiple pools, that they still will have a sufficient price impact to deter oracle price manipulation. The code, however, allows smaller orders to go through without incurring this global virtual price impact.\n\n## Impact\n\nA user can get around a large virtual price impact by chopping their large orders into multiple smaller orders, below the price impact threshold, manipulate the oracle price, and have all of the small orders executed in the same block, defeating the manipulation protection.\n\n\n## Code Snippet\n\nOnly looks at change in position:\n```solidity\n// File: gmx-synthetics/contracts/pricing/PositionPricingUtils.sol : PositionPricingUtils.getPriceImpactUsd()   #1\n\n209            if (!hasVirtualInventory) {\n210                return priceImpactUsd;\n211            }\n212    \n213            OpenInterestParams memory openInterestParamsForVirtualInventory = getNextOpenInterestForVirtualInventory(params);\n214            int256 priceImpactUsdForVirtualInventory = _getPriceImpactUsd(params.dataStore, params.market, openInterestParamsForVirtualInventory);\n215            int256 thresholdPriceImpactUsd = Precision.applyFactor(params.usdDelta.abs(), thresholdImpactFactorForVirtualInventory);\n216    \n217 @>         if (priceImpactUsdForVirtualInventory > thresholdPriceImpactUsd) {\n218                return priceImpactUsd;\n219            }\n220    \n221            return priceImpactUsdForVirtualInventory < priceImpactUsd ? priceImpactUsdForVirtualInventory : priceImpactUsd;\n222:       }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/pricing/PositionPricingUtils.sol#L207-L222\n\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nVirtual price impact needs to always apply, in order to solve for the case of splitting a large order over multiple accounts. If orders split over multiple accounts is not a risk you want to address, the price impact should at least take into account the total position size for a single account when determining whether the threshold should apply.\n\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/pull/116\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/pricing/PositionPricingUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\n\nimport \"../market/MarketUtils.sol\";\n\nimport \"../utils/Precision.sol\";\nimport \"../utils/Calc.sol\";\n\nimport \"./PricingUtils.sol\";\n\nimport \"../referral/IReferralStorage.sol\";\nimport \"../referral/ReferralUtils.sol\";\n\n// @title PositionPricingUtils\n// @dev Library for position pricing functions\nlibrary PositionPricingUtils {\n    using SignedMath for int256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Position for Position.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    // @dev GetPriceImpactUsdParams struct used in getPriceImpactUsd to avoid stack\n    // too deep errors\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longToken the longToken of the market\n    // @param shortToken the shortToken of the market\n    // @param usdDelta the change in position size in USD\n    // @param isLong whether the position is long or short\n    struct GetPriceImpactUsdParams {\n        DataStore dataStore;\n        address market;\n        address indexToken;\n        address longToken;\n        address shortToken;\n        int256 usdDelta;\n        bool isLong;\n    }\n\n    // @dev OpenInterestParams struct to contain open interest values\n    // @param longOpenInterest the amount of long open interest\n    // @param shortOpenInterest the amount of short open interest\n    // @param nextLongOpenInterest the updated amount of long open interest\n    // @param nextShortOpenInterest the updated amount of short open interest\n    struct OpenInterestParams {\n        uint256 longOpenInterest;\n        uint256 shortOpenInterest;\n        uint256 nextLongOpenInterest;\n        uint256 nextShortOpenInterest;\n    }\n\n    // @dev PositionFees struct to contain fee values\n    // @param feeReceiverAmount the amount for the fee receiver\n    // @param feeAmountForPool the amount of fees for the pool\n    // @param positionFeeAmountForPool the position fee amount for the pool\n    // @param positionFeeAmount the fee amount for increasing / decreasing the position\n    // @param borrowingFeeAmount the borrowing fee amount\n    // @param totalNetCostAmount the total net cost amount in tokens\n    // @param totalNetCostUsd the total net cost in USD\n    struct PositionFees {\n        PositionReferralFees referral;\n        PositionFundingFees funding;\n        uint256 feeReceiverAmount;\n        uint256 feeAmountForPool;\n        uint256 positionFeeAmountForPool;\n        uint256 positionFeeAmount;\n        uint256 borrowingFeeAmount;\n        uint256 totalNetCostAmount;\n        uint256 totalNetCostUsd;\n    }\n\n    // @param affiliate the referral affiliate of the trader\n    // @param traderDiscountAmount the discount amount for the trader\n    // @param affiliateRewardAmount the affiliate reward amount\n    struct PositionReferralFees {\n        address affiliate;\n        uint256 traderDiscountAmount;\n        uint256 affiliateRewardAmount;\n    }\n\n    // @param fundingFeeAmount the position's funding fee amount\n    // @param claimableLongTokenAmount the negative funding fee in long token that is claimable\n    // @param claimableShortTokenAmount the negative funding fee in short token that is claimable\n    // @param latestLongTokenFundingAmountPerSize the latest long token funding\n    // amount per size for the market\n    // @param latestShortTokenFundingAmountPerSize the latest short token funding\n    // amount per size for the market\n    // @param hasPendingLongTokenFundingFee whether there is a pending long token funding fee\n    // @param hasPendingShortTokenFundingFee whether there is a pending short token funding fee\n    struct PositionFundingFees {\n        uint256 fundingFeeAmount;\n        uint256 claimableLongTokenAmount;\n        uint256 claimableShortTokenAmount;\n        int256 latestLongTokenFundingAmountPerSize;\n        int256 latestShortTokenFundingAmountPerSize;\n        bool hasPendingLongTokenFundingFee;\n        bool hasPendingShortTokenFundingFee;\n    }\n\n    // @dev GetPositionFeesAfterReferralCache struct used in getPositionFees\n    // to avoid stack too deep errors\n    // @param feeFactor the fee factor\n    // @param positionFeeAmount the fee amount for increasing / decreasing the position\n    // @param protocolFeeAmount the protocol fee\n    // @param feeReceiverAmount the amount for the fee receiver\n    // @param positionFeeAmountForPool the position fee amount for the pool in tokens\n    struct GetPositionFeesAfterReferralCache {\n        GetPositionFeesAfterReferralCacheReferral referral;\n        uint256 feeFactor;\n        uint256 positionFeeAmount;\n        uint256 protocolFeeAmount;\n        uint256 positionFeeReceiverFactor;\n        uint256 feeReceiverAmount;\n        uint256 positionFeeAmountForPool;\n    }\n\n    // @param affiliate the referral affiliate\n    // @param totalRebateFactor the total referral rebate factor\n    // @param traderDiscountFactor the trader referral discount factor\n    // @param totalRebateAmount the total referral rebate amount in tokens\n    // @param traderDiscountAmount the trader discount amount in tokens\n    // @param affiliateRewardAmount the affiliate reward amount in tokens\n    struct GetPositionFeesAfterReferralCacheReferral {\n        address affiliate;\n        uint256 totalRebateFactor;\n        uint256 traderDiscountFactor;\n        uint256 totalRebateAmount;\n        uint256 traderDiscountAmount;\n        uint256 affiliateRewardAmount;\n    }\n\n\n    error UsdDeltaExceedsLongOpenInterest(int256 usdDelta, uint256 longOpenInterest);\n    error UsdDeltaExceedsShortOpenInterest(int256 usdDelta, uint256 shortOpenInterest);\n\n    // @dev get the price impact amount for a position increase / decrease\n    // @param size the change in position size\n    // @param executionPrice the execution price of the index token\n    // @param latestPrice the latest price of the index token\n    // @param isLong whether the position is long or short\n    // @param isIncrease whether it is an increase or decrease position\n    // @return the price impact amount for a position increase / decrease\n    function getPriceImpactAmount(\n        uint256 size,\n        uint256 executionPrice,\n        Price.Props memory latestPrice,\n        bool isLong,\n        bool isIncrease\n    ) internal pure returns (int256) {\n        uint256 _latestPrice;\n        if (isIncrease) {\n            _latestPrice = isLong ? latestPrice.max : latestPrice.min;\n        } else {\n            _latestPrice = isLong ? latestPrice.min : latestPrice.max;\n        }\n\n        // increase order:\n        //     - long: price impact is size * (_latestPrice - executionPrice) / _latestPrice\n        //             when executionPrice is smaller than _latestPrice there is a positive price impact\n        //     - short: price impact is size * (executionPrice - _latestPrice) / _latestPrice\n        //              when executionPrice is larger than _latestPrice there is a positive price impact\n        // decrease order:\n        //     - long: price impact is size * (executionPrice - _latestPrice) / _latestPrice\n        //             when executionPrice is larger than _latestPrice there is a positive price impact\n        //     - short: price impact is size * (_latestPrice - executionPrice) / _latestPrice\n        //              when executionPrice is smaller than _latestPrice there is a positive price impact\n        int256 priceDiff = _latestPrice.toInt256() - executionPrice.toInt256();\n        bool shouldFlipPriceDiff = isIncrease ? !isLong : isLong;\n        if (shouldFlipPriceDiff) { priceDiff = -priceDiff; }\n\n        int256 priceImpactUsd = size.toInt256() * priceDiff / _latestPrice.toInt256();\n\n        // round positive price impact up, this will be deducted from the position impact pool\n        if (priceImpactUsd > 0) {\n            return Calc.roundUpDivision(priceImpactUsd, _latestPrice);\n        }\n\n        // round negative price impact down, this will be stored in the position impact pool\n        return priceImpactUsd / _latestPrice.toInt256();\n    }\n\n    // @dev get the price impact in USD for a position increase / decrease\n    // @param params GetPriceImpactUsdParams\n    function getPriceImpactUsd(GetPriceImpactUsdParams memory params) internal view returns (int256) {\n        OpenInterestParams memory openInterestParams = getNextOpenInterest(params);\n\n        int256 priceImpactUsd = _getPriceImpactUsd(params.dataStore, params.market, openInterestParams);\n\n        if (priceImpactUsd >= 0) {\n            return priceImpactUsd;\n        }\n\n        (bool hasVirtualInventory, int256 thresholdImpactFactorForVirtualInventory) = MarketUtils.getThresholdPositionImpactFactorForVirtualInventory(\n            params.dataStore,\n            params.indexToken\n        );\n\n        if (!hasVirtualInventory) {\n            return priceImpactUsd;\n        }\n\n        OpenInterestParams memory openInterestParamsForVirtualInventory = getNextOpenInterestForVirtualInventory(params);\n        int256 priceImpactUsdForVirtualInventory = _getPriceImpactUsd(params.dataStore, params.market, openInterestParamsForVirtualInventory);\n        int256 thresholdPriceImpactUsd = Precision.applyFactor(params.usdDelta.abs(), thresholdImpactFactorForVirtualInventory);\n\n        if (priceImpactUsdForVirtualInventory > thresholdPriceImpactUsd) {\n            return priceImpactUsd;\n        }\n\n        return priceImpactUsdForVirtualInventory < priceImpactUsd ? priceImpactUsdForVirtualInventory : priceImpactUsd;\n    }\n\n    // @dev get the price impact in USD for a position increase / decrease\n    // @param dataStore DataStore\n    // @param market the trading market\n    // @param openInterestParams OpenInterestParams\n    function _getPriceImpactUsd(DataStore dataStore, address market, OpenInterestParams memory openInterestParams) internal view returns (int256) {\n        uint256 initialDiffUsd = Calc.diff(openInterestParams.longOpenInterest, openInterestParams.shortOpenInterest);\n        uint256 nextDiffUsd = Calc.diff(openInterestParams.nextLongOpenInterest, openInterestParams.nextShortOpenInterest);\n\n        // check whether an improvement in balance comes from causing the balance to switch sides\n        // for example, if there is $2000 of ETH and $1000 of USDC in the pool\n        // adding $1999 USDC into the pool will reduce absolute balance from $1000 to $999 but it does not\n        // help rebalance the pool much, the isSameSideRebalance value helps avoid gaming using this case\n        bool isSameSideRebalance = openInterestParams.longOpenInterest <= openInterestParams.shortOpenInterest == openInterestParams.nextLongOpenInterest <= openInterestParams.nextShortOpenInterest;\n        uint256 impactExponentFactor = dataStore.getUint(Keys.positionImpactExponentFactorKey(market));\n\n        if (isSameSideRebalance) {\n            bool hasPositiveImpact = nextDiffUsd < initialDiffUsd;\n            uint256 impactFactor = dataStore.getUint(Keys.positionImpactFactorKey(market, hasPositiveImpact));\n\n            return PricingUtils.getPriceImpactUsdForSameSideRebalance(\n                initialDiffUsd,\n                nextDiffUsd,\n                impactFactor,\n                impactExponentFactor\n            );\n        } else {\n            uint256 positiveImpactFactor = dataStore.getUint(Keys.positionImpactFactorKey(market, true));\n            uint256 negativeImpactFactor = dataStore.getUint(Keys.positionImpactFactorKey(market, false));\n\n            return PricingUtils.getPriceImpactUsdForCrossoverRebalance(\n                initialDiffUsd,\n                nextDiffUsd,\n                positiveImpactFactor,\n                negativeImpactFactor,\n                impactExponentFactor\n            );\n        }\n    }\n\n    // @dev get the next open interest values\n    // @param params GetPriceImpactUsdParams\n    // @return OpenInterestParams\n    function getNextOpenInterest(\n        GetPriceImpactUsdParams memory params\n    ) internal view returns (OpenInterestParams memory) {\n        uint256 longOpenInterest = MarketUtils.getOpenInterest(\n            params.dataStore,\n            params.market,\n            params.longToken,\n            params.shortToken,\n            true);\n\n        uint256 shortOpenInterest = MarketUtils.getOpenInterest(\n            params.dataStore,\n            params.market,\n            params.longToken,\n            params.shortToken,\n            false\n        );\n\n        return getNextOpenInterestParams(params, longOpenInterest, shortOpenInterest);\n    }\n\n    function getNextOpenInterestForVirtualInventory(\n        GetPriceImpactUsdParams memory params\n    ) internal view returns (OpenInterestParams memory) {\n        (/* bool hasVirtualInventory */, int256 virtualInventory) = MarketUtils.getVirtualInventoryForPositions(params.dataStore, params.indexToken);\n\n        uint256 longOpenInterest;\n        uint256 shortOpenInterest;\n\n        // if virtualInventory is more than zero it means that\n        // tokens were virtually sold to the pool, so set shortOpenInterest\n        // to the virtualInventory value\n        // if virtualInventory is less than zero it means that\n        // tokens were virtually bought from the pool, so set longOpenInterest\n        // to the virtualInventory value\n        if (virtualInventory > 0) {\n            shortOpenInterest = virtualInventory.toUint256();\n        } else {\n            longOpenInterest = (-virtualInventory).toUint256();\n        }\n\n        return getNextOpenInterestParams(params, longOpenInterest, shortOpenInterest);\n    }\n\n    function getNextOpenInterestParams(\n        GetPriceImpactUsdParams memory params,\n        uint256 longOpenInterest,\n        uint256 shortOpenInterest\n    ) internal pure returns (OpenInterestParams memory) {\n        uint256 nextLongOpenInterest;\n        uint256 nextShortOpenInterest;\n\n        if (params.isLong) {\n            if (params.usdDelta < 0 && (-params.usdDelta).toUint256() > longOpenInterest) {\n                revert UsdDeltaExceedsLongOpenInterest(params.usdDelta, longOpenInterest);\n            }\n\n            nextLongOpenInterest = Calc.sumReturnUint256(longOpenInterest, params.usdDelta);\n        } else {\n            if (params.usdDelta < 0 && (-params.usdDelta).toUint256() > shortOpenInterest) {\n                revert UsdDeltaExceedsShortOpenInterest(params.usdDelta, shortOpenInterest);\n            }\n\n            nextShortOpenInterest = Calc.sumReturnUint256(shortOpenInterest, params.usdDelta);\n        }\n\n        OpenInterestParams memory openInterestParams = OpenInterestParams(\n            longOpenInterest,\n            shortOpenInterest,\n            nextLongOpenInterest,\n            nextShortOpenInterest\n        );\n\n        return openInterestParams;\n    }\n\n    // @dev get position fees\n    // @param dataStore DataStore\n    // @param referralStorage IReferralStorage\n    // @param position the position values\n    // @param collateralTokenPrice the price of the position's collateralToken\n    // @param longToken the long token of the market\n    // @param shortToken the short token of the market\n    // @param sizeDeltaUsd the change in position size\n    // @return PositionFees\n    function getPositionFees(\n        DataStore dataStore,\n        IReferralStorage referralStorage,\n        Position.Props memory position,\n        Price.Props memory collateralTokenPrice,\n        address longToken,\n        address shortToken,\n        uint256 sizeDeltaUsd\n    ) internal view returns (PositionFees memory) {\n        PositionFees memory fees;\n\n        (\n            fees.referral.affiliate,\n            fees.referral.traderDiscountAmount,\n            fees.referral.affiliateRewardAmount,\n            fees.feeReceiverAmount,\n            fees.positionFeeAmountForPool\n        ) = getPositionFeesAfterReferral(\n            dataStore,\n            referralStorage,\n            collateralTokenPrice,\n            position.account(),\n            position.market(),\n            sizeDeltaUsd\n        );\n\n        fees.borrowingFeeAmount = MarketUtils.getBorrowingFees(dataStore, position) / collateralTokenPrice.min;\n\n        uint256 borrowingFeeReceiverFactor = dataStore.getUint(Keys.BORROWING_FEE_RECEIVER_FACTOR);\n        uint256 borrowingFeeAmountForFeeReceiver = Precision.applyFactor(fees.borrowingFeeAmount, borrowingFeeReceiverFactor);\n\n        fees.feeAmountForPool = fees.positionFeeAmountForPool + fees.borrowingFeeAmount - borrowingFeeAmountForFeeReceiver;\n        fees.feeReceiverAmount += borrowingFeeAmountForFeeReceiver;\n\n        int256 latestLongTokenFundingAmountPerSize = MarketUtils.getFundingAmountPerSize(dataStore, position.market(), longToken, position.isLong());\n        int256 latestShortTokenFundingAmountPerSize = MarketUtils.getFundingAmountPerSize(dataStore, position.market(), shortToken, position.isLong());\n\n        fees.funding = getFundingFees(\n            position,\n            longToken,\n            shortToken,\n            latestLongTokenFundingAmountPerSize,\n            latestShortTokenFundingAmountPerSize\n        );\n\n        fees.totalNetCostAmount = fees.referral.affiliateRewardAmount + fees.feeReceiverAmount + fees.positionFeeAmountForPool + fees.funding.fundingFeeAmount + fees.borrowingFeeAmount;\n        fees.totalNetCostUsd = fees.totalNetCostAmount * collateralTokenPrice.max;\n\n        return fees;\n    }\n\n    function getFundingFees(\n        Position.Props memory position,\n        address longToken,\n        address shortToken,\n        int256 latestLongTokenFundingAmountPerSize,\n        int256 latestShortTokenFundingAmountPerSize\n    ) internal pure returns (PositionFundingFees memory) {\n        PositionFundingFees memory fundingFees;\n\n        fundingFees.latestLongTokenFundingAmountPerSize = latestLongTokenFundingAmountPerSize;\n        fundingFees.latestShortTokenFundingAmountPerSize = latestShortTokenFundingAmountPerSize;\n\n        int256 longTokenFundingFeeAmount;\n        int256 shortTokenFundingFeeAmount;\n\n        (fundingFees.hasPendingLongTokenFundingFee, longTokenFundingFeeAmount) = MarketUtils.getFundingFeeAmount(\n            fundingFees.latestLongTokenFundingAmountPerSize,\n            position.longTokenFundingAmountPerSize(),\n            position.sizeInUsd()\n        );\n\n        (fundingFees.hasPendingShortTokenFundingFee, shortTokenFundingFeeAmount) = MarketUtils.getFundingFeeAmount(\n            fundingFees.latestShortTokenFundingAmountPerSize,\n            position.shortTokenFundingAmountPerSize(),\n            position.sizeInUsd()\n        );\n\n        // if the position has negative funding fees, distribute it to allow it to be claimable\n        if (longTokenFundingFeeAmount < 0) {\n            fundingFees.claimableLongTokenAmount = (-longTokenFundingFeeAmount).toUint256();\n        }\n\n        if (shortTokenFundingFeeAmount < 0) {\n            fundingFees.claimableShortTokenAmount = (-shortTokenFundingFeeAmount).toUint256();\n        }\n\n        if (position.collateralToken() == longToken && longTokenFundingFeeAmount > 0) {\n            fundingFees.fundingFeeAmount = longTokenFundingFeeAmount.toUint256();\n        }\n\n        if (position.collateralToken() == shortToken && shortTokenFundingFeeAmount > 0) {\n            fundingFees.fundingFeeAmount = shortTokenFundingFeeAmount.toUint256();\n        }\n\n        return fundingFees;\n    }\n\n\n    // @dev get position fees after applying referral rebates / discounts\n    // @param dataStore DataStore\n    // @param referralStorage IReferralStorage\n    // @param collateralTokenPrice the price of the position's collateralToken\n    // @param the position's account\n    // @param market the position's market\n    // @param sizeDeltaUsd the change in position size\n    // @return (affiliate, traderDiscountAmount, affiliateRewardAmount, feeReceiverAmount, positionFeeAmountForPool)\n    function getPositionFeesAfterReferral(\n        DataStore dataStore,\n        IReferralStorage referralStorage,\n        Price.Props memory collateralTokenPrice,\n        address account,\n        address market,\n        uint256 sizeDeltaUsd\n    ) internal view returns (address, uint256, uint256, uint256, uint256) {\n        GetPositionFeesAfterReferralCache memory cache;\n\n        (cache.referral.affiliate, cache.referral.totalRebateFactor, cache.referral.traderDiscountFactor) = ReferralUtils.getReferralInfo(referralStorage, account);\n\n        cache.feeFactor = dataStore.getUint(Keys.positionFeeFactorKey(market));\n        cache.positionFeeAmount = Precision.applyFactor(sizeDeltaUsd, cache.feeFactor) / collateralTokenPrice.min;\n\n        cache.referral.totalRebateAmount = Precision.applyFactor(cache.positionFeeAmount, cache.referral.totalRebateFactor);\n        cache.referral.traderDiscountAmount = Precision.applyFactor(cache.referral.totalRebateAmount, cache.referral.traderDiscountFactor);\n        cache.referral.affiliateRewardAmount = cache.referral.totalRebateAmount - cache.referral.traderDiscountAmount;\n\n        cache.protocolFeeAmount = cache.positionFeeAmount - cache.referral.totalRebateAmount;\n\n        cache.positionFeeReceiverFactor = dataStore.getUint(Keys.POSITION_FEE_RECEIVER_FACTOR);\n        cache.feeReceiverAmount = Precision.applyFactor(cache.protocolFeeAmount, cache.positionFeeReceiverFactor);\n        cache.positionFeeAmountForPool = cache.protocolFeeAmount - cache.feeReceiverAmount;\n\n        return (cache.referral.affiliate, cache.referral.traderDiscountAmount, cache.referral.affiliateRewardAmount, cache.feeReceiverAmount, cache.positionFeeAmountForPool);\n    }\n\n    function emitPositionFeesCollected(\n        EventEmitter eventEmitter,\n        address market,\n        address collateralToken,\n        bool isIncrease,\n        PositionFees memory fees\n    ) external {\n        _emitPositionFees(\n            eventEmitter,\n            market,\n            collateralToken,\n            isIncrease,\n            fees,\n            \"PositionFeesCollected\"\n        );\n    }\n\n    function emitPositionFeesInfo(\n        EventEmitter eventEmitter,\n        address market,\n        address collateralToken,\n        bool isIncrease,\n        PositionFees memory fees\n    ) external {\n        _emitPositionFees(\n            eventEmitter,\n            market,\n            collateralToken,\n            isIncrease,\n            fees,\n            \"PositionFeesInfo\"\n        );\n    }\n\n    function _emitPositionFees(\n        EventEmitter eventEmitter,\n        address market,\n        address collateralToken,\n        bool isIncrease,\n        PositionFees memory fees,\n        string memory eventName\n    ) internal {\n        EventUtils.EventLogData memory eventData;\n\n        eventData.addressItems.initItems(3);\n        eventData.addressItems.setItem(0, \"market\", market);\n        eventData.addressItems.setItem(1, \"collateralToken\", collateralToken);\n        eventData.addressItems.setItem(2, \"affiliate\", fees.referral.affiliate);\n\n        eventData.uintItems.initItems(13);\n        eventData.uintItems.setItem(0, \"traderDiscountAmount\", fees.referral.traderDiscountAmount);\n        eventData.uintItems.setItem(1, \"affiliateRewardAmount\", fees.referral.affiliateRewardAmount);\n        eventData.uintItems.setItem(3, \"fundingFeeAmount\", fees.funding.fundingFeeAmount);\n        eventData.uintItems.setItem(4, \"claimableLongTokenAmount\", fees.funding.claimableLongTokenAmount);\n        eventData.uintItems.setItem(5, \"claimableShortTokenAmount\", fees.funding.claimableShortTokenAmount);\n        eventData.uintItems.setItem(6, \"feeReceiverAmount\", fees.feeReceiverAmount);\n        eventData.uintItems.setItem(7, \"feeAmountForPool\", fees.feeAmountForPool);\n        eventData.uintItems.setItem(8, \"positionFeeAmountForPool\", fees.positionFeeAmountForPool);\n        eventData.uintItems.setItem(9, \"positionFeeAmount\", fees.positionFeeAmount);\n        eventData.uintItems.setItem(10, \"borrowingFeeAmount\", fees.borrowingFeeAmount);\n        eventData.uintItems.setItem(11, \"totalNetCostAmount\", fees.totalNetCostAmount);\n        eventData.uintItems.setItem(12, \"totalNetCostUsd\", fees.totalNetCostUsd);\n\n        eventData.intItems.initItems(2);\n        eventData.intItems.setItem(0, \"latestLongTokenFundingAmountPerSize\", fees.funding.latestLongTokenFundingAmountPerSize);\n        eventData.intItems.setItem(1, \"latestShortTokenFundingAmountPerSize\", fees.funding.latestShortTokenFundingAmountPerSize);\n\n        eventData.boolItems.initItems(3);\n        eventData.boolItems.setItem(0, \"hasPendingLongTokenFundingFee\", fees.funding.hasPendingLongTokenFundingFee);\n        eventData.boolItems.setItem(1, \"hasPendingShortTokenFundingFee\", fees.funding.hasPendingShortTokenFundingFee);\n        eventData.boolItems.setItem(2, \"isIncrease\", isIncrease);\n\n        eventEmitter.emitEventLog1(\n            eventName,\n            Cast.toBytes32(market),\n            eventData\n        );\n    }\n}"
    }
  ]
}