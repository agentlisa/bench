{
  "Title": "[G-01] Run checks first",
  "Content": "<h2 id=\"g-01-run-checks-first\" style=\"position:relative;\"><a href=\"#g-01-run-checks-first\" aria-label=\"g 01 run checks first permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-01] Run checks first</h2>\n<p>Running checks before doing other operations can save gas in case the checks donâ€™t pass (since less operations were done before the revert).</p>\n<p>Lines: <a href=\"https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBDirectory.sol#L270-L278\">JBDirectory.sol#L270-L278</a></p>\n<p>Gas saved: Not measured by tests, can be a few dozen of thousands in case of revert (tested with a contract mocking the same behavior and 3 terminals)</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"diff\" data-index=\"31\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\"> </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-    // Delete the stored terminals for the project.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-    _terminalsOf[_projectId] = _terminals;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">     // Make sure duplicates were not added.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+    // @audit run checks before assigning, to save gas in case of revert</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">     if (_terminals.length &gt; 1)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">       for (uint256 _i; _i &lt; _terminals.length; _i++)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">         for (uint256 _j = _i + 1; _j &lt; _terminals.length; _j++)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">           if (_terminals[_i] == _terminals[_j]) revert DUPLICATE_TERMINALS();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\"> </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+    // Delete the stored terminals for the project.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+    _terminalsOf[_projectId] = _terminals;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">     emit SetTerminals(_projectId, _terminals, msg.sender);</span></span></span></code></pre>\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-07-juicebox-v2-contest",
  "Code": [
    {
      "filename": "contracts/JBDirectory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport './abstract/JBOperatable.sol';\nimport './interfaces/IJBDirectory.sol';\nimport './libraries/JBGlobalFundingCycleMetadataResolver.sol';\nimport './libraries/JBOperations.sol';\n\n/**\n  @notice\n  Keeps a reference of which terminal contracts each project is currently accepting funds through, and which controller contract is managing each project's tokens and funding cycles.\n\n  @dev\n  Adheres to -\n  IJBDirectory: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  JBOperatable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n  Ownable: Includes convenience functionality for checking a message sender's permissions before executing certain transactions.\n*/\ncontract JBDirectory is IJBDirectory, JBOperatable, Ownable {\n  // A library that parses the packed funding cycle metadata into a friendlier format.\n  using JBGlobalFundingCycleMetadataResolver for uint8;\n\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n  error DUPLICATE_TERMINALS();\n  error INVALID_PROJECT_ID_IN_DIRECTORY();\n  error SET_CONTROLLER_NOT_ALLOWED();\n  error SET_TERMINALS_NOT_ALLOWED();\n  error TOKEN_NOT_ACCEPTED();\n\n  //*********************************************************************//\n  // --------------------- private stored properties ------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    For each project ID, the terminals that are currently managing its funds.\n\n    _projectId The ID of the project to get terminals of.\n  */\n  mapping(uint256 => IJBPaymentTerminal[]) private _terminalsOf;\n\n  /**\n    @notice\n    The project's primary terminal for a token.\n\n    _projectId The ID of the project to get the primary terminal of.\n    _token The token to get the project's primary terminal of.\n  */\n  mapping(uint256 => mapping(address => IJBPaymentTerminal)) private _primaryTerminalOf;\n\n  //*********************************************************************//\n  // ---------------- public immutable stored properties --------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Mints ERC-721's that represent project ownership and transfers.\n  */\n  IJBProjects public immutable override projects;\n\n  /**\n    @notice\n    The contract storing all funding cycle configurations.\n  */\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  //*********************************************************************//\n  // --------------------- public stored properties -------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice \n    For each project ID, the controller that manages how terminals interact with tokens and funding cycles.\n\n    _projectId The ID of the project to get the controller of.\n  */\n  mapping(uint256 => address) public override controllerOf;\n\n  /**\n    @notice\n    Addresses that can set a project's first controller on their behalf. These addresses/contracts have been vetted and verified by this contract's owner.\n\n    _address The address that is either allowed or not.\n  */\n  mapping(address => bool) public override isAllowedToSetFirstController;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    For each project ID, the terminals that are currently managing its funds.\n\n    @param _projectId The ID of the project to get terminals of.\n\n    @return An array of terminal addresses.\n  */\n  function terminalsOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (IJBPaymentTerminal[] memory)\n  {\n    return _terminalsOf[_projectId];\n  }\n\n  /**\n    @notice\n    The primary terminal that is managing funds for a project for a specified token.\n\n    @dev\n    The zero address is returned if a terminal isn't found for the specified token.\n\n    @param _projectId The ID of the project to get a terminal for.\n    @param _token The token the terminal accepts.\n\n    @return The primary terminal for the project for the specified token.\n  */\n  function primaryTerminalOf(uint256 _projectId, address _token)\n    external\n    view\n    override\n    returns (IJBPaymentTerminal)\n  {\n    // If a primary terminal for the token was specifically set and its one of the project's terminals, return it.\n    if (\n      _primaryTerminalOf[_projectId][_token] != IJBPaymentTerminal(address(0)) &&\n      isTerminalOf(_projectId, _primaryTerminalOf[_projectId][_token])\n    ) return _primaryTerminalOf[_projectId][_token];\n\n    // Return the first terminal which accepts the specified token.\n    for (uint256 _i; _i < _terminalsOf[_projectId].length; _i++) {\n      IJBPaymentTerminal _terminal = _terminalsOf[_projectId][_i];\n      if (_terminal.acceptsToken(_token, _projectId)) return _terminal;\n    }\n\n    // Not found.\n    return IJBPaymentTerminal(address(0));\n  }\n\n  //*********************************************************************//\n  // -------------------------- public views --------------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Whether or not a specified terminal is a terminal of the specified project.\n\n    @param _projectId The ID of the project to check within.\n    @param _terminal The address of the terminal to check for.\n\n    @return A flag indicating whether or not the specified terminal is a terminal of the specified project.\n  */\n  function isTerminalOf(uint256 _projectId, IJBPaymentTerminal _terminal)\n    public\n    view\n    override\n    returns (bool)\n  {\n    for (uint256 _i; _i < _terminalsOf[_projectId].length; _i++)\n      if (_terminalsOf[_projectId][_i] == _terminal) return true;\n    return false;\n  }\n\n  //*********************************************************************//\n  // -------------------------- constructor ---------------------------- //\n  //*********************************************************************//\n\n  /**\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _owner The address that will own the contract.\n  */\n  constructor(\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBFundingCycleStore _fundingCycleStore,\n    address _owner\n  ) JBOperatable(_operatorStore) {\n    projects = _projects;\n    fundingCycleStore = _fundingCycleStore;\n\n    _transferOwnership(_owner);\n  }\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Update the controller that manages how terminals interact with the ecosystem.\n\n    @dev\n    A controller can be set if:\n    - the message sender is the project owner or an operator having the correct authorization.\n    - the message sender is the project's current controller.\n    - or, an allowedlisted address is setting a controller for a project that doesn't already have a controller.\n\n    @param _projectId The ID of the project to set a new controller for.\n    @param _controller The new controller to set.\n  */\n  function setControllerOf(uint256 _projectId, address _controller)\n    external\n    override\n    requirePermissionAllowingOverride(\n      projects.ownerOf(_projectId),\n      _projectId,\n      JBOperations.SET_CONTROLLER,\n      (msg.sender == address(controllerOf[_projectId]) ||\n        (isAllowedToSetFirstController[msg.sender] && controllerOf[_projectId] == address(0)))\n    )\n  {\n    // The project must exist.\n    if (projects.count() < _projectId) revert INVALID_PROJECT_ID_IN_DIRECTORY();\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Setting controller is allowed if called from the current controller, or if the project doesn't have a current controller, or if the project's funding cycle allows setting the controller. Revert otherwise.\n    if (\n      msg.sender != address(controllerOf[_projectId]) &&\n      controllerOf[_projectId] != address(0) &&\n      !uint8(_fundingCycle.metadata >> 8).setControllerAllowed()\n    ) revert SET_CONTROLLER_NOT_ALLOWED();\n\n    // Set the new controller.\n    controllerOf[_projectId] = _controller;\n\n    emit SetController(_projectId, _controller, msg.sender);\n  }\n\n  /** \n    @notice \n    Set a project's terminals.\n\n    @dev\n    Only a project owner, an operator, or its controller can set its terminals.\n\n    @param _projectId The ID of the project having terminals set.\n    @param _terminals The terminal to set.\n  */\n  function setTerminalsOf(uint256 _projectId, IJBPaymentTerminal[] calldata _terminals)\n    external\n    override\n    requirePermissionAllowingOverride(\n      projects.ownerOf(_projectId),\n      _projectId,\n      JBOperations.SET_TERMINALS,\n      msg.sender == address(controllerOf[_projectId])\n    )\n  {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Setting terminals must be allowed if not called from the current controller.\n    if (\n      msg.sender != address(controllerOf[_projectId]) &&\n      !uint8(_fundingCycle.metadata >> 8).setTerminalsAllowed()\n    ) revert SET_TERMINALS_NOT_ALLOWED();\n\n    // Delete the stored terminals for the project.\n    _terminalsOf[_projectId] = _terminals;\n\n    // Make sure duplicates were not added.\n    if (_terminals.length > 1)\n      for (uint256 _i; _i < _terminals.length; _i++)\n        for (uint256 _j = _i + 1; _j < _terminals.length; _j++)\n          if (_terminals[_i] == _terminals[_j]) revert DUPLICATE_TERMINALS();\n\n    emit SetTerminals(_projectId, _terminals, msg.sender);\n  }\n\n  /**\n    @notice\n    Project's can set which terminal should be their primary for a particular token.\n    This is useful in case a project has several terminals connected for a particular token.\n\n    @dev\n    The terminal will be set as the primary terminal where ecosystem contracts should route tokens.\n\n    @dev\n    If setting a newly added terminal and the funding cycle doesn't allow new terminals, the caller must be the current controller.\n\n    @param _projectId The ID of the project for which a primary token is being set.\n    @param _token The token to set the primary terminal of.\n    @param _terminal The terminal to make primary.\n  */\n  function setPrimaryTerminalOf(\n    uint256 _projectId,\n    address _token,\n    IJBPaymentTerminal _terminal\n  )\n    external\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.SET_PRIMARY_TERMINAL)\n  {\n    // Can't set the primary terminal for a token if it doesn't accept the token.\n    if (!_terminal.acceptsToken(_token, _projectId)) revert TOKEN_NOT_ACCEPTED();\n\n    // Add the terminal to the project if it hasn't been already.\n    _addTerminalIfNeeded(_projectId, _terminal);\n\n    // Store the terminal as the primary for the particular token.\n    _primaryTerminalOf[_projectId][_token] = _terminal;\n\n    emit SetPrimaryTerminal(_projectId, _token, _terminal, msg.sender);\n  }\n\n  /** \n    @notice\t\n    Set a contract to the list of trusted addresses that can set a first controller for any project.\t\n\n    @dev\n    The owner can add addresses which are allowed to change projects' first controllers. \n    These addresses are known and vetted controllers as well as contracts designed to launch new projects. \n    A project can set its own controller without it being on the allow list.\n\n    @dev\n    If you would like an address/contract allowlisted, please reach out to the contract owner.\n\n    @param _address The address to allow or revoke allowance from.\n    @param _flag Whether allowance is being added or revoked.\n  */\n  function setIsAllowedToSetFirstController(address _address, bool _flag)\n    external\n    override\n    onlyOwner\n  {\n    // Set the flag in the allowlist.\n    isAllowedToSetFirstController[_address] = _flag;\n\n    emit SetIsAllowedToSetFirstController(_address, _flag, msg.sender);\n  }\n\n  //*********************************************************************//\n  // --------------------- private helper functions -------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Add a terminal to a project's list of terminals if it hasn't been already.\n\n    @param _projectId The ID of the project having a terminal added.\n    @param _terminal The terminal to add.\n  */\n  function _addTerminalIfNeeded(uint256 _projectId, IJBPaymentTerminal _terminal) private {\n    // Check that the terminal has not already been added.\n    if (isTerminalOf(_projectId, _terminal)) return;\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Setting terminals must be allowed if not called from the current controller.\n    if (\n      msg.sender != address(controllerOf[_projectId]) &&\n      !uint8(_fundingCycle.metadata >> 8).setTerminalsAllowed()\n    ) revert SET_TERMINALS_NOT_ALLOWED();\n\n    // Add the new terminal.\n    _terminalsOf[_projectId].push(_terminal);\n\n    emit AddTerminal(_projectId, _terminal, msg.sender);\n  }\n}"
    }
  ]
}