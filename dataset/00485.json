{
  "Title": "M-12: The current idea of ​​creating reETH and accepting several different assets in it exposes RIO users to losses",
  "Content": "# Issue M-12: The current idea of ​​creating reETH and accepting several different assets in it exposes RIO users to losses \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/386 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nComposableSecurity, PNS, fugazzi, shaka, zzykxx\n\n## Summary\nAfter the release of LRT, which will include the ability to deposit native eth and wrapped staking tokens like cbETH or wstETH, Rio users will be exposed to additional economic risks that may lead to loss of capital. In case of a predictable price drop (e.g. caused by a slashing event in an external liquid staking provider), external users can deposit their funds into Rio before the price drop. They will receive the LRT (corresponding to the value before the price drop, as priceFeed displays the changed price only when it actually happens) and withdraw them once the price drops, sharing their loss with Rio users.\n\n## Vulnerability Detail\nRio creates a network for issuing Liquid Restaking Tokens (LRTs) that have an underlying asset mix. The idea is to have multiple LRTs like: reUSD, reETH, reXXX, where for reUSD underlying asset mix will include e.g. USDC, DAI, USDT and for reETH underlying asset mix will include native ETH and e.g. cbETH (as it is used in tests), or wstETH.\n\nUsers depositing their funds into Rio are encouraged by the rewards of staking and re-staking through EigenLayer, but they also bear the risk of penalties and slashing of their deposited funds. However, in case of reETH, the 3rd party users who are not associated in any way with Rio ecosystem can take advantage of such LRT and make Rio users bear their losses.\n\nKeeping in mind these things:\n- value of assets like wstETH, cbETH generally increase over time,\n- there are price drops for assets like wstETH, cbETH, but most of the time these are temporary,\n- things that can cause price drops for assets like wstETH, cbETH include: slashing, lower demand / lack of trust for particular asset, withdrawal caused by people who accumulated big rewards over time,\n- lower demand / lack of trust is unpredictable, however, big withdrawals can be monitored and slashing is a process spread over time, so there is a time when you know the value of asset will drop,\n- liquid staking providers like LIDO etc., protects themselves from \"withdrawal before slashing\" by making withdrawal process long enough so that slashing can affect the users who request to withdraw,\n- user within Rio ecosystem can deposit asset1 to get LRT, and then request to withdraw asset2.\n\nConsider the following scenario (**values used for ease of calculation and to illustrate the attack**, real values will be presented later in this description):\n\nRio issues LRT (reETH) that supports two assets (cbETH and native ETH).\n\n1. 200 ETH is deposited inside RIO by users and 200 reETH were minted.\n\n2. The attacker (cbETH staker) has 100 cbETH (price is e.g. 1 cbETH = 2 ETH, their cbETH is worth 200 ETH)\n\nThe attacker knows through monitoring slashing events and big withdrawalas that price will drop soon.\n\n3. The attacker deposit their 100 cbETH to Rio to get 200 reETH (as current price is still 1 cbETH = 2 ETH)\n\nTotal value locked on Rio will increase from 200 ETH to 400 ETH (200 eth and 100 cbETH)\n\nPrice of cbETH now drops by 50% (so now 1 cbETH = 1 ETH)\n\nTotal value locked on Rio will decrease from 400 ETH to 300 ETH (as 200cbETH is now worth only 100 ETH).\n\n4. The attacker decides to request withdraw all of their cbETH by burning only 150 reETH and they also request to withdraw 50 ETH by burning another 100 reETH.\n\n5. Attacker gets 200 cbETH back (current price is 100 ETH) and additional 50 ETH.\n\n6. Attacker buys additional cbETH for their additional 50 ETH, so know they have 250 cbETH (from another source)\n\nNow price recover, so its again 1 cbETH = 2 ETH.\n\nAttacker now have 250 cbETH worth 500 ETH, and Rio users have 150 ETH (lost 50 ETH, as attacker delegeted their risk to rio users).\n\n\nHowever, the price will not drop by 50%. The real numbers could be up to 10%.\n\nLooking at 2 examples of assets that are considered to be added to reETH (cbETH and wstETH) we can observe the following:\n\n1. cbETH (https://coinmarketcap.com/currencies/coinbase-wrapped-staked-eth/)\n\n* there are price drops\n* based on data from last 365 days the biggest percentage drop in price occurred on March 11, 2023, with a drop of approximately 8.25% (https://coinmarketcap.com/currencies/lido-finance-wsteth/historical-data/) (https://coinmarketcap.com/currencies/coinbase-wrapped-staked-eth/historical-data/)\n\n2. wstETH (https://coinmarketcap.com/currencies/lido-finance-wsteth/)\n\n* there are price drops\n* based on data from last 365 days the biggest percentage drop in price occurred also on March 11, 2023, with a drop of approximately 9.28% (https://coinmarketcap.com/currencies/lido-finance-wsteth/historical-data/)\n\n\n## Impact\nMEDIUM - as it require conditions that needs to be satisfied (observed in advance price drop) and funds which cannot be possed in flash-loan to increase the impact of the vulnerability.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol#L99\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol#L101C22-L101C56\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThe problem is not easy to fix and several security mechanisms can be used:\n- users could be allowed to withdraw only the type of assets they deposit\n- you can monitor price drop events and temporarily freeze deposits\n- you can set a minimum period for the user between his deposit and withdrawal so that he cannot take advantage of price fluctuations\n- single LRTs can be issued for assets that are subject to such events (price drops predicted some time in advance)\n\n\n\n## Discussion\n\n**nevillehuang**\n\nMaintaining as valid medium, given I believe this should have been made known as accepted risks in the contest details\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IRioLRTWithdrawalQueue} from 'contracts/interfaces/IRioLRTWithdrawalQueue.sol';\nimport {UUPSUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {IRioLRTAssetRegistry} from 'contracts/interfaces/IRioLRTAssetRegistry.sol';\nimport {ETH_ADDRESS, MAX_REBALANCE_DELAY} from 'contracts/utils/Constants.sol';\nimport {IRioLRTCoordinator} from 'contracts/interfaces/IRioLRTCoordinator.sol';\nimport {OperatorOperations} from 'contracts/utils/OperatorOperations.sol';\nimport {RioLRTCore} from 'contracts/restaking/base/RioLRTCore.sol';\nimport {ETH_ADDRESS} from 'contracts/utils/Constants.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\n\ncontract RioLRTCoordinator is IRioLRTCoordinator, OwnableUpgradeable, UUPSUpgradeable, RioLRTCore {\n    using SafeERC20 for *;\n    using Asset for *;\n\n    /// @notice The required delay between rebalances.\n    uint24 public rebalanceDelay;\n\n    /// @notice Tracks the timestamp from which each asset is eligible for rebalancing, inclusive of the defined timestamp.\n    mapping(address asset => uint256 timestamp) public assetNextRebalanceAfter;\n\n    /// @notice Require that the asset is supported, the deposit amount is non-zero, and the\n    /// deposit cap has not been reached.\n    /// @param asset The asset being deposited.\n    /// @param amountIn The amount of the asset being deposited.\n    modifier checkDeposit(address asset, uint256 amountIn) {\n        _checkAssetSupported(asset);\n        _checkAmountGreaterThanZero(amountIn);\n        _checkDepositCapReached(asset, amountIn);\n        _;\n    }\n\n    /// @notice Require that the asset is supported and the withdrawal amount is non-zero.\n    /// @param asset The asset being deposited.\n    /// @param amountIn The amount of the asset being deposited.\n    modifier checkWithdrawal(address asset, uint256 amountIn) {\n        _checkAssetSupported(asset);\n        _checkAmountGreaterThanZero(amountIn);\n        _;\n    }\n\n    /// @notice Require that the rebalance delay has been met.\n    /// @param asset The asset being rebalanced.\n    modifier checkRebalanceDelayMet(address asset) {\n        _checkRebalanceDelayMet(asset);\n        _;\n    }\n\n    /// @param issuer_ The LRT issuer that's authorized to deploy this contract.\n    constructor(address issuer_) RioLRTCore(issuer_) {}\n\n    /// @dev Initializes the contract.\n    /// @param initialOwner The owner of the contract.\n    /// @param token_ The address of the liquid restaking token.\n    function initialize(address initialOwner, address token_) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n        __RioLRTCore_init(token_);\n\n        _setRebalanceDelay(24 hours);\n    }\n\n    /// @notice Returns the total value of all underlying assets in the unit of account.\n    function getTVL() public view returns (uint256 value) {\n        return assetRegistry().getTVL();\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Deposits ERC20 tokens and mints restaking token(s) to the caller.\n    /// @param asset The asset being deposited.\n    /// @param amountIn The amount of the asset being deposited.\n    function deposit(address asset, uint256 amountIn) external checkDeposit(asset, amountIn) returns (uint256 amountOut) {\n        // Convert deposited asset amount to restaking tokens.\n        amountOut = convertFromAssetToRestakingTokens(asset, amountIn);\n\n        // Pull tokens from the sender to the deposit pool.\n        IERC20(asset).safeTransferFrom(msg.sender, address(depositPool()), amountIn);\n\n        // Mint restaking tokens to the caller.\n        token.mint(msg.sender, amountOut);\n\n        emit Deposited(msg.sender, asset, amountIn, amountOut);\n    }\n\n    /// @notice Deposits ETH and mints restaking token(s) to the caller.\n    function depositETH() external payable returns (uint256) {\n        return _depositETH();\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Requests a withdrawal to `asset` for `amountIn` restaking tokens.\n    /// @param asset The asset being withdrawn.\n    /// @param amountIn The amount of restaking tokens being redeemed.\n    function requestWithdrawal(address asset, uint256 amountIn) external checkWithdrawal(asset, amountIn) returns (uint256 sharesOwed) {\n        // Determine the amount of shares owed to the withdrawer using the current exchange rate.\n        sharesOwed = convertToSharesFromRestakingTokens(asset, amountIn);\n\n        // If requesting ETH, reduce the precision of the shares owed to the nearest Gwei,\n        // which is the smallest unit of account supported by EigenLayer.\n        if (asset == ETH_ADDRESS) sharesOwed = sharesOwed.reducePrecisionToGwei();\n\n        // Pull restaking tokens from the sender to the withdrawal queue.\n        token.safeTransferFrom(msg.sender, address(withdrawalQueue()), amountIn);\n\n        // Ensure there are enough shares to cover the withdrawal request, and queue the withdrawal.\n        uint256 availableShares = assetRegistry().convertToSharesFromAsset(asset, assetRegistry().getTotalBalanceForAsset(asset));\n        if (sharesOwed > availableShares - withdrawalQueue().getSharesOwedInCurrentEpoch(asset)) {\n            revert INSUFFICIENT_SHARES_FOR_WITHDRAWAL();\n        }\n        withdrawalQueue().queueWithdrawal(msg.sender, asset, sharesOwed, amountIn);\n    }\n\n    /// @notice Rebalances the provided `asset` by processing outstanding withdrawals and\n    /// depositing remaining assets into EigenLayer.\n    /// @param asset The asset to rebalance.\n    function rebalance(address asset) external checkRebalanceDelayMet(asset) {\n        if (!assetRegistry().isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n        if (msg.sender != tx.origin) revert CALLER_MUST_BE_EOA();\n\n        // Process any outstanding withdrawals using funds from the deposit pool and EigenLayer.\n        uint256 sharesOwed = withdrawalQueue().getSharesOwedInCurrentEpoch(asset);\n        if (sharesOwed > 0) {\n            _processUserWithdrawalsForCurrentEpoch(asset, sharesOwed);\n        }\n\n        // Deposit remaining assets into EigenLayer.\n        (uint256 sharesReceived, bool isDepositCapped) = depositPool().depositBalanceIntoEigenLayer(asset);\n        if (sharesOwed == 0 && sharesReceived == 0) {\n            revert NO_REBALANCE_NEEDED();\n        }\n        if (sharesReceived > 0) {\n            if (asset == ETH_ADDRESS) {\n                assetRegistry().increaseUnverifiedValidatorETHBalance(sharesReceived);\n            } else {\n                assetRegistry().increaseSharesHeldForAsset(asset, sharesReceived);\n            }\n        }\n\n        // When the deposit is not capped, the rebalance is considered complete, and the asset rebalance\n        // timestamp is increased by the specified delay. If capped, the asset may be rebalanced again\n        // immediately as there are more assets to deposit.\n        if (!isDepositCapped) {\n            assetNextRebalanceAfter[asset] = uint40(block.timestamp) + rebalanceDelay;\n        }\n        emit Rebalanced(asset);\n    }\n\n    /// @notice Sets the rebalance delay.\n    /// @param newRebalanceDelay The new rebalance delay, in seconds.\n    function setRebalanceDelay(uint24 newRebalanceDelay) external onlyOwner {\n        _setRebalanceDelay(newRebalanceDelay);\n    }\n\n    /// @notice Converts the unit of account value to its equivalent in restaking tokens.\n    /// The unit of account is the price feed's quote asset.\n    /// @param value The restaking token's value in the unit of account.\n    function convertFromUnitOfAccountToRestakingTokens(uint256 value) public view returns (uint256) {\n        uint256 tvl = getTVL();\n        uint256 supply = token.totalSupply();\n\n        if (supply == 0) {\n            return value;\n        }\n        return value * supply / tvl;\n    }\n\n    /// @notice Converts an amount of restaking tokens to its equivalent value in the unit of account.\n    /// The unit of account is the price feed's quote asset.\n    /// @param amount The amount of restaking tokens to convert.\n    function convertToUnitOfAccountFromRestakingTokens(uint256 amount) public view returns (uint256) {\n        uint256 tvl = getTVL();\n        uint256 supply = token.totalSupply();\n\n        if (supply == 0) {\n            return amount;\n        }\n        return tvl * amount / supply;\n    }\n\n    /// @notice Converts an asset amount to its equivalent value in restaking tokens.\n    /// @param asset The address of the asset to convert.\n    /// @param amount The amount of the asset to convert.\n    function convertFromAssetToRestakingTokens(address asset, uint256 amount) public view returns (uint256) {\n        uint256 value = assetRegistry().convertToUnitOfAccountFromAsset(asset, amount);\n        return convertFromUnitOfAccountToRestakingTokens(value);\n    }\n\n    /// @notice Converts an amount of restaking tokens to the equivalent in the asset.\n    /// @param asset The address of the asset to convert to.\n    /// @param amount The amount of restaking tokens to convert.\n    function convertToAssetFromRestakingTokens(address asset, uint256 amount) public view returns (uint256) {\n        uint256 value = convertToUnitOfAccountFromRestakingTokens(amount);\n        return assetRegistry().convertFromUnitOfAccountToAsset(asset, value);\n    }\n\n    /// @notice Converts an amount of restaking tokens to the equivalent in the provided\n    /// asset's EigenLayer shares.\n    /// @param asset The address of the asset whose EigenLayer shares to convert to.\n    /// @param amount The amount of restaking tokens to convert.\n    function convertToSharesFromRestakingTokens(address asset, uint256 amount) public view returns (uint256 shares) {\n        uint256 assetAmount = convertToAssetFromRestakingTokens(asset, amount);\n        return assetRegistry().convertToSharesFromAsset(asset, assetAmount);\n    }\n\n    /// @notice Deposits ETH and mints restaking token(s) to the caller.\n    receive() external payable {\n        _depositETH();\n    }\n\n    /// @notice Deposits ETH and mints restaking token(s) to the caller.\n    /// @dev This function assumes that the quote asset is ETH.\n    function _depositETH() internal checkDeposit(ETH_ADDRESS, msg.value) returns (uint256 amountOut) {\n        // Convert deposited ETH to restaking tokens and mint to the caller.\n        amountOut = convertFromUnitOfAccountToRestakingTokens(msg.value);\n\n        // Forward ETH to the deposit pool.\n        address(depositPool()).transferETH(msg.value);\n\n        // Mint restaking tokens to the caller.\n        token.mint(msg.sender, amountOut);\n\n        emit Deposited(msg.sender, ETH_ADDRESS, msg.value, amountOut);\n    }\n\n    /// @dev Sets the rebalance delay.\n    /// @param newRebalanceDelay The new rebalance delay, in seconds.\n    function _setRebalanceDelay(uint24 newRebalanceDelay) internal {\n        if (newRebalanceDelay > MAX_REBALANCE_DELAY) revert REBALANCE_DELAY_TOO_LONG();\n        rebalanceDelay = newRebalanceDelay;\n\n        emit RebalanceDelaySet(newRebalanceDelay);\n    }\n\n    // forgefmt: disable-next-item\n    /// @dev Processes user withdrawals for the provided asset by transferring available\n    /// assets from the deposit pool and queueing any remaining amount for withdrawal from\n    /// EigenLayer.\n    /// @param asset The asset being withdrawn.\n    /// @param sharesOwed The amount of shares owed to users.\n    function _processUserWithdrawalsForCurrentEpoch(address asset, uint256 sharesOwed) internal {\n        IRioLRTWithdrawalQueue withdrawalQueue_ = withdrawalQueue();\n        (uint256 assetsSent, uint256 sharesSent) = depositPool().transferMaxAssetsForShares(\n            asset,\n            sharesOwed,\n            address(withdrawalQueue_)\n        );\n        uint256 sharesRemaining = sharesOwed - sharesSent;\n\n        // Exit early if all pending withdrawals were paid from the deposit pool.\n        if (sharesRemaining == 0) {\n            withdrawalQueue_.settleCurrentEpoch(asset, assetsSent, sharesSent);\n            return;\n        }\n\n        address strategy = assetRegistry().getAssetStrategy(asset);\n        bytes32 aggregateRoot = OperatorOperations.queueWithdrawalFromOperatorsForUserSettlement(\n            operatorRegistry(),\n            strategy,\n            sharesRemaining\n        );\n        withdrawalQueue_.queueCurrentEpochSettlement(asset, assetsSent, sharesSent, aggregateRoot);\n    }\n\n    /// @dev Checks if the provided asset is supported.\n    /// @param asset The address of the asset.\n    function _checkAssetSupported(address asset) internal view {\n        if (!assetRegistry().isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n    }\n\n    /// @dev Checks if the provided amount is greater than zero.\n    /// @param amount The amount being checked.\n    function _checkAmountGreaterThanZero(uint256 amount) internal pure {\n        if (amount == 0) revert AMOUNT_MUST_BE_GREATER_THAN_ZERO();\n    }\n\n    /// @dev Checks if the deposit cap for the asset has been reached.\n    /// @param asset The address of the asset.\n    /// @param amountIn The amount of the asset being deposited.\n    function _checkDepositCapReached(address asset, uint256 amountIn) internal view {\n        IRioLRTAssetRegistry assetRegistry_ = assetRegistry();\n\n        uint256 depositCap = assetRegistry_.getAssetDepositCap(asset);\n        if (depositCap > 0) {\n            uint256 existingBalance = assetRegistry_.getTotalBalanceForAsset(asset);\n            if (existingBalance + amountIn > depositCap) {\n                revert DEPOSIT_CAP_REACHED(asset, depositCap);\n            }\n        }\n    }\n\n    /// @dev Reverts if the rebalance delay has not been met.\n    /// @param asset The asset being rebalanced.\n    function _checkRebalanceDelayMet(address asset) internal view {\n        if (block.timestamp < assetNextRebalanceAfter[asset]) revert REBALANCE_DELAY_NOT_MET();\n    }\n\n    /// @dev Allows the owner to upgrade the gateway implementation.\n    /// @param newImplementation The implementation to upgrade to.\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}"
    },
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IRioLRTWithdrawalQueue} from 'contracts/interfaces/IRioLRTWithdrawalQueue.sol';\nimport {UUPSUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {IRioLRTAssetRegistry} from 'contracts/interfaces/IRioLRTAssetRegistry.sol';\nimport {ETH_ADDRESS, MAX_REBALANCE_DELAY} from 'contracts/utils/Constants.sol';\nimport {IRioLRTCoordinator} from 'contracts/interfaces/IRioLRTCoordinator.sol';\nimport {OperatorOperations} from 'contracts/utils/OperatorOperations.sol';\nimport {RioLRTCore} from 'contracts/restaking/base/RioLRTCore.sol';\nimport {ETH_ADDRESS} from 'contracts/utils/Constants.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\n\ncontract RioLRTCoordinator is IRioLRTCoordinator, OwnableUpgradeable, UUPSUpgradeable, RioLRTCore {\n    using SafeERC20 for *;\n    using Asset for *;\n\n    /// @notice The required delay between rebalances.\n    uint24 public rebalanceDelay;\n\n    /// @notice Tracks the timestamp from which each asset is eligible for rebalancing, inclusive of the defined timestamp.\n    mapping(address asset => uint256 timestamp) public assetNextRebalanceAfter;\n\n    /// @notice Require that the asset is supported, the deposit amount is non-zero, and the\n    /// deposit cap has not been reached.\n    /// @param asset The asset being deposited.\n    /// @param amountIn The amount of the asset being deposited.\n    modifier checkDeposit(address asset, uint256 amountIn) {\n        _checkAssetSupported(asset);\n        _checkAmountGreaterThanZero(amountIn);\n        _checkDepositCapReached(asset, amountIn);\n        _;\n    }\n\n    /// @notice Require that the asset is supported and the withdrawal amount is non-zero.\n    /// @param asset The asset being deposited.\n    /// @param amountIn The amount of the asset being deposited.\n    modifier checkWithdrawal(address asset, uint256 amountIn) {\n        _checkAssetSupported(asset);\n        _checkAmountGreaterThanZero(amountIn);\n        _;\n    }\n\n    /// @notice Require that the rebalance delay has been met.\n    /// @param asset The asset being rebalanced.\n    modifier checkRebalanceDelayMet(address asset) {\n        _checkRebalanceDelayMet(asset);\n        _;\n    }\n\n    /// @param issuer_ The LRT issuer that's authorized to deploy this contract.\n    constructor(address issuer_) RioLRTCore(issuer_) {}\n\n    /// @dev Initializes the contract.\n    /// @param initialOwner The owner of the contract.\n    /// @param token_ The address of the liquid restaking token.\n    function initialize(address initialOwner, address token_) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n        __RioLRTCore_init(token_);\n\n        _setRebalanceDelay(24 hours);\n    }\n\n    /// @notice Returns the total value of all underlying assets in the unit of account.\n    function getTVL() public view returns (uint256 value) {\n        return assetRegistry().getTVL();\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Deposits ERC20 tokens and mints restaking token(s) to the caller.\n    /// @param asset The asset being deposited.\n    /// @param amountIn The amount of the asset being deposited.\n    function deposit(address asset, uint256 amountIn) external checkDeposit(asset, amountIn) returns (uint256 amountOut) {\n        // Convert deposited asset amount to restaking tokens.\n        amountOut = convertFromAssetToRestakingTokens(asset, amountIn);\n\n        // Pull tokens from the sender to the deposit pool.\n        IERC20(asset).safeTransferFrom(msg.sender, address(depositPool()), amountIn);\n\n        // Mint restaking tokens to the caller.\n        token.mint(msg.sender, amountOut);\n\n        emit Deposited(msg.sender, asset, amountIn, amountOut);\n    }\n\n    /// @notice Deposits ETH and mints restaking token(s) to the caller.\n    function depositETH() external payable returns (uint256) {\n        return _depositETH();\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Requests a withdrawal to `asset` for `amountIn` restaking tokens.\n    /// @param asset The asset being withdrawn.\n    /// @param amountIn The amount of restaking tokens being redeemed.\n    function requestWithdrawal(address asset, uint256 amountIn) external checkWithdrawal(asset, amountIn) returns (uint256 sharesOwed) {\n        // Determine the amount of shares owed to the withdrawer using the current exchange rate.\n        sharesOwed = convertToSharesFromRestakingTokens(asset, amountIn);\n\n        // If requesting ETH, reduce the precision of the shares owed to the nearest Gwei,\n        // which is the smallest unit of account supported by EigenLayer.\n        if (asset == ETH_ADDRESS) sharesOwed = sharesOwed.reducePrecisionToGwei();\n\n        // Pull restaking tokens from the sender to the withdrawal queue.\n        token.safeTransferFrom(msg.sender, address(withdrawalQueue()), amountIn);\n\n        // Ensure there are enough shares to cover the withdrawal request, and queue the withdrawal.\n        uint256 availableShares = assetRegistry().convertToSharesFromAsset(asset, assetRegistry().getTotalBalanceForAsset(asset));\n        if (sharesOwed > availableShares - withdrawalQueue().getSharesOwedInCurrentEpoch(asset)) {\n            revert INSUFFICIENT_SHARES_FOR_WITHDRAWAL();\n        }\n        withdrawalQueue().queueWithdrawal(msg.sender, asset, sharesOwed, amountIn);\n    }\n\n    /// @notice Rebalances the provided `asset` by processing outstanding withdrawals and\n    /// depositing remaining assets into EigenLayer.\n    /// @param asset The asset to rebalance.\n    function rebalance(address asset) external checkRebalanceDelayMet(asset) {\n        if (!assetRegistry().isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n        if (msg.sender != tx.origin) revert CALLER_MUST_BE_EOA();\n\n        // Process any outstanding withdrawals using funds from the deposit pool and EigenLayer.\n        uint256 sharesOwed = withdrawalQueue().getSharesOwedInCurrentEpoch(asset);\n        if (sharesOwed > 0) {\n            _processUserWithdrawalsForCurrentEpoch(asset, sharesOwed);\n        }\n\n        // Deposit remaining assets into EigenLayer.\n        (uint256 sharesReceived, bool isDepositCapped) = depositPool().depositBalanceIntoEigenLayer(asset);\n        if (sharesOwed == 0 && sharesReceived == 0) {\n            revert NO_REBALANCE_NEEDED();\n        }\n        if (sharesReceived > 0) {\n            if (asset == ETH_ADDRESS) {\n                assetRegistry().increaseUnverifiedValidatorETHBalance(sharesReceived);\n            } else {\n                assetRegistry().increaseSharesHeldForAsset(asset, sharesReceived);\n            }\n        }\n\n        // When the deposit is not capped, the rebalance is considered complete, and the asset rebalance\n        // timestamp is increased by the specified delay. If capped, the asset may be rebalanced again\n        // immediately as there are more assets to deposit.\n        if (!isDepositCapped) {\n            assetNextRebalanceAfter[asset] = uint40(block.timestamp) + rebalanceDelay;\n        }\n        emit Rebalanced(asset);\n    }\n\n    /// @notice Sets the rebalance delay.\n    /// @param newRebalanceDelay The new rebalance delay, in seconds.\n    function setRebalanceDelay(uint24 newRebalanceDelay) external onlyOwner {\n        _setRebalanceDelay(newRebalanceDelay);\n    }\n\n    /// @notice Converts the unit of account value to its equivalent in restaking tokens.\n    /// The unit of account is the price feed's quote asset.\n    /// @param value The restaking token's value in the unit of account.\n    function convertFromUnitOfAccountToRestakingTokens(uint256 value) public view returns (uint256) {\n        uint256 tvl = getTVL();\n        uint256 supply = token.totalSupply();\n\n        if (supply == 0) {\n            return value;\n        }\n        return value * supply / tvl;\n    }\n\n    /// @notice Converts an amount of restaking tokens to its equivalent value in the unit of account.\n    /// The unit of account is the price feed's quote asset.\n    /// @param amount The amount of restaking tokens to convert.\n    function convertToUnitOfAccountFromRestakingTokens(uint256 amount) public view returns (uint256) {\n        uint256 tvl = getTVL();\n        uint256 supply = token.totalSupply();\n\n        if (supply == 0) {\n            return amount;\n        }\n        return tvl * amount / supply;\n    }\n\n    /// @notice Converts an asset amount to its equivalent value in restaking tokens.\n    /// @param asset The address of the asset to convert.\n    /// @param amount The amount of the asset to convert.\n    function convertFromAssetToRestakingTokens(address asset, uint256 amount) public view returns (uint256) {\n        uint256 value = assetRegistry().convertToUnitOfAccountFromAsset(asset, amount);\n        return convertFromUnitOfAccountToRestakingTokens(value);\n    }\n\n    /// @notice Converts an amount of restaking tokens to the equivalent in the asset.\n    /// @param asset The address of the asset to convert to.\n    /// @param amount The amount of restaking tokens to convert.\n    function convertToAssetFromRestakingTokens(address asset, uint256 amount) public view returns (uint256) {\n        uint256 value = convertToUnitOfAccountFromRestakingTokens(amount);\n        return assetRegistry().convertFromUnitOfAccountToAsset(asset, value);\n    }\n\n    /// @notice Converts an amount of restaking tokens to the equivalent in the provided\n    /// asset's EigenLayer shares.\n    /// @param asset The address of the asset whose EigenLayer shares to convert to.\n    /// @param amount The amount of restaking tokens to convert.\n    function convertToSharesFromRestakingTokens(address asset, uint256 amount) public view returns (uint256 shares) {\n        uint256 assetAmount = convertToAssetFromRestakingTokens(asset, amount);\n        return assetRegistry().convertToSharesFromAsset(asset, assetAmount);\n    }\n\n    /// @notice Deposits ETH and mints restaking token(s) to the caller.\n    receive() external payable {\n        _depositETH();\n    }\n\n    /// @notice Deposits ETH and mints restaking token(s) to the caller.\n    /// @dev This function assumes that the quote asset is ETH.\n    function _depositETH() internal checkDeposit(ETH_ADDRESS, msg.value) returns (uint256 amountOut) {\n        // Convert deposited ETH to restaking tokens and mint to the caller.\n        amountOut = convertFromUnitOfAccountToRestakingTokens(msg.value);\n\n        // Forward ETH to the deposit pool.\n        address(depositPool()).transferETH(msg.value);\n\n        // Mint restaking tokens to the caller.\n        token.mint(msg.sender, amountOut);\n\n        emit Deposited(msg.sender, ETH_ADDRESS, msg.value, amountOut);\n    }\n\n    /// @dev Sets the rebalance delay.\n    /// @param newRebalanceDelay The new rebalance delay, in seconds.\n    function _setRebalanceDelay(uint24 newRebalanceDelay) internal {\n        if (newRebalanceDelay > MAX_REBALANCE_DELAY) revert REBALANCE_DELAY_TOO_LONG();\n        rebalanceDelay = newRebalanceDelay;\n\n        emit RebalanceDelaySet(newRebalanceDelay);\n    }\n\n    // forgefmt: disable-next-item\n    /// @dev Processes user withdrawals for the provided asset by transferring available\n    /// assets from the deposit pool and queueing any remaining amount for withdrawal from\n    /// EigenLayer.\n    /// @param asset The asset being withdrawn.\n    /// @param sharesOwed The amount of shares owed to users.\n    function _processUserWithdrawalsForCurrentEpoch(address asset, uint256 sharesOwed) internal {\n        IRioLRTWithdrawalQueue withdrawalQueue_ = withdrawalQueue();\n        (uint256 assetsSent, uint256 sharesSent) = depositPool().transferMaxAssetsForShares(\n            asset,\n            sharesOwed,\n            address(withdrawalQueue_)\n        );\n        uint256 sharesRemaining = sharesOwed - sharesSent;\n\n        // Exit early if all pending withdrawals were paid from the deposit pool.\n        if (sharesRemaining == 0) {\n            withdrawalQueue_.settleCurrentEpoch(asset, assetsSent, sharesSent);\n            return;\n        }\n\n        address strategy = assetRegistry().getAssetStrategy(asset);\n        bytes32 aggregateRoot = OperatorOperations.queueWithdrawalFromOperatorsForUserSettlement(\n            operatorRegistry(),\n            strategy,\n            sharesRemaining\n        );\n        withdrawalQueue_.queueCurrentEpochSettlement(asset, assetsSent, sharesSent, aggregateRoot);\n    }\n\n    /// @dev Checks if the provided asset is supported.\n    /// @param asset The address of the asset.\n    function _checkAssetSupported(address asset) internal view {\n        if (!assetRegistry().isSupportedAsset(asset)) revert ASSET_NOT_SUPPORTED(asset);\n    }\n\n    /// @dev Checks if the provided amount is greater than zero.\n    /// @param amount The amount being checked.\n    function _checkAmountGreaterThanZero(uint256 amount) internal pure {\n        if (amount == 0) revert AMOUNT_MUST_BE_GREATER_THAN_ZERO();\n    }\n\n    /// @dev Checks if the deposit cap for the asset has been reached.\n    /// @param asset The address of the asset.\n    /// @param amountIn The amount of the asset being deposited.\n    function _checkDepositCapReached(address asset, uint256 amountIn) internal view {\n        IRioLRTAssetRegistry assetRegistry_ = assetRegistry();\n\n        uint256 depositCap = assetRegistry_.getAssetDepositCap(asset);\n        if (depositCap > 0) {\n            uint256 existingBalance = assetRegistry_.getTotalBalanceForAsset(asset);\n            if (existingBalance + amountIn > depositCap) {\n                revert DEPOSIT_CAP_REACHED(asset, depositCap);\n            }\n        }\n    }\n\n    /// @dev Reverts if the rebalance delay has not been met.\n    /// @param asset The asset being rebalanced.\n    function _checkRebalanceDelayMet(address asset) internal view {\n        if (block.timestamp < assetNextRebalanceAfter[asset]) revert REBALANCE_DELAY_NOT_MET();\n    }\n\n    /// @dev Allows the owner to upgrade the gateway implementation.\n    /// @param newImplementation The implementation to upgrade to.\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}"
    }
  ]
}