{
  "Title": "H-2: Risk of reward tokens being sold by malicious users under certain conditions",
  "Content": "# Issue H-2: Risk of reward tokens being sold by malicious users under certain conditions \n\nSource: https://github.com/sherlock-audit/2023-02-notional-judging/issues/13 \n\n## Found by \nxiaoming90\n\n## Summary\n\nDue to the lack of validation of the selling token within the Curve adaptors, there is a risk that the reward tokens or Convex deposit tokens of the vault being sold by malicious users under certain conditions (e.g. if reward tokens equal to primary/secondary tokens OR a new exploit is found in other parts of the code).\n\n## Vulnerability Detail\n\nFor a `EXACT_IN_SINGLE` trade within the Curve adaptors, the `from` and `to` addresses of the `exchange` function are explicitly set to `trade.sellToken` and `trade.buyToken` respectively. Thus, the swap is restricted to only `trade.sellToken` and `trade.buyToken`, which points to either the primary or secondary token of the pool. This prevents other tokens that reside in the vault from being swapped out.\n\nHowever, this measure was not applied to the `EXACT_IN_BATCH` trade as it ignores the `trade.sellToken` and `trade.buyToken` , and allow the caller to define arbitrary `data.route` where the first route (`_route[0]`) and last route (`_route[last_index]`) could be any token.\n\nThe vault will hold the reward tokens (CRV, CVX, LDO) when the vault administrator claims the rewards or a malicious user claims the rewards on behalf of the vault by calling Convex's [getReward](https://docs.convexfinance.com/convexfinanceintegration/baserewardpool#claim-rewards) function.\n\nAssume that attacker is faster than the admin calling the reinvest function. There is a possibility that an attacker executes a `EXACT_IN_BATCH` trade and specifies the `_route[0]` as one of the reward tokens residing on the vault and swaps away the reward tokens during depositing (`_tradePrimaryForSecondary`) or redemption (`_sellSecondaryBalance`). In addition, an attacker could also sell away the Convex deposit tokens if a new exploit is found.\n\nIn addition, the vault also holds Convex deposit tokens, which represent assets held by the vault.\n\nThis issue affects the in-scope `CurveV2Adapter` and `CurveAdapter` since they do not validate the `data.route` provided by the users.\n\n#### CurveV2Adapter\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/trading/adapters/CurveV2Adapter.sol#L37\n\n```solidity\nFile: CurveV2Adapter.sol\n37:     function getExecutionData(address from, Trade calldata trade)\n38:         internal view returns (\n39:             address spender,\n40:             address target,\n41:             uint256 msgValue,\n42:             bytes memory executionCallData\n43:         )\n44:     {\n45:         if (trade.tradeType == TradeType.EXACT_IN_SINGLE) {\n46:             CurveV2SingleData memory data = abi.decode(trade.exchangeData, (CurveV2SingleData));\n47:             executionCallData = abi.encodeWithSelector(\n48:                 ICurveRouterV2.exchange.selector,\n49:                 data.pool,\n50:                 _getTokenAddress(trade.sellToken),\n51:                 _getTokenAddress(trade.buyToken),\n52:                 trade.amount,\n53:                 trade.limit,\n54:                 address(this)\n55:             );\n56:         } else if (trade.tradeType == TradeType.EXACT_IN_BATCH) {\n57:             CurveV2BatchData memory data = abi.decode(trade.exchangeData, (CurveV2BatchData));\n58:             // Array of pools for swaps via zap contracts. This parameter is only needed for\n59:             // Polygon meta-factories underlying swaps.\n60:             address[4] memory pools;\n61:             executionCallData = abi.encodeWithSelector(\n62:                 ICurveRouterV2.exchange_multiple.selector,\n63:                 data.route,\n64:                 data.swapParams,\n65:                 trade.amount,\n66:                 trade.limit,\n67:                 pools,\n68:                 address(this)\n69:             );\n```\n\n#### CurveAdapter\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/trading/adapters/CurveAdapter.sol#L66\n\n```solidity\nFile: CurveAdapter.sol\n22:     function _exactInBatch(Trade memory trade) internal view returns (bytes memory executionCallData) {\n23:         CurveBatchData memory data = abi.decode(trade.exchangeData, (CurveBatchData));\n24: \n25:         return abi.encodeWithSelector(\n26:             ICurveRouter.exchange.selector,\n27:             trade.amount,\n28:             data.route,\n29:             data.indices,\n30:             trade.limit\n31:         );\n32:     }\n```\n\nFollowing are some examples of where this vulnerability could potentially be exploited. Assume a vault that supports the CurveV2's ETH/stETH pool.\n\n1) Perform the smallest possible redemption to trigger the `_sellSecondaryBalance` function. Configure the `RedeemParams` to swap the reward token (CRV, CVX, or LDO) or Convex Deposit token for the primary token (ETH). This will cause the `finalPrimaryBalance` to increase by the number of incoming primary tokens (ETH), thus inflating the number of primary tokens redeemed.\n2) Perform the smallest possible deposit to trigger the `_tradePrimaryForSecondary`. Configure `DepositTradeParams` to swap the reward token (CRV, CVX, or LDO) or Convex Deposit token for the secondary tokens (stETH). This will cause the `secondaryAmount` to increase by the number of incoming secondary tokens (stETH), thus inflating the number of secondary tokens available for the deposit.\n\nUpon further investigation, it was observed that the vault would only approve the exchange to pull the `trade.sellToken`, which points to either the primary token (ETH) or secondary token (stETH). Thus, the reward tokens (CRV, CVX, or LDO) or Convex deposit tokens cannot be sent to the exchanges. Thus, the vault will not be affected if none of the reward tokens/Convex Deposit tokens equals the primary or secondary token.\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/trading/TradingUtils.sol#L118\n\n```solidity\nFile: TradingUtils.sol\n115:     /// @notice Approve exchange to pull from this contract\n116:     /// @dev approve up to trade.amount for EXACT_IN trades and up to trade.limit\n117:     /// for EXACT_OUT trades\n118:     function _approve(Trade memory trade, address spender) private {\n119:         uint256 allowance = _isExactIn(trade) ? trade.amount : trade.limit;\n120:         address sellToken = trade.sellToken;\n121:         // approve WETH instead of ETH for ETH trades if\n122:         // spender != address(0) (checked by the caller)\n123:         if (sellToken == Constants.ETH_ADDRESS) {\n124:             sellToken = address(Deployments.WETH);\n125:         }\n126:         IERC20(sellToken).checkApprove(spender, allowance);\n127:     }\n```\n\nHowever, there might be some Curve Pools or Convex's reward contracts whose reward tokens are similar to the primary or secondary tokens of the vault. If the vault supports those pools, the vault will be vulnerable. In addition, the reward tokens of a Curve pool or Convex's reward contracts are not immutable. It is possible for the governance to add a new reward token that might be the same as the primary or secondary token.\n\n## Impact\n\nThere is a risk that the reward tokens or Convex deposit tokens of the vault are sold by malicious users under certain conditions (e.g. if reward tokens are equal to primary/secondary tokens OR a new exploit is found in other parts of the code), thus potentially draining assets from the vault.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/trading/adapters/CurveV2Adapter.sol#L37\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/trading/adapters/CurveAdapter.sol#L66\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is recommended to implement additional checks when performing a `EXACT_IN_BATCH` trade with the `CurveV2Adapter` or `CurveAdapter` adaptor. The first item in the route must be the `trade.sellToken`, and the last item in the route must be the `trade.buyToken`. This will restrict the `trade.sellToken` to the primary or secondary token, and prevent reward and Convex Deposit tokens from being sold (Assuming primary/secondary token != reward tokens).\n\n```solidity\nroute[0] == trade.sellToken\nroute[last index] == trade.buyToken\n```\n\nThe vault holds many Convex Deposit tokens (e.g. [cvxsteCRV](https://etherscan.io/token/0x9518c9063eb0262d791f38d8d6eb0aca33c63ed0#code)). A risk analysis of the vault shows that the worst thing that could happen is that all the Convex Deposit tokens are swapped away if a new exploit is found, which would drain the entire vault. For defense-in-depth, it is recommended to check that the selling token is not a Convex Deposit token under any circumstance when using the trade adaptor.\n\nThe trade adaptors are one of the attack vectors that the attacker could potentially use to move tokens out of the vault if any exploit is found. Thus, they should be locked down or restricted where possible.\n\nAlternatively, consider removing the `EXACT_IN_BATCH` trade function from the affected adaptors to reduce the attack surface if the security risk of this feature outweighs the benefit of the batch function.\n\n## Discussion\n\n**jeffywu**\n\nValid, agree that require checks needed here. @weitianjie2000, also review that the other adapters have similar require checks for batch trades.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/52",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/trading/adapters/CurveV2Adapter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {Trade, TradeType, InvalidTrade} from \"../../../interfaces/trading/ITradingModule.sol\";\nimport {ICurveRouterV2} from \"../../../interfaces/curve/ICurveRouterV2.sol\";\n\nlibrary CurveV2Adapter {\n    struct CurveV2SingleData {\n        // Address of the pool to use for the swap\n        address pool;\n    }\n\n    struct CurveV2BatchData { \n        // Array of [initial token, pool, token, pool, token, ...]\n        // The array is iterated until a pool address of 0x00, then the last\n        // given token is transferred to `_receiver`\n        address[9] route;\n        // Multidimensional array of [i, j, swap type] where i and j are the correct\n        // values for the n'th pool in `_route`. The swap type should be\n        // 1 for a stableswap `exchange`,\n        // 2 for stableswap `exchange_underlying`,\n        // 3 for a cryptoswap `exchange`,\n        // 4 for a cryptoswap `exchange_underlying`,\n        // 5 for factory metapools with lending base pool `exchange_underlying`,\n        // 6 for factory crypto-meta pools underlying exchange (`exchange` method in zap),\n        // 7-11 for wrapped coin (underlying for lending or fake pool) -> LP token \"exchange\" (actually `add_liquidity`),\n        // 12-14 for LP token -> wrapped coin (underlying for lending pool) \"exchange\" (actually `remove_liquidity_one_coin`)\n        // 15 for WETH -> ETH \"exchange\" (actually deposit/withdraw)\n        uint256[3][4] swapParams;\n    }\n\n    function _getTokenAddress(address token) internal view returns (address) {\n        return token == Deployments.ETH_ADDRESS ? Deployments.ALT_ETH_ADDRESS : token;\n    }\n\n    function getExecutionData(address from, Trade calldata trade)\n        internal view returns (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionCallData\n        )\n    {\n        if (trade.tradeType == TradeType.EXACT_IN_SINGLE) {\n            CurveV2SingleData memory data = abi.decode(trade.exchangeData, (CurveV2SingleData));\n            executionCallData = abi.encodeWithSelector(\n                ICurveRouterV2.exchange.selector,\n                data.pool,\n                _getTokenAddress(trade.sellToken),\n                _getTokenAddress(trade.buyToken),\n                trade.amount,\n                trade.limit,\n                address(this)\n            );\n        } else if (trade.tradeType == TradeType.EXACT_IN_BATCH) {\n            CurveV2BatchData memory data = abi.decode(trade.exchangeData, (CurveV2BatchData));\n            // Array of pools for swaps via zap contracts. This parameter is only needed for\n            // Polygon meta-factories underlying swaps.\n            address[4] memory pools;\n            executionCallData = abi.encodeWithSelector(\n                ICurveRouterV2.exchange_multiple.selector,\n                data.route,\n                data.swapParams,\n                trade.amount,\n                trade.limit,\n                pools,\n                address(this)\n            );\n        } else {\n            // EXACT_OUT_SINGLE and EXACT_OUT_BATCH are not supported by Curve\n            revert InvalidTrade();\n        }\n\n        target = address(Deployments.CURVE_ROUTER_V2);\n        if (trade.sellToken == Deployments.ETH_ADDRESS) {\n            msgValue = trade.amount;\n        } else {\n            spender = target;\n        }\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/trading/adapters/CurveAdapter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport \"../../../interfaces/trading/ITradingModule.sol\";\nimport \"../../../interfaces/curve/ICurvePool.sol\";\nimport \"../../../interfaces/curve/ICurveRegistryProvider.sol\";\nimport {ICurveRouter} from \"../../../interfaces/curve/ICurveRouter.sol\";\nimport {ICurveRegistry} from \"../../../interfaces/curve/ICurveRegistry.sol\";\n\nlibrary CurveAdapter {\n    int128 internal constant MAX_TOKENS = 4;\n    struct CurveBatchData { \n        address[6] route;\n        uint256[8] indices;\n    }\n\n    function _getTokenAddress(address token) internal view returns (address) {\n        return (token == Deployments.ETH_ADDRESS || token == address(Deployments.WETH)) ? Deployments.ALT_ETH_ADDRESS : token;\n    }\n\n    function _exactInBatch(Trade memory trade) internal view returns (bytes memory executionCallData) {\n        CurveBatchData memory data = abi.decode(trade.exchangeData, (CurveBatchData));\n\n        return abi.encodeWithSelector(\n            ICurveRouter.exchange.selector,\n            trade.amount,\n            data.route,\n            data.indices,\n            trade.limit\n        );\n    }\n\n    function _exactInSingle(Trade memory trade)\n        internal view returns (address target, bytes memory executionCallData)\n    {\n        address sellToken = _getTokenAddress(trade.sellToken);\n        address buyToken = _getTokenAddress(trade.buyToken);\n        ICurvePool pool = ICurvePool(Deployments.CURVE_REGISTRY.find_pool_for_coins(sellToken, buyToken));\n\n        if (address(pool) == address(0)) revert InvalidTrade();\n\n        int128 i = -1;\n        int128 j = -1;\n        for (int128 c = 0; c < MAX_TOKENS; c++) {\n            address coin = pool.coins(uint256(int256(c)));\n            if (coin == sellToken) i = c;\n            if (coin == buyToken) j = c;\n            if (i > -1 && j > -1) break;\n        }\n\n        if (i == -1 || j == -1) revert InvalidTrade();\n\n        return (\n            address(pool),\n            abi.encodeWithSelector(\n                ICurvePool.exchange.selector,\n                i,\n                j,\n                trade.amount,\n                trade.limit\n            )\n        );\n    }\n\n    function getExecutionData(address from, Trade calldata trade)\n        internal view returns (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionCallData\n        )\n    {\n        if (trade.tradeType == TradeType.EXACT_IN_SINGLE) {\n            (target, executionCallData) = _exactInSingle(trade);\n        } else if (trade.tradeType == TradeType.EXACT_IN_BATCH) {\n            target = address(Deployments.CURVE_ROUTER);\n            executionCallData = _exactInBatch(trade);\n        } else {\n            // EXACT_OUT_SINGLE and EXACT_OUT_BATCH are not supported by Curve\n            revert InvalidTrade();\n        }\n\n        if (trade.sellToken == address(Deployments.WETH) || trade.sellToken == Deployments.ETH_ADDRESS) {\n            // Curve does not support WETH as an input\n            msgValue = trade.amount;\n        } else {\n            spender = target;\n        }\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/trading/TradingUtils.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {TokenUtils, IERC20} from \"../utils/TokenUtils.sol\";\nimport \"../../interfaces/trading/IVaultExchange.sol\";\nimport \"../../interfaces/trading/ITradingModule.sol\";\nimport {nProxy} from \"../proxy/nProxy.sol\";\n\n/// @notice Utility library used by the trading module\nlibrary TradingUtils {\n    using TokenUtils for IERC20;\n\n    error ERC20Error();\n    error TradeExecution(bytes returnData);\n    error PreValidationExactIn(uint256 maxAmountIn, uint256 preTradeSellBalance);\n    error PreValidationExactOut(uint256 maxAmountIn, uint256 preTradeSellBalance);\n    error PostValidationExactIn(uint256 minAmountOut, uint256 amountReceived);\n    error PostValidationExactOut(uint256 exactAmountOut, uint256 amountReceived);\n\n    event TradeExecuted(\n        address indexed sellToken,\n        address indexed buyToken,\n        uint256 sellAmount,\n        uint256 buyAmount\n    );\n\n    function _executeInternal(\n        Trade memory trade,\n        uint16 dexId,\n        address spender,\n        address target,\n        uint256 msgValue,\n        bytes memory executionData\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        // Get pre-trade token balances\n        (uint256 preTradeSellBalance, uint256 preTradeBuyBalance) = _getBalances(trade);\n\n        // Make sure we have enough tokens to sell\n        _preValidate(trade, preTradeSellBalance);\n\n        // No need to approve ETH trades\n        if (spender != Deployments.ETH_ADDRESS && DexId(dexId) != DexId.NOTIONAL_VAULT) {\n            _approve(trade, spender);\n        }\n\n        _executeTrade(target, msgValue, executionData, spender, trade);\n\n        // Get post-trade token balances\n        (uint256 postTradeSellBalance, uint256 postTradeBuyBalance) = _getBalances(trade);\n\n        _postValidate(trade, postTradeBuyBalance - preTradeBuyBalance);\n\n        // No need to revoke ETH trades\n        if (spender != Deployments.ETH_ADDRESS && DexId(dexId) != DexId.NOTIONAL_VAULT) {\n            IERC20(trade.sellToken).checkRevoke(spender);\n        }\n\n        amountSold = preTradeSellBalance - postTradeSellBalance;\n        amountBought = postTradeBuyBalance - preTradeBuyBalance;\n\n        emit TradeExecuted(trade.sellToken, trade.buyToken, amountSold, amountBought);\n    }\n\n    function _getBalances(Trade memory trade) private view returns (uint256, uint256) {\n        return (\n            trade.sellToken == Deployments.ETH_ADDRESS\n                ? address(this).balance\n                : IERC20(trade.sellToken).balanceOf(address(this)),\n            trade.buyToken == Deployments.ETH_ADDRESS\n                ? address(this).balance\n                : IERC20(trade.buyToken).balanceOf(address(this))\n        );\n    }\n\n    function _isExactIn(Trade memory trade) private pure returns (bool) {\n        return\n            trade.tradeType == TradeType.EXACT_IN_SINGLE ||\n            trade.tradeType == TradeType.EXACT_IN_BATCH;\n    }\n\n    function _isExactOut(Trade memory trade) private pure returns (bool) {\n        return\n            trade.tradeType == TradeType.EXACT_OUT_SINGLE ||\n            trade.tradeType == TradeType.EXACT_OUT_BATCH;\n    }\n\n    /// @notice we may need to unwrap excess WETH for exact out trades\n    function _needsToUnwrapExcessWETH(Trade memory trade, address spender) private pure returns (bool) {\n        return trade.sellToken == Deployments.ETH_ADDRESS && spender != Deployments.ETH_ADDRESS && _isExactOut(trade);\n    }\n\n    function _preValidate(Trade memory trade, uint256 preTradeSellBalance) private pure {\n        if (_isExactIn(trade) && preTradeSellBalance < trade.amount) {\n            revert PreValidationExactIn(trade.amount, preTradeSellBalance);\n        } \n        \n        if (_isExactOut(trade) && preTradeSellBalance < trade.limit) {\n            // NOTE: this implies that vaults cannot execute market trades on exact out\n            revert PreValidationExactOut(trade.limit, preTradeSellBalance);\n        }\n    }\n\n    function _postValidate(Trade memory trade, uint256 amountReceived) private pure {\n        if (_isExactIn(trade) && amountReceived < trade.limit) {\n            revert PostValidationExactIn(trade.limit, amountReceived);\n        }\n\n        if (_isExactOut(trade) && amountReceived != trade.amount) {\n            revert PostValidationExactOut(trade.amount, amountReceived);\n        }\n    }\n\n    /// @notice Approve exchange to pull from this contract\n    /// @dev approve up to trade.amount for EXACT_IN trades and up to trade.limit\n    /// for EXACT_OUT trades\n    function _approve(Trade memory trade, address spender) private {\n        uint256 allowance = _isExactIn(trade) ? trade.amount : trade.limit;\n        address sellToken = trade.sellToken;\n        // approve WETH instead of ETH for ETH trades if\n        // spender != address(0) (checked by the caller)\n        if (sellToken == Constants.ETH_ADDRESS) {\n            sellToken = address(Deployments.WETH);\n        }\n        IERC20(sellToken).checkApprove(spender, allowance);\n    }\n\n    function _executeTrade(\n        address target,\n        uint256 msgValue,\n        bytes memory params,\n        address spender,\n        Trade memory trade\n    ) private {\n        uint256 preTradeBalance;\n \n        if (trade.buyToken == address(Deployments.WETH)) {\n            preTradeBalance = address(this).balance;\n        } else if (trade.buyToken == Deployments.ETH_ADDRESS || _needsToUnwrapExcessWETH(trade, spender)) {\n            preTradeBalance = IERC20(address(Deployments.WETH)).balanceOf(address(this));\n        }\n\n        if (trade.sellToken == address(Deployments.WETH) && spender == Deployments.ETH_ADDRESS) {\n            // Curve doesn't support Deployments.WETH (spender == address(0))\n            uint256 withdrawAmount = _isExactIn(trade) ? trade.amount : trade.limit;\n            Deployments.WETH.withdraw(withdrawAmount);\n        } else if (trade.sellToken == Deployments.ETH_ADDRESS && spender != Deployments.ETH_ADDRESS) {\n            // UniswapV3 doesn't support ETH (spender != address(0))\n            uint256 depositAmount = _isExactIn(trade) ? trade.amount : trade.limit;\n            Deployments.WETH.deposit{value: depositAmount }();\n        }\n\n        (bool success, bytes memory returnData) = target.call{value: msgValue}(params);\n        if (!success) revert TradeExecution(returnData);\n\n        if (trade.buyToken == address(Deployments.WETH)) {\n            if (address(this).balance > preTradeBalance) {\n                // If the caller specifies that they want to receive Deployments.WETH but we have received ETH,\n                // wrap the ETH to Deployments.WETH.\n                uint256 depositAmount;\n                unchecked { depositAmount = address(this).balance - preTradeBalance; }\n                Deployments.WETH.deposit{value: depositAmount}();\n            }\n        } else if (trade.buyToken == Deployments.ETH_ADDRESS || _needsToUnwrapExcessWETH(trade, spender)) {\n            uint256 postTradeBalance = IERC20(address(Deployments.WETH)).balanceOf(address(this));\n            if (postTradeBalance > preTradeBalance) {\n                // If the caller specifies that they want to receive ETH but we have received Deployments.WETH,\n                // unwrap the Deployments.WETH to ETH.\n                uint256 withdrawAmount;\n                unchecked { withdrawAmount = postTradeBalance - preTradeBalance; }\n                Deployments.WETH.withdraw(withdrawAmount);\n            }\n        }\n    }\n\n    function _getLimitAmount(\n        TradeType tradeType,\n        address sellToken,\n        address buyToken,\n        uint256 amount,\n        uint32 slippageLimit,\n        uint256 oraclePrice,\n        uint256 oracleDecimals\n    ) internal view returns (uint256 limitAmount) {\n        uint256 sellTokenDecimals = 10 **\n            (\n                sellToken == Deployments.ETH_ADDRESS\n                    ? 18\n                    : IERC20(sellToken).decimals()\n            );\n        uint256 buyTokenDecimals = 10 **\n            (\n                buyToken == Deployments.ETH_ADDRESS\n                    ? 18\n                    : IERC20(buyToken).decimals()\n            );\n\n        if (tradeType == TradeType.EXACT_OUT_SINGLE || tradeType == TradeType.EXACT_OUT_BATCH) {\n            // type(uint256).max means no slippage limit\n            if (slippageLimit == type(uint256).max) {\n                return type(uint256).max;\n            }\n            // For exact out trades, we need to invert the oracle price (1 / oraclePrice)\n            // We increase the precision before we divide because oraclePrice is in\n            // oracle decimals\n            oraclePrice = (oracleDecimals * oracleDecimals) / oraclePrice;\n            // For exact out trades, limitAmount is the max amount of sellToken the DEX can\n            // pull from the contract\n            limitAmount =\n                ((oraclePrice + \n                    ((oraclePrice * uint256(slippageLimit)) /\n                        Constants.SLIPPAGE_LIMIT_PRECISION)) * amount) / \n                oracleDecimals;\n\n            // limitAmount is in buyToken precision after the previous calculation,\n            // convert it to sellToken precision\n            limitAmount = (limitAmount * sellTokenDecimals) / buyTokenDecimals;\n        } else {\n            // type(uint256).max means no slippage limit\n            if (slippageLimit == type(uint256).max) {\n                return 0;\n            }\n            // For exact in trades, limitAmount is the min amount of buyToken the contract\n            // expects from the DEX\n            limitAmount =\n                ((oraclePrice -\n                    ((oraclePrice * uint256(slippageLimit)) /\n                        Constants.SLIPPAGE_LIMIT_PRECISION)) * amount) /\n                oracleDecimals;\n\n            // limitAmount is in sellToken precision after the previous calculation,\n            // convert it to buyToken precision\n            limitAmount = (limitAmount * buyTokenDecimals) / sellTokenDecimals;\n        }\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/trading/adapters/CurveV2Adapter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {Trade, TradeType, InvalidTrade} from \"../../../interfaces/trading/ITradingModule.sol\";\nimport {ICurveRouterV2} from \"../../../interfaces/curve/ICurveRouterV2.sol\";\n\nlibrary CurveV2Adapter {\n    struct CurveV2SingleData {\n        // Address of the pool to use for the swap\n        address pool;\n    }\n\n    struct CurveV2BatchData { \n        // Array of [initial token, pool, token, pool, token, ...]\n        // The array is iterated until a pool address of 0x00, then the last\n        // given token is transferred to `_receiver`\n        address[9] route;\n        // Multidimensional array of [i, j, swap type] where i and j are the correct\n        // values for the n'th pool in `_route`. The swap type should be\n        // 1 for a stableswap `exchange`,\n        // 2 for stableswap `exchange_underlying`,\n        // 3 for a cryptoswap `exchange`,\n        // 4 for a cryptoswap `exchange_underlying`,\n        // 5 for factory metapools with lending base pool `exchange_underlying`,\n        // 6 for factory crypto-meta pools underlying exchange (`exchange` method in zap),\n        // 7-11 for wrapped coin (underlying for lending or fake pool) -> LP token \"exchange\" (actually `add_liquidity`),\n        // 12-14 for LP token -> wrapped coin (underlying for lending pool) \"exchange\" (actually `remove_liquidity_one_coin`)\n        // 15 for WETH -> ETH \"exchange\" (actually deposit/withdraw)\n        uint256[3][4] swapParams;\n    }\n\n    function _getTokenAddress(address token) internal view returns (address) {\n        return token == Deployments.ETH_ADDRESS ? Deployments.ALT_ETH_ADDRESS : token;\n    }\n\n    function getExecutionData(address from, Trade calldata trade)\n        internal view returns (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionCallData\n        )\n    {\n        if (trade.tradeType == TradeType.EXACT_IN_SINGLE) {\n            CurveV2SingleData memory data = abi.decode(trade.exchangeData, (CurveV2SingleData));\n            executionCallData = abi.encodeWithSelector(\n                ICurveRouterV2.exchange.selector,\n                data.pool,\n                _getTokenAddress(trade.sellToken),\n                _getTokenAddress(trade.buyToken),\n                trade.amount,\n                trade.limit,\n                address(this)\n            );\n        } else if (trade.tradeType == TradeType.EXACT_IN_BATCH) {\n            CurveV2BatchData memory data = abi.decode(trade.exchangeData, (CurveV2BatchData));\n            // Array of pools for swaps via zap contracts. This parameter is only needed for\n            // Polygon meta-factories underlying swaps.\n            address[4] memory pools;\n            executionCallData = abi.encodeWithSelector(\n                ICurveRouterV2.exchange_multiple.selector,\n                data.route,\n                data.swapParams,\n                trade.amount,\n                trade.limit,\n                pools,\n                address(this)\n            );\n        } else {\n            // EXACT_OUT_SINGLE and EXACT_OUT_BATCH are not supported by Curve\n            revert InvalidTrade();\n        }\n\n        target = address(Deployments.CURVE_ROUTER_V2);\n        if (trade.sellToken == Deployments.ETH_ADDRESS) {\n            msgValue = trade.amount;\n        } else {\n            spender = target;\n        }\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/trading/adapters/CurveAdapter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport \"../../../interfaces/trading/ITradingModule.sol\";\nimport \"../../../interfaces/curve/ICurvePool.sol\";\nimport \"../../../interfaces/curve/ICurveRegistryProvider.sol\";\nimport {ICurveRouter} from \"../../../interfaces/curve/ICurveRouter.sol\";\nimport {ICurveRegistry} from \"../../../interfaces/curve/ICurveRegistry.sol\";\n\nlibrary CurveAdapter {\n    int128 internal constant MAX_TOKENS = 4;\n    struct CurveBatchData { \n        address[6] route;\n        uint256[8] indices;\n    }\n\n    function _getTokenAddress(address token) internal view returns (address) {\n        return (token == Deployments.ETH_ADDRESS || token == address(Deployments.WETH)) ? Deployments.ALT_ETH_ADDRESS : token;\n    }\n\n    function _exactInBatch(Trade memory trade) internal view returns (bytes memory executionCallData) {\n        CurveBatchData memory data = abi.decode(trade.exchangeData, (CurveBatchData));\n\n        return abi.encodeWithSelector(\n            ICurveRouter.exchange.selector,\n            trade.amount,\n            data.route,\n            data.indices,\n            trade.limit\n        );\n    }\n\n    function _exactInSingle(Trade memory trade)\n        internal view returns (address target, bytes memory executionCallData)\n    {\n        address sellToken = _getTokenAddress(trade.sellToken);\n        address buyToken = _getTokenAddress(trade.buyToken);\n        ICurvePool pool = ICurvePool(Deployments.CURVE_REGISTRY.find_pool_for_coins(sellToken, buyToken));\n\n        if (address(pool) == address(0)) revert InvalidTrade();\n\n        int128 i = -1;\n        int128 j = -1;\n        for (int128 c = 0; c < MAX_TOKENS; c++) {\n            address coin = pool.coins(uint256(int256(c)));\n            if (coin == sellToken) i = c;\n            if (coin == buyToken) j = c;\n            if (i > -1 && j > -1) break;\n        }\n\n        if (i == -1 || j == -1) revert InvalidTrade();\n\n        return (\n            address(pool),\n            abi.encodeWithSelector(\n                ICurvePool.exchange.selector,\n                i,\n                j,\n                trade.amount,\n                trade.limit\n            )\n        );\n    }\n\n    function getExecutionData(address from, Trade calldata trade)\n        internal view returns (\n            address spender,\n            address target,\n            uint256 msgValue,\n            bytes memory executionCallData\n        )\n    {\n        if (trade.tradeType == TradeType.EXACT_IN_SINGLE) {\n            (target, executionCallData) = _exactInSingle(trade);\n        } else if (trade.tradeType == TradeType.EXACT_IN_BATCH) {\n            target = address(Deployments.CURVE_ROUTER);\n            executionCallData = _exactInBatch(trade);\n        } else {\n            // EXACT_OUT_SINGLE and EXACT_OUT_BATCH are not supported by Curve\n            revert InvalidTrade();\n        }\n\n        if (trade.sellToken == address(Deployments.WETH) || trade.sellToken == Deployments.ETH_ADDRESS) {\n            // Curve does not support WETH as an input\n            msgValue = trade.amount;\n        } else {\n            spender = target;\n        }\n    }\n}"
    }
  ]
}