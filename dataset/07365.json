{
  "Title": "[M-02] Attacker can delay proposal rejection",
  "Content": "\nIn `OptimisticListingSeaport.rejectProposal`, it reverts if `proposedListing.collateral < _amount`. An attacker can therefore monitor the mempool, reducing the `proposedListing.collateral` to `_amount - 1` by frontrunning the `rejectProposal` call and delaying the rejection. The attacker may even be able to deny the rejection when the deadline passes.\n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L145>\n\n```solidity\n        if (proposedListing.collateral < _amount) revert InsufficientCollateral();\n```\n\n<https://github.com/code-423n4/2022-12-tessera/blob/f37a11407da2af844bbfe868e1422e3665a5f8e4/src/seaport/modules/OptimisticListingSeaport.sol#L153>\n\n```solidity\n        proposedListing.collateral -= _amount;\n```\n\n### Proof of Concept\n\n1.  Attacker proposes a 10000 collateral at a very low price\n2.  Bob tries to reject it by purchasing the 10000 collateral\n3.  Attacker sees Bob's tx in the mempool, frontruns it to reject 1 unit\n4.  The proposedListing.collateral is now 9999\n5.  Bob's call reverted\n6.  This keeps happening until PROPOSAL_PERIOD passes or Bob gave up because of gas paid on failing tx\n7.  Attacker buys the NFT at a very low price\n\n### Recommended Mitigation Steps\n\nWhen `proposedListing.collateral < _amount`, set `\\_amount` to proposedListing.collateral and refund the excess.\n\n**[stevennevins (Tessera) disagreed with severity and commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/24#issuecomment-1371389949):**\n > While annoying, I think this is a Medium severity issue.  The attacker has to under price their proposal, defend this under priced proposal from other users and front run each purchase > 1, while selling their Raes at a loss, and it would be relatively costly for griefer to defend their underpriced proposal for the duration of the proposal period.  Users could purchase 1 Rae at a time without risk of front running.\n\n**[HickupHH3 (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tessera-findings/issues/24#issuecomment-1378858509):**\n > Agree with Medium severity given the external requirements needed to pull this off.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-tessera-versus-contest",
  "Code": [
    {
      "filename": "src/seaport/modules/OptimisticListingSeaport.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Module} from \"../../modules/Module.sol\";\nimport {Multicall} from \"../../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../../utils/NFTReceiver.sol\";\nimport {SafeSend} from \"../../utils/SafeSend.sol\";\nimport {SelfPermit} from \"../../utils/SelfPermit.sol\";\n\nimport {ConsiderationItem, ItemType, OfferItem, Order, OrderParameters, OrderComponents, OrderType} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {ConsiderationInterface as ISeaport} from \"seaport/interfaces/ConsiderationInterface.sol\";\nimport {IERC1155} from \"../../interfaces/IERC1155.sol\";\nimport {IOptimisticListingSeaport, Listing} from \"../interfaces/IOptimisticListingSeaport.sol\";\nimport {IRae} from \"../../interfaces/IRae.sol\";\nimport {ISeaportLister} from \"../interfaces/ISeaportLister.sol\";\nimport {ISupply} from \"../../interfaces/ISupply.sol\";\nimport {IVault} from \"../../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../../interfaces/IVaultRegistry.sol\";\n\n/// @title OptimisticListingSeaport\n/// @author Tessera\n/// @notice Module contract for listing vault assets through the Seaport protocol\ncontract OptimisticListingSeaport is\n    IOptimisticListingSeaport,\n    Module,\n    Multicall,\n    NFTReceiver,\n    SafeSend,\n    SelfPermit\n{\n    /// @notice Address of VaultRegistry contract\n    address public immutable registry;\n    /// @notice Address of the Seaport contract\n    address public immutable seaport;\n    /// @notice Address of the Zone to list items under\n    address public immutable zone;\n    /// @notice The conduit key used to deploy the conduit\n    bytes32 public immutable conduitKey;\n    /// @notice Address of Supply target contract\n    address public immutable supply;\n    /// @notice Address of the SeaportLister target contract\n    address public immutable seaportLister;\n    /// @notice Time period of a proposed listing\n    uint256 public immutable PROPOSAL_PERIOD;\n    /// @notice Address of the OpenSea recipient for receiving fees\n    address payable public immutable OPENSEA_RECIPIENT;\n    /// @notice Address of the protocol fee receiver\n    address payable public feeReceiver;\n    /// @notice Mapping of vault address to order hash\n    mapping(address => bytes32) public vaultOrderHash;\n    /// @notice Mapping of vault address to active listings on Seaport\n    mapping(address => Listing) public activeListings;\n    /// @notice Mapping of vault address to newly proposed listings\n    mapping(address => Listing) public proposedListings;\n    /// @notice Mapping of vault address to user address to collateral amount\n    mapping(address => mapping(address => uint256)) public pendingBalances;\n\n    /// @dev Initializes contract state\n    constructor(\n        address _registry,\n        address _seaport,\n        address _zone,\n        bytes32 _conduitKey,\n        address _supply,\n        address _seaportLister,\n        address payable _feeReceiver,\n        address payable _openseaRecipient,\n        uint256 _proposalPeriod,\n        address payable _weth\n    ) SafeSend(_weth) {\n        registry = _registry;\n        seaport = _seaport;\n        zone = _zone;\n        conduitKey = _conduitKey;\n        supply = _supply;\n        seaportLister = _seaportLister;\n        feeReceiver = _feeReceiver;\n        OPENSEA_RECIPIENT = _openseaRecipient;\n        PROPOSAL_PERIOD = _proposalPeriod;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Proposes a new optimistic listing for a vault\n    /// @param _vault Address of the vault\n    /// @param _collateral Amount of tokens the proposer is risking\n    /// @param _pricePerToken Desired listing price of the vault assets divided by total supply\n    /// @param _offer List of items included in the offer to be listed\n    function propose(\n        address _vault,\n        uint256 _collateral,\n        uint256 _pricePerToken,\n        OfferItem[] calldata _offer\n    ) external {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if vault is not current owner of the assets\n        if (_verifySale(_vault)) revert NotOwner();\n        // Reverts if caller has insufficient token balance\n        _verifyBalance(token, id, _collateral);\n        // Initializes the mappings if this is the first time a proposal is being submitted for the vault\n        Listing storage proposedListing = proposedListings[_vault];\n        Listing storage activeListing = activeListings[_vault];\n        if (\n            proposedListings[_vault].proposer == address(0) &&\n            activeListings[_vault].proposer == address(0)\n        ) {\n            _setListing(proposedListing, address(this), 0, type(uint256).max, 0);\n            _setListing(activeListing, address(this), 0, type(uint256).max, 0);\n        }\n        // Reverts if price per token is not lower than both the proposed and active listings\n        if (\n            _pricePerToken >= proposedListing.pricePerToken ||\n            _pricePerToken >= activeListings[_vault].pricePerToken\n        ) revert NotLower();\n\n        // Calculates listing price based on price per token and total supply of Raes\n        uint256 listingPrice = _pricePerToken * IRae(token).totalSupply(id);\n\n        // Constructs Seaport order and sets the proposed listing\n        _constructOrder(_vault, listingPrice, _offer);\n        _setListing(proposedListing, msg.sender, _collateral, _pricePerToken, block.timestamp);\n\n        // Sets collateral amount to pending balances for withdrawal\n        pendingBalances[_vault][proposedListing.proposer] += proposedListing.collateral;\n\n        // Transfers new collateral amount from caller to this contract\n        IERC1155(token).safeTransferFrom(msg.sender, address(this), id, _collateral, \"\");\n\n        // Emits event for proposing new listing\n        emit Propose(_vault, msg.sender, _collateral, _pricePerToken, proposedListing.order);\n    }\n\n    /// @notice Rejects a new listing proposal\n    /// @param _vault Address of the vault\n    /// @param _amount Amount of tokens being rejected\n    function rejectProposal(address _vault, uint256 _amount) external payable {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if vault is not current owner of the assets\n        if (_verifySale(_vault)) revert NotOwner();\n        // Reverts if collateral is less than amount of rejected tokens\n        Listing storage proposedListing = proposedListings[_vault];\n        if (proposedListing.collateral < _amount) revert InsufficientCollateral();\n        // Reverts if payment amount is incorrect\n        if (proposedListing.pricePerToken * _amount != msg.value) revert InvalidPayment();\n\n        // Store proposer in memory\n        address proposer = proposedListing.proposer;\n\n        // Decrements collateral amount\n        proposedListing.collateral -= _amount;\n\n        // Checks if proposed listing has been rejected\n        if (proposedListing.collateral == 0) {\n            // Resets proposed listing to default\n            _setListing(proposedListing, address(this), 0, type(uint256).max, 0);\n        }\n\n        // Transfers tokens to caller\n        IERC1155(token).safeTransferFrom(address(this), msg.sender, id, _amount, \"\");\n        // Sends ether to proposer\n        _sendEthOrWeth(proposer, msg.value);\n\n        // Emits event for rejecting a proposed listing\n        emit RejectProposal(_vault, msg.sender, _amount, msg.value, proposedListing.order);\n    }\n\n    /// @notice Rejects an active listing\n    /// @param _vault Address of the vault\n    /// @param _amount Amount of tokens being rejected\n    /// @param _delistProof Merkle proof for executing the delisting of assets\n    function rejectActive(\n        address _vault,\n        uint256 _amount,\n        bytes32[] calldata _delistProof\n    ) external payable {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if vault is not current owner of the assets\n        if (_verifySale(_vault)) revert NotOwner();\n        // Reverts if collateral is less than amount of rejected tokens\n        Listing storage activeListing = activeListings[_vault];\n        if (activeListing.collateral < _amount) revert InsufficientCollateral();\n        // Reverts if payment amount is incorrect\n        if (activeListing.pricePerToken * _amount != msg.value) revert InvalidPayment();\n\n        // Store proposer in memory\n        address proposer = activeListing.proposer;\n\n        // Decrements collateral amount\n        activeListing.collateral -= _amount;\n\n        // Checks if active listing has been rejected\n        if (activeListing.collateral == 0) {\n            // Cancels the Seaport Order\n            _delist(_vault, _delistProof);\n            // Resets active listing to default\n            delete activeListings[_vault];\n            _setListing(activeListing, address(this), 0, type(uint256).max, 0);\n            // Emits event for delisting assets\n            emit Delist(_vault, activeListing.order);\n        }\n\n        // Transfers tokens to caller\n        IERC1155(token).safeTransferFrom(address(this), msg.sender, id, _amount, \"\");\n        // Sends ether to proposer\n        _sendEthOrWeth(proposer, msg.value);\n\n        // Emits event for rejecting an active listing\n        emit RejectActive(_vault, msg.sender, _amount, msg.value, activeListing.order);\n    }\n\n    /// @notice Lists the assets for sale\n    /// @param _vault Address of the vault\n    /// @param _listProof Merkle proof for executing the listing of assets\n    function list(address _vault, bytes32[] calldata _listProof) public {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if vault is not current owner of the assets\n        if (_verifySale(_vault)) revert NotOwner();\n        // Reverts if collateral of proposed listing has been rejected\n        Listing storage proposedListing = proposedListings[_vault];\n        if (proposedListing.collateral == 0) revert Rejected();\n        // Reverts if proposal period has not elapsed\n        if (proposedListing.proposalDate + PROPOSAL_PERIOD > block.timestamp)\n            revert TimeNotElapsed();\n\n        // Sets remaining collateral amount of proposer for withdrawal\n        Listing memory activeListing = activeListings[_vault];\n        pendingBalances[_vault][activeListing.proposer] = activeListing.collateral;\n\n        // Calculates new listing price\n        uint256 newPrice = proposedListing.pricePerToken * IRae(token).totalSupply(id);\n\n        // Structures the order array\n        Order[] memory order = new Order[](1);\n        order[0] = proposedListing.order;\n\n        // Replaces active listing with the successfully proposed listing\n        activeListings[_vault] = proposedListing;\n        // Resets proposed listing to default\n        _setListing(proposedListing, address(this), 0, type(uint256).max, 0);\n\n        // List order on Seaport\n        bytes memory data = abi.encodeCall(ISeaportLister.validateListing, (seaport, order));\n        IVault(payable(_vault)).execute(seaportLister, data, _listProof);\n\n        // Emits event for successful listing\n        emit List(_vault, newPrice, activeListings[_vault].order);\n    }\n\n    /// @notice Cancels an active listing from being on sale\n    /// @param _vault Address of the vault\n    /// @param _delistProof Merkle proof for executing the delisting of assets\n    function cancel(address _vault, bytes32[] calldata _delistProof) external {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if vault is not current owner of the assets\n        if (_verifySale(_vault)) revert NotOwner();\n        // Reverts if caller is not proposer of active listing\n        Listing storage activeListing = activeListings[_vault];\n        if (activeListing.proposer != msg.sender) revert NotProposer();\n\n        // Cancels the Seaport Order\n        _delist(_vault, _delistProof);\n\n        uint256 collateral = activeListing.collateral;\n        // Resets active listing to default\n        _setListing(activeListing, address(this), 0, type(uint256).max, 0);\n\n        // Transfers remaining collateral amount to proposer\n        IERC1155(token).safeTransferFrom(address(this), msg.sender, id, collateral, \"\");\n\n        // Emits event for canceling a listing\n        emit Cancel(_vault, activeListing.order);\n    }\n\n    /// @notice Cashes out proceeds from the sale of an active listing\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for executing the burning of Raes\n    function cash(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if active listing has not been settled\n        Listing storage activeListing = activeListings[_vault];\n        // Reverts if listing has not been sold\n        if (!_verifySale(_vault)) {\n            revert NotSold();\n        } else if (activeListing.collateral != 0) {\n            uint256 collateral = activeListing.collateral;\n            activeListing.collateral = 0;\n            // Sets collateral amount to pending balances for withdrawal\n            pendingBalances[_vault][activeListing.proposer] = collateral;\n        }\n        // Reverts if token balance is insufficient\n        uint256 tokenBalance = _verifyBalance(token, id, 1);\n        // Calculates ether payment for withdrawal\n        uint256 payment = tokenBalance * activeListing.pricePerToken;\n\n        // Initializes vault transaction for burn\n        bytes memory data = abi.encodeCall(ISupply.burn, (msg.sender, tokenBalance));\n        // Executes burn of tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Transfers payment to token holder\n        _sendEthOrWeth(msg.sender, payment);\n\n        // Emits event for cashing out of listing\n        emit Cash(_vault, msg.sender, payment);\n    }\n\n    /// @notice Withdraws pending collateral balance to given address\n    /// @param _vault Address of the vault\n    /// @param _to Address of the receiver\n    function withdrawCollateral(address _vault, address _to) external {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if token balance is insufficient\n        uint256 balance = pendingBalances[_vault][_to];\n        if (balance == 0) revert NotEnoughTokens();\n\n        // Resets collateral balance amount\n        pendingBalances[_vault][_to] = 0;\n\n        // Transfers collateral amount to receiver\n        IERC1155(token).safeTransferFrom(address(this), _to, id, balance, \"\");\n\n        // Emits event for withdrawing collateral balance\n        emit WithdrawCollateral(_vault, _to, balance);\n    }\n\n    /// @notice Sets the feeReceiver address\n    /// @param _new The new fee receiver address\n    function updateFeeReceiver(address payable _new) external {\n        if (msg.sender != feeReceiver) revert NotAuthorized();\n        feeReceiver = _new;\n    }\n\n    /// @notice Gets the list of permissions installed on a vault\n    /// @dev Permissions consist of a module contract, target contract, and function selector\n    /// @return permissions List of vault permissions\n    function getPermissions()\n        public\n        view\n        override(IOptimisticListingSeaport, Module)\n        returns (Permission[] memory permissions)\n    {\n        permissions = new Permission[](3);\n        // burn function selector from supply contract\n        permissions[0] = Permission(address(this), supply, ISupply.burn.selector);\n        // unwrap function selector from marketplace contract\n        permissions[1] = Permission(\n            address(this),\n            seaportLister,\n            ISeaportLister.validateListing.selector\n        );\n        // list function selector from marketplace contract\n        permissions[2] = Permission(\n            address(this),\n            seaportLister,\n            ISeaportLister.cancelListing.selector\n        );\n    }\n\n    /// @dev Constructs a seaport order given an OfferItem and a price per token\n    function _constructOrder(\n        address _vault,\n        uint256 _listingPrice,\n        OfferItem[] calldata _offer\n    ) internal {\n        Order storage order = proposedListings[_vault].order;\n        OrderParameters storage orderParams = order.parameters;\n        {\n            orderParams.offerer = _vault;\n            orderParams.startTime = block.timestamp;\n            // order doesn't expire in human time scales and needs explicit cancellations\n            orderParams.endTime = type(uint256).max;\n            orderParams.zone = zone;\n            // 0: no partial fills, anyone can execute\n            orderParams.orderType = OrderType.FULL_OPEN;\n            orderParams.conduitKey = conduitKey;\n            // 1 Consideration for the listing itself + 1 consideration for the fees\n            orderParams.totalOriginalConsiderationItems = 3;\n        }\n\n        // Builds the order params from the offer items\n        unchecked {\n            for (uint256 i = 0; i < _offer.length; ++i) {\n                orderParams.offer.push(_offer[i]);\n            }\n        }\n\n        uint256 openseaFees = _listingPrice / 40;\n        uint256 tesseraFees = _listingPrice / 20;\n\n        // Attaches the actual consideration of the order\n        orderParams.consideration.push(\n            ConsiderationItem(\n                ItemType.NATIVE,\n                address(0),\n                0,\n                _listingPrice,\n                _listingPrice,\n                payable(address(this))\n            )\n        );\n\n        // Attaches a payment to the fee receiver to the consideration\n        orderParams.consideration.push(\n            ConsiderationItem(\n                ItemType.NATIVE,\n                address(0),\n                0,\n                openseaFees,\n                openseaFees,\n                OPENSEA_RECIPIENT\n            )\n        );\n\n        // Attaches a payment to the fee receiver to the consideration\n        orderParams.consideration.push(\n            ConsiderationItem(ItemType.NATIVE, address(0), 0, tesseraFees, tesseraFees, feeReceiver)\n        );\n\n        uint256 counter = ISeaport(seaport).getCounter(_vault);\n        vaultOrderHash[_vault] = _getOrderHash(orderParams, counter);\n    }\n\n    /// @dev Executes the delisting of the assets from the marketplace\n    function _delist(address _vault, bytes32[] calldata _delistProof) internal {\n        OrderParameters memory orderParams = activeListings[_vault].order.parameters;\n\n        // Gets order components for a vaults order\n        uint256 totalConsiderationItems = orderParams.totalOriginalConsiderationItems;\n        orderParams.totalOriginalConsiderationItems = 0;\n        OrderComponents memory orderComps;\n        assembly {\n            orderComps := orderParams\n        }\n        OrderComponents[] memory components = new OrderComponents[](1);\n        components[0] = orderComps;\n\n        // Cancels the Seaport listing\n        bytes memory data = abi.encodeCall(ISeaportLister.cancelListing, (seaport, components));\n        IVault(payable(_vault)).execute(seaportLister, data, _delistProof);\n\n        // Restores order parameters\n        orderParams.totalOriginalConsiderationItems = totalConsiderationItems;\n    }\n\n    /// @dev Reverts if token balance is insufficient\n    function _verifyBalance(\n        address _token,\n        uint256 _id,\n        uint256 _collateral\n    ) internal view returns (uint256 tokenBalance) {\n        tokenBalance = IERC1155(_token).balanceOf(msg.sender, _id);\n        if (_collateral == 0 || tokenBalance < _collateral) revert NotEnoughTokens();\n    }\n\n    /// @dev Reverts if vault is not current owner of the assets\n    function _verifySale(address _vault) internal view returns (bool status) {\n        (bool isValidated, bool isCancelled, uint256 totalFilled, uint256 totalSize) = ISeaport(\n            seaport\n        ).getOrderStatus(vaultOrderHash[_vault]);\n\n        if (isValidated && !isCancelled && totalFilled > 0 && totalFilled == totalSize) {\n            status = true;\n        }\n    }\n\n    /// @dev Reverts if vault is not registered\n    function _verifyVault(address _vault) internal view returns (address token, uint256 id) {\n        (token, id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n    }\n\n    /// @dev Generates the order hash from the order components\n    function _getOrderHash(OrderParameters memory _orderParams, uint256 _counter)\n        internal\n        view\n        returns (bytes32 orderHash)\n    {\n        OrderComponents memory orderComps = OrderComponents(\n            _orderParams.offerer,\n            _orderParams.zone,\n            _orderParams.offer,\n            _orderParams.consideration,\n            _orderParams.orderType,\n            _orderParams.startTime,\n            _orderParams.endTime,\n            _orderParams.zoneHash,\n            _orderParams.salt,\n            _orderParams.conduitKey,\n            _counter\n        );\n        orderHash = ISeaport(seaport).getOrderHash(orderComps);\n    }\n\n    /// @dev Sets a proposed or active listing in storage\n    function _setListing(\n        Listing storage _listing,\n        address _proposer,\n        uint256 _collateral,\n        uint256 _pricePerToken,\n        uint256 _proposalDate\n    ) internal {\n        _listing.proposer = _proposer;\n        _listing.collateral = _collateral;\n        _listing.pricePerToken = _pricePerToken;\n        _listing.proposalDate = _proposalDate;\n    }\n}"
    },
    {
      "filename": "src/seaport/modules/OptimisticListingSeaport.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Module} from \"../../modules/Module.sol\";\nimport {Multicall} from \"../../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../../utils/NFTReceiver.sol\";\nimport {SafeSend} from \"../../utils/SafeSend.sol\";\nimport {SelfPermit} from \"../../utils/SelfPermit.sol\";\n\nimport {ConsiderationItem, ItemType, OfferItem, Order, OrderParameters, OrderComponents, OrderType} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {ConsiderationInterface as ISeaport} from \"seaport/interfaces/ConsiderationInterface.sol\";\nimport {IERC1155} from \"../../interfaces/IERC1155.sol\";\nimport {IOptimisticListingSeaport, Listing} from \"../interfaces/IOptimisticListingSeaport.sol\";\nimport {IRae} from \"../../interfaces/IRae.sol\";\nimport {ISeaportLister} from \"../interfaces/ISeaportLister.sol\";\nimport {ISupply} from \"../../interfaces/ISupply.sol\";\nimport {IVault} from \"../../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../../interfaces/IVaultRegistry.sol\";\n\n/// @title OptimisticListingSeaport\n/// @author Tessera\n/// @notice Module contract for listing vault assets through the Seaport protocol\ncontract OptimisticListingSeaport is\n    IOptimisticListingSeaport,\n    Module,\n    Multicall,\n    NFTReceiver,\n    SafeSend,\n    SelfPermit\n{\n    /// @notice Address of VaultRegistry contract\n    address public immutable registry;\n    /// @notice Address of the Seaport contract\n    address public immutable seaport;\n    /// @notice Address of the Zone to list items under\n    address public immutable zone;\n    /// @notice The conduit key used to deploy the conduit\n    bytes32 public immutable conduitKey;\n    /// @notice Address of Supply target contract\n    address public immutable supply;\n    /// @notice Address of the SeaportLister target contract\n    address public immutable seaportLister;\n    /// @notice Time period of a proposed listing\n    uint256 public immutable PROPOSAL_PERIOD;\n    /// @notice Address of the OpenSea recipient for receiving fees\n    address payable public immutable OPENSEA_RECIPIENT;\n    /// @notice Address of the protocol fee receiver\n    address payable public feeReceiver;\n    /// @notice Mapping of vault address to order hash\n    mapping(address => bytes32) public vaultOrderHash;\n    /// @notice Mapping of vault address to active listings on Seaport\n    mapping(address => Listing) public activeListings;\n    /// @notice Mapping of vault address to newly proposed listings\n    mapping(address => Listing) public proposedListings;\n    /// @notice Mapping of vault address to user address to collateral amount\n    mapping(address => mapping(address => uint256)) public pendingBalances;\n\n    /// @dev Initializes contract state\n    constructor(\n        address _registry,\n        address _seaport,\n        address _zone,\n        bytes32 _conduitKey,\n        address _supply,\n        address _seaportLister,\n        address payable _feeReceiver,\n        address payable _openseaRecipient,\n        uint256 _proposalPeriod,\n        address payable _weth\n    ) SafeSend(_weth) {\n        registry = _registry;\n        seaport = _seaport;\n        zone = _zone;\n        conduitKey = _conduitKey;\n        supply = _supply;\n        seaportLister = _seaportLister;\n        feeReceiver = _feeReceiver;\n        OPENSEA_RECIPIENT = _openseaRecipient;\n        PROPOSAL_PERIOD = _proposalPeriod;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Proposes a new optimistic listing for a vault\n    /// @param _vault Address of the vault\n    /// @param _collateral Amount of tokens the proposer is risking\n    /// @param _pricePerToken Desired listing price of the vault assets divided by total supply\n    /// @param _offer List of items included in the offer to be listed\n    function propose(\n        address _vault,\n        uint256 _collateral,\n        uint256 _pricePerToken,\n        OfferItem[] calldata _offer\n    ) external {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if vault is not current owner of the assets\n        if (_verifySale(_vault)) revert NotOwner();\n        // Reverts if caller has insufficient token balance\n        _verifyBalance(token, id, _collateral);\n        // Initializes the mappings if this is the first time a proposal is being submitted for the vault\n        Listing storage proposedListing = proposedListings[_vault];\n        Listing storage activeListing = activeListings[_vault];\n        if (\n            proposedListings[_vault].proposer == address(0) &&\n            activeListings[_vault].proposer == address(0)\n        ) {\n            _setListing(proposedListing, address(this), 0, type(uint256).max, 0);\n            _setListing(activeListing, address(this), 0, type(uint256).max, 0);\n        }\n        // Reverts if price per token is not lower than both the proposed and active listings\n        if (\n            _pricePerToken >= proposedListing.pricePerToken ||\n            _pricePerToken >= activeListings[_vault].pricePerToken\n        ) revert NotLower();\n\n        // Calculates listing price based on price per token and total supply of Raes\n        uint256 listingPrice = _pricePerToken * IRae(token).totalSupply(id);\n\n        // Constructs Seaport order and sets the proposed listing\n        _constructOrder(_vault, listingPrice, _offer);\n        _setListing(proposedListing, msg.sender, _collateral, _pricePerToken, block.timestamp);\n\n        // Sets collateral amount to pending balances for withdrawal\n        pendingBalances[_vault][proposedListing.proposer] += proposedListing.collateral;\n\n        // Transfers new collateral amount from caller to this contract\n        IERC1155(token).safeTransferFrom(msg.sender, address(this), id, _collateral, \"\");\n\n        // Emits event for proposing new listing\n        emit Propose(_vault, msg.sender, _collateral, _pricePerToken, proposedListing.order);\n    }\n\n    /// @notice Rejects a new listing proposal\n    /// @param _vault Address of the vault\n    /// @param _amount Amount of tokens being rejected\n    function rejectProposal(address _vault, uint256 _amount) external payable {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if vault is not current owner of the assets\n        if (_verifySale(_vault)) revert NotOwner();\n        // Reverts if collateral is less than amount of rejected tokens\n        Listing storage proposedListing = proposedListings[_vault];\n        if (proposedListing.collateral < _amount) revert InsufficientCollateral();\n        // Reverts if payment amount is incorrect\n        if (proposedListing.pricePerToken * _amount != msg.value) revert InvalidPayment();\n\n        // Store proposer in memory\n        address proposer = proposedListing.proposer;\n\n        // Decrements collateral amount\n        proposedListing.collateral -= _amount;\n\n        // Checks if proposed listing has been rejected\n        if (proposedListing.collateral == 0) {\n            // Resets proposed listing to default\n            _setListing(proposedListing, address(this), 0, type(uint256).max, 0);\n        }\n\n        // Transfers tokens to caller\n        IERC1155(token).safeTransferFrom(address(this), msg.sender, id, _amount, \"\");\n        // Sends ether to proposer\n        _sendEthOrWeth(proposer, msg.value);\n\n        // Emits event for rejecting a proposed listing\n        emit RejectProposal(_vault, msg.sender, _amount, msg.value, proposedListing.order);\n    }\n\n    /// @notice Rejects an active listing\n    /// @param _vault Address of the vault\n    /// @param _amount Amount of tokens being rejected\n    /// @param _delistProof Merkle proof for executing the delisting of assets\n    function rejectActive(\n        address _vault,\n        uint256 _amount,\n        bytes32[] calldata _delistProof\n    ) external payable {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if vault is not current owner of the assets\n        if (_verifySale(_vault)) revert NotOwner();\n        // Reverts if collateral is less than amount of rejected tokens\n        Listing storage activeListing = activeListings[_vault];\n        if (activeListing.collateral < _amount) revert InsufficientCollateral();\n        // Reverts if payment amount is incorrect\n        if (activeListing.pricePerToken * _amount != msg.value) revert InvalidPayment();\n\n        // Store proposer in memory\n        address proposer = activeListing.proposer;\n\n        // Decrements collateral amount\n        activeListing.collateral -= _amount;\n\n        // Checks if active listing has been rejected\n        if (activeListing.collateral == 0) {\n            // Cancels the Seaport Order\n            _delist(_vault, _delistProof);\n            // Resets active listing to default\n            delete activeListings[_vault];\n            _setListing(activeListing, address(this), 0, type(uint256).max, 0);\n            // Emits event for delisting assets\n            emit Delist(_vault, activeListing.order);\n        }\n\n        // Transfers tokens to caller\n        IERC1155(token).safeTransferFrom(address(this), msg.sender, id, _amount, \"\");\n        // Sends ether to proposer\n        _sendEthOrWeth(proposer, msg.value);\n\n        // Emits event for rejecting an active listing\n        emit RejectActive(_vault, msg.sender, _amount, msg.value, activeListing.order);\n    }\n\n    /// @notice Lists the assets for sale\n    /// @param _vault Address of the vault\n    /// @param _listProof Merkle proof for executing the listing of assets\n    function list(address _vault, bytes32[] calldata _listProof) public {\n        // Reverts if vault is not registered\n        (address token, uint256 id) = _verifyVault(_vault);\n        // Reverts if vault is not current owner of the assets\n        if (_verifySale(_vault)) revert NotOwner();\n        // Reverts if collateral of proposed listing has been rejected\n        Listing storage proposedListing = proposedListings[_vault];\n        if (proposedListing.collateral == 0) revert Rejected();\n        // Reverts if proposal period has not elapsed\n        if (proposedListing.proposalDate + PROPOSAL_PERIOD > block.timestamp)\n            revert TimeNotElapsed();\n\n        // Sets remaining collateral amount of proposer for withdrawal\n        Listing memory activeListing = activeListings[_vault];\n        pendingBalances[_vault][activeListing.proposer] = activeListing.collateral;\n\n        // Calculates new listing price\n        uint256 newPrice = proposedListing.pricePerToken * IRae(token).totalSupply(id);\n\n        // Structures the order array\n        Order[] memory order = new Order[](1);\n        order[0] = proposedListing.order;\n\n        // Re"
    }
  ]
}