{
  "Title": "M-5: `BlueBerryBank.withdrawLend` function cannot be paused",
  "Content": "# Issue M-5: `BlueBerryBank.withdrawLend` function cannot be paused \n\nSource: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/204 \n\n## Found by \nrbserver\n\n## Summary\nWhen an extreme market condition occurs, the protocol faces an exploit, or the authority issues a legal requirement, the protocol is able to pause the lending, borrowing, and repaying functionalities. However, the protocol is unable to pause the functionality for reducing a position.\n\n## Vulnerability Detail\nBecause the `BlueBerryBank` contract does not have a function, which is like `BlueBerryBank.isBorrowAllowed`, `BlueBerryBank.isRepayAllowed`, and `BlueBerryBank.isLendAllowed`, for pausing the functionality for reducing a position, the `BlueBerryBank.withdrawLend` function, which is shown in the Code Snippet section, cannot be paused. Users can still call the `IchiVaultSpell.reducePosition` function that further calls the `BlueBerryBank.withdrawLend` function to reduce a position when there is a need for pausing this functionality.\n\n## Impact\nJust like pausing the lending, borrowing, and repaying functionalities, it is possible that the protocol needs to pause the functionality for reducing a position. However, when this need occurs, users can still reduce their positions through calling the `IchiVaultSpell.reducePosition` and `BlueBerryBank.withdrawLend` functions. The protocol cannot stop the outflow of the funds due to these position reductions even it is required to do so in this situation.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L266-L274\n```solidity\n    function reducePosition(\n        uint256 strategyId,\n        address collToken,\n        uint256 collAmount\n    ) external {\n        doWithdraw(collToken, collAmount);\n        doRefund(collToken);\n        _validateMaxLTV(strategyId);\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/BlueBerryBank.sol#L669-L704\n```solidity\n    function withdrawLend(address token, uint256 shareAmount)\n        external\n        override\n        inExec\n        poke(token)\n    {\n        Position storage pos = positions[POSITION_ID];\n        Bank storage bank = banks[token];\n        if (token != pos.underlyingToken) revert INVALID_UTOKEN(token);\n        if (shareAmount == type(uint256).max) {\n            shareAmount = pos.underlyingVaultShare;\n        }\n\n        uint256 wAmount;\n        if (address(ISoftVault(bank.softVault).uToken()) == token) {\n            ISoftVault(bank.softVault).approve(\n                bank.softVault,\n                type(uint256).max\n            );\n            wAmount = ISoftVault(bank.softVault).withdraw(shareAmount);\n        } else {\n            wAmount = IHardVault(bank.hardVault).withdraw(token, shareAmount);\n        }\n\n        wAmount = wAmount > pos.underlyingAmount\n            ? pos.underlyingAmount\n            : wAmount;\n\n        pos.underlyingVaultShare -= shareAmount;\n        pos.underlyingAmount -= wAmount;\n        bank.totalLend -= wAmount;\n\n        wAmount = doCutWithdrawFee(token, wAmount);\n\n        IERC20Upgradeable(token).safeTransfer(msg.sender, wAmount);\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nA function, which is similar to the `BlueBerryBank.isBorrowAllowed`, `BlueBerryBank.isRepayAllowed`, and `BlueBerryBank.isLendAllowed` functions, can be added in the `BlueBerryBank` contract for pausing the `BlueBerryBank.withdrawLend` function. This function can then be used in the `BlueBerryBank.withdrawLend` function so the `BlueBerryBank.withdrawLend` function can be paused when needed.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/41",
  "Code": [
    {
      "filename": "contracts/spell/IchiVaultSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../utils/BlueBerryConst.sol\";\nimport \"../libraries/UniV3/UniV3WrappedLibMockup.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IWIchiFarm.sol\";\nimport \"../interfaces/ichi/IICHIVault.sol\";\n\ncontract IchiVaultSpell is BasicSpell, IUniswapV3SwapCallback {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Strategy {\n        address vault;\n        uint256 maxPositionSize;\n    }\n\n    /// @dev temperory state used to store uni v3 pool when swapping on uni v3\n    IUniswapV3Pool private swapPool;\n\n    /// @dev strategyId => ichi vault\n    Strategy[] public strategies;\n    /// @dev strategyId => collateral token => maxLTV\n    mapping(uint256 => mapping(address => uint256)) public maxLTV; // base 1e4\n    /// @dev address of ICHI farm wrapper\n    IWIchiFarm public wIchiFarm;\n    /// @dev address of ICHI token\n    address public ICHI;\n\n    event StrategyAdded(uint256 strategyId, address vault, uint256 maxPosSize);\n    event CollateralsSupportAdded(\n        uint256 strategyId,\n        address[] collaterals,\n        uint256[] maxLTVs\n    );\n\n    modifier existingStrategy(uint256 strategyId) {\n        if (strategyId >= strategies.length)\n            revert STRATEGY_NOT_EXIST(address(this), strategyId);\n\n        _;\n    }\n\n    modifier existingCollateral(uint256 strategyId, address col) {\n        if (maxLTV[strategyId][col] == 0)\n            revert COLLATERAL_NOT_EXIST(strategyId, col);\n\n        _;\n    }\n\n    function initialize(\n        IBank _bank,\n        address _werc20,\n        address _weth,\n        address _wichiFarm\n    ) external initializer {\n        __BasicSpell_init(_bank, _werc20, _weth);\n\n        wIchiFarm = IWIchiFarm(_wichiFarm);\n        ICHI = address(wIchiFarm.ICHI());\n        IWIchiFarm(_wichiFarm).setApprovalForAll(address(_bank), true);\n    }\n\n    /**\n     * @notice Owner privileged function to add vault\n     * @param vault Address of ICHI angel vault\n     * @param maxPosSize, USD price based maximum size of a position for given vault, based 1e18\n     */\n    function addStrategy(address vault, uint256 maxPosSize) external onlyOwner {\n        if (vault == address(0)) revert ZERO_ADDRESS();\n        if (maxPosSize == 0) revert ZERO_AMOUNT();\n        strategies.push(Strategy({vault: vault, maxPositionSize: maxPosSize}));\n        emit StrategyAdded(strategies.length - 1, vault, maxPosSize);\n    }\n\n    function addCollateralsSupport(\n        uint256 strategyId,\n        address[] memory collaterals,\n        uint256[] memory maxLTVs\n    ) external existingStrategy(strategyId) onlyOwner {\n        if (collaterals.length != maxLTVs.length || collaterals.length == 0)\n            revert INPUT_ARRAY_MISMATCH();\n\n        for (uint256 i = 0; i < collaterals.length; i++) {\n            if (collaterals[i] == address(0)) revert ZERO_ADDRESS();\n            if (maxLTVs[i] == 0) revert ZERO_AMOUNT();\n            maxLTV[strategyId][collaterals[i]] = maxLTVs[i];\n        }\n\n        emit CollateralsSupportAdded(strategyId, collaterals, maxLTVs);\n    }\n\n    function _validateMaxLTV(uint256 strategyId) internal view {\n        uint256 debtValue = bank.getDebtValue(bank.POSITION_ID());\n        (, address collToken, uint256 collAmount, , , , , ) = bank\n            .getCurrentPositionInfo();\n        uint256 collPrice = bank.oracle().getPrice(collToken);\n        uint256 collValue = (collPrice * collAmount) /\n            10**IERC20Metadata(collToken).decimals();\n\n        if (\n            debtValue >\n            (collValue * maxLTV[strategyId][collToken]) / DENOMINATOR\n        ) revert EXCEED_MAX_LTV();\n    }\n\n    /**\n     * @notice Internal function to deposit assets on ICHI Vault\n     * @param collToken Isolated collateral token address\n     * @param collAmount Amount of isolated collateral\n     * @param borrowToken Token address to borrow\n     * @param borrowAmount amount to borrow from Bank\n     */\n    function depositInternal(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount\n    ) internal {\n        Strategy memory strategy = strategies[strategyId];\n\n        // 1. Lend isolated collaterals on compound\n        doLend(collToken, collAmount);\n\n        // 2. Borrow specific amounts\n        doBorrow(borrowToken, borrowAmount);\n\n        // 3. Add liquidity - Deposit on ICHI Vault\n        IICHIVault vault = IICHIVault(strategy.vault);\n        bool isTokenA = vault.token0() == borrowToken;\n        uint256 balance = IERC20(borrowToken).balanceOf(address(this));\n        ensureApprove(borrowToken, address(vault));\n        if (isTokenA) {\n            vault.deposit(balance, 0, address(this));\n        } else {\n            vault.deposit(0, balance, address(this));\n        }\n\n        // 4. Validate MAX LTV\n        _validateMaxLTV(strategyId);\n\n        // 5. Validate Max Pos Size\n        uint256 lpPrice = bank.oracle().getPrice(strategy.vault);\n        uint256 curPosSize = (lpPrice * vault.balanceOf(address(this))) /\n            10**IICHIVault(strategy.vault).decimals();\n        if (curPosSize > strategy.maxPositionSize)\n            revert EXCEED_MAX_POS_SIZE(strategyId);\n    }\n\n    /**\n     * @notice External function to deposit assets on IchiVault\n     * @param collToken Collateral Token address to deposit (e.g USDC)\n     * @param collAmount Amount of user's collateral (e.g USDC)\n     * @param borrowToken Address of token to borrow\n     * @param borrowAmount Amount to borrow from Bank\n     */\n    function openPosition(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        // 1-3 Deposit on ichi vault\n        depositInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            collAmount,\n            borrowAmount\n        );\n\n        // 4. Put collateral - ICHI Vault Lp Token\n        address vault = strategies[strategyId].vault;\n        doPutCollateral(vault, IERC20(vault).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice External function to deposit assets on IchiVault and farm in Ichi Farm\n     * @param collToken Collateral Token address to deposit (e.g USDC)\n     * @param collAmount Amount of user's collateral (e.g USDC)\n     * @param borrowToken Address of token to borrow\n     * @param borrowAmount Amount to borrow from Bank\n     * @param farmingPid Pool Id of vault lp on ICHI Farm\n     */\n    function openPositionFarm(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount,\n        uint256 farmingPid\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        Strategy memory strategy = strategies[strategyId];\n        address lpToken = wIchiFarm.ichiFarm().lpToken(farmingPid);\n        if (strategy.vault != lpToken) revert INCORRECT_LP(lpToken);\n\n        // 1-3 Deposit on ichi vault\n        depositInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            collAmount,\n            borrowAmount\n        );\n\n        // 4. Take out collateral\n        (\n            ,\n            ,\n            ,\n            ,\n            address posCollToken,\n            uint256 collId,\n            uint256 collSize,\n\n        ) = bank.getCurrentPositionInfo();\n        if (collSize > 0) {\n            (uint256 decodedPid, ) = wIchiFarm.decodeId(collId);\n            if (farmingPid != decodedPid) revert INCORRECT_PID(farmingPid);\n            if (posCollToken != address(wIchiFarm))\n                revert INCORRECT_COLTOKEN(posCollToken);\n            bank.takeCollateral(collSize);\n            wIchiFarm.burn(collId, collSize);\n        }\n\n        // 5. Deposit on farming pool, put collateral\n        ensureApprove(strategy.vault, address(wIchiFarm));\n        uint256 lpAmount = IERC20(strategy.vault).balanceOf(address(this));\n        uint256 id = wIchiFarm.mint(farmingPid, lpAmount);\n        bank.putCollateral(address(wIchiFarm), id, lpAmount);\n    }\n\n    /**\n     * @dev Increase isolated collateral of position\n     * @param token Isolated collateral token address\n     * @param amount Amount of token to increase position\n     */\n    function increasePosition(address token, uint256 amount) external {\n        // 1. Get user input amounts\n        doLend(token, amount);\n    }\n\n    /**\n     * @dev Reduce isolated collateral of position\n     * @param collToken Isolated collateral token address\n     * @param collAmount Amount of Isolated collateral\n     */\n    function reducePosition(\n        uint256 strategyId,\n        address collToken,\n        uint256 collAmount\n    ) external {\n        doWithdraw(collToken, collAmount);\n        doRefund(collToken);\n        _validateMaxLTV(strategyId);\n    }\n\n    function withdrawInternal(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    ) internal {\n        Strategy memory strategy = strategies[strategyId];\n        IICHIVault vault = IICHIVault(strategy.vault);\n        uint256 positionId = bank.POSITION_ID();\n\n        // 1. Compute repay amount if MAX_INT is supplied (max debt)\n        if (amountRepay == type(uint256).max) {\n            amountRepay = bank.borrowBalanceCurrent(positionId, borrowToken);\n        }\n\n        // 2. Calculate actual amount to remove\n        uint256 amtLPToRemove = vault.balanceOf(address(this)) -\n            amountLpWithdraw;\n\n        // 3. Withdraw liquidity from ICHI vault\n        vault.withdraw(amtLPToRemove, address(this));\n\n        // 4. Swap withdrawn tokens to initial deposit token\n        bool isTokenA = vault.token0() == borrowToken;\n        uint256 amountToSwap = IERC20(\n            isTokenA ? vault.token1() : vault.token0()\n        ).balanceOf(address(this));\n        if (amountToSwap > 0) {\n            swapPool = IUniswapV3Pool(vault.pool());\n            swapPool.swap(\n                address(this),\n                // if withdraw token is Token0, then swap token1 -> token0 (false)\n                !isTokenA,\n                int256(amountToSwap),\n                isTokenA\n                    ? UniV3WrappedLibMockup.MAX_SQRT_RATIO - 1 // Token0 -> Token1\n                    : UniV3WrappedLibMockup.MIN_SQRT_RATIO + 1, // Token1 -> Token0\n                abi.encode(address(this))\n            );\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        doWithdraw(collToken, amountShareWithdraw);\n\n        // 6. Repay\n        doRepay(borrowToken, amountRepay);\n\n        _validateMaxLTV(strategyId);\n\n        // 7. Refund\n        doRefund(borrowToken);\n        doRefund(collToken);\n    }\n\n    /**\n     * @notice External function to withdraw assets from ICHI Vault\n     * @param collToken Token address to withdraw (e.g USDC)\n     * @param borrowToken Token address to withdraw (e.g USDC)\n     * @param lpTakeAmt Amount of ICHI Vault LP token to take out from Bank\n     * @param amountRepay Amount to repay the loan\n     * @param amountLpWithdraw Amount of ICHI Vault LP to withdraw from ICHI Vault\n     * @param amountShareWithdraw Amount of Isolated collateral to withdraw from Compound\n     */\n    function closePosition(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 lpTakeAmt,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        // 1. Take out collateral\n        doTakeCollateral(strategies[strategyId].vault, lpTakeAmt);\n\n        withdrawInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            amountRepay,\n            amountLpWithdraw,\n            amountShareWithdraw\n        );\n    }\n\n    function closePositionFarm(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 lpTakeAmt,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        address vault = strategies[strategyId].vault;\n        (, , , , address posCollToken, uint256 collId, , ) = bank\n            .getCurrentPositionInfo();\n        if (IWIchiFarm(posCollToken).getUnderlyingToken(collId) != vault)\n            revert INCORRECT_UNDERLYING(vault);\n        if (posCollToken != address(wIchiFarm))\n            revert INCORRECT_COLTOKEN(posCollToken);\n\n        // 1. Take out collateral\n        bank.takeCollateral(lpTakeAmt);\n        wIchiFarm.burn(collId, lpTakeAmt);\n        doCutRewardsFee(ICHI);\n\n        // 2-8. Remove liquidity\n        withdrawInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            amountRepay,\n            amountLpWithdraw,\n            amountShareWithdraw\n        );\n\n        // 9. Refund ichi token\n        doRefund(ICHI);\n    }\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external override {\n        if (msg.sender != address(swapPool)) revert NOT_FROM_UNIV3(msg.sender);\n        address payer = abi.decode(data, (address));\n\n        if (amount0Delta > 0) {\n            if (payer == address(this)) {\n                IERC20Upgradeable(swapPool.token0()).safeTransfer(\n                    msg.sender,\n                    uint256(amount0Delta)\n                );\n            } else {\n                IERC20Upgradeable(swapPool.token0()).safeTransferFrom(\n                    payer,\n                    msg.sender,\n                    uint256(amount0Delta)\n                );\n            }\n        } else if (amount1Delta > 0) {\n            if (payer == address(this)) {\n                IERC20Upgradeable(swapPool.token1()).safeTransfer(\n                    msg.sender,\n                    uint256(amount1Delta)\n                );\n            } else {\n                IERC20Upgradeable(swapPool.token1()).safeTransferFrom(\n                    payer,\n                    msg.sender,\n                    uint256(amount1Delta)\n                );\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/BlueBerryBank.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\nimport \"./utils/BlueBerryConst.sol\";\nimport \"./utils/BlueBerryErrors.sol\";\nimport \"./utils/ERC1155NaiveReceiver.sol\";\nimport \"./interfaces/IBank.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/ISoftVault.sol\";\nimport \"./interfaces/IHardVault.sol\";\nimport \"./interfaces/compound/ICErc20.sol\";\nimport \"./interfaces/compound/IComptroller.sol\";\nimport \"./libraries/BBMath.sol\";\nimport \"hardhat/console.sol\";\n\ncontract BlueBerryBank is OwnableUpgradeable, ERC1155NaiveReceiver, IBank {\n    using BBMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private constant _NO_ID = type(uint256).max;\n    address private constant _NO_ADDRESS = address(1);\n\n    uint256 public _GENERAL_LOCK; // TEMPORARY: re-entrancy lock guard.\n    uint256 public _IN_EXEC_LOCK; // TEMPORARY: exec lock guard.\n    uint256 public override POSITION_ID; // TEMPORARY: position ID currently under execution.\n    address public override SPELL; // TEMPORARY: spell currently under execution.\n\n    IProtocolConfig public config;\n    IOracle public oracle; // The oracle address for determining prices.\n    uint256 public override nextPositionId; // Next available position ID, starting from 1 (see initialize).\n\n    address[] public allBanks; // The list of all listed banks.\n    mapping(address => Bank) public banks; // Mapping from token to bank data.\n    mapping(address => bool) public cTokenInBank; // Mapping from cToken to its existence in bank.\n    mapping(uint256 => Position) public positions; // Mapping from position ID to position data.\n\n    bool public allowContractCalls; // The boolean status whether to allow call from contract (false = onlyEOA)\n    mapping(address => bool) public whitelistedTokens; // Mapping from token to whitelist status\n    mapping(address => bool) public whitelistedSpells; // Mapping from spell to whitelist status\n    mapping(address => bool) public whitelistedContracts; // Mapping from user to whitelist status\n\n    uint256 public bankStatus; // Each bit stores certain bank status, e.g. borrow allowed, repay allowed\n\n    /// @dev Ensure that the function is called from EOA\n    /// when allowContractCalls is set to false and caller is not whitelisted\n    modifier onlyEOAEx() {\n        if (!allowContractCalls && !whitelistedContracts[msg.sender]) {\n            if (msg.sender != tx.origin) revert NOT_EOA(msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Ensure that the token is already whitelisted\n    modifier onlyWhitelistedToken(address token) {\n        if (!whitelistedTokens[token]) revert TOKEN_NOT_WHITELISTED(token);\n        _;\n    }\n\n    /// @dev Reentrancy lock guard.\n    modifier lock() {\n        if (_GENERAL_LOCK != _NOT_ENTERED) revert LOCKED();\n        _GENERAL_LOCK = _ENTERED;\n        _;\n        _GENERAL_LOCK = _NOT_ENTERED;\n    }\n\n    /// @dev Ensure that the function is called from within the execution scope.\n    modifier inExec() {\n        if (POSITION_ID == _NO_ID) revert NOT_IN_EXEC();\n        if (SPELL != msg.sender) revert NOT_FROM_SPELL(msg.sender);\n        if (_IN_EXEC_LOCK != _NOT_ENTERED) revert LOCKED();\n        _IN_EXEC_LOCK = _ENTERED;\n        _;\n        _IN_EXEC_LOCK = _NOT_ENTERED;\n    }\n\n    /// @dev Ensure that the interest rate of the given token is accrued.\n    modifier poke(address token) {\n        accrue(token);\n        _;\n    }\n\n    /// @dev Initialize the bank smart contract, using msg.sender as the first governor.\n    /// @param _oracle The oracle smart contract address.\n    /// @param _config The Protocol config address\n    function initialize(IOracle _oracle, IProtocolConfig _config)\n        external\n        initializer\n    {\n        __Ownable_init();\n        if (address(_oracle) == address(0) || address(_config) == address(0)) {\n            revert ZERO_ADDRESS();\n        }\n        _GENERAL_LOCK = _NOT_ENTERED;\n        _IN_EXEC_LOCK = _NOT_ENTERED;\n        POSITION_ID = _NO_ID;\n        SPELL = _NO_ADDRESS;\n\n        config = _config;\n        oracle = _oracle;\n        nextPositionId = 1;\n        bankStatus = 7; // allow borrow, lend, repay\n\n        emit SetOracle(address(_oracle));\n    }\n\n    /// @dev Return the current executor (the owner of the current position).\n    function EXECUTOR() external view override returns (address) {\n        uint256 positionId = POSITION_ID;\n        if (positionId == _NO_ID) {\n            revert NOT_UNDER_EXECUTION();\n        }\n        return positions[positionId].owner;\n    }\n\n    /// @dev Set allowContractCalls\n    /// @param ok The status to set allowContractCalls to (false = onlyEOA)\n    function setAllowContractCalls(bool ok) external onlyOwner {\n        allowContractCalls = ok;\n    }\n\n    /// @notice Set whitelist user status\n    /// @param contracts list of users to change status\n    /// @param statuses list of statuses to change to\n    function whitelistContracts(\n        address[] calldata contracts,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        if (contracts.length != statuses.length) {\n            revert INPUT_ARRAY_MISMATCH();\n        }\n        for (uint256 idx = 0; idx < contracts.length; idx++) {\n            if (contracts[idx] == address(0)) {\n                revert ZERO_ADDRESS();\n            }\n            whitelistedContracts[contracts[idx]] = statuses[idx];\n        }\n    }\n\n    /// @dev Set whitelist spell status\n    /// @param spells list of spells to change status\n    /// @param statuses list of statuses to change to\n    function whitelistSpells(\n        address[] calldata spells,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        if (spells.length != statuses.length) {\n            revert INPUT_ARRAY_MISMATCH();\n        }\n        for (uint256 idx = 0; idx < spells.length; idx++) {\n            if (spells[idx] == address(0)) {\n                revert ZERO_ADDRESS();\n            }\n            whitelistedSpells[spells[idx]] = statuses[idx];\n        }\n    }\n\n    /// @dev Set whitelist token status\n    /// @param tokens list of tokens to change status\n    /// @param statuses list of statuses to change to\n    function whitelistTokens(\n        address[] calldata tokens,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        if (tokens.length != statuses.length) {\n            revert INPUT_ARRAY_MISMATCH();\n        }\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            if (statuses[idx] && !oracle.support(tokens[idx]))\n                revert ORACLE_NOT_SUPPORT(tokens[idx]);\n            whitelistedTokens[tokens[idx]] = statuses[idx];\n        }\n    }\n\n    /**\n     * @dev Add a new bank to the ecosystem.\n     * @param token The underlying token for the bank.\n     * @param cToken The address of the cToken smart contract.\n     * @param softVault The address of softVault.\n     * @param hardVault The address of hardVault.\n     */\n    function addBank(\n        address token,\n        address cToken,\n        address softVault,\n        address hardVault\n    ) external onlyOwner onlyWhitelistedToken(token) {\n        if (\n            token == address(0) ||\n            cToken == address(0) ||\n            softVault == address(0) ||\n            hardVault == address(0)\n        ) revert ZERO_ADDRESS();\n        Bank storage bank = banks[token];\n        if (cTokenInBank[cToken]) revert CTOKEN_ALREADY_ADDED();\n        if (bank.isListed) revert BANK_ALREADY_LISTED();\n        if (allBanks.length >= 256) revert BANK_LIMIT();\n        cTokenInBank[cToken] = true;\n        bank.isListed = true;\n        bank.index = uint8(allBanks.length);\n        bank.cToken = cToken;\n        bank.softVault = softVault;\n        bank.hardVault = hardVault;\n\n        IHardVault(hardVault).setApprovalForAll(hardVault, true);\n        allBanks.push(token);\n\n        emit AddBank(token, cToken, softVault, hardVault);\n    }\n\n    /// @dev Set bank status\n    /// @param _bankStatus new bank status to change to\n    function setBankStatus(uint256 _bankStatus) external onlyOwner {\n        bankStatus = _bankStatus;\n    }\n\n    /// @dev Bank borrow status allowed or not\n    /// @notice check last bit of bankStatus\n    function isBorrowAllowed() public view returns (bool) {\n        return (bankStatus & 0x01) > 0;\n    }\n\n    /// @dev Bank repay status allowed or not\n    /// @notice Check second-to-last bit of bankStatus\n    function isRepayAllowed() public view returns (bool) {\n        return (bankStatus & 0x02) > 0;\n    }\n\n    /// @dev Bank borrow status allowed or not\n    /// @notice check last bit of bankStatus\n    function isLendAllowed() public view returns (bool) {\n        return (bankStatus & 0x04) > 0;\n    }\n\n    /// @dev Check whether the oracle supports the token\n    /// @param token ERC-20 token to check for support\n    function support(address token) external view override returns (bool) {\n        return oracle.support(token);\n    }\n\n    /// @dev Trigger interest accrual for the given bank.\n    /// @param token The underlying token to trigger the interest accrual.\n    function accrue(address token) public override {\n        Bank storage bank = banks[token];\n        if (!bank.isListed) revert BANK_NOT_LISTED(token);\n        bank.totalDebt = ICErc20(bank.cToken).borrowBalanceCurrent(\n            address(this)\n        );\n    }\n\n    /// @dev Convenient function to trigger interest accrual for a list of banks.\n    /// @param tokens The list of banks to trigger interest accrual.\n    function accrueAll(address[] memory tokens) external {\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            accrue(tokens[idx]);\n        }\n    }\n\n    /// @dev Return the borrow balance for given position and token without triggering interest accrual.\n    /// @param positionId The position to query for borrow balance.\n    /// @param token The token to query for borrow balance.\n    function borrowBalanceStored(uint256 positionId, address token)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 totalDebt = banks[token].totalDebt;\n        uint256 totalShare = banks[token].totalShare;\n        uint256 share = positions[positionId].debtShareOf[token];\n        if (share == 0 || totalDebt == 0) {\n            return 0;\n        } else {\n            return (share * totalDebt).divCeil(totalShare);\n        }\n    }\n\n    /// @dev Trigger interest accrual and return the current borrow balance.\n    /// @param positionId The position to query for borrow balance.\n    /// @param token The token to query for borrow balance.\n    function borrowBalanceCurrent(uint256 positionId, address token)\n        external\n        override\n        poke(token)\n        returns (uint256)\n    {\n        return borrowBalanceStored(positionId, token);\n    }\n\n    /// @dev Return bank information for the given token.\n    /// @param token The token address to query for bank information.\n    function getBankInfo(address token)\n        external\n        view\n        override\n        returns (\n            bool isListed,\n            address cToken,\n            uint256 totalDebt,\n            uint256 totalShare\n        )\n    {\n        Bank storage bank = banks[token];\n        return (bank.isListed, bank.cToken, bank.totalDebt, bank.totalShare);\n    }\n\n    function getPositionIdsByOwner(address owner)\n        external\n        view\n        returns (uint256[] memory ids)\n    {\n        uint256[] memory matchingIds = new uint256[](nextPositionId);\n        uint256 index;\n        for (uint256 i = 0; i < nextPositionId; i++) {\n            if (positions[i].owner == owner) {\n                matchingIds[index] = i;\n                index++;\n            }\n        }\n\n        ids = new uint256[](index);\n        for (uint256 i = 0; i < index; i++) {\n            ids[i] = matchingIds[i];\n        }\n    }\n\n    /// @dev Return position information for the given position id.\n    /// @param positionId The position id to query for position information.\n    function getPositionInfo(uint256 positionId)\n        public\n        view\n        override\n        returns (\n            address owner,\n            address underlyingToken,\n            uint256 underlyingAmount,\n            uint256 underlyingVaultShare,\n            address collToken,\n            uint256 collId,\n            uint256 collateralSize,\n            uint256 risk\n        )\n    {\n        Position storage pos = positions[positionId];\n        owner = pos.owner;\n        underlyingToken = pos.underlyingToken;\n        underlyingAmount = pos.underlyingAmount;\n        underlyingVaultShare = pos.underlyingVaultShare;\n        collToken = pos.collToken;\n        collId = pos.collId;\n        collateralSize = pos.collateralSize;\n        risk = getPositionRisk(positionId);\n    }\n\n    /// @dev Return current position information\n    function getCurrentPositionInfo()\n        external\n        view\n        override\n        returns (\n            address owner,\n            address underlyingToken,\n            uint256 underlyingAmount,\n            uint256 underlyingVaultShare,\n            address collToken,\n            uint256 collId,\n            uint256 collateralSize,\n            uint256 risk\n        )\n    {\n        if (POSITION_ID == _NO_ID) revert BAD_POSITION(POSITION_ID);\n        return getPositionInfo(POSITION_ID);\n    }\n\n    /// @dev Return the debt share of the given bank token for the given position id.\n    /// @param positionId position id to get debt of\n    /// @param token ERC20 debt token to query\n    function getPositionDebtShareOf(uint256 positionId, address token)\n        external\n        view\n        returns (uint256)\n    {\n        return positions[positionId].debtShareOf[token];\n    }\n\n    /// @dev Return the list of all debts for the given position id.\n    /// @param positionId position id to get debts of\n    function getPositionDebts(uint256 positionId)\n        external\n        view\n        returns (address[] memory tokens, uint256[] memory debts)\n    {\n        Position storage pos = positions[positionId];\n        uint256 count = 0;\n        uint256 bitMap = pos.debtMap;\n        while (bitMap > 0) {\n            if ((bitMap & 1) != 0) {\n                count++;\n            }\n            bitMap >>= 1;\n        }\n        tokens = new address[](count);\n        debts = new uint256[](count);\n        bitMap = pos.debtMap;\n        count = 0;\n        uint256 idx = 0;\n        while (bitMap > 0) {\n            if ((bitMap & 1) != 0) {\n                address token = allBanks[idx];\n                Bank storage bank = banks[token];\n                tokens[count] = token;\n                debts[count] = (pos.debtShareOf[token] * bank.totalDebt)\n                    .divCeil(bank.totalShare);\n                count++;\n            }\n            idx++;\n            bitMap >>= 1;\n        }\n    }\n\n    /**\n     * @dev Return the USD value of total collateral of the given position.\n     * @param positionId The position ID to query for the collateral value.\n     */\n    function getPositionValue(uint256 positionId)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        Position storage pos = positions[positionId];\n        uint256 size = pos.collateralSize;\n        if (size == 0) {\n            return 0;\n        } else {\n            if (pos.collToken == address(0)) revert BAD_COLLATERAL(positionId);\n            return oracle.getCollateralValue(pos.collToken, pos.collId, size);\n        }\n    }\n\n    /// @dev Return the USD value total debt of the given position\n    /// @param positionId The position ID to query for the debt value.\n    function getDebtValue(uint256 positionId)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 value = 0;\n        Position storage pos = positions[positionId];\n        uint256 bitMap = pos.debtMap;\n        uint256 idx = 0;\n        while (bitMap > 0) {\n            if ((bitMap & 1) != 0) {\n                address token = allBanks[idx];\n                uint256 share = pos.debtShareOf[token];\n                Bank storage bank = banks[token];\n                uint256 debt = (share * bank.totalDebt).divCeil(\n                    bank.totalShare\n                );\n                value += oracle.getDebtValue(token, debt);\n            }\n            idx++;\n            bitMap >>= 1;\n        }\n        return value;\n    }\n\n    function getPositionRisk(uint256 positionId)\n        public\n        view\n        returns (uint256 risk)\n    {\n        Position storage pos = positions[positionId];\n        uint256 pv = getPositionValue(positionId);\n        uint256 ov = getDebtValue(positionId);\n        uint256 cv = oracle.getUnderlyingValue(\n            pos.underlyingToken,\n            pos.underlyingAmount\n        );\n\n        if (cv == 0) risk = 0;\n        else if (pv >= ov) risk = 0;\n        else {\n            risk = ((ov - pv) * DENOMINATOR) / cv;\n        }\n    }\n\n    function isLiquidatable(uint256 positionId)\n        public\n        view\n        returns (bool liquidatable)\n    {\n        Position storage pos = positions[positionId];\n        uint256 risk = getPositionRisk(positionId);\n        liquidatable = risk >= oracle.getLiqThreshold(pos.underlyingToken);\n    }\n\n    /// @dev Liquidate a position. Pay debt for its owner and take the collateral.\n    /// @param positionId The position ID to liquidate.\n    /// @param debtToken The debt token to repay.\n    /// @param amountCall The amount to repay when doing transferFrom call.\n    function liquidate(\n        uint256 positionId,"
    }
  ]
}