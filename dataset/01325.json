{
  "Title": "Missing reentrancy guard in `TokenFacet::transferToken`",
  "Content": "Unlike most other external and potentially state-modifying functions in `TokenFacet`, [`TokenFacet::transferToken`](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/farm/TokenFacet.sol#L56-L62) does not have the `nonReentrant` modifier applied. While we have been unable to identify a vector for exploit based on the current commit hash, it is recommended to add the modifier to this function to be in keeping with the rest of the code and prevent any potential future misuse.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/farm/TokenFacet.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {IERC1155Receiver} from \"contracts/interfaces/IERC1155Receiver.sol\";\nimport \"contracts/libraries/Token/LibTransfer.sol\";\nimport \"contracts/libraries/Token/LibWeth.sol\";\nimport \"contracts/libraries/Token/LibEth.sol\";\nimport \"contracts/libraries/Token/LibTokenPermit.sol\";\nimport \"contracts/libraries/Token/LibTokenApprove.sol\";\nimport \"../AppStorage.sol\";\nimport \"../ReentrancyGuard.sol\";\n\n/**\n * @author Publius\n * @title TokenFacet handles transfers of assets\n */\ncontract TokenFacet is IERC1155Receiver, ReentrancyGuard {\n    struct Balance {\n        uint256 internalBalance;\n        uint256 externalBalance;\n        uint256 totalBalance;\n    }\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    event InternalBalanceChanged(\n        address indexed user,\n        IERC20 indexed token,\n        int256 delta\n    );\n\n     event TokenApproval(\n        address indexed owner,\n        address indexed spender,\n        IERC20 token,\n        uint256 amount\n    );\n\n    //////////////////////// Transfer ////////////////////////\n\n    /**\n     * @notice transfers a token from msg.sender to `recipient`.\n     * @dev enables transfers between internal and external balances.\n     * \n     * @param token The token to transfer.\n     * @param recipient The recipient of the transfer.\n     * @param amount The amount to transfer.\n     * @param fromMode The source of token from the sender. See {LibTransfer.From}.\n     * @param toMode The destination of token to the recipient. See {LibTransfer.To}.\n     */\n    function transferToken(\n        IERC20 token,\n        address recipient,\n        uint256 amount,\n        LibTransfer.From fromMode,\n        LibTransfer.To toMode\n    ) external payable {\n        LibTransfer.transferToken(\n            token,\n            msg.sender,\n            recipient,\n            amount,\n            fromMode,\n            toMode\n        );\n    }\n\n    /**\n     * @notice transfers a token from `sender` to an `recipient` Internal balance.\n     * @dev differs from transferToken as it does not use msg.sender.\n     */\n    function transferInternalTokenFrom(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount,\n        LibTransfer.To toMode\n    ) external payable nonReentrant {\n        LibTransfer.transferToken(\n            token,\n            sender,\n            recipient,\n            amount,\n            LibTransfer.From.INTERNAL,\n            toMode\n        );\n\n        if (sender != msg.sender) {\n            LibTokenApprove.spendAllowance(sender, msg.sender, token, amount);\n        }\n    }\n\n    //////////////////////// Transfer ////////////////////////\n\n    /**\n     * @notice approves a token for a spender.\n     * @dev this approves a token for both internal and external balances.\n     */\n    function approveToken(\n        address spender,\n        IERC20 token,\n        uint256 amount\n    ) external payable nonReentrant {\n        LibTokenApprove.approve(msg.sender, spender, token, amount);\n    }\n\n    /**\n     * @notice increases approval for a token for a spender.\n     */\n    function increaseTokenAllowance(\n        address spender,\n        IERC20 token,\n        uint256 addedValue\n    ) public virtual nonReentrant returns (bool) {\n        LibTokenApprove.approve(\n            msg.sender,\n            spender,\n            token,\n            LibTokenApprove.allowance(msg.sender, spender, token).add(addedValue)\n        );\n        return true;\n    }\n\n    \n    /**\n     * @notice decreases approval for a token for a spender.\n     */\n    function decreaseTokenAllowance(\n        address spender,\n        IERC20 token,\n        uint256 subtractedValue\n    ) public virtual nonReentrant returns (bool) {\n        uint256 currentAllowance = LibTokenApprove.allowance(\n            msg.sender,\n            spender,\n            token\n        );\n        require(\n            currentAllowance >= subtractedValue,\n            \"Silo: decreased allowance below zero\"\n        );\n        LibTokenApprove.approve(\n            msg.sender,\n            spender,\n            token,\n            currentAllowance.sub(subtractedValue)\n        );\n        return true;\n    }\n\n    /**\n     * @notice returns the allowance for a token for a spender.\n     */\n    function tokenAllowance(\n        address account,\n        address spender,\n        IERC20 token\n    ) public view virtual returns (uint256) {\n        return LibTokenApprove.allowance(account, spender, token);\n    }\n\n    //////////////////////// Permit ////////////////////////\n\n    /**\n     * @notice approves a token for a spender using EIP2612.\n     */\n    function permitToken(\n        address owner,\n        address spender,\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable nonReentrant {\n        LibTokenPermit.permit(owner, spender, token, value, deadline, v, r, s);\n        LibTokenApprove.approve(owner, spender, IERC20(token), value);\n    }\n\n    /**\n     * @notice returns the current permit nonce for a token for an owner.\n     */\n    function tokenPermitNonces(address owner)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return LibTokenPermit.nonces(owner);\n    }\n\n    //////////////////////// ERC1155Reciever ////////////////////////\n\n    /**\n     * @notice ERC1155Reciever function that allows the silo to receive ERC1155 tokens.\n     * \n     * @dev as ERC1155 deposits are not accepted yet, \n     * this function will revert.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        revert(\"Silo: ERC1155 deposits are not accepted yet.\");\n    }\n\n    /**\n     * @notice onERC1155BatchReceived function that allows the silo to receive ERC1155 tokens.\n     * \n     * @dev as ERC1155 deposits are not accepted yet, \n     * this function will revert.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        revert(\"Silo: ERC1155 deposits are not accepted yet.\");\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function tokenPermitDomainSeparator() external view returns (bytes32) {\n        return LibTokenPermit._domainSeparatorV4();\n    }\n\n    //////////////////////// WETH ////////////////////////\n\n    /**\n     * @notice wraps ETH into WETH.\n     */\n    function wrapEth(uint256 amount, LibTransfer.To mode) external payable {\n        LibWeth.wrap(amount, mode);\n        LibEth.refundEth();\n    }\n\n    /**\n     * @notice unwraps WETH into ETH.\n     */\n    function unwrapEth(uint256 amount, LibTransfer.From mode) external payable {\n        LibWeth.unwrap(amount, mode);\n    }\n\n    //////////////////////// GETTERS ////////////////////////\n\n    /**\n     * @notice returns the internal balance of a token for an account.\n     */\n    function getInternalBalance(address account, IERC20 token)\n        public\n        view\n        returns (uint256 balance)\n    {\n        balance = LibBalance.getInternalBalance(account, token);\n    }\n\n    /**\n     * @notice returns the internal balances of tokens for an account.\n     */\n    function getInternalBalances(address account, IERC20[] memory tokens)\n        external\n        view\n        returns (uint256[] memory balances)\n    {\n        balances = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; ++i) {\n            balances[i] = getInternalBalance(account, tokens[i]);\n        }\n    }\n\n    // External\n\n    /**\n     * @notice returns the external balance of a token for an account.\n     */\n    function getExternalBalance(address account, IERC20 token)\n        public\n        view\n        returns (uint256 balance)\n    {\n        balance = token.balanceOf(account);\n    }\n\n    /**\n     * @notice returns the external balances of tokens for an account.\n     */\n    function getExternalBalances(address account, IERC20[] memory tokens)\n        external\n        view\n        returns (uint256[] memory balances)\n    {\n        balances = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; ++i) {\n            balances[i] = getExternalBalance(account, tokens[i]);\n        }\n    }\n\n\n    /**\n     * @notice returns the total balance (internal and external) \n     * of a token \n     */\n    function getBalance(address account, IERC20 token)\n        public\n        view\n        returns (uint256 balance)\n    {\n        balance = LibBalance.getBalance(account, token);\n    }\n\n    /**\n     * @notice returns the total balances (internal and external) \n     * of a token for an account.\n     */\n    function getBalances(address account, IERC20[] memory tokens)\n        external\n        view\n        returns (uint256[] memory balances)\n    {\n        balances = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; ++i) {\n            balances[i] = getBalance(account, tokens[i]);\n        }\n    }\n\n    /**\n     * @notice returns the total balance (internal and external) \n     * of a token, in a balance struct (internal, external, total).\n     */\n    function getAllBalance(address account, IERC20 token)\n        public\n        view\n        returns (Balance memory b)\n    {\n        b.internalBalance = getInternalBalance(account, token);\n        b.externalBalance = getExternalBalance(account, token);\n        b.totalBalance = b.internalBalance.add(b.externalBalance);\n    }\n\n    /**\n     * @notice returns the total balance (internal and external) \n     * of a token, in a balance struct (internal, external, total).\n     */\n    function getAllBalances(address account, IERC20[] memory tokens)\n        external\n        view\n        returns (Balance[] memory balances)\n    {\n        balances = new Balance[](tokens.length);\n        for (uint256 i; i < tokens.length; ++i) {\n            balances[i] = getAllBalance(account, tokens[i]);\n        }\n    }\n}"
    }
  ]
}