{
  "Title": "[M-24] Chainlink price feed is not sufficiently validated and can return stale price",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L91-L122\n\n\n# Vulnerability details\n\n## Impact\nAs mentioned by https://docs.tigris.trade/protocol/oracle, \"Prices provided by the oracle network are also compared to Chainlink's public price feeds for additional security. If prices have more than a 2% difference the transaction is reverted.\" The Chainlink price verification logic in the following `TradingLibrary.verifyPrice` function serves this purpose. However, besides that `IPrice(_chainlinkFeed).latestAnswer()` uses Chainlink's deprecated `latestAnswer` function, this function also does not guarantee that the price returned by the Chainlink price feed is not stale. When `assetChainlinkPriceInt != 0` is `true`, it is still possible that `assetChainlinkPriceInt` is stale in which the Chainlink price verification would compare the off-chain price against a stale price returned by the Chainlink price feed. For a off-chain price that has more than a 2% difference when comparing to a more current price returned by the Chainlink price feed, this off-chain price can be incorrectly considered to have less than a 2% difference when comparing to a stale price returned by the Chainlink price feed. As a result, a trading transaction that should revert can go through, which makes the price verification much less secure.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L91-L122\n```solidity\n    function verifyPrice(\n        uint256 _validSignatureTimer,\n        uint256 _asset,\n        bool _chainlinkEnabled,\n        address _chainlinkFeed,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        mapping(address => bool) storage _isNode\n    )\n        external view\n    {\n        ...\n        if (_chainlinkEnabled && _chainlinkFeed != address(0)) {\n            int256 assetChainlinkPriceInt = IPrice(_chainlinkFeed).latestAnswer();\n            if (assetChainlinkPriceInt != 0) {\n                uint256 assetChainlinkPrice = uint256(assetChainlinkPriceInt) * 10**(18 - IPrice(_chainlinkFeed).decimals());\n                require(\n                    _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&\n                    _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, \"!chainlinkPrice\"\n                );\n            }\n        }\n    }\n```\n\nBased on https://docs.chain.link/docs/historical-price-data, the followings can be done to avoid using a stale price returned by the Chainlink price feed.\n1. The `latestRoundData` function can be used instead of the deprecated `latestAnswer` function.\n2. `roundId` and `answeredInRound` are also returned. \"You can check `answeredInRound` against the current `roundId`. If `answeredInRound` is less than `roundId`, the answer is being carried over. If `answeredInRound` is equal to `roundId`, then the answer is fresh.\"\n3. \"A read can revert if the caller is requesting the details of a round that was invalid or has not yet been answered. If you are deriving a round ID without having observed it before, the round might not be complete. To check the round, validate that the timestamp on that round is not 0.\"\n\n## Proof of Concept\nThe following steps can occur for the described scenario.\n1. Alice calls the `Trading.initiateMarketOrder` function, which eventually calls the `TradingLibrary.verifyPrice` function, to initiate a market order.\n2. When the `TradingLibrary.verifyPrice` function is called, the off-chain price is compared to the price returned by the Chainlink price feed for the position asset.\n3. The price returned by the Chainlink price feed is stale, and the off-chain price has less than a 2% difference when comparing to this stale price.\n4. Alice's `Trading.initiateMarketOrder` transaction goes through. However, this transaction should revert because the off-chain price has more than a 2% difference if comparing to a more current price returned by the Chainlink price feed.\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L113 can be updated to the following code.\n```solidity\n            (uint80 roundId, int256 assetChainlinkPriceInt, , uint256 updatedAt, uint80 answeredInRound) = IPrice(_chainlinkFeed).latestRoundData();\n            require(answeredInRound >= roundId, \"price is stale\");\n            require(updatedAt > 0, \"round is incomplete\");\n```",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-tigris-trade-contest",
  "Code": [
    {
      "filename": "contracts/utils/TradingLibrary.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../interfaces/IPosition.sol\";\n\ninterface IPrice {\n    function latestAnswer() external view returns (int256);\n    function decimals() external view returns (uint256);\n}\n\nstruct PriceData {\n    address provider;\n    uint256 asset;\n    uint256 price;\n    uint256 spread;\n    uint256 timestamp;\n    bool isClosed;\n}\n\nlibrary TradingLibrary {\n\n    using ECDSA for bytes32;\n\n    /**\n    * @notice returns position profit or loss\n    * @param _direction true if long\n    * @param _currentPrice current price\n    * @param _price opening price\n    * @param _leverage position leverage\n    * @param _margin collateral amount\n    * @param accInterest funding fees\n    * @return _positionSize position size\n    * @return _payout payout trader should get\n    */\n    function pnl(bool _direction, uint _currentPrice, uint _price, uint _margin, uint _leverage, int256 accInterest) external pure returns (uint256 _positionSize, int256 _payout) {\n        unchecked {\n            uint _initPositionSize = _margin * _leverage / 1e18;\n            if (_direction && _currentPrice >= _price) {\n                _payout = int256(_margin) + int256(_initPositionSize * (1e18 * _currentPrice / _price - 1e18)/1e18) + accInterest;\n            } else if (_direction && _currentPrice < _price) {\n                _payout = int256(_margin) - int256(_initPositionSize * (1e18 - 1e18 * _currentPrice / _price)/1e18) + accInterest;\n            } else if (!_direction && _currentPrice <= _price) {\n                _payout = int256(_margin) + int256(_initPositionSize * (1e18 - 1e18 * _currentPrice / _price)/1e18) + accInterest;\n            } else {\n                _payout = int256(_margin) - int256(_initPositionSize * (1e18 * _currentPrice / _price - 1e18)/1e18) + accInterest;\n            }\n            _positionSize = _initPositionSize * _currentPrice / _price;\n        }\n    }\n\n    /**\n    * @notice returns position liquidation price\n    * @param _direction true if long\n    * @param _tradePrice opening price\n    * @param _leverage position leverage\n    * @param _margin collateral amount\n    * @param _accInterest funding fees\n    * @param _liqPercent liquidation percent\n    * @return _liqPrice liquidation price\n    */\n    function liqPrice(bool _direction, uint _tradePrice, uint _leverage, uint _margin, int _accInterest, uint _liqPercent) public pure returns (uint256 _liqPrice) {\n        if (_direction) {\n            _liqPrice = _tradePrice - ((_tradePrice*1e18/_leverage) * uint(int(_margin)+_accInterest) / _margin) * _liqPercent / 1e10;\n        } else {\n            _liqPrice = _tradePrice + ((_tradePrice*1e18/_leverage) * uint(int(_margin)+_accInterest) / _margin) * _liqPercent / 1e10;\n        }\n    }\n\n    /**\n    * @notice uses liqPrice() and returns position liquidation price\n    * @param _positions positions contract address\n    * @param _id position id\n    * @param _liqPercent liquidation percent\n    */\n    function getLiqPrice(address _positions, uint _id, uint _liqPercent) external view returns (uint256) {\n        IPosition.Trade memory _trade = IPosition(_positions).trades(_id);\n        return liqPrice(_trade.direction, _trade.price, _trade.leverage, _trade.margin, _trade.accInterest, _liqPercent);\n    }\n\n    /**\n    * @notice verifies that price is signed by a whitelisted node\n    * @param _validSignatureTimer seconds allowed before price is old\n    * @param _asset position asset\n    * @param _chainlinkEnabled is chainlink verification is on\n    * @param _chainlinkFeed address of chainlink price feed\n    * @param _priceData PriceData object\n    * @param _signature signature returned from oracle\n    * @param _isNode mapping of allowed nodes\n    */\n    function verifyPrice(\n        uint256 _validSignatureTimer,\n        uint256 _asset,\n        bool _chainlinkEnabled,\n        address _chainlinkFeed,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        mapping(address => bool) storage _isNode\n    )\n        external view\n    {\n        address _provider = (\n            keccak256(abi.encode(_priceData))\n        ).toEthSignedMessageHash().recover(_signature);\n        require(_provider == _priceData.provider, \"BadSig\");\n        require(_isNode[_provider], \"!Node\");\n        require(_asset == _priceData.asset, \"!Asset\");\n        require(!_priceData.isClosed, \"Closed\");\n        require(block.timestamp >= _priceData.timestamp, \"FutSig\");\n        require(block.timestamp <= _priceData.timestamp + _validSignatureTimer, \"ExpSig\");\n        require(_priceData.price > 0, \"NoPrice\");\n        if (_chainlinkEnabled && _chainlinkFeed != address(0)) {\n            int256 assetChainlinkPriceInt = IPrice(_chainlinkFeed).latestAnswer();\n            if (assetChainlinkPriceInt != 0) {\n                uint256 assetChainlinkPrice = uint256(assetChainlinkPriceInt) * 10**(18 - IPrice(_chainlinkFeed).decimals());\n                require(\n                    _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&\n                    _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, \"!chainlinkPrice\"\n                );\n            }\n        }\n    }\n}"
    }
  ]
}