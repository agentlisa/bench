{
  "Title": "H-3: Swaps associated with position orders will use the wrong price",
  "Content": "# Issue H-3: Swaps associated with position orders will use the wrong price \n\nSource: https://github.com/sherlock-audit/2023-04-gmx-judging/issues/240 \n\n## Found by \nIllIllI\n## Summary\n\nSwaps of tokens gained via position orders will use the wrong price as the latest price\n\n\n## Vulnerability Detail\n\nIn the previous iteration of the code, the `getLatestPrice()` function returned the secondary price, and fell back to the primary price if the secondary price didn't exist. In the current version of the code, `getLatestPrice()` returns the custom price if one exists, which may be the trigger price or the maximized price. This price is used not only for the execution of the order, but also now for the swaps of the tokens after the order executes.\n\n\n## Impact\n\nIf, for example, the order is a market increase order, the custom price is set to the maximized price for the execution which means the liquidity taker got fewer shares than the maker gave. When those shares are swapped, that maximized price is still used, whereas if the swap had been done as a separate order, no custom price would be consulted. The two methods of doing swaps get different prices, which leads to arbitrage opportunities.\n\n\n## Code Snippet\n\nNormal swap orders never have an exact price set:\n```solidity\n// File: gmx-synthetics/contracts/order/BaseOrderUtils.sol : BaseOrderUtils.setExactOrderPrice()   #1\n\n203        function setExactOrderPrice(\n204            Oracle oracle,\n205            address indexToken,\n206            Order.OrderType orderType,\n207            uint256 triggerPrice,\n208            bool isLong\n209        ) internal {\n210            if (isSwapOrder(orderType)) {\n211 @>             return;\n212:           }\n```\nhttps://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/order/BaseOrderUtils.sol#L203-L212\n\nbut swaps after the order will use the price set [during the position-altering portion](https://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/order/BaseOrderUtils.sol#L229-L297) of the order:\n\n```solidity\n// File: gmx-synthetics/contracts/swap/SwapUtils.sol : SwapUtils._swap()   #2\n\n178        function _swap(SwapParams memory params, _SwapParams memory _params) internal returns (address, uint256) {\n179            SwapCache memory cache;\n180    \n181            if (_params.tokenIn != _params.market.longToken && _params.tokenIn != _params.market.shortToken) {\n182                revert Errors.InvalidTokenIn(_params.tokenIn, _params.market.marketToken);\n183            }\n184    \n185            MarketUtils.validateSwapMarket(_params.market);\n186    \n187            cache.tokenOut = MarketUtils.getOppositeToken(_params.tokenIn, _params.market);\n188 @>         cache.tokenInPrice = params.oracle.getLatestPrice(_params.tokenIn);\n189:@>         cache.tokenOutPrice = params.oracle.getLatestPrice(cache.tokenOut);\n```\nhttps://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/swap/SwapUtils.sol#L178-L189\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nIntroduce a flag to the `getLatestPrice()` function, indicating whether to use the custom price if it exists\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/74",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/order/BaseOrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./Order.sol\";\nimport \"../market/Market.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../order/OrderVault.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../swap/SwapHandler.sol\";\n\n// @title Order\n// @dev Library for common order functions used in OrderUtils, IncreaseOrderUtils\n// DecreaseOrderUtils, SwapOrderUtils\nlibrary BaseOrderUtils {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    // @dev CreateOrderParams struct used in createOrder to avoid stack\n    // too deep errors\n    //\n    // @param addresses address values\n    // @param numbers number values\n    // @param orderType for order.orderType\n    // @param decreasePositionSwapType for order.decreasePositionSwapType\n    // @param isLong for order.isLong\n    // @param shouldUnwrapNativeToken for order.shouldUnwrapNativeToken\n    struct CreateOrderParams {\n        CreateOrderParamsAddresses addresses;\n        CreateOrderParamsNumbers numbers;\n        Order.OrderType orderType;\n        Order.DecreasePositionSwapType decreasePositionSwapType;\n        bool isLong;\n        bool shouldUnwrapNativeToken;\n        bytes32 referralCode;\n    }\n\n    // @param receiver for order.receiver\n    // @param callbackContract for order.callbackContract\n    // @param market for order.market\n    // @param initialCollateralToken for order.initialCollateralToken\n    // @param swapPath for order.swapPath\n    struct CreateOrderParamsAddresses {\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address initialCollateralToken;\n        address[] swapPath;\n    }\n\n    // @param sizeDeltaUsd for order.sizeDeltaUsd\n    // @param triggerPrice for order.triggerPrice\n    // @param acceptablePrice for order.acceptablePrice\n    // @param executionFee for order.executionFee\n    // @param callbackGasLimit for order.callbackGasLimit\n    // @param minOutputAmount for order.minOutputAmount\n    struct CreateOrderParamsNumbers {\n        uint256 sizeDeltaUsd;\n        uint256 initialCollateralDeltaAmount;\n        uint256 triggerPrice;\n        uint256 acceptablePrice;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n        uint256 minOutputAmount;\n    }\n\n    // @dev ExecuteOrderParams struct used in executeOrder to avoid stack\n    // too deep errors\n    //\n    // @param contracts ExecuteOrderParamsContracts\n    // @param key the key of the order to execute\n    // @param order the order to execute\n    // @param swapPathMarkets the market values of the markets in the swapPath\n    // @param minOracleBlockNumbers the min oracle block numbers\n    // @param maxOracleBlockNumbers the max oracle block numbers\n    // @param market market values of the trading market\n    // @param keeper the keeper sending the transaction\n    // @param startingGas the starting gas\n    // @param positionKey the key of the order's position\n    struct ExecuteOrderParams {\n        ExecuteOrderParamsContracts contracts;\n        bytes32 key;\n        Order.Props order;\n        Market.Props[] swapPathMarkets;\n        uint256[] minOracleBlockNumbers;\n        uint256[] maxOracleBlockNumbers;\n        Market.Props market;\n        address keeper;\n        uint256 startingGas;\n        bytes32 positionKey;\n    }\n\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param oracle Oracle\n    // @param swapHandler SwapHandler\n    // @param referralStorage IReferralStorage\n    struct ExecuteOrderParamsContracts {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        OrderVault orderVault;\n        Oracle oracle;\n        SwapHandler swapHandler;\n        IReferralStorage referralStorage;\n    }\n\n    // @dev check if an orderType is a market order\n    // @param orderType the order type\n    // @return whether an orderType is a market order\n    function isMarketOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.MarketSwap ||\n               orderType == Order.OrderType.MarketIncrease ||\n               orderType == Order.OrderType.MarketDecrease ||\n               orderType == Order.OrderType.Liquidation;\n    }\n\n    // @dev check if an orderType is a limit order\n    // @param orderType the order type\n    // @return whether an orderType is a limit order\n    function isLimitOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.LimitSwap ||\n               orderType == Order.OrderType.LimitIncrease ||\n               orderType == Order.OrderType.LimitDecrease;\n    }\n\n    // @dev check if an orderType is a swap order\n    // @param orderType the order type\n    // @return whether an orderType is a swap order\n    function isSwapOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.MarketSwap ||\n               orderType == Order.OrderType.LimitSwap;\n    }\n\n    // @dev check if an orderType is a position order\n    // @param orderType the order type\n    // @return whether an orderType is a position order\n    function isPositionOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return isIncreaseOrder(orderType) || isDecreaseOrder(orderType);\n    }\n\n    // @dev check if an orderType is an increase order\n    // @param orderType the order type\n    // @return whether an orderType is an increase order\n    function isIncreaseOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.MarketIncrease ||\n               orderType == Order.OrderType.LimitIncrease;\n    }\n\n    // @dev check if an orderType is a decrease order\n    // @param orderType the order type\n    // @return whether an orderType is a decrease order\n    function isDecreaseOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.MarketDecrease ||\n               orderType == Order.OrderType.LimitDecrease ||\n               orderType == Order.OrderType.StopLossDecrease ||\n               orderType == Order.OrderType.Liquidation;\n    }\n\n    // @dev check if an orderType is a liquidation order\n    // @param orderType the order type\n    // @return whether an orderType is a liquidation order\n    function isLiquidationOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.Liquidation;\n    }\n\n    // @dev set the price for increase / decrease position orders\n    //\n    // for market orders, set the min and max values of the customPrice for the indexToken\n    // to either primaryPrice.min or primaryPrice.max depending on whether the order\n    // is an increase or decrease and whether it is for a long or short\n    //\n    // customPrice.min and customPrice.max will be equal in this case\n    // this is because in getExecutionPrice the function will try to use the closest price which can fulfill\n    // the order, if customPrice.min is set to primaryPrice.min and customPrice.max is set to primaryPrice.max\n    // getExecutionPrice will pick a better price than what should be possible\n    //\n    // for limit orders, the the min and max value will be set to the triggerPrice\n    // and primaryPrice value, this represents the price that the user desired the order\n    // to be fulfilled at and the best oracle price that the order can be fulfilled at\n    //\n    // for stop-loss orders, the min and max value will be set to the triggerPrice value\n    // the primaryPrice and secondaryPrice are not used because the primaryPrice is a stale\n    // value and cannot be used as it would result in executing at a better price than what\n    // should be possible, the secondaryPrice is a worse price than the triggerPrice, so\n    // it should not need to be considered\n    //\n    // getExecutionPrice handles the logic for selecting the execution price to use\n    //\n    // @param oracle Oracle\n    // @param indexToken the index token\n    // @param orderType the order type\n    // @param triggerPrice the order's triggerPrice\n    // @param isLong whether the order is for a long or short\n    function setExactOrderPrice(\n        Oracle oracle,\n        address indexToken,\n        Order.OrderType orderType,\n        uint256 triggerPrice,\n        bool isLong\n    ) internal {\n        if (isSwapOrder(orderType)) {\n            return;\n        }\n\n        bool isIncrease = isIncreaseOrder(orderType);\n        // increase order:\n        //     - long: use the larger price\n        //     - short: use the smaller price\n        // decrease order:\n        //     - long: use the smaller price\n        //     - short: use the larger price\n        bool shouldUseMaxPrice = isIncrease ? isLong : !isLong;\n\n        if (orderType == Order.OrderType.MarketIncrease ||\n            orderType == Order.OrderType.MarketDecrease ||\n            orderType == Order.OrderType.Liquidation) {\n\n            Price.Props memory price = oracle.getPrimaryPrice(indexToken);\n\n            oracle.setCustomPrice(indexToken, Price.Props(\n                price.pickPrice(shouldUseMaxPrice),\n                price.pickPrice(shouldUseMaxPrice)\n            ));\n\n            return;\n        }\n\n        if (orderType == Order.OrderType.LimitIncrease ||\n            orderType == Order.OrderType.LimitDecrease\n        ) {\n            uint256 primaryPrice = oracle.getPrimaryPrice(indexToken).pickPrice(shouldUseMaxPrice);\n\n            // for limit increase orders:\n            //      - long: validate primaryPrice < triggerPrice\n            //      - short: validate primaryPrice > triggerPrice\n            // for limit decrease orders:\n            //      - long: validate primaryPrice > triggerPrice\n            //      - short: validate primaryPrice < triggerPrice\n            bool shouldValidateSmallerPrimaryPrice = shouldUseMaxPrice;\n\n            bool ok = shouldValidateSmallerPrimaryPrice ? primaryPrice <= triggerPrice : primaryPrice >= triggerPrice;\n\n            if (!ok) {\n                revert Errors.InvalidLimitOrderPrices(primaryPrice, triggerPrice, shouldValidateSmallerPrimaryPrice);\n            }\n\n            if (shouldValidateSmallerPrimaryPrice) {\n                oracle.setCustomPrice(indexToken, Price.Props(\n                    primaryPrice, // min price that order can be executed with\n                    triggerPrice // max price that order can be executed with\n                ));\n            } else {\n                oracle.setCustomPrice(indexToken, Price.Props(\n                    triggerPrice, // min price that order can be executed with\n                    primaryPrice // max price that order can be executed with\n                ));\n            }\n\n            return;\n        }\n\n        if (orderType == Order.OrderType.StopLossDecrease) {\n            uint256 primaryPrice = oracle.getPrimaryPrice(indexToken).pickPrice(shouldUseMaxPrice);\n            uint256 secondaryPrice = oracle.getSecondaryPrice(indexToken).pickPrice(shouldUseMaxPrice);\n\n            // for stop-loss decrease orders:\n            //     - long: validate descending price\n            //     - short: validate ascending price\n            bool shouldValidateAscendingPrice = !isLong;\n\n            bool ok = shouldValidateAscendingPrice ?\n                (primaryPrice <= triggerPrice && triggerPrice <= secondaryPrice) :\n                (primaryPrice >= triggerPrice && triggerPrice >= secondaryPrice);\n\n            if (!ok) {\n                revert Errors.InvalidStopLossOrderPrices(primaryPrice, secondaryPrice, triggerPrice, shouldValidateAscendingPrice);\n            }\n\n            if (shouldValidateAscendingPrice) {\n                oracle.setCustomPrice(indexToken, Price.Props(\n                    triggerPrice, // min price that order can be executed with\n                    triggerPrice // max price that order can be executed with\n                ));\n            } else {\n                oracle.setCustomPrice(indexToken, Price.Props(\n                    triggerPrice, // min price that order can be executed with\n                    triggerPrice // max price that order can be executed with\n                ));\n            }\n\n            return;\n        }\n\n        revert Errors.UnsupportedOrderType();\n    }\n\n    // @dev get the execution price for an order\n    //\n    // see setExactOrderPrice for information on the customPrice values\n    //\n    // for limit / stop-loss orders, the triggerPrice is returned here if it can\n    // fulfill the acceptablePrice after factoring in price impact\n    //\n    // if the triggerPrice cannot fulfill the acceptablePrice, check if the acceptablePrice\n    // can be fulfilled using the best oracle price after factoring in price impact\n    // if it can be fulfilled, fulfill the order at the acceptablePrice\n    //\n    // @param customIndexTokenPrice the custom price of the index token\n    // @param sizeDeltaUsd the order.sizeDeltaUsd\n    // @param priceImpactUsd the price impact of the order\n    // @param acceptablePrice the order.acceptablePrice\n    // @param isLong whether this is for a long or short order\n    // @param isIncrease whether this is for an increase or decrease order\n    // @return the execution price\n    function getExecutionPrice(\n        Price.Props memory customIndexTokenPrice,\n        uint256 sizeDeltaUsd,\n        int256 priceImpactUsd,\n        uint256 acceptablePrice,\n        bool isLong,\n        bool isIncrease\n    ) internal pure returns (uint256) {\n        // increase order:\n        //     - long: use the larger price\n        //     - short: use the smaller price\n        // decrease order:\n        //     - long: use the smaller price\n        //     - short: use the larger price\n        bool shouldUseMaxPrice = isIncrease ? isLong : !isLong;\n\n        // should price be smaller than acceptablePrice\n        // increase order:\n        //     - long: price should be smaller than acceptablePrice\n        //     - short: price should be larger than acceptablePrice\n        // decrease order:\n        //     - long: price should be larger than acceptablePrice\n        //     - short: price should be smaller than acceptablePrice\n        bool shouldPriceBeSmaller = isIncrease ? isLong : !isLong;\n\n        // for market orders, customIndexTokenPrice.min and customIndexTokenPrice.max should\n        // be equal, see setExactOrderPrice for more info\n        // for limit orders, customIndexTokenPrice contains the triggerPrice and the best oracle\n        // price, we first attempt to fulfill the order using the triggerPrice\n        uint256 price = customIndexTokenPrice.pickPrice(shouldUseMaxPrice);\n\n        // increase order:\n        //     - long: lower price for positive impact, higher price for negative impact\n        //     - short: higher price for positive impact, lower price for negative impact\n        // decrease order:\n        //     - long: higher price for positive impact, lower price for negative impact\n        //     - short: lower price for positive impact, higher price for negative impact\n        bool shouldFlipPriceImpactUsd = isIncrease ? isLong : !isLong;\n        int256 priceImpactUsdForPriceAdjustment = shouldFlipPriceImpactUsd ? -priceImpactUsd : priceImpactUsd;\n\n        if (priceImpactUsdForPriceAdjustment < 0 && (-priceImpactUsdForPriceAdjustment).toUint256() > sizeDeltaUsd) {\n            revert Errors.PriceImpactLargerThanOrderSize(priceImpactUsdForPriceAdjustment, sizeDeltaUsd);\n        }\n\n        // adjust price by price impact\n        if (sizeDeltaUsd > 0) {\n            price = price * Calc.sumReturnUint256(sizeDeltaUsd, priceImpactUsdForPriceAdjustment) / sizeDeltaUsd;\n        }\n\n        if (shouldPriceBeSmaller && price <= acceptablePrice) {\n            return price;\n        }\n\n        if (!shouldPriceBeSmaller && price >= acceptablePrice) {\n            return price;\n        }\n\n        // if the order could not be fulfilled using the triggerPrice\n        // check if the best oracle price can fulfill the order\n        price = customIndexTokenPrice.pickPrice(!shouldUseMaxPrice);\n\n        // adjust price by price impact\n        if (sizeDeltaUsd > 0) {\n            price = price * Calc.sumReturnUint256(sizeDeltaUsd, priceImpactUsdForPriceAdjustment) / sizeDeltaUsd;\n        }\n\n        if (shouldPriceBeSmaller && price <= acceptablePrice) {\n            return acceptablePrice;\n        }\n\n        if (!shouldPriceBeSmaller && price >= acceptablePrice) {\n            return acceptablePrice;\n        }\n\n        // the setExactOrderPrice function should have validated if the price fulfills\n        // the order's trigger price\n        //\n        // for decrease orders, the price impact should already be capped, so if the user\n        // had set an acceptable price within the range of the capped price impact, then\n        // the order should be fulfillable at the acceptable price\n        //\n        // for increase orders, the negative price impact is not capped\n        //\n        // for both increase and decrease orders, if it is due to price impact that the\n        // order cannot be fulfilled then the order should be frozen\n        //\n        // this is to prevent gaming by manipulation of the price impact value\n        //\n        // usually it should be costly to game the price impact value\n        // however, for certain cases, e.g. a user already has a large position opened\n        // the user may create limit orders that would only trigger after they close\n        // their position, this gives the user the option to cancel the pending order if\n        // prices do not move in their favour or to close their position and let the order\n        // execute if prices move in their favour\n        revert Errors.OrderNotFulfillableDueToPriceImpact(price, acceptablePrice);\n    }\n\n    // @dev validate that an order exists\n    // @param order the order to check\n    function validateNonEmptyOrder(Order.Props memory order) internal pure {\n        if (order.account() == address(0)) {\n            revert Errors.EmptyOrder();\n        }\n\n        if (order.sizeDeltaUsd() == 0 && order.initialCollateralDeltaAmount() == 0) {\n            revert Errors.EmptyOrder();\n        }\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/order/BaseOrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./Order.sol\";\nimport \"../market/Market.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../order/OrderVault.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../swap/SwapHandler.sol\";\n\n// @title Order\n// @dev Library for common order functions used in OrderUtils, IncreaseOrderUtils\n// DecreaseOrderUtils, SwapOrderUtils\nlibrary BaseOrderUtils {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    // @dev CreateOrderParams struct used in createOrder to avoid stack\n    // too deep errors\n    //\n    // @param addresses address values\n    // @param numbers number values\n    // @param orderType for order.orderType\n    // @param decreasePositionSwapType for order.decreasePositionSwapType\n    // @param isLong for order.isLong\n    // @param shouldUnwrapNativeToken for order.shouldUnwrapNativeToken\n    struct CreateOrderParams {\n        CreateOrderParamsAddresses addresses;\n        CreateOrderParamsNumbers numbers;\n        Order.OrderType orderType;\n        Order.DecreasePositionSwapType decreasePositionSwapType;\n        bool isLong;\n        bool shouldUnwrapNativeToken;\n        bytes32 referralCode;\n    }\n\n    // @param receiver for order.receiver\n    // @param callbackContract for order.callbackContract\n    // @param market for order.market\n    // @param initialCollateralToken for order.initialCollateralToken\n    // @param swapPath for order.swapPath\n    struct CreateOrderParamsAddresses {\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address initialCollateralToken;\n        address[] swapPath;\n    }\n\n    // @param sizeDeltaUsd for order.sizeDeltaUsd\n    // @param triggerPrice for order.triggerPrice\n    // @param acceptablePrice for order.acceptablePrice\n    // @param executionFee for order.executionFee\n    // @param callbackGasLimit for order.callbackGasLimit\n    // @param minOutputAmount for order.minOutputAmount\n    struct CreateOrderParamsNumbers {\n        uint256 sizeDeltaUsd;\n        uint256 initialCollateralDeltaAmount;\n        uint256 triggerPrice;\n        uint256 acceptablePrice;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n        uint256 minOutputAmount;\n    }\n\n    // @dev ExecuteOrderParams struct used in executeOrder to avoid stack\n    // too deep errors\n    //\n    // @param contracts ExecuteOrderParamsContracts\n    // @param key the key of the order to execute\n    // @param order the order to execute\n    // @param swapPathMarkets the market values of the markets in the swapPath\n    // @param minOracleBlockNumbers the min oracle block numbers\n    // @param maxOracleBlockNumbers the max oracle block numbers\n    // @param market market values of the trading market\n    // @param keeper the keeper sending the transaction\n    // @param startingGas the starting gas\n    // @param positionKey the key of the order's position\n    struct ExecuteOrderParams {\n        ExecuteOrderParamsContracts contracts;\n        bytes32 key;\n        Order.Props order;\n        Market.Props[] swapPathMarkets;\n        uint256[] minOracleBlockNumbers;\n        uint256[] maxOracleBlockNumbers;\n        Market.Props market;\n        address keeper;\n        uint256 startingGas;\n        bytes32 positionKey;\n    }\n\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param orderVault OrderVault\n    // @param oracle Oracle\n    // @param swapHandler SwapHandler\n    // @param referralStorage IReferralStorage\n    struct ExecuteOrderParamsContracts {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        OrderVault orderVault;\n        Oracle oracle;\n        SwapHandler swapHandler;\n        IReferralStorage referralStorage;\n    }\n\n    // @dev check if an orderType is a market order\n    // @param orderType the order type\n    // @return whether an orderType is a market order\n    function isMarketOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.MarketSwap ||\n               orderType == Order.OrderType.MarketIncrease ||\n               orderType == Order.OrderType.MarketDecrease ||\n               orderType == Order.OrderType.Liquidation;\n    }\n\n    // @dev check if an orderType is a limit order\n    // @param orderType the order type\n    // @return whether an orderType is a limit order\n    function isLimitOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.LimitSwap ||\n               orderType == Order.OrderType.LimitIncrease ||\n               orderType == Order.OrderType.LimitDecrease;\n    }\n\n    // @dev check if an orderType is a swap order\n    // @param orderType the order type\n    // @return whether an orderType is a swap order\n    function isSwapOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.MarketSwap ||\n               orderType == Order.OrderType.LimitSwap;\n    }\n\n    // @dev check if an orderType is a position order\n    // @param orderType the order type\n    // @return whether an orderType is a position order\n    function isPositionOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return isIncreaseOrder(orderType) || isDecreaseOrder(orderType);\n    }\n\n    // @dev check if an orderType is an increase order\n    // @param orderType the order type\n    // @return whether an orderType is an increase order\n    function isIncreaseOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.MarketIncrease ||\n               orderType == Order.OrderType.LimitIncrease;\n    }\n\n    // @dev check if an orderType is a decrease order\n    // @param orderType the order type\n    // @return whether an orderType is a decrease order\n    function isDecreaseOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.MarketDecrease ||\n               orderType == Order.OrderType.LimitDecrease ||\n               orderType == Order.OrderType.StopLossDecrease ||\n               orderType == Order.OrderType.Liquidation;\n    }\n\n    // @dev check if an orderType is a liquidation order\n    // @param orderType the order type\n    // @return whether an orderType is a liquidation order\n    function isLiquidationOrder(Order.OrderType orderType) internal pure returns (bool) {\n        return orderType == Order.OrderType.Liquidation;\n    }\n\n    // @dev set the price for increase / decrease position orders\n    //\n    // for market orders, set the min and max values of the customPrice for the indexToken\n    // to either primaryPrice.min or primaryPrice.max depending on whether the order\n    // is an increase or decrease and whether it is for a long or short\n    //\n    // customPrice.min and customPrice.max will be equal in this case\n    // this is because in getExecutionPrice the function will try to use the closest price which can fulfill\n    // the order, if customPrice.min is set to primaryPrice.min and customPrice.max is set to primaryPrice.max\n    // getExecutionPrice will pick a better price than what should be possible\n    //\n    // for limit orders, the the min and max value will be set to the triggerPrice\n    // and primaryPrice value, this represents the price that the user desired the order\n    // to be fulfilled at and the best oracle price that the order can be fulfilled at\n    //\n    // for stop-loss orders, the min and max value will be set to the triggerPrice value\n    // the primaryPrice and secondaryPrice are not used because the primaryPrice is a stale\n    // value and cannot be used as it would result in executing at a better price than what\n    // should be possible, the secondaryPrice is a worse price than the triggerPrice, so\n    // it should not need to be considered\n    //\n    // getExecutionPrice handles the logic for selecting the execution price to use\n    //\n    // @param oracle Oracle\n    // @param indexToken the index token\n    // @param orderType the order type\n    // @param triggerPrice the order's triggerPrice\n    // @param isLong whether the order is for a long or short\n    function setExactOrderPrice(\n        Oracle oracle,\n        address indexToken,\n        Order.OrderType orderType,\n        uint256 triggerPrice,\n        bool isLong\n    ) internal {\n        if (isSwapOrder(orderType)) {\n            return;\n        }\n\n        bool isIncrease = isIncreaseOrder(orderType);\n        // increase order:\n        //     - long: use the larger price\n        //     - short: use the smaller price\n        // decrease order:\n        //     - long: use the smaller price\n        //     - short: use the larger price\n        bool shouldUseMaxPrice = isIncrease ? isLong : !isLong;\n\n        if (orderType == Order.OrderType.MarketIncrease ||\n            orderType == Order.OrderType.MarketDecrease ||\n            orderType == Order.OrderType.Liquidation) {\n\n            Price.Props memory price = oracle.getPrimaryPrice(indexToken);\n\n            oracle.setCustomPrice(indexToken, Price.Props(\n                price.pickPrice(shouldUseMaxPrice),\n                price.pickPrice(shouldUseMaxPrice)\n            ));\n\n            return;\n        }\n\n        if (orderType == Order.OrderType.LimitIncrease ||\n            orderType == Order.OrderType.LimitDecrease\n        ) {\n            uint256 primaryPrice = oracle.getPrimaryPrice(indexToken).pickPrice(shouldUseMaxPrice);\n\n            // for limit increase orders:\n            //      - long: validate primaryPrice < triggerPrice\n            //      - short: validate primaryPrice > triggerPrice\n            // for limit decrease orders:\n            //      - long: validate primaryPrice > triggerPrice\n            //      - short: validate primaryPrice < triggerPrice\n            bool shouldValidateSmallerPrimaryPrice = shouldUseMaxPrice;\n\n            bool ok = shouldValidateSmallerPrimaryPrice ? primaryPrice <= triggerPrice : primaryPrice >= triggerPrice;\n\n            if (!ok) {\n                revert Errors.InvalidLimitOrderPrices(primaryPrice, triggerPrice, shouldValidateSmallerPrimaryPrice);\n            }\n\n            if (shouldValidateSmallerPrimaryPrice) {\n                oracle.setCustomPrice(indexToken, Price.Props(\n                    primaryPrice, // min price that order can be executed with\n                    triggerPrice // max price that order can be executed with\n                ));\n            } else {\n                oracle.setCustomPrice(indexToken, Price.Props(\n                    triggerPrice, // min price that order can be executed with\n                    primaryPrice // max price that order can be executed with\n                ));\n            }\n\n            return;\n        }\n\n        if (orderType == Order.OrderType.StopLossDecrease) {\n            uint256 primaryPrice = oracle.getPrimaryPrice(indexToken).pickPrice(shouldUseMaxPrice);\n            uint256 secondaryPrice = oracle.getSecondaryPrice(indexToken).pickPrice(shouldUseMaxPrice);\n\n            // for stop-loss decrease orders:\n            //     - long: validate descending price\n            //     - short: validate ascending price\n            bool shouldValidateAscendingPrice = !isLong;\n\n            bool ok = shouldValidateAscendingPrice ?\n                (primaryPrice <= triggerPrice && triggerPrice <= secondaryPrice) :\n                (primaryPrice >= triggerPrice && triggerPrice >= secondaryPrice);\n\n            if (!ok) {\n                revert Errors.InvalidStopLossOrderPrices(primaryPrice, secondaryPrice, triggerPrice, shouldValidateAscendingPrice);\n            }\n\n            if (shouldValidateAscendingPrice) {\n                oracle.setCustomPrice(indexToken, Price.Props(\n                    triggerPrice, // min price that order can be executed with\n                    triggerPrice // max price that order can be executed with\n                ));\n            } else {\n                oracle.setCustomPrice(indexToken, Price.Props(\n                    triggerPrice, // min price that order can be executed with\n                    triggerPrice // max price that order can be executed with\n                ));\n            }\n\n            return;\n        }\n\n        revert Errors.UnsupportedOrderType();\n    }\n\n    // @dev get the execution price for an order\n    //\n    // see setExactOrderPrice for information on the customPrice values\n    //\n    // for limit / stop-loss orders, the triggerPrice is returned here if it can\n    // fulfill the acceptablePrice after factoring in price impact\n    //\n    // if the triggerPrice cannot fulfill the acceptablePrice, check if the acceptablePrice\n    // can be fulfilled using the best oracle price after factoring in price impact\n    // if it can be fulfilled, fulfill the order at the acceptablePrice\n    //\n    // @param customIndexTokenPrice the custom price of the index token\n    // @param sizeDeltaUsd the order.sizeDeltaUsd\n    // @param priceImpactUsd the price impact of the order\n    // @param acceptablePrice the order.acceptablePrice\n    // @param isLong whether this is for a long or short order\n    // @param isIncrease whether this is for an increase or decrease order\n    // @return the execution price\n    function getExecutionPrice(\n        Price.Props memory customIndexTokenPrice,\n        uint256 sizeDeltaUsd,\n        int256 priceImpactUsd,\n        uint256 acceptablePrice,\n        bool isLong,\n        bool isIncrease\n    ) internal pure returns (uint256) {\n        // increase order:\n        //     - long: use the larger price\n        //     - short: use the smaller price\n        // decrease order:\n        //     - long: use the smaller price\n        //     - short: use the larger price\n        bool shouldUseMaxPrice = isIncrease ? isLong : !isLong;\n\n        // should price be smaller than acceptablePrice\n        // increase order:\n        //     - long: price should be smaller than acceptablePrice\n        //     - short: price should be larger than acceptablePrice\n        // decrease order:\n        //     - long: price should be larger than acceptablePrice\n        //     - short: price should be smaller than acceptablePrice\n        bool shouldPriceBeSmaller = isIncrease ? isLong : !isL"
    }
  ]
}