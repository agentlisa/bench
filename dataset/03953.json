{
  "Title": "[M05] Missing counter addition",
  "Content": "In the [`Attestations` contract](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L22), the [`addIncompleteAttestations` function](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L557) creates a [`currentIndex` variable](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L567) before entering a [`while` condition](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L571-L594).\n\n\nIf the [random validator](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L573) has already been selected as an issuer for a specific request, then the [`attestation.status` will be different from `AttestationStatus.None`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L578) and the `while` loop will restart, attempting to find new random validators until the transaction either runs out of gas or the `currentIndex` variable reaches the value of `unselectedRequest.attestationsRequested`.\n\n\nThe while loop condition will always be `true` if the [`attestationsRequested` parameter of the `request`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L147) is bigger than the current amount of validators.\n\n\nThere is a specific attack vector that can trigger this behavior: An attacker uses the [`Escrow` contract](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Escrow.sol#L14) to generate a [`transfer`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Escrow.sol#L84) for a victim with the [`minAttestations` parameterâ€™s value](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Escrow.sol#L90) higher than the current amount of validators. With the intention of [generating the minimum amount of attestations to withdraw the money](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Escrow.sol#L143-L145), the victim will make use of the `Attestations` contract to generate a `request` with the `attestationsRequested` parameter equal to the number of `minAttestations` used by the attacker. Finally, when the victim executes the `selectIssuers` function with the corresponding `identifier`, the transaction will fail with an `out of gas` error.\n\n\nConsider picking validators, [which is now done via the `seed` variable](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L572-L573), from a list of unselected validators, which can only include validators that have not already provided an attestation. Additionally, consider including a check either in `transfer` or `selectIssuers` that requires that the number of attestations does not exceed the total number of validators. Alternatively, consider modifying the `currentIndex` variable, or some other variable inside the `if` condition in such a way that the `while` loop can eventually finish its execution. If the latter is chosen, consider the effects of successfully finishing execution of `addIncompleteAttestations`, such as [the deletion of the relevant request afterwards](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Escrow.sol#L208).\n\n\n***Update:** Fixed in [pull request #2794](https://github.com/celo-org/celo-monorepo/pull/2794). Now there is a [maximum number of attestations](https://github.com/celo-org/celo-monorepo/pull/2794/files#diff-5b60f2c28dcff7d02c33de98742f3f6dR180), there is a new [check to require that the number of attestations does not exceed the number of issuers](https://github.com/celo-org/celo-monorepo/pull/2794/files#diff-5b60f2c28dcff7d02c33de98742f3f6dR609), and the [list of issuers is reduced after every iteration](https://github.com/celo-org/celo-monorepo/pull/2794/files#diff-5b60f2c28dcff7d02c33de98742f3f6dR644-R645).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/identity/Attestations.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAttestations.sol\";\nimport \"./interfaces/IRandom.sol\";\nimport \"../common/interfaces/IERC20Token.sol\";\nimport \"../common/interfaces/IAccounts.sol\";\nimport \"../governance/interfaces/IValidators.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/SafeCast.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\n/**\n * @title Contract mapping identifiers to accounts\n */\ncontract Attestations is\n  IAttestations,\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  ReentrancyGuard,\n  UsingPrecompiles\n{\n  using SafeMath for uint256;\n  using SafeCast for uint256;\n\n  enum AttestationStatus { None, Incomplete, Complete }\n\n  struct Attestation {\n    AttestationStatus status;\n    // For outstanding attestations, this is the block number of the request.\n    // For completed attestations, this is the block number of the attestation completion.\n    uint32 blockNumber;\n    // The token with which attestation request fees were paid.\n    address attestationRequestFeeToken;\n  }\n\n  // Stores attestations state for a single (identifier, account address) pair.\n  struct AttestedAddress {\n    // Total number of requested attestations.\n    uint32 requested;\n    // Total number of completed attestations.\n    uint32 completed;\n    // List of selected issuers responsible for attestations. The length of this list\n    // might be smaller than `requested` (which represents the total number of requested\n    // attestations) if users are not calling `selectIssuers` on unselected requests.\n    address[] selectedIssuers;\n    // State of each attestation keyed by issuer.\n    mapping(address => Attestation) issuedAttestations;\n  }\n\n  struct UnselectedRequest {\n    // The block at which the attestations were requested.\n    uint32 blockNumber;\n    // The number of attestations that were requested.\n    uint32 attestationsRequested;\n    // The token with which attestation request fees were paid in this request.\n    address attestationRequestFeeToken;\n  }\n\n  struct IdentifierState {\n    // All account addresses associated with this identifier.\n    address[] accounts;\n    // Keeps the state of attestations for account addresses for this identifier.\n    mapping(address => AttestedAddress) attestations;\n    // Temporarily stores attestation requests for which issuers should be selected by the account.\n    mapping(address => UnselectedRequest) unselectedRequests;\n  }\n\n  mapping(bytes32 => IdentifierState) identifiers;\n\n  // The duration in blocks in which an attestation can be completed from the block in which the\n  // attestation was requested.\n  uint256 public attestationExpiryBlocks;\n\n  // The duration to wait until selectIssuers can be called for an attestation request.\n  uint256 public selectIssuersWaitBlocks;\n\n  // The fees that are associated with attestations for a particular token.\n  mapping(address => uint256) public attestationRequestFees;\n\n  // Maps a token and attestation issuer to the amount that they're owed.\n  mapping(address => mapping(address => uint256)) public pendingWithdrawals;\n\n  event AttestationsRequested(\n    bytes32 indexed identifier,\n    address indexed account,\n    uint256 attestationsRequested,\n    address attestationRequestFeeToken\n  );\n\n  event AttestationIssuerSelected(\n    bytes32 indexed identifier,\n    address indexed account,\n    address indexed issuer,\n    address attestationRequestFeeToken\n  );\n\n  event AttestationCompleted(\n    bytes32 indexed identifier,\n    address indexed account,\n    address indexed issuer\n  );\n\n  event Withdrawal(address indexed account, address indexed token, uint256 amount);\n  event AttestationExpiryBlocksSet(uint256 value);\n  event AttestationRequestFeeSet(address indexed token, uint256 value);\n  event SelectIssuersWaitBlocksSet(uint256 value);\n\n  function initialize(\n    address registryAddress,\n    uint256 _attestationExpiryBlocks,\n    uint256 _selectIssuersWaitBlocks,\n    address[] calldata attestationRequestFeeTokens,\n    uint256[] calldata attestationRequestFeeValues\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setAttestationExpiryBlocks(_attestationExpiryBlocks);\n    setSelectIssuersWaitBlocks(_selectIssuersWaitBlocks);\n\n    require(\n      attestationRequestFeeTokens.length > 0 &&\n        attestationRequestFeeTokens.length == attestationRequestFeeValues.length,\n      \"attestationRequestFeeTokens specification was invalid\"\n    );\n    for (uint256 i = 0; i < attestationRequestFeeTokens.length; i = i.add(1)) {\n      setAttestationRequestFee(attestationRequestFeeTokens[i], attestationRequestFeeValues[i]);\n    }\n  }\n\n  /**\n   * @notice Commit to the attestation request of a hashed identifier.\n   * @param identifier The hash of the identifier to be attested.\n   * @param attestationsRequested The number of requested attestations for this request.\n   * @param attestationRequestFeeToken The address of the token with which the attestation fee will\n   * be paid.\n   */\n  function request(\n    bytes32 identifier,\n    uint256 attestationsRequested,\n    address attestationRequestFeeToken\n  ) external nonReentrant {\n    require(\n      attestationRequestFees[attestationRequestFeeToken] > 0,\n      \"Invalid attestationRequestFeeToken\"\n    );\n    require(\n      IERC20Token(attestationRequestFeeToken).transferFrom(\n        msg.sender,\n        address(this),\n        attestationRequestFees[attestationRequestFeeToken].mul(attestationsRequested)\n      ),\n      \"Transfer of attestation request fees failed\"\n    );\n\n    require(attestationsRequested > 0, \"You have to request at least 1 attestation\");\n\n    IdentifierState storage state = identifiers[identifier];\n\n    require(\n      state.unselectedRequests[msg.sender].blockNumber == 0 ||\n        isAttestationExpired(state.unselectedRequests[msg.sender].blockNumber) ||\n        !isAttestationRequestSelectable(state.unselectedRequests[msg.sender].blockNumber),\n      \"There exists an unexpired, unselected attestation request\"\n    );\n\n    state.unselectedRequests[msg.sender].blockNumber = block.number.toUint32();\n    state.unselectedRequests[msg.sender].attestationsRequested = attestationsRequested.toUint32();\n    state.unselectedRequests[msg.sender].attestationRequestFeeToken = attestationRequestFeeToken;\n\n    state.attestations[msg.sender].requested = uint256(state.attestations[msg.sender].requested)\n      .add(attestationsRequested)\n      .toUint32();\n\n    emit AttestationsRequested(\n      identifier,\n      msg.sender,\n      attestationsRequested,\n      attestationRequestFeeToken\n    );\n  }\n\n  /**\n   * @notice Selects the issuers for the most recent attestation request.\n   * @param identifier The hash of the identifier to be attested.\n   */\n  function selectIssuers(bytes32 identifier) external {\n    IdentifierState storage state = identifiers[identifier];\n\n    require(\n      state.unselectedRequests[msg.sender].blockNumber > 0,\n      \"No unselected attestation request to select issuers for\"\n    );\n\n    require(\n      !isAttestationExpired(state.unselectedRequests[msg.sender].blockNumber),\n      \"The attestation request has expired\"\n    );\n\n    addIncompleteAttestations(identifier);\n    delete state.unselectedRequests[msg.sender];\n  }\n\n  /**\n   * @notice Submit the secret message sent by the issuer to complete the attestation request.\n   * @param identifier The hash of the identifier for this attestation.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Throws if there is no matching outstanding attestation request.\n   * @dev Throws if the attestation window has passed.\n   */\n  function complete(bytes32 identifier, uint8 v, bytes32 r, bytes32 s) external {\n    address issuer = validateAttestationCode(identifier, msg.sender, v, r, s);\n\n    Attestation storage attestation = identifiers[identifier].attestations[msg.sender]\n      .issuedAttestations[issuer];\n\n    address token = attestation.attestationRequestFeeToken;\n\n    // solhint-disable-next-line not-rely-on-time\n    attestation.blockNumber = block.number.toUint32();\n    attestation.status = AttestationStatus.Complete;\n    delete attestation.attestationRequestFeeToken;\n    identifiers[identifier].attestations[msg.sender].completed++;\n\n    pendingWithdrawals[token][issuer] = pendingWithdrawals[token][issuer].add(\n      attestationRequestFees[token]\n    );\n\n    IdentifierState storage state = identifiers[identifier];\n    if (identifiers[identifier].attestations[msg.sender].completed == 1) {\n      state.accounts.push(msg.sender);\n    }\n\n    emit AttestationCompleted(identifier, msg.sender, issuer);\n  }\n\n  /**\n   * @notice Revokes an account for an identifier.\n   * @param identifier The identifier for which to revoke.\n   * @param index The index of the account in the accounts array.\n   */\n  function revoke(bytes32 identifier, uint256 index) external {\n    uint256 numAccounts = identifiers[identifier].accounts.length;\n    require(index < numAccounts, \"Index is invalid\");\n    require(\n      msg.sender == identifiers[identifier].accounts[index],\n      \"Index does not match msg.sender\"\n    );\n\n    uint256 newNumAccounts = numAccounts.sub(1);\n    if (index != newNumAccounts) {\n      identifiers[identifier].accounts[index] = identifiers[identifier].accounts[newNumAccounts];\n    }\n    identifiers[identifier].accounts[newNumAccounts] = address(0x0);\n    identifiers[identifier].accounts.length--;\n  }\n\n  /**\n   * @notice Allows issuers to withdraw accumulated attestation rewards.\n   * @param token The address of the token that will be withdrawn.\n   * @dev Throws if msg.sender does not have any rewards to withdraw.\n   */\n  function withdraw(address token) external {\n    uint256 value = pendingWithdrawals[token][msg.sender];\n    require(value > 0, \"value was negative/zero\");\n    pendingWithdrawals[token][msg.sender] = 0;\n    require(IERC20Token(token).transfer(msg.sender, value), \"token transfer failed\");\n    emit Withdrawal(msg.sender, token, value);\n  }\n\n  /**\n   * @notice Returns the unselected attestation request for an identifier/account pair, if any.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @return [\n   *           Block number at which was requested,\n   *           Number of unselected requests,\n   *           Address of the token with which this attestation request was paid for\n   *         ]\n   */\n  function getUnselectedRequest(bytes32 identifier, address account)\n    external\n    view\n    returns (uint32, uint32, address)\n  {\n    return (\n      identifiers[identifier].unselectedRequests[account].blockNumber,\n      identifiers[identifier].unselectedRequests[account].attestationsRequested,\n      identifiers[identifier].unselectedRequests[account].attestationRequestFeeToken\n    );\n  }\n\n  /**\n   * @notice Returns selected attestation issuers for a identifier/account pair.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @return Addresses of the selected attestation issuers.\n   */\n  function getAttestationIssuers(bytes32 identifier, address account)\n    external\n    view\n    returns (address[] memory)\n  {\n    return identifiers[identifier].attestations[account].selectedIssuers;\n  }\n\n  /**\n   * @notice Returns attestation stats for a identifier/account pair.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @return [Number of completed attestations, Number of total requested attestations]\n   */\n  function getAttestationStats(bytes32 identifier, address account)\n    external\n    view\n    returns (uint32, uint32)\n  {\n    return (\n      identifiers[identifier].attestations[account].completed,\n      identifiers[identifier].attestations[account].requested\n    );\n  }\n\n  /**\n   * @notice Batch lookup function to determine attestation stats for a list of identifiers.\n   * @param identifiersToLookup Array of n identifiers.\n   * @return [0] Array of number of matching accounts per identifier.\n   * @return [1] Array of sum([0]) matching walletAddresses.\n   * @return [2] Array of sum([0]) numbers indicating the completions for each account.\n   * @return [3] Array of sum([0]) numbers indicating the total number of requested\n                 attestations for each account.\n   */\n  function batchGetAttestationStats(bytes32[] calldata identifiersToLookup)\n    external\n    view\n    returns (uint256[] memory, address[] memory, uint64[] memory, uint64[] memory)\n  {\n    require(identifiersToLookup.length > 0, \"You have to pass at least one identifier\");\n\n    uint256[] memory matches;\n    address[] memory addresses;\n\n    (matches, addresses) = batchlookupAccountsForIdentifier(identifiersToLookup);\n\n    uint64[] memory completed = new uint64[](addresses.length);\n    uint64[] memory total = new uint64[](addresses.length);\n\n    uint256 currentIndex = 0;\n    for (uint256 i = 0; i < identifiersToLookup.length; i++) {\n      address[] memory addrs = identifiers[identifiersToLookup[i]].accounts;\n      for (uint256 matchIndex = 0; matchIndex < matches[i]; matchIndex++) {\n        addresses[currentIndex] = getAccounts().getWalletAddress(addrs[matchIndex]);\n        completed[currentIndex] = identifiers[identifiersToLookup[i]]\n          .attestations[addrs[matchIndex]]\n          .completed;\n        total[currentIndex] = identifiers[identifiersToLookup[i]].attestations[addrs[matchIndex]]\n          .requested;\n\n        currentIndex++;\n      }\n    }\n\n    return (matches, addresses, completed, total);\n  }\n\n  /**\n   * @notice Returns the state of a specific attestation.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @param issuer Address of the issuer.\n   * @return [\n   *           Status of the attestation,\n   *           Block number of request/completion the attestation,\n   *           Address of the token with which this attestation request was paid for\n   *         ]\n   */\n  function getAttestationState(bytes32 identifier, address account, address issuer)\n    external\n    view\n    returns (uint8, uint32, address)\n  {\n    Attestation storage attestation = identifiers[identifier].attestations[account]\n      .issuedAttestations[issuer];\n    return (\n      uint8(attestation.status),\n      attestation.blockNumber,\n      attestation.attestationRequestFeeToken\n    );\n\n  }\n\n  /**\n    * @notice Returns the state of all attestations that are completable\n    * @param identifier Hash of the identifier.\n    * @param account Address of the account.\n    * @return ( blockNumbers[] - Block number of request/completion the attestation,\n    *           issuers[] - Address of the issuer,\n    *           stringLengths[] - The length of each metadataURL string for each issuer,\n    *           stringData - All strings concatenated\n    *         )\n    */\n  function getCompletableAttestations(bytes32 identifier, address account)\n    external\n    view\n    returns (uint32[] memory, address[] memory, uint256[] memory, bytes memory)\n  {\n    AttestedAddress storage state = identifiers[identifier].attestations[account];\n    address[] storage issuers = state.selectedIssuers;\n\n    uint256 num = 0;\n    for (uint256 i = 0; i < issuers.length; i = i.add(1)) {\n      if (isAttestationCompletable(state.issuedAttestations[issuers[i]])) {\n        num = num.add(1);\n      }\n    }\n\n    uint32[] memory blockNumbers = new uint32[](num);\n    address[] memory completableIssuers = new address[](num);\n\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < issuers.length; i = i.add(1)) {\n      if (isAttestationCompletable(state.issuedAttestations[issuers[i]])) {\n        blockNumbers[pointer] = state.issuedAttestations[issuers[i]].blockNumber;\n        completableIssuers[pointer] = issuers[i];\n        pointer = pointer.add(1);\n      }\n    }\n\n    uint256[] memory stringLengths;\n    bytes memory stringData;\n    (stringLengths, stringData) = getAccounts().batchGetMetadataURL(completableIssuers);\n    return (blockNumbers, completableIssuers, stringLengths, stringData);\n  }\n\n  /**\n   * @notice Returns the fee set for a particular token.\n   * @param token Address of the attestationRequestFeeToken.\n   * @return The fee.\n   */\n  function getAttestationRequestFee(address token) external view returns (uint256) {\n    return attestationRequestFees[token];\n  }\n\n  /**\n   * @notice Updates the fee  for a particular token.\n   * @param token The address of the attestationRequestFeeToken.\n   * @param fee The fee in 'token' that is required for each attestation.\n   */\n  function setAttestationRequestFee(address token, uint256 fee) public onlyOwner {\n    require(fee > 0, \"You have to specify a fee greater than 0\");\n    attestationRequestFees[token] = fee;\n    emit AttestationRequestFeeSet(token, fee);\n  }\n\n  /**\n   * @notice Updates 'attestationExpiryBlocks'.\n   * @param _attestationExpiryBlocks The new limit on blocks allowed to come between requesting\n   * an attestation and completing it.\n   */\n  function setAttestationExpiryBlocks(uint256 _attestationExpiryBlocks) public onlyOwner {\n    require(_attestationExpiryBlocks > 0, \"attestationExpiryBlocks has to be greater than 0\");\n    attestationExpiryBlocks = _attestationExpiryBlocks;\n    emit AttestationExpiryBlocksSet(_attestationExpiryBlocks);\n  }\n\n  /**\n   * @notice Updates 'selectIssuersWaitBlocks'.\n   * @param _selectIssuersWaitBlocks The wait period in blocks to call selectIssuers on attestation\n   *                                 requests.\n   */\n  function setSelectIssuersWaitBlocks(uint256 _selectIssuersWaitBlocks) public onlyOwner {\n    require(_selectIssuersWaitBlocks > 0, \"selectIssuersWaitBlocks has to be greater than 0\");\n    selectIssuersWaitBlocks = _selectIssuersWaitBlocks;\n    emit SelectIssuersWaitBlocksSet(_selectIssuersWaitBlocks);\n  }\n\n  /**\n   * @notice Validates the given attestation code.\n   * @param identifier The hash of the identifier to be attested.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The issuer of the corresponding attestation.\n   * @dev Throws if there is no matching outstanding attestation request.\n   * @dev Throws if the attestation window has passed.\n   */\n  function validateAttestationCode(\n    bytes32 identifier,\n    address account,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 codehash = keccak256(abi.encodePacked(identifier, account));\n    address signer = Signatures.getSignerOfMessageHash(codehash, v, r, s);\n    address issuer = getAccounts().attestationSignerToAccount(signer);\n\n    Attestation storage attestation = identifiers[identifier].attestations[account]\n      .issuedAttestations[issuer];\n\n    require(\n      attestation.status == AttestationStatus.Incomplete,\n      \"Attestation code does not match any outstanding attestation\"\n    );\n    require(!isAttestationExpired(attestation.blockNumber), \"Attestation timed out\");\n\n    return issuer;\n  }\n\n  function lookupAccountsForIdentifier(bytes32 identifier)\n    external\n    view\n    returns (address[] memory)\n  {\n    return identifiers[identifier].accounts;\n  }\n\n  /**\n   * @notice Helper function for batchGetAttestationStats to calculate the\n             total number of addresses that have >0 complete attestations for the identifiers.\n   * @param identifiersToLookup Array of n identifiers.\n   * @return Array of n numbers that indicate the number of matching addresses per identifier\n   *         and array of addresses preallocated for total number of matches.\n   */\n  function batchlookupAccountsForIdentifier(bytes32[] memory identifiersToLookup)\n    internal\n    view\n    returns (uint256[] memory, address[] memory)\n  {\n    require(identifiersToLookup.length > 0, \"You have to pass at least one identifier\");\n    uint256 totalAddresses = 0;\n    uint256[] memory matches = new uint256[](identifiersToLookup.length);\n\n    for (uint256 i = 0; i < identifiersToLookup.length; i++) {\n      uint256 count = identifiers[identifiersToLookup[i]].accounts.length;\n\n      totalAddresses = totalAddresses + count;\n      matches[i] = count;\n    }\n\n    return (matches, new address[](totalAddresses));\n  }\n\n  /**\n   * @notice Adds additional attestations given the current randomness.\n   * @param identifier The hash of the identifier to be attested.\n   */\n  function addIncompleteAttestations(bytes32 identifier) internal {\n    AttestedAddress storage state = identifiers[identifier].attestations[msg.sender];\n    UnselectedRequest storage unselectedRequest = identifiers[identifier].unselectedRequests[msg\n      .sender];\n\n    bytes32 seed = getRandom().getBlockRandomness(\n      uint256(unselectedRequest.blockNumber).add(selectIssuersWaitBlocks)\n    );\n    uint256 numberValidators = numberValidatorsInCurrentSet();\n\n    uint256 currentIndex = 0;\n    address validator;\n    address issuer;\n\n    while (currentIndex < unselectedRequest.attestationsRequested) {\n      seed = keccak256(abi.encodePacked(seed));\n      validator = validatorSignerAddressFromCurrentSet(uint256(seed) % numberValidators);\n      issuer = getAccounts().validatorSignerToAccount(validator);\n      Attestation storage attestation = state.issuedAttestations[issuer];\n\n      // Attestation issuers can only be added if they haven't been already.\n      if (attestation.status != AttestationStatus.None) {\n        continue;\n      }\n\n      currentIndex = currentIndex.add(1);\n      attestation.status = AttestationStatus.Incomplete;\n      attestation.blockNumber = unselectedRequest.blockNumber;\n      attestation.attestationRequestFeeToken = unselectedRequest.attestationRequestFeeToken;\n      state.selectedIssuers.push(issuer);\n\n      emit AttestationIssuerSelected(\n        identifier,\n        msg.sender,\n        issuer,\n        unselectedRequest.attestationRequestFeeToken\n      );\n    }\n  }\n\n  function isAttestationExpired(uint128 attestationRequestBlock) internal view returns (bool) {\n    return block.number >= uint256(attestationRequestBlock).add(attestationExpiryBlocks);\n  }\n\n  function isAttestationCompletable(Attestation storage attestation) internal view returns (bool) {\n    return (attestation.status == AttestationStatus.Incomplete &&\n      !isAttestationExpired(attestation.blockNumber));\n  }\n\n  function isAttestationRequestSelectable(uint256 attestationRequestBlock)\n    internal\n    view\n    returns (bool)\n  {\n    return block.number < attestationRequestBlock.add(getRandom().randomnessBlockRetentionWindow());\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/identity/Attestations.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAttestations.sol\";\nimport \"./interfaces/IRandom.sol\";\nimport \"../common/interfaces/IERC20Token.sol\";\nimport \"../common/interfaces/IAccounts.sol\";\nimport \"../governance/interfaces/IValidators.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/SafeCast.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\n/**\n * @title Contract mapping identifiers to accounts\n */\ncontract Attestations is\n  IAttestations,\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  ReentrancyGuard,\n  UsingPrecompiles\n{\n  using SafeMath for uint256;\n  using SafeCast for uint256;\n\n  enum AttestationStatus { None, Incomplete, Complete }\n\n  struct Attestation {\n    AttestationStatus status;\n    // For outstanding attestations, this is the block number of the request.\n    // For completed attestations, this is the block number of the attestation completion.\n    uint32 blockNumber;\n    // The token with which attestation request fees were paid.\n    address attestationRequestFeeToken;\n  }\n\n  // Stores attestations state for a single (identifier, account address) pair.\n  struct AttestedAddress {\n    // Total number of requested attestations.\n    uint32 requested;\n    // Total number of completed attestations.\n    uint32 completed;\n    // List of selected issuers responsible for attestations. The length of this list\n    // might be smaller than `requested` (which represents the total number of requested\n    // attestations) if users are not calling `selectIssuers` on unselected requests.\n    address[] selectedIssuers;\n    // State of each attestation keyed by issuer.\n    mapping(address => Attestation) issuedAttestations;\n  }\n\n  struct UnselectedRequest {\n    // The block at which the attestations were requested.\n    uint32 blockNumber;\n    // The number of attestations that were requested.\n    uint32 attestationsRequested;\n    // The token with which attestation request fees were paid in this request.\n    address attestationRequestFeeToken;\n  }\n\n  struct IdentifierState {\n    // All account addresses associated with this identifier.\n    address[] accounts;\n    // Keeps the state of attestations for account addresses for this identifier.\n    mapping(address => AttestedAddress) attestations;\n    // Temporarily stores attestation requests for which issuers should be selected by the account.\n    mapping(address => UnselectedRequest) unselectedRequests;\n  }\n\n  mapping(bytes32 => IdentifierState) identifiers;\n\n  // The duration in blocks in which an attestation can be completed from the block in which the\n  // attestation was requested.\n  uint256 public attestationExpiryBlocks;\n\n  // The duration to wait until selectIssuers can be called for an attestation request.\n  uint256 public selectIssuersWaitBlocks;\n\n  // The fees that are associated with attestations for a particular token.\n  mapping(address => uint256) public attestationRequestFees;\n\n  // Maps a token and attestation issuer to the amount that they're owed.\n  mapping(address => mapping(address => uint256)) public pendingWithdrawals;\n\n  event AttestationsRequested(\n    bytes32 indexed identifier,\n    address indexed account,\n    uint256 attestationsRequested,\n    address attestationRequestFeeToken\n  );\n\n  event AttestationIssuerSelected(\n    bytes32 indexed identifier,\n    address indexed account,\n    address indexed issuer,\n    address attestationRequestFeeToken\n  );\n\n  event AttestationCompleted(\n    bytes32 indexed identifier,\n    address indexed account,\n    address indexed issuer\n  );\n\n  event Withdrawal(address indexed account, address indexed token, uint256 amount);\n  event AttestationExpiryBlocksSet(uint256 value);\n  event AttestationRequestFeeSet(address indexed token, uint256 value);\n  event SelectIssuersWaitBlocksSet(uint256 value);\n\n  function initialize(\n    address registryAddress,\n    uint256 _attestationExpiryBlocks,\n    uint256 _selectIssuersWaitBlocks,\n    address[] calldata attestationRequestFeeTokens,\n    uint256[] calldata attestationRequestFeeValues\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setAttestationExpiryBlocks(_attestationExpiryBlocks);\n    setSelectIssuersWaitBlocks(_selectIssuersWaitBlocks);\n\n    require(\n      attestationRequestFeeTokens.length > 0 &&\n        attestationRequestFeeTokens.length == attestationRequestFeeValues.length,\n      \"attestationRequestFeeTokens specification was invalid\"\n    );\n    for (uint256 i = 0; i < attestationRequestFeeTokens.length; i = i.add(1)) {\n      setAttestationRequestFee(attestationRequestFeeTokens[i], attestationRequestFeeValues[i]);\n    }\n  }\n\n  /**\n   * @notice Commit to the attestation request of a hashed identifier.\n   * @param identifier The hash of the identifier to be attested.\n   * @param attestationsRequested The number of requested attestations for this request.\n   * @param attestationRequestFeeToken The address of the token with which the attestation fee will\n   * be paid.\n   */\n  function request(\n    bytes32 identifier,\n    uint256 attestationsRequested,\n    address attestationRequestFeeToken\n  ) external nonReentrant {\n    require(\n      attestationRequestFees[attestationRequestFeeToken] > 0,\n      \"Invalid attestationRequestFeeToken\"\n    );\n    require(\n      IERC20Token(attestationRequestFeeToken).transferFrom(\n        msg.sender,\n        address(this),\n        attestationRequestFees[attestationRequestFeeToken].mul(attestationsRequested)\n      ),\n      \"Transfer of attestation request fees failed\"\n    );\n\n    require(attestationsRequested > 0, \"You have to request at least 1 attestation\");\n\n    IdentifierState storage state = identifiers[identifier];\n\n    require(\n      state.unselectedRequests[msg.sender].blockNumber == 0 ||\n        isAttestationExpired(state.unselectedRequests[msg.sender].blockNumber) ||\n        !isAttestationRequestSelectable(state.unselectedRequests[msg.sender].blockNumber),\n      \"There exists an unexpired, unselected attestation request\"\n    );\n\n    state.unselectedRequests[msg.sender].blockNumber = block.number.toUint32();\n    state.unselectedRequests[msg.sender].attestationsRequested = attestationsRequested.toUint32();\n    state.unselectedRequests[msg.sender].attestationRequestFeeToken = attestationRequestFeeToken;\n\n    state.attestations[msg.sender].requested = uint256(state.attestations[msg.sender].requested)\n      .add(attestationsRequested)\n      .toUint32();\n\n    emit AttestationsRequested(\n      identifier,\n      msg.sender,\n      attestationsRequested,\n      attestationRequestFeeToken\n    );\n  }\n\n  /**\n   * @notice Selects the issuers for the most recent attestation request.\n   * @param identifier The hash of the identifier to be attested.\n   */\n  function selectIssuers(bytes32 identifier) external {\n    IdentifierState storage state = identifiers[identifier];\n\n    require(\n      state.unselectedRequests[msg.sender].blockNumber > 0,\n      \"No unselected attestation request to select issuers for\"\n    );\n\n    require(\n      !isAttestationExpired(state.unselectedRequests[msg.sender].blockNumber),\n      \"The attestation request has expired\"\n    );\n\n    addIncompleteAttestations(identifier);\n    delete state.unselectedRequests[msg.sender];\n  }\n\n  /**\n   * @notice Submit the secret message sent by the issuer to complete the attestation request.\n   * @param identifier The hash of the identifier for this attestation.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Throws if there is no matching outstanding attestation request.\n   * @dev Throws if the attestation window has passed.\n   */\n  function complete(bytes32 identifier, uint8 v, bytes32 r, bytes32 s) external {\n    address issuer = validateAttestationCode(identifier, msg.sender, v, r, s);\n\n    Attestation storage attestation = identifiers[identifier].attestations[msg.sender]\n      .issuedAttestations[issuer];\n\n    address token = attestation.attestationRequestFeeToken;\n\n    // solhint-disable-next-line not-rely-on-time\n    attestation.blockNumber = block.number.toUint32();\n    attestation.status = AttestationStatus.Complete;\n    delete attestation.attestationRequestFeeToken;\n    identifiers[identifier].attestations[msg.sender].completed++;\n\n    pendingWithdrawals[token][issuer] = pendingWithdrawals[token][issuer].add(\n      attestationRequestFees[token]\n    );\n\n    IdentifierState storage state = identifiers[identifier];\n    if (identifiers[identifier].attestations[msg.sender].completed == 1) {\n      state.accounts.push(msg.sender);\n    }\n\n    emit AttestationCompleted(identifier, msg.sender, issuer);\n  }\n\n  /**\n   * @notice Revokes an account for an identifier.\n   * @param identifier The identifier for which to revoke.\n   * @param index The index of the account in the accounts array.\n   */\n  function revoke(bytes32 identifier, uint256 index) external {\n    uint256 numAccounts = identifiers[identifier].accounts.length;\n    require(index < numAccounts, \"Index is invalid\");\n    require(\n      msg.sender == identifiers[identifier].accounts[index],\n      \"Index does not match msg.sender\"\n    );\n\n    uint256 newNumAccounts = numAccounts.sub(1);\n    if (index != newNumAccounts) {\n      identifiers[identifier].accounts[index] = identifiers[identifier].accounts[newNumAccounts];\n    }\n    identifiers[identifier].accounts[newNumAccounts] = address(0x0);\n    identifiers[identifier].accounts.length--;\n  }\n\n  /**\n   * @notice A"
    }
  ]
}