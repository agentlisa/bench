{
  "Title": "H-4: Tracking of the latest ADL block use the wrong block number on Arbitrum",
  "Content": "# Issue H-4: Tracking of the latest ADL block use the wrong block number on Arbitrum \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/150 \n\n## Found by \nGalloDaSballo, IllIllI, ShadowForce\n\n## Summary\n\nTracking of the latest ADL block use the wrong block number on Arbitrum\n\n\n## Vulnerability Detail\n\nThe call to `setLatestAdlBlock()` passes in `block.timestamp`, which on Arbitrum, is the L1 block timestamp, not the L2 timestamp on which order timestamps are based.\n\n\n## Impact\n\nTracking of whether ADL is currently required or not will be based on block numbers that are very far in the past (since Arbitrum block numbers are incremented much more quickly than Ethereum ones), so checks of whether ADL is enabled will pass, and the ADL keeper will be able to execute ADL orders whenever it wants to.\n\n\n## Code Snippet\n\nUses `block.number` rather than [`Chain.currentBlockNumber()`](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/chain/Chain.sol#L24-L30\n):\n```solidity\n// File: gmx-synthetics/contracts/adl/AdlUtils.sol : AdlUtils.updateAdlState()   #1\n\n104            MarketUtils.MarketPrices memory prices = MarketUtils.getMarketPrices(oracle, _market);\n105            (bool shouldEnableAdl, int256 pnlToPoolFactor, uint256 maxPnlFactor) = MarketUtils.isPnlFactorExceeded(\n106                dataStore,\n107                _market,\n108                prices,\n109                isLong,\n110                Keys.MAX_PNL_FACTOR\n111            );\n112    \n113            setIsAdlEnabled(dataStore, market, isLong, shouldEnableAdl);\n114 @>         setLatestAdlBlock(dataStore, market, isLong, block.number);\n115    \n116            emitAdlStateUpdated(eventEmitter, market, isLong, pnlToPoolFactor, maxPnlFactor, shouldEnableAdl);\n117:       }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/adl/AdlUtils.sol#L104-L117\n\nThe block number (which is an L1 block number) is checked against the L2 oracle [block numbers](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/adl/AdlUtils.sol#L192-L195).\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nUse `Chain.currentBlockNumber()` as is done everywhere else in the code base\n\n\n\n## Discussion\n\n**Jiaren-tang**\n\nEscalate for 11 USDC. I think this should definitely be high. ADL should not be allowed to execute at any time, and if it does, it clearly the loss of fund. Because https://github.com/sherlock-audit/2023-02-gmx-judging/issues/143 is rewarded as high I think using wrong block.number allowing ADL operations to be executed when they are not supposed to be executed leads to loss of fund and deserves a high severity.\n\n**sherlock-admin**\n\n > Escalate for 11 USDC. I think this should definitely be high. ADL should not be allowed to execute at any time, and if it does, it clearly the loss of fund. Because https://github.com/sherlock-audit/2023-02-gmx-judging/issues/143 is rewarded as high I think using wrong block.number allowing ADL operations to be executed when they are not supposed to be executed leads to loss of fund and deserves a high severity.\n\nYou've created an escalation for 11 USDC, however, the escalation amount is fixed at 10 USDC.\nTo update the escalation with the correct amount, please edit this comment. **(do not create a new comment)**\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IllIllI000**\n\nI'm not sure about this one. I submitted as Medium because it's essentially a cap on profit, but as the escalator points out, slippage does create a loss. I'll leave this one to the Sherlock team to decide\n\n**hrishibhat**\n\nEscalation accepted\n\nConsidering this issue a high based on the slippage reasoning.\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Considering this issue a high based on the slippage reasoning. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Considering this issue a high based on the slippage reasoning.\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/commit/2129b82693b31ec698a100c6b38a7fadf6ec711b\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/chain/Chain.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./ArbSys.sol\";\n\n// @title Chain\n// @dev Wrap the calls to retrieve chain variables to handle differences\n// between chain implementations\nlibrary Chain {\n    uint256 constant public ARBITRUM_CHAIN_ID = 42161;\n    uint256 constant public ARBITRUM_RINKEBY_CHAIN_ID = 421611;\n\n    ArbSys constant public arbSys = ArbSys(address(100));\n\n    // @dev return the current block's timestamp\n    // @return the current block's timestamp\n    function currentTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    // @dev return the current block's number\n    // @return the current block's number\n    function currentBlockNumber() internal view returns (uint256) {\n        if (block.chainid == ARBITRUM_CHAIN_ID || block.chainid == ARBITRUM_RINKEBY_CHAIN_ID) {\n            return arbSys.arbBlockNumber();\n        }\n\n        return block.number;\n    }\n\n    // @dev return the current block's hash\n    // @return the current block's hash\n    function getBlockHash(uint256 blockNumber) internal view returns (bytes32) {\n        if (block.chainid == ARBITRUM_CHAIN_ID || block.chainid == ARBITRUM_RINKEBY_CHAIN_ID) {\n            return arbSys.arbBlockHash(blockNumber);\n        }\n\n        return blockhash(blockNumber);\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/adl/AdlUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../order/OrderStoreUtils.sol\";\nimport \"../order/OrderEventUtils.sol\";\nimport \"../position/PositionUtils.sol\";\nimport \"../position/PositionStoreUtils.sol\";\nimport \"../nonce/NonceUtils.sol\";\n\n// @title AdlUtils\n// @dev Library to help with auto-deleveraging\n// This is particularly for markets with an index token that is different from\n// the long token\n//\n// For example, if there is a DOGE / USD perp market with ETH as the long token\n// it would be possible for the price of DOGE to increase faster than the price of\n// ETH\n//\n// In this scenario, profitable positions should be closed through ADL to ensure\n// that the system remains fully solvent\nlibrary AdlUtils {\n    using SafeCast for int256;\n    using Array for uint256[];\n    using Market for Market.Props;\n    using Position for Position.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    // @dev CreateAdlOrderParams struct used in createAdlOrder to avoid stack\n    // too deep errors\n    //\n    // @param dataStore DataStore\n    // @param orderStore OrderStore\n    // @param account the account to reduce the position for\n    // @param market the position's market\n    // @param collateralToken the position's collateralToken\n    // @param isLong whether the position is long or short\n    // @param sizeDeltaUsd the size to reduce the position by\n    // @param updatedAtBlock the block to set the order's updatedAtBlock to\n    struct CreateAdlOrderParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        address account;\n        address market;\n        address collateralToken;\n        bool isLong;\n        uint256 sizeDeltaUsd;\n        uint256 updatedAtBlock;\n    }\n\n    error InvalidSizeDeltaForAdl(uint256 sizeDeltaUsd, uint256 positionSizeInUsd);\n    error AdlNotEnabled();\n\n    // @dev Multiple positions may need to be reduced to ensure that the pending\n    // profits does not exceed the allowed thresholds\n    //\n    // This automatic reduction of positions can only be done if the pool is in a state\n    // where auto-deleveraging is required\n    //\n    // This function checks the pending profit state and updates an isAdlEnabled\n    // flag to avoid having to repeatedly validate whether auto-deleveraging is required\n    //\n    // Once the pending profit has been reduced below the threshold this function can\n    // be called again to clear the flag\n    //\n    // The ADL check would be possible to do in AdlHandler.executeAdl as well\n    // but with that order keepers could use stale oracle prices to prove that\n    // an ADL state is possible\n    //\n    // Having this function allows any order keeper to disable ADL if prices\n    // have updated such that ADL is no longer needed\n    //\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param oracle Oracle\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param maxOracleBlockNumbers the oracle block numbers for the prices stored in the oracle\n    function updateAdlState(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        Oracle oracle,\n        address market,\n        bool isLong,\n        uint256[] memory maxOracleBlockNumbers\n    ) external {\n        uint256 latestAdlBlock = getLatestAdlBlock(dataStore, market, isLong);\n\n        if (!maxOracleBlockNumbers.areGreaterThanOrEqualTo(latestAdlBlock)) {\n            OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(maxOracleBlockNumbers, latestAdlBlock);\n        }\n\n        Market.Props memory _market = MarketUtils.getEnabledMarket(dataStore, market);\n        MarketUtils.MarketPrices memory prices = MarketUtils.getMarketPrices(oracle, _market);\n        (bool shouldEnableAdl, int256 pnlToPoolFactor, uint256 maxPnlFactor) = MarketUtils.isPnlFactorExceeded(\n            dataStore,\n            _market,\n            prices,\n            isLong,\n            Keys.MAX_PNL_FACTOR\n        );\n\n        setIsAdlEnabled(dataStore, market, isLong, shouldEnableAdl);\n        setLatestAdlBlock(dataStore, market, isLong, block.number);\n\n        emitAdlStateUpdated(eventEmitter, market, isLong, pnlToPoolFactor, maxPnlFactor, shouldEnableAdl);\n    }\n\n    // @dev Construct an ADL order\n    //\n    // A decrease order is used to reduce a profitable position\n    //\n    // @param params CreateAdlOrderParams\n    // @return the key of the created order\n    function createAdlOrder(CreateAdlOrderParams memory params) external returns (bytes32) {\n        bytes32 positionKey = PositionUtils.getPositionKey(params.account, params.market, params.collateralToken, params.isLong);\n        Position.Props memory position = PositionStoreUtils.get(params.dataStore, positionKey);\n\n        if (params.sizeDeltaUsd > position.sizeInUsd()) {\n            revert InvalidSizeDeltaForAdl(params.sizeDeltaUsd, position.sizeInUsd());\n        }\n\n        Order.Addresses memory addresses = Order.Addresses(\n            params.account, // account\n            params.account, // receiver\n            address(0), // callbackContract\n            params.market, // market\n            position.collateralToken(), // initialCollateralToken\n            new address[](0) // swapPath\n        );\n\n        Order.Numbers memory numbers = Order.Numbers(\n            Order.OrderType.MarketDecrease, // orderType\n            Order.DecreasePositionSwapType.NoSwap, // decreasePositionSwapType\n            params.sizeDeltaUsd, // sizeDeltaUsd\n            0, // initialCollateralDeltaAmount\n            0, // triggerPrice\n            position.isLong() ? 0 : type(uint256).max, // acceptablePrice\n            0, // executionFee\n            0, // callbackGasLimit\n            0, // minOutputAmount\n            params.updatedAtBlock // updatedAtBlock\n        );\n\n        Order.Flags memory flags = Order.Flags(\n            position.isLong(), // isLong\n            true, // shouldUnwrapNativeToken\n            false // isFrozen\n        );\n\n        Order.Props memory order = Order.Props(\n            addresses,\n            numbers,\n            flags\n        );\n\n        bytes32 key = NonceUtils.getNextKey(params.dataStore);\n        OrderStoreUtils.set(params.dataStore, key, order);\n\n        OrderEventUtils.emitOrderCreated(params.eventEmitter, key, order);\n\n        return key;\n    }\n\n    // @dev validate if the requested ADL can be executed\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param maxOracleBlockNumbers the oracle block numbers for the prices stored in the oracle\n    function validateAdl(\n        DataStore dataStore,\n        address market,\n        bool isLong,\n        uint256[] memory maxOracleBlockNumbers\n    ) external view {\n        bool isAdlEnabled = AdlUtils.getIsAdlEnabled(dataStore, market, isLong);\n        if (!isAdlEnabled) {\n            revert AdlNotEnabled();\n        }\n\n        uint256 latestAdlBlock = AdlUtils.getLatestAdlBlock(dataStore, market, isLong);\n        if (!maxOracleBlockNumbers.areGreaterThanOrEqualTo(latestAdlBlock)) {\n            OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(maxOracleBlockNumbers, latestAdlBlock);\n        }\n    }\n\n    // @dev get the latest block at which the ADL flag was updated\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    //\n    // @return the latest block at which the ADL flag was updated\n    function getLatestAdlBlock(DataStore dataStore, address market, bool isLong) internal view returns (uint256) {\n        return dataStore.getUint(Keys.latestAdlBlockKey(market, isLong));\n    }\n\n    // @dev set the latest block at which the ADL flag was updated\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param value the latest block value\n    //\n    // @return the latest block value\n    function setLatestAdlBlock(DataStore dataStore, address market, bool isLong, uint256 value) internal returns (uint256) {\n        return dataStore.setUint(Keys.latestAdlBlockKey(market, isLong), value);\n    }\n\n    // @dev get whether ADL is enabled\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    //\n    // @return whether ADL is enabled\n    function getIsAdlEnabled(DataStore dataStore, address market, bool isLong) internal view returns (bool) {\n        return dataStore.getBool(Keys.isAdlEnabledKey(market, isLong));\n    }\n\n    // @dev set whether ADL is enabled\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param value whether ADL is enabled\n    //\n    // @return whether ADL is enabled\n    function setIsAdlEnabled(DataStore dataStore, address market, bool isLong, bool value) internal returns (bool) {\n        return dataStore.setBool(Keys.isAdlEnabledKey(market, isLong), value);\n    }\n\n    // @dev emit ADL state update events\n    //\n    // @param eventEmitter EventEmitter\n    // @param market address of the market for the ADL state update\n    // @param isLong indicates the ADL state update is for the long or short side of the market\n    // @param pnlToPoolFactor the ratio of PnL to pool value\n    // @param maxPnlFactor the max PnL factor\n    // @param shouldEnableAdl whether ADL was enabled or disabled\n    function emitAdlStateUpdated(\n        EventEmitter eventEmitter,\n        address market,\n        bool isLong,\n        int256 pnlToPoolFactor,\n        uint256 maxPnlFactor,\n        bool shouldEnableAdl\n    ) internal {\n        EventUtils.EventLogData memory eventData;\n\n        eventData.intItems.initItems(1);\n        eventData.intItems.setItem(0, \"pnlToPoolFactor\", pnlToPoolFactor);\n\n        eventData.uintItems.initItems(1);\n        eventData.uintItems.setItem(0, \"maxPnlFactor\", maxPnlFactor);\n\n        eventData.boolItems.initItems(2);\n        eventData.boolItems.setItem(0, \"isLong\", isLong);\n        eventData.boolItems.setItem(1, \"shouldEnableAdl\", shouldEnableAdl);\n\n        eventEmitter.emitEventLog1(\n            \"AdlStateUpdated\",\n            Cast.toBytes32(market),\n            eventData\n        );\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/adl/AdlUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../order/OrderStoreUtils.sol\";\nimport \"../order/OrderEventUtils.sol\";\nimport \"../position/PositionUtils.sol\";\nimport \"../position/PositionStoreUtils.sol\";\nimport \"../nonce/NonceUtils.sol\";\n\n// @title AdlUtils\n// @dev Library to help with auto-deleveraging\n// This is particularly for markets with an index token that is different from\n// the long token\n//\n// For example, if there is a DOGE / USD perp market with ETH as the long token\n// it would be possible for the price of DOGE to increase faster than the price of\n// ETH\n//\n// In this scenario, profitable positions should be closed through ADL to ensure\n// that the system remains fully solvent\nlibrary AdlUtils {\n    using SafeCast for int256;\n    using Array for uint256[];\n    using Market for Market.Props;\n    using Position for Position.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    // @dev CreateAdlOrderParams struct used in createAdlOrder to avoid stack\n    // too deep errors\n    //\n    // @param dataStore DataStore\n    // @param orderStore OrderStore\n    // @param account the account to reduce the position for\n    // @param market the position's market\n    // @param collateralToken the position's collateralToken\n    // @param isLong whether the position is long or short\n    // @param sizeDeltaUsd the size to reduce the position by\n    // @param updatedAtBlock the block to set the order's updatedAtBlock to\n    struct CreateAdlOrderParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        address account;\n        address market;\n        address collateralToken;\n        bool isLong;\n        uint256 sizeDeltaUsd;\n        uint256 updatedAtBlock;\n    }\n\n    error InvalidSizeDeltaForAdl(uint256 sizeDeltaUsd, uint256 positionSizeInUsd);\n    error AdlNotEnabled();\n\n    // @dev Multiple positions may need to be reduced to ensure that the pending\n    // profits does not exceed the allowed thresholds\n    //\n    // This automatic reduction of positions can only be done if the pool is in a state\n    // where auto-deleveraging is required\n    //\n    // This function checks the pending profit state and updates an isAdlEnabled\n    // flag to avoid having to repeatedly validate whether auto-deleveraging is required\n    //\n    // Once the pending profit has been reduced below the threshold this function can\n    // be called again to clear the flag\n    //\n    // The ADL check would be possible to do in AdlHandler.executeAdl as well\n    // but with that order keepers could use stale oracle prices to prove that\n    // an ADL state is possible\n    //\n    // Having this function allows any order keeper to disable ADL if prices\n    // have updated such that ADL is no longer needed\n    //\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param oracle Oracle\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param maxOracleBlockNumbers the oracle block numbers for the prices stored in the oracle\n    function updateAdlState(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        Oracle oracle,\n        address market,\n        bool isLong,\n        uint256[] memory maxOracleBlockNumbers\n    ) external {\n        uint256 latestAdlBlock = getLatestAdlBlock(dataStore, market, isLong);\n\n        if (!maxOracleBlockNumbers.areGreaterThanOrEqualTo(latestAdlBlock)) {\n            OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(maxOracleBlockNumbers, latestAdlBlock);\n        }\n\n        Market.Props memory _market = MarketUtils.getEnabledMarket(dataStore, market);\n        MarketUtils.MarketPrices memory prices = MarketUtils.getMarketPrices(oracle, _market);\n        (bool shouldEnableAdl, int256 pnlToPoolFactor, uint256 maxPnlFactor) = MarketUtils.isPnlFactorExceeded(\n            dataStore,\n            _market,\n            prices,\n            isLong,\n            Keys.MAX_PNL_FACTOR\n        );\n\n        setIsAdlEnabled(dataStore, market, isLong, shouldEnableAdl);\n        setLatestAdlBlock(dataStore, market, isLong, block.number);\n\n        emitAdlStateUpdated(eventEmitter, market, isLong, pnlToPoolFactor, maxPnlFactor, shouldEnableAdl);\n    }\n\n    // @dev Construct an ADL order\n    //\n    // A decrease order is used to reduce a profitable position\n    //\n    // @param params CreateAdlOrderParams\n    // @return the key of the created order\n    function createAdlOrder(CreateAdlOrderParams memory params) external returns (bytes32) {\n        bytes32 positionKey = PositionUtils.getPositionKey(params.account, params.market, params.collateralToken, params.isLong);\n        Position.Props memory position = PositionStoreUtils.get(params.dataStore, positionKey);\n\n        if (params.sizeDeltaUsd > position.sizeInUsd()) {\n            revert InvalidSizeDeltaForAdl(params.sizeDeltaUsd, position.sizeInUsd());\n        }\n\n        Order.Addresses memory addresses = Order.Addresses(\n            params.account, // account\n            params.account, // receiver\n            address(0), // callbackContract\n            params.market, // market\n            position.collateralToken(), // initialCollateralToken\n            new address[](0) // swapPath\n        );\n\n        Order.Numbers memory numbers = Order.Numbers(\n            Order.OrderType.MarketDecrease, // orderType\n            Order.DecreasePositionSwapType.NoSwap, // decreasePositionSwapType\n            params.sizeDeltaUsd, // sizeDeltaUsd\n            0, // initialCollateralDeltaAmount\n            0, // triggerPrice\n            position.isLong() ? 0 : type(uint256).max, // acceptablePrice\n            0, // executionFee\n            0, // callbackGasLimit\n            0, // minOutputAmount\n            params.updatedAtBlock // updatedAtBlock\n        );\n\n        Order.Flags memory flags = Order.Flags(\n            position.isLong(), // isLong\n            true, // shouldUnwrapNativeToken\n            false // isFrozen\n        );\n\n        Order.Props memory order = Order.Props(\n            addresses,\n            numbers,\n            flags\n        );\n\n        bytes32 key = NonceUtils.getNextKey(params.dataStore);\n        OrderStoreUtils.set(params.dataStore, key, order);\n\n        OrderEventUtils.emitOrderCreated(params.eventEmitter, key, order);\n\n        return key;\n    }\n\n    // @dev validate if the requested ADL can be executed\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param maxOracleBlockNumbers the oracle block numbers for the prices stored in the oracle\n    function validateAdl(\n        DataStore dataStore,\n        address market,\n        bool isLong,\n        uint256[] memory maxOracleBlockNumbers\n    ) external view {\n        bool isAdlEnabled = AdlUtils.getIsAdlEnabled(dataStore, market, isLong);\n        if (!isAdlEnabled) {\n            revert AdlNotEnabled();\n        }\n\n        uint256 latestAdlBlock = AdlUtils.getLatestAdlBlock(dataStore, market, isLong);\n        if (!maxOracleBlockNumbers.areGreaterThanOrEqualTo(latestAdlBlock)) {\n            OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(maxOracleBlockNumbers, latestAdlBlock);\n        }\n    }\n\n    // @dev get the latest block at which the ADL flag was updated\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    //\n    // @return the latest block at which the ADL flag was updated\n    function getLatestAdlBlock(DataStore dataStore, address market, bool isLong) internal view returns (uint256) {\n        return dataStore.getUint(Keys.latestAdlBlockKey(market, isLong));\n    }\n\n    // @dev set the latest block at which the ADL flag was updated\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param value the latest block value\n    //\n    // @return the latest block value\n    function setLatestAdlBlock(DataStore dataStore, address market, bool isLong, uint256 value) internal returns (uint256) {\n        return dataStore.setUint(Keys.latestAdlBlockKey(market, isLong), value);\n    }\n\n    // @dev get whether ADL is enabled\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    //\n    // @return whether ADL is enabled\n    function getIsAdlEnabled(DataStore dataStore, address market, bool isLong) internal view returns (bool) {\n        return dataStore.getBool(Keys.isAdlEnabledKey(market, isLong));\n    }\n\n    // @dev set whether ADL is enabled\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param value whether ADL is enabled\n    //\n    // @return whether ADL is enabled\n    function setIsAdlEnabled(DataStore dataStore, address market, bool isLong, bool value) internal returns (bool) {\n        return dataStore.setBool(Keys.isAdlEnabledKey(market, isLong), value);\n    }\n\n    // @dev emit ADL state update events\n    //\n    // @param eventEmitter EventEmitter\n    // @param market address of the market for the ADL state update\n    // @param isLong indicates the ADL state update is for the long or short side of the market\n    // @param pnlToPoolFactor the ratio of PnL to pool value\n    // @param maxPnlFactor the max PnL factor\n    // @param shouldEnableAdl whether ADL was enabled or disabled\n    function emitAdlStateUpdated(\n        EventEmitter eventEmitter,\n        address market,\n        bool isLong,\n        int256 pnlToPoolFactor,\n        uint256 maxPnlFactor,\n        bool shouldEnableAdl\n    ) internal {\n        EventUtils.EventLogData memory eventData;\n\n        eventData.intItems.initItems(1);\n        eventData.intItems.setItem(0, \"pnlToPoolFactor\", pnlToPoolFactor);\n\n        eventData.uintItems.initItems(1);\n        eventData.uintItems.setItem(0, \"maxPnlFactor\", maxPnlFactor);\n\n        eventData.boolItems.initItems(2);\n        eventData.boolItems.setItem(0, \"isLong\", isLong);\n        eventData.boolItems.setItem(1, \"shouldEnableAdl\", shouldEnableAdl);\n\n        eventEmitter.emitEventLog1(\n            \"AdlStateUpdated\",\n            Cast.toBytes32(market),\n            eventData\n        );\n    }\n}"
    }
  ]
}