{
  "Title": "Failed Funds Can Be Locked Inside L2BatchBridgeGateway",
  "Content": "After a batch deposit [has been finalized on L2](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/batch-bridge/L2BatchBridgeGateway.sol#L144), the `KEEPER_ROLE` can [distribute the funds](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/batch-bridge/L2BatchBridgeGateway.sol#L188). If distributing to a party fails, the failed amounts [are accounted for](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/batch-bridge/L2BatchBridgeGateway.sol#L210) in order to rescue them later through the [`withdrawFailedAmount` function](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/batch-bridge/L2BatchBridgeGateway.sol#L176). Note that the [`_transferToken` function](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/batch-bridge/L2BatchBridgeGateway.sol#L228C5-L245C6) does not revert on failure but returns a `success` value which [is not checked](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/batch-bridge/L2BatchBridgeGateway.sol#L181). As such, if the ETH or token transfer to the receiver fails, the [`failedAmount[token]`](https://github.com/scroll-tech/scroll/blob/84f73c76d2cfd0b07640315fc85e7e43eef98498/contracts/src/batch-bridge/L2BatchBridgeGateway.sol#L179) is still set to 0, locking the funds.\n\n\nConsider checking the success value of `_transferTokens` and reverting if the transfer fails.\n\n\n***Update:** Acknowledged, not resolved. The Scroll team stated:*\n\n\n\n> *Acknowledged. Not a priority.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/batch-bridge/L2BatchBridgeGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.24;\n\nimport {AccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport {IL2ScrollMessenger} from \"../L2/IL2ScrollMessenger.sol\";\nimport {BatchBridgeCodec} from \"./BatchBridgeCodec.sol\";\n\n/// @title L2BatchBridgeGateway\ncontract L2BatchBridgeGateway is AccessControlEnumerableUpgradeable {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when token mapping for ERC20 token is updated.\n    /// @param l2Token The address of corresponding ERC20 token in layer 2.\n    /// @param oldL1Token The address of the old corresponding ERC20 token in layer 1.\n    /// @param newL1Token The address of the new corresponding ERC20 token in layer 1.\n    event UpdateTokenMapping(address indexed l2Token, address indexed oldL1Token, address indexed newL1Token);\n\n    /// @notice Emitted when batch bridge is finalized.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch finalized.\n    event FinalizeBatchDeposit(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when batch distribution finished.\n    /// @param l1Token The address of token in L1.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of batch distributed.\n    event BatchDistribute(address indexed l1Token, address indexed l2Token, uint256 indexed batchIndex);\n\n    /// @notice Emitted when token distribute failed.\n    /// @param l2Token The address of token in L2.\n    /// @param batchIndex The index of the batch.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to distribute.\n    event DistributeFailed(address indexed l2Token, uint256 indexed batchIndex, address receiver, uint256 amount);\n\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when caller is not `messenger`.\n    error ErrorCallerNotMessenger();\n\n    /// @dev Thrown when the L1 token mapping mismatch with `finalizeBatchBridge`.\n    error ErrorL1TokenMismatched();\n\n    /// @dev Thrown when message sender is not `counterpart`.\n    error ErrorMessageSenderNotCounterpart();\n\n    /// @dev Thrown no failed distribution exists.\n    error ErrorNoFailedDistribution();\n\n    /// @dev Thrown when the batch hash mismatch.\n    error ErrorBatchHashMismatch();\n\n    /// @dev Thrown when distributing the same batch.\n    error ErrorBatchDistributed();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The role for batch deposit keeper.\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    /// @notice The safe gas limit for ETH transfer\n    uint256 private constant SAFE_ETH_TRANSFER_GAS_LIMIT = 50000;\n\n    /// @notice The address of corresponding `L1BatchBridgeGateway` contract.\n    address public immutable counterpart;\n\n    /// @notice The address of corresponding `L2ScrollMessenger` contract.\n    address public immutable messenger;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from l2 token address to l1 token address.\n    mapping(address => address) public tokenMapping;\n\n    /// @notice Mapping from L2 token address to batch index to batch hash.\n    mapping(address => mapping(uint256 => bytes32)) public batchHashes;\n\n    /// @notice Mapping from token address to the amount of failed distribution.\n    mapping(address => uint256) public failedAmount;\n\n    /// @notice Mapping from batch hash to the distribute status.\n    mapping(bytes32 => bool) public isDistributed;\n\n    /*************\n     * Modifiers *\n     *************/\n\n    modifier onlyMessenger() {\n        if (_msgSender() != messenger) {\n            revert ErrorCallerNotMessenger();\n        }\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @param _counterpart The address of `L1BatchBridgeGateway` contract in L1.\n    /// @param _messenger The address of `L2ScrollMessenger` contract in L2.\n    constructor(address _counterpart, address _messenger) {\n        _disableInitializers();\n\n        counterpart = _counterpart;\n        messenger = _messenger;\n    }\n\n    /// @notice Initialize the storage of `L2BatchBridgeGateway`.\n    function initialize() external initializer {\n        __Context_init(); // from ContextUpgradeable\n        __ERC165_init(); // from ERC165Upgradeable\n        __AccessControl_init(); // from AccessControlUpgradeable\n        __AccessControlEnumerable_init(); // from AccessControlEnumerableUpgradeable\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Receive batch bridged ETH from `L2ScrollMessenger`.\n    receive() external payable onlyMessenger {\n        // empty\n    }\n\n    /// @notice Finalize L1 initiated batch token deposit.\n    /// @param l1Token The address of the token in L1.\n    /// @param l2Token The address of the token in L2.\n    /// @param batchIndex The index of this batch bridge.\n    /// @param hash The hash of this batch.\n    function finalizeBatchDeposit(\n        address l1Token,\n        address l2Token,\n        uint256 batchIndex,\n        bytes32 hash\n    ) external onlyMessenger {\n        if (counterpart != IL2ScrollMessenger(messenger).xDomainMessageSender()) {\n            revert ErrorMessageSenderNotCounterpart();\n        }\n\n        // trust the messenger and update `tokenMapping` in first call\n        // another assumption is this function should never fail due to out of gas\n        address storedL1Token = tokenMapping[l2Token];\n        if (storedL1Token == address(0) && l1Token != address(0)) {\n            tokenMapping[l2Token] = l1Token;\n        } else if (storedL1Token != l1Token) {\n            // this usually won't happen, check just in case.\n            revert ErrorL1TokenMismatched();\n        }\n\n        batchHashes[l2Token][batchIndex] = hash;\n\n        emit FinalizeBatchDeposit(l1Token, l2Token, batchIndex);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Withdraw distribution failed tokens.\n    /// @param token The address of token to withdraw.\n    /// @param receiver The address of token receiver.\n    function withdrawFailedAmount(address token, address receiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        uint256 amount = failedAmount[token];\n        if (amount == 0) revert ErrorNoFailedDistribution();\n        failedAmount[token] = 0;\n\n        _transferToken(token, receiver, amount);\n    }\n\n    /// @notice Distribute deposited token to corresponding receivers.\n    /// @param l2Token The address of L2 token.\n    /// @param batchIndex The index of batch to distribute.\n    /// @param nodes The list of encoded L1 deposits.\n    function distribute(\n        address l2Token,\n        uint64 batchIndex,\n        bytes32[] memory nodes\n    ) external onlyRole(KEEPER_ROLE) {\n        address l1Token = tokenMapping[l2Token];\n        bytes32 hash = BatchBridgeCodec.encodeInitialNode(l1Token, batchIndex);\n        for (uint256 i = 0; i < nodes.length; i++) {\n            hash = BatchBridgeCodec.hash(hash, nodes[i]);\n        }\n        if (batchHashes[l2Token][batchIndex] != hash) {\n            revert ErrorBatchHashMismatch();\n        }\n        if (isDistributed[hash]) {\n            revert ErrorBatchDistributed();\n        }\n        isDistributed[hash] = true;\n\n        // do transfer and allow failure to avoid DDOS attack\n        for (uint256 i = 0; i < nodes.length; i++) {\n            (address receiver, uint256 amount) = BatchBridgeCodec.decodeNode(nodes[i]);\n            if (!_transferToken(l2Token, receiver, amount)) {\n                failedAmount[l2Token] += amount;\n\n                emit DistributeFailed(l2Token, batchIndex, receiver, amount);\n            }\n        }\n\n        emit BatchDistribute(l1Token, l2Token, batchIndex);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to transfer token, including ETH.\n    /// @param token The address of token.\n    /// @param receiver The address of token receiver.\n    /// @param amount The amount of token to transfer.\n    /// @return success Whether the transfer is successful.\n    function _transferToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) private returns (bool success) {\n        if (token == address(0)) {\n            // We add gas limit here to avoid DDOS from malicious receiver.\n            (success, ) = receiver.call{value: amount, gas: SAFE_ETH_TRANSFER_GAS_LIMIT}(\"\");\n        } else {\n            // We perform a low level call here, to bypass Solidity's return data size checking mechanism.\n            // Normally, the token is selected that the call would not revert unless out of gas.\n            bytes memory returnData;\n            (success, returnData) = token.call(abi.encodeCall(IERC20Upgradeable.transfer, (receiver, amount)));\n            if (success && returnData.length > 0) {\n                success = abi.decode(returnData, (bool));\n            }\n        }\n    }\n}"
    }
  ]
}