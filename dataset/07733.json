{
  "Title": "[09] Function Calls in Loop Could Lead to Denial of Service",
  "Content": "\nFunction calls made in unbounded loop are error-prone with potential resource exhaustion as it can trap the contract due to the gas limitations or failed transactions. Here are some of the instances entailed:\n\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/proxies/SeaportProxy.sol#L102\n\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/proxies/SeaportProxy.sol#L126\n\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/proxies/SeaportProxy.sol#L145\n\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/proxies/SeaportProxy.sol#L187\n\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/proxies/SeaportProxy.sol#L255\n\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/ERC20EnabledLooksRareAggregator.sol#L41\n\nConsider bounding the loop where possible to avoid unnecessary gas wastage and denial of service.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-11-looksrare",
  "Code": [
    {
      "filename": "contracts/proxies/SeaportProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {CollectionType} from \"../libraries/OrderEnums.sol\";\nimport {BasicOrder, FeeData} from \"../libraries/OrderStructs.sol\";\nimport {ItemType, OrderType} from \"../libraries/seaport/ConsiderationEnums.sol\";\nimport {AdvancedOrder, CriteriaResolver, OrderParameters, OfferItem, ConsiderationItem, FulfillmentComponent, AdditionalRecipient} from \"../libraries/seaport/ConsiderationStructs.sol\";\nimport {IProxy} from \"../interfaces/IProxy.sol\";\nimport {SeaportInterface} from \"../interfaces/SeaportInterface.sol\";\nimport {TokenRescuer} from \"../TokenRescuer.sol\";\n\n/**\n * @title SeaportProxy\n * @notice This contract allows NFT sweepers to batch buy NFTs from Seaport\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract SeaportProxy is IProxy, TokenRescuer {\n    SeaportInterface public immutable marketplace;\n    address public immutable aggregator;\n\n    error TradeExecutionFailed();\n\n    struct ExtraData {\n        FulfillmentComponent[][] offerFulfillments; // Contains the order and item index of each offer item\n        FulfillmentComponent[][] considerationFulfillments; // Contains the order and item index of each consideration item\n    }\n\n    struct OrderExtraData {\n        uint120 numerator; // A fraction to attempt to fill\n        uint120 denominator; // The total size of the order\n        OrderType orderType; // Seaport order type\n        address zone; // A zone can cancel the order or restrict who can fulfill the order depending on the type\n        bytes32 zoneHash; // An arbitrary 32-byte value that will be supplied to the zone when fulfilling restricted orders that the zone can utilize when making a determination on whether to authorize the order\n        uint256 salt; // An arbitrary source of entropy for the order\n        bytes32 conduitKey; // A bytes32 value that indicates what conduit, if any, should be utilized as a source for token approvals when performing transfers\n        AdditionalRecipient[] recipients; // Recipients of consideration items\n    }\n\n    /**\n     * @param _marketplace Seaport's address\n     * @param _aggregator LooksRareAggregator's address\n     */\n    constructor(address _marketplace, address _aggregator) {\n        marketplace = SeaportInterface(_marketplace);\n        aggregator = _aggregator;\n    }\n\n    /**\n     * @notice Execute Seaport NFT sweeps in a single transaction\n     * @param orders Orders to be executed by Seaport\n     * @param ordersExtraData Extra data for each order\n     * @param extraData Extra data for the whole transaction\n     * @param recipient The address to receive the purchased NFTs\n     * @param isAtomic Flag to enable atomic trades (all or nothing) or partial trades\n     * @param feeBp Fee basis point to pay for the trade, set by the aggregator\n     * @param feeRecipient Fee recipient for the trade, set by the aggregator\n     */\n    function execute(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes calldata extraData,\n        address recipient,\n        bool isAtomic,\n        uint256 feeBp,\n        address feeRecipient\n    ) external payable override {\n        if (address(this) != aggregator) revert InvalidCaller();\n\n        uint256 ordersLength = orders.length;\n        if (ordersLength == 0 || ordersLength != ordersExtraData.length) revert InvalidOrderLength();\n\n        if (isAtomic) {\n            _executeAtomicOrders(orders, ordersExtraData, extraData, recipient, feeBp, feeRecipient);\n        } else {\n            _executeNonAtomicOrders(orders, ordersExtraData, recipient, feeBp, feeRecipient);\n        }\n    }\n\n    /**\n     * @dev If fulfillAvailableAdvancedOrders fails, the ETH paid to Seaport\n     *      is refunded to the proxy contract. The proxy then has to refund\n     *      the ETH back to the user through _returnETHIfAny.\n     */\n    receive() external payable {}\n\n    function _executeAtomicOrders(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes calldata extraData,\n        address recipient,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        uint256 ordersLength = orders.length;\n        AdvancedOrder[] memory advancedOrders = new AdvancedOrder[](ordersLength);\n        ExtraData memory extraDataStruct = abi.decode(extraData, (ExtraData));\n\n        uint256 ethValue;\n\n        for (uint256 i; i < ordersLength; ) {\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n            advancedOrders[i].parameters = _populateParameters(orders[i], orderExtraData);\n            advancedOrders[i].numerator = orderExtraData.numerator;\n            advancedOrders[i].denominator = orderExtraData.denominator;\n            advancedOrders[i].signature = orders[i].signature;\n\n            if (orders[i].currency == address(0)) ethValue += orders[i].price;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        (bool[] memory availableOrders, ) = marketplace.fulfillAvailableAdvancedOrders{value: ethValue}(\n            advancedOrders,\n            new CriteriaResolver[](0),\n            extraDataStruct.offerFulfillments,\n            extraDataStruct.considerationFulfillments,\n            bytes32(0),\n            recipient,\n            ordersLength\n        );\n\n        for (uint256 i; i < availableOrders.length; ) {\n            if (!availableOrders[i]) revert TradeExecutionFailed();\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (feeRecipient != address(0)) _handleFees(orders, feeBp, feeRecipient);\n    }\n\n    function _handleFees(\n        BasicOrder[] calldata orders,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        address lastOrderCurrency;\n        uint256 fee;\n        uint256 ordersLength = orders.length;\n\n        for (uint256 i; i < ordersLength; ) {\n            address currency = orders[i].currency;\n            uint256 orderFee = (orders[i].price * feeBp) / 10000;\n\n            if (currency == lastOrderCurrency) {\n                fee += orderFee;\n            } else {\n                if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n\n                lastOrderCurrency = currency;\n                fee = orderFee;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n    }\n\n    function _transferFee(\n        uint256 fee,\n        address lastOrderCurrency,\n        address recipient\n    ) private {\n        if (lastOrderCurrency == address(0)) {\n            _transferETH(recipient, fee);\n        } else {\n            _executeERC20DirectTransfer(lastOrderCurrency, recipient, fee);\n        }\n    }\n\n    function _executeNonAtomicOrders(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        address recipient,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        uint256 fee;\n        address lastOrderCurrency;\n        for (uint256 i; i < orders.length; ) {\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n            AdvancedOrder memory advancedOrder;\n            advancedOrder.parameters = _populateParameters(orders[i], orderExtraData);\n            advancedOrder.numerator = orderExtraData.numerator;\n            advancedOrder.denominator = orderExtraData.denominator;\n            advancedOrder.signature = orders[i].signature;\n\n            address currency = orders[i].currency;\n            uint256 price = orders[i].price;\n\n            try\n                marketplace.fulfillAdvancedOrder{value: currency == address(0) ? price : 0}(\n                    advancedOrder,\n                    new CriteriaResolver[](0),\n                    bytes32(0),\n                    recipient\n                )\n            {\n                if (feeRecipient != address(0)) {\n                    uint256 orderFee = (price * feeBp) / 10000;\n                    if (currency == lastOrderCurrency) {\n                        fee += orderFee;\n                    } else {\n                        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n\n                        lastOrderCurrency = currency;\n                        fee = orderFee;\n                    }\n                }\n            } catch {}\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n    }\n\n    function _populateParameters(BasicOrder calldata order, OrderExtraData memory orderExtraData)\n        private\n        pure\n        returns (OrderParameters memory parameters)\n    {\n        uint256 recipientsLength = orderExtraData.recipients.length;\n\n        parameters.offerer = order.signer;\n        parameters.zone = orderExtraData.zone;\n        parameters.zoneHash = orderExtraData.zoneHash;\n        parameters.salt = orderExtraData.salt;\n        parameters.conduitKey = orderExtraData.conduitKey;\n        parameters.orderType = orderExtraData.orderType;\n        parameters.startTime = order.startTime;\n        parameters.endTime = order.endTime;\n        parameters.totalOriginalConsiderationItems = recipientsLength;\n\n        OfferItem[] memory offer = new OfferItem[](1);\n        // Seaport enums start with NATIVE and ERC20 so plus 2\n        offer[0].itemType = ItemType(uint8(order.collectionType) + 2);\n        offer[0].token = order.collection;\n        offer[0].identifierOrCriteria = order.tokenIds[0];\n        uint256 amount = order.amounts[0];\n        offer[0].startAmount = amount;\n        offer[0].endAmount = amount;\n        parameters.offer = offer;\n\n        ConsiderationItem[] memory consideration = new ConsiderationItem[](recipientsLength);\n        for (uint256 j; j < recipientsLength; ) {\n            // We don't need to assign value to identifierOrCriteria as it is always 0.\n            uint256 recipientAmount = orderExtraData.recipients[j].amount;\n            consideration[j].startAmount = recipientAmount;\n            consideration[j].endAmount = recipientAmount;\n            consideration[j].recipient = payable(orderExtraData.recipients[j].recipient);\n            consideration[j].itemType = order.currency == address(0) ? ItemType.NATIVE : ItemType.ERC20;\n            consideration[j].token = order.currency;\n\n            unchecked {\n                ++j;\n            }\n        }\n        parameters.consideration = consideration;\n    }\n}"
    },
    {
      "filename": "contracts/proxies/SeaportProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {CollectionType} from \"../libraries/OrderEnums.sol\";\nimport {BasicOrder, FeeData} from \"../libraries/OrderStructs.sol\";\nimport {ItemType, OrderType} from \"../libraries/seaport/ConsiderationEnums.sol\";\nimport {AdvancedOrder, CriteriaResolver, OrderParameters, OfferItem, ConsiderationItem, FulfillmentComponent, AdditionalRecipient} from \"../libraries/seaport/ConsiderationStructs.sol\";\nimport {IProxy} from \"../interfaces/IProxy.sol\";\nimport {SeaportInterface} from \"../interfaces/SeaportInterface.sol\";\nimport {TokenRescuer} from \"../TokenRescuer.sol\";\n\n/**\n * @title SeaportProxy\n * @notice This contract allows NFT sweepers to batch buy NFTs from Seaport\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract SeaportProxy is IProxy, TokenRescuer {\n    SeaportInterface public immutable marketplace;\n    address public immutable aggregator;\n\n    error TradeExecutionFailed();\n\n    struct ExtraData {\n        FulfillmentComponent[][] offerFulfillments; // Contains the order and item index of each offer item\n        FulfillmentComponent[][] considerationFulfillments; // Contains the order and item index of each consideration item\n    }\n\n    struct OrderExtraData {\n        uint120 numerator; // A fraction to attempt to fill\n        uint120 denominator; // The total size of the order\n        OrderType orderType; // Seaport order type\n        address zone; // A zone can cancel the order or restrict who can fulfill the order depending on the type\n        bytes32 zoneHash; // An arbitrary 32-byte value that will be supplied to the zone when fulfilling restricted orders that the zone can utilize when making a determination on whether to authorize the order\n        uint256 salt; // An arbitrary source of entropy for the order\n        bytes32 conduitKey; // A bytes32 value that indicates what conduit, if any, should be utilized as a source for token approvals when performing transfers\n        AdditionalRecipient[] recipients; // Recipients of consideration items\n    }\n\n    /**\n     * @param _marketplace Seaport's address\n     * @param _aggregator LooksRareAggregator's address\n     */\n    constructor(address _marketplace, address _aggregator) {\n        marketplace = SeaportInterface(_marketplace);\n        aggregator = _aggregator;\n    }\n\n    /**\n     * @notice Execute Seaport NFT sweeps in a single transaction\n     * @param orders Orders to be executed by Seaport\n     * @param ordersExtraData Extra data for each order\n     * @param extraData Extra data for the whole transaction\n     * @param recipient The address to receive the purchased NFTs\n     * @param isAtomic Flag to enable atomic trades (all or nothing) or partial trades\n     * @param feeBp Fee basis point to pay for the trade, set by the aggregator\n     * @param feeRecipient Fee recipient for the trade, set by the aggregator\n     */\n    function execute(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes calldata extraData,\n        address recipient,\n        bool isAtomic,\n        uint256 feeBp,\n        address feeRecipient\n    ) external payable override {\n        if (address(this) != aggregator) revert InvalidCaller();\n\n        uint256 ordersLength = orders.length;\n        if (ordersLength == 0 || ordersLength != ordersExtraData.length) revert InvalidOrderLength();\n\n        if (isAtomic) {\n            _executeAtomicOrders(orders, ordersExtraData, extraData, recipient, feeBp, feeRecipient);\n        } else {\n            _executeNonAtomicOrders(orders, ordersExtraData, recipient, feeBp, feeRecipient);\n        }\n    }\n\n    /**\n     * @dev If fulfillAvailableAdvancedOrders fails, the ETH paid to Seaport\n     *      is refunded to the proxy contract. The proxy then has to refund\n     *      the ETH back to the user through _returnETHIfAny.\n     */\n    receive() external payable {}\n\n    function _executeAtomicOrders(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes calldata extraData,\n        address recipient,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        uint256 ordersLength = orders.length;\n        AdvancedOrder[] memory advancedOrders = new AdvancedOrder[](ordersLength);\n        ExtraData memory extraDataStruct = abi.decode(extraData, (ExtraData));\n\n        uint256 ethValue;\n\n        for (uint256 i; i < ordersLength; ) {\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n            advancedOrders[i].parameters = _populateParameters(orders[i], orderExtraData);\n            advancedOrders[i].numerator = orderExtraData.numerator;\n            advancedOrders[i].denominator = orderExtraData.denominator;\n            advancedOrders[i].signature = orders[i].signature;\n\n            if (orders[i].currency == address(0)) ethValue += orders[i].price;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        (bool[] memory availableOrders, ) = marketplace.fulfillAvailableAdvancedOrders{value: ethValue}(\n            advancedOrders,\n            new CriteriaResolver[](0),\n            extraDataStruct.offerFulfillments,\n            extraDataStruct.considerationFulfillments,\n            bytes32(0),\n            recipient,\n            ordersLength\n        );\n\n        for (uint256 i; i < availableOrders.length; ) {\n            if (!availableOrders[i]) revert TradeExecutionFailed();\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (feeRecipient != address(0)) _handleFees(orders, feeBp, feeRecipient);\n    }\n\n    function _handleFees(\n        BasicOrder[] calldata orders,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        address lastOrderCurrency;\n        uint256 fee;\n        uint256 ordersLength = orders.length;\n\n        for (uint256 i; i < ordersLength; ) {\n            address currency = orders[i].currency;\n            uint256 orderFee = (orders[i].price * feeBp) / 10000;\n\n            if (currency == lastOrderCurrency) {\n                fee += orderFee;\n            } else {\n                if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n\n                lastOrderCurrency = currency;\n                fee = orderFee;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n    }\n\n    function _transferFee(\n        uint256 fee,\n        address lastOrderCurrency,\n        address recipient\n    ) private {\n        if (lastOrderCurrency == address(0)) {\n            _transferETH(recipient, fee);\n        } else {\n            _executeERC20DirectTransfer(lastOrderCurrency, recipient, fee);\n        }\n    }\n\n    function _executeNonAtomicOrders(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        address recipient,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        uint256 fee;\n        address lastOrderCurrency;\n        for (uint256 i; i < orders.length; ) {\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n            AdvancedOrder memory advancedOrder;\n            advancedOrder.parameters = _populateParameters(orders[i], orderExtraData);\n            advancedOrder.numerator = orderExtraData.numerator;\n            advancedOrder.denominator = orderExtraData.denominator;\n            advancedOrder.signature = orders[i].signature;\n\n            address currency = orders[i].currency;\n            uint256 price = orders[i].price;\n\n            try\n                marketplace.fulfillAdvancedOrder{value: currency == address(0) ? price : 0}(\n                    advancedOrder,\n                    new CriteriaResolver[](0),\n                    bytes32(0),\n                    recipient\n                )\n            {\n                if (feeRecipient != address(0)) {\n                    uint256 orderFee = (price * feeBp) / 10000;\n                    if (currency == lastOrderCurrency) {\n                        fee += orderFee;\n                    } else {\n                        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n\n                        lastOrderCurrency = currency;\n                        fee = orderFee;\n                    }\n                }\n            } catch {}\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n    }\n\n    function _populateParameters(BasicOrder calldata order, OrderExtraData memory orderExtraData)\n        private\n        pure\n        returns (OrderParameters memory parameters)\n    {\n        uint256 recipientsLength = orderExtraData.recipients.length;\n\n        parameters.offerer = order.signer;\n        parameters.zone = orderExtraData.zone;\n        parameters.zoneHash = orderExtraData.zoneHash;\n        parameters.salt = orderExtraData.salt;\n        parameters.conduitKey = orderExtraData.conduitKey;\n        parameters.orderType = orderExtraData.orderType;\n        parameters.startTime = order.startTime;\n        parameters.endTime = order.endTime;\n        parameters.totalOriginalConsiderationItems = recipientsLength;\n\n        OfferItem[] memory offer = new OfferItem[](1);\n        // Seaport enums start with NATIVE and ERC20 so plus 2\n        offer[0].itemType = ItemType(uint8(order.collectionType) + 2);\n        offer[0].token = order.collection;\n        offer[0].identifierOrCriteria = order.tokenIds[0];\n        uint256 amount = order.amounts[0];\n        offer[0].startAmount = amount;\n        offer[0].endAmount = amount;\n        parameters.offer = offer;\n\n        ConsiderationItem[] memory consideration = new ConsiderationItem[](recipientsLength);\n        for (uint256 j; j < recipientsLength; ) {\n            // We don't need to assign value to identifierOrCriteria as it is always 0.\n            uint256 recipientAmount = orderExtraData.recipients[j].amount;\n            consideration[j].startAmount = recipientAmount;\n            consideration[j].endAmount = recipientAmount;\n            consideration[j].recipient = payable(orderExtraData.recipients[j].recipient);\n            consideration[j].itemType = order.currency == address(0) ? ItemType.NATIVE : ItemType.ERC20;\n            consideration[j].token = order.currency;\n\n            unchecked {\n                ++j;\n            }\n        }\n        parameters.consideration = consideration;\n    }\n}"
    },
    {
      "filename": "contracts/proxies/SeaportProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {CollectionType} from \"../libraries/OrderEnums.sol\";\nimport {BasicOrder, FeeData} from \"../libraries/OrderStructs.sol\";\nimport {ItemType, OrderType} from \"../libraries/seaport/ConsiderationEnums.sol\";\nimport {AdvancedOrder, CriteriaResolver, OrderParameters, OfferItem, ConsiderationItem, FulfillmentComponent, AdditionalRecipient} from \"../libraries/seaport/ConsiderationStructs.sol\";\nimport {IProxy} from \"../interfaces/IProxy.sol\";\nimport {SeaportInterface} from \"../interfaces/SeaportInterface.sol\";\nimport {TokenRescuer} from \"../TokenRescuer.sol\";\n\n/**\n * @title SeaportProxy\n * @notice This contract allows NFT sweepers to batch buy NFTs from Seaport\n *         by passing high-level structs + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract SeaportProxy is IProxy, TokenRescuer {\n    SeaportInterface public immutable marketplace;\n    address public immutable aggregator;\n\n    error TradeExecutionFailed();\n\n    struct ExtraData {\n        FulfillmentComponent[][] offerFulfillments; // Contains the order and item index of each offer item\n        FulfillmentComponent[][] considerationFulfillments; // Contains the order and item index of each consideration item\n    }\n\n    struct OrderExtraData {\n        uint120 numerator; // A fraction to attempt to fill\n        uint120 denominator; // The total size of the order\n        OrderType orderType; // Seaport order type\n        address zone; // A zone can cancel the order or restrict who can fulfill the order depending on the type\n        bytes32 zoneHash; // An arbitrary 32-byte value that will be supplied to the zone when fulfilling restricted orders that the zone can utilize when making a determination on whether to authorize the order\n        uint256 salt; // An arbitrary source of entropy for the order\n        bytes32 conduitKey; // A bytes32 value that indicates what conduit, if any, should be utilized as a source for token approvals when performing transfers\n        AdditionalRecipient[] recipients; // Recipients of consideration items\n    }\n\n    /**\n     * @param _marketplace Seaport's address\n     * @param _aggregator LooksRareAggregator's address\n     */\n    constructor(address _marketplace, address _aggregator) {\n        marketplace = SeaportInterface(_marketplace);\n        aggregator = _aggregator;\n    }\n\n    /**\n     * @notice Execute Seaport NFT sweeps in a single transaction\n     * @param orders Orders to be executed by Seaport\n     * @param ordersExtraData Extra data for each order\n     * @param extraData Extra data for the whole transaction\n     * @param recipient The address to receive the purchased NFTs\n     * @param isAtomic Flag to enable atomic trades (all or nothing) or partial trades\n     * @param feeBp Fee basis point to pay for the trade, set by the aggregator\n     * @param feeRecipient Fee recipient for the trade, set by the aggregator\n     */\n    function execute(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes calldata extraData,\n        address recipient,\n        bool isAtomic,\n        uint256 feeBp,\n        address feeRecipient\n    ) external payable override {\n        if (address(this) != aggregator) revert InvalidCaller();\n\n        uint256 ordersLength = orders.length;\n        if (ordersLength == 0 || ordersLength != ordersExtraData.length) revert InvalidOrderLength();\n\n        if (isAtomic) {\n            _executeAtomicOrders(orders, ordersExtraData, extraData, recipient, feeBp, feeRecipient);\n        } else {\n            _executeNonAtomicOrders(orders, ordersExtraData, recipient, feeBp, feeRecipient);\n        }\n    }\n\n    /**\n     * @dev If fulfillAvailableAdvancedOrders fails, the ETH paid to Seaport\n     *      is refunded to the proxy contract. The proxy then has to refund\n     *      the ETH back to the user through _returnETHIfAny.\n     */\n    receive() external payable {}\n\n    function _executeAtomicOrders(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        bytes calldata extraData,\n        address recipient,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        uint256 ordersLength = orders.length;\n        AdvancedOrder[] memory advancedOrders = new AdvancedOrder[](ordersLength);\n        ExtraData memory extraDataStruct = abi.decode(extraData, (ExtraData));\n\n        uint256 ethValue;\n\n        for (uint256 i; i < ordersLength; ) {\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n            advancedOrders[i].parameters = _populateParameters(orders[i], orderExtraData);\n            advancedOrders[i].numerator = orderExtraData.numerator;\n            advancedOrders[i].denominator = orderExtraData.denominator;\n            advancedOrders[i].signature = orders[i].signature;\n\n            if (orders[i].currency == address(0)) ethValue += orders[i].price;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        (bool[] memory availableOrders, ) = marketplace.fulfillAvailableAdvancedOrders{value: ethValue}(\n            advancedOrders,\n            new CriteriaResolver[](0),\n            extraDataStruct.offerFulfillments,\n            extraDataStruct.considerationFulfillments,\n            bytes32(0),\n            recipient,\n            ordersLength\n        );\n\n        for (uint256 i; i < availableOrders.length; ) {\n            if (!availableOrders[i]) revert TradeExecutionFailed();\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (feeRecipient != address(0)) _handleFees(orders, feeBp, feeRecipient);\n    }\n\n    function _handleFees(\n        BasicOrder[] calldata orders,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        address lastOrderCurrency;\n        uint256 fee;\n        uint256 ordersLength = orders.length;\n\n        for (uint256 i; i < ordersLength; ) {\n            address currency = orders[i].currency;\n            uint256 orderFee = (orders[i].price * feeBp) / 10000;\n\n            if (currency == lastOrderCurrency) {\n                fee += orderFee;\n            } else {\n                if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n\n                lastOrderCurrency = currency;\n                fee = orderFee;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n    }\n\n    function _transferFee(\n        uint256 fee,\n        address lastOrderCurrency,\n        address recipient\n    ) private {\n        if (lastOrderCurrency == address(0)) {\n            _transferETH(recipient, fee);\n        } else {\n            _executeERC20DirectTransfer(lastOrderCurrency, recipient, fee);\n        }\n    }\n\n    function _executeNonAtomicOrders(\n        BasicOrder[] calldata orders,\n        bytes[] calldata ordersExtraData,\n        address recipient,\n        uint256 feeBp,\n        address feeRecipient\n    ) private {\n        uint256 fee;\n        address lastOrderCurrency;\n        for (uint256 i; i < orders.length; ) {\n            OrderExtraData memory orderExtraData = abi.decode(ordersExtraData[i], (OrderExtraData));\n            AdvancedOrder memory advancedOrder;\n            advancedOrder.parameters = _populateParameters(orders[i], orderExtraData);\n            advancedOrder.numerator = orderExtraData.numerator;\n            advancedOrder.denominator = orderExtraData.denominator;\n            advancedOrder.signature = orders[i].signature;\n\n            address currency = orders[i].currency;\n            uint256 price = orders[i].price;\n\n            try\n                marketplace.fulfillAdvancedOrder{value: currency == address(0) ? price : 0}(\n                    advancedOrder,\n                    new CriteriaResolver[](0),\n                    bytes32(0),\n                    recipient\n                )\n            {\n                if (feeRecipient != address(0)) {\n                    uint256 orderFee = (price * feeBp) / 10000;\n                    if (currency == lastOrderCurrency) {\n                        fee += orderFee;\n                    } else {\n                        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n\n                        lastOrderCurrency = currency;\n                        fee = orderFee;\n                    }\n                }\n            } catch {}\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (fee > 0) _transferFee(fee, lastOrderCurrency, feeRecipient);\n    }\n\n    function _populateParameters(BasicOrder calldata order, OrderExtraData memory orderExtraData)\n        private\n        pure\n        returns (OrderParameters memory parameters)\n    {\n        uint256 recipientsLength = orderExtraData.recipients.length;\n\n        parameters.offerer = order.signer;\n        parameters.zone = orderExtraData.zone;\n        parameters.zoneHash = orderExtraData.zoneHash;\n        parameters.salt = orderExtraData.salt;\n        parameters.conduitKey = orderExtraData.conduitKey;\n        parameters.orderType = orderExtraData.orderType;\n        parameters.startTime = order.startTime;\n        parameters.endTime = order.endTime;\n        parameters.totalOriginalConsiderationItems = recipientsLength;\n\n        OfferItem[] memory offer = new OfferItem[](1);\n        // Seaport enums start with NATIVE and ERC20 so plus 2\n        offer[0].itemType = ItemType(uint8(order.collectionType) + 2);\n        offer[0].token = order.collection;\n        offer[0].identifierOrCriteria = order.tokenIds[0];\n        uint256 amount = order.amounts[0];\n        offer[0].startAmount = amount;\n        offer[0].endAmount = amount;\n        parameters.offer = offer;\n\n        ConsiderationItem[] memory consideration = new ConsiderationItem[](recipientsLength);\n        for (uint256 j; j < recipientsLength; ) {\n            // We don't need to assign value to identifierOrCriteria as it is always 0.\n            uint256 recipientAmount = orderExtraData.recipients[j].amount;\n            consideration[j].startAmount = recipientAmount;\n            consideration[j].endAmount = recipientAmount;\n            consideration[j].recipient = payable(orderExtraData.recipients[j].recipient);\n            consideration[j].itemType = order.currency == address(0) ? ItemType.NATIVE : ItemType.ERC20;\n            consideration[j].token = order.currency;\n\n            unchecked {\n                ++j;\n            }\n        }\n        parameters.consideration = consideration;\n    }\n}"
    },
    {
      "filename": "contracts/proxies/SeaportProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {CollectionType} from \"../libraries/OrderEnums.sol\";\nimport {BasicOrder, FeeData} from \"../libraries/OrderStructs.sol\";\nimport {ItemType, OrderType} from \"../libraries/seaport/ConsiderationEnums.sol\";\nimport {AdvancedOrder, CriteriaResolver, OrderParameters, OfferItem, ConsiderationItem, FulfillmentComponent, AdditionalRecipient} from \"../libraries/seaport/ConsiderationStructs.sol\";\nimport {IProxy} from \"../interfaces/IProxy.sol\";\nimport {SeaportInterface} from \"../interfaces/SeaportInterface.sol\";\nimport {TokenRescuer} from \"../TokenRescuer.sol\";\n\n/**\n * @title SeaportProxy\n * @notice This contract allows NFT sweepers to batch"
    }
  ]
}