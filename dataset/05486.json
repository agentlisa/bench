{
  "Title": "[L-02] Set the price feeds during an initialization",
  "Content": "\nCurrently, the price feeds are set by using `updatePriceOracleFor()` after an `LRTOPracle` being deployed. However, it's better to set up everything during an initialization process.\n\n### Example of an occurrence\n\nCould be added, for instance, [here](https://github.com/code-423n4/2023-11-kelp/blob/main/src/LRTOracle.sol#L29-L35).\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-11-kelp",
  "Code": [
    {
      "filename": "src/LRTOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.21;\n\nimport { UtilLib } from \"./utils/UtilLib.sol\";\nimport { LRTConstants } from \"./utils/LRTConstants.sol\";\nimport { LRTConfigRoleChecker, ILRTConfig } from \"./utils/LRTConfigRoleChecker.sol\";\n\nimport { IRSETH } from \"./interfaces/IRSETH.sol\";\nimport { IPriceFetcher } from \"./interfaces/IPriceFetcher.sol\";\nimport { ILRTOracle } from \"./interfaces/ILRTOracle.sol\";\nimport { ILRTDepositPool } from \"./interfaces/ILRTDepositPool.sol\";\nimport { INodeDelegator } from \"./interfaces/INodeDelegator.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/// @title LRTOracle Contract\n/// @notice oracle contract that calculates the exchange rate of assets\ncontract LRTOracle is ILRTOracle, LRTConfigRoleChecker, PausableUpgradeable {\n    mapping(address asset => address priceOracle) public override assetPriceOracle;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract\n    /// @param lrtConfigAddr LRT config address\n    function initialize(address lrtConfigAddr) external initializer {\n        UtilLib.checkNonZeroAddress(lrtConfigAddr);\n        __Pausable_init();\n\n        lrtConfig = ILRTConfig(lrtConfigAddr);\n        emit UpdatedLRTConfig(lrtConfigAddr);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            view functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Provides Asset/ETH exchange rate\n    /// @dev reads from priceFetcher interface which may fetch price from any supported oracle\n    /// @param asset the asset for which exchange rate is required\n    /// @return assetPrice exchange rate of asset\n    function getAssetPrice(address asset) public view onlySupportedAsset(asset) returns (uint256) {\n        return IPriceFetcher(assetPriceOracle[asset]).getAssetPrice(asset);\n    }\n\n    /// @notice Provides RSETH/ETH exchange rate\n    /// @dev calculates based on stakedAsset value received from eigen layer\n    /// @return rsETHPrice exchange rate of RSETH\n    function getRSETHPrice() external view returns (uint256 rsETHPrice) {\n        address rsETHTokenAddress = lrtConfig.rsETH();\n        uint256 rsEthSupply = IRSETH(rsETHTokenAddress).totalSupply();\n\n        if (rsEthSupply == 0) {\n            return 1 ether;\n        }\n\n        uint256 totalETHInPool;\n        address lrtDepositPoolAddr = lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);\n\n        address[] memory supportedAssets = lrtConfig.getSupportedAssetList();\n        uint256 supportedAssetCount = supportedAssets.length;\n\n        for (uint16 asset_idx; asset_idx < supportedAssetCount;) {\n            address asset = supportedAssets[asset_idx];\n            uint256 assetER = getAssetPrice(asset);\n\n            uint256 totalAssetAmt = ILRTDepositPool(lrtDepositPoolAddr).getTotalAssetDeposits(asset);\n            totalETHInPool += totalAssetAmt * assetER;\n\n            unchecked {\n                ++asset_idx;\n            }\n        }\n\n        return totalETHInPool / rsEthSupply;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            write functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev add/update the price oracle of any supported asset\n    /// @dev only LRTManager is allowed\n    /// @param asset asset address for which oracle price needs to be added/updated\n    function updatePriceOracleFor(\n        address asset,\n        address priceOracle\n    )\n        external\n        onlyLRTManager\n        onlySupportedAsset(asset)\n    {\n        UtilLib.checkNonZeroAddress(priceOracle);\n        assetPriceOracle[asset] = priceOracle;\n        emit AssetPriceOracleUpdate(asset, priceOracle);\n    }\n\n    /// @dev Triggers stopped state. Contract must not be paused.\n    function pause() external onlyLRTManager {\n        _pause();\n    }\n\n    /// @dev Returns to normal state. Contract must be paused\n    function unpause() external onlyLRTAdmin {\n        _unpause();\n    }\n}"
    }
  ]
}