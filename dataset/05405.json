{
  "Title": "[M-13] Malicious lender can manipulate the fee to force borrower pay high premium",
  "Content": "\nWhen user creates a position, the fee is snapshot is queryed from uniswap v3 position manager when [preparing leverage](https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/libraries/Base.sol#L132)\n\n```solidity\n    function prepareLeverage(\n        uint256 tokenId,\n        uint128 liquidity,\n        bool zeroForOne\n    )\n        internal\n        view\n        returns (\n            address tokenFrom,\n            address tokenTo,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint256 collateralFrom,\n            uint256 collateralTo\n        )\n    {\n        int24 tickLower;\n        int24 tickUpper;\n        (\n            ,\n            ,\n            tokenFrom,\n            tokenTo,\n            ,\n            tickLower,\n            tickUpper,\n            ,\n            feeGrowthInside0LastX128,\n            feeGrowthInside1LastX128,\n            ,\n\n        ) = UNI_POSITION_MANAGER.positions(tokenId);\n```\n\nand stored in the lien struct\n\n```solidity\n// prepare data for swap\n(\n\tcache.tokenFrom,\n\tcache.tokenTo,\n\tcache.feeGrowthInside0LastX128,\n\tcache.feeGrowthInside1LastX128,\n\tcache.collateralFrom,\n\tcollateralTo\n) = Base.prepareLeverage(params.tokenId, params.liquidity, params.zeroForOne);\n```\n\nthen [stored in the liens struct](https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/protocol/ParticlePositionManager.sol#L247)\n\n```solidity\n// create a new lien\nliens[keccak256(abi.encodePacked(msg.sender, lienId = _nextRecordId++))] = Lien.Info({\n\ttokenId: uint40(params.tokenId), // @audit\n\tliquidity: params.liquidity,\n\ttoken0PremiumPortion: cache.token0PremiumPortion,\n\ttoken1PremiumPortion: cache.token1PremiumPortion,\n\tstartTime: uint32(block.timestamp),\n\tfeeGrowthInside0LastX128: cache.feeGrowthInside0LastX128,\n\tfeeGrowthInside1LastX128: cache.feeGrowthInside1LastX128,\n\tzeroForOne: params.zeroForOne\n});\n```\n\nthen when the position is closed, the [premium interested paid depends on the spot value of the fee](https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/protocol/ParticlePositionManager.sol#L442)\n\n```solidity\n// obtain the position's latest FeeGrowthInside after increaseLiquidity\n(, , , , , , , , cache.feeGrowthInside0LastX128, cache.feeGrowthInside1LastX128, , ) = Base\n\t.UNI_POSITION_MANAGER\n\t.positions(lien.tokenId);\n\n// caculate the amounts owed since last fee collection during the borrowing period\n(cache.token0Owed, cache.token1Owed) = Base.getOwedFee(\n\tcache.feeGrowthInside0LastX128,\n\tcache.feeGrowthInside1LastX128,\n\tlien.feeGrowthInside0LastX128,\n\tlien.feeGrowthInside1LastX128,\n\tlien.liquidity\n);\n```\n\nIf the fee increased during the position opening time, the premium is used to cover the fee to make sure there are incentive for lenders to deposit V3 NFT as lender.\n\nAs the comments point out:\n\n> // calculate the the amounts owed to LP up to the premium in the lien<br>\n> // must ensure enough amount is left to pay for interest first, then send gains and fund left to borrower\n\nHowever, because the fee amount is queried from position manager in spot value, malicious lender increase the liquidity to that ticker range and then can swap back and forth between ticker range to inflate the fee amount to force borrower pay high fee / high premium, while the lender has to pay the gas cost + uniswap trading fee.\n\nBut if the lender [adds more liquidity](https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/protocol/ParticlePositionManager.sol#L118) to nft's ticker range, he can collect the majority of the liqudity fee + collect high premium from borrower (or forcefully liquidated user to take premium).\n\n### Recommended Mitigation Steps\n\nIt is recommend to cap the premium interest payment instead of query spot fee amount to avoid swap fee manipulation.\n\n**[adriro (Warden) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/18#issuecomment-1867761631):**\n > The attack is quite impractical, the attacker would need to spend fees between all other LPs in range of the pool, so to get a small portion of it back.\n\n**[Ladboy233 (Warden) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/18#issuecomment-1867775137):**\n > Thanks for reviewing my submission @adriro\n> \n> > spend fees between all other LPs in range of the pool\n> \n> As the original report points out, the lender can always [add more liquidity](https://github.com/code-423n4/2023-12-particle/blob/a3af40839b24aa13f5764d4f84933dbfa8bc8134/contracts/protocol/ParticlePositionManager.sol#L118) to nft's ticker range to get more share of the fee.\n> \n> If he provides majority of the liquidity, he gets majority of the fee.\n> \n> So as long as the premium added by borrower > gas cost + uniswap trading fee, the borrower is forced to lose money and the lender loses nothing.\n\n**[wukong-particle commented](https://github.com/code-423n4/2023-12-particle-findings/issues/18#issuecomment-1868186767):**\n > I tend to agree with @adriro on the general direction here. But let's play out the scenario @ladboy233 outlined --\n> \n> So for the attacker to be profitable, the amount they earn from liquidating a position should outweigh the swapping fees they pay to all *other* LPs.\n> \n> Basically, Alice the attacker would need the fee generated in her borrowed liquidity to be more than the fee generated by all other LPs combined that cover her borrowed liquidity's tick range. Note that it should be other liquidity that \"cover\" the borrowed liquidity range (this even including full range).\n> \n> This basically requires Alice to be the absolute dominating LP on the entire pool. If that kind of whale is swimming in our protocol, well, I think smart traders will be cautious and that LP won't earn as much in the first place. Basically the incentive will be very low based on typical investment-return ratio.\n> \n> However, I do worry that some flash loan might have some attack angle -- flash loan enormous and outweigh other LPs. But that require the *borrowed* amount to outweigh other LPs, this doesn't seem to be doable with one tx flash loan. \n> \n> Along this line though, if there's other novel attack pattern, happy to discuss any time!\n\n**[Ladboy233 (Warden) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/18#issuecomment-1868283407):**\n > > So for the attacker to be profitable, the amount they earn from liquidating a position should outweigh the swapping fees they pay to all other LPs.\n> \n> Yes, premium collected > gas cost + uniswap trading fee + fee paid to all other LPs\n> \n> Lender cannot control how much premium borrowers add.\n> \n> But if lender see borrower's more premium is valuable\n> \n> > This basically requires Alice to be the absolute dominating LP on the entire pool. If that kind of whale is swimming in our protocol, well, I think smart traders will be cautious and that LP won't earn as much in the first place.\n> \n> Even if does not dominate the LP range in the beginning, he can always increase liquidity to dominate the LP range.\n\n**[wukong-particle (Particle) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2023-12-particle-findings/issues/18#issuecomment-1868469522):**\n > Acknowledge the issue because it's indeed a possible manipulation angle. But as the discussion goes above, this attack is very impractical, unless the LP is the absolute dominance. \n> \n> Also disagree with severity because such attack is not practical in economic terms.\n> \n> Will let the judge join the discussion and ultimately decide. Thanks!\n\n**[0xLeastwood (Judge) decreased severity to Medium](https://github.com/code-423n4/2023-12-particle-findings/issues/18#issuecomment-1868504895)**\n\n**[adriro (Warden) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/18#issuecomment-1872538901):**\n > @0xleastwood I'll reiterate my previous comment that this is impractical, there's no reason to perform this attack. Profitable conditions to trigger this attack are impossible in practice. Seems more on the QA side to me.\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-12-particle-findings/issues/18#issuecomment-1872945940):**\n > While the attack is impractical in most cases, it is not infeasible. The attacker stands to profit under certain conditions so keeping this as is.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-particle",
  "Code": [
    {
      "filename": "contracts/libraries/Base.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC20} from \"../../lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\";\nimport {FixedPoint128} from \"../../lib/v3-core/contracts/libraries/FixedPoint128.sol\";\nimport {IUniswapV3Pool} from \"../../lib/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {IUniswapV3Factory} from \"../../lib/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport {INonfungiblePositionManager} from \"../interfaces/INonfungiblePositionManager.sol\";\nimport {Errors} from \"./Errors.sol\";\nimport {FullMath} from \"./FullMath.sol\";\nimport {TickMath} from \"./TickMath.sol\";\nimport {LiquidityAmounts} from \"./LiquidityAmounts.sol\";\nimport {DataStruct, DataCache} from \"../libraries/Structs.sol\";\n\n/// @title Base Library\n/// @notice Contains internal helper functions for all contracts\nlibrary Base {\n    // solhint-disable private-vars-leading-underscore\n    address internal constant UNI_POSITION_MANAGER_ADDR = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88;\n    uint256 internal constant BASIS_POINT = 1_000_000;\n\n    INonfungiblePositionManager internal constant UNI_POSITION_MANAGER =\n        INonfungiblePositionManager(UNI_POSITION_MANAGER_ADDR);\n    IUniswapV3Factory internal constant UNI_FACTORY = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n\n    // solhint-enable private-vars-leading-underscore\n\n    /**\n     * @notice Swap at most `amountFrom` of `tokenFrom` for at least `amountToMinimum` of `tokenTo`\n     * @dev Caller must check for non-reentrancy and proper amount is deposited in\n     * @param tokenFrom address of token to swap from\n     * @param tokenTo address of token to swap to\n     * @param amountFrom amount of tokenFrom to swap\n     * @param amountToMinimum minimum amount of tokenTo to receive\n     * @param dexAggregator address of DEX aggregator to perform swapping\n     * @param data calldata bytes to pass into DEX aggregator to perform swapping\n     * @return amountSpent amount of tokenFrom spent\n     * @return amountReceived amount of tokenTo received\n     */\n    function swap(\n        address tokenFrom,\n        address tokenTo,\n        uint256 amountFrom,\n        uint256 amountToMinimum,\n        address dexAggregator,\n        bytes calldata data\n    ) internal returns (uint256 amountSpent, uint256 amountReceived) {\n        uint256 balanceFromBefore = IERC20(tokenFrom).balanceOf(address(this));\n        uint256 balanceToBefore = IERC20(tokenTo).balanceOf(address(this));\n\n        if (amountFrom > 0) {\n            ///@dev only allow amountFrom of tokenFrom to be spent by the DEX aggregator\n            TransferHelper.safeApprove(tokenFrom, dexAggregator, amountFrom);\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = dexAggregator.call(data);\n            if (!success) revert Errors.SwapFailed();\n            TransferHelper.safeApprove(tokenFrom, dexAggregator, 0);\n        }\n\n        amountSpent = balanceFromBefore - IERC20(tokenFrom).balanceOf(address(this));\n        amountReceived = IERC20(tokenTo).balanceOf(address(this)) - balanceToBefore;\n\n        if (amountReceived < amountToMinimum) revert Errors.InsufficientSwap();\n    }\n\n    /**\n     * @notice Helper function to refund a token\n     * @param recipient the address to receive the refund\n     * @param token address of token to potentially refund\n     * @param amountExpected amount of token0 expected to spend\n     * @param amountActual amount of token0 actually spent\n     */\n    function refund(address recipient, address token, uint256 amountExpected, uint256 amountActual) internal {\n        if (amountExpected > amountActual) {\n            TransferHelper.safeTransfer(token, recipient, amountExpected - amountActual);\n        }\n    }\n\n    /**\n     * @notice Helper function to refund a token, with additional check that amountActual must not exceed amountExpected\n     * @param recipient the address to receive the refund\n     * @param token address of token to potentially refund\n     * @param amountExpected amount of token0 expected to spend\n     * @param amountActual amount of token0 actually spent\n     */\n    function refundWithCheck(address recipient, address token, uint256 amountExpected, uint256 amountActual) internal {\n        if (amountActual > amountExpected) revert Errors.OverRefund();\n        refund(recipient, token, amountExpected, amountActual);\n    }\n\n    /**\n     * @notice Helper function to prepare data for leveraged swap\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param liquidity amount of liquidity to borrow out\n     * @param zeroForOne direction of the swap\n     * @return tokenFrom token to swap from\n     * @return tokenTo token to swap to\n     * @return feeGrowthInside0LastX128 the current fee growth of the aggregate position for token0\n     * @return feeGrowthInside1LastX128 the current fee growth of the aggregate position for token1\n     * @return collateralFrom amount of `tokenFrom` that `liquidity` concentrates to at its end\n     * @return collateralTo amount of `tokenTo` that `liquidity` concentrate to at its end\n     */\n    function prepareLeverage(\n        uint256 tokenId,\n        uint128 liquidity,\n        bool zeroForOne\n    )\n        internal\n        view\n        returns (\n            address tokenFrom,\n            address tokenTo,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint256 collateralFrom,\n            uint256 collateralTo\n        )\n    {\n        int24 tickLower;\n        int24 tickUpper;\n        (\n            ,\n            ,\n            tokenFrom,\n            tokenTo,\n            ,\n            tickLower,\n            tickUpper,\n            ,\n            feeGrowthInside0LastX128,\n            feeGrowthInside1LastX128,\n            ,\n\n        ) = UNI_POSITION_MANAGER.positions(tokenId);\n\n        (collateralFrom, collateralTo) = getRequiredCollateral(liquidity, tickLower, tickUpper);\n        if (!zeroForOne) {\n            (tokenFrom, tokenTo) = (tokenTo, tokenFrom);\n            (collateralFrom, collateralTo) = (collateralTo, collateralFrom);\n        }\n    }\n\n    /**\n     * @notice Calculates the amount of collateral needed when borrowing liquidity from a position\n     * @param liquidity amount of liquidity to borrow\n     * @param tickLower lower tick of the position\n     * @param tickUpper upper tick of the position\n     * @return amount0 amount that the liquidity concentrates to at tickLower\n     * @return amount1 amount that the liquidity concentrates to at tickHigher\n     */\n    function getRequiredCollateral(\n        uint128 liquidity,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n        uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n    }\n\n    function getRequiredRepay(\n        uint128 liquidity,\n        uint256 tokenId\n    ) internal view returns (uint256 amount0, uint256 amount1) {\n        DataCache.RepayCache memory repayCache;\n        (\n            ,\n            ,\n            repayCache.token0,\n            repayCache.token1,\n            repayCache.fee,\n            repayCache.tickLower,\n            repayCache.tickUpper,\n            ,\n            ,\n            ,\n            ,\n\n        ) = UNI_POSITION_MANAGER.positions(tokenId);\n        IUniswapV3Pool pool = IUniswapV3Pool(UNI_FACTORY.getPool(repayCache.token0, repayCache.token1, repayCache.fee));\n        (repayCache.sqrtRatioX96, , , , , , ) = pool.slot0();\n        repayCache.sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(repayCache.tickLower);\n        repayCache.sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(repayCache.tickUpper);\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            repayCache.sqrtRatioX96,\n            repayCache.sqrtRatioAX96,\n            repayCache.sqrtRatioBX96,\n            liquidity\n        );\n    }\n\n    /**\n     * @notice Get the current owed fees for a position\n     * @param params.tokenId tokenId of the liquidity position NFT\n     * @param params.liquidity amount of liquidity in the position\n     * @param params.feeGrowthInside0LastX128 the fee growth of the position for token0 as of the last fee update\n     * @param params.feeGrowthInside1LastX128 the fee growth of the position for token1 as of the last fee update\n     * @param params.token0PremiumPortion the portion of token0 premium locked in the lien\n     * @param params.token1PremiumPortion the portion of token1 premium locked in the lien\n     * @param zeroForOne direction of the swap\n     * @return tokenFrom  address of token to swap from at close position\n     * @return tokenTo address of token to swap to at close position\n     * @return tokenFromOwed amount owed to the liquidity provider for the token on the side of swap from\n     * @return tokenToOwed amount owed to the liquidity provider for the token on the side of swap to\n     * @return tokenFromPremium amount of premium for the token on the side of swap from\n     * @return tokenToPremium amount of premium for the token on the side of swap to\n     * @return collateralFrom amount of collateral for the token on the side of swap from\n     * @return collateralTo amount of collateral for the token on the side of swap to\n     */\n    function getOwedInfoConverted(\n        DataStruct.OwedInfoParams memory params,\n        bool zeroForOne\n    )\n        internal\n        view\n        returns (\n            address tokenFrom,\n            address tokenTo,\n            uint128 tokenFromOwed,\n            uint128 tokenToOwed,\n            uint128 tokenFromPremium,\n            uint128 tokenToPremium,\n            uint256 collateralFrom,\n            uint256 collateralTo\n        )\n    {\n        (\n            tokenFrom,\n            tokenTo,\n            tokenFromOwed,\n            tokenToOwed,\n            tokenFromPremium,\n            tokenToPremium,\n            collateralFrom,\n            collateralTo\n        ) = getOwedInfo(params);\n        if (zeroForOne) {\n            (tokenFrom, tokenTo) = (tokenTo, tokenFrom);\n            (tokenFromOwed, tokenToOwed) = (tokenToOwed, tokenFromOwed);\n            (tokenFromPremium, tokenToPremium) = (tokenToPremium, tokenFromPremium);\n            (collateralFrom, collateralTo) = (collateralTo, collateralFrom);\n        }\n    }\n\n    /**\n     * @notice Get the current owed fees for a position\n     * @param params.tokenId tokenId of the liquidity position NFT\n     * @param params.liquidity amount of liquidity in the position\n     * @param params.feeGrowthInside0LastX128 the fee growth of the position for token0 as of the last fee update\n     * @param params.feeGrowthInside1LastX128 the fee growth of the position for token1 as of the last fee update\n     * @param params.token0PremiumPortion the portion of token0 premium locked in the lien\n     * @param params.token1PremiumPortion the portion of token1 premium locked in the lien\n     * @return token0 address of token0\n     * @return token1 address of token1\n     * @return token0Owed amount of token0 owed to the liquidity provider\n     * @return token1Owed amount of token1 owed to the liquidity provider\n     * @return token0Premium amount of token0 premium locked in the lien\n     * @return token1Premium amount of token1 premium locked in the lien\n     * @return collateral0 amount of token0 required by the lp (if oneForZero)\n     * @return collateral1 amount of token1 required by the lp (if zeroForOne)\n     */\n    function getOwedInfo(\n        DataStruct.OwedInfoParams memory params\n    )\n        internal\n        view\n        returns (\n            address token0,\n            address token1,\n            uint128 token0Owed,\n            uint128 token1Owed,\n            uint128 token0Premium,\n            uint128 token1Premium,\n            uint256 collateral0,\n            uint256 collateral1\n        )\n    {\n        DataCache.OwedInfoCache memory cache;\n        (, , token0, token1, cache.fee, cache.tickLower, cache.tickUpper, , , , , ) = UNI_POSITION_MANAGER.positions(\n            params.tokenId\n        );\n        (cache.feeGrowthInside0X128, cache.feeGrowthInside1X128) = getFeeGrowthInside(\n            token0,\n            token1,\n            cache.fee,\n            cache.tickLower,\n            cache.tickUpper\n        );\n        (token0Owed, token1Owed) = getOwedFee(\n            cache.feeGrowthInside0X128,\n            cache.feeGrowthInside1X128,\n            params.feeGrowthInside0LastX128,\n            params.feeGrowthInside1LastX128,\n            params.liquidity\n        );\n        (collateral0, collateral1) = getRequiredCollateral(params.liquidity, cache.tickLower, cache.tickUpper);\n        (token0Premium, token1Premium) = getPremium(\n            collateral0,\n            collateral1,\n            params.token0PremiumPortion,\n            params.token1PremiumPortion\n        );\n    }\n\n    /**\n     * @notice Helper function to calculate the current feeGrothInside(0/1)X128 based on tickLower and tickUpper\n     * @dev feeGrowthInsideX128 calculation adopted from uniswap v3 periphery PositionValue\n     * @param token0 address of token0\n     * @param token1 address of token1\n     * @param fee fee level of the pool\n     * @param tickLower lower tick of the position\n     * @param tickUpper upper tick of the position\n     * @return feeGrowthInside0X128 the current fee growth of the position for token0\n     * @return feeGrowthInside1X128 the current fee growth of the position for token1\n     */\n    function getFeeGrowthInside(\n        address token0,\n        address token1,\n        uint24 fee,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {\n        IUniswapV3Pool pool = IUniswapV3Pool(UNI_FACTORY.getPool(token0, token1, fee));\n        (, int24 tickCurrent, , , , , ) = pool.slot0();\n        (, , uint256 lowerFeeGrowthOutside0X128, uint256 lowerFeeGrowthOutside1X128, , , , ) = pool.ticks(tickLower);\n        (, , uint256 upperFeeGrowthOutside0X128, uint256 upperFeeGrowthOutside1X128, , , , ) = pool.ticks(tickUpper);\n\n        if (tickCurrent < tickLower) {\n            feeGrowthInside0X128 = lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n        } else if (tickCurrent < tickUpper) {\n            uint256 feeGrowthGlobal0X128 = pool.feeGrowthGlobal0X128();\n            uint256 feeGrowthGlobal1X128 = pool.feeGrowthGlobal1X128();\n            feeGrowthInside0X128 = feeGrowthGlobal0X128 - lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = feeGrowthGlobal1X128 - lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n        } else {\n            feeGrowthInside0X128 = upperFeeGrowthOutside0X128 - lowerFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = upperFeeGrowthOutside1X128 - lowerFeeGrowthOutside1X128;\n        }\n    }\n\n    /**\n     * @notice Helper function to get the fee owed based on the current and last feeGrowthInside\n     * @param feeGrowthInside0X128 the current fee growth of the position for token0\n     * @param feeGrowthInside1X128 the current fee growth of the position for token1\n     * @param feeGrowthInside0LastX128 the fee growth of the position for token0 at the last borrow / fee collection\n     * @param feeGrowthInside1LastX128 the fee growth of the position for token1 at the last borrow / fee collection\n     * @param liquidity liquidity of the position\n     * @return token0Owed amount of token0 owed\n     * @return token1Owed amount of token1 owed\n     */\n    function getOwedFee(\n        uint256 feeGrowthInside0X128,\n        uint256 feeGrowthInside1X128,\n        uint256 feeGrowthInside0LastX128,\n        uint256 feeGrowthInside1LastX128,\n        uint128 liquidity\n    ) internal pure returns (uint128 token0Owed, uint128 token1Owed) {\n        if (feeGrowthInside0X128 > feeGrowthInside0LastX128) {\n            token0Owed = uint128(\n                FullMath.mulDiv(feeGrowthInside0X128 - feeGrowthInside0LastX128, liquidity, FixedPoint128.Q128)\n            );\n        }\n        if (feeGrowthInside1X128 > feeGrowthInside1LastX128) {\n            token1Owed = uint128(\n                FullMath.mulDiv(feeGrowthInside1X128 - feeGrowthInside1LastX128, liquidity, FixedPoint128.Q128)\n            );\n        }\n    }\n\n    /**\n     * @notice Helper function to get the premium amount based on the premium portion and collateral as base\n     * @param collateral0 the amount of collateral for token0\n     * @param collateral1 the amount of collateral for token1\n     * @param token0PremiumPortion the premium portion based on collateral0 and BASIS_POINT\n     * @param token1PremiumPortion the premium portion based on collateral1 and BASIS_POINT\n     * @return token0Premium amount of premium for token0\n     * @return token1Premium amount of premium for token1\n     */\n    function getPremium(\n        uint256 collateral0,\n        uint256 collateral1,\n        uint24 token0PremiumPortion,\n        uint24 token1PremiumPortion\n    ) internal pure returns (uint128 token0Premium, uint128 token1Premium) {\n        token0Premium = uint128((token0PremiumPortion * collateral0) / BASIS_POINT);\n        token1Premium = uint128((token1PremiumPortion * collateral1) / BASIS_POINT);\n    }\n\n    /**\n     * @notice Helper function to fit a non-overflow uint256 value to uint24\n     * @param value the uint256 value to fit\n     * @return result uint24 value that fits\n     */\n    function uint256ToUint24(uint256 value) internal pure returns (uint24 result) {\n        if (value > type(uint24).max) revert Errors.Overflow();\n        result = uint24(value);\n    }\n}"
    },
    {
      "filename": "contracts/protocol/ParticlePositionManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC721Receiver} from \"../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {Multicall} from \"../../lib/openzeppelin-contracts/contracts/utils/Multicall.sol\";\nimport {ReentrancyGuard} from \"../../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport {Ownable2StepUpgradeable} from \"../../lib/openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"../../lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport {IParticlePositionManager} from \"../interfaces/IParticlePositionManager.sol\";\nimport {Base} from \"../libraries/Base.sol\";\nimport {LiquidityPosition} from \"../libraries/LiquidityPosition.sol\";\nimport {Lien} from \"../libraries/Lien.sol\";\nimport {SwapPosition} from \"../libraries/SwapPosition.sol\";\nimport {DataStruct, DataCache} from \"../libraries/Structs.sol\";\nimport {Errors} from \"../libraries/Errors.sol\";\n\ncontract ParticlePositionManager is\n    IParticlePositionManager,\n    Ownable2StepUpgradeable,\n    UUPSUpgradeable,\n    IERC721Receiver,\n    ReentrancyGuard,\n    Multicall\n{\n    using LiquidityPosition for mapping(uint256 => LiquidityPosition.Info);\n    using Lien for mapping(bytes32 => Lien.Info);\n    using SwapPosition for mapping(bytes32 => SwapPosition.Info);\n\n    /* Constants */\n    uint256 private constant _TREASURY_RATE_MAX = 500_000;\n    uint256 private constant _FEE_FACTOR_MAX = 1_000;\n    uint128 private constant _LIQUIDATION_REWARD_FACTOR_MAX = 100_000;\n    uint256 private constant _LOAN_TERM_MAX = 30 days;\n\n    /* Variables */\n    uint96 private _nextRecordId; ///@dev used for both lien and swap\n    uint256 private _treasuryRate;\n    // solhint-disable var-name-mixedcase\n    address public DEX_AGGREGATOR;\n    uint256 public FEE_FACTOR;\n    uint128 public LIQUIDATION_REWARD_FACTOR;\n    uint256 public LOAN_TERM;\n    // solhint-enable var-name-mixedcase\n\n    /* Storage */\n    mapping(uint256 => LiquidityPosition.Info) public lps; ///@dev tokenId => liquidity position\n    mapping(bytes32 => Lien.Info) public liens; ///@dev (address, lienId) => lien\n    mapping(address => uint256) private _treasury; ///@dev address => amount\n\n    // required by openzeppelin UUPS module\n    // solhint-disable-next-line no-empty-blocks\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address dexAggregator,\n        uint256 feeFactor,\n        uint128 liquidationRewardFactor,\n        uint256 loanTerm,\n        uint256 treasuryRate\n    ) external initializer {\n        __UUPSUpgradeable_init();\n        __Ownable_init();\n        DEX_AGGREGATOR = dexAggregator;\n        FEE_FACTOR = feeFactor;\n        LIQUIDATION_REWARD_FACTOR = liquidationRewardFactor;\n        LOAN_TERM = loanTerm;\n        _treasuryRate = treasuryRate;\n    }\n\n    /*==============================================================\n                        Liquidity Provision Logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function mint(\n        DataStruct.MintParams calldata params\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 tokenId, uint128 liquidity, uint256 amount0Minted, uint256 amount1Minted)\n    {\n        (tokenId, liquidity, amount0Minted, amount1Minted) = lps.mint(params);\n    }\n\n    /**\n     * @notice Receiver function upon ERC721 LP position transfer\n     * @dev LP must use safeTransferFrom to trigger onERC721Received\n     * @param from the address which previously owned the NFT\n     * @param tokenId the NFT identifier which is being transferred\n     */\n    function onERC721Received(\n        address,\n        address from,\n        uint256 tokenId,\n        bytes calldata\n    ) external override returns (bytes4) {\n        if (msg.sender == Base.UNI_POSITION_MANAGER_ADDR) {\n            // matched with Uniswap v3 position NFTs\n            lps[tokenId] = LiquidityPosition.Info({owner: from, renewalCutoffTime: 0, token0Owed: 0, token1Owed: 0});\n            (, , , , , , , uint128 liquidity, , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n            emit LiquidityPosition.SupplyLiquidity(tokenId, from, liquidity);\n        }\n        return this.onERC721Received.selector;\n    }\n\n    /*==============================================================\n                       Liquidity Management Logic\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function increaseLiquidity(\n        uint256 tokenId,\n        uint256 amount0,\n        uint256 amount1\n    ) external override nonReentrant returns (uint128 liquidity, uint256 amount0Added, uint256 amount1Added) {\n        (liquidity, amount0Added, amount1Added) = lps.increaseLiquidity(tokenId, amount0, amount1);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function decreaseLiquidity(\n        uint256 tokenId,\n        uint128 liquidity\n    ) external override nonReentrant returns (uint256 amount0Decreased, uint256 amount1Decreased) {\n        (amount0Decreased, amount1Decreased) = lps.decreaseLiquidity(tokenId, liquidity);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function collectLiquidity(\n        uint256 tokenId\n    ) external override nonReentrant returns (uint256 amount0Collected, uint256 amount1Collected) {\n        (amount0Collected, amount1Collected) = lps.collectLiquidity(tokenId);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function reclaimLiquidity(uint256 tokenId) external override nonReentrant {\n        lps.reclaimLiquidity(tokenId);\n    }\n\n    /*=============================================================\n                             Open Position\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function openPosition(\n        DataStruct.OpenPositionParams calldata params\n    ) public override nonReentrant returns (uint96 lienId, uint256 collateralTo) {\n        if (params.liquidity == 0) revert Errors.InsufficientBorrow();\n\n        // local cache to avoid stack too deep\n        DataCache.OpenPositionCache memory cache;\n\n        // prepare data for swap\n        (\n            cache.tokenFrom,\n            cache.tokenTo,\n            cache.feeGrowthInside0LastX128,\n            cache.feeGrowthInside1LastX128,\n            cache.collateralFrom,\n            collateralTo\n        ) = Base.prepareLeverage(params.tokenId, params.liquidity, params.zeroForOne);\n\n        // decrease liquidity from LP position, pull the amount to this contract\n        (cache.amountFromBorrowed, cache.amountToBorrowed) = LiquidityPosition.decreaseLiquidity(\n            params.tokenId,\n            params.liquidity\n        );\n        LiquidityPosition.collectLiquidity(\n            params.tokenId,\n            uint128(cache.amountFromBorrowed),\n            uint128(cache.amountToBorrowed),\n            address(this)\n        );\n        if (!params.zeroForOne)\n            (cache.amountFromBorrowed, cache.amountToBorrowed) = (cache.amountToBorrowed, cache.amountFromBorrowed);\n\n        // transfer in enough collateral\n        if (params.marginFrom > 0) {\n            TransferHelper.safeTransferFrom(cache.tokenFrom, msg.sender, address(this), params.marginFrom);\n        }\n        if (params.marginTo > 0) {\n            TransferHelper.safeTransferFrom(cache.tokenTo, msg.sender, address(this), params.marginTo);\n        }\n\n        // pay for fee\n        if (FEE_FACTOR > 0) {\n            cache.feeAmount = ((params.marginFrom + cache.amountFromBorrowed) * FEE_FACTOR) / Base.BASIS_POINT;\n            cache.treasuryAmount = (cache.feeAmount * _treasuryRate) / Base.BASIS_POINT;\n            _treasury[cache.tokenFrom] += cache.treasuryAmount;\n            if (params.zeroForOne) {\n                lps.addTokensOwed(params.tokenId, uint128(cache.feeAmount - cache.treasuryAmount), 0);\n            } else {\n                lps.addTokensOwed(params.tokenId, 0, uint128(cache.feeAmount - cache.treasuryAmount));\n            }\n        }\n\n        // cannot swap more than available amount\n        if (params.amountSwap > params.marginFrom + cache.amountFromBorrowed - cache.feeAmount)\n            revert Errors.OverSpend();\n\n        // swap to meet the collateral requirement\n        (cache.amountSpent, cache.amountReceived) = Base.swap(\n            cache.tokenFrom,\n            cache.tokenTo,\n            params.amountSwap,\n            collateralTo - cache.amountToBorrowed - params.marginTo, // amount needed to meet requirement\n            DEX_AGGREGATOR,\n            params.data\n        );\n\n        // leftover amounts from the collateral are now premiums, and ensure enough premium is stored\n        if (params.zeroForOne) {\n            cache.token0PremiumPortion = Base.uint256ToUint24(\n                ((params.marginFrom + cache.amountFromBorrowed - cache.feeAmount - cache.amountSpent) *\n                    Base.BASIS_POINT) / cache.collateralFrom\n            );\n            cache.token1PremiumPortion = Base.uint256ToUint24(\n                ((cache.amountReceived + cache.amountToBorrowed + params.marginTo - collateralTo) * Base.BASIS_POINT) /\n                    collateralTo\n            );\n            if (\n                cache.token0PremiumPortion < params.tokenFromPremiumPortionMin ||\n                cache.token1PremiumPortion < params.tokenToPremiumPortionMin\n            ) revert Errors.InsufficientPremium();\n        } else {\n            cache.token1PremiumPortion = Base.uint256ToUint24(\n                ((params.marginFrom + cache.amountFromBorrowed - cache.feeAmount - cache.amountSpent) *\n                    Base.BASIS_POINT) / cache.collateralFrom\n            );\n            cache.token0PremiumPortion = Base.uint256ToUint24(\n                ((cache.amountReceived + cache.amountToBorrowed + params.marginTo - collateralTo) * Base.BASIS_POINT) /\n                    collateralTo\n            );\n            if (\n                cache.token0PremiumPortion < params.tokenToPremiumPortionMin ||\n                cache.token1PremiumPortion < params.tokenFromPremiumPortionMin\n            ) revert Errors.InsufficientPremium();\n        }\n\n        // create a new lien\n        liens[keccak256(abi.encodePacked(msg.sender, lienId = _nextRecordId++))] = Lien.Info({\n            tokenId: uint40(params.tokenId),\n            liquidity: params.liquidity,\n            token0PremiumPortion: cache.token0PremiumPortion,\n            token1PremiumPortion: cache.token1PremiumPortion,\n            startTime: uint32(block.timestamp),\n            feeGrowthInside0LastX128: cache.feeGrowthInside0LastX128,\n            feeGrowthInside1LastX128: cache.feeGrowthInside1LastX128,\n            zeroForOne: params.zeroForOne\n        });\n\n        emit OpenPosition(msg.sender, lienId, collateralTo);\n    }\n\n    /*=============================================================\n                             Close Position\n    ==============================================================*/\n\n    /// @inheritdoc IParticlePositionManager\n    function closePosition(DataStruct.ClosePositionParams calldata params) external override nonReentrant {\n        bytes32 lienKey = keccak256(abi.encodePacked(msg.sender, params.lienId));\n        Lien.Info memory lien = liens.getInfo(lienKey);\n\n        // check lien is valid\n        if (lien.liquidity == 0) revert Errors.RecordEmpty();\n\n        // delete lien from storage\n        delete liens[lienKey];\n\n        // local cache to avoid stack too deep\n        DataCache.ClosePositionCache memory cache;\n\n        // prepare data for swap back\n        ///@dev the token/collateralFrom and token/collateralTo are swapped compared to openPosition\n        (cache.tokenTo, cache.tokenFrom, , , cache.collateralTo, cache.collateralFrom) = Base.prepareLeverage(\n            lien.tokenId,\n            lien.liquidity,\n            lien.zeroForOne\n        );\n\n        // get the amount of premium in the lien\n        if (lien.zeroForOne) {\n            (cache.tokenToPremium, cache.tokenFromPremium) = Base.getPremium(\n                cache.collateralTo,\n                cache.collateralFrom,\n                lien.token0PremiumPortion,\n                lien.token1PremiumPortion\n            );\n        } else {\n            (cache.tokenFromPremium, cache.tokenToPremium) = Base.getPremium(\n                cache.collateralFrom,\n                cache.collateralTo,\n                lien.token0PremiumPortion,\n                lien.token1PremiumPortion\n            );\n        }\n\n        // execute actual position closing\n        _closePosition(params, cache, lien, msg.sender);\n\n        emit ClosePosition(msg.sender, lien.tokenId, cache.amountFromAdd, cache.amountToAdd);\n    }\n\n    /// @inheritdoc IParticlePositionManager\n    function liquidatePosition(\n        DataStruct.ClosePositionParams calldata params,\n        address borrower\n    ) external override nonReentrant {\n        bytes32 lienKey = keccak256(abi.encodePacked(borrower, params.lienId));\n        Lien.Info memory lien = liens.getInfo(lienKey);\n\n        // check lien is valid\n        if (lien.liquidity == 0) revert Errors.RecordEmpty();\n\n        // local cache to avoid stack too deep\n        DataCache.ClosePositionCache memory closeCache;\n        DataCache.LiquidatePositionCache memory liquidateCache;\n\n        // get liquidation parameters\n        ///@dev calculate premium outside of _closePosition to allow liquidatePosition to take reward from premium\n        (\n            closeCache.tokenFrom,\n            closeCache.tokenTo,\n            liquidateCache.tokenFromOwed,\n            liquidateCache.tokenToOwed,\n            closeCache.tokenFromPremium,\n            closeCache.tokenToPremium,\n            closeCache.collateralFrom,\n\n        ) = Base.getOwedInfoConverted(\n            DataStruct.OwedInfoParams({\n                tokenId: lien.tokenId,\n                liquidity: lien.liquidity,\n                feeGrowthInside0LastX128: lien.feeGrowthInside0LastX128,\n                feeGrowthInside1LastX128: lien.feeGrowthInside1LastX128,\n                token0PremiumPortion: lien.token0PremiumPortion,\n                token1PremiumPortion: lien.token1PremiumPortion\n            }),\n            lien.zeroForOne\n        );\n\n        // calculate liquidation reward\n        liquidateCache.liquidationRewardFrom =\n            ((closeCache.tokenFromPremium) * LIQUIDATION_REWARD_FACTOR) /\n            uint128(Base.BASIS_POINT);"
    }
  ]
}