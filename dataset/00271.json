{
  "Title": "M-2: Code asymmetry of `globalPositions.marginDepositedTotal`",
  "Content": "# Issue M-2: Code asymmetry of `globalPositions.marginDepositedTotal` \n\nSource: https://github.com/sherlock-audit/2024-03-flat-money-fix-review-contest-judging/issues/19 \n\n## Found by \nxiaoming90\n## Summary\n\nCode asymmetry of `globalPositions.marginDepositedTotal` state variable could lead to an accounting error within the protocol, leading to the protocol being broken. It will also lead to a loss of assets for the LP.\n\n## Vulnerability Detail\n\nThere is a code asymmetry issue in how the `globalPositions.marginDepositedTotal` is calculated within the `FlatcoinVault.settleFundingFees` and `FlatcoinVault.updateGlobalPositionData` functions.\n\nWithin the ``FlatcoinVault.settleFundingFees`` function, the `globalPositions.marginDepositedTotal` is allowed to go to negative. The reason for allowing this is mentioned in the code's comment `Once the underwater position is liquidated, then the funding fees will be reverted and the total will be positive again.` in Line 238 of the ``FlatcoinVault.settleFundingFees`` function. During the liquidation of the underwater position, the liquidation logic will re-adjust the negative `globalPositions.marginDepositedTotal` to be positive again.\n\nhttps://github.com/sherlock-audit/2024-03-flat-money-fix-review-contest/blob/main/flatcoin-v1/src/FlatcoinVault.sol#L224\n\n```solidity\nFile: FlatcoinVault.sol\n224:     function settleFundingFees() public returns (int256 _fundingFees) {\n..SNIP..\n234:         // Calculate the funding fees accrued to the longs.\n235:         // This will be used to adjust the global margin and collateral amounts.\n236:         _fundingFees = PerpMath._accruedFundingTotalByLongs(_globalPositions, unrecordedFunding);\n237: \n238:         // In the worst case scenario that the last position which remained open is underwater,\n239:         // We set the margin deposited total to negative. Once the underwater position is liquidated,\n240:         // then the funding fees will be reverted and the total will be positive again.\n241:         _globalPositions.marginDepositedTotal = _globalPositions.marginDepositedTotal + _fundingFees;\n242: \n243:         _updateStableCollateralTotal(-_fundingFees);\n244:     }\n```\n\nHowever, within the `FlatcoinVault.updateGlobalPositionData` functions, it operates differently where the `globalPositions.marginDepositedTotal` cannot become negative. If the value is negative, it will be set to zero, as seen in Line 191 of the `FlatcoinVault.updateGlobalPositionData` functions above.\n\nhttps://github.com/sherlock-audit/2024-03-flat-money-fix-review-contest/blob/main/flatcoin-v1/src/FlatcoinVault.sol#L175\n\n```solidity\nFile: FlatcoinVault.sol\n175:     function updateGlobalPositionData(\n176:         uint256 _price,\n177:         int256 _marginDelta,\n178:         int256 _additionalSizeDelta\n179:     ) external onlyAuthorizedModule {\n180:         // Note that technically, even the funding fees should be accounted for when computing the margin deposited total.\n181:         // However, since the funding fees are settled at the same time as the global position data is updated,\n182:         // we can ignore the funding fees here.\n183:         int256 newMarginDepositedTotal = _globalPositions.marginDepositedTotal + _marginDelta;\n184: \n185:         // Check that the sum of margin of all the leverage traders is not negative.\n186:         // Rounding errors shouldn't result in a negative margin deposited total given that\n187:         // we are rounding down the profit loss of the position.\n188:         // The margin may be negative if liquidations are not happening in a timely manner.\n189:         // In such a case, the system should continue to function as normal.\n190:         if (newMarginDepositedTotal < 0) {\n191:             newMarginDepositedTotal = 0;\n192:         }\n```\n\nThe misalignment of how the `globalPositions.marginDepositedTotal` should behave within different functions causes various issues within the protocol.\n\nConsider the following scenario to demonstrate one of the negative impacts.\n\n- Alice (LP) deposits 25 ETH and mints 25 UNIT\n- LP's `stableCollateralTotal` = 25 ETH\n- Bob (Trader) deposits 10 ETH as a margin and opens a long position with the size of 100 ETH (10x leverage)\n- `globalPositions.marginDepositedTotal` = 10 ETH (Consists of margin of Bob position)\n- Total ETH within the protocol = 35 ETH (25 + 10)\n\nAssume the accrued funding fee is 20 ETH, and the long traders must pay the LP (short). Note that these values are intentionally chosen or inflated to demonstrate the accounting/math error in the implementation, and they do not affect the validity of this issue.\n\nWhenever any of the transactions (e.g. announce or execute order, change protocol's parameters) within the protocol is executed, the following `FlatcoinVault.settleFundingFees` function will be executed to settle the global funding fees. In addition, the `FlatcoinVault.settleFundingFees` function is also permissionless and can be executed by anyone at any point in time.\n\nhttps://github.com/sherlock-audit/2024-03-flat-money-fix-review-contest/blob/main/flatcoin-v1/src/FlatcoinVault.sol#L224\n\n```solidity\nFile: FlatcoinVault.sol\n224:     function settleFundingFees() public returns (int256 _fundingFees) {\n225:         (int256 fundingChangeSinceRecomputed, int256 unrecordedFunding) = _getUnrecordedFunding();\n226: \n227:         // Record the funding rate change and update the cumulative funding rate.\n228:         cumulativeFundingRate = PerpMath._nextFundingEntry(unrecordedFunding, cumulativeFundingRate);\n229: \n230:         // Update the latest funding rate and the latest funding recomputation timestamp.\n231:         lastRecomputedFundingRate += fundingChangeSinceRecomputed;\n232:         lastRecomputedFundingTimestamp = (block.timestamp).toUint64();\n233: \n234:         // Calculate the funding fees accrued to the longs.\n235:         // This will be used to adjust the global margin and collateral amounts.\n236:         _fundingFees = PerpMath._accruedFundingTotalByLongs(_globalPositions, unrecordedFunding);\n237: \n238:         // In the worst case scenario that the last position which remained open is underwater,\n239:         // We set the margin deposited total to negative. Once the underwater position is liquidated,\n240:         // then the funding fees will be reverted and the total will be positive again.\n241:         _globalPositions.marginDepositedTotal = _globalPositions.marginDepositedTotal + _fundingFees;\n242: \n243:         _updateStableCollateralTotal(-_fundingFees);\n244:     }\n```\n\nAssume that the `FlatcoinVault.settleFundingFees` function is executed at this point. Line 241 above will be evaluated as follows. The `globalPositions.marginDepositedTotal` will be updated to -10 ETH.\n\n```solidity\n_globalPositions.marginDepositedTotal = _globalPositions.marginDepositedTotal + _fundingFees;\n_globalPositions.marginDepositedTotal = 10 ETH + (-20 ETH) = -10 ETH\n```\n\nIn the comments in Lines 238-240 above within the `FlatcoinVault.settleFundingFees` function, it expects the liquidation process to re-adjust back the `globalPositions.marginDepositedTotal` to positive or the correct value later.\n\nAssume that a liquidation is executed. The `vault.updateGlobalPositionData` function at Line 150 within the  `LiquidationModule.liquidate` function below will be executed, and the value of `marginDelta` parameter will be as follows:\n\n```solidity\nmarginDelta = -(int256(position.marginDeposited) + positionSummary.accruedFunding)\nmarginDelta = -(10 ETH + (-20 ETH))\nmarginDelta = -(-10 ETH)\nmarginDelta = +10 ETH\n```\nhttps://github.com/sherlock-audit/2024-03-flat-money-fix-review-contest/blob/main/flatcoin-v1/src/LiquidationModule.sol#L150\n```solidity\nFile: LiquidationModule.sol\n074:     function liquidate(\n..SNIP..\n149:         // Update the global leverage position data.\n150:         vault.updateGlobalPositionData({\n151:             price: position.averagePrice,\n152:             marginDelta: -(int256(position.marginDeposited) + positionSummary.accruedFunding),\n153:             additionalSizeDelta: -int256(position.additionalSize) // Since position is being closed, additionalSizeDelta should be negative.\n154:         });\n```\n\nWithin the `updateGlobalPositionData` function below, Line 183 will evaluate as follows:\n\n```solidity\nnewMarginDepositedTotal = _globalPositions.marginDepositedTotal + _marginDelta;\nnewMarginDepositedTotal = -10 + (+10) = 0\n```\n\nThis is aligned with the earlier code's comments (`Once the underwater position is liquidated, then the funding fees will be reverted and the total will be positive again.`) as the `globalPositions.marginDepositedTotal` indeed is restored back to the positive and correct value after the re-adjustment.\n\nhttps://github.com/sherlock-audit/2024-03-flat-money-fix-review-contest/blob/main/flatcoin-v1/src/FlatcoinVault.sol#L175\n\n```solidity\nFile: FlatcoinVault.sol\n175:     function updateGlobalPositionData(\n176:         uint256 _price,\n177:         int256 _marginDelta,\n178:         int256 _additionalSizeDelta\n179:     ) external onlyAuthorizedModule {\n180:         // Note that technically, even the funding fees should be accounted for when computing the margin deposited total.\n181:         // However, since the funding fees are settled at the same time as the global position data is updated,\n182:         // we can ignore the funding fees here.\n183:         int256 newMarginDepositedTotal = _globalPositions.marginDepositedTotal + _marginDelta;\n```\n\nUnfortunately, in reality, the execution of the `settleFundingFees` function is not always followed by the execution of the liquidation logic. Thus, the logic code expect the liquidation process executed later to always re-adjust the `globalPositions.marginDepositedTotal` value back to the intended value.\n\nLet's assume another scenario. Assume that after the `FlatcoinVault.settleFundingFees` function is executed, someone triggers an action (e.g., open, adjust, close order) that executes the `updateGlobalPositionData` function instead of the liquidation. Assume that the `_marginDelta` is insignificant in the following:\n\nhttps://github.com/sherlock-audit/2024-03-flat-money-fix-review-contest/blob/main/flatcoin-v1/src/FlatcoinVault.sol#L175\n\n```solidity\nFile: FlatcoinVault.sol\n175:     function updateGlobalPositionData(\n176:         uint256 _price,\n177:         int256 _marginDelta,\n178:         int256 _additionalSizeDelta\n179:     ) external onlyAuthorizedModule {\n180:         // Note that technically, even the funding fees should be accounted for when computing the margin deposited total.\n181:         // However, since the funding fees are settled at the same time as the global position data is updated,\n182:         // we can ignore the funding fees here.\n183:         int256 newMarginDepositedTotal = _globalPositions.marginDepositedTotal + _marginDelta;\n..SNIP..\n190:         if (newMarginDepositedTotal < 0) {\n191:             newMarginDepositedTotal = 0;\n192:         }\n```\n\nWhen Line 190 above is executed, since ``globalPositions.marginDepositedTotal`` is negative (-10 ETH), it will be reset to zero. This is an issue because the code earlier assumes that the liquidation process will help to re-adjust the negative value. However, over here, the state has been wiped out.\n\nWhen the liquidation is executed subsequently, the `marginDelta` will be `+10 ETH`, similar to the earlier scenario.\n\nhttps://github.com/sherlock-audit/2024-03-flat-money-fix-review-contest/blob/main/flatcoin-v1/src/LiquidationModule.sol#L150\n\n```solidity\nFile: LiquidationModule.sol\n074:     function liquidate(\n..SNIP..\n149:         // Update the global leverage position data.\n150:         vault.updateGlobalPositionData({\n151:             price: position.averagePrice,\n152:             marginDelta: -(int256(position.marginDeposited) + positionSummary.accruedFunding),\n153:             additionalSizeDelta: -int256(position.additionalSize) // Since position is being closed, additionalSizeDelta should be negative.\n154:         });\n```\n\nWithin the `updateGlobalPositionData` function, the `globalPositions.marginDepositedTotal` will be set to as follows:\n\n```solidity\nnewMarginDepositedTotal = _globalPositions.marginDepositedTotal + _marginDelta\nnewMarginDepositedTotal = 0 + (+10 ETH)\nnewMarginDepositedTotal = 10 ETH\n```\nhttps://github.com/sherlock-audit/2024-03-flat-money-fix-review-contest/blob/main/flatcoin-v1/src/FlatcoinVault.sol#L175\n```solidity\nFile: FlatcoinVault.sol\n175:     function updateGlobalPositionData(\n176:         uint256 _price,\n177:         int256 _marginDelta,\n178:         int256 _additionalSizeDelta\n179:     ) external onlyAuthorizedModule {\n180:         // Note that technically, even the funding fees should be accounted for when computing the margin deposited total.\n181:         // However, since the funding fees are settled at the same time as the global position data is updated,\n182:         // we can ignore the funding fees here.\n183:         int256 newMarginDepositedTotal = _globalPositions.marginDepositedTotal + _marginDelta;\n```\n\nAt the end of the liquidation, the long trader side, which had lost all its margin earlier, regained 10 ETH, which is incorrect and shows an error in the protocol's accounting. \n\nThe `globalPositions.marginDepositedTotal` is also inflated and not backed by any assets. The system will wrongly assume that there are `globalPositions.marginDepositedTotal`, while in reality, there is none. This results in the system continuing to transfer collateral assets to the LP when settling funding fees when there are none. The LP will receive collateral credit backed by no assets, leading to a loss of assets for them.\n\n## Impact\n\nThe `marginDepositedTotal` state is the key variable in the protocol's account system, and its value will be incorrect, leading to the protocol being broken. It will also lead to a loss of assets for the LP.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-03-flat-money-fix-review-contest/blob/main/flatcoin-v1/src/FlatcoinVault.sol#L224\n\nhttps://github.com/sherlock-audit/2024-03-flat-money-fix-review-contest/blob/main/flatcoin-v1/src/FlatcoinVault.sol#L175\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure that the behavior of `globalPositions.marginDepositedTotal` (whether it can go negative) is consistent throughout the codebase to prevent any error from occurring.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**santipu_** commented:\n> Medium\n\n\n\n**itsermin**\n\nYes, it looks like when `marginDepositedTotal` is negative, opening a new leverage position can break an invariant because of setting it to 0 on `updateGlobalPositionData`.\n\nBy removing this line (not zeroing a negative `marginDepositedTotal`), the system is able to handle the scenario.\n\n**santipu03**\n\nEscalate\n\nI believe this issue to be medium severity due to the low probability of happening. \n\nFor this bug to be triggered it needs the value of `globalPositions.marginDepositedTotal` to be negative. These scenarios can cause it:\n1. The total debt of the positions on the market becomes bigger than the total deposited margin.\n2. The funding fee becomes bigger than the total deposited margin.\n3. A combination of both scenarios above.\n\nScenario 1 is highly unlikely to happen because insolvent positions would have been liquidated before their debt became bigger than the total deposited margin on the market. Moreover, in a volatile market, the protocol team can adjust the value of `liquidationBufferRatio` to ensure that even sharp price movements don't cause positions to get underwater. \n\nScenario 2 is also highly unlikely to happen because when the funding fee is so big, it's expected that the market will regulate itself, bringing the skew back to zero and decreasing the funding fees. Even if the funding fee starts to rapidly decrease the margins of the positions, liquidators will step up and liquidate those underwater positions before bad debt is accrued. \n\nGiven the low probability of this bug happening, I think it deserves medium severity. \n\n**sherlock-admin2**\n\n> Escalate\n> \n> I believe this issue to be medium severity due to the low probability of happening. \n> \n> For this bug to be triggered it needs the value of `globalPositions.marginDepositedTotal` to be negative. These scenarios can cause it:\n> 1. The total debt of the positions on the market becomes bigger than the total deposited margin.\n> 2. The funding fee becomes bigger than the total deposited margin.\n> 3. A combination of both scenarios above.\n> \n> Scenario 1 is highly unlikely to happen because insolvent positions would have been liquidated before their debt became bigger than the total deposited margin on the market. Moreover, in a volatile market, the protocol team can adjust the value of `liquidationBufferRatio` to ensure that even sharp price movements don't cause positions to get underwater. \n> \n> Scenario 2 is also highly unlikely to happen because when the funding fee is so big, it's expected that the market will regulate itself, bringing the skew back to zero and decreasing the funding fees. Even if the funding fee starts to rapidly decrease the margins of the positions, liquidators will step up and liquidate those underwater positions before bad debt is accrued. \n> \n> Given the low probability of this bug happening, I think it deserves medium severity. \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cvetanovv**\n\nI agree with the low probability, but when it happens it definitely hits the High category on both points according to the rules:\n> - Definite loss of funds without (extensive) limitations of external conditions.\n> - Inflicts serious non-material losses.\n\n**santipu03**\n\nThe README states that the protocol is running liquidators, so it's assumed that unhealthy positions are going to be liquidated on time and bad debt is not going to be created: \n\n> Are there any off-chain mechanisms or off-chain procedures for the protocol (keeper bots, arbitrage bots, etc.)?\n> - There are keepers for order execution and liquidations. [...]\n\nI'd say that this itself is an extensive limitation for this issue to happen. \n\n**WangSecurity**\n\nEven though the protocol will be using keepers for order execution and liquidations, it doesn't ensure that every liquidatable position will be liquidated. Despite that fact, the issue will happen in the scenarios listend in the escalation comment [here](https://github.com/sherlock-audit/2024-03-flat-money-fix-review-contest-judging/issues/19#issuecomment-2070851874), hence, I believe medium is appropriate here cause it requires specific states, and loss is highly constrained:\n\n> Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained.\n\nPlanning to accept the escalation and downgrade the issue to Medium.\n\n**Evert0x**\n\nResult:\nMedium\nUnique \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [santipu03](https://github.com/sherlock-audit/2024-03-flat-money-fix-review-contest-judging/issues/19/#issuecomment-2070851874): accepted\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/dhedge/flatcoin-v1/pull/344\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/287",
  "Code": [
    {
      "filename": "flatcoin-v1/src/FlatcoinVault.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.20;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\n\n/// @title FlatcoinVault\n/// @author dHEDGE\n/// @notice Contains state to be reused by different modules of the system.\n/// @dev Holds the stable LP deposits and leverage traders' collateral amounts.\n///      Also stores other related contract address pointers.\ncontract FlatcoinVault is IFlatcoinVault, OwnableUpgradeable {\n    using SafeCast for *;\n    using SafeERC20 for IERC20;\n\n    /// @notice The collateral token address.\n    IERC20 public collateral;\n\n    /// @notice The last market skew recomputation timestamp.\n    uint64 public lastRecomputedFundingTimestamp;\n\n    /// @notice The minimum time that needs to expire between trade announcement and execution.\n    uint64 public minExecutabilityAge;\n\n    /// @notice The maximum amount of time that can expire between trade announcement and execution.\n    uint64 public maxExecutabilityAge;\n\n    /// @notice The last recomputed funding rate.\n    int256 public lastRecomputedFundingRate;\n\n    /// @notice Sum of funding rate over the entire lifetime of the market.\n    int256 public cumulativeFundingRate;\n\n    /// @notice Total collateral deposited by users minting the flatcoin.\n    /// @dev This value is adjusted due to funding fee payments.\n    uint256 public stableCollateralTotal;\n\n    /// @notice The maximum funding velocity used to limit the funding rate fluctuations.\n    /// @dev Funding velocity is used for calculating the current funding rate and acts as\n    ///      a limit on how much the funding rate can change between funding re-computations.\n    ///      The units are %/day (1e18 = 100% / day at max or min skew).\n    uint256 public maxFundingVelocity;\n\n    /// @notice The skew percentage at which the funding rate velocity is at its maximum.\n    /// @dev When absolute pSkew > maxVelocitySkew, then funding velocity = maxFundingVelocity.\n    ///      The units are in % (0.1e18 = 10% skew)\n    uint256 public maxVelocitySkew;\n\n    /// @notice Maximum cap on the total stable LP deposits.\n    uint256 public stableCollateralCap;\n\n    /// @notice The maximum limit of total leverage long size vs stable LP.\n    /// @dev This prevents excessive short skew of stable LPs by capping long trader total open interest.\n    ///      Care needs to be taken when increasing this value as it can lead to the stable LPs being excessively short.\n    uint256 public skewFractionMax;\n\n    /// @notice Holds mapping between module keys and module addresses.\n    ///         A module key is a keccak256 hash of the module name.\n    /// @dev Make sure that a module key is created using the following format:\n    ///      moduleKey = bytes32(<MODULE_NAME>)\n    ///      All the module keys should reside in a single file (see FlatcoinModuleKeys.sol).\n    mapping(bytes32 moduleKey => address moduleAddress) public moduleAddress;\n\n    /// @notice Holds mapping between module addresses and their authorization status.\n    mapping(address moduleAddress => bool authorized) public isAuthorizedModule;\n\n    /// @notice Holds mapping between module keys and their pause status.\n    mapping(bytes32 moduleKey => bool paused) public isModulePaused;\n\n    /// @dev Tracks global totals of leverage trade positions to be able to:\n    ///      - price stable LP value.\n    ///      - calculate the funding rate.\n    ///      - calculate the skew.\n    ///      - calculate funding fees payments.\n    FlatcoinStructs.GlobalPositions internal _globalPositions;\n\n    /// @dev Holds mapping between user addresses and their leverage positions.\n    mapping(uint256 tokenId => FlatcoinStructs.Position userPosition) internal _positions;\n\n    modifier onlyAuthorizedModule() {\n        if (isAuthorizedModule[msg.sender] == false) revert FlatcoinErrors.OnlyAuthorizedModule(msg.sender);\n        _;\n    }\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    ///      function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    /// @param _collateral The collateral token address.\n    /// @param _maxFundingVelocity The maximum funding velocity used to limit the funding rate fluctuations.\n    /// @param _maxVelocitySkew The skew percentage at which the funding rate velocity is at its maximum.\n    /// @param _skewFractionMax The maximum limit of total leverage long size vs stable LP.\n    /// @param _stableCollateralCap The maximum cap on the total stable LP deposits.\n    /// @param _minExecutabilityAge The minimum time that needs to expire between trade announcement and execution.\n    /// @param _maxExecutabilityAge The maximum amount of time that can expire between trade announcement and execution.\n    function initialize(\n        IERC20 _collateral,\n        uint256 _maxFundingVelocity,\n        uint256 _maxVelocitySkew,\n        uint256 _skewFractionMax,\n        uint256 _stableCollateralCap,\n        uint64 _minExecutabilityAge,\n        uint64 _maxExecutabilityAge\n    ) external initializer {\n        if (address(_collateral) == address(0)) revert FlatcoinErrors.ZeroAddress(\"collateral\");\n        if (_skewFractionMax < 1e18) revert FlatcoinErrors.InvalidSkewFractionMax(_skewFractionMax);\n        if (_maxVelocitySkew > 1e18 || _maxVelocitySkew == 0)\n            revert FlatcoinErrors.InvalidMaxVelocitySkew(_maxVelocitySkew);\n        if (_minExecutabilityAge == 0 || _maxExecutabilityAge == 0)\n            revert FlatcoinErrors.ZeroValue(\"minExecutabilityAge|maxExecutabilityAge\");\n\n        __Ownable_init(msg.sender);\n\n        collateral = _collateral;\n        maxFundingVelocity = _maxFundingVelocity;\n        maxVelocitySkew = _maxVelocitySkew;\n        stableCollateralCap = _stableCollateralCap;\n        skewFractionMax = _skewFractionMax;\n        minExecutabilityAge = _minExecutabilityAge;\n        maxExecutabilityAge = _maxExecutabilityAge;\n    }\n\n    /////////////////////////////////////////////\n    //            Module Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Collateral can only be withdrawn by the flatcoin contracts (Delayed Orders, Stable or Leverage module).\n    function sendCollateral(address to, uint256 amount) external onlyAuthorizedModule {\n        collateral.safeTransfer(to, amount);\n    }\n\n    /// @notice Function to set the position of a leverage trader.\n    /// @dev This function is only callable by the authorized modules.\n    /// @param _newPosition The new struct encoded position of the leverage trader.\n    /// @param _tokenId The token ID of the leverage trader.\n    function setPosition(\n        FlatcoinStructs.Position calldata _newPosition,\n        uint256 _tokenId\n    ) external onlyAuthorizedModule {\n        _positions[_tokenId] = _newPosition;\n    }\n\n    /// @notice Function to delete the position of a leverage trader.\n    /// @dev This function is only callable by the authorized modules.\n    /// @param _tokenId The token ID of the leverage trader.\n    function deletePosition(uint256 _tokenId) external onlyAuthorizedModule {\n        delete _positions[_tokenId];\n    }\n\n    /// @notice Function to update the stable collateral total.\n    /// @dev This function is only callable by the authorized modules.\n    ///      When `_stableCollateralAdjustment` is negative, it means that the stable collateral total is decreasing.\n    /// @param _stableCollateralAdjustment The adjustment to the stable collateral total.\n    function updateStableCollateralTotal(int256 _stableCollateralAdjustment) external onlyAuthorizedModule {\n        _updateStableCollateralTotal(_stableCollateralAdjustment);\n    }\n\n    /// @notice Function to update the global position data.\n    /// @dev This function is only callable by the authorized modules.\n    /// @param _price The current price of the underlying asset.\n    /// @param _marginDelta The change in the margin deposited total.\n    /// @param _additionalSizeDelta The change in the size opened total.\n    function updateGlobalPositionData(\n        uint256 _price,\n        int256 _marginDelta,\n        int256 _additionalSizeDelta\n    ) external onlyAuthorizedModule {\n        // Note that technically, even the funding fees should be accounted for when computing the margin deposited total.\n        // However, since the funding fees are settled at the same time as the global position data is updated,\n        // we can ignore the funding fees here.\n        int256 newMarginDepositedTotal = _globalPositions.marginDepositedTotal + _marginDelta;\n\n        // Check that the sum of margin of all the leverage traders is not negative.\n        // Rounding errors shouldn't result in a negative margin deposited total given that\n        // we are rounding down the profit loss of the position.\n        // The margin may be negative if liquidations are not happening in a timely manner.\n        // In such a case, the system should continue to function as normal.\n        if (newMarginDepositedTotal < 0) {\n            newMarginDepositedTotal = 0;\n        }\n\n        int256 averageEntryPrice = int256(_globalPositions.averagePrice);\n        int256 sizeOpenedTotal = int256(_globalPositions.sizeOpenedTotal);\n\n        // Recompute the average entry price.\n        if ((sizeOpenedTotal + _additionalSizeDelta) != 0) {\n            int256 newAverageEntryPrice = ((averageEntryPrice * sizeOpenedTotal) +\n                (int256(_price) * _additionalSizeDelta)) / (sizeOpenedTotal + _additionalSizeDelta);\n\n            _globalPositions = FlatcoinStructs.GlobalPositions({\n                marginDepositedTotal: newMarginDepositedTotal,\n                sizeOpenedTotal: (int256(_globalPositions.sizeOpenedTotal) + _additionalSizeDelta).toUint256(),\n                averagePrice: uint256(newAverageEntryPrice)\n            });\n        } else {\n            // Close the last remaining position.\n            // TODO: Move this to an invariant check\n            if (newMarginDepositedTotal > 1e6) revert FlatcoinErrors.MarginMismatchOnClose();\n\n            delete _globalPositions;\n        }\n    }\n\n    /////////////////////////////////////////////\n    //            Public Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Function to settle the funding fees between longs and LPs.\n    /// @dev Anyone can call this function to settle the funding fees.\n    /// @return _fundingFees The funding fees paid to longs.\n    ///         If it's negative, longs pay shorts and vice versa.\n    function settleFundingFees() public returns (int256 _fundingFees) {\n        (int256 fundingChangeSinceRecomputed, int256 unrecordedFunding) = _getUnrecordedFunding();\n\n        // Record the funding rate change and update the cumulative funding rate.\n        cumulativeFundingRate = PerpMath._nextFundingEntry(unrecordedFunding, cumulativeFundingRate);\n\n        // Update the latest funding rate and the latest funding recomputation timestamp.\n        lastRecomputedFundingRate += fundingChangeSinceRecomputed;\n        lastRecomputedFundingTimestamp = (block.timestamp).toUint64();\n\n        // Calculate the funding fees accrued to the longs.\n        // This will be used to adjust the global margin and collateral amounts.\n        _fundingFees = PerpMath._accruedFundingTotalByLongs(_globalPositions, unrecordedFunding);\n\n        // In the worst case scenario that the last position which remained open is underwater,\n        // We set the margin deposited total to negative. Once the underwater position is liquidated,\n        // then the funding fees will be reverted and the total will be positive again.\n        _globalPositions.marginDepositedTotal = _globalPositions.marginDepositedTotal + _fundingFees;\n\n        _updateStableCollateralTotal(-_fundingFees);\n    }\n\n    /////////////////////////////////////////////\n    //             View Functions              //\n    /////////////////////////////////////////////\n\n    /// @notice Function to get a summary of the vault.\n    /// @dev This can be used by modules to get the current state of the vault.\n    /// @return _vaultSummary The vault summary struct.\n    function getVaultSummary() external view returns (FlatcoinStructs.VaultSummary memory _vaultSummary) {\n        return\n            FlatcoinStructs.VaultSummary({\n                marketSkew: int256(_globalPositions.sizeOpenedTotal) - int256(stableCollateralTotal),\n                cumulativeFundingRate: cumulativeFundingRate,\n                lastRecomputedFundingRate: lastRecomputedFundingRate,\n                lastRecomputedFundingTimestamp: lastRecomputedFundingTimestamp,\n                stableCollateralTotal: stableCollateralTotal,\n                globalPositions: _globalPositions\n            });\n    }\n\n    /// @notice Function to get the current funding rate.\n    /// @dev This can be used by modules to get the current funding rate.\n    /// @return currentFundingRate_ The current funding rate.\n    function getCurrentFundingRate() external view returns (int256 currentFundingRate_) {\n        return\n            PerpMath._currentFundingRate({\n                proportionalSkew: PerpMath._proportionalSkew({\n                    skew: int256(_globalPositions.sizeOpenedTotal) - int256(stableCollateralTotal),\n                    stableCollateralTotal: stableCollateralTotal\n                }),\n                lastRecomputedFundingRate: lastRecomputedFundingRate,\n                lastRecomputedFundingTimestamp: lastRecomputedFundingTimestamp,\n                maxFundingVelocity: maxFundingVelocity,\n                maxVelocitySkew: maxVelocitySkew\n            });\n    }\n\n    /// @notice Function to get the position details of associated with a `_tokenId`.\n    /// @dev This can be used by modules to get the position details of a leverage trader.\n    /// @param _tokenId The token ID of the leverage trader.\n    /// @return _positionDetails The position struct with details.\n    function getPosition(uint256 _tokenId) external view returns (FlatcoinStructs.Position memory _positionDetails) {\n        return _positions[_tokenId];\n    }\n\n    /// @notice Function to get the global position details.\n    /// @dev This can be used by modules to get the global position details.\n    /// @return _globalPositionsDetails The global position struct with details.\n    function getGlobalPositions()\n        external\n        view\n        returns (FlatcoinStructs.GlobalPositions memory _globalPositionsDetails)\n    {\n        return _globalPositions;\n    }\n\n    /// @notice Asserts that the system will not be too skewed towards longs after additional skew is added (position change).\n    /// @param _sizeChange The proposed change in additional size\n    /// @param _stableCollateralChange The proposed change in the stable collateral\n    function checkSkewMax(uint256 _sizeChange, int256 _stableCollateralChange) public view {\n        // check that skew is not essentially disabled\n        if (skewFractionMax < type(uint256).max) {\n            uint256 sizeOpenedTotal = _globalPositions.sizeOpenedTotal;\n\n            if (stableCollateralTotal == 0) revert FlatcoinErrors.ZeroValue(\"stableCollateralTotal\");\n            assert(int256(stableCollateralTotal) + _stableCollateralChange >= 0);\n\n            // if the longs are closed completely then there is no reason to check if long skew has reached max\n            if (sizeOpenedTotal + _sizeChange == 0) return;\n\n            uint256 longSkewFraction = (int256((sizeOpenedTotal + _sizeChange) * 1e18) /\n                (int256(stableCollateralTotal) + _stableCollateralChange)).toUint256();\n\n            if (longSkewFraction > skewFractionMax) revert FlatcoinErrors.MaxSkewReached(longSkewFraction);\n        }\n    }\n\n    /// @notice Reverts if the stable LP deposit cap is reached on deposit.\n    /// @param _depositAmount The amount of stable LP tokens to deposit.\n    function checkCollateralCap(uint256 _depositAmount) public view {\n        uint256 collateralCap = stableCollateralCap;\n\n        if (stableCollateralTotal + _depositAmount > collateralCap)\n            revert FlatcoinErrors.DepositCapReached(collateralCap);\n    }\n\n    /// @notice Returns the current skew of the market taking into account unnacrued funding.\n    /// @return _skew The current skew of the market.\n    function getCurrentSkew() external view returns (int256 _skew) {\n        (, int256 unrecordedFunding) = _getUnrecordedFunding();\n        uint256 sizeOpenedTotal = _globalPositions.sizeOpenedTotal;\n\n        return\n            int256(sizeOpenedTotal) -\n            int256(stableCollateralTotal) -\n            (int256(sizeOpenedTotal) * unrecordedFunding) /\n            1e18;\n    }\n\n    /////////////////////////////////////////////\n    //             Owner Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Setter for the maximum leverage total skew fraction.\n    /// @dev This ensures that stable LPs are not too short by capping long trader total open interest.\n    ///      Note that `_skewFractionMax` should include 18 decimals.\n    /// @param _skewFractionMax The maximum limit of total leverage long size vs stable LP.\n    function setSkewFractionMax(uint256 _skewFractionMax) public onlyOwner {\n        if (_skewFractionMax < 1e18) revert FlatcoinErrors.InvalidSkewFractionMax(_skewFractionMax);\n\n        skewFractionMax = _skewFractionMax;\n    }\n\n    /// @notice Setter for the maximum funding velocity.\n    /// @param _newMaxFundingVelocity The maximum funding velocity used to limit the funding rate fluctuations.\n    /// @dev NOTE: `_newMaxFundingVelocity` should include 18 decimals.\n    function setMaxFundingVelocity(uint256 _newMaxFundingVelocity) public onlyOwner {\n        settleFundingFees(); // settle funding fees before updating the max funding velocity so that positions are not affected by the change\n        maxFundingVelocity = _newMaxFundingVelocity;\n    }\n\n    /// @notice Setter for the maximum funding velocity skew.\n    /// @param _newMaxVelocitySkew The skew percentage at which the funding rate velocity is at its maximum.\n    /// @dev NOTE: `_newMaxVelocitySkew` should include 18 decimals.\n    function setMaxVelocitySkew(uint256 _newMaxVelocitySkew) public onlyOwner {\n        if (_newMaxVelocitySkew > 1e18 || _newMaxVelocitySkew == 0)\n            revert FlatcoinErrors.InvalidMaxVelocitySkew(_newMaxVelocitySkew);\n\n        settleFundingFees(); // settle funding fees before updating the max velocity skew so that positions are not affected by the change\n        maxVelocitySkew = _newMaxVelocitySkew;\n    }\n\n    /// @notice Function to add multiple authorized modules.\n    /// @dev NOTE: This function can overwrite an existing authorized module.\n    /// @param _modules The array of authorized modules to add.\n    function addAuthorizedModules(FlatcoinStructs.AuthorizedModule[] calldata _modules) external onlyOwner {\n        uint8 modulesLength = uint8(_modules.length);\n\n        for (uint8 i; i < modulesLength; ++i) {\n            addAuthorizedModule(_modules[i]);\n        }\n    }\n\n    /// @notice Function to set an authorized module.\n    /// @dev NOTE: This function can overwrite an existing authorized module.\n    /// @param _module The authorized module to add.\n    function addAuthorizedModule(FlatcoinStructs.AuthorizedModule calldata _module) public onlyOwner {\n        if (_module.moduleAddress == address(0)) revert FlatcoinErrors.ZeroAddress(\"moduleAddress\");\n        if (_module.moduleKey == bytes32(0)) revert FlatcoinErrors.ZeroValue(\"moduleKey\");\n\n        moduleAddress[_module.moduleKey] = _module.moduleAddress;\n        isAuthorizedModule[_module.moduleAddress] = true;\n    }\n\n    /// @notice Function to remove an authorized module.\n    /// @param _modKey The module key of the module to remove.\n    function removeAuthorizedModule(bytes32 _modKey) public onlyOwner {\n        address modAddress = moduleAddress[_modKey];\n\n        delete moduleAddress[_modKey];\n        delete isAuthorizedModule[modAddress];\n    }\n\n    /// @notice Function to pause the module\n    /// @param _moduleKey The module key of the module to pause.\n    function pauseModule(bytes32 _moduleKey) external onlyOwner {\n        isModulePaused[_moduleKey] = true;\n    }\n\n    /// @notice Function to unpause the critical functions\n    /// @param _moduleKey The module key of the module to unpause.\n    function unpauseModule(bytes32 _moduleKey) external onlyOwner {\n        isModulePaused[_moduleKey] = false;\n    }\n\n    /// @notice Setter for the stable collateral cap.\n    /// @param _collateralCap The maximum cap on the total stable LP deposits.\n    function setStableCollateralCap(uint256 _collateralCap) public onlyOwner {\n        stableCollateralCap = _collateralCap;\n    }\n\n    /// @notice Setter for the minimum and maximum time delayed executatibility\n    /// @dev The maximum executability timer starts after the minimum time has elapsed\n    /// @param _minExecutabilityAge The minimum time that needs to expire between trade announcement and execution.\n    /// @param _maxExecutabilityAge The maximum amount of time that can expire between trade announcement and execution.\n    function setExecutabilityAge(uint64 _minExecutabilityAge, uint64 _maxExecutabilityAge) public onlyOwner {\n        if (_minExecutabilityAge == 0 || _maxExecutabilityAge == 0)\n            revert FlatcoinErrors.ZeroValue(\"minExecutabilityAge|maxExecutabilityAge\");\n\n        minExecutabilityAge = _minExecutabilityAge;\n        maxExecutabilityAge = _maxExecutabilityAge;\n    }\n\n    /////////////////////////////////////////////\n    //             Private Functions           //\n    /////////////////////////////////////////////\n\n    function _updateStableCollateralTotal(int256 _stableCollateralAdjustment) private {\n        int256 newStableCollateralTotal = int256(stableCollateralTotal) + _stableCollateralAdjustment;\n\n        // The stable collateral shouldn't be negative as the other calculations which depend on this\n        // will behave in unexpected manners.\n        stableCollateralTotal = (newStableCollateralTotal > 0) ? uint256(newStableCollateralTotal) : 0;\n    }\n\n    /// @dev Function to calculate the unrecorded funding amount.\n    function _getUnrecordedFunding()\n        private\n        view\n        returns (int256 fundingChangeSinceRecomputed, int256 unrecordedFunding)\n    {\n        int256 proportionalSkew = PerpMath._proportionalSkew({\n            skew: int256(_globalPositions.sizeOpenedTotal) - int256(stableCollateralTotal),\n            stableCollateralTotal: stableCollateralTotal\n        });\n\n        fundingChangeSinceRecomputed = PerpMath._fundingChangeSinceRecomputed({\n            proportionalSkew: proportionalSkew,\n            prevFundingModTimestamp: lastRecomputedFundingTimestamp,\n            maxFundingVelocity: maxFundingVelocity,\n            maxVelocitySkew: maxVelocitySkew\n        });\n\n        unrecordedFunding = PerpMath._unrecordedFunding({\n            currentFundingRate: fundingChangeSinceRecomputed + lastRecomputedFundingRate,\n            prevFundingRate: lastRecomputedFundingRate,\n            prevFundingModTimestamp: lastRecomputedFundingTimestamp\n        });\n    }\n}"
    },
    {
      "filename": "flatcoin-v1/src/FlatcoinVault.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.20;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {FlatcoinErrors} from \"./libraries/FlatcoinErrors.sol\";\nimport {FlatcoinStructs} from \"./libraries/FlatcoinStructs.sol\";\nimport {PerpMath} from \"./libraries/PerpMath.sol\";\n\nimport {IFlatcoinVault} from \"./interfaces/IFlatcoinVault.sol\";\n\n/// @title FlatcoinVault\n/// @author dHEDGE\n/// @notice Contains state to be reused by different modules of the system.\n/// @dev Holds the stable LP deposits and leverage traders' collateral amounts.\n///      Also stores other related contract address pointers.\ncontract FlatcoinVault is IFlatcoinVault, OwnableUpgradeable {\n    using SafeCast for *;\n    using SafeERC20 for IERC20;\n\n    /// @notice The collateral token address.\n    IERC20 public collateral;\n\n    /// @notice The last market skew recomputation timestamp.\n    uint64 public lastRecomputedFundingTimestamp;\n\n    /// @notice The minimum time that needs to expire between trade announcement and execution.\n    uint64 public minExecutabilityAge;\n\n    /// @notice The maximum amount of time that can expire between trade announcement and execution.\n    uint64 public maxExecutabilityAge;\n\n    /// @notice The last recomputed funding rate.\n    int256 public lastRecomputedFundingRate;\n\n    /// @notice Sum of funding rate over the entire lifetime of the market.\n    int256 public cumulativeFundingRate;\n\n    /// @notice Total collateral deposited by users minting the flatcoin.\n    /// @dev This value is adjusted due to funding fee payments.\n    uint256 public stableCollateralTotal;\n\n    /// @notice The maximum funding velocity used to limit the funding rate fluctuations.\n    /// @dev Funding velocity is used for calculating the current funding rate and acts as\n    ///      a limit on how much the funding rate can change between funding re-computations.\n    ///      The units are %/day (1e18 = 100% / day at max or min skew).\n    uint256 public maxFundingVelocity;\n\n    /// @notice The skew percentage at which the funding rate velocity is at its maximum.\n    /// @dev When absolute pSkew > maxVelocitySkew, then funding velocity = maxFundingVelocity.\n    ///      The units are in % (0.1e18 = 10% skew)\n    uint256 public maxVelocitySkew;\n\n    /// @notice Maximum cap on the total stable LP deposits.\n    uint256 public stableCollateralCap;\n\n    /// @notice The maximum limit of total leverage long size vs stable LP.\n    /// @dev This prevents excessive short skew of stable LPs by capping long trader total open interest.\n    ///      Care needs to be taken when increasing this value as it can lead to the stable LPs being excessively short.\n    uint256 public skewFractionMax;\n\n    /// @notice Holds mapping between module keys and module addresses.\n    ///         A module key is a keccak256 hash of the module name.\n    /// @dev Make sure that a module key is created using the following format:\n    ///      moduleKey = bytes32(<MODULE_NAME>)\n    ///      All the module keys should reside in a single file (see FlatcoinModuleKeys.sol).\n    mapping(bytes32 moduleKey => address moduleAddress) public moduleAddress;\n\n    /// @notice Holds mapping between module addresses and their authorization status.\n    mapping(address moduleAddress => bool authorized) public isAuthorizedModule;\n\n    /// @notice Holds mapping between module keys and their pause status.\n    mapping(bytes32 moduleKey => bool paused) public isModulePaused;\n\n    /// @dev Tracks global totals of leverage trade positions to be able to:\n    ///      - price stable LP value.\n    ///      - calculate the funding rate.\n    ///      - calculate the skew.\n    ///      - calculate funding fees payments.\n    FlatcoinStructs.GlobalPositions internal _globalPositions;\n\n    /// @dev Holds mapping between user addresses and their leverage positions.\n    mapping(uint256 tokenId => FlatcoinStructs.Position userPosition) internal _positions;\n\n    modifier onlyAuthorizedModule() {\n        if (isAuthorizedModule[msg.sender] == false) revert FlatcoinErrors.OnlyAuthorizedModule(msg.sender);\n        _;\n    }\n\n    /// @dev To prevent the implementation contract from being used, we invoke the _disableInitializers\n    ///      function in the constructor to automatically lock it when it is deployed.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Function to initialize this contract.\n    /// @param _collateral The collateral token address.\n    /// @param _maxFundingVelocity The maximum funding velocity used to limit the funding rate fluctuations.\n    /// @param _maxVelocitySkew The skew percentage at which the funding rate velocity is at its maximum.\n    /// @param _skewFractionMax The maximum limit of total leverage long size vs stable LP.\n    /// @param _stableCollateralCap The maximum cap on the total stable LP deposits.\n    /// @param _minExecutabilityAge The minimum time that needs to expire between trade announcement and execution.\n    /// @param _maxExecutabilityAge The maximum amount of time that can expire between trade announcement and execution.\n    function initialize(\n        IERC20 _collateral,\n        uint256 _maxFundingVelocity,\n        uint256 _maxVelocitySkew,\n        uint256 _skewFractionMax,\n        uint256 _stableCollateralCap,\n        uint64 _minExecutabilityAge,\n        uint64 _maxExecutabilityAge\n    ) external initializer {\n        if (address(_collateral) == address(0)) revert FlatcoinErrors.ZeroAddress(\"collateral\");\n        if (_skewFractionMax < 1e18) revert FlatcoinErrors.InvalidSkewFractionMax(_skewFractionMax);\n        if (_maxVelocitySkew > 1e18 || _maxVelocitySkew == 0)\n            revert FlatcoinErrors.InvalidMaxVelocitySkew(_maxVelocitySkew);\n        if (_minExecutabilityAge == 0 || _maxExecutabilityAge == 0)\n            revert FlatcoinErrors.ZeroValue(\"minExecutabilityAge|maxExecutabilityAge\");\n\n        __Ownable_init(msg.sender);\n\n        collateral = _collateral;\n        maxFundingVelocity = _maxFundingVelocity;\n        maxVelocitySkew = _maxVelocitySkew;\n        stableCollateralCap = _stableCollateralCap;\n        skewFractionMax = _skewFractionMax;\n        minExecutabilityAge = _minExecutabilityAge;\n        maxExecutabilityAge = _maxExecutabilityAge;\n    }\n\n    /////////////////////////////////////////////\n    //            Module Functions             //\n    /////////////////////////////////////////////\n\n    /// @notice Collateral can only be withdrawn by the flatcoin contracts (Delayed Orders, Stable or Leverage module).\n    function sendCollateral(address to, uint256 amount) external onlyAuthorizedModule {\n        collateral.safeTransfer(to, amount);\n    }\n\n    /// @notice Function to set the position of a leverage trader.\n    /// @dev This function is only callable by the authorized modules.\n    /// @param _newPosition The new struct encoded position of the leverage trader.\n    /// @param _tokenId The token ID of the leverage trader.\n    function setPosition(\n        FlatcoinStructs.Position calldata _newPosition,\n        uint256 _tokenId\n    ) external onlyAuthorizedModule {\n        _positions[_tokenId] = _newPosition;\n    }\n\n    /// @notice Function to delete the position of a leverage trader.\n    /// @dev This function is only callable by the authorized modules.\n    /// @param _tokenId The token ID of the leverage trader.\n    function deletePosition(uint256 _tokenId) external onlyAuthorizedModule {\n        delete _positions[_tokenId];\n    }\n\n    /// @notice Function to update the stable collateral total.\n    /// @dev This function is only callable by the authorized modules.\n    ///      When `_stableCollateralAdjustment` is negative, it means that the stable collateral total is decreasing.\n    /// @param _stableCollateralAdjustment The adjustment to the stable collateral total.\n    function updateStableCollateralTotal(int256 _stableCollateralAdjustment) external onlyAuthorizedModule {\n        _updateStableCollateralTotal(_stableCollateralAdjustment);\n    }\n\n    /// @notice Function to update the global position data.\n    /// @dev This function is only callable by the authorized modules.\n    /// @param _price The current price of the underlying asset.\n    /// @param _marginDelta The change in the margin deposited total.\n    /// @param _additionalSizeDelta The change in the size opened total.\n    function updateGlobalPositionData(\n        uint256 _price,\n        int256 _marginDelta,\n        int256 _additionalSizeDelta\n    ) external onlyAuthorizedModule {"
    }
  ]
}