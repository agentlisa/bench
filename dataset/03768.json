{
  "Title": "[H01] Rescue of ERC20 tokens can fail",
  "Content": "The [`Incentivizer`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/incentivizer/Incentivizer.sol) contract has the [`rescue`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/incentivizer/Incentivizer.sol#L176) function that can be called to send to the `reserve` any ERC20 token that is left in the contract.\n\n\nThe fact that an arbitrary `token` address is passed proves that it is intended to move all types of ERC20 tokens.\n\n\nHowever, [the call in the `rescue` function](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/incentivizer/Incentivizer.sol#L181) of the [`verifyRewardBalance`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/incentivizer/Incentivizer.sol#L191) function will revert anytime there are no sufficient reward assets in the contract, as required in lines [193-194](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/incentivizer/Incentivizer.sol#L193-L194).\n\n\nThe docstrings of the function states that this function can transfer any ERC20 token, but this is not always true if not enough rewards of `rewardTokens` are in the balance of the contract, even though the tokens to be rescued do not count for that balance.\n\n\nConsider either restricting the `rescue` function to only exclusively rescue `rewardsTokens` or to exclusively call the [`verifyRewardBalance`](https://github.com/emptysetsquad/emptyset/blob/bf9753ef9cd5b17236036257f290e0d0b850a029/protocol/contracts/src/incentivizer/Incentivizer.sol#L181) if the tokens to be rescued are reward tokens.\n\n\n***Update**: Fixed on [pull request 14](https://github.com/emptysetsquad/emptyset/pull/14/commits/228a81bbee212cabf4ea02a3f475650cd296f455). The EmptySetSquad team stated the following for this issue:*\n\n\n\n> \n> *verifyRewardBalance() couldnâ€™t ever fail unless either token is rewardToken or the contract has been hacked and drained, this is purely an extra defensive check rather than something that could ever be hit under normal usage.*\n> \n> \n> \n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/src/incentivizer/Incentivizer.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../lib/Decimal.sol\";\n\n/**\n * @title Incentivizer\n * @notice Generic incentivization contract that allows one ERC20 to be staked while earning\n *         either the same ERC20 or a different ERC20 as a reward\n * @dev Reward program can be adjusted or ended at any time through governance as long as there\n *      is sufficient balance. Architecture based off the Synthetix StakingRewards contract:\n *      https://github.com/Synthetixio/synthetix/blob/master/contracts/StakingRewards.sol\n */\ncontract Incentivizer is Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Decimal for Decimal.D256;\n\n    /**\n     * @notice Emitted when the reward program is updated with a rate `rate` completing `complete`\n     */\n    event RewardProgramUpdate(uint256 rate, uint256 complete);\n\n    /**\n     * @notice Emitted when the owner rescues `amount` of `token`\n     */\n    event Rescue(address token, uint256 amount);\n\n    /**\n     * @notice Emitted on reward accrual when `newReward` reward tokens are dispersed at\n     *         timestamp `updated`, updating the rewards per unit to `rewardPerUnit`\n     */\n    event Settle(uint256 rewardPerUnit, uint256 newReward, uint256 updated);\n\n    /**\n     * @notice Emitted on when `account` stakes `amount` of the underlying token\n     */\n    event Stake(address account, uint256 amount);\n\n    /**\n     * @notice Emitted on when `account` withdraws `amount` of the underlying token\n     */\n    event Withdrawal(address account, uint256 amount);\n\n    /**\n     * @notice Emitted on when `account` claims `amount` of the reward token\n     */\n    event Claim(address account, uint256 amount);\n\n    /**\n     * @notice Address to receive rescued and refunded funds\n     */\n    address public reserve;\n\n    /**\n     * @notice ERC20 token that will be used as underlying for staking\n     */\n    IERC20 public underlyingToken;\n\n    /**\n     * @notice ERC20 token that will be dispersed as rewards\n     */\n    IERC20 public rewardToken;\n\n    /**\n     * @notice Quantity of  rewardToken` dispersed to the entire staking pool per second\n     */\n    uint256 public rewardRate;\n\n    /**\n     * @notice Timestamp the current reward program ends\n     */\n    uint256 public rewardComplete;\n\n    /**\n     * @notice Timestamp that reward accrual was last settled\n     */\n    uint256 public rewardUpdated;\n\n    /**\n     * @notice Mapping of underlying token balance per account\n     */\n    mapping(address => uint256) public balanceOfUnderlying;\n\n    /**\n     * @notice Total underlying token balance staked in this contract\n     */\n    uint256 public totalUnderlying;\n\n    /**\n     * @notice Total outstanding unclaimed rewards that have accrued so far\n     */\n    uint256 public totalReward;\n\n    /**\n     * @notice Mapping of settled reward balance per account\n     */\n    mapping(address => uint256) internal _reward;\n\n    /**\n     * @notice Mapping of rewards already paid out per account\n     */\n    mapping(address => Decimal.D256) internal _paid;\n\n    /**\n     * @notice Monotonically increasing accumulator to track the reward amount per unit of staked underlying\n     */\n    Decimal.D256 internal _rewardPerUnit;\n\n\n    /**\n     * @notice Constructs the Incentivizer\n     * @param underlying_ Underlying ERC20 token for staking\n     * @param reward_ Reward ERC20 token for rewards\n     * @notice reserve_ Address to receive rescued and refunded ERC20 tokens\n     */\n    constructor(IERC20 underlying_, IERC20 reward_, address reserve_) public {\n        reserve = reserve_;\n        underlyingToken = underlying_;\n        rewardToken = reward_;\n    }\n\n    // ADMIN\n\n    /**\n     * @notice Updates the rate and completion time for this contract's reward program\n     * @dev Owner only - governance hook\n     *      Insufficient funds will revert - excess funds will be refunded to {reserve}\n     * @param rate Reward token amount to disperse to enter staking pool per second\n     * @param complete Timestamp the reward program ends\n     */\n    function updateRewardProgram(uint256 rate, uint256 complete) external onlyOwner {\n        require(complete > block.timestamp, \"Incentivizer: already ended\");\n\n        settle();\n\n        // Set new reward rate\n        (rewardRate, rewardComplete, rewardUpdated) = (rate, complete, block.timestamp);\n\n        // Return rewards in excess of the required amount\n        rewardToken.safeTransfer(reserve, verifyRewardBalance());\n\n        emit RewardProgramUpdate(rate, complete);\n    }\n\n    /**\n     * @notice Allows the owner to withdraw stuck ERC20 tokens to {reserve}\n     * @dev Owner only - governance hook\n     *      Non-reentrant\n     *      Cannot withdraw the underlying token\n     *      Cannot withdraw more of the reward token than is needed for the current reward program\n     * @param token ERC20 token to withdraw\n     * @param amount Amount to withdraw\n     */\n    function rescue(address token, uint256 amount) external nonReentrant onlyOwner {\n        require(token != address(underlyingToken), \"Incentivizer: underlying token\");\n\n        IERC20(token).safeTransfer(reserve, amount);\n\n        verifyRewardBalance();\n\n        emit Rescue(token, amount);\n    }\n\n    /**\n     * @notice Verifies that there is sufficient reward tokens for the current reward program\n     * @dev Internal only - helper\n     *      Reverts if there is insufficient reward token funds\n     */\n    function verifyRewardBalance() private view returns (uint256) {\n        return _totalRewardBalance()\n            .sub(totalReward, \"Incentivizer: insufficient rewards\")\n            .sub(totalProvisionedReward(), \"Incentivizer: insufficient rewards\");\n    }\n\n    // FLYWHEEL\n\n    /**\n     * @notice Total rewards that have been provisioned for the current reward program,\n     *         but not yet settled or paid out\n     * @return Total provisioned rewards\n     */\n    function totalProvisionedReward() public view returns (uint256) {\n        uint256 complete = rewardComplete;\n        uint256 updated = rewardUpdated;\n\n        return complete > updated ? complete.sub(updated).mul(rewardRate) : 0;\n    }\n\n    /**\n     * @notice Returns either the current timestamp or the last applicable timestamp of the reward program\n     * @return Most recent reward-applicable timestamp\n     */\n    function nowOrComplete() public view returns (uint256) {\n        uint256 complete = rewardComplete;\n        uint256 latest = block.timestamp;\n\n        return latest > complete ? complete : latest;\n    }\n\n    /**\n     * @notice Monotonically increasing accumulator to track the reward amount per unit of staked underlying\n     * @dev Computes the current effective rewardPerUnit value as if there was a settlement now\n     * @return Effective rewards per unit\n     */\n    function rewardPerUnit() public view returns (Decimal.D256 memory) {\n        if (totalUnderlying == 0) {\n            return _rewardPerUnit;\n        } else {\n            return _rewardPerUnit\n                .add(Decimal.from(nowOrComplete().sub(rewardUpdated).mul(rewardRate)).div(totalUnderlying));\n        }\n    }\n\n    /**\n     * @notice Accrues and updates rewards since last settlement\n     * @dev Internal only\n     */\n    function settle() internal {\n        uint256 nowOrComplete = nowOrComplete();\n        Decimal.D256 memory newRewardPerUnit = rewardPerUnit();\n        uint256 newReward = newRewardPerUnit.sub(_rewardPerUnit).mul(totalUnderlying).asUint256();\n        uint256 newTotalReward = totalReward.add(newReward);\n\n        _rewardPerUnit = newRewardPerUnit;\n        totalReward = newTotalReward;\n        rewardUpdated = nowOrComplete;\n\n        emit Settle(newRewardPerUnit.value, newReward, nowOrComplete);\n    }\n\n    /**\n     * @notice Accrues and records rewards for `account` to simplify accounting math\n     * @dev Internal only\n     * @param account Account to settle rewards for\n     */\n    function settleAccount(address account) internal {\n        settle();\n\n        _reward[account] = balanceOfReward(account);\n        _paid[account] = _rewardPerUnit;\n    }\n\n    // EXTERNAL\n\n    /**\n     * @notice Balance of all accrued rewards (including unsettled) for `account`\n     * @param account Account to retrieve balance for\n     */\n    function balanceOfReward(address account) public view returns (uint256) {\n        return _reward[account].add(\n            rewardPerUnit().sub(_paid[account])      // Since last checkpoint\n                .mul(balanceOfUnderlying[account])   // Multiply per unit\n                .asUint256()                         // Convert and truncate\n        );\n    }\n\n    /**\n     * @notice Deposit `amount` underlying tokens to start accruing rewards\n     * @dev Non-reentrant\n     * @param amount Amount of underlying tokens for the caller to deposit\n     */\n    function stake(uint256 amount) external nonReentrant {\n        settleAccount(msg.sender);\n\n        // Increment account balance\n        balanceOfUnderlying[msg.sender] = balanceOfUnderlying[msg.sender].add(amount);\n        totalUnderlying = totalUnderlying.add(amount);\n\n        // Transfer in token amount\n        underlyingToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Stake(msg.sender, amount);\n    }\n\n    /**\n     * @notice Withdraw `amount` underlying tokens\n     * @dev Non-reentrant\n     * @param amount Amount of underlying tokens for the caller to withdraw\n     */\n    function withdraw(uint256 amount) public nonReentrant {\n        settleAccount(msg.sender);\n\n        // Decrement account balance\n        balanceOfUnderlying[msg.sender] = balanceOfUnderlying[msg.sender].sub(amount, \"Incentivizer: insufficient balance\");\n        totalUnderlying = totalUnderlying.sub(amount, \"Incentivizer: insufficient balance\");\n\n        // Transfer out token amount\n        underlyingToken.safeTransfer(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    /**\n     * @notice Claim all accrued reward tokens for caller\n     * @dev Non-reentrant\n     */\n    function claim() public nonReentrant {\n        settleAccount(msg.sender);\n\n        uint256 rewardBalance = _reward[msg.sender];\n        rewardToken.safeTransfer(msg.sender, rewardBalance);\n\n        _reward[msg.sender] = 0;\n        totalReward = totalReward.sub(rewardBalance);\n\n        emit Claim(msg.sender, rewardBalance);\n    }\n\n    /**\n     * @notice Claim all accrued reward tokens withdraw all underlying tokens for caller\n     */\n    function exit() external {\n        withdraw(balanceOfUnderlying[msg.sender]);\n        claim();\n    }\n\n    // INTERNAL\n\n    /**\n     * @notice Total reward token holdings of this contract\n     * @dev If reward token == underlying token, this will subtract the total underlying amount from the balance\n     * @dev Internal only - helper\n     */\n    function _totalRewardBalance() private view returns (uint256) {\n        if (underlyingToken == rewardToken) {\n            uint256 totalBalance = rewardToken.balanceOf(address(this));\n            return totalBalance > totalUnderlying ? totalBalance - totalUnderlying : 0;\n        }\n\n        return rewardToken.balanceOf(address(this));\n    }\n}"
    },
    {
      "filename": "protocol/contracts/src/incentivizer/Incentivizer.sol",
      "content": "/*\n    Copyright 2021 Empty Set Squad <emptysetsquad@protonmail.com>\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../lib/Decimal.sol\";\n\n/**\n * @title Incentivizer\n * @notice Generic incentivization contract that allows one ERC20 to be staked while earning\n *         either the same ERC20 or a different ERC20 as a reward\n * @dev Reward program can be adjusted or ended at any time through governance as long as there\n *      is sufficient balance. Architecture based off the Synthetix StakingRewards contract:\n *      https://github.com/Synthetixio/synthetix/blob/master/contracts/StakingRewards.sol\n */\ncontract Incentivizer is Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Decimal for Decimal.D256;\n\n    /**\n     * @notice Emitted when the reward program is updated with a rate `rate` completing `complete`\n     */\n    event RewardProgramUpdate(uint256 rate, uint256 complete);\n\n    /**\n     * @notice Emitted when the owner rescues `amount` of `token`\n     */\n    event Rescue(address token, uint256 amount);\n\n    /**\n     * @notice Emitted on reward accrual when `newReward` reward tokens are dispersed at\n     *         timestamp `updated`, updating the rewards per unit to `rewardPerUnit`\n     */\n    event Settle(uint256 rewardPerUnit, uint256 newReward, uint256 updated);\n\n    /**\n     * @notice Emitted on when `account` stakes `amount` of the underlying token\n     */\n    event Stake(address account, uint256 amount);\n\n    /**\n     * @notice Emitted on when `account` withdraws `amount` of the underlying token\n     */\n    event Withdrawal(address account, uint256 amount);\n\n    /**\n     * @notice Emitted on when `account` claims `amount` of the reward token\n     */\n    event Claim(address account, uint256 amount);\n\n    /**\n     * @notice Address to receive rescued and refunded funds\n     */\n    address public reserve;\n\n    /**\n     * @notice ERC20 token that will be used as underlying for staking\n     */\n    IERC20 public underlyingToken;\n\n    /**\n     * @notice ERC20 token that will be dispersed as rewards\n     */\n    IERC20 public rewardToken;\n\n    /**\n     * @notice Quantity of  rewardToken` dispersed to the entire staking pool per second\n     */\n    uint256 public rewardRate;\n\n    /**\n     * @notice Timestamp the current reward program ends\n     */\n    uint256 public rewardComplete;\n\n    /**\n     * @notice Timestamp that reward accrual was last settled\n     */\n    uint256 public rewardUpdated;\n\n    /**\n     * @notice Mapping of underlying token balance per account\n     */\n    mapping(address => uint256) public balanceOfUnderlying;\n\n    /**\n     * @notice Total underlying token balance staked in this contract\n     */\n    uint256 public totalUnderlying;\n\n    /**\n     * @notice Total outstanding unclaimed rewards that have accrued so far\n     */\n    uint256 public totalReward;\n\n    /**\n     * @notice Mapping of settled reward balance per account\n     */\n    mapping(address => uint256) internal _reward;\n\n    /**\n     * @notice Mapping of rewards already paid out per account\n     */\n    mapping(address => Decimal.D256) internal _paid;\n\n    /**\n     * @notice Monotonically increasing accumulator to track the reward amount per unit of staked underlying\n     */\n    Decimal.D256 internal _rewardPerUnit;\n\n\n    /**\n     * @notice Constructs the Incentivizer\n     * @param underlying_ Underlying ERC20 token for staking\n     * @param reward_ Reward ERC20 token for rewards\n     * @notice reserve_ Address to receive rescued and refunded ERC20 tokens\n     */\n    constructor(IERC20 underlying_, IERC20 reward_, address reserve_) public {\n        reserve = reserve_;\n        underlyingToken = underlying_;\n        rewardToken = reward_;\n    }\n\n    // ADMIN\n\n    /**\n     * @notice Updates the rate and completion time for this contract's reward program\n     * @dev Owner only - governance hook\n     *      Insufficient funds will revert - excess funds will be refunded to {reserve}\n     * @param rate Reward token amount to disperse to enter staking pool per second\n     * @param complete Timestamp the reward program ends\n     */\n    function updateRewardProgram(uint256 rate, uint256 complete) external onlyOwner {\n        require(complete > block.timestamp, \"Incentivizer: already ended\");\n\n        settle();\n\n        // Set new reward rate\n        (rewardRate, rewardComplete, rewardUpdated) = (rate, complete, block.timestamp);\n\n        // Return rewards in excess of the required amount\n        rewardToken.safeTransfer(reserve, verifyRewardBalance());\n\n        emit RewardProgramUpdate(rate, complete);\n    }\n\n    /**\n     * @notice Allows the owner to withdraw stuck ERC20 tokens to {reserve}\n     * @dev Owner only - governance hook\n     *      Non-reentrant\n     *      Cannot withdraw the underlying token\n     *      Cannot withdraw more of the reward token than is needed for the current reward program\n     * @param token ERC20 token to withdraw\n     * @param amount Amount to withdraw\n     */\n    function rescue(address token, uint256 amount) external nonReentrant onlyOwner {\n        require(token != address(underlyingToken), \"Incentivizer: underlying token\");\n\n        IERC20(token).safeTransfer(reserve, amount);\n\n        verifyRewardBalance();\n\n        emit Rescue(token, amount);\n    }\n\n    /**\n     * @notice Verifies that there is sufficient reward tokens for the current reward program\n     * @dev Internal only - helper\n     *      Reverts if there is insufficient reward token funds\n     */\n    function verifyRewardBalance() private view returns (uint256) {\n        return _totalRewardBalance()\n            .sub(totalReward, \"Incentivizer: insufficient rewards\")\n            .sub(totalProvisionedReward(), \"Incentivizer: insufficient rewards\");\n    }\n\n    // FLYWHEEL\n\n    /**\n     * @notice Total rewards that have been provisioned for the current reward program,\n     *         but not yet settled or paid out\n     * @return Total provisioned rewards\n     */\n    function totalProvisionedReward() public view returns (uint256) {\n        uint256 complete = rewardComplete;\n        uint256 updated = rewardUpdated;\n\n        return complete > updated ? complete.sub(updated).mul(rewardRate) : 0;\n    }\n\n    /**\n     * @notice Returns either the current timestamp or the last applicable timestamp of the reward program\n     * @return Most recent reward-applicable timestamp\n     */\n    function nowOrComplete() public view returns (uint256) {\n        uint256 complete = rewardComplete;\n        uint256 latest = block.timestamp;\n\n        return latest > complete ? complete : latest;\n    }\n\n    /**\n     * @notice Monotonically increasing accumulator to track the reward amount per unit of staked underlying\n     * @dev Computes the current effective rewardPerUnit value as if there was a settlement now\n     * @return Effective rewards per unit\n     */\n    function rewardPerUnit() public view returns (Decimal.D256 memory) {\n        if (totalUnderlying == 0) {\n            return _rewardPerUnit;\n        } else {\n            return _rewardPerUnit\n                .add(Decimal.from(nowOrComplete().sub(rewardUpdated).mul(rewardRate)).div(totalUnderlying));\n        }\n    }\n\n    /**\n     * @notice Accrues and updates rewards since last settlement\n     * @dev Internal only\n     */\n    function settle() internal {\n        uint256 nowOrComplete = nowOrComplete();\n        Decimal.D256 memory newRewardPerUnit = rewardPerUnit();\n        uint256 newReward = newRewardPerUnit.sub(_rewardPerUnit).mul(totalUnderlying).asUint256();\n        uint256 newTotalReward = totalReward.add(newReward);\n\n        _rewardPerUnit = newRewardPerUnit;\n        totalReward = newTotalReward;\n        rewardUpdated = nowOrComplete;\n\n        emit Settle(newRewardPerUnit.value, newReward, nowOrComplete);\n    }\n\n    /**\n     * @notice Accrues and records rewards for `account` to simplify accounting math\n     * @dev Internal only\n     * @param account Account to settle rewards for\n     */\n    function settleAccount(address account) internal {\n        settle();\n\n        _reward[account] = balanceOfReward(account);\n        _paid[account] = _rewardPerUnit;\n    }\n\n    // EXTERNAL\n\n    /**\n     * @notice Balance of all accrued rewards (including unsettled) for `account`\n     * @param account Account to retrieve balance for\n     */\n    function balanceOfReward(address account) public view returns (uint256) {\n        return _reward[account].add(\n            rewardPerUnit().sub(_paid[account])      // Since last checkpoint\n                .mul(balanceOfUnderlying[account])   // Multiply per unit\n                .asUint256()                         // Convert and truncate\n        );\n    }\n\n    /**\n     * @notice Deposit `amount` underlying tokens to start accruing rewards\n     * @dev Non-reentrant\n     * @param amount Amount of underlying tokens for the caller to deposit\n     */\n    function stake(uint256 amount) external nonReentrant {\n        settleAccount(msg.sender);\n\n        // Increment account balance\n        balanceOfUnderlying[msg.sender] = balanceOfUnderlying[msg.sender].add(amount);\n        totalUnderlying = totalUnderlying.add(amount);\n\n        // Transfer in token amount\n        underlyingToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Stake(msg.sender, amount);\n    }\n\n    /**\n     * @notice Withdraw `amount` underlying tokens\n     * @dev Non-reentrant\n     * @param amount Amount of underlying tokens for the caller to withdraw\n     */\n    function withdraw(uint256 amount) public nonReentrant {\n        settleAccount(msg.sender);\n\n        // Decrement account balance\n        balanceOfUnderlying[msg.sender] = balanceOfUnderlying[msg.sender].sub(amount, \"Incentivizer: insufficient balance\");\n        totalUnderlying = totalUnderlying.sub(amount, \"Incentivizer: insufficient balance\");\n\n        // Transfer out token amount\n        underlyingToken.safeTransfer(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    /**\n     * @notice Claim all accrued reward tokens for caller\n     * @dev Non-reentrant\n     */\n    function claim() public nonReentrant {\n        settleAccount(msg.sender);\n\n        uint256 rewardBalance = _reward[msg.sender];\n        rewardToken.safeTransfer(msg.sender, rewardBalance);\n\n        _reward[msg.sender] = 0;\n        totalReward = totalReward.sub(rewardBalance);\n\n        emit Claim(msg.sender, rewardBalance);\n    }\n\n    /**\n     * @notice Claim all accrued reward tokens withdraw all underlying tokens for caller\n     */\n    function exit() external {\n        withdraw(balanceOfUnderlying[msg.sender]);\n        claim();\n    }\n\n    // INTERNAL\n\n    /**\n     * @notice Total reward token holdings of this contract\n     * @dev If reward token == underlying token, this will subtract the total underlying amount from the balance\n     * @dev Internal only - helper\n     */\n    function _totalRewardBalance() private view returns (uint256) {\n        if (underlyingToken == rewardToken) {\n            uint256 totalBalance = rewardToken.balanceOf(address(this));\n            return totalBalance > totalUnderlying ? totalBalance - totalUnderlying : 0;\n        }\n\n        return rewardToken.balanceOf(address(this));\n    }\n}"
    }
  ]
}