{
  "Title": "Instant arbitrage opportunity through rETH and stETH price discrepancy",
  "Content": "# Instant arbitrage opportunity through rETH and stETH price discrepancy\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/BridgeRouterFacet.sol#L88-L114\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/BridgeRouterFacet.sol#L88-L114</a>\n\n\n## Summary\n\nUser can choose to withdraw their zETH to be a rETH or stETH, while in reality most user will choose the best return (highest value between rETH and stETH), instant arbitrage will happen and this will trigger pool imbalance, draining one over the other.\n\n## Vulnerability Details\n\nIn DittoETH, they accept two special types of Ethereum tokens: rETH and stETH. These tokens are based on regular ETH but are designed to stay close in value to one regular Ether. However, in reality, they can have slightly different values. [rETH](https://coinmarketcap.com/currencies/rocket-pool-eth/), [stETH](https://coinmarketcap.com/currencies/steth/).\n\nIn practice, when user want to withdraw, they can choose between rETH and stETH based on which one is worth more at that moment. The system doesn't really care which one you put in when a user first deposited their asset.\n\nNow, here's where it gets interesting. Because rETH and stETH can have slightly different values, a savvy user could deposit the cheaper one, get a zeth, and then withdraw the more valuable rETH and stETH. a quick way to make some extra profit\n\nAs we can see on line 110-112, the rETH or stETH withdrawn is depends on `ethAmount`, which from `_ethConversion` it's amount is 'equal' between rETH and stETH\n\n```js\nFile: BridgeRouterFacet.sol\n088:     function withdraw(address bridge, uint88 zethAmount)\n089:         external\n090:         nonReentrant\n091:         onlyValidBridge(bridge)\n092:     {\n093:         if (zethAmount == 0) revert Errors.ParameterIsZero();\n094:\n095:         uint88 fee;\n096:         uint256 withdrawalFee = bridge.withdrawalFee();\n097:         uint256 vault;\n098:         if (bridge == rethBridge || bridge == stethBridge) {\n099:             vault = Vault.CARBON;\n100:         } else {\n101:             vault = s.bridge[bridge].vault;\n102:         }\n103:\n104:         if (withdrawalFee > 0) {\n105:             fee = zethAmount.mulU88(withdrawalFee);\n106:             zethAmount -= fee;\n107:             s.vaultUser[vault][address(this)].ethEscrowed += fee;\n108:         }\n109:\n110:         uint88 ethAmount = _ethConversion(vault, zethAmount);\n111:         vault.removeZeth(zethAmount, fee);\n112:         IBridge(bridge).withdraw(msg.sender, ethAmount);\n113:         emit Events.Withdraw(bridge, msg.sender, zethAmount, fee);\n114:     }\n...\n175:     function _ethConversion(uint256 vault, uint88 amount) private view returns (uint88) {\n176:         uint256 zethTotalNew = vault.getZethTotal();\n177:         uint88 zethTotal = s.vault[vault].zethTotal;\n178:\n179:         if (zethTotalNew >= zethTotal) {\n180:             // when yield is positive 1 zeth = 1 eth\n181:             return amount;\n182:         } else {\n183:             // negative yield means 1 zeth < 1 eth\n184:             return amount.mulU88(zethTotalNew).divU88(zethTotal);\n185:         }\n186:     }\n```\n\n## Impact\n\nInstant arbitrage opportunity through rETH and stETH price discrepancy, will also trigger imbalance between rETH and stETH pool.\n\n## Tools Used\n\nManual analysis\n\n## Recommendations\n\nConsider to use oracle to adjust the price difference between rETH and stETH\n",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/BridgeRouterFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IBridge} from \"contracts/interfaces/IBridge.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {LibBridge} from \"contracts/libraries/LibBridge.sol\";\nimport {LibVault} from \"contracts/libraries/LibVault.sol\";\nimport {Constants, Vault} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract BridgeRouterFacet is Modifiers {\n    using U256 for uint256;\n    using U88 for uint88;\n    using LibBridge for uint256;\n    using LibBridge for address;\n    using LibVault for uint256;\n\n    address private immutable rethBridge;\n    address private immutable stethBridge;\n\n    constructor(address _rethBridge, address _stethBridge) {\n        rethBridge = _rethBridge;\n        stethBridge = _stethBridge;\n    }\n\n    function getZethTotal(uint256 vault)\n        external\n        view\n        nonReentrantView\n        returns (uint256)\n    {\n        return vault.getZethTotal();\n    }\n\n    //@dev does not need read only re-entrancy\n    function getBridges(uint256 vault) external view returns (address[] memory) {\n        return s.vaultBridges[vault];\n    }\n\n    function deposit(address bridge, uint88 amount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (amount < Constants.MIN_DEPOSIT) revert Errors.UnderMinimumDeposit();\n        // @dev amount after deposit might be less, if bridge takes a fee\n        uint88 zethAmount = uint88(IBridge(bridge).deposit(msg.sender, amount)); // @dev(safe-cast)\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        vault.addZeth(zethAmount);\n        maybeUpdateYield(vault, zethAmount);\n        emit Events.Deposit(bridge, msg.sender, zethAmount);\n    }\n\n    function depositEth(address bridge)\n        external\n        payable\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (msg.value < Constants.MIN_DEPOSIT) revert Errors.UnderMinimumDeposit();\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        uint88 zethAmount = uint88(IBridge(bridge).depositEth{value: msg.value}()); // Assumes 1 ETH = 1 ZETH\n        vault.addZeth(zethAmount);\n        maybeUpdateYield(vault, zethAmount);\n        emit Events.DepositEth(bridge, msg.sender, zethAmount);\n    }\n\n    function withdraw(address bridge, uint88 zethAmount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint88 fee;\n        uint256 withdrawalFee = bridge.withdrawalFee();\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        if (withdrawalFee > 0) {\n            fee = zethAmount.mulU88(withdrawalFee);\n            zethAmount -= fee;\n            s.vaultUser[vault][address(this)].ethEscrowed += fee;\n        }\n\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n        vault.removeZeth(zethAmount, fee);\n        IBridge(bridge).withdraw(msg.sender, ethAmount);\n        emit Events.Withdraw(bridge, msg.sender, zethAmount, fee);\n    }\n\n    function unstakeEth(address bridge, uint88 zethAmount)\n        external\n        nonReentrant\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint88 fee = zethAmount.mulU88(bridge.unstakeFee());\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n\n        if (fee > 0) {\n            zethAmount -= fee;\n            s.vaultUser[vault][address(this)].ethEscrowed += fee;\n        }\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n        vault.removeZeth(zethAmount, fee);\n        IBridge(bridge).unstake(msg.sender, ethAmount);\n        emit Events.UnstakeEth(bridge, msg.sender, zethAmount, fee);\n    }\n\n    function withdrawTapp(address bridge, uint88 zethAmount)\n        external\n        onlyDAO\n        onlyValidBridge(bridge)\n    {\n        if (zethAmount == 0) revert Errors.ParameterIsZero();\n\n        uint256 vault;\n        if (bridge == rethBridge || bridge == stethBridge) {\n            vault = Vault.CARBON;\n        } else {\n            vault = s.bridge[bridge].vault;\n        }\n        uint88 ethAmount = _ethConversion(vault, zethAmount);\n\n        s.vaultUser[vault][address(this)].ethEscrowed -= zethAmount;\n        s.vault[vault].zethTotal -= zethAmount;\n\n        IBridge(bridge).withdraw(msg.sender, ethAmount);\n        emit Events.WithdrawTapp(bridge, msg.sender, zethAmount);\n    }\n\n    function maybeUpdateYield(uint256 vault, uint88 amount) private {\n        uint88 zethTotal = s.vault[vault].zethTotal;\n        if (\n            zethTotal > Constants.BRIDGE_YIELD_UPDATE_THRESHOLD\n                && amount.div(zethTotal) > Constants.BRIDGE_YIELD_PERCENT_THRESHOLD\n        ) {\n            // Update yield for \"large\" bridge deposits\n            vault.updateYield();\n        }\n    }\n\n    function _ethConversion(uint256 vault, uint88 amount) private view returns (uint88) {\n        uint256 zethTotalNew = vault.getZethTotal();\n        uint88 zethTotal = s.vault[vault].zethTotal;\n\n        if (zethTotalNew >= zethTotal) {\n            // when yield is positive 1 zeth = 1 eth\n            return amount;\n        } else {\n            // negative yield means 1 zeth < 1 eth\n            return amount.mulU88(zethTotalNew).divU88(zethTotal);\n        }\n    }\n}"
    }
  ]
}