{
  "Title": "Implementation of EIP-2535 Does Not Fully Match the Specification",
  "Content": "The [`Diamond` contract](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/Diamond.sol#L24) implements the [EIP-2535 standard](https://eips.ethereum.org/EIPS/eip-2535), often referred to as the diamond proxy pattern.\n\n\nThe diamond proxy pattern is a proxy design where the functions are separated into multiple smaller 'facet' contracts. By breaking down the implementation contract into multiple facets, it is possible to build larger and more complex applications without exceeding the contract size limit.\n\n\nHowever, there are some mismatches between the current implementation and the official specification worth highlighting:\n\n\n* The [diamondCut(IDiamondCut.FacetCut[] memory \\_diamondCut)](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/Diamond.sol#L24) function should be `diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes calldata _calldata)`.\n* The [`getFacetFunctionSelectors`](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/Diamond.sol#L34) function should be `facetFunctionSelectors`.\n* The [`getAllFacetAddresses`](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/Diamond.sol#L51) function should be `facetAddresses`.\n* The `Diamond` contract does not implement the `facets` function.\n* The `Diamond` contract does not implement the `facetAddress` function.\n* The [`DiamondCut(IDiamondCut.FacetCut[] _diamondCut)`](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/Diamond.sol#L9) event should be `DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);`.\n\n\nWhile the deviations from the specification may not be problematic for this particular use case, they may potentially cause errors in clients interacting with the `Diamond` contract who expect a fully-compliant implementation of EIP-2535. For example, tools such as [Louper](https://louper.dev/) will not work as the function signatures of the functions used to inspect the `Diamond` do not match the ones from the standard.\n\n\nTherefore, it is advisable to either modify the contract to make it fully compliant or clearly document the expected differences between the `Diamond` contract and the EIP.\n\n\n***Update:** Resolved in [pull request #312](https://github.com/VenusProtocol/venus-protocol/pull/312) at commit [7417d8f](https://github.com/VenusProtocol/venus-protocol/pull/224/commits/7417d8f4b17eb156dd44a8b4d8eb6dbf3e6e4015).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Comptroller/Diamond/Diamond.sol",
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\nimport \"../ComptrollerStorage.sol\";\nimport \"../Unitroller.sol\";\n\ncontract Diamond is ComptrollerV12Storage {\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut);\n\n    /**\n     * @notice Call _acceptImplementation to accept the diamond proxy as new implementaion.\n     * @param unitroller Address of the unitroller.\n     */\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n    }\n\n    /**\n     * @notice To add function selectors to the facets' mapping.\n     * @param _diamondCut IDiamondCut contains facets address, action and function selectors.\n     */\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut) public {\n        require(msg.sender == admin, \"only unitroller admin can\");\n        libDiamondCut(_diamondCut);\n    }\n\n    /**\n     * @notice Get all function selectors mapped to the facet address\n     * @param _facet Address of the facet\n     * @return _facetFunctionSelectors Array of function selectors\n     */\n    function getFacetFunctionSelectors(address _facet) external view returns (bytes4[] memory _facetFunctionSelectors) {\n        _facetFunctionSelectors = facetFunctionSelectors[_facet].functionSelectors;\n    }\n\n    /**\n     * @notice Get facet position in the facetFunctionSelectors through facet address\n     * @param _facet Address of the facet\n     * @return Position of the facet\n     */\n    function getFacetPosition(address _facet) external view returns (uint256) {\n        return facetFunctionSelectors[_facet].facetAddressPosition;\n    }\n\n    /**\n     * @notice Get all facet addresses\n     * @return facetAddresses_ Array of facet addresses\n     */\n    function getAllFacetAddresses() external view returns (address[] memory facetAddresses_) {\n        facetAddresses_ = facetAddresses;\n    }\n\n    /**\n     * @notice Get facet address and position through function selector\n     * @param _functionSelector function selector\n     * @return FacetAddressAndPosition facet address and position\n     */\n    function getFacetAddressAndPosition(\n        bytes4 _functionSelector\n    ) external view returns (ComptrollerV12Storage.FacetAddressAndPosition memory) {\n        return selectorToFacetAndPosition[_functionSelector];\n    }\n\n    /**\n     * @notice To add function selectors to the facets' mapping.\n     * @param _diamondCut IDiamondCut contains facets address, action and function selectors.\n     */\n    function libDiamondCut(IDiamondCut.FacetCut[] memory _diamondCut) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut);\n    }\n\n    /**\n     * @notice Add function selectors to the facet's address mapping.\n     * @param _facetAddress Address of the facet.\n     * @param _functionSelectors Array of function selectors need to add in the mapping.\n     */\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    /**\n     * @notice Replace facet's address mapping for function selectors i.e selectors already associate to any other existing facet.\n     * @param _facetAddress Address of the facet.\n     * @param _functionSelectors Array of function selectors need to replace in the mapping.\n     */\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(oldFacetAddress, selector);\n            addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    /**\n     * @notice Remove function selectors to the facet's address mapping.\n     * @param _facetAddress Address of the facet.\n     * @param _functionSelectors Array of function selectors need to remove in the mapping.\n     */\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        // if function does not exist then do nothing and revert\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(oldFacetAddress, selector);\n        }\n    }\n\n    /**\n     * @notice Add new facet to the proxy.\n     * @param _facetAddress Address of the facet.\n     */\n    function addFacet(address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"Diamond: New facet has no code\");\n        facetFunctionSelectors[_facetAddress].facetAddressPosition = facetAddresses.length;\n        facetAddresses.push(_facetAddress);\n    }\n\n    /**\n     * @notice Add function selector to the facet's address mapping.\n     * @param _selector funciton selector need to be added.\n     * @param _selectorPosition funciton selector position.\n     * @param _facetAddress Address of the facet.\n     */\n    function addFunction(bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    /**\n     * @notice Remove function selector to the facet's address mapping.\n     * @param _facetAddress Address of the facet.\n     * @param _selector function selectors need to remove in the mapping.\n     */\n    function removeFunction(address _facetAddress, bytes4 _selector) internal {\n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = facetAddresses.length - 1;\n            uint256 facetAddressPosition = facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = facetAddresses[lastFacetAddressPosition];\n                facetAddresses[facetAddressPosition] = lastFacetAddress;\n                facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            facetAddresses.pop();\n            delete facetFunctionSelectors[_facetAddress];\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    function() external payable {\n        address facet = selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute public function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/Comptroller/Diamond/Diamond.sol",
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\nimport \"../ComptrollerStorage.sol\";\nimport \"../Unitroller.sol\";\n\ncontract Diamond is ComptrollerV12Storage {\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut);\n\n    /**\n     * @notice Call _acceptImplementation to accept the diamond proxy as new implementaion.\n     * @param unitroller Address of the unitroller.\n     */\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n    }\n\n    /**\n     * @notice To add function selectors to the facets' mapping.\n     * @param _diamondCut IDiamondCut contains facets address, action and function selectors.\n     */\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut) public {\n        require(msg.sender == admin, \"only unitroller admin can\");\n        libDiamondCut(_diamondCut);\n    }\n\n    /**\n     * @notice Get all function selectors mapped to the facet address\n     * @param _facet Address of the facet\n     * @return _facetFunctionSelectors Array of function selectors\n     */\n    function getFacetFunctionSelectors(address _facet) external view returns (bytes4[] memory _facetFunctionSelectors) {\n        _facetFunctionSelectors = facetFunctionSelectors[_facet].functionSelectors;\n    }\n\n    /**\n     * @notice Get facet position in the facetFunctionSelectors through facet address\n     * @param _facet Address of the facet\n     * @return Position of the facet\n     */\n    function getFacetPosition(address _facet) external view returns (uint256) {\n        return facetFunctionSelectors[_facet].facetAddressPosition;\n    }\n\n    /**\n     * @notice Get all facet addresses\n     * @return facetAddresses_ Array of facet addresses\n     */\n    function getAllFacetAddresses() external view returns (address[] memory facetAddresses_) {\n        facetAddresses_ = facetAddresses;\n    }\n\n    /**\n     * @notice Get facet address and position through function selector\n     * @param _functionSelector function selector\n     * @return FacetAddressAndPosition facet address and position\n     */\n    function getFacetAddressAndPosition(\n        bytes4 _functionSelector\n    ) external view returns (ComptrollerV12Storage.FacetAddressAndPosition memory) {\n        return selectorToFacetAndPosition[_functionSelector];\n    }\n\n    /**\n     * @notice To add function selectors to the facets' mapping.\n     * @param _diamondCut IDiamondCut contains facets address, action and function selectors.\n     */\n    function libDiamondCut(IDiamondCut.FacetCut[] memory _diamondCut) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut);\n    }\n\n    /**\n     * @notice Add function selectors to the facet's address mapping.\n     * @param _facetAddress Address of the facet.\n     * @param _functionSelectors Array of function selectors need to add in the mapping.\n     */\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    /**\n     * @notice Replace facet's address mapping for function selectors i.e selectors already associate to any other existing facet.\n     * @param _facetAddress Address of the facet.\n     * @param _functionSelectors Array of function selectors need to replace in the mapping.\n     */\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(oldFacetAddress, selector);\n            addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    /**\n     * @notice Remove function selectors to the facet's address mapping.\n     * @param _facetAddress Address of the facet.\n     * @param _functionSelectors Array of function selectors need to remove in the mapping.\n     */\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        // if function does not exist then do nothing and revert\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(oldFacetAddress, selector);\n        }\n    }\n\n    /**\n     * @notice Add new facet to the proxy.\n     * @param _facetAddress Address of the facet.\n     */\n    function addFacet(address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"Diamond: New facet has no code\");\n        facetFunctionSelectors[_facetAddress].facetAddressPosition = facetAddresses.length;\n        facetAddresses.push(_facetAddress);\n    }\n\n    /**\n     * @notice Add function selector to the facet's address mapping.\n     * @param _selector funciton selector need to be added.\n     * @param _selectorPosition funciton selector position.\n     * @param _facetAddress Address of the facet.\n     */\n    function addFunction(bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    /**\n     * @notice Remove function selector to the facet's address mapping.\n     * @param _facetAddress Address of the facet.\n     * @param _selector function selectors need to remove in the mapping.\n     */\n    function removeFunction(address _facetAddress, bytes4 _selector) internal {\n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = facetAddresses.length - 1;\n            uint256 facetAddressPosition = facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = facetAddresses[lastFacetAddressPosition];\n                facetAddresses[facetAddressPosition] = lastFacetAddress;\n                facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            facetAddresses.pop();\n            delete facetFunctionSelectors[_facetAddress];\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    function() external payable {\n        address facet = selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute public function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/Comptroller/Diamond/Diamond.sol",
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\nimport \"../ComptrollerStorage.sol\";\nimport \"../Unitroller.sol\";\n\ncontract Diamond is ComptrollerV12Storage {\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut);\n\n    /**\n     * @notice Call _acceptImplementation to accept the diamond proxy as new implementaion.\n     * @param unitroller Address of the unitroller.\n     */\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n    }\n\n    /**\n     * @notice To add function selectors to the facets' mapping.\n     * @param _diamondCut IDiamondCut contains facets address, action and function selectors.\n     */\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut) public {\n        require(msg.sender == admin, \"only unitroller admin can\");\n        libDiamondCut(_diamondCut);\n    }\n\n    /**\n     * @notice Get all function selectors mapped to the facet address\n     * @param _facet Address of the facet\n     * @return _facetFunctionSelectors Array of function selectors\n     */\n    function getFacetFunctionSelectors(address _facet) external view returns (bytes4[] memory _facetFunctionSelectors) {\n        _facetFunctionSelectors = facetFunctionSelectors[_facet].functionSelectors;\n    }\n\n    /**\n     * @notice Get facet position in the facetFunctionSelectors through facet address\n     * @param _facet Address of the facet\n     * @return Position of the facet\n     */\n    function getFacetPosition(address _facet) external view returns (uint256) {\n        return facetFunctionSelectors[_facet].facetAddressPosition;\n    }\n\n    /**\n     * @notice Get all facet addresses\n     * @return facetAddresses_ Array of facet addresses\n     */\n    function getAllFacetAddresses() external view returns (address[] memory facetAddresses_) {\n        facetAddresses_ = facetAddresses;\n    }\n\n    /**\n     * @notice Get facet address and position through function selector\n     * @param _functionSelector function selector\n     * @return FacetAddressAndPosition facet address and position\n     */\n    function getFacetAddressAndPosition(\n        bytes4 _functionSelector\n    ) external view returns (ComptrollerV12Storage.FacetAddressAndPosition memory) {\n        return selectorToFacetAndPosition[_functionSelector];\n    }\n\n    /**\n     * @notice To add function selectors to the facets' mapping.\n     * @param _diamondCut IDiamondCut contains facets address, action and function selectors.\n     */\n    function libDiamondCut(IDiamondCut.FacetCut[] memory _diamondCut) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut);\n    }\n\n    /**\n     * @notice Add function selectors to the facet's address mapping.\n     * @param _facetAddress Address of the facet.\n     * @param _functionSelectors Array of function selectors need to add in the mapping.\n     */\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    /**\n     * @notice Replace facet's address mapping for function selectors i.e selectors already associate to any other existing facet.\n     * @param _facetAddress Address of the facet.\n     * @param _functionSelectors Array of function selectors need to replace in the mapping.\n     */\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(oldFacetAddress, selector);\n            addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    /**\n     * @notice Remove function selectors to the facet's address mapping.\n     * @param _facetAddress Address of the facet.\n     * @param _functionSelectors Array of function selectors need to remove in the mapping.\n     */\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        // if function does not exist then do nothing and revert\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(oldFacetAddress, selector);\n        }\n    }\n\n    /**\n     * @notice Add new facet to the proxy.\n     * @param _facetAddress Address of the facet.\n     */\n    function addFacet(address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"Diamond: New facet has no code\");\n        facetFunctionSelectors[_facetAddress].facetAddressPosition = facetAddresses.length;\n        facetAddresses.push(_facetAddress);\n    }\n\n    /**\n     * @notice Add function selector to the facet's address mapping.\n     * @param _selector funciton selector need to be added.\n     * @param _selectorPosition funciton selector position.\n     * @param _facetAddress Address of the facet.\n     */\n    function addFunction(bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    /**\n     * @notice Remove function selector to the facet's address mapping.\n     * @param _facetAddress Address of the facet.\n     * @param _selector function selectors need to remove in the mapping.\n     */\n    function removeFunction(address _facetAddress, bytes4 _selector) internal {\n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = facet"
    }
  ]
}