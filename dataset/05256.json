{
  "Title": "[M-26] formPOL lacks slippage and deadline protection",
  "Content": "\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/dao/DAO.sol#L316> \n\n<https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/dao/DAO.sol#L360>\n\nformPOL can be vulnerable to a well known liquidity deposit sandwich attack causing loss of funds for the protocol.\n\n### Proof of Concept\n\nIn `formPOL`, there are no slippage parameters when calling `depositLiquidityAndIncreaseShare`\n\nAll liquidity deposits in a Uniswap v2 style pool can be frontrun by this sequence of steps:\n\n1.  attacker pushes pool away from correct ratio\n2.  victims liquidity deposit goes through at wrong ratio\n3.  attacker sells tokens into the new liquidity for a profit\n\nLiquidity withdrawals in a `x * y = k` pool are actually rarely profitable to frontrun attack (it requires certain edge cases), as the same sequence actually loses money if it is a liquidity withdrawals, which is why `withdrawPOL` wasn't explicitly mentioned. However, this issue also applies to `withdrawPOL` and adding slippage protection in that function could be an extra safety measure.\n\n### Recommended Mitigation Steps\n\n`formPOL` should have some form of slippage protection. This could be based off a maximum deviation off some other price feed such a Uniswap v3 TWAP or Chainlink pricefeed. If the pool reserves deviates too much from the expected ratio from the price feed, `formPOL` should revert.\n\n**[othernet-global (Salty.IO) acknowledged and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/224#issuecomment-1933560340):**\n > The automatic arbitrage on the DEX provides some built in protection against front running as the attacker is not able to move in and out without experiencing friction from the arbitrage itself.\n> \n> Simulations (see Sandwich.t.sol) show that when sandwich attacks are used on Salty, the arbitrage earned by the protocol sometimes exceeds any amount lost due to the sandwich attack itself. The actual swap loss (taking arbitrage profits generated by the sandwich swaps into account) is dependent on the multiple pool reserves involved in the arbitrage (which are encouraged by rewards distribution to create more reasonable arbitrage opportunities).\n\n**[Picodes (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/224#issuecomment-1956986114):**\n > Regrouping issues about missing slippage checks here as the root cause is the same - the assumption that AAA is enough to prevent MEV bots from sandwiching maintenance transactions doesn't always hold.\n\n**[othernet-global (Salty.IO) commented](https://github.com/code-423n4/2024-01-salty-findings/issues/224#issuecomment-1960660588):**\n > POL has been removed from the protocol:\n> \n> [eaf40ef0fa27314c6e674db6830990df68e5d70e](https://github.com/othernet-global/salty-io/commit/eaf40ef0fa27314c6e674db6830990df68e5d70e)\n> https://github.com/othernet-global/salty-io/commit/8e3231d3f444e9851881d642d6dd03021fade5ed \n\n**Status:** Mitigation confirmed. Full details in reports from [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/87), [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/107), and [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/23).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/dao/DAO.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../price_feed/interfaces/IPriceAggregator.sol\";\nimport \"../rewards/interfaces/IRewardsEmitter.sol\";\nimport \"../rewards/interfaces/IRewardsConfig.sol\";\nimport \"../stable/interfaces/IStableConfig.sol\";\nimport \"../stable/interfaces/ILiquidizer.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"../staking/interfaces/IStaking.sol\";\nimport \"../interfaces/IAccessManager.sol\";\nimport \"./interfaces/ICalledContract.sol\";\nimport \"./interfaces/IProposals.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"../pools/PoolUtils.sol\";\nimport \"./Parameters.sol\";\nimport \"../Upkeep.sol\";\n\n\n// Allows users to propose and vote on various governance actions such as changing parameters, whitelisting/unwhitelisting tokens, sending tokens, calling other contracts, and updating the website.\n// It handles proposing ballots, tracking votes, enforcing voting requirements, and executing approved proposals.\ncontract DAO is IDAO, Parameters, ReentrancyGuard\n    {\n\tevent BallotFinalized(uint256 indexed ballotID, Vote winningVote);\n    event SetContract(string indexed ballotName, address indexed contractAddress);\n    event SetWebsiteURL(string newURL);\n    event WhitelistToken(IERC20 indexed token);\n    event UnwhitelistToken(IERC20 indexed token);\n    event GeoExclusionUpdated(string country, bool excluded, uint256 geoVersion);\n    event ArbitrageProfitsWithdrawn(address indexed upkeepContract, IERC20 indexed weth, uint256 withdrawnAmount);\n    event SaltSent(address indexed to, uint256 amount);\n    event ContractCalled(address indexed contractAddress, uint256 indexed intArg);\n    event TeamRewardsTransferred(uint256 teamAmount);\n\n    event POLFormed(IERC20 indexed tokenA, IERC20 indexed tokenB, uint256 amountA, uint256 amountB);\n    event POLProcessed(uint256 claimedSALT);\n    event POLWithdrawn(IERC20 indexed tokenA, IERC20 indexed tokenB, uint256 withdrawnA, uint256 withdrawnB);\n\n\tusing SafeERC20 for ISalt;\n\tusing SafeERC20 for IERC20;\n\tusing SafeERC20 for IUSDS;\n\n\tIPools immutable public pools;\n\tIProposals immutable public proposals;\n\tIExchangeConfig immutable public exchangeConfig;\n\tIPoolsConfig immutable public poolsConfig;\n\tIStakingConfig immutable public stakingConfig;\n\tIRewardsConfig immutable public rewardsConfig;\n\tIStableConfig immutable public stableConfig;\n\tIDAOConfig immutable public daoConfig;\n\tIPriceAggregator immutable public priceAggregator;\n\tIRewardsEmitter immutable public liquidityRewardsEmitter;\n\tICollateralAndLiquidity immutable public collateralAndLiquidity;\n\tILiquidizer immutable public liquidizer;\n\n\tISalt immutable public salt;\n    IUSDS immutable public usds;\n\tIERC20 immutable public dai;\n\n\n\t// The default IPFS URL for the website content (can be changed with a setWebsiteURL proposal)\n\tstring public websiteURL;\n\n\t// Countries that have been excluded from access to the DEX (used by AccessManager.sol)\n\t// Keys as ISO 3166 Alpha-2 Codes\n\tmapping(string=>bool) public excludedCountries;\n\n\n    constructor( IPools _pools, IProposals _proposals, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig, IRewardsConfig _rewardsConfig, IStableConfig _stableConfig, IDAOConfig _daoConfig, IPriceAggregator _priceAggregator, IRewardsEmitter _liquidityRewardsEmitter, ICollateralAndLiquidity _collateralAndLiquidity )\n\t\t{\n\t\tpools = _pools;\n\t\tproposals = _proposals;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\t\trewardsConfig = _rewardsConfig;\n\t\tstableConfig = _stableConfig;\n\t\tdaoConfig = _daoConfig;\n\t\tpriceAggregator = _priceAggregator;\n        liquidityRewardsEmitter = _liquidityRewardsEmitter;\n        collateralAndLiquidity = _collateralAndLiquidity;\n \t\tliquidizer = collateralAndLiquidity.liquidizer();\n\n        usds = exchangeConfig.usds();\n        salt = exchangeConfig.salt();\n        dai = exchangeConfig.dai();\n\n\t\t// Gas saving approves for eventually forming Protocol Owned Liquidity\n\t\tsalt.approve(address(collateralAndLiquidity), type(uint256).max);\n\t\tusds.approve(address(collateralAndLiquidity), type(uint256).max);\n\t\tdai.approve(address(collateralAndLiquidity), type(uint256).max);\n\n\t\t// Excluded by default: United States, Canada, United Kingdom, China, India, Pakistan, Russia, Afghanistan, Cuba, Iran, North Korea, Syria, Venezuela\n\t\t// Note that the DAO can remove any of these exclusions - or open up access completely to the exchange as it sees fit.\n\t\texcludedCountries[\"US\"] = true;\n\t\texcludedCountries[\"CA\"] = true;\n\t\texcludedCountries[\"GB\"] = true;\n\t\texcludedCountries[\"CN\"] = true;\n\t\texcludedCountries[\"IN\"] = true;\n\t\texcludedCountries[\"PK\"] = true;\n\t\texcludedCountries[\"RU\"] = true;\n\t\texcludedCountries[\"AF\"] = true;\n\t\texcludedCountries[\"CU\"] = true;\n\t\texcludedCountries[\"IR\"] = true;\n\t\texcludedCountries[\"KP\"] = true;\n\t\texcludedCountries[\"SY\"] = true;\n\t\texcludedCountries[\"VE\"] = true;\n        }\n\n\n\t// Finalize the vote for a parameter ballot (increase, decrease or no_change) for a given parameter\n\tfunction _finalizeParameterBallot( uint256 ballotID ) internal\n\t\t{\n\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\tVote winningVote = proposals.winningParameterVote(ballotID);\n\n\t\tif ( winningVote == Vote.INCREASE )\n\t\t\t_executeParameterChange( ParameterTypes(ballot.number1), true, poolsConfig, stakingConfig, rewardsConfig, stableConfig, daoConfig, priceAggregator );\n\t\telse if ( winningVote == Vote.DECREASE )\n\t\t\t_executeParameterChange( ParameterTypes(ballot.number1), false, poolsConfig, stakingConfig, rewardsConfig, stableConfig, daoConfig, priceAggregator );\n\n\t\t// Finalize the ballot even if NO_CHANGE won\n\t\tproposals.markBallotAsFinalized(ballotID);\n\n\t\temit BallotFinalized(ballotID, winningVote);\n\t\t}\n\n\n\tfunction _executeSetContract( Ballot memory ballot ) internal\n\t\t{\n\t\tbytes32 nameHash = keccak256(bytes( ballot.ballotName ) );\n\n\t\tif ( nameHash == keccak256(bytes( \"setContract:priceFeed1_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 1, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:priceFeed2_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 2, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:priceFeed3_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 3, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:accessManager_confirm\" )) )\n\t\t\texchangeConfig.setAccessManager( IAccessManager(ballot.address1) );\n\n\t\temit SetContract(ballot.ballotName, ballot.address1);\n\t\t}\n\n\n\tfunction _executeSetWebsiteURL( Ballot memory ballot ) internal\n\t\t{\n\t\twebsiteURL = ballot.string1;\n\t\temit SetWebsiteURL(ballot.string1);\n\t\t}\n\n\n\tfunction _executeApproval( Ballot memory ballot ) internal\n\t\t{\n\t\tif ( ballot.ballotType == BallotType.UNWHITELIST_TOKEN )\n\t\t\t{\n\t\t\t// All tokens are paired with both WBTC and WETH so unwhitelist those pools\n\t\t\tpoolsConfig.unwhitelistPool( pools, IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tpoolsConfig.unwhitelistPool( pools, IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\temit UnwhitelistToken(IERC20(ballot.address1));\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.SEND_SALT )\n\t\t\t{\n\t\t\t// Make sure the contract has the SALT balance before trying to send it.\n\t\t\t// This should not happen but is here just in case - to prevent approved proposals from reverting on finalization.\n\t\t\tif ( exchangeConfig.salt().balanceOf(address(this)) >= ballot.number1 )\n\t\t\t\t{\n\t\t\t\tIERC20(exchangeConfig.salt()).safeTransfer( ballot.address1, ballot.number1 );\n\n\t\t\t\temit SaltSent(ballot.address1, ballot.number1);\n\t\t\t\t}\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.CALL_CONTRACT )\n\t\t\t{\n\t\t\tICalledContract(ballot.address1).callFromDAO( ballot.number1 );\n\n\t\t\temit ContractCalled(ballot.address1, ballot.number1);\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.INCLUDE_COUNTRY )\n\t\t\t{\n\t\t\texcludedCountries[ ballot.string1 ] = false;\n\n\t\t\temit GeoExclusionUpdated(ballot.string1, false, exchangeConfig.accessManager().geoVersion());\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.EXCLUDE_COUNTRY )\n\t\t\t{\n\t\t\texcludedCountries[ ballot.string1 ] = true;\n\n\t\t\t// If the AccessManager doesn't implement excludedCountriesUpdated, this will revert and countries will not be able to be excluded until the AccessManager is working properly.\n\t\t\texchangeConfig.accessManager().excludedCountriesUpdated();\n\n\t\t\temit GeoExclusionUpdated(ballot.string1, true, exchangeConfig.accessManager().geoVersion());\n\t\t\t}\n\n\t\t// Once an initial setContract proposal passes, it automatically starts a second confirmation ballot (to prevent last minute approvals)\n\t\telse if ( ballot.ballotType == BallotType.SET_CONTRACT )\n\t\t\tproposals.createConfirmationProposal( string.concat(ballot.ballotName, \"_confirm\"), BallotType.CONFIRM_SET_CONTRACT, ballot.address1, \"\", ballot.description );\n\n\t\t// Once an initial setWebsiteURL proposal passes, it automatically starts a second confirmation ballot (to prevent last minute approvals)\n\t\telse if ( ballot.ballotType == BallotType.SET_WEBSITE_URL )\n\t\t\tproposals.createConfirmationProposal( string.concat(ballot.ballotName, \"_confirm\"), BallotType.CONFIRM_SET_WEBSITE_URL, address(0), ballot.string1, ballot.description );\n\n\t\telse if ( ballot.ballotType == BallotType.CONFIRM_SET_CONTRACT )\n\t\t\t_executeSetContract( ballot );\n\n\t\telse if ( ballot.ballotType == BallotType.CONFIRM_SET_WEBSITE_URL )\n\t\t\t_executeSetWebsiteURL( ballot );\n\t\t}\n\n\n\t// Finalize the vote for an approval ballot (yes or no) for a given proposal\n\tfunction _finalizeApprovalBallot( uint256 ballotID ) internal\n\t\t{\n\t\tif ( proposals.ballotIsApproved(ballotID ) )\n\t\t\t{\n\t\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\t\t\t_executeApproval( ballot );\n\t\t\t}\n\n\t\tproposals.markBallotAsFinalized(ballotID);\n\t\t}\n\n\n\t// Finalize and execute a token whitelisting ballot.\n\t// If the proposal is currently the whitelisting proposal with the most yes votes then the token can be whitelisted.\n\t// Only the top voted whitelisting proposal can be finalized - as whitelisting requires bootstrapping rewards to be sent from the DAO.\n\t// If NO > YES than the proposal is removed immediately (quorum would already have been determined - in canFinalizeBallot as called from finalizeBallot).\n\tfunction _finalizeTokenWhitelisting( uint256 ballotID ) internal\n\t\t{\n\t\tif ( proposals.ballotIsApproved(ballotID ) )\n\t\t\t{\n\t\t\t// The ballot is approved. Any reversions below will allow the ballot to be attemped to be finalized later - as the ballot won't be finalized on reversion.\n\t\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\t\tuint256 bootstrappingRewards = daoConfig.bootstrappingRewards();\n\n\t\t\t// Make sure that the DAO contract holds the required amount of SALT for bootstrappingRewards.\n\t\t\t// Twice the bootstrapping rewards are needed (for both the token/WBTC and token/WETH pools)\n\t\t\tuint256 saltBalance = exchangeConfig.salt().balanceOf( address(this) );\n\t\t\trequire( saltBalance >= bootstrappingRewards * 2, \"Whitelisting is not currently possible due to insufficient bootstrapping rewards\" );\n\n\t\t\t// Fail to whitelist for now if this isn't the whitelisting proposal with the most votes - can try again later.\n\t\t\tuint256 bestWhitelistingBallotID = proposals.tokenWhitelistingBallotWithTheMostVotes();\n\t\t\trequire( bestWhitelistingBallotID == ballotID, \"Only the token whitelisting ballot with the most votes can be finalized\" );\n\n\t\t\t// All tokens are paired with both WBTC and WETH, so whitelist both pairings\n\t\t\tpoolsConfig.whitelistPool( pools,  IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tpoolsConfig.whitelistPool( pools,  IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\tbytes32 pool1 = PoolUtils._poolID( IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tbytes32 pool2 = PoolUtils._poolID( IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\t// Send the initial bootstrappingRewards to promote initial liquidity on these two newly whitelisted pools\n\t\t\tAddedReward[] memory addedRewards = new AddedReward[](2);\n\t\t\taddedRewards[0] = AddedReward( pool1, bootstrappingRewards );\n\t\t\taddedRewards[1] = AddedReward( pool2, bootstrappingRewards );\n\n\t\t\texchangeConfig.salt().approve( address(liquidityRewardsEmitter), bootstrappingRewards * 2 );\n\t\t\tliquidityRewardsEmitter.addSALTRewards( addedRewards );\n\n\t\t\temit WhitelistToken(IERC20(ballot.address1));\n\t\t\t}\n\n\t\t// Mark the ballot as finalized (which will also remove it from the list of open token whitelisting proposals)\n\t\tproposals.markBallotAsFinalized(ballotID);\n\t\t}\n\n\n\t// Finalize the vote on a specific ballot.\n\t// Can be called by anyone, but only actually finalizes the ballot if it can be finalized.\n\tfunction finalizeBallot( uint256 ballotID ) external nonReentrant\n\t\t{\n\t\t// Checks that ballot is live, and minimumEndTime and quorum have both been reached\n\t\trequire( proposals.canFinalizeBallot(ballotID), \"The ballot is not yet able to be finalized\" );\n\n\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\tif ( ballot.ballotType == BallotType.PARAMETER )\n\t\t\t_finalizeParameterBallot(ballotID);\n\t\telse if ( ballot.ballotType == BallotType.WHITELIST_TOKEN )\n\t\t\t_finalizeTokenWhitelisting(ballotID);\n\t\telse\n\t\t\t_finalizeApprovalBallot(ballotID);\n\t\t}\n\n\n\t// Withdraw the WETH arbitrage profits deposited in the Pools contract and send them to the caller (the Upkeep contract).\n\tfunction withdrawArbitrageProfits( IERC20 weth ) external returns (uint256 withdrawnAmount)\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.withdrawArbitrageProfits is only callable from the Upkeep contract\" );\n\n\t\t// The arbitrage profits are deposited in the Pools contract as WETH and owned by the DAO.\n\t\tuint256 depositedWETH = pools.depositedUserBalance(address(this), weth );\n\t\tif ( depositedWETH == 0 )\n\t\t\treturn 0;\n\n\t\tpools.withdraw( weth, depositedWETH );\n\n\t\t// Check the WETH balance - in case any WETH was accidentally sent here previously\n\t\twithdrawnAmount = weth.balanceOf( address(this) );\n\t\tweth.safeTransfer( msg.sender, withdrawnAmount );\n\n\t\temit ArbitrageProfitsWithdrawn(msg.sender, weth, withdrawnAmount);\n\t\t}\n\n\n\t// Form SALT/USDS or USDS/DAI Protocol Owned Liquidity using the given amount of specified tokens.\n\t// Assumes that the tokens have already been transferred to this contract.\n\tfunction formPOL( IERC20 tokenA, IERC20 tokenB, uint256 amountA, uint256 amountB ) external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.formPOL is only callable from the Upkeep contract\" );\n\n\t\t// Use zapping to form the liquidity so that all the specified tokens are used\n\t\tcollateralAndLiquidity.depositLiquidityAndIncreaseShare( tokenA, tokenB, amountA, amountB, 0, block.timestamp, true );\n\n\t\temit POLFormed(tokenA, tokenB, amountA, amountB);\n\t\t}\n\n\n\tfunction processRewardsFromPOL() external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.processRewardsFromPOL is only callable from the Upkeep contract\" );\n\n\t\t// The DAO owns SALT/USDS and USDS/DAI liquidity.\n\t\tbytes32[] memory poolIDs = new bytes32[](2);\n\t\tpoolIDs[0] = PoolUtils._poolID(salt, usds);\n\t\tpoolIDs[1] = PoolUtils._poolID(usds, dai);\n\n\t\tuint256 claimedSALT = collateralAndLiquidity.claimAllRewards(poolIDs);\n\t\tif ( claimedSALT == 0 )\n\t\t\treturn;\n\n\t\t// Send 10% of the rewards to the initial team\n\t\tuint256 amountToSendToTeam = claimedSALT / 10;\n\t\tsalt.safeTransfer( exchangeConfig.managedTeamWallet().mainWallet(), amountToSendToTeam );\n\t\temit TeamRewardsTransferred(amountToSendToTeam);\n\n\t\tuint256 remainingSALT = claimedSALT - amountToSendToTeam;\n\n\t\t// Burn a default 50% of the remaining SALT that was just claimed - the rest of the SALT stays in the DAO contract.\n\t\tuint256 saltToBurn = ( remainingSALT * daoConfig.percentPolRewardsBurned() ) / 100;\n\n\t\tsalt.safeTransfer( address(salt), saltToBurn );\n\t\tsalt.burnTokensInContract();\n\n\t\temit POLProcessed(claimedSALT);\n\t\t}\n\n\n\t// Withdraws the specified amount of the Protocol Owned Liquidity from the DAO and sends the underlying tokens to the Liquidizer to be burned as USDS as needed.\n\t// Called when the amount of recovered USDS from liquidating a user's WBTC/WETH collateral is insufficient to cover burning the USDS that they had borrowed.\n\t// Only callable from the Liquidizer contract.\n\tfunction withdrawPOL( IERC20 tokenA, IERC20 tokenB, uint256 percentToLiquidate ) external\n\t\t{\n\t\trequire(msg.sender == address(liquidizer), \"DAO.withdrawProtocolOwnedLiquidity is only callable from the Liquidizer contract\" );\n\n\t\tbytes32 poolID = PoolUtils._poolID(tokenA, tokenB);\n\t\tuint256 liquidityHeld = collateralAndLiquidity.userShareForPool( address(this), poolID );\n\t\tif ( liquidityHeld == 0 )\n\t\t\treturn;\n\n\t\tuint256 liquidityToWithdraw = (liquidityHeld * percentToLiquidate) / 100;\n\n\t\t// Withdraw the specified Protocol Owned Liquidity\n\t\t(uint256 reclaimedA, uint256 reclaimedB) = collateralAndLiquidity.withdrawLiquidityAndClaim(tokenA, tokenB, liquidityToWithdraw, 0, 0, block.timestamp );\n\n\t\t// Send the withdrawn tokens to the Liquidizer so that the tokens can be swapped to USDS and burned as needed.\n\t\ttokenA.safeTransfer( address(liquidizer), reclaimedA );\n\t\ttokenB.safeTransfer( address(liquidizer), reclaimedB );\n\n\t\temit POLWithdrawn(tokenA, tokenB, reclaimedA, reclaimedB);\n\t\t}\n\n\n\t// === VIEWS ===\n\n\tfunction countryIsExcluded( string calldata country ) external view returns (bool)\n\t\t{\n\t\treturn excludedCountries[country];\n\t\t}\n\t}"
    },
    {
      "filename": "src/dao/DAO.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../price_feed/interfaces/IPriceAggregator.sol\";\nimport \"../rewards/interfaces/IRewardsEmitter.sol\";\nimport \"../rewards/interfaces/IRewardsConfig.sol\";\nimport \"../stable/interfaces/IStableConfig.sol\";\nimport \"../stable/interfaces/ILiquidizer.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"../staking/interfaces/IStaking.sol\";\nimport \"../interfaces/IAccessManager.sol\";\nimport \"./interfaces/ICalledContract.sol\";\nimport \"./interfaces/IProposals.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"../pools/PoolUtils.sol\";\nimport \"./Parameters.sol\";\nimport \"../Upkeep.sol\";\n\n\n// Allows users to propose and vote on various governance actions such as changing parameters, whitelisting/unwhitelisting tokens, sending tokens, calling other contracts, and updating the website.\n// It handles proposing ballots, tracking votes, enforcing voting requirements, and executing approved proposals.\ncontract DAO is IDAO, Parameters, ReentrancyGuard\n    {\n\tevent BallotFinalized(uint256 indexed ballotID, Vote winningVote);\n    event SetContract(string indexed ballotName, address indexed contractAddress);\n    event SetWebsiteURL(string newURL);\n    event WhitelistToken(IERC20 indexed token);\n    event UnwhitelistToken(IERC20 indexed token);\n    event GeoExclusionUpdated(string country, bool excluded, uint256 geoVersion);\n    event ArbitrageProfitsWithdrawn(address indexed upkeepContract, IERC20 indexed weth, uint256 withdrawnAmount);\n    event SaltSent(address indexed to, uint256 amount);\n    event ContractCalled(address indexed contractAddress, uint256 indexed intArg);\n    event TeamRewardsTransferred(uint256 teamAmount);\n\n    event POLFormed(IERC20 indexed tokenA, IERC20 indexed tokenB, uint256 amountA, uint256 amountB);\n    event POLProcessed(uint256 claimedSALT);\n    event POLWithdrawn(IERC20 indexed tokenA, IERC20 indexed tokenB, uint256 withdrawnA, uint256 withdrawnB);\n\n\tusing SafeERC20 for ISalt;\n\tusing SafeERC20 for IERC20;\n\tusing SafeERC20 for IUSDS;\n\n\tIPools immutable public pools;\n\tIProposals immutable public proposals;\n\tIExchangeConfig immutable public exchangeConfig;\n\tIPoolsConfig immutable public poolsConfig;\n\tIStakingConfig immutable public stakingConfig;\n\tIRewardsConfig immutable public rewardsConfig;\n\tIStableConfig immutable public stableConfig;\n\tIDAOConfig immutable public daoConfig;\n\tIPriceAggregator immutable public priceAggregator;\n\tIRewardsEmitter immutable public liquidityRewardsEmitter;\n\tICollateralAndLiquidity immutable public collateralAndLiquidity;\n\tILiquidizer immutable public liquidizer;\n\n\tISalt immutable public salt;\n    IUSDS immutable public usds;\n\tIERC20 immutable public dai;\n\n\n\t// The default IPFS URL for the website content (can be changed with a setWebsiteURL proposal)\n\tstring public websiteURL;\n\n\t// Countries that have been excluded from access to the DEX (used by AccessManager.sol)\n\t// Keys as ISO 3166 Alpha-2 Codes\n\tmapping(string=>bool) public excludedCountries;\n\n\n    constructor( IPools _pools, IProposals _proposals, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig, IRewardsConfig _rewardsConfig, IStableConfig _stableConfig, IDAOConfig _daoConfig, IPriceAggregator _priceAggregator, IRewardsEmitter _liquidityRewardsEmitter, ICollateralAndLiquidity _collateralAndLiquidity )\n\t\t{\n\t\tpools = _pools;\n\t\tproposals = _proposals;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\t\trewardsConfig = _rewardsConfig;\n\t\tstableConfig = _stableConfig;\n\t\tdaoConfig = _daoConfig;\n\t\tpriceAggregator = _priceAggregator;\n        liquidityRewardsEmitter = _liquidityRewardsEmitter;\n        collateralAndLiquidity = _collateralAndLiquidity;\n \t\tliquidizer = collateralAndLiquidity.liquidizer();\n\n        usds = exchangeConfig.usds();\n        salt = exchangeConfig.salt();\n        dai = exchangeConfig.dai();\n\n\t\t// Gas saving approves for eventually forming Protocol Owned Liquidity\n\t\tsalt.approve(address(collateralAndLiquidity), type(uint256).max);\n\t\tusds.approve(address(collateralAndLiquidity), type(uint256).max);\n\t\tdai.approve(address(collateralAndLiquidity), type(uint256).max);\n\n\t\t// Excluded by default: United States, Canada, United Kingdom, China, India, Pakistan, Russia, Afghanistan, Cuba, Iran, North Korea, Syria, Venezuela\n\t\t// Note that the DAO can remove any of these exclusions - or open up access completely to the exchange as it sees fit.\n\t\texcludedCountries[\"US\"] = true;\n\t\texcludedCountries[\"CA\"] = true;\n\t\texcludedCountries[\"GB\"] = true;\n\t\texcludedCountries[\"CN\"] = true;\n\t\texcludedCountries[\"IN\"] = true;\n\t\texcludedCountries[\"PK\"] = true;\n\t\texcludedCountries[\"RU\"] = true;\n\t\texcludedCountries[\"AF\"] = true;\n\t\texcludedCountries[\"CU\"] = true;\n\t\texcludedCountries[\"IR\"] = true;\n\t\texcludedCountries[\"KP\"] = true;\n\t\texcludedCountries[\"SY\"] = true;\n\t\texcludedCountries[\"VE\"] = true;\n        }\n\n\n\t// Finalize the vote for a parameter ballot (increase, decrease or no_change) for a given parameter\n\tfunction _finalizeParameterBallot( uint256 ballotID ) internal\n\t\t{\n\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\tVote winningVote = proposals.winningParameterVote(ballotID);\n\n\t\tif ( winningVote == Vote.INCREASE )\n\t\t\t_executeParameterChange( ParameterTypes(ballot.number1), true, poolsConfig, stakingConfig, rewardsConfig, stableConfig, daoConfig, priceAggregator );\n\t\telse if ( winningVote == Vote.DECREASE )\n\t\t\t_executeParameterChange( ParameterTypes(ballot.number1), false, poolsConfig, stakingConfig, rewardsConfig, stableConfig, daoConfig, priceAggregator );\n\n\t\t// Finalize the ballot even if NO_CHANGE won\n\t\tproposals.markBallotAsFinalized(ballotID);\n\n\t\temit BallotFinalized(ballotID, winningVote);\n\t\t}\n\n\n\tfunction _executeSetContract( Ballot memory ballot ) internal\n\t\t{\n\t\tbytes32 nameHash = keccak256(bytes( ballot.ballotName ) );\n\n\t\tif ( nameHash == keccak256(bytes( \"setContract:priceFeed1_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 1, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:priceFeed2_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 2, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:priceFeed3_confirm\" )) )\n\t\t\tpriceAggregator.setPriceFeed( 3, IPriceFeed(ballot.address1) );\n\t\telse if ( nameHash == keccak256(bytes( \"setContract:accessManager_confirm\" )) )\n\t\t\texchangeConfig.setAccessManager( IAccessManager(ballot.address1) );\n\n\t\temit SetContract(ballot.ballotName, ballot.address1);\n\t\t}\n\n\n\tfunction _executeSetWebsiteURL( Ballot memory ballot ) internal\n\t\t{\n\t\twebsiteURL = ballot.string1;\n\t\temit SetWebsiteURL(ballot.string1);\n\t\t}\n\n\n\tfunction _executeApproval( Ballot memory ballot ) internal\n\t\t{\n\t\tif ( ballot.ballotType == BallotType.UNWHITELIST_TOKEN )\n\t\t\t{\n\t\t\t// All tokens are paired with both WBTC and WETH so unwhitelist those pools\n\t\t\tpoolsConfig.unwhitelistPool( pools, IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tpoolsConfig.unwhitelistPool( pools, IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\temit UnwhitelistToken(IERC20(ballot.address1));\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.SEND_SALT )\n\t\t\t{\n\t\t\t// Make sure the contract has the SALT balance before trying to send it.\n\t\t\t// This should not happen but is here just in case - to prevent approved proposals from reverting on finalization.\n\t\t\tif ( exchangeConfig.salt().balanceOf(address(this)) >= ballot.number1 )\n\t\t\t\t{\n\t\t\t\tIERC20(exchangeConfig.salt()).safeTransfer( ballot.address1, ballot.number1 );\n\n\t\t\t\temit SaltSent(ballot.address1, ballot.number1);\n\t\t\t\t}\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.CALL_CONTRACT )\n\t\t\t{\n\t\t\tICalledContract(ballot.address1).callFromDAO( ballot.number1 );\n\n\t\t\temit ContractCalled(ballot.address1, ballot.number1);\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.INCLUDE_COUNTRY )\n\t\t\t{\n\t\t\texcludedCountries[ ballot.string1 ] = false;\n\n\t\t\temit GeoExclusionUpdated(ballot.string1, false, exchangeConfig.accessManager().geoVersion());\n\t\t\t}\n\n\t\telse if ( ballot.ballotType == BallotType.EXCLUDE_COUNTRY )\n\t\t\t{\n\t\t\texcludedCountries[ ballot.string1 ] = true;\n\n\t\t\t// If the AccessManager doesn't implement excludedCountriesUpdated, this will revert and countries will not be able to be excluded until the AccessManager is working properly.\n\t\t\texchangeConfig.accessManager().excludedCountriesUpdated();\n\n\t\t\temit GeoExclusionUpdated(ballot.string1, true, exchangeConfig.accessManager().geoVersion());\n\t\t\t}\n\n\t\t// Once an initial setContract proposal passes, it automatically starts a second confirmation ballot (to prevent last minute approvals)\n\t\telse if ( ballot.ballotType == BallotType.SET_CONTRACT )\n\t\t\tproposals.createConfirmationProposal( string.concat(ballot.ballotName, \"_confirm\"), BallotType.CONFIRM_SET_CONTRACT, ballot.address1, \"\", ballot.description );\n\n\t\t// Once an initial setWebsiteURL proposal passes, it automatically starts a second confirmation ballot (to prevent last minute approvals)\n\t\telse if ( ballot.ballotType == BallotType.SET_WEBSITE_URL )\n\t\t\tproposals.createConfirmationProposal( string.concat(ballot.ballotName, \"_confirm\"), BallotType.CONFIRM_SET_WEBSITE_URL, address(0), ballot.string1, ballot.description );\n\n\t\telse if ( ballot.ballotType == BallotType.CONFIRM_SET_CONTRACT )\n\t\t\t_executeSetContract( ballot );\n\n\t\telse if ( ballot.ballotType == BallotType.CONFIRM_SET_WEBSITE_URL )\n\t\t\t_executeSetWebsiteURL( ballot );\n\t\t}\n\n\n\t// Finalize the vote for an approval ballot (yes or no) for a given proposal\n\tfunction _finalizeApprovalBallot( uint256 ballotID ) internal\n\t\t{\n\t\tif ( proposals.ballotIsApproved(ballotID ) )\n\t\t\t{\n\t\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\t\t\t_executeApproval( ballot );\n\t\t\t}\n\n\t\tproposals.markBallotAsFinalized(ballotID);\n\t\t}\n\n\n\t// Finalize and execute a token whitelisting ballot.\n\t// If the proposal is currently the whitelisting proposal with the most yes votes then the token can be whitelisted.\n\t// Only the top voted whitelisting proposal can be finalized - as whitelisting requires bootstrapping rewards to be sent from the DAO.\n\t// If NO > YES than the proposal is removed immediately (quorum would already have been determined - in canFinalizeBallot as called from finalizeBallot).\n\tfunction _finalizeTokenWhitelisting( uint256 ballotID ) internal\n\t\t{\n\t\tif ( proposals.ballotIsApproved(ballotID ) )\n\t\t\t{\n\t\t\t// The ballot is approved. Any reversions below will allow the ballot to be attemped to be finalized later - as the ballot won't be finalized on reversion.\n\t\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\t\tuint256 bootstrappingRewards = daoConfig.bootstrappingRewards();\n\n\t\t\t// Make sure that the DAO contract holds the required amount of SALT for bootstrappingRewards.\n\t\t\t// Twice the bootstrapping rewards are needed (for both the token/WBTC and token/WETH pools)\n\t\t\tuint256 saltBalance = exchangeConfig.salt().balanceOf( address(this) );\n\t\t\trequire( saltBalance >= bootstrappingRewards * 2, \"Whitelisting is not currently possible due to insufficient bootstrapping rewards\" );\n\n\t\t\t// Fail to whitelist for now if this isn't the whitelisting proposal with the most votes - can try again later.\n\t\t\tuint256 bestWhitelistingBallotID = proposals.tokenWhitelistingBallotWithTheMostVotes();\n\t\t\trequire( bestWhitelistingBallotID == ballotID, \"Only the token whitelisting ballot with the most votes can be finalized\" );\n\n\t\t\t// All tokens are paired with both WBTC and WETH, so whitelist both pairings\n\t\t\tpoolsConfig.whitelistPool( pools,  IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tpoolsConfig.whitelistPool( pools,  IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\tbytes32 pool1 = PoolUtils._poolID( IERC20(ballot.address1), exchangeConfig.wbtc() );\n\t\t\tbytes32 pool2 = PoolUtils._poolID( IERC20(ballot.address1), exchangeConfig.weth() );\n\n\t\t\t// Send the initial bootstrappingRewards to promote initial liquidity on these two newly whitelisted pools\n\t\t\tAddedReward[] memory addedRewards = new AddedReward[](2);\n\t\t\taddedRewards[0] = AddedReward( pool1, bootstrappingRewards );\n\t\t\taddedRewards[1] = AddedReward( pool2, bootstrappingRewards );\n\n\t\t\texchangeConfig.salt().approve( address(liquidityRewardsEmitter), bootstrappingRewards * 2 );\n\t\t\tliquidityRewardsEmitter.addSALTRewards( addedRewards );\n\n\t\t\temit WhitelistToken(IERC20(ballot.address1));\n\t\t\t}\n\n\t\t// Mark the ballot as finalized (which will also remove it from the list of open token whitelisting proposals)\n\t\tproposals.markBallotAsFinalized(ballotID);\n\t\t}\n\n\n\t// Finalize the vote on a specific ballot.\n\t// Can be called by anyone, but only actually finalizes the ballot if it can be finalized.\n\tfunction finalizeBallot( uint256 ballotID ) external nonReentrant\n\t\t{\n\t\t// Checks that ballot is live, and minimumEndTime and quorum have both been reached\n\t\trequire( proposals.canFinalizeBallot(ballotID), \"The ballot is not yet able to be finalized\" );\n\n\t\tBallot memory ballot = proposals.ballotForID(ballotID);\n\n\t\tif ( ballot.ballotType == BallotType.PARAMETER )\n\t\t\t_finalizeParameterBallot(ballotID);\n\t\telse if ( ballot.ballotType == BallotType.WHITELIST_TOKEN )\n\t\t\t_finalizeTokenWhitelisting(ballotID);\n\t\telse\n\t\t\t_finalizeApprovalBallot(ballotID);\n\t\t}\n\n\n\t// Withdraw the WETH arbitrage profits deposited in the Pools contract and send them to the caller (the Upkeep contract).\n\tfunction withdrawArbitrageProfits( IERC20 weth ) external returns (uint256 withdrawnAmount)\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.withdrawArbitrageProfits is only callable from the Upkeep contract\" );\n\n\t\t// The arbitrage profits are deposited in the Pools contract as WETH and owned by the DAO.\n\t\tuint256 depositedWETH = pools.depositedUserBalance(address(this), weth );\n\t\tif ( depositedWETH == 0 )\n\t\t\treturn 0;\n\n\t\tpools.withdraw( weth, depositedWETH );\n\n\t\t// Check the WETH balance - in case any WETH was accidentally sent here previously\n\t\twithdrawnAmount = weth.balanceOf( address(this) );\n\t\tweth.safeTransfer( msg.sender, withdrawnAmount );\n\n\t\temit ArbitrageProfitsWithdrawn(msg.sender, weth, withdrawnAmount);\n\t\t}\n\n\n\t// Form SALT/USDS or USDS/DAI Protocol Owned Liquidity using the given amount of specified tokens.\n\t// Assumes that the tokens have already been transferred to this contract.\n\tfunction formPOL( IERC20 tokenA, IERC20 tokenB, uint256 amountA, uint256 amountB ) external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.formPOL is only callable from the Upkeep contract\" );\n\n\t\t// Use zapping to form the liquidity so that all the specified tokens are used\n\t\tcollateralAndLiquidity.depositLiquidityAndIncreaseShare( tokenA, tokenB, amountA, amountB, 0, block.timestamp, true );\n\n\t\temit POLFormed(tokenA, tokenB, amountA, amountB);\n\t\t}\n\n\n\tfunction processRewardsFromPOL() external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"DAO.processRewardsFromPOL is only callable from the Upkeep contract\" );\n\n\t\t// The DAO owns SALT/USDS and USDS/DAI liquidity.\n\t\tbytes32[] memory poolIDs = new bytes32[](2);\n\t\tpoolIDs[0] = PoolUtils._poolID(salt, usds);\n\t\tpoolIDs[1] = PoolUtils._poolID(usds, dai);\n\n\t\tuint256 claimedSALT = collateralAndLiquidity.claimAllRewards(poolIDs);\n\t\tif ( claimedSALT == 0 )\n\t\t\treturn;\n\n\t\t// Send 10% of the rewar"
    }
  ]
}