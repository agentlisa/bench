{
  "Title": "[G-06] Using storage instead of memory for structs/arrays saves gas (**Not found by the bot**)",
  "Content": "\n### ODSafeManager.sol.transferSAFEOwnership(): Use storage for `_sData`\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/ODSafeManager.sol#L136-L152\n```solidity\nFile: /src/contracts/proxies/ODSafeManager.sol\n136:  function transferSAFEOwnership(uint256 _safe, address _dst) external {\n\n140:    SAFEData memory _sData = _safeData[_safe];\n141:    if (_dst == _sData.owner) revert AlreadySafeOwner();\n\n143:    _usrSafes[_sData.owner].remove(_safe);\n144:    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n\n146:    _usrSafes[_dst].add(_safe);\n147:    _usrSafesPerCollat[_dst][_sData.collateralType].add(_safe);\n\n149:    _safeData[_safe].owner = _dst;\n\n151:    emit TransferSAFEOwnership(msg.sender, _safe, _dst);\n152:  }\n```\nAfter changing to storage, we cache the fields that are being read several times\n```diff\ndiff --git a/src/contracts/proxies/ODSafeManager.sol b/src/contracts/proxies/ODS\nafeManager.sol\nindex b3ab2f5..0b2346b 100644\n--- a/src/contracts/proxies/ODSafeManager.sol\n+++ b/src/contracts/proxies/ODSafeManager.sol\n@@ -137,14 +137,16 @@ contract ODSafeManager is IODSafeManager {\n     require(msg.sender == address(vault721), 'SafeMngr: Only Vault721');\n\n     if (_dst == address(0)) revert ZeroAddress();\n-    SAFEData memory _sData = _safeData[_safe];\n-    if (_dst == _sData.owner) revert AlreadySafeOwner();\n+    SAFEData storage _sData = _safeData[_safe];\n+    address _owner = _sData.owner;\n+    if (_dst == _owner) revert AlreadySafeOwner();\n\n-    _usrSafes[_sData.owner].remove(_safe);\n-    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n+    _usrSafes[_owner].remove(_safe);\n+    bytes32 _collateralType = _sData.collateralType;\n+    _usrSafesPerCollat[_owner][_collateralType].remove(_safe);\n\n     _usrSafes[_dst].add(_safe);\n-    _usrSafesPerCollat[_dst][_sData.collateralType].add(_safe);\n+    _usrSafesPerCollat[_dst][_collateralType].add(_safe);\n\n+     _sData.owner = _dst;\n\n```\n\n### ODSafeManager.sol.modifySAFECollateralization(): Use storage for `_sData` and cache fields being called repeatedly\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/ODSafeManager.sol#L155-L165\n```solidity\nFile: /src/contracts/proxies/ODSafeManager.sol\n155:  function modifySAFECollateralization(\n156:    uint256 _safe,\n157:    int256 _deltaCollateral,\n158:    int256 _deltaDebt\n159:  ) external safeAllowed(_safe) {\n160:    SAFEData memory _sData = _safeData[_safe];\n161:    ISAFEEngine(safeEngine).modifySAFECollateralization(\n162:      _sData.collateralType, _sData.safeHandler, _sData.safeHandler, _sData.safeHandler, _deltaCollateral, _deltaDebt\n163:    );\n164:    emit ModifySAFECollateralization(msg.sender, _safe, _deltaCollateral, _deltaDebt);\n165: }\n```\n\n```diff\ndiff --git a/src/contracts/proxies/ODSafeManager.sol b/src/contracts/proxies/ODS\nafeManager.sol\nindex b3ab2f5..4d6e7ab 100644\n--- a/src/contracts/proxies/ODSafeManager.sol\n+++ b/src/contracts/proxies/ODSafeManager.sol\n@@ -157,9 +157,10 @@ contract ODSafeManager is IODSafeManager {\n     int256 _deltaCollateral,\n     int256 _deltaDebt\n   ) external safeAllowed(_safe) {\n-    SAFEData memory _sData = _safeData[_safe];\n+    SAFEData storage _sData = _safeData[_safe];\n+    address _safeHandler = _sData.safeHandler;\n     ISAFEEngine(safeEngine).modifySAFECollateralization(\n-      _sData.collateralType, _sData.safeHandler, _sData.safeHandler, _sData.safeHandler, _deltaCollateral, _deltaDebt\n+      _sData.collateralType, _safeHandler, _safeHandler, _safeHandler, _deltaCollateral, _deltaDebt\n     );\n     emit ModifySAFECollateralization(msg.sender, _safe, _deltaCollateral, _deltaDebt);\n   }\n```\n\n### ODSafeManager.sol.transferCollateral(): Use storage for `_sData`\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/ODSafeManager.sol#L168-L172\n```solidity\nFile: /src/contracts/proxies/ODSafeManager.sol\n168:  function transferCollateral(uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n169:    SAFEData memory _sData = _safeData[_safe];\n170:    ISAFEEngine(safeEngine).transferCollateral(_sData.collateralType, _sData.safeHandler, _dst, _wad);\n171:    emit TransferCollateral(msg.sender, _safe, _dst, _wad);\n172:  }\n```\n\n```diff\n   function transferCollateral(uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n-    SAFEData memory _sData = _safeData[_safe];\n+    SAFEData storage _sData = _safeData[_safe];\n     ISAFEEngine(safeEngine).transferCollateral(_sData.collateralType, _sData.safeHandler, _dst, _wad);\n     emit TransferCollateral(msg.sender, _safe, _dst, _wad);\n   }\n```\n\n### ODSafeManager.sol.quitSystem(): Use storage for `_sData` and cache repeatedly read fields\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/ODSafeManager.sol#L189-L202\n\n**The bot only suggested changing `_safeInfo`** - `We can actually optimize more` \n\n```solidity\nFile: /src/contracts/proxies/ODSafeManager.sol\n189:  function quitSystem(uint256 _safe, address _dst) external safeAllowed(_safe) handlerAllowed(_dst) {\n190:    SAFEData memory _sData = _safeData[_safe];\n191:    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n192:    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n193:    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n194:    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n195:      _sData.collateralType, _sData.safeHandler, _dst, _deltaCollateral, _deltaDebt\n196:    );\n\n198:    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n199:    _usrSafes[_sData.owner].remove(_safe);\n200:    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n201:    emit QuitSystem(msg.sender, _safe, _dst);\n202:  }\n```\n\n```diff\n   function quitSystem(uint256 _safe, address _dst) external safeAllowed(_safe) handlerAllowed(_dst) {\n-    SAFEData memory _sData = _safeData[_safe];\n-    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n+    SAFEData storage _sData = _safeData[_safe];\n+    bytes32 _collateralType= _sData.collateralType;\n+    address _safeHandler = _sData.safeHandler;\n+    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_collateralType, _safeHandler);\n     int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n     int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n     ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n-      _sData.collateralType, _sData.safeHandler, _dst, _deltaCollateral, _deltaDebt\n+      _collateralType, _safeHandler, _dst, _deltaCollateral, _deltaDebt\n     );\n+    address _owner = _sData.owner;\n\n     // Remove safe from owner's list (notice it doesn't erase safe ownership)\n-    _usrSafes[_sData.owner].remove(_safe);\n-    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n+    _usrSafes[_owner].remove(_safe);\n+    _usrSafesPerCollat[_owner][_collateralType].remove(_safe);\n     emit QuitSystem(msg.sender, _safe, _dst);\n   }\n\n```\n\n### ODSafeManager.sol.enterSystem(): Use storage for `_sData` and cache repeatedly read fields\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/ODSafeManager.sol#L205-L214\n\n**The bot only suggested changing `_safeInfo`** - `We can actually optimize more` \n\n```solidity\nFile: /src/contracts/proxies/ODSafeManager.sol\n205:  function enterSystem(address _src, uint256 _safe) external handlerAllowed(_src) safeAllowed(_safe) {\n206:    SAFEData memory _sData = _safeData[_safe];\n207:    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n208:    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n209:    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n210:    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n211:      _sData.collateralType, _src, _sData.safeHandler, _deltaCollateral, _deltaDebt\n212:    );\n213:    emit EnterSystem(msg.sender, _src, _safe);\n214:  }\n```\n\n```diff\n   function enterSystem(address _src, uint256 _safe) external handlerAllowed(_src) safeAllowed(_safe) {\n-    SAFEData memory _sData = _safeData[_safe];\n-    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n+    SAFEData storage _sData = _safeData[_safe];\n+    bytes32 _collateralType = _sData.collateralType;\n+    address _safeHandler = _sData.safeHandler;\n+    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_collateralType, _safeHandler);\n     int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n     int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n     ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n-      _sData.collateralType, _src, _sData.safeHandler, _deltaCollateral, _deltaDebt\n+      _collateralType, _src, _safeHandler, _deltaCollateral, _deltaDebt\n     );\n     emit EnterSystem(msg.sender, _src, _safe);\n   }\n```\n\n### ODSafeManager.sol.moveSAFE(): Use storage for `_srcData,_dstData` and cache repeatedly read fields\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/ODSafeManager.sol#L217-L232\n\n**The bot only suggested changing `_safeInfo`** - `We can actually optimize more` \n\n```solidity\nFile: /src/contracts/proxies/ODSafeManager.sol\n217:  function moveSAFE(uint256 _safeSrc, uint256 _safeDst) external safeAllowed(_safeSrc) safeAllowed(_safeDst) {\n218:    SAFEData memory _srcData = _safeData[_safeSrc];\n219:    SAFEData memory _dstData = _safeData[_safeDst];\n220:    if (_srcData.collateralType != _dstData.collateralType) revert CollateralTypesMismatch();\n221:    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_srcData.collateralType, _srcData.safeHandler);\n222:    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n223:    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n224:    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n225:      _srcData.collateralType, _srcData.safeHandler, _dstData.safeHandler, _deltaCollateral, _deltaDebt\n226:    );\n\n228:    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n229:    _usrSafes[_srcData.owner].remove(_safeSrc);\n230:    _usrSafesPerCollat[_srcData.owner][_srcData.collateralType].remove(_safeSrc);\n231:    emit MoveSAFE(msg.sender, _safeSrc, _safeDst);\n232:  }\n```\n\n```diff\n   function moveSAFE(uint256 _safeSrc, uint256 _safeDst) external safeAllowed(_safeSrc) safeAllowed(_safeDst) {\n-    SAFEData memory _srcData = _safeData[_safeSrc];\n-    SAFEData memory _dstData = _safeData[_safeDst];\n-    if (_srcData.collateralType != _dstData.collateralType) revert CollateralTypesMismatch();\n-    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_srcData.collateralType, _srcData.safeHandler);\n+    SAFEData storage _srcData = _safeData[_safeSrc];\n+    SAFEData storage _dstData = _safeData[_safeDst];\n+\n+    bytes32 _srcDataCollateralType= _srcData.collateralType;\n+\n+    if (_srcDataCollateralType != _dstData.collateralType) revert CollateralTypesMismatch();\n+    address _srcDataOwner = _srcData.owner;\n+    address _srcDataSafeHandler = _srcData.safeHandler;\n+\n+    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_srcDataCollateralType, _srcDataSafeHandler);\n     int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n     int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n     ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n-      _srcData.collateralType, _srcData.safeHandler, _dstData.safeHandler, _deltaCollateral, _deltaDebt\n+      _srcDataCollateralType, _srcDataSafeHandler, _dstData.safeHandler, _deltaCollateral, _deltaDebt\n     );\n\n     // Remove safe from owner's list (notice it doesn't erase safe ownership)\n-    _usrSafes[_srcData.owner].remove(_safeSrc);\n-    _usrSafesPerCollat[_srcData.owner][_srcData.collateralType].remove(_safeSrc);\n+    _usrSafes[_srcDataOwner].remove(_safeSrc);\n+    _usrSafesPerCollat[_srcDataOwner][_srcDataCollateralType].remove(_safeSrc);\n     emit MoveSAFE(msg.sender, _safeSrc, _safeDst);\n   }\n```\n\n### ODSafeManager.sol.removeSAFE(): Use storage for `_sData` and cache repeatedly read fields\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/ODSafeManager.sol#L242-L246\n```solidity\nFile: /src/contracts/proxies/ODSafeManager.sol\n242:  function removeSAFE(uint256 _safe) external safeAllowed(_safe) {\n243:    SAFEData memory _sData = _safeData[_safe];\n244:    _usrSafes[_sData.owner].remove(_safe);\n245:    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n246:  }\n```\n\n```diff\n   function removeSAFE(uint256 _safe) external safeAllowed(_safe) {\n-    SAFEData memory _sData = _safeData[_safe];\n-    _usrSafes[_sData.owner].remove(_safe);\n-    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n+    SAFEData storage _sData = _safeData[_safe];\n+    address _owner = _sData.owner;\n+    _usrSafes[_owner].remove(_safe);\n+    _usrSafesPerCollat[_owner][_sData.collateralType].remove(_safe);\n   }\n```\n\n### ODSafeManager.sol.protectSAFE(): Use storage for `_sData` and cache repeatedly read fields\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/ODSafeManager.sol#L249-L253\n```solidity\nFile: /src/contracts/proxies/ODSafeManager.sol\n249:  function protectSAFE(uint256 _safe, address _liquidationEngine, address _saviour) external safeAllowed(_safe) {\n250:    SAFEData memory _sData = _safeData[_safe];\n251:    ILiquidationEngine(_liquidationEngine).protectSAFE(_sData.collateralType, _sData.safeHandler, _saviour);\n252:    emit ProtectSAFE(msg.sender, _safe, _liquidationEngine, _saviour);\n253:  }\n```\n\n```diff\n   function protectSAFE(uint256 _safe, address _liquidationEngine, address _saviour) external safeAllowed(_safe) {\n-    SAFEData memory _sData = _safeData[_safe];\n+    SAFEData storage _sData = _safeData[_safe];\n     ILiquidationEngine(_liquidationEngine).protectSAFE(_sData.collateralType, _sData.safeHandler, _saviour);\n     emit ProtectSAFE(msg.sender, _safe, _liquidationEngine, _saviour);\n   }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-opendollar",
  "Code": [
    {
      "filename": "src/contracts/proxies/ODSafeManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {SAFEHandler} from '@contracts/proxies/SAFEHandler.sol';\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ILiquidationEngine} from '@interfaces/ILiquidationEngine.sol';\nimport {IVault721} from '@interfaces/proxies/IVault721.sol';\n\nimport {Math} from '@libraries/Math.sol';\nimport {EnumerableSet} from '@openzeppelin/utils/structs/EnumerableSet.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\n\nimport {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\n\n/**\n * @title  ODSafeManager\n * @notice This contract acts as interface to the SAFEEngine, facilitating the management of SAFEs\n * @dev    This contract is meant to be used by users that interact with the protocol through a proxy contract\n */\ncontract ODSafeManager is IODSafeManager {\n  using Math for uint256;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using Assertions for address;\n\n  /// @inheritdoc IODSafeManager\n  address public safeEngine;\n\n  // --- ERC721 ---\n  IVault721 public vault721;\n\n  uint256 internal _safeId; // Auto incremental\n  mapping(address _safeOwner => EnumerableSet.UintSet) private _usrSafes;\n  /// @notice Mapping of user addresses to their enumerable set of safes per collateral type\n  mapping(address _safeOwner => mapping(bytes32 _cType => EnumerableSet.UintSet)) private _usrSafesPerCollat;\n  /// @notice Mapping of safe ids to their data\n  mapping(uint256 _safeId => SAFEData) internal _safeData;\n\n  /// @inheritdoc IODSafeManager\n  mapping(address _owner => mapping(uint256 _safeId => mapping(address _caller => uint256 _ok))) public safeCan;\n  /// @inheritdoc IODSafeManager\n  mapping(address _safeHandler => mapping(address _caller => uint256 _ok)) public handlerCan;\n\n  // --- Modifiers ---\n\n  /**\n   * @notice Checks if the sender is the owner of the safe or the safe has permissions to call the function\n   * @param  _safe Id of the safe to check if msg.sender has permissions for\n   */\n  modifier safeAllowed(uint256 _safe) {\n    address _owner = _safeData[_safe].owner;\n    if (msg.sender != _owner && safeCan[_owner][_safe][msg.sender] == 0) revert SafeNotAllowed();\n    _;\n  }\n\n  /**\n   * @notice Checks if the sender is the safe handler has permissions to call the function\n   * @param  _handler Address of the handler to check if msg.sender has permissions for\n   */\n  modifier handlerAllowed(address _handler) {\n    if (msg.sender != _handler && handlerCan[_handler][msg.sender] == 0) revert HandlerNotAllowed();\n    _;\n  }\n\n  constructor(address _safeEngine, address _vault721) {\n    safeEngine = _safeEngine.assertNonNull();\n    vault721 = IVault721(_vault721);\n    vault721.initializeManager();\n  }\n\n  // --- Getters ---\n\n  /// @inheritdoc IODSafeManager\n  function getSafes(address _usr) external view returns (uint256[] memory _safes) {\n    _safes = _usrSafes[_usr].values();\n  }\n\n  /// @inheritdoc IODSafeManager\n  function getSafes(address _usr, bytes32 _cType) external view returns (uint256[] memory _safes) {\n    _safes = _usrSafesPerCollat[_usr][_cType].values();\n  }\n\n  /// @inheritdoc IODSafeManager\n  function getSafesData(address _usr)\n    external\n    view\n    returns (uint256[] memory _safes, address[] memory _safeHandlers, bytes32[] memory _cTypes)\n  {\n    _safes = _usrSafes[_usr].values();\n    _safeHandlers = new address[](_safes.length);\n    _cTypes = new bytes32[](_safes.length);\n    for (uint256 _i; _i < _safes.length; _i++) {\n      _safeHandlers[_i] = _safeData[_safes[_i]].safeHandler;\n      _cTypes[_i] = _safeData[_safes[_i]].collateralType;\n    }\n  }\n\n  /// @inheritdoc IODSafeManager\n  function safeData(uint256 _safe) external view returns (SAFEData memory _sData) {\n    _sData = _safeData[_safe];\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IODSafeManager\n  function allowSAFE(uint256 _safe, address _usr, uint256 _ok) external safeAllowed(_safe) {\n    address _owner = _safeData[_safe].owner;\n    safeCan[_owner][_safe][_usr] = _ok;\n    emit AllowSAFE(msg.sender, _safe, _usr, _ok);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function allowHandler(address _usr, uint256 _ok) external {\n    handlerCan[msg.sender][_usr] = _ok;\n    emit AllowHandler(msg.sender, _usr, _ok);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function openSAFE(bytes32 _cType, address _usr) external returns (uint256 _id) {\n    if (_usr == address(0)) revert ZeroAddress();\n\n    ++_safeId;\n    address _safeHandler = address(new SAFEHandler(safeEngine));\n\n    _safeData[_safeId] = SAFEData({owner: _usr, safeHandler: _safeHandler, collateralType: _cType});\n\n    _usrSafes[_usr].add(_safeId);\n    _usrSafesPerCollat[_usr][_cType].add(_safeId);\n\n    vault721.mint(_usr, _safeId);\n\n    emit OpenSAFE(msg.sender, _usr, _safeId);\n    return _safeId;\n  }\n\n  // Give the safe ownership to a dst address.\n  function transferSAFEOwnership(uint256 _safe, address _dst) external {\n    require(msg.sender == address(vault721), 'SafeMngr: Only Vault721');\n\n    if (_dst == address(0)) revert ZeroAddress();\n    SAFEData memory _sData = _safeData[_safe];\n    if (_dst == _sData.owner) revert AlreadySafeOwner();\n\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n\n    _usrSafes[_dst].add(_safe);\n    _usrSafesPerCollat[_dst][_sData.collateralType].add(_safe);\n\n    _safeData[_safe].owner = _dst;\n\n    emit TransferSAFEOwnership(msg.sender, _safe, _dst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function modifySAFECollateralization(\n    uint256 _safe,\n    int256 _deltaCollateral,\n    int256 _deltaDebt\n  ) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).modifySAFECollateralization(\n      _sData.collateralType, _sData.safeHandler, _sData.safeHandler, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit ModifySAFECollateralization(msg.sender, _safe, _deltaCollateral, _deltaDebt);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferCollateral(uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferCollateral(_sData.collateralType, _sData.safeHandler, _dst, _wad);\n    emit TransferCollateral(msg.sender, _safe, _dst, _wad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferCollateral(bytes32 _cType, uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferCollateral(_cType, _sData.safeHandler, _dst, _wad);\n    emit TransferCollateral(msg.sender, _cType, _safe, _dst, _wad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferInternalCoins(uint256 _safe, address _dst, uint256 _rad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferInternalCoins(_sData.safeHandler, _dst, _rad);\n    emit TransferInternalCoins(msg.sender, _safe, _dst, _rad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function quitSystem(uint256 _safe, address _dst) external safeAllowed(_safe) handlerAllowed(_dst) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _sData.collateralType, _sData.safeHandler, _dst, _deltaCollateral, _deltaDebt\n    );\n\n    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n    emit QuitSystem(msg.sender, _safe, _dst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function enterSystem(address _src, uint256 _safe) external handlerAllowed(_src) safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _sData.collateralType, _src, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit EnterSystem(msg.sender, _src, _safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function moveSAFE(uint256 _safeSrc, uint256 _safeDst) external safeAllowed(_safeSrc) safeAllowed(_safeDst) {\n    SAFEData memory _srcData = _safeData[_safeSrc];\n    SAFEData memory _dstData = _safeData[_safeDst];\n    if (_srcData.collateralType != _dstData.collateralType) revert CollateralTypesMismatch();\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_srcData.collateralType, _srcData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _srcData.collateralType, _srcData.safeHandler, _dstData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n\n    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n    _usrSafes[_srcData.owner].remove(_safeSrc);\n    _usrSafesPerCollat[_srcData.owner][_srcData.collateralType].remove(_safeSrc);\n    emit MoveSAFE(msg.sender, _safeSrc, _safeDst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function addSAFE(uint256 _safe) external {\n    SAFEData memory _sData = _safeData[_safe];\n    _usrSafes[msg.sender].add(_safe);\n    _usrSafesPerCollat[msg.sender][_sData.collateralType].add(_safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function removeSAFE(uint256 _safe) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function protectSAFE(uint256 _safe, address _liquidationEngine, address _saviour) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ILiquidationEngine(_liquidationEngine).protectSAFE(_sData.collateralType, _sData.safeHandler, _saviour);\n    emit ProtectSAFE(msg.sender, _safe, _liquidationEngine, _saviour);\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/ODSafeManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {SAFEHandler} from '@contracts/proxies/SAFEHandler.sol';\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ILiquidationEngine} from '@interfaces/ILiquidationEngine.sol';\nimport {IVault721} from '@interfaces/proxies/IVault721.sol';\n\nimport {Math} from '@libraries/Math.sol';\nimport {EnumerableSet} from '@openzeppelin/utils/structs/EnumerableSet.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\n\nimport {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\n\n/**\n * @title  ODSafeManager\n * @notice This contract acts as interface to the SAFEEngine, facilitating the management of SAFEs\n * @dev    This contract is meant to be used by users that interact with the protocol through a proxy contract\n */\ncontract ODSafeManager is IODSafeManager {\n  using Math for uint256;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using Assertions for address;\n\n  /// @inheritdoc IODSafeManager\n  address public safeEngine;\n\n  // --- ERC721 ---\n  IVault721 public vault721;\n\n  uint256 internal _safeId; // Auto incremental\n  mapping(address _safeOwner => EnumerableSet.UintSet) private _usrSafes;\n  /// @notice Mapping of user addresses to their enumerable set of safes per collateral type\n  mapping(address _safeOwner => mapping(bytes32 _cType => EnumerableSet.UintSet)) private _usrSafesPerCollat;\n  /// @notice Mapping of safe ids to their data\n  mapping(uint256 _safeId => SAFEData) internal _safeData;\n\n  /// @inheritdoc IODSafeManager\n  mapping(address _owner => mapping(uint256 _safeId => mapping(address _caller => uint256 _ok))) public safeCan;\n  /// @inheritdoc IODSafeManager\n  mapping(address _safeHandler => mapping(address _caller => uint256 _ok)) public handlerCan;\n\n  // --- Modifiers ---\n\n  /**\n   * @notice Checks if the sender is the owner of the safe or the safe has permissions to call the function\n   * @param  _safe Id of the safe to check if msg.sender has permissions for\n   */\n  modifier safeAllowed(uint256 _safe) {\n    address _owner = _safeData[_safe].owner;\n    if (msg.sender != _owner && safeCan[_owner][_safe][msg.sender] == 0) revert SafeNotAllowed();\n    _;\n  }\n\n  /**\n   * @notice Checks if the sender is the safe handler has permissions to call the function\n   * @param  _handler Address of the handler to check if msg.sender has permissions for\n   */\n  modifier handlerAllowed(address _handler) {\n    if (msg.sender != _handler && handlerCan[_handler][msg.sender] == 0) revert HandlerNotAllowed();\n    _;\n  }\n\n  constructor(address _safeEngine, address _vault721) {\n    safeEngine = _safeEngine.assertNonNull();\n    vault721 = IVault721(_vault721);\n    vault721.initializeManager();\n  }\n\n  // --- Getters ---\n\n  /// @inheritdoc IODSafeManager\n  function getSafes(address _usr) external view returns (uint256[] memory _safes) {\n    _safes = _usrSafes[_usr].values();\n  }\n\n  /// @inheritdoc IODSafeManager\n  function getSafes(address _usr, bytes32 _cType) external view returns (uint256[] memory _safes) {\n    _safes = _usrSafesPerCollat[_usr][_cType].values();\n  }\n\n  /// @inheritdoc IODSafeManager\n  function getSafesData(address _usr)\n    external\n    view\n    returns (uint256[] memory _safes, address[] memory _safeHandlers, bytes32[] memory _cTypes)\n  {\n    _safes = _usrSafes[_usr].values();\n    _safeHandlers = new address[](_safes.length);\n    _cTypes = new bytes32[](_safes.length);\n    for (uint256 _i; _i < _safes.length; _i++) {\n      _safeHandlers[_i] = _safeData[_safes[_i]].safeHandler;\n      _cTypes[_i] = _safeData[_safes[_i]].collateralType;\n    }\n  }\n\n  /// @inheritdoc IODSafeManager\n  function safeData(uint256 _safe) external view returns (SAFEData memory _sData) {\n    _sData = _safeData[_safe];\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IODSafeManager\n  function allowSAFE(uint256 _safe, address _usr, uint256 _ok) external safeAllowed(_safe) {\n    address _owner = _safeData[_safe].owner;\n    safeCan[_owner][_safe][_usr] = _ok;\n    emit AllowSAFE(msg.sender, _safe, _usr, _ok);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function allowHandler(address _usr, uint256 _ok) external {\n    handlerCan[msg.sender][_usr] = _ok;\n    emit AllowHandler(msg.sender, _usr, _ok);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function openSAFE(bytes32 _cType, address _usr) external returns (uint256 _id) {\n    if (_usr == address(0)) revert ZeroAddress();\n\n    ++_safeId;\n    address _safeHandler = address(new SAFEHandler(safeEngine));\n\n    _safeData[_safeId] = SAFEData({owner: _usr, safeHandler: _safeHandler, collateralType: _cType});\n\n    _usrSafes[_usr].add(_safeId);\n    _usrSafesPerCollat[_usr][_cType].add(_safeId);\n\n    vault721.mint(_usr, _safeId);\n\n    emit OpenSAFE(msg.sender, _usr, _safeId);\n    return _safeId;\n  }\n\n  // Give the safe ownership to a dst address.\n  function transferSAFEOwnership(uint256 _safe, address _dst) external {\n    require(msg.sender == address(vault721), 'SafeMngr: Only Vault721');\n\n    if (_dst == address(0)) revert ZeroAddress();\n    SAFEData memory _sData = _safeData[_safe];\n    if (_dst == _sData.owner) revert AlreadySafeOwner();\n\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n\n    _usrSafes[_dst].add(_safe);\n    _usrSafesPerCollat[_dst][_sData.collateralType].add(_safe);\n\n    _safeData[_safe].owner = _dst;\n\n    emit TransferSAFEOwnership(msg.sender, _safe, _dst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function modifySAFECollateralization(\n    uint256 _safe,\n    int256 _deltaCollateral,\n    int256 _deltaDebt\n  ) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).modifySAFECollateralization(\n      _sData.collateralType, _sData.safeHandler, _sData.safeHandler, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit ModifySAFECollateralization(msg.sender, _safe, _deltaCollateral, _deltaDebt);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferCollateral(uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferCollateral(_sData.collateralType, _sData.safeHandler, _dst, _wad);\n    emit TransferCollateral(msg.sender, _safe, _dst, _wad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferCollateral(bytes32 _cType, uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferCollateral(_cType, _sData.safeHandler, _dst, _wad);\n    emit TransferCollateral(msg.sender, _cType, _safe, _dst, _wad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferInternalCoins(uint256 _safe, address _dst, uint256 _rad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferInternalCoins(_sData.safeHandler, _dst, _rad);\n    emit TransferInternalCoins(msg.sender, _safe, _dst, _rad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function quitSystem(uint256 _safe, address _dst) external safeAllowed(_safe) handlerAllowed(_dst) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _sData.collateralType, _sData.safeHandler, _dst, _deltaCollateral, _deltaDebt\n    );\n\n    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n    emit QuitSystem(msg.sender, _safe, _dst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function enterSystem(address _src, uint256 _safe) external handlerAllowed(_src) safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _sData.collateralType, _src, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit EnterSystem(msg.sender, _src, _safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function moveSAFE(uint256 _safeSrc, uint256 _safeDst) external safeAllowed(_safeSrc) safeAllowed(_safeDst) {\n    SAFEData memory _srcData = _safeData[_safeSrc];\n    SAFEData memory _dstData = _safeData[_safeDst];\n    if (_srcData.collateralType != _dstData.collateralType) revert CollateralTypesMismatch();\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_srcData.collateralType, _srcData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _srcData.collateralType, _srcData.safeHandler, _dstData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n\n    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n    _usrSafes[_srcData.owner].remove(_safeSrc);\n    _usrSafesPerCollat[_srcData.owner][_srcData.collateralType].remove(_safeSrc);\n    emit MoveSAFE(msg.sender, _safeSrc, _safeDst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function addSAFE(uint256 _safe) external {\n    SAFEData memory _sData = _safeData[_safe];\n    _usrSafes[msg.sender].add(_safe);\n    _usrSafesPerCollat[msg.sender][_sData.collateralType].add(_safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function removeSAFE(uint256 _safe) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function protectSAFE(uint256 _safe, address _liquidationEngine, address _saviour) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ILiquidationEngine(_liquidationEngine).protectSAFE(_sData.collateralType, _sData.safeHandler, _saviour);\n    emit ProtectSAFE(msg.sender, _safe, _liquidationEngine, _saviour);\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/ODSafeManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {SAFEHandler} from '@contracts/proxies/SAFEHandler.sol';\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ILiquidationEngine} from '@interfaces/ILiquidationEngine.sol';\nimport {IVault721} from '@interfaces/proxies/IVault721.sol';\n\nimport {Math} from '@libraries/Math.sol';\nimport {EnumerableSet} from '@openzeppelin/utils/structs/EnumerableSet.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\n\nimport {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\n\n/**\n * @title  ODSafeManager\n * @notice This contract acts as interface to the SAFEEngine, facilitating the management of SAFEs\n * @dev    This contract is meant to be used by users that interact with the protocol through a proxy contract\n */\ncontract ODSafeManager is IODSafeManager {\n  using Math for uint256;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using Assertions for address;\n\n  /// @inheritdoc IODSafeManager\n  address public safeEngine;\n\n  // --- ERC721 ---\n  IVault721 public vault721;\n\n  uint256 internal _safeId; // Auto incremental\n  mapping(address _safeOwner => EnumerableSet.UintSet) private _usrSafes;\n  /// @notice Mapping of user addresses to their enumerable set of safes per collateral type\n  mapping(address _safeOwner => mapping(bytes32 _cType => EnumerableSet.UintSet)) private _usrSafesPerCollat;\n  /// @notice Mapping of safe ids to their data\n  mapping(uint256 _safeId => SAFEData) internal _safeData;\n\n  /// @inheritdoc IODSafeManager\n  mapping(address _owner => mapping(uint256 _safeId => mapping(address _caller => uint256 _ok))) public safeCan;\n  /// @inheritdoc IODSafeManager\n  mapping(address _safeHandler => mapping(address _caller => uint256 _ok)) public handlerCan;\n\n  // --- Modifiers ---\n\n  /**\n   * @notice Checks if the sender is the owner of the safe or the safe has permissions to call the function\n   * @param  _safe Id of the safe to check if msg.sender has permissions for\n   */\n  modifier safeAllowed(uint256 _safe) {\n    address _owner = _safeData[_safe].owner;\n    if (msg.sender != _owner && safeCan[_owner][_safe][msg.sender] == 0) revert SafeNotAllowed();\n    _;\n  }\n\n  /**\n   * @notice Checks if the sender is the safe handler has permissions to call the function\n   * @param  _handler Address of the handler to check if msg.sender has permissions for\n   */\n  modifier handlerAllowed(address _handler) {\n    if (msg.sender != _handler && handlerCan[_handler][msg.sender] == 0) revert HandlerNotAllowed();\n    _;\n  }\n\n  constructor(address _safeEngine, address _vault721) {\n    safeEngine = _safeEngine.assertNonNull();\n    vault721 = IVault721(_vault721);\n    vault721.initializeManager();\n  }\n\n  // --- Getters ---\n\n  /// @inheritdoc IODSafeManager\n  function getSafes(address _usr) external view returns (uint256[] memory _safes) {\n    _safes = _usrSafes[_usr].values();\n  }\n\n  /// @inheritdoc IODSafeManager\n  function getSafes(address _usr, bytes32 _cType) external view returns (uint256[] memory _safes) {\n    _safes = _usrSafesPerCollat[_usr][_cType].values();\n  }\n\n  /// @inheritdoc IODSafeManager\n  function getSafesData(address _usr)\n    external\n    view\n    returns (uint256[] memory _safes, address[] memory _safeHandlers, bytes32[] memory _cTypes)\n  {\n    _safes = _usrSafes[_usr].values();\n    _safeHandlers = new address[](_safes.length);\n    _cTypes = new bytes32[](_safes.length);\n    for (uint256 _i; _i < _safes.length; _i++) {\n      _safeHandlers[_i] = _safeData[_safes[_i]].safeHandler;\n      _cTypes[_i] = _safeData[_safes[_i]].collateralType;\n    }\n  }\n\n  /// @inheritdoc IODSafeManager\n  function safeData(uint256 _safe) external view returns (SAFEData memory _sData) {\n    _sData = _safeData[_safe];\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IODSafeManager\n  function allowSAFE(uint256 _safe, address _usr, uint256 _ok) external safeAllowed(_safe) {\n    address _owner = _safeData[_safe].owner;\n    safeCan[_owner][_safe][_usr] = _ok;\n    emit AllowSAFE(msg.sender, _safe, _usr, _ok);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function allowHandler(address _usr, uint256 _ok) external {\n    handlerCan[msg.sender][_usr] = _ok;\n    emit AllowHandler(msg.sender, _usr, _ok);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function openSAFE(bytes32 _cType, address _usr) external returns (uint256 _id) {\n    if (_usr == address(0)) revert ZeroAddress();\n\n    ++_safeId;\n    address _safeHandler = address(new SAFEHandler(safeEngine));\n\n    _safeData[_safeId] = SAFEData({owner: _usr, safeHandler: _safeHandler, collateralType: _cType});\n\n    _usrSafes[_usr].add(_safeId);\n    _usrSafesPerCollat[_usr][_cType].add(_safeId);\n\n    vault721.mint(_usr, _safeId);\n\n    emit OpenSAFE(msg.sender, _usr, _safeId);\n    return _safeId;\n  }\n\n  // Give the safe ownership to a dst address.\n  function transferSAFEOwnership(uint256 _safe, address _dst) external {\n    require(msg.sender == address(vault721), 'SafeMngr: Only Vault721');\n\n    if (_dst == address(0)) revert ZeroAddress();\n    SAFEData memory _sData = _safeData[_safe];\n    if (_dst == _sData.owner) revert AlreadySafeOwner();\n\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n\n    _usrSafes[_dst].add(_safe);\n    _usrSafesPerCollat[_dst][_sData.collateralType].add(_safe);\n\n    _safeData[_safe].owner = _dst;\n\n    emit TransferSAFEOwnership(msg.sender, _safe, _dst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function modifySAFECollateralization(\n    uint256 _safe,\n    int256 _deltaCollateral,\n    int256 _deltaDebt\n  ) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).modifySAFECollateralization(\n      _sData.collateralType, _sData.safeHandler, _sData.safeHandler, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit ModifySAFECollateralization(msg.sender, _safe, _deltaCollateral, _deltaDebt);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferCollateral(uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferCollateral(_sData.collateralType, _sData.safeHandler, _dst, _wad);\n    emit TransferCollateral(msg.sender, _safe, _dst, _wad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferCollateral(bytes32 _cType, uint256 _safe, address _dst, uint256 _wad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferCollateral(_cType, _sData.safeHandler, _dst, _wad);\n    emit TransferCollateral(msg.sender, _cType, _safe, _dst, _wad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function transferInternalCoins(uint256 _safe, address _dst, uint256 _rad) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine(safeEngine).transferInternalCoins(_sData.safeHandler, _dst, _rad);\n    emit TransferInternalCoins(msg.sender, _safe, _dst, _rad);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function quitSystem(uint256 _safe, address _dst) external safeAllowed(_safe) handlerAllowed(_dst) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _sData.collateralType, _sData.safeHandler, _dst, _deltaCollateral, _deltaDebt\n    );\n\n    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n    emit QuitSystem(msg.sender, _safe, _dst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function enterSystem(address _src, uint256 _safe) external handlerAllowed(_src) safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_sData.collateralType, _sData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _sData.collateralType, _src, _sData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n    emit EnterSystem(msg.sender, _src, _safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function moveSAFE(uint256 _safeSrc, uint256 _safeDst) external safeAllowed(_safeSrc) safeAllowed(_safeDst) {\n    SAFEData memory _srcData = _safeData[_safeSrc];\n    SAFEData memory _dstData = _safeData[_safeDst];\n    if (_srcData.collateralType != _dstData.collateralType) revert CollateralTypesMismatch();\n    ISAFEEngine.SAFE memory _safeInfo = ISAFEEngine(safeEngine).safes(_srcData.collateralType, _srcData.safeHandler);\n    int256 _deltaCollateral = _safeInfo.lockedCollateral.toInt();\n    int256 _deltaDebt = _safeInfo.generatedDebt.toInt();\n    ISAFEEngine(safeEngine).transferSAFECollateralAndDebt(\n      _srcData.collateralType, _srcData.safeHandler, _dstData.safeHandler, _deltaCollateral, _deltaDebt\n    );\n\n    // Remove safe from owner's list (notice it doesn't erase safe ownership)\n    _usrSafes[_srcData.owner].remove(_safeSrc);\n    _usrSafesPerCollat[_srcData.owner][_srcData.collateralType].remove(_safeSrc);\n    emit MoveSAFE(msg.sender, _safeSrc, _safeDst);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function addSAFE(uint256 _safe) external {\n    SAFEData memory _sData = _safeData[_safe];\n    _usrSafes[msg.sender].add(_safe);\n    _usrSafesPerCollat[msg.sender][_sData.collateralType].add(_safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function removeSAFE(uint256 _safe) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    _usrSafes[_sData.owner].remove(_safe);\n    _usrSafesPerCollat[_sData.owner][_sData.collateralType].remove(_safe);\n  }\n\n  /// @inheritdoc IODSafeManager\n  function protectSAFE(uint256 _safe, address _liquidationEngine, address _saviour) external safeAllowed(_safe) {\n    SAFEData memory _sData = _safeData[_safe];\n    ILiquidationEngine(_liquidationEngine).protectSAFE(_sData.collateralType, _sData.safeHandler, _saviour);\n    emit ProtectSAFE(msg.sender, _safe, _liquidationEngine, _saviour);\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/ODSafeManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {SAFEHandler} from '@contracts/proxies/SAFEHandler.sol';\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ILiquidationEngine} from '@interfaces/ILiquidationEngine.sol';\nimport {IVault721} from '@interfaces/proxies/IVault721.sol';\n\nimport {Math} from '@libraries/Math.sol';\nimport {EnumerableSet} from '@openzeppelin/utils/structs/EnumerableSet.sol';\nimport {Assertions} from '@libraries/Assertions.sol';\n\nimport {IODSafeManager} from '@interfaces/proxies/IODSafeManager.sol';\n\n/**\n * @title  ODSafeManager\n * @notice This contract acts as interface to the SAFEEngine, facilitating the management of SAFEs\n * @dev    This contract is meant to be used by users that interact with the protocol through a proxy contract\n */\ncontract ODSafeManager is IODSafeManager {\n  using Math for uint256;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using Assertions for address;\n\n  /// @inheritdoc IODSafeManager\n  address public safeEngine;\n\n  // --- ERC721 ---\n  IVault721 public vault721;\n\n  uint256 internal _safeId; // Auto incremental\n  mapping(address _safeOwner => EnumerableSet.UintSet) private _usrSafes;\n  /// @notice Mapping of user addresses to their enumerable set of safes per collateral type\n  mapping(address _safeOwner => mapping(bytes32 _cType => EnumerableSet.UintSet)) private _usrSafesPerCollat;\n  /// @notice Mapping of safe ids to their data\n  mapping(uint256 _safeId => SAFEData) internal _safeData;\n\n  /// @inheritdoc IODSafeManager\n  mapping(address _owner => mapping(uint256 _safeId => mapping(addr"
    }
  ]
}