{
  "Title": "[M-06] `ETHCrowdfundBase.sol#processContribution` - Impossible to finalize crowdfund because of `minContribution` check",
  "Content": "\nThe contract implements a state variable `minContribution`, which enforces a minimum contribution to the crowdfund.\n\nAn issue occurs when `minContribution > maxTotalContribution - minTotalContribution`. The protocol team even accounted for such a case, but they assumed that `minTotalContribution` can always be reached, so a host can then call `finalize` and finalize the crowdfund early, but that isn't the case.\n\n```js\n        // Check that the contribution amount is at or above the minimum. This\n        // is done after `amount` is potentially reduced if refunding excess\n        // contribution. There is a case where this prevents a crowdfunds from\n        // reaching `maxTotalContributions` if the `minContribution` is greater\n        // than the difference between `maxTotalContributions` and the current\n        // `totalContributions`. In this scenario users will have to wait until\n        // the crowdfund expires or a host finalizes after\n        // `minTotalContribution` has been reached by calling `finalize()`.\n        uint96 minContribution_ = minContribution;\n        if (amount < minContribution_) {\n            revert BelowMinimumContributionsError(amount, minContribution_);\n        }\n```\n\nLet's look at an example:\n(Keep in mind that the values can vary, this is just an example).\n`minContribution = 2e18`<br>\n`minTotalContribution = 9e18`<br>\n`maxTotalContribution = 10e18`\n\n- There is already `8.5e18` ETH contributed to the crowdfund.\n- We need `0.5e18` ETH to reach `minTotalContribution` and `1.5e18` ETH to reach `maxTotalContribution`, but both of these cases are impossible since `minContribution = 2e18`.\n- Alice contributes `2e18` ETH and `totalContributions = 10.5e18`, so we refund Alice `0.5e18` ETH and `amount` is now `1.5e18`.\n\nThen we apply this check, which will always revert. We can't send less than `minContribution` and even if we send more, after we apply the refund `amount` will always be smaller than `minContribution`.\n\n```js\n    if (amount < minContribution_) {\n            revert BelowMinimumContributionsError(amount, minContribution_);\n    }\n```\n\nAt this point the crowdfund is stuck in limbo, `minTotalContribution` and `maxTotalContribution` can never be reached. Because `minTotalContribution` isn't reached, the host can't finalize the crowdfund early. Thus, the crowdfund will eventually expire and be lost.\n\nUsers will be able to call `refund` only after the crowdfund is `Lost`. The DoS will last as long as the `duration` of the crowdfund. If `duration = 14 days`, then the users will recover their funds after 14 days.\n\nNote that if `emergencyDisabled = true`, the DAO won't be able to retrieve their funds through `emergencyExecute` and the users will have to wait until the crowdfund is lost.\n\nThis issue can occur without anyone being malicious, although a malicious user can set up the correct state more effectively.\n\n### Proof of Concept\n\nPaste the following inside `test/crowdfund/InitialETHCrowdfund.t.sol` in contract `InitialETHCrowdfundTest` and run `forge test --mt test_MinTotalContributionsProblem -vvvv`:\n\n```js\nfunction _createCrowdfund(\n        CreateCrowdfundArgs memory args,\n        bool initialize\n    ) internal returns (InitialETHCrowdfund crowdfund) {\n        crowdfundOpts.initialContributor = args.initialContributor;\n        crowdfundOpts.initialDelegate = args.initialDelegate;\n        crowdfundOpts.minContribution = args.minContributions;\n        crowdfundOpts.maxContribution = args.maxContributions;\n        crowdfundOpts.disableContributingForExistingCard = args.disableContributingForExistingCard;\n        crowdfundOpts.minTotalContributions = args.minTotalContributions;\n        crowdfundOpts.maxTotalContributions = args.maxTotalContributions;\n        crowdfundOpts.duration = args.duration;\n        crowdfundOpts.exchangeRateBps = args.exchangeRateBps;\n        crowdfundOpts.fundingSplitBps = args.fundingSplitBps;\n        crowdfundOpts.fundingSplitRecipient = args.fundingSplitRecipient;\n        crowdfundOpts.gateKeeper = args.gateKeeper;\n        crowdfundOpts.gateKeeperId = args.gateKeeperId;\n\n        partyOpts.name = \"Test Party\";\n        partyOpts.symbol = \"TEST\";\n        partyOpts.governanceOpts.partyImpl = partyImpl;\n        partyOpts.governanceOpts.partyFactory = partyFactory;\n        partyOpts.governanceOpts.voteDuration = 7 days;\n        partyOpts.governanceOpts.executionDelay = 1 days;\n        partyOpts.governanceOpts.passThresholdBps = 0.5e4;\n        partyOpts.governanceOpts.hosts = new address[](1);\n        partyOpts.governanceOpts.hosts[0] = address(this);\n        \n\n        crowdfund = InitialETHCrowdfund(payable(address(initialETHCrowdfundImpl).clone()));\n        if (initialize) {\n            crowdfund.initialize{ value: args.initialContribution }(\n                crowdfundOpts,\n                partyOpts,\n                MetadataProvider(address(0)),\n                \"\"\n            );\n        }\n    }\n\nfunction test_MinTotalContributionsProblem() public {\n         InitialETHCrowdfund crowdfund = _createCrowdfund(\n            CreateCrowdfundArgs({\n                initialContribution: 0,\n                initialContributor: payable(address(0)),\n                initialDelegate: address(0),\n                // notice the value, it's > maxTotalContributions - minTotalContributions,\n                minContributions: 2 ether,\n                maxContributions: type(uint96).max,\n                disableContributingForExistingCard: false,\n                minTotalContributions: 9 ether,\n                maxTotalContributions: 10 ether, \n                duration: 7 days,\n                exchangeRateBps: 1e4, \n                fundingSplitBps: 0,\n                fundingSplitRecipient: payable(address(0)),\n                gateKeeper: IGateKeeper(address(0)),\n                gateKeeperId: bytes12(0)\n            })\n        );\n        Party party = crowdfund.party();\n\n        // Simulating users contributing to reach 8.5e18 ETH contributed\n        address alice = _randomAddress();\n        vm.deal(alice, 10_000 ether);\n        vm.prank(alice);\n        crowdfund.contribute{value: 8.5 ether }(address(alice), \"\");\n\n        // Can't contribute anything < 2 ether\n        vm.prank(alice);\n        vm.expectRevert();\n        crowdfund.contribute{value: 1 ether }(address(alice), \"\");\n\n        \n        // Can't contribute 2 ether, because 0.5 ether will be refuned which is < minContribution\n        vm.prank(alice);\n        vm.expectRevert();\n        crowdfund.contribute{value: 2 ether}(address(alice), \"\");\n\n        // At this point the crowdfund is in limbo, it can't be finalized, \n        // Host, can't finalize the crowdfund\n        vm.prank(address(this));\n        vm.expectRevert();\n        crowdfund.finalize();\n    }\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nPossible solution is not to allow `minContributions > maxTotalContributions - minTotalContributions`. This mitigation may not be the best long-term solution, so we suggest exploring different mitigation.\n\n### Assessed type\n\nDoS\n\n**[0xble (Party) confirmed and commented via duplicate issue #453](https://github.com/code-423n4/2023-10-party-findings/issues/453#issuecomment-1813245813):**\n> Would like to note this setup is not currently possible in production due to the way we allow crowdfunds to be configured for ETH raises in our UI at `party.app`. This is because either `minTotalContributions == maxTotalContributions` or `maxTotalContributions == type(uint96).max` depending on the option the Party creator selects when they choose \"Allow Flexible Contributions\" in our \"Start a Party\" page.\n\n**[0xble (Party) commented via duplicate issue #453](https://github.com/code-423n4/2023-10-party-findings/issues/453#issuecomment-1814431344):**\n> Posting this here too for reference:\n>> Upon reflection, while it is similar to the issue pointed out in [the comment](https://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/crowdfund/ETHCrowdfundBase.sol#L247), the finding does add nuance beyond what was acknowledged in our code comment and points out a scenario that goes beyond that mentioned. We'd like to consider it valid. It also helps that the mitigation is strong, we'd like to implement it\n>\n> In our comment we mention \"In this scenario, users will have to wait until the crowdfund expires or a host finalizes\", but in this finding's scenario, it would not be possible for a host to finalize.\n>\n> Another, probably more significant, factor behind us changing our minds to consider this valid and \"sponsor confirmed\" is that the mitigation proposed cleanly prevents the scenario from happening.\n>\n> Perhaps we are being too lenient here to consider it valid. I do not entirely disagree with the comment [here](https://github.com/code-423n4/2023-10-party-findings/issues/552#issuecomment-1806713047). I'll just give the reasoning behind why we chose to confirm the issue, but would like to leave it to the judge to ultimately decide, as I lack context on the standard C4 usually applies to validate finding.\n\n**[gzeon (judge) commented via duplicate issue #453](https://github.com/code-423n4/2023-10-party-findings/issues/453#issuecomment-1817874806):**\n> This is clearly out-of-scope, the fact that the proposed mitigation is good should not affect the validity of this issue for fairness.\n\n**[J4X (warden) commented via duplicate issue #453](https://github.com/code-423n4/2023-10-party-findings/issues/453#issuecomment-1822610122):**\n> @gzeon - Thanks for taking a look at the issue. I'd like to emphasize that, in my perspective, this issue should not be considered out of scope based on the following arguments.\n>\n> The rationale for categorizing this issue as out of scope is primarily linked to the comment in Line 247-254. However, it's crucial to note that the comment discusses a different scenario and severity. Specifically, the comment states, \"In this scenario, users will have to wait until the crowdfund expires or a host finalizes after `minTotalContribution` has been reached by calling `finalize()`\". It's important to highlight that the host finalizing the crowdfund is not feasible in the context showcased and validated by the POC. In this case, I've outlined that no host has the capability to prematurely close the fund and rescue user funds. This leads to a different threat than described by the comment, which incorrectly gives users the security of their funds being rescued by a host in the case of a crowdfund getting stuck.\n>\n> Furthermore, the comment illustrates a situation where `minTotalContributions` can still be reached by depositing, while `maxTotalContributions` cannot be achieved. This state can be described as an invariant: `minTotalContributions <= potentialDeposits < maxTotalContributions`. In this case, I've presented that neither of these thresholds can be reached. The invariant for my scenario reads as follows: `potentialDeposits < minTotalContributions <= maxTotalContributions`. Looking at those invariants one can easily determine that although using similar variables, the 2 states differ.\n>\n> It's crucial to note that my issue outlines a method by which a malicious user could exploit the vulnerability to freeze other users' funds or potentially lead to a loss of user funds, due to the arbitrarily selectable duration of the crowdfund. Unlike the situation described in the comment, a \"permanent\" loss of user funds would be possible in my case. According to the comment, the host can always close the funds after a sufficient number of deposits have been received. This is impossible in the state my issue describes, as `minTotalContributions` can never be reached, further differentiating the issues.\n\n**[gzeon (judge) commented via duplicate issue #453](https://github.com/code-423n4/2023-10-party-findings/issues/127#issuecomment-1824548107):**\n> Fair, judging as Medium due to funds are only stuck but not lost in a reasonably configured party (expire after realistic duration).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-party",
  "Code": [
    {
      "filename": "contracts/crowdfund/ETHCrowdfundBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../party/Party.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\ncontract ETHCrowdfundBase is Implementation {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    enum CrowdfundLifecycle {\n        // In practice, this state is never used. If the crowdfund is ever in\n        // this stage, something is wrong (e.g. crowdfund was never initialized).\n        Invalid,\n        // Ready to accept contributions to reach contribution targets\n        // until a deadline or the minimum contribution target is reached and\n        // host finalizes.\n        Active,\n        // Expired and the minimum contribution target was not reached.\n        Lost,\n        // The crowdfund has expired and reached the minimum contribution\n        // target. It is now ready to finalize.\n        Won,\n        // A won crowdfund has been finalized, with funds transferred to the\n        // party and voting power successfully updated.\n        Finalized\n    }\n\n    // Options to be passed into `initialize()` when the crowdfund is created.\n    struct ETHCrowdfundOptions {\n        Party party;\n        address payable initialContributor;\n        address initialDelegate;\n        uint96 minContribution;\n        uint96 maxContribution;\n        bool disableContributingForExistingCard;\n        uint96 minTotalContributions;\n        uint96 maxTotalContributions;\n        uint16 exchangeRateBps;\n        uint16 fundingSplitBps;\n        address payable fundingSplitRecipient;\n        uint40 duration;\n        IGateKeeper gateKeeper;\n        bytes12 gateKeeperId;\n    }\n\n    error WrongLifecycleError(CrowdfundLifecycle lc);\n    error NotAllowedByGateKeeperError(\n        address contributor,\n        IGateKeeper gateKeeper,\n        bytes12 gateKeeperId,\n        bytes gateData\n    );\n    error OnlyPartyHostError();\n    error OnlyPartyDaoError(address notDao);\n    error OnlyPartyDaoOrHostError(address notDao);\n    error NotOwnerError(uint256 tokenId);\n    error OnlyWhenEmergencyActionsAllowedError();\n    error InvalidDelegateError();\n    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);\n    error MinGreaterThanMaxError(uint96 min, uint96 max);\n    error MaxTotalContributionsCannotBeZeroError(uint96 maxTotalContributions);\n    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);\n    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);\n    error InvalidExchangeRateError(uint16 exchangeRateBps);\n    error ContributingForExistingCardDisabledError();\n    error ZeroVotingPowerError();\n    error FundingSplitAlreadyPaidError();\n    error FundingSplitNotConfiguredError();\n    error InvalidMessageValue();\n\n    event Contributed(\n        address indexed sender,\n        address indexed contributor,\n        uint256 amount,\n        address delegate\n    );\n    event Finalized();\n    event FundingSplitSent(address indexed fundingSplitRecipient, uint256 amount);\n    event EmergencyExecuteDisabled();\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and itâ€™s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The address of the `Party` contract instance associated\n    ///         with the crowdfund.\n    Party public party;\n    /// @notice The minimum amount of ETH that a contributor can send to\n    ///         participate in the crowdfund.\n    uint96 public minContribution;\n    /// @notice The maximum amount of ETH that a contributor can send to\n    ///         participate in the crowdfund per address.\n    uint96 public maxContribution;\n    /// @notice A boolean flag that determines whether contributors are allowed\n    ///         to increase the voting power of their existing party cards.\n    bool public disableContributingForExistingCard;\n    /// @notice Whether the funding split has been claimed by the funding split\n    ///         recipient.\n    bool public fundingSplitPaid;\n    /// @notice Whether the DAO has emergency powers for this crowdfund.\n    bool public emergencyExecuteDisabled;\n    /// @notice The minimum amount of total ETH contributions required for the\n    ///         crowdfund to be considered successful.\n    uint96 public minTotalContributions;\n    /// @notice The maximum amount of total ETH contributions allowed for the\n    ///         crowdfund.\n    uint96 public maxTotalContributions;\n    /// @notice The total amount of ETH contributed to the crowdfund so far.\n    uint96 public totalContributions;\n    /// @notice The timestamp at which the crowdfund will end or ended. If 0, the\n    ///         crowdfund has finalized.\n    uint40 public expiry;\n    /// @notice The exchange rate to use for converting ETH contributions to\n    ///         voting power in basis points (e.g. 10000 = 1:1).\n    uint16 public exchangeRateBps;\n    /// @notice The portion of contributions to send to the funding recipient in\n    ///         basis points (e.g. 100 = 1%).\n    uint16 public fundingSplitBps;\n    /// @notice The address to which a portion of the contributions is sent to.\n    address payable public fundingSplitRecipient;\n    /// @notice The gatekeeper contract used to restrict who can contribute to the party.\n    IGateKeeper public gateKeeper;\n    /// @notice The ID of the gatekeeper to use for restricting contributions to the party.\n    bytes12 public gateKeeperId;\n    /// @notice The address a contributor is delegating their voting power to.\n    mapping(address => address) public delegationsByContributor;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts, credit initial contribution (if\n    // any), and setup gatekeeper.\n    function _initialize(ETHCrowdfundOptions memory opts) internal {\n        // Set the minimum and maximum contribution amounts.\n        if (opts.minContribution > opts.maxContribution) {\n            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);\n        }\n        minContribution = opts.minContribution;\n        maxContribution = opts.maxContribution;\n        // Set the min total contributions.\n        if (opts.minTotalContributions > opts.maxTotalContributions) {\n            revert MinGreaterThanMaxError(opts.minTotalContributions, opts.maxTotalContributions);\n        }\n        minTotalContributions = opts.minTotalContributions;\n        // Set the max total contributions.\n        if (opts.maxTotalContributions == 0) {\n            // Prevent this because when `maxTotalContributions` is 0 the\n            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has\n            // never been initialized.\n            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);\n        }\n        maxTotalContributions = opts.maxTotalContributions;\n        // Set the party crowdfund is for.\n        party = opts.party;\n        // Set the crowdfund start and end timestamps.\n        expiry = uint40(block.timestamp + opts.duration);\n        // Set the exchange rate.\n        if (opts.exchangeRateBps == 0) revert InvalidExchangeRateError(opts.exchangeRateBps);\n        exchangeRateBps = opts.exchangeRateBps;\n        // Set the funding split and its recipient.\n        fundingSplitBps = opts.fundingSplitBps;\n        fundingSplitRecipient = opts.fundingSplitRecipient;\n        // Set whether to disable contributing for existing card.\n        disableContributingForExistingCard = opts.disableContributingForExistingCard;\n    }\n\n    /// @notice Get the current lifecycle of the crowdfund.\n    function getCrowdfundLifecycle() public view returns (CrowdfundLifecycle lifecycle) {\n        if (maxTotalContributions == 0) {\n            return CrowdfundLifecycle.Invalid;\n        }\n\n        uint256 expiry_ = expiry;\n        if (expiry_ == 0) {\n            return CrowdfundLifecycle.Finalized;\n        }\n\n        if (block.timestamp >= expiry_) {\n            if (totalContributions >= minTotalContributions) {\n                return CrowdfundLifecycle.Won;\n            } else {\n                return CrowdfundLifecycle.Lost;\n            }\n        }\n\n        return CrowdfundLifecycle.Active;\n    }\n\n    function _processContribution(\n        address payable contributor,\n        address delegate,\n        uint96 amount\n    ) internal returns (uint96 votingPower) {\n        address oldDelegate = delegationsByContributor[contributor];\n        if (msg.sender == contributor || oldDelegate == address(0)) {\n            // Update delegate.\n            delegationsByContributor[contributor] = delegate;\n        } else {\n            // Prevent changing another's delegate if already delegated.\n            delegate = oldDelegate;\n        }\n\n        emit Contributed(msg.sender, contributor, amount, delegate);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        // Only allow contributions while the crowdfund is active.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Active) {\n            revert WrongLifecycleError(lc);\n        }\n\n        // Check that the contribution amount is at or below the maximum.\n        uint96 maxContribution_ = maxContribution;\n        if (amount > maxContribution_) {\n            revert AboveMaximumContributionsError(amount, maxContribution_);\n        }\n\n        uint96 newTotalContributions = totalContributions + amount;\n        uint96 maxTotalContributions_ = maxTotalContributions;\n        if (newTotalContributions >= maxTotalContributions_) {\n            totalContributions = maxTotalContributions_;\n\n            // Finalize the crowdfund.\n            // This occurs before refunding excess contribution to act as a\n            // reentrancy guard.\n            _finalize(maxTotalContributions_);\n\n            // Refund excess contribution.\n            uint96 refundAmount = newTotalContributions - maxTotalContributions;\n            if (refundAmount > 0) {\n                amount -= refundAmount;\n                payable(msg.sender).transferEth(refundAmount);\n            }\n        } else {\n            totalContributions = newTotalContributions;\n        }\n\n        // Check that the contribution amount is at or above the minimum. This\n        // is done after `amount` is potentially reduced if refunding excess\n        // contribution. There is a case where this prevents a crowdfunds from\n        // reaching `maxTotalContributions` if the `minContribution` is greater\n        // than the difference between `maxTotalContributions` and the current\n        // `totalContributions`. In this scenario users will have to wait until\n        // the crowdfund expires or a host finalizes after\n        // `minTotalContribution` has been reached by calling `finalize()`.\n        uint96 minContribution_ = minContribution;\n        if (amount < minContribution_) {\n            revert BelowMinimumContributionsError(amount, minContribution_);\n        }\n\n        // Subtract fee from contribution amount if applicable.\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            // Removes funding split from contribution amount in a way that\n            // avoids rounding errors for very small contributions <1e4 wei.\n            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;\n        }\n\n        // Calculate voting power.\n        votingPower = (amount * exchangeRateBps) / 1e4;\n\n        if (votingPower == 0) revert ZeroVotingPowerError();\n    }\n\n    /// @notice Calculate the contribution amount from the given voting power.\n    /// @param votingPower The voting power to convert to a contribution amount.\n    /// @return amount The contribution amount.\n    function convertVotingPowerToContribution(\n        uint96 votingPower\n    ) public view returns (uint96 amount) {\n        amount = (votingPower * 1e4) / exchangeRateBps;\n\n        // Add back funding split to contribution amount if applicable.\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);\n        }\n    }\n\n    function finalize() external {\n        uint96 totalContributions_ = totalContributions;\n\n        // Check that the crowdfund is not already finalized.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc == CrowdfundLifecycle.Active) {\n            // Allow host to finalize crowdfund early if it has reached its minimum goal.\n            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();\n\n            // Check that the crowdfund has reached its minimum goal.\n            uint96 minTotalContributions_ = minTotalContributions;\n            if (totalContributions_ < minTotalContributions_) {\n                revert NotEnoughContributionsError(totalContributions_, minTotalContributions_);\n            }\n        } else {\n            // Otherwise only allow finalization if the crowdfund has expired\n            // and been won. Can be finalized by anyone.\n            if (lc != CrowdfundLifecycle.Won) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        // Finalize the crowdfund.\n        _finalize(totalContributions_);\n    }\n\n    function _finalize(uint96 totalContributions_) internal {\n        // Finalize the crowdfund.\n        delete expiry;\n\n        // Transfer funding split to recipient if applicable.\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;\n        }\n\n        // Update the party's total voting power.\n        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;\n        party.increaseTotalVotingPower(newVotingPower);\n\n        // Transfer ETH to the party.\n        payable(address(party)).transferEth(totalContributions_);\n\n        emit Finalized();\n    }\n\n    /// @notice Send the funding split to the recipient if applicable.\n    function sendFundingSplit() external returns (uint96 splitAmount) {\n        // Check that the crowdfund is finalized.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Finalized) revert WrongLifecycleError(lc);\n\n        if (fundingSplitPaid) revert FundingSplitAlreadyPaidError();\n\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ == address(0) || fundingSplitBps_ == 0) {\n            revert FundingSplitNotConfiguredError();\n        }\n\n        fundingSplitPaid = true;\n\n        // Transfer funding split to recipient.\n        splitAmount = (totalContributions * fundingSplitBps_) / 1e4;\n        payable(fundingSplitRecipient_).transferEth(splitAmount);\n\n        emit FundingSplitSent(fundingSplitRecipient_, splitAmount);\n    }\n\n    /// @notice As the DAO, execute an arbitrary function call from this contract.\n    /// @dev Emergency actions must not be revoked for this to work.\n    /// @param targetAddress The contract to call.\n    /// @param targetCallData The data to pass to the contract.\n    /// @param amountEth The amount of ETH to send to the contract.\n    function emergencyExecute(\n        address targetAddress,\n        bytes calldata targetCallData,\n        uint256 amountEth\n    ) external payable {\n        // Must be called by the DAO.\n        if (_GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender) {\n            revert OnlyPartyDaoError(msg.sender);\n        }\n        // Must not be disabled by DAO or host.\n        if (emergencyExecuteDisabled) {\n            revert OnlyWhenEmergencyActionsAllowedError();\n        }\n        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);\n        if (!success) {\n            res.rawRevert();\n        }\n        emit EmergencyExecute(targetAddress, targetCallData, amountEth);\n    }\n\n    /// @notice Revoke the DAO's ability to call emergencyExecute().\n    /// @dev Either the DAO or the party host can call this.\n    function disableEmergencyExecute() external {\n        // Only the DAO or a host can call this.\n        if (\n            !party.isHost(msg.sender) &&\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender\n        ) {\n            revert OnlyPartyDaoOrHostError(msg.sender);\n        }\n        emergencyExecuteDisabled = true;\n        emit EmergencyExecuteDisabled();\n    }\n}"
    }
  ]
}