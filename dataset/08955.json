{
  "Title": "[M-17] WeVE (FTM) may be lost forever if redemption process is failed",
  "Content": "_Submitted by Chom_\n\n[RedemptionSender.sol#L28-L51](https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/redeem/RedemptionSender.sol#L28-L51)<br>\n[RedemptionReceiver.sol#L72-L105](https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/redeem/RedemptionReceiver.sol#L72-L105)<br>\n\nWeVE (FTM) may be lost forever if redemption process is failed.\n\nRedemption process is likely to be failed if\n\n*   (redeemedWEVE += amountWEVE) > eligibleWEVE\n*   Not enough USDC or VELO in the contract\n\nThe case that redeem more than eligible can't be fixed because eligibleWEVE is hardcoded on contract initialization.\n\nThis mean that if there are any mistake for example LayerZero slow down and user try to repeatedly redeem their WeVE, user will lose their WeVE token forever due to contract always reverted in the destination chain due to the reason that user has redeemed more than eligible.\n\n### Proof of Concept\n\n1.  User redeem WeVE in fantom chain using redeemWEVE function in RedemptionSender contract.\n2.  LayerZero slow but user think it is failed. (But it is just slow)\n3.  User repeat process 1 again\n4.  LayerZero call lzReceive in RedemptionReceiver contract on Optimism chain for the first time it's success. USDC + VELO is redeemed as intended.\n5.  LayerZero call lzReceive in RedemptionReceiver contract on Optimism chain again due to repeated transaction in step 3. But this time, user has exceeded her redeem limit. Caused lzReceive call to revert with reason \"cannot redeem more than eligible\". **But doesn't refund WeVE to the user**\n\n<!---->\n\n            require(\n                (redeemedWEVE += amountWEVE) <= eligibleWEVE,\n                \"cannot redeem more than eligible\"\n            );\n\n6.  User FUD Velodrome and file a lawsuit against Velodrome.\n\n### Recommended Mitigation Steps\n\n*   In RedemptionReceiver, Wrap lzReceive into another function and perform try catch on new lzReceive function to call old wrapped lzReceive function and on revert add refund amount to that user.\n*   Write refund lzReceive handler on RedemptionSender.\n*   Create a new refund function in RedemptionReceiver. When user call, it will send layerzero message back to lzReceive function in RedemptionSender contract on Fantom.\n\n**[pooltypes (Velodrome) disputed and disagreed with severity](https://github.com/code-423n4/2022-05-velodrome-findings/issues/90)**\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/90#issuecomment-1171832618):**\n > I believe the finding to have validity exclusively on the basis of the fact that a user may burn their WeVe and reach cap on the receiving chain, getting nothing out of it.\n> \n> Because that's contingent on reaching cap, the loss will be limited to the capped amount. For that reason, I think Medium Severity to be more appropriate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-05-velodrome",
  "Code": [
    {
      "filename": "contracts/contracts/redeem/RedemptionSender.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"LayerZero/interfaces/ILayerZeroEndpoint.sol\";\nimport \"../interfaces/IERC20.sol\";\n\n/// @notice Part 1 of 2 in the WeVE (FTM) -> USDC + VELO (OP) redemption process\n/// This contract is responsible for burning WeVE and sending the LZ message\ncontract RedemptionSender {\n    address public immutable weve;\n    uint16 public immutable optimismChainId; // 11 for OP, 10011 for OP Kovan\n    address public immutable endpoint;\n    address public immutable optimismReceiver;\n\n    constructor(\n        address _weve,\n        uint16 _optimismChainId,\n        address _endpoint,\n        address _optimismReceiver\n    ) {\n        require(_optimismChainId == 11 || _optimismChainId == 10011, \"CHAIN_ID_NOT_OP\");\n        weve = _weve;\n        optimismChainId = _optimismChainId;\n        endpoint = _endpoint;\n        optimismReceiver = _optimismReceiver;\n    }\n\n    function redeemWEVE(\n        uint256 amount,\n        address zroPaymentAddress,\n        bytes memory zroTransactionParams\n    ) public payable {\n        require(amount != 0, \"AMOUNT_ZERO\");\n        require(\n            IERC20(weve).transferFrom(\n                msg.sender,\n                0x000000000000000000000000000000000000dEaD,\n                amount\n            ),\n            \"WEVE: TRANSFER_FAILED\"\n        );\n\n        ILayerZeroEndpoint(endpoint).send{value: msg.value}(\n            optimismChainId,\n            abi.encodePacked(optimismReceiver),\n            abi.encode(msg.sender, amount),\n            payable(msg.sender),\n            zroPaymentAddress,\n            zroTransactionParams\n        );\n    }\n}"
    },
    {
      "filename": "contracts/contracts/redeem/RedemptionReceiver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"LayerZero/interfaces/ILayerZeroEndpoint.sol\";\nimport \"LayerZero/interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IVelo.sol\";\n\n/// @notice Part 2 of 2 in the WeVE (FTM) -> USDC + VELO (OP) redemption process\n/// This contract is responsible for receiving the LZ message and distributing USDC + VELO\ncontract RedemptionReceiver is ILayerZeroReceiver {\n    IERC20 public immutable USDC;\n    IVelo public immutable VELO;\n    uint16 public immutable fantomChainId; // 12 for FTM, 10012 for FTM testnet\n    address public immutable endpoint;\n    address public immutable deployer;\n\n    constructor(\n        address _usdc,\n        address _velo,\n        uint16 _fantomChainId,\n        address _endpoint\n    ) {\n        require(_fantomChainId == 12 || _fantomChainId == 10012, \"CHAIN_ID_NOT_FTM\");\n        USDC = IERC20(_usdc);\n        VELO = IVelo(_velo);\n        fantomChainId = _fantomChainId;\n        endpoint = _endpoint;\n        deployer = msg.sender;\n    }\n\n    address public fantomSender;\n    uint256 public eligibleWEVE;\n    uint256 public redeemableUSDC;\n    uint256 public redeemableVELO;\n\n    function initializeReceiverWith(\n        address _fantomSender,\n        uint256 _eligibleWEVE,\n        uint256 _redeemableUSDC,\n        uint256 _redeemableVELO\n    ) external {\n        require(msg.sender == deployer, \"ONLY_DEPLOYER\");\n        require(fantomSender == address(0), \"ALREADY_INITIALIZED\");\n        require(\n            USDC.transferFrom(msg.sender, address(this), _redeemableUSDC),\n            \"USDC_TRANSFER_FAILED\"\n        );\n        require(\n            VELO.mintToRedemptionReceiver(_redeemableVELO),\n            \"VELO_MINT_FAILED\"\n        );\n        fantomSender = _fantomSender;\n        eligibleWEVE = _eligibleWEVE;\n        redeemableUSDC = _redeemableUSDC;\n        redeemableVELO = _redeemableVELO;\n    }\n\n    uint256 public redeemedWEVE;\n\n    function previewRedeem(uint256 amountWEVE)\n        public\n        view\n        returns (uint256 shareOfUSDC, uint256 shareOfVELO)\n    {\n        // pro rata USDC\n        shareOfUSDC = (amountWEVE * redeemableUSDC) / eligibleWEVE;\n        // pro rata VELO\n        shareOfVELO = (amountWEVE * redeemableVELO) / eligibleWEVE;\n    }\n\n    function lzReceive(\n        uint16 srcChainId,\n        bytes memory srcAddress,\n        uint64,\n        bytes memory payload\n    ) external override {\n        require(fantomSender != address(0), \"NOT_INITIALIZED\");\n        require(\n            msg.sender == endpoint &&\n                srcChainId == fantomChainId &&\n                addressFromPackedBytes(srcAddress) == fantomSender,\n            \"UNAUTHORIZED_CALLER\"\n        );\n\n        (address redemptionAddress, uint256 amountWEVE) = abi.decode(\n            payload,\n            (address, uint256)\n        );\n\n        require(\n            (redeemedWEVE += amountWEVE) <= eligibleWEVE,\n            \"cannot redeem more than eligible\"\n        );\n        (uint256 shareOfUSDC, uint256 shareOfVELO) = previewRedeem(amountWEVE);\n\n        require(\n            USDC.transfer(redemptionAddress, shareOfUSDC),\n            \"USDC_TRANSFER_FAILED\"\n        );\n        require(\n            VELO.transfer(redemptionAddress, shareOfVELO),\n            \"VELO_TRANSFER_FAILED\"\n        );\n    }\n\n    function addressFromPackedBytes(bytes memory toAddressBytes)\n        public\n        pure\n        returns (address toAddress)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            toAddress := mload(add(toAddressBytes, 20))\n        }\n    }\n}"
    }
  ]
}