{
  "Title": "M-5: Usage of HSG for existing safe can brick safe",
  "Content": "# Issue M-5: Usage of HSG for existing safe can brick safe \n\nSource: https://github.com/sherlock-audit/2023-02-hats-judging/issues/93 \n\n## Found by \ncducrest-brainbot\n\n## Summary\n\nThe `HatsSignerGateFactory` allows for deployment of HSG / MHSG for existing safes. I believe the intention is to let the user call `enableModule()` and `setGuard()` on the safe after deployme with the HSG / MHSG address. \n\nThis can result in unmatching values of `maxSigners` in the HSG and number of valid signers of the safe. That will prevent further interaction with the safe rendering it unusable.\n\n## Vulnerability Detail\n\nIf a safe has 10 owners with valid hats, and a HSG / MHSG is deployed with a value of `maxSigners < 10` and this HSG / MHSG is wired to the safe, the checks for `validSignerCount <= maxSigners` will revert in the HSG. \n\nThese checks are present in `reconcileSignerCount` and `claimSigner`. However `reconcileSignerCount` is a core function that is called by `checkTransaction()`, the pre-flight check on the safe transaction.\n\n## Impact\n\nThe safe will not be able to execute any transaction until the number of valid signers is lowered (some hat wearers give up their hats / some hats turns invalid ...)\n\n## Code Snippet\n\n`reconcileSignerCount` checks maxSigners value:\n\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L183-L189\n\nIt is called during `checkTransaction`: \n\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L464\n\nThe value is set once during setup and not changeable:\n\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L66-L84\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow this value to be changed by owner, or have a function that checks the HSG is safe before making it active after it is wired to an existing safe.\n\n## Discussion\n\n**spengrah**\n\nI like the recommendation to add a function to check that HSG is can be safely wired up to an existing Safe. \n\nAnother approach could be to check in the factory that `maxSigners >= hat.currentSupply` — or use the recommendation from #104 of ensuring that `maxSigners > safe.getOwners()` — but this wouldn't completely solve it because more hats could be minted to existing signers between deployment and wiring up.\n\ncc @zobront \n\n**zobront**\n\n@spengrah I agree that the check needs to be at the \"wiring up\" time and not earlier.\n\n**spengrah**\n\nRe-adding the severity dispute tag since existing signers (who have full control over the safe prior to attaching HSG) would be both the ones attaching HSG in the first place and needing to renounce or be revoked if they made a mistake to attach. To me, this means that this is not a high severity bug, since attaching / fixing an attachment of HSG are incentive-aligned.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/48",
  "Code": [
    {
      "filename": "src/HatsSignerGateBase.sol",
      "content": "// SPDX-License-Identifier: CC0\npragma solidity >=0.8.13;\n\nimport { Test, console2 } from \"forge-std/Test.sol\"; // remove after testing\nimport \"./HSGLib.sol\";\nimport { HatsOwnedInitializable } from \"hats-auth/HatsOwnedInitializable.sol\";\nimport { BaseGuard } from \"zodiac/guard/BaseGuard.sol\";\nimport { IAvatar } from \"zodiac/interfaces/IAvatar.sol\";\nimport { StorageAccessible } from \"@gnosis.pm/safe-contracts/contracts/common/StorageAccessible.sol\";\nimport { IGnosisSafe, Enum } from \"./Interfaces/IGnosisSafe.sol\";\nimport { SignatureDecoder } from \"@gnosis.pm/safe-contracts/contracts/common/SignatureDecoder.sol\";\n\nabstract contract HatsSignerGateBase is BaseGuard, SignatureDecoder, HatsOwnedInitializable {\n    /// @notice The multisig to which this contract is attached\n    IGnosisSafe public safe;\n\n    /// @notice The minimum signature threshold for the `safe`\n    uint256 public minThreshold;\n\n    /// @notice The highest level signature threshold for the `safe`\n    uint256 public targetThreshold;\n\n    /// @notice The maximum number of signers allowed for the `safe`\n    uint256 public maxSigners;\n\n    /// @notice The current number of signers on the `safe`\n    uint256 public signerCount;\n\n    /// @notice The version of HatsSignerGate used in this contract\n    string public version;\n\n    /// @notice The number of modules enabled on the `safe`, as enabled via this contract\n    uint256 public enabledModuleCount;\n\n    /// @dev Temporary record of the existing modules on the `safe` when a transaction is submitted\n    bytes32 internal _existingModulesHash;\n    \n    /// @dev A simple re-entrency guard\n    uint256 internal _guardEntries;\n\n    /// @dev The head pointer used in the GnosisSafe owners linked list, as well as the module linked list\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    /// @dev The storage slot used by GnosisSafe to store the guard address\n    ///      keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Makes the singleton unusable by setting its owner to the 1-address\n    constructor() payable initializer {\n        _HatsOwned_init(1, address(0x1));\n    }\n\n    /// @notice Initializes a new instance\n    /// @dev Can only be called once\n    /// @param initializeParams ABI-encoded bytes with initialization parameters\n    function setUp(bytes calldata initializeParams) public payable virtual initializer { }\n\n    /// @notice Internal function to initialize a new instance\n    /// @param _ownerHatId The hat id of the hat that owns this instance of HatsSignerGate\n    /// @param _safe The multisig to which this instance of HatsSignerGate is attached\n    /// @param _hats The Hats Protocol address\n    /// @param _minThreshold The minimum threshold for the `_safe`\n    /// @param _targetThreshold The maxium threshold for the `_safe`\n    /// @param _maxSigners The maximum number of signers allowed on the `_safe`\n    /// @param _version The current version of HatsSignerGate\n    function _setUp(\n        uint256 _ownerHatId,\n        address _safe,\n        address _hats,\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners,\n        string memory _version,\n        uint256 _existingModuleCount\n    ) internal {\n        _HatsOwned_init(_ownerHatId, _hats);\n        maxSigners = _maxSigners;\n        safe = IGnosisSafe(_safe);\n\n        _setTargetThreshold(_targetThreshold);\n        _setMinThreshold(_minThreshold);\n        version = _version;\n        enabledModuleCount = _existingModuleCount + 1; // this contract is enabled as well\n    }\n\n    /// @notice Checks if `_account` is a valid signer\n    /// @dev Must be implemented by all flavors of HatsSignerGate\n    /// @param _account The address to check\n    /// @return valid Whether `_account` is a valid signer\n    function isValidSigner(address _account) public view virtual returns (bool valid) { }\n\n    /// @notice Sets a new target threshold, and changes `safe`'s threshold if appropriate\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_targetThreshold` is greater than `maxSigners`.\n    /// @param _targetThreshold The new target threshold to set\n    function setTargetThreshold(uint256 _targetThreshold) public onlyOwner {\n        if (_targetThreshold != targetThreshold) {\n            _setTargetThreshold(_targetThreshold);\n\n            if (signerCount > 1) _setSafeThreshold(_targetThreshold);\n\n            emit HSGLib.TargetThresholdSet(_targetThreshold);\n        }\n    }\n\n    /// @notice Internal function to set the target threshold\n    /// @dev Reverts if `_targetThreshold` is greater than `maxSigners`\n    /// @param _targetThreshold The new target threshold to set\n    function _setTargetThreshold(uint256 _targetThreshold) internal {\n        if (_targetThreshold > maxSigners) {\n            revert InvalidTargetThreshold();\n        }\n\n        targetThreshold = _targetThreshold;\n    }\n\n    /// @notice Internal function to set the threshold for the `safe`\n    /// @dev Forwards the threshold-setting call to `safe.ExecTransactionFromModule`\n    /// @param _threshold The threshold to set on the `safe`\n    function _setSafeThreshold(uint256 _threshold) internal {\n        uint256 newThreshold = _threshold;\n        uint256 signerCount_ = signerCount; // save an SLOAD\n\n        // ensure that txs can't execute if fewer signers than target threshold\n        if (signerCount_ <= _threshold) {\n            newThreshold = signerCount_;\n        }\n        if (newThreshold != safe.getThreshold()) {\n            bytes memory data = abi.encodeWithSignature(\"changeThreshold(uint256)\", newThreshold);\n\n            bool success = safe.execTransactionFromModule(\n                address(safe), // to\n                0, // value\n                data, // data\n                Enum.Operation.Call // operation\n            );\n\n            if (!success) {\n                revert FailedExecChangeThreshold();\n            }\n        }\n    }\n\n    /// @notice Sets a new minimum threshold\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_minThreshold` is greater than `maxSigners` or `targetThreshold`\n    /// @param _minThreshold The new minimum threshold\n    function setMinThreshold(uint256 _minThreshold) public onlyOwner {\n        _setMinThreshold(_minThreshold);\n        emit HSGLib.MinThresholdSet(_minThreshold);\n    }\n\n    /// @notice Internal function to set a new minimum threshold\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_minThreshold` is greater than `maxSigners` or `targetThreshold`\n    /// @param _minThreshold The new minimum threshold\n    function _setMinThreshold(uint256 _minThreshold) internal {\n        if (_minThreshold > maxSigners || _minThreshold > targetThreshold) {\n            revert InvalidMinThreshold();\n        }\n\n        minThreshold = _minThreshold;\n    }\n\n    /// @notice Allows the owner to enable a new module on the `safe`\n    /// @dev Increments the `enabledModuleCount` to include the new module in the allowed list (see `checkTransaction` and `checkAfterExecution`)\n    /// @param _module The address of the module to enable\n    function enableNewModule(address _module) external onlyOwner {\n        ++enabledModuleCount;\n\n        bytes memory data = abi.encodeWithSignature(\"enableModule(address)\", _module);\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            data, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecEnableModule();\n        }\n    }\n\n    /// @notice Tallies the number of existing `safe` owners that wear a signer hat, sets `signerCount` to that value, and updates the `safe` threshold if necessary\n    /// @dev Does NOT remove invalid `safe` owners\n    function reconcileSignerCount() public {\n        address[] memory owners = safe.getOwners();\n        uint256 validSignerCount = _countValidSigners(owners);\n\n        if (validSignerCount > maxSigners) {\n            revert MaxSignersReached();\n        }\n\n        // update the signer count accordingly\n        signerCount = validSignerCount;\n\n        uint256 currentThreshold = safe.getThreshold();\n        uint256 newThreshold;\n        uint256 target = targetThreshold; // save SLOADs\n\n        if (validSignerCount <= target && validSignerCount != currentThreshold) {\n            newThreshold = validSignerCount;\n        } else if (validSignerCount > target && currentThreshold < target) {\n            newThreshold = target;\n        }\n        if (newThreshold > 0) {\n            bytes memory data = abi.encodeWithSignature(\"changeThreshold(uint256)\", validSignerCount);\n\n            bool success = safe.execTransactionFromModule(\n                address(safe), // to\n                0, // value\n                data, // data\n                Enum.Operation.Call // operation\n            );\n\n            if (!success) {\n                revert FailedExecChangeThreshold();\n            }\n        }\n    }\n\n    /// @notice Internal function to count the number of valid signers in an array of addresses\n    /// @param owners The addresses to check for validity\n    /// @return validSignerCount The number of valid signers in `owners`\n    function _countValidSigners(address[] memory owners) internal view returns (uint256 validSignerCount) {\n        uint256 length = owners.length;\n        // count the existing safe owners that wear the signer hat\n        for (uint256 i; i < length;) {\n            if (isValidSigner(owners[i])) {\n                // shouldn't overflow given reasonable owners array length\n                unchecked {\n                    ++validSignerCount;\n                }\n            }\n            // shouldn't overflow given reasonable owners array length\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Internal function that adds `_signer` as an owner on `safe`, updating the threshold if appropriate\n    /// @dev Unsafe. Does not check if `_signer` is a valid signer\n    /// @param _owners Array of owners on the `safe`\n    /// @param _currentSignerCount The current number of signers\n    /// @param _signer The address to add as a new `safe` owner\n    function _grantSigner(address[] memory _owners, uint256 _currentSignerCount, address _signer) internal {\n        uint256 newSignerCount = _currentSignerCount;\n\n        uint256 currentThreshold = safe.getThreshold(); // view function\n        uint256 newThreshold = currentThreshold;\n\n        bytes memory addOwnerData;\n\n        // if the only owner is a non-signer (ie this module set as an owner on initialization), replace it with _signer\n        if (_owners.length == 1 && _owners[0] == address(this)) {\n            // prevOwner will always be the sentinel when owners.length == 1\n\n            // set up the swapOwner call\n            addOwnerData = abi.encodeWithSignature(\n                \"swapOwner(address,address,address)\",\n                SENTINEL_OWNERS, // prevOwner\n                address(this), // oldOwner\n                _signer // newOwner\n            );\n            unchecked {\n                // shouldn't overflow given MaxSignersReached check higher in call stack\n                ++newSignerCount;\n            }\n        } else {\n            // otherwise, add the claimer as a new owner\n\n            unchecked {\n                // shouldn't overflow given MaxSignersReached check higher in call stack\n                ++newSignerCount;\n            }\n\n            // ensure that txs can't execute if fewer signers than target threshold\n            if (newSignerCount <= targetThreshold) {\n                newThreshold = newSignerCount;\n            }\n\n            // set up the addOwner call\n            addOwnerData = abi.encodeWithSignature(\"addOwnerWithThreshold(address,uint256)\", _signer, newThreshold);\n        }\n\n        // increment signer count\n        signerCount = newSignerCount;\n\n        // execute the call\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            addOwnerData, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecAddSigner();\n        }\n    }\n\n    /// @notice Internal function that adds `_signer` as an owner on `safe` by swapping with an existing (invalid) owner\n    /// @dev Unsafe. Does not check if `_signer` is a valid signer.\n    /// @param _owners Array of owners on the `safe`\n    /// @param _ownerCount The number of owners on the `safe` (length of `_owners` array)\n    /// @param _maxSigners The maximum number of signers allowed\n    /// @param _currentSignerCount The current number of signers\n    /// @param _signer The address to add as a new `safe` owner\n    /// @return success Whether an invalid signer was found and successfully replaced with `_signer`\n    function _swapSigner(\n        address[] memory _owners,\n        uint256 _ownerCount,\n        uint256 _maxSigners,\n        uint256 _currentSignerCount,\n        address _signer\n    ) internal returns (bool success) {\n        address ownerToCheck;\n        bytes memory data;\n\n        for (uint256 i; i < _ownerCount - 1;) {\n            ownerToCheck = _owners[i];\n\n            if (!isValidSigner(ownerToCheck)) {\n                // prep the swap\n                data = abi.encodeWithSignature(\n                    \"swapOwner(address,address,address)\",\n                    _findPrevOwner(_owners, ownerToCheck), // prevOwner\n                    ownerToCheck, // oldOwner\n                    _signer // newOwner\n                );\n\n                // execute the swap, reverting if it fails for some reason\n                success = safe.execTransactionFromModule(\n                    address(safe), // to\n                    0, // value\n                    data, // data\n                    Enum.Operation.Call // operation\n                );\n\n                if (!success) {\n                    revert FailedExecRemoveSigner();\n                }\n\n                // increment the signer count if signerCount was correct, ie `reconcileSignerCount` was called prior\n                if (_currentSignerCount < _maxSigners) ++signerCount;\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Removes an invalid signer from the `safe`, updating the threshold if appropriate\n    /// @param _signer The address to remove if not a valid signer\n    function removeSigner(address _signer) public virtual {\n        if (isValidSigner(_signer)) {\n            revert StillWearsSignerHat(_signer);\n        }\n\n        _removeSigner(_signer);\n    }\n\n    /// @notice Internal function to remove a signer from the `safe`, updating the threshold if appropriate\n    /// @dev Unsafe. Does not check for signer validity before removal\n    /// @param _signer The address to remove\n    function _removeSigner(address _signer) internal {\n        bytes memory removeOwnerData;\n        address[] memory owners = safe.getOwners();\n        uint256 currentSignerCount = signerCount; // save an SLOAD\n        uint256 newSignerCount;\n\n        if (currentSignerCount < 2 && owners.length == 1) {\n            // signerCount could be 0 after reconcileSignerCount\n            // make address(this) the only owner\n            removeOwnerData = abi.encodeWithSignature(\n                \"swapOwner(address,address,address)\",\n                SENTINEL_OWNERS, // prevOwner\n                _signer, // oldOwner\n                address(this) // newOwner\n            );\n\n            // newSignerCount is already 0\n        } else {\n            uint256 currentThreshold = safe.getThreshold();\n            uint256 newThreshold = currentThreshold;\n            uint256 validSignerCount = _countValidSigners(owners);\n\n            if (validSignerCount == currentSignerCount) {\n                newSignerCount = currentSignerCount;\n            } else {\n                newSignerCount = currentSignerCount - 1;\n            }\n\n            // ensure that txs can't execute if fewer signers than target threshold\n            if (newSignerCount <= targetThreshold) {\n                newThreshold = newSignerCount;\n            }\n\n            removeOwnerData = abi.encodeWithSignature(\n                \"removeOwner(address,address,uint256)\", _findPrevOwner(owners, _signer), _signer, newThreshold\n            );\n        }\n\n        // update signerCount\n        signerCount = newSignerCount;\n\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            removeOwnerData, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecRemoveSigner();\n        }\n    }\n\n    /// @notice Internal function to find the previous owner of an `_owner` in an array of `_owners`, ie the pointer to the owner to remove from the `safe` owners linked list\n    /// @param _owners An array of addresses\n    /// @param _owner The address after the one to find\n    /// @return prevOwner The owner previous to `_owner` in the `safe` linked list\n    function _findPrevOwner(address[] memory _owners, address _owner) internal pure returns (address prevOwner) {\n        prevOwner = SENTINEL_OWNERS;\n\n        for (uint256 i; i < _owners.length;) {\n            if (_owners[i] == _owner) {\n                if (i == 0) break;\n                prevOwner = _owners[i - 1];\n            }\n            // shouldn't overflow given reasonable _owners array length\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // solhint-disallow-next-line payable-fallback\n    fallback() external {\n        // We don't revert on fallback to avoid issues in case of a Safe upgrade\n        // E.g. The expected check method might change and then the Safe would be locked.\n    }\n\n    /// @notice Pre-flight check on a `safe` transaction to ensure that it s signers are valid, called from within `safe.execTransactionFromModule()`\n    /// @dev Overrides All params mirror params for `safe.execTransactionFromModule()`\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address // msgSender\n    ) external override {\n        if (msg.sender != address(safe)) revert NotCalledFromSafe();\n\n        uint256 safeOwnerCount = safe.getOwners().length;\n        // uint256 validSignerCount = _countValidSigners(safe.getOwners());\n\n        // ensure that safe threshold is correct\n        reconcileSignerCount();\n\n        if (safeOwnerCount < minThreshold) {\n            revert BelowMinThreshold(minThreshold, safeOwnerCount);\n        }\n\n        // get the tx hash; view function\n        bytes32 txHash = safe.getTransactionHash(\n            // Transaction info\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            // Payment info\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver,\n            // Signature info\n            // We subtract 1 since nonce was just incremented in the parent function call\n            safe.nonce() - 1 // view function\n        );\n\n        uint256 validSigCount = countValidSignatures(txHash, signatures, signatures.length / 65);\n\n        // revert if there aren't enough valid signatures\n        if (validSigCount < safe.getThreshold() || validSigCount < minThreshold) {\n            revert InvalidSigners();\n        }\n\n        // record existing modules for post-flight check\n        // SENTINEL_OWNERS and SENTINEL_MODULES are both address(0x1)\n        (address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount);\n        _existingModulesHash = keccak256(abi.encode(modules));\n\n        unchecked {\n            ++_guardEntries;\n        }\n    }\n\n    /// @notice Post-flight check to prevent `safe` signers from removing this contract guard, changing any modules, or changing the threshold\n    /// @dev Modified from https://github.com/gnosis/zodiac-guard-mod/blob/988ebc7b71e352f121a0be5f6ae37e79e47a4541/contracts/ModGuard.sol#L86\n    function checkAfterExecution(bytes32, bool) external override {\n        if (msg.sender != address(safe)) revert NotCalledFromSafe();\n\n        if (\n            abi.decode(StorageAccessible(address(safe)).getStorageAt(uint256(GUARD_STORAGE_SLOT), 1), (address))\n                != address(this)\n        ) {\n            revert CannotDisableThisGuard(address(this));\n        }\n\n        if (safe.getThreshold() != _getCorrectThreshold()) {\n            revert SignersCannotChangeThreshold();\n        }\n\n        // SENTINEL_OWNERS and SENTINEL_MODULES are both address(0x1)\n        (address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount + 1);\n        if (keccak256(abi.encode(modules)) != _existingModulesHash) {\n            revert SignersCannotChangeModules();\n        }\n\n        // leave checked to catch underflows triggered by re-erntry attempts\n        --_guardEntries;\n    }\n\n    /// @notice Internal function to calculate the threshold that `safe` should have, given the correct `signerCount`, `minThreshold`, and `targetThreshold`\n    /// @return _threshold The correct threshold\n    function _getCorrectThreshold() internal view returns (uint256 _threshold) {\n        uint256 count = _countValidSigners(safe.getOwners());\n        uint256 min = minThreshold;\n        uint256 max = targetThreshold;\n        if (count < min) _threshold = min;\n        else if (count > max) _threshold = max;\n        else _threshold = count;\n    }\n\n    /// @notice Counts the number of hats-valid signatures within a set of `signatures`\n    /// @dev modified from https://github.com/safe-global/safe-contracts/blob/c36bcab46578a442862d043e12a83fec41143dec/contracts/GnosisSafe.sol#L240\n    /// @param dataHash The signed data\n    /// @param signatures The set of signatures to check\n    /// @return validSigCount The number of hats-valid signatures\n    function countValidSignatures(bytes32 dataHash, bytes memory signatures, uint256 sigCount)\n        public\n        view\n        returns (uint256 validSigCount)\n    {\n        // There cannot be an owner with address 0.\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n\n        for (i; i < sigCount;) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner =\n                    ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n\n            if (isValidSigner(currentOwner)) {\n                // shouldn't overflow given reasonable sigCount\n                unchecked {\n                    ++validSigCount;\n                }\n            }\n            // shouldn't overflow given reasonable sigCount\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/HatsSignerGateBase.sol",
      "content": "// SPDX-License-Identifier: CC0\npragma solidity >=0.8.13;\n\nimport { Test, console2 } from \"forge-std/Test.sol\"; // remove after testing\nimport \"./HSGLib.sol\";\nimport { HatsOwnedInitializable } from \"hats-auth/HatsOwnedInitializable.sol\";\nimport { BaseGuard } from \"zodiac/guard/BaseGuard.sol\";\nimport { IAvatar } from \"zodiac/interfaces/IAvatar.sol\";\nimport { StorageAccessible } from \"@gnosis.pm/safe-contracts/contracts/common/StorageAccessible.sol\";\nimport { IGnosisSafe, Enum } from \"./Interfaces/IGnosisSafe.sol\";\nimport { SignatureDecoder } from \"@gnosis.pm/safe-contracts/contracts/common/SignatureDecoder.sol\";\n\nabstract contract HatsSignerGateBase is BaseGuard, SignatureDecoder, HatsOwnedInitializable {\n    /// @notice The multisig to which this contract is attached\n    IGnosisSafe public safe;\n\n    /// @notice The minimum signature threshold for the `safe`\n    uint256 public minThreshold;\n\n    /// @notice The highest level signature threshold for the `safe`\n    uint256 public targetThreshold;\n\n    /// @notice The maximum number of signers allowed for the `safe`\n    uint256 public maxSigners;\n\n    /// @notice The current number of signers on the `safe`\n    uint256 public signerCount;\n\n    /// @notice The version of HatsSignerGate used in this contract\n    string public version;\n\n    /// @notice The number of modules enabled on the `safe`, as enabled via this contract\n    uint256 public enabledModuleCount;\n\n    /// @dev Temporary record of the existing modules on the `safe` when a transaction is submitted\n    bytes32 internal _existingModulesHash;\n    \n    /// @dev A simple re-entrency guard\n    uint256 internal _guardEntries;\n\n    /// @dev The head pointer used in the GnosisSafe owners linked list, as well as the module linked list\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    /// @dev The storage slot used by GnosisSafe to store the guard address\n    ///      keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    /// @dev Makes the singleton unusable by setting its owner to the 1-address\n    constructor() payable initializer {\n        _HatsOwned_init(1, address(0x1));\n    }\n\n    /// @notice Initializes a new instance\n    /// @dev Can only be called once\n    /// @param initializeParams ABI-encoded bytes with initialization parameters\n    function setUp(bytes calldata initializeParams) public payable virtual initializer { }\n\n    /// @notice Internal function to initialize a new instance\n    /// @param _ownerHatId The hat id of the hat that owns this instance of HatsSignerGate\n    /// @param _safe The multisig to which this instance of HatsSignerGate is attached\n    /// @param _hats The Hats Protocol address\n    /// @param _minThreshold The minimum threshold for the `_safe`\n    /// @param _targetThreshold The maxium threshold for the `_safe`\n    /// @param _maxSigners The maximum number of signers allowed on the `_safe`\n    /// @param _version The current version of HatsSignerGate\n    function _setUp(\n        uint256 _ownerHatId,\n        address _safe,\n        address _hats,\n        uint256 _minThreshold,\n        uint256 _targetThreshold,\n        uint256 _maxSigners,\n        string memory _version,\n        uint256 _existingModuleCount\n    ) internal {\n        _HatsOwned_init(_ownerHatId, _hats);\n        maxSigners = _maxSigners;\n        safe = IGnosisSafe(_safe);\n\n        _setTargetThreshold(_targetThreshold);\n        _setMinThreshold(_minThreshold);\n        version = _version;\n        enabledModuleCount = _existingModuleCount + 1; // this contract is enabled as well\n    }\n\n    /// @notice Checks if `_account` is a valid signer\n    /// @dev Must be implemented by all flavors of HatsSignerGate\n    /// @param _account The address to check\n    /// @return valid Whether `_account` is a valid signer\n    function isValidSigner(address _account) public view virtual returns (bool valid) { }\n\n    /// @notice Sets a new target threshold, and changes `safe`'s threshold if appropriate\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_targetThreshold` is greater than `maxSigners`.\n    /// @param _targetThreshold The new target threshold to set\n    function setTargetThreshold(uint256 _targetThreshold) public onlyOwner {\n        if (_targetThreshold != targetThreshold) {\n            _setTargetThreshold(_targetThreshold);\n\n            if (signerCount > 1) _setSafeThreshold(_targetThreshold);\n\n            emit HSGLib.TargetThresholdSet(_targetThreshold);\n        }\n    }\n\n    /// @notice Internal function to set the target threshold\n    /// @dev Reverts if `_targetThreshold` is greater than `maxSigners`\n    /// @param _targetThreshold The new target threshold to set\n    function _setTargetThreshold(uint256 _targetThreshold) internal {\n        if (_targetThreshold > maxSigners) {\n            revert InvalidTargetThreshold();\n        }\n\n        targetThreshold = _targetThreshold;\n    }\n\n    /// @notice Internal function to set the threshold for the `safe`\n    /// @dev Forwards the threshold-setting call to `safe.ExecTransactionFromModule`\n    /// @param _threshold The threshold to set on the `safe`\n    function _setSafeThreshold(uint256 _threshold) internal {\n        uint256 newThreshold = _threshold;\n        uint256 signerCount_ = signerCount; // save an SLOAD\n\n        // ensure that txs can't execute if fewer signers than target threshold\n        if (signerCount_ <= _threshold) {\n            newThreshold = signerCount_;\n        }\n        if (newThreshold != safe.getThreshold()) {\n            bytes memory data = abi.encodeWithSignature(\"changeThreshold(uint256)\", newThreshold);\n\n            bool success = safe.execTransactionFromModule(\n                address(safe), // to\n                0, // value\n                data, // data\n                Enum.Operation.Call // operation\n            );\n\n            if (!success) {\n                revert FailedExecChangeThreshold();\n            }\n        }\n    }\n\n    /// @notice Sets a new minimum threshold\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_minThreshold` is greater than `maxSigners` or `targetThreshold`\n    /// @param _minThreshold The new minimum threshold\n    function setMinThreshold(uint256 _minThreshold) public onlyOwner {\n        _setMinThreshold(_minThreshold);\n        emit HSGLib.MinThresholdSet(_minThreshold);\n    }\n\n    /// @notice Internal function to set a new minimum threshold\n    /// @dev Only callable by a wearer of the owner hat. Reverts if `_minThreshold` is greater than `maxSigners` or `targetThreshold`\n    /// @param _minThreshold The new minimum threshold\n    function _setMinThreshold(uint256 _minThreshold) internal {\n        if (_minThreshold > maxSigners || _minThreshold > targetThreshold) {\n            revert InvalidMinThreshold();\n        }\n\n        minThreshold = _minThreshold;\n    }\n\n    /// @notice Allows the owner to enable a new module on the `safe`\n    /// @dev Increments the `enabledModuleCount` to include the new module in the allowed list (see `checkTransaction` and `checkAfterExecution`)\n    /// @param _module The address of the module to enable\n    function enableNewModule(address _module) external onlyOwner {\n        ++enabledModuleCount;\n\n        bytes memory data = abi.encodeWithSignature(\"enableModule(address)\", _module);\n        bool success = safe.execTransactionFromModule(\n            address(safe), // to\n            0, // value\n            data, // data\n            Enum.Operation.Call // operation\n        );\n\n        if (!success) {\n            revert FailedExecEnableModule();\n        }\n    }\n\n    /// @notice Tallies the number of existing `safe` owners that wear a signer hat, sets `signerCount` to that value, and updates the `safe` threshold if necessary\n    /// @dev Does NOT remove invalid `safe` owners\n    function reconcileSignerCount() public {\n        address[] memory owners = safe.getOwners();\n        uint256 validSignerCount = _countValidSigners(owners);\n\n        if (validSignerCount > maxSigners) {\n            revert MaxSignersReached();\n        }\n\n        // update the signer count accordingly\n        signerCount = validSignerCount;\n\n        uint256 currentThreshold = safe.getThreshold();\n        uint256 newThreshold;\n        uint256 target = targetThreshold; // save SLOADs\n\n        if (validSignerCount <= target && validSignerCount != currentThreshold) {"
    }
  ]
}