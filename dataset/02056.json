{
  "Title": "M-10: `Carousel.mintRollovers` potentially mints `0` shares and can grief rollover queue",
  "Content": "# Issue M-10: `Carousel.mintRollovers` potentially mints `0` shares and can grief rollover queue \n\nSource: https://github.com/sherlock-audit/2023-03-Y2K-judging/issues/418 \n\n## Found by \nberndartmueller, evan, kenzo\n\n## Summary\n\nIf the deposited assets for a queued rollover item are equal to the relayer fee, the rollover will be minted with `0` shares, potentially leading to zero TVL and hence `finalTVL[_id] = 0`. This will cause the `previewWithdraw` call to revert due to division by zero and the rollover queue will be stuck forever.\n\n## Vulnerability Detail\n\nMinting rollovers in the carousel vault iterates over all items in the `rolloverQueue` queue. Each item is processed, and the entitled shares (`entitledShares`) are calculated using `previewWithdraw`. If the [entitled shares are greater than the deposited assets](https://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Carousel/Carousel.sol#L403)), the rollover is minted.\n\nHowever, if the deposited assets for the queued item are equal to the relayer fee, the assets to mint (`assetsToMint`) calculated in line 436 will be `0`.\n\nIf this happens to be the only deposit (mint) for the epoch and the vaults TVL remains zero, the `previewWithdraw` call in line 396 will [revert due to division by zero](https://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/VaultV2.sol#L366).\n\n## Impact\n\nOnce there is a rollover minted with `0` shares for an epoch and the vaults TVL (i.e., `finalTVL`) remains zero, the rollover queue will be stuck forever unless the owner of this queue item delists it.\n\n## Code Snippet\n\n[src/v2/Carousel/Carousel.mintRollovers](https://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/Carousel/Carousel.sol#L396-L399)\n\n```solidity\n361: function mintRollovers(uint256 _epochId, uint256 _operations)\n362:     external\n363:     epochIdExists(_epochId)\n364:     epochHasNotStarted(_epochId)\n365:     nonReentrant\n366: {\n...      // [...]\n392:\n393:     while ((index - prevIndex) < (_operations)) {\n394:         // only roll over if last epoch is resolved\n395:         if (epochResolved[queue[index].epochId]) {\n396: @>          uint256 entitledShares = previewWithdraw( // @audit-info reverts if epoch's `finalTVL` == 0\n397:                 queue[index].epochId,\n398:                 queue[index].assets\n399:             );\n400:             // mint only if user won epoch he is rolling over\n401:             if (entitledShares > queue[index].assets) {\n402:                 // skip the rollover for the user if the assets cannot cover the relayer fee instead of revert.\n403:                 if (queue[index].assets < relayerFee) {\n404:                     index++;\n405:                     continue;\n406:                 }\n407:                 // @note we know shares were locked up to this point\n408:                 _burn(\n409:                     queue[index].receiver,\n410:                     queue[index].epochId,\n411:                     queue[index].assets\n412:                 );\n413:                 // transfer emission tokens out of contract otherwise user could not access them as vault shares are burned\n414:                 _burnEmissions(\n415:                     queue[index].receiver,\n416:                     queue[index].epochId,\n417:                     queue[index].assets\n418:                 );\n419:                 // @note emission token is a known token which has no before transfer hooks which makes transfer safer\n420:                 emissionsToken.safeTransfer(\n421:                     queue[index].receiver,\n422:                     previewEmissionsWithdraw(\n423:                         queue[index].epochId,\n424:                         queue[index].assets\n425:                     )\n426:                 );\n427:\n428:                 emit Withdraw(\n429:                     msg.sender,\n430:                     queue[index].receiver,\n431:                     queue[index].receiver,\n432:                     _epochId,\n433:                     queue[index].assets,\n434:                     entitledShares\n435:                 );\n436: @>              uint256 assetsToMint = queue[index].assets - relayerFee; // @audit-info `assetsToMint` can potentially become 0\n437:                 _mintShares(queue[index].receiver, _epochId, assetsToMint);\n438:                 emit Deposit(\n439:                     msg.sender,\n440:                     queue[index].receiver,\n441:                     _epochId,\n442:                     assetsToMint\n443:                 );\n444:                 rolloverQueue[index].assets = assetsToMint;\n445:                 rolloverQueue[index].epochId = _epochId;\n446:                 // only pay relayer for successful mints\n447:                 executions++;\n448:             }\n449:         }\n450:         index++;\n451:     }\n452:\n...      // [...]\n459: }\n```\n\n[src/v2/VaultV2.previewWithdraw](https://github.com/sherlock-audit/2023-03-Y2K/blob/main/Earthquake/src/v2/VaultV2.sol#L366)\n\n```solidity\n357: function previewWithdraw(uint256 _id, uint256 _assets)\n358:     public\n359:     view\n360:     override(SemiFungibleVault)\n361:     returns (uint256 entitledAmount)\n362: {\n363:     // entitledAmount amount is derived from the claimTVL and the finalTVL\n364:     // if user deposited 1000 assets and the claimTVL is 50% lower than finalTVL, the user is entitled to 500 assets\n365:     // if user deposited 1000 assets and the claimTVL is 50% higher than finalTVL, the user is entitled to 1500 assets\n366:     entitledAmount = _assets.mulDivDown(claimTVL[_id], finalTVL[_id]);\n367: }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider checking the total assets of the epoch `queue[index].epochId` to be greater than 0 before calling `previewWithdraw` in line 396.\n\n\n\n## Discussion\n\n**3xHarry**\n\nwill move check from line `403` up before `previewWithdraw`, also considering implementing rollover delisting if `assetsToMint` is less than relayerFee \n\n**3xHarry**\n\nin general delisting of stale rollovers (not enough to pay for relayer, or not won prev epoch) should be delisted by smart contract. \n\n**3xHarry**\n\nfix PR: https://github.com/Y2K-Finance/Earthquake/pull/133\n\n**IAm0x52**\n\nNeeds additional changes. This still doesn't address the issue of minting 0 because if assets == relayerFee then it will still mint 0. Should instead be:\n\n`if (queue[index].assets <= relayerFee) {`\n\n**IAm0x52**\n\nFix looks good. Suggested change above has been added\n\n**jacksanford1**\n\nNote: 0x52 referenced this commit in their second message from PR #133:\n\nhttps://github.com/Y2K-Finance/Earthquake/pull/133/commits/9edaa8a5da96edf7c61bef4a8847f7c107f2b630\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/57",
  "Code": [
    {
      "filename": "Earthquake/src/v2/Carousel/Carousel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../VaultV2.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\n/// @author Y2K Finance Team\n\ncontract Carousel is VaultV2 {\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint256;\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES AND STORAGE\n    //////////////////////////////////////////////////////////////*/\n    // Earthquake parameters\n    uint256 public relayerFee;\n    uint256 public depositFee;\n    IERC20 public immutable emissionsToken;\n\n    mapping(address => uint256) public ownerToRollOverQueueIndex;\n    QueueItem[] public rolloverQueue;\n    QueueItem[] public depositQueue;\n    mapping(uint256 => uint256) public rolloverAccounting;\n    mapping(uint256 => mapping(address => uint256)) public _emissionsBalances;\n    mapping(uint256 => uint256) public emissions;\n\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice constructor\n        @param _data  Carousel.ConstructorArgs struct containing the data to be used in the constructor;\n     */\n    constructor(ConstructorArgs memory _data)\n        VaultV2(\n            _data.isWETH,\n            _data.assetAddress,\n            _data.name,\n            _data.symbol,\n            _data.tokenURI,\n            _data.token,\n            _data.strike,\n            _data.controller,\n            _data.treasury\n        )\n    {\n        if (_data.relayerFee < 10000) revert RelayerFeeToLow();\n        if (_data.depositFee > 250) revert BPSToHigh();\n        if (_data.emissionsToken == address(0)) revert AddressZero();\n        emissionsToken = IERC20(_data.emissionsToken);\n        relayerFee = _data.relayerFee;\n        depositFee = _data.depositFee;\n\n        // set epoch 0 to be allways available to deposit into Queue\n        epochExists[0] = true;\n        epochConfig[0] = EpochConfig({\n            epochBegin: 10**10 * 40 - 7 days,\n            epochEnd: 10**10 * 40,\n            epochCreation: uint40(block.timestamp)\n        });\n        epochs.push(0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice Deposit function\n        @param  _id epoch id\n        @param _assets   uint256 of how many assets you want to deposit;\n        @param _receiver  address of the receiver of the shares provided by this function, that represent the ownership of the deposited asset;\n     */\n    function deposit(\n        uint256 _id,\n        uint256 _assets,\n        address _receiver\n    )\n        public\n        override(VaultV2)\n        epochIdExists(_id)\n        epochHasNotStarted(_id)\n        minRequiredDeposit(_assets)\n        nonReentrant\n    {\n        // make sure that epoch exists\n        // epoch has not started (valid deposit period)\n        // amount is enough to pay for relayer fees in case of queue deposit\n        // function is not reentrant\n        if (_receiver == address(0)) revert AddressZero();\n\n        _asset().safeTransferFrom(msg.sender, address(this), _assets);\n        // handles deposit logic for all cases (direct deposit, late deposit (if activated), queue deposit)\n        _deposit(_id, _assets, _receiver);\n    }\n\n    function depositETH(uint256 _id, address _receiver)\n        external\n        payable\n        override(VaultV2)\n        minRequiredDeposit(msg.value)\n        epochIdExists(_id)\n        epochHasNotStarted(_id)\n        nonReentrant\n    {\n        if (!isWETH) revert CanNotDepositETH();\n        if (_receiver == address(0)) revert AddressZero();\n\n        IWETH(address(asset)).deposit{value: msg.value}();\n\n        uint256 assets = msg.value;\n\n        _deposit(_id, assets, _receiver);\n    }\n\n    /**\n    @notice Withdraw entitled deposited assets, checking if a depeg event\n    @param  _id uint256 identifier of the epoch you want to withdraw from;\n    @param _assets   uint256 of how many assets you want to withdraw, this value will be used to calculate how many assets you are entitle to according the vaults claimTVL;\n    @param _receiver  Address of the receiver of the assets provided by this function, that represent the ownership of the transfered asset;\n    @param _owner    Address of the owner of these said assets;\n    @return shares How many shares the owner is entitled to, according to the conditions;\n     */\n    function withdraw(\n        uint256 _id,\n        uint256 _assets,\n        address _receiver,\n        address _owner\n    )\n        external\n        virtual\n        override(VaultV2)\n        epochIdExists(_id)\n        epochHasEnded(_id)\n        notRollingOver(_owner, _id, _assets)\n        nonReentrant\n        returns (uint256 shares)\n    {\n        // make sure that epoch exists\n        // epoch is resolved\n        // owners funds are not locked in rollover\n        // function is not reentrant\n        if (_receiver == address(0)) revert AddressZero();\n\n        if (\n            msg.sender != _owner &&\n            isApprovedForAll(_owner, msg.sender) == false\n        ) revert OwnerDidNotAuthorize(msg.sender, _owner);\n\n        _burn(_owner, _id, _assets);\n        _burnEmissions(_owner, _id, _assets);\n        uint256 entitledShares;\n        uint256 entitledEmissions = previewEmissionsWithdraw(_id, _assets);\n        if (epochNull[_id] == false) {\n            entitledShares = previewWithdraw(_id, _assets);\n        } else {\n            entitledShares = _assets;\n        }\n        if (entitledShares > 0) {\n            SemiFungibleVault.asset.safeTransfer(_receiver, entitledShares);\n        }\n        if (entitledEmissions > 0) {\n            emissionsToken.safeTransfer(_receiver, entitledEmissions);\n        }\n\n        emit Withdraw(\n            msg.sender,\n            _receiver,\n            _owner,\n            _id,\n            _assets,\n            entitledShares\n        );\n\n        return entitledShares;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        TRANSFER LOGIC\n        add notRollingOver modifier to all transfer functions      \n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public override notRollingOver(from, id, amount) {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n        // emissions transfer\n        uint256 fromBalance = _emissionsBalances[id][from];\n        require(\n            fromBalance >= amount,\n            \"ERC1155: insufficient balance for transfer\"\n        );\n        unchecked {\n            _emissionsBalances[id][from] = fromBalance - amount;\n        }\n        _emissionsBalances[id][to] += amount;\n        emit TransferSingleEmissions(_msgSender(), from, to, id, amount);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address, /*from*/\n        address, /*to*/\n        uint256[] memory, /*ids*/\n        uint256[] memory, /*amounts*/\n        bytes memory /*data*/\n    ) public pure override {\n        revert();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Carousel Rollover Logic\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice enlists in rollover queue\n        @dev user needs to have >= _assets in epoch (_epochId)\n        @param  _epochId epoch id\n        @param _assets   uint256 of how many assets deposited;\n        @param _receiver  address of the receiver of the emissions;\n     */\n    function enlistInRollover(\n        uint256 _epochId,\n        uint256 _assets,\n        address _receiver\n    ) public epochIdExists(_epochId) minRequiredDeposit(_assets) {\n        // check if sender is approved by owner\n        if (\n            msg.sender != _receiver &&\n            isApprovedForAll(_receiver, msg.sender) == false\n        ) revert OwnerDidNotAuthorize(msg.sender, _receiver);\n        // check if user has enough balance\n        if (balanceOf(_receiver, _epochId) < _assets)\n            revert InsufficientBalance();\n\n        // check if user has already queued up a rollover\n        if (ownerToRollOverQueueIndex[_receiver] != 0) {\n            // if so, update the queue\n            uint256 index = getRolloverIndex(_receiver);\n            rolloverQueue[index].assets = _assets;\n            rolloverQueue[index].epochId = _epochId;\n        } else {\n            // if not, add to queue\n            rolloverQueue.push(\n                QueueItem({\n                    assets: _assets,\n                    receiver: _receiver,\n                    epochId: _epochId\n                })\n            );\n        }\n        ownerToRollOverQueueIndex[_receiver] = rolloverQueue.length;\n\n        emit RolloverQueued(_receiver, _assets, _epochId);\n    }\n\n    /** @notice delists from rollover queue\n        @param _owner address that is delisting from rollover queue\n     */\n    function delistInRollover(address _owner) public {\n        // check if user has already queued up a rollover\n        if (ownerToRollOverQueueIndex[_owner] == 0) revert NoRolloverQueued();\n        // check if sender is approved by owner\n        if (\n            msg.sender != _owner &&\n            isApprovedForAll(_owner, msg.sender) == false\n        ) revert OwnerDidNotAuthorize(msg.sender, _owner);\n\n        // swich the last item in the queue with the item to be removed\n        uint256 index = getRolloverIndex(_owner);\n        uint256 length = rolloverQueue.length;\n        if (index == length - 1) {\n            // if only one item in queue\n            rolloverQueue.pop();\n            delete ownerToRollOverQueueIndex[_owner];\n        } else {\n            // overwrite the item to be removed with the last item in the queue\n            rolloverQueue[index] = rolloverQueue[length - 1];\n            // remove the last item in the queue\n            rolloverQueue.pop();\n            // update the index of prev last user ( mapping index is allways array index + 1)\n            ownerToRollOverQueueIndex[rolloverQueue[index].receiver] =\n                index +\n                1;\n            // remove receiver from index mapping\n            delete ownerToRollOverQueueIndex[_owner];\n        }\n    }\n\n    /** @notice mints deposit in rollover queue\n        @param _epochId epoch id\n        @param _operations  uint256 of how many operations to execute;\n     */\n    function mintDepositInQueue(uint256 _epochId, uint256 _operations)\n        external\n        epochIdExists(_epochId)\n        epochHasNotStarted(_epochId)\n        nonReentrant\n    {\n        // make sure there is already a new epoch set\n        // epoch has not started\n        QueueItem[] memory queue = depositQueue;\n        uint256 length = depositQueue.length;\n\n        // dont allow minting if epochId is 0\n        if (_epochId == 0) revert InvalidEpochId();\n\n        if (length == 0) revert OverflowQueue();\n        // relayers can always input a very big number to mint all deposit queues, without the need to read depostQueue length first\n        if (_operations > length) _operations = length;\n\n        // queue is executed from the tail to the head\n        // get last index of queue\n        uint256 i = length - 1;\n        while ((length - _operations) <= i) {\n            // this loop impelements FILO (first in last out) stack to reduce gas cost and improve code readability\n            // changing it to FIFO (first in first out) would require more code changes and would be more expensive\n            _mintShares(\n                queue[i].receiver,\n                _epochId,\n                queue[i].assets - relayerFee\n            );\n            emit Deposit(\n                msg.sender,\n                queue[i].receiver,\n                _epochId,\n                queue[i].assets - relayerFee\n            );\n            depositQueue.pop();\n            if (i == 0) break;\n            unchecked {\n                i--;\n            }\n        }\n\n        emit RelayerMinted(_epochId, _operations);\n\n        asset.safeTransfer(msg.sender, _operations * relayerFee);\n    }\n\n    /** @notice mints for rollovers\n        @param _epochId epoch id\n        @param _operations  uint256 of how many operations to execute;\n     */\n    function mintRollovers(uint256 _epochId, uint256 _operations)\n        external\n        epochIdExists(_epochId)\n        epochHasNotStarted(_epochId)\n        nonReentrant\n    {\n        // epoch has not started\n        // dont allow minting if epochId is 0\n        if (_epochId == 0) revert InvalidEpochId();\n\n        uint256 length = rolloverQueue.length;\n        uint256 index = rolloverAccounting[_epochId];\n\n        // revert if queue is empty or operations are more than queue length\n        if (length == 0) revert OverflowQueue();\n\n        if (_operations > length || (index + _operations) > length)\n            _operations = length - index;\n\n        // prev epoch is resolved\n        if (!epochResolved[epochs[epochs.length - 2]])\n            revert EpochNotResolved();\n\n        // make sure epoch is next epoch\n        if (epochs[epochs.length - 1] != _epochId) revert InvalidEpochId();\n\n        QueueItem[] memory queue = rolloverQueue;\n\n        // account for how many operations have been done\n        uint256 prevIndex = index;\n        uint256 executions = 0;\n\n        while ((index - prevIndex) < (_operations)) {\n            // only roll over if last epoch is resolved\n            if (epochResolved[queue[index].epochId]) {\n                uint256 entitledShares = previewWithdraw(\n                    queue[index].epochId,\n                    queue[index].assets\n                );\n                // mint only if user won epoch he is rolling over\n                if (entitledShares > queue[index].assets) {\n                    // skip the rollover for the user if the assets cannot cover the relayer fee instead of revert.\n                    if (queue[index].assets < relayerFee) {\n                        index++;\n                        continue;\n                    }\n                    // @note we know shares were locked up to this point\n                    _burn(\n                        queue[index].receiver,\n                        queue[index].epochId,\n                        queue[index].assets\n                    );\n                    // transfer emission tokens out of contract otherwise user could not access them as vault shares are burned\n                    _burnEmissions(\n                        queue[index].receiver,\n                        queue[index].epochId,\n                        queue[index].assets\n                    );\n                    // @note emission token is a known token which has no before transfer hooks which makes transfer safer\n                    emissionsToken.safeTransfer(\n                        queue[index].receiver,\n                        previewEmissionsWithdraw(\n                            queue[index].epochId,\n                            queue[index].assets\n                        )\n                    );\n\n                    emit Withdraw(\n                        msg.sender,\n                        queue[index].receiver,\n                        queue[index].receiver,\n                        _epochId,\n                        queue[index].assets,\n                        entitledShares\n                    );\n                    uint256 assetsToMint = queue[index].assets - relayerFee;\n                    _mintShares(queue[index].receiver, _epochId, assetsToMint);\n                    emit Deposit(\n                        msg.sender,\n                        queue[index].receiver,\n                        _epochId,\n                        assetsToMint\n                    );\n                    rolloverQueue[index].assets = assetsToMint;\n                    rolloverQueue[index].epochId = _epochId;\n                    // only pay relayer for successful mints\n                    executions++;\n                }\n            }\n            index++;\n        }\n\n        if (executions > 0) rolloverAccounting[_epochId] = index;\n\n        if (executions * relayerFee > 0)\n            asset.safeTransfer(msg.sender, executions * relayerFee);\n\n        emit RelayerMinted(_epochId, executions);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        INTERNAL MUTATIVE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice deposits assets into epoch\n        @param _id epoch id\n        @param _assets amount of assets to deposit\n        @param _receiver address of receiver\n     */\n    function _deposit(\n        uint256 _id,\n        uint256 _assets,\n        address _receiver\n    ) internal {\n        // mint logic, either in queue or direct deposit\n        if (_id != 0) {\n            uint256 assetsToDeposit = _assets;\n\n            if (depositFee > 0) {\n                (uint256 maxX, , uint256 minX) = getEpochConfig(_id);\n                // deposit fee is calcualted linearly between time of epoch creation and epoch starting (deposit window)\n                // this is because late depositors have an informational advantage\n                uint256 fee = _calculateFeePercent(int256(minX), int256(maxX));\n                // min minRequiredDeposit modifier ensures that _assets has high enough value to not devide by 0\n                // 0.5% = multiply by 10000 then divide by 50\n                uint256 feeAmount = _assets.mulDivDown(fee, 10000);\n                assetsToDeposit = _assets - feeAmount;\n                _asset().safeTransfer(treasury, feeAmount);\n            }\n\n            _mintShares(_receiver, _id, assetsToDeposit);\n\n            emit Deposit(msg.sender, _receiver, _id, _assets);\n        } else {\n            depositQueue.push(\n                QueueItem({assets: _assets, receiver: _receiver, epochId: _id})\n            );\n\n            emit DepositInQueue(msg.sender, _receiver, _id, _assets);\n        }\n    }\n\n    /**\n     * @notice calculates fee percent based on time\n     * @param minX min x value\n     * @param maxX max x value\n     */\n    function _calculateFeePercent(int256 minX, int256 maxX)\n        internal\n        view\n        returns (uint256 _y)\n    {\n        /**\n         * Two Point Form\n         * https://www.cuemath.com/geometry/two-point-form/\n         * https://ethereum.stackexchange.com/a/143172\n         */\n        // minY will always be 0 thats why is (maxY - minY) shorten to maxY\n        int256 maxY = int256(depositFee) * int256(FixedPointMathLib.WAD);\n        _y = uint256( // cast to uint256\n            ((((maxY) / (maxX - minX)) * (int256(block.timestamp) - maxX)) +\n                maxY) / (int256(FixedPointMathLib.WAD)) // two point math // scale down\n        );\n    }\n\n    /** @notice mints shares of vault for user\n        @param to address of receiver\n        @param id epoch id\n        @param amount amount of shares to mint\n     */\n    function _mintShares(\n        address to,\n        uint256 id,\n        uint256 amount\n    ) internal {\n        _mint(to, id, amount, EMPTY);\n        _mintEmissions(to, id, amount);\n    }\n\n    /** @notice mints emission shares based of vault shares for user\n        @param to address of receiver\n        @param id epoch id\n        @param amount amount of shares to mint\n     */\n    function _mintEmissions(\n        address to,\n        uint256 id,\n        uint256 amount\n    ) internal {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        _emissionsBalances[id][to] += amount;\n        emit TransferSingleEmissions(_msgSender(), address(0), to, id, amount);\n    }\n\n    /** @notice burns emission shares of vault for user\n        @param from address of sender\n        @param id epoch id\n        @param amount amount of shares to burn\n     */\n    function _burnEmissions(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        uint256 fromBalance = _emissionsBalances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _emissionsBalances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingleEmissions(\n            _msgSender(),\n            from,\n            address(0),\n            id,\n            amount\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice sets emissions\n     * @param _epochId epoch id\n     * @param _emissionsRate emissions rate\n     */\n    function setEmissions(uint256 _epochId, uint256 _emissionsRate)\n        external\n        onlyFactory\n        epochIdExists(_epochId)\n    {\n        emissions[_epochId] = _emissionsRate;\n    }\n\n    /** @notice changes relayer fee\n     * @param _relayerFee relayer fee\n     */\n    function changeRelayerFee(uint256 _relayerFee) external onlyFactory {\n        relayerFee = _relayerFee;\n    }\n\n    /** @notice changes deposit fee\n     * @param _depositFee deposit fee\n     */\n    function changeDepositFee(uint256 _depositFee) external onlyFactory {\n        depositFee = _depositFee;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Getter Functions\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice returns the rollover index\n     * @param _owner address of the owner\n     * @return rollover index\n     */\n    function getRolloverIndex(address _owner) public view returns (uint256) {\n        return ownerToRollOverQueueIndex[_owner] - 1;\n    }\n\n    /** @notice returns the emissions to withdraw\n     * @param _id epoch id\n     * @param _assets amount of assets to withdraw\n     * @return entitledAmount amount of emissions to withdraw\n     */\n    function previewEmissionsWithdraw(uint256 _id, uint256 _assets)\n        public\n        view\n        returns (uint256 entitledAmount)\n    {\n        entitledAmount = _assets.mulDivDown(emissions[_id], finalTVL[_id]);\n    }\n\n    /** @notice returns the deposit queue length\n     * @return queue length for the deposit\n     */\n    function getDepositQueueLenght() public view returns (uint256) {\n        return depositQueue.length;\n    }\n\n    /** @notice returns the queue length for the rollover\n     * @return queue length for the rollover\n     */\n    function getRolloverQueueLenght() public view returns (uint256) {\n        return rolloverQueue.length;\n    }\n\n    /** @notice returns the total value locked in the rollover queue\n     * @return tvl total value locked in the rollover queue\n     */\n    function getRolloverTVL(uint256 _epochId)\n        public\n        view\n        returns (uint256 tvl)\n    {\n        for (uint256 i = 0; i < rolloverQueue.length; i++) {\n            if (\n                rolloverQueue[i].epochId == _epochId &&\n                (previewWithdraw(\n                    rolloverQueue[i].epochId,\n                    rolloverQueue[i].assets\n                ) > rolloverQueue[i].assets)\n            ) {\n                tvl += rolloverQueue[i].assets;\n            }\n        }\n    }\n\n    /** @notice returns users rollover balance and epoch which is rolling over\n     * @param _owner address of the user\n     * @return balance balance of the user\n     * @return epochId epoch id\n     */\n    function getRolloverBalance(address _owner)\n        public\n        view\n        returns (uint256 balance, uint256 epochId)\n    {\n        balance = rolloverQueue[getRolloverIndex(_owner)].assets;\n        epochId = rolloverQueue[getRolloverIndex(_owner)].epochId;\n    }\n\n    /** @notice returns the total value locked in the deposit queue\n     * @return tvl total value locked in the deposit queue\n     */\n    function getDepositQueueTVL() public view returns (uint256 tvl) {\n        for (uint256 i = 0; i < depositQueue.length; i++) {\n            tvl += depositQueue[i].assets;\n        }\n    }\n\n    /** @notice returns the total emissions balance\n     * @return totalEmissions total emissions balance\n     */\n    function balanceOfEmissions(address _owner, uint256 _id)\n        public\n        view\n        returns (uint256)\n    {\n        return _emissionsBalances[_id][_owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    struct QueueItem {\n        uint256 assets;\n        address receiver;\n        uint256 epochId;\n    }\n\n    struct ConstructorArgs {\n        bool isWETH;\n        address assetAddress;\n        string name;\n        string symbol;\n        string tokenURI;\n        address token;\n        uint256 strike;\n        address controller;\n        address treasury;\n        address emissionsToken;\n        uint256 relayerFee;\n        uint256 depositFee;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice checks if deposit is greater than relayer fee\n     * @param _assets amount of assets to deposit\n     */\n    modifier minRequiredDeposit(uint256 _assets) {\n        if (_assets < relayerFee) revert MinDeposit();\n        _;\n    }\n\n    /** @notice checks if not rolling over\n     * @param _receiver address of the receiver\n     * @param _epochId epoch id\n     * @param _assets amount of assets to deposit\n     */\n    modifier notRollingOver(\n        address _receiver,\n        uint256 _epochId,\n        uint256 _assets\n    ) {\n        if (ownerToRollOverQueueIndex[_receiver] != 0) {\n            QueueItem memory item = rolloverQueue[getRolloverIndex(_receiver)];\n            if (\n                item.epochId == _epochId &&\n                (balanceOf(_receiver, _epochId) - item.assets) < _assets\n            ) revert AlreadyRollingOver();\n        }\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MinDeposit();\n    error OverflowQueue();\n    error AlreadyRollingOver();\n    error InvalidEpochId();\n    error InsufficientBalance();\n    error NoRolloverQueued();\n    error RelayerFeeToLow();\n    error BPSToHigh();\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice emitted when a deposit is queued\n     * @param sender the address of the sender\n     * @param receiver the address of the receiver\n     * @param epochId the epoch id\n     * @param assets the amount of assets\n     */\n    event DepositInQueue(\n        address indexed sender,\n        address indexed receiver,\n        uint256 epochId,\n        uint256 assets\n    );\n\n    /** @notice emitted when shares are minted by relayer\n     * @param epochId the epoch id\n     * @param operations how many positions were minted\n     */\n    event RelayerMinted(uint256 epochId, uint256 operations);\n\n    /** @notice emitted when a rollover is queued\n     * @param sender the address of the sender\n     * @param assets the amount of assets\n     * @param epochId the epoch id\n     */\n    event RolloverQueued(\n        address indexed sender,\n        uint256 assets,\n        uint256 epochId\n    );\n\n    /** @notice emitted when emissions are transfered\n     * @param operator the address of the operator\n     * @param from the address of the sender\n     * @param to the address of the receiver\n     * @param id the id of the emissions\n     * @param value the amount of emissions\n     */\n    event TransferSingleEmissions(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n}"
    },
    {
      "filename": "Earthquake/src/v2/VaultV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./SemiFungibleVault.sol\";\nimport {IVaultV2} from \"./interfaces/IVaultV2.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\n/// @author Y2K Finance Team\n\ncontract VaultV2 is IVaultV2, SemiFungibleVault, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES AND STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    // Earthquake parameters\n    address public immutable token;\n    uint256 public immutable strike;\n    // Earthquake bussiness logic\n    bool public immutable isWETH;\n    address public treasury;\n    address public counterPartyVault;\n    address public factory;\n    address public controller;\n    uint256[] public epochs;\n\n    mapping(uint256 => uint256) public finalTVL;\n    mapping(uint256 => uint256) public claimTVL;\n    mapping(uint256 => uint256) public epochAccounting;\n    mapping(uint256 => EpochConfig) public epochConfig;\n    mapping(uint256 => bool) public epochResolved;\n    mapping(uint256 => bool) public epochExists;\n    mapping(uint256 => bool) public epochNull;\n    mapping(address => bool) public whitelistedAddresses;\n\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /** @notice constructor\n        @param _assetAddress  address of the asset that will be used as collateral;\n        @param _name  string representing the name of the vault;\n        @param _symbol  string representing the symbol of the vault;\n        @param _tokenURI  string representing the tokenURI of the vault;\n        @param _token  address of the token that will be used as collateral;\n        @param _strike  uint256 representing the strike price of the vault;\n        @param _controller  address of the controller of the vault;\n        @param _treasury  address of the treasury of the vault;\n     */\n    constructor(\n        bool _isWETH,\n        address _assetAddress,\n        string memory _name,\n        string memory _symbol,\n        string memory _tokenURI,\n        address _token,\n        uint256 _strike,\n        address _controller,\n        address _treasury\n    ) SemiFungibleVault(IERC20(_assetAddress), _name, _symbol, _tokenURI) {\n        if (_controller == address(0)) revert AddressZero();\n        if (_token == address(0)) revert AddressZero();\n        if (_assetAddress == address(0)) revert AddressZero();\n        if (_treasury == address(0)) revert AddressZero();\n        token = _token;\n        strike = _strike;\n        factory = msg.sender;\n        controller = _controller;\n        treasury = _treasury;\n        whitelistedAddresses[_treasury] = true;\n        isWETH = _isWETH;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @param  _id  uint256 in UNIX timestamp, representing the end date of the epoch. Example: Epoch ends in 30th June 2022 at 00h 00min 00sec: 1654038000;\n        @param  _assets  uint256 representing how many assets the user wants to deposit, a fee will be taken from this value;\n        @param _receiver  address of the receiver of the assets provided by this function, that represent the ownership of the deposited asset;\n     */\n    function deposit(\n        uint256 _id,\n        uint256 _assets,\n        address _receiver\n    )\n        public\n        virtual\n        override(SemiFungibleVault)\n        epochIdExists(_id)\n        epochHasNotStarted(_id)\n        nonReentrant"
    }
  ]
}