{
  "Title": "EXECUTOR has a full write access to the wallet storage",
  "Content": "##### Description\nEXECUTOR has a write access to any storage slots vie the executeShortcut function and delegatecall to a specially crafted library. This allows to trigger\ntransfer/renounce of the OWNER address and other unintended actions.\nhttps://github.com/EnsoFinance/shortcuts-contracts/blob/4902e55608f975f73772310955444110b1cfc4fc/contracts/EnsoWallet.sol#L57\n##### Recommendation\nWe recommend implementing an access control for the DELEGATECALL, i.e. a whitelist of permitted libraries.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/EnsoWallet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@ensofinance/weiroll/contracts/VM.sol\";\nimport \"./access/AccessController.sol\";\nimport \"./wallet/ERC1271.sol\";\nimport \"./wallet/MinimalWallet.sol\";\nimport \"./interfaces/IEnsoWallet.sol\";\n\ncontract EnsoWallet is IEnsoWallet, VM, AccessController, ERC1271, MinimalWallet {\n    using StorageAPI for bytes32;\n\n    // Using same slot generation technique as eip-1967 -- https://eips.ethereum.org/EIPS/eip-1967\n    bytes32 internal constant SALT = bytes32(uint256(keccak256(\"enso.wallet.salt\")) - 1);\n\n    error AlreadyInit();\n\n    // @notice Initialize wallet by setting state and permissions\n    // @dev A wallet is considered initialized if the SALT is set in state. Subsequent calls to this function will fail.\n    // @param owner The address of the wallet owner\n    // @param salt The salt used to deploy the proxy that uses this contract as it's implementation\n    // @param commands The optional commands for executing a shortcut\n    // @param state The optional state for executing a shortcut\n    function initialize(\n        address owner,\n        bytes32 salt,\n        bytes32[] calldata commands,\n        bytes[] calldata state\n    ) external override payable {\n        if (SALT.getBytes32() != bytes32(0)) revert AlreadyInit();\n        SALT.setBytes32(salt);\n        _setPermission(OWNER_ROLE, owner, true);\n        _setPermission(EXECUTOR_ROLE, owner, true);\n        if (commands.length != 0) {\n            _execute(commands, state);\n        }\n    }\n\n    // @notice A function to execute an arbitrary call on another contract\n    // @param target The address of the target contract\n    // @param value The ether value that is to be sent with the call\n    // @param data The call data to be sent to the target\n    function execute(\n        address target,\n        uint256 value,\n        bytes memory data\n    ) external payable isPermitted(EXECUTOR_ROLE) returns (bool success) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := call(gas(), target, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    // @notice Execute a shortcut from this contract\n    // @param commands An array of bytes32 values that encode calls\n    // @param state An array of bytes that are used to generate call data for each command\n    function executeShortcut(bytes32[] calldata commands, bytes[] calldata state)\n        external\n        payable\n        isPermitted(EXECUTOR_ROLE)\n        returns (bytes[] memory returnData)\n    {\n        returnData = _execute(commands, state);\n    }\n\n    // @notice Internal function for checking the ERC-1271 signer\n    // @param signer The address that signed a message\n    function _checkSigner(address signer) internal view override returns (bool) {\n        return _getPermission(OWNER_ROLE, signer);\n    }\n}"
    }
  ]
}