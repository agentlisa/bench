{
  "Title": "[N-05] Event is missing `indexed` fields",
  "Content": "\nEach `event` should use three `indexed` fields if there are three or more fields.\n\nThere are 8 instances of this issue:\n\n```solidity\nFile: contracts/operators/Beefy/BeefyVaultStorage.sol\n\n12:       event VaultAdded(address vault, address tokenOrZapper);\n\n16:       event VaultRemoved(address vault);\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Beefy/BeefyVaultStorage.sol#L12\n\nFile: contracts/operators/Yearn/YearnVaultStorage.sol\n\n17:       event VaultAdded(address vault, CurvePool pool);\n\n21:       event VaultRemoved(address vault);\n```\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/operators/Yearn/YearnVaultStorage.sol#L17\n\n```solidity\nFile: contracts/governance/TimelockControllerEmergency.sol\n\n37        event CallScheduled(\n38            bytes32 indexed id,\n39            uint256 indexed index,\n40            address target,\n41            uint256 value,\n42            bytes data,\n43            bytes32 predecessor,\n44            uint256 delay\n45:       );\n\n50:       event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n60:       event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n```\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/governance/TimelockControllerEmergency.sol#L37-L45\n\n```solidity\nFile: contracts/abstracts/MixinOperatorResolver.sol\n\n14:       event CacheUpdated(bytes32 name, IOperatorResolver.Operator destination);\n```\n\nhttps://github.com/code-423n4/2022-06-nested/blob/b4a153c943d54755711a2f7b80cbbf3a5bb49d76/contracts/abstracts/MixinOperatorResolver.sol#L14\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-06-nested",
  "Code": [
    {
      "filename": "contracts/operators/Beefy/BeefyVaultStorage.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title BeefyVaultOperator storage contract\ncontract BeefyVaultStorage is Ownable {\n    /// @dev Emitted when a vault is added\n    /// @param vault The vault address\n    /// @param tokenOrZapper The underlying token address or zapper\n    event VaultAdded(address vault, address tokenOrZapper);\n\n    /// @dev Emitted when a vault is removed\n    /// @param vault The removed vault address\n    event VaultRemoved(address vault);\n\n    /// @dev Map of vault address with underlying token address or zapper\n    mapping(address => address) public vaults;\n\n    /// @notice Add a beefy single asset vault\n    /// @param vault The vault address\n    /// @param tokenOrZapper The underlying token address or zapper (used to deposit)\n    function addVault(address vault, address tokenOrZapper) external onlyOwner {\n        require(vault != address(0), \"BVS: INVALID_VAULT_ADDRESS\");\n        require(tokenOrZapper != address(0), \"BVS: INVALID_UNDERLYING_ADDRESS\");\n        require(vaults[vault] == address(0), \"BVS: ALREADY_EXISTENT_VAULT\");\n        vaults[vault] = tokenOrZapper;\n        emit VaultAdded(vault, tokenOrZapper);\n    }\n\n    /// @notice Remove a beefy vault\n    /// @param vault The vault address to remove\n    function removeVault(address vault) external onlyOwner {\n        require(vaults[vault] != address(0), \"BVS: NON_EXISTENT_VAULT\");\n        delete vaults[vault];\n        emit VaultRemoved(vault);\n    }\n}"
    },
    {
      "filename": "contracts/operators/Yearn/YearnVaultStorage.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nstruct CurvePool {\n    address poolAddress;\n    uint96 poolCoinAmount;\n    address lpToken;\n}\n\n/// @title YearnVaultStorage storage contract\ncontract YearnVaultStorage is Ownable {\n    /// @dev Emitted when a vault is added\n    /// @param vault The vault address\n    /// @param pool The underlying CurvePool\n    event VaultAdded(address vault, CurvePool pool);\n\n    /// @dev Emitted when a vault is removed\n    /// @param vault The removed vault address\n    event VaultRemoved(address vault);\n\n    /// @dev Map of vault address with underlying CurvePool\n    mapping(address => CurvePool) public vaults;\n\n    /// @notice Add a Yearn Curve vault\n    /// @param vault The vault address\n    /// @param curvePool The underlying CurvePool (used to add liquidity)\n    function addVault(address vault, CurvePool calldata curvePool) external onlyOwner {\n        require(vault != address(0), \"YVS: INVALID_VAULT_ADDRESS\");\n        require(curvePool.poolAddress != address(0), \"YVS: INVALID_POOL_ADDRESS\");\n        require(curvePool.lpToken != address(0), \"YVS: INVALID_TOKEN_ADDRESS\");\n        require(vaults[vault].poolAddress == address(0), \"YVS: VAULT_ALREADY_HAS_POOL\");\n        require(vaults[vault].lpToken == address(0), \"YVS: VAULT_ALREADY_HAS_LP\");\n        vaults[vault] = curvePool;\n        emit VaultAdded(vault, curvePool);\n    }\n\n    /// @notice Remove a Yearn vault\n    /// @param vault The vault address to remove\n    function removeVault(address vault) external onlyOwner {\n        require(vaults[vault].poolAddress != address(0), \"YVS: NON_EXISTENT_VAULT\");\n        delete vaults[vault];\n        emit VaultRemoved(vault);\n    }\n}"
    },
    {
      "filename": "contracts/governance/TimelockControllerEmergency.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * This version introduces the \"Emergency\" role bypassing the timelock process.\n * The emergency role should be a multisig with more members than the operational to\n * use when the delay is a problem (critical vulnerability to fix).\n *\n */\ncontract TimelockControllerEmergency is AccessControl {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant EMERGENCY_ROLE = keccak256(\"EMERGENCY_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with a given `minDelay`.\n     */\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors,\n        address emergency\n    ) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EMERGENCY_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // register emergency\n        _setupRole(EMERGENCY_ROLE, emergency);\n\n        // register proposers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, datas, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _beforeCall(id, predecessor);\n        _call(id, 0, target, value, data);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute a single transaction without scheduling.\n     *\n     * Emits a {CallExecuted} event (id will be zero).\n     *\n     * Requirements:\n     * - the caller must have the 'emergency' role (emergency multisig)\n     */\n    function executeEmergency(\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) public payable onlyRole(EMERGENCY_ROLE) {\n        _call(0, 0, target, value, data);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            _call(id, i, targets[i], values[i], datas[i]);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     *\n     * Emits a {CallExecuted} event.\n     */\n    function _call(\n        bytes32 id,\n        uint256 index,\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) private {\n        (bool success, ) = target.call{ value: value }(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n\n        emit CallExecuted(id, index, target, value, data);\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n}"
    },
    {
      "filename": "contracts/abstracts/MixinOperatorResolver.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"../OperatorResolver.sol\";\nimport \"../interfaces/IOperatorResolver.sol\";\nimport \"../interfaces/INestedFactory.sol\";\n\n/// @title Mixin operator resolver\n/// @notice Store in cache operators name and address/selector\nabstract contract MixinOperatorResolver {\n    /// @notice Emitted when cache is updated\n    /// @param name The operator name\n    /// @param destination The operator address\n    event CacheUpdated(bytes32 name, IOperatorResolver.Operator destination);\n\n    /// @dev The OperatorResolver used to build the cache\n    OperatorResolver public immutable resolver;\n\n    /// @dev Cache operators map of the name and Operator struct (address/selector)\n    mapping(bytes32 => IOperatorResolver.Operator) internal operatorCache;\n\n    constructor(address _resolver) {\n        require(_resolver != address(0), \"MOR: INVALID_ADDRESS\");\n        resolver = OperatorResolver(_resolver);\n    }\n\n    /// @dev This function is public not external in order for it to be overridden and\n    ///      invoked via super in subclasses\n    function resolverOperatorsRequired() public view virtual returns (bytes32[] memory) {}\n\n    /// @notice Rebuild the operatorCache\n    function rebuildCache() public {\n        bytes32[] memory requiredOperators = resolverOperatorsRequired();\n        bytes32 name;\n        IOperatorResolver.Operator memory destination;\n        // The resolver must call this function whenever it updates its state\n        for (uint256 i = 0; i < requiredOperators.length; i++) {\n            name = requiredOperators[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            destination = resolver.getOperator(name);\n            if (destination.implementation != address(0)) {\n                operatorCache[name] = destination;\n            } else {\n                delete operatorCache[name];\n            }\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    /// @notice Check the state of operatorCache\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory requiredOperators = resolverOperatorsRequired();\n        bytes32 name;\n        IOperatorResolver.Operator memory cacheTmp;\n        IOperatorResolver.Operator memory actualValue;\n        for (uint256 i = 0; i < requiredOperators.length; i++) {\n            name = requiredOperators[i];\n            cacheTmp = operatorCache[name];\n            actualValue = resolver.getOperator(name);\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (\n                actualValue.implementation != cacheTmp.implementation ||\n                actualValue.selector != cacheTmp.selector ||\n                cacheTmp.implementation == address(0)\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @dev Get operator address in cache and require (if exists)\n    /// @param name The operator name\n    /// @return The operator address\n    function requireAndGetAddress(bytes32 name) internal view returns (IOperatorResolver.Operator memory) {\n        IOperatorResolver.Operator memory _foundAddress = operatorCache[name];\n        require(_foundAddress.implementation != address(0), string(abi.encodePacked(\"MOR: MISSING_OPERATOR: \", name)));\n        return _foundAddress;\n    }\n\n    /// @dev Build the calldata (with safe datas) and call the Operator\n    /// @param _order The order to execute\n    /// @param _inputToken The input token address\n    /// @param _outputToken The output token address\n    /// @return success If the operator call is successful\n    /// @return amounts The amounts from the execution (used and received)\n    ///         - amounts[0] : The amount of output token\n    ///         - amounts[1] : The amount of input token USED by the operator (can be different than expected)\n    function callOperator(\n        INestedFactory.Order calldata _order,\n        address _inputToken,\n        address _outputToken\n    ) internal returns (bool success, uint256[] memory amounts) {\n        IOperatorResolver.Operator memory _operator = requireAndGetAddress(_order.operator);\n        // Parameters are concatenated and padded to 32 bytes.\n        // We are concatenating the selector + given params\n        bytes memory data;\n        (success, data) = _operator.implementation.delegatecall(bytes.concat(_operator.selector, _order.callData));\n\n        if (success) {\n            address[] memory tokens;\n            (amounts, tokens) = abi.decode(data, (uint256[], address[]));\n            require(tokens[0] == _outputToken, \"MOR: INVALID_OUTPUT_TOKEN\");\n            require(tokens[1] == _inputToken, \"MOR: INVALID_INPUT_TOKEN\");\n        }\n    }\n}"
    }
  ]
}