{
  "Title": "[G-08] Use simple comparison in if statement",
  "Content": "<h2 id=\"g-08-use-simple-comparison-in-if-statement\" style=\"position:relative;\"><a href=\"#g-08-use-simple-comparison-in-if-statement\" aria-label=\"g 08 use simple comparison in if statement permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-08] Use simple comparison in if statement</h2>\n<p>The comparison operators &gt;= and &lt;= use more gas than &gt;, &lt;, or ==. Replacing the  &gt;= and â‰¤ operators with a comparison operator that has an opcode in the EVM saves gas.</p>\n<p>The existing code is:<br>\n<a href=\"https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L37-L39\">ERC20Gauges.sol#L37-L39</a><br></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"58\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">if (_incrementFreezeWindow &gt;= _gaugeCycleLength) revert IncrementFreezeError();</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">gaugeCycleLength = _gaugeCycleLength;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">incrementFreezeWindow = _incrementFreezeWindow;</span></span></code></pre>\n<p>A simple comparison can be used for gas savings by reversing the logic:<br></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"59\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">if (_incrementFreezeWindow &lt; _gaugeCycleLength) {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">gaugeCycleLength = _gaugeCycleLength;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">incrementFreezeWindow = _incrementFreezeWindow;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">} else {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">revert IncrementFreezeError();</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">}</span></span></code></pre>\n<h3 id=\"recommended-mitigation-steps-14\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-14\" aria-label=\"recommended mitigation steps 14 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Replace the comparison operator and reverse the logic to save gas using the suggestions above.</p>\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-04-xtribe-contest",
  "Code": [
    {
      "filename": "src/token/ERC20Gauges.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"solmate/auth/Auth.sol\";\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/utils/SafeCastLib.sol\";\nimport \"../../lib/EnumerableSet.sol\";\nimport \"../interfaces/Errors.sol\";\n\n/** \n @title  An ERC20 with an embedded \"Gauge\" style vote with liquid weights\n @author Tribe DAO\n @notice This contract is meant to be used to support gauge style votes with weights associated with resource allocation.\n         Holders can allocate weight in any proportion to supported gauges.\n         A \"gauge\" is represented by an address which would receive the resources periodically or continuously.\n\n         For example, gauges can be used to direct token emissions, similar to Curve or Tokemak.\n         Alternatively, gauges can be used to direct another quantity such as relative access to a line of credit.\n\n         The contract's Authority <https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol> manages the gauge set and cap.\n         \"Live\" gauges are in the set.  \n         Users can only add weight to live gauges but can remove weight from live or deprecated gauges.\n         Gauges can be deprecated and reinstated, and will maintain any non-removed weight from before.\n\n @dev    SECURITY NOTES: `maxGauges` is a critical variable to protect against gas DOS attacks upon token transfer. \n         This must be low enough to allow complicated transactions to fit in a block.\n \n         Weight state is preserved on the gauge and user level even when a gauge is removed, in case it is re-added. \n         This maintains state efficiently, and global accounting is managed only on the `_totalWeight`\n*/\nabstract contract ERC20Gauges is ERC20, Auth {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    constructor(uint32 _gaugeCycleLength, uint32 _incrementFreezeWindow) {\n        if (_incrementFreezeWindow >= _gaugeCycleLength) revert IncrementFreezeError();\n        gaugeCycleLength = _gaugeCycleLength;\n        incrementFreezeWindow = _incrementFreezeWindow;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice the length of a gauge cycle\n    uint32 public immutable gaugeCycleLength;\n\n    /// @notice the period at the end of a cycle where votes cannot increment\n    uint32 public immutable incrementFreezeWindow;\n\n    struct Weight {\n        uint112 storedWeight;\n        uint112 currentWeight;\n        uint32 currentCycle;\n    }\n\n    /// @notice a mapping from users to gauges to a user's allocated weight to that gauge\n    mapping(address => mapping(address => uint112)) public getUserGaugeWeight;\n\n    /// @notice a mapping from a user to their total allocated weight across all gauges\n    /// @dev NOTE this may contain weights for deprecated gauges\n    mapping(address => uint112) public getUserWeight;\n\n    /// @notice a mapping from a gauge to the total weight allocated to it\n    /// @dev NOTE this may contain weights for deprecated gauges\n    mapping(address => Weight) internal _getGaugeWeight;\n\n    /// @notice the total global allocated weight ONLY of live gauges\n    Weight internal _totalWeight;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead weight\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                              VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice return the end of the current cycle. This is the next unix timestamp which evenly divides `gaugeCycleLength`\n    function getGaugeCycleEnd() public view returns (uint32) {\n        return _getGaugeCycleEnd();\n    }\n\n    /// @notice see `getGaugeCycleEnd()`\n    function _getGaugeCycleEnd() internal view returns (uint32) {\n        uint32 nowPlusOneCycle = block.timestamp.safeCastTo32() + gaugeCycleLength;\n        unchecked {\n            return (nowPlusOneCycle / gaugeCycleLength) * gaugeCycleLength; // cannot divide by zero and always <= nowPlusOneCycle so no overflow\n        }\n    }\n\n    /// @notice returns the current weight of a given gauge\n    function getGaugeWeight(address gauge) public view returns (uint112) {\n        return _getGaugeWeight[gauge].currentWeight;\n    }\n\n    /// @notice returns the stored weight of a given gauge. This is the snapshotted weight as-of the end of the last cycle.\n    function getStoredGaugeWeight(address gauge) public view returns (uint112) {\n        if (_deprecatedGauges.contains(gauge)) return 0;\n        return _getStoredWeight(_getGaugeWeight[gauge], _getGaugeCycleEnd());\n    }\n\n    /// @notice see `getStoredGaugeWeight()`\n    function _getStoredWeight(Weight storage gaugeWeight, uint32 currentCycle) internal view returns (uint112) {\n        return gaugeWeight.currentCycle < currentCycle ? gaugeWeight.currentWeight : gaugeWeight.storedWeight;\n    }\n\n    /// @notice returns the current total allocated weight\n    function totalWeight() external view returns (uint112) {\n        return _totalWeight.currentWeight;\n    }\n\n    /// @notice returns the stored total allocated weight\n    function storedTotalWeight() external view returns (uint112) {\n        return _getStoredWeight(_totalWeight, _getGaugeCycleEnd());\n    }\n\n    /// @notice returns the set of live gauges\n    function gauges() external view returns (address[] memory) {\n        return _gauges.values();\n    }\n\n    /** \n      @notice returns a paginated subset of live gauges\n      @param offset the index of the first gauge element to read\n      @param num the number of gauges to return\n    */\n    function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num; ) {\n            unchecked {\n                values[i] = _gauges.at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @notice returns true if `gauge` is not in deprecated gauges\n    function isGauge(address gauge) external view returns (bool) {\n        return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);\n    }\n\n    /// @notice returns the number of live gauges\n    function numGauges() external view returns (uint256) {\n        return _gauges.length();\n    }\n\n    /// @notice returns the set of previously live but now deprecated gauges\n    function deprecatedGauges() external view returns (address[] memory) {\n        return _deprecatedGauges.values();\n    }\n\n    /// @notice returns the number of live gauges\n    function numDeprecatedGauges() external view returns (uint256) {\n        return _deprecatedGauges.length();\n    }\n\n    /// @notice returns the set of gauges the user has allocated to, may be live or deprecated.\n    function userGauges(address user) external view returns (address[] memory) {\n        return _userGauges[user].values();\n    }\n\n    /// @notice returns true if `gauge` is in user gauges\n    function isUserGauge(address user, address gauge) external view returns (bool) {\n        return _userGauges[user].contains(gauge);\n    }\n\n    /** \n      @notice returns a paginated subset of gauges the user has allocated to, may be live or deprecated.\n      @param user the user to return gauges from.\n      @param offset the index of the first gauge element to read.\n      @param num the number of gauges to return.\n    */\n    function userGauges(\n        address user,\n        uint256 offset,\n        uint256 num\n    ) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num; ) {\n            unchecked {\n                values[i] = _userGauges[user].at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @notice returns the number of user gauges\n    function numUserGauges(address user) external view returns (uint256) {\n        return _userGauges[user].length();\n    }\n\n    /// @notice helper function exposing the amount of weight available to allocate for a user\n    function userUnusedWeight(address user) external view returns (uint256) {\n        return balanceOf[user] - getUserWeight[user];\n    }\n\n    /** \n     @notice helper function for calculating the proportion of a `quantity` allocated to a gauge\n     @param gauge the gauge to calculate allocation of\n     @param quantity a representation of a resource to be shared among all gauges\n     @return the proportion of `quantity` allocated to `gauge`. Returns 0 if gauge is not live, even if it has weight.\n    */\n    function calculateGaugeAllocation(address gauge, uint256 quantity) external view returns (uint256) {\n        if (_deprecatedGauges.contains(gauge)) return 0;\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        uint112 total = _getStoredWeight(_totalWeight, currentCycle);\n        uint112 weight = _getStoredWeight(_getGaugeWeight[gauge], currentCycle);\n        return (quantity * weight) / total;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice thrown when trying to increment/decrement a mismatched number of gauges and weights.\n    error SizeMismatchError();\n\n    /// @notice thrown when trying to increment over the max allowed gauges.\n    error MaxGaugeError();\n\n    /// @notice thrown when incrementing over a users free weight.\n    error OverWeightError();\n\n    /// @notice thrown when incremending during the freeze window.\n    error IncrementFreezeError();\n\n    /// @notice emitted when incrementing a gauge\n    event IncrementGaugeWeight(address indexed user, address indexed gauge, uint256 weight, uint32 cycleEnd);\n\n    /// @notice emitted when decrementing a gauge\n    event DecrementGaugeWeight(address indexed user, address indexed gauge, uint256 weight, uint32 cycleEnd);\n\n    /** \n     @notice increment a gauge with some weight for the caller\n     @param gauge the gauge to increment\n     @param weight the amount of weight to increment on gauge\n     @return newUserWeight the new user weight\n    */\n    function incrementGauge(address gauge, uint112 weight) external returns (uint112 newUserWeight) {\n        uint32 currentCycle = _getGaugeCycleEnd();\n        _incrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n        return _incrementUserAndGlobalWeights(msg.sender, weight, currentCycle);\n    }\n\n    function _incrementGaugeWeight(\n        address user,\n        address gauge,\n        uint112 weight,\n        uint32 cycle\n    ) internal {\n        if (_deprecatedGauges.contains(gauge)) revert InvalidGaugeError();\n        unchecked {\n            if (cycle - block.timestamp <= incrementFreezeWindow) revert IncrementFreezeError();\n        }\n\n        bool added = _userGauges[user].add(gauge); // idempotent add\n        if (added && _userGauges[user].length() > maxGauges && !canContractExceedMaxGauges[user])\n            revert MaxGaugeError();\n\n        getUserGaugeWeight[user][gauge] += weight;\n\n        _writeGaugeWeight(_getGaugeWeight[gauge], _add, weight, cycle);\n\n        emit IncrementGaugeWeight(user, gauge, weight, cycle);\n    }\n\n    function _incrementUserAndGlobalWeights(\n        address user,\n        uint112 weight,\n        uint32 cycle\n    ) internal returns (uint112 newUserWeight) {\n        newUserWeight = getUserWeight[user] + weight;\n        // Ensure under weight\n        if (newUserWeight > balanceOf[user]) revert OverWeightError();\n\n        // Update gauge state\n        getUserWeight[user] = newUserWeight;\n\n        _writeGaugeWeight(_totalWeight, _add, weight, cycle);\n    }\n\n    /** \n     @notice increment a list of gauges with some weights for the caller\n     @param gaugeList the gauges to increment\n     @param weights the weights to increment by\n     @return newUserWeight the new user weight\n    */\n    function incrementGauges(address[] calldata gaugeList, uint112[] calldata weights)\n        external\n        returns (uint256 newUserWeight)\n    {\n        uint256 size = gaugeList.length;\n        if (weights.length != size) revert SizeMismatchError();\n\n        // store total in summary for batch update on user/global state\n        uint112 weightsSum;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Update gauge specific state\n        for (uint256 i = 0; i < size; ) {\n            address gauge = gaugeList[i];\n            uint112 weight = weights[i];\n            weightsSum += weight;\n\n            _incrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n            unchecked {\n                i++;\n            }\n        }\n        return _incrementUserAndGlobalWeights(msg.sender, weightsSum, currentCycle);\n    }\n\n    /** \n     @notice decrement a gauge with some weight for the caller\n     @param gauge the gauge to decrement\n     @param weight the amount of weight to decrement on gauge\n     @return newUserWeight the new user weight\n    */\n    function decrementGauge(address gauge, uint112 weight) external returns (uint112 newUserWeight) {\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // All operations will revert on underflow, protecting against bad inputs\n        _decrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n        return _decrementUserAndGlobalWeights(msg.sender, weight, currentCycle);\n    }\n\n    function _decrementGaugeWeight(\n        address user,\n        address gauge,\n        uint112 weight,\n        uint32 cycle\n    ) internal {\n        uint112 oldWeight = getUserGaugeWeight[user][gauge];\n\n        getUserGaugeWeight[user][gauge] = oldWeight - weight;\n        if (oldWeight == weight) {\n            // If removing all weight, remove gauge from user list.\n            require(_userGauges[user].remove(gauge));\n        }\n\n        _writeGaugeWeight(_getGaugeWeight[gauge], _subtract, weight, cycle);\n\n        emit DecrementGaugeWeight(user, gauge, weight, cycle);\n    }\n\n    function _decrementUserAndGlobalWeights(\n        address user,\n        uint112 weight,\n        uint32 cycle\n    ) internal returns (uint112 newUserWeight) {\n        newUserWeight = getUserWeight[user] - weight;\n\n        getUserWeight[user] = newUserWeight;\n        _writeGaugeWeight(_totalWeight, _subtract, weight, cycle);\n    }\n\n    /** \n     @notice decrement a list of gauges with some weights for the caller\n     @param gaugeList the gauges to decrement\n     @param weights the list of weights to decrement on the gauges\n     @return newUserWeight the new user weight\n    */\n    function decrementGauges(address[] calldata gaugeList, uint112[] calldata weights)\n        external\n        returns (uint112 newUserWeight)\n    {\n        uint256 size = gaugeList.length;\n        if (weights.length != size) revert SizeMismatchError();\n\n        // store total in summary for batch update on user/global state\n        uint112 weightsSum;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Update gauge specific state\n        // All operations will revert on underflow, protecting against bad inputs\n        for (uint256 i = 0; i < size; ) {\n            address gauge = gaugeList[i];\n            uint112 weight = weights[i];\n            weightsSum += weight;\n\n            _decrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n            unchecked {\n                i++;\n            }\n        }\n        return _decrementUserAndGlobalWeights(msg.sender, weightsSum, currentCycle);\n    }\n\n    /**\n     @dev this function is the key to the entire contract.\n     The storage weight it operates on is either a global or gauge-specific weight.\n     The operation applied is either addition for incrementing gauges or subtraction for decrementing a gauge.\n    */\n    function _writeGaugeWeight(\n        Weight storage weight,\n        function(uint112, uint112) view returns (uint112) op,\n        uint112 delta,\n        uint32 cycle\n    ) private {\n        uint112 currentWeight = weight.currentWeight;\n        // If the last cycle of the weight is before the current cycle, use the current weight as the stored.\n        uint112 stored = weight.currentCycle < cycle ? currentWeight : weight.storedWeight;\n        uint112 newWeight = op(currentWeight, delta);\n\n        weight.storedWeight = stored;\n        weight.currentWeight = newWeight;\n        weight.currentCycle = cycle;\n    }\n\n    function _add(uint112 a, uint112 b) private pure returns (uint112) {\n        return a + b;\n    }\n\n    function _subtract(uint112 a, uint112 b) private pure returns (uint112) {\n        return a - b;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice thrown when trying to increment or remove a non-live gauge, or add a live gauge.\n    error InvalidGaugeError();\n\n    /// @notice emitted when adding a new gauge to the live set.\n    event AddGauge(address indexed gauge);\n\n    /// @notice emitted when removing a gauge from the live set.\n    event RemoveGauge(address indexed gauge);\n\n    /// @notice emitted when updating the max number of gauges a user can delegate to.\n    event MaxGaugesUpdate(uint256 oldMaxGauges, uint256 newMaxGauges);\n\n    /// @notice emitted when changing a contract's approval to go over the max gauges.\n    event CanContractExceedMaxGaugesUpdate(address indexed account, bool canContractExceedMaxGauges);\n\n    /// @notice the default maximum amount of gauges a user can allocate to.\n    /// @dev if this number is ever lowered, or a contract has an override, then existing addresses MAY have more gauges allocated to. Use `numUserGauges` to check this.\n    uint256 public maxGauges;\n\n    /// @notice an approve list for contracts to go above the max gauge limit.\n    mapping(address => bool) public canContractExceedMaxGauges;\n\n    /// @notice add a new gauge. Requires auth by `authority`.\n    function addGauge(address gauge) external requiresAuth returns (uint112) {\n        return _addGauge(gauge);\n    }\n\n    function _addGauge(address gauge) internal returns (uint112 weight) {\n        bool newAdd = _gauges.add(gauge);\n        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);\n        // add and fail loud if zero address or already present and not deprecated\n        if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGaugeError();\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Check if some previous weight exists and re-add to total. Gauge and user weights are preserved.\n        weight = _getGaugeWeight[gauge].currentWeight;\n        if (weight > 0) {\n            _writeGaugeWeight(_totalWeight, _add, weight, currentCycle);\n        }\n\n        emit AddGauge(gauge);\n    }\n\n    /// @notice remove a new gauge. Requires auth by `authority`.\n    function removeGauge(address gauge) external requiresAuth {\n        _removeGauge(gauge);\n    }\n\n    function _removeGauge(address gauge) internal {\n        // add to deprecated and fail loud if not present\n        if (!_deprecatedGauges.add(gauge)) revert InvalidGaugeError();\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Remove weight from total but keep the gauge and user weights in storage in case gauge is re-added.\n        uint112 weight = _getGaugeWeight[gauge].currentWeight;\n        if (weight > 0) {\n            _writeGaugeWeight(_totalWeight, _subtract, weight, currentCycle);\n        }\n\n        emit RemoveGauge(gauge);\n    }\n\n    /// @notice replace a gauge. Requires auth by `authority`.\n    function replaceGauge(address oldGauge, address newGauge) external requiresAuth {\n        _removeGauge(oldGauge);\n        _addGauge(newGauge);\n    }\n\n    /// @notice set the new max gauges. Requires auth by `authority`.\n    /// @dev if this is set to a lower number than the current max, users MAY have more gauges active than the max. Use `numUserGauges` to check this.\n    function setMaxGauges(uint256 newMax) external requiresAuth {\n        uint256 oldMax = maxGauges;\n        maxGauges = newMax;\n\n        emit MaxGaugesUpdate(oldMax, newMax);\n    }\n\n    /// @notice set the canContractExceedMaxGauges flag for an account.\n    function setContractExceedMaxGauges(address account, bool canExceedMax) external requiresAuth {\n        if (canExceedMax && account.code.length == 0) revert Errors.NonContractError(); // can only approve contracts\n\n        canContractExceedMaxGauges[account] = canExceedMax;\n\n        emit CanContractExceedMaxGaugesUpdate(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires userUnusedWeight < amount.\n    /// _decrementWeightUntilFree is called as a greedy algorithm to free up weight.\n    /// It may be more gas efficient to free weight before burning or transferring tokens.\n\n    function _burn(address from, uint256 amount) internal virtual override {\n        _decrementWeightUntilFree(from, amount);\n        super._burn(from, amount);\n    }\n\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        _decrementWeightUntilFree(msg.sender, amount);\n        return super.transfer(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _decrementWeightUntilFree(from, amount);\n        return super.transferFrom(from, to, amount);\n    }\n\n    /// a greedy algorithm for freeing weight before a token burn/transfer\n    /// frees up entire gauges, so likely will free more than `weight`\n    function _decrementWeightUntilFree(address user, uint256 weight) internal {\n        uint256 userFreeWeight = balanceOf[user] - getUserWeight[user];\n\n        // early return if already free\n        if (userFreeWeight >= weight) return;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // cache totals for batch updates\n        uint112 userFreed;\n        uint112 totalFreed;\n\n        // Loop through all user gauges, live and deprecated\n        address[] memory gaugeList = _userGauges[user].values();\n\n        // Free gauges until through entire list or under weight\n        uint256 size = gaugeList.length;\n        for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight; ) {\n            address gauge = gaugeList[i];\n            uint112 userGaugeWeight = getUserGaugeWeight[user][gauge];\n            if (userGaugeWeight != 0) {\n                // If the gauge is live (not deprecated), include its weight in the total to remove\n                if (!_deprecatedGauges.contains(gauge)) {\n                    totalFreed += userGaugeWeight;\n                }\n                userFreed += userGaugeWeight;\n                _decrementGaugeWeight(user, gauge, userGaugeWeight, currentCycle);\n\n                unchecked {\n                    i++;\n                }\n            }\n        }\n\n        getUserWeight[user] -= userFreed;\n        _writeGaugeWeight(_totalWeight, _subtract, totalFreed, currentCycle);\n    }\n}"
    }
  ]
}