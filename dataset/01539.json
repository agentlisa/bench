{
  "Title": "M-4: Full inventory asset purchases can be DOS'd via frontrunning",
  "Content": "# Issue M-4: Full inventory asset purchases can be DOS'd via frontrunning \n\nSource: https://github.com/sherlock-audit/2023-06-Index-judging/issues/41 \n\n## Found by \n0x52, Arabadzhiev\n## Summary\n\nUsers who attempt to swap the entire component value can be frontrun with a very small bid making their transaction revert\n\n## Vulnerability Detail\n\n[AuctionRebalanceModuleV1.sol#L795-L796](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L795-L796)\n\n        // Ensure that the component quantity in the bid does not exceed the available auction quantity.\n        require(_componentQuantity <= bidInfo.auctionQuantity, \"Bid size exceeds auction quantity\");\n\nWhen creating a bid, it enforces the above requirement. This prevents users from buying more than they should but it is also a source of an easy DOS attack. Assume a user is trying to buy the entire balance of a component, a malicious user can frontrun them buying only a tiny amount. Since they requested the entire balance, the call with fail. This is a useful technique if an attacker wants to DOS other buyers to pass the time and get a better price from the dutch auction.\n\n## Impact\n\nMalicious user can DOS legitimate users attempting to purchase the entire amount of component\n\n## Code Snippet\n\n[AuctionRebalanceModuleV1.sol#L772-L836](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L772-L836)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow users to specify type(uint256.max) to swap the entire available balance\n\n\n\n## Discussion\n\n**pblivin0x**\n\nThe recommendation here is that we allow `componentQuantity` to be specified in excess of the auction size? so replace the current check\n\n```solidity\n// Ensure that the component quantity in the bid does not exceed the available auction quantity.\nrequire(_componentQuantity <= bidInfo.auctionQuantity, \"Bid size exceeds auction quantity\");\n```\n\nwith a enforced cap\n\n```solidity\nif (_componentQuantity > bidInfo.auctionQuantity) {\n    _componentQuantity = bidInfo.auctionQuantity;\n}\n```\n\nI was originally hesitant because of some unintuitive UX, but if this removes the potential for a DOS attack, i think it is worth implementing.\n\n**FlattestWhite**\n\nHmmm we should probably allow user to specify `maxQuantity` rather than the absolute quantity they want to buy\n\n**snake-poison**\n\n> The recommendation here is that we allow `componentQuantity` to be specified in excess of the auction size? so replace the current check\n> \n> ```solidity\n> // Ensure that the component quantity in the bid does not exceed the available auction quantity.\n> require(_componentQuantity <= bidInfo.auctionQuantity, \"Bid size exceeds auction quantity\");\n> ```\n> \n> with a enforced cap\n> \n> ```solidity\n> if (_componentQuantity > bidInfo.auctionQuantity) {\n>     _componentQuantity = bidInfo.auctionQuantity;\n> }\n> ```\n> \n> I was originally hesitant because of some unintuitive UX, but if this removes the potential for a DOS attack, i think it is worth implementing.\n\nI believe what the submitter was recommending was something more akin to keeping the :\n\n```solidity\n if (_componentQuantity == type(uint256).max) {\n     _componentQuantity = bidInfo.auctionQuantity;\n} else {\nrequire(_componentQuantity <= bidInfo.auctionQuantity, \"Bid size exceeds auction quantity\");\n}\n```\n\nnote: the difference in gas is trivial, but it isn't equivalent to your suggestion so I wanted to point it out. My examples assumes pragma > 0.7 to use the type().max syntax but the older idiomatic `uint256(-1) ` would.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> Severity should not be Medium, has to be low or invalid, because there is no incentive at all for front-runners and also based on Sherlock's documentation, DOS < 1yr is not a valid one.\n\nThe escalation could not be created because you are not exceeding the escalation threshold.\n\nYou can view the required number of additional valid issues/judging contest payouts in your Profile page,\nin the [Sherlock webapp](https://app.sherlock.xyz/audits/).\n\n\n**JJtheAndroid**\n\nEscalate\n\nThis issue should be low/invalid as per Sherlock's rules https://docs.sherlock.xyz/audits/judging/judging. In addition, this is an edge case with no user funds at risk. \n\n**sherlock-admin2**\n\n > Escalate\n> \n> This issue should be low/invalid as per Sherlock's rules https://docs.sherlock.xyz/audits/judging/judging. In addition, this is an edge case with no user funds at risk. \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Arabadzhiew**\n\n> Escalate\n> \n> This issue should be low/invalid as per Sherlock's rules https://docs.sherlock.xyz/audits/judging/judging. In addition, this is an edge case with no user funds at risk.\n\nCan't agree on this. This is definitely not an edge case. There is an incentive to perform such kind of a DoS - If the price of the auction decreases over time, users will probably want to prolong it as much as they can. Additionally, the DoS can very easily happen unintentionally, when a lot of bid transactions get executed in the same block.\n\n**JJtheAndroid**\n\n> > Escalate\n> > This issue should be low/invalid as per Sherlock's rules https://docs.sherlock.xyz/audits/judging/judging. In addition, this is an edge case with no user funds at risk.\n> \n> Can't agree on this. This is definitely not an edge case. There is an incentive to perform such kind of a DoS - If the price of the auction decreases over time, users will probably want to prolong it as much as they can. Additionally, the DoS can very easily happen unintentionally, when a lot of bid transactions get executed in the same block.\n\n\n\nIn your scenario, users can only prolong it as long the current price is higher than min price. Malicious front running is useless beyond that point, because the price cannot go any lower. This would be invalid as per Sherlock rules on DOS attacks.\n\n\nThe unintentional scenario is not a DOS, it is just multiple people bidding at the same time. This is by design.\n\n\nAgain, no user funds are at risk. This should not be a med\n\n**IAm0x52**\n\n> Can't agree on this. This is definitely not an edge case. There is an incentive to perform such kind of a DoS - If the price of the auction decreases over time, users will probably want to prolong it as much as they can. Additionally, the DoS can very easily happen unintentionally, when a lot of bid transactions get executed in the same block.\n\nAgreed with this. Given the nature of a dutch auction, the temporary DOS will prevent the auction from executing as expected and lead to assets being sold under market value.\n\n**pblivin0x**\n\nI agree this is a valid Medium\n\n**0xauditsea**\n\nvalid Medium? ðŸ¤”ðŸ¤”ðŸ¤”\n\n**0xauditsea**\n\nHere's the docs about the severity of DOS: https://docs.sherlock.xyz/audits/judging/judging\n\n![image](https://github.com/sherlock-audit/2023-06-Index-judging/assets/133329604/6df6248c-d3d7-4a2b-8e7e-67d4598d44fd)\n\nHope this helps in escalation! Thanks y'all! ðŸ‘\n\n**hrishibhat**\n\n@0xauditsea @JJtheAndroid \nThere seems to be some confusion about the rule for DOS. Funds not being accessible temporarily does not apply here. \nHere the DOS results in loss of funds which is considered to be a medium:\n> Agreed with this. Given the nature of a dutch auction, the temporary DOS will prevent the auction from executing as expected and lead to assets being sold under market value.\n\n**0xauditsea**\n\n@hrishibhat - Why is there loss of funds at all? The auction has minimum price defined which can be lower than the market value, that's totally fine for users to buy tokens with lower price, it's benefit for users, acceptable for auction manager.\n\n**hrishibhat**\n\n@pblivin0x @0xauditsea \nCorrect me if I'm wrong, assuming here it is a Dutch auction where price reduces over time. If i can DOS someone who is ready to bid for a higher price and I bid for a lesser price after some time. Isn't this an issue?\n\n\n**hrishibhat**\n\nTo add to my comment: \nthe Max min values are values that are acceptable by the manager if the users decide to bid for the value within that range. \nThat does not mean the code should unfairly allow someone to stop a higher bid and bid at a lower price. This seems like valid issue that does not allow normal functioning of dutch auction. \n\n**0xauditsea**\n\n@hrishibhat - In selling auction (users buy component), component price goes lower as time goes. So when it's front-run, the user will try again with lower price, which is fine for the user, also no problem with the auction manager.\n\n**0xauditsea**\n\nThis is basically not loss of funds.\n\n**JJtheAndroid**\n\n> To add to my comment: the Max min values are values that are acceptable by the manager if the users decide to bid for the value within that range. That does not mean the code should unfairly allow someone to stop a higher bid and bid at a lower price. This seems like valid issue that does not allow normal functioning of dutch auction.\n\nI don't want to go back and forth on this. I just want to say that your description is inaccurate. The report does not describe DOS on higher bids, it is a DOS on **full inventory** bids which is a rarer occurrence. Big difference. Also such an \"attack\" does not benefit the attacker nor does it hurt the \"victim\" because they both want to buy assets at a lower price. \n\n Finally, there is a min price bound set by the manager. So any full inventory DOS at that point is completely useless and a waste of gas. \n\nAll of this is assuming that there are only 2 actors (the attacker and the victim) bidding. In reality, there will likely be many more and not all of them will submit a full inventory bid. \n\n\nI will not comment on this further \n\n**pblivin0x**\n\n> @pblivin0x @0xauditsea Correct me if I'm wrong, assuming here it is a Dutch auction where price reduces over time. If i can DOS someone who is ready to bid for a higher price and I bid for a lesser price after some time. Isn't this an issue?\n\nWe have a 1000 ETH auction, a legitimate bidder wants to settle the full 1000 ETH auction at `PRICE_HIGH`\n\nThe malicious bidder is willing to settle the 1000 ETH auction at `PRICE_LOW`, so they frontrun the legitimate bidder with `SMALL_SIZE` bid. \n\nIf some transactions are successfully DOS'd, the legitimate bidder could submit a 1000 ETH - `SMALL_SIZE` bid, or something like a 500 ETH bid, such that the malicious bidder is not willing to front run at that size\n\n**Oot2k**\n\n> > Escalate\n> > This issue should be low/invalid as per Sherlock's rules https://docs.sherlock.xyz/audits/judging/judging. In addition, this is an edge case with no user funds at risk.\n> \n> Can't agree on this. This is definitely not an edge case. There is an incentive to perform such kind of a DoS - If the price of the auction decreases over time, users will probably want to prolong it as much as they can. Additionally, the DoS can very easily happen unintentionally, when a lot of bid transactions get executed in the same block.\n\nI think this is valid, this comment explains it well.\n\n**0xauditsea**\n\n> > @pblivin0x @0xauditsea Correct me if I'm wrong, assuming here it is a Dutch auction where price reduces over time. If i can DOS someone who is ready to bid for a higher price and I bid for a lesser price after some time. Isn't this an issue?\n> \n> We have a 1000 ETH auction, a legitimate bidder wants to settle the full 1000 ETH auction at `PRICE_HIGH`\n> \n> The malicious bidder is willing to settle the 1000 ETH auction at `PRICE_LOW`, so they frontrun the legitimate bidder with `SMALL_SIZE` bid.\n> \n> If some transactions are successfully DOS'd, the legitimate bidder could submit a 1000 ETH - `SMALL_SIZE` bid, or something like a 500 ETH bid, such that the malicious bidder is not willing to front run at that size\n\nTotally agree with this, no way front-runners would try it.\n\n**Arabadzhiew**\n\n> > @pblivin0x @0xauditsea Correct me if I'm wrong, assuming here it is a Dutch auction where price reduces over time. If i can DOS someone who is ready to bid for a higher price and I bid for a lesser price after some time. Isn't this an issue?\n> \n> We have a 1000 ETH auction, a legitimate bidder wants to settle the full 1000 ETH auction at `PRICE_HIGH`\n> \n> The malicious bidder is willing to settle the 1000 ETH auction at `PRICE_LOW`, so they frontrun the legitimate bidder with `SMALL_SIZE` bid.\n> \n> If some transactions are successfully DOS'd, the legitimate bidder could submit a 1000 ETH - `SMALL_SIZE` bid, or something like a 500 ETH bid, such that the malicious bidder is not willing to front run at that size\n\nCorrect me if I'm wrong, but even in your example, the legitimate bidder is most likely still going to end up buying the ETH at a lower price, leading to the protocol receiving less assets that it could have received. \n\nThe main issue here is that due to the current implementation, full inventory purchases are going to end up being reverted most of the time, be it due to intentional DoS attacks, or simply because there were a lot of bid transactions executed at the given time (for example, if there were 5 bid transactions sitting in the mempool with the same gas price and one of them was for a full inventory purchase, if that one does not get executed first, it will simply be reverted), leading to the component assets being sold at lower prices.\n\n**0xauditsea**\n\n@Arabadzhiew\nYou guys keep saying components are being sold at lower prices, if auction manager doesn't want them to be sold at lower prices, they should increase MIN price. When auction manager defines MIN price, it surely means that purchase at MIN price is pretty acceptable, this is pretty logical thing. Components being sold at lower price, good for buyers, acceptable for the auction manager, what is the problem here at all?\n\nRegarding the example you mentioned above, you are right that full purchase bid will be reverted when there is another bid tx is executed before it, I think that's fine, that's what the auction is for - first buyer gets what they want.\nIf you don't agree with this and let full purchase tx buy all remaining amount, it will cause an issue like, users wanted to buy whole 10WETH from the auction but they end up only buying 5WETH, do you think users will like this?\n\nOfc this issue needs to be fixed, but the severity can not be Med at all.\n\n**Arabadzhiew**\n\n> @Arabadzhiew You guys keep saying components are being sold at lower prices, if auction manager doesn't want them to be sold at lower prices, they should increase MIN price. When auction manager defines MIN price, it surely means that purchase at MIN price is pretty acceptable, this is pretty logical thing. Components being sold at lower price, good for buyers, acceptable for the auction manager, what is the problem here at all?\n> \n> Regarding the example you mentioned above, you are right that full purchase bid will be reverted when there is another bid tx is executed before it, I think that's fine, that's what the auction is for - first buyer gets what they want. If you don't agree with this and let full purchase tx buy all remaining amount, it will cause an issue like, users wanted to buy whole 10WETH from the auction but they end up only buying 5WETH, do you think users will like this?\n> \n> Ofc this issue needs to be fixed, but the severity can not be Med at all.\n\nSure, the MIN value is defined by the auction manager, but the fact that the component asset is going to be sold at a lower price is still a loss of funds for the protocol. The MIN value is there to make sure that the auction targets get reached, but I don't think the protocol team should be ok with receiving less assets, when they can receive more.\n\nAlso, regarding the mitigation recommended in this report, I think it is fine due to the fact that it is optional - users can only use the entire available balance purchase functionality if they explicitly say so, otherwise the bidding functionality should work as it currently does.\n\nI won't comment on this issue any further. Let's let the Sherlock team decide whether it is a valid medium or not.\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nAfter consideration of the above comments this issue is a valid medium, DOS of a valid bid at a certain price in a Dutch auction is considered damage to how the auction functions. \n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [JJtheAndroid](https://github.com/sherlock-audit/2023-06-Index-judging/issues/41/#issuecomment-1658752271): rejected\n\n**hrishibhat**\n\nAdditionally, I see that the Sherlock rules are being interpreted incorrectly, will make sure to make the necessary changes to the docs and see how best any possible confusion can be avoided. \n\n**pblivin0x**\n\nThe remediation for this issue is open for review here https://github.com/IndexCoop/index-protocol/pull/25\n\nThe changes are to allow users to specify `type(uint256.max)` to settle the remaining auction https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol#L811-L817\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/91",
  "Code": [
    {
      "filename": "index-protocol/contracts/protocol/modules/v1/AuctionRebalanceModuleV1.sol",
      "content": "/*\n    Copyright 2023 Index Coop\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.6.10;\npragma experimental \"ABIEncoderV2\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/math/Math.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport { AddressArrayUtils } from \"../../../lib/AddressArrayUtils.sol\";\nimport { IAuctionPriceAdapterV1 } from \"../../../interfaces/IAuctionPriceAdapterV1.sol\";\nimport { IController } from \"../../../interfaces/IController.sol\";\nimport { Invoke } from \"../../lib/Invoke.sol\";\nimport { ISetToken } from \"../../../interfaces/ISetToken.sol\";\nimport { ModuleBase } from \"../../lib/ModuleBase.sol\";\nimport { Position } from \"../../lib/Position.sol\";\nimport { PreciseUnitMath } from \"../../../lib/PreciseUnitMath.sol\";\n\n/**\n * @title AuctionRebalanceModuleV1\n * @author Index Coop\n * @notice Facilitates rebalances for index sets via single-asset auctions. Managers initiate\n * rebalances specifying target allocations in precise units (scaled by 10^18), quote asset\n * (e.g., WETH, USDC), auction parameters per component, and rebalance duration through\n * startRebalance(). Bidders can participate via bid() for individual components. Excess\n * quote asset can be managed by proportionally increasing the targets using raiseAssetTargets().\n *\n * @dev Compatible with StreamingFeeModule and BasicIssuanceModule. Review compatibility if used\n * with additional modules.\n */\ncontract AuctionRebalanceModuleV1 is ModuleBase, ReentrancyGuard {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using Position for uint256;\n    using Math for uint256;\n    using Position for ISetToken;\n    using Invoke for ISetToken;\n    using AddressArrayUtils for address[];\n    using AddressArrayUtils for IERC20[];\n\n    /* ============ Structs ============ */\n\n    struct AuctionExecutionParams {\n        uint256 targetUnit;                      // Target quantity of the component in Set, in precise units (10 ** 18).\n        string priceAdapterName;                 // Identifier for the price adapter to be used.\n        bytes priceAdapterConfigData;            // Encoded data for configuring the chosen price adapter.\n    }\n\n    struct BidPermissionInfo {\n        bool isAnyoneAllowedToBid;               // Flag indicating if bids are open to anyone (true) or restricted (false).\n        address[] biddersHistory;                // List of addresses that have been permissioned to bid.\n        mapping(address => bool) bidAllowList;   // Mapping of addresses to a boolean indicating if they are allowed to bid.\n    }\n\n    struct RebalanceInfo {\n        IERC20 quoteAsset;                       // Reference to the ERC20 token used to quote auctions.\n        uint256 rebalanceStartTime;              // Unix timestamp marking the start of the rebalance.\n        uint256 rebalanceDuration;               // Duration of the rebalance in seconds.\n        uint256 positionMultiplier;              // Position multiplier when target units were calculated.\n        uint256 raiseTargetPercentage;           // Optional percentage to increase all target units if allowed, in precise units.\n        address[] rebalanceComponents;           // List of component tokens involved in the rebalance.\n    }\n\n    struct BidInfo {\n        ISetToken setToken;                      // Instance of the SetToken contract that is being rebalanced.\n        IERC20 sendToken;                        // The ERC20 token being sent in this bid.\n        IERC20 receiveToken;                     // The ERC20 token being received in this bid.\n        IAuctionPriceAdapterV1 priceAdapter;     // Instance of the price adapter contract used for this bid.\n        bytes priceAdapterConfigData;            // Data for configuring the price adapter.\n        bool isSellAuction;                      // Indicates if this is a sell auction (true) or a buy auction (false).\n        uint256 auctionQuantity;                 // The quantity of the component being auctioned.\n        uint256 componentPrice;                  // The price of the component as quoted by the price adapter.\n        uint256 quantitySentBySet;               // Quantity of tokens sent by SetToken in this bid.\n        uint256 quantityReceivedBySet;           // Quantity of tokens received by SetToken in this bid.\n        uint256 preBidTokenSentBalance;          // Balance of tokens being sent by SetToken before the bid.\n        uint256 preBidTokenReceivedBalance;      // Balance of tokens being received by SetToken before the bid.\n        uint256 setTotalSupply;                  // Total supply of the SetToken at the time of the bid.\n    }\n\n    /* ============ Events ============ */\n\n    /**\n     * @dev Emitted when the target percentage increase is modified via setRaiseTargetPercentage()\n     * @param setToken                   Reference to the SetToken undergoing rebalancing\n     * @param newRaiseTargetPercentage   Updated percentage for potential target unit increases, in precise units (10 ** 18)\n     */\n    event RaiseTargetPercentageUpdated(\n        ISetToken indexed setToken, \n        uint256 newRaiseTargetPercentage\n    );\n\n    /**\n     * @dev Emitted upon calling raiseAssetTargets()\n     * @param setToken                Reference to the SetToken undergoing rebalancing\n     * @param newPositionMultiplier   Updated position multiplier for the SetToken rebalance\n     */\n    event AssetTargetsRaised(\n        ISetToken indexed setToken, \n        uint256 newPositionMultiplier\n    );\n\n    /**\n     * @dev Emitted upon toggling the bid permission setting via setAnyoneBid()\n     * @param setToken               Reference to the SetToken undergoing rebalancing\n     * @param isAnyoneAllowedToBid   Flag indicating if bids are open to all (true) or restricted (false)\n     */\n    event AnyoneBidUpdated(\n        ISetToken indexed setToken, \n        bool isAnyoneAllowedToBid\n    );\n\n    /**\n     * @dev Emitted when the bidding status of an address is changed via setBidderStatus()\n     * @param setToken          Reference to the SetToken undergoing rebalancing\n     * @param bidder            Address whose bidding permission status is toggled\n     * @param isBidderAllowed   Flag indicating if the address is allowed (true) or not allowed (false) to bid\n     */\n    event BidderStatusUpdated(\n        ISetToken indexed setToken, \n        address indexed bidder, \n        bool isBidderAllowed\n    );\n\n    /**\n     * @dev Emitted when a rebalance is initiated using the startRebalance() function.\n     * @param setToken                    Instance of the SetToken contract that is undergoing rebalancing.\n     * @param quoteAsset                  The ERC20 token that is used as a quote currency for the auctions.\n     * @param isSetTokenLocked            Indicates if the rebalance process locks the SetToken (true) or not (false).\n     * @param rebalanceDuration           Duration of the rebalance process in seconds.\n     * @param initialPositionMultiplier   Position multiplier when target units were calculated.\n     * @param componentsInvolved          Array of addresses of the component tokens involved in the rebalance.\n     * @param auctionParameters           Array of AuctionExecutionParams structs, containing auction parameters for each component token.\n     */\n    event RebalanceStarted(\n        ISetToken indexed setToken,\n        IERC20 indexed quoteAsset,\n        bool isSetTokenLocked,\n        uint256 rebalanceDuration,\n        uint256 initialPositionMultiplier,\n        address[] componentsInvolved,\n        AuctionExecutionParams[] auctionParameters\n    );\n\n    /**\n     * @dev Emitted upon execution of a bid via the bid() function.\n     * @param setToken                   Instance of the SetToken contract that is being rebalanced.\n     * @param sendToken                  The ERC20 token that is being sent by the bidder.\n     * @param receiveToken               The ERC20 token that is being received by the bidder.\n     * @param bidder                     The address of the bidder.\n     * @param priceAdapter               Instance of the price adapter contract used for this bid.\n     * @param isSellAuction              Indicates if this is a sell auction (true) or a buy auction (false).\n     * @param price                      The price of the component in precise units (10 ** 18).\n     * @param netQuantitySentBySet       The net amount of tokens sent by the SetToken in the bid.\n     * @param netQuantityReceivedBySet   The net amount of tokens received by the SetToken in the bid.\n     * @param protocolFee                The amount of the received token allocated as a protocol fee.\n     * @param setTotalSupply             The total supply of the SetToken at the time of the bid.\n     */\n    event BidExecuted(\n        ISetToken indexed setToken,\n        address indexed sendToken,\n        address indexed receiveToken,\n        address bidder,\n        IAuctionPriceAdapterV1 priceAdapter,\n        bool isSellAuction,\n        uint256 price,\n        uint256 netQuantitySentBySet,\n        uint256 netQuantityReceivedBySet,\n        uint256 protocolFee,\n        uint256 setTotalSupply\n    );\n\n    /**\n     * @dev Emitted when a locked rebalance is concluded early via the unlock() function.\n     * @param setToken            Instance of the SetToken contract that is being rebalanced.\n     */\n    event LockedRebalanceEndedEarly(\n        ISetToken indexed setToken\n    );\n\n\n    /* ============ Constants ============ */\n\n    uint256 private constant AUCTION_MODULE_V1_PROTOCOL_FEE_INDEX = 0;   // Index of the protocol fee percentage assigned to this module in the Controller.\n\n    /* ============ State Variables ============ */\n\n    mapping(ISetToken => mapping(IERC20 => AuctionExecutionParams)) public executionInfo;   // Maps SetToken to component tokens and their respective auction execution parameters.\n    mapping(ISetToken => BidPermissionInfo) public permissionInfo;                          // Maps SetToken to information regarding bid permissions during a rebalance.\n    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Maps SetToken to data relevant to the most recent rebalance.\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyAllowedBidder(ISetToken _setToken) {\n        _validateOnlyAllowedBidder(_setToken);\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    constructor(IController _controller) public ModuleBase(_controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @dev MANAGER ONLY: Initiates the rebalance process by setting target allocations for the SetToken. Opens auctions\n     * for filling by the Set's designated bidders. The function takes in new components to be added with their target units\n     * and existing components with updated target units (set to 0 if removing). A positionMultiplier is supplied to adjust\n     * target units, e.g., in cases where fee accrual affects the positionMultiplier of the SetToken, ensuring proportional\n     * allocation among components. If target allocations are not met within the specified duration, the rebalance concludes\n     * with the allocations achieved.\n     *\n     * @param _setToken                     The SetToken to be rebalanced.\n     * @param _quoteAsset                   ERC20 token used as the quote asset in auctions.\n     * @param _newComponents                Addresses of new components to be added.\n     * @param _newComponentsAuctionParams   AuctionExecutionParams for new components, indexed corresponding to _newComponents.\n     * @param _oldComponentsAuctionParams   AuctionExecutionParams for existing components, indexed corresponding to\n     *                                      the current component positions. Set to 0 for components being removed.\n     * @param _shouldLockSetToken           Indicates if the rebalance should lock the SetToken.\n     * @param _rebalanceDuration            Duration of the rebalance in seconds.\n     * @param _initialPositionMultiplier    Position multiplier at the start of the rebalance.\n     */\n    function startRebalance(\n        ISetToken _setToken,\n        IERC20 _quoteAsset,\n        address[] calldata _newComponents,\n        AuctionExecutionParams[] memory _newComponentsAuctionParams,\n        AuctionExecutionParams[] memory _oldComponentsAuctionParams,\n        bool _shouldLockSetToken,\n        uint256 _rebalanceDuration,\n        uint256 _initialPositionMultiplier\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Lock the SetToken if the _shouldLockSetToken flag is true and the SetToken is not already locked by this module\n        if (_shouldLockSetToken && _setToken.locker() != address(this)) {\n            _setToken.lock();\n        }\n\n        // Aggregate components and auction parameters\n        (address[] memory allComponents, AuctionExecutionParams[] memory allAuctionParams) = _aggregateComponentsAndAuctionParams(\n            _setToken.getComponents(),\n            _newComponents,\n            _newComponentsAuctionParams,\n            _oldComponentsAuctionParams\n        );\n\n        // Set the execution information\n        for (uint256 i = 0; i < allComponents.length; i++) {\n            require(!_setToken.hasExternalPosition(allComponents[i]), \"External positions not allowed\");\n            executionInfo[_setToken][IERC20(allComponents[i])] = allAuctionParams[i];\n        }\n\n        // Set the rebalance information\n        rebalanceInfo[_setToken].quoteAsset = _quoteAsset;\n        rebalanceInfo[_setToken].rebalanceStartTime = block.timestamp;\n        rebalanceInfo[_setToken].rebalanceDuration = _rebalanceDuration;\n        rebalanceInfo[_setToken].positionMultiplier = _initialPositionMultiplier;\n        rebalanceInfo[_setToken].rebalanceComponents = allComponents;\n\n        // Emit the RebalanceStarted event\n        emit RebalanceStarted(_setToken, _quoteAsset, _shouldLockSetToken, _rebalanceDuration, _initialPositionMultiplier, allComponents, allAuctionParams);\n    }\n\n   /**\n     * @dev ACCESS LIMITED: Only approved addresses can call this function unless isAnyoneAllowedToBid is enabled. This function\n     * is used to push the current component units closer to the target units defined in startRebalance().\n     *\n     * Bidders specify the amount of the component they intend to buy or sell, and also specify the maximum/minimum amount \n     * of the quote asset they are willing to spend/receive.\n     *\n     * The auction parameters, which are set by the manager, are used to determine the price of the component. Any bids that \n     * either don't move the component units towards the target, or overshoot the target, will be reverted.\n     *\n     * If protocol fees are enabled, they are collected in the token received in a bid.\n     * \n     * SELL AUCTIONS:\n     * At the start of the rebalance, sell auctions are available to be filled in their full size.\n     * \n     * BUY AUCTIONS:\n     * Buy auctions can be filled up to the amount of quote asset available in the SetToken. This means that if the SetToken \n     * does not contain the quote asset as a component, buy auctions cannot be bid on until sell auctions have been executed \n     * and there is quote asset available in the SetToken.\n     *\n     * @param _setToken          The SetToken to be rebalanced.\n     * @param _component         The component for which the auction is to be bid on.\n     * @param _componentAmount   The amount of component in the bid.\n     * @param _quoteAssetLimit   The maximum or minimum amount of quote asset that can be spent or received during the bid.\n     */\n    function bid(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _componentAmount,\n        uint256 _quoteAssetLimit\n    )\n        external\n        nonReentrant\n        onlyAllowedBidder(_setToken)\n    {\n        // Validate whether the bid targets are legitimate\n        _validateBidTargets(_setToken, _component);\n\n        // Create the bid information structure\n        BidInfo memory bidInfo = _createBidInfo(_setToken, _component, _componentAmount, _quoteAssetLimit);\n\n        // Execute the token transfer specified in the bid information\n        _executeBid(bidInfo);\n\n        // Accrue protocol fee and store the amount\n        uint256 protocolFeeAmount = _accrueProtocolFee(bidInfo);\n\n        // Update the position state and store the net amounts\n        (uint256 netAmountSent, uint256 netAmountReceived) = _updatePositionState(bidInfo);\n\n        // Emit the BidExecuted event\n        emit BidExecuted(\n            bidInfo.setToken,\n            address(bidInfo.sendToken),\n            address(bidInfo.receiveToken),\n            msg.sender,\n            bidInfo.priceAdapter,\n            bidInfo.isSellAuction,\n            bidInfo.componentPrice,\n            netAmountSent,\n            netAmountReceived,\n            protocolFeeAmount,\n            bidInfo.setTotalSupply\n        );\n    }\n\n    /**\n     * @dev ACCESS LIMITED: Increases asset targets uniformly when all target units have been met but there is remaining quote asset.\n     * Can be called multiple times if necessary. Targets are increased by the percentage specified by raiseAssetTargetsPercentage set by the manager.\n     * This helps in reducing tracking error and providing greater granularity in reaching an equilibrium between the excess quote asset\n     * and the components to be purchased. However, excessively raising targets may result in under-allocating to the quote asset as more of\n     * it is spent buying components to meet the new targets.\n     *\n     * @param _setToken   The SetToken to be rebalanced.\n     */\n    function raiseAssetTargets(ISetToken _setToken)\n        external\n        onlyAllowedBidder(_setToken)\n        virtual\n    {\n        // Ensure the rebalance is in progress\n        require(!_isRebalanceDurationElapsed(_setToken), \"Rebalance must be in progress\");\n\n        // Ensure that all targets are met and there is excess quote asset\n        require(_canRaiseAssetTargets(_setToken), \"Targets not met or quote asset =~ 0\");\n\n        // Calculate the new positionMultiplier\n        uint256 newPositionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(\n            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)\n        );\n\n        // Update the positionMultiplier in the RebalanceInfo struct\n        rebalanceInfo[_setToken].positionMultiplier = newPositionMultiplier;\n\n        // Emit the AssetTargetsRaised event\n        emit AssetTargetsRaised(_setToken, newPositionMultiplier);\n    }\n\n    /**\n     * @dev Unlocks the SetToken after rebalancing. Can be called once the rebalance duration has elapsed.\n     * Can only be called before the rebalance duration has elapsed if all targets are met, there is excess\n     * or at-target quote asset, and raiseTargetPercentage is zero.\n     *\n     * @param _setToken The SetToken to be unlocked.\n     */\n    function unlock(ISetToken _setToken) external {\n        bool isRebalanceDurationElapsed = _isRebalanceDurationElapsed(_setToken);\n        bool canUnlockEarly = _canUnlockEarly(_setToken);\n\n        // Ensure that either the rebalance duration has elapsed or the conditions for early unlock are met\n        require(isRebalanceDurationElapsed || canUnlockEarly, \"Cannot unlock early unless all targets are met and raiseTargetPercentage is zero\");\n\n        // If unlocking early, update the state\n        if (canUnlockEarly) {\n            delete rebalanceInfo[_setToken].rebalanceDuration;\n            emit LockedRebalanceEndedEarly(_setToken);\n        }\n\n        // Unlock the SetToken\n        _setToken.unlock();\n    }\n\n    /**\n     * @dev MANAGER ONLY: Sets the percentage by which the target units for all components can be increased.\n     * Can be called at any time by the manager.\n     *\n     * @param _setToken               The SetToken to be rebalanced.\n     * @param _raiseTargetPercentage  The percentage (in precise units) by which the target units can be increased.\n     */\n    function setRaiseTargetPercentage(\n        ISetToken _setToken,\n        uint256 _raiseTargetPercentage\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Ensure the raise target percentage is greater than 0\n        require(_raiseTargetPercentage > 0, \"Target percentage must be greater than 0\");\n\n        // Update the raise target percentage in the RebalanceInfo struct\n        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;\n\n        // Emit an event to log the updated raise target percentage\n        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);\n    }\n\n    /**\n     * @dev MANAGER ONLY: Toggles the permission status of specified addresses to call the `bid()` function.\n     * The manager can call this function at any time.\n     *\n     * @param _setToken  The SetToken being rebalanced.\n     * @param _bidders   An array of addresses whose bidding permission status is to be toggled.\n     * @param _statuses  An array of booleans indicating the new bidding permission status for each corresponding address in `_bidders`.\n     */\n    function setBidderStatus(\n        ISetToken _setToken,\n        address[] memory _bidders,\n        bool[] memory _statuses\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Validate that the input arrays have the same length\n        _bidders.validatePairsWithArray(_statuses);\n\n        // Iterate through the input arrays and update the permission status for each bidder\n        for (uint256 i = 0; i < _bidders.length; i++) {\n            _updateBiddersHistory(_setToken, _bidders[i], _statuses[i]);\n            permissionInfo[_setToken].bidAllowList[_bidders[i]] = _statuses[i];\n\n            // Emit an event to log the updated permission status\n            emit BidderStatusUpdated(_setToken, _bidders[i], _statuses[i]);\n        }\n    }\n\n    /**\n     * @dev MANAGER ONLY: Toggles whether or not anyone is allowed to call the `bid()` function.\n     * If set to true, it bypasses the bidAllowList, allowing any address to call the `bid()` function.\n     * The manager can call this function at any time.\n     *\n     * @param _setToken  The SetToken instance.\n     * @param _status    A boolean indicating if anyone can bid.\n     */\n    function setAnyoneBid(\n        ISetToken _setToken,\n        bool _status\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Update the anyoneBid status in the PermissionInfo struct\n        permissionInfo[_setToken].isAnyoneAllowedToBid = _status;\n\n        // Emit an event to log the updated anyoneBid status\n        emit AnyoneBidUpdated(_setToken, _status);\n    }\n\n\n    /**\n     * @dev MANAGER ONLY: Initializes the module for a SetToken, enabling access to AuctionModuleV1 for rebalances.\n     * Retrieves the current units for each asset in the Set and sets the targetUnit to match the current unit, effectively\n     * preventing any bidding until `startRebalance()` is explicitly called. The position multiplier is also logged to ensure that\n     * any changes to the position multiplier do not unintentionally open the Set for rebalancing.\n     *\n     * @param _setToken   Address of the Set Token\n     */\n    function initialize(ISetToken _setToken)\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        ISetToken.Position[] memory positions = _setToken.getPositions();\n\n        for (uint256 i = 0; i < positions.length; i++) {\n            ISetToken.Position memory position = positions[i];\n            require(position.positionState == 0, \"External positions not allowed\");\n            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();\n        }\n\n        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();\n        _setToken.initializeModule();\n    }\n\n\n    /**\n     * @dev Called by a SetToken to notify that this module was removed from the SetToken.\n     * Clears the `rebalanceInfo` and `permissionsInfo` of the calling SetToken.\n     * IMPORTANT: The auction execution settings of the SetToken, including auction parameters,\n     * are NOT DELETED. Restoring a previously removed module requires careful initialization of\n     * the execution settings.\n     */\n    function removeModule() external override {\n        BidPermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];\n\n        for (uint256 i = 0; i < tokenPermissionInfo.biddersHistory.length; i++) {\n            tokenPermissionInfo.bidAllowList[tokenPermissionInfo.biddersHistory[i]] = false;\n        }\n\n        delete rebalanceInfo[ISetToken(msg.sender)];\n        delete permissionInfo[ISetToken(msg.sender)];\n    }\n\n\n    /* ============ External View Functions ============ */\n\n    /**\n     * @dev Checks externally if the rebalance duration has elapsed for the given SetToken.\n     *\n     * @param _setToken The SetToken whose rebalance duration is being checked.\n     * @return bool True if the rebalance duration has elapsed; false otherwise.\n     */\n    function isRebalanceDurationElapsed(ISetToken _setToken) external view returns (bool) {\n        return _isRebalanceDurationElapsed(_setToken);\n    }\n\n    /**\n     * @dev Retrieves the array of components that are involved in the rebalancing of the given SetToken.\n     *\n     * @param _setToken    Instance of the SetToken.\n     *\n     * @return address[]   Array of component addresses involved in the rebalance.\n     */\n    function getRebalanceComponents(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return rebalanceInfo[_setToken].rebalanceComponents;\n    }\n\n    /**\n     * @dev Calculates the quantity of a component involved in the rebalancing of the given SetToken,\n     * and determines if the component is being bought or sold.\n     *\n     * @param _setToken    Instance of the SetToken being rebalanced.\n     * @param _component   Instance of the IERC20 component to bid on.\n     *\n     * @return isSellAuction       Indicates if this is a sell auction (true) or a buy auction (false).\n     * @return componentQuantity   Quantity of the component involved in the bid.\n     */\n    function getAuctionSizeAndDirection(\n        ISetToken _setToken,\n        IERC20 _component\n    )\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool isSellAuction, uint256 componentQuantity)\n    {\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            \"Component not part of rebalance\"\n        );\n        \n        uint256 totalSupply = _setToken.totalSupply();\n        return _calculateAuctionSizeAndDirection(_setToken, _component, totalSupply);\n    }\n\n    /**\n     * @dev Retrieves the balance of the quote asset for a given SetToken.\n     *\n     * @param _setToken The SetToken whose quote asset balance is being retrieved.\n     * @return uint256 The balance of the quote asset.\n     */\n    function getQuoteAssetBalance(ISetToken _setToken) external view returns (uint256) {\n        RebalanceInfo storage rebalance = rebalanceInfo[_setToken];\n        return IERC20(rebalance.quoteAsset).balanceOf(address(_setToken));\n    }\n\n    /**\n     * @dev Generates a preview of the bid for a given component in the rebalancing of the SetToken.\n     * It calculates the quantity of the component that will be exchanged and the direction of exchange.\n     *\n     * @param _setToken             Instance of the SetToken being rebalanced.\n     * @param _component            Instance of the component auction to bid on.\n     * @param _componentQuantity    Quantity of the component involved in the bid.\n     * @param _quoteQuantityLimit   Maximum or minimum amount of quote asset spent or received during the bid.\n     *\n     * @return BidInfo              Struct containing data for the bid.\n     */\n    function getBidPreview(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _componentQuantity,\n        uint256 _quoteQuantityLimit\n    )\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (BidInfo memory)\n    {\n        _validateBidTargets(_setToken, _component);\n        BidInfo memory bidInfo = _createBidInfo(_setToken, _component, _componentQuantity, _quoteQuantityLimit);\n        \n        return bidInfo;\n    }\n\n    /**\n     * @dev Checks externally if the conditions for early unlock are met.\n     *\n     * @param _setToken The SetToken being checked.\n     * @return bool True if early unlock conditions are met; false otherwise.\n     */\n    function canUnlockEarly(ISetToken _setToken) external view returns (bool) {\n        return _canUnlockEarly(_setToken);\n    }\n\n    /**\n     * @dev Checks externally if the conditions to raise asset targets are met.\n     *\n     * @param _setToken The SetToken being checked.\n     * @return bool True if conditions to raise asset targets are met; false otherwise.\n     */\n    function canRaiseAssetTargets(ISetToken _setToken) external view returns (bool) {\n        return _canRaiseAssetTargets(_setToken);\n    }\n\n    /**\n     * @dev Checks externally if all target units for components have been met.\n     *\n     * @param _setToken Instance of the SetToken to be rebalanced.\n     * @return bool True if all component's target units have been met; false otherwise.\n     */\n    function allTargetsMet(ISetToken _setToken) external view returns (bool) {\n        return _allTargetsMet(_setToken);\n    }\n\n    /**\n     * @dev Checks externally if the quote asset is in excess or at target.\n     *\n     * @param _setToken The SetToken being checked.\n     * @return bool True if the quote asset is in excess or at target; false otherwise.\n     */\n    function isQuoteAssetExcessOrAtTarget(ISetToken _setToken) external view returns (bool) {\n        return _isQuoteAssetExcessOrAtTarget(_setToken);\n    }\n\n    /**\n     * @dev Determines whether the given bidder address is allowed to participate in the auction.\n     *\n     * @param _setToken   Instance of the SetToken for which the bid is being placed.\n     * @param _bidder     Address of the bidder.\n     *\n     * @return bool       True if the given `_bidder` is permitted to bid, false otherwise.\n     */\n    function isAllowedBidder(ISetToken _setToken, address _bidder)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool)\n    {\n        return _isAllowedBidder(_setToken, _bidder);\n    }\n\n    /**\n     * @dev Retrieves the list of addresses that are permitted to participate in the auction by calling `bid()`.\n     *\n     * @param _setToken           Instance of the SetToken for which to retrieve the list of allowed bidders.\n     *\n     * @return address[]          Array of addresses representing the allowed bidders.\n     */\n    function getAllowedBidders(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return permissionInfo[_setToken].biddersHistory;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @dev Aggregates the current SetToken components with the new components and validates their auction parameters.\n     * Ensures that the sizes of the new components and new auction parameters arrays are the same, and that the number of current component auction parameters\n     * matches the number of current components. Additionally, it validates that the price adapter exists, the price adapter configuration data is valid for the adapter,\n     * and the target unit is greater than zero for new components. T"
    }
  ]
}