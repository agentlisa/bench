{
  "Title": "M-3: `escrowedReward` will be frozen in the contract if `escrowPool == address(0)` but `escrowPortion > 0`",
  "Content": "# Issue M-3: `escrowedReward` will be frozen in the contract if `escrowPool == address(0)` but `escrowPortion > 0` \n\nSource: https://github.com/sherlock-audit/2022-10-merit-circle-judging/issues/107 \n\n## Found by \nbin2chen, hickuphh3, saian, Jeiwan, WATCHPUG, ctf\\_sec, berndartmueller\n\n## Summary\n\nA portion of users' reward, which is expected to be \"escrowed\", will be frozen in the pool contract if `escrowPool == address(0)` but `escrowPortion > 0`.\n\n## Vulnerability Detail\n\nSetting `_escrowPool` to `address(0)` is allowed in `__BasePool_init()`:\n\nhttps://github.com/sherlock-audit/2022-10-merit-circle/blob/main/merit-liquidity-mining/contracts/base/BasePool.sol#L75-L77\n\nHowever, when `escrowPortion > 0`, if `escrowPool == address(0)`, `claimRewards()` will still only transferring `nonEscrowedRewardAmount` to the `_receiver` and left the `escrowedRewardAmount` in the contract.\n\n## Impact\n\nAs a result, a portion (`escrowPortion`) of the rewards will be frozen in the contract, and there is no way for the users or even the admin to retrieve these rewards.\n\n## Code Snippet\n\nhttps://github.com/Merit-Circle/merit-liquidity-mining/blob/ce5feaae19126079d309ac8dd9a81372648437f1/contracts/base/BasePool.sol#L100-L115\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange to:\n\n```solidity\nfunction claimRewards(address _receiver) external {\n    uint256 rewardAmount = _prepareCollect(_msgSender());\n    uint256 escrowedRewardAmount = 0;\n\n    if(escrowPortion != 0 && address(escrowPool) != address(0)) {\n        escrowedRewardAmount = rewardAmount * escrowPortion / 1e18;\n        if (escrowedRewardAmount != 0) {\n            escrowPool.deposit(escrowedRewardAmount, escrowDuration, _receiver);\n            rewardAmount -= escrowedRewardAmount;\n        }\n    }\n\n    // ignore dust\n    if(rewardAmount > 1) {\n        rewardToken.safeTransfer(_receiver, rewardAmount);\n    }\n\n    emit RewardsClaimed(_msgSender(), _receiver, escrowedRewardAmount, rewardAmount);\n}\n```\n\n## Discussion\n\n**federava**\n\nConditions stablished in this issue, that is, `escrowPool == address(0)` and `escrowPortion > 0` will never be met because pools are deployed with:\n\n`escrowPool  != address(0)` and `escrowPortion > 0`\nor\n`escrowPool  == address(0)` and `escrowPortion > 0`\n\nAs a priority we could check on deployment that such conditions are not met.\n\n**federava**\n\n[PR](https://github.com/Merit-Circle/merit-liquidity-mining/pull/15) from this issue\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/9",
  "Code": [
    {
      "filename": "merit-liquidity-mining/contracts/base/BasePool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport { IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { SafeERC20Upgradeable as SafeERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { ERC20VotesUpgradeable as ERC20Votes } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport { SafeCastUpgradeable as SafeCast } from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport { AccessControlEnumerableUpgradeable as AccessControlEnumerable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/IBasePool.sol\";\nimport \"../interfaces/ITimeLockPool.sol\";\n\nimport \"./AbstractRewards.sol\";\nimport \"./BoringBatchable.sol\";\n\nabstract contract BasePool is Initializable, AccessControlEnumerable, ERC20Votes, AbstractRewards, IBasePool, BaseBoringBatchable {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    error MoreThanOneError();\n    error NoDepositTokenError();\n    error NotGovError();\n\n    IERC20 public depositToken;\n    IERC20 public rewardToken;\n    ITimeLockPool public escrowPool;\n    uint256 public escrowPortion; // how much is escrowed 1e18 == 100%\n    uint256 public escrowDuration; // escrow duration in seconds\n\n    bytes32 public constant GOV_ROLE = keccak256(\"GOV_ROLE\");\n\n    event RewardsClaimed(address indexed _from, address indexed _receiver, uint256 _escrowedAmount, uint256 _nonEscrowedAmount);\n\n    // Saves space calling _onlyGov instead having the code\n    modifier onlyGov() {\n        _onlyGov();\n        _;\n    }\n    \n    function _onlyGov() private view {\n        if (!hasRole(GOV_ROLE, _msgSender())) {\n            revert NotGovError();\n        }\n    }\n\n    function __BasePool_init(\n        string memory _name,\n        string memory _symbol,\n        address _depositToken,\n        address _rewardToken,\n        address _escrowPool,\n        uint256 _escrowPortion,\n        uint256 _escrowDuration\n    ) internal onlyInitializing {\n        __ERC20Permit_init(_name); // only initializes ERC712Permit\n        __ERC20_init(_name, _symbol); // unchained or not it only saves the variables\n        __AbstractRewards_init(balanceOf, totalSupply);\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        __AccessControlEnumerable_init();\n\n        if (_escrowPortion > 1e18) {\n            revert MoreThanOneError();\n        }\n        if (_depositToken == address(0)) {\n            revert NoDepositTokenError();\n        }\n        depositToken = IERC20(_depositToken);\n        rewardToken = IERC20(_rewardToken);\n        escrowPool = ITimeLockPool(_escrowPool);\n        escrowPortion = _escrowPortion;\n        escrowDuration = _escrowDuration;\n\n        if(_rewardToken != address(0) && _escrowPool != address(0)) {\n            IERC20(_rewardToken).safeApprove(_escrowPool, type(uint256).max);\n        }\n    }\n\n    function _mint(address _account, uint256 _amount) internal virtual override {\n\t\tsuper._mint(_account, _amount);\n        _correctPoints(_account, -(_amount.toInt256()));\n\t}\n\t\n\tfunction _burn(address _account, uint256 _amount) internal virtual override {\n\t\tsuper._burn(_account, _amount);\n        _correctPoints(_account, _amount.toInt256());\n\t}\n\n    function _transfer(address _from, address _to, uint256 _value) internal virtual override {\n\t\tsuper._transfer(_from, _to, _value);\n        _correctPointsForTransfer(_from, _to, _value);\n\t}\n\n    function distributeRewards(uint256 _amount) external override {\n        rewardToken.safeTransferFrom(_msgSender(), address(this), _amount);\n        _distributeRewards(_amount);\n    }\n\n    function claimRewards(address _receiver) external {\n        uint256 rewardAmount = _prepareCollect(_msgSender());\n        uint256 escrowedRewardAmount = rewardAmount * escrowPortion / 1e18;\n        uint256 nonEscrowedRewardAmount = rewardAmount - escrowedRewardAmount;\n\n        if(escrowedRewardAmount != 0 && address(escrowPool) != address(0)) {\n            escrowPool.deposit(escrowedRewardAmount, escrowDuration, _receiver);\n        }\n\n        // ignore dust\n        if(nonEscrowedRewardAmount > 1) {\n            rewardToken.safeTransfer(_receiver, nonEscrowedRewardAmount);\n        }\n\n        emit RewardsClaimed(_msgSender(), _receiver, escrowedRewardAmount, nonEscrowedRewardAmount);\n    }\n\n}"
    },
    {
      "filename": "contracts/base/BasePool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport { IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { SafeERC20Upgradeable as SafeERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { ERC20VotesUpgradeable as ERC20Votes } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport { SafeCastUpgradeable as SafeCast } from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport { AccessControlEnumerableUpgradeable as AccessControlEnumerable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/IBasePool.sol\";\nimport \"../interfaces/ITimeLockPool.sol\";\n\nimport \"./AbstractRewards.sol\";\nimport \"./BoringBatchable.sol\";\n\nabstract contract BasePool is Initializable, AccessControlEnumerable, ERC20Votes, AbstractRewards, IBasePool, BaseBoringBatchable {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    error MoreThanOneError();\n    error NoDepositTokenError();\n    error NotGovError();\n\n    IERC20 public depositToken;\n    IERC20 public rewardToken;\n    ITimeLockPool public escrowPool;\n    uint256 public escrowPortion; // how much is escrowed 1e18 == 100%\n    uint256 public escrowDuration; // escrow duration in seconds\n\n    bytes32 public constant GOV_ROLE = keccak256(\"GOV_ROLE\");\n\n    event RewardsClaimed(address indexed _from, address indexed _receiver, uint256 _escrowedAmount, uint256 _nonEscrowedAmount);\n\n    // Saves space calling _onlyGov instead having the code\n    modifier onlyGov() {\n        _onlyGov();\n        _;\n    }\n    \n    function _onlyGov() private view {\n        if (!hasRole(GOV_ROLE, _msgSender())) {\n            revert NotGovError();\n        }\n    }\n\n    function __BasePool_init(\n        string memory _name,\n        string memory _symbol,\n        address _depositToken,\n        address _rewardToken,\n        address _escrowPool,\n        uint256 _escrowPortion,\n        uint256 _escrowDuration\n    ) internal onlyInitializing {\n        __ERC20Permit_init(_name); // only initializes ERC712Permit\n        __ERC20_init(_name, _symbol); // unchained or not it only saves the variables\n        __AbstractRewards_init(balanceOf, totalSupply);\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        __AccessControlEnumerable_init();\n\n        if (_escrowPortion > 1e18) {\n            revert MoreThanOneError();\n        }\n        if (_depositToken == address(0)) {\n            revert NoDepositTokenError();\n        }\n        depositToken = IERC20(_depositToken);\n        rewardToken = IERC20(_rewardToken);\n        escrowPool = ITimeLockPool(_escrowPool);\n        escrowPortion = _escrowPortion;\n        escrowDuration = _escrowDuration;\n\n        if(_rewardToken != address(0) && _escrowPool != address(0)) {\n            IERC20(_rewardToken).safeApprove(_escrowPool, type(uint256).max);\n        }\n    }\n\n    function _mint(address _account, uint256 _amount) internal virtual override {\n\t\tsuper._mint(_account, _amount);\n        _correctPoints(_account, -(_amount.toInt256()));\n\t}\n\t\n\tfunction _burn(address _account, uint256 _amount) internal virtual override {\n\t\tsuper._burn(_account, _amount);\n        _correctPoints(_account, _amount.toInt256());\n\t}\n\n    function _transfer(address _from, address _to, uint256 _value) internal virtual override {\n\t\tsuper._transfer(_from, _to, _value);\n        _correctPointsForTransfer(_from, _to, _value);\n\t}\n\n    function distributeRewards(uint256 _amount) external override {\n        rewardToken.safeTransferFrom(_msgSender(), address(this), _amount);\n        _distributeRewards(_amount);\n    }\n\n    function claimRewards(address _receiver) external {\n        uint256 rewardAmount = _prepareCollect(_msgSender());\n        uint256 escrowedRewardAmount = rewardAmount * escrowPortion / 1e18;\n        uint256 nonEscrowedRewardAmount = rewardAmount - escrowedRewardAmount;\n\n        if(escrowedRewardAmount != 0 && address(escrowPool) != address(0)) {\n            escrowPool.deposit(escrowedRewardAmount, escrowDuration, _receiver);\n        }\n\n        // ignore dust\n        if(nonEscrowedRewardAmount > 1) {\n            rewardToken.safeTransfer(_receiver, nonEscrowedRewardAmount);\n        }\n\n        emit RewardsClaimed(_msgSender(), _receiver, escrowedRewardAmount, nonEscrowedRewardAmount);\n    }\n\n}"
    }
  ]
}