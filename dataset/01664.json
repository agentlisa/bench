{
  "Title": "Lack of event emission",
  "Content": "The internal [`_sync`](https://github.com/UMAprotocol/protocol/blob/3687d9b3a80ca9b3694211d50a2ccad5415c77e1/packages/core/contracts/gnosis-zodiac/implementation/OptimisticGovernor.sol#L419) function changes the `OptimisticOracleV3` contract used by the `OptimisticGovernor`, but unlike other administrative setter functions, it does not emit an event when a change occurs.\n\n\nConsider adding a new `OptimisticOracleChanged` event that is emitted by `_sync` whenever the [finder contract returns](https://github.com/UMAprotocol/protocol/blob/3687d9b3a80ca9b3694211d50a2ccad5415c77e1/packages/core/contracts/gnosis-zodiac/implementation/OptimisticGovernor.sol#L421) a different address than that of the current `optimisticOracleV3` variable.\n\n\n***Update:** Resolved in [pull request #4487](https://github.com/UMAprotocol/protocol/pull/4487) at commit [f3ea7a6](https://github.com/UMAprotocol/protocol/commit/f3ea7a6c04bd5da53ca9a225fc7682c17f465b93).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/gnosis-zodiac/implementation/OptimisticGovernor.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.6;\n\n// https://github.com/gnosis/zodiac/blob/master/contracts/core/Module.sol\nimport \"@gnosis.pm/zodiac/contracts/core/Module.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\n\nimport \"../../optimistic-oracle-v3/implementation/ClaimData.sol\";\nimport \"../../optimistic-oracle-v3/interfaces/OptimisticOracleV3Interface.sol\";\nimport \"../../optimistic-oracle-v3/interfaces/OptimisticOracleV3CallbackRecipientInterface.sol\";\n\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/interfaces/AddressWhitelistInterface.sol\";\n\n/**\n * @title Optimistic Governor\n * @notice A contract that allows optimistic governance of a set of transactions. The contract can be used to propose\n * transactions that can be challenged by anyone. If the challenge is not resolved within a certain liveness period, the\n * transactions can be executed.\n */\ncontract OptimisticGovernor is OptimisticOracleV3CallbackRecipientInterface, Module, Lockable {\n    using SafeERC20 for IERC20;\n\n    event OptimisticGovernorDeployed(address indexed owner, address indexed avatar, address target);\n\n    event TransactionsProposed(\n        address indexed proposer,\n        uint256 indexed proposalTime,\n        bytes32 indexed assertionId,\n        Proposal proposal,\n        bytes32 proposalHash,\n        bytes explanation,\n        string rules,\n        uint256 challengeWindowEnds\n    );\n\n    event TransactionExecuted(\n        bytes32 indexed proposalHash,\n        bytes32 indexed assertionId,\n        uint256 indexed transactionIndex\n    );\n\n    event ProposalExecuted(bytes32 indexed proposalHash, bytes32 indexed assertionId);\n\n    event ProposalDeleted(bytes32 indexed proposalHash, bytes32 indexed assertionId);\n\n    event SetBond(IERC20 indexed collateral, uint256 indexed bondAmount);\n\n    event SetCollateral(IERC20 indexed collateral);\n\n    event SetRules(string rules);\n\n    event SetLiveness(uint64 indexed liveness);\n\n    event SetIdentifier(bytes32 indexed identifier);\n\n    event SetEscalationManager(address indexed escalationManager);\n\n    FinderInterface public immutable finder; // Finder used to discover other UMA ecosystem contracts.\n\n    IERC20 public collateral; // Collateral currency used to assert proposed transactions.\n    uint64 public liveness; // The amount of time to dispute proposed transactions before they can be executed.\n    uint256 public bondAmount; // Configured amount of collateral currency to make assertions for proposed transactions.\n    string public rules; // Rules for the Optimistic Governor.\n    bytes32 public identifier; // Identifier used to request price from the DVM, compatible with Optimistic Oracle V3.\n    OptimisticOracleV3Interface public optimisticOracleV3; // Optimistic Oracle V3 contract used to assert proposed transactions.\n    address public escalationManager; // Optional Escalation Manager contract to whitelist proposers / disputers.\n\n    // Keys for assertion claim data.\n    bytes public constant PROPOSAL_HASH_KEY = \"proposalHash\";\n    bytes public constant EXPLANATION_KEY = \"explanation\";\n    bytes public constant RULES_KEY = \"rules\";\n\n    // Struct for a proposed transaction.\n    struct Transaction {\n        address to; // The address to which the transaction is being sent.\n        Enum.Operation operation; // Operation type of transaction: 0 == call, 1 == delegate call.\n        uint256 value; // The value, in wei, to be sent with the transaction.\n        bytes data; // The data payload to be sent in the transaction.\n    }\n\n    // Struct for a proposed set of transactions, used only for off-chain infrastructure.\n    struct Proposal {\n        Transaction[] transactions;\n        uint256 requestTime;\n    }\n\n    mapping(bytes32 => bytes32) public proposalHashes; // Maps proposal hashes to assertionIds.\n    mapping(bytes32 => bytes32) public assertionIds; // Maps assertionIds to proposal hashes.\n\n    /**\n     * @notice Construct Optimistic Governor module.\n     * @param _finder Finder address.\n     * @param _owner Address of the owner.\n     * @param _collateral Address of the ERC20 collateral used for bonds.\n     * @param _bondAmount Amount of collateral currency to make assertions for proposed transactions\n     * @param _rules Reference to the rules for the Optimistic Governor.\n     * @param _identifier The approved identifier to be used with the contract, compatible with Optimistic Oracle V3.\n     * @param _liveness The period, in seconds, in which a proposal can be disputed.\n     */\n    constructor(\n        address _finder,\n        address _owner,\n        address _collateral,\n        uint256 _bondAmount,\n        string memory _rules,\n        bytes32 _identifier,\n        uint64 _liveness\n    ) {\n        bytes memory initializeParams = abi.encode(_owner, _collateral, _bondAmount, _rules, _identifier, _liveness);\n        require(_finder != address(0), \"Finder address can not be empty\");\n        finder = FinderInterface(_finder);\n        setUp(initializeParams);\n    }\n\n    /**\n     * @notice Sets up the Optimistic Governor module.\n     * @param initializeParams ABI encoded parameters to initialize the module with.\n     * @dev This method can be called only either by the constructor or as part of first time initialization when\n     * cloning the module.\n     */\n    function setUp(bytes memory initializeParams) public override initializer {\n        _startReentrantGuardDisabled();\n        __Ownable_init();\n        (\n            address _owner,\n            address _collateral,\n            uint256 _bondAmount,\n            string memory _rules,\n            bytes32 _identifier,\n            uint64 _liveness\n        ) = abi.decode(initializeParams, (address, address, uint256, string, bytes32, uint64));\n        setCollateralAndBond(IERC20(_collateral), _bondAmount);\n        setRules(_rules);\n        setIdentifier(_identifier);\n        setLiveness(_liveness);\n        setAvatar(_owner);\n        setTarget(_owner);\n        transferOwnership(_owner);\n        _sync();\n\n        emit OptimisticGovernorDeployed(_owner, avatar, target);\n    }\n\n    /**\n     * @notice Sets the collateral and bond amount for proposals.\n     * @param _collateral token that will be used for all bonds for the contract.\n     * @param _bondAmount amount of the bond token that will need to be paid for future proposals.\n     */\n    function setCollateralAndBond(IERC20 _collateral, uint256 _bondAmount) public onlyOwner {\n        // ERC20 token to be used as collateral (must be approved by UMA governance).\n        require(_getCollateralWhitelist().isOnWhitelist(address(_collateral)), \"Bond token not supported\");\n        collateral = _collateral;\n\n        // Value of the bond posted for asserting the proposed transactions. If the minimum amount required by\n        // Optimistic Oracle V3 is higher this contract will attempt to pull the required bond amount.\n        bondAmount = _bondAmount;\n        emit SetBond(_collateral, _bondAmount);\n    }\n\n    /**\n     * @notice Sets the rules that will be used to evaluate future proposals.\n     * @param _rules string that outlines or references the location where the rules can be found.\n     */\n    function setRules(string memory _rules) public onlyOwner {\n        // Set reference to the rules for the Optimistic Governor\n        require(bytes(_rules).length > 0, \"Rules can not be empty\");\n        rules = _rules;\n        emit SetRules(_rules);\n    }\n\n    /**\n     * @notice Sets the liveness for future proposals. This is the amount of delay before a proposal is approved by\n     * default.\n     * @param _liveness liveness to set in seconds.\n     */\n    function setLiveness(uint64 _liveness) public onlyOwner {\n        // Set liveness for disputing proposed transactions.\n        require(_liveness > 0, \"Liveness can't be 0\");\n        require(_liveness < 5200 weeks, \"Liveness must be less than 5200 weeks\");\n        liveness = _liveness;\n        emit SetLiveness(_liveness);\n    }\n\n    /**\n     * @notice Sets the identifier for future proposals.\n     * @param _identifier identifier to set.\n     */\n    function setIdentifier(bytes32 _identifier) public onlyOwner {\n        // Set identifier which is used along with the rules to determine if transactions are valid.\n        require(_getIdentifierWhitelist().isIdentifierSupported(_identifier), \"Identifier not supported\");\n        identifier = _identifier;\n        emit SetIdentifier(_identifier);\n    }\n\n    /**\n     * @notice Sets the Escalation Manager for future proposals.\n     * @param _escalationManager address of the Escalation Manager, can be zero to disable this functionality.\n     * @dev Only the owner can call this method. The provided address must conform to the Escalation Manager interface.\n     * FullPolicyEscalationManager can be used, but within the context of this contract it should be used only for\n     * whitelisting of proposers and disputers since Optimistic Governor is deleting disputed proposals.\n     */\n    function setEscalationManager(address _escalationManager) external onlyOwner {\n        escalationManager = _escalationManager;\n        emit SetEscalationManager(_escalationManager);\n    }\n\n    /**\n     * @notice This caches the most up-to-date Optimistic Oracle V3.\n     * @dev If a new Optimistic Oracle V3 is added and this is run between a proposal's introduction and execution, the\n     * proposal will become unexecutable.\n     */\n    function sync() external nonReentrant {\n        _sync();\n    }\n\n    /**\n     * @notice Makes a new proposal for transactions to be executed with an explanation argument.\n     * @param _transactions the transactions being proposed.\n     * @param _explanation Auxillary information that can be referenced to validate the proposal.\n     * @dev Proposer must grant the contract collateral allowance at least to the bondAmount or result of getMinimumBond\n     * from the Optimistic Oracle V3, whichever is greater.\n     */\n    function proposeTransactions(Transaction[] memory _transactions, bytes memory _explanation) external nonReentrant {\n        // note: Optional explanation explains the intent of the transactions to make comprehension easier.\n        uint256 time = getCurrentTime();\n        address proposer = msg.sender;\n\n        // Create proposal in memory to emit in an event.\n        Proposal memory proposal;\n        proposal.requestTime = time;\n\n        // Add transactions to proposal in memory.\n        for (uint256 i = 0; i < _transactions.length; i++) {\n            require(_transactions[i].to != address(0), \"The `to` address cannot be 0x0\");\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\n            if (_transactions[i].data.length > 0) {\n                require(_isContract(_transactions[i].to), \"EOA can't accept tx with data\");\n            }\n        }\n        proposal.transactions = _transactions;\n\n        // Create the proposal hash.\n        bytes32 proposalHash = keccak256(abi.encode(_transactions));\n\n        // Add the proposal hash, explanation and rules to ancillary data.\n        bytes memory claim = _constructClaim(proposalHash, _explanation);\n\n        // Check that the proposal is not already mapped to an assertionId, i.e., is not a duplicate.\n        require(proposalHashes[proposalHash] == bytes32(0), \"Duplicate proposals not allowed\");\n\n        // Get the bond from the proposer and approve the required bond to be used by the Optimistic Oracle V3.\n        // This will fail if the proposer has not granted the Optimistic Governor contract an allowance\n        // of the collateral token equal to or greater than the totalBond.\n        uint256 totalBond = getProposalBond();\n        collateral.safeTransferFrom(msg.sender, address(this), totalBond);\n        collateral.safeIncreaseAllowance(address(optimisticOracleV3), totalBond);\n\n        // Assert that the proposal is correct at the Optimistic Oracle V3.\n        bytes32 assertionId =\n            optimisticOracleV3.assertTruth(\n                claim, // claim containing proposalHash, explanation and rules.\n                proposer, // asserter will receive back bond if the assertion is correct.\n                address(this), // callbackRecipient is set to this contract for automated proposal deletion on disputes.\n                escalationManager, // escalationManager (if set) used for whitelisting proposers / disputers.\n                liveness, // liveness in seconds.\n                collateral, // currency in which the bond is denominated.\n                totalBond, // bond amount used to assert proposal.\n                identifier, // identifier used to determine if the claim is correct at DVM.\n                bytes32(0) // domainId is not set.\n            );\n\n        // Maps the proposal hash to the returned assertionId and vice versa.\n        proposalHashes[proposalHash] = assertionId;\n        assertionIds[assertionId] = proposalHash;\n\n        emit TransactionsProposed(\n            proposer,\n            time,\n            assertionId,\n            proposal,\n            proposalHash,\n            _explanation,\n            rules,\n            time + liveness\n        );\n    }\n\n    /**\n     * @notice Executes an approved proposal.\n     * @param _transactions the transactions being executed. These must exactly match those that were proposed.\n     */\n    function executeProposal(Transaction[] memory _transactions) external payable nonReentrant {\n        // Recreate the proposal hash from the inputs and check that it matches the stored proposal hash.\n        bytes32 _proposalHash = keccak256(abi.encode(_transactions));\n\n        // This will reject the transaction if the proposal hash generated from the inputs does not match the stored\n        // proposal hash. This is possible when a) the transactions have not been proposed, b) transactions have already\n        // been executed, c) the proposal was disputed or d) the proposal was deleted after Optimistic Oracle V3 upgrade.\n        require(proposalHashes[_proposalHash] != bytes32(0), \"Proposal hash does not exist\");\n\n        // Get the original proposal assertionId.\n        bytes32 assertionId = proposalHashes[_proposalHash];\n\n        // Remove proposal hash and assertionId so transactions can not be executed again.\n        delete proposalHashes[_proposalHash];\n        delete assertionIds[assertionId];\n\n        // There is no need to check the assertion result as this point can be reached only for non-disputed assertions.\n        // This will revert if the assertion has not been settled and can not currently be settled.\n        optimisticOracleV3.settleAndGetAssertionResult(assertionId);\n\n        // Execute the transactions.\n        for (uint256 i = 0; i < _transactions.length; i++) {\n            Transaction memory transaction = _transactions[i];\n\n            require(\n                exec(transaction.to, transaction.value, transaction.data, transaction.operation),\n                \"Failed to execute transaction\"\n            );\n            emit TransactionExecuted(_proposalHash, assertionId, i);\n        }\n\n        emit ProposalExecuted(_proposalHash, assertionId);\n    }\n\n    /**\n     * @notice Function to delete a proposal on an Optimistic Oracle V3 upgrade.\n     * @param _proposalHash the hash of the proposal to delete.\n     * @dev In case of an Optimistic Oracle V3 upgrade, the proposal execution would be blocked as its related\n     * assertionId would not be recognized by the new Optimistic Oracle V3. This function allows the proposal to be\n     * deleted if detecting an Optimistic Oracle V3 upgrade so that transactions can be re-proposed if needed.\n     */\n    function deleteProposalOnUpgrade(bytes32 _proposalHash) public nonReentrant {\n        require(_proposalHash != bytes32(0), \"Invalid proposal hash\");\n        bytes32 assertionId = proposalHashes[_proposalHash];\n        require(assertionId != bytes32(0), \"Proposal hash does not exist\");\n\n        // Detect Optimistic Oracle V3 upgrade by checking if it has the matching assertionId.\n        require(optimisticOracleV3.getAssertion(assertionId).asserter == address(0), \"OOv3 upgrade not detected\");\n\n        // Remove proposal hash and assertionId so that transactions can be re-proposed if needed.\n        delete proposalHashes[_proposalHash];\n        delete assertionIds[assertionId];\n\n        emit ProposalDeleted(_proposalHash, assertionId);\n    }\n\n    /**\n     * @notice Callback to automatically delete a proposal that was disputed.\n     * @param assertionId the identifier of the disputed assertion.\n     */\n    function assertionDisputedCallback(bytes32 assertionId) external {\n        // In order to optimize for happy path, the assertionId is validated for potential spoofing only in the\n        // deleteProposalOnUpgrade call. Genuine Optimistic Oracle V3 should always pass a valid assertionId that has a\n        // matching proposalHash in this contract.\n        bytes32 proposalHash = assertionIds[assertionId];\n\n        // Callback should only be called by the Optimistic Oracle V3. Address would not match in case of contract\n        // upgrade, thus try deleting the proposal through deleteProposalOnUpgrade function that should revert if\n        // address mismatch was not caused by an Optimistic Oracle V3 upgrade.\n        if (msg.sender == address(optimisticOracleV3)) {\n            // Delete the disputed proposal and associated assertionId.\n            delete proposalHashes[proposalHash];\n            delete assertionIds[assertionId];\n\n            emit ProposalDeleted(proposalHash, assertionId);\n        } else deleteProposalOnUpgrade(proposalHash);\n    }\n\n    /**\n     * @notice Callback function that is called by Optimistic Oracle V3 when an assertion is resolved.\n     * @dev This function does nothing and is only here to satisfy the callback recipient interface.\n     * @param assertionId The identifier of the assertion that was resolved.\n     * @param assertedTruthfully Whether the assertion was resolved as truthful or not.\n     */\n    function assertionResolvedCallback(bytes32 assertionId, bool assertedTruthfully) external {}\n\n    /**\n     * @notice Gets the current time for this contract.\n     * @dev This only exists so it can be overridden for testing.\n     */\n    function getCurrentTime() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /**\n     * @notice Getter function to check required collateral currency approval.\n     * @return The amount of bond required to propose a transaction.\n     */\n    function getProposalBond() public view returns (uint256) {\n        uint256 minimumBond = optimisticOracleV3.getMinimumBond(address(collateral));\n        return minimumBond > bondAmount ? minimumBond : bondAmount;\n    }\n\n    // Gets the address of Collateral Whitelist from the Finder.\n    function _getCollateralWhitelist() internal view returns (AddressWhitelistInterface) {\n        return AddressWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\n    }\n\n    // Gets the address of Identifier Whitelist from the Finder.\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\n    }\n\n    // Gets the address of Store contract from the Finder.\n    function _getStore() internal view returns (StoreInterface) {\n        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\n    }\n\n    // Caches the address of the Optimistic Oracle V3 from the Finder.\n    function _sync() internal {\n        optimisticOracleV3 = OptimisticOracleV3Interface(\n            finder.getImplementationAddress(OracleInterfaces.OptimisticOracleV3)\n        );\n    }\n\n    // Checks if the address is a contract.\n    function _isContract(address addr) internal view returns (bool) {\n        return addr.code.length > 0;\n    }\n\n    // Constructs the claim that will be asserted at the Optimistic Oracle V3.\n    function _constructClaim(bytes32 _proposalHash, bytes memory _explanation) internal view returns (bytes memory) {\n        return\n            abi.encodePacked(\n                ClaimData.appendKeyValueBytes32(\"\", PROPOSAL_HASH_KEY, _proposalHash),\n                \",\",\n                EXPLANATION_KEY,\n                ':\"',\n                _explanation,\n                '\",',\n                RULES_KEY,\n                ':\"',\n                rules,\n                '\"'\n            );\n    }\n}"
    },
    {
      "filename": "packages/core/contracts/gnosis-zodiac/implementation/OptimisticGovernor.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.6;\n\n// https://github.com/gnosis/zodiac/blob/master/contracts/core/Module.sol\nimport \"@gnosis.pm/zodiac/contracts/core/Module.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../data-verification-mechanism/implementation/Constants.sol\";\nimport \"../../data-verification-mechanism/interfaces/FinderInterface.sol\";\nimport \"../../data-verification-mechanism/interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../../data-verification-mechanism/interfaces/StoreInterface.sol\";\n\nimport \"../../optimistic-oracle-v3/implementation/ClaimData.sol\";\nimport \"../../optimistic-oracle-v3/interfaces/OptimisticOracleV3Interface.sol\";\nimport \"../../optimistic-oracle-v3/interfaces/OptimisticOracleV3CallbackRecipientInterface.sol\";\n\nimport \"../../common/implementation/Lockable.sol\";\nimport \"../../common/interfaces/AddressWhitelistInterface.sol\";\n\n/**\n * @title Optimistic Governor\n * @notice A contract that allows optimistic governance of a set of transactions. The contract can be used to propose\n * transactions that can be challenged by anyone. If the challenge is not resolved within a certain liveness period, the\n * transactions can be executed.\n */\ncontract OptimisticGovernor is OptimisticOracleV3CallbackRecipientInterface, Module, Lockable {\n    using SafeERC20 for IERC20;\n\n    event OptimisticGovernorDeployed(address indexed owner, address indexed avatar, address target);\n\n    event TransactionsProposed(\n        address indexed proposer,\n        uint256 indexed proposalTime,\n        bytes32 indexed assertionId,\n        Proposal proposal,\n        bytes32 proposalHash,\n        bytes explanation,\n        string rules,\n        uint256 challengeWindowEnds\n    );\n\n    event TransactionExecuted(\n        bytes32 indexed proposalHash,\n        bytes32 indexed assertionId,\n        uint256 indexed transactionIndex\n    );\n\n    event ProposalExecuted(bytes32 indexed proposalHash, bytes32 indexed assertionId);\n\n    event ProposalDeleted(bytes32 indexed proposalHash, bytes32 indexed assertionId);\n\n    event SetBond(IERC20 indexed collateral, uint256 indexed bondAmount);\n\n    event SetCollateral(IERC20 indexed collateral);\n\n    event SetRules(string rules);\n\n    event SetLiveness(uint64 indexed liveness);\n\n    event SetIdentifier(bytes32 indexed identifier);\n\n    event SetEscalationManager(address indexed escalationManager);\n\n    FinderInterface public immutable finder; // Finder used to discover other UMA ecosystem contracts.\n\n    IERC20 public collateral; // Collateral currency used to assert proposed transactions.\n    uint64 public liveness; // The amount of time to dispute proposed transactions before they can be executed.\n    uint256 public bondAmount; // Configured amount of collateral currency to make assertions for proposed transactions.\n    string public rules; // Rules for the Optimistic Governor.\n    bytes32 public identifier; // Identifier used to request price from the DVM, compatible with Optimistic Oracle V3.\n    OptimisticOracleV3Interface public optimisticOracleV3; // Optimistic Oracle V3 contract used to assert proposed transactions.\n    address public escalationManager; // Optional Escalation Manager contract to whitelist proposers / disputers.\n\n    // Keys for assertion claim data.\n    bytes public constant PROPOSAL_HASH_KEY = \"proposalHash\";\n    bytes public constant EXPLANATION_KEY = \"explanation\";\n    bytes public constant RULES_KEY = \"rules\";\n\n    // Struct for a proposed transaction.\n    struct Transaction {\n        address to; // The address to which the transaction is being sent.\n        Enum.Operation operation; // Operation type of transaction: 0 == call, 1 == delegate call.\n        uint256 value; // The value, in wei, to be sent with the transaction.\n        bytes data; // The data payload to be sent in the transaction.\n    }\n\n    // Struct for a proposed set of transactions, used only for off-chain infrastructure.\n    struct Proposal {\n        Transaction[] transactions;\n        uint256 requestTime;\n    }\n\n    mapping(bytes32 => bytes32) public proposalHashes; // Maps proposal hashes to assertionIds.\n    mapping(bytes32 => bytes32) public assertionIds; // Maps assertionIds to proposal hashes.\n\n    /**\n     * @notice Construct Optimistic Governor module.\n     * @param _finder Finder address.\n     * @param _owner Address of the owner.\n     * @param _collateral Address of the ERC20 collateral used for bonds.\n     * @param _bondAmount Amount of collateral currency to make assertions for proposed transactions\n     * @param _rules Reference to the rules for the Optimistic Governor.\n     * @param _identifier The approved identifier to be used with the contract, compatible with Optimistic Oracle V3.\n     * @param _liveness The period, in seconds, in which a proposal can be disputed.\n     */\n    constructor(\n        address _finder,\n        address _owner,\n        address _collateral,\n        uint256 _bondAmount,\n        string memory _rules,\n        bytes32 _identifier,\n        uint64 _liveness\n    ) {\n        bytes memory initializeParams = abi.encode(_owner, _collateral, _bondAmount, _rules, _identifier, _liveness);\n        require(_finder != address(0), \"Finder address can not be empty\");\n        finder = FinderInterface(_finder);\n        setUp(initializeParams);\n    }\n\n    /**\n     * @notice Sets up the Optimistic Governor module.\n     * @param initializeParams ABI encoded parameters to initialize the module with.\n     * @dev This method can be called only either by the constructor or as part of first time initialization when\n     * cloning the module.\n     */\n    function setUp(bytes memory initializeParams) public override initializer {\n        _startReentrantGuardDisabled();\n        __Ownable_init();\n        (\n            address _owner,\n            address _collateral,\n            uint256 _bondAmount,\n            string memory _rules,\n            bytes32 _identifier,\n            uint64 _liveness\n        ) = abi.decode(initializeParams, (address, address, uint256, string, bytes32, uint64));\n        setCollateralAndBond(IERC20(_collateral), _bondAmount);\n        setRules(_rules);\n        setIdentifier(_identifier);\n        setLiveness(_liveness);\n        setAvatar(_owner);\n        setTarget(_owner);\n        transferOwnership(_owner);\n        _sync();\n\n        emit OptimisticGovernorDeployed(_owner, avatar, target);\n    }\n\n    /**\n     * @notice Sets the collateral and bond amount for proposals.\n     * @param _collateral token that will be used for all bonds for the contract.\n     * @param _bondAmount amount of the bond token that will need to be paid for future proposals.\n     */\n    function setCollateralAndBond(IERC20 _collateral, uint256 _bondAmount) public onlyOwner {\n        // ERC20 token to be used as collateral (must be approved by UMA governance).\n        require(_getCollateralWhitelist().isOnWhitelist(address(_collateral)), \"Bond token not supported\");\n        collateral = _collateral;\n\n        // Value of the bond posted for asserting the proposed transactions. If the minimum amount required by\n        // Optimistic Oracle V3 is higher this contract will attempt to pull the required bond amount.\n        bondAmount = _bondAmount;\n        emit SetBond(_collateral, _bondAmount);\n    }\n\n    /**\n     * @notice Sets the rules that will be used to evaluate future proposals.\n     * @param _rules string that outlines or references the location where the rules can be found.\n     */\n    function setRules(string memory _rules) public onlyOwner {\n        // Set reference to the rules for the Optimistic Governor\n        require(bytes(_rules).length > 0, \"Rules can not be empty\");\n        rules = _rules;\n        emit SetRules(_rules);\n    }\n\n    /**\n     * @notice Sets the liveness for future proposals. This is the amount of delay before a proposal is approved by\n     * default.\n     * @param _liveness liveness to set in seconds.\n     */\n    function setLiveness(uint64 _liveness) public onlyOwner {\n        // Set liveness for disputing proposed transactions.\n        require(_liveness > 0, \"Liveness can't be 0\");\n        require(_liveness < 5200 weeks, \"Liveness must be less than 5200 weeks\");\n        liveness = _liveness;\n        emit SetLiveness(_liveness);\n    }\n\n    /**\n     * @notice Sets the identifier for future proposals.\n     * @param _identifier identifier to set.\n     */\n    function setIdentifier(bytes32 _identifier) public onlyOwner {\n        // Set identifier which is used along with the rules to determine if transactions are valid.\n        require(_getIdentifierWhitelist().isIdentifierSupported(_identifier), \"Identifier not supported\");\n        identifier = _identifier;\n        emit SetIdentifier(_identifier);\n    }\n\n    /**\n     * @notice Sets the Escalation Manager for future proposals.\n     * @param _escalationManager address of the Escalation Manager, can be zero to disable this functionality.\n     * @dev Only the owner can call this method. The provided address must conform to the Escalation Manager interface.\n     * FullPolicyEscalationManager can be used, but within the context of this contract it should be used only for\n     * whitelisting of proposers and disputers since Optimistic Governor is deleting disputed proposals.\n     */\n    function setEscalationManager(address _escalationManager) external onlyOwner {\n        escalationManager = _escalationManager;\n        emit SetEscalationManager(_escalationManager);\n    }\n\n    /**\n     * @notice This caches the most up-to-date Optimistic Oracle V3.\n     * @dev If a new Optimistic Oracle V3 is added and this is run between a proposal's introduction and execution, the\n     * proposal will become unexecutable.\n     */\n    function sync() external nonReentrant {\n        _sync();\n    }\n\n    /**\n     * @notice Makes a new proposal for transactions to be executed with an explanation argument.\n     * @param _transactions the transactions being proposed.\n     * @param _explanation Auxillary information that can be referenced to validate the proposal.\n     * @dev Proposer must grant the contract collateral allowance at least to the bondAmount or result of getMinimumBond\n     * from the Optimistic Oracle V3, whichever is greater.\n     */\n    function proposeTransactions(Transaction[] memory _transactions, bytes memory _explanation) external nonReentrant {\n        // note: Optional explanation explains the intent of the transactions to make comprehension easier.\n        uint256 time = getCurrentTime();\n        address proposer = msg.sender;\n\n        // Create proposal in memory to emit in an event.\n        Proposal memory proposal;\n        proposal.requestTime = time;\n\n        // Add transactions to proposal in memory.\n        for (uint256 i = 0; i < _transactions.length; i++) {\n            require(_transactions[i].to != address(0), \"The `to` address cannot be 0x0\");\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\n            if (_transactions[i].data.length > 0) {\n                require(_isContract(_transactions[i].to), \"EOA can't accept tx with data\");\n            }\n        }\n        proposal.transactions = _transactions;\n\n        // Create the proposal hash.\n        bytes32 proposalHash = keccak256(abi.encode(_transactions));\n\n        // Add the proposal hash, explanation and rules to ancillary data.\n        bytes memory claim = _constructClaim(proposalHash, _explanation);\n\n        // Check that the proposal is not already mapped to an assertionId, i.e., is not a duplicate.\n        require(proposalHashes[prop"
    }
  ]
}