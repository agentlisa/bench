{
  "Title": "[G-01] Immutable over constant",
  "Content": "The use of constant `keccak` variables results in extra hashing whenever the variable is used, increasing gas costs relative to just storing the output hash. Changing to immutable will only perform hashing on contract deployment which will save gas.\n\nHere are some of the instances entailed.\n\nhttps://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/aave/StaticATokenLM.sol#L44-L60\n\n```solidity\n    bytes public constant EIP712_REVISION = bytes(\"1\");\n    bytes32 internal constant EIP712_DOMAIN =\n        keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n    bytes32 public constant METADEPOSIT_TYPEHASH =\n        keccak256(\n            \"Deposit(address depositor,address recipient,uint256 value,uint16 referralCode,bool fromUnderlying,uint256 nonce,uint256 deadline)\"\n        );\n    bytes32 public constant METAWITHDRAWAL_TYPEHASH =\n        keccak256(\n            \"Withdraw(address owner,address recipient,uint256 staticAmount,uint256 dynamicAmount,bool toUnderlying,uint256 nonce,uint256 deadline)\"\n        );\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-reserve",
  "Code": [
    {
      "filename": "contracts/plugins/assets/aave/StaticATokenLM.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport { ILendingPool } from \"@aave/protocol-v2/contracts/interfaces/ILendingPool.sol\";\nimport { IERC20 } from \"@aave/protocol-v2/contracts/dependencies/openzeppelin/contracts/IERC20.sol\";\n\nimport { IERC20Detailed } from \"@aave/protocol-v2/contracts/dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport { IAToken } from \"./vendor/IAToken.sol\";\nimport { IStaticATokenLM } from \"./IStaticATokenLM.sol\";\nimport { IAaveIncentivesController } from \"./vendor/IAaveIncentivesController.sol\";\n\nimport { StaticATokenErrors } from \"./StaticATokenErrors.sol\";\n\nimport { ERC20 } from \"./vendor/ERC20.sol\";\nimport { ReentrancyGuard } from \"./vendor/ReentrancyGuard.sol\";\n\nimport { SafeERC20 } from \"@aave/protocol-v2/contracts/dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport { WadRayMath } from \"@aave/protocol-v2/contracts/protocol/libraries/math/WadRayMath.sol\";\nimport { RayMathNoRounding } from \"./vendor/RayMathNoRounding.sol\";\nimport { SafeMath } from \"@aave/protocol-v2/contracts/dependencies/openzeppelin/contracts/SafeMath.sol\";\n\n/**\n * @title StaticATokenLM\n * @notice Wrapper token that allows to deposit tokens on the Aave protocol and receive\n * a token which balance doesn't increase automatically, but uses an ever-increasing exchange rate.\n * The token support claiming liquidity mining rewards from the Aave system.\n * @author Aave\n * From: https://github.com/aave/protocol-v2/blob/238e5af2a95c3fbb83b0c8f44501ed2541215122/contracts/protocol/tokenization/StaticATokenLM.sol#L255\n **/\ncontract StaticATokenLM is\n    ReentrancyGuard,\n    ERC20(\"STATIC_ATOKEN_IMPL\", \"STATIC_ATOKEN_IMPL\"),\n    IStaticATokenLM\n{\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using WadRayMath for uint256;\n    using RayMathNoRounding for uint256;\n\n    /// Emitted whenever a reward token balance is claimed\n    event RewardsClaimed(IERC20 indexed erc20, uint256 indexed amount);\n\n    bytes public constant EIP712_REVISION = bytes(\"1\");\n    bytes32 internal constant EIP712_DOMAIN =\n        keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n    bytes32 public constant METADEPOSIT_TYPEHASH =\n        keccak256(\n            \"Deposit(address depositor,address recipient,uint256 value,uint16 referralCode,bool fromUnderlying,uint256 nonce,uint256 deadline)\"\n        );\n    bytes32 public constant METAWITHDRAWAL_TYPEHASH =\n        keccak256(\n            \"Withdraw(address owner,address recipient,uint256 staticAmount,uint256 dynamicAmount,bool toUnderlying,uint256 nonce,uint256 deadline)\"\n        );\n\n    uint256 public constant STATIC_ATOKEN_LM_REVISION = 0x1;\n\n    ILendingPool public override LENDING_POOL;\n    IAaveIncentivesController public override INCENTIVES_CONTROLLER;\n    IERC20 public override ATOKEN;\n    IERC20 public override ASSET;\n    IERC20 public override REWARD_TOKEN;\n\n    mapping(address => uint256) public _nonces;\n\n    uint256 internal _accRewardsPerToken;\n    uint256 internal _lifetimeRewardsClaimed;\n    uint256 internal _lifetimeRewards;\n    uint256 internal _lastRewardBlock;\n\n    // user => _accRewardsPerToken at last interaction (in RAYs)\n    mapping(address => uint256) private _userSnapshotRewardsPerToken;\n    // user => unclaimedRewards (in RAYs)\n    mapping(address => uint256) private _unclaimedRewards;\n\n    constructor(\n        ILendingPool pool,\n        address aToken,\n        string memory staticATokenName,\n        string memory staticATokenSymbol\n    ) public {\n        LENDING_POOL = pool;\n        ATOKEN = IERC20(aToken);\n\n        _name = staticATokenName;\n        _symbol = staticATokenSymbol;\n        _setupDecimals(IERC20Detailed(aToken).decimals());\n\n        try IAToken(aToken).getIncentivesController() returns (\n            IAaveIncentivesController incentivesController\n        ) {\n            if (address(incentivesController) != address(0)) {\n                INCENTIVES_CONTROLLER = incentivesController;\n                REWARD_TOKEN = IERC20(INCENTIVES_CONTROLLER.REWARD_TOKEN());\n            }\n        } catch {}\n\n        ASSET = IERC20(IAToken(aToken).UNDERLYING_ASSET_ADDRESS());\n        ASSET.safeApprove(address(pool), type(uint256).max);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    // untested:\n    //      nonReentrant line is assumed to be working. cost/benefit of direct testing is high\n    function deposit(\n        address recipient,\n        uint256 amount,\n        uint16 referralCode,\n        bool fromUnderlying\n    ) external override nonReentrant returns (uint256) {\n        return _deposit(msg.sender, recipient, amount, referralCode, fromUnderlying);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    // untested:\n    //      nonReentrant line is assumed to be working. cost/benefit of direct testing is high\n    function withdraw(\n        address recipient,\n        uint256 amount,\n        bool toUnderlying\n    ) external override nonReentrant returns (uint256, uint256) {\n        return _withdraw(msg.sender, recipient, amount, 0, toUnderlying);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    // untested:\n    //      nonReentrant line is assumed to be working. cost/benefit of direct testing is high\n    function withdrawDynamicAmount(\n        address recipient,\n        uint256 amount,\n        bool toUnderlying\n    ) external override nonReentrant returns (uint256, uint256) {\n        return _withdraw(msg.sender, recipient, 0, amount, toUnderlying);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner != address(0), StaticATokenErrors.INVALID_OWNER);\n        //solium-disable-next-line\n        require(block.timestamp <= deadline, StaticATokenErrors.INVALID_EXPIRATION);\n        uint256 currentValidNonce = _nonces[owner];\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                getDomainSeparator(),\n                keccak256(\n                    abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline)\n                )\n            )\n        );\n        require(owner == ecrecover(digest, v, r, s), StaticATokenErrors.INVALID_SIGNATURE);\n        _nonces[owner] = currentValidNonce.add(1);\n        _approve(owner, spender, value);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    // untested:\n    //      nonReentrant line is assumed to be working. cost/benefit of direct testing is high\n    function metaDeposit(\n        address depositor,\n        address recipient,\n        uint256 value,\n        uint16 referralCode,\n        bool fromUnderlying,\n        uint256 deadline,\n        SignatureParams calldata sigParams\n    ) external override nonReentrant returns (uint256) {\n        require(depositor != address(0), StaticATokenErrors.INVALID_DEPOSITOR);\n        //solium-disable-next-line\n        require(block.timestamp <= deadline, StaticATokenErrors.INVALID_EXPIRATION);\n        uint256 currentValidNonce = _nonces[depositor];\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                getDomainSeparator(),\n                keccak256(\n                    abi.encode(\n                        METADEPOSIT_TYPEHASH,\n                        depositor,\n                        recipient,\n                        value,\n                        referralCode,\n                        fromUnderlying,\n                        currentValidNonce,\n                        deadline\n                    )\n                )\n            )\n        );\n        require(\n            depositor == ecrecover(digest, sigParams.v, sigParams.r, sigParams.s),\n            StaticATokenErrors.INVALID_SIGNATURE\n        );\n        _nonces[depositor] = currentValidNonce.add(1);\n        return _deposit(depositor, recipient, value, referralCode, fromUnderlying);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    // untested:\n    //      nonReentrant line is assumed to be working. cost/benefit of direct testing is high\n    function metaWithdraw(\n        address owner,\n        address recipient,\n        uint256 staticAmount,\n        uint256 dynamicAmount,\n        bool toUnderlying,\n        uint256 deadline,\n        SignatureParams calldata sigParams\n    ) external override nonReentrant returns (uint256, uint256) {\n        require(owner != address(0), StaticATokenErrors.INVALID_OWNER);\n        //solium-disable-next-line\n        require(block.timestamp <= deadline, StaticATokenErrors.INVALID_EXPIRATION);\n        uint256 currentValidNonce = _nonces[owner];\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                getDomainSeparator(),\n                keccak256(\n                    abi.encode(\n                        METAWITHDRAWAL_TYPEHASH,\n                        owner,\n                        recipient,\n                        staticAmount,\n                        dynamicAmount,\n                        toUnderlying,\n                        currentValidNonce,\n                        deadline\n                    )\n                )\n            )\n        );\n\n        require(\n            owner == ecrecover(digest, sigParams.v, sigParams.r, sigParams.s),\n            StaticATokenErrors.INVALID_SIGNATURE\n        );\n        _nonces[owner] = currentValidNonce.add(1);\n        return _withdraw(owner, recipient, staticAmount, dynamicAmount, toUnderlying);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function dynamicBalanceOf(address account) external view override returns (uint256) {\n        return _staticToDynamicAmount(balanceOf(account), rate());\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function staticToDynamicAmount(uint256 amount) external view override returns (uint256) {\n        return _staticToDynamicAmount(amount, rate());\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function dynamicToStaticAmount(uint256 amount) external view override returns (uint256) {\n        return _dynamicToStaticAmount(amount, rate());\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function rate() public view override returns (uint256) {\n        return LENDING_POOL.getReserveNormalizedIncome(address(ASSET));\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function getDomainSeparator() public view override returns (bytes32) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return\n            keccak256(\n                abi.encode(\n                    EIP712_DOMAIN,\n                    keccak256(bytes(name())),\n                    keccak256(EIP712_REVISION),\n                    chainId,\n                    address(this)\n                )\n            );\n    }\n\n    function _dynamicToStaticAmount(uint256 amount, uint256 rate_) internal pure returns (uint256) {\n        return amount.rayDiv(rate_);\n    }\n\n    function _staticToDynamicAmount(uint256 amount, uint256 rate_) internal pure returns (uint256) {\n        return amount.rayMul(rate_);\n    }\n\n    function _deposit(\n        address depositor,\n        address recipient,\n        uint256 amount,\n        uint16 referralCode,\n        bool fromUnderlying\n    ) internal returns (uint256) {\n        require(recipient != address(0), StaticATokenErrors.INVALID_RECIPIENT);\n        _updateRewards();\n\n        if (fromUnderlying) {\n            ASSET.safeTransferFrom(depositor, address(this), amount);\n            LENDING_POOL.deposit(address(ASSET), amount, address(this), referralCode);\n        } else {\n            ATOKEN.safeTransferFrom(depositor, address(this), amount);\n        }\n\n        uint256 amountToMint = _dynamicToStaticAmount(amount, rate());\n        _mint(recipient, amountToMint);\n\n        return amountToMint;\n    }\n\n    function _withdraw(\n        address owner,\n        address recipient,\n        uint256 staticAmount,\n        uint256 dynamicAmount,\n        bool toUnderlying\n    ) internal returns (uint256, uint256) {\n        require(recipient != address(0), StaticATokenErrors.INVALID_RECIPIENT);\n        require(\n            staticAmount == 0 || dynamicAmount == 0,\n            StaticATokenErrors.ONLY_ONE_AMOUNT_FORMAT_ALLOWED\n        );\n        _updateRewards();\n\n        uint256 userBalance = balanceOf(owner);\n\n        uint256 amountToWithdraw;\n        uint256 amountToBurn;\n\n        uint256 currentRate = rate();\n        if (staticAmount > 0) {\n            amountToBurn = (staticAmount > userBalance) ? userBalance : staticAmount;\n            amountToWithdraw = _staticToDynamicAmount(amountToBurn, currentRate);\n        } else {\n            uint256 dynamicUserBalance = _staticToDynamicAmount(userBalance, currentRate);\n            amountToWithdraw = (dynamicAmount > dynamicUserBalance)\n                ? dynamicUserBalance\n                : dynamicAmount;\n            amountToBurn = _dynamicToStaticAmount(amountToWithdraw, currentRate);\n        }\n\n        _burn(owner, amountToBurn);\n\n        if (toUnderlying) {\n            uint256 amt = LENDING_POOL.withdraw(address(ASSET), amountToWithdraw, recipient);\n            assert(amt == amountToWithdraw);\n        } else {\n            ATOKEN.safeTransfer(recipient, amountToWithdraw);\n        }\n\n        return (amountToBurn, amountToWithdraw);\n    }\n\n    /**\n     * @notice Updates rewards for senders and receiver in a transfer (not updating rewards for address(0))\n     * @param from The address of the sender of tokens\n     * @param to The address of the receiver of tokens\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256\n    ) internal override {\n        if (address(INCENTIVES_CONTROLLER) == address(0)) {\n            return;\n        }\n        if (from != address(0)) {\n            _updateUser(from);\n        }\n        if (to != address(0)) {\n            _updateUser(to);\n        }\n    }\n\n    /**\n     * @notice Updates virtual internal accounting of rewards.\n     */\n    function _updateRewards() internal {\n        if (address(INCENTIVES_CONTROLLER) == address(0)) {\n            return;\n        }\n        if (block.number > _lastRewardBlock) {\n            _lastRewardBlock = block.number;\n            uint256 supply = totalSupply();\n            if (supply == 0) {\n                // No rewards can have accrued since last because there were no funds.\n                return;\n            }\n\n            address[] memory assets = new address[](1);\n            assets[0] = address(ATOKEN);\n\n            uint256 freshRewards = INCENTIVES_CONTROLLER.getRewardsBalance(assets, address(this));\n            uint256 lifetimeRewards = _lifetimeRewardsClaimed.add(freshRewards);\n            uint256 rewardsAccrued = lifetimeRewards.sub(_lifetimeRewards).wadToRay();\n\n            _accRewardsPerToken = _accRewardsPerToken.add(\n                (rewardsAccrued).rayDivNoRounding(supply.wadToRay())\n            );\n            _lifetimeRewards = lifetimeRewards;\n        }\n    }\n\n    function _collectAndUpdateRewards() internal {\n        if (address(INCENTIVES_CONTROLLER) == address(0)) {\n            return;\n        }\n\n        _lastRewardBlock = block.number;\n        uint256 supply = totalSupply();\n\n        address[] memory assets = new address[](1);\n        assets[0] = address(ATOKEN);\n\n        uint256 freshlyClaimed = INCENTIVES_CONTROLLER.claimRewards(\n            assets,\n            type(uint256).max,\n            address(this)\n        );\n        uint256 lifetimeRewards = _lifetimeRewardsClaimed.add(freshlyClaimed);\n        uint256 rewardsAccrued = lifetimeRewards.sub(_lifetimeRewards).wadToRay();\n        if (supply > 0 && rewardsAccrued > 0) {\n            _accRewardsPerToken = _accRewardsPerToken.add(\n                (rewardsAccrued).rayDivNoRounding(supply.wadToRay())\n            );\n        }\n\n        if (rewardsAccrued > 0) {\n            _lifetimeRewards = lifetimeRewards;\n        }\n\n        _lifetimeRewardsClaimed = lifetimeRewards;\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    // untested:\n    //      nonReentrant line is assumed to be working. cost/benefit of direct testing is high\n    function collectAndUpdateRewards() external override nonReentrant {\n        _collectAndUpdateRewards();\n    }\n\n    /**\n     * @notice Claim rewards on behalf of a user and send them to a receiver\n     * @param onBehalfOf The address to claim on behalf of\n     * @param receiver The address to receive the rewards\n     * @param forceUpdate Flag to retrieve latest rewards from `INCENTIVES_CONTROLLER`\n     */\n    function _claimRewardsOnBehalf(\n        address onBehalfOf,\n        address receiver,\n        bool forceUpdate\n    ) internal {\n        if (forceUpdate) {\n            _collectAndUpdateRewards();\n        }\n\n        uint256 balance = balanceOf(onBehalfOf);\n        uint256 reward = _getClaimableRewards(onBehalfOf, balance, false);\n        uint256 totBal = REWARD_TOKEN.balanceOf(address(this));\n\n        if (reward > totBal) {\n            reward = totBal;\n        }\n        if (reward > 0) {\n            _unclaimedRewards[onBehalfOf] = 0;\n            _updateUserSnapshotRewardsPerToken(onBehalfOf);\n            REWARD_TOKEN.safeTransfer(receiver, reward);\n        }\n    }\n\n    // untested:\n    //      nonReentrant line is assumed to be working. cost/benefit of direct testing is high\n    function claimRewardsOnBehalf(\n        address onBehalfOf,\n        address receiver,\n        bool forceUpdate\n    ) external override nonReentrant {\n        if (address(INCENTIVES_CONTROLLER) == address(0)) {\n            return;\n        }\n\n        require(\n            msg.sender == onBehalfOf || msg.sender == INCENTIVES_CONTROLLER.getClaimer(onBehalfOf),\n            StaticATokenErrors.INVALID_CLAIMER\n        );\n        _claimRewardsOnBehalf(onBehalfOf, receiver, forceUpdate);\n    }\n\n    // untested:\n    //      nonReentrant line is assumed to be working. cost/benefit of direct testing is high\n    function claimRewards(address receiver, bool forceUpdate) external override nonReentrant {\n        if (address(INCENTIVES_CONTROLLER) == address(0)) {\n            return;\n        }\n        _claimRewardsOnBehalf(msg.sender, receiver, forceUpdate);\n    }\n\n    // untested:\n    //      nonReentrant line is assumed to be working. cost/benefit of direct testing is high\n    function claimRewardsToSelf(bool forceUpdate) external override nonReentrant {\n        if (address(INCENTIVES_CONTROLLER) == address(0)) {\n            return;\n        }\n        _claimRewardsOnBehalf(msg.sender, msg.sender, forceUpdate);\n    }\n\n    // untested:\n    //      nonReentrant line is assumed to be working. cost/benefit of direct testing is high\n    function claimRewards() external virtual nonReentrant {\n        if (address(INCENTIVES_CONTROLLER) == address(0)) {\n            return;\n        }\n        uint256 oldBal = REWARD_TOKEN.balanceOf(msg.sender);\n        _claimRewardsOnBehalf(msg.sender, msg.sender, true);\n        emit RewardsClaimed(REWARD_TOKEN, REWARD_TOKEN.balanceOf(msg.sender) - oldBal);\n    }\n\n    /**\n     * @notice Update the rewardDebt for a user with balance as his balance\n     * @param user The user to update\n     */\n    function _updateUserSnapshotRewardsPerToken(address user) internal {\n        _userSnapshotRewardsPerToken[user] = _accRewardsPerToken;\n    }\n\n    /**\n     * @notice Adding the pending rewards to the unclaimed for specific user and updating user index\n     * @param user The address of the user to update\n     */\n    function _updateUser(address user) internal {\n        uint256 balance = balanceOf(user);\n        if (balance > 0) {\n            uint256 pending = _getPendingRewards(user, balance, false);\n            _unclaimedRewards[user] = _unclaimedRewards[user].add(pending);\n        }\n        _updateUserSnapshotRewardsPerToken(user);\n    }\n\n    /**\n     * @notice Compute the pending in RAY (rounded down). Pending is the amount to add (not yet unclaimed) rewards in RAY (rounded down).\n     * @param user The user to compute for\n     * @param balance The balance of the user\n     * @param fresh Flag to account for rewards not claimed by contract yet\n     * @return The amound of pending rewards in RAY\n     */\n    function _getPendingRewards(\n        address user,\n        uint256 balance,\n        bool fresh\n    ) internal view returns (uint256) {\n        if (address(INCENTIVES_CONTROLLER) == address(0)) {\n            return 0;\n        }\n\n        if (balance == 0) {\n            return 0;\n        }\n\n        uint256 rayBalance = balance.wadToRay();\n\n        uint256 supply = totalSupply();\n        uint256 accRewardsPerToken = _accRewardsPerToken;\n\n        if (supply != 0 && fresh) {\n            address[] memory assets = new address[](1);\n            assets[0] = address(ATOKEN);\n\n            uint256 freshReward = INCENTIVES_CONTROLLER.getRewardsBalance(assets, address(this));\n            uint256 lifetimeRewards = _lifetimeRewardsClaimed.add(freshReward);\n            uint256 rewardsAccrued = lifetimeRewards.sub(_lifetimeRewards).wadToRay();\n            accRewardsPerToken = accRewardsPerToken.add(\n                (rewardsAccrued).rayDivNoRounding(supply.wadToRay())\n            );\n        }\n\n        return\n            rayBalance.rayMulNoRounding(accRewardsPerToken.sub(_userSnapshotRewardsPerToken[user]));\n    }\n\n    /**\n     * @notice Compute the claimable rewards for a user\n     * @param user The address of the user\n     * @param balance The balance of the user in WAD\n     * @param fresh Flag to account for rewards not claimed by contract yet\n     * @return The total rewards that can be claimed by the user (if `fresh` flag true, after updating rewards)\n     */\n    function _getClaimableRewards(\n        address user,\n        uint256 balance,\n        bool fresh\n    ) internal view returns (uint256) {\n        uint256 reward = _unclaimedRewards[user].add(_getPendingRewards(user, balance, fresh));\n        return reward.rayToWadNoRounding();\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function getTotalClaimableRewards() external view override returns (uint256) {\n        if (address(INCENTIVES_CONTROLLER) == address(0)) {\n            return 0;\n        }\n\n        address[] memory assets = new address[](1);\n        assets[0] = address(ATOKEN);\n        uint256 freshRewards = INCENTIVES_CONTROLLER.getRewardsBalance(assets, address(this));\n        return REWARD_TOKEN.balanceOf(address(this)).add(freshRewards);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function getClaimableRewards(address user) external view override returns (uint256) {\n        return _getClaimableRewards(user, balanceOf(user), true);\n    }\n\n    ///@inheritdoc IStaticATokenLM\n    function getUnclaimedRewards(address user) external view override returns (uint256) {\n        return _unclaimedRewards[user].rayToWadNoRounding();\n    }\n\n    function getAccRewardsPerToken() external view override returns (uint256) {\n        return _accRewardsPerToken;\n    }\n\n    function getLifetimeRewardsClaimed() external view override returns (uint256) {\n        return _lifetimeRewardsClaimed;\n    }\n\n    function getLifetimeRewards() external view override returns (uint256) {\n        return _lifetimeRewards;\n    }\n\n    function getLastRewardBlock() external view override returns (uint256) {\n        return _lastRewardBlock;\n    }\n\n    function getIncentivesController() external view override returns (IAaveIncentivesController) {\n        return INCENTIVES_CONTROLLER;\n    }\n\n    function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {\n        return address(ASSET);\n    }\n}"
    }
  ]
}