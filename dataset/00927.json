{
  "Title": "No Access Control on Setters Produced by accessors Macro",
  "Content": "The `accessors` macro implements [getters](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/lang/codegen/src/accessors.rs#L29) and [setters](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/lang/codegen/src/accessors.rs#L45) for struct fields, which can be called externally in a smart contract context since they are annotated with `#[ink(message)]`. It is vital to ensure that any sensitive or critical state variables cannot be trivially accessible or modifiable using these generated functions, as it could expose vulnerabilities in the contract.\n\n\nCurrently, modifiers cannot be attached to these setters, and there is inadequate documentation cautioning users about this macro's use.\n\n\nConsider modifying the macro setter attribute to incorporate access control capabilities. Furthermore, it would be ideal for the setters to come with access control mechanisms enabled by default and only allow them to be disabled if users intentionally choose to do so.\n\n\n***Update:** Acknowledged, will resolve. The Brushfam team stated that they will resolve the issue:*\n\n\n\n> *The macro is going to be reworked soon, the suggestion will be implemented there, progress can be tracked here: https://github.com/Brushfam/openbrush-contracts/issues/135.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "lang/codegen/src/accessors.rs",
      "content": "use proc_macro2::TokenStream;\nuse quote::{\n    format_ident,\n    quote,\n    quote_spanned,\n};\nuse syn::{\n    spanned::Spanned,\n    Data,\n    DataStruct,\n    Field,\n    Fields,\n};\n\npub fn accessors(attrs: TokenStream, s: synstructure::Structure) -> TokenStream {\n    let trait_ident = attrs;\n\n    let struct_ident = s.ast().ident.clone();\n\n    let item = match s.ast().data.clone() {\n        Data::Struct(struct_item) => generate_struct(&s, struct_item),\n        _ => panic!(\"Only structs are supported\"),\n    };\n\n    let fields: Vec<_> = extract_get_fields(s.clone());\n\n    let get_impls = fields.iter().map(|field| {\n        let field_ident = field.ident.clone().unwrap();\n        let method_ident = format_ident!(\"get_{}\", field_ident);\n        let field_type = field.ty.clone();\n        let span = field.span();\n\n        quote_spanned! {span =>\n            #[ink(message)]\n            fn #method_ident(&self) -> #field_type {\n                self.data().#field_ident\n            }\n        }\n    });\n\n    let fields: Vec<_> = extract_set_fields(s.clone());\n\n    let set_impls = fields.iter().map(|field| {\n        let field_ident = field.ident.clone().unwrap();\n        let method_ident = format_ident!(\"set_{}\", field_ident);\n        let field_type = field.ty.clone();\n        let span = field.span();\n\n        quote_spanned! {span =>\n            #[ink(message)]\n            fn #method_ident(&mut self, value: #field_type) {\n                self.data().#field_ident = value;\n            }\n        }\n    });\n\n    let result = quote! {\n        #item\n\n        #[openbrush::trait_definition]\n        pub trait #trait_ident : Storage<#struct_ident>{\n            #(#get_impls)*\n            #(#set_impls)*\n        }\n    };\n\n    result\n}\n\nfn generate_struct(s: &synstructure::Structure, struct_item: DataStruct) -> TokenStream {\n    let struct_ident = s.ast().ident.clone();\n    let vis = s.ast().vis.clone();\n    let attrs = s.ast().attrs.clone();\n    let types = s.ast().generics.clone();\n    let (_, _, where_closure) = s.ast().generics.split_for_impl();\n\n    let fields = struct_item\n        .clone()\n        .fields\n        .into_iter()\n        .map(|mut field| consume_attrs(&mut field));\n\n    match struct_item.fields {\n        Fields::Unnamed(_) => {\n            quote! {\n                #(#attrs)*\n                #vis struct #struct_ident #types #where_closure (\n                    #(#fields),*\n                );\n            }\n        }\n        _ => {\n            quote! {\n                #(#attrs)*\n                #vis struct #struct_ident #types #where_closure {\n                    #(#fields),*\n                }\n            }\n        }\n    }\n}\n\nfn consume_attrs(field: &mut syn::Field) -> Field {\n    let attr = field\n        .attrs\n        .iter()\n        .filter(|a| !a.path.is_ident(\"get\") && !a.path.is_ident(\"set\"))\n        .cloned()\n        .collect();\n\n    field.attrs = attr;\n\n    field.clone()\n}\n\nfn extract_get_fields(s: synstructure::Structure) -> Vec<Field> {\n    let struct_item = match s.ast().data.clone() {\n        Data::Struct(struct_item) => struct_item,\n        _ => panic!(\"Only structs are supported\"),\n    };\n\n    struct_item\n        .fields\n        .iter()\n        .filter(|field| field.attrs.iter().any(|a| a.path.is_ident(\"get\")))\n        .cloned()\n        .collect::<Vec<_>>()\n}\n\nfn extract_set_fields(s: synstructure::Structure) -> Vec<Field> {\n    let struct_item = match s.ast().data.clone() {\n        Data::Struct(struct_item) => struct_item,\n        _ => panic!(\"Only structs are supported\"),\n    };\n\n    struct_item\n        .fields\n        .iter()\n        .filter(|field| field.attrs.iter().any(|a| a.path.is_ident(\"set\")))\n        .cloned()\n        .collect::<Vec<_>>()\n}"
    }
  ]
}