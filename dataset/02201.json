{
  "Title": "M-36: Deposited funds are locked in inactive vaults",
  "Content": "# Issue M-36: Deposited funds are locked in inactive vaults \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/318 \n\n## Found by \nMet, saidam017, Jeiwan\n\n## Summary\nUsers cannot request withdrawal of their funds from inactive vaults: if a vault receives 0 allocations from gamers, only previous withdrawal requests can be process and new requests cannot be made.\n## Vulnerability Detail\nDuring rebalancing, if a vault receives 0 allocations from gamers, [it becomes inactive](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L229-L235). `MainVault` doesn't allow calling these functions on an inactive vault:\n1. [deposit](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L106-L109), which makes sense because the vault doesn't generate yield and users shouldn't be allowed to deposit funds in such vaults;\n1. [withdraw](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L131-L135), which also makes sense because the vault holds no funds, so immediate withdrawals are not possible;\n1. [withdrawalRequest](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L149-L151), which seems wrong because this doesn't allow users to withdraw funds after next rebalancing.\n\nSince inactive vaults don't receive funds during rebalancing, it expected that immediate withdrawals via the `withdraw` function are disabled (inactive vaults don't hold funds, thus funds cannot be withdrawn immediately). However, disallowing `withdrawalRequest` seems like a mistake: users who have deposited their funds into an inactive vault and who are still holding shares of the vault might decide, after seeing that the vault haven't received allocations during last rebalancing (e.g. protocols on other networks might generate higher yields and gamers might want to direct all allocations to those protocols), to withdraw their funds. `withdrawalRequest` allows them to request withdrawal after next rebalancing, which is a crucial feature of the protocol.\n## Impact\nIn the worst case scenario, user funds can be locked in an inactive vault for a prolonged period of time. E.g. if the vault is deployed in a network where yield generating protocols produce lower APY than protocols on other networks. In this scenario, gamers will be willing to allocate to more profitable protocols, but depositors of the inactive vault will be forced to keep their funds locked in the vault until on-chain conditions change (which are not controlled by users, e.g. users cannot force a protocol to have a higher APY).\n## Code Snippet\n1. When `XChainController` receives allocations, it disables vault that have 0 allocations and that haven't received new allocations:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/XChainController.sol#L229-L235\n1. Withdrawals cannot be requested in inactive vaults due to the `onlyWhenVaultIsOn` modifier:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L149-L151\n1. `withdrawAllowance` can only withdraw funds when there's a withdrawal request:\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L166-L169\n## Tool used\nManual Review\n## Recommendation\nConsider allowing users call `withdrawalRequest` to request withdrawal in inactive vault. During rebalancing, inactive vaults with positive `withdrawalRequest` should receive enough funds for all requests to be processed.\n\n## Discussion\n\n**sjoerdsommen**\n\nDuplicate with https://github.com/sherlock-audit/2023-01-derby-judging/issues/318 https://github.com/sherlock-audit/2023-01-derby-judging/issues/211 https://github.com/sherlock-audit/2023-01-derby-judging/issues/137\n\n**hrishibhat**\n\nGiven the necessary preconditions for the issue to happen considering this issue as a valid medium\n\n\n\n\n\n## Discussion\n\n**sjoerdsommen**\n\nDuplicate with https://github.com/sherlock-audit/2023-01-derby-judging/issues/318 https://github.com/sherlock-audit/2023-01-derby-judging/issues/211 https://github.com/sherlock-audit/2023-01-derby-judging/issues/137\n\n**hrishibhat**\n\nGiven the necessary preconditions for the issue to happen considering this issue as a valid medium\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/XChainController.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"./Interfaces/IXProvider.sol\";\r\n\r\ncontract XChainController {\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct vaultInfo {\r\n    int256 totalCurrentAllocation;\r\n    uint256 totalUnderlying;\r\n    uint256 totalSupply;\r\n    uint256 totalWithdrawalRequests;\r\n    // (chainId => bool): true == off // false == on\r\n    mapping(uint32 => bool) chainIdOff;\r\n    // (chainId => currentAllocation)\r\n    mapping(uint32 => int256) currentAllocationPerChain;\r\n    // (chainId => totalUnderlying)\r\n    mapping(uint32 => uint256) totalUnderlyingPerChain;\r\n    // (chainId => vaultAddress)\r\n    mapping(uint32 => address) vaultChainAddress;\r\n    // (chainId => underlyingAddress): e.g USDC\r\n    mapping(uint32 => address) vaultUnderlyingAddress;\r\n    // (chainId => totalWithdrawalRequests): total withdrawal requests in LP Token\r\n    mapping(uint32 => uint256) withdrawalRequests;\r\n    // (chainId => amountToDeposit)\r\n    mapping(uint32 => uint256) amountToDepositPerChain;\r\n  }\r\n\r\n  // activeVaults; number of active vaults for vaultNumber, set in XChainRebalance\r\n  // stage 0 Ready; waiting for game to send allocations\r\n  // stage 1 AllocationsReceived; allocations received from game, ready to rebalance XChain and set activeVaults\r\n  // stage 2 UnderlyingReceived; underlyings received from all active vault contracts\r\n  // stage 3 FundsReceived; funds received from all active vault contracts\r\n  struct vaultStages {\r\n    uint256 activeVaults;\r\n    bool ready; // stage 0\r\n    bool allocationsReceived; // stage 1\r\n    uint256 underlyingReceived; // stage 2\r\n    uint256 fundsReceived; // stage 3\r\n    uint256 fundsSent; // stage 4\r\n  }\r\n\r\n  address private dao;\r\n  address private guardian;\r\n  address public game;\r\n  address public xProviderAddr;\r\n  IXProvider public xProvider;\r\n\r\n  uint32[] public chainIds;\r\n  uint32 public homeChain;\r\n  int256 public minimumAmount;\r\n\r\n  // (vaultNumber => vaultInfo struct)\r\n  mapping(uint256 => vaultInfo) internal vaults;\r\n  // (vaultNumber => vaultStages struct)\r\n  mapping(uint256 => vaultStages) public vaultStage;\r\n\r\n  event SendXChainAmount(\r\n    address _vault,\r\n    uint32 _chainId,\r\n    uint256 _amountToSendXChain,\r\n    uint256 _exchangeRate,\r\n    bool _receivingFunds\r\n  );\r\n\r\n  event SentFundsToVault(address _vault, uint32 _chainId, uint256 _amount, address _asset);\r\n\r\n  modifier onlyGame() {\r\n    require(msg.sender == game, \"xController: only Game\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyDao() {\r\n    require(msg.sender == dao, \"xController: only DAO\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == guardian, \"xController: only Guardian\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyXProvider() {\r\n    require(msg.sender == address(xProvider), \"xController: only xProviderAddr\");\r\n    _;\r\n  }\r\n\r\n  // vaultStage 0\r\n  modifier onlyWhenReady(uint256 _vaultNumber) {\r\n    require(vaultStage[_vaultNumber].ready, \"Not all vaults are ready\");\r\n    _;\r\n  }\r\n\r\n  // vaultStage 1\r\n  modifier onlyWhenAllocationsReceived(uint256 _vaultNumber) {\r\n    require(vaultStage[_vaultNumber].allocationsReceived, \"Allocations not received from game\");\r\n    _;\r\n  }\r\n\r\n  // vaultStage 2\r\n  modifier onlyWhenUnderlyingsReceived(uint256 _vaultNumber) {\r\n    require(\r\n      vaultStage[_vaultNumber].underlyingReceived == vaultStage[_vaultNumber].activeVaults,\r\n      \"Not all underlyings received\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  // vaultStage 3\r\n  modifier onlyWhenFundsReceived(uint256 _vaultNumber) {\r\n    require(\r\n      vaultStage[_vaultNumber].fundsReceived == vaultStage[_vaultNumber].activeVaults,\r\n      \"Not all funds received\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  constructor(address _game, address _dao, address _guardian, uint32 _homeChain) {\r\n    game = _game;\r\n    dao = _dao;\r\n    guardian = _guardian;\r\n    homeChain = _homeChain;\r\n    minimumAmount = 1000e6;\r\n  }\r\n\r\n  /// @notice Setter for number of active vaults for vaultNumber, set in xChainRebalance\r\n  /// @param _vaultNumber Number of the vault\r\n  /// @param _activeVaults Number active vaults, calculated in xChainRebalance\r\n  function setActiveVaults(uint256 _vaultNumber, uint256 _activeVaults) internal {\r\n    vaultStage[_vaultNumber].activeVaults = _activeVaults;\r\n  }\r\n\r\n  /// @notice Setter for stage 0:\r\n  /// @notice Ready; waiting for game to send allocations\r\n  function setReady(uint256 _vaultNumber, bool _state) internal {\r\n    vaultStage[_vaultNumber].ready = _state;\r\n  }\r\n\r\n  /// @notice Setter for stage 1:\r\n  /// @notice AllocationsReceived; allocations received from game, ready to rebalance XChain and set activeVaults\r\n  function setAllocationsReceived(\r\n    uint256 _vaultNumber,\r\n    bool _state\r\n  ) internal onlyWhenReady(_vaultNumber) {\r\n    vaultStage[_vaultNumber].allocationsReceived = _state;\r\n  }\r\n\r\n  /// @notice Setter to tick up stage 2:\r\n  /// @notice UnderlyingReceived; underlyings received from all active vault contracts\r\n  function upUnderlyingReceived(\r\n    uint256 _vaultNumber\r\n  ) internal onlyWhenAllocationsReceived(_vaultNumber) {\r\n    vaultStage[_vaultNumber].underlyingReceived++;\r\n  }\r\n\r\n  /// @notice Step 4 end; Push funds from vaults to xChainController\r\n  /// @notice FundsReceived; funds received from all active vault contracts\r\n  function upFundsReceived(\r\n    uint256 _vaultNumber\r\n  ) external onlyXProvider onlyWhenUnderlyingsReceived(_vaultNumber) {\r\n    vaultStage[_vaultNumber].fundsReceived++;\r\n  }\r\n\r\n  /// @notice Resets all stages in vaultStage struct for a vaultNumber\r\n  function resetVaultStages(uint256 _vaultNumber) internal {\r\n    vaultStage[_vaultNumber].ready = true;\r\n    vaultStage[_vaultNumber].allocationsReceived = false;\r\n    vaultStage[_vaultNumber].underlyingReceived = 0;\r\n    vaultStage[_vaultNumber].fundsReceived = 0;\r\n    vaultStage[_vaultNumber].fundsSent = 0;\r\n  }\r\n\r\n  /// @notice Resets underlying for a vaultNumber at the start of a rebalancing period\r\n  function resetVaultUnderlying(uint256 _vaultNumber) internal {\r\n    vaults[_vaultNumber].totalUnderlying = 0;\r\n    vaultStage[_vaultNumber].underlyingReceived = 0;\r\n    vaults[_vaultNumber].totalSupply = 0;\r\n  }\r\n\r\n  /// @notice Resets underlying for a vaultNumber per chainId at the start of a rebalancing period\r\n  function resetVaultUnderlyingForChain(uint256 _vaultNumber, uint32 _chainId) internal {\r\n    vaults[_vaultNumber].totalUnderlyingPerChain[_chainId] = 0;\r\n  }\r\n\r\n  /// @notice Step 1 end; Game pushes totalDeltaAllocations to xChainController\r\n  /// @param _vaultNumber Number of Vault\r\n  /// @param _deltas Delta allocations array received from game, indexes match chainIds[] set in this contract\r\n  function receiveAllocationsFromGame(\r\n    uint256 _vaultNumber,\r\n    int256[] memory _deltas\r\n  ) external onlyXProvider onlyWhenReady(_vaultNumber) {\r\n    return receiveAllocationsFromGameInt(_vaultNumber, _deltas);\r\n  }\r\n\r\n  /// @notice Step 1 end; Game pushes totalDeltaAllocations to xChainController\r\n  /// @param _vaultNumber Number of Vault\r\n  /// @param _deltas Delta allocations array received from game, indexes match chainIds[] set in this contract\r\n  function receiveAllocationsFromGameInt(uint256 _vaultNumber, int256[] memory _deltas) internal {\r\n    uint256 activeVaults;\r\n\r\n    for (uint256 i = 0; i < chainIds.length; i++) {\r\n      uint32 chain = chainIds[i];\r\n      activeVaults += settleCurrentAllocation(_vaultNumber, chain, _deltas[i]);\r\n      resetVaultUnderlyingForChain(_vaultNumber, chain);\r\n    }\r\n\r\n    resetVaultUnderlying(_vaultNumber);\r\n    setActiveVaults(_vaultNumber, activeVaults);\r\n    setAllocationsReceived(_vaultNumber, true);\r\n    setReady(_vaultNumber, false);\r\n  }\r\n\r\n  /// @notice Helper to settle the total current allocation with the delta allocations received from Game\r\n  /// @notice Will set a chainId on/off depending on the currentAllocation and incoming deltaAllocation\r\n  /// @dev if currentAllocation = 0 and deltaAllocation = 0, chainId will be set to Off and feedback will be send to vault\r\n  /// @param _vaultNumber Number of Vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _deltas Delta allocations array received from game, indexes match chainIds[] set in this contract\r\n  function settleCurrentAllocation(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    int256 _deltas\r\n  ) internal returns (uint256 activeVault) {\r\n    if (getCurrentAllocation(_vaultNumber, _chainId) == 0 && _deltas == 0) {\r\n      vaults[_vaultNumber].chainIdOff[_chainId] = true;\r\n      activeVault = 0;\r\n    } else {\r\n      vaults[_vaultNumber].chainIdOff[_chainId] = false;\r\n      activeVault = 1;\r\n    }\r\n\r\n    vaults[_vaultNumber].totalCurrentAllocation += _deltas;\r\n    vaults[_vaultNumber].currentAllocationPerChain[_chainId] += _deltas;\r\n\r\n    require(vaults[_vaultNumber].totalCurrentAllocation >= 0, \"Allocation underflow\");\r\n  }\r\n\r\n  /// @notice Will send feedback to the vault if it is turned on or off by settleCurrentAllocation\r\n  /// @notice Step 1.5, toggle vault on or off\r\n  /// @param _vaultNumber Number of vault\r\n  /// @param _chainId Chain id of the vault where the funds need to be sent\r\n  function sendFeedbackToVault(uint256 _vaultNumber, uint32 _chainId) external payable {\r\n    address vault = getVaultAddress(_vaultNumber, _chainId);\r\n    require(vault != address(0), \"xChainController: not a valid vaultnumber\");\r\n    xProvider.pushStateFeedbackToVault{value: msg.value}(\r\n      vault,\r\n      _chainId,\r\n      vaults[_vaultNumber].chainIdOff[_chainId]\r\n    );\r\n  }\r\n\r\n  /// @notice See setTotalUnderlyingInt below\r\n  function setTotalUnderlying(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) external onlyXProvider onlyWhenAllocationsReceived(_vaultNumber) {\r\n    require(getTotalUnderlyingOnChain(_vaultNumber, _chainId) == 0, \"TotalUnderlying already set\");\r\n    setTotalUnderlyingInt(_vaultNumber, _chainId, _underlying, _totalSupply, _withdrawalRequests);\r\n  }\r\n\r\n  /// @notice Step 2 end; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\r\n  /// @notice Receive and set totalUnderlyings from the vaults for every chainId\r\n  /// @param _vaultNumber number of the vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _underlying totalUnderling plus vault balance in vaultcurrency e.g USDC\r\n  /// @param _totalSupply Supply of the LP token of the vault on given chainId\r\n  /// @param _withdrawalRequests Total amount of withdrawal requests from the vault in LP Tokens\r\n  function setTotalUnderlyingInt(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) internal {\r\n    vaults[_vaultNumber].totalUnderlyingPerChain[_chainId] = _underlying;\r\n    vaults[_vaultNumber].withdrawalRequests[_chainId] = _withdrawalRequests;\r\n    vaults[_vaultNumber].totalSupply += _totalSupply;\r\n    vaults[_vaultNumber].totalUnderlying += _underlying;\r\n    vaults[_vaultNumber].totalWithdrawalRequests += _withdrawalRequests;\r\n    vaultStage[_vaultNumber].underlyingReceived++;\r\n  }\r\n\r\n  /// @notice Step 3 trigger; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\r\n  /// @notice Calculates the amounts the vaults on each chainId have to send or receive\r\n  /// @param _vaultNumber Number of vault\r\n  /// @param _chain Chain id of the vault where the funds need to be sent\r\n  function pushVaultAmounts(\r\n    uint256 _vaultNumber,\r\n    uint16 _chain\r\n  ) external payable onlyWhenUnderlyingsReceived(_vaultNumber) {\r\n    address vault = getVaultAddress(_vaultNumber, _chain);\r\n    require(vault != address(0), \"xChainController: not a valid vaultnumber\");\r\n    int256 totalAllocation = getCurrentTotalAllocation(_vaultNumber);\r\n    uint256 totalWithdrawalRequests = getTotalWithdrawalRequests(_vaultNumber);\r\n    uint256 totalUnderlying = getTotalUnderlyingVault(_vaultNumber) - totalWithdrawalRequests;\r\n    uint256 totalSupply = getTotalSupply(_vaultNumber);\r\n\r\n    uint256 decimals = xProvider.getDecimals(vault);\r\n    uint256 newExchangeRate = (totalUnderlying * (10 ** decimals)) / totalSupply;\r\n\r\n    if (!getVaultChainIdOff(_vaultNumber, _chain)) {\r\n      int256 amountToChain = calcAmountToChain(\r\n        _vaultNumber,\r\n        _chain,\r\n        totalUnderlying,\r\n        totalAllocation\r\n      );\r\n      (int256 amountToDeposit, uint256 amountToWithdraw) = calcDepositWithdraw(\r\n        _vaultNumber,\r\n        _chain,\r\n        amountToChain\r\n      );\r\n\r\n      sendXChainAmount(_vaultNumber, _chain, amountToDeposit, amountToWithdraw, newExchangeRate);\r\n    }\r\n  }\r\n\r\n  /// @notice Calculates the amounts the vaults on each chainId have to send or receive\r\n  /// @param _vaultNumber number of the vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _amountToChain Amount in vaultcurrency that should be on given chainId\r\n  function calcDepositWithdraw(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    int256 _amountToChain\r\n  ) internal view returns (int256, uint256) {\r\n    uint256 currentUnderlying = getTotalUnderlyingOnChain(_vaultNumber, _chainId);\r\n\r\n    int256 amountToDeposit = _amountToChain - int256(currentUnderlying);\r\n    uint256 amountToWithdraw = amountToDeposit < 0\r\n      ? currentUnderlying - uint256(_amountToChain)\r\n      : 0;\r\n\r\n    return (amountToDeposit, amountToWithdraw);\r\n  }\r\n\r\n  /// @notice Calculates the amounts the vaults has to send back to the xChainController\r\n  /// @param _totalUnderlying Total underlying on all chains for given vaultNumber\r\n  /// @param _totalAllocation Total allocation on all chains for given vaultNumber\r\n  function calcAmountToChain(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    uint256 _totalUnderlying,\r\n    int256 _totalAllocation\r\n  ) internal view returns (int256) {\r\n    int256 allocation = getCurrentAllocation(_vaultNumber, _chainId);\r\n    uint256 withdrawalRequests = getWithdrawalRequests(_vaultNumber, _chainId);\r\n\r\n    int256 amountToChain = (int(_totalUnderlying) * allocation) / _totalAllocation;\r\n    amountToChain += int(withdrawalRequests);\r\n\r\n    return amountToChain;\r\n  }\r\n\r\n  /// @notice Sends out cross-chain messages to vaults with the amount the vault has to send back\r\n  /// @dev if the xChainController needs to deposit, the amount will be 0 so the vault knows it will receive currency\r\n  /// @param _amountDeposit Amount the vault will receive from the xChainController\r\n  /// @param _amountToWithdraw Amount the vault will have to send back to the xChainController\r\n  /// @param _exchangeRate New exchangerate for vaults\r\n  function sendXChainAmount(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    int256 _amountDeposit,\r\n    uint256 _amountToWithdraw,\r\n    uint256 _exchangeRate\r\n  ) internal {\r\n    address vault = getVaultAddress(_vaultNumber, _chainId);\r\n    bool receivingFunds;\r\n    uint256 amountToSend = 0;\r\n\r\n    if (_amountDeposit > 0 && _amountDeposit < minimumAmount) {\r\n      vaultStage[_vaultNumber].fundsReceived++;\r\n    } else if (_amountDeposit >= minimumAmount) {\r\n      receivingFunds = true;\r\n      setAmountToDeposit(_vaultNumber, _chainId, _amountDeposit);\r\n      vaultStage[_vaultNumber].fundsReceived++;\r\n    }\r\n\r\n    if (_amountToWithdraw > 0 && _amountToWithdraw < uint(minimumAmount)) {\r\n      vaultStage[_vaultNumber].fundsReceived++;\r\n    } else if (_amountToWithdraw >= uint(minimumAmount)) {\r\n      amountToSend = _amountToWithdraw;\r\n    }\r\n\r\n    xProvider.pushSetXChainAllocation{value: msg.value}(\r\n      vault,\r\n      _chainId,\r\n      amountToSend,\r\n      _exchangeRate,\r\n      receivingFunds\r\n    );\r\n    emit SendXChainAmount(vault, _chainId, amountToSend, _exchangeRate, receivingFunds);\r\n  }\r\n\r\n  /// @notice Step 5 trigger; Push funds from xChainController to vaults\r\n  /// @notice Send amount to deposit from xController to vault and reset all stages for the vault\r\n  /// @param _vaultNumber Number of vault\r\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\r\n  /// @param _chain Chain id of the vault where the funds need to be sent\r\n  /// @param _relayerFee The fee offered to the relayers\r\n  function sendFundsToVault(\r\n    uint256 _vaultNumber,\r\n    uint256 _slippage,\r\n    uint32 _chain,\r\n    uint256 _relayerFee\r\n  ) external payable onlyWhenFundsReceived(_vaultNumber) {\r\n    address vault = getVaultAddress(_vaultNumber, _chain);\r\n    require(vault != address(0), \"xChainController: not a valid vaultnumber\");\r\n    if (!getVaultChainIdOff(_vaultNumber, _chain)) {\r\n      uint256 amountToDeposit = getAmountToDeposit(_vaultNumber, _chain);\r\n\r\n      if (amountToDeposit > 0) {\r\n        address underlying = getUnderlyingAddress(_vaultNumber, _chain);\r\n\r\n        uint256 balance = IERC20(underlying).balanceOf(address(this));\r\n        if (amountToDeposit > balance) amountToDeposit = balance;\r\n\r\n        IERC20(underlying).safeIncreaseAllowance(address(xProvider), amountToDeposit);\r\n        xProvider.xTransferToVaults{value: msg.value}(\r\n          vault,\r\n          _chain,\r\n          amountToDeposit,\r\n          underlying,\r\n          _slippage,\r\n          _relayerFee\r\n        );\r\n        setAmountToDeposit(_vaultNumber, _chain, 0);\r\n        emit SentFundsToVault(vault, _chain, amountToDeposit, underlying);\r\n      }\r\n    }\r\n    vaultStage[_vaultNumber].fundsSent++;\r\n    if (vaultStage[_vaultNumber].fundsSent == chainIds.length) resetVaultStages(_vaultNumber);\r\n  }\r\n\r\n  /// @notice Helper to get total current allocation of vaultNumber\r\n  function getTotalUnderlyingOnChain(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId\r\n  ) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].totalUnderlyingPerChain[_chainId];\r\n  }\r\n\r\n  /// @notice Gets saved totalUnderlying for vaultNumber\r\n  function getTotalUnderlyingVault(\r\n    uint256 _vaultNumber\r\n  ) internal view onlyWhenUnderlyingsReceived(_vaultNumber) returns (uint256) {\r\n    return vaults[_vaultNumber].totalUnderlying;\r\n  }\r\n\r\n  /// @notice Helper to get vault address of vaultNumber with given chainID\r\n  function getVaultAddress(uint256 _vaultNumber, uint32 _chainId) internal view returns (address) {\r\n    return vaults[_vaultNumber].vaultChainAddress[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get underyling address of vaultNumber with given chainID eg USDC\r\n  function getUnderlyingAddress(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId\r\n  ) internal view returns (address) {\r\n    return vaults[_vaultNumber].vaultUnderlyingAddress[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get current allocation per chain of vaultNumber with given chainID\r\n  function getCurrentAllocation(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId\r\n  ) internal view returns (int256) {\r\n    return vaults[_vaultNumber].currentAllocationPerChain[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get total current allocation of vaultNumber\r\n  function getCurrentTotalAllocation(uint256 _vaultNumber) internal view returns (int256) {\r\n    return vaults[_vaultNumber].totalCurrentAllocation;\r\n  }\r\n\r\n  /// @notice Helper to get if vault is active or not\r\n  function getVaultChainIdOff(uint256 _vaultNumber, uint32 _chainId) public view returns (bool) {\r\n    return vaults[_vaultNumber].chainIdOff[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to set the amount to deposit in a chain vault\r\n  function setAmountToDeposit(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    int256 _amountToDeposit\r\n  ) internal {\r\n    vaults[_vaultNumber].amountToDepositPerChain[_chainId] = uint256(_amountToDeposit);\r\n  }\r\n\r\n  /// @notice Helper to get the amount to deposit in a chain vault\r\n  function getAmountToDeposit(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId\r\n  ) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].amountToDepositPerChain[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get total supply from the vault on given chainId\r\n  function getTotalSupply(uint256 _vaultNumber) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].totalSupply;\r\n  }\r\n\r\n  /// @notice Helper to get withdrawal requests from the vault on given chainId\r\n  function getWithdrawalRequests(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId\r\n  ) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].withdrawalRequests[_chainId];\r\n  }\r\n\r\n  /// @notice Helper to get total withdrawal requests from the vault on given chainId\r\n  function getTotalWithdrawalRequests(uint256 _vaultNumber) internal view returns (uint256) {\r\n    return vaults[_vaultNumber].totalWithdrawalRequests;\r\n  }\r\n\r\n  /// @notice Getter for chainId array\r\n  function getChainIds() public view returns (uint32[] memory) {\r\n    return chainIds;\r\n  }\r\n\r\n  /// @notice Getter for dao address\r\n  function getDao() public view returns (address) {\r\n    return dao;\r\n  }\r\n\r\n  /// @notice Getter for guardian address\r\n  function getGuardian() public view returns (address) {\r\n    return guardian;\r\n  }\r\n\r\n  /*\r\n  Only Dao functions\r\n  */\r\n\r\n  /// @notice Set Vault address and underlying for a particulair chainId\r\n  /// @param _vaultNumber number of Vault\r\n  /// @param _chainId Number of chain used\r\n  /// @param _address address of the Vault\r\n  /// @param _underlying underlying of the Vault eg USDC\r\n  function setVaultChainAddress(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    address _address,\r\n    address _underlying\r\n  ) external onlyDao {\r\n    vaults[_vaultNumber].vaultChainAddress[_chainId] = _address;\r\n    vaults[_vaultNumber].vaultUnderlyingAddress[_chainId] = _underlying;\r\n  }\r\n\r\n  /// @notice Setter for xProvider address\r\n  /// @param _xProvider new address of xProvider on this chain\r\n  function setHomeXProvider(address _xProvider) external onlyDao {\r\n    xProvider = IXProvider(_xProvider);\r\n  }\r\n\r\n  /// @notice Setter for homeChain Id\r\n  /// @param _homeChainId New home chainId\r\n  function setHomeChainId(uint32 _homeChainId) external onlyDao {\r\n    homeChain = _homeChainId;\r\n  }\r\n\r\n  /// @notice Setter for DAO address\r\n  /// @param _dao DAO address\r\n  function setDao(address _dao) external onlyDao {\r\n    dao = _dao;\r\n  }\r\n\r\n  /// @notice Setter for guardian address\r\n  /// @param _guardian new address of the guardian\r\n  function setGuardian(address _guardian) external onlyDao {\r\n    guardian = _guardian;\r\n  }\r\n\r\n  /// @notice Setter for new game address\r\n  /// @param _game New address of the game\r\n  function setGame(address _game) external onlyDao {\r\n    game = _game;\r\n  }\r\n\r\n  /// @notice Setter for minumum amount to send xchain\r\n  /// @param _amount New minimum amount\r\n  function setMinimumAmount(int256 _amount) external onlyDao {\r\n    minimumAmount = _amount;\r\n  }\r\n\r\n  /*\r\n  Only Guardian functions\r\n  */\r\n\r\n  /// @notice Setter for chainId array\r\n  /// @param _chainIds array of all the used chainIds\r\n  function setChainIds(uint32[] memory _chainIds) external onlyGuardian {\r\n    chainIds = _chainIds;\r\n  }\r\n\r\n  /// @notice Resets all stages in vaultStage struct for a vaultNumber\r\n  /// @notice Must be run when a new vaultNumber is deployed\r\n  /// @dev onlyGuardian modifier so the dao can reset all stages for a vaultNumber incase something goes wrong\r\n  function resetVaultStagesDao(uint256 _vaultNumber) external onlyGuardian {\r\n    return resetVaultStages(_vaultNumber);\r\n  }\r\n\r\n  /// @notice Step 1: Guardian function\r\n  function receiveAllocationsFromGameGuard(\r\n    uint256 _vaultNumber,\r\n    int256[] memory _deltas\r\n  ) external onlyGuardian {\r\n    return receiveAllocationsFromGameInt(_vaultNumber, _deltas);\r\n  }\r\n\r\n  /// @notice Step 2: Guardian function\r\n  function setTotalUnderlyingGuard(\r\n    uint256 _vaultNumber,\r\n    uint32 _chainId,\r\n    uint256 _underlying,\r\n    uint256 _totalSupply,\r\n    uint256 _withdrawalRequests\r\n  ) external onlyGuardian {\r\n    return\r\n      setTotalUnderlyingInt(_vaultNumber, _chainId, _underlying, _totalSupply, _withdrawalRequests);\r\n  }\r\n\r\n  /// @notice Step 4: Guardian function\r\n  function setFundsReceivedGuard(\r\n    uint256 _vaultNumber,\r\n    uint256 _fundsReceived\r\n  ) external onlyGuardian {\r\n    vaultStage[_vaultNumber].fundsReceived = _fundsReceived;\r\n  }\r\n\r\n  /// @notice Guardian setter for number of active vaults for vaultNumber, set in xChainRebalance\r\n  function setActiveVaultsGuard(uint256 _vaultNumber, uint256 _activeVaults) external onlyGuardian {\r\n    vaultStage[_vaultNumber].activeVaults = _activeVaults;\r\n  }\r\n\r\n  /// @notice Guardian setter for stage 0:\r\n  function setReadyGuard(uint256 _vaultNumber, bool _state) external onlyGuardian {\r\n    vaultStage[_vaultNumber].ready = _state;\r\n  }\r\n\r\n  /// @notice Guardian setter for stage 1:\r\n  function setAllocationsReceivedGuard(uint256 _vaultNumber, bool _state) external onlyGuardian {\r\n    vaultStage[_vaultNumber].allocationsReceived = _state;\r\n  }\r\n\r\n  /// @notice Guardian setter to tick up stage 2:\r\n  function setUnderlyingReceivedGuard(\r\n    uint256 _vaultNumber,\r\n    uint256 _underlyingReceived\r\n  ) external onlyGuardian {\r\n    vaultStage[_vaultNumber].underlyingReceived = _underlyingReceived;\r\n  }\r\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/MainVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"./Vault.sol\";\n\nimport \"./Interfaces/IXProvider.sol\";\n\ncontract MainVault is Vault, VaultToken {\n  using SafeERC20 for IERC20;\n\n  struct UserInfo {\n    // amount in vaultCurrency the vault owes to the user\n    uint256 withdrawalAllowance;\n    // rebalancing period the withdrawal request is made\n    uint256 withdrawalRequestPeriod;\n    // amount in vaultCurrency the vault owes to the user\n    uint256 rewardAllowance;\n    // rebalancing period the reward request is made\n    uint256 rewardRequestPeriod;\n  }\n\n  address public derbyToken;\n  address public game;\n  address public xProvider;\n\n  bool public vaultOff;\n  // True when rewards should be swapped to derby tokens\n  bool public swapRewards;\n\n  // total amount of withdrawal requests for the vault to pull extra during a cross-chain rebalance, will be upped when a user makes a withdrawalRequest\n  // during a cross-chain rebalance the vault will pull extra funds by the amount of totalWithdrawalRequests and the totalWithdrawalRequests will turn into actual reservedFunds\n  uint256 internal totalWithdrawalRequests;\n  uint256 public exchangeRate;\n  uint32 public homeChain;\n  uint256 public amountToSendXChain;\n  uint256 public governanceFee; // Basis points\n  uint256 public maxDivergenceWithdraws;\n\n  string internal allowanceError = \"!Allowance\";\n\n  // (userAddress => userInfo struct)\n  mapping(address => UserInfo) internal userInfo;\n\n  // training\n  bool private training;\n  uint256 private maxTrainingDeposit;\n  mapping(address => bool) private whitelist;\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    uint256 _vaultNumber,\n    address _dao,\n    address _game,\n    address _controller,\n    address _vaultCurrency,\n    uint256 _uScale\n  )\n    VaultToken(_name, _symbol, _decimals)\n    Vault(_vaultNumber, _dao, _controller, _vaultCurrency, _uScale)\n  {\n    exchangeRate = _uScale;\n    game = _game;\n    governanceFee = 0;\n    maxDivergenceWithdraws = 1_000_000;\n  }\n\n  modifier onlyXProvider() {\n    require(msg.sender == xProvider, \"only xProvider\");\n    _;\n  }\n\n  modifier onlyWhenVaultIsOn() {\n    require(state == State.Idle, \"Rebalancing\");\n    require(!vaultOff, \"Vault is off\");\n    _;\n  }\n\n  modifier onlyWhenIdle() {\n    require(state == State.Idle, \"Rebalancing\");\n    _;\n  }\n\n  modifier onlyGame() {\n    require(msg.sender == game, \"only game\");\n    _;\n  }\n\n  event PushTotalUnderlying(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _underlying,\n    uint256 _totalSupply,\n    uint256 _withdrawalRequests\n  );\n  event RebalanceXChain(uint256 _vaultNumber, uint256 _amount, address _asset);\n  event PushedRewardsToGame(uint256 _vaultNumber, uint32 _chain, int256[] _rewards);\n\n  /// @notice Deposit in Vault\n  /// @dev Deposit VaultCurrency to Vault and mint LP tokens\n  /// @param _amount Amount to deposit\n  /// @param _receiver Receiving adress for the tokens\n  /// @return shares Tokens received by buyer\n  function deposit(\n    uint256 _amount,\n    address _receiver\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 shares) {\n    if (training) {\n      require(whitelist[msg.sender]);\n      uint256 balanceSender = (balanceOf(msg.sender) * exchangeRate) / (10 ** decimals());\n      require(_amount + balanceSender <= maxTrainingDeposit);\n    }\n\n    uint256 balanceBefore = getVaultBalance() - reservedFunds;\n    vaultCurrency.safeTransferFrom(msg.sender, address(this), _amount);\n    uint256 balanceAfter = getVaultBalance() - reservedFunds;\n\n    uint256 amount = balanceAfter - balanceBefore;\n    shares = (amount * (10 ** decimals())) / exchangeRate;\n\n    _mint(_receiver, shares);\n  }\n\n  /// @notice Withdraw from Vault\n  /// @dev Withdraw VaultCurrency from Vault and burn LP tokens\n  /// @param _amount Amount to withdraw in LP tokens\n  /// @param _receiver Receiving adress for the vaultcurrency\n  /// @return value Amount received by seller in vaultCurrency\n  function withdraw(\n    uint256 _amount,\n    address _receiver,\n    address _owner\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 value) {\n    value = (_amount * exchangeRate) / (10 ** decimals());\n\n    require(value > 0, \"!value\");\n\n    require(getVaultBalance() - reservedFunds >= value, \"!funds\");\n\n    _burn(msg.sender, _amount);\n    transferFunds(_receiver, value);\n  }\n\n  /// @notice Withdrawal request for when the vault doesnt have enough funds available\n  /// @dev Will give the user allowance for his funds and pulls the extra funds at the next rebalance\n  /// @param _amount Amount to withdraw in LP token\n  function withdrawalRequest(\n    uint256 _amount\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.withdrawalRequestPeriod == 0, \"Already a request\");\n\n    value = (_amount * exchangeRate) / (10 ** decimals());\n\n    _burn(msg.sender, _amount);\n\n    user.withdrawalAllowance = value;\n    user.withdrawalRequestPeriod = rebalancingPeriod;\n    totalWithdrawalRequests += value;\n  }\n\n  /// @notice Withdraw the allowance the user requested on the last rebalancing period\n  /// @dev Will send the user funds and reset the allowance\n  function withdrawAllowance() external nonReentrant onlyWhenIdle returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.withdrawalAllowance > 0, allowanceError);\n    require(rebalancingPeriod > user.withdrawalRequestPeriod, \"Funds not arrived\");\n\n    value = user.withdrawalAllowance;\n    value = checkForBalance(value);\n\n    reservedFunds -= value;\n    delete user.withdrawalAllowance;\n    delete user.withdrawalRequestPeriod;\n\n    transferFunds(msg.sender, value);\n  }\n\n  /// @notice Substract governance fee from value\n  /// @param _receiver Receiving adress for the vaultcurrency\n  /// @param _value Amount received by seller in vaultCurrency\n  function transferFunds(address _receiver, uint256 _value) internal {\n    uint256 govFee = (_value * governanceFee) / 10_000;\n\n    vaultCurrency.safeTransfer(getDao(), govFee);\n    vaultCurrency.safeTransfer(_receiver, _value - govFee);\n  }\n\n  /// @notice Function for the game to set a withdrawalRequest for the rewards of the game user\n  /// @param _value Amount to set a request in vaultCurrency\n  /// @param _user Address of the user\n  function redeemRewardsGame(\n    uint256 _value,\n    address _user\n  ) external onlyGame nonReentrant onlyWhenVaultIsOn {\n    UserInfo storage user = userInfo[_user];\n    require(user.rewardAllowance == 0, allowanceError);\n\n    user.rewardAllowance = _value;\n    user.rewardRequestPeriod = rebalancingPeriod;\n    totalWithdrawalRequests += _value;\n  }\n\n  /// @notice Withdraw the reward allowance set by the game with redeemRewardsGame\n  /// @dev Will swap vaultCurrency to Derby tokens, send the user funds and reset the allowance\n  function withdrawRewards() external nonReentrant onlyWhenIdle returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.rewardAllowance > 0, allowanceError);\n    require(rebalancingPeriod > user.rewardRequestPeriod, \"!Funds\");\n\n    value = user.rewardAllowance;\n    value = checkForBalance(value);\n\n    reservedFunds -= value;\n    delete user.rewardAllowance;\n    delete user.rewardRequestPeriod;\n\n    if (swapRewards) {\n      uint256 tokensReceived = Swap.swapTokensMulti(\n        Swap.SwapInOut(value, address(vaultCurrency), derbyToken),\n        controller.getUniswap"
    }
  ]
}