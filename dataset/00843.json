{
  "Title": "M-1: Adjusting \"_I_\" will create a sandwich opportunity because of price changes",
  "Content": "# Issue M-1: Adjusting \"_I_\" will create a sandwich opportunity because of price changes \n\nSource: https://github.com/sherlock-audit/2023-12-dodo-gsp-judging/issues/40 \n\n## Found by \nBandit, cergyk, mstpr-brainbot\n## Summary\nAdjusting the value of \"I\" directly influences the price. This can be exploited by a MEV bot, simply by trading just before the \"adjustPrice\" function and exiting right after the price change. The profit gained from this operation essentially represents potential losses for the liquidity providers who supplied liquidity to the pool.\n## Vulnerability Detail\nAs we can see in the docs, the \"_I_\" is the \"i\" value in here and it is directly related with the output amount a trader will receive when selling a quote/base token:\n<img width=\"581\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-12-dodo-gsp-mstpr/assets/120012681/61930727-f8d0-4f47-8712-32d6ada95334\">\n\nSince the price will change, the MEV bot can simply sandwich the tx. Here an example how it can be executed by a MEV bot:\n\n```solidity\nfunction test_Adjusting_I_CanBeFrontrunned() external {\n        vm.startPrank(tapir);\n\n        //  Buy shares with tapir, 10 - 10\n        dai.safeTransfer(address(gsp), 10 * 1e18);\n        usdc.transfer(address(gsp), 10 * 1e6);\n        gsp.buyShares(tapir);\n\n        // print some stuff\n        console.log(\"Base target initial\", gsp._BASE_TARGET_());\n        console.log(\"Quote target initial\", gsp._QUOTE_TARGET_());\n        console.log(\"Base reserve initial\", gsp._BASE_RESERVE_());\n        console.log(\"Quote reserve initial\", gsp._QUOTE_RESERVE_());\n        \n        // we know the price will decrease so lets sell the base token before that\n        uint256 initialBaseTokensSwapped = 5 * 1e18;\n\n        // sell the base tokens before adjustPrice\n        dai.safeTransfer(address(gsp), initialBaseTokensSwapped);\n        uint256 receivedQuoteTokens = gsp.sellBase(tapir);\n        vm.stopPrank();\n\n        // this is the tx will be sandwiched by the MEV trader\n        vm.prank(MAINTAINER);\n        gsp.adjustPrice(999000);\n\n        // quickly resell whatever gained by the price update\n        vm.startPrank(tapir);\n        usdc.safeTransfer(address(gsp), receivedQuoteTokens);\n        uint256 receivedBaseTokens = gsp.sellQuote(tapir);\n        console.log(\"Base target\", gsp._BASE_TARGET_());\n        console.log(\"Quote target\", gsp._QUOTE_TARGET_());\n        console.log(\"Base reserve\", gsp._BASE_RESERVE_());\n        console.log(\"Quote reserve\", gsp._QUOTE_RESERVE_());\n        console.log(\"Received base tokens\", receivedBaseTokens);\n\n        // NOTE: the LP fee and MT FEE is set for this example, so this is not an rough assumption\n        // where fees are 0. Here the fees set for both of the values (default values):\n        // uint256 constant LP_FEE_RATE = 10000000000000;\n        // uint256 constant MT_FEE_RATE = 10000000000000;\n\n        // whatever we get is more than we started, in this example\n        // MEV trader started 5 DAI and we have more than 5 DAI!!\n        assertGe(receivedBaseTokens, initialBaseTokensSwapped);\n    }\n```\nTest result and logs:\n<img width=\"435\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-12-dodo-gsp-mstpr/assets/120012681/2c90a84e-7fba-47ef-8fe9-bbcd36a65268\">\n\nAfter the sandwich, we can see that the MEV bot's DAI amount exceeds its initial DAI balance (profits). Additionally, the reserves for both base and quote tokens are less than the initial 10 tokens deposited by the tapir (only LP). The profit gained by the MEV bot essentially translates to a loss for the tapir.\n\nAnother note on this is that even though the `adjustPrice` called by MAINTAINER without getting frontrunned, it still creates a big price difference which requires immediate arbitrages. Usually these type of parameter changes that impacts the trades are setted by time via ramping to mitigate the unfair advantages that it can occur during the price update.\n## Impact\nMedium since the adjusting price is a privileged role and it is not frequently used. However, this tx can be frontrunnable easily as we see in the PoC which would result in loss of funds. Although the admins are trusted this is not about admin being trustworthy. This is basically a common DeFi parameter change thread and should be well awared. For example, in curve/yeth/balancer contracts the ramp factors are changed via async slow update. It doesn't changes its value immediately but rather does this update slowly by every sec. For example we can see here in the yETH contract that the changing a parameter which determines the trades of users is updated slowly rather than one go:\nhttps://github.com/yearn/yETH/blob/8d831fd6b4de9f004d419f035cd2806dc8d5cf7e/contracts/Pool.vy#L983-L997\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-12-dodo-gsp/blob/af43d39f6a89e5084843e196fc0185abffe6304d/dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPVault.sol#L169-L174\nhttps://github.com/sherlock-audit/2023-12-dodo-gsp/blob/af43d39f6a89e5084843e196fc0185abffe6304d/dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPTrader.sol#L40-L113\n## Tool used\n\nManual Review\n\n## Recommendation\nAcknowledge the issue and use private RPC's to eliminate front-running or slowly ramp up the \"I\" so that the arbitrage opportunity is fair\n\n\n\n## Discussion\n\n**Skyewwww**\n\nWe think this is normal arbitrage behavior and not a bug.\n\n**nevillehuang**\n\n@Skyewwww Since this wasn't mention as an intended known risk, I will maintain as medium severity.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/135",
  "Code": [
    {
      "filename": "contracts/Pool.vy",
      "content": "# @version 0.3.7\n\"\"\"\n@title yETH weighted stableswap pool\n@author 0xkorin, Yearn Finance\n@license GNU AGPLv3\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\ninterface ERC20Ext:\n    def decimals() -> uint8: view\n\ninterface RateProvider:\n    def rate(_asset: address) -> uint256: view\n\ninterface PoolToken:\n    def mint(_account: address, _value: uint256): nonpayable\n    def burn(_account: address, _value: uint256): nonpayable\n\ntoken: public(immutable(address))\nsupply: public(uint256)\namplification: public(uint256) # A f^n\nstaking: public(address)\nnum_assets: public(uint256)\nassets: public(address[MAX_NUM_ASSETS])\nrate_providers: public(address[MAX_NUM_ASSETS])\npacked_vbs: uint256[MAX_NUM_ASSETS] # x_i = b_i r_i (96) | r_i (80) | w_i (20) | target w_i (20) | lower (20) | upper (20)\nmanagement: public(address)\npending_management: public(address)\nguardian: public(address)\npaused: public(bool)\nkilled: public(bool)\nswap_fee_rate: public(uint256)\nramp_step: public(uint256)\nramp_last_time: public(uint256)\nramp_stop_time: public(uint256)\ntarget_amplification: public(uint256)\npacked_pool_vb: uint256 # vb_prod (128) | vb_sum (128)\n# vb_prod: pi, product term `product((w_i * D / x_i)^(w_i n))`\n# vb_sum: sigma, sum term `sum(x_i)`\n\nevent Swap:\n    account: indexed(address)\n    receiver: address\n    asset_in: indexed(uint256)\n    asset_out: indexed(uint256)\n    amount_in: uint256\n    amount_out: uint256\n\nevent AddLiquidity:\n    account: indexed(address)\n    receiver: indexed(address)\n    amounts_in: DynArray[uint256, MAX_NUM_ASSETS]\n    lp_amount: uint256\n\nevent RemoveLiquidity:\n    account: indexed(address)\n    receiver: indexed(address)\n    lp_amount: uint256\n\nevent RemoveLiquiditySingle:\n    account: indexed(address)\n    receiver: indexed(address)\n    asset: indexed(uint256)\n    amount_out: uint256\n    lp_amount: uint256\n\nevent RateUpdate:\n    asset: indexed(uint256)\n    rate: uint256\n\nevent Pause:\n    account: indexed(address)\n\nevent Unpause:\n    account: indexed(address)\n\nevent Kill: pass\n\nevent AddAsset:\n    index: uint256\n    asset: address\n    rate_provider: address\n    rate: uint256\n    weight: uint256\n    amount: uint256\n\nevent SetSwapFeeRate:\n    rate: uint256\n\nevent SetWeightBand:\n    asset: indexed(uint256)\n    lower: uint256\n    upper: uint256\n\nevent SetRateProvider:\n    asset: uint256\n    rate_provider: address\n\nevent SetRamp:\n    amplification: uint256\n    weights: DynArray[uint256, MAX_NUM_ASSETS]\n    duration: uint256\n    start: uint256\n\nevent SetRampStep:\n    ramp_step: uint256\n\nevent StopRamp: pass\n\nevent SetStaking:\n    staking: address\n\nevent PendingManagement:\n    management: address\n\nevent SetManagement:\n    management: address\n\nevent SetGuardian:\n    acount: indexed(address)\n    guardian: address\n\nPRECISION: constant(uint256) = 1_000_000_000_000_000_000\nMAX_NUM_ASSETS: constant(uint256) = 32\nALL_ASSETS_FLAG: constant(uint256) = 14528991250861404666834535435384615765856667510756806797353855100662256435713 # sum((i+1) << 8*i)\nPOOL_VB_MASK: constant(uint256) = 2**128 - 1\nPOOL_VB_SHIFT: constant(int128) = -128\n\nVB_MASK: constant(uint256) = 2**96 - 1\nRATE_MASK: constant(uint256) = 2**80 - 1\nRATE_SHIFT: constant(int128) = -96\nPACKED_WEIGHT_SHIFT: constant(int128) = -176\n\nWEIGHT_SCALE: constant(uint256) = 1_000_000_000_000\nWEIGHT_MASK: constant(uint256) = 2**20 - 1\nTARGET_WEIGHT_SHIFT: constant(int128) = -20\nLOWER_BAND_SHIFT: constant(int128) = -40\nUPPER_BAND_SHIFT: constant(int128) = -60\n\n# powers of 10\nE3: constant(int256)               = 1_000\nE6: constant(int256)               = E3 * E3\nE9: constant(int256)               = E3 * E6\nE12: constant(int256)              = E3 * E9\nE15: constant(int256)              = E3 * E12\nE17: constant(int256)              = 100 * E15\nE18: constant(int256)              = E3 * E15\nE20: constant(int256)              = 100 * E18\nE36: constant(int256)              = E18 * E18\nMAX_POW_REL_ERR: constant(uint256) = 100 # 1e-16\nMIN_NAT_EXP: constant(int256)      = -41 * E18\nMAX_NAT_EXP: constant(int256)      = 130 * E18\nLOG36_LOWER: constant(int256)      = E18 - E17\nLOG36_UPPER: constant(int256)      = E18 + E17\nMILD_EXP_BOUND: constant(uint256)  = 2**254 / 100_000_000_000_000_000_000\n\n# x_n = 2^(7-n), a_n = exp(x_n)\n# in 20 decimals for n >= 2\nX0: constant(int256)  = 128 * E18 # 18 decimals\nA0: constant(int256)  = 38_877_084_059_945_950_922_200 * E15 * E18 # no decimals\nX1: constant(int256)  = X0 / 2 # 18 decimals\nA1: constant(int256)  = 6_235_149_080_811_616_882_910 * E6 # no decimals\nX2: constant(int256)  = X1 * 100 / 2\nA2: constant(int256)  = 7_896_296_018_268_069_516_100 * E12\nX3: constant(int256)  = X2 / 2\nA3: constant(int256)  = 888_611_052_050_787_263_676 * E6\nX4: constant(int256)  = X3 / 2\nA4: constant(int256)  = 298_095_798_704_172_827_474 * E3\nX5: constant(int256)  = X4 / 2\nA5: constant(int256)  = 5_459_815_003_314_423_907_810\nX6: constant(int256)  = X5 / 2\nA6: constant(int256)  = 738_905_609_893_065_022_723\nX7: constant(int256)  = X6 / 2\nA7: constant(int256)  = 271_828_182_845_904_523_536\nX8: constant(int256)  = X7 / 2\nA8: constant(int256)  = 164_872_127_070_012_814_685\nX9: constant(int256)  = X8 / 2\nA9: constant(int256)  = 128_402_541_668_774_148_407\nX10: constant(int256) = X9 / 2\nA10: constant(int256) = 11_331_4845_306_682_631_683\nX11: constant(int256) = X10 / 2\nA11: constant(int256) = 1_064_49_445_891_785_942_956\n\n@external\ndef __init__(\n    _token: address, \n    _amplification: uint256,\n    _assets: DynArray[address, MAX_NUM_ASSETS], \n    _rate_providers: DynArray[address, MAX_NUM_ASSETS], \n    _weights: DynArray[uint256, MAX_NUM_ASSETS]\n):\n    \"\"\"\n    @notice Constructor\n    @param _token The address of the pool LP token\n    @param _amplification The pool amplification factor (in 18 decimals)\n    @param _assets Array of addresses of tokens in the pool\n    @param _rate_providers Array of addresses of rate provider for each asset\n    @param _weights Weight of each asset (in 18 decimals)\n    @dev Only non-rebasing assets with 18 decimals are supported\n    @dev Weights need to sum to unity\n    \"\"\"\n    num_assets: uint256 = len(_assets)\n    assert num_assets >= 2\n    assert len(_rate_providers) == num_assets and len(_weights) == num_assets\n    assert _token != empty(address)\n    assert _amplification > 0\n\n    token = _token\n    self.amplification = _amplification\n    self.num_assets = num_assets\n    \n    weight_sum: uint256 = 0\n    for asset in range(MAX_NUM_ASSETS):\n        if asset == num_assets:\n            break\n        assert _assets[asset] != empty(address)\n        assert ERC20Ext(_assets[asset]).decimals() == 18\n        self.assets[asset] = _assets[asset]\n        assert _rate_providers[asset] != empty(address)\n        self.rate_providers[asset] = _rate_providers[asset]\n        assert _weights[asset] > 0\n        packed_weight: uint256 = self._pack_weight(_weights[asset], _weights[asset], PRECISION, PRECISION)\n        self.packed_vbs[asset] = self._pack_vb(0, 0, packed_weight)\n        weight_sum += _weights[asset]\n    assert weight_sum == PRECISION\n\n    self.ramp_step = 1\n    self.management = msg.sender\n    self.guardian = msg.sender\n\n@external\n@nonreentrant('lock')\ndef swap(\n    _i: uint256, \n    _j: uint256, \n    _dx: uint256, \n    _min_dy: uint256, \n    _receiver: address = msg.sender\n) -> uint256:\n    \"\"\"\n    @notice Swap one pool asset for another\n    @param _i Index of the input asset\n    @param _j Index of the output asset\n    @param _dx Amount of input asset to take from caller\n    @param _min_dy Minimum amount of output asset to send\n    @param _receiver Account to receive the output asset\n    @return The amount of output asset sent\n    \"\"\"\n    num_assets: uint256 = self.num_assets\n    assert _i != _j # dev: same input and output asset\n    assert _i < num_assets and _j < num_assets # dev: index out of bounds\n    assert _dx > 0 # dev: zero amount\n\n    # update rates for from and to assets\n    vb_prod: uint256 = 0\n    vb_sum: uint256 = 0\n    vb_prod, vb_sum = self._unpack_pool_vb(self.packed_pool_vb)\n    vb_prod, vb_sum = self._update_rates(unsafe_add(_i, 1) | shift(unsafe_add(_j, 1), 8), vb_prod, vb_sum)\n    prev_vb_sum: uint256 = vb_sum\n\n    prev_vb_x: uint256 = 0\n    rate_x: uint256 = 0\n    packed_weight_x: uint256 = 0\n    prev_vb_x, rate_x, packed_weight_x = self._unpack_vb(self.packed_vbs[_i])\n    wn_x: uint256 = self._unpack_wn(packed_weight_x, num_assets)\n\n    prev_vb_y: uint256 = 0\n    rate_y: uint256 = 0\n    packed_weight_y: uint256 = 0\n    prev_vb_y, rate_y, packed_weight_y = self._unpack_vb(self.packed_vbs[_j])\n    wn_y: uint256 = self._unpack_wn(packed_weight_y, num_assets)\n\n    dx_fee: uint256 = _dx * self.swap_fee_rate / PRECISION\n    dvb_x: uint256 = (_dx - dx_fee) * rate_x / PRECISION\n    vb_x: uint256 = prev_vb_x + dvb_x\n    \n    # update x_i and remove x_j from variables\n    vb_prod = vb_prod * self._pow_up(prev_vb_y, wn_y) / self._pow_down(vb_x * PRECISION / prev_vb_x, wn_x)\n    vb_sum = vb_sum + dvb_x - prev_vb_y\n\n    # calulate new balance of out token\n    vb_y: uint256 = self._calc_vb(wn_y, prev_vb_y, self.supply, self.amplification, vb_prod, vb_sum)\n    vb_sum += vb_y\n\n    # check bands\n    self._check_bands(prev_vb_x * PRECISION / prev_vb_sum, vb_x * PRECISION / vb_sum, packed_weight_x)\n    self._check_bands(prev_vb_y * PRECISION / prev_vb_sum, vb_y * PRECISION / vb_sum, packed_weight_y)\n\n    dy: uint256 = (prev_vb_y - vb_y) * PRECISION / rate_y\n    assert dy >= _min_dy, \"slippage\"\n\n    if dx_fee > 0:\n        # add fee to pool\n        dvb_x = dx_fee * rate_x / PRECISION\n        vb_prod = vb_prod * PRECISION / self._pow_down((vb_x + dvb_x) * PRECISION / vb_x, wn_x)\n        vb_x += dvb_x\n        vb_sum += dvb_x\n\n    # update variables\n    self.packed_vbs[_i] = self._pack_vb(vb_x, rate_x, packed_weight_x)\n    self.packed_vbs[_j] = self._pack_vb(vb_y, rate_y, packed_weight_y)\n    vb_prod = vb_prod * PRECISION / self._pow_up(vb_y, wn_y)\n    \n    # mint fees\n    if dx_fee > 0:\n        supply: uint256 = 0\n        supply, vb_prod = self._update_supply(self.supply, vb_prod, vb_sum)\n\n    self.packed_pool_vb = self._pack_pool_vb(vb_prod, vb_sum)\n\n    # transfer tokens\n    assert ERC20(self.assets[_i]).transferFrom(msg.sender, self, _dx, default_return_value=True)\n    assert ERC20(self.assets[_j]).transfer(_receiver, dy, default_return_value=True)\n    log Swap(msg.sender, _receiver, _i, _j, _dx, dy)\n\n    return dy\n\n@external\n@nonreentrant('lock')\ndef swap_exact_out(\n    _i: uint256, \n    _j: uint256, \n    _dy: uint256, \n    _max_dx: uint256, \n    _receiver: address = msg.sender\n) -> uint256:\n    \"\"\"\n    @notice Swap one pool asset for another, with a fixed output amount\n    @param _i Index of the input asset\n    @param _j Index of the output asset\n    @param _dy Amount of output asset to send\n    @param _max_dx Maximum amount of input asset to take from caller\n    @param _receiver Account to receive the output asset\n    @return The amount of input asset taken\n    \"\"\"\n    num_assets: uint256 = self.num_assets\n    assert _i != _j # dev: same input and output asset\n    assert _i < num_assets and _j < num_assets # dev: index out of bounds\n    assert _dy > 0 # dev: zero amount\n\n    # update rates for from and to assets\n    vb_prod: uint256 = 0\n    vb_sum: uint256 = 0\n    vb_prod, vb_sum = self._unpack_pool_vb(self.packed_pool_vb)\n    vb_prod, vb_sum = self._update_rates(unsafe_add(_i, 1) | shift(unsafe_add(_j, 1), 8), vb_prod, vb_sum)\n    prev_vb_sum: uint256 = vb_sum\n\n    prev_vb_x: uint256 = 0\n    rate_x: uint256 = 0\n    packed_weight_x: uint256 = 0\n    prev_vb_x, rate_x, packed_weight_x = self._unpack_vb(self.packed_vbs[_i])\n    wn_x: uint256 = self._unpack_wn(packed_weight_x, num_assets)\n\n    prev_vb_y: uint256 = 0\n    rate_y: uint256 = 0\n    packed_weight_y: uint256 = 0\n    prev_vb_y, rate_y, packed_weight_y = self._unpack_vb(self.packed_vbs[_j])\n    wn_y: uint256 = self._unpack_wn(packed_weight_y, num_assets)\n\n    dvb_y: uint256 = _dy * rate_y / PRECISION\n    vb_y: uint256 = prev_vb_y - dvb_y\n\n    # update x_j and remove x_i from variables\n    vb_prod = vb_prod * self._pow_up(prev_vb_x, wn_x) / self._pow_down(vb_y * PRECISION / prev_vb_y, wn_y)\n    vb_sum = vb_sum - dvb_y - prev_vb_x\n\n    # calulate new balance of in token\n    vb_x: uint256 = self._calc_vb(wn_x, prev_vb_x, self.supply, self.amplification, vb_prod, vb_sum)\n    dx: uint256 = (vb_x - prev_vb_x) * PRECISION / rate_x\n    dx_fee: uint256 = self.swap_fee_rate\n    dx_fee = dx * dx_fee / (PRECISION - dx_fee)\n    dx += dx_fee\n    vb_x += dx_fee * rate_x / PRECISION\n    vb_sum += vb_x\n    assert dx <= _max_dx, \"slippage\"\n\n    # check bands\n    self._check_bands(prev_vb_x * PRECISION / prev_vb_sum, vb_x * PRECISION / vb_sum, packed_weight_x)\n    self._check_bands(prev_vb_y * PRECISION / prev_vb_sum, vb_y * PRECISION / vb_sum, packed_weight_y)\n\n    # update variables\n    self.packed_vbs[_i] = self._pack_vb(vb_x, rate_x, packed_weight_x)\n    self.packed_vbs[_j] = self._pack_vb(vb_y, rate_y, packed_weight_y)\n    vb_prod = vb_prod * PRECISION / self._pow_up(vb_x, wn_x)\n\n    # mint fees\n    if dx_fee > 0:\n        supply: uint256 = 0\n        supply, vb_prod = self._update_supply(self.supply, vb_prod, vb_sum)\n\n    self.packed_pool_vb = self._pack_pool_vb(vb_prod, vb_sum)\n\n    assert ERC20(self.assets[_i]).transferFrom(msg.sender, self, dx, default_return_value=True)\n    assert ERC20(self.assets[_j]).transfer(_receiver, _dy, default_return_value=True)\n    log Swap(msg.sender, _receiver, _i, _j, dx, _dy)\n\n    return dx\n\n@external\n@nonreentrant('lock')\ndef add_liquidity(\n    _amounts: DynArray[uint256, MAX_NUM_ASSETS], \n    _min_lp_amount: uint256, \n    _receiver: address = msg.sender\n) -> uint256:\n    \"\"\"\n    @notice Deposit assets into the pool\n    @param _amounts Array of amount for each asset to take from caller\n    @param _min_lp_amount Minimum amount of LP tokens to mint\n    @param _receiver Account to receive the LP tokens\n    @return The amount of LP tokens minted\n    \"\"\"\n    num_assets: uint256 = self.num_assets\n    assert len(_amounts) == num_assets\n\n    vb_prod: uint256 = 0\n    vb_sum: uint256 = 0\n    vb_prod, vb_sum = self._unpack_pool_vb(self.packed_pool_vb)\n\n    prev_vb: uint256 = 0\n    rate: uint256 = 0\n    packed_weight: uint256 = 0\n\n    # find lowest relative increase in balance\n    assets: uint256 = 0\n    lowest: uint256 = max_value(uint256)\n    sh: int128 = 0\n    for asset in range(MAX_NUM_ASSETS):\n        if asset == num_assets:\n            break\n        if _amounts[asset] > 0:\n            assets = assets | shift(unsafe_add(asset, 1), sh)\n            sh = unsafe_add(sh, 8)\n            if vb_sum > 0 and lowest > 0:\n                prev_vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[asset])\n                lowest = min(_amounts[asset] * rate / prev_vb, lowest)\n        else:\n            lowest = 0\n    assert sh > 0 # dev: need to deposit at least one asset\n\n    # update rates\n    vb_prod, vb_sum = self._update_rates(assets, vb_prod, vb_sum)\n    prev_supply: uint256 = self.supply\n\n    vb_prod_final: uint256 = vb_prod\n    vb_sum_final: uint256 = vb_sum\n    fee_rate: uint256 = self.swap_fee_rate / 2\n    prev_vb_sum: uint256 = vb_sum\n    prev_ratios: DynArray[uint256, MAX_NUM_ASSETS] = []\n    vb: uint256 = 0\n    for asset in range(MAX_NUM_ASSETS):\n        if asset == num_assets:\n            break\n\n        amount: uint256 = _amounts[asset]\n        if amount == 0:\n            assert prev_supply > 0 # dev: initial deposit amounts must be non-zero\n            continue\n\n        # update stored virtual balance\n        prev_vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[asset])\n        dvb: uint256 = amount * rate / PRECISION\n        vb = prev_vb + dvb\n        self.packed_vbs[asset] = self._pack_vb(vb, rate, packed_weight)\n\n        if prev_supply > 0:\n            prev_ratios.append(prev_vb * PRECISION / prev_vb_sum)\n            wn: uint256 = self._unpack_wn(packed_weight, num_assets)\n\n            # update product and sum of virtual balances\n            vb_prod_final = vb_prod_final * self._pow_up(prev_vb * PRECISION / vb, wn) / PRECISION\n            # the `D^n` factor will be updated in `_calc_supply()`\n            vb_sum_final += dvb\n\n            # remove fees from balance and recalculate sum and product\n            fee: uint256 = (dvb - prev_vb * lowest / PRECISION) * fee_rate / PRECISION\n            vb_prod = vb_prod * self._pow_up(prev_vb * PRECISION / (vb - fee), wn) / PRECISION\n            vb_sum += dvb - fee\n        assert ERC20(self.assets[asset]).transferFrom(msg.sender, self, amount, default_return_value=True)\n\n    supply: uint256 = prev_supply\n    if prev_supply == 0:\n        # initital deposit, calculate necessary variables\n        vb_prod, vb_sum = self._calc_vb_prod_sum()\n        assert vb_prod > 0 # dev: amounts must be non-zero\n        supply = vb_sum\n    else:\n        # check bands\n        j: uint256 = 0\n        for asset in range(MAX_NUM_ASSETS):\n            if asset == num_assets:\n                break\n            if _amounts[asset] == 0:\n                continue\n            vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[asset])\n            self._check_bands(prev_ratios[j], vb * PRECISION / vb_sum_final, packed_weight)\n            j = unsafe_add(j, 1)\n\n    # mint LP tokens\n    supply, vb_prod = self._calc_supply(num_assets, supply, self.amplification, vb_prod, vb_sum, prev_supply == 0)\n    mint: uint256 = supply - prev_supply\n    assert mint > 0 and mint >= _min_lp_amount, \"slippage\"\n    PoolToken(token).mint(_receiver, mint)\n    log AddLiquidity(msg.sender, _receiver, _amounts, mint)\n\n    supply_final: uint256 = supply\n    if prev_supply > 0:\n        # mint fees\n        supply_final, vb_prod_final = self._calc_supply(num_assets, prev_supply, self.amplification, vb_prod_final, vb_sum_final, True)\n        PoolToken(token).mint(self.staking, supply_final - supply)\n    else:\n        vb_prod_final = vb_prod\n        vb_sum_final = vb_sum\n\n    self.supply = supply_final\n    self.packed_pool_vb = self._pack_pool_vb(vb_prod_final, vb_sum_final)\n\n    return mint\n\n@external\n@nonreentrant('lock')\ndef remove_liquidity(\n    _lp_amount: uint256, \n    _min_amounts: DynArray[uint256, MAX_NUM_ASSETS], \n    _receiver: address = msg.sender\n):\n    \"\"\"\n    @notice Withdraw assets from the pool in a balanced manner\n    @param _lp_amount Amount of LP tokens to burn\n    @param _min_amounts Array of minimum amount of each asset to send\n    @param _receiver Account to receive the assets\n    \"\"\"\n    num_assets: uint256 = self.num_assets\n    assert len(_min_amounts) == num_assets\n\n    # update supply\n    prev_supply: uint256 = self.supply\n    supply: uint256 = prev_supply - _lp_amount\n    self.supply = supply\n    PoolToken(token).burn(msg.sender, _lp_amount)\n    log RemoveLiquidity(msg.sender, _receiver, _lp_amount)\n\n    # update necessary variables and transfer assets\n    vb_prod: uint256 = PRECISION\n    vb_sum: uint256 = 0\n\n    prev_vb: uint256 = 0\n    rate: uint256 = 0\n    packed_weight: uint256 = 0\n    for asset in range(MAX_NUM_ASSETS):\n        if asset == num_assets:\n            break\n        prev_vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[asset])\n        weight: uint256 = self._unpack_wn(packed_weight, 1)\n\n        dvb: uint256 = prev_vb * _lp_amount / prev_supply\n        vb: uint256 = prev_vb - dvb\n        self.packed_vbs[asset] = self._pack_vb(vb, rate, packed_weight)\n        \n        vb_prod = unsafe_div(unsafe_mul(vb_prod, self._pow_down(unsafe_div(unsafe_mul(supply, weight), vb), unsafe_mul(weight, num_assets))), PRECISION)\n        vb_sum = unsafe_add(vb_sum, vb)\n\n        amount: uint256 = dvb * PRECISION / rate\n        assert amount >= _min_amounts[asset], \"slippage\"\n        assert ERC20(self.assets[asset]).transfer(_receiver, amount, default_return_value=True)\n\n    self.packed_pool_vb = self._pack_pool_vb(vb_prod, vb_sum)\n\n@external\n@nonreentrant('lock')\ndef remove_liquidity_single(\n    _asset: uint256, \n    _lp_amount: uint256, \n    _min_amount: uint256, \n    _receiver: address = msg.sender\n) -> uint256:\n    \"\"\"\n    @notice Withdraw a single asset from the pool\n    @param _asset Index of the asset to withdraw\n    @param _lp_amount Amount of LP tokens to burn\n    @param _min_amount Minimum amount of asset to send\n    @param _receiver Account to receive the asset\n    @return The amount of asset sent\n    \"\"\"\n    num_assets: uint256 = self.num_assets\n    assert _asset < num_assets # dev: index out of bounds\n\n    # update rate\n    vb_prod: uint256 = 0\n    vb_sum: uint256 = 0\n    vb_prod, vb_sum = self._unpack_pool_vb(self.packed_pool_vb)\n    vb_prod, vb_sum = self._update_rates(unsafe_add(_asset, 1), vb_prod, vb_sum)\n    prev_vb_sum: uint256 = vb_sum\n\n    # update supply\n    prev_supply: uint256 = self.supply\n    supply: uint256 = prev_supply - _lp_amount\n    self.supply = supply\n    PoolToken(token).burn(msg.sender, _lp_amount)\n\n    prev_vb: uint256 = 0\n    rate: uint256 = 0\n    packed_weight: uint256 = 0\n    prev_vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[_asset])\n    wn: uint256 = self._unpack_wn(packed_weight, num_assets)\n\n    # update variables\n    vb_prod = vb_prod * self._pow_up(prev_vb, wn) / PRECISION\n    for i in range(MAX_NUM_ASSETS):\n        if i == num_assets:\n            break\n        vb_prod = vb_prod * supply / prev_supply\n    vb_sum = vb_sum - prev_vb\n\n    # calculate new balance of asset\n    vb: uint256 = self._calc_vb(wn, prev_vb, supply, self.amplification, vb_prod, vb_sum)\n    dvb: uint256 = prev_vb - vb\n    fee: uint256 = dvb * self.swap_fee_rate / 2 / PRECISION\n    dvb -= fee\n    vb += fee\n    dx: uint256 = dvb * PRECISION / rate\n    assert dx > _min_amount, \"slippage\"\n\n    # update variables\n    self.packed_vbs[_asset] = self._pack_vb(vb, rate, packed_weight)\n    vb_prod = vb_prod * PRECISION / self._pow_up(vb, wn)\n    vb_sum = vb_sum + vb\n\n    for asset in range(MAX_NUM_ASSETS):\n        if asset == num_assets:\n            break\n        if asset == _asset:\n            self._check_bands(prev_vb * PRECISION / prev_vb_sum, vb * PRECISION / vb_sum, packed_weight)\n        else:\n            vb_loop: uint256 = 0\n            rate_loop: uint256 = 0\n            packed_weight_loop: uint256 = 0\n            vb_loop, rate_loop, packed_weight_loop = self._unpack_vb(self.packed_vbs[asset])\n            self._check_bands(vb_loop * PRECISION / prev_vb_sum, vb_loop * PRECISION / vb_sum, packed_weight_loop)\n\n    if fee > 0:\n        # mint fee\n        supply, vb_prod = self._update_supply(supply, vb_prod, vb_sum)\n\n    self.packed_pool_vb = self._pack_pool_vb(vb_prod, vb_sum)\n\n    assert ERC20(self.assets[_asset]).transfer(_receiver, dx, default_return_value=True)\n    log RemoveLiquiditySingle(msg.sender, _receiver, _asset, dx, _lp_amount)\n    return dx\n\n@external\ndef update_rates(_assets: DynArray[uint256, MAX_NUM_ASSETS]):\n    \"\"\"\n    @notice Update the stored rate of any of the pool's assets\n    @param _assets Array of indices of assets to update\n    @dev If no assets are passed in, every asset will be updated\n    \"\"\"\n    num_assets: uint256 = self.num_assets\n    assets: uint256 = 0\n    for i in range(MAX_NUM_ASSETS):\n        if i == len(_assets):\n            break\n        assert _assets[i] < num_assets # dev: index out of bounds\n        assets = assets | shift(_assets[i] + 1, unsafe_mul(8, convert(i, int128)))\n\n    if len(_assets) == 0:\n        assets = ALL_ASSETS_FLAG\n    vb_prod: uint256 = 0\n    vb_sum: uint256 = 0\n    vb_prod, vb_sum = self._unpack_pool_vb(self.packed_pool_vb)\n    vb_prod, vb_sum = self._update_rates(assets, vb_prod, vb_sum)\n    self.packed_pool_vb = self._pack_pool_vb(vb_prod, vb_sum)\n\n@external\ndef update_weights() -> bool:\n    \"\"\"\n    @notice Update weights and amplification factor, if possible\n    @return Boolean to indicate whether the weights and amplification factor have been updated\n    @dev Will only update the weights if a ramp is active and at least the minimum time step has been reached\n    \"\"\"\n    assert not self.paused # dev: paused\n    updated: bool = False\n    vb_prod: uint256 = 0\n    vb_sum: uint256 = 0\n    vb_prod, vb_sum = self._unpack_pool_vb(self.packed_pool_vb)\n    vb_prod, updated = self._update_weights(vb_prod)\n    if updated and vb_sum > 0:\n        supply: uint256 = 0\n        supply, vb_prod = self._update_supply(self.supply, vb_prod, vb_sum)\n        self.packed_pool_vb = self._pack_pool_vb(vb_prod, vb_sum)\n    return updated\n\n@external\n@view\ndef vb_prod_sum() -> (uint256, uint256):\n    \"\"\"\n    @notice Get the pool's virtual balance product (pi) and sum (sigma)\n    @return Tuple with product and sum\n    \"\"\"\n    return self._unpack_pool_vb(self.packed_pool_vb)\n\n@external\n@view\ndef virtual_balance(_asset: uint256) -> uint256:\n    \"\"\"\n    @notice Get the virtual balance of an asset\n    @param _asset Index of the asset\n    @return Virtual balance of asset\n    \"\"\"\n    assert _asset < self.num_assets # dev: index out of bounds\n    return self.packed_vbs[_asset] & VB_MASK\n\n@external\n@view\ndef rate(_asset: uint256) -> uint256:\n    \"\"\"\n    @notice Get the rate of an asset\n    @param _asset Index of the asset\n    @return Rate of asset\n    \"\"\"\n    assert _asset < self.num_assets # dev: index out of bounds\n    return shift(self.packed_vbs[_asset], RATE_SHIFT) & RATE_MASK\n\n@external\n@view\ndef weight(_asset: uint256) -> (uint256, uint256, uint256, uint256):\n    \"\"\"\n    @notice Get the weight of an asset\n    @param _asset Index of the asset\n    @return Tuple with weight, target weight, lower band width and upper weight band width\n    @dev Does not take into account any active ramp\n    \"\"\"\n    assert _asset < self.num_assets # dev: index out of bounds\n    weight: uint256 = 0\n    target: uint256 = 0\n    lower: uint256 = 0\n    upper: uint256 = 0\n    weight, target, lower, upper = self._unpack_weight(shift(self.packed_vbs[_asset], PACKED_WEIGHT_SHIFT))\n    if self.ramp_last_time == 0:\n        target = weight\n    return weight, target, lower, upper\n\n@external\n@view\ndef packed_weight(_asset: uint256) -> uint256:\n    \"\"\"\n    @notice Get the packed weight of an asset in a packed format\n    @param _asset Index of the asset\n    @return Weight in packed format\n    @dev Does not take into account any active ramp\n    \"\"\"\n    assert _asset < self.num_assets # dev: index out of bounds\n    return shift(self.packed_vbs[_asset], PACKED_WEIGHT_SHIFT)\n\n# PRIVILEGED FUNCTIONS\n\n@external\ndef pause():\n    \"\"\"\n    @notice Pause the pool\n    \"\"\"\n    assert msg.sender == self.management or msg.sender == self.guardian\n    assert not self.paused # dev: already paused\n    self.paused = True\n    log Pause(msg.sender)\n\n@external\ndef unpause():\n    \"\"\"\n    @notice Unpause the pool\n    \"\"\"\n    assert msg.sender == self.management or msg.sender == self.guardian\n    assert self.paused # dev: not paused\n    assert not self.killed # dev: killed\n    self.paused = False\n    log Unpause(msg.sender)\n\n@external\ndef kill():\n    \"\"\"\n    @notice Kill the pool\n    \"\"\"\n    assert msg.sender == self.management\n    assert self.paused # dev: not paused\n    assert not self.killed # dev: already killed\n    self.killed = True\n    log Kill()\n\n@external\ndef add_asset(\n    _asset: address, \n    _rate_provider: address, \n    _weight: uint256, \n    _lower: uint256, \n    _upper: uint256, \n    _amount: uint256, \n    _amplification: uint256,\n    _min_lp_amount: uint256,\n    _receiver: address = msg.sender\n):\n    \"\"\"\n    @notice Add a new asset to the pool\n    @param _asset Address of the asset to add\n    @param _rate_provider Rate provider for asset\n    @param _weight Weight of the new asset\n    @param _lower Lower band width\n    @param _upper Upper band width\n    @param _amount Amount of tokens\n    @param _amplification New pool amplification factor\n    @param _receiver Account to receive the LP tokens minted\n    @dev Can only be called if no ramp is currently active\n    @dev Every other asset will have their weight reduced pro rata\n    @dev Caller should assure that effective amplification before and after call are the same\n    \"\"\"\n    assert msg.sender == self.management\n\n    assert _amount > 0\n    prev_num_assets: uint256 = self.num_assets\n    assert prev_num_assets < MAX_NUM_ASSETS # dev: pool is full\n    assert _amplification > 0\n    assert self.ramp_last_time == 0 # dev: ramp active\n    assert self.supply > 0 # dev: pool empty\n\n    assert _weight > 0 and _weight <= PRECISION/100\n    assert _lower <= PRECISION\n    assert _upper <= PRECISION\n\n    # update weights for existing assets\n    num_assets: uint256 = prev_num_assets + 1\n    vb: uint256 = 0\n    rate: uint256 = 0\n    packed_weight: uint256 = 0\n    prev_weight: uint256 = 0\n    target: uint256 = 0\n    lower: uint256 = 0\n    upper: uint256 = 0\n    for i in range(MAX_NUM_ASSETS):\n        if i == prev_num_assets:\n            break\n        assert self.assets[i] != _asset # dev: asset already part of pool\n        vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[i])\n        prev_weight, target, lower, upper = self._unpack_weight(packed_weight)\n        packed_weight = self._pack_weight(unsafe_sub(prev_weight, unsafe_div(unsafe_mul(prev_weight, _weight), PRECISION)), target, lower, upper)\n        self.packed_vbs[i] = self._pack_vb(vb, rate, packed_weight)\n    \n    assert ERC20Ext(_asset).decimals() == 18\n    rate = RateProvider(_rate_provider).rate(_asset)\n    assert rate > 0 # dev: no rate\n\n    vb = _amount * rate / PRECISION\n    packed_weight = self._pack_weight(_weight, _weight, _lower, _upper)\n\n    # set parameters for new asset\n    self.num_assets = num_assets\n    self.assets[prev_num_assets] = _asset\n    self.rate_providers[prev_num_assets] = _rate_provider\n    self.packed_vbs[prev_num_assets] = self._pack_vb(vb, rate, packed_weight)\n\n    # recalculate variables\n    vb_prod: uint256 = 0\n    vb_sum: uint256 = 0\n    vb_prod, vb_sum = self._calc_vb_prod_sum()\n\n    # update supply\n    prev_supply: uint256 = self.supply\n    supply: uint256 = 0\n    supply, vb_prod = self._calc_supply(num_assets, vb_sum, _amplification, vb_prod, vb_sum, True)\n\n    self.amplification = _amplification\n    self.supply = supply\n    self.packed_pool_vb = self._pack_pool_vb(vb_prod, vb_sum)\n\n    assert ERC20(_asset).transferFrom(msg.sender, self, _amount, default_return_value=True)\n    assert supply > prev_supply\n    lp_amount: uint256 = unsafe_sub(supply, prev_supply)\n    assert lp_amount >= _min_lp_amount\n    PoolToken(token).mint(_receiver, lp_amount)\n    log AddAsset(prev_num_assets, _asset, _rate_provider, rate, _weight, _amount)\n\n@external\ndef rescue(_token: address, _receiver: address):\n    \"\"\"\n    @notice Rescue tokens from this contract\n    @param _token The token to be rescued\n    @param _receiver Receiver of rescued tokens\n    @dev Can't be used to rescue pool assets\n    \"\"\"\n    assert msg.sender == self.management\n    num_assets: uint256 = self.num_assets\n    for asset in range(MAX_NUM_ASSETS):\n        if asset == num_assets:\n            break\n        assert _token != self.assets[asset] # dev: cant rescue pool asset\n    amount: uint256 = ERC20(_token).balanceOf(self)\n    assert ERC20(_token).transfer(_receiver, amount, default_return_value=True)\n\n@external\ndef skim(_asset: uint256, _receiver: address):\n    \"\"\"\n    @notice Skim surplus of a pool asset\n    @param _asset Index of the asset\n    @param _receiver Receiver of skimmed tokens\n    \"\"\"\n    assert msg.sender == self.management\n    assert _asset < self.num_assets # dev: index out of bounds\n    vb: uint256 = 0\n    rate: uint256 = 0\n    packed_weight: uint256 = 0\n    vb, rate, packed_weight = self._unpack_vb(self.packed_vbs[_asset])\n    expected: uint256 = vb * PRECISION / rate + 1\n    token_: address = self.assets[_asset]\n    actual: uint256 = ERC20(token_).balanceOf(self)\n    assert actual > expected # dev: no surplus\n    assert ERC20(token_).transfer(_receiver, actual - expected, default_return_value=True)\n\n@external\ndef set_swap_fee_rate(_fee_rate: uint256):\n    \"\"\"\n    @notice Set the swap fee rate\n    @param _fee_rate New swap fee rate (in 18 decimals)\n    \"\"\"\n    assert msg.sender == self.management\n    assert _fee_rate <= PRECISION / 100\n    self.swap_fee_rate = _fee_rate\n    log SetSwapFeeRate(_fee_rate)\n\n@external\ndef set_weight_bands(\n    _assets: DynArray[uint256, MAX_NUM_ASSETS], \n    _lower: DynArray[uint256, MAX_NUM_ASSETS], \n    _upper: DynArray[uint256, MAX_NUM_ASSETS]\n):\n    \"\"\"\n    @notice Set safety weight bands\n            If any user operation puts the weight outside of the bands, the transaction will revert\n    @param _assets Array of indices of the assets to set the bands for\n    @param _lower Array of widths of the lower band\n    @param _upper Array of widths of the upper band\n    \"\"\"\n    assert msg.sender == self.management\n    asse"
    }
  ]
}