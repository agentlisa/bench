{
  "Title": "M-3: WrappedAerodromeAM.sol is not compatible with the Revert on Zero Value Tokens",
  "Content": "# Issue M-3: WrappedAerodromeAM.sol is not compatible with the Revert on Zero Value Tokens \n\nSource: https://github.com/sherlock-audit/2024-04-arcadia-pricing-module-judging/issues/23 \n\n## Found by \nblackhole, merlin\n## Summary\nFrom the README file:\nWe also want to receive issues regarding minimal implementations of ERC20 Tokens, which besides a standard implementation have one of the following \"weird behaviours\": `Revert on Zero Value`.\n\n## Vulnerability Detail\nWhen the owner of a position calls `WrappedAerodromeAM.decreaseLiquidity`, they should receive the transferred liquidity back and fees.\n\nLet's consider the following scenario:\n\n1)The owner of the position calls `decreaseLiquidity`, and they are supposed to receive fees.\n```solidity\n        // Claim any pending fees from the Aerodrome Pool.\n        (uint256 fee0Pool, uint256 fee1Pool) = _claimFees(pool);\n\n        // Calculate the new fee balances.\n        (poolState_, positionState_) = _getFeeBalances(poolState_, positionState_, fee0Pool, fee1Pool);\n```\n2)Since the fee for the `revert on zero transfer token` is zero, a DOS will occur, and the user will not be able to decrease liquidity.\n```solidity\n        // Pay out the fees to the position owner.\n        ERC20(token0[pool]).safeTransfer(msg.sender, fee0Position);  //fee0Position = 0\n        ERC20(token1[pool]).safeTransfer(msg.sender, fee1Position); // or fee1Position = 0\n        emit FeesPaid(positionId, uint128(fee0Position), uint128(fee1Position));\n```\n\n## Impact\nA denial-of-service (DOS) can occur on the `decreaseLiquidity` and `claimFees` functions in `WrappedAerodromeAM` smart contract of the revert on zero transfer token when the fee is zero value.\n\n## Code Snippet\n[src/asset-modules/Aerodrome-Finance/WrappedAerodromeAM.sol#L452-L453](https://github.com/sherlock-audit/2024-04-arcadia-pricing-module/blob/main/accounts-v2/src/asset-modules/Aerodrome-Finance/WrappedAerodromeAM.sol#L452-L453)\n[src/asset-modules/Aerodrome-Finance/WrappedAerodromeAM.sol#L411-L412](https://github.com/sherlock-audit/2024-04-arcadia-pricing-module/blob/main/accounts-v2/src/asset-modules/Aerodrome-Finance/WrappedAerodromeAM.sol#L411-L412)\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider changing `decreaseLiquidity` and `claimFees` functions as follows:\n```diff\n+ if (fee0Position != 0)\n            ERC20(token0[pool]).safeTransfer(msg.sender, fee0Position);\n+ if (fee1Position != 0)\n            ERC20(token1[pool]).safeTransfer(msg.sender, fee1Position);\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  this should be valid considering the readMe stated to report issues with the said(weird) behavior; medium(1)\n\n**shealtielanz** commented:\n>  dup of #033\n\n\n\n**sherlock-admin3**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/arcadia-finance/accounts-v2/pull/202\n\n\n**oxwhite**\n\nWhat does \"besides a standard implementation have one of the following \"weird behaviours\": Revert on Zero Value\" mean? What Ä± understand the protocol will not accept any vulnerability related to \"Revert on Zero Value\" and the followings mentioned in ReadMe, which means it is out of scope. How can this submission be valid?\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/321",
  "Code": [
    {
      "filename": "accounts-v2/src/asset-modules/Aerodrome-Finance/WrappedAerodromeAM.sol",
      "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { AssetValuationLib, AssetValueAndRiskFactors } from \"../../libraries/AssetValuationLib.sol\";\nimport { DerivedAM, FixedPointMathLib, IRegistry } from \"../abstracts/AbstractDerivedAM.sol\";\nimport { ERC20 } from \"../../../lib/solmate/src/tokens/ERC20.sol\";\nimport { ERC721 } from \"../../../lib/solmate/src/tokens/ERC721.sol\";\nimport { IAeroPool } from \"./interfaces/IAeroPool.sol\";\nimport { ReentrancyGuard } from \"../../../lib/solmate/src/utils/ReentrancyGuard.sol\";\nimport { SafeCastLib } from \"../../../lib/solmate/src/utils/SafeCastLib.sol\";\nimport { SafeTransferLib } from \"../../../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { Strings } from \"../../libraries/Strings.sol\";\n\n/**\n * @title Asset Module for Wrapped Aerodrome Finance pools\n * @author Pragma Labs\n * @notice The Wrapped Aerodrome Finance Asset Module stores pricing logic and basic information for Wrapped Aerodrome Finance Pools.\n */\ncontract WrappedAerodromeAM is DerivedAM, ERC721, ReentrancyGuard {\n    using FixedPointMathLib for uint256;\n    using Strings for uint256;\n    using SafeCastLib for uint256;\n    using SafeTransferLib for ERC20;\n\n    /* //////////////////////////////////////////////////////////////\n                                STORAGE\n    ////////////////////////////////////////////////////////////// */\n\n    // The id of last minted position.\n    uint256 internal lastPositionId;\n\n    // The baseURI of the ERC721 tokens.\n    string public baseURI;\n\n    // Map a Pool to its corresponding token0.\n    mapping(address pool => address token0) public token0;\n    // Map a Pool to its corresponding token1.\n    mapping(address pool => address token1) public token1;\n    // Map a Pool to its corresponding struct with global state.\n    mapping(address pool => PoolState) public poolState;\n    // Map a position id to its corresponding struct with the position state.\n    mapping(uint256 position => PositionState) public positionState;\n\n    // Struct with the global state per Pool.\n    struct PoolState {\n        // The growth of fees per Pool, at the last interaction with this contract,\n        // with 18 decimals precision.\n        uint128 fee0PerLiquidity;\n        uint128 fee1PerLiquidity;\n        // The total amount of liquidity wrapped.\n        uint128 totalWrapped;\n    }\n\n    // Struct with the Position specific state.\n    struct PositionState {\n        // The growth of fees per Pool, at the last interaction of the position owner with this contract,\n        // with 18 decimals precision.\n        uint128 fee0PerLiquidity;\n        uint128 fee1PerLiquidity;\n        // The unclaimed amount of fees of the position owner, at the last interaction of the owner with this contract.\n        uint128 fee0;\n        uint128 fee1;\n        // Total amount of liquidity wrapped for this position.\n        uint128 amountWrapped;\n        // The contract address of the Pool.\n        address pool;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                EVENTS\n    ////////////////////////////////////////////////////////////// */\n\n    event LiquidityDecreased(uint256 indexed positionId, address indexed pool, uint128 amount);\n    event LiquidityIncreased(uint256 indexed positionId, address indexed pool, uint128 amount);\n    event FeesPaid(uint256 indexed positionId, uint128 fee0, uint128 fee1);\n\n    /* //////////////////////////////////////////////////////////////\n                                ERRORS\n    ////////////////////////////////////////////////////////////// */\n\n    error NotOwner();\n    error PoolNotAllowed();\n    error ZeroAmount();\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @param registry The address of the Registry.\n     * @dev The ASSET_TYPE, necessary for the deposit and withdraw logic in the Accounts, is \"2\" for ERC721 tokens.\n     */\n    constructor(address registry) DerivedAM(registry, 2) ERC721(\"Arcadia Wrapped Aerodrome Positions\", \"aWAEROP\") { }\n\n    /* //////////////////////////////////////////////////////////////\n                               INITIALIZE\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice This function will add this contract as an asset in the Registry.\n     * @dev Will revert if called more than once.\n     */\n    function initialize() external onlyOwner {\n        inAssetModule[address(this)] = true;\n\n        IRegistry(REGISTRY).addAsset(uint96(ASSET_TYPE), address(this));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            ASSET MANAGEMENT\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Adds a new Aerodrome Finance pool to the WrappedAerodromeAM.\n     * @param pool The contract address of the Aerodrome Finance pool.\n     */\n    function addAsset(address pool) external {\n        if (!IRegistry(REGISTRY).isAllowed(pool, 0)) revert PoolNotAllowed();\n\n        // No need to check if token0 and token1 are allowed, since that was already checked when the pool was added.\n        (address token0_, address token1_) = IAeroPool(pool).tokens();\n        token0[pool] = token0_;\n        token1[pool] = token1_;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ASSET INFORMATION\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Checks for a token address and the corresponding id if it is allowed.\n     * @param asset The contract address of the asset.\n     * @param assetId The id of the asset.\n     * @return allowed A boolean, indicating if the asset is allowed.\n     */\n    function isAllowed(address asset, uint256 assetId) public view override returns (bool allowed) {\n        if (asset == address(this) && assetId <= lastPositionId) allowed = true;\n    }\n\n    /**\n     * @notice Returns the unique identifiers of the underlying assets.\n     * @param assetKey The unique identifier of the asset.\n     * @return underlyingAssetKeys The unique identifiers of the underlying assets.\n     */\n    function _getUnderlyingAssets(bytes32 assetKey)\n        internal\n        view\n        override\n        returns (bytes32[] memory underlyingAssetKeys)\n    {\n        (, uint256 positionId) = _getAssetFromKey(assetKey);\n\n        address pool = positionState[positionId].pool;\n        underlyingAssetKeys = new bytes32[](3);\n        underlyingAssetKeys[0] = _getKeyFromAsset(pool, 0);\n        underlyingAssetKeys[1] = _getKeyFromAsset(token0[pool], 0);\n        underlyingAssetKeys[2] = _getKeyFromAsset(token1[pool], 0);\n    }\n\n    /**\n     * @notice Calculates for a given amount of Asset the corresponding amount(s) of underlying asset(s).\n     * param creditor The contract address of the creditor.\n     * @param assetKey The unique identifier of the asset.\n     * @param amount The amount of the Asset, in the decimal precision of the Asset.\n     * param underlyingAssetKeys The unique identifiers of the underlying assets.\n     * @return underlyingAssetsAmounts The corresponding amount(s) of Underlying Asset(s), in the decimal precision of the Underlying Asset.\n     * @return rateUnderlyingAssetsToUsd The usd rates of 10**18 tokens of underlying asset, with 18 decimals precision.\n     */\n    function _getUnderlyingAssetsAmounts(address, bytes32 assetKey, uint256 amount, bytes32[] memory)\n        internal\n        view\n        override\n        returns (uint256[] memory underlyingAssetsAmounts, AssetValueAndRiskFactors[] memory rateUnderlyingAssetsToUsd)\n    {\n        // Amount of a Wrapped position in the Asset Module can only be either 0 or 1.\n        if (amount == 0) return (new uint256[](3), rateUnderlyingAssetsToUsd);\n\n        (, uint256 positionId) = _getAssetFromKey(assetKey);\n        (uint256 fee0Position, uint256 fee1Position) = feesOf(positionId);\n\n        underlyingAssetsAmounts = new uint256[](3);\n        underlyingAssetsAmounts[0] = positionState[positionId].amountWrapped;\n        underlyingAssetsAmounts[1] = fee0Position;\n        underlyingAssetsAmounts[2] = fee1Position;\n\n        return (underlyingAssetsAmounts, rateUnderlyingAssetsToUsd);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                          PRICING LOGIC\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the risk factors of an asset for a Creditor.\n     * @param creditor The contract address of the Creditor.\n     * @param asset The contract address of the asset.\n     * @param assetId The id of the asset.\n     * @return collateralFactor The collateral factor of the asset for the Creditor, 4 decimals precision.\n     * @return liquidationFactor The liquidation factor of the asset for the Creditor, 4 decimals precision.\n     */\n    function getRiskFactors(address creditor, address asset, uint256 assetId)\n        external\n        view\n        override\n        returns (uint16 collateralFactor, uint16 liquidationFactor)\n    {\n        bytes32 assetKey = _getKeyFromAsset(asset, assetId);\n        bytes32[] memory underlyingAssetKeys = _getUnderlyingAssets(assetKey);\n\n        uint256[] memory underlyingAssetsAmounts;\n        (underlyingAssetsAmounts,) = _getUnderlyingAssetsAmounts(creditor, assetKey, 1, underlyingAssetKeys);\n        AssetValueAndRiskFactors[] memory rateUnderlyingAssetsToUsd =\n            _getRateUnderlyingAssetsToUsd(creditor, underlyingAssetKeys);\n\n        (, uint256 collateralFactor_, uint256 liquidationFactor_) =\n            _calculateValueAndRiskFactors(creditor, underlyingAssetsAmounts, rateUnderlyingAssetsToUsd);\n\n        // Unsafe cast: collateralFactor_ and liquidationFactor_ are smaller than or equal to 1e4.\n        return (uint16(collateralFactor_), uint16(liquidationFactor_));\n    }\n\n    /**\n     * @notice Returns the USD value of an asset.\n     * @param creditor The contract address of the Creditor.\n     * @param underlyingAssetsAmounts The corresponding amount(s) of Underlying Asset(s), in the decimal precision of the Underlying Asset.\n     * @param rateUnderlyingAssetsToUsd The USD rates of 10**18 tokens of underlying asset, with 18 decimals precision.\n     * @return valueInUsd The value of the asset denominated in USD, with 18 Decimals precision.\n     * @return collateralFactor The collateral factor of the asset for a given Creditor, with 4 decimals precision.\n     * @return liquidationFactor The liquidation factor of the asset for a given Creditor, with 4 decimals precision.\n     * @dev We take a weighted risk factor of both underlying assets.\n     */\n    function _calculateValueAndRiskFactors(\n        address creditor,\n        uint256[] memory underlyingAssetsAmounts,\n        AssetValueAndRiskFactors[] memory rateUnderlyingAssetsToUsd\n    ) internal view override returns (uint256 valueInUsd, uint256 collateralFactor, uint256 liquidationFactor) {\n        // \"rateUnderlyingAssetsToUsd\" is the USD value with 18 decimals precision for 10**18 tokens of Underlying Asset.\n        // To get the USD value (also with 18 decimals) of the actual amount of underlying assets, we have to multiply\n        // the actual amount with the rate for 10**18 tokens, and divide by 10**18.\n        uint256 valuePool = underlyingAssetsAmounts[0].mulDivDown(rateUnderlyingAssetsToUsd[0].assetValue, 1e18);\n        uint256 valueToken0 = underlyingAssetsAmounts[1].mulDivDown(rateUnderlyingAssetsToUsd[1].assetValue, 1e18);\n        uint256 valueToken1 = underlyingAssetsAmounts[2].mulDivDown(rateUnderlyingAssetsToUsd[2].assetValue, 1e18);\n\n        valueInUsd = valuePool + valueToken0 + valueToken1;\n\n        // Calculate weighted risk factors.\n        if (valueInUsd > 0) {\n            unchecked {\n                collateralFactor = (\n                    valuePool * rateUnderlyingAssetsToUsd[0].collateralFactor\n                        + valueToken0 * rateUnderlyingAssetsToUsd[1].collateralFactor\n                        + valueToken1 * rateUnderlyingAssetsToUsd[2].collateralFactor\n                ) / valueInUsd;\n                liquidationFactor = (\n                    valuePool * rateUnderlyingAssetsToUsd[0].liquidationFactor\n                        + valueToken0 * rateUnderlyingAssetsToUsd[1].liquidationFactor\n                        + valueToken1 * rateUnderlyingAssetsToUsd[2].liquidationFactor\n                ) / valueInUsd;\n            }\n        }\n\n        // Lower risk factors with the protocol wide risk factor.\n        uint256 riskFactor = riskParams[creditor].riskFactor;\n        collateralFactor = riskFactor.mulDivDown(collateralFactor, AssetValuationLib.ONE_4);\n        liquidationFactor = riskFactor.mulDivDown(liquidationFactor, AssetValuationLib.ONE_4);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         WRAPPING MODULE LOGIC\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Wraps an amount of liquidity and mints a new position.\n     * @param pool The contract address of the Aerodrome pool.\n     * @param amount The amount of liquidity to wrap.\n     * @return positionId The id of the minted position.\n     */\n    function mint(address pool, uint128 amount) external nonReentrant returns (uint256 positionId) {\n        if (amount == 0) revert ZeroAmount();\n        if (token0[pool] == address(0)) revert PoolNotAllowed();\n\n        // Need to transfer before minting or ERC777s could reenter.\n        ERC20(pool).safeTransferFrom(msg.sender, address(this), amount);\n\n        // Cache the old poolState.\n        PoolState memory poolState_ = poolState[pool];\n\n        // Create a new positionState.\n        PositionState memory positionState_;\n        positionState_.pool = pool;\n\n        // Claim any pending fees from the Aerodrome Pool.\n        (uint256 fee0Pool, uint256 fee1Pool) = _claimFees(pool);\n\n        // Calculate the new fee balances.\n        (poolState_, positionState_) = _getFeeBalances(poolState_, positionState_, fee0Pool, fee1Pool);\n\n        // Calculate the new wrapped amounts.\n        poolState_.totalWrapped = poolState_.totalWrapped + amount;\n        positionState_.amountWrapped = amount;\n\n        // Store the new positionState and poolState.\n        unchecked {\n            positionId = ++lastPositionId;\n        }\n        positionState[positionId] = positionState_;\n        poolState[pool] = poolState_;\n\n        // Mint the new position.\n        _safeMint(msg.sender, positionId);\n\n        emit LiquidityIncreased(positionId, pool, amount);\n    }\n\n    /**\n     * @notice Wraps additional liquidity for an existing position.\n     * @param positionId The id of the position.\n     * @param amount The amount of liquidity to wrap.\n     */\n    function increaseLiquidity(uint256 positionId, uint128 amount) external nonReentrant {\n        if (amount == 0) revert ZeroAmount();\n        if (_ownerOf[positionId] != msg.sender) revert NotOwner();\n\n        // Cache the old positionState and poolState.\n        PositionState memory positionState_ = positionState[positionId];\n        address pool = positionState_.pool;\n        PoolState memory poolState_ = poolState[pool];\n\n        // Need to transfer before increasing liquidity or ERC777s could reenter.\n        ERC20(pool).safeTransferFrom(msg.sender, address(this), amount);\n\n        // Claim any pending fees from the Aerodrome Pool.\n        (uint256 fee0Pool, uint256 fee1Pool) = _claimFees(pool);\n\n        // Calculate the new fee balances.\n        (poolState_, positionState_) = _getFeeBalances(poolState_, positionState_, fee0Pool, fee1Pool);\n\n        // Calculate the new wrapped amounts.\n        poolState_.totalWrapped = poolState_.totalWrapped + amount;\n        positionState_.amountWrapped = positionState_.amountWrapped + amount;\n\n        // Store the new positionState and poolState.\n        positionState[positionId] = positionState_;\n        poolState[pool] = poolState_;\n\n        emit LiquidityIncreased(positionId, pool, amount);\n    }\n\n    /**\n     * @notice Unwraps, withdraws and claims fees for total amount of liquidity in position.\n     * @param positionId The id of the position to burn.\n     * @return fee0Position The amount of fees of token0 that can be claimed for a certain position.\n     * @return fee1Position The amount of fees of token1 that can be claimed for a certain position.\n     * @dev Also claims and transfers the fees of the position.\n     */\n    function burn(uint256 positionId) external returns (uint256 fee0Position, uint256 fee1Position) {\n        return decreaseLiquidity(positionId, positionState[positionId].amountWrapped);\n    }\n\n    /**\n     * @notice Unwraps and withdraws liquidity.\n     * @param positionId The id of the position to withdraw from.\n     * @param amount The amount of liquidity to unwrap and withdraw.\n     * @return fee0Position The amount of fees of token0 that can be claimed for a certain position.\n     * @return fee1Position The amount of fees of token1 that can be claimed for a certain position.\n     * @dev Also claims and transfers the fees of the position.\n     */\n    function decreaseLiquidity(uint256 positionId, uint128 amount)\n        public\n        nonReentrant\n        returns (uint256 fee0Position, uint256 fee1Position)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (_ownerOf[positionId] != msg.sender) revert NotOwner();\n\n        // Cache the old positionState and poolState.\n        PositionState memory positionState_ = positionState[positionId];\n        address pool = positionState_.pool;\n        PoolState memory poolState_ = poolState[pool];\n\n        // Claim any pending fees from the Aerodrome Pool.\n        (uint256 fee0Pool, uint256 fee1Pool) = _claimFees(pool);\n\n        // Calculate the new fee balances.\n        (poolState_, positionState_) = _getFeeBalances(poolState_, positionState_, fee0Pool, fee1Pool);\n\n        // Calculate the new wrapped amounts, reverts if balance is too low.\n        poolState_.totalWrapped = poolState_.totalWrapped - amount;\n        positionState_.amountWrapped = positionState_.amountWrapped - amount;\n\n        // Fees are paid out to the owner on a decreaseLiquidity.\n        // -> Reset the balances of the pending fees.\n        fee0Position = positionState_.fee0;\n        fee1Position = positionState_.fee1;\n        positionState_.fee0 = 0;\n        positionState_.fee1 = 0;\n\n        // Store the new positionState and poolState.\n        if (positionState_.amountWrapped > 0) {\n            positionState[positionId] = positionState_;\n        } else {\n            delete positionState[positionId];\n            _burn(positionId);\n        }\n        poolState[pool] = poolState_;\n\n        // Pay out the fees to the position owner.\n        ERC20(token0[pool]).safeTransfer(msg.sender, fee0Position);\n        ERC20(token1[pool]).safeTransfer(msg.sender, fee1Position);\n        emit FeesPaid(positionId, uint128(fee0Position), uint128(fee1Position));\n\n        // Transfer the liquidity back to the position owner.\n        ERC20(pool).safeTransfer(msg.sender, amount);\n        emit LiquidityDecreased(positionId, pool, amount);\n    }\n\n    /**\n     * @notice Claims and transfers the fees of the position.\n     * @param positionId The id of the position.\n     * @return fee0Position The amount of fees of token0 that can be claimed for a certain position.\n     * @return fee1Position The amount of fees of token1 that can be claimed for a certain position.\n     */\n    function claimFees(uint256 positionId) external nonReentrant returns (uint256 fee0Position, uint256 fee1Position) {\n        if (_ownerOf[positionId] != msg.sender) revert NotOwner();\n\n        // Cache the old positionState and poolState.\n        PositionState memory positionState_ = positionState[positionId];\n        address pool = positionState_.pool;\n        PoolState memory poolState_ = poolState[pool];\n\n        // Claim any pending fees from the Aerodrome Pool.\n        (uint256 fee0Pool, uint256 fee1Pool) = _claimFees(pool);\n\n        // Calculate the new fee balances.\n        (poolState_, positionState_) = _getFeeBalances(poolState_, positionState_, fee0Pool, fee1Pool);\n\n        // Fees are paid out to the owner on a claimFees.\n        // -> Reset the balances of the pending fees.\n        fee0Position = positionState_.fee0;\n        fee1Position = positionState_.fee1;\n        positionState_.fee0 = 0;\n        positionState_.fee1 = 0;\n\n        // Store the new positionState and poolState.\n        positionState[positionId] = positionState_;\n        poolState[pool] = poolState_;\n\n        // Pay out the fees to the position owner.\n        ERC20(token0[pool]).safeTransfer(msg.sender, fee0Position);\n        ERC20(token1[pool]).safeTransfer(msg.sender, fee1Position);\n        emit FeesPaid(positionId, uint128(fee0Position), uint128(fee1Position));\n    }\n\n    /**\n     * @notice Skims any surplus pool-tokens to the owner.\n     * @param pool The contract address of the Aerodrome pool.\n     * @dev If pool tokens are transferred without depositing before any position is minted,\n     * the pool can have non zero fees balances while totalWrapped_ is 0.\n     * In this case the fees are not accounted for and will be lost.\n     */\n    function skim(address pool) external onlyOwner nonReentrant {\n        if (token0[pool] == address(0)) revert PoolNotAllowed();\n\n        // Claim any pending fees from the Aerodrome Pool.\n        (uint256 fee0Pool, uint256 fee1Pool) = _claimFees(pool);\n\n        // Cache the poolState.\n        PoolState memory poolState_ = poolState[pool];\n\n        // Calculate the new fee balances.\n        PositionState memory positionState_;\n        (poolState_,) = _getFeeBalances(poolState_, positionState_, fee0Pool, fee1Pool);\n\n        // Store the new poolState.\n        poolState[pool] = poolState_;\n\n        // Transfer excess funds to the owner.\n        uint256 deltaWrapped = ERC20(pool).balanceOf(address(this)) - poolState_.totalWrapped;\n        ERC20(pool).safeTransfer(msg.sender, deltaWrapped);\n    }\n\n    /**\n     * @notice Returns the total amount of liquidity wrapped via this contract.\n     * @param pool The contract address of the Aerodrome pool.\n     * @return totalWrapped_ The total amount of liquidity wrapped via this contract.\n     */\n    function totalWrapped(address pool) external view returns (uint256 totalWrapped_) {\n        totalWrapped_ = poolState[pool].totalWrapped;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                     INTERACTIONS AERODROME POOL\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Claims the fees available for this contract.\n     * @param pool The contract address of the Aerodrome pool to claim the fees for.\n     * @return fee0 The amount of fees of token0 claimed.\n     * @return fee1 The amount of fees of token1 claimed.\n     */\n    function _claimFees(address pool) internal returns (uint256 fee0, uint256 fee1) {\n        (fee0, fee1) = IAeroPool(pool).claimFees();\n    }\n\n    /**\n     * @notice Returns the amount of fees that can be claimed by this contract for a specific asset.\n     * @param pool The contract address of the Aerodrome pool to get the current fees for.\n     * @return fee0 The amount of fees of token0 that can be claimed by this contract.\n     * @return fee1 The amount of fees of token1 that can be claimed by this contract.\n     * @dev If pool tokens are transferred without depositing before any position is minted,\n     * the pool can have non zero fees balances while totalWrapped_ is 0.\n     * In this case the fees are not accounted for and will be lost.\n     */\n    function _getCurrentFees(address pool) internal view returns (uint256 fee0, uint256 fee1) {\n        // Cache totalWrapped.\n        uint256 totalWrapped_ = poolState[pool].totalWrapped;\n\n        if (totalWrapped_ > 0) {\n            // Unfortunately Aerodrome does not have a view function to get pending fees.\n            fee0 = IAeroPool(pool).claimable0(address(this))\n                + totalWrapped_.mulDivDown(IAeroPool(pool).index0() - IAeroPool(pool).supplyIndex0(address(this)), 1e18);\n            fee1 = IAeroPool(pool).claimable1(address(this))\n                + totalWrapped_.mulDivDown(IAeroPool(pool).index1() - IAeroPool(pool).supplyIndex1(address(this)), 1e18);\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         REWARDS VIEW FUNCTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the amount of fees claimable by a position.\n     * @param positionId The id of the position to check the fees for.\n     * @return fee0Position The amount of fees of token0 that can be claimed for a certain position.\n     * @return fee1Position The amount of fees of token1 that can be claimed for a certain position.\n     */\n    function feesOf(uint256 positionId) public view returns (uint256 fee0Position, uint256 fee1Position) {\n        // Cache the old positionState and poolState.\n        PositionState memory positionState_ = positionState[positionId];\n        PoolState memory poolState_ = poolState[positionState_.pool];\n\n        // Calculate the new fee balances.\n        (uint256 fee0Pool, uint256 fee1Pool) = _getCurrentFees(positionState_.pool);\n        (, positionState_) = _getFeeBalances(poolState_, positionState_, fee0Pool, fee1Pool);\n\n        fee0Position = positionState_.fee0;\n        fee1Position = positionState_.fee1;\n    }\n\n    /**\n     * @notice Calculates the current global and position specific fee balances.\n     * @param poolState_ Struct with the old fees state of the Asset.\n     * @param positionState_ Struct with the old fees state of the position.\n     * @return currentPoolState Struct with the current fees state of the Asset.\n     * @return currentPositionState Struct with the current fees state of the position.\n     */\n    function _getFeeBalances(\n        PoolState memory poolState_,\n        PositionState memory positionState_,\n        uint256 fee0,\n        uint256 fee1\n    ) internal pure returns (PoolState memory, PositionState memory) {\n        if (poolState_.totalWrapped > 0) {\n            // Calculate the new poolState.\n            // Calculate the change in FeePerLiquidity.\n            uint256 deltaFee0PerLiquidity = fee0.mulDivDown(1e18, poolState_.totalWrapped);\n            uint256 deltaFee1PerLiquidity = fee1.mulDivDown(1e18, poolState_.totalWrapped);\n            // Calculate and update the new FeePerLiquidity of the Pool.\n            // unchecked: FeePerLiquidity can overflow, what matters is the delta in FeePerLiquidity between two interactions.\n            unchecked {\n                poolState_.fee0PerLiquidity = poolState_.fee0PerLiquidity + deltaFee0PerLiquidity.safeCastTo128();\n                poolState_.fee1PerLiquidity = poolState_.fee1PerLiquidity + deltaFee1PerLiquidity.safeCastTo128();\n            }\n\n            if (positionState_.amountWrapped > 0) {\n                // Calculate the new positionState.\n                // Calculate the difference in feePerLiquidity since the last position interaction.\n                // unchecked: FeePerLiquidity can underflow, what matters is the delta in FeePerLiquidity between two interactions.\n                unchecked {\n                    deltaFee0PerLiquidity = poolState_.fee0PerLiquidity - positionState_.fee0PerLiquidity;\n                    deltaFee1PerLiquidity = poolState_.fee1PerLiquidity - positionState_.fee1PerLiquidity;\n                }\n                // Calculate the fees earned by the position since its last interaction.\n                // unchecked: deltaFeePerLiquidity and positionState_.amountWrapped are smaller than type(uint128).max.\n                uint256 deltaFee0;\n                uint256 deltaFee1;\n                unchecked {\n                    deltaFee0 = deltaFee0PerLiquidity * positionState_.amountWrapped / 1e18;\n                    deltaFee1 = deltaFee1PerLiquidity * positionState_.amountWrapped / 1e18;\n                }\n                // Update the fee balance of the position.\n                positionState_.fee0 = (positionState_.fee0 + deltaFee0).safeCastTo128();\n                positionState_.fee1 = (positionState_.fee1 + deltaFee1).safeCastTo128();\n            }\n        }\n        // Update the FeePerLiquidity of the position.\n        positionState_.fee0PerLiquidity = poolState_.fee0PerLiquidity;\n        positionState_.fee1PerLiquidity = poolState_.fee1PerLiquidity;\n\n        return (poolState_, positionState_);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ERC-721 LOGIC\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function that stores a new base URI.\n     * @param newBaseURI The new base URI to store.\n     */\n    function setBaseURI(string calldata newBaseURI) external onlyOwner {\n        baseURI = newBaseURI;\n    }\n\n    /**\n     * @notice Function that returns the token URI as defined in the ERC721 standard.\n     * @param tokenId The id of the Account.\n     * @return uri The token URI.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory uri) {\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n}"
    },
    {
      "filename": "accounts-v2/src/asset-modules/Aerodrome-Finance/WrappedAerodromeAM.sol",
      "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { AssetValuationLib, AssetValueAndRiskFactors } from \"../../libraries/AssetValuationLib.sol\";\nimport { DerivedAM, FixedPointMathLib, IRegistry } from \"../abstracts/AbstractDerivedAM.sol\";\nimport { ERC20 } from \"../../../lib/solmate/src/tokens/ERC20.sol\";\nimport { ERC721 } from \"../../../lib/solmate/src/tokens/ERC721.sol\";\nimport { IAeroPool } from \"./interfaces/IAeroPool.sol\";\nimport { ReentrancyGuard } from \"../../../lib/solmate/src/utils/ReentrancyGuard.sol\";\nimport { SafeCastLib } from \"../../../lib/solmate/src/utils/SafeCastLib.sol\";\nimport { SafeTransferLib } from \"../../../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { Strings } from \"../../libraries/Strings.sol\";\n\n/**\n * @title Asset Module for Wrapped Aerodrome Finance pools\n * @author Pragma Labs\n * @notice The Wrapped Aerodrome Finance Asset Module stores pricing logic and basic information for Wrapped Aerodrome Finance Pools.\n */\ncontract WrappedAerodromeAM is DerivedAM, ERC721, ReentrancyGuard {\n    using FixedPointMathLib for uint256;\n    using Strings for uint256;\n    using SafeCastLib for uint256;\n    using SafeTransferLib for ERC20;\n\n    /* //////////////////////////////////////////////////////////////\n                                STORAGE\n    ////////////////////////////////////////////////////////////// */\n\n    // The id of last minted position.\n    uint256 internal lastPositionId;\n\n    // The baseURI of the ERC721 tokens.\n    string public baseURI;\n\n    // Map a Pool to its corresponding token0.\n    mapping(address pool => address token0) public token0;\n    // Map a Pool to its corresponding token1.\n    mapping(address pool => address token1) public token1;\n    // Map a Pool to its corresponding struct with global state.\n    mapping(address pool => PoolState) public poolState;\n    // Map a position id to its corresponding struct with the position state.\n    mapping(uint256 position => PositionState) public positionState;\n\n    // Struct with the global state per Pool.\n    struct PoolState {\n        // The growth of fees per Pool, at the last interaction with this contract,\n        // with 18 decimals precision.\n        uint128 fee0PerLiquidity;\n        uint128 fee1PerLiquidity;\n        // The total amount of liquidity wrapped.\n        uint128 totalWrapped;\n    }\n\n    // Struct with the Position specific state.\n    struct PositionState {\n        // The growth of fees per Pool, at the last interaction of the position owner with this contract,\n        // with 18 decimals precision.\n        uint128 fee0PerLiquidity;\n        uint128 fee1PerLiquidity;\n        // The unclaimed amount of fees of the position owner, at the last interaction of the owner with this contract.\n        uint128 fee0;\n        uint128 fee1;\n        // Total amount of liquidity wrapped for this position.\n        uint128 amountWrapped;\n        // The contract address of the Pool.\n        address pool;\n    }\n\n    /* //////////////////////////////////////////////////"
    }
  ]
}