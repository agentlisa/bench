{
  "Title": "[05] Masking deposit calculation can lead to unexpected results in certain circumstances",
  "Content": "\nhttps://github.com/code-423n4/2024-03-phala-network/blob/a01ffbe992560d8d0f17deadfb9b9a2bed38377e/phala-blockchain/crates/pink/runtime/src/contract.rs#L122-L135\n\nThe function coarse gas relies on complex bit math to mask deposits in order to mitigate side channel attacks. Therefore, we can consider that masked deposits must be at least higher or equal to the original deposit. However, this invariant can be broken.\n\nConsider the fuzz test below:\n\n```\n#[test]\nfn test_mask_deposit_properties(deposit in 1u128..=u128::MAX, deposit_per_byte in any::<u128>()) {\n    let masked_deposit = mask_deposit(deposit, deposit_per_byte);\n\n    // Property 1: Masked deposit should be greater than or equal to the original deposit.\n    prop_assert!(masked_deposit >= deposit);\n}\n```\n\nHere the invariant will be broken if `deposit_per_byte` is `= 664613997892457936451903530140172289`. This can be problematic if the cluster creator (the actor who sets the deposit per byte) is acting in a malicious way as this opens the door for the side channel attack that the function is supposed to prevent. \n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-phala-network",
  "Code": [
    {
      "filename": "phala-blockchain/crates/pink/runtime/src/contract.rs",
      "content": "use frame_support::weights::Weight;\nuse pallet_contracts::Determinism;\nuse pallet_contracts::StorageDeposit;\nuse pink_capi::{types::ExecutionMode, v1::ecall::TransactionArguments};\nuse sp_runtime::DispatchError;\n\nuse crate::{\n    runtime::{Contracts, Pink as PalletPink, PinkRuntime},\n    types::{AccountId, Balance, Hash},\n};\nuse anyhow::Result;\n\ntype EventRecord = frame_system::EventRecord<\n    <PinkRuntime as frame_system::Config>::RuntimeEvent,\n    <PinkRuntime as frame_system::Config>::Hash,\n>;\n\npub type ContractExecResult = pallet_contracts::ContractExecResult<Balance, EventRecord>;\npub type ContractInstantiateResult =\n    pallet_contracts::ContractInstantiateResult<AccountId, Balance, EventRecord>;\npub type ContractResult<T> =\n    pallet_contracts::ContractResult<Result<T, DispatchError>, Balance, EventRecord>;\n\nmacro_rules! define_mask_fn {\n    ($name: ident, $bits: expr, $typ: ty) => {\n        /// Mask given number's lowest bits.\n        ///\n        /// Given a number 0x1000beef, in binary representation:\n        ///     0b_10000_00000000_10111110_11101111\n        /// We want to mask it to 0x100fffff.\n        /// Rough steps:\n        ///     0b_10000_00000000_10111110_11101111\n        ///        ^\n        ///      1. we find the most left bit position here\n        ///     0b_10000_00000000_10111110_11101111\n        ///                  ^^^^^^^^^^^^^^^^^^^^^^\n        ///               2. than calculate these bits need to be mask\n        ///     0b_10000_00001111_11111111_11111111\n        ///                  ^^^^^^^^^^^^^^^^^^^^^^\n        ///               3. mask it\n        fn $name(v: $typ, min_mask_bits: u32) -> $typ {\n            // Given v = 0x1000_beef\n            // Suppose we have:\n            // bits = 64\n            // v =0b010000_00000000_10111110_11101111\n            let pos = $bits - v.leading_zeros();\n            //    0b010000_00000000_10111110_11101111\n            //      ^\n            //     here, pos=30\n            // shift right by 9\n            let pos = pos.max(9) - 9;\n            // Now pos =  0b_10000_00000000_00000000\n            //               ^\n            //              now here, pos=21\n            // If min_mask_bits = 16\n            //                  0b_10000000_00000000\n            //                     ^\n            //                  min_mask_bits here\n            let pos = pos.clamp(min_mask_bits, $bits - 1);\n            let cursor: $typ = 1 << pos;\n            //            0b_10000_00000000_00000000\n            //               ^\n            //               cursor here\n            let mask = cursor.saturating_sub(1);\n            // mask =  0b_00001111_11111111_11111111\n            // v | mask =\n            //    0b10000_00001111_11111111_11111111\n            //  = 0x100fffff\n            v | mask\n        }\n    };\n}\n\ndefine_mask_fn!(mask_low_bits64, 64, u64);\ndefine_mask_fn!(mask_low_bits128, 128, u128);\n\nfn mask_deposit(deposit: u128, deposit_per_byte: u128) -> u128 {\n    const MIN_MASKED_BYTES: u128 = 256;\n    let min_masked_value = deposit_per_byte\n        .saturating_mul(MIN_MASKED_BYTES)\n        .saturating_sub(1);\n    let min_mask_bits = 128 - min_masked_value.leading_zeros();\n    mask_low_bits128(deposit, min_mask_bits)\n}\n\nfn mask_gas(weight: Weight) -> Weight {\n    Weight::from_parts(mask_low_bits64(weight.ref_time(), 28), 0)\n}\n\n#[test]\nfn mask_low_bits_works() {\n    let min_mask_bits = 24;\n    assert_eq!(mask_low_bits64(0, min_mask_bits), 0xffffff);\n    assert_eq!(mask_low_bits64(0x10, min_mask_bits), 0xffffff);\n    assert_eq!(mask_low_bits64(0x1000_0000, min_mask_bits), 0x10ff_ffff);\n    assert_eq!(\n        mask_low_bits64(0x10_0000_0000, min_mask_bits),\n        0x10_0fff_ffff\n    );\n    assert_eq!(\n        mask_low_bits64(0x10_0000_0000_0000, min_mask_bits),\n        0x10_0fff_ffff_ffff\n    );\n    assert_eq!(\n        mask_low_bits64(0xffff_ffff_0000_0000, min_mask_bits),\n        0xffff_ffff_ffff_ffff\n    );\n\n    let price = 10;\n    assert_eq!(mask_deposit(0, 0), 0);\n    assert_eq!(mask_deposit(0, 1), 255);\n    assert_eq!(mask_deposit(0, price), 4095);\n    assert_eq!(mask_deposit(0x10, price), 4095);\n    assert_eq!(mask_deposit(0x10_0000, price), 0x10_0fff);\n    assert_eq!(mask_deposit(0x10_0000_0000, price), 0x10_0fff_ffff);\n    assert_eq!(\n        mask_deposit(0x10_0000_0000_0000, price),\n        0x10_0fff_ffff_ffff\n    );\n}\n\nfn coarse_grained<T>(mut result: ContractResult<T>, deposit_per_byte: u128) -> ContractResult<T> {\n    result.gas_consumed = mask_gas(result.gas_consumed);\n    result.gas_required = mask_gas(result.gas_required);\n\n    match &mut result.storage_deposit {\n        StorageDeposit::Charge(v) => {\n            *v = mask_deposit(*v, deposit_per_byte);\n        }\n        StorageDeposit::Refund(v) => {\n            *v = mask_deposit(*v, deposit_per_byte);\n        }\n    }\n    result\n}\n\npub fn check_instantiate_result(result: &ContractInstantiateResult) -> Result<AccountId> {\n    let ret = result\n        .result\n        .as_ref()\n        .map_err(|err| anyhow::anyhow!(\"{err:?}\"))?;\n    if ret.result.did_revert() {\n        anyhow::bail!(\"contract instantiation failed: {:?}\", ret.result)\n    }\n    Ok(ret.account_id.clone())\n}\n\n/// Instantiate a contract with given code hash and input data.\npub fn instantiate(\n    code_hash: Hash,\n    input_data: Vec<u8>,\n    salt: Vec<u8>,\n    mode: ExecutionMode,\n    args: TransactionArguments,\n) -> ContractInstantiateResult {\n    let TransactionArguments {\n        origin,\n        transfer,\n        gas_limit,\n        storage_deposit_limit,\n        gas_free,\n        deposit: _,\n    } = args;\n    let gas_limit = Weight::from_parts(gas_limit, 0).set_proof_size(u64::MAX);\n    let result = contract_tx(origin.clone(), gas_limit, gas_free, move || {\n        Contracts::bare_instantiate(\n            origin,\n            transfer,\n            gas_limit,\n            storage_deposit_limit,\n            pallet_contracts::Code::Existing(code_hash),\n            input_data,\n            salt,\n            pallet_contracts::DebugInfo::UnsafeDebug,\n            pallet_contracts::CollectEvents::Skip,\n        )\n    });\n    log::info!(\"Contract instantiation result: {:?}\", &result.result);\n    if mode.should_return_coarse_gas() {\n        coarse_grained(result, PalletPink::deposit_per_byte())\n    } else {\n        result\n    }\n}\n\n/// Call a contract method\n///\n/// # Parameters\n/// * `input_data`: The SCALE encoded arguments including the 4-bytes selector as prefix.\n/// # Return\n/// Returns the SCALE encoded method return value.\npub fn bare_call(\n    address: AccountId,\n    input_data: Vec<u8>,\n    mode: ExecutionMode,\n    tx_args: TransactionArguments,\n) -> ContractExecResult {\n    let TransactionArguments {\n        origin,\n        transfer,\n        gas_limit,\n        gas_free,\n        storage_deposit_limit,\n        deposit: _,\n    } = tx_args;\n    let gas_limit = Weight::from_parts(gas_limit, 0).set_proof_size(u64::MAX);\n    let determinism = if mode.deterministic_required() {\n        Determinism::Enforced\n    } else {\n        Determinism::Relaxed\n    };\n    let result = contract_tx(origin.clone(), gas_limit, gas_free, move || {\n        Contracts::bare_call(\n            origin,\n            address,\n            transfer,\n            gas_limit,\n            storage_deposit_limit,\n            input_data,\n            pallet_contracts::DebugInfo::UnsafeDebug,\n            pallet_contracts::CollectEvents::Skip,\n            determinism,\n        )\n    });\n    if mode.should_return_coarse_gas() {\n        coarse_grained(result, PalletPink::deposit_per_byte())\n    } else {\n        result\n    }\n}\n\nfn contract_tx<T>(\n    origin: AccountId,\n    gas_limit: Weight,\n    gas_free: bool,\n    tx_fn: impl FnOnce() -> ContractResult<T>,\n) -> ContractResult<T> {\n    if !gas_free {\n        if let Err(err) = PalletPink::pay_for_gas(&origin, gas_limit) {\n            return ContractResult {\n                gas_consumed: Weight::zero(),\n                gas_required: Weight::zero(),\n                storage_deposit: Default::default(),\n                debug_message: Default::default(),\n                result: Err(err),\n                events: None,\n            };\n        }\n    }\n    let result = tx_fn();\n    if !gas_free {\n        let refund = gas_limit\n            .checked_sub(&result.gas_consumed)\n            .expect(\"BUG: consumed gas more than the gas limit\");\n        PalletPink::refund_gas(&origin, refund).expect(\"BUG: failed to refund gas\");\n    }\n    result\n}"
    }
  ]
}