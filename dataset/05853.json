{
  "Title": "[05] `CreateOfferer` uses a custom context implementation instead of an existing SIP",
  "Content": "\nIt is suggested to use an existing [SIP implementation](https://github.com/ProjectOpenSea/SIPs/blob/main/SIPS/sip-7.md) instead of creating a new standard from scratch, which might be prone to errors:\n\n```solidity\nStructs.Context memory decodedContext = abi.decode(context, (Structs.Context));\n```\n\nhttps://github.com/code-423n4/2023-09-delegate/blob/main/src/CreateOfferer.sol#L59\n\nPlease note that the contract needs to be SIP compliant before it's possible to implement SIP-7, as it requires SIP-5 and SIP-6. \n\nThe issue describing non-compliance is described here: [`#280`](https://github.com/code-423n4/2023-09-delegate-findings/issues/280).\n\n**[0xfoobar (Delegate) commented](https://github.com/code-423n4/2023-09-delegate-findings/issues/293#issuecomment-1724128834):**\n > Useful QA report.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-09-delegate-findings/issues/293#issuecomment-1732627819):**\n > **[01] previewOrder should not revert**<br>\n> Low\n> \n> **[02] Withdraw should revert with a not supported delegationType**<br>\n> Refactoring\n> \n> **[03] Lack of data on flashloan could make some ERC1155 unusable**<br>\n> Low\n> \n> **[04] Using delegatecall inside a loop may cause issues with payable functions**<br>\n> Refactoring\n> \n> **[05] CreateOfferer uses a custom context implementation instead of an existing SIP**<br>\n> Low\n> \n> The following downgraded submissions from the warden were also considered in scoring:\n> - [Seaport orders will not work with USDT](https://github.com/code-423n4/2023-09-delegate-findings/issues/259)\n> - [DelegateToken is not EIP-721 compliant](https://github.com/code-423n4/2023-09-delegate-findings/issues/260)\n> - [Rebasing tokens remain permanently locked inside DelegateToken](https://github.com/code-423n4/2023-09-delegate-findings/issues/264)\n> - [ETH can be permanently locked during a flashloan](https://github.com/code-423n4/2023-09-delegate-findings/issues/267)\n> - [Principal token can be permanently locked](https://github.com/code-423n4/2023-09-delegate-findings/issues/269)\n> - [CreateOfferer is not SIP-compliant, which can cause integration issues with third parties](https://github.com/code-423n4/2023-09-delegate-findings/issues/280)\n> \n> Total: 6+ Low and 2 Refactoring\n> \n> By far the best submission, great work!\n\n**[0xfoobar (Delegate) acknowledged and commented](https://github.com/code-423n4/2023-09-delegate-findings/issues/293#issuecomment-1745886019):**\n > **[01] previewOrder should not revert**<br>\n> The quoted documentation actually says it can revert, we're not doing order penalties here just straightforward fulfillment.\n> \n> **[02] Withdraw should revert with non-supported delegationType**<br>\n> It does.\n> \n> **[03] Lack of data on flashloan could make some ERC1155 unusable**<br>\n> Acknowledged, we won't be transferring directly to staking contracts with merkle roots so this is fine.\n> \n> **[04] Using delegatecall inside a loop may cause issues with payable functions**<br>\n> But here it does not, we can see in the quoted code that it's not looping over `msg.value`.\n> \n> **[05] CreateOfferer uses a custom context implementation instead of an existing SIP**<br>\n> Acknowledged.\n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-delegate",
  "Code": [
    {
      "filename": "src/CreateOfferer.sol",
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.21;\n\nimport {IDelegateRegistry} from \"delegate-registry/src/IDelegateRegistry.sol\";\nimport {IDelegateToken, Structs as IDelegateTokenStructs} from \"./interfaces/IDelegateToken.sol\";\nimport {RegistryHashes} from \"delegate-registry/src/libraries/RegistryHashes.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"openzeppelin/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"openzeppelin/token/ERC1155/IERC1155.sol\";\n\nimport {ContractOffererInterface, SpentItem, ReceivedItem, Schema} from \"seaport/contracts/interfaces/ContractOffererInterface.sol\";\nimport {\n    CreateOffererStructs as Structs,\n    CreateOffererEnums as Enums,\n    CreateOffererErrors as Errors,\n    CreateOffererHelpers as Helpers,\n    CreateOffererModifiers as Modifiers\n} from \"src/libraries/CreateOffererLib.sol\";\n\nimport {ERC1155Holder} from \"openzeppelin/token/ERC1155/utils/ERC1155Holder.sol\";\n\n/// @dev Experimental way to create delegate tokens with seaport and existing seaport conduit approvals\ncontract CreateOfferer is Modifiers, ContractOffererInterface, ERC1155Holder {\n    address public immutable delegateToken;\n    address public immutable principalToken;\n    Structs.TransientState internal transientState;\n    Structs.Nonce internal nonce;\n\n    constructor(Structs.Parameters memory parameters) Modifiers(parameters.seaport, Enums.Stage.generate) {\n        if (parameters.delegateToken == address(0)) revert Errors.DelegateTokenIsZero();\n        delegateToken = parameters.delegateToken;\n        if (parameters.principalToken == address(0)) revert Errors.PrincipalTokenIsZero();\n        principalToken = parameters.principalToken;\n        Structs.Order memory defaultInfo =\n            Structs.Order({rights: 0, expiryLength: 1, signerSalt: 1, tokenContract: address(42), expiryType: Enums.ExpiryType.absolute, targetToken: Enums.TargetToken.principal});\n        transientState = Structs.TransientState({\n            erc721Order: Structs.ERC721Order({tokenId: 1, info: defaultInfo}),\n            erc20Order: Structs.ERC20Order({amount: 1, info: defaultInfo}),\n            erc1155Order: Structs.ERC1155Order({tokenId: 1, amount: 1, info: defaultInfo}),\n            receivers: Structs.Receivers({fulfiller: address(1), targetTokenReceiver: address(1)})\n        });\n    }\n\n    /**\n     * @notice Implementation of seaport contract offerer generateOrder\n     * @param minimumReceived The \"ghost\" create offerer token to be ordered\n     * @param maximumSpent The underlying token required during the liquid delegate create process\n     * @param context The upper bits of context should be encoded with the CreateOffererStruct\n     * @return offer Returns minimumReceived\n     * @return consideration Returns maximumSpent but with the beneficiary specified as this contract\n     */\n    function generateOrder(address fulfiller, SpentItem[] calldata minimumReceived, SpentItem[] calldata maximumSpent, bytes calldata context)\n        external\n        checkStage(Enums.Stage.generate, Enums.Stage.transfer)\n        onlySeaport(msg.sender)\n        returns (SpentItem[] memory offer, ReceivedItem[] memory consideration)\n    {\n        if (context.length != 160) revert Errors.InvalidContextLength();\n        Structs.Context memory decodedContext = abi.decode(context, (Structs.Context));\n        (offer, consideration) = Helpers.processSpentItems(minimumReceived, maximumSpent);\n        Helpers.updateTransientState(transientState, fulfiller, minimumReceived[0], maximumSpent[0], decodedContext);\n    }\n\n    /**\n     * @notice Implementation of seaport contract offerer generateOrder\n     * @param offer The delegateToken created during transfer\n     * @param consideration The underlying used for create during transfer\n     * @param context The upper bits of context should be encoded with the CreateOffererStruct\n     * @param contractNonce Should match with the nonce tracked by this contract\n     */\n    function ratifyOrder(SpentItem[] calldata offer, ReceivedItem[] calldata consideration, bytes calldata context, bytes32[] calldata, uint256 contractNonce)\n        external\n        checkStage(Enums.Stage.ratify, Enums.Stage.generate)\n        onlySeaport(msg.sender)\n        returns (bytes4)\n    {\n        Helpers.processNonce(nonce, contractNonce);\n        Helpers.verifyCreate(delegateToken, offer[0].identifier, transientState.receivers, consideration[0], context);\n        return this.ratifyOrder.selector;\n    }\n\n    /**\n     * @notice Implementation of the ERC721 transferFrom interface to force create delegate tokens\n     * @param from Must be this contract address\n     * @param targetTokenReceiver Is the receiver of the intended targetToken, the delegate / principal token\n     * @param createOrderHashAsTokenId The hash that secures the intended targetToken receiver being the beneficiary of a specific delegate / principal token\n     */\n    //slither-disable-next-line erc20-interface\n    function transferFrom(address from, address targetTokenReceiver, uint256 createOrderHashAsTokenId) external checkStage(Enums.Stage.transfer, Enums.Stage.ratify) {\n        if (from != address(this)) revert Errors.FromNotCreateOfferer(from);\n        transientState.receivers.targetTokenReceiver = targetTokenReceiver;\n        IDelegateRegistry.DelegationType tokenType = RegistryHashes.decodeType(bytes32(createOrderHashAsTokenId));\n        if (tokenType == IDelegateRegistry.DelegationType.ERC721) {\n            Structs.ERC721Order memory erc721Order = transientState.erc721Order;\n            if (!(erc721Order.info.targetToken == Enums.TargetToken.delegate || erc721Order.info.targetToken == Enums.TargetToken.principal)) {\n                revert Errors.TargetTokenInvalid(erc721Order.info.targetToken);\n            }\n            Helpers.validateCreateOrderHash(targetTokenReceiver, createOrderHashAsTokenId, abi.encode(erc721Order), tokenType);\n            IERC721(erc721Order.info.tokenContract).setApprovalForAll(address(delegateToken), true);\n            Helpers.createAndValidateDelegateTokenId(\n                delegateToken,\n                createOrderHashAsTokenId,\n                IDelegateTokenStructs.DelegateInfo({\n                    principalHolder: erc721Order.info.targetToken == Enums.TargetToken.principal ? targetTokenReceiver : transientState.receivers.fulfiller,\n                    tokenType: tokenType,\n                    delegateHolder: erc721Order.info.targetToken == Enums.TargetToken.delegate ? targetTokenReceiver : transientState.receivers.fulfiller,\n                    amount: 0,\n                    tokenContract: erc721Order.info.tokenContract,\n                    tokenId: erc721Order.tokenId,\n                    rights: erc721Order.info.rights,\n                    expiry: Helpers.calculateExpiry(erc721Order.info.expiryType, erc721Order.info.expiryLength)\n                })\n            );\n            IERC721(erc721Order.info.tokenContract).setApprovalForAll(address(delegateToken), false); // saves gas\n        } else if (tokenType == IDelegateRegistry.DelegationType.ERC20) {\n            Structs.ERC20Order memory erc20Order = transientState.erc20Order;\n            if (!(erc20Order.info.targetToken == Enums.TargetToken.delegate || erc20Order.info.targetToken == Enums.TargetToken.principal)) {\n                revert Errors.TargetTokenInvalid(erc20Order.info.targetToken);\n            }\n            Helpers.validateCreateOrderHash(targetTokenReceiver, createOrderHashAsTokenId, abi.encode(erc20Order), tokenType);\n            if (!IERC20(erc20Order.info.tokenContract).approve(address(delegateToken), erc20Order.amount)) {\n                revert Errors.ERC20ApproveFailed(erc20Order.info.tokenContract);\n            }\n            Helpers.createAndValidateDelegateTokenId(\n                delegateToken,\n                createOrderHashAsTokenId,\n                IDelegateTokenStructs.DelegateInfo({\n                    principalHolder: erc20Order.info.targetToken == Enums.TargetToken.principal ? targetTokenReceiver : transientState.receivers.fulfiller,\n                    tokenType: tokenType,\n                    delegateHolder: erc20Order.info.targetToken == Enums.TargetToken.delegate ? targetTokenReceiver : transientState.receivers.fulfiller,\n                    amount: erc20Order.amount,\n                    tokenContract: erc20Order.info.tokenContract,\n                    tokenId: 0,\n                    rights: erc20Order.info.rights,\n                    expiry: Helpers.calculateExpiry(erc20Order.info.expiryType, erc20Order.info.expiryLength)\n                })\n            );\n            if (IERC20(erc20Order.info.tokenContract).allowance(address(this), address(delegateToken)) != 0) {\n                revert Errors.ERC20AllowanceInvariant(erc20Order.info.tokenContract);\n            }\n        } else if (tokenType == IDelegateRegistry.DelegationType.ERC1155) {\n            Structs.ERC1155Order memory erc1155Order = transientState.erc1155Order;\n            if (!(erc1155Order.info.targetToken == Enums.TargetToken.delegate || erc1155Order.info.targetToken == Enums.TargetToken.principal)) {\n                revert Errors.TargetTokenInvalid(erc1155Order.info.targetToken);\n            }\n            Helpers.validateCreateOrderHash(targetTokenReceiver, createOrderHashAsTokenId, abi.encode(erc1155Order), tokenType);\n            IERC1155(erc1155Order.info.tokenContract).setApprovalForAll(address(delegateToken), true);\n            Helpers.createAndValidateDelegateTokenId(\n                delegateToken,\n                createOrderHashAsTokenId,\n                IDelegateTokenStructs.DelegateInfo({\n                    principalHolder: erc1155Order.info.targetToken == Enums.TargetToken.principal ? targetTokenReceiver : transientState.receivers.fulfiller,\n                    tokenType: tokenType,\n                    delegateHolder: erc1155Order.info.targetToken == Enums.TargetToken.delegate ? targetTokenReceiver : transientState.receivers.fulfiller,\n                    amount: erc1155Order.amount,\n                    tokenContract: erc1155Order.info.tokenContract,\n                    tokenId: erc1155Order.tokenId,\n                    rights: erc1155Order.info.rights,\n                    expiry: Helpers.calculateExpiry(erc1155Order.info.expiryType, erc1155Order.info.expiryLength)\n                })\n            );\n            IERC1155(erc1155Order.info.tokenContract).setApprovalForAll(address(delegateToken), false); // saves gas\n        } else {\n            revert Errors.InvalidTokenType(tokenType);\n        }\n    }\n\n    /**\n     * @notice Implementation of seaport contract offerer previewOrder\n     * @param caller Must be the seaport address\n     * @param minimumReceived The \"ghost\" create offerer token to be ordered\n     * @param maximumSpent The underlying token required during the liquid delegate create process\n     * @return offer Returns minimumReceived\n     * @return consideration Returns maximumSpent but with the beneficiary specified as this contract\n     */\n    function previewOrder(address caller, address, SpentItem[] calldata minimumReceived, SpentItem[] calldata maximumSpent, bytes calldata context)\n        external\n        view\n        onlySeaport(caller)\n        returns (SpentItem[] memory offer, ReceivedItem[] memory consideration)\n    {\n        if (context.length != 160) revert Errors.InvalidContextLength();\n        (offer, consideration) = Helpers.processSpentItems(minimumReceived, maximumSpent);\n    }\n\n    /**\n     * @notice Calculates the hash and id for an ERC721 order\n     * @param targetTokenReceiver The receiver of the target token in the ERC721 order\n     * @param conduit The conduit used in the order of the targetTokenReceiver\n     * @param erc721Order The ERC721Order struct with the details of the order\n     * @return createOrderHash The hash used by CreateOfferer to capture the order intent\n     * @return delegateTokenId The id of the delegateToken that would be created by CreateOfferer with these parameters\n     * @dev Reverts if the delegateTokenId has already been used, use a different salt in the order struct\n     */\n    function calculateERC721OrderHashAndId(address targetTokenReceiver, address conduit, Structs.ERC721Order calldata erc721Order)\n        external\n        view\n        returns (uint256 createOrderHash, uint256 delegateTokenId)\n    {\n        (createOrderHash, delegateTokenId) =\n            Helpers.calculateOrderHashAndId(delegateToken, targetTokenReceiver, conduit, abi.encode(erc721Order), IDelegateRegistry.DelegationType.ERC721);\n    }\n\n    /**\n     * @notice Calculates the hash and id for an ERC721 order\n     * @param targetTokenReceiver The receiver of the target token in the ERC721 order\n     * @param conduit The conduit used in the order of the targetTokenReceiver\n     * @param erc20Order The ERC20Order struct with the details of the order\n     * @return createOrderHash The hash used by CreateOfferer to capture the order intent\n     * @return delegateTokenId The id of the delegateToken that would be created by CreateOfferer with these parameters\n     * @dev Reverts if the delegateTokenId has already been used, use a different salt in the order struct\n     */\n    function calculateERC20OrderHashAndId(address targetTokenReceiver, address conduit, Structs.ERC20Order calldata erc20Order)\n        external\n        view\n        returns (uint256 createOrderHash, uint256 delegateTokenId)\n    {\n        (createOrderHash, delegateTokenId) =\n            Helpers.calculateOrderHashAndId(delegateToken, targetTokenReceiver, conduit, abi.encode(erc20Order), IDelegateRegistry.DelegationType.ERC20);\n    }\n\n    /**\n     * @notice Calculates the hash and id for an ERC721 order\n     * @param targetTokenReceiver The receiver of the target token in the ERC721 order\n     * @param conduit The conduit used in the order of the targetTokenReceiver\n     * @param erc1155Order The ERC1155Order struct with the details of the order.\n     * @return createOrderHash The hash used by CreateOfferer to capture the order intent\n     * @return delegateTokenId The id of the delegateToken that would be created by CreateOfferer with these parameters\n     * @dev Reverts if the delegateTokenId has already been used, use a different salt in the order struct\n     */\n    function calculateERC1155OrderHashAndId(address targetTokenReceiver, address conduit, Structs.ERC1155Order calldata erc1155Order)\n        external\n        view\n        returns (uint256 createOrderHash, uint256 delegateTokenId)\n    {\n        (createOrderHash, delegateTokenId) =\n            Helpers.calculateOrderHashAndId(delegateToken, targetTokenReceiver, conduit, abi.encode(erc1155Order), IDelegateRegistry.DelegationType.ERC1155);\n    }\n\n    /// @notice Implementation of seaport contract offerer getSeaportMetadata\n    function getSeaportMetadata() external pure returns (string memory, Schema[] memory) {\n        return (\"Delegate Market Contract Offerer\", new Schema[](0));\n    }\n}"
    }
  ]
}