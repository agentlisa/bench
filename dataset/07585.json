{
  "Title": "[H-01] User can redirect fees by using a proxy contract",
  "Content": "\n<https://github.com/code-423n4/2022-11-canto/blob/main/CIP-001/src/Turnstile.sol#L86-L101>\n\n<https://github.com/code-423n4/2022-11-canto/blob/main/Canto/x/csr/keeper/evm_hooks.go#L51>\n\n### Impact\n\nFor any given tx, the fees are sent to its recipient (`To`). Anybody can register an address using the Turnstile contract. Thus, a user is able to create a proxy contract with which they execute other smart contracts. That way, the fees are sent to their own contract instead of the actual application they are using. People who use smart contract wallets don't even have to bother with setting up a proxy structure. They just add their own wallet to the Turnstile contract.\n\nAlso, there might be a possibility of someone setting up a proxy for high-usage contracts where the fees are sent back to the caller. So for contract $X$, we create $X'$ which calls $X$ for the caller. Since $X'$ is the recipient of the tx, it gets the gas refund. To incentivize the user to use $X'$ instead of $X$, $X'$ sends a percentage of the refund to the caller. The feasibility both technically and economically depends on the contract that is attacked. But, theoretically, it's possible.\n\nThe incentive to take it for yourself instead of giving it to the app is pretty high. Since this causes a loss of funds for the app I rate it as HIGH.\n\n### Proof of Concept\n\nRegistering an address is permissionless:\n\n```sol\n    function register(address _recipient) public onlyUnregistered returns (uint256 tokenId) {\n        address smartContract = msg.sender;\n\n        if (_recipient == address(0)) revert InvalidRecipient();\n\n        tokenId = _tokenIdTracker.current();\n        _mint(_recipient, tokenId);\n        _tokenIdTracker.increment();\n\n        emit Register(smartContract, _recipient, tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: tokenId,\n            registered: true\n        });\n    }\n```\n\nFees are sent to the recipient of the tx:\n\n```sol\nfunc (h Hooks) PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error {\n\t// Check if the csr module has been enabled\n\tparams := h.k.GetParams(ctx)\n\tif !params.EnableCsr {\n\t\treturn nil\n\t}\n\n\t// Check and process turnstile events if applicable\n\th.processEvents(ctx, receipt)\n\n\tcontract := msg.To()\n\tif contract == nil {\n\t\treturn nil\n\t}\n\n        // ...\n```\n\n### Recommended Mitigation Steps\n\nIt's pretty difficult to fix this properly. The ideal solution is to distribute fees according to each contract's gas usage. That will be a little more complicated to implement. Also, you have to keep an eye on whether it incentivizes developers to make their contracts less efficient. Another solution is to make this feature permissioned so that only select contracts are allowed to participate. For example, you could say that an address has to be triggered $X$ amount of times before it is eligible for gas refunds.\n\n**[tkkwon1998 (Canto) acknowledged and commented](https://github.com/code-423n4/2022-11-canto-findings/issues/48#issuecomment-1356331310):**\n > We acknowledge this as true, but it's a drawback that was discussed during the design of CSR.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-11-canto",
  "Code": [
    {
      "filename": "CIP-001/src/Turnstile.sol",
      "content": "// SPDX-License-Identifier: GPLv3\npragma solidity 0.8.17;\n\nimport \"openzeppelin/access/Ownable.sol\";\nimport \"openzeppelin/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"openzeppelin/utils/Counters.sol\";\n\n/// @notice Implementation of CIP-001 https://github.com/Canto-Improvement-Proposals/CIPs/blob/main/CIP-001.md\n/// @dev Every contract is responsible to register itself in the constructor by calling `register(address)`.\n///      If contract is using proxy pattern, it's possible to register retroactively, however past fees will be lost.\n///      Recipient withdraws fees by calling `withdraw(uint256,address,uint256)`.\ncontract Turnstile is Ownable, ERC721Enumerable {\n    using Counters for Counters.Counter;\n\n    struct NftData {\n        uint256 tokenId;\n        bool registered;\n    }\n\n    Counters.Counter private _tokenIdTracker;\n\n    /// @notice maps smart contract address to tokenId\n    mapping(address => NftData) public feeRecipient;\n\n    /// @notice maps tokenId to fees earned\n    mapping(uint256 => uint256) public balances;\n\n    event Register(address smartContract, address recipient, uint256 tokenId);\n    event Assign(address smartContract, uint256 tokenId);\n    event Withdraw(uint256 tokenId, address recipient, uint256 feeAmount);\n    event DistributeFees(uint256 tokenId, uint256 feeAmount);\n\n    error NotAnOwner();\n    error AlreadyRegistered();\n    error Unregistered();\n    error InvalidRecipient();\n    error InvalidTokenId();\n    error NothingToWithdraw();\n    error NothingToDistribute();\n\n    /// @dev only owner of _tokenId can call this function\n    modifier onlyNftOwner(uint256 _tokenId) {\n        if (ownerOf(_tokenId) != msg.sender) revert NotAnOwner();\n\n        _;\n    }\n\n    /// @dev only smart contract that is unregistered can call this function\n    modifier onlyUnregistered() {\n        address smartContract = msg.sender;\n\n        if (isRegistered(smartContract)) revert AlreadyRegistered();\n\n        _;\n    }\n\n    constructor() ERC721(\"Turnstile\", \"Turnstile\") {}\n\n    /// @notice Returns current value of counter used to tokenId of new minted NFTs\n    /// @return current counter value\n    function currentCounterId() external view returns (uint256) {\n        return _tokenIdTracker.current();\n    }\n\n    /// @notice Returns tokenId that collects fees generated by the smart contract\n    /// @param _smartContract address of the smart contract\n    /// @return tokenId that collects fees generated by the smart contract\n    function getTokenId(address _smartContract) external view returns (uint256) {\n        if (!isRegistered(_smartContract)) revert Unregistered();\n\n        return feeRecipient[_smartContract].tokenId;\n    }\n\n    /// @notice Returns true if smart contract is registered to collect fees\n    /// @param _smartContract address of the smart contract\n    /// @return true if smart contract is registered to collect fees, false otherwise\n    function isRegistered(address _smartContract) public view returns (bool) {\n        return feeRecipient[_smartContract].registered;\n    }\n\n    /// @notice Mints ownership NFT that allows the owner to collect fees earned by the smart contract.\n    ///         `msg.sender` is assumed to be a smart contract that earns fees. Only smart contract itself\n    ///         can register a fee receipient.\n    /// @param _recipient recipient of the ownership NFT\n    /// @return tokenId of the ownership NFT that collects fees\n    function register(address _recipient) public onlyUnregistered returns (uint256 tokenId) {\n        address smartContract = msg.sender;\n\n        if (_recipient == address(0)) revert InvalidRecipient();\n\n        tokenId = _tokenIdTracker.current();\n        _mint(_recipient, tokenId);\n        _tokenIdTracker.increment();\n\n        emit Register(smartContract, _recipient, tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: tokenId,\n            registered: true\n        });\n    }\n\n    /// @notice Assigns smart contract to existing NFT. That NFT will collect fees generated by the smart contract.\n    ///         Callable only by smart contract itself.\n    /// @param _tokenId tokenId which will collect fees\n    /// @return tokenId of the ownership NFT that collects fees\n    function assign(uint256 _tokenId) public onlyUnregistered returns (uint256) {\n        address smartContract = msg.sender;\n\n        if (!_exists(_tokenId)) revert InvalidTokenId();\n\n        emit Assign(smartContract, _tokenId);\n\n        feeRecipient[smartContract] = NftData({\n            tokenId: _tokenId,\n            registered: true\n        });\n\n        return _tokenId;\n    }\n\n    /// @notice Withdraws earned fees to `_recipient` address. Only callable by NFT owner.\n    /// @param _tokenId token Id\n    /// @param _recipient recipient of fees\n    /// @param _amount amount of fees to withdraw\n    /// @return amount of fees withdrawn\n    function withdraw(uint256 _tokenId, address payable _recipient, uint256 _amount)\n        public\n        onlyNftOwner(_tokenId)\n        returns (uint256)\n    {\n        uint256 earnedFees = balances[_tokenId];\n\n        if (earnedFees == 0 || _amount == 0) revert NothingToWithdraw();\n        if (_amount > earnedFees) _amount = earnedFees;\n\n        balances[_tokenId] = earnedFees - _amount;\n\n        emit Withdraw(_tokenId, _recipient, _amount);\n\n        Address.sendValue(_recipient, _amount);\n\n        return _amount;\n    }\n\n    /// @notice Distributes collected fees to the smart contract. Only callable by owner.\n    /// @param _tokenId NFT that earned fees\n    function distributeFees(uint256 _tokenId) public onlyOwner payable {\n        if (msg.value == 0) revert NothingToDistribute();\n\n        balances[_tokenId] += msg.value;\n        emit DistributeFees(_tokenId, msg.value);\n    }\n}"
    },
    {
      "filename": "Canto/x/csr/keeper/evm_hooks.go",
      "content": "package keeper\n\nimport (\n\t\"math/big\"\n\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tsdkerrors \"github.com/cosmos/cosmos-sdk/types/errors\"\n\n\t\"github.com/Canto-Network/Canto/v2/contracts\"\n\t\"github.com/Canto-Network/Canto/v2/x/csr/types\"\n\t\"github.com/ethereum/go-ethereum/accounts/abi\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\tethtypes \"github.com/ethereum/go-ethereum/core/types\"\n\tevmtypes \"github.com/evmos/ethermint/x/evm/types\"\n)\n\n// Hooks wrapper struct for fees keeper\ntype Hooks struct {\n\tk Keeper\n}\n\nvar (\n\t_                 evmtypes.EvmHooks = Hooks{}\n\tTurnstileContract abi.ABI           = contracts.TurnstileContract.ABI\n)\n\n// Hooks return the wrapper hooks struct for the Keeper\nfunc (k Keeper) Hooks() Hooks {\n\treturn Hooks{k}\n}\n\n// The PostTxProcessing hook implements EvmHooks.PostTxProcessing. The EVM hook allows\n// users to utilize the Turnstile smart contract to register and assign smart contracts\n// to a CSR NFT + distribute transaction fees for contracts that are already registered\n// to some NFT. After each successful EVM transaction, the PostTxProcessing hook will\n// check if any of the events emitted in the tx originate from the Turnstile address.\n// If some event does exist, the event handler will process and update state accordingly.\n// At the very end of the hook, the hook will check if the To address in the tx belongs\n// to any NFT currently in state. If so, the fees will be split and distributed to the\n// Turnstile Address / NFT.\nfunc (h Hooks) PostTxProcessing(ctx sdk.Context, msg core.Message, receipt *ethtypes.Receipt) error {\n\t// Check if the csr module has been enabled\n\tparams := h.k.GetParams(ctx)\n\tif !params.EnableCsr {\n\t\treturn nil\n\t}\n\n\t// Check and process turnstile events if applicable\n\th.processEvents(ctx, receipt)\n\n\tcontract := msg.To()\n\tif contract == nil {\n\t\treturn nil\n\t}\n\n\tnftID, foundNFT := h.k.GetNFTByContract(ctx, contract.String())\n\tif !foundNFT {\n\t\treturn nil\n\t}\n\n\tcsr, found := h.k.GetCSR(ctx, nftID)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrNonexistentCSR, \"EVMHook::PostTxProcessing the NFT ID was found but the CSR was not: %d\", nftID)\n\t}\n\n\t// Calculate fees to be distributed = intFloor(GasUsed * GasPrice * csrShares)\n\tfee := sdk.NewIntFromUint64(receipt.GasUsed).Mul(sdk.NewIntFromBigInt(msg.GasPrice()))\n\tcsrFee := sdk.NewDecFromInt(fee).Mul(params.CsrShares).TruncateInt()\n\tevmDenom := h.k.evmKeeper.GetParams(ctx).EvmDenom\n\tcsrFees := sdk.Coins{{Denom: evmDenom, Amount: csrFee}}\n\n\t// Send fees from fee collector to module account before distribution\n\terr := h.k.bankKeeper.SendCoinsFromModuleToModule(ctx, h.k.FeeCollectorName, types.ModuleName, csrFees)\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from fee collector to module acount, %d\", err)\n\t}\n\n\t// Get the turnstile which will receive funds for tx fees\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\treturn sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\")\n\t}\n\n\t// Distribute fees to turnstile contract by NFT ID distributeFees(amount, nftID)\n\tamount := csrFee.BigInt()\n\t_, err = h.k.CallMethod(ctx, \"distributeFees\", contracts.TurnstileContract, types.ModuleAddress, &turnstileAddress, amount, new(big.Int).SetUint64(nftID))\n\tif err != nil {\n\t\treturn sdkerrors.Wrapf(ErrFeeDistribution, \"EVMHook::PostTxProcessing failed to distribute fees from module account to turnstile, %d\", err)\n\t}\n\n\t// Update metrics on the CSR obj\n\tcsr.Txs += 1\n\tcsr.Revenue = csr.Revenue.Add(csrFee)\n\n\t// Store updated CSR\n\th.k.SetCSR(ctx, *csr)\n\n\treturn nil\n}\n\nfunc (h Hooks) processEvents(ctx sdk.Context, receipt *ethtypes.Receipt) {\n\t// Get the turnstile address from which state transition events are emitted\n\tturnstileAddress, found := h.k.GetTurnstile(ctx)\n\tif !found {\n\t\tpanic(sdkerrors.Wrapf(ErrContractDeployments, \"EVMHook::PostTxProcessing the turnstile contract has not been found.\"))\n\t}\n\n\tfor _, log := range receipt.Logs {\n\t\tif len(log.Topics) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Only process events that originate from the Turnstile contract\n\t\teventID := log.Topics[0]\n\t\tif log.Address == turnstileAddress {\n\t\t\tevent, err := TurnstileContract.EventByID(eventID)\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// switch and process based on the turnstile event type\n\t\t\tswitch event.Name {\n\t\t\tcase types.TurnstileEventRegister:\n\t\t\t\terr = h.k.RegisterEvent(ctx, log.Data)\n\t\t\tcase types.TurnstileEventUpdate:\n\t\t\t\terr = h.k.UpdateEvent(ctx, log.Data)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\th.k.Logger(ctx).Error(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}"
    }
  ]
}