{
  "Title": "[M-04] It's possible to swap NFT token ids without fee and also attacker can wrap unwrap all the NFT token balance of the Pair contract and steal their air drops for those token ids",
  "Content": "\n<https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L217-L243> <br><https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L248-L262>\n\nUsers can `wrap()` their NFT tokens (which id is whitelisted) and receive `1e18` fractional token or they can pay `1e18` fractional token and unwrap NFT token. there is two issue here:\n\n1.  anyone can swap their NFT token id with another NFT token id without paying any fee(both ids should be whitelisted). it's swap without fee.\n2.  attacker can swap his NFT token(with whitelisted id) for all the NFT balance of contract and steal those NFT tokens airdrop all in one transaction.\n\n### Proof of Concept\n\nThis is `wrap()` and `unwrap()` code:\n\n        function wrap(uint256[] calldata tokenIds, bytes32[][] calldata proofs)\n            public\n            returns (uint256 fractionalTokenAmount)\n        {\n            // *** Checks *** //\n\n            // check that wrapping is not closed\n            require(closeTimestamp == 0, \"Wrap: closed\");\n\n            // check the tokens exist in the merkle root\n            _validateTokenIds(tokenIds, proofs);\n\n            // *** Effects *** //\n\n            // mint fractional tokens to sender\n            fractionalTokenAmount = tokenIds.length * ONE;\n            _mint(msg.sender, fractionalTokenAmount);\n\n            // *** Interactions *** //\n\n            // transfer nfts from sender\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n            }\n\n            emit Wrap(tokenIds);\n        }\n\n        function unwrap(uint256[] calldata tokenIds) public returns (uint256 fractionalTokenAmount) {\n            // *** Effects *** //\n\n            // burn fractional tokens from sender\n            fractionalTokenAmount = tokenIds.length * ONE;\n            _burn(msg.sender, fractionalTokenAmount);\n\n            // *** Interactions *** //\n\n            // transfer nfts to sender\n            for (uint256 i = 0; i < tokenIds.length; i++) {\n                ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n            }\n\n            emit Unwrap(tokenIds);\n        }\n\nAs you can see it's possible to wrap one NFT token (which id is whitelisted and is in merkle tree) and unwrap another NFT token without paying fee. so Pair contract create NFT swap without fee for users but there is no fee generated for those who wrapped and put their fractional tokens as liquidity providers.\nThe other issue with this is that some NFT tokens air drop new NFT tokens for NFT holders by making NFT holders to call `getAirdrop()` function. attacker can use this swap functionality to get air drop token for all the NFT balance of the Pair contract. to steps to perform this attack:\n\n1.  if Pair contract is for NFT1 and baseToken1 and also merkle tree root hash is 0x0.\n2.  users deposited 100 NFT1 tokens to the Pair contract.\n3.  NFT1 decide to airdrop some new tokens for token holders and token holders need to call `nft.getAirDrop(id)` while they own the NFT id.\n4.  attacker would create a contract and buy one of the NFT1 tokens (attackerID1) and wrap it to receive `1e18` fractional tokens and perform this steps in the contract:<br>\n    4.1 loop through all the NFT tokens in the Pair contract balance and:<br>\n    4.2 unwrap NFT token id=i from Pair contract by paying `1e18` fractional token.<br>\n    4.3 call `nft.getAirDrop(i)` and receive the new airdrop token. (the name of the function can be other thing not exactly `getAirDrop()`)<br>\n    4.4 wrap NFT token id=i and receive `1e18` fractional token.\n\n5. in the end attacker would unwrap attackerID1 token from Pair contract.<br>\nso attacker was able to receive all the air drops of the NFT tokens that were in the contract address, there could be 100 or 1000 NFT tokens in the contract address and attacker can steal their air drops in one transaction(by writing a contract). those air drops belongs to all the fractional owners and contract shouldn't allow one user to take all the air drops for himself. as airdrops are common in NFT collections so this bug is critical and would happen.\n\nalso some of the NFT tokens allows users to stake some tokens for their NFT tokens and receive rewards(for example BAYC/MAYC). if a user stakes tokens for his NFT tokens then wrap those NFT tokens then it would be possible for attacker to unwrap those tokens and steal user staked amounts. in this scenario user made a risky move and wrapped NFT tokens while they have stake but as a lot of users wants to stake for their NFTs this would make them unable to use caviar protocol.\n\nalso any other action that attacker can perform by becoming the owner of the NFT token is possible by this attack and if that action can harm the NFT token holders then attacker can harm by doing this attack and performing that action.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nThe real solution to prevent this attack (stealing air drops) can be hard. some of the things can be done is:\n* create functionality so admin can call `getAirDrop()` functions during the airdrops before attacker.\n* call `getAirDrop()` (which admin specified) function before unwrapping tokens.\n* make some fee for NFT token unwrapping.\n* create some lock time(some days) for each wrapped NFT that in that lock time only the one who supplied that token can unwrap it.\n* create some delay for unwrapping tokens and if user wants to unwrap token he would receive it after this delay.\n\n**[outdoteth (Caviar) acknowledged, but disagreed with severity](https://github.com/code-423n4/2022-12-caviar-findings/issues/367#event-8160517199)**\n\n**[berndartmueller (judge) decreased severity to Medium](https://github.com/code-423n4/2022-12-caviar-findings/issues/367#event-8227237597)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-caviar-contest",
  "Code": [
    {
      "filename": "src/Pair.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/tokens/ERC721.sol\";\nimport \"solmate/utils/MerkleProofLib.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"openzeppelin/utils/math/Math.sol\";\n\nimport \"./LpToken.sol\";\nimport \"./Caviar.sol\";\n\n/// @title Pair\n/// @author out.eth (@outdoteth)\n/// @notice A pair of an NFT and a base token that can be used to create and trade fractionalized NFTs.\ncontract Pair is ERC20, ERC721TokenReceiver {\n    using SafeTransferLib for address;\n    using SafeTransferLib for ERC20;\n\n    uint256 public constant ONE = 1e18;\n    uint256 public constant CLOSE_GRACE_PERIOD = 7 days;\n\n    address public immutable nft;\n    address public immutable baseToken; // address(0) for ETH\n    bytes32 public immutable merkleRoot;\n    LpToken public immutable lpToken;\n    Caviar public immutable caviar;\n    uint256 public closeTimestamp;\n\n    event Add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n    event Remove(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n    event Buy(uint256 inputAmount, uint256 outputAmount);\n    event Sell(uint256 inputAmount, uint256 outputAmount);\n    event Wrap(uint256[] tokenIds);\n    event Unwrap(uint256[] tokenIds);\n    event Close(uint256 closeTimestamp);\n    event Withdraw(uint256 tokenId);\n\n    constructor(\n        address _nft,\n        address _baseToken,\n        bytes32 _merkleRoot,\n        string memory pairSymbol,\n        string memory nftName,\n        string memory nftSymbol\n    ) ERC20(string.concat(nftName, \" fractional token\"), string.concat(\"f\", nftSymbol), 18) {\n        nft = _nft;\n        baseToken = _baseToken; // use address(0) for native ETH\n        merkleRoot = _merkleRoot;\n        lpToken = new LpToken(pairSymbol);\n        caviar = Caviar(msg.sender);\n    }\n\n    // ************************ //\n    //      Core AMM logic      //\n    // ***********************  //\n\n    /// @notice Adds liquidity to the pair.\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param fractionalTokenAmount The amount of fractional tokens to add.\n    /// @param minLpTokenAmount The minimum amount of LP tokens to mint.\n    /// @return lpTokenAmount The amount of LP tokens minted.\n    function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)\n        public\n        payable\n        returns (uint256 lpTokenAmount)\n    {\n        // *** Checks *** //\n\n        // check the token amount inputs are not zero\n        require(baseTokenAmount > 0 && fractionalTokenAmount > 0, \"Input token amount is zero\");\n\n        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used\n        require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, \"Invalid ether input\");\n\n        // calculate the lp token shares to mint\n        lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);\n\n        // check that the amount of lp tokens outputted is greater than the min amount\n        require(lpTokenAmount >= minLpTokenAmount, \"Slippage: lp token amount out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens in\n        _transferFrom(msg.sender, address(this), fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // mint lp tokens to sender\n        lpToken.mint(msg.sender, lpTokenAmount);\n\n        // transfer base tokens in if the base token is not ETH\n        if (baseToken != address(0)) {\n            // transfer base tokens in\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n        }\n\n        emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);\n    }\n\n    /// @notice Removes liquidity from the pair.\n    /// @param lpTokenAmount The amount of LP tokens to burn.\n    /// @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.\n    /// @param minFractionalTokenOutputAmount The minimum amount of fractional tokens to receive.\n    /// @return baseTokenOutputAmount The amount of base tokens received.\n    /// @return fractionalTokenOutputAmount The amount of fractional tokens received.\n    function remove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256 minFractionalTokenOutputAmount)\n        public\n        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)\n    {\n        // *** Checks *** //\n\n        // calculate the output amounts\n        (baseTokenOutputAmount, fractionalTokenOutputAmount) = removeQuote(lpTokenAmount);\n\n        // check that the base token output amount is greater than the min amount\n        require(baseTokenOutputAmount >= minBaseTokenOutputAmount, \"Slippage: base token amount out\");\n\n        // check that the fractional token output amount is greater than the min amount\n        require(fractionalTokenOutputAmount >= minFractionalTokenOutputAmount, \"Slippage: fractional token out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens to sender\n        _transferFrom(address(this), msg.sender, fractionalTokenOutputAmount);\n\n        // *** Interactions *** //\n\n        // burn lp tokens from sender\n        lpToken.burn(msg.sender, lpTokenAmount);\n\n        if (baseToken == address(0)) {\n            // if base token is native ETH then send ether to sender\n            msg.sender.safeTransferETH(baseTokenOutputAmount);\n        } else {\n            // transfer base tokens to sender\n            ERC20(baseToken).safeTransfer(msg.sender, baseTokenOutputAmount);\n        }\n\n        emit Remove(baseTokenOutputAmount, fractionalTokenOutputAmount, lpTokenAmount);\n    }\n\n    /// @notice Buys fractional tokens from the pair.\n    /// @param outputAmount The amount of fractional tokens to buy.\n    /// @param maxInputAmount The maximum amount of base tokens to spend.\n    /// @return inputAmount The amount of base tokens spent.\n    function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n        // *** Checks *** //\n\n        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used\n        require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, \"Invalid ether input\");\n\n        // calculate required input amount using xyk invariant\n        inputAmount = buyQuote(outputAmount);\n\n        // check that the required amount of base tokens is less than the max amount\n        require(inputAmount <= maxInputAmount, \"Slippage: amount in\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens to sender\n        _transferFrom(address(this), msg.sender, outputAmount);\n\n        // *** Interactions *** //\n\n        if (baseToken == address(0)) {\n            // refund surplus eth\n            uint256 refundAmount = maxInputAmount - inputAmount;\n            if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);\n        } else {\n            // transfer base tokens in\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n        }\n\n        emit Buy(inputAmount, outputAmount);\n    }\n\n    /// @notice Sells fractional tokens to the pair.\n    /// @param inputAmount The amount of fractional tokens to sell.\n    /// @param minOutputAmount The minimum amount of base tokens to receive.\n    /// @return outputAmount The amount of base tokens received.\n    function sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {\n        // *** Checks *** //\n\n        // calculate output amount using xyk invariant\n        outputAmount = sellQuote(inputAmount);\n\n        // check that the outputted amount of fractional tokens is greater than the min amount\n        require(outputAmount >= minOutputAmount, \"Slippage: amount out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens from sender\n        _transferFrom(msg.sender, address(this), inputAmount);\n\n        // *** Interactions *** //\n\n        if (baseToken == address(0)) {\n            // transfer ether out\n            msg.sender.safeTransferETH(outputAmount);\n        } else {\n            // transfer base tokens out\n            ERC20(baseToken).safeTransfer(msg.sender, outputAmount);\n        }\n\n        emit Sell(inputAmount, outputAmount);\n    }\n\n    // ******************** //\n    //      Wrap logic      //\n    // ******************** //\n\n    /// @notice Wraps NFTs into fractional tokens.\n    /// @param tokenIds The ids of the NFTs to wrap.\n    /// @param proofs The merkle proofs for the NFTs proving that they can be used in the pair.\n    /// @return fractionalTokenAmount The amount of fractional tokens minted.\n    function wrap(uint256[] calldata tokenIds, bytes32[][] calldata proofs)\n        public\n        returns (uint256 fractionalTokenAmount)\n    {\n        // *** Checks *** //\n\n        // check that wrapping is not closed\n        require(closeTimestamp == 0, \"Wrap: closed\");\n\n        // check the tokens exist in the merkle root\n        _validateTokenIds(tokenIds, proofs);\n\n        // *** Effects *** //\n\n        // mint fractional tokens to sender\n        fractionalTokenAmount = tokenIds.length * ONE;\n        _mint(msg.sender, fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // transfer nfts from sender\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        emit Wrap(tokenIds);\n    }\n\n    /// @notice Unwraps fractional tokens into NFTs.\n    /// @param tokenIds The ids of the NFTs to unwrap.\n    /// @return fractionalTokenAmount The amount of fractional tokens burned.\n    function unwrap(uint256[] calldata tokenIds) public returns (uint256 fractionalTokenAmount) {\n        // *** Effects *** //\n\n        // burn fractional tokens from sender\n        fractionalTokenAmount = tokenIds.length * ONE;\n        _burn(msg.sender, fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // transfer nfts to sender\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n        }\n\n        emit Unwrap(tokenIds);\n    }\n\n    // *********************** //\n    //      NFT AMM logic      //\n    // *********************** //\n\n    /// @notice nftAdd Adds liquidity to the pair using NFTs.\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param tokenIds The ids of the NFTs to add.\n    /// @param minLpTokenAmount The minimum amount of lp tokens to receive.\n    /// @param proofs The merkle proofs for the NFTs.\n    /// @return lpTokenAmount The amount of lp tokens minted.\n    function nftAdd(\n        uint256 baseTokenAmount,\n        uint256[] calldata tokenIds,\n        uint256 minLpTokenAmount,\n        bytes32[][] calldata proofs\n    ) public payable returns (uint256 lpTokenAmount) {\n        // wrap the incoming NFTs into fractional tokens\n        uint256 fractionalTokenAmount = wrap(tokenIds, proofs);\n\n        // add liquidity using the fractional tokens and base tokens\n        lpTokenAmount = add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);\n    }\n\n    /// @notice Removes liquidity from the pair using NFTs.\n    /// @param lpTokenAmount The amount of lp tokens to remove.\n    /// @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.\n    /// @param tokenIds The ids of the NFTs to remove.\n    /// @return baseTokenOutputAmount The amount of base tokens received.\n    /// @return fractionalTokenOutputAmount The amount of fractional tokens received.\n    function nftRemove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256[] calldata tokenIds)\n        public\n        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)\n    {\n        // remove liquidity and send fractional tokens and base tokens to sender\n        (baseTokenOutputAmount, fractionalTokenOutputAmount) =\n            remove(lpTokenAmount, minBaseTokenOutputAmount, tokenIds.length * ONE);\n\n        // unwrap the fractional tokens into NFTs and send to sender\n        unwrap(tokenIds);\n    }\n\n    /// @notice Buys NFTs from the pair using base tokens.\n    /// @param tokenIds The ids of the NFTs to buy.\n    /// @param maxInputAmount The maximum amount of base tokens to spend.\n    /// @return inputAmount The amount of base tokens spent.\n    function nftBuy(uint256[] calldata tokenIds, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n        // buy fractional tokens using base tokens\n        inputAmount = buy(tokenIds.length * ONE, maxInputAmount);\n\n        // unwrap the fractional tokens into NFTs and send to sender\n        unwrap(tokenIds);\n    }\n\n    /// @notice Sells NFTs to the pair for base tokens.\n    /// @param tokenIds The ids of the NFTs to sell.\n    /// @param minOutputAmount The minimum amount of base tokens to receive.\n    /// @param proofs The merkle proofs for the NFTs.\n    /// @return outputAmount The amount of base tokens received.\n    function nftSell(uint256[] calldata tokenIds, uint256 minOutputAmount, bytes32[][] calldata proofs)\n        public\n        returns (uint256 outputAmount)\n    {\n        // wrap the incoming NFTs into fractional tokens\n        uint256 inputAmount = wrap(tokenIds, proofs);\n\n        // sell fractional tokens for base tokens\n        outputAmount = sell(inputAmount, minOutputAmount);\n    }\n\n    // ****************************** //\n    //      Emergency exit logic      //\n    // ****************************** //\n\n    /// @notice Closes the pair to new wraps.\n    /// @dev Can only be called by the caviar owner. This is used as an emergency exit in case\n    ///      the caviar owner suspects that the pair has been compromised.\n    function close() public {\n        // check that the sender is the caviar owner\n        require(caviar.owner() == msg.sender, \"Close: not owner\");\n\n        // set the close timestamp with a grace period\n        closeTimestamp = block.timestamp + CLOSE_GRACE_PERIOD;\n\n        // remove the pair from the Caviar contract\n        caviar.destroy(nft, baseToken, merkleRoot);\n\n        emit Close(closeTimestamp);\n    }\n\n    /// @notice Withdraws a particular NFT from the pair.\n    /// @dev Can only be called by the caviar owner after the close grace period has passed. This\n    ///      is used to auction off the NFTs in the pair in case NFTs get stuck due to liquidity\n    ///      imbalances. Proceeds from the auction should be distributed pro rata to fractional\n    ///      token holders. See documentation for more details.\n    function withdraw(uint256 tokenId) public {\n        // check that the sender is the caviar owner\n        require(caviar.owner() == msg.sender, \"Withdraw: not owner\");\n\n        // check that the close period has been set\n        require(closeTimestamp != 0, \"Withdraw not initiated\");\n\n        // check that the close grace period has passed\n        require(block.timestamp >= closeTimestamp, \"Not withdrawable yet\");\n\n        // transfer the nft to the caviar owner\n        ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenId);\n\n        emit Withdraw(tokenId);\n    }\n\n    // ***************** //\n    //      Getters      //\n    // ***************** //\n\n    function baseTokenReserves() public view returns (uint256) {\n        return _baseTokenReserves();\n    }\n\n    function fractionalTokenReserves() public view returns (uint256) {\n        return balanceOf[address(this)];\n    }\n\n    /// @notice The current price of one fractional token in base tokens with 18 decimals of precision.\n    /// @dev Calculated by dividing the base token reserves by the fractional token reserves.\n    /// @return price The price of one fractional token in base tokens * 1e18.\n    function price() public view returns (uint256) {\n        return (_baseTokenReserves() * ONE) / fractionalTokenReserves();\n    }\n\n    /// @notice The amount of base tokens required to buy a given amount of fractional tokens.\n    /// @dev Calculated using the xyk invariant and a 30bps fee.\n    /// @param outputAmount The amount of fractional tokens to buy.\n    /// @return inputAmount The amount of base tokens required.\n    function buyQuote(uint256 outputAmount) public view returns (uint256) {\n        return (outputAmount * 1000 * baseTokenReserves()) / ((fractionalTokenReserves() - outputAmount) * 997);\n    }\n\n    /// @notice The amount of base tokens received for selling a given amount of fractional tokens.\n    /// @dev Calculated using the xyk invariant and a 30bps fee.\n    /// @param inputAmount The amount of fractional tokens to sell.\n    /// @return outputAmount The amount of base tokens received.\n    function sellQuote(uint256 inputAmount) public view returns (uint256) {\n        uint256 inputAmountWithFee = inputAmount * 997;\n        return (inputAmountWithFee * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + inputAmountWithFee);\n    }\n\n    /// @notice The amount of lp tokens received for adding a given amount of base tokens and fractional tokens.\n    /// @dev Calculated as a share of existing deposits. If there are no existing deposits, then initializes to\n    ///      sqrt(baseTokenAmount * fractionalTokenAmount).\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param fractionalTokenAmount The amount of fractional tokens to add.\n    /// @return lpTokenAmount The amount of lp tokens received.\n    function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {\n        uint256 lpTokenSupply = lpToken.totalSupply();\n        if (lpTokenSupply > 0) {\n            // calculate amount of lp tokens as a fraction of existing reserves\n            uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();\n            uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();\n            return Math.min(baseTokenShare, fractionalTokenShare);\n        } else {\n            // if there is no liquidity then init\n            return Math.sqrt(baseTokenAmount * fractionalTokenAmount);\n        }\n    }\n\n    /// @notice The amount of base tokens and fractional tokens received for burning a given amount of lp tokens.\n    /// @dev Calculated as a share of existing deposits.\n    /// @param lpTokenAmount The amount of lp tokens to burn.\n    /// @return baseTokenAmount The amount of base tokens received.\n    /// @return fractionalTokenAmount The amount of fractional tokens received.\n    function removeQuote(uint256 lpTokenAmount) public view returns (uint256, uint256) {\n        uint256 lpTokenSupply = lpToken.totalSupply();\n        uint256 baseTokenOutputAmount = (baseTokenReserves() * lpTokenAmount) / lpTokenSupply;\n        uint256 fractionalTokenOutputAmount = (fractionalTokenReserves() * lpTokenAmount) / lpTokenSupply;\n\n        return (baseTokenOutputAmount, fractionalTokenOutputAmount);\n    }\n\n    // ************************ //\n    //      Internal utils      //\n    // ************************ //\n\n    function _transferFrom(address from, address to, uint256 amount) internal returns (bool) {\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /// @dev Validates that the given tokenIds are valid for the contract's merkle root. Reverts\n    ///      if any of the tokenId proofs are invalid.\n    function _validateTokenIds(uint256[] calldata tokenIds, bytes32[][] calldata proofs) internal view {\n        // if merkle root is not set then all tokens are valid\n        if (merkleRoot == bytes23(0)) return;\n\n        // validate merkle proofs against merkle root\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            bool isValid = MerkleProofLib.verify(proofs[i], merkleRoot, keccak256(abi.encodePacked(tokenIds[i])));\n            require(isValid, \"Invalid merkle proof\");\n        }\n    }\n\n    /// @dev Returns the current base token reserves. If the base token is ETH then it ignores\n    ///      the msg.value that is being sent in the current call context - this is to ensure the\n    ///      xyk math is correct in the buy() and add() functions.\n    function _baseTokenReserves() internal view returns (uint256) {\n        return baseToken == address(0)\n            ? address(this).balance - msg.value // subtract the msg.value if the base token is ETH\n            : ERC20(baseToken).balanceOf(address(this));\n    }\n}"
    }
  ]
}