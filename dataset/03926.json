{
  "Title": "[C05] Anyone with enough liquidity to reach the maxGenesisPrice can make profit from genesis",
  "Content": "The [`GenesisGroup` contract](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol) allows users to deposit ETH through the [`purchase` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L80) in exchange for `FGEN` tokens, which represent the proportion of the total ETH in the contract that the user deposited. After the [genesis period has ended or after the `maxGenesisPrice` has been reached](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L106), the protocol can be launched via the [`launch` function](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L105) (which can be called by anyone). After the protocol is launched, users will be able to [`redeem`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L89) `FEI` and `TRIBE` tokens proportional to the amount of `FGEN` tokens they own.\n\n\nSince all of the operations mentioned above can be executed in the same transaction, a flash loan could be used to steal ETH using the following attack:\n\n\n1. Borrow the amount of ETH necessary to increase the [average price](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L146) to the `maxGenesisPrice`.\n2. Launch the protocol by calling the `launch` function. This operation will:\n\n\n– [Initialize the bonding curve oracle](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L113), which will start with an initial price that equals the `maxGenesisPrice`.  \n\n– Purchase `FEI` in the bonding curve so that users can redeem them.  \n\n– Add liquidity to the [`FEI/TRIBE`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/IDO.sol#L38) Uniswap pool at an exchange rate based on the amount of `FEI` purchased in the genesis period, the [amount of `TRIBE` held by the `IDO` contract](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/orchestration/CoreOrchestrator.sol#L155)  and the [`exchangeRateDiscount`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L162) variable.  \n\n– Add liquidity to the [`ETH/FEI`](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pcv/EthUniswapPCVDeposit.sol#L55) Uniswap pool.  \n\n3. Call the `redeem` function to withdraw `FEI` and `TRIBE` tokens [based on the ratio of `FGEN` owned](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/genesis/GenesisGroup.sol#L96-L100).  \n\n4. Sell all the `TRIBE` earned in exchange for `FEI` in the initialized `FEI/TRIBE` Uniswap pool.  \n\n5. Sell all the `FEI` (earned from the `redeem` function, and from selling `TRIBE`) in the initialized `ETH/FEI` pool in exchange for ETH.  \n\n6. Repay the loan and keep the remaining ETH as profit.\n\n\nThe amount used by the attacker should be such that they can afford the price impact on Uniswap’s `ETH/FEI` pair, and still make profit. A spreadsheet that calculates this amount can be found [here](https://docs.google.com/spreadsheets/d/1ZT2hjcKJeXJjEEuqyDbu6Mo1XBFr6Vdn_Q-aLFpSzzM/edit#gid=0).\n\n\nIf this attack is performed, then:\n\n\n* The `ETH/FEI` Uniswap pool price will be below the bonding curve oracle’s peg, [forcing a reweight](https://github.com/fei-protocol/fei-protocol-core/blob/29aeefddd97f31c7f2a598fb3dca3ef24dc0beb4/contracts/pcv/EthUniswapPCVController.sol#L59), or other users in the system will try to restore the peg by interacting with the incentive contracts.\n* The `ETH/FEI` Uniswap pool will be launched with less ETH than expected.\n* The `FEI/TRIBE` pool will be launched with less `FEI` and a lower price than expected.\n* The attacker will steal around 800,000 USD in ETH from the protocol.\n\n\nNote that this attack is feasible even without a flash loan, for example, by a user with enough liquidity to reach the `maxGenesisPrice` with a purchase.\n\n\nConsider flagging the block where the `maxGenesisPrice` is reached in a global variable and restricting the `launch` function to only be called when the current block number is higher than this value. Additionally, consider revising the `exchangeRateDiscount` amount so that this scenario is not profitable for a user with enough liquidity nor for an attacker using a flash loan.\n\n\n**Update:** *Fixed in [PR#27](https://github.com/fei-protocol/fei-protocol-core/pull/27). The flash loan attack was fixed by disallowing to launch the protocol and redeem `FEI` and `TRIBE` in the same transaction. Additionally, the initial bonidng curve oracle price [has been decreased](https://github.com/fei-protocol/fei-protocol-core/pull/27/files#diff-cedd2b628f5acaa0f34fa730a0891aaea9e105e490712a7ed83abd0229a21ee3R154) to drastically reduce the profit that users with enough liquidity would make by selling all their `FEI` and `TRIBE` tokens right after the protocol is launched.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/genesis/GenesisGroup.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IGenesisGroup.sol\";\nimport \"./IDOInterface.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../refs/CoreRef.sol\";\nimport \"../pool/IPool.sol\";\nimport \"../oracle/IBondingCurveOracle.sol\";\nimport \"../bondingcurve/IBondingCurve.sol\";\n\ninterface IOrchestrator {\n\tfunction launchGovernance() external;\n\tfunction pool() external returns(address);\n\tfunction bondingCurveOracle() external returns(address);\n}\n\n/// @title IGenesisGroup implementation\n/// @author Fei Protocol\ncontract GenesisGroup is IGenesisGroup, CoreRef, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\n\tIOrchestrator private orchestrator;\n\n\tIBondingCurve private bondingcurve;\n\n\tIBondingCurveOracle private bondingCurveOracle;\n\n\tIPool private pool;\n\n\tIDOInterface private ido;\n\tuint private exchangeRateDiscount;\n\n\t/// @notice a cap on the genesis group purchase price\n\tDecimal.D256 public maxGenesisPrice;\n\n\t/// @notice GenesisGroup constructor\n\t/// @param _core Fei Core address to reference\n\t/// @param _bondingcurve Bonding curve address for purchase\n\t/// @param _ido IDO contract to deploy\n\t/// @param _oracle Bonding curve oracle\n\t/// @param _pool Staking Pool\n\t/// @param _duration duration of the Genesis Period\n\t/// @param _maxPriceBPs max price of FEI allowed in Genesis Group in dollar terms\n\t/// @param _exchangeRateDiscount a divisor on the FEI/TRIBE ratio at Genesis to deploy to the IDO\n\tconstructor(\n\t\taddress _core, \n\t\taddress _bondingcurve,\n\t\taddress _ido,\n\t\taddress _oracle,\n\t\taddress _pool,\n\t\tuint32 _duration,\n\t\tuint _maxPriceBPs,\n\t\tuint _exchangeRateDiscount\n\t) public\n\t\tCoreRef(_core)\n\t\tERC20(\"Fei Genesis Group\", \"FGEN\")\n\t\tTimed(_duration)\n\t{\n\t\tbondingcurve = IBondingCurve(_bondingcurve);\n\n\t\texchangeRateDiscount = _exchangeRateDiscount;\n\t\tido = IDOInterface(_ido);\n\n\t\tpool = IPool(_pool);\n\t\tbondingCurveOracle = IBondingCurveOracle(_oracle);\n\n\t\t_initTimed();\n\n\t\tmaxGenesisPrice = Decimal.ratio(_maxPriceBPs, 10000);\n\t}\n\n\tmodifier onlyGenesisPeriod() {\n\t\trequire(!isTimeEnded(), \"GenesisGroup: Not in Genesis Period\");\n\t\t_;\n\t}\n\n\tfunction purchase(address to, uint value) external override payable onlyGenesisPeriod {\n\t\trequire(msg.value == value, \"GenesisGroup: value mismatch\");\n\t\trequire(value != 0, \"GenesisGroup: no value sent\");\n\n\t\t_mint(to, value);\n\n\t\temit Purchase(to, value);\n\t}\n\n\tfunction redeem(address to) external override postGenesis {\n\t\tDecimal.D256 memory ratio = _fgenRatio(to);\n\t\trequire(!ratio.equals(Decimal.zero()), \"GensisGroup: No balance to redeem\");\n\n\t\tuint amountIn = balanceOf(to);\n\t\tburnFrom(to, amountIn);\n\n\t\tuint feiAmount = ratio.mul(feiBalance()).asUint256();\n\t\tfei().transfer(to, feiAmount);\n\n\t\tuint tribeAmount = ratio.mul(tribeBalance()).asUint256();\n\t\ttribe().transfer(to, tribeAmount);\n\n\t\temit Redeem(to, amountIn, feiAmount, tribeAmount);\n\t}\n\n\tfunction launch() external override {\n\t\trequire(isTimeEnded() || isAtMaxPrice(), \"GenesisGroup: Still in Genesis Period\");\n\n\t\tcore().completeGenesisGroup();\n\n\t\taddress genesisGroup = address(this);\n\t\tuint balance = genesisGroup.balance;\n\n\t\tbondingCurveOracle.init(bondingcurve.getAveragePrice(balance));\n\n\t\tbondingcurve.purchase{value: balance}(genesisGroup, balance);\n\t\tbondingcurve.allocate();\n\n\t\tpool.init();\n\n\t\tido.deploy(_feiTribeExchangeRate());\n\n\t\t// solhint-disable-next-line not-rely-on-time\n\t\temit Launch(now);\n\t}\n\n\tfunction getAmountOut(\n\t\tuint amountIn, \n\t\tbool inclusive\n\t) public view override returns (uint feiAmount, uint tribeAmount) {\n\t\tuint totalIn = totalSupply();\n\t\tif (!inclusive) {\n\t\t\ttotalIn += amountIn;\n\t\t}\n\t\trequire(amountIn <= totalIn, \"GenesisGroup: Not enough supply\");\n\n\t\tuint totalFei = bondingcurve.getAmountOut(totalIn);\n\t\tuint totalTribe = tribeBalance();\n\n\t\treturn (totalFei * amountIn / totalIn, totalTribe * amountIn / totalIn);\n\t}\n\n\tfunction isAtMaxPrice() public view override returns(bool) {\n\t\tuint balance = address(this).balance;\n\t\trequire(balance != 0, \"GenesisGroup: No balance\");\n\n\t\treturn bondingcurve.getAveragePrice(balance).greaterThanOrEqualTo(maxGenesisPrice);\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\t// Sender doesn't need approval\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _fgenRatio(address account) internal view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(balanceOf(account), totalSupply());\n\t}\n\n\tfunction _feiTribeExchangeRate() public view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(feiBalance(), tribeBalance()).div(exchangeRateDiscount);\n\t}\n}"
    },
    {
      "filename": "contracts/genesis/GenesisGroup.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IGenesisGroup.sol\";\nimport \"./IDOInterface.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../refs/CoreRef.sol\";\nimport \"../pool/IPool.sol\";\nimport \"../oracle/IBondingCurveOracle.sol\";\nimport \"../bondingcurve/IBondingCurve.sol\";\n\ninterface IOrchestrator {\n\tfunction launchGovernance() external;\n\tfunction pool() external returns(address);\n\tfunction bondingCurveOracle() external returns(address);\n}\n\n/// @title IGenesisGroup implementation\n/// @author Fei Protocol\ncontract GenesisGroup is IGenesisGroup, CoreRef, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\n\tIOrchestrator private orchestrator;\n\n\tIBondingCurve private bondingcurve;\n\n\tIBondingCurveOracle private bondingCurveOracle;\n\n\tIPool private pool;\n\n\tIDOInterface private ido;\n\tuint private exchangeRateDiscount;\n\n\t/// @notice a cap on the genesis group purchase price\n\tDecimal.D256 public maxGenesisPrice;\n\n\t/// @notice GenesisGroup constructor\n\t/// @param _core Fei Core address to reference\n\t/// @param _bondingcurve Bonding curve address for purchase\n\t/// @param _ido IDO contract to deploy\n\t/// @param _oracle Bonding curve oracle\n\t/// @param _pool Staking Pool\n\t/// @param _duration duration of the Genesis Period\n\t/// @param _maxPriceBPs max price of FEI allowed in Genesis Group in dollar terms\n\t/// @param _exchangeRateDiscount a divisor on the FEI/TRIBE ratio at Genesis to deploy to the IDO\n\tconstructor(\n\t\taddress _core, \n\t\taddress _bondingcurve,\n\t\taddress _ido,\n\t\taddress _oracle,\n\t\taddress _pool,\n\t\tuint32 _duration,\n\t\tuint _maxPriceBPs,\n\t\tuint _exchangeRateDiscount\n\t) public\n\t\tCoreRef(_core)\n\t\tERC20(\"Fei Genesis Group\", \"FGEN\")\n\t\tTimed(_duration)\n\t{\n\t\tbondingcurve = IBondingCurve(_bondingcurve);\n\n\t\texchangeRateDiscount = _exchangeRateDiscount;\n\t\tido = IDOInterface(_ido);\n\n\t\tpool = IPool(_pool);\n\t\tbondingCurveOracle = IBondingCurveOracle(_oracle);\n\n\t\t_initTimed();\n\n\t\tmaxGenesisPrice = Decimal.ratio(_maxPriceBPs, 10000);\n\t}\n\n\tmodifier onlyGenesisPeriod() {\n\t\trequire(!isTimeEnded(), \"GenesisGroup: Not in Genesis Period\");\n\t\t_;\n\t}\n\n\tfunction purchase(address to, uint value) external override payable onlyGenesisPeriod {\n\t\trequire(msg.value == value, \"GenesisGroup: value mismatch\");\n\t\trequire(value != 0, \"GenesisGroup: no value sent\");\n\n\t\t_mint(to, value);\n\n\t\temit Purchase(to, value);\n\t}\n\n\tfunction redeem(address to) external override postGenesis {\n\t\tDecimal.D256 memory ratio = _fgenRatio(to);\n\t\trequire(!ratio.equals(Decimal.zero()), \"GensisGroup: No balance to redeem\");\n\n\t\tuint amountIn = balanceOf(to);\n\t\tburnFrom(to, amountIn);\n\n\t\tuint feiAmount = ratio.mul(feiBalance()).asUint256();\n\t\tfei().transfer(to, feiAmount);\n\n\t\tuint tribeAmount = ratio.mul(tribeBalance()).asUint256();\n\t\ttribe().transfer(to, tribeAmount);\n\n\t\temit Redeem(to, amountIn, feiAmount, tribeAmount);\n\t}\n\n\tfunction launch() external override {\n\t\trequire(isTimeEnded() || isAtMaxPrice(), \"GenesisGroup: Still in Genesis Period\");\n\n\t\tcore().completeGenesisGroup();\n\n\t\taddress genesisGroup = address(this);\n\t\tuint balance = genesisGroup.balance;\n\n\t\tbondingCurveOracle.init(bondingcurve.getAveragePrice(balance));\n\n\t\tbondingcurve.purchase{value: balance}(genesisGroup, balance);\n\t\tbondingcurve.allocate();\n\n\t\tpool.init();\n\n\t\tido.deploy(_feiTribeExchangeRate());\n\n\t\t// solhint-disable-next-line not-rely-on-time\n\t\temit Launch(now);\n\t}\n\n\tfunction getAmountOut(\n\t\tuint amountIn, \n\t\tbool inclusive\n\t) public view override returns (uint feiAmount, uint tribeAmount) {\n\t\tuint totalIn = totalSupply();\n\t\tif (!inclusive) {\n\t\t\ttotalIn += amountIn;\n\t\t}\n\t\trequire(amountIn <= totalIn, \"GenesisGroup: Not enough supply\");\n\n\t\tuint totalFei = bondingcurve.getAmountOut(totalIn);\n\t\tuint totalTribe = tribeBalance();\n\n\t\treturn (totalFei * amountIn / totalIn, totalTribe * amountIn / totalIn);\n\t}\n\n\tfunction isAtMaxPrice() public view override returns(bool) {\n\t\tuint balance = address(this).balance;\n\t\trequire(balance != 0, \"GenesisGroup: No balance\");\n\n\t\treturn bondingcurve.getAveragePrice(balance).greaterThanOrEqualTo(maxGenesisPrice);\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\t// Sender doesn't need approval\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _fgenRatio(address account) internal view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(balanceOf(account), totalSupply());\n\t}\n\n\tfunction _feiTribeExchangeRate() public view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(feiBalance(), tribeBalance()).div(exchangeRateDiscount);\n\t}\n}"
    },
    {
      "filename": "contracts/genesis/IDO.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol\";\nimport \"./IDOInterface.sol\";\nimport \"../utils/LinearTokenTimelock.sol\";\nimport \"../refs/UniRef.sol\";\n\n/// @title IDOInterface implementation\n/// @author Fei Protocol\ncontract IDO is IDOInterface, UniRef, LinearTokenTimelock {\n\n\t/// @notice IDO constructor\n\t/// @param _core Fei Core address to reference\n\t/// @param _beneficiary the beneficiary to vest LP shares\n\t/// @param _duration the duration of LP share vesting\n\t/// @param _pair the Uniswap pair contract of the IDO\n\t/// @param _router the Uniswap router contract\n\tconstructor(\n\t\taddress _core, \n\t\taddress _beneficiary, \n\t\tuint32 _duration, \n\t\taddress _pair, \n\t\taddress _router\n\t) public\n\t\tUniRef(_core, _pair, _router, address(0)) // no oracle needed\n\t\tLinearTokenTimelock(_beneficiary, _duration)\n\t{\n\t\tsetLockedToken(_pair);\n\t}\n\n\tfunction deploy(Decimal.D256 calldata feiRatio) external override onlyGenesisGroup {\n\t\tuint tribeAmount = tribeBalance();\n\n\t\tuint feiAmount = feiRatio.mul(tribeAmount).asUint256();\n\t\t_mintFei(feiAmount);\n\n\t\trouter.addLiquidity(\n\t        address(tribe()),\n\t        address(fei()),\n\t        tribeAmount,\n\t        feiAmount,\n\t        tribeAmount,\n\t        feiAmount,\n\t        address(this),\n\t        uint(-1)\n\t    );\n\n\t    emit Deploy(feiAmount, tribeAmount);\n\t} \n}"
    },
    {
      "filename": "contracts/pcv/EthUniswapPCVDeposit.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./UniswapPCVDeposit.sol\";\n\n/// @title implementation for an ETH Uniswap LP PCV Deposit\n/// @author Fei Protocol\ncontract EthUniswapPCVDeposit is UniswapPCVDeposit {\n    using Address for address payable;\n\n\t/// @notice ETH Uniswap PCV Deposit constructor\n\t/// @param _core Fei Core for reference\n\t/// @param _pair Uniswap Pair to deposit to\n\t/// @param _router Uniswap Router\n\t/// @param _oracle oracle for reference\n    constructor(\n        address _core, \n        address _pair, \n        address _router, \n        address _oracle\n    ) public UniswapPCVDeposit(_core, _pair, _router, _oracle) {}\n\n    receive() external payable {}\n\n    function deposit(uint ethAmount) external override payable postGenesis {\n    \trequire(ethAmount == msg.value, \"Bonding Curve: Sent value does not equal input\");\n        \n        uint feiAmount = _getAmountFeiToDeposit(ethAmount);\n\n        _addLiquidity(ethAmount, feiAmount);\n\n        emit Deposit(msg.sender, ethAmount);\n    }\n\n    function _removeLiquidity(uint liquidity) internal override returns (uint) {\n        (, uint amountWithdrawn) = router.removeLiquidityETH(\n            address(fei()),\n            liquidity,\n            0,\n            0,\n            address(this),\n            uint(-1)\n        );\n        return amountWithdrawn;\n    }\n\n    function _transferWithdrawn(address to, uint amount) internal override {\n        payable(to).sendValue(amount);\n    }\n\n    function _addLiquidity(uint ethAmount, uint feiAmount) internal {\n        _mintFei(feiAmount);\n        \n        router.addLiquidityETH{value : ethAmount}(address(fei()),\n            feiAmount,\n            0,\n            0,\n            address(this),\n            uint(-1)\n        );\n    }\n}"
    },
    {
      "filename": "contracts/genesis/GenesisGroup.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IGenesisGroup.sol\";\nimport \"./IDOInterface.sol\";\nimport \"../utils/Timed.sol\";\nimport \"../refs/CoreRef.sol\";\nimport \"../pool/IPool.sol\";\nimport \"../oracle/IBondingCurveOracle.sol\";\nimport \"../bondingcurve/IBondingCurve.sol\";\n\ninterface IOrchestrator {\n\tfunction launchGovernance() external;\n\tfunction pool() external returns(address);\n\tfunction bondingCurveOracle() external returns(address);\n}\n\n/// @title IGenesisGroup implementation\n/// @author Fei Protocol\ncontract GenesisGroup is IGenesisGroup, CoreRef, ERC20, ERC20Burnable, Timed {\n\tusing Decimal for Decimal.D256;\n\n\tIOrchestrator private orchestrator;\n\n\tIBondingCurve private bondingcurve;\n\n\tIBondingCurveOracle private bondingCurveOracle;\n\n\tIPool private pool;\n\n\tIDOInterface private ido;\n\tuint private exchangeRateDiscount;\n\n\t/// @notice a cap on the genesis group purchase price\n\tDecimal.D256 public maxGenesisPrice;\n\n\t/// @notice GenesisGroup constructor\n\t/// @param _core Fei Core address to reference\n\t/// @param _bondingcurve Bonding curve address for purchase\n\t/// @param _ido IDO contract to deploy\n\t/// @param _oracle Bonding curve oracle\n\t/// @param _pool Staking Pool\n\t/// @param _duration duration of the Genesis Period\n\t/// @param _maxPriceBPs max price of FEI allowed in Genesis Group in dollar terms\n\t/// @param _exchangeRateDiscount a divisor on the FEI/TRIBE ratio at Genesis to deploy to the IDO\n\tconstructor(\n\t\taddress _core, \n\t\taddress _bondingcurve,\n\t\taddress _ido,\n\t\taddress _oracle,\n\t\taddress _pool,\n\t\tuint32 _duration,\n\t\tuint _maxPriceBPs,\n\t\tuint _exchangeRateDiscount\n\t) public\n\t\tCoreRef(_core)\n\t\tERC20(\"Fei Genesis Group\", \"FGEN\")\n\t\tTimed(_duration)\n\t{\n\t\tbondingcurve = IBondingCurve(_bondingcurve);\n\n\t\texchangeRateDiscount = _exchangeRateDiscount;\n\t\tido = IDOInterface(_ido);\n\n\t\tpool = IPool(_pool);\n\t\tbondingCurveOracle = IBondingCurveOracle(_oracle);\n\n\t\t_initTimed();\n\n\t\tmaxGenesisPrice = Decimal.ratio(_maxPriceBPs, 10000);\n\t}\n\n\tmodifier onlyGenesisPeriod() {\n\t\trequire(!isTimeEnded(), \"GenesisGroup: Not in Genesis Period\");\n\t\t_;\n\t}\n\n\tfunction purchase(address to, uint value) external override payable onlyGenesisPeriod {\n\t\trequire(msg.value == value, \"GenesisGroup: value mismatch\");\n\t\trequire(value != 0, \"GenesisGroup: no value sent\");\n\n\t\t_mint(to, value);\n\n\t\temit Purchase(to, value);\n\t}\n\n\tfunction redeem(address to) external override postGenesis {\n\t\tDecimal.D256 memory ratio = _fgenRatio(to);\n\t\trequire(!ratio.equals(Decimal.zero()), \"GensisGroup: No balance to redeem\");\n\n\t\tuint amountIn = balanceOf(to);\n\t\tburnFrom(to, amountIn);\n\n\t\tuint feiAmount = ratio.mul(feiBalance()).asUint256();\n\t\tfei().transfer(to, feiAmount);\n\n\t\tuint tribeAmount = ratio.mul(tribeBalance()).asUint256();\n\t\ttribe().transfer(to, tribeAmount);\n\n\t\temit Redeem(to, amountIn, feiAmount, tribeAmount);\n\t}\n\n\tfunction launch() external override {\n\t\trequire(isTimeEnded() || isAtMaxPrice(), \"GenesisGroup: Still in Genesis Period\");\n\n\t\tcore().completeGenesisGroup();\n\n\t\taddress genesisGroup = address(this);\n\t\tuint balance = genesisGroup.balance;\n\n\t\tbondingCurveOracle.init(bondingcurve.getAveragePrice(balance));\n\n\t\tbondingcurve.purchase{value: balance}(genesisGroup, balance);\n\t\tbondingcurve.allocate();\n\n\t\tpool.init();\n\n\t\tido.deploy(_feiTribeExchangeRate());\n\n\t\t// solhint-disable-next-line not-rely-on-time\n\t\temit Launch(now);\n\t}\n\n\tfunction getAmountOut(\n\t\tuint amountIn, \n\t\tbool inclusive\n\t) public view override returns (uint feiAmount, uint tribeAmount) {\n\t\tuint totalIn = totalSupply();\n\t\tif (!inclusive) {\n\t\t\ttotalIn += amountIn;\n\t\t}\n\t\trequire(amountIn <= totalIn, \"GenesisGroup: Not enough supply\");\n\n\t\tuint totalFei = bondingcurve.getAmountOut(totalIn);\n\t\tuint totalTribe = tribeBalance();\n\n\t\treturn (totalFei * amountIn / totalIn, totalTribe * amountIn / totalIn);\n\t}\n\n\tfunction isAtMaxPrice() public view override returns(bool) {\n\t\tuint balance = address(this).balance;\n\t\trequire(balance != 0, \"GenesisGroup: No balance\");\n\n\t\treturn bondingcurve.getAveragePrice(balance).greaterThanOrEqualTo(maxGenesisPrice);\n\t}\n\n\tfunction burnFrom(address account, uint amount) public override {\n\t\t// Sender doesn't need approval\n\t\tif (msg.sender == account) {\n\t\t\tincreaseAllowance(account, amount);\n\t\t}\n\t\tsuper.burnFrom(account, amount);\n\t}\n\n\tfunction _fgenRatio(address account) internal view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(balanceOf(account), totalSupply());\n\t}\n\n\tfunction _feiTribeExchangeRate() public view returns (Decimal.D256 memory) {\n\t\treturn Decimal.ratio(feiBalance(), tribeBalance()).div(exchangeRateDiscount);\n\t}\n}"
    },
    {
      "filename": "contracts/pcv/EthUniswapPCVController.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IWETH.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./IUniswapPCVController.sol\";\nimport \"../refs/UniRef.sol\";\nimport \"../oracle/IOracle.sol\";\nimport \"../external/Decimal.sol\";\n\n/// @title a IUniswapPCVController implementation for ETH\n/// @author Fei Protocol\ncontract EthUniswapPCVController is IUniswapPCVController, UniRef {\n\tusing Decimal for Decimal.D256;\n\n\tIPCVDeposit public override pcvDeposit;\n\tIUniswapIncentive public override incentiveContract;\n\n\tuint public override reweightIncentiveAmount;\n\tDecimal.D256 public minDistanceForReweight;\n\n\t/// @notice EthUniswapPCVController constructor\n\t/// @param _core Fei Core for reference\n\t/// @param _pcvDeposit PCV Deposit to reweight\n\t/// @param _oracle oracle for reference\n\t/// @param _incentiveContract incentive contract for reference\n\t/// @param _incentiveAmount amount of FEI for triggering a reweight\n\t/// @param _minDistanceForReweightBPs minimum distance from peg to reweight in basis points\n\t/// @param _pair Uniswap pair contract to reweight\n\t/// @param _router Uniswap Router\n\tconstructor (\n\t\taddress _core, \n\t\taddress _pcvDeposit, \n\t\taddress _oracle, \n\t\taddress _incentiveContract,\n\t\tuint _incentiveAmount,\n\t\tuint _minDistanceForReweightBPs,\n\t\taddress _pair,\n\t\taddress _router\n\t) public\n\t\tUniRef(_core, _pair, _router, _oracle)\n\t{\n\t\tpcvDeposit = IPCVDeposit(_pcvDeposit);\n\t\tincentiveContract = IUniswapIncentive(_incentiveContract);\n\n\t\treweightIncentiveAmount = _incentiveAmount;\n\t\tminDistanceForReweight = Decimal.ratio(_minDistanceForReweightBPs, 10000);\n\t}\n\n\treceive() external payable {}\n\n\tfunction reweight() external override postGenesis {\n\t\trequire(reweightEligible(), \"EthUniswapPCVController: Not at incentive parity or not at min distance\");\n\t\t_reweight();\n\t\t_incentivize();\n\t}\n\n\tfunction forceReweight() external override onlyGovernor {\n\t\t_reweight();\n\t}\n\n\tfunction setPCVDeposit(address _pcvDeposit) external override onlyGovernor {\n\t\tpcvDeposit = IPCVDeposit(_pcvDeposit);\n\t\temit PCVDepositUpdate(_pcvDeposit);\n\t}\n\n\tfunction setReweightIncentive(uint amount) external override onlyGovernor {\n\t\treweightIncentiveAmount = amount;\n\t\temit ReweightIncentiveUpdate(amount);\n\t}\n\n\tfunction setReweightMinDistance(uint basisPoints) external override onlyGovernor {\n\t\tminDistanceForReweight = Decimal.ratio(basisPoints, 10000);\n\t\temit ReweightMinDistanceUpdate(basisPoints);\n\t}\n\n\tfunction reweightEligible() public view override returns(bool) {\n\t\tbool magnitude = getDistanceToPeg().greaterThan(minDistanceForReweight);\n\t\tbool time = incentiveContract.isIncentiveParity();\n\t\treturn magnitude && time;\n\t}\n\n\tfunction _incentivize() internal ifMinterSelf {\n\t\tfei().mint(msg.sender, reweightIncentiveAmount);\n\t}\n\n\tfunction _reweight() internal {\n\t\t_withdrawAll();\n\t\t_returnToPeg();\n\n\t\tuint balance = address(this).balance;\n\t\tpcvDeposit.deposit{value: balance}(balance);\n\n\t\t_burnFeiHeld();\n\n\t\temit Reweight(msg.sender);\n\t}\n\n\tfunction _returnToPeg() internal {\n\t\t(uint feiReserves, uint ethReserves) = getReserves();\n\t\tif (feiReserves == 0 || ethReserves == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tupdateOracle();\n\n    \trequire(isBelowPeg(peg()), \"EthUniswapPCVController: already at or above peg\");\n    \t\n\t\tuint amountEth = getAmountToPegOther();\n    \t_swapEth(amountEth, ethReserves, feiReserves);\n\t}\n\n\tfunction _swapEth(uint amountEth, uint ethReserves, uint feiReserves) internal {\n\t\tuint balance = address(this).balance;\n\t\tuint amount = Math.min(amountEth, balance);\n\t\t\n\t\tuint amountOut = UniswapV2Library.getAmountOut(amount, ethReserves, feiReserves);\n\t\t\n\t\tIWETH weth = IWETH(router.WETH());\n\t\tweth.deposit{value: amount}();\n\t\tweth.transfer(address(pair), amount);\n\n\t\t(uint amount0Out, uint amount1Out) = pair.token0() == address(weth) ? (uint(0), amountOut) : (amountOut, uint(0));\n\t\tpair.swap(amount0Out, amount1Out, address(this), new bytes(0));\n\t}\n\n\tfunction _withdrawAll() internal {\n\t\tuint value = pcvDeposit.totalValue();\n\t\tpcvDeposit.withdraw(address(this), value);\n\t}\n}"
    }
  ]
}