{
  "Title": "Too open rebalance method",
  "Content": "##### Description\nThis is potentially dangerous because of potential manipulations on the market: https://github.com/pie-dao/ExperiPie/blob/0.0.2/contracts/callManagers/RSIManager.sol#L50\n\n##### Recommendation\nWe suggest adding some restrictions for the caller account.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/callManagers/RSIManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/ISynthetix.sol\";\nimport \"../interfaces/IExperiPie.sol\";\nimport \"../interfaces/IPriceReferenceFeed.sol\";\n\ncontract RSISynthetixManager {\n\n    address public immutable assetShort;\n    address public immutable assetLong;\n    bytes32 public immutable assetShortKey;\n    bytes32 public immutable assetLongKey;\n\n    IPriceReferenceFeed public immutable priceFeed;\n    IExperiPie public immutable basket;\n    ISynthetix public immutable synthetix;\n\n    struct RoundData {\n        uint80 roundId;\n        int256 answer;\n        uint256 startedAt; \n        uint256 updatedAt; \n        uint80 answeredInRound;\n    }\n\n    event Rebalanced(address indexed basket, address indexed fromToken, address indexed toToken);\n\n    constructor(\n        address _assetShort,\n        address _assetLong,\n        bytes32 _assetShortKey,\n        bytes32 _assetLongKey,\n        address _priceFeed,\n        address _basket,\n        address _synthetix\n    ) {\n        assetShort = _assetShort;\n        assetLong = _assetLong;\n        assetShortKey = _assetShortKey;\n        assetLongKey = _assetLongKey;\n        priceFeed = IPriceReferenceFeed(_priceFeed);\n        basket = IExperiPie(_basket);\n        synthetix = ISynthetix(_synthetix);\n    }\n\n\n    function rebalance() external {\n        RoundData memory roundData = readLatestRound();\n        require(roundData.updatedAt > 0, \"Round not complete\");\n\n        if(roundData.answer <= 30 * 10**18) {\n            // long\n            long();\n            return;\n        } else if(roundData.answer >= 70 * 10**18) {\n            // Short\n            short();\n            return;\n        }\n    }\n\n    function long() internal {\n        IERC20 currentToken = IERC20(getCurrentToken());\n        require(address(currentToken) == assetShort, \"Can only long when short\");\n\n        uint256 currentTokenBalance = currentToken.balanceOf(address(basket));\n\n        address[] memory targets = new address[](4);\n        bytes[] memory data = new bytes[](4);\n        uint256[] memory values = new uint256[](4);\n\n        // lock pool\n        targets[0] = address(basket);\n        // lock for 30\n        data[0] = setLockData(block.number + 30);\n\n        // Swap on synthetix\n        targets[1] = address(synthetix);\n        data[1] = abi.encodeWithSelector(synthetix.exchange.selector, assetShortKey, currentTokenBalance, assetLongKey);\n\n\n        // Remove current token\n        targets[2] = address(basket);\n        data[2] = abi.encodeWithSelector(basket.removeToken.selector, assetShort);\n\n        // Add new token\n        targets[3] = address(basket);\n        data[3] = abi.encodeWithSelector(basket.addToken.selector, assetLong);\n\n        // Do calls\n        basket.call(targets, data, values);\n\n        // sanity checks\n        require(currentToken.balanceOf(address(basket)) == 0, \"Current token balance should be zero\");\n        require(IERC20(assetLong).balanceOf(address(basket)) >= 10**6, \"Amount too small\");\n\n        emit Rebalanced(address(basket), assetShort, assetLong);\n    }\n\n    function short() internal {\n        IERC20 currentToken = IERC20(getCurrentToken());\n        require(address(currentToken) == assetLong, \"Can only short when long\");\n\n        uint256 currentTokenBalance = currentToken.balanceOf(address(basket));\n\n        address[] memory targets = new address[](4);\n        bytes[] memory data = new bytes[](4);\n        uint256[] memory values = new uint256[](4);\n\n        // lock pool\n        targets[0] = address(basket);\n        // lock for 30\n        data[0] = setLockData(block.number + 30);\n\n        // Swap on synthetix\n        targets[1] = address(synthetix);\n        data[1] = abi.encodeWithSelector(synthetix.exchange.selector, assetLongKey, currentTokenBalance, assetShortKey);\n\n        // Remove current token\n        targets[2] = address(basket);\n        data[2] = abi.encodeWithSelector(basket.removeToken.selector, assetLong);\n\n        // Add new token\n        targets[3] = address(basket);\n        data[3] = abi.encodeWithSelector(basket.addToken.selector, assetShort);\n\n        // Do calls\n        basket.call(targets, data, values);\n\n        // sanity checks\n        require(currentToken.balanceOf(address(basket)) == 0, \"Current token balance should be zero\");\n        \n        // Catched by addToken in the basket itself\n        // require(IERC20(assetShort).balanceOf(address(basket)) >= 10**6, \"Amount too small\");\n\n        emit Rebalanced(address(basket), assetShort, assetLong);\n    }\n\n    function getCurrentToken() public view returns(address) {\n        address[] memory tokens = basket.getTokens();\n        require(tokens.length == 1, \"RSI Pie can only have 1 asset at the time\");\n        return tokens[0];\n    }\n\n\n    function setLockData(uint256 _block) internal returns(bytes memory data) {\n        bytes memory data = abi.encodeWithSelector(basket.setLock.selector, _block);\n        return data;\n    }\n    function readRound(uint256 _round) public view returns(RoundData memory data) {\n        (\n            uint80 roundId, \n            int256 answer, \n            uint256 startedAt, \n            uint256 updatedAt, \n            uint80 answeredInRound\n        ) = priceFeed.getRoundData(uint80(_round));\n\n        return RoundData({\n            roundId: roundId,\n            answer: answer,\n            startedAt: startedAt,\n            updatedAt: updatedAt,\n            answeredInRound: answeredInRound\n        });\n    }\n\n    function readLatestRound() public view returns(RoundData memory data) {\n        (\n            uint80 roundId, \n            int256 answer, \n            uint256 startedAt, \n            uint256 updatedAt, \n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n\n        return RoundData({\n            roundId: roundId,\n            answer: answer,\n            startedAt: startedAt,\n            updatedAt: updatedAt,\n            answeredInRound: answeredInRound\n        });\n    }\n\n}"
    }
  ]
}