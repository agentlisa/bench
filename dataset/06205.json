{
  "Title": "[M-20] Improper handling of cases when withdrawable assets = 0",
  "Content": "\n- Improper handling of cases when withdrawable assets = 0.\n- The vault will not function correctly.\n\n### Proof of Concept\n\nThe functions `_currentExchangeRate` and `_isVaultCollateralized` of `Vault` are implemented as follows:\n\n```solidity\nfunction _currentExchangeRate() internal view returns (uint256) {\n    uint256 _totalSupplyAmount = _totalSupply();\n    uint256 _totalSupplyToAssets = _convertToAssets(\n      _totalSupplyAmount,\n      _lastRecordedExchangeRate,\n      Math.Rounding.Down\n    );\n\n    uint256 _withdrawableAssets = _yieldVault.maxWithdraw(address(this));\n\n    if (_withdrawableAssets > _totalSupplyToAssets) {\n      _withdrawableAssets = _withdrawableAssets - (_withdrawableAssets - _totalSupplyToAssets);\n    }\n\n    if (_totalSupplyAmount != 0 && _withdrawableAssets != 0) {\n      return _withdrawableAssets.mulDiv(_assetUnit, _totalSupplyAmount, Math.Rounding.Down);\n    }\n\n    return _assetUnit;\n  }\n\nfunction _isVaultCollateralized() internal view returns (bool) {\n    return _currentExchangeRate() >= _assetUnit;\n}\n```\n\nThe function calculates the exchange rate between the amount of assets withdrawable from the `YieldVault` and the amount of shares minted by this Vault.\n\nHowever, if `_withdrawableAssets` is 0, then the function returns `_assetUnit` (which means 1-1 ratio). This means, that even when the `vault` has no withdrawable assets from `_yieldVault`, it's still considered collateralized.\n\nTo illustrate the oddity of this special case, consider when `_withdrawableAssets` `= 1` and `_totalSupplyAmount` `> 0`; in this scenario, `_currentExchangeRate` returns 0 and the vault is considered under-collateralized (since `1 <` `_assetUnit`). However, if `_withdrawableAssets` `= 0`, the vault is considered collateralized.\n\n**This case has profound impact since a lot of vault logic is based on the vault's collateralized status.**\n\nBelow is a POC for the above example. For ease of testing, let's place these 2 test cases\nin file `vault/test/unit/Vault/Deposit.t.sol` under contract `VaultDepositTest`,\nthen test them using commands:\n- `forge test --match-path test/unit/Vault/Deposit.t.sol --match-test testOneWithdrawableAmount -vvvv`\n- `forge test --match-path test/unit/Vault/Deposit.t.sol --match-test testZeroWithdrawableAmount -vvvv`\n\n`testOneWithdrawableAmount` is to demonstrate when `_withdrawableAssets` `= 1` and the vault is considered not collateralized.\n`testZeroWithdrawableAmount` is to demonstrate when `_withdrawableAssets` `= 0` and the vault is considered collateralized.\n\n```solidity\nfunction testZeroWithdrawableAmount() public {\n    vm.startPrank(alice);\n    uint256 _amount = 1000e18;\n    underlyingAsset.mint(alice, _amount);\n    underlyingAsset.approve(address(vault), type(uint256).max);\n\n    vault.deposit(_amount, alice);\n    \n\n    // Now make the withdrawable asset = 0\n    // Burn the balance of yieldVault\n    uint256 yieldVaultAsset = underlyingAsset.balanceOf(address(yieldVault));\n    underlyingAsset.burn(address(yieldVault), yieldVaultAsset);\n\n    assertEq(underlyingAsset.balanceOf(address(yieldVault)), 0);\n\n    // Although the vault has no asset withdrawable in yieldVault\n    // the exchange rate is 10**18 = assetUnit and the vault is \"collateralized\"\n    assertEq(yieldVault.maxWithdraw(address(vault)), 0);\n    assertEq(vault.exchangeRate(), 10**18);\n    assertEq(vault.isVaultCollateralized(), true);\n  }\n\n  function testOneWithdrawableAmount() public {\n    vm.startPrank(alice);\n    uint256 _amount = 1000e18;\n    underlyingAsset.mint(alice, _amount);\n    underlyingAsset.approve(address(vault), type(uint256).max);\n\n    vault.deposit(_amount, alice);\n    \n\n    // Now make the withdrawable asset = 0\n    // Burn the balance of yieldVault\n    uint256 yieldVaultAsset = underlyingAsset.balanceOf(address(yieldVault));\n    underlyingAsset.burn(address(yieldVault), yieldVaultAsset -1);\n\n    assertEq(underlyingAsset.balanceOf(address(yieldVault)), 1);\n\n    // vault only has 1 asset token withdrawable, and the exchangeRate is 0\n    // the vault is not collateralized\n    assertEq(yieldVault.maxWithdraw(address(vault)), 1);\n    assertEq(vault.exchangeRate(), 0);\n    assertEq(vault.isVaultCollateralized(), false);\n  }\n```\n\n### Recommended Mitigation Steps\n\nSince `_withdrawableAssets` is the dividend, there seems to be no harm in removing the check if `_withdrawableAssets` `= 0`. Therefore, I recommend removing it from the condition.\n\n### Assessed type\n\nInvalid Validation\n\n**[asselstine (PoolTogether) confirmed](https://github.com/code-423n4/2023-07-pooltogether-findings/issues/180#issuecomment-1642684778)**\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-07-pooltogether-findings/issues/180#issuecomment-1666959751):**\n > There is definitely a bug here, but I don't see why it should be high severity.\n > \"This case has a profound impact since a lot of vault logic is based on the vault's collateralized status\" is a bit light to pass the burden or proof. At first sight, as there are no funds in the vault anymore, there is no loss of funds. Then there is the case where assets are re-added to the vault for some reason; but this would be a Medium severity scenario, considering it's very unlikely and not described by the report.\n\n**[ktg9 (warden) commented](https://github.com/code-423n4/2023-07-pooltogether-findings/issues/180#issuecomment-1672472579):**\n > Hi @Picodes, thank you for your response!\n> \n> Sorry I didn't make it clearer. As you can see in the report, the affected function is `_currentExchangeRate`, so not only is the `Vault` incorrectly specified as collateralized, the `currentExchangeRate` also `= 1` (`assetUnit`). These 2 functions affect many other functions, for example:\n> \n> - Function `mintYieldFee` requires that vault is collateralized, so a user can mint the yield fee even when it's not.\n> - Function `liquidate` requires that vault is collateralized, so a user can liquidate asset even when vault's withdrawable asset `= 0`.\n> - For `deposit` function, first `deposit` will calculate `maxDeposit` to limit the input tokens:\n> ```solidity\n>   function maxDeposit(address) public view virtual override returns (uint256) {\n>     return _isVaultCollateralized() ? `type(uint96).max` : 0;\n>   }\n> ``` \n> \n> If the Vault is under-collateralized, a user can't deposit since `maxDeposit` will return 0; however, a user can still deposit in this case:\n> - User calls `exchangeRate` and receives 1, this can lead them to bad decisions.\n> \n> To conclude, I agree that this will not lead to direct loss of funds for the vault, but will greatly impact the user, making them send tokens to the vault (through liquidate or deposit) when it's not collateralized and will potentially suffer economically. I think it should be marked as High severity.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-07-pooltogether-findings/issues/180#issuecomment-1676025503):**\n > @ktg9 - I still think that the original reports perfectly fit with the definition of Med severity:\n >> \"leak value with a hypothetical attack path with stated assumptions, but external requirements\".\n >\n > The described scenarios require that we are in a situation with `withdrawable assets = 0` and that some users behave incorrectly. Also note that I can't consider scenarios that are not described in the original report.\n\n**[PierrickGT (PoolTogether) commented](https://github.com/code-423n4/2023-07-pooltogether-findings/issues/180#issuecomment-1681398000):**\n> This issue has been fixed and the exchange rate between the Vault and YieldVault is now 1 to 1. We've replaced the exchange rate function by a collateral one, which simplifies the conversions from shares to assets and assets to shares.\n>\n> If the Vault is collateralized, meaning the amount of withdrawable assets from the YieldVault is greater than the amount of underlying assets supplied to the YieldVault, then users can only withdraw the amount they deposited. Otherwise, any remaining collateral within the YieldVault is available and distributed proportionally among depositors.\n>\n> https://github.com/GenerationSoftware/pt-v5-vault/blob/8985bead1be85ae6822cd329933f5a53de05c237/src/Vault.sol#L1208\n\n**[PoolTogether mitigated](https://github.com/code-423n4/2023-08-pooltogether-mitigation#individual-prs):**\n> Vault shares are now 1:1 with an underlying asset, and the exchange logic has been simplified.<br>\n> PR: https://github.com/GenerationSoftware/pt-v5-vault/pull/18\n\n**Status**: Mitigation confirmed. Full details in report from [dirk\\_y](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/89), [rvierdiiev](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/59) and [0xStalin](https://github.com/code-423n4/2023-08-pooltogether-mitigation-findings/issues/78).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-pooltogether",
  "Code": [
    {
      "filename": "src/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { ERC4626, ERC20, IERC20, IERC4626 } from \"openzeppelin/token/ERC20/extensions/ERC4626.sol\";\nimport { ERC20Permit, IERC20Permit } from \"openzeppelin/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport { SafeERC20 } from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"openzeppelin/utils/math/SafeCast.sol\";\nimport { Math } from \"openzeppelin/utils/math/Math.sol\";\nimport { Ownable } from \"owner-manager-contracts/Ownable.sol\";\n\nimport { ILiquidationPair } from \"pt-v5-liquidator-interfaces/ILiquidationPair.sol\";\nimport { ILiquidationSource } from \"pt-v5-liquidator-interfaces/ILiquidationSource.sol\";\nimport { PrizePool } from \"pt-v5-prize-pool/PrizePool.sol\";\nimport { TwabController } from \"pt-v5-twab-controller/TwabController.sol\";\nimport { VaultHooks } from \"./interfaces/IVaultHooks.sol\";\n\n/// @notice Emitted when the TWAB controller is set to the zero address.\nerror TwabControllerZeroAddress();\n\n/// @notice Emitted when the Yield Vault is set to the zero address.\nerror YieldVaultZeroAddress();\n\n/// @notice Emitted when the Prize Pool is set to the zero address.\nerror PrizePoolZeroAddress();\n\n/// @notice Emitted when the Owner is set to the zero address.\nerror OwnerZeroAddress();\n\n/**\n * @notice Emitted when the underlying asset passed to the constructor is different from the YieldVault one.\n * @param asset Address of the underlying asset passed to the constructor\n * @param yieldVaultAsset Address of the YieldVault underlying asset\n */\nerror UnderlyingAssetMismatch(address asset, address yieldVaultAsset);\n\n/**\n * @notice Emitted when the amount being deposited for the receiver is greater than the max amount allowed.\n * @param receiver The receiver of the deposit\n * @param amount The amount to deposit\n * @param max The max deposit amount allowed\n */\nerror DepositMoreThanMax(address receiver, uint256 amount, uint256 max);\n\n/**\n * @notice Emitted when the amount being withdrawn for the owner is greater than the max amount allowed.\n * @param owner The owner of the assets\n * @param amount The amount to withdraw\n * @param max The max withdrawable amount\n */\nerror WithdrawMoreThanMax(address owner, uint256 amount, uint256 max);\n\n/**\n * @notice Emitted when the amount being redeemed for owner is greater than the max allowed amount.\n * @param owner The owner of the assets\n * @param amount The amount to redeem\n * @param max The max redeemable amount\n */\nerror RedeemMoreThanMax(address owner, uint256 amount, uint256 max);\n\n/**\n * @notice Emitted when the amount of shares being minted to the receiver is greater than the max amount allowed.\n * @param receiver The receiver address\n * @param shares The shares being minted\n * @param max The max amount of shares that can be minted to the receiver\n */\nerror MintMoreThanMax(address receiver, uint256 shares, uint256 max);\n\n/// @notice Emitted when `_deposit` is called but no shares are minted back to the receiver.\nerror MintZeroShares();\n\n/// @notice Emitted when `_withdraw` is called but no assets are being withdrawn.\nerror WithdrawZeroAssets();\n\n/// @notice Emitted when `sweep` is called but no underlying assets are currently held by the Vault.\nerror SweepZeroAssets();\n\n/**\n * @notice Emitted during the liquidation process when the caller is not the liquidation pair contract.\n * @param caller The caller address\n * @param liquidationPair The LP address\n */\nerror LiquidationCallerNotLP(address caller, address liquidationPair);\n\n/**\n * @notice Emitted during the liquidation process when the token in is not the prize token.\n * @param tokenIn The provided tokenIn address\n * @param prizeToken The prize token address\n */\nerror LiquidationTokenInNotPrizeToken(address tokenIn, address prizeToken);\n\n/**\n * @notice Emitted during the liquidation process when the token out is not the vault share token.\n * @param tokenOut The provided tokenOut address\n * @param vaultShare The vault share token address\n */\nerror LiquidationTokenOutNotVaultShare(address tokenOut, address vaultShare);\n\n/// @notice Emitted during the liquidation process when the liquidation amount out is zero.\nerror LiquidationAmountOutZero();\n\n/**\n * @notice Emitted during the liquidation process if the amount out is greater than the available yield.\n * @param amountOut The amount out\n * @param availableYield The available yield\n */\nerror LiquidationAmountOutGTYield(uint256 amountOut, uint256 availableYield);\n\n/// @notice Emitted when the Vault is under-collateralized.\nerror VaultUnderCollateralized();\n\n/**\n * @notice Emitted when after a deposit the amount of withdrawable assets from the YieldVault is lower than the expected amount.\n * @param withdrawableAssets The actual amount of assets withdrawable from the YieldVault\n * @param expectedWithdrawableAssets The expected amount of assets withdrawable from the YieldVault\n */\nerror YVWithdrawableAssetsLTExpected(\n  uint256 withdrawableAssets,\n  uint256 expectedWithdrawableAssets\n);\n\n/**\n * @notice Emitted when the target token is not supported for a given token address.\n * @param token The unsupported token address\n */\nerror TargetTokenNotSupported(address token);\n\n/**\n * @notice Emitted when the caller is not the prize claimer.\n * @param caller The caller address\n * @param claimer The claimer address\n */\nerror CallerNotClaimer(address caller, address claimer);\n\n/**\n * @notice Emitted when the minted yield exceeds the yield fee shares available.\n * @param shares The amount of yield shares to mint\n * @param yieldFeeShares The accrued yield fee shares available\n */\nerror YieldFeeGTAvailableShares(uint256 shares, uint256 yieldFeeShares);\n\n/**\n * @notice Emitted when the minted yield exceeds the amount of available yield in the YieldVault.\n * @param assets The amount of yield assets requested\n * @param availableYield The amount of yield available\n */\nerror YieldFeeGTAvailableYield(uint256 assets, uint256 availableYield);\n\n/// @notice Emitted when the Liquidation Pair being set is the zero address.\nerror LPZeroAddress();\n\n/**\n * @notice Emitted when the yield fee percentage being set is greater than or equal to 1.\n * @param yieldFeePercentage The yield fee percentage in integer format\n * @param maxYieldFeePercentage The max yield fee percentage in integer format (this value is equal to 1 in decimal format)\n */\nerror YieldFeePercentageGtePrecision(uint256 yieldFeePercentage, uint256 maxYieldFeePercentage);\n\n/// @notice Emitted when the BeforeClaim prize hook fails\n/// @param reason The revert reason that was thrown\nerror BeforeClaimPrizeFailed(bytes reason);\n\n/// @notice Emitted when the AfterClaim prize hook fails\n/// @param reason The revert reason that was thrown\nerror AfterClaimPrizeFailed(bytes reason);\n\n// The gas to give to each of the before and after prize claim hooks.\n// This should be enough gas to mint an NFT if needed.\nuint256 constant HOOK_GAS = 150_000;\n\n/**\n * @title  PoolTogether V5 Vault\n * @author PoolTogether Inc Team, Generation Software Team\n * @notice Vault extends the ERC4626 standard and is the entry point for users interacting with a V5 pool.\n *         Users deposit an underlying asset (i.e. USDC) in this contract and receive in exchange an ERC20 token\n *         representing their share of deposit in the vault.\n *         Underlying assets are then deposited in a YieldVault to generate yield.\n *         This yield is sold for prize tokens (i.e. POOL) via the Liquidator and captured by the PrizePool to be awarded to depositors.\n * @dev    Balances are stored in the TwabController contract.\n */\ncontract Vault is ERC4626, ERC20Permit, ILiquidationSource, Ownable {\n  using Math for uint256;\n  using SafeCast for uint256;\n  using SafeERC20 for IERC20;\n\n  /* ============ Events ============ */\n\n  /**\n   * @notice Emitted when a new Vault has been deployed.\n   * @param asset Address of the underlying asset used by the vault\n   * @param name Name of the ERC20 share minted by the vault\n   * @param symbol Symbol of the ERC20 share minted by the vault\n   * @param twabController Address of the TwabController used to keep track of balances\n   * @param yieldVault Address of the ERC4626 vault in which assets are deposited to generate yield\n   * @param prizePool Address of the PrizePool that computes prizes\n   * @param claimer Address of the claimer\n   * @param yieldFeeRecipient Address of the yield fee recipient\n   * @param yieldFeePercentage Yield fee percentage in integer format with 1e9 precision (50% would be 5e8)\n   * @param owner Address of the contract owner\n   */\n  event NewVault(\n    IERC20 indexed asset,\n    string name,\n    string symbol,\n    TwabController twabController,\n    IERC4626 indexed yieldVault,\n    PrizePool indexed prizePool,\n    address claimer,\n    address yieldFeeRecipient,\n    uint256 yieldFeePercentage,\n    address owner\n  );\n\n  /**\n   * @notice Emitted when a new claimer has been set.\n   * @param previousClaimer Address of the previous claimer\n   * @param newClaimer Address of the new claimer\n   */\n  event ClaimerSet(address previousClaimer, address newClaimer);\n\n  /**\n   * @notice Emitted when an account sets new hooks\n   * @param account The account whose hooks are being configured\n   * @param hooks The hooks being set\n   */\n  event SetHooks(address account, VaultHooks hooks);\n\n  /**\n   * @notice Emitted when a new LiquidationPair has been set.\n   * @param newLiquidationPair Address of the new liquidationPair\n   */\n  event LiquidationPairSet(ILiquidationPair newLiquidationPair);\n\n  /**\n   * @notice Emitted when yield fee is minted to the yield recipient.\n   * @param caller Address that called the function\n   * @param recipient Address receiving the Vault shares\n   * @param shares Amount of shares minted to `recipient`\n   */\n  event MintYieldFee(address indexed caller, address indexed recipient, uint256 shares);\n\n  /**\n   * @notice Emitted when a new yield fee recipient has been set.\n   * @param previousYieldFeeRecipient Address of the previous yield fee recipient\n   * @param newYieldFeeRecipient Address of the new yield fee recipient\n   */\n  event YieldFeeRecipientSet(address previousYieldFeeRecipient, address newYieldFeeRecipient);\n\n  /**\n   * @notice Emitted when a new yield fee percentage has been set.\n   * @param previousYieldFeePercentage Previous yield fee percentage\n   * @param newYieldFeePercentage New yield fee percentage\n   */\n  event YieldFeePercentageSet(uint256 previousYieldFeePercentage, uint256 newYieldFeePercentage);\n\n  /**\n   * @notice Emitted when a user sponsors the Vault.\n   * @param caller Address that called the function\n   * @param assets Amount of assets deposited into the Vault\n   * @param shares Amount of shares minted to the caller address\n   */\n  event Sponsor(address indexed caller, uint256 assets, uint256 shares);\n\n  /**\n   * @notice Emitted when a user sweeps assets held by the Vault into the YieldVault.\n   * @param caller Address that called the function\n   * @param assets Amount of assets sweeped into the YieldVault\n   */\n  event Sweep(address indexed caller, uint256 assets);\n\n  /* ============ Variables ============ */\n\n  /// @notice Address of the TwabController used to keep track of balances.\n  TwabController private immutable _twabController;\n\n  /// @notice Address of the ERC4626 vault generating yield.\n  IERC4626 private immutable _yieldVault;\n\n  /// @notice Address of the PrizePool that computes prizes.\n  PrizePool private immutable _prizePool;\n\n  /// @notice Address of the claimer.\n  address private _claimer;\n\n  /// @notice Address of the ILiquidationPair used to liquidate yield for prize token.\n  ILiquidationPair private _liquidationPair;\n\n  /// @notice Yield fee percentage represented in integer format with 9 decimal places (i.e. 10000000 = 0.01 = 1%).\n  uint256 private _yieldFeePercentage;\n\n  /// @notice Address of the yield fee recipient. Receives Vault shares when `mintYieldFee` is called.\n  address private _yieldFeeRecipient;\n\n  /// @notice Total yield fee shares available. Can be minted to `_yieldFeeRecipient` by calling `mintYieldFee`.\n  uint256 private _yieldFeeShares;\n\n  /// @notice Fee precision denominated in 9 decimal places and used to calculate yield fee percentage.\n  uint256 private constant FEE_PRECISION = 1e9;\n\n  /// @notice Maps user addresses to hooks that they want to execute when prizes are won.\n  mapping(address => VaultHooks) internal _hooks;\n\n  /* ============ Constructor ============ */\n\n  /**\n   * @notice Vault constructor\n   * @dev `claimer_` can be set to address zero if none is available yet.\n   * @param asset_ Address of the underlying asset used by the vault\n   * @param name_ Name of the ERC20 share minted by the vault\n   * @param symbol_ Symbol of the ERC20 share minted by the vault\n   * @param twabController_ Address of the TwabController used to keep track of balances\n   * @param yieldVault_ Address of the ERC4626 vault in which assets are deposited to generate yield\n   * @param prizePool_ Address of the PrizePool that computes prizes\n   * @param claimer_ Address of the claimer\n   * @param yieldFeeRecipient_ Address of the yield fee recipient\n   * @param yieldFeePercentage_ Yield fee percentage\n   * @param owner_ Address that will gain ownership of this contract\n   */\n  constructor(\n    IERC20 asset_,\n    string memory name_,\n    string memory symbol_,\n    TwabController twabController_,\n    IERC4626 yieldVault_,\n    PrizePool prizePool_,\n    address claimer_,\n    address yieldFeeRecipient_,\n    uint256 yieldFeePercentage_,\n    address owner_\n  ) ERC4626(asset_) ERC20(name_, symbol_) ERC20Permit(name_) Ownable(owner_) {\n    if (address(twabController_) == address(0)) revert TwabControllerZeroAddress();\n    if (address(yieldVault_) == address(0)) revert YieldVaultZeroAddress();\n    if (address(prizePool_) == address(0)) revert PrizePoolZeroAddress();\n    if (address(owner_) == address(0)) revert OwnerZeroAddress();\n    if (address(asset_) != yieldVault_.asset())\n      revert UnderlyingAssetMismatch(address(asset_), yieldVault_.asset());\n\n    _twabController = twabController_;\n    _yieldVault = yieldVault_;\n    _prizePool = prizePool_;\n\n    _setClaimer(claimer_);\n    _setYieldFeeRecipient(yieldFeeRecipient_);\n    _setYieldFeePercentage(yieldFeePercentage_);\n\n    // Approve once for max amount\n    asset_.safeApprove(address(yieldVault_), type(uint256).max);\n\n    emit NewVault(\n      asset_,\n      name_,\n      symbol_,\n      twabController_,\n      yieldVault_,\n      prizePool_,\n      claimer_,\n      yieldFeeRecipient_,\n      yieldFeePercentage_,\n      owner_\n    );\n  }\n\n  /* ===================================================== */\n  /* ============ Public & External Functions ============ */\n  /* ===================================================== */\n\n  /**\n   * @notice Total available yield amount accrued by this vault.\n   * @dev This amount includes the liquidatable yield + yield fee amount.\n   * @dev The available yield is equal to the total amount of assets managed by this Vault\n   *      minus the total amount of assets supplied to the Vault and current allocated `_yieldFeeShares`.\n   * @dev If `_assetsAllocated` is greater than `_assets`, it means that the Vault is undercollateralized.\n   *      We must not mint more shares than underlying assets available so we return 0.\n   * @return uint256 Total yield amount\n   */\n  function availableYieldBalance() public view returns (uint256) {\n    uint256 _assets = _totalAssets();\n    uint256 _assetsAllocated = _convertToAssets(\n      _totalSupply() + _yieldFeeShares,\n      Math.Rounding.Down\n    );\n\n    return _assetsAllocated > _assets ? 0 : _assets - _assetsAllocated;\n  }\n\n  /**\n   * @notice Get the available yield fee amount accrued by this vault.\n   * @return uint256 Yield fee amount\n   */\n  function availableYieldFeeBalance() public view returns (uint256) {\n    uint256 _availableYield = availableYieldBalance();\n\n    if (_availableYield != 0 && _yieldFeePercentage != 0) {\n      return _availableYieldFeeBalance(_availableYield);\n    }\n\n    return 0;\n  }\n\n  /// @inheritdoc ERC20\n  function balanceOf(\n    address _account\n  ) public view virtual override(ERC20, IERC20) returns (uint256) {\n    return _twabController.balanceOf(address(this), _account);\n  }\n\n  /// @inheritdoc ERC4626\n  function decimals() public view virtual override(ERC4626, ERC20) returns (uint8) {\n    return super.decimals();\n  }\n\n  /// @inheritdoc ERC4626\n  function totalAssets() public view virtual override returns (uint256) {\n    return _totalAssets();\n  }\n\n  /// @inheritdoc ERC20\n  function totalSupply() public view virtual override(ERC20, IERC20) returns (uint256) {\n    return _totalSupply();\n  }\n\n  /**\n   * @notice Check if the Vault is collateralized.\n   * @return bool True if the vault is collateralized, false otherwise\n   */\n  function isVaultCollateralized() public view returns (bool) {\n    return _isVaultCollateralized();\n  }\n\n  /**\n   * @inheritdoc ERC4626\n   * @dev We use type(uint96).max cause this is the type used to store balances in TwabController.\n   */\n  function maxDeposit(address recipient) public view virtual override returns (uint256) {\n    if (!_isVaultCollateralized()) return 0;\n\n    uint256 _vaultMaxDeposit = type(uint96).max -\n      _convertToAssets(balanceOf(recipient), Math.Rounding.Up);\n    uint256 _yieldVaultMaxDeposit = _yieldVault.maxDeposit(address(this));\n\n    return _yieldVaultMaxDeposit < _vaultMaxDeposit ? _yieldVaultMaxDeposit : _vaultMaxDeposit;\n  }\n\n  /**\n   * @inheritdoc ERC4626\n   * @dev We use type(uint96).max cause this is the type used to store balances in TwabController.\n   */\n  function maxMint(address recipient) public view virtual override returns (uint256) {\n    if (!_isVaultCollateralized()) return 0;\n\n    uint256 _vaultMaxMint = type(uint96).max - balanceOf(recipient);\n    uint256 _yieldVaultMaxMint = _yieldVault.maxMint(address(this));\n\n    return _yieldVaultMaxMint < _vaultMaxMint ? _yieldVaultMaxMint : _vaultMaxMint;\n  }\n\n  /**\n   * @notice Mint Vault shares to the `_yieldFeeRecipient`.\n   * @dev Will revert if the Vault is undercollateralized.\n   * @dev Will revert if `_shares` is greater than `_yieldFeeShares`.\n   * @dev Will revert if there is not enough yield available in the YieldVault to back `_shares`.\n   * @param _shares Amount of shares to mint\n   */\n  function mintYieldFee(uint256 _shares) external {\n    _requireVaultCollateralized();\n\n    uint256 _assets = _convertToAssets(_shares, Math.Rounding.Down);\n    uint256 _availableYield = _yieldVault.maxWithdraw(address(this)) -\n      _convertToAssets(_totalSupply(), Math.Rounding.Down);\n\n    if (_assets > _availableYield) revert YieldFeeGTAvailableYield(_assets, _availableYield);\n    if (_shares > _yieldFeeShares) revert YieldFeeGTAvailableShares(_shares, _yieldFeeShares);\n\n    _yieldFeeShares -= _shares;\n    _mint(_yieldFeeRecipient, _shares);\n\n    emit MintYieldFee(msg.sender, _yieldFeeRecipient, _shares);\n  }\n\n  /* ============ Deposit Functions ============ */\n\n  /// @inheritdoc ERC4626\n  function deposit(uint256 _assets, address _receiver) public virtual override returns (uint256) {\n    return _depositAssets(_assets, msg.sender, _receiver);\n  }\n\n  /**\n   * @notice Approve underlying asset with permit, deposit into the Vault and mint Vault shares to `_receiver`.\n   * @dev Can't be used to deposit on behalf of another user since `permit` does not accept a receiver parameter.\n   *      Meaning that anyone could reuse the signature and pass an arbitrary `_receiver` to this function.\n   * @param _assets Amount of assets to approve and deposit\n   * @param _owner Address of the owner depositing `_assets` and signing the permit\n   * @param _deadline Timestamp after which the approval is no longer valid\n   * @param _v V part of the secp256k1 signature\n   * @param _r R part of the secp256k1 signature\n   * @param _s S part of the secp256k1 signature\n   * @return uint256 Amount of Vault shares minted to `_receiver`.\n   */\n  function depositWithPermit(\n    uint256 _assets,\n    address _owner,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external returns (uint256) {\n    _permit(IERC20Permit(asset()), _owner, address(this), _assets, _deadline, _v, _r, _s);\n    return _depositAssets(_assets, _owner, _owner);\n  }\n\n  /// @inheritdoc ERC4626\n  function mint(uint256 _shares, address _receiver) public virtual override returns (uint256) {\n    _requireVaultCollateralized();\n\n    uint256 _assets = _convertToAssets(_shares, Math.Rounding.Up);\n    _deposit(msg.sender, _receiver, _assets, _shares);\n\n    return _assets;\n  }\n\n  /**\n   * @notice Deposit assets into the Vault and delegate to the sponsorship address.\n   * @param _assets Amount of assets to deposit\n   * @return uint256 Amount of shares minted to caller.\n   */\n  function sponsor(uint256 _assets) external returns (uint256) {\n    return _sponsor(_assets, msg.sender);\n  }\n\n  /**\n   * @notice Deposit assets into the Vault and delegate to the sponsorship address.\n   * @param _assets Amount of assets to deposit\n   * @param _owner Address of the owner depositing `_assets` and signing the permit\n   * @param _deadline Timestamp after which the approval is no longer valid\n   * @param _v V part of the secp256k1 signature\n   * @param _r R part of the secp256k1 signature\n   * @param _s S part of the secp256k1 signature\n   * @return uint256 Amount of shares minted to caller.\n   */\n  function sponsorWithPermit(\n    uint256 _assets,\n    address _owner,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external returns (uint256) {\n    _permit(IERC20Permit(asset()), _owner, address(this), _assets, _deadline, _v, _r, _s);\n    return _sponsor(_assets, _owner);\n  }\n\n  /**\n   * @notice Deposit underlying assets that have been mistakenly sent to the Vault into the YieldVault.\n   * @dev The deposited assets will contribute to the yield of the YieldVault.\n   * @return uint256 Amount of underlying assets deposited\n   */\n  function sweep() external returns (uint256) {\n    uint256 _assets = IERC20(asset()).balanceOf(address(this));\n    if (_assets == 0) revert SweepZeroAssets();\n\n    _yieldVault.deposit(_assets, address(this));\n\n    emit Sweep(msg.sender, _assets);\n\n    return _assets;\n  }\n\n  /* ============ Withdraw Functions ============ */\n\n  /// @inheritdoc ERC4626\n  function withdraw(\n    uint256 _assets,\n    address _receiver,\n    address _owner\n  ) public virtual override returns (uint256) {\n    if (_assets > maxWithdraw(_owner))\n      revert WithdrawMoreThanMax(_owner, _assets, maxWithdraw(_owner));\n\n    uint256 _shares = _convertToShares(_assets, Math.Rounding.Up);\n    _withdraw(msg.sender, _receiver, _owner, _assets, _shares);\n\n    return _shares;\n  }\n\n  /// @inheritdoc ERC4626\n  function redeem(\n    uint256 _shares,\n    address _receiver,\n    address _owner\n  ) public virtual override returns (uint256) {\n    if (_shares > maxRedeem(_owner)) revert RedeemMoreThanMax(_owner, _shares, maxRedeem(_owner));\n\n    uint256 _assets = _convertToAssets(_shares, Math.Rounding.Down);\n    _withdraw(msg.sender, _receiver, _owner, _assets, _shares);\n\n    return _assets;\n  }\n\n  /* ============ Liquidation Functions ============ */\n\n  /// @inheritdoc ILiquidationSource\n  function liquidatableBalanceOf(address _token) public view override returns (uint256) {\n    return _liquidatableBalanceOf(_token);\n  }\n\n  /**\n   * @inheritdoc ILiquidationSource\n   * @dev User provides prize tokens and receives in exchange Vault shares.\n   * @dev The yield fee can serve as a buffer in case of undercollateralization of the Vault.\n   * @dev If assets are living in the Vault, we deposit it in the YieldVault.\n   */\n  function liquidate(\n    address _account,\n    address _tokenIn,\n    uint256 _amountIn,\n    address _tokenOut,\n    uint256 _amountOut\n  ) public virtual override returns (bool) {\n    _requireVaultCollateralized();\n\n    if (msg.sender != address(_liquidationPair))\n      revert LiquidationCallerNotLP(msg.sender, address(_liquidationPair));\n\n    if (_tokenIn != address(_prizePool.prizeToken()))\n      revert LiquidationTokenInNotPrizeToken(_tokenIn, address(_prizePool.prizeToken()));\n\n    if (_tokenOut != address(this))\n      revert LiquidationTokenOutNotVaultShare(_tokenOut, address(this));\n\n    if (_amountOut == 0) revert LiquidationAmountOutZero();\n\n    uint256 _assetAmountOut = _convertToAssets(_amountOut, Math.Rounding.Down);\n    uint256 _liquidatableYield = _liquidatableBalanceOf(_tokenOut);\n\n    if (_assetAmountOut > _liquidatableYield)\n      revert LiquidationAmountOutGTYield(_assetAmountOut, _liquidatableYield);\n\n    _prizePool.contributePrizeTokens(address(this), _amountIn);\n\n    // Distributes the specified yield fee percentage.\n    // For instance, with a yield fee percentage of 20% and 8e18 Vault shares being liquidated,\n    // this calculation assigns 2e18 Vault shares to the yield fee recipient.\n    // `_amountOut` is the amount of Vault shares being liquidated after accounting for the yield fee.\n    if (_yieldFeePercentage != 0) {\n      _increaseYieldFeeBalance(\n        (_amountOut * FEE_PRECISION) / (FEE_PRECISION - _yieldFeePercentage) - _amountOut\n      );\n    }\n\n    _mint(_account, _amountOut);\n\n    return true;\n  }\n\n  /// @inheritdoc ILiquidationSource\n  function targetOf(address _token) external view returns (address) {\n    return address(_prizePool);\n  }\n\n  /* ============ Claim Functions ============ */\n\n  /* ============ Setter Functions ============ */\n\n  /**\n   * @notice Set claimer.\n   * @param claimer_ Address of the claimer\n   * @return address New claimer address\n   */\n  function setClaimer(address claimer_) external onlyOwner returns (address) {\n    address _previousClaimer = _claimer;\n    _setClaimer(claimer_);\n\n    emit ClaimerSet(_previousClaimer, claimer_);\n    return claimer_;\n  }\n\n  /**\n   * @notice Sets the hooks for a winner.\n   * @param hooks The hooks to set\n   */\n  function setHooks(VaultHooks memory hooks) external {\n    _hooks[msg.sender] = hooks;\n\n    emit SetHooks(msg.sender, hooks);\n  }\n\n  /**\n   * @notice Set liquidationPair.\n   * @dev We reset approval of the previous liquidationPair and approve max for new one.\n   * @param liquidationPair_ New liquidationPair address\n   * @return address New liquidationPair address\n   */\n  function setLiquidationPair(\n    ILiquidationPair liquidationPair_\n  ) external onlyOwner returns (address) {\n    if (address(liquidationPair_) == address(0)) revert LPZeroAddress();\n\n    IERC20 _asset = IERC20(asset());\n    address _previousLiquidationPair = address(_liquidationPair);\n\n    if (_previousLiquidationPair != address(0)) {\n      _asset.safeApprove(_previousLiquidationPair, 0);\n    }\n\n    _asset.safeApprove(address(liquidationPair_), type(uint256).max);\n\n    _liquidationPair = liquidationPair_;\n\n    emit LiquidationPairSet(liquidationPair_);\n    return address(liquidationPair_);\n  }\n\n  /**\n   * @notice Set yield fee percentage.\n   * @dev Yield fee is represented in 9 decimals and can't exceed `1e9`.\n   * @param yieldFeePercentage_ Yield fee percentage\n   * @return uint256 New yield fee percentage\n   */\n  function setYieldFeePercentage(uint256 yieldFeePercentage_) external onlyOwner returns (uint256) {\n    uint256 _previousYieldFeePercentage = _yieldFeePercentage;\n    _setYieldFeePercentage(yieldFeePercentage_);\n\n    emit YieldFeePercentageSet(_previousYieldFeePercentage, yieldFeePercentage_);\n    return yieldFeePercentage_;\n  }\n\n  /**\n   * @notice Set fee recipient.\n   * @param yieldFeeRecipient_ Address of the fee recipient\n   * @return address New fee recipient address\n   */\n  function setYieldFeeRecipient(address yieldFeeRecipient_) external onlyOwner returns (address) {\n    address _previousYieldFeeRecipient = _yieldFeeRecipient;\n    _setYieldFeeRecipient(yieldFeeRecipient_);\n\n    emit YieldFeeRecipientSet(_previousYieldFeeRecipient, yieldFeeRecipient_);\n    return yieldFeeRecipient_;\n  }\n\n  /* ============ Getter Functions ============ */\n\n  /**\n   * @notice Address of the yield fee recipient.\n   * @return address Yield fee recipient address\n   */\n\n  function yieldFeeRecipient() public view returns (address) {\n    return _yieldFeeRecipient;\n  }\n\n  /**\n   * @notice Yield fee percentage.\n   * @return uint256 Yield fee percentage\n   */\n\n  function yieldFeePercentage() public view returns (uint256) {\n    return _yieldFeePercentage;\n  }\n\n  /**\n   * @notice Get total yield fee accrued by this Vault.\n   * @dev If the vault becomes undercollateralized, this total yield fee can be used to collateralize it.\n   * @return uint256 Total accrued yield fee\n   */\n  function yieldFeeShares() public view returns (uint256) {\n    return _yieldFeeShares;\n  }\n\n  /**\n   * @notice Address of the TwabController keeping track of balances.\n   * @return address TwabController address\n   */\n  function twabController() public view returns (address) {\n    return address(_twabController);\n  }\n\n  /**\n   * @notice Address of the ERC4626 vault generating yield.\n   * @return address YieldVault address\n   */\n  function yieldVault() public view returns (address) {\n    return address(_yieldVault);\n  }\n\n  /**\n   * @notice Address of the LiquidationPair used to liquidate yield for prize token.\n   * @return address LiquidationPair address\n   */\n  function liquidationPair() public view returns (address) {\n    return address(_liquidationPair);\n  }\n\n  /**\n   * @notice Address of the PrizePool that computes prizes.\n   * @return address PrizePool address\n   */\n  function prizePool() public view returns (address) {\n    return address(_prizePool);\n  }\n\n  /**\n   * @notice Address of the claimer.\n   * @return address Claimer address\n   */\n  function claimer() public view returns (address) {\n    return _claimer;\n  }\n\n  /**\n   * @notice Gets the hooks for the given user.\n   * @param _account The user to retrieve the hooks for\n   * @return VaultHooks The hooks for the given user\n   */\n  function getHooks(address _account) external view returns (VaultHooks memory) {\n    return _hooks[_account];\n  }\n\n  /* ============================================ */\n  /* ============ Internal Functions ============ */\n  /* ============================================ */\n\n  /**\n   * @notice Total amount of assets managed by this Vault.\n   * @return uint256 Total amount of assets\n   */\n  function _totalAssets() internal view returns (uint256) {\n    return _yieldVault.maxWithdraw(address(this));\n  }\n\n  /**\n   * @notice Total amount of shares minted by this Vault.\n   * @return uint256 Total amount of shares\n   */\n  function _totalSupply() internal view returns (uint256) {\n    return _twabController.totalSupply(address(this));\n  }\n\n  /* ============ Liquidation Functions ============ */\n\n  /**\n   * @notice Return the yield amount (available yield minus fees) that can be liquidated by minting Vault shares.\n   * @param _token Address of the token to get available balance for\n   * @return uint256 Available amount of `_token`\n   */\n  function _liquidatableBalanceOf(address _token) internal view returns (uint256) {\n    if (_token != address(this)) revert LiquidationTokenOutNotVaultShare(_token, address(this));\n\n    uint256 _availableYield = availableYieldBalance();\n\n    unchecked {\n      return _availableYield -= _availableYieldFeeBalance(_availableYield);\n    }\n  }\n\n  /**\n   * @notice Available yield fee amount.\n   * @param _availableYield Total amount of yield available\n   * @return uint256 Available yield fee balance\n   */\n  function _availableYieldFeeBalance(uint256 _availableYield) internal view returns (uint256) {\n    return (_availableYield * _yieldFeePercentage) / FEE_PRECISION;\n  }\n\n  /**\n   * @notice Increase yield fee balance accrued by `_yieldFeeRecipient`.\n   * @param _shares Amount of shares to increase yield fee balance by\n   */\n  function _increaseYieldFeeBalance(uint256 _shares) internal {\n    _yieldFeeShares += _shares;\n  }\n\n  /* ============ Conversion Functions ============ */\n\n  /**\n   * @inheritdoc ERC4626\n   * @param _assets Amount of assets to convert\n   * @param _rounding Rounding mode (i.e. down or up)\n   * @return uint256 Amount of shares corresponding to the assets\n   */\n  function _convertToShares(\n    uint256 _assets,\n    Math.Rounding _rounding\n  ) internal view virtual override returns (uint256) {\n    uint256 _collateralAssets = _collateral();\n    uint256 _depositedAssets = _totalSupply();\n\n    if (_assets == 0 || _depositedAssets == 0) {\n      return _assets;\n    }\n\n    return\n      _collateralAssets == 0 ? 0 : _assets.mulDiv(_depositedAssets, _collateralAssets, _rounding);\n  }\n\n  /**\n   * @inheritdoc ERC4626\n   * @param _shares Amount of shares to convert\n   * @param _rounding Rounding mode (i.e. down or up)\n   * @return uint256 Amount of assets corresponding to the shares\n   */"
    }
  ]
}