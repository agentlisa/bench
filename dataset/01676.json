{
  "Title": "Risk-prone Accounting in GaugeExtraRewarder",
  "Content": "The `GaugeExtraRewarder` contract tracks shares by updating internal tracking whenever the [`onReward` function](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeExtraRewarder.sol#L71-L83) is called. This function is called from the underlying gauge whenever tokens are [deposited](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeV2.sol#L225) or [withdrawn](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeV2.sol#L251).\n\n\nHowever, if any deposits or withdrawals are executed while the `GaugeExtraRewarder` is paused, the `onReward` function will [not track the state changes](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeExtraRewarder.sol#L72), resulting in the internal accounting of the `GaugeExtraRewarder` not matching the internal accounting of the gauge. Additionally, the internal accounting can become inaccurate if the gauge ever changes its `GaugeExtraRewarder`, or if withdrawals and deposits are done before setting a `GaugeExtraRewarder`.\n\n\nConsider updating the accounting method of the `GaugeExtraRewarder` to accurately track shares on their associated gauge contracts. In order to save gas fees, it may be beneficial to piggyback off of the accounting done on the gauge rather than tracking everything in two places.\n\n\n***Update:** Partially resolved in [pull request #4](https://github.com/ThenafiBNB/THENA-Contracts/pull/4) at commit [6b17ff7](https://github.com/ThenafiBNB/THENA-Contracts/pull/4/commits/6b17ff7e3b01fbd13bd38d5ecadcd0cc59fe2935). The pause functionality for the `GaugeExtraRewarder` contract has been removed. The accounting method has not been altered, which requires that the users interact with the system when a \"GaugeExtraRewarder\" contract with extra reward amount is deployed in order to start accruing their extra reward share.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/GaugeExtraRewarder.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./libraries/SignedSafeMath.sol\";\n\n\ninterface IRewarder {\n    function onReward(uint256 pid, address user, address recipient, uint256 lqdrAmount, uint256 newLpAmount) external;\n    function pendingTokens(uint256 pid, address user, uint256 lqdrAmount) external view returns (IERC20[] memory, uint256[] memory);\n}\n\ninterface IGauge {\n    function TOKEN() external view returns(address);\n}\n\n\ncontract GaugeExtraRewarder is Ownable {\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    bool public stop = false;\n\n    IERC20 public immutable rewardToken;\n\n    /// @notice Info of each user.\n    struct UserInfo {\n        uint256 amount;\n        int256 rewardDebt;\n    }\n\n    /// @notice Struct of pool info\n   \n    struct PoolInfo {\n        uint256 accRewardPerShare;\n        uint256 lastRewardTime;\n    }\n\n    /// @notice pool info\n    PoolInfo public poolInfo;\n\n    /// @notice Info of each user that stakes tokens.\n    mapping(address => UserInfo) public userInfo;\n\n    uint public lastDistributedTime;\n    uint public rewardPerSecond;\n    uint public distributePeriod = 86400 * 7;\n    uint public ACC_TOKEN_PRECISION = 1e12;\n\n\n    address private immutable GAUGE;\n\n    event LogOnReward(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\n\n    constructor (IERC20 _rewardToken, address gauge) {\n        rewardToken = _rewardToken;\n        poolInfo = PoolInfo({\n            lastRewardTime: block.timestamp,\n            accRewardPerShare: 0\n        });\n        GAUGE = gauge;\n    }\n\n\n    function onReward(uint256 /*pid*/, address _user, address to, uint256 /*extraData*/, uint256 lpToken) onlyGauge external {\n        if(stop) return;\n        PoolInfo memory pool = updatePool();\n        UserInfo storage user = userInfo[_user];\n        uint256 pending;\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        if (user.amount > 0) {\n            pending = int256( user.amount.mul(accRewardPerShare) / ACC_TOKEN_PRECISION ).sub(user.rewardDebt).toUInt256();\n            rewardToken.safeTransfer(to, pending);\n        }\n        user.amount = lpToken;\n        user.rewardDebt = int256(lpToken.mul(pool.accRewardPerShare) / ACC_TOKEN_PRECISION);\n    }\n\n\n    /// @notice View function to see pending WBNB on frontend.\n    /// @param _user Address of user.\n    /// @return pending rewardToken reward for a given user.\n    function pendingReward(address _user) external view returns (uint256 pending){\n        PoolInfo memory pool = poolInfo;\n        UserInfo storage user = userInfo[_user];\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        uint256 lpSupply = IERC20(IGauge(GAUGE).TOKEN()).balanceOf(GAUGE);\n\n        if (block.timestamp > pool.lastRewardTime && lpSupply != 0) {\n            uint256 time = block.timestamp.sub(pool.lastRewardTime);\n            uint256 reward = time.mul(rewardPerSecond);\n            accRewardPerShare = accRewardPerShare.add( reward.mul(ACC_TOKEN_PRECISION) / lpSupply );\n        }\n        pending = int256( user.amount.mul(accRewardPerShare) / ACC_TOKEN_PRECISION ).sub(user.rewardDebt).toUInt256();\n    }\n\n\n    modifier onlyGauge {\n        require(msg.sender == GAUGE,\"!GAUGE\");\n        _;\n    }\n\n\n\n    /// @notice Sets the reward per second to be distributed. Can only be called by the owner.\n    /// @param _rewardPerSecond The amount of Reward to be distributed per second.\n    function setRewardPerSecond(uint256 _rewardPerSecond) public onlyOwner {\n        updatePool();\n        rewardPerSecond = _rewardPerSecond;\n    }\n\n\n    function setDistributionRate(uint256 amount) public onlyOwner {\n        updatePool();\n        require(IERC20(rewardToken).balanceOf(address(this)) >= amount);\n        uint256 notDistributed;\n        if (lastDistributedTime > 0 && block.timestamp < lastDistributedTime) {\n            uint256 timeLeft = lastDistributedTime.sub(block.timestamp);\n            notDistributed = rewardPerSecond.mul(timeLeft);\n        }\n\n        amount = amount.add(notDistributed);\n        uint256 _rewardPerSecond = amount.div(distributePeriod);\n        rewardPerSecond = _rewardPerSecond;\n        lastDistributedTime = block.timestamp.add(distributePeriod);\n    }\n\n\n\n    /// @notice Update reward variables of the given pool.\n    /// @return pool Returns the pool that was updated.\n    function updatePool() public returns (PoolInfo memory pool) {\n        pool = poolInfo;\n\n        if (block.timestamp > pool.lastRewardTime) {\n            uint256 lpSupply = IERC20(IGauge(GAUGE).TOKEN()).balanceOf(GAUGE);\n            if (lpSupply > 0) {\n                uint256 time = block.timestamp.sub(pool.lastRewardTime);\n                uint256 reward = time.mul(rewardPerSecond);\n                pool.accRewardPerShare = pool.accRewardPerShare.add( reward.mul(ACC_TOKEN_PRECISION).div(lpSupply) );\n            }\n            pool.lastRewardTime = block.timestamp;\n            poolInfo = pool;\n        }\n    }\n\n\n    function recoverERC20(uint amount, address token) external onlyOwner {\n        require(amount > 0);\n        require(token != address(0));\n        require(IERC20(token).balanceOf(address(this)) >= amount);\n        IERC20(token).safeTransfer(msg.sender, amount);\n    }\n\n    function stopRewarder() external onlyOwner {\n        stop = true;\n    }\n\n    function startRewarder() external onlyOwner {\n        stop = false;\n    }\n\n\n}"
    },
    {
      "filename": "contracts/GaugeExtraRewarder.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./libraries/SignedSafeMath.sol\";\n\n\ninterface IRewarder {\n    function onReward(uint256 pid, address user, address recipient, uint256 lqdrAmount, uint256 newLpAmount) external;\n    function pendingTokens(uint256 pid, address user, uint256 lqdrAmount) external view returns (IERC20[] memory, uint256[] memory);\n}\n\ninterface IGauge {\n    function TOKEN() external view returns(address);\n}\n\n\ncontract GaugeExtraRewarder is Ownable {\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    bool public stop = false;\n\n    IERC20 public immutable rewardToken;\n\n    /// @notice Info of each user.\n    struct UserInfo {\n        uint256 amount;\n        int256 rewardDebt;\n    }\n\n    /// @notice Struct of pool info\n   \n    struct PoolInfo {\n        uint256 accRewardPerShare;\n        uint256 lastRewardTime;\n    }\n\n    /// @notice pool info\n    PoolInfo public poolInfo;\n\n    /// @notice Info of each user that stakes tokens.\n    mapping(address => UserInfo) public userInfo;\n\n    uint public lastDistributedTime;\n    uint public rewardPerSecond;\n    uint public distributePeriod = 86400 * 7;\n    uint public ACC_TOKEN_PRECISION = 1e12;\n\n\n    address private immutable GAUGE;\n\n    event LogOnReward(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\n\n    constructor (IERC20 _rewardToken, address gauge) {\n        rewardToken = _rewardToken;\n        poolInfo = PoolInfo({\n            lastRewardTime: block.timestamp,\n            accRewardPerShare: 0\n        });\n        GAUGE = gauge;\n    }\n\n\n    function onReward(uint256 /*pid*/, address _user, address to, uint256 /*extraData*/, uint256 lpToken) onlyGauge external {\n        if(stop) return;\n        PoolInfo memory pool = updatePool();\n        UserInfo storage user = userInfo[_user];\n        uint256 pending;\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        if (user.amount > 0) {\n            pending = int256( user.amount.mul(accRewardPerShare) / ACC_TOKEN_PRECISION ).sub(user.rewardDebt).toUInt256();\n            rewardToken.safeTransfer(to, pending);\n        }\n        user.amount = lpToken;\n        user.rewardDebt = int256(lpToken.mul(pool.accRewardPerShare) / ACC_TOKEN_PRECISION);\n    }\n\n\n    /// @notice View function to see pending WBNB on frontend.\n    /// @param _user Address of user.\n    /// @return pending rewardToken reward for a given user.\n    function pendingReward(address _user) external view returns (uint256 pending){\n        PoolInfo memory pool = poolInfo;\n        UserInfo storage user = userInfo[_user];\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        uint256 lpSupply = IERC20(IGauge(GAUGE).TOKEN()).balanceOf(GAUGE);\n\n        if (block.timestamp > pool.lastRewardTime && lpSupply != 0) {\n            uint256 time = block.timestamp.sub(pool.lastRewardTime);\n            uint256 reward = time.mul(rewardPerSecond);\n            accRewardPerShare = accRewardPerShare.add( reward.mul(ACC_TOKEN_PRECISION) / lpSupply );\n        }\n        pending = int256( user.amount.mul(accRewardPerShare) / ACC_TOKEN_PRECISION ).sub(user.rewardDebt).toUInt256();\n    }\n\n\n    modifier onlyGauge {\n        require(msg.sender == GAUGE,\"!GAUGE\");\n        _;\n    }\n\n\n\n    /// @notice Sets the reward per second to be distributed. Can only be called by the owner.\n    /// @param _rewardPerSecond The amount of Reward to be distributed per second.\n    function setRewardPerSecond(uint256 _rewardPerSecond) public onlyOwner {\n        updatePool();\n        rewardPerSecond = _rewardPerSecond;\n    }\n\n\n    function setDistributionRate(uint256 amount) public onlyOwner {\n        updatePool();\n        require(IERC20(rewardToken).balanceOf(address(this)) >= amount);\n        uint256 notDistributed;\n        if (lastDistributedTime > 0 && block.timestamp < lastDistributedTime) {\n            uint256 timeLeft = lastDistributedTime.sub(block.timestamp);\n            notDistributed = rewardPerSecond.mul(timeLeft);\n        }\n\n        amount = amount.add(notDistributed);\n        uint256 _rewardPerSecond = amount.div(distributePeriod);\n        rewardPerSecond = _rewardPerSecond;\n        lastDistributedTime = block.timestamp.add(distributePeriod);\n    }\n\n\n\n    /// @notice Update reward variables of the given pool.\n    /// @return pool Returns the pool that was updated.\n    function updatePool() public returns (PoolInfo memory pool) {\n        pool = poolInfo;\n\n        if (block.timestamp > pool.lastRewardTime) {\n            uint256 lpSupply = IERC20(IGauge(GAUGE).TOKEN()).balanceOf(GAUGE);\n            if (lpSupply > 0) {\n                uint256 time = block.timestamp.sub(pool.lastRewardTime);\n                uint256 reward = time.mul(rewardPerSecond);\n                pool.accRewardPerShare = pool.accRewardPerShare.add( reward.mul(ACC_TOKEN_PRECISION).div(lpSupply) );\n            }\n            pool.lastRewardTime = block.timestamp;\n            poolInfo = pool;\n        }\n    }\n\n\n    function recoverERC20(uint amount, address token) external onlyOwner {\n        require(amount > 0);\n        require(token != address(0));\n        require(IERC20(token).balanceOf(address(this)) >= amount);\n        IERC20(token).safeTransfer(msg.sender, amount);\n    }\n\n    function stopRewarder() external onlyOwner {\n        stop = true;\n    }\n\n    function startRewarder() external onlyOwner {\n        stop = false;\n    }\n\n\n}"
    }
  ]
}