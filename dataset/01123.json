{
  "Title": "Lack of Refunds",
  "Content": "The protocol allows users to bridge their ERC-20, ERC-721, ERC-1155, USDC, WETH, and ETH assets to the L2 rollup and back. If the target address is a contract, a callback is executed during the bridging transaction. For example, when calling the `deposit{ERC20|ETH}AndCall` function on the gateway contracts (for [ETH](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/gateways/L1ETHGateway.sol#L62), [ERC-20s, USDC, and WETH](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/gateways/L1ERC20Gateway.sol#L55)), the [`onScrollGatewayCallback`](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/libraries/gateway/ScrollGatewayBase.sol#L111) call is made to the target contract as the last step of the bridging process. The same happens on the `withdraw{ERC20|ETH}AndCall` function. Such callbacks are also standardly triggered on the `safeTransferFrom` function for [ERC-721](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/gateways/L1ERC721Gateway.sol#L117) and [ERC-1155](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/gateways/L1ERC1155Gateway.sol#L123) tokens, which respectively call [`onERC721Received`](https://eips.ethereum.org/EIPS/eip-721#specification) and [`onERC1155Received`](https://eips.ethereum.org/EIPS/eip-1155#specification) on the target contract.\n\n\nHowever, because bridging transactions are not atomic, it is possible for the first half of the transaction to be successful while the second half fails. This can happen when withdrawing/depositing if the external call for the callback on the target contract reverts, for instance, when a user is trying to bridge ETH through the `L{1|2}ETHGateway` but the target contract reverts when calling `onScrollGatewayCallback`. Under such circumstances, users' funds are stuck in the gateways or messenger, as there is no mechanism for them to recover their assets. As mentioned above, the same could happen for the other assets.\n\n\nIt is worth noting that a reverting L2 transaction does not prevent the block from being finalized on L1. Moreover, if the L2 transaction from an L1 deposit is not provable it has to be [skipped from the L1 message queue for finalization](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/rollup/ScrollChain.sol#L167). However, the prior asset deposit into the L1 gateway or messenger would currently not be refunded to the user.\n\n\nFurther, when messaging from L1 to L2 (including bridging assets), users have to provide a [gas limit](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/L1ScrollMessenger.sol#L326) that will be used for the L2 transaction. The relayer accounts for this by deducting a [fee based on the gas limit](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/rollup/L2GasPriceOracle.sol#L101) from the `msg.value` when queuing the transaction on L1. Users expecting this functionality to behave [similarly to Ethereum](https://ethereum.org/en/developers/docs/gas/#what-is-gas-limit) could set a high gas limit to ensure the success of their transaction while being refunded for unused gas. However, any excessive gas results in a fee overpayment that goes towards Scroll's fee vault, and is not refunded on L2.\n\n\nTo avoid funds being lost when bridging, consider adding a way for users to be refunded when the bridging transaction cannot be completed (for example when the transaction reverts or is skipped), and when the gas limit exceeds the gas effectively consumed.\n\n\n***Update**: Acknowledged, not resolved. The Scroll team stated:*\n\n\n\n> *This is not a priority at the time. It will be addressed later on.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/gateways/L1ETHGateway.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport {IL2ETHGateway} from \"../../L2/gateways/IL2ETHGateway.sol\";\nimport {IL1ScrollMessenger} from \"../IL1ScrollMessenger.sol\";\nimport {IL1ETHGateway} from \"./IL1ETHGateway.sol\";\n\nimport {IMessageDropCallback} from \"../../libraries/callbacks/IMessageDropCallback.sol\";\nimport {ScrollGatewayBase} from \"../../libraries/gateway/ScrollGatewayBase.sol\";\n\n// solhint-disable avoid-low-level-calls\n\n/// @title L1ETHGateway\n/// @notice The `L1ETHGateway` is used to deposit ETH in layer 1 and\n/// finalize withdraw ETH from layer 2.\n/// @dev The deposited ETH tokens are held in this gateway. On finalizing withdraw, the corresponding\n/// ETH will be transfer to the recipient directly.\ncontract L1ETHGateway is Initializable, ScrollGatewayBase, IL1ETHGateway, IMessageDropCallback {\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1ETHGateway.\n    /// @param _counterpart The address of L2ETHGateway in L2.\n    /// @param _router The address of L1GatewayRouter.\n    /// @param _messenger The address of L1ScrollMessenger.\n    function initialize(\n        address _counterpart,\n        address _router,\n        address _messenger\n    ) external initializer {\n        require(_router != address(0), \"zero router address\");\n        ScrollGatewayBase._initialize(_counterpart, _router, _messenger);\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(uint256 _amount, uint256 _gasLimit) external payable override {\n        _deposit(msg.sender, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETH(\n        address _to,\n        uint256 _amount,\n        uint256 _gasLimit\n    ) public payable override {\n        _deposit(_to, _amount, new bytes(0), _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function depositETHAndCall(\n        address _to,\n        uint256 _amount,\n        bytes calldata _data,\n        uint256 _gasLimit\n    ) external payable override {\n        _deposit(_to, _amount, _data, _gasLimit);\n    }\n\n    /// @inheritdoc IL1ETHGateway\n    function finalizeWithdrawETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCallByCounterpart nonReentrant {\n        require(msg.value == _amount, \"msg.value mismatch\");\n\n        // @note can possible trigger reentrant call to messenger,\n        // but it seems not a big problem.\n        (bool _success, ) = _to.call{value: _amount}(\"\");\n        require(_success, \"ETH transfer failed\");\n\n        _doCallback(_to, _data);\n\n        emit FinalizeWithdrawETH(_from, _to, _amount, _data);\n    }\n\n    /// @inheritdoc IMessageDropCallback\n    function onDropMessage(bytes calldata _message) external payable virtual onlyInDropContext nonReentrant {\n        // _message should start with 0x232e8748  =>  finalizeDepositETH(address,address,uint256,bytes)\n        require(bytes4(_message[0:4]) == IL2ETHGateway.finalizeDepositETH.selector, \"invalid selector\");\n\n        // decode (receiver, amount)\n        (address _receiver, , uint256 _amount, ) = abi.decode(_message[4:], (address, address, uint256, bytes));\n\n        require(_amount == msg.value, \"msg.value mismatch\");\n\n        (bool _success, ) = _receiver.call{value: _amount}(\"\");\n        require(_success, \"ETH transfer failed\");\n\n        emit RefundETH(_receiver, _amount);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev The internal ETH deposit implementation.\n    /// @param _to The address of recipient's account on L2.\n    /// @param _amount The amount of ETH to be deposited.\n    /// @param _data Optional data to forward to recipient's account.\n    /// @param _gasLimit Gas limit required to complete the deposit on L2.\n    function _deposit(\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        uint256 _gasLimit\n    ) internal virtual nonReentrant {\n        require(_amount > 0, \"deposit zero eth\");\n\n        // 1. Extract real sender if this call is from L1GatewayRouter.\n        address _from = msg.sender;\n        if (router == msg.sender) {\n            (_from, _data) = abi.decode(_data, (address, bytes));\n        }\n\n        // 2. Generate message passed to L1ScrollMessenger.\n        bytes memory _message = abi.encodeCall(IL2ETHGateway.finalizeDepositETH, (_from, _to, _amount, _data));\n\n        IL1ScrollMessenger(messenger).sendMessage{value: msg.value}(counterpart, _amount, _message, _gasLimit, _from);\n\n        emit DepositETH(_from, _to, _amount, _data);\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/rollup/ScrollChain.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport {IL1MessageQueue} from \"./IL1MessageQueue.sol\";\nimport {IScrollChain} from \"./IScrollChain.sol\";\nimport {BatchHeaderV0Codec} from \"../../libraries/codec/BatchHeaderV0Codec.sol\";\nimport {ChunkCodec} from \"../../libraries/codec/ChunkCodec.sol\";\nimport {IRollupVerifier} from \"../../libraries/verifier/IRollupVerifier.sol\";\n\n// solhint-disable no-inline-assembly\n// solhint-disable reason-string\n\n/// @title ScrollChain\n/// @notice This contract maintains data for the Scroll rollup.\ncontract ScrollChain is OwnableUpgradeable, IScrollChain {\n    /**********\n     * Events *\n     **********/\n\n    /// @notice Emitted when owner updates the status of sequencer.\n    /// @param account The address of account updated.\n    /// @param status The status of the account updated.\n    event UpdateSequencer(address indexed account, bool status);\n\n    /// @notice Emitted when owner updates the status of prover.\n    /// @param account The address of account updated.\n    /// @param status The status of the account updated.\n    event UpdateProver(address indexed account, bool status);\n\n    /// @notice Emitted when the address of rollup verifier is updated.\n    /// @param oldVerifier The address of old rollup verifier.\n    /// @param newVerifier The address of new rollup verifier.\n    event UpdateVerifier(address oldVerifier, address newVerifier);\n\n    /// @notice Emitted when the value of `maxNumL2TxInChunk` is updated.\n    /// @param oldMaxNumL2TxInChunk The old value of `maxNumL2TxInChunk`.\n    /// @param newMaxNumL2TxInChunk The new value of `maxNumL2TxInChunk`.\n    event UpdateMaxNumL2TxInChunk(uint256 oldMaxNumL2TxInChunk, uint256 newMaxNumL2TxInChunk);\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @notice The chain id of the corresponding layer 2 chain.\n    uint64 public immutable layer2ChainId;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The maximum number of transactions allowed in each chunk.\n    uint256 public maxNumL2TxInChunk;\n\n    /// @notice The address of L1MessageQueue.\n    address public messageQueue;\n\n    /// @notice The address of RollupVerifier.\n    address public verifier;\n\n    /// @notice Whether an account is a sequencer.\n    mapping(address => bool) public isSequencer;\n\n    /// @notice Whether an account is a prover.\n    mapping(address => bool) public isProver;\n\n    /// @notice The latest finalized batch index.\n    uint256 public lastFinalizedBatchIndex;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override committedBatches;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override finalizedStateRoots;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override withdrawRoots;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier OnlySequencer() {\n        // @note In the decentralized mode, it should be only called by a list of validator.\n        require(isSequencer[msg.sender], \"caller not sequencer\");\n        _;\n    }\n\n    modifier OnlyProver() {\n        require(isProver[msg.sender], \"caller not prover\");\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor(uint64 _chainId) {\n        _disableInitializers();\n\n        layer2ChainId = _chainId;\n    }\n\n    function initialize(\n        address _messageQueue,\n        address _verifier,\n        uint256 _maxNumL2TxInChunk\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        messageQueue = _messageQueue;\n        verifier = _verifier;\n        maxNumL2TxInChunk = _maxNumL2TxInChunk;\n\n        emit UpdateVerifier(address(0), _verifier);\n        emit UpdateMaxNumL2TxInChunk(0, _maxNumL2TxInChunk);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IScrollChain\n    function isBatchFinalized(uint256 _batchIndex) external view override returns (bool) {\n        return _batchIndex <= lastFinalizedBatchIndex;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Import layer 2 genesis block\n    function importGenesisBatch(bytes calldata _batchHeader, bytes32 _stateRoot) external {\n        // check genesis batch header length\n        require(_stateRoot != bytes32(0), \"zero state root\");\n\n        // check whether the genesis batch is imported\n        require(finalizedStateRoots[0] == bytes32(0), \"Genesis batch imported\");\n\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        // check all fields except `dataHash` and `lastBlockHash` are zero\n        unchecked {\n            uint256 sum = BatchHeaderV0Codec.version(memPtr) +\n                BatchHeaderV0Codec.batchIndex(memPtr) +\n                BatchHeaderV0Codec.l1MessagePopped(memPtr) +\n                BatchHeaderV0Codec.totalL1MessagePopped(memPtr);\n            require(sum == 0, \"not all fields are zero\");\n        }\n        require(BatchHeaderV0Codec.dataHash(memPtr) != bytes32(0), \"zero data hash\");\n        require(BatchHeaderV0Codec.parentBatchHash(memPtr) == bytes32(0), \"nonzero parent batch hash\");\n\n        committedBatches[0] = _batchHash;\n        finalizedStateRoots[0] = _stateRoot;\n\n        emit CommitBatch(0, _batchHash);\n        emit FinalizeBatch(0, _batchHash, _stateRoot, bytes32(0));\n    }\n\n    /// @inheritdoc IScrollChain\n    function commitBatch(\n        uint8 _version,\n        bytes calldata _parentBatchHeader,\n        bytes[] memory _chunks,\n        bytes calldata _skippedL1MessageBitmap\n    ) external override OnlySequencer {\n        require(_version == 0, \"invalid version\");\n\n        // check whether the batch is empty\n        uint256 _chunksLength = _chunks.length;\n        require(_chunksLength > 0, \"batch is empty\");\n\n        // The overall memory layout in this function is organized as follows\n        // +---------------------+-------------------+------------------+\n        // | parent batch header | chunk data hashes | new batch header |\n        // +---------------------+-------------------+------------------+\n        // ^                     ^                   ^\n        // batchPtr              dataPtr             newBatchPtr (re-use var batchPtr)\n        //\n        // 1. We copy the parent batch header from calldata to memory starting at batchPtr\n        // 2. We store `_chunksLength` number of Keccak hashes starting at `dataPtr`. Each Keccak\n        //    hash corresponds to the data hash of a chunk. So we reserve the memory region from\n        //    `dataPtr` to `dataPtr + _chunkLength * 32` for the chunk data hashes.\n        // 3. The memory starting at `newBatchPtr` is used to store the new batch header and compute\n        //    the batch hash.\n\n        // the variable `batchPtr` will be reused later for the current batch\n        (uint256 batchPtr, bytes32 _parentBatchHash) = _loadBatchHeader(_parentBatchHeader);\n\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(batchPtr);\n        uint256 _totalL1MessagesPoppedOverall = BatchHeaderV0Codec.totalL1MessagePopped(batchPtr);\n        require(committedBatches[_batchIndex] == _parentBatchHash, \"incorrect parent batch hash\");\n        require(committedBatches[_batchIndex + 1] == 0, \"batch already committed\");\n\n        // load `dataPtr` and reserve the memory region for chunk data hashes\n        uint256 dataPtr;\n        assembly {\n            dataPtr := mload(0x40)\n            mstore(0x40, add(dataPtr, mul(_chunksLength, 32)))\n        }\n\n        // compute the data hash for each chunk\n        uint256 _totalL1MessagesPoppedInBatch;\n        for (uint256 i = 0; i < _chunksLength; i++) {\n            uint256 _totalNumL1MessagesInChunk = _commitChunk(\n                dataPtr,\n                _chunks[i],\n                _totalL1MessagesPoppedInBatch,\n                _totalL1MessagesPoppedOverall,\n                _skippedL1MessageBitmap\n            );\n\n            unchecked {\n                _totalL1MessagesPoppedInBatch += _totalNumL1MessagesInChunk;\n                _totalL1MessagesPoppedOverall += _totalNumL1MessagesInChunk;\n                dataPtr += 32;\n            }\n        }\n\n        // check the length of bitmap\n        unchecked {\n            require(\n                ((_totalL1MessagesPoppedInBatch + 255) / 256) * 32 == _skippedL1MessageBitmap.length,\n                \"wrong bitmap length\"\n            );\n        }\n\n        // compute the data hash for current batch\n        bytes32 _dataHash;\n        assembly {\n            let dataLen := mul(_chunksLength, 0x20)\n            _dataHash := keccak256(sub(dataPtr, dataLen), dataLen)\n\n            batchPtr := mload(0x40) // reset batchPtr\n            _batchIndex := add(_batchIndex, 1) // increase batch index\n        }\n\n        // store entries, the order matters\n        BatchHeaderV0Codec.storeVersion(batchPtr, _version);\n        BatchHeaderV0Codec.storeBatchIndex(batchPtr, _batchIndex);\n        BatchHeaderV0Codec.storeL1MessagePopped(batchPtr, _totalL1MessagesPoppedInBatch);\n        BatchHeaderV0Codec.storeTotalL1MessagePopped(batchPtr, _totalL1MessagesPoppedOverall);\n        BatchHeaderV0Codec.storeDataHash(batchPtr, _dataHash);\n        BatchHeaderV0Codec.storeParentBatchHash(batchPtr, _parentBatchHash);\n        BatchHeaderV0Codec.storeSkippedBitmap(batchPtr, _skippedL1MessageBitmap);\n\n        // compute batch hash\n        bytes32 _batchHash = BatchHeaderV0Codec.computeBatchHash(batchPtr, 89 + _skippedL1MessageBitmap.length);\n\n        committedBatches[_batchIndex] = _batchHash;\n        emit CommitBatch(_batchIndex, _batchHash);\n    }\n\n    /// @inheritdoc IScrollChain\n    /// @dev If the owner want to revert a sequence of batches by sending multiple transactions,\n    ///      make sure to revert recent batches first.\n    function revertBatch(bytes calldata _batchHeader, uint256 _count) external onlyOwner {\n        require(_count > 0, \"count must be nonzero\");\n\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        // check batch hash\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(memPtr);\n        require(committedBatches[_batchIndex] == _batchHash, \"incorrect batch hash\");\n        // make sure no gap is left when reverting from the ending to the beginning.\n        require(committedBatches[_batchIndex + _count] == bytes32(0), \"reverting must start from the ending\");\n\n        // check finalization\n        require(_batchIndex > lastFinalizedBatchIndex, \"can only revert unfinalized batch\");\n\n        while (_count > 0) {\n            emit RevertBatch(_batchIndex, _batchHash);\n\n            committedBatches[_batchIndex] = bytes32(0);\n            unchecked {\n                _batchIndex += 1;\n                _count -= 1;\n            }\n\n            _batchHash = committedBatches[_batchIndex];\n            if (_batchHash == bytes32(0)) break;\n        }\n    }\n\n    /// @inheritdoc IScrollChain\n    function finalizeBatchWithProof(\n        bytes calldata _batchHeader,\n        bytes32 _prevStateRoot,\n        bytes32 _postStateRoot,\n        bytes32 _withdrawRoot,\n        bytes calldata _aggrProof\n    ) external override OnlyProver {\n        require(_prevStateRoot != bytes32(0), \"previous state root is zero\");\n        require(_postStateRoot != bytes32(0), \"new state root is zero\");\n\n        // compute batch hash and verify\n        (uint256 memPtr, bytes32 _batchHash) = _loadBatchHeader(_batchHeader);\n\n        bytes32 _dataHash = BatchHeaderV0Codec.dataHash(memPtr);\n        uint256 _batchIndex = BatchHeaderV0Codec.batchIndex(memPtr);\n        require(committedBatches[_batchIndex] == _batchHash, \"incorrect batch hash\");\n\n        // verify previous state root.\n        require(finalizedStateRoots[_batchIndex - 1] == _prevStateRoot, \"incorrect previous state root\");\n\n        // avoid duplicated verification\n        require(finalizedStateRoots[_batchIndex] == bytes32(0), \"batch already verified\");\n\n        // compute public input hash\n        bytes32 _publicInputHash = keccak256(\n            abi.encodePacked(layer2ChainId, _prevStateRoot, _postStateRoot, _withdrawRoot, _dataHash)\n        );\n\n        // verify batch\n        IRollupVerifier(verifier).verifyAggregateProof(_batchIndex, _aggrProof, _publicInputHash);\n\n        // check and update lastFinalizedBatchIndex\n        unchecked {\n            require(lastFinalizedBatchIndex + 1 == _batchIndex, \"incorrect batch index\");\n            lastFinalizedBatchIndex = _batchIndex;\n        }\n\n        // record state root and withdraw root\n        finalizedStateRoots[_batchIndex] = _postStateRoot;\n        withdrawRoots[_batchIndex] = _withdrawRoot;\n\n        // Pop finalized and non-skipped message from L1MessageQueue.\n        uint256 _l1MessagePopped = BatchHeaderV0Codec.l1MessagePopped(memPtr);\n        if (_l1MessagePopped > 0) {\n            IL1MessageQueue _queue = IL1MessageQueue(messageQueue);\n\n            unchecked {\n                uint256 _startIndex = BatchHeaderV0Codec.totalL1MessagePopped(memPtr) - _l1MessagePopped;\n\n                for (uint256 i = 0; i < _l1MessagePopped; i += 256) {\n                    uint256 _count = 256;\n                    if (_l1MessagePopped - i < _count) {\n                        _count = _l1MessagePopped - i;\n                    }\n                    uint256 _skippedBitmap = BatchHeaderV0Codec.skippedBitmap(memPtr, i / 256);\n\n                    _queue.popCrossDomainMessage(_startIndex, _count, _skippedBitmap);\n\n                    _startIndex += 256;\n                }\n            }\n        }\n\n        emit FinalizeBatch(_batchIndex, _batchHash, _postStateRoot, _withdrawRoot);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Update the status of sequencer.\n    /// @dev This function can only called by contract owner.\n    /// @param _account The address of account to update.\n    /// @param _status The status of the account to update.\n    function updateSequencer(address _account, bool _status) external onlyOwner {\n        isSequencer[_account] = _status;\n\n        emit UpdateSequencer(_account, _status);\n    }\n\n    /// @notice Update the status of prover.\n    /// @dev This function can only called by contract owner.\n    /// @param _account The address of account to update.\n    /// @param _status The status of the account to update.\n    function updateProver(address _account, bool _status) external onlyOwner {\n        isProver[_account] = _status;\n\n        emit UpdateProver(_account, _status);\n    }\n\n    /// @notice Update the address verifier contract.\n    /// @param _newVerifier The address of new verifier contract.\n    function updateVerifier(address _newVerifier) external onlyOwner {\n        address _oldVerifier = verifier;\n        verifier = _newVerifier;\n\n        emit UpdateVerifier(_oldVerifier, _newVerifier);\n    }\n\n    /// @notice Update the value of `maxNumL2TxInChunk`.\n    /// @param _maxNumL2TxInChunk The new value of `maxNumL2TxInChunk`.\n    function updateMaxNumL2TxInChunk(uint256 _maxNumL2TxInChunk) external onlyOwner {\n        uint256 _oldMaxNumL2TxInChunk = maxNumL2TxInChunk;\n        maxNumL2TxInChunk = _maxNumL2TxInChunk;\n\n        emit UpdateMaxNumL2TxInChunk(_oldMaxNumL2TxInChunk, _maxNumL2TxInChunk);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to load batch header from calldata to memory.\n    /// @param _batchHeader The batch header in calldata.\n    /// @return memPtr The start memory offset of loaded batch header.\n    /// @return _batchHash The hash of the loaded batch header.\n    function _loadBatchHeader(bytes calldata _batchHeader) internal pure returns (uint256 memPtr, bytes32 _batchHash) {\n        // load to memory\n        uint256 _length;\n        (memPtr, _length) = BatchHeaderV0Codec.loadAndValidate(_batchHeader);\n\n        // compute batch hash\n        _batchHash = BatchHeaderV0Codec.computeBatchHash(memPtr, _length);\n    }\n\n    /// @dev Internal function to commit a chunk.\n    /// @param memPtr The start memory offset to store list of `dataHash`.\n    /// @param _chunk The encoded chunk to commit.\n    /// @param _totalL1MessagesPoppedInBatch The total number of L1 messages popped in current batch.\n    /// @param _totalL1MessagesPoppedOverall The total number of L1 messages popped in all batches including current batch.\n    /// @param _skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    /// @return _totalNumL1MessagesInChunk The total number of L1 message popped in current chunk\n    function _commitChunk(\n        uint256 memPtr,\n        bytes memory _chunk,\n        uint256 _totalL1MessagesPoppedInBatch,\n        uint256 _totalL1MessagesPoppedOverall,\n        bytes calldata _skippedL1MessageBitmap\n    ) internal view returns (uint256 _totalNumL1MessagesInChunk) {\n        uint256 chunkPtr;\n        uint256 startDataPtr;\n        uint256 dataPtr;\n        uint256 blockPtr;\n\n        assembly {\n            dataPtr := mload(0x40)\n            startDataPtr := dataPtr\n            chunkPtr := add(_chunk, 0x20) // skip chunkLength\n            blockPtr := add(chunkPtr, 1) // skip numBlocks\n        }\n\n        uint256 _numBlocks = ChunkCodec.validateChunkLength(chunkPtr, _chunk.length);\n\n        // concatenate block contexts\n        uint256 _totalTransactionsInChunk;\n        for (uint256 i = 0; i < _numBlocks; i++) {\n            dataPtr = ChunkCodec.copyBlockContext(chunkPtr, dataPtr, i);\n            uint256 _numTransactionsInBlock = ChunkCodec.numTransactions(blockPtr);\n            unchecked {\n                _totalTransactionsInChunk += _numTransactionsInBlock;\n                blockPtr += ChunkCodec.BLOCK_CONTEXT_LENGTH;\n            }\n        }\n\n        assembly {\n            mstore(0x40, add(dataPtr, mul(_totalTransactionsInChunk, 0x20))) // reserve memory for tx hashes\n            blockPtr := add(chunkPtr, 1) // reset block ptr\n        }\n\n        // concatenate tx hashes\n        uint256 l2TxPtr = ChunkCodec.l2TxPtr(chunkPtr, _numBlocks);\n        while (_numBlocks > 0) {\n            // concatenate l1 message hashes\n            uint256 _numL1MessagesInBlock = ChunkCodec.numL1Messages(blockPtr);\n            dataPtr = _loadL1MessageHashes(\n                dataPtr,\n                _numL1MessagesInBlock,\n                _totalL1MessagesPoppedInBatch,\n                _totalL1MessagesPoppedOverall,\n                _skippedL1MessageBitmap\n            );\n\n            // concatenate l2 transaction hashes\n            uint256 _numTransactionsInBlock = ChunkCodec.numTransactions(blockPtr);\n            for (uint256 j = _numL1MessagesInBlock; j < _numTransactionsInBlock; j++) {\n                bytes32 txHash;\n                (txHash, l2TxPtr) = ChunkCodec.loadL2TxHash(l2TxPtr);\n                assembly {\n                    mstore(dataPtr, txHash)\n                    dataPtr := add(dataPtr, 0x20)\n                }\n            }\n\n            unchecked {\n                _totalNumL1MessagesInChunk += _numL1MessagesInBlock;\n                _totalL1MessagesPoppedInBatch += _numL1MessagesInBlock;\n                _totalL1MessagesPoppedOverall += _numL1MessagesInBlock;\n\n                _numBlocks -= 1;\n                blockPtr += ChunkCodec.BLOCK_CONTEXT_LENGTH;\n            }\n        }\n\n        // check the number of L2 transactions in the chunk\n        require(\n            _totalTransactionsInChunk - _totalNumL1MessagesInChunk <= maxNumL2TxInChunk,\n            \"too many L2 txs in one chunk\"\n        );\n\n        // check chunk has correct length\n        require(l2TxPtr - chunkPtr == _chunk.length, \"incomplete l2 transaction data\");\n\n        // compute data hash and store to memory\n        assembly {\n            let dataHash := keccak256(startDataPtr, sub(dataPtr, startDataPtr))\n            mstore(memPtr, dataHash)\n        }\n\n        return _totalNumL1MessagesInChunk;\n    }\n\n    /// @dev Internal function to load L1 message hashes from the message queue.\n    /// @param _ptr The memory offset to store the transaction hash.\n    /// @param _numL1Messages The number of L1 messages to load.\n    /// @param _totalL1MessagesPoppedInBatch The total number of L1 messages popped in current batch.\n    /// @param _totalL1MessagesPoppedOverall The total number of L1 messages popped in all batches including current batch.\n    /// @param _skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    /// @return uint256 The new memory offset after loading.\n    function _loadL1MessageHashes(\n        uint256 _ptr,\n        uint256 _numL1Messages,\n        uint256 _totalL1MessagesPoppedInBatch,\n        uint256 _totalL1MessagesPoppedOverall,\n        bytes calldata _skippedL1MessageBitmap\n    ) internal view returns (uint256) {\n        if (_numL1Messages == 0) return _ptr;\n        IL1MessageQueue _messageQueue = IL1MessageQueue(messageQueue);\n\n        unchecked {\n            uint256 _bitmap;\n            for (uint256 i = 0; i < _numL1Messages; i++) {\n                uint256 quo = _totalL1MessagesPoppedInBatch >> 8;\n                uint256 rem = _totalL1MessagesPoppedInBatch & 0xff;\n\n                // load bitmap every 256 bits\n                if (i == 0 || rem == 0) {\n                    assembly {\n                        _bitmap := calldataload(add(_skippedL1MessageBitmap.offset, mul(0x20, quo)))\n                    }\n                }\n                if (((_bitmap >> rem) & 1) == 0) {\n                    // message not skipped\n                    bytes32 _hash = _messageQueue.getCrossDomainMessage(_totalL1MessagesPoppedOverall);\n                    assembly {\n                        mstore(_ptr, _hash)\n                        _ptr := add(_ptr, 0x20)\n                    }\n                }\n\n                _totalL1MessagesPoppedInBatch += 1;\n                _totalL1MessagesPoppedOverall += 1;\n            }\n        }\n\n        return _ptr;\n    }\n}"
    },
    {
      "filename": "contracts/src/L1/L1ScrollMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IScrollChain} from \"./rollup/IScrollChain.sol\";\nimport {IL1MessageQueue} from \"./rollup/IL1MessageQueue.sol\";\nimport {IL1ScrollMessenger} from \"./IL1ScrollMessenger.sol\";\nimport {ScrollConstants} from \"../libraries/constants/ScrollConstants.sol\";\nimport {IScrollMessenger} from \"../libraries/IScrollMessenger.sol\";\nimport {ScrollMessengerBase} from \"../libraries/ScrollMessengerBase.sol\";\nimport {AddressAliasHelper} from \"../libraries/common/AddressAliasHelper.sol\";\nimport {WithdrawTrieVerifier} from \"../libraries/verifier/WithdrawTrieVerifier.sol\";\n\nimport {IMessageDropCallback} from \"../libraries/callbacks/IMessageDropCallback.sol\";\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable reason-string\n\n/// @title L1ScrollMessenger\n/// @notice The `L1ScrollMessenger` contract can:\n///\n/// 1. send messages from layer 1 to layer 2;\n/// 2. relay messages from layer 2 layer 1;\n/// 3. replay failed message by replacing the gas limit;\n/// 4. drop expired message due to sequencer problems.\n///\n/// @dev All deposited Ether (including `WETH` deposited throng `L1WETHGateway`) will locked in\n/// this contract.\ncontract L1ScrollMessenger is PausableUpgradeable, ScrollMessengerBase, IL1ScrollMessenger {\n    /***********\n     * Structs *\n     ***********/\n\n    struct ReplayState {\n        // The number of replayed times.\n        uint128 times;\n        // The queue index of lastest replayed one. If it is zero, it means the message has not been replayed.\n        uint128 lastIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L1 message hash to sent status.\n    mapping(bytes32 => bool) public isL1MessageSent;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to drop status.\n    mapping(bytes32 => bool) public isL1MessageDropped;\n\n    /// @notice The address of Rollup contract.\n    address public rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public messageQueue;\n\n    /// @notice The maximum number of times each L1 message can be replayed.\n    uint256 public maxReplayTimes;\n\n    /// @notice Mapping from L1 message hash to replay state.\n    mapping(bytes32 => ReplayState) public replayStates;\n\n    /// @notice Mapping from queue index to previous replay queue index.\n    ///\n    /// @dev If a message `x` was replayed 3 times with index `q1`, `q2` and `q3`, the\n    /// value of `prevReplayIndex` and `replayStates` will be `replayStates[hash(x)].lastIndex = q3`,\n    /// `replayStates[hash(x)].times = 3`, `prevReplayIndex[q3] = q2`, `prevReplayIndex[q2] = q1`,\n    /// `prevReplayIndex[q1] = x` and `prevReplayIndex[x]=nil`.\n    ///\n    /// @dev The index `x` that `prevReplayIndex[x]=nil` is used as the termination of the list.\n    /// Usually we use `0` to represent `nil`, but we cannot distinguish it with the first message\n    /// with index zero. So a nonzero offset `1` is added to the value of `prevReplayIndex[x]` to\n    /// avoid such situation.\n    mapping(uint256 => uint256) public prevReplayIndex;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        PausableUpgradeable.__Pausable_init();\n        ScrollMessengerBase._initialize(_counterpart, _feeVault);\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, msg.sender);\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused notInExecution {\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], \"Message was already successfully executed\");\n\n        {\n            address _rollup = rollup;\n            require(IScrollChain(_rollup).isBatchFinalized(_proof.batchIndex), \"Batch is not finalized\");"
    }
  ]
}