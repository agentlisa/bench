{
  "Title": "[M-10] Griefer can extend period of higher withdrawal fees",
  "Content": "_Submitted by 0xDjango_\n\n[LiquidityPool.sol#L790-L792](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/LiquidityPool.sol#L790-L792)<br>\n\nThe `_updateUserFeesOnDeposit()` function in `LiquidityPool.sol` is used to update a user's withdrawal fees after an action such as deposit, transfer in, etc. The withdrawal fee decays toward a minimum withdrawal fee over a period of 1 or 2 weeks (discussed with developer). Since anyone can transfer lp tokens to any user, a griefer can transfer 1 wei of lp tokens to another user to reset their `lastActionTimestamp` used in the withdrawal fee calculation.\n\nThe developers nicely weight the updated withdrawal fee by taking the original balance/original fee vs the added balance/added fee. The attacker will only be able to extend the runway of the withdrawal fee cooldown by resetting the `lastActionTimestamp` for future calculations. Example below:\n\n### Proof of Concept\nAssumptions:\n- MinWithdrawalFee = 0% //For easy math\n- MaxWithdrawalFee = 10%\n- timeToWait = 2 weeks\n\n#### Steps\n- User A has `100 wei` of shares\n- User A waits 1 week (Current withdrawal fee = 5%)\n- User B deposits, receives `1 wei` of shares, current withdrawal fee = 10%\n- User B immediately transfers `1 wei` of shares to User A\n\nBased on the formula to calculated User A's new feeRatio:\n\n```solidity\nuint256 newFeeRatio = shareExisting.scaledMul(newCurrentFeeRatio) +\n    shareAdded.scaledMul(feeOnDeposit);\n```\n\nIn reality, User A's withdrawal fee will only increase by a negligible amount since the shares added were very small in proportion to the original shares. We can assume user A's current withdrawal fee is still 5%.\n\nThe issue is that the function then reset's User A's `lastActionTimestamp` to the current time. This means that User A will have to wait the maximum 2 weeks for the withdrawal fee to reduce from 5% to 0%. Effectively the cooldown runway is the same length as the original runway length, so the decay down to 0% will take twice as long.\n\n`meta.lastActionTimestamp = uint64(_getTime());`\n\n### Recommended Mitigation Steps\nInstead of resetting `lastActionTimestamp` to the current time, scale it the same way the `feeRatio` is scaled. I understand that this would technically not be the timestamp of the last action, so the variable would probably need to be renamed.\n\n**[chase-manning (Backd) confirmed and resolved](https://github.com/code-423n4/2022-04-backd-findings/issues/56)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-backd-contest",
  "Code": [
    {
      "filename": "backd/contracts/pool/LiquidityPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/pool/ILiquidityPool.sol\";\nimport \"../../interfaces/ILpToken.sol\";\nimport \"../../interfaces/IStakerVault.sol\";\nimport \"../../interfaces/IVault.sol\";\n\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/ScaledMath.sol\";\n\nimport \"../access/Authorization.sol\";\nimport \"../utils/Preparable.sol\";\nimport \"../utils/Pausable.sol\";\n\n/**\n * @dev Pausing/unpausing the pool will disable/re-enable deposits.\n */\nabstract contract LiquidityPool is\n    ILiquidityPool,\n    Authorization,\n    Preparable,\n    Pausable,\n    Initializable\n{\n    using AddressProviderHelpers for IAddressProvider;\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n\n    struct WithdrawalFeeMeta {\n        uint64 timeToWait;\n        uint64 feeRatio;\n        uint64 lastActionTimestamp;\n    }\n\n    bytes32 internal constant _VAULT_KEY = \"Vault\";\n    bytes32 internal constant _RESERVE_DEVIATION_KEY = \"ReserveDeviation\";\n    bytes32 internal constant _REQUIRED_RESERVES_KEY = \"RequiredReserves\";\n\n    bytes32 internal constant _MAX_WITHDRAWAL_FEE_KEY = \"MaxWithdrawalFee\";\n    bytes32 internal constant _MIN_WITHDRAWAL_FEE_KEY = \"MinWithdrawalFee\";\n    bytes32 internal constant _WITHDRAWAL_FEE_DECREASE_PERIOD_KEY = \"WithdrawalFeeDecreasePeriod\";\n\n    uint256 internal constant _INITIAL_RESERVE_DEVIATION = 0.005e18; // 0.5%\n    uint256 internal constant _INITIAL_FEE_DECREASE_PERIOD = 1 weeks;\n    uint256 internal constant _INITIAL_MAX_WITHDRAWAL_FEE = 0.03e18; // 3%\n\n    /**\n     * @notice even through admin votes and later governance, the withdrawal\n     * fee will never be able to go above this value\n     */\n    uint256 internal constant _MAX_WITHDRAWAL_FEE = 0.05e18;\n\n    /**\n     * @notice Keeps track of the withdrawal fees on a per-address basis\n     */\n    mapping(address => WithdrawalFeeMeta) public withdrawalFeeMetas;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    uint256 public depositCap;\n    IStakerVault public staker;\n    ILpToken public lpToken;\n    string public name;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        require(address(_controller) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        controller = IController(_controller);\n        addressProvider = IController(_controller).addressProvider();\n    }\n\n    /**\n     * @notice Deposit funds into liquidity pool and mint LP tokens in exchange.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @return The actual amount minted.\n     */\n    function deposit(uint256 depositAmount) external payable override returns (uint256) {\n        return depositFor(msg.sender, depositAmount, 0);\n    }\n\n    /**\n     * @notice Deposit funds into liquidity pool and mint LP tokens in exchange.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @param minTokenAmount Minimum amount of LP tokens that should be minted.\n     * @return The actual amount minted.\n     */\n    function deposit(uint256 depositAmount, uint256 minTokenAmount)\n        external\n        payable\n        override\n        returns (uint256)\n    {\n        return depositFor(msg.sender, depositAmount, minTokenAmount);\n    }\n\n    /**\n     * @notice Deposit funds into liquidity pool and stake LP Tokens in Staker Vault.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @param minTokenAmount Minimum amount of LP tokens that should be minted.\n     * @return The actual amount minted and staked.\n     */\n    function depositAndStake(uint256 depositAmount, uint256 minTokenAmount)\n        external\n        payable\n        override\n        returns (uint256)\n    {\n        uint256 amountMinted_ = depositFor(address(this), depositAmount, minTokenAmount);\n        staker.stakeFor(msg.sender, amountMinted_);\n        return amountMinted_;\n    }\n\n    /**\n     * @notice Withdraws all funds from vault.\n     * @dev Should be called in case of emergencies.\n     */\n    function withdrawAll() external override onlyGovernance {\n        getVault().withdrawAll();\n    }\n\n    function setLpToken(address _lpToken)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)\n        returns (bool)\n    {\n        require(address(lpToken) == address(0), Error.ADDRESS_ALREADY_SET);\n        require(ILpToken(_lpToken).minter() == address(this), Error.INVALID_MINTER);\n        lpToken = ILpToken(_lpToken);\n        _approveStakerVaultSpendingLpTokens();\n        emit LpTokenSet(_lpToken);\n        return true;\n    }\n\n    /**\n     * @notice Checkpoint function to update a user's withdrawal fees on deposit and redeem\n     * @param from Address sending from\n     * @param to Address sending to\n     * @param amount Amount to redeem or deposit\n     */\n    function handleLpTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) external override {\n        require(\n            msg.sender == address(lpToken) || msg.sender == address(staker),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        if (\n            addressProvider.isStakerVault(to, address(lpToken)) ||\n            addressProvider.isStakerVault(from, address(lpToken)) ||\n            addressProvider.isAction(to) ||\n            addressProvider.isAction(from)\n        ) {\n            return;\n        }\n\n        if (to != address(0)) {\n            _updateUserFeesOnDeposit(to, from, amount);\n        }\n    }\n\n    /**\n     * @notice Prepare update of required reserve ratio (with time delay enforced).\n     * @param _newRatio New required reserve ratio.\n     * @return `true` if success.\n     */\n    function prepareNewRequiredReserves(uint256 _newRatio) external onlyGovernance returns (bool) {\n        require(_newRatio <= ScaledMath.ONE, Error.INVALID_AMOUNT);\n        return _prepare(_REQUIRED_RESERVES_KEY, _newRatio);\n    }\n\n    /**\n     * @notice Execute required reserve ratio update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New required reserve ratio.\n     */\n    function executeNewRequiredReserves() external override returns (uint256) {\n        uint256 requiredReserveRatio = _executeUInt256(_REQUIRED_RESERVES_KEY);\n        _rebalanceVault();\n        return requiredReserveRatio;\n    }\n\n    /**\n     * @notice Reset the prepared required reserves.\n     * @return `true` if success.\n     */\n    function resetRequiredReserves() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_REQUIRED_RESERVES_KEY);\n    }\n\n    /**\n     * @notice Prepare update of reserve deviation ratio (with time delay enforced).\n     * @param newRatio New reserve deviation ratio.\n     * @return `true` if success.\n     */\n    function prepareNewReserveDeviation(uint256 newRatio) external onlyGovernance returns (bool) {\n        require(newRatio <= (ScaledMath.DECIMAL_SCALE * 50) / 100, Error.INVALID_AMOUNT);\n        return _prepare(_RESERVE_DEVIATION_KEY, newRatio);\n    }\n\n    /**\n     * @notice Execute reserve deviation ratio update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New reserve deviation ratio.\n     */\n    function executeNewReserveDeviation() external override returns (uint256) {\n        uint256 reserveDeviation = _executeUInt256(_RESERVE_DEVIATION_KEY);\n        _rebalanceVault();\n        return reserveDeviation;\n    }\n\n    /**\n     * @notice Reset the prepared reserve deviation.\n     * @return `true` if success.\n     */\n    function resetNewReserveDeviation() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_RESERVE_DEVIATION_KEY);\n    }\n\n    /**\n     * @notice Prepare update of min withdrawal fee (with time delay enforced).\n     * @param newFee New min withdrawal fee.\n     * @return `true` if success.\n     */\n    function prepareNewMinWithdrawalFee(uint256 newFee) external onlyGovernance returns (bool) {\n        _checkFeeInvariants(newFee, getMaxWithdrawalFee());\n        return _prepare(_MIN_WITHDRAWAL_FEE_KEY, newFee);\n    }\n\n    /**\n     * @notice Execute min withdrawal fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New withdrawal fee.\n     */\n    function executeNewMinWithdrawalFee() external returns (uint256) {\n        uint256 newFee = _executeUInt256(_MIN_WITHDRAWAL_FEE_KEY);\n        _checkFeeInvariants(newFee, getMaxWithdrawalFee());\n        return newFee;\n    }\n\n    /**\n     * @notice Reset the prepared min withdrawal fee\n     * @return `true` if success.\n     */\n    function resetNewMinWithdrawalFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MIN_WITHDRAWAL_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare update of max withdrawal fee (with time delay enforced).\n     * @param newFee New max withdrawal fee.\n     * @return `true` if success.\n     */\n    function prepareNewMaxWithdrawalFee(uint256 newFee) external onlyGovernance returns (bool) {\n        _checkFeeInvariants(getMinWithdrawalFee(), newFee);\n        return _prepare(_MAX_WITHDRAWAL_FEE_KEY, newFee);\n    }\n\n    /**\n     * @notice Execute max withdrawal fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New max withdrawal fee.\n     */\n    function executeNewMaxWithdrawalFee() external override returns (uint256) {\n        uint256 newFee = _executeUInt256(_MAX_WITHDRAWAL_FEE_KEY);\n        _checkFeeInvariants(getMinWithdrawalFee(), newFee);\n        return newFee;\n    }\n\n    /**\n     * @notice Reset the prepared max fee.\n     * @return `true` if success.\n     */\n    function resetNewMaxWithdrawalFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_WITHDRAWAL_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare update of withdrawal decrease fee period (with time delay enforced).\n     * @param newPeriod New withdrawal fee decrease period.\n     * @return `true` if success.\n     */\n    function prepareNewWithdrawalFeeDecreasePeriod(uint256 newPeriod)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY, newPeriod);\n    }\n\n    /**\n     * @notice Execute withdrawal fee decrease period update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New withdrawal fee decrease period.\n     */\n    function executeNewWithdrawalFeeDecreasePeriod() external returns (uint256) {\n        return _executeUInt256(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY);\n    }\n\n    /**\n     * @notice Reset the prepared withdrawal fee decrease period update.\n     * @return `true` if success.\n     */\n    function resetNewWithdrawalFeeDecreasePeriod() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY);\n    }\n\n    /**\n     * @notice Set the staker vault for this pool's LP token\n     * @dev Staker vault and LP token pairs are immutable and the staker vault can only be set once for a pool.\n     *      Only one vault exists per LP token. This information will be retrieved from the controller of the pool.\n     * @return Address of the new staker vault for the pool.\n     */\n    function setStaker()\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)\n        returns (bool)\n    {\n        require(address(staker) == address(0), Error.ADDRESS_ALREADY_SET);\n        address stakerVault = addressProvider.getStakerVault(address(lpToken));\n        require(stakerVault != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        staker = IStakerVault(stakerVault);\n        _approveStakerVaultSpendingLpTokens();\n        emit StakerVaultSet(stakerVault);\n        return true;\n    }\n\n    /**\n     * @notice Prepare setting a new Vault (with time delay enforced).\n     * @param _vault Address of new Vault contract.\n     * @return `true` if success.\n     */\n    function prepareNewVault(address _vault) external override onlyGovernance returns (bool) {\n        _prepare(_VAULT_KEY, _vault);\n        return true;\n    }\n\n    /**\n     * @notice Execute Vault update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return Address of new Vault contract.\n     */\n    function executeNewVault() external override returns (address) {\n        IVault vault = getVault();\n        if (address(vault) != address(0)) {\n            vault.withdrawAll();\n        }\n        address newVault = _executeAddress(_VAULT_KEY);\n        addressProvider.updateVault(address(vault), newVault);\n        return newVault;\n    }\n\n    /**\n     * @notice Reset the vault deadline.\n     * @return `true` if success.\n     */\n    function resetNewVault() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_VAULT_KEY);\n    }\n\n    /**\n     * @notice Redeems the underlying asset by burning LP tokens.\n     * @param redeemLpTokens Number of tokens to burn for redeeming the underlying.\n     * @return Actual amount of the underlying redeemed.\n     */\n    function redeem(uint256 redeemLpTokens) external override returns (uint256) {\n        return redeem(redeemLpTokens, 0);\n    }\n\n    /**\n     * @notice Uncap the pool to remove the deposit limit.\n     * @return `true` if success.\n     */\n    function uncap() external override onlyGovernance returns (bool) {\n        require(isCapped(), Error.NOT_CAPPED);\n\n        depositCap = 0;\n        return true;\n    }\n\n    /**\n     * @notice Update the deposit cap value.\n     * @param _depositCap The maximum allowed deposits per address in the pool\n     * @return `true` if success.\n     */\n    function updateDepositCap(uint256 _depositCap) external override onlyGovernance returns (bool) {\n        require(isCapped(), Error.NOT_CAPPED);\n        require(depositCap != _depositCap, Error.SAME_AS_CURRENT);\n        require(_depositCap > 0, Error.INVALID_AMOUNT);\n\n        depositCap = _depositCap;\n        return true;\n    }\n\n    /**\n     * @notice Rebalance vault according to required underlying backing reserves.\n     */\n    function rebalanceVault() external onlyGovernance {\n        _rebalanceVault();\n    }\n\n    /**\n     * @notice Deposit funds for an address into liquidity pool and mint LP tokens in exchange.\n     * @param account Account to deposit for.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @return Actual amount minted.\n     */\n    function depositFor(address account, uint256 depositAmount)\n        external\n        payable\n        override\n        returns (uint256)\n    {\n        return depositFor(account, depositAmount, 0);\n    }\n\n    /**\n     * @notice Redeems the underlying asset by burning LP tokens, unstaking any LP tokens needed.\n     * @param redeemLpTokens Number of tokens to unstake and/or burn for redeeming the underlying.\n     * @param minRedeemAmount Minimum amount of underlying that should be received.\n     * @return Actual amount of the underlying redeemed.\n     */\n    function unstakeAndRedeem(uint256 redeemLpTokens, uint256 minRedeemAmount)\n        external\n        override\n        returns (uint256)\n    {\n        uint256 lpBalance_ = lpToken.balanceOf(msg.sender);\n        require(\n            lpBalance_ + staker.balanceOf(msg.sender) >= redeemLpTokens,\n            Error.INSUFFICIENT_BALANCE\n        );\n        if (lpBalance_ < redeemLpTokens) {\n            staker.unstakeFor(msg.sender, msg.sender, redeemLpTokens - lpBalance_);\n        }\n        return redeem(redeemLpTokens, minRedeemAmount);\n    }\n\n    /**\n     * @notice Returns the address of the LP token of this pool\n     * @return The address of the LP token\n     */\n    function getLpToken() external view override returns (address) {\n        return address(lpToken);\n    }\n\n    /**\n     * @notice Calculates the amount of LP tokens that need to be redeemed to get a certain amount of underlying (includes fees and exchange rate)\n     * @param account Address of the account redeeming.\n     * @param underlyingAmount The amount of underlying desired.\n     * @return Amount of LP tokens that need to be redeemed.\n     */\n    function calcRedeem(address account, uint256 underlyingAmount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(underlyingAmount > 0, Error.INVALID_AMOUNT);\n        ILpToken lpToken_ = lpToken;\n        require(lpToken_.balanceOf(account) > 0, Error.INSUFFICIENT_BALANCE);\n\n        uint256 currentExchangeRate = exchangeRate();\n        uint256 withoutFeesLpAmount = underlyingAmount.scaledDiv(currentExchangeRate);\n        if (withoutFeesLpAmount == lpToken_.totalSupply()) {\n            return withoutFeesLpAmount;\n        }\n\n        WithdrawalFeeMeta memory meta = withdrawalFeeMetas[account];\n\n        uint256 currentFeeRatio = 0;\n        if (!addressProvider.isAction(account)) {\n            currentFeeRatio = getNewCurrentFees(\n                meta.timeToWait,\n                meta.lastActionTimestamp,\n                meta.feeRatio\n            );\n        }\n        uint256 scalingFactor = currentExchangeRate.scaledMul((ScaledMath.ONE - currentFeeRatio));\n        uint256 neededLpTokens = underlyingAmount.scaledDivRoundUp(scalingFactor);\n\n        return neededLpTokens;\n    }\n\n    function getUnderlying() external view virtual override returns (address);\n\n    /**\n     * @notice Deposit funds for an address into liquidity pool and mint LP tokens in exchange.\n     * @param account Account to deposit for.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @param minTokenAmount Minimum amount of LP tokens that should be minted.\n     * @return Actual amount minted.\n     */\n    function depositFor(\n        address account,\n        uint256 depositAmount,\n        uint256 minTokenAmount\n    ) public payable override notPaused returns (uint256) {\n        uint256 rate = exchangeRate();\n\n        if (isCapped()) {\n            uint256 lpBalance = lpToken.balanceOf(account);\n            uint256 stakedAndLockedBalance = staker.stakedAndActionLockedBalanceOf(account);\n            uint256 currentUnderlyingBalance = (lpBalance + stakedAndLockedBalance).scaledMul(rate);\n            require(\n                currentUnderlyingBalance + depositAmount <= depositCap,\n                Error.EXCEEDS_DEPOSIT_CAP\n            );\n        }\n\n        _doTransferIn(msg.sender, depositAmount);\n        uint256 mintedLp = depositAmount.scaledDiv(rate);\n        require(mintedLp >= minTokenAmount, Error.INVALID_AMOUNT);\n\n        lpToken.mint(account, mintedLp);\n        _rebalanceVault();\n\n        if (msg.sender == account || address(this) == account) {\n            emit Deposit(msg.sender, depositAmount, mintedLp);\n        } else {\n            emit DepositFor(msg.sender, account, depositAmount, mintedLp);\n        }\n        return mintedLp;\n    }\n\n    /**\n     * @notice Redeems the underlying asset by burning LP tokens.\n     * @param redeemLpTokens Number of tokens to burn for redeeming the underlying.\n     * @param minRedeemAmount Minimum amount of underlying that should be received.\n     * @return Actual amount of the underlying redeemed.\n     */\n    function redeem(uint256 redeemLpTokens, uint256 minRedeemAmount)\n        public\n        override\n        returns (uint256)\n    {\n        require(redeemLpTokens > 0, Error.INVALID_AMOUNT);\n        ILpToken lpToken_ = lpToken;\n        require(lpToken_.balanceOf(msg.sender) >= redeemLpTokens, Error.INSUFFICIENT_BALANCE);\n\n        uint256 withdrawalFee = addressProvider.isAction(msg.sender)\n            ? 0\n            : getWithdrawalFee(msg.sender, redeemLpTokens);\n        uint256 redeemMinusFees = redeemLpTokens - withdrawalFee;\n        // Pay no fees on the last withdrawal (avoid locking funds in the pool)\n        if (redeemLpTokens == lpToken_.totalSupply()) {\n            redeemMinusFees = redeemLpTokens;\n        }\n        uint256 redeemUnderlying = redeemMinusFees.scaledMul(exchangeRate());\n        require(redeemUnderlying >= minRedeemAmount, Error.NOT_ENOUGH_FUNDS_WITHDRAWN);\n\n        _rebalanceVault(redeemUnderlying);\n\n        lpToken_.burn(msg.sender, redeemLpTokens);\n        _doTransferOut(payable(msg.sender), redeemUnderlying);\n        emit Redeem(msg.sender, redeemUnderlying, redeemLpTokens);\n        return redeemUnderlying;\n    }\n\n    /**\n     * @return the current required reserves ratio\n     */\n    function getRequiredReserveRatio() public view virtual returns (uint256) {\n        return currentUInts256[_REQUIRED_RESERVES_KEY];\n    }\n\n    /**\n     * @return the current maximum reserve deviation ratio\n     */\n    function getMaxReserveDeviationRatio() public view virtual returns (uint256) {\n        return currentUInts256[_RESERVE_DEVIATION_KEY];\n    }\n\n    /**\n     * @notice Returns the current minimum withdrawal fee\n     */\n    function getMinWithdrawalFee() public view returns (uint256) {\n        return currentUInts256[_MIN_WITHDRAWAL_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the current maximum withdrawal fee\n     */\n    function getMaxWithdrawalFee() public view returns (uint256) {\n        return currentUInts256[_MAX_WITHDRAWAL_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the current withdrawal fee decrease period\n     */\n    function getWithdrawalFeeDecreasePeriod() public view returns (uint256) {\n        return currentUInts256[_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY];\n    }\n\n    /**\n     * @return the current vault of the liquidity pool\n     */\n    function getVault() public view virtual override returns (IVault) {\n        return IVault(currentAddresses[_VAULT_KEY]);\n    }\n\n    /**\n     * @notice Compute current exchange rate of LP tokens to underlying scaled to 1e18.\n     * @dev Exchange rate means: underlying = LP token * exchangeRate\n     * @return Current exchange rate.\n     */\n    function exchangeRate() public view override returns (uint256) {\n        uint256 totalUnderlying_ = totalUnderlying();\n        uint256 totalSupply = lpToken.totalSupply();\n        if (totalSupply == 0 || totalUnderlying_ == 0) {\n            return ScaledMath.ONE;\n        }\n\n        return totalUnderlying_.scaledDiv(totalSupply);\n    }\n\n    /**\n     * @notice Compute total amount of underlying tokens for this pool.\n     * @return Total amount of underlying in pool.\n     */\n    function totalUnderlying() public view override returns (uint256) {\n        IVault vault = getVault();\n        uint256 balanceUnderlying = _getBalanceUnderlying();\n        if (address(vault) == address(0)) {\n            return balanceUnderlying;\n        }\n        uint256 investedUnderlying = vault.getTotalUnderlying();\n        return investedUnderlying + balanceUnderlying;\n    }\n\n    /**\n     * @notice Retuns if the pool has an active deposit limit\n     * @return `true` if there is currently a deposit limit\n     */\n    function isCapped() public view override returns (bool) {\n        return depositCap != 0;\n    }\n\n    /**\n     * @notice Returns the withdrawal fee for `account`\n     * @param account Address to get the withdrawal fee for\n     * @param amount Amount to calculate the withdrawal fee for\n     * @return Withdrawal fee in LP tokens\n     */\n    function getWithdrawalFee(address account, uint256 amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        WithdrawalFeeMeta memory meta = withdrawalFeeMetas[account];\n\n        if (lpToken.balanceOf(account) == 0) {\n            return 0;\n        }\n        uint256 currentFee = getNewCurrentFees(\n            meta.timeToWait,\n            meta.lastActionTimestamp,\n            meta.feeRatio\n        );\n        return amount.scaledMul(currentFee);\n    }\n\n    /**\n     * @notice Calculates the withdrawal fee a user would currently need to pay on currentBalance.\n     * @param timeToWait The total time to wait until the withdrawal fee reached the min. fee\n     * @param lastActionTimestamp Timestamp of the last fee update\n     * @param feeRatio Fees that would currently be paid on the user's entire balance\n     * @return Updated fee amount on the currentBalance\n     */\n    function getNewCurrentFees(\n        uint256 timeToWait,\n        uint256 lastActionTimestamp,\n        uint256 feeRatio\n    ) public view returns (uint256) {\n        uint256 timeElapsed = _getTime() - lastActionTimestamp;\n        uint256 minFeePercentage = getMinWithdrawalFee();\n        if (timeElapsed >= timeToWait) {\n            return minFeePercentage;\n        }\n        uint256 elapsedShare = timeElapsed.scaledDiv(timeToWait);\n        return feeRatio - (feeRatio - minFeePercentage).scaledMul(elapsedShare);\n    }\n\n    function _rebalanceVault() internal {\n        _rebalanceVault(0);\n    }\n\n    function _initialize(\n        string memory name_,\n        uint256 depositCap_,\n        address vault_\n    ) internal initializer returns (bool) {\n        name = name_;\n        depositCap = depositCap_;\n\n        _setConfig(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY, _INITIAL_FEE_DECREASE_PERIOD);\n        _setConfig(_MAX_WITHDRAWAL_FEE_KEY, _INITIAL_MAX_WITHDRAWAL_FEE);\n        _setConfig(_REQUIRED_RESERVES_KEY, ScaledMath.ONE);\n        _setConfig(_RESERVE_DEVIATION_KEY, _INITIAL_RESERVE_DEVIATION);\n        _setConfig(_VAULT_KEY, vault_);\n        return true;\n    }\n\n    function _approveStakerVaultSpendingLpTokens() internal {\n        address staker_ = address(staker);\n        address lpToken_ = address(lpToken);\n        if (staker_ == address(0) || lpToken_ == address(0)) return;\n        IERC20(lpToken_).safeApprove(staker_, type(uint256).max);\n    }\n\n    function _doTransferIn(address from, uint256 amount) internal virtual;\n\n    function _doTransferOut(address payable to, uint256 amount) internal virtual;\n\n    /**\n     * @dev Rebalances the pool's allocations to the vault\n     * @param underlyingToWithdraw Amount of underlying to withdraw such that after the withdrawal the pool and vault allocations are correctly balanced.\n     */\n    function _rebalanceVault(uint256 underlyingToWithdraw) internal {\n        IVault vault = getVault();\n\n        if (address(vault) == address(0)) return;\n        uint256 lockedLp = staker.getStakedByActions();\n        uint256 totalUnderlyingStaked = lockedLp.scaledMul(exchangeRate());\n\n        uint256 underlyingBalance = _getBalanceUnderlying(true);\n        uint256 maximumDeviation = totalUnderlyingStaked.scaledMul(getMaxReserveDeviationRatio());\n\n        uint256 nextTargetBalance = totalUnderlyingStaked.scaledMul(getRequiredReserveRatio());\n\n        if (\n            underlyingToWithdraw > underlyingBalance ||\n            (underlyingBalance - underlyingToWithdraw) + maximumDeviation < nextTargetBalance\n        ) {\n            uint256 requiredDeposits = nextTargetBalance + underlyingToWithdraw - underlyingBalance;\n            vault.withdraw(requiredDeposits);\n        } else {\n            uint256 nextBalance = underlyingBalance - underlyingToWithdraw;\n            if (nextBalance > nextTargetBalance + maximumDeviation) {\n                uint256 excessDeposits = nextBalance - nextTargetBalance;\n                _doTransferOut(payable(address(vault)), excessDeposits);\n                vault.deposit();\n            }\n        }\n    }\n\n    function _updateUserFeesOnDeposit(\n        address account,\n        address from,\n        uint256 amountAdded\n    ) internal {\n        WithdrawalFeeMeta storage meta = withdrawalFeeMetas[account];\n        uint256 balance = lpToken.balanceOf(account) +\n            staker.stakedAndActionLockedBalanceOf(account);\n        uint256 newCurrentFeeRatio = getNewCurrentFees(\n            meta.timeToWait,\n            meta.lastActionTimestamp,\n            meta.feeRatio\n        );\n        uint256 shareAdded = amountAdded.scaledDiv(amountAdded + balance);\n        uint256 shareExisting = ScaledMath.ONE - shareAdded;\n        uint256 feeOnDeposit;\n        if (from == address(0)) {\n            feeOnDeposit = getMaxWithdrawalFee();\n        } else {\n            WithdrawalFeeMeta storage fromMeta = withdrawalFeeMetas[from];\n            feeOnDeposit = getNewCurrentFees(\n                fromMeta.timeToWait,\n                fromMeta.lastActionTimestamp,\n                fromMeta.feeRatio\n            );\n        }\n\n        uint256 newFeeRatio = shareExisting.scaledMul(newCurrentFeeRatio) +\n            shareAdded.scaledMul(feeOnDeposit);\n\n        meta.feeRatio = uint64(newFeeRatio);\n        meta.timeToWait = uint64(getWithdrawalFeeDecreasePeriod());\n        meta.lastActionTimestamp = uint64(_getTime());\n    }\n\n    function _getBalanceUnderlying() internal view virtual returns (uint256);\n\n    function _getBalanceUnderlying(bool transferInDone) internal view virtual returns (uint256);\n\n    function _isAuthorizedToPause(address account) internal view override returns (bool) {\n        return _roleManager().hasRole(Roles.GOVERNANCE, account);\n    }\n\n    /**\n     * @dev Overriden for testing\n     */\n    function _getTime() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    function _checkFeeInvariants(uint256 minFee, uint256 maxFee) internal pure {\n        require(maxFee >= minFee, Error.INVALID_AMOUNT);\n        require(maxFee <= _MAX_WITHDRAWAL_FEE, Error.INVALID_AMOUNT);\n    }\n}"
    }
  ]
}