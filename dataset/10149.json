{
  "Title": "[M-02] `.latestRoundData()` does not update the oracle - `ExchangeRate.sol`",
  "Content": "_Submitted by a_delamo, also found by tensors, JMukesh, cmichel and defsec_\n\nThe method `.latestRoundData()` on an oracle returns the latest updated price from the oracle, but this is not the current price of an asset. To get an accurate current price you need to query it by calling the oracle and waiting for a callback to fulfill the request.\n\nInaccurate price data could quickly lead to a large loss of funds. Suppose the price of an asset changes downward 5% but your oracle is not updated. A user could deposit funds (credited with an extra 5% since the oracle isn't updated), wait until `.latestRoundData()` updates (or update it himself) and becomes accurate. He then withdraws to the same asset he put in for an extra 5%. [`ExchangeRate.sol` L84](https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/valuation/ExchangeRate.sol#L84)\n\nRecommend not fetching the latest price (having to call the oracle to update the price instead), and then waiting for the callback.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-08-notional",
  "Code": [
    {
      "filename": "contracts/internal/valuation/ExchangeRate.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../balances/TokenHandler.sol\";\nimport \"../../math/SafeInt256.sol\";\nimport \"interfaces/chainlink/AggregatorV2V3Interface.sol\";\n\nlibrary ExchangeRate {\n    using SafeInt256 for int256;\n\n    uint256 private constant ETH_RATE_STORAGE_SLOT = 1;\n\n    /// @notice Converts a balance to ETH from a base currency. Buffers or haircuts are\n    /// always applied in this method.\n    /// @param er exchange rate object from base to ETH\n    /// @return the converted balance denominated in ETH with Constants.INTERNAL_TOKEN_PRECISION\n    function convertToETH(ETHRate memory er, int256 balance) internal pure returns (int256) {\n        if (balance == 0) return 0;\n        int256 multiplier = balance > 0 ? er.haircut : er.buffer;\n\n        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals\n        // internalDecimals * rateDecimals * multiplier /  (rateDecimals * multiplierDecimals)\n        // Therefore the result is in ethDecimals\n        int256 result =\n            balance.mul(er.rate).mul(multiplier).div(Constants.PERCENTAGE_DECIMALS).div(\n                er.rateDecimals\n            );\n\n        return result;\n    }\n\n    /// @notice Converts the balance denominated in ETH to the equivalent value in a base currency.\n    /// Buffers and haircuts ARE NOT applied in this method.\n    /// @param er exchange rate object from base to ETH\n    /// @param balance amount (denominated in ETH) to convert\n    function convertETHTo(ETHRate memory er, int256 balance) internal pure returns (int256) {\n        if (balance == 0) return 0;\n\n        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals\n        // internalDecimals * rateDecimals / rateDecimals\n        int256 result = balance.mul(er.rateDecimals).div(er.rate);\n\n        return result;\n    }\n\n    /// @notice Calculates the exchange rate between two currencies via ETH. Returns the rate denominated in\n    /// base exchange rate decimals: (baseRateDecimals * quoteRateDecimals) / quoteRateDecimals\n    /// @param baseER base exchange rate struct\n    /// @param quoteER quote exchange rate struct\n    function exchangeRate(ETHRate memory baseER, ETHRate memory quoteER)\n        internal\n        pure\n        returns (int256)\n    {\n        return baseER.rate.mul(quoteER.rateDecimals).div(quoteER.rate);\n    }\n\n    /// @notice Returns an ETHRate object used to calculate free collateral\n    function buildExchangeRate(uint256 currencyId) internal view returns (ETHRate memory) {\n        bytes32 slot = keccak256(abi.encode(currencyId, ETH_RATE_STORAGE_SLOT));\n        bytes32 data;\n\n        assembly {\n            data := sload(slot)\n        }\n\n        int256 rateDecimals;\n        int256 rate;\n        if (currencyId == Constants.ETH_CURRENCY_ID) {\n            // ETH rates will just be 1e18, but will still have buffers, haircuts,\n            // and liquidation discounts\n            rateDecimals = Constants.ETH_DECIMALS;\n            rate = Constants.ETH_DECIMALS;\n        } else {\n            address rateOracle = address(bytes20(data << 96));\n            // prettier-ignore\n            (\n                /* uint80 */,\n                rate,\n                /* uint256 */,\n                /* uint256 */,\n                /* uint80 */\n            ) = AggregatorV2V3Interface(rateOracle).latestRoundData();\n            require(rate > 0, \"ExchangeRate: invalid rate\");\n\n            uint8 rateDecimalPlaces = uint8(bytes1(data << 88));\n            rateDecimals = int256(10**rateDecimalPlaces);\n            if (\n                bytes1(data << 80) != Constants.BOOL_FALSE /* mustInvert */\n            ) {\n                rate = rateDecimals.mul(rateDecimals).div(rate);\n            }\n        }\n\n        int256 buffer = int256(uint8(bytes1(data << 72)));\n        int256 haircut = int256(uint8(bytes1(data << 64)));\n        int256 liquidationDiscount = int256(uint8(bytes1(data << 56)));\n        return\n            ETHRate({\n                rateDecimals: rateDecimals,\n                rate: rate,\n                buffer: buffer,\n                haircut: haircut,\n                liquidationDiscount: liquidationDiscount\n            });\n    }\n}"
    }
  ]
}