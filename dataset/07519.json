{
  "Title": "[M-02] When a smart contract calls `CrossChainRelayerArbitrum.processCalls`, excess submission fees may be lost",
  "Content": "\nWhen the user calls CrossChainRelayerArbitrum.processCalls, ETH is sent as the submission fee.\n\nAccording to the documentation : <https://github.com/OffchainLabs/arbitrum/blob/master/docs/L1_L2_Messages.md#retryable-transaction-lifecycle>\n\n    Credit-Back Address: Address to which all excess gas is credited on L2; i.e., excess ETH for base submission cost (MaxSubmissionCost - ActualSubmissionCostPaid) and excess ETH provided for L2 execution ( (GasPrice x MaxGas) - ActualETHSpentInExecution).\n    ...\n    Submission fee is collected: submission fee is deducted from the senderâ€™s L2 account; MaxSubmissionCost - submission fee is credited to Credit-Back Address.\n\nThe excess submission fee is refunded to the address on L2 of the `excessFeeRefundAddress` provided when calling `createRetryableTicket`.\n\n```solidity\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev all msg.value will deposited to callValueRefundAddress on L2\n     * @param destAddr destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param  maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress maxgas x gasprice - execution cost gets credited here on L2 balance\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param maxGas Max gas deducted from user's L2 balance to cover L2 execution\n     * @param gasPriceBid price bid for L2 execution\n     * @param data ABI encoded data of L2 message\n     * @return unique id for retryable transaction (keccak256(requestID, uint(0) )\n     */\n    function createRetryableTicket(\n        address destAddr,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable virtual override onlyWhitelisted returns (uint256) {\n```\n\nIn `CrossChainRelayerArbitrum.processCalls`, `excessFeeRefundAddress == msg.sender`.\n\n```solidity\n    uint256 _ticketID = inbox.createRetryableTicket{ value: msg.value }(\n      address(executor),\n      0,\n      _maxSubmissionCost,\n      msg.sender,   // @audit : excessFeeRefundAddress\n      msg.sender,  // @audit: callValueRefundAddress\n      _gasLimit,\n      _gasPriceBid,\n      _data\n    );\n```\n\nFor EOA accounts, the excess submission fees are correctly refunded to their address on L2.\nHowever, for smart contracts, since there may not exist a corresponding address on L2, these excess submission fees will be lost.\n\nAlso, since the `callValueRefundAddress` is also `msg.sender`, according to the documentation, if the Retryable Ticket is cancelled or expired, then the smart contract caller may lose all the submission fees\n\n```\nIf the Retryable Ticket is cancelled or expires before it is redeemed, Callvalue is credited to Beneficiary.\n\n```\n\n### Proof of Concept\n\n<https://github.com/pooltogether/ERC5164/blob/5647bd84f2a6d1a37f41394874d567e45a97bf48/src/ethereum-arbitrum/EthereumToArbitrumRelayer.sol#L118-L127>\n\n<https://github.com/OffchainLabs/arbitrum/blob/master/packages/arb-bridge-eth/contracts/bridge/Inbox.sol#L333-L354>\n\n### Recommended Mitigation Steps\n\nConsider allowing the user to specify `excessFeeRefundAddress` and `callValueRefundAddress` when calling `CrossChainRelayerArbitrum.processCalls`.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-pooltogether-findings/issues/63#issuecomment-1345650911):**\n > Making primary for quality of info.\n> \n> Ultimately boils down to the idea that contracts won't get a refund. Will have to think about whether this Med (submitted as such), or Low (self-inflicted).\n\n**[PierrickGT (PoolTogether) confirmed and commented](https://github.com/code-423n4/2022-12-pooltogether-findings/issues/63#issuecomment-1350288109):**\n > Fixed in this PR: https://github.com/code-423n4/2022-12-pooltogether-findings/issues/63\n> \n> The `processCalls` function was intended to be called by an EOA only but it's true that a contract may want to call it while providing the required `_gasLimit`, `_maxSubmissionCost` and `_gasPriceBid` by an EOA.<br>\n> Passing a `refundAddress` variable will allow a contract to refund the EOA that called it.\n> \n> Regarding the severity, I think 2 (Med Risk) is appropriate since the contract would leak value.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-pooltogether-findings/issues/63#issuecomment-1365313747):**\n > Agree with finding, am conflicted on severity:\n> - Low -> User sends more than necessary\n> - Med -> Behaviour, is inconsistent to expected / intended functionality\n> \n> Will think about it further.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-pooltogether-findings/issues/63#issuecomment-1365317980):**\n > More specifically, the fact that the system wants to allow refunds and has a bug that prevents that, which would qualify as Medium. (We care if you send more, we will send it back, but because of bug we cannot)\n> \n> While the pre-condition, in case of a less sophisticated system, would most likely be Low (we don't care if you send more, don't send more)\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-pooltogether-findings/issues/63#issuecomment-1365508732):**\n > The Warden has shown an incorrect implementation, which can cause excess fees to be lost.\n> \n> While the loss of excess fees could be considered Low Severity (self-inflicted), the integration mistake is worth flagging and warrants the increased severity. \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-12-pooltogether",
  "Code": [
    {
      "filename": "src/ethereum-arbitrum/EthereumToArbitrumRelayer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.16;\n\nimport { IInbox } from \"@arbitrum/nitro-contracts/src/bridge/IInbox.sol\";\n\nimport { ICrossChainExecutor } from \"../interfaces/ICrossChainExecutor.sol\";\nimport { ICrossChainRelayer } from \"../interfaces/ICrossChainRelayer.sol\";\nimport \"../libraries/CallLib.sol\";\n\n/**\n * @title CrossChainRelayerArbitrum contract\n * @notice The CrossChainRelayerArbitrum contract allows a user or contract to send messages from Ethereum to Arbitrum.\n *         It lives on the Ethereum chain and communicates with the `CrossChainExecutorArbitrum` contract on the Arbitrum chain.\n */\ncontract CrossChainRelayerArbitrum is ICrossChainRelayer {\n  /* ============ Events ============ */\n\n  /**\n   * @notice Emitted once a message has been processed and put in the Arbitrum inbox.\n   * @dev Using the `ticketId`, this message can be reexecuted for some fixed amount of time if it reverts.\n   * @param nonce Nonce to uniquely idenfity the batch of calls\n   * @param sender Address who processed the calls\n   * @param ticketId Id of the newly created retryable ticket\n   */\n  event ProcessedCalls(uint256 indexed nonce, address indexed sender, uint256 indexed ticketId);\n\n  /* ============ Variables ============ */\n\n  /// @notice Address of the Arbitrum inbox on the Ethereum chain.\n  IInbox public immutable inbox;\n\n  /// @notice Address of the executor contract on the Arbitrum chain.\n  ICrossChainExecutor public executor;\n\n  /// @notice Gas limit provided for free on Arbitrum.\n  uint256 public immutable maxGasLimit;\n\n  /// @notice Nonce to uniquely idenfity each batch of calls.\n  uint256 internal nonce;\n\n  /**\n   * @notice Hash of transactions that were relayed in `relayCalls`.\n   *         txHash => boolean\n   * @dev Ensure that messages passed to `processCalls` have been relayed first.\n   */\n  mapping(bytes32 => bool) public relayed;\n\n  /* ============ Constructor ============ */\n\n  /**\n   * @notice CrossChainRelayer constructor.\n   * @param _inbox Address of the Arbitrum inbox on Ethereum\n   * @param _maxGasLimit Gas limit provided for free on Arbitrum\n   */\n  constructor(IInbox _inbox, uint256 _maxGasLimit) {\n    require(address(_inbox) != address(0), \"Relayer/inbox-not-zero-address\");\n    require(_maxGasLimit > 0, \"Relayer/max-gas-limit-gt-zero\");\n\n    inbox = _inbox;\n    maxGasLimit = _maxGasLimit;\n  }\n\n  /* ============ External Functions ============ */\n\n  /// @inheritdoc ICrossChainRelayer\n  function relayCalls(CallLib.Call[] calldata _calls, uint256 _gasLimit)\n    external\n    payable\n    returns (uint256)\n  {\n    uint256 _maxGasLimit = maxGasLimit;\n\n    if (_gasLimit > _maxGasLimit) {\n      revert GasLimitTooHigh(_gasLimit, _maxGasLimit);\n    }\n\n    nonce++;\n\n    uint256 _nonce = nonce;\n\n    relayed[_getTxHash(_nonce, _calls, msg.sender, _gasLimit)] = true;\n\n    emit RelayedCalls(_nonce, msg.sender, _calls, _gasLimit);\n\n    return _nonce;\n  }\n\n  /**\n   * @notice Process calls that have been relayed.\n   * @dev The transaction hash must match the one stored in the `relayed` mapping.\n   * @dev We store `_data` in memory to avoid a stack too deep error.\n   * @param _nonce Nonce of the batch of calls to process\n   * @param _calls Array of calls being processed\n   * @param _sender Address who relayed the `_calls`\n   * @param _gasLimit Maximum amount of gas required for the `_calls` to be executed\n   * @param _maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n   * @param _gasPriceBid Gas price bid for L2 execution\n   * @return uint256 Id of the retryable ticket that was created\n   */\n  function processCalls(\n    uint256 _nonce,\n    CallLib.Call[] calldata _calls,\n    address _sender,\n    uint256 _gasLimit,\n    uint256 _maxSubmissionCost,\n    uint256 _gasPriceBid\n  ) external payable returns (uint256) {\n    require(relayed[_getTxHash(_nonce, _calls, _sender, _gasLimit)], \"Relayer/calls-not-relayed\");\n\n    bytes memory _data = abi.encodeWithSignature(\n      \"executeCalls(uint256,address,(address,bytes)[])\",\n      _nonce,\n      _sender,\n      _calls\n    );\n\n    uint256 _ticketID = inbox.createRetryableTicket{ value: msg.value }(\n      address(executor),\n      0,\n      _maxSubmissionCost,\n      msg.sender,\n      msg.sender,\n      _gasLimit,\n      _gasPriceBid,\n      _data\n    );\n\n    emit ProcessedCalls(_nonce, msg.sender, _ticketID);\n\n    return _ticketID;\n  }\n\n  /**\n   * @notice Set executor contract address.\n   * @dev Will revert if it has already been set.\n   * @param _executor Address of the executor contract on the Arbitrum chain\n   */\n  function setExecutor(ICrossChainExecutor _executor) external {\n    require(address(executor) == address(0), \"Relayer/executor-already-set\");\n    executor = _executor;\n  }\n\n  /**\n   * @notice Get transaction hash.\n   * @dev The transaction hash is used to ensure that only calls that were relayed are processed.\n   * @param _nonce Nonce uniquely identifying the batch of calls that were relayed\n   * @param _calls Array of calls that were relayed\n   * @param _sender Address who relayed the calls\n   * @param _gasLimit Maximum amount of gas that will be consumed by the calls\n   * @return bytes32 Transaction hash\n   */\n  function getTxHash(\n    uint256 _nonce,\n    CallLib.Call[] calldata _calls,\n    address _sender,\n    uint256 _gasLimit\n  ) external view returns (bytes32) {\n    return _getTxHash(_nonce, _calls, _sender, _gasLimit);\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /**\n   * @notice Get transaction hash.\n   * @dev The transaction hash is used to ensure that only calls that were relayed are processed.\n   * @param _nonce Nonce uniquely identifying the batch of calls that were relayed\n   * @param _calls Array of calls that were relayed\n   * @param _sender Address who relayed the calls\n   * @param _gasLimit Maximum amount of gas that will be consumed by the calls\n   * @return bytes32 Transaction hash\n   */\n  function _getTxHash(\n    uint256 _nonce,\n    CallLib.Call[] calldata _calls,\n    address _sender,\n    uint256 _gasLimit\n  ) internal view returns (bytes32) {\n    return keccak256(abi.encode(address(this), _nonce, _calls, _sender, _gasLimit));\n  }\n}"
    }
  ]
}