{
  "Title": "[M-11] `RiskFund.swapPoolsAsset` does not allow the user to supply deadline, which may cause swap revert",
  "Content": "\nNot allowing users to supply their own deadline could potentially expose them to sandwich attacks.\n\n### Proof of Concept\n\n[RiskFund.sol#L174](https://github.com/code-423n4/2023-05-venus/blob/main/contracts/RiskFund/RiskFund.sol#L174)\n\n```solidity\nfunction swapPoolsAssets(\n    address[] calldata markets,\n    uint256[] calldata amountsOutMin,\n    address[][] calldata paths\n) external override returns (uint256) {\n    _checkAccessAllowed(\"swapPoolsAssets(address[],uint256[],address[][])\");\n    require(poolRegistry != address(0), \"Risk fund: Invalid pool registry.\");\n    require(markets.length == amountsOutMin.length, \"Risk fund: markets and amountsOutMin are unequal lengths\");\n    require(markets.length == paths.length, \"Risk fund: markets and paths are unequal lengths\");\n\n    uint256 totalAmount;\n    uint256 marketsCount = markets.length;\n\n    _ensureMaxLoops(marketsCount);\n\n    for (uint256 i; i < marketsCount; ++i) {\n        VToken vToken = VToken(markets[i]);\n        address comptroller = address(vToken.comptroller());\n\n        PoolRegistry.VenusPool memory pool = PoolRegistry(poolRegistry).getPoolByComptroller(comptroller);\n        require(pool.comptroller == comptroller, \"comptroller doesn't exist pool registry\");\n        require(Comptroller(comptroller).isMarketListed(vToken), \"market is not listed\");\n\n        uint256 swappedTokens = _swapAsset(vToken, comptroller, amountsOutMin[i], paths[i]);\n        poolReserves[comptroller] = poolReserves[comptroller] + swappedTokens;\n        totalAmount = totalAmount + swappedTokens;\n    }\n\n    emit SwappedPoolsAssets(markets, amountsOutMin, totalAmount);\n\n    return totalAmount;\n}\n```\n\nIn `RiskFund.swapPoolsAsset`, there is a parameter to allow users to supply slippage through `amountOutMin`, but does not allow the user to include a deadline check when swapping pool assets into base assets, in the event that pool assets are not equal to `convertibleBaseAsset`.\n\n```solidity\nuint256 swappedTokens = _swapAsset(vToken, comptroller, amountsOutMin[i], paths[i]);\n```\n\nIn `RiskFund._swapAsset`, there is a call to `IPancakeswapV2Router(pancakeSwapRouter).swapExactTokensForTokens()`, but the `deadline` parameter is simply passed in as the current `block.timestamp`, in which the transaction occurs. This effectively means that the transaction has no deadline, which means that swap transactions may be included anytime by validators and remain pending in mempool, potentially exposing users to sandwich attacks by attackers or MEV bots.\n\n[RiskFund.sol#L265](https://github.com/code-423n4/2023-05-venus/blob/main/contracts/RiskFund/RiskFund.sol#L265)\n\n```solidity\nfunction _swapAsset(\n    VToken vToken,\n    address comptroller,\n    uint256 amountOutMin,\n    address[] calldata path\n) internal returns (uint256) \n            ...\n            ...\n            if (underlyingAsset != convertibleBaseAsset) {\n                require(path[0] == underlyingAsset, \"RiskFund: swap path must start with the underlying asset\");\n                require(\n                    path[path.length - 1] == convertibleBaseAsset,\n                    \"RiskFund: finally path must be convertible base asset\"\n                );\n                IERC20Upgradeable(underlyingAsset).safeApprove(pancakeSwapRouter, 0);\n                IERC20Upgradeable(underlyingAsset).safeApprove(pancakeSwapRouter, balanceOfUnderlyingAsset);\n                uint256[] memory amounts = IPancakeswapV2Router(pancakeSwapRouter).swapExactTokensForTokens(\n                    balanceOfUnderlyingAsset,\n                    amountOutMin,\n                    path,\n                    address(this),\n                    /// @audit does not allow deadline to be passed in by user\n                    block.timestamp\n                );\n                ...\n                ...\n```\n\nConsider the following scenario:\n\n1.  Alice wants to swap 30 vBNB tokens for 1 BNB and later sell the 1 BNB for 300 DAI. She signs the transaction calling `RiskFund.swapPoolsAsset()` with inputAmount = 30 vBNB and `amountOutmin` = 0.99 BNB to allow for 1% slippage.\n2. The transaction is submitted to the mempool; however, Alice chose a transaction fee that is too low for validators to be interested in including her transaction in a block. The transaction stays pending in the mempool for extended periods, which could be hours, days, weeks, or even longer.\n3. When the average gas fee dropped far enough for Alice's transaction to become interesting again for miners to include it, her swap will be executed. In the meantime, the price of BNB could have drastically decreased. She will still at least get 0.99 BNB due to `amountOutmin`, but the DAI value of that output might be significantly lower. She has unknowingly performed a bad trade due to the pending transaction she forgot about.\n\nAn even worse way this issue can be maliciously exploited is through MEV:\n\n1.  The swap transaction is still pending in the mempool. Average fees are still too high for validators to be interested in it. The price of BNB has gone up significantly since the transaction was signed, meaning Alice would receive a lot more ETH when the swap is executed. But that also means that her `minOutput` value is outdated and would allow for significant slippage.\n2. A MEV bot detects the pending transaction. Since the outdated `minOut` now allows for high slippage, the bot sandwiches Alice, resulting in significant profit for the bot and significant loss for Alice.\n\n### Tools Used\n\nManual Analysis\n\n### Recommendation\n\nAllow users to supply their own deadline parameter within `RiskFund.swapPoolsAsset`.\n\n**[chechu (Venus) acknowledged](https://github.com/code-423n4/2023-05-venus-findings/issues/167#issuecomment-1560095263)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-venus",
  "Code": [
    {
      "filename": "contracts/RiskFund/RiskFund.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../VToken.sol\";\nimport \"../Pool/PoolRegistry.sol\";\nimport \"../IPancakeswapV2Router.sol\";\nimport \"./ReserveHelpers.sol\";\nimport \"./IRiskFund.sol\";\nimport \"../Shortfall/IShortfall.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport \"../MaxLoopsLimitHelper.sol\";\n\n/**\n * @dev This contract does not support BNB.\n */\ncontract RiskFund is\n    Ownable2StepUpgradeable,\n    AccessControlledV8,\n    ExponentialNoError,\n    ReserveHelpers,\n    MaxLoopsLimitHelper,\n    IRiskFund\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address private pancakeSwapRouter;\n    uint256 private minAmountToConvert;\n    address private convertibleBaseAsset;\n    address private shortfall;\n\n    // Store base asset's reserve for specific pool\n    mapping(address => uint256) public poolReserves;\n\n    /// @notice Emitted when pool registry address is updated\n    event PoolRegistryUpdated(address indexed oldPoolRegistry, address indexed newPoolRegistry);\n\n    /// @notice Emitted when shortfall contract address is updated\n    event ShortfallContractUpdated(address indexed oldShortfallContract, address indexed newShortfallContract);\n\n    /// @notice Emitted when PancakeSwap router contract address is updated\n    event PancakeSwapRouterUpdated(address indexed oldPancakeSwapRouter, address indexed newPancakeSwapRouter);\n\n    /// @notice Emitted when min amount out for PancakeSwap is updated\n    event AmountOutMinUpdated(uint256 oldAmountOutMin, uint256 newAmountOutMin);\n\n    /// @notice Emitted when minimum amount to convert is updated\n    event MinAmountToConvertUpdated(uint256 oldMinAmountToConvert, uint256 newMinAmountToConvert);\n\n    /// @notice Emitted when pools assets are swapped\n    event SwappedPoolsAssets(address[] markets, uint256[] amountsOutMin, uint256 totalAmount);\n\n    /// @notice Emitted when reserves are transferred for auction\n    event TransferredReserveForAuction(address comptroller, uint256 amount);\n\n    /// @dev Note that the contract is upgradeable. Use initialize() or reinitializers\n    ///      to set the state variables.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes the deployer to owner.\n     * @param pancakeSwapRouter_ Address of the PancakeSwap router\n     * @param minAmountToConvert_ Minimum amount assets must be worth to convert into base asset\n     * @param convertibleBaseAsset_ Address of the base asset\n     * @param accessControlManager_ Address of the access control contract\n     * @param loopsLimit_ Limit for the loops in the contract to avoid DOS\n     */\n    function initialize(\n        address pancakeSwapRouter_,\n        uint256 minAmountToConvert_,\n        address convertibleBaseAsset_,\n        address accessControlManager_,\n        uint256 loopsLimit_\n    ) external initializer {\n        require(pancakeSwapRouter_ != address(0), \"Risk Fund: Pancake swap address invalid\");\n        require(convertibleBaseAsset_ != address(0), \"Risk Fund: Base asset address invalid\");\n        require(minAmountToConvert_ > 0, \"Risk Fund: Invalid min amount to convert\");\n        require(loopsLimit_ > 0, \"Risk Fund: Loops limit can not be zero\");\n\n        __Ownable2Step_init();\n        __AccessControlled_init_unchained(accessControlManager_);\n\n        pancakeSwapRouter = pancakeSwapRouter_;\n        minAmountToConvert = minAmountToConvert_;\n        convertibleBaseAsset = convertibleBaseAsset_;\n\n        _setMaxLoopsLimit(loopsLimit_);\n    }\n\n    /**\n     * @dev Pool registry setter\n     * @param _poolRegistry Address of the pool registry.\n     */\n    function setPoolRegistry(address _poolRegistry) external onlyOwner {\n        require(_poolRegistry != address(0), \"Risk Fund: Pool registry address invalid\");\n        address oldPoolRegistry = poolRegistry;\n        poolRegistry = _poolRegistry;\n        emit PoolRegistryUpdated(oldPoolRegistry, _poolRegistry);\n    }\n\n    /**\n     * @dev Shortfall contract address setter\n     * @param shortfallContractAddress_ Address of the auction contract.\n     */\n    function setShortfallContractAddress(address shortfallContractAddress_) external onlyOwner {\n        require(shortfallContractAddress_ != address(0), \"Risk Fund: Shortfall contract address invalid\");\n        require(\n            IShortfall(shortfallContractAddress_).convertibleBaseAsset() == convertibleBaseAsset,\n            \"Risk Fund: Base asset doesn't match\"\n        );\n\n        address oldShortfallContractAddress = shortfall;\n        shortfall = shortfallContractAddress_;\n        emit ShortfallContractUpdated(oldShortfallContractAddress, shortfallContractAddress_);\n    }\n\n    /**\n     * @dev PancakeSwap router address setter\n     * @param pancakeSwapRouter_ Address of the PancakeSwap router.\n     */\n    function setPancakeSwapRouter(address pancakeSwapRouter_) external onlyOwner {\n        require(pancakeSwapRouter_ != address(0), \"Risk Fund: PancakeSwap address invalid\");\n        address oldPancakeSwapRouter = pancakeSwapRouter;\n        pancakeSwapRouter = pancakeSwapRouter_;\n        emit PancakeSwapRouterUpdated(oldPancakeSwapRouter, pancakeSwapRouter_);\n    }\n\n    /**\n     * @dev Min amount to convert setter\n     * @param minAmountToConvert_ Min amount to convert.\n     */\n    function setMinAmountToConvert(uint256 minAmountToConvert_) external {\n        _checkAccessAllowed(\"setMinAmountToConvert(uint256)\");\n        require(minAmountToConvert_ > 0, \"Risk Fund: Invalid min amount to convert\");\n        uint256 oldMinAmountToConvert = minAmountToConvert;\n        minAmountToConvert = minAmountToConvert_;\n        emit MinAmountToConvertUpdated(oldMinAmountToConvert, minAmountToConvert_);\n    }\n\n    /**\n     * @notice Swap array of pool assets into base asset's tokens of at least a mininum amount.\n     * @param markets Array of vTokens whose assets to swap for base asset\n     * @param amountsOutMin Minimum amount to recieve for swap\n     * @return Number of swapped tokens.\n     */\n    function swapPoolsAssets(\n        address[] calldata markets,\n        uint256[] calldata amountsOutMin,\n        address[][] calldata paths\n    ) external override returns (uint256) {\n        _checkAccessAllowed(\"swapPoolsAssets(address[],uint256[],address[][])\");\n        require(poolRegistry != address(0), \"Risk fund: Invalid pool registry.\");\n        require(markets.length == amountsOutMin.length, \"Risk fund: markets and amountsOutMin are unequal lengths\");\n        require(markets.length == paths.length, \"Risk fund: markets and paths are unequal lengths\");\n\n        uint256 totalAmount;\n        uint256 marketsCount = markets.length;\n\n        _ensureMaxLoops(marketsCount);\n\n        for (uint256 i; i < marketsCount; ++i) {\n            VToken vToken = VToken(markets[i]);\n            address comptroller = address(vToken.comptroller());\n\n            PoolRegistry.VenusPool memory pool = PoolRegistry(poolRegistry).getPoolByComptroller(comptroller);\n            require(pool.comptroller == comptroller, \"comptroller doesn't exist pool registry\");\n            require(Comptroller(comptroller).isMarketListed(vToken), \"market is not listed\");\n\n            uint256 swappedTokens = _swapAsset(vToken, comptroller, amountsOutMin[i], paths[i]);\n            poolReserves[comptroller] = poolReserves[comptroller] + swappedTokens;\n            totalAmount = totalAmount + swappedTokens;\n        }\n\n        emit SwappedPoolsAssets(markets, amountsOutMin, totalAmount);\n\n        return totalAmount;\n    }\n\n    /**\n     * @dev Transfer tokens for auction.\n     * @param comptroller Comptroller of the pool.\n     * @param amount Amount to be transferred to auction contract.\n     * @return Number reserved tokens.\n     */\n    function transferReserveForAuction(address comptroller, uint256 amount) external override returns (uint256) {\n        require(msg.sender == shortfall, \"Risk fund: Only callable by Shortfall contract\");\n        require(amount <= poolReserves[comptroller], \"Risk Fund: Insufficient pool reserve.\");\n        poolReserves[comptroller] = poolReserves[comptroller] - amount;\n        IERC20Upgradeable(convertibleBaseAsset).safeTransfer(shortfall, amount);\n\n        emit TransferredReserveForAuction(comptroller, amount);\n\n        return amount;\n    }\n\n    /**\n     * @notice Set the limit for the loops can iterate to avoid the DOS\n     * @param limit Limit for the max loops can execute at a time\n     */\n    function setMaxLoopsLimit(uint256 limit) external onlyOwner {\n        _setMaxLoopsLimit(limit);\n    }\n\n    /**\n     * @dev Update the reserve of the asset for the specific pool after transferring to risk fund.\n     * @param comptroller  Comptroller address(pool).\n     * @param asset Asset address.\n     */\n    function updateAssetsState(address comptroller, address asset) public override(IRiskFund, ReserveHelpers) {\n        super.updateAssetsState(comptroller, asset);\n    }\n\n    /**\n     * @dev Swap single asset to base asset.\n     * @param vToken VToken\n     * @param comptroller Comptroller address\n     * @param amountOutMin Minimum amount to receive for swap\n     * @return Number of swapped tokens.\n     */\n    function _swapAsset(\n        VToken vToken,\n        address comptroller,\n        uint256 amountOutMin,\n        address[] calldata path\n    ) internal returns (uint256) {\n        require(amountOutMin != 0, \"RiskFund: amountOutMin must be greater than 0 to swap vToken\");\n        require(amountOutMin >= minAmountToConvert, \"RiskFund: amountOutMin should be greater than minAmountToConvert\");\n        uint256 totalAmount;\n\n        address underlyingAsset = VTokenInterface(address(vToken)).underlying();\n        uint256 balanceOfUnderlyingAsset = poolsAssetsReserves[comptroller][underlyingAsset];\n\n        ComptrollerViewInterface(comptroller).oracle().updatePrice(address(vToken));\n\n        uint256 underlyingAssetPrice = ComptrollerViewInterface(comptroller).oracle().getUnderlyingPrice(\n            address(vToken)\n        );\n\n        if (balanceOfUnderlyingAsset > 0) {\n            Exp memory oraclePrice = Exp({ mantissa: underlyingAssetPrice });\n            uint256 amountInUsd = mul_ScalarTruncate(oraclePrice, balanceOfUnderlyingAsset);\n\n            if (amountInUsd >= minAmountToConvert) {\n                assetsReserves[underlyingAsset] -= balanceOfUnderlyingAsset;\n                poolsAssetsReserves[comptroller][underlyingAsset] -= balanceOfUnderlyingAsset;\n\n                if (underlyingAsset != convertibleBaseAsset) {\n                    require(path[0] == underlyingAsset, \"RiskFund: swap path must start with the underlying asset\");\n                    require(\n                        path[path.length - 1] == convertibleBaseAsset,\n                        \"RiskFund: finally path must be convertible base asset\"\n                    );\n                    IERC20Upgradeable(underlyingAsset).safeApprove(pancakeSwapRouter, 0);\n                    IERC20Upgradeable(underlyingAsset).safeApprove(pancakeSwapRouter, balanceOfUnderlyingAsset);\n                    uint256[] memory amounts = IPancakeswapV2Router(pancakeSwapRouter).swapExactTokensForTokens(\n                        balanceOfUnderlyingAsset,\n                        amountOutMin,\n                        path,\n                        address(this),\n                        block.timestamp\n                    );\n                    totalAmount = amounts[path.length - 1];\n                } else {\n                    totalAmount = balanceOfUnderlyingAsset;\n                }\n            }\n        }\n\n        return totalAmount;\n    }\n}"
    },
    {
      "filename": "contracts/RiskFund/RiskFund.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../VToken.sol\";\nimport \"../Pool/PoolRegistry.sol\";\nimport \"../IPancakeswapV2Router.sol\";\nimport \"./ReserveHelpers.sol\";\nimport \"./IRiskFund.sol\";\nimport \"../Shortfall/IShortfall.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport \"../MaxLoopsLimitHelper.sol\";\n\n/**\n * @dev This contract does not support BNB.\n */\ncontract RiskFund is\n    Ownable2StepUpgradeable,\n    AccessControlledV8,\n    ExponentialNoError,\n    ReserveHelpers,\n    MaxLoopsLimitHelper,\n    IRiskFund\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address private pancakeSwapRouter;\n    uint256 private minAmountToConvert;\n    address private convertibleBaseAsset;\n    address private shortfall;\n\n    // Store base asset's reserve for specific pool\n    mapping(address => uint256) public poolReserves;\n\n    /// @notice Emitted when pool registry address is updated\n    event PoolRegistryUpdated(address indexed oldPoolRegistry, address indexed newPoolRegistry);\n\n    /// @notice Emitted when shortfall contract address is updated\n    event ShortfallContractUpdated(address indexed oldShortfallContract, address indexed newShortfallContract);\n\n    /// @notice Emitted when PancakeSwap router contract address is updated\n    event PancakeSwapRouterUpdated(address indexed oldPancakeSwapRouter, address indexed newPancakeSwapRouter);\n\n    /// @notice Emitted when min amount out for PancakeSwap is updated\n    event AmountOutMinUpdated(uint256 oldAmountOutMin, uint256 newAmountOutMin);\n\n    /// @notice Emitted when minimum amount to convert is updated\n    event MinAmountToConvertUpdated(uint256 oldMinAmountToConvert, uint256 newMinAmountToConvert);\n\n    /// @notice Emitted when pools assets are swapped\n    event SwappedPoolsAssets(address[] markets, uint256[] amountsOutMin, uint256 totalAmount);\n\n    /// @notice Emitted when reserves are transferred for auction\n    event TransferredReserveForAuction(address comptroller, uint256 amount);\n\n    /// @dev Note that the contract is upgradeable. Use initialize() or reinitializers\n    ///      to set the state variables.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes the deployer to owner.\n     * @param pancakeSwapRouter_ Address of the PancakeSwap router\n     * @param minAmountToConvert_ Minimum amount assets must be worth to convert into base asset\n     * @param convertibleBaseAsset_ Address of the base asset\n     * @param accessControlManager_ Address of the access control contract\n     * @param loopsLimit_ Limit for the loops in the contract to avoid DOS\n     */\n    function initialize(\n        address pancakeSwapRouter_,\n        uint256 minAmountToConvert_,\n        address convertibleBaseAsset_,\n        address accessControlManager_,\n        uint256 loopsLimit_\n    ) external initializer {\n        require(pancakeSwapRouter_ != address(0), \"Risk Fund: Pancake swap address invalid\");\n        require(convertibleBaseAsset_ != address(0), \"Risk Fund: Base asset address invalid\");\n        require(minAmountToConvert_ > 0, \"Risk Fund: Invalid min amount to convert\");\n        require(loopsLimit_ > 0, \"Risk Fund: Loops limit can not be zero\");\n\n        __Ownable2Step_init();\n        __AccessControlled_init_unchained(accessControlManager_);\n\n        pancakeSwapRouter = pancakeSwapRouter_;\n        minAmountToConvert = minAmountToConvert_;\n        convertibleBaseAsset = convertibleBaseAsset_;\n\n        _setMaxLoopsLimit(loopsLimit_);\n    }\n\n    /**\n     * @dev Pool registry setter\n     * @param _poolRegistry Address of the pool registry.\n     */\n    function setPoolRegistry(address _poolRegistry) external onlyOwner {\n        require(_poolRegistry != address(0), \"Risk Fund: Pool registry address invalid\");\n        address oldPoolRegistry = poolRegistry;\n        poolRegistry = _poolRegistry;\n        emit PoolRegistryUpdated(oldPoolRegistry, _poolRegistry);\n    }\n\n    /**\n     * @dev Shortfall contract address setter\n     * @param shortfallContractAddress_ Address of the auction contract.\n     */\n    function setShortfallContractAddress(address shortfallContractAddress_) external onlyOwner {\n        require(shortfallContractAddress_ != address(0), \"Risk Fund: Shortfall contract address invalid\");\n        require(\n            IShortfall(shortfallContractAddress_).convertibleBaseAsset() == convertibleBaseAsset,\n            \"Risk Fund: Base asset doesn't match\"\n        );\n\n        address oldShortfallContractAddress = shortfall;\n        shortfall = shortfallContractAddress_;\n        emit ShortfallContractUpdated(oldShortfallContractAddress, shortfallContractAddress_);\n    }\n\n    /**\n     * @dev PancakeSwap router address setter\n     * @param pancakeSwapRouter_ Address of the PancakeSwap router.\n     */\n    function setPancakeSwapRouter(address pancakeSwapRouter_) external onlyOwner {\n        require(pancakeSwapRouter_ != address(0), \"Risk Fund: PancakeSwap address invalid\");\n        address oldPancakeSwapRouter = pancakeSwapRouter;\n        pancakeSwapRouter = pancakeSwapRouter_;\n        emit PancakeSwapRouterUpdated(oldPancakeSwapRouter, pancakeSwapRouter_);\n    }\n\n    /**\n     * @dev Min amount to convert setter\n     * @param minAmountToConvert_ Min amount to convert.\n     */\n    function setMinAmountToConvert(uint256 minAmountToConvert_) external {\n        _checkAccessAllowed(\"setMinAmountToConvert(uint256)\");\n        require(minAmountToConvert_ > 0, \"Risk Fund: Invalid min amount to convert\");\n        uint256 oldMinAmountToConvert = minAmountToConvert;\n        minAmountToConvert = minAmountToConvert_;\n        emit MinAmountToConvertUpdated(oldMinAmountToConvert, minAmountToConvert_);\n    }\n\n    /**\n     * @notice Swap array of pool assets into base asset's tokens of at least a mininum amount.\n     * @param markets Array of vTokens whose assets to swap for base asset\n     * @param amountsOutMin Minimum amount to recieve for swap\n     * @return Number of swapped tokens.\n     */\n    function swapPoolsAssets(\n        address[] calldata markets,\n        uint256[] calldata amountsOutMin,\n        address[][] calldata paths\n    ) external override returns (uint256) {\n        _checkAccessAllowed(\"swapPoolsAssets(address[],uint256[],address[][])\");\n        require(poolRegistry != address(0), \"Risk fund: Invalid pool registry.\");\n        require(markets.length == amountsOutMin.length, \"Risk fund: markets and amountsOutMin are unequal lengths\");\n        require(markets.length == paths.length, \"Risk fund: markets and paths are unequal lengths\");\n\n        uint256 totalAmount;\n        uint256 marketsCount = markets.length;\n\n        _ensureMaxLoops(marketsCount);\n\n        for (uint256 i; i < marketsCount; ++i) {\n            VToken vToken = VToken(markets[i]);\n            address comptroller = address(vToken.comptroller());\n\n            PoolRegistry.VenusPool memory pool = PoolRegistry(poolRegistry).getPoolByComptroller(comptroller);\n            require(pool.comptroller == comptroller, \"comptroller doesn't exist pool registry\");\n            require(Comptroller(comptroller).isMarketListed(vToken), \"market is not listed\");\n\n            uint256 swappedTokens = _swapAsset(vToken, comptroller, amountsOutMin[i], paths[i]);\n            poolReserves[comptroller] = poolReserves[comptroller] + swappedTokens;\n            totalAmount = totalAmount + swappedTokens;\n        }\n\n        emit SwappedPoolsAssets(markets, amountsOutMin, totalAmount);\n\n        return totalAmount;\n    }\n\n    /**\n     * @dev Transfer tokens for auction.\n     * @param comptroller Comptroller of the pool.\n     * @param amount Amount to be transferred to auction contract.\n     * @return Number reserved tokens.\n     */\n    function transferReserveForAuction(address comptroller, uint256 amount) external override returns (uint256) {\n        require(msg.sender == shortfall, \"Risk fund: Only callable by Shortfall contract\");\n        require(amount <= poolReserves[comptroller], \"Risk Fund: Insufficient pool reserve.\");\n        poolReserves[comptroller] = poolReserves[comptroller] - amount;\n        IERC20Upgradeable(convertibleBaseAsset).safeTransfer(shortfall, amount);\n\n        emit TransferredReserveForAuction(comptroller, amount);\n\n        return amount;\n    }\n\n    /**\n     * @notice Set the limit for the loops can iterate to avoid the DOS\n     * @param limit Limit for the max loops can execute at a time\n     */\n    function setMaxLoopsLimit(uint256 limit) external onlyOwner {\n        _setMaxLoopsLimit(limit);\n    }\n\n    /**\n     * @dev Update the reserve of the asset for the specific pool after transferring to risk fund.\n     * @param comptroller  Comptroller address(pool).\n     * @param asset Asset address.\n     */\n    function updateAssetsState(address comptroller, address asset) public override(IRiskFund, ReserveHelpers) {\n        super.updateAssetsState(comptroller, asset);\n    }\n\n    /**\n     * @dev Swap single asset to base asset.\n     * @param vToken VToken\n     * @param comptroller Comptroller address\n     * @param amountOutMin Minimum amount to receive for swap\n     * @return Number of swapped tokens.\n     */\n    function _swapAsset(\n        VToken vToken,\n        address comptroller,\n        uint256 amountOutMin,\n        address[] calldata path\n    ) internal returns (uint256) {\n        require(amountOutMin != 0, \"RiskFund: amountOutMin must be greater than 0 to swap vToken\");\n        require(amountOutMin >= minAmountToConvert, \"RiskFund: amountOutMin should be greater than minAmountToConvert\");\n        uint256 totalAmount;\n\n        address underlyingAsset = VTokenInterface(address(vToken)).underlying();\n        uint256 balanceOfUnderlyingAsset = poolsAssetsReserves[comptroller][underlyingAsset];\n\n        ComptrollerViewInterface(comptroller).oracle().updatePrice(address(vToken));\n\n        uint256 underlyingAssetPrice = ComptrollerViewInterface(comptroller).oracle().getUnderlyingPrice(\n            address(vToken)\n        );\n\n        if (balanceOfUnderlyingAsset > 0) {\n            Exp memory oraclePrice = Exp({ mantissa: underlyingAssetPrice });\n            uint256 amountInUsd = mul_ScalarTruncate(oraclePrice, balanceOfUnderlyingAsset);\n\n            if (amountInUsd >= minAmountToConvert) {\n                assetsReserves[underlyingAsset] -= balanceOfUnderlyingAsset;\n                poolsAssetsReserves[comptroller][underlyingAsset] -= balanceOfUnderlyingAsset;\n\n                if (underlyingAsset != convertibleBaseAsset) {\n                    require(path[0] == underlyingAsset, \"RiskFund: swap path must start with the underlying asset\");\n                    require(\n                        path[path.length - 1] == convertibleBaseAsset,\n                        \"RiskFund: finally path must be convertible base asset\"\n                    );\n                    IERC20Upgradeable(underlyingAsset).safeApprove(pancakeSwapRouter, 0);\n                    IERC20Upgradeable(underlyingAsset).safeApprove(pancakeSwapRouter, balanceOfUnderlyingAsset);\n                    uint256[] memory amounts = IPancakeswapV2Router(pancakeSwapRouter).swapExactTokensForTokens(\n                        balanceOfUnderlyingAsset,\n                        amountOutMin,\n                        path,\n                        address(this),\n                        block.timestamp\n                    );\n                    totalAmount = amounts[path.length - 1];\n                } else {\n                    totalAmount = balanceOfUnderlyingAsset;\n                }\n            }\n        }\n\n        return totalAmount;\n    }\n}"
    }
  ]
}