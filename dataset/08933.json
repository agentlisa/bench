{
  "Title": "[M-28] ExtraRewardStashV2's stashRewards can become unavailable",
  "Content": "_Submitted by hyh_\n\nThere is no check for the reward token amount to be transferred out in stashRewards(). As reward token list is external (controlled with `IGauge(gauge).reward_tokens`), and an arbitrary token can end up there, in the case when such token doesn't allow for zero amount transfers, the stashRewards() managed extra rewards retrieval can become unavailable.\n\nI.e. stashRewards() can be blocked for even an extended period of time, so all other extra rewards gathering will not be possible. This cannot be controlled by the system as pool reward token list is external.\n\nSetting the severity to medium as reward gathering is a base functionality of the system and its availability is affected.\n\n### Proof of Concept\n\n`stashRewards()` attempts to send the `amount` to rewardArbitrator() without checking:\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV2.sol#L193-L203>\n\n```\n    if (activeCount > 1) {\n        //take difference of before/after(only send new tokens)\n        uint256 amount = IERC20(token).balanceOf(address(this));\n        amount = amount.sub(before);\n\n        //send to arbitrator\n        address arb = IDeposit(operator).rewardArbitrator();\n        if (arb != address(0)) {\n            IERC20(token).safeTransfer(arb, amount);\n        }\n    }\n```\n\nIf `IStaker(staker).withdraw()` produced no new tokens for any reason, the `amount = amount.sub(before)` above can be zero:\n\n<https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV2.sol#L188-L189>\n\n```\n    uint256 before = IERC20(token).balanceOf(address(this));\n    IStaker(staker).withdraw(token);\n```\n\nAs reward `token` can be arbitrary, it can also be reverting on an attempt to transfer zero amounts:\n\n<https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers>\n\nIf this be the case then the whole stashRewards() call will be failing until `IStaker(staker).withdraw()` manage to withdraw some `tokens` or such `token` be removed from gauge's reward token list. Both events arenâ€™t directly controllable by the system.\n\n### Recommended Mitigation Steps\n\nConsider running the transfer only when amount is positive:\n\n```\n-   if (activeCount > 1) {\n+   if (amount > 0 && activeCount > 1) {\n        //take difference of before/after(only send new tokens)\n        uint256 amount = IERC20(token).balanceOf(address(this));\n        amount = amount.sub(before);\n\n        //send to arbitrator\n        address arb = IDeposit(operator).rewardArbitrator();\n        if (arb != address(0)) {\n            IERC20(token).safeTransfer(arb, amount);\n        }\n    }\n```\n\n**[jetbrain10 (veToken Finance) confirmed](https://github.com/code-423n4/2022-05-vetoken-findings/issues/36)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-vetoken-findings/issues/36#issuecomment-1196153811):**\n > The warden has shown how, due to a lack of check for zero-transfer, for specific tokens, the `stashRewads` function can be made to revert, causing it not to process any reward token\n> \n> Because this is contingent on the token having zero-balance and reverting, I think Medium Severity to be appropriate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-vetoken-finance-contest",
  "Code": [
    {
      "filename": "contracts/ExtraRewardStashV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IGauge.sol\";\nimport \"./Interfaces/IRewardFactory.sol\";\nimport \"./Interfaces/IStaker.sol\";\nimport \"./Interfaces/IDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\ncontract ExtraRewardStashV2 {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant maxRewards = 8;\n    uint256 private constant WEEK = 7 * 86400;\n\n    uint256 public immutable pid;\n    address public immutable veAsset;\n    address public immutable operator;\n    address public immutable staker;\n    address public immutable gauge;\n    address public immutable rewardFactory;\n\n    mapping(address => uint256) public historicalRewards;\n\n    struct TokenInfo {\n        address token;\n        address rewardAddress;\n        uint256 lastActiveTime;\n    }\n    uint256 public tokenCount;\n    TokenInfo[maxRewards] public tokenInfo;\n\n    constructor(\n        uint256 _pid,\n        address _veAsset,\n        address _operator,\n        address _staker,\n        address _gauge,\n        address _rFactory\n    ) {\n        pid = _pid;\n        veAsset = _veAsset;\n        operator = _operator;\n        staker = _staker;\n        gauge = _gauge;\n        rewardFactory = _rFactory;\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"ExtraRewardStashV2\";\n    }\n\n    //try claiming if there are reward tokens registered\n    function claimRewards() external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        //this is updateable in v2 gauges now so must check each time.\n        checkForNewRewardTokens();\n\n        uint256 length = tokenCount;\n        if (length > 0) {\n            //get previous balances of all tokens\n            uint256[] memory balances = new uint256[](length);\n            for (uint256 i = 0; i < length; i++) {\n                balances[i] = IERC20(tokenInfo[i].token).balanceOf(staker);\n            }\n            //claim rewards on gauge for staker\n            //booster will call for future proofing (cant assume anyone will always be able to call)\n            IDeposit(operator).claimRewards(pid, gauge);\n\n            for (uint256 i = 0; i < length; i++) {\n                address token = tokenInfo[i].token;\n                uint256 newbalance = IERC20(token).balanceOf(staker);\n                //stash if balance increased\n                if (newbalance > balances[i]) {\n                    IStaker(staker).withdraw(token);\n                    tokenInfo[i].lastActiveTime = block.timestamp;\n\n                    //make sure this pool is in active list,\n                    IRewardFactory(rewardFactory).addActiveReward(token, pid);\n\n                    //check if other stashes are also active, and if so, send to arbitrator\n                    //do this here because processStash will have tokens from the arbitrator\n                    uint256 activeCount = IRewardFactory(rewardFactory).activeRewardCount(token);\n                    if (activeCount > 1) {\n                        //send to arbitrator\n                        address arb = IDeposit(operator).rewardArbitrator();\n                        if (arb != address(0)) {\n                            IERC20(token).safeTransfer(arb, newbalance);\n                        }\n                    }\n                } else {\n                    //check if this reward has been inactive too long\n                    if (block.timestamp > tokenInfo[i].lastActiveTime + WEEK) {\n                        //set as inactive\n                        IRewardFactory(rewardFactory).removeActiveReward(token, pid);\n                    } else {\n                        //edge case around reward ending periods\n                        if (newbalance > 0) {\n                            // - recently active pool\n                            // - rewards claimed to staker contract via a deposit/withdraw(or someone manually calling on the gauge)\n                            // - rewards ended before the deposit, thus deposit took the last available tokens\n                            // - thus claimRewards doesnt see any new rewards, but there are rewards on the staker contract\n                            // - i think its safe to assume claim will be called within the timeframe, or else these rewards\n                            //     will be unretrievable until some pool starts rewards again\n\n                            //claim the tokens\n                            IStaker(staker).withdraw(token);\n\n                            uint256 activeCount = IRewardFactory(rewardFactory).activeRewardCount(\n                                token\n                            );\n                            if (activeCount > 1) {\n                                //send to arbitrator\n                                address arb = IDeposit(operator).rewardArbitrator();\n                                if (arb != address(0)) {\n                                    IERC20(token).safeTransfer(arb, newbalance);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    //check if gauge rewards have changed\n    function checkForNewRewardTokens() internal {\n        for (uint256 i = 0; i < maxRewards; i++) {\n            address token = IGauge(gauge).reward_tokens(i);\n            if (token == address(0)) {\n                for (uint256 x = i; x < tokenCount; x++) {\n                    IRewardFactory(rewardFactory).removeActiveReward(tokenInfo[x].token, pid);\n                }\n                if (i != tokenCount) {\n                    tokenCount = i;\n                }\n                break;\n            }\n            setToken(i, token);\n        }\n    }\n\n    //replace a token on token list\n    function setToken(uint256 _tid, address _token) internal {\n        TokenInfo storage t = tokenInfo[_tid];\n        address currentToken = t.token;\n        if (currentToken != _token) {\n            //set old as inactive\n            IRewardFactory(rewardFactory).removeActiveReward(currentToken, pid);\n\n            //set token address\n            t.token = _token;\n\n            //create new reward contract\n            (, , , address mainRewardContract, , ) = IDeposit(operator).poolInfo(pid);\n            address rewardContract = IRewardFactory(rewardFactory).CreateTokenRewards(\n                _token,\n                mainRewardContract\n            );\n            t.rewardAddress = rewardContract;\n            t.lastActiveTime = 0;\n            //do not set as active yet, wait for first earmark\n        }\n    }\n\n    //pull assigned tokens from staker to stash\n    function stashRewards() external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        //after depositing/withdrawing, extra incentive tokens are transfered to the staking contract\n        //need to pull them off and stash here.\n        for (uint256 i = 0; i < tokenCount; i++) {\n            TokenInfo storage t = tokenInfo[i];\n            address token = t.token;\n            if (token == address(0)) continue;\n\n            //only stash if rewards are active\n            if (block.timestamp <= t.lastActiveTime + WEEK) {\n                uint256 before = IERC20(token).balanceOf(address(this));\n                IStaker(staker).withdraw(token);\n\n                //check for multiple pools claiming same token\n                uint256 activeCount = IRewardFactory(rewardFactory).activeRewardCount(token);\n                if (activeCount > 1) {\n                    //take difference of before/after(only send new tokens)\n                    uint256 amount = IERC20(token).balanceOf(address(this));\n                    amount = amount.sub(before);\n\n                    //send to arbitrator\n                    address arb = IDeposit(operator).rewardArbitrator();\n                    if (arb != address(0)) {\n                        IERC20(token).safeTransfer(arb, amount);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    //send all extra rewards to their reward contracts\n    function processStash() external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        for (uint256 i = 0; i < tokenCount; i++) {\n            TokenInfo storage t = tokenInfo[i];\n            address token = t.token;\n            if (token == address(0)) continue;\n\n            uint256 amount = IERC20(token).balanceOf(address(this));\n            if (amount > 0) {\n                historicalRewards[token] = historicalRewards[token].add(amount);\n                if (token == veAsset) {\n                    //if veAsset, send back to booster to distribute\n                    IERC20(token).safeTransfer(operator, amount);\n                    continue;\n                }\n                //add to reward contract\n                address rewards = t.rewardAddress;\n                if (rewards == address(0)) continue;\n                IERC20(token).safeTransfer(rewards, amount);\n                IRewards(rewards).queueNewRewards(amount);\n            }\n        }\n        return true;\n    }\n}"
    },
    {
      "filename": "contracts/ExtraRewardStashV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Interfaces/IGauge.sol\";\nimport \"./Interfaces/IRewardFactory.sol\";\nimport \"./Interfaces/IStaker.sol\";\nimport \"./Interfaces/IDeposit.sol\";\nimport \"./Interfaces/IRewards.sol\";\n\ncontract ExtraRewardStashV2 {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant maxRewards = 8;\n    uint256 private constant WEEK = 7 * 86400;\n\n    uint256 public immutable pid;\n    address public immutable veAsset;\n    address public immutable operator;\n    address public immutable staker;\n    address public immutable gauge;\n    address public immutable rewardFactory;\n\n    mapping(address => uint256) public historicalRewards;\n\n    struct TokenInfo {\n        address token;\n        address rewardAddress;\n        uint256 lastActiveTime;\n    }\n    uint256 public tokenCount;\n    TokenInfo[maxRewards] public tokenInfo;\n\n    constructor(\n        uint256 _pid,\n        address _veAsset,\n        address _operator,\n        address _staker,\n        address _gauge,\n        address _rFactory\n    ) {\n        pid = _pid;\n        veAsset = _veAsset;\n        operator = _operator;\n        staker = _staker;\n        gauge = _gauge;\n        rewardFactory = _rFactory;\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"ExtraRewardStashV2\";\n    }\n\n    //try claiming if there are reward tokens registered\n    function claimRewards() external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        //this is updateable in v2 gauges now so must check each time.\n        checkForNewRewardTokens();\n\n        uint256 length = tokenCount;\n        if (length > 0) {\n            //get previous balances of all tokens\n            uint256[] memory balances = new uint256[](length);\n            for (uint256 i = 0; i < length; i++) {\n                balances[i] = IERC20(tokenInfo[i].token).balanceOf(staker);\n            }\n            //claim rewards on gauge for staker\n            //booster will call for future proofing (cant assume anyone will always be able to call)\n            IDeposit(operator).claimRewards(pid, gauge);\n\n            for (uint256 i = 0; i < length; i++) {\n                address token = tokenInfo[i].token;\n                uint256 newbalance = IERC20(token).balanceOf(staker);\n                //stash if balance increased\n                if (newbalance > balances[i]) {\n                    IStaker(staker).withdraw(token);\n                    tokenInfo[i].lastActiveTime = block.timestamp;\n\n                    //make sure this pool is in active list,\n                    IRewardFactory(rewardFactory).addActiveReward(token, pid);\n\n                    //check if other stashes are also active, and if so, send to arbitrator\n                    //do this here because processStash will have tokens from the arbitrator\n                    uint256 activeCount = IRewardFactory(rewardFactory).activeRewardCount(token);\n                    if (activeCount > 1) {\n                        //send to arbitrator\n                        address arb = IDeposit(operator).rewardArbitrator();\n                        if (arb != address(0)) {\n                            IERC20(token).safeTransfer(arb, newbalance);\n                        }\n                    }\n                } else {\n                    //check if this reward has been inactive too long\n                    if (block.timestamp > tokenInfo[i].lastActiveTime + WEEK) {\n                        //set as inactive\n                        IRewardFactory(rewardFactory).removeActiveReward(token, pid);\n                    } else {\n                        //edge case around reward ending periods\n                        if (newbalance > 0) {\n                            // - recently active pool\n                            // - rewards claimed to staker contract via a deposit/withdraw(or someone manually calling on the gauge)\n                            // - rewards ended before the deposit, thus deposit took the last available tokens\n                            // - thus claimRewards doesnt see any new rewards, but there are rewards on the staker contract\n                            // - i think its safe to assume claim will be called within the timeframe, or else these rewards\n                            //     will be unretrievable until some pool starts rewards again\n\n                            //claim the tokens\n                            IStaker(staker).withdraw(token);\n\n                            uint256 activeCount = IRewardFactory(rewardFactory).activeRewardCount(\n                                token\n                            );\n                            if (activeCount > 1) {\n                                //send to arbitrator\n                                address arb = IDeposit(operator).rewardArbitrator();\n                                if (arb != address(0)) {\n                                    IERC20(token).safeTransfer(arb, newbalance);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    //check if gauge rewards have changed\n    function checkForNewRewardTokens() internal {\n        for (uint256 i = 0; i < maxRewards; i++) {\n            address token = IGauge(gauge).reward_tokens(i);\n            if (token == address(0)) {\n                for (uint256 x = i; x < tokenCount; x++) {\n                    IRewardFactory(rewardFactory).removeActiveReward(tokenInfo[x].token, pid);\n                }\n                if (i != tokenCount) {\n                    tokenCount = i;\n                }\n                break;\n            }\n            setToken(i, token);\n        }\n    }\n\n    //replace a token on token list\n    function setToken(uint256 _tid, address _token) internal {\n        TokenInfo storage t = tokenInfo[_tid];\n        address currentToken = t.token;\n        if (currentToken != _token) {\n            //set old as inactive\n            IRewardFactory(rewardFactory).removeActiveReward(currentToken, pid);\n\n            //set token address\n            t.token = _token;\n\n            //create new reward contract\n            (, , , address mainRewardContract, , ) = IDeposit(operator).poolInfo(pid);\n            address rewardContract = IRewardFactory(rewardFactory).CreateTokenRewards(\n                _token,\n                mainRewardContract\n            );\n            t.rewardAddress = rewardContract;\n            t.lastActiveTime = 0;\n            //do not set as active yet, wait for first earmark\n        }\n    }\n\n    //pull assigned tokens from staker to stash\n    function stashRewards() external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        //after depositing/withdrawing, extra incentive tokens are transfered to the staking contract\n        //need to pull them off and stash here.\n        for (uint256 i = 0; i < tokenCount; i++) {\n            TokenInfo storage t = tokenInfo[i];\n            address token = t.token;\n            if (token == address(0)) continue;\n\n            //only stash if rewards are active\n            if (block.timestamp <= t.lastActiveTime + WEEK) {\n                uint256 before = IERC20(token).balanceOf(address(this));\n                IStaker(staker).withdraw(token);\n\n                //check for multiple pools claiming same token\n                uint256 activeCount = IRewardFactory(rewardFactory).activeRewardCount(token);\n                if (activeCount > 1) {\n                    //take difference of before/after(only send new tokens)\n                    uint256 amount = IERC20(token).balanceOf(address(this));\n                    amount = amount.sub(before);\n\n                    //send to arbitrator\n                    address arb = IDeposit(operator).rewardArbitrator();\n                    if (arb != address(0)) {\n                        IERC20(token).safeTransfer(arb, amount);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    //send all extra rewards to their reward contracts\n    function processStash() external returns (bool) {\n        require(msg.sender == operator, \"!authorized\");\n\n        for (uint256 i = 0; i < tokenCount; i++) {\n            TokenInfo storage t = tokenInfo[i];\n            address token = t.token;\n            if (token == address(0)) continue;\n\n            uint256 amount = IERC20(token).balanceOf(address(this));\n            if (amount > 0) {\n                historicalRewards[token] = historicalRewards[token].add(amount);\n                if (token == veAsset) {\n                    //if veAsset, send back to booster to distribute\n                    IERC20(token).safeTransfer(operator, amount);\n                    continue;\n                }\n                //add to reward contract\n                address rewards = t.rewardAddress;\n                if (rewards == address(0)) continue;\n                IERC20(token).safeTransfer(rewards, amount);\n                IRewards(rewards).queueNewRewards(amount);\n            }\n        }\n        return true;\n    }\n}"
    }
  ]
}