{
  "Title": "[M-32] Changing matchingEnabled in RubiconMarket breaks protocol",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L685-L691\n\n\n# Vulnerability details\n\n## Impact\n\nIf `matchingEnabled` in `RubiconMarket` is changed from `false` to `true`, all offers created while `matchingEnabled = false` can not be matched or canceled if `matchingEnabled` is toggled to `true` again. Only changing the value `matchingEnabled` back to `false` allows those offers to be used again.\n\n## Proof of Concept\n\nOffers created while `matchingEnabled = false` do not populate `_rank` and `_best`. However, both variables are used in multiple functions `isOfferSorted`, `_unsort`, `_hide` which are used if `matchingEnabled = true`.\n\nFor example, canceling an offer that has been created when `matchingEnabled = false` and enabling matching again, will revert:\n\n[RubiconMarket.sol#L685-L691](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L685-L691)\n\n```solidity\nif (matchingEnabled) {\n    if (isOfferSorted(id)) {\n        require(_unsort(id)); // @audit-info will revert for offers created while `matchingEnabled = false`\n    } else {\n        require(_hide(id)); // @audit-info will revert for offers created while `matchingEnabled = false`\n    }\n}\n```\n\n## Tools Used\n\nManual review\n\n## Recommended mitigation steps\n\nConsider removing the functionality to toggle `matchingEnabled` or only allow changing `matchingEnabled` to `false` without changing the value back to `true`.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-rubicon-contest",
  "Code": [
    {
      "filename": "contracts/RubiconMarket.sol",
      "content": "/// SPDX-License-Identifier: Apache-2.0\n/// This contract is a derivative work of the open-source work of Oasis DEX: https://github.com/OasisDEX/oasis\n\n/// @title RubiconMarket.sol\n/// @notice Please see the repository for this code at https://github.com/RubiconDeFi/rubicon-protocol-v1;\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice DSAuth events for authentication schema\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\n/// @notice DSAuth library for setting owner of the contract\n/// @dev Provides the auth modifier for authenticated function calls\ncontract DSAuth is DSAuthEvents {\n    address public owner;\n\n    function setOwner(address owner_) external auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    modifier auth() {\n        require(isAuthorized(msg.sender), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n/// @notice DSMath library for safe math without integer overflow/underflow\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n}\n\n// /// @notice ERC-20 interface as derived from EIP-20\n// contract ERC20 {\n//     function totalSupply() public view returns (uint256);\n\n//     function balanceOf(address guy) public view returns (uint256);\n\n//     function allowance(address src, address guy) public view returns (uint256);\n\n//     function approve(address guy, uint256 wad) public returns (bool);\n\n//     function transfer(address dst, uint256 wad) public returns (bool);\n\n//     function transferFrom(\n//         address src,\n//         address dst,\n//         uint256 wad\n//     ) public returns (bool);\n// }\n\n/// @notice Events contract for logging trade activity on Rubicon Market\n/// @dev Provides the key event logs that are used in all core functionality of exchanging on the Rubicon Market\ncontract EventfulMarket {\n    event LogItemUpdate(uint256 id);\n    event LogTrade(\n        uint256 pay_amt,\n        address indexed pay_gem,\n        uint256 buy_amt,\n        address indexed buy_gem\n    );\n\n    event LogMake(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogBump(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogTake(\n        bytes32 id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        address indexed taker,\n        uint128 take_amt,\n        uint128 give_amt,\n        uint64 timestamp\n    );\n\n    event LogKill(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogInt(string lol, uint256 input);\n\n    event FeeTake(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        ERC20 asset,\n        address indexed taker,\n        address feeTo,\n        uint256 feeAmt,\n        uint64 timestamp\n    );\n\n    event OfferDeleted(uint256 id);\n}\n\n/// @notice Core trading logic for ERC-20 pairs, an orderbook, and transacting of tokens\n/// @dev This contract holds the core ERC-20 / ERC-20 offer, buy, and cancel logic\ncontract SimpleMarket is EventfulMarket, DSMath {\n    uint256 public last_offer_id;\n\n    /// @dev The mapping that makes up the core orderbook of the exchange\n    mapping(uint256 => OfferInfo) public offers;\n\n    bool locked;\n\n    /// @dev This parameter is in basis points\n    uint256 internal feeBPS;\n\n    /// @dev This parameter provides the address to which fees are sent\n    address internal feeTo;\n\n    struct OfferInfo {\n        uint256 pay_amt;\n        ERC20 pay_gem;\n        uint256 buy_amt;\n        ERC20 buy_gem;\n        address owner;\n        uint64 timestamp;\n    }\n\n    /// @notice Modifier that insures an order exists and is properly in the orderbook\n    modifier can_buy(uint256 id) virtual {\n        require(isActive(id));\n        _;\n    }\n\n    /// @notice Modifier that checks the user to make sure they own the offer and its valid before they attempt to cancel it\n    modifier can_cancel(uint256 id) virtual {\n        require(isActive(id));\n        require(getOwner(id) == msg.sender);\n        _;\n    }\n\n    modifier can_offer() virtual {\n        _;\n    }\n\n    modifier synchronized() {\n        require(!locked);\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function isActive(uint256 id) public view returns (bool active) {\n        return offers[id].timestamp > 0;\n    }\n\n    function getOwner(uint256 id) public view returns (address owner) {\n        return offers[id].owner;\n    }\n\n    function getOffer(uint256 id)\n        public\n        view\n        returns (\n            uint256,\n            ERC20,\n            uint256,\n            ERC20\n        )\n    {\n        OfferInfo memory _offer = offers[id];\n        return (_offer.pay_amt, _offer.pay_gem, _offer.buy_amt, _offer.buy_gem);\n    }\n\n    /// @notice Below are the main public entrypoints\n\n    function bump(bytes32 id_) external can_buy(uint256(id_)) {\n        uint256 id = uint256(id_);\n        emit LogBump(\n            id_,\n            keccak256(abi.encodePacked(offers[id].pay_gem, offers[id].buy_gem)),\n            offers[id].owner,\n            offers[id].pay_gem,\n            offers[id].buy_gem,\n            uint128(offers[id].pay_amt),\n            uint128(offers[id].buy_amt),\n            offers[id].timestamp\n        );\n    }\n\n    /// @notice Accept a given `quantity` of an offer. Transfers funds from caller/taker to offer maker, and from market to caller/taker.\n    /// @notice The fee for taker trades is paid in this function.\n    function buy(uint256 id, uint256 quantity)\n        public\n        virtual\n        can_buy(id)\n        synchronized\n        returns (bool)\n    {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        // Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 10000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, _offer.owner, spend),\n            \"_offer.buy_gem.transferFrom(msg.sender, _offer.owner, spend) failed - check that you can pay the fee\"\n        );\n        require(\n            _offer.pay_gem.transfer(msg.sender, quantity),\n            \"_offer.pay_gem.transfer(msg.sender, quantity) failed\"\n        );\n\n        emit LogItemUpdate(id);\n        emit LogTake(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.owner,\n            _offer.pay_gem,\n            _offer.buy_gem,\n            msg.sender,\n            uint128(quantity),\n            uint128(spend),\n            uint64(block.timestamp)\n        );\n        emit FeeTake(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.buy_gem,\n            msg.sender,\n            feeTo,\n            fee,\n            uint64(block.timestamp)\n        );\n        emit LogTrade(\n            quantity,\n            address(_offer.pay_gem),\n            spend,\n            address(_offer.buy_gem)\n        );\n\n        if (offers[id].pay_amt == 0) {\n            delete offers[id];\n            emit OfferDeleted(id);\n        }\n\n        return true;\n    }\n\n    /// @notice Allows the caller to cancel the offer if it is their own.\n    /// @notice This function refunds the offer to the maker.\n    function cancel(uint256 id)\n        public\n        virtual\n        can_cancel(id)\n        synchronized\n        returns (bool success)\n    {\n        OfferInfo memory _offer = offers[id];\n        delete offers[id];\n\n        require(_offer.pay_gem.transfer(_offer.owner, _offer.pay_amt));\n\n        emit LogItemUpdate(id);\n        emit LogKill(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.owner,\n            _offer.pay_gem,\n            _offer.buy_gem,\n            uint128(_offer.pay_amt),\n            uint128(_offer.buy_amt),\n            uint64(block.timestamp)\n        );\n\n        success = true;\n    }\n\n    function kill(bytes32 id) external virtual {\n        require(cancel(uint256(id)));\n    }\n\n    function make(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt\n    ) external virtual returns (bytes32 id) {\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\n    }\n\n    /// @notice Key function to make a new offer. Takes funds from the caller into market escrow.\n    function offer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) public virtual can_offer synchronized returns (uint256 id) {\n        require(uint128(pay_amt) == pay_amt);\n        require(uint128(buy_amt) == buy_amt);\n        require(pay_amt > 0);\n        require(pay_gem != ERC20(0x0));\n        require(buy_amt > 0);\n        require(buy_gem != ERC20(0x0));\n        require(pay_gem != buy_gem);\n\n        OfferInfo memory info;\n        info.pay_amt = pay_amt;\n        info.pay_gem = pay_gem;\n        info.buy_amt = buy_amt;\n        info.buy_gem = buy_gem;\n        info.owner = msg.sender;\n        info.timestamp = uint64(block.timestamp);\n        id = _next_id();\n        offers[id] = info;\n\n        require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n\n        emit LogItemUpdate(id);\n        emit LogMake(\n            bytes32(id),\n            keccak256(abi.encodePacked(pay_gem, buy_gem)),\n            msg.sender,\n            pay_gem,\n            buy_gem,\n            uint128(pay_amt),\n            uint128(buy_amt),\n            uint64(block.timestamp)\n        );\n    }\n\n    function take(bytes32 id, uint128 maxTakeAmount) external virtual {\n        require(buy(uint256(id), maxTakeAmount));\n    }\n\n    function _next_id() internal returns (uint256) {\n        last_offer_id++;\n        return last_offer_id;\n    }\n\n    // Fee logic\n    function getFeeBPS() internal view returns (uint256) {\n        return feeBPS;\n    }\n}\n\n/// @notice Expiring market is a Simple Market with a market lifetime.\n/// @dev When the close_time has been reached, offers can only be cancelled (offer and buy will throw).\ncontract ExpiringMarket is DSAuth, SimpleMarket {\n    bool public stopped;\n\n    /// @dev After close_time has been reached, no new offers are allowed.\n    modifier can_offer() override {\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, no new buys are allowed.\n    modifier can_buy(uint256 id) override {\n        require(isActive(id));\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, anyone can cancel an offer.\n    modifier can_cancel(uint256 id) virtual override {\n        require(isActive(id));\n        require((msg.sender == getOwner(id)) || isClosed());\n        _;\n    }\n\n    function isClosed() public pure returns (bool closed) {\n        return false;\n    }\n\n    function getTime() public view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    function stop() external auth {\n        stopped = true;\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 indexed bar,\n        uint256 wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note() {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue()\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n\n        _;\n    }\n}\n\ncontract MatchingEvents {\n    event LogBuyEnabled(bool isEnabled);\n    event LogMinSell(address pay_gem, uint256 min_amount);\n    event LogMatchingEnabled(bool isEnabled);\n    event LogUnsortedOffer(uint256 id);\n    event LogSortedOffer(uint256 id);\n    event LogInsert(address keeper, uint256 id);\n    event LogDelete(address keeper, uint256 id);\n    event LogMatch(uint256 id, uint256 amount);\n}\n\n/// @notice The core Rubicon Market smart contract\n/// @notice This contract is based on the original open-source work done by OasisDEX under the Apache License 2.0\n/// @dev This contract inherits the key trading functionality from SimpleMarket\ncontract RubiconMarket is MatchingEvents, ExpiringMarket, DSNote {\n    bool public buyEnabled = true; //buy enabled\n    bool public matchingEnabled = true; //true: enable matching,\n    //false: revert to expiring market\n    /// @dev Below is variable to allow for a proxy-friendly constructor\n    bool public initialized;\n\n    /// @dev unused deprecated variable for applying a token distribution on top of a trade\n    bool public AqueductDistributionLive;\n    /// @dev unused deprecated variable for applying a token distribution of this token on top of a trade\n    address public AqueductAddress;\n\n    struct sortInfo {\n        uint256 next; //points to id of next higher offer\n        uint256 prev; //points to id of previous lower offer\n        uint256 delb; //the blocknumber where this entry was marked for delete\n    }\n    mapping(uint256 => sortInfo) public _rank; //doubly linked lists of sorted offer ids\n    mapping(address => mapping(address => uint256)) public _best; //id of the highest offer for a token pair\n    mapping(address => mapping(address => uint256)) public _span; //number of offers stored for token pair in sorted orderbook\n    mapping(address => uint256) public _dust; //minimum sell amount for a token to avoid dust offers\n    mapping(uint256 => uint256) public _near; //next unsorted offer id\n    uint256 public _head; //first unsorted offer id\n    uint256 public dustId; // id of the latest offer marked as dust\n\n    /// @dev Proxy-safe initialization of storage\n    function initialize(bool _live, address _feeTo) public {\n        require(!initialized, \"contract is already initialized\");\n        AqueductDistributionLive = _live;\n\n        /// @notice The market fee recipient\n        feeTo = _feeTo;\n\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n\n        /// @notice The starting fee on taker trades in basis points\n        feeBPS = 20;\n\n        initialized = true;\n        matchingEnabled = true;\n        buyEnabled = true;\n    }\n\n    // After close, anyone can cancel an offer\n    modifier can_cancel(uint256 id) override {\n        require(isActive(id), \"Offer was deleted or taken, or never existed.\");\n        require(\n            isClosed() || msg.sender == getOwner(id) || id == dustId,\n            \"Offer can not be cancelled because user is not owner, and market is open, and offer sells required amount of tokens.\"\n        );\n        _;\n    }\n\n    // ---- Public entrypoints ---- //\n\n    function make(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt\n    ) public override returns (bytes32) {\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\n    }\n\n    function take(bytes32 id, uint128 maxTakeAmount) public override {\n        require(buy(uint256(id), maxTakeAmount));\n    }\n\n    function kill(bytes32 id) external override {\n        require(cancel(uint256(id)));\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    //\n    // If matching is enabled:\n    //     * creates new offer without putting it in\n    //       the sorted list.\n    //     * available to authorized contracts only!\n    //     * keepers should call insert(id,pos)\n    //       to put offer in the sorted list.\n    //\n    // If matching is disabled:\n    //     * calls expiring market's offer().\n    //     * available to everyone without authorization.\n    //     * no sorting is done.\n    //\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //taker (ask) buy how much\n        ERC20 buy_gem //taker (ask) buy which token\n    ) public override returns (uint256) {\n        require(!locked, \"Reentrancy attempt\");\n\n\n            function(uint256, ERC20, uint256, ERC20) returns (uint256) fn\n         = matchingEnabled ? _offeru : super.offer;\n        return fn(pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external can_offer returns (uint256) {\n        return offer(pay_amt, pay_gem, buy_amt, buy_gem, pos, true);\n    }\n\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos, //position to insert offer, 0 should be used if unknown\n        bool matching //match \"close enough\" orders?\n    ) public can_offer returns (uint256) {\n        require(!locked, \"Reentrancy attempt\");\n        require(_dust[address(pay_gem)] <= pay_amt);\n\n        if (matchingEnabled) {\n            return _matcho(pay_amt, pay_gem, buy_amt, buy_gem, pos, matching);\n        }\n        return super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    //Transfers funds from caller to offer maker, and from market to caller.\n    function buy(uint256 id, uint256 amount)\n        public\n        override\n        can_buy(id)\n        returns (bool)\n    {\n        require(!locked, \"Reentrancy attempt\");\n\n        //Optional distribution on trade\n        if (AqueductDistributionLive) {\n            IAqueduct(AqueductAddress).distributeToMakerAndTaker(\n                getOwner(id),\n                msg.sender\n            );\n        }\n        function(uint256, uint256) returns (bool) fn = matchingEnabled\n            ? _buys\n            : super.buy;\n\n        return fn(id, amount);\n    }\n\n    // Cancel an offer. Refunds offer maker.\n    function cancel(uint256 id)\n        public\n        override\n        can_cancel(id)\n        returns (bool success)\n    {\n        require(!locked, \"Reentrancy attempt\");\n        if (matchingEnabled) {\n            if (isOfferSorted(id)) {\n                require(_unsort(id));\n            } else {\n                require(_hide(id));\n            }\n        }\n        return super.cancel(id); //delete the offer.\n    }\n\n    //insert offer into the sorted list\n    //keepers need to use this function\n    function insert(\n        uint256 id, //maker (ask) id\n        uint256 pos //position to insert into\n    ) public returns (bool) {\n        require(!locked, \"Reentrancy attempt\");\n        require(!isOfferSorted(id)); //make sure offers[id] is not yet sorted\n        require(isActive(id)); //make sure offers[id] is active\n\n        _hide(id); //remove offer from unsorted offers list\n        _sort(id, pos); //put offer into the sorted offers list\n        emit LogInsert(msg.sender, id);\n        return true;\n    }\n\n    //deletes _rank [id]\n    //  Function should be called by keepers.\n    function del_rank(uint256 id) external returns (bool) {\n        require(!locked, \"Reentrancy attempt\");\n        require(\n            !isActive(id) &&\n                _rank[id].delb != 0 &&\n                _rank[id].delb < block.number - 10\n        );\n        delete _rank[id];\n        emit LogDelete(msg.sender, id);\n        return true;\n    }\n\n    //set the minimum sell amount for a token\n    //    Function is used to avoid \"dust offers\" that have\n    //    very small amount of tokens to sell, and it would\n    //    cost more gas to accept the offer, than the value\n    //    of tokens received.\n    function setMinSell(\n        ERC20 pay_gem, //token to assign minimum sell amount to\n        uint256 dust //maker (ask) minimum sell amount\n    ) external auth note returns (bool) {\n        _dust[address(pay_gem)] = dust;\n        emit LogMinSell(address(pay_gem), dust);\n        return true;\n    }\n\n    //returns the minimum sell amount for an offer\n    function getMinSell(\n        ERC20 pay_gem //token for which minimum sell amount is queried\n    ) external view returns (uint256) {\n        return _dust[address(pay_gem)];\n    }\n\n    //set buy functionality enabled/disabled\n    function setBuyEnabled(bool buyEnabled_) external auth returns (bool) {\n        buyEnabled = buyEnabled_;\n        emit LogBuyEnabled(buyEnabled);\n        return true;\n    }\n\n    //set matching enabled/disabled\n    //    If matchingEnabled true(default), then inserted offers are matched.\n    //    Except the ones inserted by contracts, because those end up\n    //    in the unsorted list of offers, that must be later sorted by\n    //    keepers using insert().\n    //    If matchingEnabled is false then RubiconMarket is reverted to ExpiringMarket,\n    //    and matching is not done, and sorted lists are disabled.\n    function setMatchingEnabled(bool matchingEnabled_)\n        external\n        auth\n        returns (bool)\n    {\n        matchingEnabled = matchingEnabled_;\n        emit LogMatchingEnabled(matchingEnabled);\n        return true;\n    }\n\n    //return the best offer for a token pair\n    //      the best offer is the lowest one if it's an ask,\n    //      and highest one if it's a bid offer\n    function getBestOffer(ERC20 sell_gem, ERC20 buy_gem)\n        public\n        view\n        returns (uint256)\n    {\n        return _best[address(sell_gem)][address(buy_gem)];\n    }\n\n    //return the next worse offer in the sorted list\n    //      the worse offer is the higher one if its an ask,\n    //      a lower one if its a bid offer,\n    //      and in both cases the newer one if they're equal.\n    function getWorseOffer(uint256 id) public view returns (uint256) {\n        return _rank[id].prev;\n    }\n\n    //return the next better offer in the sorted list\n    //      the better offer is in the lower priced one if its an ask,\n    //      the next higher priced one if its a bid offer\n    //      and in both cases the older one if they're equal.\n    function getBetterOffer(uint256 id) external view returns (uint256) {\n        return _rank[id].next;\n    }\n\n    //return the amount of better offers for a token pair\n    function getOfferCount(ERC20 sell_gem, ERC20 buy_gem)\n        public\n        view\n        returns (uint256)\n    {\n        return _span[address(sell_gem)][address(buy_gem)];\n    }\n\n    //get the first unsorted offer that was inserted by a contract\n    //      Contracts can't calculate the insertion position of their offer because it is not an O(1) operation.\n    //      Their offers get put in the unsorted list of offers.\n    //      Keepers can calculate the insertion position offchain and pass it to the insert() function to insert\n    //      the unsorted offer into the sorted list. Unsorted offers will not be matched, but can be bought with buy().\n    function getFirstUnsortedOffer() public view returns (uint256) {\n        return _head;\n    }\n\n    //get the next unsorted offer\n    //      Can be used to cycle through all the unsorted offers.\n    function getNextUnsortedOffer(uint256 id) public view returns (uint256) {\n        return _near[id];\n    }\n\n    function isOfferSorted(uint256 id) public view returns (bool) {\n        return\n            _rank[id].next != 0 ||\n            _rank[id].prev != 0 ||\n            _best[address(offers[id].pay_gem)][address(offers[id].buy_gem)] ==\n            id;\n    }\n\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked, \"Reentrancy attempt\");\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                pay_amt * 1 ether <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    pay_amt * 10**9,\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10**9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount);\n    }\n\n    function buyAllAmount(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked, \"Reentrancy attempt\");\n        uint256 offerId;\n        while (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0);\n\n            // There is a chance that buy_amt is smaller than 1 wei of the other token\n            if (\n                buy_amt * 1 ether <\n                wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (buy_amt >= offers[offerId].pay_amt) {\n                //If amount to buy is higher or equal than current offer amount to sell\n                fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount sold to acumulator\n                buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                //if lower\n                fill_amt = add(\n                    fill_amt,\n                    rmul(\n                        buy_amt * 10**9,\n                        rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n                    ) / 10**9\n                ); //Add amount sold to acumulator\n                take(bytes32(offerId), uint128(buy_amt)); //We take the portion of the offer that we need\n                buy_amt = 0; //All amount is bought\n            }\n        }\n        require(fill_amt <= max_fill_amount);\n    }\n\n    function getBuyAmount(\n        ERC20 buy_gem,\n        ERC20 pay_gem,\n        uint256 pay_amt\n    ) external view returns (uint256 fill_amt) {\n        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair\n        while (pay_amt > offers[offerId].buy_amt) {\n            fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount to buy accumulator\n            pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to pay\n            if (pay_amt > 0) {\n                //If we still need more offers\n                offerId = getWorseOffer(offerId); //We look for the next best offer\n                require(offerId != 0); //Fails if there are not enough offers to complete\n            }\n        }\n        fill_amt = add(\n            fill_amt,\n            rmul(\n                pay_amt * 10**9,\n                rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) / 10**9\n        ); //Add proportional amount of last offer to buy accumulator\n    }\n\n    function getPayAmount(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint256 buy_amt\n    ) external view returns (uint256 fill_amt) {\n        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair\n        while (buy_amt > offers[offerId].pay_amt) {\n            fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount to pay accumulator\n            buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n            if (buy_amt > 0) {\n                //If we still need more offers\n                offerId = getWorseOffer(offerId); //We look for the next best offer\n                require(offerId != 0); //Fails if there are not enough offers to complete\n            }\n        }\n        fill_amt = add(\n            fill_amt,\n            rmul(\n                buy_amt * 10**9,\n                rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) / 10**9\n        ); //Add proportional amount of last offer to pay accumulator\n    }\n\n    // ---- Internal Functions ---- //\n\n    function _buys(uint256 id, uint256 amount) internal returns (bool) {\n        require(buyEnabled);\n        if (amount == offers[id].pay_amt) {\n            if (isOfferSorted(id)) {\n                //offers[id] must be removed from sorted list because all of it is bought\n                _unsort(id);\n            } else {\n                _hide(id);\n            }\n        }\n\n        require(super.buy(id, amount));\n\n        // If offer has become dust during buy, we cancel it\n        if (\n            isActive(id) &&\n            offers[id].pay_amt < _dust[address(offers[id].pay_gem)]\n        ) {\n            dustId = id; //enable current msg.sender to call cancel(id)\n            cancel(id);\n        }\n        return true;\n    }\n\n    //find the id of the next higher offer after offers[id]\n    function _find(uint256 id) internal view returns (uint256) {\n        require(id > 0);\n\n        address buy_gem = address(offers[id].buy_gem);\n        address pay_gem = address(offers[id].pay_gem);\n        uint256 top ="
    }
  ]
}