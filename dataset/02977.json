{
  "Title": "M-6: Internal `OptionMath._getPositivePlaceValues()` function do not handle values below `185`",
  "Content": "# Issue M-6: Internal `OptionMath._getPositivePlaceValues()` function do not handle values below `185` \n\nSource: https://github.com/sherlock-audit/2022-09-knox-judging/issues/43 \n\n## Found by \nshung, ArbitraryExecution\n\n## Summary\n\nInternal `OptionMath._getPositivePlaceValues()` function do not handle values below `185`.\n\n## Vulnerability Detail\n\n`OptionMath._getPositivePlaceValues()` is a library function used by special floor and ceiling functions which are in turn used in the calculation of the strike price. However, `_getPositivePlaceValues()` function incorrectly reverts when the provided value is below `185`. This happens because a 64x64 `185` equals to a wad value with one digit, which is represented internally with one extra decimal. Since the division by 100 will return zero for a number with less than three digits, the division in the following line reverts due to division by zero.\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/libraries/OptionMath.sol#L101-L103\n\n## Impact\n\nThis might prevent auctions from starting due to the following execution flow `VaultAdmin.initializeAuction() -> VaultInternal._setOptionParameters() -> Pricer.snapToGrid64x64() -> OptionMath.ceil64x64() -> OptionMath._getPositivePlaceValues()`.\n\nThere can also be more serious issues if this library is reused in other places.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-knox/blob/main/knox-contracts/contracts/libraries/OptionMath.sol#L93-L103\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nApplying the following diff will properly handle division by zero, such that values below `185` can still be rounded up or down.\n\n```diff\ndiff --git a/knox-contracts/contracts/libraries/OptionMath.sol b/knox-contracts/contracts/libraries/OptionMath.sol\nindex 746dd78..8ed2bbc 100644\n--- a/knox-contracts/contracts/libraries/OptionMath.sol\n+++ b/knox-contracts/contracts/libraries/OptionMath.sol\n@@ -92,15 +92,21 @@ library OptionMath {\n \n         // setup the first place value\n         values[0].ruler = ruler;\n-        values[0].value = (integer / values[0].ruler) % 10;\n-\n-        // setup the second place value\n-        values[1].ruler = ruler / 10;\n-        values[1].value = (integer / values[1].ruler) % 10;\n-\n-        // setup the third place value\n-        values[2].ruler = ruler / 100;\n-        values[2].value = (integer / values[2].ruler) % 10;\n+        if (values[0].ruler != 0) {\n+            values[0].value = (integer / values[0].ruler) % 10;\n+\n+            // setup the second place value\n+            values[1].ruler = ruler / 10;\n+            if (values[1].ruler != 0) {\n+                values[1].value = (integer / values[1].ruler) % 10;\n+\n+                // setup the third place value\n+                values[2].ruler = ruler / 100;\n+                if (values[2].ruler != 0) {\n+                    values[2].value = (integer / values[2].ruler) % 10;\n+                }\n+            }\n+        }\n \n         return (integer, values);\n     }\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/4",
  "Code": [
    {
      "filename": "knox-contracts/contracts/libraries/OptionMath.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"abdk-libraries-solidity/ABDKMath64x64.sol\";\nimport \"@solidstate/abdk-math-extensions/contracts/ABDKMath64x64Token.sol\";\n\n/**\n * @title Option Math Helper Library\n */\n\nlibrary OptionMath {\n    using ABDKMath64x64 for int128;\n    using ABDKMath64x64 for uint256;\n    using ABDKMath64x64Token for int128;\n    using ABDKMath64x64Token for uint256;\n\n    int256 private constant ONE = 10000000000000000000;\n\n    struct Value {\n        int256 value;\n        int256 ruler;\n    }\n\n    /**\n     * @custom:author Yaojin Sun\n     * @notice applies ceiling to the second highest place value of a positive 64x64 fixed point number\n     * @param x 64x64 fixed point number\n     * @return rounded 64x64 fixed point number\n     */\n    function ceil64x64(int128 x) internal pure returns (int128) {\n        require(x > 0);\n\n        (int256 integer, Value[3] memory values) = _getPositivePlaceValues(x);\n\n        // if the summation of first and second values is equal to integer, the integer has already been rounded\n        if (\n            values[0].ruler *\n                values[0].value +\n                values[1].ruler *\n                values[1].value ==\n            integer\n        ) {\n            return int128((integer << 64) / ONE);\n        }\n\n        return\n            int128(\n                (((values[0].ruler * values[0].value) +\n                    (values[1].ruler * (values[1].value + 1))) << 64) / ONE\n            );\n    }\n\n    /**\n     * @custom:author Yaojin Sun\n     * @notice applies floor to the second highest place value of a positive 64x64 fixed point number\n     * @param x 64x64 fixed point number\n     * @return rounded 64x64 fixed point number\n     */\n    function floor64x64(int128 x) internal pure returns (int128) {\n        require(x > 0);\n\n        (, Value[3] memory values) = _getPositivePlaceValues(x);\n\n        // No matter whether third value is non-zero or not, we ONLY need to keep the first and second places.\n        int256 res =\n            (values[0].ruler * values[0].value) +\n                (values[1].ruler * values[1].value);\n        return int128((res << 64) / ONE);\n    }\n\n    function _getPositivePlaceValues(int128 x)\n        private\n        pure\n        returns (int256, Value[3] memory)\n    {\n        // move the decimal part to integer by multiplying 10...0\n        int256 integer = (int256(x) * ONE) >> 64;\n\n        // scan and identify the highest position\n        int256 ruler = 100000000000000000000000000000000000000; // 10^38\n        while (integer < ruler) {\n            ruler = ruler / 10;\n        }\n\n        Value[3] memory values;\n\n        // find the first/second/third largest places and there value\n        values[0] = Value(0, 0);\n        values[1] = Value(0, 0);\n        values[2] = Value(0, 0);\n\n        // setup the first place value\n        values[0].ruler = ruler;\n        values[0].value = (integer / values[0].ruler) % 10;\n\n        // setup the second place value\n        values[1].ruler = ruler / 10;\n        values[1].value = (integer / values[1].ruler) % 10;\n\n        // setup the third place value\n        values[2].ruler = ruler / 100;\n        values[2].value = (integer / values[2].ruler) % 10;\n\n        return (integer, values);\n    }\n\n    /**\n     * @notice converts the value to the base token amount\n     * @param underlyingDecimals decimal precision of the underlying asset\n     * @param baseDecimals decimal precision of the base asset\n     * @param value amount to convert\n     * @return decimal representation of base token amount\n     */\n    function toBaseTokenAmount(\n        uint8 underlyingDecimals,\n        uint8 baseDecimals,\n        uint256 value\n    ) internal pure returns (uint256) {\n        int128 value64x64 = value.fromDecimals(underlyingDecimals);\n        return value64x64.toDecimals(baseDecimals);\n    }\n\n    /**\n     * @notice calculates the collateral asset amount from the number of contracts\n     * @param isCall option type, true if call option\n     * @param underlyingDecimals decimal precision of the underlying asset\n     * @param baseDecimals decimal precision of the base asset\n     * @param strike64x64 strike price of the option as 64x64 fixed point number\n     * @return collateral asset amount\n     */\n    function fromContractsToCollateral(\n        uint256 contracts,\n        bool isCall,\n        uint8 underlyingDecimals,\n        uint8 baseDecimals,\n        int128 strike64x64\n    ) internal pure returns (uint256) {\n        if (isCall) {\n            return contracts;\n        }\n\n        return\n            toBaseTokenAmount(\n                underlyingDecimals,\n                baseDecimals,\n                strike64x64.mulu(contracts)\n            );\n    }\n\n    /**\n     * @notice calculates number of contracts from the collateral asset amount\n     * @param isCall option type, true if call option\n     * @param baseDecimals decimal precision of the base asset\n     * @param strike64x64 strike price of the option as 64x64 fixed point number\n     * @return number of contracts\n     */\n    function fromContractsToCollateral(\n        uint256 collateral,\n        bool isCall,\n        uint8 baseDecimals,\n        int128 strike64x64\n    ) internal pure returns (uint256) {\n        if (isCall) {\n            return collateral;\n        }\n\n        int128 collateral64x64 = collateral.fromDecimals(baseDecimals);\n        return collateral64x64.div(strike64x64).toDecimals(baseDecimals);\n    }\n}"
    },
    {
      "filename": "knox-contracts/contracts/libraries/OptionMath.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"abdk-libraries-solidity/ABDKMath64x64.sol\";\nimport \"@solidstate/abdk-math-extensions/contracts/ABDKMath64x64Token.sol\";\n\n/**\n * @title Option Math Helper Library\n */\n\nlibrary OptionMath {\n    using ABDKMath64x64 for int128;\n    using ABDKMath64x64 for uint256;\n    using ABDKMath64x64Token for int128;\n    using ABDKMath64x64Token for uint256;\n\n    int256 private constant ONE = 10000000000000000000;\n\n    struct Value {\n        int256 value;\n        int256 ruler;\n    }\n\n    /**\n     * @custom:author Yaojin Sun\n     * @notice applies ceiling to the second highest place value of a positive 64x64 fixed point number\n     * @param x 64x64 fixed point number\n     * @return rounded 64x64 fixed point number\n     */\n    function ceil64x64(int128 x) internal pure returns (int128) {\n        require(x > 0);\n\n        (int256 integer, Value[3] memory values) = _getPositivePlaceValues(x);\n\n        // if the summation of first and second values is equal to integer, the integer has already been rounded\n        if (\n            values[0].ruler *\n                values[0].value +\n                values[1].ruler *\n                values[1].value ==\n            integer\n        ) {\n            return int128((integer << 64) / ONE);\n        }\n\n        return\n            int128(\n                (((values[0].ruler * values[0].value) +\n                    (values[1].ruler * (values[1].value + 1))) << 64) / ONE\n            );\n    }\n\n    /**\n     * @custom:author Yaojin Sun\n     * @notice applies floor to the second highest place value of a positive 64x64 fixed point number\n     * @param x 64x64 fixed point number\n     * @return rounded 64x64 fixed point number\n     */\n    function floor64x64(int128 x) internal pure returns (int128) {\n        require(x > 0);\n\n        (, Value[3] memory values) = _getPositivePlaceValues(x);\n\n        // No matter whether third value is non-zero or not, we ONLY need to keep the first and second places.\n        int256 res =\n            (values[0].ruler * values[0].value) +\n                (values[1].ruler * values[1].value);\n        return int128((res << 64) / ONE);\n    }\n\n    function _getPositivePlaceValues(int128 x)\n        private\n        pure\n        returns (int256, Value[3] memory)\n    {\n        // move the decimal part to integer by multiplying 10...0\n        int256 integer = (int256(x) * ONE) >> 64;\n\n        // scan and identify the highest position\n        int256 ruler = 100000000000000000000000000000000000000; // 10^38\n        while (integer < ruler) {\n            ruler = ruler / 10;\n        }\n\n        Value[3] memory values;\n\n        // find the first/second/third largest places and there value\n        values[0] = Value(0, 0);\n        values[1] = Value(0, 0);\n        values[2] = Value(0, 0);\n\n        // setup the first place value\n        values[0].ruler = ruler;\n        values[0].value = (integer / values[0].ruler) % 10;\n\n        // setup the second place value\n        values[1].ruler = ruler / 10;\n        values[1].value = (integer / values[1].ruler) % 10;\n\n        // setup the third place value\n        values[2].ruler = ruler / 100;\n        values[2].value = (integer / values[2].ruler) % 10;\n\n        return (integer, values);\n    }\n\n    /**\n     * @notice converts the value to the base token amount\n     * @param underlyingDecimals decimal precision of the underlying asset\n     * @param baseDecimals decimal precision of the base asset\n     * @param value amount to convert\n     * @return decimal representation of base token amount\n     */\n    function toBaseTokenAmount(\n        uint8 underlyingDecimals,\n        uint8 baseDecimals,\n        uint256 value\n    ) internal pure returns (uint256) {\n        int128 value64x64 = value.fromDecimals(underlyingDecimals);\n        return value64x64.toDecimals(baseDecimals);\n    }\n\n    /**\n     * @notice calculates the collateral asset amount from the number of contracts\n     * @param isCall option type, true if call option\n     * @param underlyingDecimals decimal precision of the underlying asset\n     * @param baseDecimals decimal precision of the base asset\n     * @param strike64x64 strike price of the option as 64x64 fixed point number\n     * @return collateral asset amount\n     */\n    function fromContractsToCollateral(\n        uint256 contracts,\n        bool isCall,\n        uint8 underlyingDecimals,\n        uint8 baseDecimals,\n        int128 strike64x64\n    ) internal pure returns (uint256) {\n        if (isCall) {\n            return contracts;\n        }\n\n        return\n            toBaseTokenAmount(\n                underlyingDecimals,\n                baseDecimals,\n                strike64x64.mulu(contracts)\n            );\n    }\n\n    /**\n     * @notice calculates number of contracts from the collateral asset amount\n     * @param isCall option type, true if call option\n     * @param baseDecimals decimal precision of the base asset\n     * @param strike64x64 strike price of the option as 64x64 fixed point number\n     * @return number of contracts\n     */\n    function fromContractsToCollateral(\n        uint256 collateral,\n        bool isCall,\n        uint8 baseDecimals,\n        int128 strike64x64\n    ) internal pure returns (uint256) {\n        if (isCall) {\n            return collateral;\n        }\n\n        int128 collateral64x64 = collateral.fromDecimals(baseDecimals);\n        return collateral64x64.div(strike64x64).toDecimals(baseDecimals);\n    }\n}"
    }
  ]
}