{
  "Title": "[M-11] updateStrategyAllocBPS() can cause loss of ActivePoolâ€™s collateral during an emergency exit",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/ReaperVaultV2.sol#L191-L199\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/abstract/ReaperBaseStrategyv4.sol#L123\n\n\n# Vulnerability details\n\n\n\n The function `updateStrategyAllocBPS()` can cause ActivePool to record an incorrect profit after `setEmergencyExit()` is triggered. \n\n## Impact\nThe incorrect profit will cause a large portion of the ActivePool's collateral to be distributed to Treasury, Staking Pool and Stability Pool. Depositors and Stakers can then withdraw the profits, leading to loss of ActivePool's collateral.\n\n\n### Background\nIn Ethos Reserve, the Vault rehypothecates the collateral from ActivePool using one or more Strategy, which will deposit the funds in other protocols (e.g. lending pool) to farm for yields. \n\nOnly Guardian and above roles are able to trigger `setEmergencyExit()` on a specific Strategy to force it to exit all its position upon the next harvest, depositing all funds from lending pool into the Vault. How it works, is that `setEmergencyExit()` will trigger Vault to `revokeStrategy()`, setting the strategy's `allocBPS` to `0`. This sets Strategy allocation to `0` and increases Strategy's debt, so that it will repay Vault all the funds.\n(see https://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/abstract/ReaperBaseStrategyv4.sol#L156-L160)\n\nNote that `setEmergencyExit()` is not reversible. I believe this is to protects funds from being re-deployed into the lending pool during an emergency situation (e.g. lending pool hacked or market crash). And it is different from Vault's EmergencyShutdown, which is effected on all Strategies and is reversible.\n\n### Detailed Explanation\nThe issue is that, Strategist (a lower privilege role than Guardian) is able to reverse `revokeStrategy()` by calling `updateStrategyAllocBPS()` with a non-zero value to increase the strategy allocation. This will lead to a reduction of the strategy's debt and cause an incorrect profit to be recorded when it liquidate its positions in the next harvest. Due to the incorrect profit, a fee will be charged on it and transferred to Treasury, leaving less funds for the Vault. \n\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/ReaperVaultV2.sol#L191-L199 \n\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/abstract/ReaperBaseStrategyv4.sol#L123\n\nEven worse, `updateStrategyAllocBPS()` will cause an increase to vault's totalAllocated value during `harvest()`, while the incorrect profit is transferred to the Vault during harvest. Both of these changes will lead to a discrepancy in the vault's `totalAllocated` and its token balance, causing the vault's total balance to be incorrect and higher than actual. This leads to a higher share price. \n\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/ReaperVaultV2.sol#L521\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Vault/contracts/ReaperVaultV2.sol#L528\n\nWith a higher share price, ActivePool's owned asset value in the Vault will be inflated. This will cause ActivePool to record an incorrect profit in the next  `_rebalance()`,  and distrbute them to Treasury, Staking Pool and Stability Pool. \n\nhttps://github.com/code-423n4/2023-02-ethos/blob/main/Ethos-Core/contracts/ActivePool.sol#L239-L309\n\nDepositors and Stakers can then withdraw the profits, leading to loss of ActivePool's collateral.\n\n\n## Proof of Concept\n\nAdd the following test case to `Ethos-Vault/test/start-test.js`. This shows that ActivePool's asset value will be inflated due to the issue. The next test case will show that inflated asset value will cause ActivePool's `_rebalance()` to record a profit and distribute them to the respective pools, that can be withdrawn.\n\n    it.only('updateStrategyAllocBPS can cause loss of ActivePool collateral during emergency exit', async function () {\n      const {vault, strategy, want, wantHolder, strategyAddress, strategist, guardian} = \n        await loadFixture(deployVaultAndStrategyAndGetSigners);\n      // intialize guardian account with ETH for gas\n      const tx = await strategist.sendTransaction({\n        to: guardianAddress,\n        value: ethers.utils.parseEther('0.1'),\n      });\n      await tx.wait();\n\n      // Treasury owned asset value starts with zero\n      const treasurySharesBefore = await vault.balanceOf(treasuryAddr);\n      const treasuryAssetsBefore = await vault.convertToAssets(treasurySharesBefore);\n      expect(treasuryAssetsBefore).to.equal(0);\n\n      // ActivePool deposits 10 WBTC \n      await vault.connect(wantHolder)['deposit(uint256)'](toWantUnit('10'));\n      await strategy.harvest();\n     \n      // Expect ActivePool's owned share and asset to be equal to 10 WBTC as deposited\n      const activePoolSharesBefore = await vault.balanceOf(wantHolder.address);\n      const activePoolAssetsBefore = await vault.convertToAssets(activePoolSharesBefore);\n      expect(activePoolSharesBefore).to.equal(toWantUnit('10'));\n      expect(activePoolAssetsBefore).to.equal(toWantUnit('10'));\n\n      /* Guardian calls setEmergencyExit().\n      *  This triggers Vault to revokeStrategy() and set strategy's allocBPS to 0.\n      *  By design, this will force strategy to exit all its position and \n      *  return funds to vault in the next harvest().\n      */\n      await strategy.connect(guardian).setEmergencyExit();\n\n      /* Strategist set AllocBPS back to 10000 (100%). \n      *  This will reverse the revokeStrategy() and cause strategy's debt value \n      *  to be reduced in next harvest()\n      */\n      await vault.connect(strategist).updateStrategyAllocBPS(strategy.address, 10000);\n\n      /* Strategy will liquidate all its position due to emergency exit state.\n      * However, it will also record an incorrect profit due to reduced debt value.\n      */\n      await strategy.harvest();\n\n      // Jump ahead for incorrect profit to unlock\n      await moveTimeForward(3600*7);\n\n      // Treasury will gain fees of 1.56 WBTC on the incorrect profit value\n      const treasurySharesAfter = await vault.balanceOf(treasuryAddr);\n      const treasuryAssetsAfter = await vault.convertToAssets(treasurySharesAfter);\n      expect(treasuryAssetsAfter).to.not.equal(treasuryAssetsBefore);\n      expect(treasuryAssetsAfter).to.equal(156880733);\n\n      // ActivePool's owned asset value is incorrectly inflated \n      // This is due to increased share price from the incorrect profit and wrong accounting from allocBPS\n      const activePoolSharesAfter = await vault.balanceOf(wantHolder.address);\n      const activePoolAssetsAfter = await vault.convertToAssets(activePoolSharesAfter);\n      expect(activePoolAssetsAfter).to.equal(\"1743119266\");\n      expect(activePoolAssetsAfter).to.not.equal(activePoolAssetsBefore);\n\n      /* ActivePool will record a profit of 7.43 WBTC (74% of initial deposit) due to the inflated asset value\n      *  In the next ActivePool's _rebalance(), the  incorrect profit will be distributed to Treasury, \n      *  Staking Pool and StabilityPool. \n      *  Depositors and Stakers will be able to withdraw the profits, leading to loss of borrowers's collateral.\n      */\n      const estimatedActivePoolProfit = activePoolAssetsAfter - activePoolAssetsBefore;\n      expect(estimatedActivePoolProfit).to.be.equal(743119266);\n\n    });\n\n\nAdd the following test case to `Ethos-Core/test/PoolsTest.js`. Note that this is an  test independent from the preivous test case just to show that ActivePool will record a profit when the share asset value increases, and the profit will be distributed to the respective pools.\n\n\tit.only('simulate incorrect profit to show that _rebalance() called by sendCollateral() will distributes profit', async () => {\n\t\tawait setReasonableDefaultStateForYielding();\n\n\t\t// Simulate incorrect profit: mint 1 ether to vault.  \n\t\t// This will increase the vault share price and inflate the ActivePool's owned asset value.\n\t\tawait collaterals[0].mint(vaults[0].address, dec(1, 'ether'))\n\n\t\t// Trigger ActivePool's _rebalance() via sendCollateral(). \n\t\t// ActivePool will record a profit due to the inflated owned asset value.\n\t\tconst sendCollData = th.getTransactionData('sendCollateral(address,address,uint256)', \n\t\t  [collaterals[0].address, alice, web3.utils.toHex(dec(1, 'ether'))])\n\t\tawait mockBorrowerOperations.forward(activePool.address, sendCollData, { from: owner })\n\n\t\t// The incorrect profit will be distributed to Treasury, StabilityPool and Staking Pool\n\t\tassert.equal((await collaterals[0].balanceOf(treasury.address)).toString(), '200000000000000000') // 0.2 ether\n\t\tassert.equal((await collaterals[0].balanceOf(stabilityPool.address)).toString(), '300000000000000000') // 0.3 ether\n\t\tassert.equal((await collaterals[0].balanceOf(lqtyStaking.address)).toString(), '500000000000000000') // 0.5 ether\n\t})\n\n## Recommended Mitigation Steps\nThe fix is to block all changes to strategy's `allocBPS` after `setEmergencyExit()`. \n\nSince `allocBPS` is already tracked within `ReaperVaultV2.sol`, it is better to refactor and shift `emergencyExit` from `ReaperBaseStrategyv4.sol` to `ReaperVaultV2.StrategyParams`. With that, the fix can simply just to add a check for emergency exit within `updateStrategyAllocBPS()`.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-02-ethos-reserve-contest",
  "Code": [
    {
      "filename": "Ethos-Vault/contracts/ReaperVaultV2.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IERC4626Events.sol\";\nimport \"./interfaces/IStrategy.sol\";\nimport \"./libraries/ReaperMathUtils.sol\";\nimport \"./mixins/ReaperAccessControl.sol\";\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @notice Implementation of a vault to deposit funds for yield optimizing.\n * This is the contract that receives funds and that users interface with.\n * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.\n */\ncontract ReaperVaultV2 is ReaperAccessControl, ERC20, IERC4626Events, AccessControlEnumerable, ReentrancyGuard {\n    using ReaperMathUtils for uint256;\n    using SafeERC20 for IERC20Metadata;\n\n    struct StrategyParams {\n        uint256 activation; // Activation block.timestamp\n        uint256 feeBPS; // Performance fee taken from profit, in BPS\n        uint256 allocBPS; // Allocation in BPS of vault's total assets\n        uint256 allocated; // Amount of capital allocated to this strategy\n        uint256 gains; // Total returns that Strategy has realized for Vault\n        uint256 losses; // Total losses that Strategy has realized for Vault\n        uint256 lastReport; // block.timestamp of the last time a report occured\n    }\n\n    mapping(address => StrategyParams) public strategies;\n\n    // Ordering that `withdraw` uses to determine which strategies to pull funds from\n    address[] public withdrawalQueue;\n\n    uint256 public constant DEGRADATION_COEFFICIENT = 10**18; // The unit for calculating profit degradation.\n    uint256 public constant PERCENT_DIVISOR = 10000;\n    uint256 public tvlCap;\n\n    uint256 public totalAllocBPS; // Sum of allocBPS across all strategies (in BPS, <= 10k)\n    uint256 public totalAllocated; // Amount of tokens that have been allocated to all strategies\n    uint256 public lastReport; // block.timestamp of last report from any strategy\n\n    uint256 public immutable constructionTime;\n    bool public emergencyShutdown;\n\n    // The token the vault accepts and looks to maximize.\n    IERC20Metadata public immutable token;\n\n    // Max slippage(loss) allowed when withdrawing, in BPS (0.01%)\n    uint256 public withdrawMaxLoss = 1;\n    uint256 public lockedProfitDegradation; // rate per block of degradation. DEGRADATION_COEFFICIENT is 100% per block\n    uint256 public lockedProfit; // how much profit is locked and cant be withdrawn\n\n    /**\n     * Reaper Roles in increasing order of privilege.\n     * {DEPOSITOR} - Role conferred to EOAs/contracts that are allowed to deposit in the vault.\n     * {STRATEGIST} - Role conferred to authors of the strategy, allows for tweaking non-critical params.\n     * {GUARDIAN} - Multisig requiring 2 signatures for invoking emergency measures.\n     * {ADMIN}- Multisig requiring 3 signatures for deactivating emergency measures and changing TVL cap.\n     *\n     * The DEFAULT_ADMIN_ROLE (in-built access control role) will be granted to a multisig requiring 4\n     * signatures. This role would have the ability to add strategies, as well as the ability to grant any other\n     * roles.\n     *\n     * Also note that roles are cascading. So any higher privileged role should be able to perform all the functions\n     * of any lower privileged role.\n     */\n    bytes32 public constant DEPOSITOR = keccak256(\"DEPOSITOR\");\n    bytes32 public constant STRATEGIST = keccak256(\"STRATEGIST\");\n    bytes32 public constant GUARDIAN = keccak256(\"GUARDIAN\");\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    address public treasury; // address to whom performance fee is remitted in the form of vault shares\n\n    event StrategyAdded(address indexed strategy, uint256 feeBPS, uint256 allocBPS);\n    event StrategyFeeBPSUpdated(address indexed strategy, uint256 feeBPS);\n    event StrategyAllocBPSUpdated(address indexed strategy, uint256 allocBPS);\n    event StrategyRevoked(address indexed strategy);\n    event UpdateWithdrawalQueue(address[] withdrawalQueue);\n    event WithdrawMaxLossUpdated(uint256 withdrawMaxLoss);\n    event EmergencyShutdown(bool active);\n    event InCaseTokensGetStuckCalled(address token, uint256 amount);\n    event TvlCapUpdated(uint256 newTvlCap);\n    event LockedProfitDegradationUpdated(uint256 degradation);\n    event StrategyReported(\n        address indexed strategy,\n        uint256 gain,\n        uint256 loss,\n        uint256 debtPaid,\n        uint256 gains,\n        uint256 losses,\n        uint256 allocated,\n        uint256 allocationAdded,\n        uint256 allocBPS\n    );\n\n    /**\n     * @notice Initializes the vault's own 'RF' token.\n     * This token is minted when someone does a deposit. It is burned in order\n     * to withdraw the corresponding portion of the underlying assets.\n     * @param _token the token to maximize.\n     * @param _name the name of the vault token.\n     * @param _symbol the symbol of the vault token.\n     * @param _tvlCap initial deposit cap for scaling TVL safely\n     */\n    constructor(\n        address _token,\n        string memory _name,\n        string memory _symbol,\n        uint256 _tvlCap,\n        address _treasury,\n        address[] memory _strategists,\n        address[] memory _multisigRoles\n    ) ERC20(string(_name), string(_symbol)) {\n        token = IERC20Metadata(_token);\n        constructionTime = block.timestamp;\n        lastReport = block.timestamp;\n        tvlCap = _tvlCap;\n        treasury = _treasury;\n        lockedProfitDegradation = (DEGRADATION_COEFFICIENT * 46) / 10**6; // 6 hours in blocks\n\n        uint256 numStrategists = _strategists.length;\n        for (uint256 i = 0; i < numStrategists; i = i.uncheckedInc()) {\n            _grantRole(STRATEGIST, _strategists[i]);\n        }\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(DEFAULT_ADMIN_ROLE, _multisigRoles[0]);\n        _grantRole(ADMIN, _multisigRoles[1]);\n        _grantRole(GUARDIAN, _multisigRoles[2]);\n    }\n\n    /**\n     * @notice Adds a new strategy to the vault with a given allocation amount in basis points.\n     * @param _strategy The strategy to add.\n     * @param _feeBPS The performance fee (taken from profit) in basis points\n     * @param _allocBPS The strategy allocation in basis points\n     */\n    function addStrategy(\n        address _strategy,\n        uint256 _feeBPS,\n        uint256 _allocBPS\n    ) external {\n        _atLeastRole(DEFAULT_ADMIN_ROLE);\n        require(!emergencyShutdown, \"Cannot add strategy during emergency shutdown\");\n        require(_strategy != address(0), \"Invalid strategy address\");\n        require(strategies[_strategy].activation == 0, \"Strategy already added\");\n        require(address(this) == IStrategy(_strategy).vault(), \"Strategy's vault does not match\");\n        require(address(token) == IStrategy(_strategy).want(), \"Strategy's want does not match\");\n        require(_feeBPS <= PERCENT_DIVISOR / 5, \"Fee cannot be higher than 20 BPS\");\n        require(_allocBPS + totalAllocBPS <= PERCENT_DIVISOR, \"Invalid allocBPS value\");\n\n        strategies[_strategy] = StrategyParams({\n            activation: block.timestamp,\n            feeBPS: _feeBPS,\n            allocBPS: _allocBPS,\n            allocated: 0,\n            gains: 0,\n            losses: 0,\n            lastReport: block.timestamp\n        });\n\n        totalAllocBPS += _allocBPS;\n        withdrawalQueue.push(_strategy);\n        emit StrategyAdded(_strategy, _feeBPS, _allocBPS);\n    }\n\n    /**\n     * @notice Updates the strategy's performance fee.\n     * @param _strategy The strategy to update.\n     * @param _feeBPS The new performance fee in basis points.\n     */\n    function updateStrategyFeeBPS(address _strategy, uint256 _feeBPS) external {\n        _atLeastRole(ADMIN);\n        require(strategies[_strategy].activation != 0, \"Invalid strategy address\");\n        require(_feeBPS <= PERCENT_DIVISOR / 5, \"Fee cannot be higher than 20 BPS\");\n        strategies[_strategy].feeBPS = _feeBPS;\n        emit StrategyFeeBPSUpdated(_strategy, _feeBPS);\n    }\n\n    /**\n     * @notice Updates the allocation points for a given strategy.\n     * @param _strategy The strategy to update.\n     * @param _allocBPS The strategy allocation in basis points\n     */\n    function updateStrategyAllocBPS(address _strategy, uint256 _allocBPS) external {\n        _atLeastRole(STRATEGIST);\n        require(strategies[_strategy].activation != 0, \"Invalid strategy address\");\n        totalAllocBPS -= strategies[_strategy].allocBPS;\n        strategies[_strategy].allocBPS = _allocBPS;\n        totalAllocBPS += _allocBPS;\n        require(totalAllocBPS <= PERCENT_DIVISOR, \"Invalid BPS value\");\n        emit StrategyAllocBPSUpdated(_strategy, _allocBPS);\n    }\n\n    /**\n     * @notice Removes any allocation to a given strategy.\n     * @param _strategy The strategy to revoke.\n     */\n    function revokeStrategy(address _strategy) external {\n        if (msg.sender != _strategy) {\n            _atLeastRole(GUARDIAN);\n        }\n\n        if (strategies[_strategy].allocBPS == 0) {\n            return;\n        }\n\n        totalAllocBPS -= strategies[_strategy].allocBPS;\n        strategies[_strategy].allocBPS = 0;\n        emit StrategyRevoked(_strategy);\n    }\n\n    /**\n     * @notice Called by a strategy to determine the amount of capital that the vault is\n     * able to provide it. A positive amount means that vault has excess capital to provide\n     * the strategy, while a negative amount means that the strategy has a balance owing to\n     * the vault.\n     */\n    function availableCapital() public view returns (int256) {\n        address stratAddr = msg.sender;\n        if (totalAllocBPS == 0 || emergencyShutdown) {\n            return -int256(strategies[stratAddr].allocated);\n        }\n\n        uint256 stratMaxAllocation = (strategies[stratAddr].allocBPS * balance()) / PERCENT_DIVISOR;\n        uint256 stratCurrentAllocation = strategies[stratAddr].allocated;\n\n        if (stratCurrentAllocation > stratMaxAllocation) {\n            return -int256(stratCurrentAllocation - stratMaxAllocation);\n        } else if (stratCurrentAllocation < stratMaxAllocation) {\n            uint256 vaultMaxAllocation = (totalAllocBPS * balance()) / PERCENT_DIVISOR;\n            uint256 vaultCurrentAllocation = totalAllocated;\n\n            if (vaultCurrentAllocation >= vaultMaxAllocation) {\n                return 0;\n            }\n\n            uint256 available = stratMaxAllocation - stratCurrentAllocation;\n            available = Math.min(available, vaultMaxAllocation - vaultCurrentAllocation);\n            available = Math.min(available, token.balanceOf(address(this)));\n\n            return int256(available);\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Updates the withdrawalQueue to match the addresses and order specified.\n     * @param _withdrawalQueue The new withdrawalQueue to update to.\n     */\n    function setWithdrawalQueue(address[] calldata _withdrawalQueue) external {\n        _atLeastRole(ADMIN);\n        uint256 queueLength = _withdrawalQueue.length;\n        require(queueLength != 0, \"Queue must not be empty\");\n\n        delete withdrawalQueue;\n        for (uint256 i = 0; i < queueLength; i = i.uncheckedInc()) {\n            address strategy = _withdrawalQueue[i];\n            StrategyParams storage params = strategies[strategy];\n            require(params.activation != 0, \"Invalid strategy address\");\n            withdrawalQueue.push(strategy);\n        }\n        emit UpdateWithdrawalQueue(_withdrawalQueue);\n    }\n\n    /**\n     * @dev It calculates the total underlying value of {token} held by the system.\n     * It takes into account the vault contract balance, and the balance deployed across\n     * all the strategies.\n     */\n    function balance() public view returns (uint256) {\n        return token.balanceOf(address(this)) + totalAllocated;\n    }\n\n    /**\n     * @notice It calculates the amount of free funds available after profit locking.\n     * For calculating share price, issuing shares during deposit, or burning shares during withdrawal.\n     * @return freeFunds - the total amount of free funds available.\n     */\n    function _freeFunds() internal view returns (uint256) {\n        return balance() - _calculateLockedProfit();\n    }\n\n    /**\n     * @dev Function for various UIs to display the current value of one of our yield tokens.\n     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return totalSupply() == 0 ? 10**decimals() : (_freeFunds() * 10**decimals()) / totalSupply();\n    }\n\n    /**\n     * @dev A helper function to call deposit() with all the sender's funds.\n     */\n    function depositAll() external {\n        _deposit(token.balanceOf(msg.sender), msg.sender);\n    }\n\n    /**\n     * @notice The entrypoint of funds into the system. People deposit with this function\n     * into the vault.\n     * @notice the _before and _after variables are used to account properly for\n     * 'burn-on-transaction' tokens.\n     * @param _amount The amount of assets to deposit\n     */\n    function deposit(uint256 _amount) external {\n        _deposit(_amount, msg.sender);\n    }\n\n    // Internal helper function to deposit {_amount} of assets and mint corresponding\n    // shares to {_receiver}. Returns the number of shares that were minted.\n    function _deposit(uint256 _amount, address _receiver) internal nonReentrant returns (uint256 shares) {\n        _atLeastRole(DEPOSITOR);\n        require(!emergencyShutdown, \"Cannot deposit during emergency shutdown\");\n        require(_amount != 0, \"Invalid amount\");\n        uint256 pool = balance();\n        require(pool + _amount <= tvlCap, \"Vault is full\");\n\n        uint256 freeFunds = _freeFunds();\n        uint256 balBefore = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 balAfter = token.balanceOf(address(this));\n        _amount = balAfter - balBefore;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount * totalSupply()) / freeFunds; // use \"freeFunds\" instead of \"pool\"\n        }\n        _mint(_receiver, shares);\n        emit Deposit(msg.sender, _receiver, _amount, shares);\n    }\n\n    /**\n     * @dev A helper function to call withdraw() with all the sender's funds.\n     */\n    function withdrawAll() external {\n        _withdraw(balanceOf(msg.sender), msg.sender, msg.sender);\n    }\n\n    /**\n     * @notice Function to exit the system. The vault will withdraw the required tokens\n     * from the strategies and pay up the token holder. A proportional number of IOU\n     * tokens are burned in the process.\n     * @param _shares the number of shares to burn\n     */\n    function withdraw(uint256 _shares) external {\n        _withdraw(_shares, msg.sender, msg.sender);\n    }\n\n    // Internal helper function to burn {_shares} of vault shares belonging to {_owner}\n    // and return corresponding assets to {_receiver}. Returns the number of assets that were returned.\n    function _withdraw(\n        uint256 _shares,\n        address _receiver,\n        address _owner\n    ) internal nonReentrant returns (uint256 value) {\n        require(_shares != 0, \"Invalid amount\");\n        value = (_freeFunds() * _shares) / totalSupply();\n        _burn(_owner, _shares);\n\n        if (value > token.balanceOf(address(this))) {\n            uint256 totalLoss = 0;\n            uint256 queueLength = withdrawalQueue.length;\n            uint256 vaultBalance = 0;\n            for (uint256 i = 0; i < queueLength; i = i.uncheckedInc()) {\n                vaultBalance = token.balanceOf(address(this));\n                if (value <= vaultBalance) {\n                    break;\n                }\n\n                address stratAddr = withdrawalQueue[i];\n                uint256 strategyBal = strategies[stratAddr].allocated;\n                if (strategyBal == 0) {\n                    continue;\n                }\n\n                uint256 remaining = value - vaultBalance;\n                uint256 loss = IStrategy(stratAddr).withdraw(Math.min(remaining, strategyBal));\n                uint256 actualWithdrawn = token.balanceOf(address(this)) - vaultBalance;\n\n                // Withdrawer incurs any losses from withdrawing as reported by strat\n                if (loss != 0) {\n                    value -= loss;\n                    totalLoss += loss;\n                    _reportLoss(stratAddr, loss);\n                }\n\n                strategies[stratAddr].allocated -= actualWithdrawn;\n                totalAllocated -= actualWithdrawn;\n            }\n\n            vaultBalance = token.balanceOf(address(this));\n            if (value > vaultBalance) {\n                value = vaultBalance;\n            }\n\n            require(\n                totalLoss <= ((value + totalLoss) * withdrawMaxLoss) / PERCENT_DIVISOR,\n                \"Withdraw loss exceeds slippage\"\n            );\n        }\n\n        token.safeTransfer(_receiver, value);\n        emit Withdraw(msg.sender, _receiver, _owner, value, _shares);\n    }\n\n    /**\n     * @notice It calculates the amount of locked profit from recent harvests.\n     * @return the amount of locked profit.\n     */\n    function _calculateLockedProfit() internal view returns (uint256) {\n        uint256 lockedFundsRatio = (block.timestamp - lastReport) * lockedProfitDegradation;\n        if (lockedFundsRatio < DEGRADATION_COEFFICIENT) {\n            return lockedProfit - ((lockedFundsRatio * lockedProfit) / DEGRADATION_COEFFICIENT);\n        }\n\n        return 0;\n    }\n\n    /**\n     * @notice Helper function to report a loss by a given strategy.\n     * @param strategy The strategy to report the loss for.\n     * @param loss The amount lost.\n     */\n    function _reportLoss(address strategy, uint256 loss) internal {\n        StrategyParams storage stratParams = strategies[strategy];\n        // Loss can only be up the amount of capital allocated to the strategy\n        uint256 allocation = stratParams.allocated;\n        require(loss <= allocation, \"Strategy loss cannot be greater than allocation\");\n\n        if (totalAllocBPS != 0) {\n            // reduce strat's allocBPS proportional to loss\n            uint256 bpsChange = Math.min((loss * totalAllocBPS) / totalAllocated, stratParams.allocBPS);\n\n            // If the loss is too small, bpsChange will be 0\n            if (bpsChange != 0) {\n                stratParams.allocBPS -= bpsChange;\n                totalAllocBPS -= bpsChange;\n            }\n        }\n\n        // Finally, adjust our strategy's parameters by the loss\n        stratParams.losses += loss;\n        stratParams.allocated -= loss;\n        totalAllocated -= loss;\n    }\n\n    /**\n     * @notice Helper function to charge fees from the gain reported by a strategy.\n     * Fees is charged by issuing the corresponding amount of vault shares to the treasury.\n     * @param strategy The strategy that reported gain.\n     * @param gain The amount of profit reported.\n     * @return The fee amount in assets.\n     */\n    function _chargeFees(address strategy, uint256 gain) internal returns (uint256) {\n        uint256 performanceFee = (gain * strategies[strategy].feeBPS) / PERCENT_DIVISOR;\n        if (performanceFee != 0) {\n            uint256 supply = totalSupply();\n            uint256 shares = supply == 0 ? performanceFee : (performanceFee * supply) / _freeFunds();\n            _mint(treasury, shares);\n        }\n        return performanceFee;\n    }\n\n    // To avoid \"stack too deep\" errors\n    struct LocalVariables_report {\n        address stratAddr;\n        uint256 loss;\n        uint256 gain;\n        uint256 fees;\n        int256 available;\n        uint256 debt;\n        uint256 credit;\n        uint256 debtPayment;\n        uint256 freeWantInStrat;\n        uint256 lockedProfitBeforeLoss;\n    }\n\n    /**\n     * @notice Main contact point where each strategy interacts with the vault during its harvest\n     * to report profit/loss as well as any repayment of debt.\n     * @param _roi The return on investment (positive or negative) given as the total amount\n     * gained or lost from the harvest.\n     * @param _repayment The repayment of debt by the strategy.\n     */\n    function report(int256 _roi, uint256 _repayment) external returns (uint256) {\n        LocalVariables_report memory vars;\n        vars.stratAddr = msg.sender;\n        StrategyParams storage strategy = strategies[vars.stratAddr];\n        require(strategy.activation != 0, \"Unauthorized strategy\");\n\n        if (_roi < 0) {\n            vars.loss = uint256(-_roi);\n            _reportLoss(vars.stratAddr, vars.loss);\n        } else if (_roi > 0) {\n            vars.gain = uint256(_roi);\n            vars.fees = _chargeFees(vars.stratAddr, vars.gain);\n            strategy.gains += vars.gain;\n        }\n\n        vars.available = availableCapital();\n        if (vars.available < 0) {\n            vars.debt = uint256(-vars.available);\n            vars.debtPayment = Math.min(vars.debt, _repayment);\n\n            if (vars.debtPayment != 0) {\n                strategy.allocated -= vars.debtPayment;\n                totalAllocated -= vars.debtPayment;\n                vars.debt -= vars.debtPayment; // tracked for return value\n            }\n        } else if (vars.available > 0) {\n            vars.credit = uint256(vars.available);\n            strategy.allocated += vars.credit;\n            totalAllocated += vars.credit;\n        }\n\n        vars.freeWantInStrat = vars.gain + _repayment;\n        if (vars.credit > vars.freeWantInStrat) {\n            token.safeTransfer(vars.stratAddr, vars.credit - vars.freeWantInStrat);\n        } else if (vars.credit < vars.freeWantInStrat) {\n            token.safeTransferFrom(vars.stratAddr, address(this), vars.freeWantInStrat - vars.credit);\n        }\n\n        // Profit is locked and gradually released per block\n        // NOTE: compute current locked profit and replace with sum of current and new\n        vars.lockedProfitBeforeLoss = _calculateLockedProfit() + vars.gain - vars.fees;\n        if (vars.lockedProfitBeforeLoss > vars.loss) {\n            lockedProfit = vars.lockedProfitBeforeLoss - vars.loss;\n        } else {\n            lockedProfit = 0;\n        }\n\n        strategy.lastReport = block.timestamp;\n        lastReport = block.timestamp;\n\n        emit StrategyReported(\n            vars.stratAddr,\n            vars.gain,\n            vars.loss,\n            vars.debtPayment,\n            strategy.gains,\n            strategy.losses,\n            strategy.allocated,\n            vars.credit,\n            strategy.allocBPS\n        );\n\n        if (strategy.allocBPS == 0 || emergencyShutdown) {\n            return IStrategy(vars.stratAddr).balanceOf();\n        }\n\n        return vars.debt;\n    }\n\n    /**\n     * @notice Updates the withdrawMaxLoss which is the maximum allowed slippage.\n     * @param _withdrawMaxLoss The new value, in basis points.\n     */\n    function updateWithdrawMaxLoss(uint256 _withdrawMaxLoss) external {\n        _atLeastRole(STRATEGIST);\n        require(_withdrawMaxLoss <= PERCENT_DIVISOR, \"Invalid BPS value\");\n        withdrawMaxLoss = _withdrawMaxLoss;\n        emit WithdrawMaxLossUpdated(_withdrawMaxLoss);\n    }\n\n    /**\n     * @notice Updates the vault tvl cap (the max amount of assets held by the vault).\n     * @dev pass in max value of uint to effectively remove TVL cap.\n     * @param _newTvlCap The new tvl cap.\n     */\n    function updateTvlCap(uint256 _newTvlCap) public {\n        _atLeastRole(ADMIN);\n        tvlCap = _newTvlCap;\n        emit TvlCapUpdated(tvlCap);\n    }\n\n    /**\n     * @dev helper function to remove TVL cap\n     */\n    function removeTvlCap() external {\n        updateTvlCap(type(uint256).max);\n    }\n\n    /**\n     * Activates or deactivates Vault mode where all Strategies go into full\n     * withdrawal.\n     * During Emergency Shutdown:\n     * 1. No Users may deposit into the Vault (but may withdraw as usual.)\n     * 2. New Strategies may not be added.\n     * 3. Each Strategy must pay back their debt as quickly as reasonable to\n     * minimally affect their position.\n     *\n     * If true, the Vault goes into Emergency Shutdown. If false, the Vault\n     * goes back into Normal Operation.\n     */\n    function setEmergencyShutdown(bool _active) external {\n        if (_active) {\n            _atLeastRole(GUARDIAN);\n        } else {\n            _atLeastRole(ADMIN);\n        }\n        emergencyShutdown = _active;\n        emit EmergencyShutdown(_active);\n    }\n\n    /**\n     * @notice Changes the locked profit degradation.\n     * @param degradation - The rate of degradation in percent per second scaled to 1e18.\n     */\n    function setLockedProfitDegradation(uint256 degradation) external {\n        _atLeastRole(ADMIN);\n        require(degradation <= DEGRADATION_COEFFICIENT, \"Degradation cannot be more than 100%\");\n        lockedProfitDegradation = degradation;\n        emit LockedProfitDegradationUpdated(degradation);\n    }\n\n    /**\n     * @notice Only DEFAULT_ADMIN_ROLE can update treasury address.\n     */\n    function updateTreasury(address newTreasury) external {\n        _atLeastRole(DEFAULT_ADMIN_ROLE);\n        require(newTreasury != address(0), \"Invalid address\");\n        treasury = newTreasury;\n    }\n\n    /**\n     * @dev Rescues random funds stuck that the strat can't handle.\n     * @param _token address of the token to rescue.\n     */\n    function inCaseTokensGetStuck(address _token) external {\n        _atLeastRole(ADMIN);\n        require(_token != address(token), \"!token\");\n\n        uint256 amount = IERC20Metadata(_token).balanceOf(address(this));\n        IERC20Metadata(_token).safeTransfer(msg.sender, amount);\n        emit InCaseTokensGetStuckCalled(_token, amount);\n    }\n\n    /**\n     * @dev Overrides the default 18 decimals for the vault ERC20 to\n     * match the same decimals as the underlying token used\n     */\n    function decimals() public view override returns (uint8) {\n        return token.decimals();\n    }\n\n    /**\n     * @dev Returns an array of all the relevant roles arranged in descending order of privilege.\n     *      Subclasses should override this to specify their unique roles arranged in the correct\n     *      order, for example, [SUPER-ADMIN, ADMIN, GUARDIAN, STRATEGIST].\n     */\n    function _cascadingAccessRoles() internal view override returns (bytes32[] memory) {\n        bytes32[] memory cascadingAccessRoles = new bytes32[](5);\n        cascadingAccessRoles[0] = DEFAULT_ADMIN_ROLE;\n        cascadingAccessRoles[1] = ADMIN;\n        cascadingAccessRoles[2] = GUARDIAN;\n        cascadingAccessRoles[3] = STRATEGIST;\n        cascadingAccessRoles[4] = DEPOSITOR;\n        return cascadingAccessRoles;\n    }\n\n    /**\n     * @dev Returns {true} if {_account} has been granted {_role}. Subclasses should override\n     *      this to specify their unique role-checking criteria.\n     */\n    function _hasRole(bytes32 _role, address _account) internal view override returns (bool) {\n        return hasRole(_role, _account);\n    }\n}"
    },
    {
      "filename": "Ethos-Vault/contracts/abstract/ReaperBaseStrategyv4.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../libraries/ReaperMathUtils.sol\";\nimport \"../mixins/ReaperAccessControl.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nabstract contract ReaperBaseStrategyv4 is\n    ReaperAccessControl,\n    IStrategy,\n    UUPSUpgradeable,\n    AccessControlEnumerableUpgradeable\n{\n    using ReaperMathUtils for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint256 public constant PERCENT_DIVISOR = 10_000;\n    uint256 public constant UPGRADE_TIMELOCK = 48 hours; // minimum 48 hours for RF\n    uint256 public constant FUTURE_NEXT_PROPOSAL_TIME = 365 days * 100;\n\n    // The token the strategy wants to operate\n    address public want;\n\n    bool public emergencyExit;\n    uint256 public lastHarvestTimestamp;\n\n    uint256 public upgradeProposalTime;\n\n    /**\n     * Reaper Roles in increasing order of privilege.\n     * {KEEPER} - Stricly permissioned trustless access for off-chain programs or third party keepers.\n     * {STRATEGIST} - Role conferred to authors of the strategy, allows for tweaking non-critical params.\n     * {GUARDIAN} - Multisig requiring 2 signatures for emergency measures such as pausing and panicking.\n     * {ADMIN}- Multisig requiring 3 signatures for unpausing.\n     *\n     * The DEFAULT_ADMIN_ROLE (in-built access control role) will be granted to a multisig requiring 4\n     * signatures. This role would have upgrading capability, as well as the ability to grant any other\n     * roles.\n     *\n     * Also note that roles are cascading. So any higher privileged role should be able to perform all the functions\n     * of any lower privileged role.\n     */\n    bytes32 public constant KEEPER = keccak256(\"KEEPER\");\n    bytes32 public constant STRATEGIST = keccak256(\"STRATEGIST\");\n    bytes32 public constant GUARDIAN = keccak256(\"GUARDIAN\");\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    /**\n     * @dev Reaper contracts:\n     * {vault} - Address of the vault that controls the strategy's funds.\n     */\n    address public vault;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    function __ReaperBaseStrategy_init(\n        address _vault,\n        address _want,\n        address[] memory _strategists,\n        address[] memory _multisigRoles\n    ) internal onlyInitializing {\n        __UUPSUpgradeable_init();\n        __AccessControlEnumerable_init();\n\n        vault = _vault;\n        want = _want;\n        IERC20Upgradeable(want).safeApprove(vault, type(uint256).max);\n\n        uint256 numStrategists = _strategists.length;\n        for (uint256 i = 0; i < numStrategists; i = i.uncheckedInc()) {\n            _grantRole(STRATEGIST, _strategists[i]);\n        }\n\n        require(_multisigRoles.length == 3, \"Invalid number of multisig roles\");\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(DEFAULT_ADMIN_ROLE, _multisigRoles[0]);\n        _grantRole(ADMIN, _multisigRoles[1]);\n        _grantRole(GUARDIAN, _multisigRoles[2]);\n\n        clearUpgradeCooldown();\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault. Can only\n     *      be called by the vault. _amount must be valid and security fee\n     *      is deducted up-front.\n     */\n    function withdraw(uint256 _amount) external override returns (uint256 loss) {\n        require(msg.sender == vault, \"Only vault can withdraw\");\n        require(_amount != 0, \"Amount cannot be zero\");\n        require(_amount <= balanceOf(), \"Ammount must be less than balance\");\n\n        uint256 amountFreed = 0;\n        (amountFreed, loss) = _liquidatePosition(_amount);\n        IERC20Upgradeable(want).safeTransfer(vault, amountFreed);\n    }\n\n    /**\n     * @dev harvest() function that takes care of logging. Subcontracts should\n     *      override _harvestCore() and implement their specific logic in it.\n     */\n    function harvest() external override returns (int256 roi) {\n        _atLeastRole(KEEPER);\n        int256 availableCapital = IVault(vault).availableCapital();\n        uint256 debt = 0;\n        if (availableCapital < 0) {\n            debt = uint256(-availableCapital);\n        }\n\n        uint256 repayment = 0;\n        if (emergencyExit) {\n            uint256 amountFreed = _liquidateAllPositions();\n            if (amountFreed < debt) {\n                roi = -int256(debt - amountFreed);\n            } else if (amountFreed > debt) {\n                roi = int256(amountFreed - debt);\n            }\n\n            repayment = debt;\n            if (roi < 0) {\n                repayment -= uint256(-roi);\n            }\n        } else {\n            (roi, repayment) = _harvestCore(debt);\n        }\n\n        debt = IVault(vault).report(roi, repayment);\n        _adjustPosition(debt);\n\n        lastHarvestTimestamp = block.timestamp;\n    }\n\n    /**\n     * @dev Function to calculate the total {want} held by the strat.\n     *      It takes into account both the funds in hand, p"
    }
  ]
}