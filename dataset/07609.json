{
  "Title": "[M-08] Tokens with fees will break the ``depositGlp()`` logic",
  "Content": "\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L367>\n\n<https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L583>\n\n### Impact\n\nIn `PirexGmx` and `AutoPxGlp` you have function `depositGlp()`, which accepts any ERC20 token from whitelist.\n\nNow there are 9 tokens (see here: <https://arbiscan.io/address/0x489ee077994b6658eafa855c308275ead8097c4a#readContract>):\n\n`WBTC, WETH, USDC, LINK, UNI, USDT, MIM, FRAX, DAI`\nAnd the list may extend\n\nSo any user can deposit any of those tokens and receive pxGlp token:\n\n        function testUSDTDepositGlp() external {\n            // 0 USDT TOKENS\n            address myAddress = address(this);\n            assertEq(usdt.balanceOf(myAddress), 0);\n\n            // The one with many USDT tokens\n            vm.prank(0xB6CfcF89a7B22988bfC96632aC2A9D6daB60d641);\n            uint256 amount = 100000;\n            usdt.transfer(myAddress, amount);\n\n            // amount USDT TOKENS\n            assertEq(usdt.balanceOf(myAddress), amount);\n\n            // DEPOSIT USDT TOKENS\n            usdt.approve(address(pirexGmx), amount);\n            pirexGmx.depositGlp(address(usdt), amount, 1, 1, address(this));\n            \n            // SUCCESSSFULLY DEPOSITED\n            assertEq(usdt.balanceOf(address(this)), 0);\n            assertEq(pxGlp.balanceOf(address(this)), 118890025839780442);\n        }\n\nBut if any of these tokens will start charge fee on transfers, the logic will be broken and calls to `depositGlp()` with suck token will fail.\n\nBecause here you use the amount of tokens sent from user wallet: <https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/PirexGmx.sol#L512>\n\n                t.safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n                // Mint and stake GLP using ERC20 tokens\n                deposited = gmxRewardRouterV2.mintAndStakeGlp(\n                    token,\n                    tokenAmount,\n                    minUsdg,\n                    minGlp\n                );\n\nAnd then `gmxRewardRouterV2` tries to transfer tokens to his balance from your balance:\n\n    IERC20(_token).safeTransferFrom(_fundingAccount, address(vault), _amount);\n\n(See <https://arbiscan.io/address/0x321f653eed006ad1c29d174e17d96351bde22649#code> - GlpManager and\n<https://arbiscan.io/address/0xA906F338CB21815cBc4Bc87ace9e68c87eF8d8F1#code> - RewardRouterV2)\n\nBut you received less than `tokenAmount` tokens because of fee. The transaction will fail.\n\n### Proof of Concept\n\nLet's imagine USDT in arbitrub started to charge fees 1% per transfer.\n\nAlice wants to deposit 100 USDT through `PirexGmx.depositGlp()`\n\nThen you do\n`t.safeTransferFrom(Alice, address(this), 100);`\n\nYou will receive only 99 USDT\n\nBut in the next line you will try to send 100 USDT:\n\n    deposited = gmxRewardRouterV2.mintAndStakeGlp(\n                    token,\n                    tokenAmount,\n                    minUsdg,\n                    minGlp\n                );\n\nSo transaction fails and Alice can't get pxGlp tokens.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nUSDT already has fees in other blockchains.\n\nMany of these tokens use proxy pattern (and USDT too). It's quite probably that in one day one of the tokens will start charge fees. Or you would like to add one more token to whitelist and the token will be with fees.\n\nThats why I consider finding as Medium severity.\n\nTo avoid problems, use common pattern, when you check your balance before operation and balance after, like that:\n\n                uint256 balanceBefore = t.balanceOf(address(this));\n                t.safeTransferFrom(msg.sender, address(this), tokenAmount);\n                uint256 balanceAfter = t.balanceOf(address(this));\n\n                uint256 tokenAmount = balanceAfter - balanceBefore;\n\n                // Mint and stake GLP using ERC20 tokens\n                deposited = gmxRewardRouterV2.mintAndStakeGlp(\n                    token,\n                    tokenAmount,\n                    minUsdg,\n                    minGlp\n                );\n\n**[drahrealm (Redacted Cartel) confirmed](https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/196)** \n\n**[Picodes (judge) commented](https://github.com/code-423n4/2022-11-redactedcartel-findings/issues/196#issuecomment-1368081026):**\n > As USDT is already an accepted underlying token, Medium severity is appropriate.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-redacted-cartel-contest",
  "Code": [
    {
      "filename": "src/vaults/AutoPxGlp.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {PxGmxReward} from \"src/vaults/PxGmxReward.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\n\ncontract AutoPxGlp is PirexERC4626, PxGmxReward, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n    uint256 public constant EXPANDED_DECIMALS = 1e30;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    // GMX protocol base reward (e.g. WETH)\n    ERC20 public immutable gmxBaseReward;\n\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint256 minGlp,\n        uint256 gmxBaseRewardAmount,\n        uint256 pxGmxAmountOut,\n        uint256 pxGlpAmountOut,\n        uint256 totalPxGlpFee,\n        uint256 totalPxGmxFee,\n        uint256 pxGlpIncentive,\n        uint256 pxGmxIncentive\n    );\n\n    error ZeroAmount();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _asset          address  Asset address (vault asset, e.g. pxGLP)\n        @param  _pxGmx          address  pxGMX address (as secondary reward)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGLP)\n        @param  _symbol         string   Asset symbol (e.g. apxGLP)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _asset,\n        address _pxGmx,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) PxGmxReward(_pxGmx) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(_platform), type(uint256).max);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGLP custodied by the AutoPxGlp contract\n        @return uint256  Amount of pxGLP custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares   uint256  Shares amount\n        @return          uint256  Assets amount\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets   uint256  Assets amount\n        @return          uint256  Shares amount\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGLP (and additionally pxGMX) rewards\n        @param  minUsdg                uint256  Minimum USDG amount used when minting GLP\n        @param  minGlp                 uint256  Minimum GLP amount received from the WETH deposit\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  WETH inbound amount\n        @return pxGmxAmountOut         uint256  pxGMX outbound amount\n        @return pxGlpAmountOut         uint256  pxGLP outbound amount\n        @return totalPxGlpFee          uint256  Total platform fee for pxGLP\n        @return totalPxGmxFee          uint256  Total platform fee for pxGMX\n        @return pxGlpIncentive         uint256  Compound incentive for pxGLP\n        @return pxGmxIncentive         uint256  Compound incentive for pxGMX\n     */\n    function compound(\n        uint256 minUsdg,\n        uint256 minGlp,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 pxGmxAmountOut,\n            uint256 pxGlpAmountOut,\n            uint256 totalPxGlpFee,\n            uint256 totalPxGmxFee,\n            uint256 pxGlpIncentive,\n            uint256 pxGmxIncentive\n        )\n    {\n        if (minUsdg == 0) revert InvalidParam();\n        if (minGlp == 0) revert InvalidParam();\n\n        uint256 preClaimTotalAssets = asset.balanceOf(address(this));\n        uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n        PirexRewards(rewardsModule).claim(pxGmx, address(this));\n\n        // Track the amount of rewards received\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            // Deposit received rewards for pxGLP\n            (, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(\n                address(gmxBaseReward),\n                gmxBaseRewardAmountIn,\n                minUsdg,\n                minGlp,\n                address(this)\n            );\n        }\n\n        // Distribute fees if the amount of vault assets increased\n        uint256 newAssets = totalAssets() - preClaimTotalAssets;\n        if (newAssets != 0) {\n            totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;\n            pxGlpIncentive = optOutIncentive\n                ? 0\n                : (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGlpIncentive != 0)\n                asset.safeTransfer(msg.sender, pxGlpIncentive);\n\n            asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);\n        }\n\n        // Track the amount of pxGMX received\n        pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;\n\n        if (pxGmxAmountOut != 0) {\n            // Calculate and distribute pxGMX fees if the amount of pxGMX increased\n            totalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;\n            pxGmxIncentive = optOutIncentive\n                ? 0\n                : (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGmxIncentive != 0)\n                pxGmx.safeTransfer(msg.sender, pxGmxIncentive);\n\n            pxGmx.safeTransfer(owner, totalPxGmxFee - pxGmxIncentive);\n\n            // Update the pxGmx reward accrual\n            _harvest(pxGmxAmountOut - totalPxGmxFee);\n        } else {\n            // Required to keep the globalState up-to-date\n            _globalAccrue();\n        }\n\n        emit Compounded(\n            msg.sender,\n            minGlp,\n            gmxBaseRewardAmountIn,\n            pxGmxAmountOut,\n            pxGlpAmountOut,\n            totalPxGlpFee,\n            totalPxGmxFee,\n            pxGlpIncentive,\n            pxGmxIncentive\n        );\n    }\n\n    /**\n        @notice Internal deposit handler\n        @param  assets    uint256  pxGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return shares    uint256  Vault shares (i.e. apxGLP)\n     */\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        uint256 supply = totalSupply;\n\n        if (\n            (shares = supply == 0\n                ? assets\n                : assets.mulDivDown(supply, totalAssets() - assets)) == 0\n        ) revert ZeroShares();\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    /**\n        @notice Deposit fsGLP for apxGLP\n        @param  amount    uint256  fsGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositFsGlp(uint256 amount, address receiver)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        ERC20 stakedGlp = ERC20(address(PirexGmx(platform).stakedGlp()));\n\n        // Transfer fsGLP from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        stakedGlp.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve as needed here since the stakedGlp address is mutable in PirexGmx\n        stakedGlp.safeApprove(platform, amount);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositFsGlp(\n            amount,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ERC20 tokens) for apxGLP\n        @param  token        address  GMX-whitelisted token for minting GLP\n        @param  tokenAmount  uint256  Whitelisted token amount\n        @param  minUsdg      uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp       uint256  Minimum GLP amount minted from ERC20 tokens\n        @param  receiver     address  apxGLP receiver\n        @return              uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external nonReentrant returns (uint256) {\n        if (token == address(0)) revert ZeroAddress();\n        if (tokenAmount == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        // PirexGmx will do the check whether the token is whitelisted or not\n        ERC20 erc20Token = ERC20(token);\n\n        // Transfer token from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        erc20Token.safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n        // Approve as needed here since it can be a new whitelisted token (unless it's the baseReward)\n        if (erc20Token != gmxBaseReward) {\n            erc20Token.safeApprove(platform, tokenAmount);\n        }\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ETH) for apxGLP\n        @param  minUsdg   uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp    uint256  Minimum GLP amount minted from ETH\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlpETH(\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external payable nonReentrant returns (uint256) {\n        if (msg.value == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlpETH{\n            value: msg.value\n        }(minUsdg, minGlp, address(this));\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Override the withdrawal method to make sure compound is called before withdrawing\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        compound(1, 1, true);\n\n        shares = PirexERC4626.withdraw(assets, receiver, owner);\n    }\n\n    /**\n        @notice Override the redemption method to make sure compound is called before redeeming\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        compound(1, 1, true);\n\n        assets = PirexERC4626.redeem(shares, receiver, owner);\n    }\n\n    /**\n        @notice Compound and internally update pxGMX reward accrual before deposit\n     */\n    function beforeDeposit(\n        address,\n        uint256,\n        uint256\n    ) internal override {\n        compound(1, 1, true);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual after deposit\n        @param  receiver  address  Receiver of the vault shares\n     */\n    function afterDeposit(\n        address receiver,\n        uint256,\n        uint256\n    ) internal override {\n        _globalAccrue();\n        _userAccrue(receiver);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual after withdrawal\n        @param  owner  address  Owner of the vault shares\n     */\n    function afterWithdraw(\n        address owner,\n        uint256,\n        uint256\n    ) internal override {\n        _globalAccrue();\n        _userAccrue(owner);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual for both sender and receiver after transfer\n        @param  owner     address  Owner of the vault shares\n        @param  receiver  address  Receiver of the vault shares\n     */\n    function afterTransfer(\n        address owner,\n        address receiver,\n        uint256\n    ) internal override {\n        _userAccrue(owner);\n        _userAccrue(receiver);\n    }\n}"
    },
    {
      "filename": "src/PirexGmx.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {Pausable} from \"openzeppelin-contracts/contracts/security/Pausable.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PxERC20} from \"src/PxERC20.sol\";\nimport {PirexFees} from \"src/PirexFees.sol\";\nimport {DelegateRegistry} from \"src/external/DelegateRegistry.sol\";\nimport {IRewardRouterV2} from \"src/interfaces/IRewardRouterV2.sol\";\nimport {RewardTracker} from \"src/external/RewardTracker.sol\";\nimport {IStakedGlp} from \"src/interfaces/IStakedGlp.sol\";\nimport {IVault} from \"src/interfaces/IVault.sol\";\nimport {IRewardDistributor} from \"src/interfaces/IRewardDistributor.sol\";\nimport {IPirexRewards} from \"src/interfaces/IPirexRewards.sol\";\nimport {IGlpManager} from \"src/interfaces/IGlpManager.sol\";\n\ncontract PirexGmx is ReentrancyGuard, Owned, Pausable {\n    using SafeTransferLib for ERC20;\n\n    // Configurable fees\n    enum Fees {\n        Deposit,\n        Redemption,\n        Reward\n    }\n\n    // Configurable external contracts\n    enum Contracts {\n        PirexFees,\n        RewardRouterV2,\n        RewardTrackerGmx,\n        RewardTrackerGlp,\n        FeeStakedGlp,\n        StakedGmx,\n        StakedGlp,\n        GmxVault,\n        GlpManager\n    }\n\n    // Fee denominator\n    uint256 public constant FEE_DENOMINATOR = 1_000_000;\n\n    // Fee maximum (i.e. 20%)\n    uint256 public constant FEE_MAX = 200_000;\n\n    // External token contracts\n    ERC20 public immutable gmxBaseReward; // e.g. WETH (Ethereum)\n    ERC20 public immutable gmx;\n    ERC20 public immutable esGmx;\n\n    // Pirex token contract(s) which are unlikely to change\n    PxERC20 public immutable pxGmx;\n    PxERC20 public immutable pxGlp;\n\n    // Pirex fee repository and distribution contract\n    PirexFees public pirexFees;\n\n    // Pirex reward module contract\n    address public immutable pirexRewards;\n\n    // Snapshot vote delegation contract\n    DelegateRegistry public immutable delegateRegistry;\n\n    // GMX contracts\n    IRewardRouterV2 public gmxRewardRouterV2;\n    RewardTracker public rewardTrackerGmx;\n    RewardTracker public rewardTrackerGlp;\n    RewardTracker public feeStakedGlp;\n    RewardTracker public stakedGmx;\n    IStakedGlp public stakedGlp;\n    address public glpManager;\n    IVault public gmxVault;\n\n    // Migration related address\n    address public migratedTo;\n\n    // Snapshot space\n    bytes32 public delegationSpace = bytes32(\"gmx.eth\");\n\n    // Fees (e.g. 5000 / 1000000 = 0.5%)\n    mapping(Fees => uint256) public fees;\n\n    event ConfigureGmxState(\n        address indexed caller,\n        RewardTracker rewardTrackerGmx,\n        RewardTracker rewardTrackerGlp,\n        RewardTracker feeStakedGlp,\n        RewardTracker stakedGmx,\n        address glpManager,\n        IVault gmxVault\n    );\n    event SetFee(Fees indexed f, uint256 fee);\n    event SetContract(Contracts indexed c, address contractAddress);\n    event DepositGmx(\n        address indexed caller,\n        address indexed receiver,\n        uint256 deposited,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event DepositGlp(\n        address indexed caller,\n        address indexed receiver,\n        address indexed token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        uint256 deposited,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event RedeemGlp(\n        address indexed caller,\n        address indexed receiver,\n        address indexed token,\n        uint256 amount,\n        uint256 minOut,\n        uint256 redemption,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event ClaimRewards(\n        uint256 baseRewards,\n        uint256 esGmxRewards,\n        uint256 gmxBaseRewards,\n        uint256 glpBaseRewards,\n        uint256 gmxEsGmxRewards,\n        uint256 glpEsGmxRewards\n    );\n    event ClaimUserReward(\n        address indexed receiver,\n        address indexed token,\n        uint256 amount,\n        uint256 rewardAmount,\n        uint256 feeAmount\n    );\n    event InitiateMigration(address newContract);\n    event CompleteMigration(address oldContract);\n    event SetDelegationSpace(string delegationSpace, bool shouldClear);\n    event SetVoteDelegate(address voteDelegate);\n    event ClearVoteDelegate();\n\n    error ZeroAmount();\n    error ZeroAddress();\n    error InvalidToken(address token);\n    error NotPirexRewards();\n    error InvalidFee();\n    error EmptyString();\n    error NotMigratedTo();\n    error PendingMigration();\n\n    /**\n        @param  _pxGmx              address  PxGmx contract address\n        @param  _pxGlp              address  PxGlp contract address\n        @param  _pirexFees          address  PirexFees contract address\n        @param  _pirexRewards       address  PirexRewards contract address\n        @param  _delegateRegistry   address  Delegation registry contract address\n        @param  _gmxBaseReward      address  GMX base reward token contract address\n        @param  _gmx                address  GMX token contract address\n        @param  _esGmx              address  esGMX token contract address\n        @param  _gmxRewardRouterV2  address  GMX Reward Router contract address\n        @param  _stakedGlp          address  Staked GLP token contract address\n    */\n    constructor(\n        address _pxGmx,\n        address _pxGlp,\n        address _pirexFees,\n        address _pirexRewards,\n        address _delegateRegistry,\n        address _gmxBaseReward,\n        address _gmx,\n        address _esGmx,\n        address _gmxRewardRouterV2,\n        address _stakedGlp\n    ) Owned(msg.sender) {\n        // Start the contract paused, to ensure contract set is properly configured\n        _pause();\n\n        if (_pxGmx == address(0)) revert ZeroAddress();\n        if (_pxGlp == address(0)) revert ZeroAddress();\n        if (_pirexFees == address(0)) revert ZeroAddress();\n        if (_pirexRewards == address(0)) revert ZeroAddress();\n        if (_delegateRegistry == address(0)) revert ZeroAddress();\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_gmx == address(0)) revert ZeroAddress();\n        if (_esGmx == address(0)) revert ZeroAddress();\n        if (_gmxRewardRouterV2 == address(0)) revert ZeroAddress();\n        if (_stakedGlp == address(0)) revert ZeroAddress();\n\n        pxGmx = PxERC20(_pxGmx);\n        pxGlp = PxERC20(_pxGlp);\n        pirexFees = PirexFees(_pirexFees);\n        pirexRewards = _pirexRewards;\n        delegateRegistry = DelegateRegistry(_delegateRegistry);\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        gmx = ERC20(_gmx);\n        esGmx = ERC20(_esGmx);\n        gmxRewardRouterV2 = IRewardRouterV2(_gmxRewardRouterV2);\n        stakedGlp = IStakedGlp(_stakedGlp);\n    }\n\n    modifier onlyPirexRewards() {\n        if (msg.sender != pirexRewards) revert NotPirexRewards();\n        _;\n    }\n\n    /**\n        @notice Compute post-fee asset and fee amounts from a fee type and total assets\n        @param  f              enum     Fee\n        @param  assets         uint256  GMX/GLP/WETH asset amount\n        @return postFeeAmount  uint256  Post-fee asset amount (for mint/burn/claim/etc.)\n        @return feeAmount      uint256  Fee amount\n     */\n    function _computeAssetAmounts(Fees f, uint256 assets)\n        internal\n        view\n        returns (uint256 postFeeAmount, uint256 feeAmount)\n    {\n        feeAmount = (assets * fees[f]) / FEE_DENOMINATOR;\n        postFeeAmount = assets - feeAmount;\n\n        assert(feeAmount + postFeeAmount == assets);\n    }\n\n    /**\n        @notice Calculate the base (e.g. WETH) or esGMX rewards for either GMX or GLP\n        @param  isBaseReward  bool     Whether to calculate base or esGMX rewards\n        @param  useGmx        bool     Whether the calculation should be for GMX\n        @return               uint256  Amount of WETH/esGMX rewards\n     */\n    function _calculateRewards(bool isBaseReward, bool useGmx)\n        internal\n        view\n        returns (uint256)\n    {\n        RewardTracker r;\n\n        if (isBaseReward) {\n            r = useGmx ? rewardTrackerGmx : rewardTrackerGlp;\n        } else {\n            r = useGmx ? stakedGmx : feeStakedGlp;\n        }\n\n        address distributor = r.distributor();\n        uint256 pendingRewards = IRewardDistributor(distributor)\n            .pendingRewards();\n        uint256 distributorBalance = (isBaseReward ? gmxBaseReward : esGmx)\n            .balanceOf(distributor);\n        uint256 blockReward = pendingRewards > distributorBalance\n            ? distributorBalance\n            : pendingRewards;\n        uint256 precision = r.PRECISION();\n        uint256 cumulativeRewardPerToken = r.cumulativeRewardPerToken() +\n            ((blockReward * precision) / r.totalSupply());\n\n        if (cumulativeRewardPerToken == 0) return 0;\n\n        return\n            r.claimableReward(address(this)) +\n            ((r.stakedAmounts(address(this)) *\n                (cumulativeRewardPerToken -\n                    r.previousCumulatedRewardPerToken(address(this)))) /\n                precision);\n    }\n\n    /**\n        @notice Configure GMX contract state\n     */\n    function configureGmxState() external onlyOwner whenPaused {\n        // Variables which can be assigned by reading previously-set GMX contracts\n        rewardTrackerGmx = RewardTracker(gmxRewardRouterV2.feeGmxTracker());\n        rewardTrackerGlp = RewardTracker(gmxRewardRouterV2.feeGlpTracker());\n        feeStakedGlp = RewardTracker(gmxRewardRouterV2.stakedGlpTracker());\n        stakedGmx = RewardTracker(gmxRewardRouterV2.stakedGmxTracker());\n        glpManager = gmxRewardRouterV2.glpManager();\n        gmxVault = IVault(IGlpManager(glpManager).vault());\n\n        emit ConfigureGmxState(\n            msg.sender,\n            rewardTrackerGmx,\n            rewardTrackerGlp,\n            feeStakedGlp,\n            stakedGmx,\n            glpManager,\n            gmxVault\n        );\n\n        // Approve GMX to enable staking\n        gmx.safeApprove(address(stakedGmx), type(uint256).max);\n    }\n\n    /**\n        @notice Set fee\n        @param  f    enum     Fee\n        @param  fee  uint256  Fee amount\n     */\n    function setFee(Fees f, uint256 fee) external onlyOwner {\n        if (fee > FEE_MAX) revert InvalidFee();\n\n        fees[f] = fee;\n\n        emit SetFee(f, fee);\n    }\n\n    /**\n        @notice Set a contract address\n        @param  c                enum     Contracts\n        @param  contractAddress  address  Contract address\n     */\n    function setContract(Contracts c, address contractAddress)\n        external\n        onlyOwner\n    {\n        if (contractAddress == address(0)) revert ZeroAddress();\n\n        emit SetContract(c, contractAddress);\n\n        if (c == Contracts.PirexFees) {\n            pirexFees = PirexFees(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardRouterV2) {\n            gmxRewardRouterV2 = IRewardRouterV2(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardTrackerGmx) {\n            rewardTrackerGmx = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardTrackerGlp) {\n            rewardTrackerGlp = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.FeeStakedGlp) {\n            feeStakedGlp = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.StakedGmx) {\n            // Set the current stakedGmx (pending change) approval amount to 0\n            gmx.safeApprove(address(stakedGmx), 0);\n\n            stakedGmx = RewardTracker(contractAddress);\n\n            // Approve the new stakedGmx contract address allowance to the max\n            gmx.safeApprove(contractAddress, type(uint256).max);\n            return;\n        }\n\n        if (c == Contracts.StakedGlp) {\n            stakedGlp = IStakedGlp(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.GmxVault) {\n            gmxVault = IVault(contractAddress);\n            return;\n        }\n\n        glpManager = contractAddress;\n    }\n\n    /**\n        @notice Deposit GMX for pxGMX\n        @param  amount    uint256  GMX amount\n        @param  receiver  address  pxGMX receiver\n        @return           uint256  GMX deposited\n        @return           uint256  pxGMX minted for the receiver\n        @return           uint256  pxGMX distributed as fees\n     */\n    function depositGmx(uint256 amount, address receiver)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Transfer the caller's GMX to this contract and stake it for rewards\n        gmx.safeTransferFrom(msg.sender, address(this), amount);\n        gmxRewardRouterV2.stakeGmx(amount);\n\n        // Get the pxGMX amounts for the receiver and the protocol (fees)\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            amount\n        );\n\n        // Mint pxGMX for the receiver (excludes fees)\n        pxGmx.mint(receiver, postFeeAmount);\n\n        // Mint pxGMX for fee distribution contract\n        if (feeAmount != 0) {\n            pxGmx.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGmx(msg.sender, receiver, amount, postFeeAmount, feeAmount);\n\n        return (amount, postFeeAmount, feeAmount);\n    }\n\n    /**\n        @notice Deposit fsGLP for pxGLP\n        @param  amount    uint256  fsGLP amount\n        @param  receiver  address  pxGLP receiver\n        @return           uint256  fsGLP deposited\n        @return           uint256  pxGLP minted for the receiver\n        @return           uint256  pxGLP distributed as fees\n     */\n    function depositFsGlp(uint256 amount, address receiver)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Transfer the caller's fsGLP (unstaked for the user, staked for this contract)\n        stakedGlp.transferFrom(msg.sender, address(this), amount);\n\n        // Get the pxGLP amounts for the receiver and the protocol (fees)\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            amount\n        );\n\n        // Mint pxGLP for the receiver (excludes fees)\n        pxGlp.mint(receiver, postFeeAmount);\n\n        // Mint pxGLP for fee distribution contract\n        if (feeAmount != 0) {\n            pxGlp.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGlp(\n            msg.sender,\n            receiver,\n            address(stakedGlp),\n            0,\n            0,\n            0,\n            amount,\n            postFeeAmount,\n            feeAmount\n        );\n\n        return (amount, postFeeAmount, feeAmount);\n    }\n\n    /**\n        @notice Deposit GLP for pxGLP\n        @param  token          address  GMX-whitelisted token for minting GLP (optional)"
    }
  ]
}