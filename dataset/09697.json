{
  "Title": "[M-02] Anyone can get swaps for free given certain conditions in `swap`.",
  "Content": "_Submitted by hake, also found by csanuragjain, hickuphh3, hyh, Kenshin, kirk-baird, obront, pmerkleplant, rayn, Ruhum, shw, tintin, VAD37, WatchPug, and wuwe1_\n\n[LibSwap.swap](https://github.com/code-423n4/2022-03-lifinance/blob/main/src/Libraries/LibSwap.sol#L29-L48)<br>\n[GenericSwapFacet.sol](https://github.com/code-423n4/2022-03-lifinance/blob/main/src/Facets/GenericSwapFacet.sol)\n\nRemaining or unaccounted ERC20 balance could be freely taken through `swapTokensGenerics` and `swap`.\n\n### Proof of Concept\n\n    function swap(bytes32 transactionId, SwapData calldata _swapData) internal {\n            uint256 fromAmount = _swapData.fromAmount;\n            uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);\n            address fromAssetId = _swapData.sendingAssetId;\n            if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {\n                LibAsset.transferFromERC20(fromAssetId, msg.sender, address(this), fromAmount);\n            }\n\n            if (!LibAsset.isNativeAsset(fromAssetId)) {\n                LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);\n            }\n\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);\n            if (!success) {\n                string memory reason = LibUtil.getRevertMsg(res);\n                revert(reason);\n            }\n\n            toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;\n\nGiven:\n\n*   There has been a deposit to LiFi of a non-native ERC20 that makes `LibAsset.getOwnBalance(fromAssetId)` a desirable amount.\n\n*   Attacker calls `swapTokensGeneric` with a `_swapData.fromAmount` value just below `LibAsset.getOwnBalance(fromAssetId)`.\n\n*   First `if` statement in `swap` is skipped (no funds are tranferred to LiFis contract).\n\n<!---->\n\n    if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {\n                LibAsset.transferFromERC20(fromAssetId, msg.sender, address(this), fromAmount);\n            }\n\n*   Swap happens and increases `LibAsset.getOwnBalance(_lifiData.receivingAssetId)`\n*   Difference of LiFis balance of the receiving token before and after swap is calculated using `postSwapBalance` and transfered to attacker.\n\n### Recommended Mitigation Steps\n\nEnsure funds are always subtracted from users account in `swap`, even if LiFi has enough balance to do the swap.\n\n**[H3xept (Li.Fi) acknowledged and commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/66#issuecomment-1096366089):**\n > We are aware that the contract allows users to use latent funds, although we disagree on it being an issue as **no funds** (ERC20 or native) should ever lay in the contract. To make sure that no value is ever kept by the diamond, we now provide refunds for outstanding user value (after bridges/swaps).\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/66#issuecomment-1100698703):**\n > Keeping this as Med Risk. There can be fund leftover in the contract under normal operation, for example [this tx](https://etherscan.io/tx/0xe78c36dd2c2f21cade00a4099701b9c9f82acc8da568e1048a4d7287ce2e45b0). In fact, ~\\$300 worth of token is left in the LI.Fi smart contract on ETH mainnet [0x5a9fd7c39a6c488e715437d7b1f3c823d5596ed1](https://etherscan.io/address/0x5a9fd7c39a6c488e715437d7b1f3c823d5596ed1) as of block 14597316. I don't think this is High Risk because the max amount lost is no more than allowed slippage, which can be loss to MEV too.\n\n**[ezynda3 (Li.Fi) resolved and commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/66#issuecomment-1115936416):**\n > This has been fixed in the most recent version of `src/Helpers/Swapper.sol` which sweeps any latent funds back to the user's wallet.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-03-lifinance",
  "Code": [
    {
      "filename": "src/Libraries/LibSwap.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { LibAsset, IERC20 } from \"./LibAsset.sol\";\nimport { LibUtil } from \"./LibUtil.sol\";\n\nlibrary LibSwap {\n    uint256 private constant MAX_INT = 2**256 - 1;\n\n    struct SwapData {\n        address callTo;\n        address approveTo;\n        address sendingAssetId;\n        address receivingAssetId;\n        uint256 fromAmount;\n        bytes callData;\n    }\n\n    event AssetSwapped(\n        bytes32 transactionId,\n        address dex,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount,\n        uint256 timestamp\n    );\n\n    function swap(bytes32 transactionId, SwapData calldata _swapData) internal {\n        uint256 fromAmount = _swapData.fromAmount;\n        uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);\n        address fromAssetId = _swapData.sendingAssetId;\n        if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {\n            LibAsset.transferFromERC20(fromAssetId, msg.sender, address(this), fromAmount);\n        }\n\n        if (!LibAsset.isNativeAsset(fromAssetId)) {\n            LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);\n        if (!success) {\n            string memory reason = LibUtil.getRevertMsg(res);\n            revert(reason);\n        }\n\n        toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;\n        emit AssetSwapped(\n            transactionId,\n            _swapData.callTo,\n            _swapData.sendingAssetId,\n            _swapData.receivingAssetId,\n            fromAmount,\n            toAmount,\n            block.timestamp\n        );\n    }\n}"
    }
  ]
}