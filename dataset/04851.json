{
  "Title": "[G-19] Checking balance after the transfer cannot underflow, thus can be unchecked",
  "Content": "\n**File:** `L1ERC20Bridge.sol`\n\nThis issue has been reported as separate finding, as it uses different invariant for underflow detection. While another finding uses the invariant that subtraction won't underflow, because `require` guarantees that subtrahend is lower than minuend, this one utilizes the fact that after the transfer, the balance cannot be lower then the balance before the transfer, thus line 165 won't underflow and can be unchecked.\n\n[File: code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L161)\n```solidity\n161:         uint256 balanceBefore = _token.balanceOf(address(sharedBridge));\n162:         _token.safeTransferFrom(_from, address(sharedBridge), _amount);\n163:         uint256 balanceAfter = _token.balanceOf(address(sharedBridge));\n164: \n165:         return balanceAfter - balanceBefore;\n```\n\nBalance after the transfer cannot be lower then before the transfer, thus `balanceAfter - balanceBefore` won't underflow and can be unchecked.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IL1ERC20Bridge} from \"./interfaces/IL1ERC20Bridge.sol\";\nimport {IL1SharedBridge} from \"./interfaces/IL1SharedBridge.sol\";\n\nimport {L2ContractHelper} from \"../common/libraries/L2ContractHelper.sol\";\nimport {ReentrancyGuard} from \"../common/ReentrancyGuard.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Smart contract that allows depositing ERC20 tokens from Ethereum to hyperchains\n/// @dev It is a legacy bridge from zkSync Era, that was deprecated in favour of shared bridge.\n/// It is needed for backward compatibility with already integrated projects.\ncontract L1ERC20Bridge is IL1ERC20Bridge, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @dev The shared bridge that is now used for all bridging, replacing the legacy contract.\n    IL1SharedBridge public immutable override sharedBridge;\n\n    /// @dev A mapping L2 batch number => message number => flag.\n    /// @dev Used to indicate that L2 -> L1 message was already processed for zkSync Era withdrawals.\n    mapping(uint256 l2BatchNumber => mapping(uint256 l2ToL1MessageNumber => bool isFinalized))\n        public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount.\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail in zkSync Era.\n    mapping(address account => mapping(address l1Token => mapping(bytes32 depositL2TxHash => uint256 amount)))\n        public depositAmount;\n\n    /// @dev The address that is used as a L2 bridge counterpart in zkSync Era.\n    address public l2Bridge;\n\n    /// @dev The address that is used as a beacon for L2 tokens in zkSync Era.\n    address public l2TokenBeacon;\n\n    /// @dev Stores the hash of the L2 token proxy contract's bytecode on zkSync Era.\n    bytes32 public l2TokenProxyBytecodeHash;\n\n    /// @dev Deprecated storage variable related to withdrawal limitations.\n    mapping(address => uint256) private __DEPRECATED_lastWithdrawalLimitReset;\n\n    /// @dev Deprecated storage variable related to withdrawal limitations.\n    mapping(address => uint256) private __DEPRECATED_withdrawnAmountInWindow;\n\n    /// @dev Deprecated storage variable related to deposit limitations.\n    mapping(address => mapping(address => uint256)) private __DEPRECATED_totalDepositedAmountPerUser;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IL1SharedBridge _sharedBridge) reentrancyGuardInitializer {\n        sharedBridge = _sharedBridge;\n    }\n\n    /// @dev Initializes the reentrancy guard. Expected to be used in the proxy.\n    function initialize() external reentrancyGuardInitializer {}\n\n    /// @dev transfer token to shared bridge as part of upgrade\n    function tranferTokenToSharedBridge(address _token, uint256 _amount) external {\n        require(msg.sender == address(sharedBridge), \"Not shared bridge\");\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        require(amount == _amount, \"Incorrect amount\");\n        IERC20(_token).safeTransfer(address(sharedBridge), amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERA LEGACY GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @return The L2 token address that would be minted for deposit of the given L1 token on zkSync Era.\n    function l2TokenAddress(address _l1Token) external view returns (address) {\n        bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, \"\"));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERA LEGACY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Legacy deposit method with refunding the fee to the caller, use another `deposit` method instead.\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    /// NOTE: the function doesn't use `nonreentrant` modifier, because the inner method does.\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte\n    ) external payable returns (bytes32 l2TxHash) {\n        l2TxHash = deposit(_l2Receiver, _l1Token, _amount, _l2TxGasLimit, _l2TxGasPerPubdataByte, address(0));\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// @dev Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) public payable nonReentrant returns (bytes32 l2TxHash) {\n        require(_amount != 0, \"0T\"); // empty deposit\n        uint256 amount = _depositFundsToSharedBridge(msg.sender, IERC20(_l1Token), _amount);\n        require(amount == _amount, \"3T\"); // The token has non-standard transfer logic\n\n        l2TxHash = sharedBridge.depositLegacyErc20Bridge{value: msg.value}(\n            msg.sender,\n            _l2Receiver,\n            _l1Token,\n            _amount,\n            _l2TxGasLimit,\n            _l2TxGasPerPubdataByte,\n            _refundRecipient\n        );\n        depositAmount[msg.sender][_l1Token][l2TxHash] = _amount;\n        emit DepositInitiated(l2TxHash, msg.sender, _l2Receiver, _l1Token, _amount);\n    }\n\n    /// @dev Transfers tokens from the depositor address to the shared bridge address.\n    /// @return The difference between the contract balance before and after the transferring of funds.\n    function _depositFundsToSharedBridge(address _from, IERC20 _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = _token.balanceOf(address(sharedBridge));\n        _token.safeTransferFrom(_from, address(sharedBridge), _amount);\n        uint256 balanceAfter = _token.balanceOf(address(sharedBridge));\n\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2.\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 ERC20 token\n    /// @param _l2TxHash The L2 transaction hash of the failed deposit finalization\n    /// @param _l2BatchNumber The L2 batch number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in a batch, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        uint256 amount = depositAmount[_depositSender][_l1Token][_l2TxHash];\n        require(amount != 0, \"2T\"); // empty deposit\n        delete depositAmount[_depositSender][_l1Token][_l2TxHash];\n\n        sharedBridge.claimFailedDepositLegacyErc20Bridge(\n            _depositSender,\n            _l1Token,\n            amount,\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof\n        );\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BatchNumber The L2 batch number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBatch The L2 transaction number in the batch, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        require(!isWithdrawalFinalized[_l2BatchNumber][_l2MessageIndex], \"pw\");\n        // We don't need to set finalizeWithdrawal here, as we set it in the shared bridge\n\n        (address l1Receiver, address l1Token, uint256 amount) = sharedBridge.finalizeWithdrawalLegacyErc20Bridge(\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _message,\n            _merkleProof\n        );\n        emit WithdrawalFinalized(l1Receiver, l1Token, amount);\n    }\n}"
    }
  ]
}