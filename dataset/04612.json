{
  "Title": "ERC20 decimals field should be uint8",
  "Content": "The decimals field of the token is defined as `uint256` both in [`CrowdsaleToken`](https://github.com/CoinFabrik/ico/blob/142f43f3bec4afd0ffff3fce06946cf67cb0272f/contracts/CrowdsaleToken.sol#L31) and [`FractionalERC20`](https://github.com/CoinFabrik/ico/blob/142f43f3bec4afd0ffff3fce06946cf67cb0272f/contracts/FractionalERC20.sol#L14). It is, however, [defined as `uint8`](https://github.com/frozeman/EIPs/blob/94bc4311e889c2c58c561c074be1483f48ac9374/EIPS/eip-20-token-standard.md#decimals) in the ERC20 standard. Consider changing the type to `uint8`.\n\n\n**Update:** Hubii replied *“We have updated the contracts to reflect the standard and declared decimals as `uint8`.”* Fixed in [`312d8be8002dc99074dbd2a0a6db1075cc5623ed`](https://github.com/CoinFabrik/ico/commit/312d8be8002dc99074dbd2a0a6db1075cc5623ed).\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/CrowdsaleToken.sol",
      "content": "pragma solidity ^0.4.11;\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n\nimport \"./ReleasableToken.sol\";\nimport \"./MintableToken.sol\";\nimport \"./UpgradeableToken.sol\";\n\n/**\n * A crowdsale token.\n *\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\n *\n * - The token transfer() is disabled until the crowdsale is over\n * - The token contract gives an opt-in upgrade path to a new contract\n * - The same token can be part of several crowdsales through the approve() mechanism\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\n *\n */\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\n\n  event UpdatedTokenInformation(string newName, string newSymbol);\n\n  string public name;\n\n  string public symbol;\n\n  uint public decimals;\n\n  /**\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   *\n   * @param _name Token name\n   * @param _symbol Token symbol - typically it's all caps\n   * @param _initialSupply How many tokens we start with\n   * @param _decimals Number of decimal places\n   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\n   */\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\n    UpgradeableToken(msg.sender) {\n    // The message sender is the owner initially.\n    // It can be transferred to another team multisig via changeOwner().\n    // When doing so, remember to call setUpgradeMaster() too.\n\n    name = _name;\n    symbol = _symbol;\n\n    totalSupply = _initialSupply;\n\n    decimals = _decimals;\n\n    // Create initially all balance on the team multisig\n    balances[owner] = totalSupply;\n\n    if(totalSupply > 0) {\n      Minted(owner, totalSupply);\n    }\n\n    // No more new supply allowed after the token creation\n    mintingFinished = !_mintable;\n    // Cannot create a token without supply and no minting\n    require(_mintable || totalSupply != 0);\n  }\n\n  /**\n   * When token is released to be transferable, prohibit new token creation.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /**\n   * Allow upgrade agent functionality to kick in only if the crowdsale was a success.\n   */\n  function canUpgrade() public constant returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  /**\n   * Owner can update token information here\n   */\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\n    name = _name;\n    symbol = _symbol;\n\n    UpdatedTokenInformation(name, symbol);\n  }\n\n}"
    }
  ]
}