{
  "Title": "[L-04] Reverts on 0 transfer",
  "Content": "It deposits 0 amount to the staking contract to claim rewards but it might revert [during the 0 transfer](https://github.com/stargate-protocol/stargate/blob/main/contracts/LPStaking.sol#L161). There is no problem with the current `lpToken` but good to keep in mind.\n\n- https://github.com/reserve-protocol/protocol/blob/9ee60f142f9f5c1fe8bc50eef915cf33124a534f/contracts/plugins/assets/stargate/StargateRewardableWrapper.sol#L48\n\n```solidity\nstakingContract.deposit(poolId, 0);\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-reserve",
  "Code": [
    {
      "filename": "contracts/LPStaking.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\n\n// imports\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./StargateToken.sol\";\n\n// interfaces\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// libraries\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract LPStaking is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount; // How many LP tokens the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of STGs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accStargatePerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accStargatePerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken; // Address of LP token contract.\n        uint256 allocPoint; // How many allocation points assigned to this pool. STGs to distribute per block.\n        uint256 lastRewardBlock; // Last block number that STGs distribution occurs.\n        uint256 accStargatePerShare; // Accumulated STGs per share, times 1e12. See below.\n    }\n    // The STG TOKEN!\n    StargateToken public stargate;\n    // Block number when bonus STG period ends.\n    uint256 public bonusEndBlock;\n    // STG tokens created per block.\n    uint256 public stargatePerBlock;\n    // Bonus multiplier for early stargate makers.\n    uint256 public constant BONUS_MULTIPLIER = 1;\n    // Track which tokens have been added.\n    mapping(address => bool) private addedLPTokens;\n\n    mapping(uint256 => uint256) public lpBalances;\n\n    // Info of each pool.\n    PoolInfo[] public poolInfo;\n    // Info of each user that stakes LP tokens.\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint256 public totalAllocPoint = 0;\n    // The block number when STG mining starts.\n    uint256 public startBlock;\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n\n    constructor(\n        StargateToken _stargate,\n        uint256 _stargatePerBlock,\n        uint256 _startBlock,\n        uint256 _bonusEndBlock\n    ) {\n        require(_startBlock >= block.number, \"LPStaking: _startBlock must be >= current block\");\n        require(_bonusEndBlock >= _startBlock, \"LPStaking: _bonusEndBlock must be > than _startBlock\");\n        require(address(_stargate) != address(0x0), \"Stargate: _stargate cannot be 0x0\");\n        stargate = _stargate;\n        stargatePerBlock = _stargatePerBlock;\n        startBlock = _startBlock;\n        bonusEndBlock = _bonusEndBlock;\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    /// @notice handles adding a new LP token (Can only be called by the owner)\n    /// @param _allocPoint The alloc point is used as the weight of the pool against all other alloc points added.\n    /// @param _lpToken The lp token address\n    function add(uint256 _allocPoint, IERC20 _lpToken) public onlyOwner {\n        massUpdatePools();\n        require(address(_lpToken) != address(0x0), \"StarGate: lpToken cant be 0x0\");\n        require(addedLPTokens[address(_lpToken)] == false, \"StarGate: _lpToken already exists\");\n        addedLPTokens[address(_lpToken)] = true;\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n        poolInfo.push(PoolInfo({lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accStargatePerShare: 0}));\n    }\n\n    function set(uint256 _pid, uint256 _allocPoint) public onlyOwner {\n        massUpdatePools();\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\n        poolInfo[_pid].allocPoint = _allocPoint;\n    }\n\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\n        if (_to <= bonusEndBlock) {\n            return _to.sub(_from).mul(BONUS_MULTIPLIER);\n        } else if (_from >= bonusEndBlock) {\n            return _to.sub(_from);\n        } else {\n            return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add(_to.sub(bonusEndBlock));\n        }\n    }\n\n    function pendingStargate(uint256 _pid, address _user) external view returns (uint256) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accStargatePerShare = pool.accStargatePerShare;\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n            uint256 stargateReward = multiplier.mul(stargatePerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n            accStargatePerShare = accStargatePerShare.add(stargateReward.mul(1e12).div(lpSupply));\n        }\n        return user.amount.mul(accStargatePerShare).div(1e12).sub(user.rewardDebt);\n    }\n\n    function massUpdatePools() public {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint256 stargateReward = multiplier.mul(stargatePerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n\n        pool.accStargatePerShare = pool.accStargatePerShare.add(stargateReward.mul(1e12).div(lpSupply));\n        pool.lastRewardBlock = block.number;\n    }\n\n    function deposit(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) {\n            uint256 pending = user.amount.mul(pool.accStargatePerShare).div(1e12).sub(user.rewardDebt);\n            safeStargateTransfer(msg.sender, pending);\n        }\n        pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n        user.amount = user.amount.add(_amount);\n        user.rewardDebt = user.amount.mul(pool.accStargatePerShare).div(1e12);\n        lpBalances[_pid] = lpBalances[_pid].add(_amount);\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    function withdraw(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"withdraw: _amount is too large\");\n        updatePool(_pid);\n        uint256 pending = user.amount.mul(pool.accStargatePerShare).div(1e12).sub(user.rewardDebt);\n        safeStargateTransfer(msg.sender, pending);\n        user.amount = user.amount.sub(_amount);\n        user.rewardDebt = user.amount.mul(pool.accStargatePerShare).div(1e12);\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n        lpBalances[_pid] = lpBalances[_pid].sub(_amount);\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n\n    /// @notice Withdraw without caring about rewards.\n    /// @param _pid The pid specifies the pool\n    function emergencyWithdraw(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 userAmount = user.amount;\n        user.amount = 0;\n        user.rewardDebt = 0;\n        pool.lpToken.safeTransfer(address(msg.sender), userAmount);\n        lpBalances[_pid] = lpBalances[_pid].sub(userAmount);\n        emit EmergencyWithdraw(msg.sender, _pid, userAmount);\n    }\n\n    /// @notice Safe transfer function, just in case if rounding error causes pool to not have enough STGs.\n    /// @param _to The address to transfer tokens to\n    /// @param _amount The quantity to transfer\n    function safeStargateTransfer(address _to, uint256 _amount) internal {\n        uint256 stargateBal = stargate.balanceOf(address(this));\n        if (_amount > stargateBal) {\n            IERC20(stargate).safeTransfer(_to, stargateBal);\n        } else {\n            IERC20(stargate).safeTransfer(_to, _amount);\n        }\n    }\n\n    function setStargatePerBlock(uint256 _stargatePerBlock) external onlyOwner {\n        massUpdatePools();\n        stargatePerBlock = _stargatePerBlock;\n    }\n\n    // Override the renounce ownership inherited by zeppelin ownable\n    function renounceOwnership() public override onlyOwner {}\n}"
    },
    {
      "filename": "contracts/plugins/assets/stargate/StargateRewardableWrapper.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity ^0.8.19;\n\nimport \"./interfaces/IStargateLPStaking.sol\";\nimport \"./interfaces/IStargatePool.sol\";\n\nimport \"../erc20/RewardableERC20Wrapper.sol\";\n\ncontract StargateRewardableWrapper is RewardableERC20Wrapper {\n    IStargateLPStaking public immutable stakingContract;\n    IStargatePool public immutable pool;\n    IERC20 public immutable stargate;\n    uint256 public immutable poolId;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        IERC20 stargate_,\n        IStargateLPStaking stakingContract_,\n        IStargatePool pool_\n    ) RewardableERC20Wrapper(pool_, name_, symbol_, stargate_) {\n        require(\n            address(stargate_) != address(0) &&\n                address(stakingContract_) != address(0) &&\n                address(pool_) != address(0),\n            \"Invalid address\"\n        );\n\n        uint256 poolLength = stakingContract_.poolLength();\n        uint256 pid = type(uint256).max;\n        for (uint256 i = 0; i < poolLength; ++i) {\n            if (address(stakingContract_.poolInfo(i).lpToken) == address(pool_)) {\n                pid = i;\n                break;\n            }\n        }\n        require(pid != type(uint256).max, \"Invalid pool\");\n\n        pool_.approve(address(stakingContract_), type(uint256).max); // TODO: Change this!\n\n        pool = pool_;\n        poolId = pid;\n        stakingContract = stakingContract_;\n        stargate = stargate_;\n    }\n\n    function _claimAssetRewards() internal override {\n        stakingContract.deposit(poolId, 0);\n    }\n\n    function _afterDeposit(uint256 _amount, address to) internal override {\n        require(to == msg.sender, \"Only the sender can deposit\");\n\n        stakingContract.deposit(poolId, _amount);\n    }\n\n    function _beforeWithdraw(uint256 _amount, address to) internal override {\n        require(to == msg.sender, \"Only the sender can withdraw\");\n\n        stakingContract.withdraw(poolId, _amount);\n    }\n}"
    }
  ]
}