{
  "Title": "M-2: price is calculated wrongly in BoundedStepwiseExponentialPriceAdapter",
  "Content": "# Issue M-2: price is calculated wrongly in BoundedStepwiseExponentialPriceAdapter \n\nSource: https://github.com/sherlock-audit/2023-06-Index-judging/issues/39 \n\n## Found by \n0x007, 0x52, Brenzee, auditsea, dany.armstrong90\n## Summary\nThe BoundedStepwiseExponentialPriceAdapter contract is trying to implement price change as `scalingFactor * (e^x - 1)` but the code implements `scalingFactor * e^x - 1`. Since there are no brackets, multiplication would be executed before subtraction. And this has been confirmed with one of the team members.\n\n## Vulnerability Detail\nThe [getPrice code](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L40-L73) has been simplified as the following when boundary/edge cases are ignored\n\n```solidity\n(\n    uint256 initialPrice,\n    uint256 scalingFactor,\n    uint256 timeCoefficient,\n    uint256 bucketSize,\n    bool isDecreasing,\n    uint256 maxPrice,\n    uint256 minPrice\n) = getDecodedData(_priceAdapterConfigData);\n\nuint256 timeBucket = _timeElapsed / bucketSize;\n\nint256 expArgument = int256(timeCoefficient * timeBucket);\n\nuint256 expExpression = uint256(FixedPointMathLib.expWad(expArgument));\n\nuint256 priceChange = scalingFactor * expExpression - WAD;\n```\n\nWhen timeBucket is 0, we want priceChange to be 0, so that the returned price would be the initial price. Since `e^0 = 1`, we need to subtract 1 (in WAD) from the `expExpression`. \n\nHowever, with the incorrect implementation, the returned price would be different than real price by a value equal to `scalingFactor - 1`. The image below shows the difference between the right and wrong formula when initialPrice is 100 and scalingFactor is 11. The right formula starts at 100 while the wrong one starts at 110=100+11-1\n\n![newplot (11)](https://github.com/sherlock-audit/2023-06-Index-bizzyvinci/assets/22333930/56cfc3e4-2bca-40d3-99bd-9e02df94bf33)\n\n\n\n## Impact\nIncorrect price is returned from BoundedStepwiseExponentialPriceAdapter and that will have devastating effects on rebalance.\n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L73\n\n## Tool used\n\nManual Review\n\n## Recommendation\nChange the following [line](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L73)\n```solidity\n- uint256 priceChange = scalingFactor * expExpression - WAD;\n+ uint256 priceChange = scalingFactor * (expExpression - WAD);\n```\n\n\n\n## Discussion\n\n**pblivin0x**\n\nConfirmed âœ…\n\n**IAm0x52**\n\nEscalate\n\nThis should be medium not high. While it is true that the calculation will be wrong for scaling factors other than 1, it heavily depends on the configuration of auction settings as to whether this sells assets at a bad price and causes a loss to the set token.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This should be medium not high. While it is true that the calculation will be wrong for scaling factors other than 1, it heavily depends on the configuration of auction settings as to whether this sells assets at a bad price and causes a loss to the set token.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**pblivin0x**\n\n> Escalate\n> \n> This should be medium not high. While it is true that the calculation will be wrong for scaling factors other than 1, it heavily depends on the configuration of auction settings as to whether this sells assets at a bad price and causes a loss to the set token.\n\nAgree here this should be a medium not a high\n\n1) manager's are expected to preview full auction price curves ahead of a `startRebalance` call by calling the pure function `getPrice` with input `_timeElapsed` in the range `[0, _duration]`\n\n2) the difference is not catastrophic, it is a shift that stays constant throughout the auction https://colab.research.google.com/drive/1ZkXs2MuTJFaWUU611KolNXQ52zh9k3VM?usp=sharing\n\n![issue_39](https://github.com/sherlock-audit/2023-06-Index-judging/assets/84149824/64dbbd35-c5d8-4e0a-b952-67b6da0e8d2e)\n\n\n**bizzyvinci**\n\n> manager's are expected to preview full auction price curves ahead of a startRebalance call by calling the pure function getPrice with input _timeElapsed in the range [0, _duration]\n\ngetPrice only takes in one _timeElapsed (not array), so managers can't view full curve. Also, the curve is directly affected by `timeBucket`, rather than `_timeElapsed`. Different `_timeElapsed` could give the same price depending on bucketSize. There's hardly a simulation or plotting tool for solidity, so it might be done in other languages like we're doing right now.\n\n> the difference is not catastrophic\n\nIt could be very catastrophic mainly because it affects priceChange (which would then be added or subtracted from price). WE DON'T KNOW WHAT INITIAL PRICE IS. It could be `10,000`, it could `20`, it could be `0.1`, it could be `1e-12`.\n\n## POC\n* A manager wants to switch stablecoins. He wants to buy DAI and Sell USDT at a price of minimum and initial price of `1` and increasing to `1.05`.\n* Technically, the price is not 1, but rather `1e-12` because of decimals `1e6/1e18` (1e6 in WAD)\n\n### With the right formula\n* If he uses the scalingFactor of `2`, the priceChange at `t0` would be 0\n* Therefore bidder would have to pay 1e18 DAI for 1e6USDT.\n\n### With the wrong formula\n* If he uses the scalingFactor of `2`, the priceChange at `t0` would `1` (1e18 in WAD) instead of `0`\n* Therefore the price would increase by a magnitude 1e12. \n* Therefore, bidder would pay approximately 1e18 DAI for 1e6 * 1e12 USDT.\n* Attacker could take 1e12 (1 trillion USDT) with one DAI in a flash.\n* Or if there's not enough liquidity e.g if there's only 1m USDT, then he'll pay `1e-12` DAI. That's less than a penny.\n\n\n**bizzyvinci**\n\nMy bad, I agree with Med cause the catastrophe is bounded by min and [max](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L86) value.\n\n**pblivin0x**\n\n> My bad, I agree with Med cause the catastrophe is bounded by min and [max](https://github.com/sherlock-audit/2023-06-Index/blob/main/index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L86) value.\n\nI think we all agree this should be de-escalated to a Medium\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates \nConsidering this a valid medium based on the above comments. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-06-Index-judging/issues/39/#issuecomment-1660521258): accepted\n\n**pblivin0x**\n\nThe remediation for this issue is open for review here https://github.com/IndexCoop/index-protocol/pull/25\n\nThe fix to the formula is here: https://github.com/IndexCoop/index-protocol/blob/839a6c699cc9217c8ee9f3b67418c64e80f0e10d/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol#L73\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/91",
  "Code": [
    {
      "filename": "index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\n\n/**\n * @title BoundedStepwiseExponentialPriceAdapter\n * @author Index Coop\n * @notice Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that\n * increases or decreases exponentially in steps over time, within a bounded range.\n * The rate of change is increasing.\n * Price formula: price = initialPrice +/- scalingFactor * e ^ (timeCoefficient * timeBucket)\n */\ncontract BoundedStepwiseExponentialPriceAdapter {\n    using FixedPointMathLib for int256;\n\n    uint256 constant WAD = 1e18;            // Equivalent to PreciseUnitMath.preciseUnit()\n    int256 constant MAX_EXP_ARG = 100e18;   // To protect against overflow and increasing relative error\n\n    /**\n     * @dev Calculates and returns the exponential price.\n     *\n     * @param _timeElapsed              Time elapsed since the start of the auction.\n     * @param _priceAdapterConfigData   Encoded bytes representing the exponential function parameters.\n     *\n     * @return price                    The price calculated using the exponential function.\n     */\n    function getPrice(\n        address /* _setToken */,\n        address /* _component */,\n        uint256 /* _componentQuantity */,\n        uint256 _timeElapsed,\n        uint256 /* _duration */,\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (uint256 price)\n    {\n        (\n            uint256 initialPrice,\n            uint256 scalingFactor,\n            uint256 timeCoefficient,\n            uint256 bucketSize,\n            bool isDecreasing,\n            uint256 maxPrice,\n            uint256 minPrice\n        ) = getDecodedData(_priceAdapterConfigData);\n\n        require(\n            areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice), \n            \"BoundedStepwiseExponentialPriceAdapter: Invalid params\"\n        );\n\n        uint256 timeBucket = _timeElapsed / bucketSize;\n\n        // Protect against exponential argument overflow\n        if (timeBucket > type(uint256).max / timeCoefficient) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        int256 expArgument = int256(timeCoefficient * timeBucket);\n        \n        // Protect against exponential overflow and increasing relative error\n        if (expArgument > MAX_EXP_ARG) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        uint256 expExpression = uint256(FixedPointMathLib.expWad(expArgument));\n\n        // Protect against priceChange overflow\n        if (scalingFactor > type(uint256).max / expExpression) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        uint256 priceChange = scalingFactor * expExpression - WAD;\n\n        if (isDecreasing) {\n            // Protect against price underflow\n            if (priceChange > initialPrice) {\n                return minPrice;\n            }\n            return FixedPointMathLib.max(initialPrice - priceChange , minPrice);\n        } else {\n            // Protect against price overflow\n            if (priceChange > type(uint256).max - initialPrice) {\n                return maxPrice;\n            }\n            return FixedPointMathLib.min(initialPrice + priceChange, maxPrice);\n        }\n    }\n\n    /**\n     * @dev Returns true if the price adapter is valid for the given parameters.\n     * \n     * @param _priceAdapterConfigData   Encoded data for configuring the price adapter.\n     * \n     * @return isValid                  Boolean indicating if the adapter config data is valid.\n     */\n    function isPriceAdapterConfigDataValid(\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (bool isValid)\n    {\n        (\n            uint256 initialPrice,\n            uint256 scalingFactor,\n            uint256 timeCoefficient,\n            uint256 bucketSize,\n            ,\n            uint256 maxPrice,\n            uint256 minPrice\n        ) = getDecodedData(_priceAdapterConfigData);\n\n        return areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice);\n    }\n\n    /**\n     * @dev Returns true if the price adapter parameters are valid.\n     * \n     * @param _initialPrice      Initial price of the auction\n     * @param _scalingFactor     Scaling factor for exponential expression\n     * @param _timeCoefficient   Scaling factor for exponential argument\n     * @param _bucketSize        Time elapsed between each bucket\n     * @param _maxPrice          Maximum price of the auction\n     * @param _minPrice          Minimum price of the auction\n     */\n    function areParamsValid(\n        uint256 _initialPrice,\n        uint256 _scalingFactor,\n        uint256 _timeCoefficient,\n        uint256 _bucketSize,\n        uint256 _maxPrice,\n        uint256 _minPrice\n    )\n        public\n        pure\n        returns (bool)\n    {\n        return _initialPrice > 0\n            && _scalingFactor > 0\n            && _timeCoefficient > 0\n            && _bucketSize > 0\n            && _initialPrice <= _maxPrice\n            && _initialPrice >= _minPrice;\n    }\n\n    /**\n     * @dev Returns the encoded data for the price curve parameters\n     * \n     * @param _initialPrice        Initial price of the auction\n     * @param _scalingFactor       Scaling factor for exponential expression\n     * @param _timeCoefficient     Scaling factor for exponential argument\n     * @param _bucketSize          Time elapsed between each bucket\n     * @param _isDecreasing        Flag for whether the price is decreasing or increasing\n     * @param _maxPrice            Maximum price of the auction\n     * @param _minPrice            Minimum price of the auction\n     */\n    function getEncodedData(\n        uint256 _initialPrice,\n        uint256 _scalingFactor,\n        uint256 _timeCoefficient,\n        uint256 _bucketSize,\n        bool _isDecreasing,\n        uint256 _maxPrice,\n        uint256 _minPrice\n    )\n        external\n        pure\n        returns (bytes memory data)\n    {\n        return abi.encode(_initialPrice, _scalingFactor, _timeCoefficient, _bucketSize, _isDecreasing, _maxPrice, _minPrice);\n    }\n\n    /**\n     * @dev Decodes the parameters from the provided bytes.\n     *\n     * @param _data                Bytes encoded auction parameters\n     * @return initialPrice        Initial price of the auction\n     * @return scalingFactor       Scaling factor for exponential expression\n     * @return timeCoefficient     Scaling factor for exponential argument\n     * @return bucketSize          Time elapsed between each bucket\n     * @return isDecreasing        Flag for whether the price is decreasing or increasing\n     * @return maxPrice            Maximum price of the auction\n     * @return minPrice            Minimum price of the auction\n     */\n    function getDecodedData(bytes memory _data)\n        public\n        pure\n        returns (uint256 initialPrice, uint256 scalingFactor, uint256 timeCoefficient, uint256 bucketSize, bool isDecreasing, uint256 maxPrice, uint256 minPrice)\n    {\n        return abi.decode(_data, (uint256, uint256, uint256, uint256, bool, uint256, uint256));\n    }\n\n    function _getBoundaryPrice(bool isDecreasing, uint256 maxPrice, uint256 minPrice) private pure returns (uint256) {\n        return isDecreasing ? minPrice : maxPrice;\n    }\n}"
    },
    {
      "filename": "index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\n\n/**\n * @title BoundedStepwiseExponentialPriceAdapter\n * @author Index Coop\n * @notice Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that\n * increases or decreases exponentially in steps over time, within a bounded range.\n * The rate of change is increasing.\n * Price formula: price = initialPrice +/- scalingFactor * e ^ (timeCoefficient * timeBucket)\n */\ncontract BoundedStepwiseExponentialPriceAdapter {\n    using FixedPointMathLib for int256;\n\n    uint256 constant WAD = 1e18;            // Equivalent to PreciseUnitMath.preciseUnit()\n    int256 constant MAX_EXP_ARG = 100e18;   // To protect against overflow and increasing relative error\n\n    /**\n     * @dev Calculates and returns the exponential price.\n     *\n     * @param _timeElapsed              Time elapsed since the start of the auction.\n     * @param _priceAdapterConfigData   Encoded bytes representing the exponential function parameters.\n     *\n     * @return price                    The price calculated using the exponential function.\n     */\n    function getPrice(\n        address /* _setToken */,\n        address /* _component */,\n        uint256 /* _componentQuantity */,\n        uint256 _timeElapsed,\n        uint256 /* _duration */,\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (uint256 price)\n    {\n        (\n            uint256 initialPrice,\n            uint256 scalingFactor,\n            uint256 timeCoefficient,\n            uint256 bucketSize,\n            bool isDecreasing,\n            uint256 maxPrice,\n            uint256 minPrice\n        ) = getDecodedData(_priceAdapterConfigData);\n\n        require(\n            areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice), \n            \"BoundedStepwiseExponentialPriceAdapter: Invalid params\"\n        );\n\n        uint256 timeBucket = _timeElapsed / bucketSize;\n\n        // Protect against exponential argument overflow\n        if (timeBucket > type(uint256).max / timeCoefficient) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        int256 expArgument = int256(timeCoefficient * timeBucket);\n        \n        // Protect against exponential overflow and increasing relative error\n        if (expArgument > MAX_EXP_ARG) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        uint256 expExpression = uint256(FixedPointMathLib.expWad(expArgument));\n\n        // Protect against priceChange overflow\n        if (scalingFactor > type(uint256).max / expExpression) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        uint256 priceChange = scalingFactor * expExpression - WAD;\n\n        if (isDecreasing) {\n            // Protect against price underflow\n            if (priceChange > initialPrice) {\n                return minPrice;\n            }\n            return FixedPointMathLib.max(initialPrice - priceChange , minPrice);\n        } else {\n            // Protect against price overflow\n            if (priceChange > type(uint256).max - initialPrice) {\n                return maxPrice;\n            }\n            return FixedPointMathLib.min(initialPrice + priceChange, maxPrice);\n        }\n    }\n\n    /**\n     * @dev Returns true if the price adapter is valid for the given parameters.\n     * \n     * @param _priceAdapterConfigData   Encoded data for configuring the price adapter.\n     * \n     * @return isValid                  Boolean indicating if the adapter config data is valid.\n     */\n    function isPriceAdapterConfigDataValid(\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (bool isValid)\n    {\n        (\n            uint256 initialPrice,\n            uint256 scalingFactor,\n            uint256 timeCoefficient,\n            uint256 bucketSize,\n            ,\n            uint256 maxPrice,\n            uint256 minPrice\n        ) = getDecodedData(_priceAdapterConfigData);\n\n        return areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice);\n    }\n\n    /**\n     * @dev Returns true if the price adapter parameters are valid.\n     * \n     * @param _initialPrice      Initial price of the auction\n     * @param _scalingFactor     Scaling factor for exponential expression\n     * @param _timeCoefficient   Scaling factor for exponential argument\n     * @param _bucketSize        Time elapsed between each bucket\n     * @param _maxPrice          Maximum price of the auction\n     * @param _minPrice          Minimum price of the auction\n     */\n    function areParamsValid(\n        uint256 _initialPrice,\n        uint256 _scalingFactor,\n        uint256 _timeCoefficient,\n        uint256 _bucketSize,\n        uint256 _maxPrice,\n        uint256 _minPrice\n    )\n        public\n        pure\n        returns (bool)\n    {\n        return _initialPrice > 0\n            && _scalingFactor > 0\n            && _timeCoefficient > 0\n            && _bucketSize > 0\n            && _initialPrice <= _maxPrice\n            && _initialPrice >= _minPrice;\n    }\n\n    /**\n     * @dev Returns the encoded data for the price curve parameters\n     * \n     * @param _initialPrice        Initial price of the auction\n     * @param _scalingFactor       Scaling factor for exponential expression\n     * @param _timeCoefficient     Scaling factor for exponential argument\n     * @param _bucketSize          Time elapsed between each bucket\n     * @param _isDecreasing        Flag for whether the price is decreasing or increasing\n     * @param _maxPrice            Maximum price of the auction\n     * @param _minPrice            Minimum price of the auction\n     */\n    function getEncodedData(\n        uint256 _initialPrice,\n        uint256 _scalingFactor,\n        uint256 _timeCoefficient,\n        uint256 _bucketSize,\n        bool _isDecreasing,\n        uint256 _maxPrice,\n        uint256 _minPrice\n    )\n        external\n        pure\n        returns (bytes memory data)\n    {\n        return abi.encode(_initialPrice, _scalingFactor, _timeCoefficient, _bucketSize, _isDecreasing, _maxPrice, _minPrice);\n    }\n\n    /**\n     * @dev Decodes the parameters from the provided bytes.\n     *\n     * @param _data                Bytes encoded auction parameters\n     * @return initialPrice        Initial price of the auction\n     * @return scalingFactor       Scaling factor for exponential expression\n     * @return timeCoefficient     Scaling factor for exponential argument\n     * @return bucketSize          Time elapsed between each bucket\n     * @return isDecreasing        Flag for whether the price is decreasing or increasing\n     * @return maxPrice            Maximum price of the auction\n     * @return minPrice            Minimum price of the auction\n     */\n    function getDecodedData(bytes memory _data)\n        public\n        pure\n        returns (uint256 initialPrice, uint256 scalingFactor, uint256 timeCoefficient, uint256 bucketSize, bool isDecreasing, uint256 maxPrice, uint256 minPrice)\n    {\n        return abi.decode(_data, (uint256, uint256, uint256, uint256, bool, uint256, uint256));\n    }\n\n    function _getBoundaryPrice(bool isDecreasing, uint256 maxPrice, uint256 minPrice) private pure returns (uint256) {\n        return isDecreasing ? minPrice : maxPrice;\n    }\n}"
    },
    {
      "filename": "index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\n\n/**\n * @title BoundedStepwiseExponentialPriceAdapter\n * @author Index Coop\n * @notice Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that\n * increases or decreases exponentially in steps over time, within a bounded range.\n * The rate of change is increasing.\n * Price formula: price = initialPrice +/- scalingFactor * e ^ (timeCoefficient * timeBucket)\n */\ncontract BoundedStepwiseExponentialPriceAdapter {\n    using FixedPointMathLib for int256;\n\n    uint256 constant WAD = 1e18;            // Equivalent to PreciseUnitMath.preciseUnit()\n    int256 constant MAX_EXP_ARG = 100e18;   // To protect against overflow and increasing relative error\n\n    /**\n     * @dev Calculates and returns the exponential price.\n     *\n     * @param _timeElapsed              Time elapsed since the start of the auction.\n     * @param _priceAdapterConfigData   Encoded bytes representing the exponential function parameters.\n     *\n     * @return price                    The price calculated using the exponential function.\n     */\n    function getPrice(\n        address /* _setToken */,\n        address /* _component */,\n        uint256 /* _componentQuantity */,\n        uint256 _timeElapsed,\n        uint256 /* _duration */,\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (uint256 price)\n    {\n        (\n            uint256 initialPrice,\n            uint256 scalingFactor,\n            uint256 timeCoefficient,\n            uint256 bucketSize,\n            bool isDecreasing,\n            uint256 maxPrice,\n            uint256 minPrice\n        ) = getDecodedData(_priceAdapterConfigData);\n\n        require(\n            areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice), \n            \"BoundedStepwiseExponentialPriceAdapter: Invalid params\"\n        );\n\n        uint256 timeBucket = _timeElapsed / bucketSize;\n\n        // Protect against exponential argument overflow\n        if (timeBucket > type(uint256).max / timeCoefficient) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        int256 expArgument = int256(timeCoefficient * timeBucket);\n        \n        // Protect against exponential overflow and increasing relative error\n        if (expArgument > MAX_EXP_ARG) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        uint256 expExpression = uint256(FixedPointMathLib.expWad(expArgument));\n\n        // Protect against priceChange overflow\n        if (scalingFactor > type(uint256).max / expExpression) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        uint256 priceChange = scalingFactor * expExpression - WAD;\n\n        if (isDecreasing) {\n            // Protect against price underflow\n            if (priceChange > initialPrice) {\n                return minPrice;\n            }\n            return FixedPointMathLib.max(initialPrice - priceChange , minPrice);\n        } else {\n            // Protect against price overflow\n            if (priceChange > type(uint256).max - initialPrice) {\n                return maxPrice;\n            }\n            return FixedPointMathLib.min(initialPrice + priceChange, maxPrice);\n        }\n    }\n\n    /**\n     * @dev Returns true if the price adapter is valid for the given parameters.\n     * \n     * @param _priceAdapterConfigData   Encoded data for configuring the price adapter.\n     * \n     * @return isValid                  Boolean indicating if the adapter config data is valid.\n     */\n    function isPriceAdapterConfigDataValid(\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (bool isValid)\n    {\n        (\n            uint256 initialPrice,\n            uint256 scalingFactor,\n            uint256 timeCoefficient,\n            uint256 bucketSize,\n            ,\n            uint256 maxPrice,\n            uint256 minPrice\n        ) = getDecodedData(_priceAdapterConfigData);\n\n        return areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice);\n    }\n\n    /**\n     * @dev Returns true if the price adapter parameters are valid.\n     * \n     * @param _initialPrice      Initial price of the auction\n     * @param _scalingFactor     Scaling factor for exponential expression\n     * @param _timeCoefficient   Scaling factor for exponential argument\n     * @param _bucketSize        Time elapsed between each bucket\n     * @param _maxPrice          Maximum price of the auction\n     * @param _minPrice          Minimum price of the auction\n     */\n    function areParamsValid(\n        uint256 _initialPrice,\n        uint256 _scalingFactor,\n        uint256 _timeCoefficient,\n        uint256 _bucketSize,\n        uint256 _maxPrice,\n        uint256 _minPrice\n    )\n        public\n        pure\n        returns (bool)\n    {\n        return _initialPrice > 0\n            && _scalingFactor > 0\n            && _timeCoefficient > 0\n            && _bucketSize > 0\n            && _initialPrice <= _maxPrice\n            && _initialPrice >= _minPrice;\n    }\n\n    /**\n     * @dev Returns the encoded data for the price curve parameters\n     * \n     * @param _initialPrice        Initial price of the auction\n     * @param _scalingFactor       Scaling factor for exponential expression\n     * @param _timeCoefficient     Scaling factor for exponential argument\n     * @param _bucketSize          Time elapsed between each bucket\n     * @param _isDecreasing        Flag for whether the price is decreasing or increasing\n     * @param _maxPrice            Maximum price of the auction\n     * @param _minPrice            Minimum price of the auction\n     */\n    function getEncodedData(\n        uint256 _initialPrice,\n        uint256 _scalingFactor,\n        uint256 _timeCoefficient,\n        uint256 _bucketSize,\n        bool _isDecreasing,\n        uint256 _maxPrice,\n        uint256 _minPrice\n    )\n        external\n        pure\n        returns (bytes memory data)\n    {\n        return abi.encode(_initialPrice, _scalingFactor, _timeCoefficient, _bucketSize, _isDecreasing, _maxPrice, _minPrice);\n    }\n\n    /**\n     * @dev Decodes the parameters from the provided bytes.\n     *\n     * @param _data                Bytes encoded auction parameters\n     * @return initialPrice        Initial price of the auction\n     * @return scalingFactor       Scaling factor for exponential expression\n     * @return timeCoefficient     Scaling factor for exponential argument\n     * @return bucketSize          Time elapsed between each bucket\n     * @return isDecreasing        Flag for whether the price is decreasing or increasing\n     * @return maxPrice            Maximum price of the auction\n     * @return minPrice            Minimum price of the auction\n     */\n    function getDecodedData(bytes memory _data)\n        public\n        pure\n        returns (uint256 initialPrice, uint256 scalingFactor, uint256 timeCoefficient, uint256 bucketSize, bool isDecreasing, uint256 maxPrice, uint256 minPrice)\n    {\n        return abi.decode(_data, (uint256, uint256, uint256, uint256, bool, uint256, uint256));\n    }\n\n    function _getBoundaryPrice(bool isDecreasing, uint256 maxPrice, uint256 minPrice) private pure returns (uint256) {\n        return isDecreasing ? minPrice : maxPrice;\n    }\n}"
    },
    {
      "filename": "index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\n\n/**\n * @title BoundedStepwiseExponentialPriceAdapter\n * @author Index Coop\n * @notice Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that\n * increases or decreases exponentially in steps over time, within a bounded range.\n * The rate of change is increasing.\n * Price formula: price = initialPrice +/- scalingFactor * e ^ (timeCoefficient * timeBucket)\n */\ncontract BoundedStepwiseExponentialPriceAdapter {\n    using FixedPointMathLib for int256;\n\n    uint256 constant WAD = 1e18;            // Equivalent to PreciseUnitMath.preciseUnit()\n    int256 constant MAX_EXP_ARG = 100e18;   // To protect against overflow and increasing relative error\n\n    /**\n     * @dev Calculates and returns the exponential price.\n     *\n     * @param _timeElapsed              Time elapsed since the start of the auction.\n     * @param _priceAdapterConfigData   Encoded bytes representing the exponential function parameters.\n     *\n     * @return price                    The price calculated using the exponential function.\n     */\n    function getPrice(\n        address /* _setToken */,\n        address /* _component */,\n        uint256 /* _componentQuantity */,\n        uint256 _timeElapsed,\n        uint256 /* _duration */,\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (uint256 price)\n    {\n        (\n            uint256 initialPrice,\n            uint256 scalingFactor,\n            uint256 timeCoefficient,\n            uint256 bucketSize,\n            bool isDecreasing,\n            uint256 maxPrice,\n            uint256 minPrice\n        ) = getDecodedData(_priceAdapterConfigData);\n\n        require(\n            areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice), \n            \"BoundedStepwiseExponentialPriceAdapter: Invalid params\"\n        );\n\n        uint256 timeBucket = _timeElapsed / bucketSize;\n\n        // Protect against exponential argument overflow\n        if (timeBucket > type(uint256).max / timeCoefficient) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        int256 expArgument = int256(timeCoefficient * timeBucket);\n        \n        // Protect against exponential overflow and increasing relative error\n        if (expArgument > MAX_EXP_ARG) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        uint256 expExpression = uint256(FixedPointMathLib.expWad(expArgument));\n\n        // Protect against priceChange overflow\n        if (scalingFactor > type(uint256).max / expExpression) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        uint256 priceChange = scalingFactor * expExpression - WAD;\n\n        if (isDecreasing) {\n            // Protect against price underflow\n            if (priceChange > initialPrice) {\n                return minPrice;\n            }\n            return FixedPointMathLib.max(initialPrice - priceChange , minPrice);\n        } else {\n            // Protect against price overflow\n            if (priceChange > type(uint256).max - initialPrice) {\n                return maxPrice;\n            }\n            return FixedPointMathLib.min(initialPrice + priceChange, maxPrice);\n        }\n    }\n\n    /**\n     * @dev Returns true if the price adapter is valid for the given parameters.\n     * \n     * @param _priceAdapterConfigData   Encoded data for configuring the price adapter.\n     * \n     * @return isValid                  Boolean indicating if the adapter config data is valid.\n     */\n    function isPriceAdapterConfigDataValid(\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (bool isValid)\n    {\n        (\n            uint256 initialPrice,\n            uint256 scalingFactor,\n            uint256 timeCoefficient,\n            uint256 bucketSize,\n            ,\n            uint256 maxPrice,\n            uint256 minPrice\n        ) = getDecodedData(_priceAdapterConfigData);\n\n        return areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice);\n    }\n\n    /**\n     * @dev Returns true if the price adapter parameters are valid.\n     * \n     * @param _initialPrice      Initial price of the auction\n     * @param _scalingFactor     Scaling factor for exponential expression\n     * @param _timeCoefficient   Scaling factor for exponential argument\n     * @param _bucketSize        Time elapsed between each bucket\n     * @param _maxPrice          Maximum price of the auction\n     * @param _minPrice          Minimum price of the auction\n     */\n    function areParamsValid(\n        uint256 _initialPrice,\n        uint256 _scalingFactor,\n        uint256 _timeCoefficient,\n        uint256 _bucketSize,\n        uint256 _maxPrice,\n        uint256 _minPrice\n    )\n        public\n        pure\n        returns (bool)\n    {\n        return _initialPrice > 0\n            && _scalingFactor > 0\n            && _timeCoefficient > 0\n            && _bucketSize > 0\n            && _initialPrice <= _maxPrice\n            && _initialPrice >= _minPrice;\n    }\n\n    /**\n     * @dev Returns the encoded data for the price curve parameters\n     * \n     * @param _initialPrice        Initial price of the auction\n     * @param _scalingFactor       Scaling factor for exponential expression\n     * @param _timeCoefficient     Scaling factor for exponential argument\n     * @param _bucketSize          Time elapsed between each bucket\n     * @param _isDecreasing        Flag for whether the price is decreasing or increasing\n     * @param _maxPrice            Maximum price of the auction\n     * @param _minPrice            Minimum price of the auction\n     */\n    function getEncodedData(\n        uint256 _initialPrice,\n        uint256 _scalingFactor,\n        uint256 _timeCoefficient,\n        uint256 _bucketSize,\n        bool _isDecreasing,\n        uint256 _maxPrice,\n        uint256 _minPrice\n    )\n        external\n        pure\n        returns (bytes memory data)\n    {\n        return abi.encode(_initialPrice, _scalingFactor, _timeCoefficient, _bucketSize, _isDecreasing, _maxPrice, _minPrice);\n    }\n\n    /**\n     * @dev Decodes the parameters from the provided bytes.\n     *\n     * @param _data                Bytes encoded auction parameters\n     * @return initialPrice        Initial price of the auction\n     * @return scalingFactor       Scaling factor for exponential expression\n     * @return timeCoefficient     Scaling factor for exponential argument\n     * @return bucketSize          Time elapsed between each bucket\n     * @return isDecreasing        Flag for whether the price is decreasing or increasing\n     * @return maxPrice            Maximum price of the auction\n     * @return minPrice            Minimum price of the auction\n     */\n    function getDecodedData(bytes memory _data)\n        public\n        pure\n        returns (uint256 initialPrice, uint256 scalingFactor, uint256 timeCoefficient, uint256 bucketSize, bool isDecreasing, uint256 maxPrice, uint256 minPrice)\n    {\n        return abi.decode(_data, (uint256, uint256, uint256, uint256, bool, uint256, uint256));\n    }\n\n    function _getBoundaryPrice(bool isDecreasing, uint256 maxPrice, uint256 minPrice) private pure returns (uint256) {\n        return isDecreasing ? minPrice : maxPrice;\n    }\n}"
    },
    {
      "filename": "index-protocol/contracts/protocol/integration/auction-price/BoundedStepwiseExponentialPriceAdapter.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\n\n/**\n * @title BoundedStepwiseExponentialPriceAdapter\n * @author Index Coop\n * @notice Price adapter contract for the AuctionRebalanceModuleV1. It returns a price that\n * increases or decreases exponentially in steps over time, within a bounded range.\n * The rate of change is increasing.\n * Price formula: price = initialPrice +/- scalingFactor * e ^ (timeCoefficient * timeBucket)\n */\ncontract BoundedStepwiseExponentialPriceAdapter {\n    using FixedPointMathLib for int256;\n\n    uint256 constant WAD = 1e18;            // Equivalent to PreciseUnitMath.preciseUnit()\n    int256 constant MAX_EXP_ARG = 100e18;   // To protect against overflow and increasing relative error\n\n    /**\n     * @dev Calculates and returns the exponential price.\n     *\n     * @param _timeElapsed              Time elapsed since the start of the auction.\n     * @param _priceAdapterConfigData   Encoded bytes representing the exponential function parameters.\n     *\n     * @return price                    The price calculated using the exponential function.\n     */\n    function getPrice(\n        address /* _setToken */,\n        address /* _component */,\n        uint256 /* _componentQuantity */,\n        uint256 _timeElapsed,\n        uint256 /* _duration */,\n        bytes memory _priceAdapterConfigData\n    )\n        external\n        pure\n        returns (uint256 price)\n    {\n        (\n            uint256 initialPrice,\n            uint256 scalingFactor,\n            uint256 timeCoefficient,\n            uint256 bucketSize,\n            bool isDecreasing,\n            uint256 maxPrice,\n            uint256 minPrice\n        ) = getDecodedData(_priceAdapterConfigData);\n\n        require(\n            areParamsValid(initialPrice, scalingFactor, timeCoefficient, bucketSize, maxPrice, minPrice), \n            \"BoundedStepwiseExponentialPriceAdapter: Invalid params\"\n        );\n\n        uint256 timeBucket = _timeElapsed / bucketSize;\n\n        // Protect against exponential argument overflow\n        if (timeBucket > type(uint256).max / timeCoefficient) {\n            return _getBoundaryPrice(isDecreasing, maxPrice, minPrice);\n        }\n        int256 expArgument = int256(timeCoefficient * timeBucket);\n        \n        // Protect against exponential overflow a"
    }
  ]
}