{
  "Title": "M-4: DoS on liquidations when utilization rate is high",
  "Content": "# Issue M-4: DoS on liquidations when utilization rate is high \n\nSource: https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/70 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nsantipu\\_\n## Summary\n\nWhen a position is liquidated, the liquidator seizes some (or all) of the borrower's assets in compensation for repaying the unhealthy debt. However, when the utilization rate is high in a market, liquidations won't work because of insufficient protocol liquidity.\n\nAn attacker could use this bug to frontrun a liquidation transaction by withdrawing assets from a market, bringing the utilization higher and preventing the liquidation. \n\n## Vulnerability Detail\n\nIn liquidation, one of the last steps is to seize the assets from a borrower and give them to the liquidator. The `seize` function calls `internalSeize` to seize the assets from the borrower: \n\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L678-L694\n```solidity\n  function internalSeize(Market seizeMarket, address liquidator, address borrower, uint256 assets) internal {\n    if (assets == 0) revert ZeroWithdraw();\n\n    // reverts on failure\n    auditor.checkSeize(seizeMarket, this);\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleDeposit(borrower);\n    uint256 shares = previewWithdraw(assets);\n>>  beforeWithdraw(assets, shares);\n      \n    // ...\n  }\n```\n\nThe function `internalSeize`, in turn, calls `beforeWithdraw` to update the state of the market before the actual seizing of the assets. The issue is that `beforeWithdraw` checks if the protocol has enough liquidity for the withdrawal of assets:\n\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L698-L706\n```solidity\n  function beforeWithdraw(uint256 assets, uint256) internal override whenNotPaused {\n    updateFloatingAssetsAverage();\n    depositToTreasury(updateFloatingDebt());\n    uint256 earnings = accrueAccumulatedEarnings();\n    uint256 newFloatingAssets = floatingAssets + earnings - assets;\n    // check if the underlying liquidity that the account wants to withdraw is borrowed\n>>  if (floatingBackupBorrowed + floatingDebt > newFloatingAssets) revert InsufficientProtocolLiquidity();\n    floatingAssets = newFloatingAssets;\n  }\n```\n\nThis check will make the whole liquidation revert when the utilization rate of that market is near the top. An attacker can use this bug to prevent a liquidation of one of his accounts by frontrunning the liquidation and withdrawing liquidity with another account. When that liquidity is withdrawn, the actual liquidation will fail. \n\n## Impact\n\nWhen the utilization rate of a market is high, the liquidations will fail, causing bad debt on the protocol if the price moves against the borrower. Liquidations are a core invariant of any lending protocol and should never fail in order to prevent bad debt, and ultimately, a bank run. \n\nAn attacker can use this vulnerability to make his positions not liquidatable by frontrunning a liquidation and withdrawing liquidity from that market with another account. \n\n## PoC\n\nThe following PoC can be pasted in the `Market.t.sol` file and can be run with the following command `forge test --match-test test_fail_liquidation`.\n\n```solidity\nfunction test_fail_liquidation() external {\n    // We set the price of the asset to 0.0002 (1 ETH = 5,000 DAI)\n    daiPriceFeed.setPrice(0.0002e18);\n\n    // Simulate deposits on the markets\n    market.deposit(50_000e18, ALICE);\n    marketWETH.deposit(10e18, address(this));\n\n    // Simulate borrowing on the markets\n    vm.startPrank(ALICE);\n    market.auditor().enterMarket(market);\n    marketWETH.borrow(5e18, ALICE, ALICE);\n    vm.stopPrank();\n\n    market.borrow(35_000e18, address(this), address(this));\n\n    // Price falls to 0.00025 (1 ETH = 4,000 DAI)\n    daiPriceFeed.setPrice(0.00025e18);\n\n    // Position cannot be liquidated due to insufficient protocol liquidity\n    vm.prank(BOB);\n    vm.expectRevert(InsufficientProtocolLiquidity.selector);\n    market.liquidate(address(this), type(uint256).max, marketWETH);\n}\n```\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L704\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo mitigate this issue is recommended to not call `beforeWithdraw` in a liquidation and add the logic of `beforeWithdraw` in the `internalSeize` function except for the liquidity check.\n\n\n\n## Discussion\n\n**MehdiKarimi81**\n\nEscalate \n\nConsider: \nThere is a reserve factor that prevents borrowing all of the pool assets,\nFor borrowing, the attacker needs to deposit some collateral and since the utilization rate is high, the interest rate would be high and the borrower should pay a huge interest and it doesn't seem to have any profit for the attacker, \nThe liquidator can choose to liquidate from a different market that the user has entered or only liquidate some part of the assets \nUsers deposits add to pool liquidity and prevent DoS\n\nI believe it should be invalid or medium \n\n\n**sherlock-admin3**\n\n> Escalate \n> \n> Consider: \n> There is a reserve factor that prevents borrowing all of the pool assets,\n> For borrowing, the attacker needs to deposit some collateral and since the utilization rate is high, the interest rate would be high and the borrower should pay a huge interest and it doesn't seem to have any profit for the attacker, \n> The liquidator can choose to liquidate from a different market that the user has entered or only liquidate some part of the assets \n> Users deposits add to pool liquidity and prevent DoS\n> \n> I believe it should be invalid or medium \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**santichez**\n\n@santipu03 given the POC you provided, if the liquidity check is removed from the liquidation flow, the liquidation will still fail because there are not enough underlying assets to be withdrawn.\nIf the utilization rate is high and a user front-runs the liquidation by withdrawing floating pool deposits from another account, the liquidation will still revert due to insufficient underlying assets and this is a problem we can't escape, same occurs with AAVE or Compound. That's why adjust factor values are important, which might give enough time for the market to arbitrage the rates by itself (other users providing liquidity) and liquidations happening sooner.\nThe liquidity check also ensures that only floating pool deposits are being used when seizing users' collateral. Let's say there's an excess of fixed pool deposits and we don't have the liquidity check, then possibly, the underlying assets of the fixed pool deposits are going to be withdrawn and this is unwanted.\n\n**0x73696d616f**\n\n> @santipu03 given the POC you provided, if the liquidity check is removed from the liquidation flow, the liquidation will still fail because there are not enough underlying assets to be withdrawn.\n\nThis is not true as the protocol can first pay off the debt using the liquidator's assets (it currently does not and it is incorrect, should be fixed). When it does the liquidity check, it uses updated debt values (removed the debt first), but has not yet pulled the debt assets, which is incorrect.\n\n**santichez**\n\n@0x73696d616f I have just seen your report that I previously missed because it was marked as duplicate and I consider it more valid indeed. I'll jump back to your report asap.\nMy answer to @santipu03 is not inaccurate though, since in the POC we are dealing with a cross-asset liquidation.\n\n**santipu03**\n\nThe fix proposed on #118 will also fix the scenario described in the report on some cases. However, it's still possible (and probable) that liquidations may fail due to the liquidity check when the utilization rate is high.\n\nIt's true that even if the liquidity check is removed the transaction would fail due to insufficient funds on the contract. However, the fact that an attacker can make liquidations consistently revert by withdrawing assets is directly breaking a core invariant of a lending protocol. Moreover, this scenario can be given without the need of an attacker, when the market is highly utilized, liquidations will also fail. \n\n**etherSky111**\n\nThe impact of this issue is medium, but the likelihood is low. \nIt can only occur when almost all liquidity is borrowed and the seize market is the same as the borrow market. \nTherefore, I believe this issue can be classified as low/medium.\n\n**0x73696d616f**\n\n> The impact of this issue is medium\n\nThe impact of DoSing liquidations is high in lending protocols, even more so when users can trigger it.\n\n> but the likelihood is low.\n\nI disagree with this, borrowing most of the liquidity is an expected and accepted state of a lending protocol, so the likelihood is not low.\n\n**etherSky111**\n\n@Trumpero , could you please also take a look at this as LSW?\n\nI believe that @MehdiKarimi81 described correctly in the escalation.\nThis is really rare case and easy to avoid this as the liquidator(or bot) can choose other market as seize market or partially liquidate.\n\n**Trumpero**\n\nFrom my perspective, some protocols have this risk as well, and I thought this was an accepted risk, so I didn't submit this issue. \nFor example, you can look at the Silo protocol, which has the concept of 'deposit-only' assets that can't be borrowed. However, if the market utilization becomes high, these 'deposit-only' assets can still be borrowed. So, I think the likelihood of high utilization is quite small\n\nBut I don't negate the possibility of the issue. I think we should leave it to the head judge to decide\n\n**santipu03**\n\nEven though the likelihood of this issue occurring organically might be medium/low, an attacker can exploit this vulnerability to always prevent getting liquidated.\n\nThe attack sequence is the following:\n1. Attacker deposits collateral at market A (better if it's highly utilized but it's not necessary)\n2. Attacker deposits a ton of collateral with another account at market A.\n3. Attacker borrows from whatever market using the first account.\n4. When the attacker is going to be liquidated, frontrun txn by withdrawing assets from market A using the second account. Liquidation will fail because of the lack of liquidity.\n\nNote that the attacker can withdraw the maximum liquidity allowed so that the liquidator cannot even liquidate partially. Also, the liquidator cannot seize from another market because the attacker only has collateral at market A. The cost of the attack is low because there's no fee on deposits or withdrawals of collateral, the only cost is the gas spent.\n\nAs you can see, the impact is high (liquidation constantly reverts) and the likelihood is also high (the attacker can execute the attack as long as necessary). It perfectly fits in the high severity category according to the Sherlock rules:\n\n> Definite loss of funds without (extensive) limitations of external conditions.\n\n\n\n\n**0x73696d616f**\n\nGiven the fact that bad debt may be socialized by subtracting from the earnings accumulator, there is no need to perform the liquidity check. It just creates more bad debt by delaying the problem further. The correct flow is, if the market is close to not having enough liquidity for liquidations, liquidate the user and socialize the bad debt, if this is the case. It makes no sense to accumulate more bad debt.\n\nIf we look at the exact liquidity check:\n```solidity\nuint256 earnings = accrueAccumulatedEarnings();\nuint256 newFloatingAssets = floatingAssets + earnings - assets;\n// check if the underlying liquidity that the account wants to withdraw is borrowed\nif (floatingBackupBorrowed + floatingDebt > newFloatingAssets) revert InsufficientProtocolLiquidity();\n```\nThe liquidity is checked against `accrueAccumulatedEarnings()`. There is room to deduct losses from the earnings accumulator, which is the correct flow to fix the risk.\n\n**0x73696d616f**\n\nThis part here is key\n> the liquidator cannot seize from another market because the attacker only has collateral at market A.\n\nThe attacker is able to limit the losses of the total position to only a portion of the total collateral (both accounts). Even on market A alone, the only assets that may be seized are that of the account that is borrowing.\n\n**etherSky111**\n\n> Even though the likelihood of this issue occurring organically might be medium/low, an attacker can exploit this vulnerability to always prevent getting liquidated.\n> \n> The attack sequence is the following:\n> \n> 1. Attacker deposits collateral at market A (better if it's highly utilized but it's not necessary)\n> 2. Attacker deposits a ton of collateral with another account at market A.\n> 3. Attacker borrows from whatever market using the first account.\n> 4. When the attacker is going to be liquidated, frontrun txn by withdrawing assets from market A using the second account. Liquidation will fail because of the lack of liquidity.\n> \n> Note that the attacker can withdraw the maximum liquidity allowed so that the liquidator cannot even liquidate partially. Also, the liquidator cannot seize from another market because the attacker only has collateral at market A. The cost of the attack is low because there's no fee on deposits or withdrawals of collateral, the only cost is the gas spent.\n> \n> As you can see, the impact is high (liquidation constantly reverts) and the likelihood is also high (the attacker can execute the attack as long as necessary). It perfectly fits in the high severity category according to the Sherlock rules:\n> \n> > Definite loss of funds without (extensive) limitations of external conditions.\n\nFor the attacker to execute this attack, they would need to deposit the majority of the liquidity in the pool in step 2. This is not a practical attack vector.\n\nWhen the attacker withdraws their assets, the utilization ratio (UR) becomes high, indicating that the attacker deposited enough liquidity to control the UR of the pool. Therefore, the likelihood of this attack is still low, and its impact is medium.\n\nShould the attackers do these operations in order to just avoid upcoming liquidation?\n\nWhile your suggested fixes provide some benefits to the protocol, this doesn't mean the issues should be considered high priority. Even low-priority issues require fixes.\n\n**MehdiKarimi81**\n\nAccording to sherlock docs: DoS has two separate scores on which it can become an issue:\n\nThe issue causes locking of funds for users for more than a week.\nThe issue impacts the availability of time-sensitive functions (cutoff functions are not considered time-sensitive). \nIf at least one of these are describing the case, the issue can be a Medium. If both apply, the issue can be considered of High severity.\n\nSince only second condition is met for this issue it can be considered medium \n\nalso consider cost of attack\n\n**santipu03**\n\n> For the attacker to execute this attack, they would need to deposit the majority of the liquidity in the pool in step 2. This is not a practical attack vector.\n\nThat's incorrect, in a highly utilized pool (e.g. 90% utilization), the attacker only needs to own a little bit more than 10% of the total liquidity to execute this attack safely. Currently, in the Exactly live contracts, there are pools with less than 1M total deposited assets, the attacker would just have to own up to 100k of liquidity there to safely execute the attack. The attack can be executed in all pools, but it will need fewer assets when attacking pools with relatively low liquidity and high utilization rates. \n\nAs I described before, the attacker can use this vulnerability to make risk-free trades limiting his collateral to a small amount of assets. If prices go up and the attacker makes a profit, there's no need to execute any attack. If prices go down and the attacker can be liquidated, he can make liquidations revert until the prices go up again or until bad debt is created, thus making the rest of the market pay for the losses of that trade. \n\nGiven that the attack doesn't actually need any external conditions to be profitable, I believe this issue warrants the high severity. \n\n**cvetanovv**\n\nI think this issue can remain High severity because it fits the definition given in the documentation:\n\n> Definite loss of funds without (extensive) limitations of external conditions.\n\nThe attack is straightforward to execute. A malicious user can easily front-run a liquidation transaction to prevent their own liquidation, and the cost of performing this attack is minimal.\n\nThis vulnerability breaks a core contract functionality—liquidation. It allows a malicious user to exploit the system and gain unfair advantages over other users without the risk of being liquidated.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**etherSky111**\n\nWhat is a definite loss of funds?\n\nI show an example.\nA attacker deposit some liquidity into the `DAI` pool and borrow `USDC` in other pool.\nIn order to prevent future liquidation, this attacker deposit other liquidity(no need to be huge as you said) into the `DAI` pool using other account.\nWhen the price of `DAI` falls and his position becomes liquidatable, he immediatly withdraw his liquidity and increase UR of DAI pool.\nSo his position can't be liquidatable.\nAt this point, his debt is e.x. 1000$ and his collateral is about 1050$.\nBut he will say: \"I am happy to prevent the liquidation of my position finally.\"\n\nIs this a high risk?\n\nAnd also the duplication of this issue was reported as medium and the lead judge still insist this as high.\nThere are many other issues which was downgraded as medium even though the reporters indeed thought as a high severity.\nHowever didn't escalate to avoid complex judge process.\n\nPlease check this again.\n\nThe pool with high UR (90%) means that this pool is active pool and there are many depositors and liquidity in most cases.\nIn order to prevent any small liquidation, the attacker needs large amount of liquidity in this kind of pool.\n\nI don't think the cost of this attack is minimal.\n\nWhat is the real benefit for the attacker?\n\nIn order to just prevent liquidation, he will need pool with high UR and some liquidity and complex calculation regarding the correct deposit and withdraw amount to make the UR as the limited value of the pool.\n\n**santichez**\n\nWe try not to interfere in the categorization of the severity of the findings, but in my opinion this should not be **high** at all.\n\n**santichez**\n\n@0x73696d616f #118 was way more valid than this one.\n\n**cvetanovv**\n\nI'll agree with @etherSky111 arguments and opinions on the protocol. \n\nThe attack must happen in an active pool with many depositors and liquidity. This means that many funds are needed, making it unlikely.\n\nI also didn't see much benefit to the attacker for this issue to be of High severity. Even the duplicate that has the same root cause is submitted as Medium. \n\nThis issue breaks a core contract functionality—liquidation, but this meets the Medium severity definition.\n\nPlanning to accept the escalation and make this issue a Medium severity.\n\n**0x73696d616f**\n\n@cvetanovv the dup #118 is not a dup as the root cause is different. #118 is transferFrom order, this one is protocol liquidity checks.\nOnly the impact is the same.\nSince this one was escalated this may still be fixed.\n\n**cvetanovv**\n\nThe root cause is that liquidations won't work when the market is highly utilized, so #118 and #70 will be duplicates.\n\n**0x73696d616f**\n\n@cvetanovv fixing #70 does not fix #118 and fixing #118 does not fix #70. They are different issues that lead to the same impact.\n\n**0x73696d616f**\n\nRoot cause of #70:\n\n `if (floatingBackupBorrowed + floatingDebt > newFloatingAssets) revert InsufficientProtocolLiquidity();`\n\nRoot cause of #118:\n\n`asset.safeTransferFrom(msg.sender, address(this), repaidAssets + lendersAssets);` after transferring the collateral to the liquidator, instead of before.\n\n**0x73696d616f**\n\nHere is one example of the issues not being dups\n\nThe market has\n1000 debt\n1200 collateral\n200 funds are in the market (1000 are borrowed)\nNow let's say there is a liquidation and 1000 debt is being repaid for 1200 collateral, in the same market.\n\n#118\nDebt is repaid [first](https://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L557-L595), and is now 0, but funds have not been transferred yet to the market (it only calls `safeTransferFrom()` at the [end](https://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L613)).\nCollateral is [seized](https://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L602) in the same market, a few lines below the debt repayment in `liquidate()`.\nIn `internalSeize()`, `beforeWithdraw()` is [called](https://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L687).\nIn `beforeWithdraw()`, there is at the moment 0 debt and 1200 collateral, so the [check](https://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L704) does not revert (and the utilization, which is debt / collateral is 0, not high as the initial reason for dupping mentioned).\nLater, back in `internalSeize()`, it tries to [send](https://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L693) 1200 to the liquidator, but it reverts, as it still only has 200 funds as the funds have not yet been pulled.\n\nThus, this is not due to the liquidity check, but the wrong tracking of funds due to not having pulling them when the debt has already been reduced to 0. When it transfers the assets to the liquidator, debt is 0, collateral is 1200, but the market only has 200 funds, which is incorrect.\n\n#70 works just fine here\nRepay debt -> 0 debt\nCollateral is 1200 still\nUtilization ratio is 0 (debt/collateral) when the [check](https://github.com/sherlock-audit/2024-04-interest-rate-model/blob/main/protocol/contracts/Market.sol#L704) happens, so there is 0 debt and 1200 collateral and it does not revert.\nNon issue.\n\n**cvetanovv**\n\nThis [comment](https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/70#issuecomment-2131230052) showed how the utilization ratio could be 0, and we still have an issue аnd how the root cause of the issue in #118 is the wrong tracking of funds. \n\nThat's why #118 and #70 can be split.\n\n**MehdiKarimi81**\n\n> According to Sherlock docs: DoS has two separate scores on which it can become an issue:\n> \n> The issue causes the locking of funds for users for more than a week. The issue impacts the availability of time-sensitive functions (cutoff functions are not considered time-sensitive). If at least one of these are describing the case, the issue can be a Medium. If both apply, the issue can be considered of High severity.\n> \n> Since only the second condition is met for this issue it can be considered medium\n> \n> also consider cost of attack\n\n@cvetanovv \nWhat do you think about this? it is a time-sensitive function but doesn't meet the first rule ( loss of funds ), so it seems to be medium \n\n**cvetanovv**\n\n@MehdiKarimi81 Yes, in that [comment](https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/70#issuecomment-2129237385), I wrote that I would accept the escalation, and both issues would be Medium.\n\n**cvetanovv**\n\nFor more clarity, the decision is to accept the escalation and downgrade the severity to Medium. \n\n[70](https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/70) and [118](https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/118) will be downgraded to Medium severity but will be split as separate issues.\n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [MehdiKarimi81](https://github.com/sherlock-audit/2024-04-interest-rate-model-judging/issues/70/#issuecomment-2118693094): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/247",
  "Code": [
    {
      "filename": "protocol/contracts/Market.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { MathUpgradeable as Math } from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { ERC4626, ERC20, SafeTransferLib } from \"solmate/src/mixins/ERC4626.sol\";\nimport { InterestRateModel } from \"./InterestRateModel.sol\";\nimport { RewardsController } from \"./RewardsController.sol\";\nimport { FixedLib } from \"./utils/FixedLib.sol\";\nimport { Auditor } from \"./Auditor.sol\";\n\ncontract Market is Initializable, AccessControlUpgradeable, PausableUpgradeable, ERC4626 {\n  using FixedPointMathLib for int256;\n  using FixedPointMathLib for uint256;\n  using FixedPointMathLib for uint128;\n  using SafeTransferLib for ERC20;\n  using FixedLib for FixedLib.Pool;\n  using FixedLib for FixedLib.Position;\n  using FixedLib for uint256;\n\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant EMERGENCY_ADMIN_ROLE = keccak256(\"EMERGENCY_ADMIN_ROLE\");\n\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n  Auditor public immutable auditor;\n\n  /// @notice Tracks account's fixed deposit positions by maturity, account and position.\n  mapping(uint256 => mapping(address => FixedLib.Position)) public fixedDepositPositions;\n  /// @notice Tracks account's fixed borrow positions by maturity, account and position.\n  mapping(uint256 => mapping(address => FixedLib.Position)) public fixedBorrowPositions;\n  /// @notice Tracks fixed pools state by maturity.\n  mapping(uint256 => FixedLib.Pool) public fixedPools;\n\n  /// @notice Tracks fixed deposit and borrow map and floating borrow shares of an account.\n  mapping(address => Account) public accounts;\n\n  /// @notice Amount of assets lent by the floating pool to the fixed pools.\n  uint256 public floatingBackupBorrowed;\n  /// @notice Amount of assets lent by the floating pool to accounts.\n  uint256 public floatingDebt;\n\n  /// @notice Accumulated earnings from extraordinary sources to be gradually distributed.\n  uint256 public earningsAccumulator;\n  /// @notice Rate per second to be charged to delayed fixed pools borrowers after maturity.\n  uint256 public penaltyRate;\n  /// @notice Rate charged to the fixed pool to be retained by the floating pool for initially providing liquidity.\n  uint256 public backupFeeRate;\n  /// @notice Damp speed factor to update `floatingAssetsAverage` when `floatingAssets` is higher.\n  uint256 public dampSpeedUp;\n  /// @notice Damp speed factor to update `floatingAssetsAverage` when `floatingAssets` is lower.\n  uint256 public dampSpeedDown;\n\n  /// @notice Number of fixed pools to be active at the same time.\n  uint8 public maxFuturePools;\n  /// @notice Last time the accumulator distributed earnings.\n  uint32 public lastAccumulatorAccrual;\n  /// @notice Last time the floating debt was updated.\n  uint32 public lastFloatingDebtUpdate;\n  /// @notice Last time the floating assets average was updated.\n  uint32 public lastAverageUpdate;\n\n  /// @notice Interest rate model contract used to get the borrow rates.\n  InterestRateModel public interestRateModel;\n\n  /// @notice Factor used for gradual accrual of earnings to the floating pool.\n  uint128 public earningsAccumulatorSmoothFactor;\n  /// @notice Percentage factor that represents the liquidity reserves that can't be borrowed.\n  uint128 public reserveFactor;\n\n  /// @notice Amount of floating assets deposited to the pool.\n  uint256 public floatingAssets;\n  /// @notice Average of the floating assets to get fixed borrow rates and prevent rate manipulation.\n  uint256 public floatingAssetsAverage;\n\n  /// @notice Total amount of floating borrow shares assigned to floating borrow accounts.\n  uint256 public totalFloatingBorrowShares;\n\n  /// @dev gap from deprecated state.\n  /// @custom:oz-renamed-from floatingUtilization\n  uint256 private __gap;\n\n  /// @notice Address of the treasury that will receive the allocated earnings.\n  address public treasury;\n  /// @notice Rate to be charged by the treasury to floating and fixed borrows.\n  uint256 public treasuryFeeRate;\n\n  /// @notice Address of the rewards controller that will accrue rewards for accounts operating with the Market.\n  RewardsController public rewardsController;\n\n  /// @notice Flag to prevent new borrows and deposits.\n  bool public isFrozen;\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor(ERC20 asset_, Auditor auditor_) ERC4626(asset_, \"\", \"\") {\n    auditor = auditor_;\n\n    _disableInitializers();\n  }\n\n  /// @notice Initializes the contract.\n  /// @dev can only be called once.\n  function initialize(\n    string calldata assetSymbol,\n    uint8 maxFuturePools_,\n    uint128 earningsAccumulatorSmoothFactor_,\n    InterestRateModel interestRateModel_,\n    uint256 penaltyRate_,\n    uint256 backupFeeRate_,\n    uint128 reserveFactor_,\n    uint256 dampSpeedUp_,\n    uint256 dampSpeedDown_\n  ) external initializer {\n    __AccessControl_init();\n    __Pausable_init();\n\n    lastAccumulatorAccrual = uint32(block.timestamp);\n    lastFloatingDebtUpdate = uint32(block.timestamp);\n    lastAverageUpdate = uint32(block.timestamp);\n\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n    setAssetSymbol(assetSymbol);\n    setMaxFuturePools(maxFuturePools_);\n    setEarningsAccumulatorSmoothFactor(earningsAccumulatorSmoothFactor_);\n    setInterestRateModel(interestRateModel_);\n    setPenaltyRate(penaltyRate_);\n    setBackupFeeRate(backupFeeRate_);\n    setReserveFactor(reserveFactor_);\n    setDampSpeed(dampSpeedUp_, dampSpeedDown_);\n  }\n\n  /// @notice Borrows a certain amount from the floating pool.\n  /// @param assets amount to be sent to receiver and repaid by borrower.\n  /// @param receiver address that will receive the borrowed assets.\n  /// @param borrower address that will repay the borrowed assets.\n  /// @return borrowShares shares corresponding to the borrowed assets.\n  function borrow(\n    uint256 assets,\n    address receiver,\n    address borrower\n  ) external whenNotPaused whenNotFrozen returns (uint256 borrowShares) {\n    spendAllowance(borrower, assets);\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    depositToTreasury(updateFloatingDebt());\n\n    borrowShares = previewBorrow(assets);\n\n    uint256 newFloatingDebt = floatingDebt + assets;\n    floatingDebt = newFloatingDebt;\n    // check if the underlying liquidity that the account wants to withdraw is borrowed, also considering the reserves\n    if (floatingBackupBorrowed + newFloatingDebt > floatingAssets.mulWadDown(1e18 - reserveFactor)) {\n      revert InsufficientProtocolLiquidity();\n    }\n\n    totalFloatingBorrowShares += borrowShares;\n    accounts[borrower].floatingBorrowShares += borrowShares;\n\n    emit Borrow(msg.sender, receiver, borrower, assets, borrowShares);\n    emitMarketUpdate();\n\n    auditor.checkBorrow(this, borrower);\n    asset.safeTransfer(receiver, assets);\n  }\n\n  /// @notice Repays a certain amount of assets to the floating pool.\n  /// @param assets assets to be subtracted from the borrower's accountability.\n  /// @param borrower address of the account that has the debt.\n  /// @return actualRepay the actual amount that should be transferred into the protocol.\n  /// @return borrowShares subtracted shares from the borrower's accountability.\n  function repay(\n    uint256 assets,\n    address borrower\n  ) external whenNotPaused returns (uint256 actualRepay, uint256 borrowShares) {\n    (actualRepay, borrowShares) = noTransferRefund(previewRepay(assets), borrower);\n    emitMarketUpdate();\n    asset.safeTransferFrom(msg.sender, address(this), actualRepay);\n  }\n\n  /// @notice Repays a certain amount of shares to the floating pool.\n  /// @param borrowShares shares to be subtracted from the borrower's accountability.\n  /// @param borrower address of the account that has the debt.\n  /// @return assets subtracted assets from the borrower's accountability.\n  /// @return actualShares actual subtracted shares from the borrower's accountability.\n  function refund(\n    uint256 borrowShares,\n    address borrower\n  ) external whenNotPaused returns (uint256 assets, uint256 actualShares) {\n    (assets, actualShares) = noTransferRefund(borrowShares, borrower);\n    emitMarketUpdate();\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n  }\n\n  /// @notice Allows to (partially) repay a floating borrow. It does not transfer assets.\n  /// @param borrowShares shares to be subtracted from the borrower's accountability.\n  /// @param borrower the address of the account that has the debt.\n  /// @return assets the actual amount that should be transferred into the protocol.\n  /// @return actualShares actual subtracted shares from the borrower's accountability.\n  function noTransferRefund(\n    uint256 borrowShares,\n    address borrower\n  ) internal returns (uint256 assets, uint256 actualShares) {\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    depositToTreasury(updateFloatingDebt());\n    Account storage account = accounts[borrower];\n    uint256 accountBorrowShares = account.floatingBorrowShares;\n    actualShares = Math.min(borrowShares, accountBorrowShares);\n    assets = previewRefund(actualShares);\n\n    if (assets == 0) revert ZeroRepay();\n\n    floatingDebt -= assets;\n    account.floatingBorrowShares = accountBorrowShares - actualShares;\n    totalFloatingBorrowShares -= actualShares;\n\n    emit Repay(msg.sender, borrower, assets, actualShares);\n  }\n\n  /// @notice Deposits a certain amount to a maturity.\n  /// @param maturity maturity date where the assets will be deposited.\n  /// @param assets amount to receive from the msg.sender.\n  /// @param minAssetsRequired minimum amount of assets required by the depositor for the transaction to be accepted.\n  /// @param receiver address that will be able to withdraw the deposited assets.\n  /// @return positionAssets total amount of assets (principal + fee) to be withdrawn at maturity.\n  function depositAtMaturity(\n    uint256 maturity,\n    uint256 assets,\n    uint256 minAssetsRequired,\n    address receiver\n  ) external whenNotPaused whenNotFrozen returns (uint256 positionAssets) {\n    if (assets == 0) revert ZeroDeposit();\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.NONE);\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n\n    uint256 backupEarnings = pool.accrueEarnings(maturity);\n    floatingAssets += backupEarnings;\n\n    (uint256 fee, uint256 backupFee) = pool.calculateDeposit(assets, backupFeeRate);\n    positionAssets = assets + fee;\n    if (positionAssets < minAssetsRequired) revert Disagreement();\n\n    floatingBackupBorrowed -= pool.deposit(assets);\n    pool.unassignedEarnings -= fee + backupFee;\n    earningsAccumulator += backupFee;\n\n    // update account's position\n    FixedLib.Position storage position = fixedDepositPositions[maturity][receiver];\n\n    // if account doesn't have a current position, add it to the list\n    if (position.principal == 0) {\n      Account storage account = accounts[receiver];\n      account.fixedDeposits = account.fixedDeposits.setMaturity(maturity);\n    }\n\n    position.principal += assets;\n    position.fee += fee;\n\n    emit DepositAtMaturity(maturity, msg.sender, receiver, assets, fee);\n    emitMarketUpdate();\n    emitFixedEarningsUpdate(maturity);\n\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n  }\n\n  /// @notice Borrows a certain amount from a maturity.\n  /// @param maturity maturity date for repayment.\n  /// @param assets amount to be sent to receiver and repaid by borrower.\n  /// @param maxAssets maximum amount of debt that the account is willing to accept.\n  /// @param receiver address that will receive the borrowed assets.\n  /// @param borrower address that will repay the borrowed assets.\n  /// @return assetsOwed total amount of assets (principal + fee) to be repaid at maturity.\n  function borrowAtMaturity(\n    uint256 maturity,\n    uint256 assets,\n    uint256 maxAssets,\n    address receiver,\n    address borrower\n  ) external whenNotPaused whenNotFrozen returns (uint256 assetsOwed) {\n    if (assets == 0) revert ZeroBorrow();\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.NONE);\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n    floatingAssets += pool.accrueEarnings(maturity);\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    {\n      uint256 backupDebtAddition = pool.borrow(assets);\n      if (backupDebtAddition != 0) {\n        uint256 newFloatingBackupBorrowed = floatingBackupBorrowed + backupDebtAddition;\n        depositToTreasury(updateFloatingDebt());\n        if (newFloatingBackupBorrowed + floatingDebt > floatingAssets.mulWadDown(1e18 - reserveFactor)) {\n          revert InsufficientProtocolLiquidity();\n        }\n        floatingBackupBorrowed = newFloatingBackupBorrowed;\n      }\n    }\n    uint256 fee;\n    {\n      uint256 memFloatingAssetsAverage = previewFloatingAssetsAverage();\n      uint256 memFloatingDebt = floatingDebt;\n      uint256 fixedRate = interestRateModel.fixedRate(\n        maturity,\n        maxFuturePools,\n        fixedUtilization(pool.supplied, pool.borrowed, memFloatingAssetsAverage),\n        floatingUtilization(memFloatingAssetsAverage, memFloatingDebt),\n        globalUtilization(memFloatingAssetsAverage, memFloatingDebt, floatingBackupBorrowed)\n      );\n      fee = assets.mulWadDown(fixedRate.mulDivDown(maturity - block.timestamp, 365 days));\n    }\n    assetsOwed = assets + fee;\n\n    // validate that the account is not taking arbitrary fees\n    if (assetsOwed > maxAssets) revert Disagreement();\n\n    spendAllowance(borrower, assetsOwed);\n\n    {\n      // if account doesn't have a current position, add it to the list\n      FixedLib.Position storage position = fixedBorrowPositions[maturity][borrower];\n      if (position.principal == 0) {\n        Account storage account = accounts[borrower];\n        account.fixedBorrows = account.fixedBorrows.setMaturity(maturity);\n      }\n\n      // calculate what portion of the fees are to be accrued and what portion goes to earnings accumulator\n      (uint256 newUnassignedEarnings, uint256 newBackupEarnings) = pool.distributeEarnings(\n        chargeTreasuryFee(fee),\n        assets\n      );\n      if (newUnassignedEarnings != 0) pool.unassignedEarnings += newUnassignedEarnings;\n      collectFreeLunch(newBackupEarnings);\n\n      fixedBorrowPositions[maturity][borrower] = FixedLib.Position(position.principal + assets, position.fee + fee);\n    }\n\n    emit BorrowAtMaturity(maturity, msg.sender, receiver, borrower, assets, fee);\n    emitMarketUpdate();\n    emitFixedEarningsUpdate(maturity);\n\n    auditor.checkBorrow(this, borrower);\n    asset.safeTransfer(receiver, assets);\n  }\n\n  /// @notice Withdraws a certain amount from a maturity.\n  /// @param maturity maturity date where the assets will be withdrawn.\n  /// @param positionAssets position size to be reduced.\n  /// @param minAssetsRequired minimum amount required by the account (if discount included for early withdrawal).\n  /// @param receiver address that will receive the withdrawn assets.\n  /// @param owner address that previously deposited the assets.\n  /// @return assetsDiscounted amount of assets withdrawn (can include a discount for early withdraw).\n  function withdrawAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 minAssetsRequired,\n    address receiver,\n    address owner\n  ) external whenNotPaused returns (uint256 assetsDiscounted) {\n    if (positionAssets == 0) revert ZeroWithdraw();\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.MATURED);\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n    floatingAssets += pool.accrueEarnings(maturity);\n\n    FixedLib.Position memory position = fixedDepositPositions[maturity][owner];\n\n    if (positionAssets > position.principal + position.fee) positionAssets = position.principal + position.fee;\n\n    {\n      // remove the supply from the fixed rate pool\n      uint256 newFloatingBackupBorrowed = floatingBackupBorrowed +\n        pool.withdraw(\n          FixedLib.Position(position.principal, position.fee).scaleProportionally(positionAssets).principal\n        );\n      if (newFloatingBackupBorrowed + floatingDebt > floatingAssets) revert InsufficientProtocolLiquidity();\n      floatingBackupBorrowed = newFloatingBackupBorrowed;\n    }\n\n    // verify if there are any penalties/fee for the account because of early withdrawal, if so discount\n    if (block.timestamp < maturity) {\n      uint256 memFloatingAssetsAverage = previewFloatingAssetsAverage();\n      uint256 memFloatingDebt = floatingDebt;\n      uint256 memFloatingBackupBorrowed = floatingBackupBorrowed;\n\n      uint256 fixedRate = interestRateModel.fixedRate(\n        maturity,\n        maxFuturePools,\n        fixedUtilization(pool.supplied, pool.borrowed, memFloatingAssetsAverage),\n        floatingUtilization(memFloatingAssetsAverage, memFloatingDebt),\n        globalUtilization(memFloatingAssetsAverage, memFloatingDebt, memFloatingBackupBorrowed)\n      );\n      assetsDiscounted = positionAssets.divWadDown(1e18 + fixedRate.mulDivDown(maturity - block.timestamp, 365 days));\n    } else {\n      assetsDiscounted = positionAssets;\n    }\n\n    if (assetsDiscounted < minAssetsRequired) revert Disagreement();\n\n    spendAllowance(owner, assetsDiscounted);\n\n    // all the fees go to unassigned or to the floating pool\n    (uint256 unassignedEarnings, uint256 newBackupEarnings) = pool.distributeEarnings(\n      chargeTreasuryFee(positionAssets - assetsDiscounted),\n      assetsDiscounted\n    );\n    pool.unassignedEarnings += unassignedEarnings;\n    collectFreeLunch(newBackupEarnings);\n\n    // the account gets discounted the full amount\n    position.reduceProportionally(positionAssets);\n    if (position.principal | position.fee == 0) {\n      delete fixedDepositPositions[maturity][owner];\n      Account storage account = accounts[owner];\n      account.fixedDeposits = account.fixedDeposits.clearMaturity(maturity);\n    } else {\n      // proportionally reduce the values\n      fixedDepositPositions[maturity][owner] = position;\n    }\n\n    emit WithdrawAtMaturity(maturity, msg.sender, receiver, owner, positionAssets, assetsDiscounted);\n    emitMarketUpdate();\n    emitFixedEarningsUpdate(maturity);\n\n    asset.safeTransfer(receiver, assetsDiscounted);\n  }\n\n  /// @notice Repays a certain amount to a maturity.\n  /// @param maturity maturity date where the assets will be repaid.\n  /// @param positionAssets amount to be paid for the borrower's debt.\n  /// @param maxAssets maximum amount of debt that the account is willing to accept to be repaid.\n  /// @param borrower address of the account that has the debt.\n  /// @return actualRepayAssets the actual amount that was transferred into the protocol.\n  function repayAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 maxAssets,\n    address borrower\n  ) external whenNotPaused returns (uint256 actualRepayAssets) {\n    // reverts on failure\n    FixedLib.checkPoolState(maturity, maxFuturePools, FixedLib.State.VALID, FixedLib.State.MATURED);\n\n    actualRepayAssets = noTransferRepayAtMaturity(maturity, positionAssets, maxAssets, borrower, true);\n    emitMarketUpdate();\n\n    asset.safeTransferFrom(msg.sender, address(this), actualRepayAssets);\n  }\n\n  /// @notice Allows to (partially) repay a fixed rate position. It does not transfer assets.\n  /// @param maturity the maturity to access the pool.\n  /// @param positionAssets the amount of debt of the pool that should be paid.\n  /// @param maxAssets maximum amount of debt that the account is willing to accept to be repaid.\n  /// @param borrower the address of the account that has the debt.\n  /// @param canDiscount should early repay discounts be applied.\n  /// @return actualRepayAssets the actual amount that should be transferred into the protocol.\n  function noTransferRepayAtMaturity(\n    uint256 maturity,\n    uint256 positionAssets,\n    uint256 maxAssets,\n    address borrower,\n    bool canDiscount\n  ) internal returns (uint256 actualRepayAssets) {\n    if (positionAssets == 0) revert ZeroRepay();\n\n    FixedLib.Pool storage pool = fixedPools[maturity];\n\n    uint256 backupEarnings = pool.accrueEarnings(maturity);\n    floatingAssets += backupEarnings;\n\n    FixedLib.Position memory position = fixedBorrowPositions[maturity][borrower];\n\n    uint256 debtCovered = Math.min(positionAssets, position.principal + position.fee);\n\n    uint256 principalCovered = FixedLib\n      .Position(position.principal, position.fee)\n      .scaleProportionally(debtCovered)\n      .principal;\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n\n    // early repayment allows a discount from the unassigned earnings\n    if (block.timestamp < maturity) {\n      if (canDiscount) {\n        // calculate the deposit fee considering the amount of debt the account'll pay\n        (uint256 discountFee, uint256 backupFee) = pool.calculateDeposit(principalCovered, backupFeeRate);\n\n        // remove the fee from unassigned earnings\n        pool.unassignedEarnings -= discountFee + backupFee;\n\n        // the fee charged to the fixed pool supplier goes to the earnings accumulator\n        earningsAccumulator += backupFee;\n\n        // the fee gets discounted from the account through `actualRepayAssets`\n        actualRepayAssets = debtCovered - discountFee;\n      } else {\n        actualRepayAssets = debtCovered;\n      }\n    } else {\n      actualRepayAssets = debtCovered + debtCovered.mulWadDown((block.timestamp - maturity) * penaltyRate);\n\n      // all penalties go to the earnings accumulator\n      earningsAccumulator += actualRepayAssets - debtCovered;\n    }\n\n    // verify that the account agrees to this discount or penalty\n    if (actualRepayAssets > maxAssets) revert Disagreement();\n\n    // reduce the borrowed from the pool and might decrease the floating backup borrowed\n    floatingBackupBorrowed -= pool.repay(principalCovered);\n\n    // update the account position\n    position.reduceProportionally(debtCovered);\n    if (position.principal | position.fee == 0) {\n      delete fixedBorrowPositions[maturity][borrower];\n      Account storage account = accounts[borrower];\n      account.fixedBorrows = account.fixedBorrows.clearMaturity(maturity);\n    } else {\n      // proportionally reduce the values\n      fixedBorrowPositions[maturity][borrower] = position;\n    }\n\n    emit RepayAtMaturity(maturity, msg.sender, borrower, actualRepayAssets, debtCovered);\n    emitFixedEarningsUpdate(maturity);\n  }\n\n  /// @notice Liquidates undercollateralized fixed/floating (or both) position(s).\n  /// @dev Msg.sender liquidates borrower's position(s) and repays a certain amount of debt for the floating pool,\n  /// or/and for multiple fixed pools, seizing a portion of borrower's collateral.\n  /// @param borrower account that has an outstanding debt across floating or fixed pools.\n  /// @param maxAssets maximum amount of debt that the liquidator is willing to accept. (it can be less)\n  /// @param seizeMarket market from which the collateral will be seized to give to the liquidator.\n  /// @return repaidAssets actual amount repaid.\n  function liquidate(\n    address borrower,\n    uint256 maxAssets,\n    Market seizeMarket\n  ) external whenNotPaused returns (uint256 repaidAssets) {\n    if (msg.sender == borrower) revert SelfLiquidation();\n\n    maxAssets = auditor.checkLiquidation(this, seizeMarket, borrower, maxAssets);\n    if (maxAssets == 0) revert ZeroRepay();\n\n    Account storage account = accounts[borrower];\n\n    {\n      uint256 packedMaturities = account.fixedBorrows;\n      uint256 maturity = packedMaturities & ((1 << 32) - 1);\n      packedMaturities = packedMaturities >> 32;\n      while (packedMaturities != 0 && maxAssets != 0) {\n        if (packedMaturities & 1 != 0) {\n          uint256 actualRepay;\n          if (block.timestamp < maturity) {\n            actualRepay = noTransferRepayAtMaturity(maturity, maxAssets, maxAssets, borrower, false);\n            maxAssets -= actualRepay;\n          } else {\n            uint256 position;\n            {\n              FixedLib.Position storage p = fixedBorrowPositions[maturity][borrower];\n              position = p.principal + p.fee;\n            }\n            uint256 debt = position + position.mulWadDown((block.timestamp - maturity) * penaltyRate);\n            actualRepay = debt > maxAssets ? maxAssets.mulDivDown(position, debt) : maxAssets;\n\n            if (actualRepay == 0) maxAssets = 0;\n            else {\n              actualRepay = noTransferRepayAtMaturity(maturity, actualRepay, maxAssets, borrower, false);\n              maxAssets -= actualRepay;\n            }\n          }\n          repaidAssets += actualRepay;\n        }\n        packedMaturities >>= 1;\n        maturity += FixedLib.INTERVAL;\n      }\n    }\n\n    if (maxAssets != 0 && account.floatingBorrowShares != 0) {\n      uint256 borrowShares = previewRepay(maxAssets);\n      if (borrowShares != 0) {\n        (uint256 actualRepayAssets, ) = noTransferRefund(borrowShares, borrower);\n        repaidAssets += actualRepayAssets;\n      }\n    }\n\n    // reverts on failure\n    (uint256 lendersAssets, uint256 seizeAssets) = auditor.calculateSeize(this, seizeMarket, borrower, repaidAssets);\n    earningsAccumulator += lendersAssets;\n\n    if (address(seizeMarket) == address(this)) {\n      internalSeize(this, msg.sender, borrower, seizeAssets);\n    } else {\n      seizeMarket.seize(msg.sender, borrower, seizeAssets);\n\n      emitMarketUpdate();\n    }\n\n    emit Liquidate(msg.sender, borrower, repaidAssets, lendersAssets, seizeMarket, seizeAssets);\n\n    auditor.handleBadDebt(borrower);\n\n    asset.safeTransferFrom(msg.sender, address(this), repaidAssets + lendersAssets);\n  }\n\n  /// @notice Clears floating and fixed debt for an account spreading the losses to the `earningsAccumulator`.\n  /// @dev Can only be called from the auditor.\n  /// @param borrower account with insufficient collateral to be cleared the debt.\n  function clearBadDebt(address borrower) external {\n    if (msg.sender != address(auditor)) revert NotAuditor();\n\n    floatingAssets += accrueAccumulatedEarnings();\n    Account storage account = accounts[borrower];\n    uint256 accumulator = earningsAccumulator;\n    uint256 totalBadDebt = 0;\n    uint256 packedMaturities = account.fixedBorrows;\n    uint256 maturity = packedMaturities & ((1 << 32) - 1);\n    packedMaturities = packedMaturities >> 32;\n    while (packedMaturities != 0) {\n      if (packedMaturities & 1 != 0) {\n        FixedLib.Position storage position = fixedBorrowPositions[maturity][borrower];\n        uint256 badDebt = position.principal + position.fee;\n        if (accumulator >= badDebt) {\n          RewardsController memRewardsController = rewardsController;\n          if (address(memRewardsController) != address(0)) memRewardsController.handleBorrow(borrower);\n          accumulator -= badDebt;\n          totalBadDebt += badDebt;\n          floatingBackupBorrowed -= fixedPools[maturity].repay(position.principal);\n          delete fixedBorrowPositions[maturity][borrower];\n          account.fixedBorrows = account.fixedBorrows.clearMaturity(maturity);\n\n          emit RepayAtMaturity(maturity, msg.sender, borrower, badDebt, badDebt);\n        }\n      }\n      packedMaturities >>= 1;\n      maturity += FixedLib.INTERVAL;\n    }\n    if (account.floatingBorrowShares != 0 && (accumulator = previewRepay(accumulator)) != 0) {\n      (uint256 badDebt, ) = noTransferRefund(accumulator, borrower);\n      totalBadDebt += badDebt;\n    }\n    if (totalBadDebt != 0) {\n      earningsAccumulator -= totalBadDebt;\n      emit SpreadBadDebt(borrower, totalBadDebt);\n    }\n    emitMarketUpdate();\n  }\n\n  /// @notice Public function to seize a certain amount of assets.\n  /// @dev Public function for liquidator to seize borrowers assets in the floating pool.\n  /// This function will only be called from another Market, on `liquidation` calls.\n  /// That's why msg.sender needs to be passed to the internal function (to be validated as a Market).\n  /// @param liquidator address which will receive the seized assets.\n  /// @param borrower address from which the assets will be seized.\n  /// @param assets amount to be removed from borrower's possession.\n  function seize(address liquidator, address borrower, uint256 assets) external whenNotPaused {\n    internalSeize(Market(msg.sender), liquidator, borrower, assets);\n  }\n\n  /// @notice Internal function to seize a certain amount of assets.\n  /// @dev Internal function for liquidator to seize borrowers assets in the floating pool.\n  /// Will only be called from this Market on `liquidation` or through `seize` calls from another Market.\n  /// That's why msg.sender needs to be passed to the internal function (to be validated as a Market).\n  /// @param seizeMarket address which is calling the seize function (see `seize` public function).\n  /// @param liquidator address which will receive the seized assets.\n  /// @param borrower address from which the assets will be seized.\n  /// @param assets amount to be removed from borrower's possession.\n  function internalSeize(Market seizeMarket, address liquidator, address borrower, uint256 assets) internal {\n    if (assets == 0) revert ZeroWithdraw();\n\n    // reverts on failure\n    auditor.checkSeize(seizeMarket, this);\n\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleDeposit(borrower);\n    uint256 shares = previewWithdraw(assets);\n    beforeWithdraw(assets, shares);\n    _burn(borrower, shares);\n    emit Withdraw(msg.sender, liquidator, borrower, assets, shares);\n    emit Seize(liquidator, borrower, assets);\n    emitMarketUpdate();\n\n    asset.safeTransfer(liquidator, assets);\n  }\n\n  /// @notice Hook to update the floating pool average, floating pool balance and distribute earnings from accumulator.\n  /// @param assets amount of assets to be withdrawn from the floating pool.\n  function beforeWithdraw(uint256 assets, uint256) internal override whenNotPaused {\n    updateFloatingAssetsAverage();\n    depositToTreasury(updateFloatingDebt());\n    uint256 earnings = accrueAccumulatedEarnings();\n    uint256 newFloatingAssets = floatingAssets + earnings - assets;\n    // check if the underlying liquidity that the account wants to withdraw is borrowed\n    if (floatingBackupBorrowed + floatingDebt > newFloatingAssets) revert InsufficientProtocolLiquidity();\n    floatingAssets = newFloatingAssets;\n  }\n\n  /// @notice Hook to update the floating pool average, floating pool balance and distribute earnings from accumulator.\n  /// @param assets amount of assets to be deposited to the floating pool.\n  function afterDeposit(uint256 assets, uint256) internal override whenNotPaused whenNotFrozen {\n    updateFloatingAssetsAverage();\n    uint256 treasuryFee = updateFloatingDebt();\n    uint256 earnings = accrueAccumulatedEarnings();\n    floatingAssets += earnings + assets;\n    depositToTreasury(treasuryFee);\n    emitMarketUpdate();\n  }\n\n  /// @notice Withdraws the owner's floating pool assets to the receiver address.\n  /// @dev Makes sure that the owner doesn't have shortfall after withdrawing.\n  /// @param assets amount of underlying to be withdrawn.\n  /// @param receiver address to which the assets will be transferred.\n  /// @param owner address which owns the floating pool assets.\n  /// @return shares amount of shares redeemed for underlying asset.\n  function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {\n    auditor.checkShortfall(this, owner, assets);\n    RewardsController memRewardsController = rewardsController;\n    if (address(memRewardsController) != address(0)) memRewardsController.handleDeposit(owner);\n    shares = super.withdraw(assets, receiver, owner);\n    emitMarketUpdate();\n  }\n\n  /// @notice Redeems the owner's floating pool assets"
    }
  ]
}