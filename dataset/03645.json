{
  "Title": "Incorrect input parameters",
  "Content": "##### Description\nIn the function for calculating price, relative difference `old` argument can be zero:\nhttps://github.com/lidofinance/steth-price-feed/blob/459495f07c97d04f6e3839e7a3b32acfcade22ad/contracts/StEthPriceFeed.vy#L58\n##### Recommendation\nWe recommend to add simple check:\n```python=\nassert old > 0, \"oracle price not init\"\n```",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/StEthPriceFeed.vy",
      "content": "# SPDX-License-Identifier: MIT\n# @author Lido <info@lido.fi>\n# @version 0.2.12\n\n\nCURVE_ETH_INDEX: constant(uint256) = 0\nCURVE_STETH_INDEX: constant(uint256) = 1\n\nadmin: public(address)\nmax_safe_price_difference: public(uint256)\nsafe_price_value: public(uint256)\nsafe_price_timestamp: public(uint256)\ncurve_pool_address: public(address)\nstable_swap_oracle_address: public(address)\n\n\ninterface StableSwap:\n    def get_dy(i: int128, j: int128, x: uint256) -> uint256: view\n\n\ninterface StableSwapStateOracle:\n    def stethPrice() -> uint256: view\n\n\nevent SafePriceUpdated:\n    from_price: uint256\n    to_price: uint256\n\n\n@external\ndef initialize(\n    max_safe_price_difference: uint256,\n    stable_swap_oracle_address: address,\n    curve_pool_address: address,\n    admin: address\n):\n    \"\"\"\n    @dev Initializes the feed.\n\n    @param max_safe_price_difference maximum allowed safe price change. 10000 equals to 100%\n    @param admin Contract admin address, that's allowed to change the maximum allowed price change\n    @param curve_pool_address Curve stEth/Eth pool address\n    @param stable_swap_oracle_address Stable swap oracle address\n    \"\"\"\n    assert self.curve_pool_address == ZERO_ADDRESS\n    assert max_safe_price_difference <= 10000\n    assert stable_swap_oracle_address != ZERO_ADDRESS\n    assert curve_pool_address != ZERO_ADDRESS\n\n    self.max_safe_price_difference = max_safe_price_difference\n    self.admin = admin\n    self.stable_swap_oracle_address = stable_swap_oracle_address\n    self.curve_pool_address = curve_pool_address\n\n\n@view\n@internal\ndef _percentage_diff(new: uint256, old: uint256) -> uint256:\n    if new > old :\n        return (new - old) * 10000 / old\n    else:\n        return (old - new) * 10000 / old\n\n\n@view\n@external\ndef safe_price() -> (uint256, uint256):\n    \"\"\"\n    @dev Returns the cached safe price and its timestamp. Reverts if no cached price was set.\n    \"\"\"\n    safe_price_timestamp: uint256 = self.safe_price_timestamp\n    assert safe_price_timestamp != 0\n    return (self.safe_price_value, safe_price_timestamp)\n\n\n@view\n@internal\ndef _current_price() -> (uint256, bool, uint256):\n    pool_price: uint256 = StableSwap(self.curve_pool_address).get_dy(CURVE_STETH_INDEX, CURVE_ETH_INDEX, 10**18)\n    oracle_price: uint256 = StableSwapStateOracle(self.stable_swap_oracle_address).stethPrice()\n    has_changed_unsafely: bool = self._percentage_diff(pool_price, oracle_price) > self.max_safe_price_difference\n    return (pool_price, has_changed_unsafely, oracle_price)\n\n\n@view\n@external\ndef current_price() -> (uint256, bool, uint256):\n    \"\"\"\n    @dev Returns the current pool price and whether the price is safe.\n    \"\"\"\n    current_price: uint256 = 0\n    has_changed_unsafely: bool = True\n    oracle_price: uint256 = 0\n    current_price, has_changed_unsafely, oracle_price = self._current_price()\n    is_safe: bool = current_price <= 10**18 and not has_changed_unsafely\n    return (current_price, is_safe, oracle_price)\n\n\n@internal\ndef _update_safe_price() -> uint256:\n    price: uint256 = 0\n    has_changed_unsafely: bool = True\n    _: uint256 = 0\n    price, has_changed_unsafely, _ = self._current_price()\n    assert not has_changed_unsafely, \"price is not safe\"\n\n    price = min(10**18, price)\n    log SafePriceUpdated(self.safe_price_value, price)\n\n    self.safe_price_value = price\n    self.safe_price_timestamp = block.timestamp\n\n    return price\n\n\n@external\ndef update_safe_price() -> uint256:\n    \"\"\"\n    @dev Sets the cached safe price to the current pool price.\n\n    If the price is higher than 10**18, sets the cached safe price to 10**18.\n    If the price is not safe for any other reason, reverts.\n    \"\"\"\n    return self._update_safe_price()\n\n\n@external\ndef fetch_safe_price(max_age: uint256) -> (uint256, uint256):\n    \"\"\"\n    @dev Returns the cached safe price and its timestamp.\n\n    Calls `update_safe_price()` prior to that if the cached safe price\n    is older than `max_age` seconds.\n    \"\"\"\n    safe_price_timestamp: uint256 = self.safe_price_timestamp\n    if safe_price_timestamp == 0 or block.timestamp - safe_price_timestamp > max_age:\n        price: uint256 = self._update_safe_price()\n        return (price, block.timestamp)\n    else:\n        return (self.safe_price_value, safe_price_timestamp)\n\n\n@external\ndef set_admin(admin: address):\n    \"\"\"\n    @dev Updates the admin address.\n\n    May only be called by the current admin.\n    \"\"\"\n    assert msg.sender == self.admin\n    self.admin = admin\n\n\n@external\ndef set_max_safe_price_difference(max_safe_price_difference: uint256):\n    \"\"\"\n    @dev Updates the maximum difference between the safe price and the time-shifted price.\n\n    May only be called by the admin.\n    \"\"\"\n    assert msg.sender == self.admin\n    assert max_safe_price_difference <= 10000\n    self.max_safe_price_difference = max_safe_price_difference"
    }
  ]
}