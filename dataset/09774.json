{
  "Title": "[M-02] A pauser can brick the contracts",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/security/Pausable.sol#L65-L68\n\n\n# Vulnerability details\n\nhttps://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/security/Pausable.sol#L65-L68\n\n```solidity\n    function renouncePauser() external virtual onlyPauser {\n        emit PauserChanged(_pauser, address(0));\n        _pauser = address(0);\n    }\n```\n\nA malicious or compromised `pauser` can call `pause()` and `renouncePauser()` to brick the contract and all the funds can be frozen.\n\n### PoC\n\nGiven:\n\n* Alice (EOA) is the `pauser` of the contract.\n\n1. Alice calls `pause()` ;\n2. Alice calls `renouncePauser()`;\n\n\nAs a result, most of the contract's methods are now unavailable, and this cannot be reversed even by the `owner`.\n\n### Recommendation\n\nConsider removing `renouncePauser()`, or requiring the contract not in `paused` mode when `renouncePauser()`.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-03-biconomy-hyphen-20-contest",
  "Code": [
    {
      "filename": "contracts/security/Pausable.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Initializable, PausableUpgradeable {\n    address private _pauser;\n\n    event PauserChanged(address indexed previousPauser, address indexed newPauser);\n\n    /**\n     * @dev The pausable constructor sets the original `pauser` of the contract to the sender\n     * account & Initializes the contract in unpaused state..\n     */\n    function __Pausable_init(address pauser) internal initializer {\n        require(pauser != address(0), \"Pauser Address cannot be 0\");\n        __Pausable_init();\n        _pauser = pauser;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isPauser(address pauser) public view returns (bool) {\n        return pauser == _pauser;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the pauser.\n     */\n    modifier onlyPauser() {\n        require(isPauser(msg.sender), \"Only pauser is allowed to perform this operation\");\n        _;\n    }\n\n    /**\n     * @dev Allows the current pauser to transfer control of the contract to a newPauser.\n     * @param newPauser The address to transfer pauserShip to.\n     */\n    function changePauser(address newPauser) public onlyPauser {\n        _changePauser(newPauser);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newPauser.\n     * @param newPauser The address to transfer ownership to.\n     */\n    function _changePauser(address newPauser) internal {\n        require(newPauser != address(0));\n        emit PauserChanged(_pauser, newPauser);\n        _pauser = newPauser;\n    }\n\n    function renouncePauser() external virtual onlyPauser {\n        emit PauserChanged(_pauser, address(0));\n        _pauser = address(0);\n    }\n\n    function pause() public onlyPauser {\n        _pause();\n    }\n\n    function unpause() public onlyPauser {\n        _unpause();\n    }\n}"
    }
  ]
}