{
  "Title": "H-4: Orders from other market makers can be invalidated",
  "Content": "# Issue H-4: Orders from other market makers can be invalidated \n\nSource: https://github.com/sherlock-audit/2022-11-opyn-judging/issues/6 \n\n## Found by \nbin2chen, hyh, hansfriese, aviggiano, caventa, thec00n, indijanc, rotcivegaf, kaliberpoziomka, chainNue, John, adriro, Atarpara, cccz, \\_\\_141345\\_\\_, Haruxe, zimu, minhtrng, HonorLt, ctf\\_sec, imare, reassor, jonatascm\n\n## Summary\nThe `checkOrder()` function performs verification of pre-signed orders. This function allows anyone to set the status of an order as used by storing the nonce contained in the order. Orders and their respective nonce can only be used once.  \n\n## Vulnerability Detail\nThe `_useNonce()` function is called as called as part of the `checkOrder()` function. It checks that the nonce of a trader has not already been used, marks the nonce as used and performs other order verification checks. Orders and their respective nonce are also checked by the same implementation as part of the auction functions `withdrawAuction()` and `depositAuction()`. An order that has been invalidated once can not be used anymore and by calling `checkOrder()` any user can invalidate existing orders. \n\n## Impact\nA malicious user could perform a grieving attack and invalidate any presigned orders by monitoring the mempool and front run any orders that are submitted to `withdrawAuction()` and `depositAuction()` and send them to `checkOrder()`. One invalidated order can cause the auction functions to fail.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-opyn/blob/main/crab-netting/src/CrabNetting.sol#L447-L476\n\nhttps://github.com/sherlock-audit/2022-11-opyn/blob/main/crab-netting/src/CrabNetting.sol#L756-L759\n\n## Tool used\nManual Review\n\n## Recommendation\n1.) Change the `checkOrder()` and `_checkOrder()` to a view function \n2.) Remove `_useNonce()` from `_checkOrder()`\n3.) Use `_useNonce()` and `_checkOrder()` in `withdrawAuction()` and `depositAuction()`\n\n## Discussion\n\n**sanandnarayan**\n\nfix https://github.com/opynfinance/squeeth-monorepo/pull/806\n\n**thec00n**\n\nFix lgtm.\n\n**SecurityDat**\n\nEscalate for 10 USDC\n\nI have two issues classfied to https://github.com/sherlock-audit/2022-11-opyn-judging/issues/60. I think one of them (https://github.com/sherlock-audit/2022-11-opyn-judging/issues/51) is exactly about this issue https://github.com/sherlock-audit/2022-11-opyn-judging/issues/6.\n\nPlease rejudge https://github.com/sherlock-audit/2022-11-opyn-judging/issues/51. It is about submitting calls to `checkorder()` to make orders from other market makers invalid.\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I have two issues classfied to https://github.com/sherlock-audit/2022-11-opyn-judging/issues/60. I think one of them (https://github.com/sherlock-audit/2022-11-opyn-judging/issues/51) is exactly about this issue https://github.com/sherlock-audit/2022-11-opyn-judging/issues/6.\n> \n> Please rejudge https://github.com/sherlock-audit/2022-11-opyn-judging/issues/51. It is about submitting calls to `checkorder()` to make orders from other market makers invalid.\n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**kaliberpoziomka**\n\nEscalate for 10 USDC\nThe issue #132 I've submitted was classified to #60. I think it is this issue #6.\nPlease rejudge #132, since it is about function `checkOrder(....)` marking nonces as used.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> The issue #132 I've submitted was classified to #60. I think it is this issue #6.\n> Please rejudge #132, since it is about function `checkOrder(....)` marking nonces as used.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/26",
  "Code": [
    {
      "filename": "crab-netting/src/CrabNetting.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.13;\n\n// interface\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {IWETH} from \"../src/interfaces/IWETH.sol\";\nimport {IOracle} from \"../src/interfaces/IOracle.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport {ICrabStrategyV2} from \"../src/interfaces/ICrabStrategyV2.sol\";\nimport {IController} from \"../src/interfaces/IController.sol\";\n\n// contract\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {EIP712} from \"openzeppelin/utils/cryptography/draft-EIP712.sol\";\nimport {ECDSA} from \"openzeppelin/utils/cryptography/ECDSA.sol\";\n\n/// @dev order struct for a signed order from market maker\nstruct Order {\n    uint256 bidId;\n    address trader;\n    uint256 quantity;\n    uint256 price;\n    bool isBuying;\n    uint256 expiry;\n    uint256 nonce;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\n/// @dev struct to store proportional amounts of erc20s (received or to send)\nstruct Portion {\n    uint256 crab;\n    uint256 eth;\n    uint256 sqth;\n}\n\n/// @dev params for deposit auction\nstruct DepositAuctionParams {\n    /// @dev USDC to deposit\n    uint256 depositsQueued;\n    /// @dev minETH equivalent to get from uniswap of the USDC to deposit\n    uint256 minEth;\n    /// @dev total ETH to deposit after selling the minted SQTH\n    uint256 totalDeposit;\n    /// @dev orders to buy sqth\n    Order[] orders;\n    /// @dev price from the auction to sell sqth\n    uint256 clearingPrice;\n    /// @dev remaining ETH to flashDeposit\n    uint256 ethToFlashDeposit;\n    /// @dev fee to pay uniswap for ethUSD swap\n    uint24 ethUSDFee;\n    /// @dev fee to pay uniswap for sqthETH swap\n    uint24 flashDepositFee;\n}\n\n/// @dev params for withdraw auction\nstruct WithdrawAuctionParams {\n    /// @dev amont of crab to queue for withdrawal\n    uint256 crabToWithdraw;\n    /// @dev orders that sell sqth to the auction\n    Order[] orders;\n    /// @dev price that the auction pays for the purchased sqth\n    uint256 clearingPrice;\n    /// @dev minUSDC to receive from swapping the ETH obtained by withdrawing\n    uint256 minUSDC;\n    /// @dev uniswap fee for swapping eth to USD;\n    uint24 ethUSDFee;\n}\n\n/// @dev receipt used to store deposits and withdraws\nstruct Receipt {\n    /// @dev address of the depositor or withdrawer\n    address sender;\n    /// @dev usdc amount to queue for deposit or crab amount to queue for withdrawal\n    uint256 amount;\n}\n\n/**\n * @dev CrabNetting contract\n * @notice Contract for Netting Deposits and Withdrawals\n * @author Opyn team\n */\ncontract CrabNetting is Ownable, EIP712 {\n    /// @dev typehash for signed orders\n    bytes32 private constant _CRAB_NETTING_TYPEHASH = keccak256(\n        \"Order(uint256 bidId,address trader,uint256 quantity,uint256 price,bool isBuying,uint256 expiry,uint256 nonce)\"\n    );\n    /// @dev owner sets to true when starting auction\n    bool public isAuctionLive;\n\n    /// @dev sqth twap period\n    uint32 public immutable sqthTwapPeriod;\n    /// @dev twap period to use for auction calculations\n    uint32 public auctionTwapPeriod = 420 seconds;\n\n    /// @dev min USDC amounts to withdraw or deposit via netting\n    uint256 public minUSDCAmount;\n\n    /// @dev min CRAB amounts to withdraw or deposit via netting\n    uint256 public minCrabAmount;\n\n    // @dev OTC price must be within this distance of the uniswap twap price\n    uint256 public otcPriceTolerance = 5e16; // 5%\n    // @dev OTC price tolerance cannot exceed 20%\n    uint256 public constant MAX_OTC_PRICE_TOLERANCE = 2e17; // 20%\n\n    /// @dev address for ERC20 tokens\n    address public immutable usdc;\n    address public immutable crab;\n    address public immutable weth;\n    address public immutable sqth;\n\n    /// @dev address for uniswap router\n    ISwapRouter public immutable swapRouter;\n\n    /// @dev address for uniswap oracle\n    address public immutable oracle;\n\n    /// @dev address for sqth eth pool\n    address public immutable ethSqueethPool;\n\n    /// @dev address for usdc eth pool\n    address public immutable ethUsdcPool;\n\n    /// @dev address for sqth controller\n    address public immutable sqthController;\n\n    /// @dev array index of last processed deposits\n    uint256 public depositsIndex;\n\n    /// @dev array index of last processed withdraws\n    uint256 public withdrawsIndex;\n\n    /// @dev array of deposit receipts\n    Receipt[] public deposits;\n    /// @dev array of withdrawal receipts\n    Receipt[] public withdraws;\n\n    /// @dev usd amount to deposit for an address\n    mapping(address => uint256) public usdBalance;\n\n    /// @dev crab amount to withdraw for an address\n    mapping(address => uint256) public crabBalance;\n\n    /// @dev indexes of deposit receipts of an address\n    mapping(address => uint256[]) public userDepositsIndex;\n\n    /// @dev indexes of withdraw receipts of an address\n    mapping(address => uint256[]) public userWithdrawsIndex;\n\n    /// @dev store the used flag for a nonce for each address\n    mapping(address => mapping(uint256 => bool)) public nonces;\n\n    event USDCQueued(\n        address indexed depositor, uint256 amount, uint256 depositorsBalance, uint256 indexed receiptIndex\n    );\n\n    event USDCDeQueued(address indexed depositor, uint256 amount, uint256 depositorsBalance);\n\n    event CrabQueued(\n        address indexed withdrawer, uint256 amount, uint256 withdrawersBalance, uint256 indexed receiptIndex\n    );\n\n    event CrabDeQueued(address indexed withdrawer, uint256 amount, uint256 withdrawersBalance);\n\n    event USDCDeposited(\n        address indexed depositor,\n        uint256 usdcAmount,\n        uint256 crabAmount,\n        uint256 indexed receiptIndex,\n        uint256 refundedETH\n    );\n\n    event CrabWithdrawn(\n        address indexed withdrawer, uint256 crabAmount, uint256 usdcAmount, uint256 indexed receiptIndex\n    );\n\n    event BidTraded(uint256 indexed bidId, address indexed trader, uint256 quantity, uint256 price, bool isBuying);\n\n    event SetAuctionTwapPeriod(uint32 previousTwap, uint32 newTwap);\n    event SetOTCPriceTolerance(uint256 previousTolerance, uint256 newOtcPriceTolerance);\n    event SetMinCrab(uint256 amount);\n    event SetMinUSDC(uint256 amount);\n    event NonceTrue(address sender, uint256 nonce);\n    event ToggledAuctionLive(bool isAuctionLive);\n\n    /**\n     * @notice netting contract constructor\n     * @dev initializes the erc20 address, uniswap router and approves them\n     * @param _crab address of crab contract token\n     * @param _swapRouter address of uniswap swap router\n     */\n    constructor(address _crab, address _swapRouter) EIP712(\"CRABNetting\", \"1\") {\n        crab = _crab;\n        swapRouter = ISwapRouter(_swapRouter);\n\n        sqthController = ICrabStrategyV2(_crab).powerTokenController();\n        usdc = IController(sqthController).quoteCurrency();\n        weth = ICrabStrategyV2(_crab).weth();\n        sqth = ICrabStrategyV2(_crab).wPowerPerp();\n        oracle = ICrabStrategyV2(_crab).oracle();\n        ethSqueethPool = ICrabStrategyV2(_crab).ethWSqueethPool();\n        ethUsdcPool = IController(sqthController).ethQuoteCurrencyPool();\n        sqthTwapPeriod = IController(sqthController).TWAP_PERIOD();\n\n        // approve crab and sqth so withdraw can happen\n        IERC20(sqth).approve(crab, type(uint256).max);\n\n        IERC20(weth).approve(address(swapRouter), type(uint256).max);\n        IERC20(usdc).approve(address(swapRouter), type(uint256).max);\n    }\n\n    /**\n     * @dev view function to get the domain seperator used in signing\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev toggles the value of isAuctionLive\n     */\n    function toggleAuctionLive() external onlyOwner {\n        isAuctionLive = !isAuctionLive;\n        emit ToggledAuctionLive(isAuctionLive);\n    }\n\n    /**\n     * @notice set nonce to true\n     * @param _nonce the number to be set true\n     */\n    function setNonceTrue(uint256 _nonce) external {\n        nonces[msg.sender][_nonce] = true;\n        emit NonceTrue(msg.sender, _nonce);\n    }\n\n    /**\n     * @notice set minUSDCAmount\n     * @param _amount the number to be set as minUSDC\n     */\n    function setMinUSDC(uint256 _amount) external onlyOwner {\n        minUSDCAmount = _amount;\n        emit SetMinUSDC(_amount);\n    }\n\n    /**\n     * @notice set minCrabAmount\n     * @param _amount the number to be set as minCrab\n     */\n    function setMinCrab(uint256 _amount) external onlyOwner {\n        minCrabAmount = _amount;\n        emit SetMinCrab(_amount);\n    }\n\n    /**\n     * @notice queue USDC for deposit into crab strategy\n     * @param _amount USDC amount to deposit\n     */\n    function depositUSDC(uint256 _amount) external {\n        require(_amount >= minUSDCAmount, \"deposit amount smaller than minimum OTC amount\");\n\n        IERC20(usdc).transferFrom(msg.sender, address(this), _amount);\n\n        // update usd balance of user, add their receipt, and receipt index to user deposits index\n        usdBalance[msg.sender] = usdBalance[msg.sender] + _amount;\n        deposits.push(Receipt(msg.sender, _amount));\n        userDepositsIndex[msg.sender].push(deposits.length - 1);\n\n        emit USDCQueued(msg.sender, _amount, usdBalance[msg.sender], deposits.length - 1);\n    }\n\n    /**\n     * @notice withdraw USDC from queue\n     * @param _amount USDC amount to dequeue\n     */\n    function withdrawUSDC(uint256 _amount) external {\n        require(!isAuctionLive, \"auction is live\");\n\n        usdBalance[msg.sender] = usdBalance[msg.sender] - _amount;\n        require(\n            usdBalance[msg.sender] >= minUSDCAmount || usdBalance[msg.sender] == 0,\n            \"remaining amount smaller than minimum, consider removing full balance\"\n        );\n\n        // start withdrawing from the users last deposit\n        uint256 toRemove = _amount;\n        uint256 lastIndexP1 = userDepositsIndex[msg.sender].length;\n        for (uint256 i = lastIndexP1; i > 0; i--) {\n            Receipt storage r = deposits[userDepositsIndex[msg.sender][i - 1]];\n            if (r.amount > toRemove) {\n                r.amount -= toRemove;\n                toRemove = 0;\n                break;\n            } else {\n                toRemove -= r.amount;\n                delete deposits[userDepositsIndex[msg.sender][i - 1]];\n            }\n        }\n        IERC20(usdc).transfer(msg.sender, _amount);\n\n        emit USDCDeQueued(msg.sender, _amount, usdBalance[msg.sender]);\n    }\n\n    /**\n     * @notice queue Crab for withdraw from crab strategy\n     * @param _amount crab amount to withdraw\n     */\n    function queueCrabForWithdrawal(uint256 _amount) external {\n        require(_amount >= minCrabAmount, \"withdraw amount smaller than minimum OTC amount\");\n        IERC20(crab).transferFrom(msg.sender, address(this), _amount);\n        crabBalance[msg.sender] = crabBalance[msg.sender] + _amount;\n        withdraws.push(Receipt(msg.sender, _amount));\n        userWithdrawsIndex[msg.sender].push(withdraws.length - 1);\n        emit CrabQueued(msg.sender, _amount, crabBalance[msg.sender], withdraws.length - 1);\n    }\n\n    /**\n     * @notice withdraw Crab from queue\n     * @param _amount Crab amount to dequeue\n     */\n    function dequeueCrab(uint256 _amount) external {\n        require(!isAuctionLive, \"auction is live\");\n        crabBalance[msg.sender] = crabBalance[msg.sender] - _amount;\n        require(\n            crabBalance[msg.sender] >= minCrabAmount || crabBalance[msg.sender] == 0,\n            \"remaining amount smaller than minimum, consider removing full balance\"\n        );\n        // deQueue crab from the last, last in first out\n        uint256 toRemove = _amount;\n        uint256 lastIndexP1 = userWithdrawsIndex[msg.sender].length;\n        for (uint256 i = lastIndexP1; i > 0; i--) {\n            Receipt storage r = withdraws[userWithdrawsIndex[msg.sender][i - 1]];\n            if (r.amount > toRemove) {\n                r.amount -= toRemove;\n                toRemove = 0;\n                break;\n            } else {\n                toRemove -= r.amount;\n                delete withdraws[userWithdrawsIndex[msg.sender][i - 1]];\n            }\n        }\n        IERC20(crab).transfer(msg.sender, _amount);\n        emit CrabDeQueued(msg.sender, _amount, crabBalance[msg.sender]);\n    }\n\n    /**\n     * @dev swaps _quantity amount of usdc for crab at _price\n     * @param _price price of crab in usdc\n     * @param _quantity amount of USDC to net\n     */\n    function netAtPrice(uint256 _price, uint256 _quantity) external onlyOwner {\n        _checkCrabPrice(_price);\n        uint256 crabQuantity = (_quantity * 1e18) / _price;\n        require(_quantity <= IERC20(usdc).balanceOf(address(this)), \"Not enough deposits to net\");\n        require(crabQuantity <= IERC20(crab).balanceOf(address(this)), \"Not enough withdrawals to net\");\n\n        // process deposits and send crab\n        uint256 i = depositsIndex;\n        uint256 amountToSend;\n        while (_quantity > 0) {\n            Receipt memory deposit = deposits[i];\n            if (deposit.amount == 0) {\n                i++;\n                continue;\n            }\n            if (deposit.amount <= _quantity) {\n                // deposit amount is lesser than quantity use it fully\n                _quantity = _quantity - deposit.amount;\n                usdBalance[deposit.sender] -= deposit.amount;\n                amountToSend = (deposit.amount * 1e18) / _price;\n                IERC20(crab).transfer(deposit.sender, amountToSend);\n                emit USDCDeposited(deposit.sender, deposit.amount, amountToSend, i, 0);\n                delete deposits[i];\n                i++;\n            } else {\n                // deposit amount is greater than quantity; use it partially\n                deposits[i].amount = deposit.amount - _quantity;\n                usdBalance[deposit.sender] -= _quantity;\n                amountToSend = (_quantity * 1e18) / _price;\n                IERC20(crab).transfer(deposit.sender, amountToSend);\n                emit USDCDeposited(deposit.sender, _quantity, amountToSend, i, 0);\n                _quantity = 0;\n            }\n        }\n        depositsIndex = i;\n\n        // process withdraws and send usdc\n        i = withdrawsIndex;\n        while (crabQuantity > 0) {\n            Receipt memory withdraw = withdraws[i];\n            if (withdraw.amount == 0) {\n                i++;\n                continue;\n            }\n            if (withdraw.amount <= crabQuantity) {\n                crabQuantity = crabQuantity - withdraw.amount;\n                crabBalance[withdraw.sender] -= withdraw.amount;\n                amountToSend = (withdraw.amount * _price) / 1e18;\n                IERC20(usdc).transfer(withdraw.sender, amountToSend);\n\n                emit CrabWithdrawn(withdraw.sender, withdraw.amount, amountToSend, i);\n\n                delete withdraws[i];\n                i++;\n            } else {\n                withdraws[i].amount = withdraw.amount - crabQuantity;\n                crabBalance[withdraw.sender] -= crabQuantity;\n                amountToSend = (crabQuantity * _price) / 1e18;\n                IERC20(usdc).transfer(withdraw.sender, amountToSend);\n\n                emit CrabWithdrawn(withdraw.sender, withdraw.amount, amountToSend, i);\n\n                crabQuantity = 0;\n            }\n        }\n        withdrawsIndex = i;\n    }\n\n    /**\n     * @return sum usdc amount in queue\n     */\n    function depositsQueued() external view returns (uint256) {\n        uint256 j = depositsIndex;\n        uint256 sum;\n        while (j < deposits.length) {\n            sum = sum + deposits[j].amount;\n            j++;\n        }\n        return sum;\n    }\n\n    /**\n     * @return sum crab amount in queue\n     */\n    function withdrawsQueued() external view returns (uint256) {\n        uint256 j = withdrawsIndex;\n        uint256 sum;\n        while (j < withdraws.length) {\n            sum = sum + withdraws[j].amount;\n            j++;\n        }\n        return sum;\n    }\n\n    function checkOrder(Order memory _order) external {\n        return _checkOrder(_order);\n    }\n\n    /**\n     * @dev checks the expiry nonce and signer of an order\n     * @param _order is the Order struct\n     */\n    function _checkOrder(Order memory _order) internal {\n        _useNonce(_order.trader, _order.nonce);\n        bytes32 structHash = keccak256(\n            abi.encode(\n                _CRAB_NETTING_TYPEHASH,\n                _order.bidId,\n                _order.trader,\n                _order.quantity,\n                _order.price,\n                _order.isBuying,\n                _order.expiry,\n                _order.nonce\n            )\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n        address offerSigner = ECDSA.recover(hash, _order.v, _order.r, _order.s);\n        require(offerSigner == _order.trader, \"Signature not correct\");\n        require(_order.expiry >= block.timestamp, \"order expired\");\n    }\n\n    /**\n     * @dev calculates wSqueeth minted when amount is deposited\n     * @param _amount to deposit into crab\n     */\n    function _debtToMint(uint256 _amount) internal view returns (uint256) {\n        uint256 feeAdjustment = _calcFeeAdjustment();\n        (,, uint256 collateral, uint256 debt) = ICrabStrategyV2(crab).getVaultDetails();\n        uint256 wSqueethToMint = (_amount * debt) / (collateral + (debt * feeAdjustment));\n        return wSqueethToMint;\n    }\n\n    /**\n     * @dev takes in orders from mm's to buy sqth and deposits the usd amount from the depositQueue into crab along with the eth from selling sqth\n     * @param _p DepositAuction Params that contain orders, usdToDeposit, uniswap min amount and fee\n     */\n    function depositAuction(DepositAuctionParams calldata _p) external onlyOwner {\n        _checkOTCPrice(_p.clearingPrice, false);\n        /**\n         * step 1: get eth from mm\n         *     step 2: get eth from deposit usdc\n         *     step 3: crab deposit\n         *     step 4: flash deposit\n         *     step 5: send sqth to mms\n         *     step 6: send crab to depositors\n         */\n        uint256 initCrabBalance = IERC20(crab).balanceOf(address(this));\n        uint256 initEthBalance = address(this).balance;\n\n        uint256 sqthToSell = _debtToMint(_p.totalDeposit);\n        // step 1 get all the eth in\n        uint256 remainingToSell = sqthToSell;\n        for (uint256 i = 0; i < _p.orders.length; i++) {\n            require(_p.orders[i].isBuying, \"auction order not buying sqth\");\n            require(_p.orders[i].price >= _p.clearingPrice, \"buy order price less than clearing\");\n            _checkOrder(_p.orders[i]);\n            if (_p.orders[i].quantity >= remainingToSell) {\n                IWETH(weth).transferFrom(\n                    _p.orders[i].trader, address(this), (remainingToSell * _p.clearingPrice) / 1e18\n                );\n                remainingToSell = 0;\n                break;\n            } else {\n                IWETH(weth).transferFrom(\n                    _p.orders[i].trader, address(this), (_p.orders[i].quantity * _p.clearingPrice) / 1e18\n                );\n                remainingToSell -= _p.orders[i].quantity;\n            }\n        }\n        require(remainingToSell == 0, \"not enough buy orders for sqth\");\n\n        // step 2\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: usdc,\n            tokenOut: weth,\n            fee: _p.ethUSDFee,\n            recipient: address(this),\n            deadline: block.timestamp,\n            amountIn: _p.depositsQueued,\n            amountOutMinimum: _p.minEth,\n            sqrtPriceLimitX96: 0\n        });\n        swapRouter.exactInputSingle(params);\n\n        // step 3\n        IWETH(weth).withdraw(IWETH(weth).balanceOf(address(this)));\n        ICrabStrategyV2(crab).deposit{value: _p.totalDeposit}();\n\n        // step 4\n        Portion memory to_send;\n        to_send.eth = address(this).balance - initEthBalance;\n        if (to_send.eth > 0 && _p.ethToFlashDeposit > 0) {\n            if (to_send.eth <= _p.ethToFlashDeposit) {\n                // we cant send more than the flashDeposit\n                ICrabStrategyV2(crab).flashDeposit{value: to_send.eth}(_p.ethToFlashDeposit, _p.flashDepositFee);\n            }\n        }\n\n        // step 5\n        to_send.sqth = IERC20(sqth).balanceOf(address(this));\n        remainingToSell = to_send.sqth;\n        for (uint256 j = 0; j < _p.orders.length; j++) {\n            if (_p.orders[j].quantity < remainingToSell) {\n                IERC20(sqth).transfer(_p.orders[j].trader, _p.orders[j].quantity);\n                remainingToSell -= _p.orders[j].quantity;\n                emit BidTraded(_p.orders[j].bidId, _p.orders[j].trader, _p.orders[j].quantity, _p.clearingPrice, true);\n            } else {\n                IERC20(sqth).transfer(_p.orders[j].trader, remainingToSell);\n                emit BidTraded(_p.orders[j].bidId, _p.orders[j].trader, remainingToSell, _p.clearingPrice, true);\n                break;\n            }\n        }\n\n        // step 6 send crab to depositors\n        uint256 remainingDeposits = _p.depositsQueued;\n        uint256 k = depositsIndex;\n\n        to_send.crab = IERC20(crab).balanceOf(address(this)) - initCrabBalance;\n        // get the balance between start and now\n        to_send.eth = address(this).balance - initEthBalance;\n        IWETH(weth).deposit{value: to_send.eth}();\n\n        while (remainingDeposits > 0) {\n            uint256 queuedAmount = deposits[k].amount;\n            Portion memory portion;\n            if (queuedAmount == 0) {\n                k++;\n                continue;\n            }\n            if (queuedAmount <= remainingDeposits) {\n                remainingDeposits = remainingDeposits - queuedAmount;\n                usdBalance[deposits[k].sender] -= queuedAmount;\n\n                portion.crab = (((queuedAmount * 1e18) / _p.depositsQueued) * to_send.crab) / 1e18;\n\n                IERC20(crab).transfer(deposits[k].sender, portion.crab);\n\n                portion.eth = (((queuedAmount * 1e18) / _p.depositsQueued) * to_send.eth) / 1e18;\n                if (portion.eth > 1e12) {\n                    IWETH(weth).transfer(deposits[k].sender, portion.eth);\n                } else {\n                    portion.eth = 0;\n                }\n                emit USDCDeposited(deposits[k].sender, queuedAmount, portion.crab, k, portion.eth);\n\n                delete deposits[k];\n                k++;\n            } else {\n                usdBalance[deposits[k].sender] -= remainingDeposits;\n\n                portion.crab = (((remainingDeposits * 1e18) / _p.depositsQueued) * to_send.crab) / 1e18;\n                IERC20(crab).transfer(deposits[k].sender, portion.crab);\n\n                portion.eth = (((remainingDeposits * 1e18) / _p.depositsQueued) * to_send.eth) / 1e18;\n                if (portion.eth > 1e12) {\n                    IWETH(weth).transfer(deposits[k].sender, portion.eth);\n                } else {\n                    portion.eth = 0;\n                }\n                emit USDCDeposited(deposits[k].sender, remainingDeposits, portion.crab, k, portion.eth);\n\n                deposits[k].amount -= remainingDeposits;\n                remainingDeposits = 0;\n            }\n        }\n        depositsIndex = k;\n        isAuctionLive = false;\n    }\n\n    /**\n     * @dev takes in orders from mm's to sell sqth and withdraws the crab amount in q\n     * @param _p Withdraw Params that contain orders, crabToWithdraw, uniswap min amount and fee\n     */\n    function withdrawAuction(WithdrawAuctionParams calldata _p) public onlyOwner {\n        _checkOTCPrice(_p.clearingPrice, true);\n        uint256 initWethBalance = IERC20(weth).balanceOf(address(this));\n        uint256 initEthBalance = address(this).balance;\n        /**\n         * step 1: get sqth from mms\n         *     step 2: withdraw from crab\n         *     step 3: send eth to mms\n         *     step 4: convert eth to usdc\n         *     step 5: send usdc to withdrawers\n         */\n\n        // step 1 get sqth from mms\n        uint256 sqthRequired = ICrabStrategyV2(crab).getWsqueethFromCrabAmount(_p.crabToWithdraw);\n        uint256 toPull = sqthRequired;\n        for (uint256 i = 0; i < _p.orders.length && toPull > 0; i++) {\n            _checkOrder(_p.orders[i]);\n            require(!_p.orders[i].isBuying, \"auction order is not selling\");\n            require(_p.orders[i].price <= _p.clearingPrice, \"sell order price greater than clearing\");\n            if (_p.orders[i].quantity < toPull) {\n                toPull -= _p.orders[i].quantity;\n                IERC20(sqth).transferFrom(_p.orders[i].trader, address(this), _p.orders[i].quantity);\n            } else {\n                IERC20(sqth).transferFrom(_p.orders[i].trader, address(this), toPull);\n                toPull = 0;\n            }\n        }\n\n        // step 2 withdraw from crab\n        ICrabStrategyV2(crab).withdraw(_p.crabToWithdraw);\n\n        // step 3 pay all mms\n        IWETH(weth).deposit{value: address(this).balance - initEthBalance}();\n        toPull = sqthRequired;\n        uint256 sqthQuantity;\n        for (uint256 i = 0; i < _p.orders.length && toPull > 0; i++) {\n            if (_p.orders[i].quantity < toPull) {\n                sqthQuantity = _p.orders[i].quantity;\n            } else {\n                sqthQuantity = toPull;\n            }\n            IERC20(weth).transfer(_p.orders[i].trader, (sqthQuantity * _p.clearingPrice) / 1e18);\n            toPull -= sqthQuantity;\n            emit BidTraded(_p.orders[i].bidId, _p.orders[i].trader, sqthQuantity, _p.clearingPrice, false);\n        }\n\n        // step 4 convert to USDC\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: address(weth),\n            tokenOut: address(usdc),\n            fee: _p.ethUSDFee,\n            recipient: address(this),\n            deadline: block.timestamp,\n            amountIn: (IERC20(weth).balanceOf(address(this)) - initWethBalance),\n            amountOutMinimum: _p.minUSDC,\n            sqrtPriceLimitX96: 0\n        });\n        uint256 usdcReceived = swapRouter.exactInputSingle(params);\n\n        // step 5 pay all withdrawers and mark their withdraws as done\n        uint256 remainingWithdraws = _p.crabToWithdraw;\n        uint256 j = withdrawsIndex;\n        uint256 usdcAmount;\n        while (remainingWithdraws > 0) {\n            Receipt memory withdraw = withdraws[j];\n            if (withdraw.amount == 0) {\n                j++;\n                continue;\n            }\n            if (withdraw.amount <= remainingWithdraws) {\n                // full usage\n                remainingWithdraws -= withdraw.amount;\n                crabBalance[withdraw.sender] -= withdraw.amount;\n\n                // send proportional usdc\n                usdcAmount = (((withdraw.amount * 1e18) / _p.crabToWithdraw) * usdcReceived) / 1e18;\n                IERC20(usdc).transfer(withdraw.sender, usdcAmount);\n                emit CrabWithdrawn(withdraw.sender, withdraw.amount, usdcAmount, j);\n                delete withdraws[j];\n                j++;\n            } else {\n                withdraws[j].amount -= remainingWithdraws;\n                crabBalance[withdraw.sender] -= remainingWithdraws;\n\n                // send proportional usdc\n                usdcAmount = (((remainingWithdraws * 1e18) / _p.crabToWithdraw) * usdcReceived) / 1e18;\n                IERC20(usdc).transfer(withdraw.sender, usdcAmount);\n                emit CrabWithdrawn(withdraw.sender, remainingWithdraws, usdcAmount, j);\n\n                remainingWithdraws = 0;\n            }\n        }\n        withdrawsIndex = j;\n        isAuctionLive = false;\n    }\n\n    /**\n     * @notice owner can set the twap period in seconds that is used for obtaining TWAP prices\n     * @param _auctionTwapPeriod the twap period, in seconds\n     */\n    function setAuctionTwapPeriod(uint32 _auctionTwapPeriod) external onlyOwner {\n        require(_auctionTwapPeriod >= 180, \"twap period cannot be less than 180\");\n        uint32 previousTwap = auctionTwapPeriod;\n\n        auctionTwapPeriod = _auctionTwapPeriod;\n\n        emit SetAuctionTwapPeriod(previousTwap, _auctionTwapPeriod);\n    }\n\n    /**\n     * @notice owner can set a threshold, scaled by 1e18 that determines the maximum discount of a clearing sale price to the current uniswap twap price\n     * @param _otcPriceTolerance the OTC price tolerance, in percent, scaled by 1e18\n     */\n    function setOTCPriceTolerance(uint256 _otcPriceTolerance) external onlyOwner {\n        // Tolerance cannot be more than 20%\n        require(_otcPriceTolerance <= MAX_OTC_PRICE_TOLERANCE, \"Price tolerance has to be less than 20%\");\n        uint256 previousOtcTolerance = auctionTwapPeriod;\n\n        otcPriceTolerance = _otcPriceTolerance;\n\n        emit SetOTCPriceTolerance(previousOtcTolerance, _otcPriceTolerance);\n    }\n\n    /**\n     * @dev set nonce flag of the trader to true\n     * @param _trader address of the signer\n     * @param _nonce number that is to be traded only once\n     */\n    function _useNonce(address _trader, uint256 _nonce) internal {\n        require(!nonces[_trader][_nonce], \"Nonce already used\");\n        nonces[_trader][_nonce] = true;\n    }\n\n    /**\n     * @notice check that the proposed sale price is within a tolerance of the current Uniswap twap\n     * @param _price clearing price provided by manager\n     * @param _isAuctionBuying is crab buying or selling oSQTH\n     */\n    function _checkOTCPrice(uint256 _price, bool _isAuctionBuying) internal view {\n        // Get twap\n        uint256 squeethEthPrice = IOracle(oracle).getTwap(ethSqueethPool, sqth, weth, auctionTwapPeriod, true);\n\n        if (_isAuctionBuying) {\n            require(\n                _price <= (squeethEthPrice * (1e18 + otcPriceTolerance)) / 1e18,\n                \"Price too high relative to Uniswap twap.\"\n            );\n        } else {\n            require(\n                _price >= (squeethEthPrice * (1e18 - otcPriceTolerance)) / 1e18,\n                \"Price too low relative to Uniswap twap.\"\n            );\n        }\n    }\n\n    function _checkCrabPrice(uint256 _price) internal view {\n        // Get twap\n        uint256 squeethEthPrice = IOracle(oracle).getTwap(ethSqueethPool, sqth, weth, auctionTwapPeriod, true);\n        uint256 usdcEthPrice = IOracle(oracle).getTwap(ethUsdcPool, weth, usdc, auctionTwapPeriod, true);\n        (,, uint256 collateral, uint256 debt) = ICrabStrategyV2(crab).getVaultDetails();\n        uint256 crabFairPrice =\n            ((collateral - ((debt * squeethEthPrice) / 1e18)) * usdcEthPrice) / ICrabStrategyV2(crab).totalSupply();\n        crabFairPrice = crabFairPrice / 1e12; //converting from units of 18 to 6\n        require(_price <= (crabFairPrice * (1e18 + otcPriceTolerance)) / 1e18, \"Crab Price too high\");\n        require(_price >= (crabFairPrice * (1e18 - otcPriceTolerance)) / 1e18, \"Crab Price too low\");\n    }\n\n    function _calcFeeAdjustment() internal view returns (uint256) {\n        uint256 feeRate = IController(sqthController).feeRate();\n        if (feeRate == 0) return 0;\n        uint256 squeethEthPrice = IOracle(oracle).getTwap(ethSqueethPool, sqth, weth, sqthTwapPeriod, true);\n        return (squeethEthPrice * feeRate) / 10000;\n    }\n\n    receive() external payable {\n        require(msg.sender == weth || msg.sender == crab, \"only weth and crab can send me monies\");\n    }\n}"
    },
    {
      "filename": "crab-netting/src/CrabNetting.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.13;\n\n// interface\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {IWETH} from \"../src/interfaces/IWETH.sol\";\nimport {IOracle} from \"../src/interfaces/IOracle.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport {ICrabStrategyV2} from \"../src/interfaces/ICrabStrategyV2.sol\";\nimport {IController} from \"../src/interfaces/IController.sol\";\n\n// contract\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {EIP712} from \"openzeppelin/utils/cryptography/draft-EIP712.sol\";\nimport {ECDSA} from \"openzeppelin/utils/cryptography/ECDSA.sol\";\n\n/// @dev order struct for a signed order from market maker\nstruct Order {\n    uint256 bidId;\n    address trader;\n    uint256 quantity;\n    uint256 price;\n    bool isBuying;\n    uint256 expiry;\n    uint256 nonce;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\n/// @dev struct to store proportional amounts of erc20s (received or to send)\nstruct Portion {\n    uint256 crab;\n    uint256 eth;\n    uint256 sqth;\n}\n\n/// @dev params for deposit auction\nstruct DepositAuctionParams {\n    /// @dev USDC to deposit\n    uint256 depositsQueued;\n    /// @dev minETH equivalent to get from uniswap of the USDC to deposit\n    uint256 minEth;\n    /// @dev total ETH t"
    }
  ]
}