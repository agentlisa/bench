{
  "Title": "[N-01] `safeApprove()` is deprecated",
  "Content": "\n[Deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of `safeIncreaseAllowance()` and `safeDecreaseAllowance()`. If only setting the initial allowance to the value that means infinite, `safeIncreaseAllowance()` can be used instead\n\n*There are 3 instances of this issue:*\n\n```solidity\nFile: contracts/MyStrategy.sol   #1\n\n65:           AURA.safeApprove(address(LOCKER), type(uint256).max);\n```\n\n<https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L65>\n\n```solidity\nFile: contracts/MyStrategy.sol   #2\n\n67:           AURABAL.safeApprove(address(BALANCER_VAULT), type(uint256).max);\n```\n\n<https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L67>\n\n```solidity\nFile: contracts/MyStrategy.sol   #3\n\n68:           WETH.safeApprove(address(BALANCER_VAULT), type(uint256).max);\n```\n\n<https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L68>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-06-badger",
  "Code": [
    {
      "filename": "contracts/token/ERC20/utils/SafeERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"
    },
    {
      "filename": "contracts/MyStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {IERC20Upgradeable} from \"@openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin-contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {SafeMathUpgradeable} from \"@openzeppelin-contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin-contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport {BaseStrategy} from \"@badger-finance/BaseStrategy.sol\";\n\nimport {IVault} from \"../interfaces/badger/IVault.sol\";\nimport {IAsset} from \"../interfaces/balancer/IAsset.sol\";\nimport {ExitKind, IBalancerVault} from \"../interfaces/balancer/IBalancerVault.sol\";\nimport {IAuraLocker} from \"../interfaces/aura/IAuraLocker.sol\";\nimport {IRewardDistributor} from \"../interfaces/hiddenhand/IRewardDistributor.sol\";\nimport {IBribesProcessor} from \"../interfaces/badger/IBribesProcessor.sol\";\nimport {IWeth} from \"../interfaces/weth/IWeth.sol\";\n\ncontract MyStrategy is BaseStrategy, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMathUpgradeable for uint256;\n\n    bool public withdrawalSafetyCheck;\n    // If nothing is unlocked, processExpiredLocks will revert\n    bool public processLocksOnReinvest;\n\n    bool private isClaimingBribes;\n\n    IBribesProcessor public bribesProcessor;\n\n    IBalancerVault public constant BALANCER_VAULT = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n\n    address public constant BADGER = 0x3472A5A71965499acd81997a54BBA8D852C6E53d;\n    address public constant BADGER_TREE = 0x660802Fc641b154aBA66a62137e71f331B6d787A;\n\n    IAuraLocker public constant LOCKER = IAuraLocker(0x3Fa73f1E5d8A792C80F426fc8F84FBF7Ce9bBCAC);\n\n    IERC20Upgradeable public constant BAL = IERC20Upgradeable(0xba100000625a3754423978a60c9317c58a424e3D);\n    IERC20Upgradeable public constant WETH = IERC20Upgradeable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20Upgradeable public constant AURA = IERC20Upgradeable(0xC0c293ce456fF0ED870ADd98a0828Dd4d2903DBF);\n    IERC20Upgradeable public constant AURABAL = IERC20Upgradeable(0x616e8BfA43F920657B3497DBf40D6b1A02D4608d);\n    IERC20Upgradeable public constant BALETH_BPT = IERC20Upgradeable(0x5c6Ee304399DBdB9C8Ef030aB642B10820DB8F56);\n\n    bytes32 public constant AURABAL_BALETH_BPT_POOL_ID = 0x3dd0843a028c86e0b760b1a76929d1c5ef93a2dd000200000000000000000249;\n    bytes32 public constant BAL_ETH_POOL_ID = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;\n    bytes32 public constant AURA_ETH_POOL_ID = 0xc29562b045d80fd77c69bec09541f5c16fe20d9d000200000000000000000251;\n\n    uint256 private constant BPT_WETH_INDEX = 1;\n\n    event RewardsCollected(address token, uint256 amount);\n\n    /// @dev Initialize the Strategy with security settings as well as tokens\n    /// @notice Proxies will set any non constant variable you declare as default value\n    /// @dev add any extra changeable variable at end of initializer as shown\n    function initialize(address _vault) public initializer {\n        assert(IVault(_vault).token() == address(AURA));\n\n        __BaseStrategy_init(_vault);\n\n        want = address(AURA);\n\n        /// @dev do one off approvals here\n        // Permissions for Locker\n        AURA.safeApprove(address(LOCKER), type(uint256).max);\n\n        AURABAL.safeApprove(address(BALANCER_VAULT), type(uint256).max);\n        WETH.safeApprove(address(BALANCER_VAULT), type(uint256).max);\n\n        // Set Safe Defaults\n        withdrawalSafetyCheck = true;\n\n        // Process locks on reinvest is best left false as gov can figure out if they need to save that gas\n    }\n\n    /// ===== Extra Functions =====\n\n    /// @dev Change Delegation to another address\n    function manualSetDelegate(address delegate) external {\n        _onlyGovernance();\n        // Set delegate is enough as it will clear previous delegate automatically\n        LOCKER.delegate(delegate);\n    }\n\n    ///@dev Should we check if the amount requested is more than what we can return on withdrawal?\n    function setWithdrawalSafetyCheck(bool newWithdrawalSafetyCheck) external {\n        _onlyGovernance();\n        withdrawalSafetyCheck = newWithdrawalSafetyCheck;\n    }\n\n    ///@dev Should we processExpiredLocks during reinvest?\n    function setProcessLocksOnReinvest(bool newProcessLocksOnReinvest) external {\n        _onlyGovernance();\n        processLocksOnReinvest = newProcessLocksOnReinvest;\n    }\n\n     ///@dev Change the contract that handles bribes\n    function setBribesProcessor(IBribesProcessor newBribesProcessor) external {\n        _onlyGovernance();\n        bribesProcessor = newBribesProcessor;\n    }\n\n    /// @dev Function to move rewards that are not protected\n    /// @notice Only not protected, moves the whole amount using _handleRewardTransfer\n    /// @notice because token paths are hardcoded, this function is safe to be called by anyone\n    /// @notice Will not notify the BRIBES_PROCESSOR as this could be triggered outside bribes\n    function sweepRewardToken(address token) public nonReentrant {\n        _onlyGovernanceOrStrategist();\n        _onlyNotProtectedTokens(token);\n\n        uint256 toSend = IERC20Upgradeable(token).balanceOf(address(this));\n        _handleRewardTransfer(token, toSend);\n    }\n\n    /// @dev Bulk function for sweepRewardToken\n    function sweepRewards(address[] calldata tokens) external {\n        uint256 length = tokens.length;\n        for(uint i = 0; i < length; i++){\n            sweepRewardToken(tokens[i]);\n        }\n    }\n\n   /// ===== View Functions =====\n\n    /// @dev Return the name of the strategy\n    function getName() external pure override returns (string memory) {\n        return \"vlAURA Voting Strategy\";\n    }\n\n    /// @dev Specify the version of the Strategy, for upgrades\n    function version() external pure returns (string memory) {\n        return \"1.0\";\n    }\n\n    /// @dev Does this function require `tend` to be called?\n    function _isTendable() internal pure override returns (bool) {\n        return false; // Change to true if the strategy should be tended\n    }\n\n    /// @dev Return the balance (in want) that the strategy has invested somewhere\n    function balanceOfPool() public view override returns (uint256) {\n        // Return the balance in locker\n        IAuraLocker.Balances memory balances = LOCKER.balances(address(this));\n        return balances.locked;\n    }\n\n    /// @dev Return the balance of rewards that the strategy has accrued\n    /// @notice Used for offChain APY and Harvest Health monitoring\n    function balanceOfRewards() external view override returns (TokenAmount[] memory rewards) {\n        IAuraLocker.EarnedData[] memory earnedData = LOCKER.claimableRewards(address(this));\n        uint256 numRewards = earnedData.length;\n        rewards = new TokenAmount[](numRewards);\n        for (uint256 i; i < numRewards; ++i) {\n            rewards[i] = TokenAmount(earnedData[i].token, earnedData[i].amount);\n        }\n    }\n\n    /// @dev Return a list of protected tokens\n    /// @notice It's very important all tokens that are meant to be in the strategy to be marked as protected\n    /// @notice this provides security guarantees to the depositors they can't be sweeped away\n    function getProtectedTokens() public view virtual override returns (address[] memory) {\n        address[] memory protectedTokens = new address[](2);\n        protectedTokens[0] = want; // AURA\n        protectedTokens[1] = address(AURABAL);\n        return protectedTokens;\n    }\n\n    /// ===== Internal Core Implementations =====\n\n    /// @dev Deposit `_amount` of want, investing it to earn yield\n    function _deposit(uint256 _amount) internal override {\n        // Lock tokens for 16 weeks, send credit to strat\n        LOCKER.lock(address(this), _amount);\n    }\n\n    /// @dev utility function to withdraw all AURA that we can from the lock\n    function prepareWithdrawAll() external {\n        manualProcessExpiredLocks();\n    }\n\n    /// @dev Withdraw all funds, this is used for migrations, most of the time for emergency reasons\n    function _withdrawAll() internal override {\n        //NOTE: This probably will always fail unless we have all tokens expired\n        require(\n            balanceOfPool() == 0 && LOCKER.balanceOf(address(this)) == 0,\n            \"You have to wait for unlock or have to manually rebalance out of it\"\n        );\n\n        // Make sure to call prepareWithdrawAll before _withdrawAll\n    }\n\n    /// @dev Withdraw `_amount` of want, so that it can be sent to the vault / depositor\n    /// @notice just unlock the funds and return the amount you could unlock\n    function _withdrawSome(uint256 _amount) internal override returns (uint256) {\n        uint256 max = balanceOfWant();\n\n        if (_amount > max) {\n            // Try to unlock, as much as possible\n            // @notice Reverts if no locks expired\n            LOCKER.processExpiredLocks(false);\n            max = balanceOfWant();\n        }\n\n        if (withdrawalSafetyCheck) {\n            require(max >= _amount.mul(9_980).div(MAX_BPS), \"Withdrawal Safety Check\"); // 20 BP of slippage\n        }\n\n        if (_amount > max) {\n            return max;\n        }\n\n        return _amount;\n    }\n\n    /// @notice Autocompound auraBAL rewards into AURA.\n    /// @dev Anyone can claim bribes for this contract from hidden hands with \n    ///      the correct merkle proof. Therefore, only tokens that are gained\n    ///      after claiming rewards or swapping are auto-compunded.\n    function _harvest() internal override returns (TokenAmount[] memory harvested) {\n        uint256 auraBalBalanceBefore = AURABAL.balanceOf(address(this));\n\n        // Claim auraBAL from locker\n        LOCKER.getReward(address(this));\n\n        harvested = new TokenAmount[](1);\n        harvested[0].token = address(AURA);\n\n        uint256 auraBalEarned = AURABAL.balanceOf(address(this)).sub(auraBalBalanceBefore);\n        // auraBAL -> BAL/ETH BPT -> WETH -> AURA\n        if (auraBalEarned > 0) {\n            // Common structs for swaps\n            IBalancerVault.SingleSwap memory singleSwap;\n            IBalancerVault.FundManagement memory fundManagement = IBalancerVault.FundManagement({\n                sender: address(this),\n                fromInternalBalance: false,\n                recipient: payable(address(this)),\n                toInternalBalance: false\n            });\n\n            // Swap auraBal -> BAL/ETH BPT\n            singleSwap = IBalancerVault.SingleSwap({\n                poolId: AURABAL_BALETH_BPT_POOL_ID,\n                kind: IBalancerVault.SwapKind.GIVEN_IN,\n                assetIn: IAsset(address(AURABAL)),\n                assetOut: IAsset(address(BALETH_BPT)),\n                amount: auraBalEarned,\n                userData: new bytes(0)\n            });\n            uint256 balEthBptEarned = BALANCER_VAULT.swap(singleSwap, fundManagement, 0, type(uint256).max);\n\n            // Withdraw BAL/ETH BPT -> WETH\n            uint256 wethBalanceBefore = WETH.balanceOf(address(this));\n\n            IAsset[] memory assets = new IAsset[](2);\n            assets[0] = IAsset(address(BAL));\n            assets[1] = IAsset(address(WETH));\n            IBalancerVault.ExitPoolRequest memory exitPoolRequest = IBalancerVault.ExitPoolRequest({\n                assets: assets,\n                minAmountsOut: new uint256[](2),\n                userData: abi.encode(ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, balEthBptEarned, BPT_WETH_INDEX),\n                toInternalBalance: false\n            });\n            BALANCER_VAULT.exitPool(BAL_ETH_POOL_ID, address(this), payable(address(this)), exitPoolRequest);\n\n            // Swap WETH -> AURA\n            uint256 wethEarned = WETH.balanceOf(address(this)).sub(wethBalanceBefore);\n            singleSwap = IBalancerVault.SingleSwap({\n                poolId: AURA_ETH_POOL_ID,\n                kind: IBalancerVault.SwapKind.GIVEN_IN,\n                assetIn: IAsset(address(WETH)),\n                assetOut: IAsset(address(AURA)),\n                amount: wethEarned,\n                userData: new bytes(0)\n            });\n            harvested[0].amount = BALANCER_VAULT.swap(singleSwap, fundManagement, 0, type(uint256).max);\n        }\n\n        _reportToVault(harvested[0].amount);\n        if (harvested[0].amount > 0) {\n            _deposit(harvested[0].amount);\n        }\n    }\n\n    // TODO: Hardcode claim.account = address(this)?\n    /// @dev allows claiming of multiple bribes, badger is sent to tree\n    /// @notice Hidden hand only allows to claim all tokens at once, not individually.\n    ///         Allows claiming any token as it uses the difference in balance\n    function claimBribesFromHiddenHand(IRewardDistributor hiddenHandDistributor, IRewardDistributor.Claim[] calldata _claims) external nonReentrant {\n        _onlyGovernanceOrStrategist();\n        require(address(bribesProcessor) != address(0), \"Bribes processor not set\");\n\n        uint256 beforeVaultBalance = _getBalance();\n        uint256 beforePricePerFullShare = _getPricePerFullShare();\n\n        // Hidden hand uses BRIBE_VAULT address as a substitute for ETH\n        address hhBribeVault = hiddenHandDistributor.BRIBE_VAULT();\n\n        // Track token balances before bribes claim\n        uint256[] memory beforeBalance = new uint256[](_claims.length);\n        for (uint256 i = 0; i < _claims.length; i++) {\n            (address token, , , ) = hiddenHandDistributor.rewards(_claims[i].identifier);\n            if (token == hhBribeVault) {\n                beforeBalance[i] = address(this).balance;\n            } else {\n                beforeBalance[i] = IERC20Upgradeable(token).balanceOf(address(this));\n            }\n        }\n\n        // Claim bribes\n        isClaimingBribes = true;\n        hiddenHandDistributor.claim(_claims);\n        isClaimingBribes = false;\n\n        bool nonZeroDiff; // Cached value but also to check if we need to notifyProcessor\n        // Ultimately it's proof of non-zero which is good enough\n\n        for (uint256 i = 0; i < _claims.length; i++) {\n            (address token, , , ) = hiddenHandDistributor.rewards(_claims[i].identifier);\n\n            if (token == hhBribeVault) {\n                // ETH\n                uint256 difference = address(this).balance.sub(beforeBalance[i]);\n                if (difference > 0) {\n                    IWeth(address(WETH)).deposit{value: difference}();\n                    nonZeroDiff = true;\n                    _handleRewardTransfer(address(WETH), difference);\n                }\n            } else {\n                uint256 difference = IERC20Upgradeable(token).balanceOf(address(this)).sub(beforeBalance[i]);\n                if (difference > 0) {\n                    nonZeroDiff = true;\n                    _handleRewardTransfer(token, difference);\n                }\n            }\n        }\n\n        if (nonZeroDiff) {\n            _notifyBribesProcessor();\n        }\n\n        require(beforeVaultBalance == _getBalance(), \"Balance can't change\");\n        require(beforePricePerFullShare == _getPricePerFullShare(), \"Ppfs can't change\");\n    }\n\n    // Example tend is a no-op which returns the values, could also just revert\n    function _tend() internal override returns (TokenAmount[] memory tended) {\n        revert(\"no op\");\n    }\n\n    /// MANUAL FUNCTIONS ///\n\n    /// @dev manual function to reinvest all Aura that was locked\n    function reinvest() external whenNotPaused returns (uint256) {\n        _onlyGovernance();\n\n        if (processLocksOnReinvest) {\n            // Withdraw all we can\n            LOCKER.processExpiredLocks(false);\n        }\n\n        // Redeposit all into vlAURA\n        uint256 toDeposit = IERC20Upgradeable(want).balanceOf(address(this));\n\n        // Redeposit into vlAURA\n        _deposit(toDeposit);\n\n        return toDeposit;\n    }\n\n    /// @dev process all locks, to redeem\n    /// @notice No Access Control Checks, anyone can unlock an expired lock\n    function manualProcessExpiredLocks() public whenNotPaused {\n        // Unlock vlAURA that is expired and redeem AURA back to this strat\n        LOCKER.processExpiredLocks(false);\n    }\n\n    /// @dev Send all available Aura to the Vault\n    /// @notice you can do this so you can earn again (re-lock), or just to add to the redemption pool\n    function manualSendAuraToVault() external whenNotPaused {\n        _onlyGovernance();\n        uint256 auraAmount = balanceOfWant();\n        _transferToVault(auraAmount);\n    }\n\n    function checkUpkeep(bytes calldata checkData) external view returns (bool upkeepNeeded, bytes memory performData) {\n        (, uint256 unlockable, ,) = LOCKER.lockedBalances(address(this));\n        upkeepNeeded = unlockable > 0;\n    }\n\n    /// @dev Function for ChainLink Keepers to automatically process expired locks\n    function performUpkeep(bytes calldata performData) external {\n        // Works like this because it reverts if lock is not expired\n        LOCKER.processExpiredLocks(false);\n    }\n\n    function _getBalance() internal returns (uint256) {\n        return IVault(vault).balance();\n    }\n\n    function _getPricePerFullShare() internal returns (uint256) {\n        return IVault(vault).getPricePerFullShare();\n    }\n\n    /// *** Handling of rewards ***\n    function _handleRewardTransfer(address token, uint256 amount) internal {\n        // NOTE: BADGER is emitted through the tree\n        if (token == BADGER) {\n            _sendBadgerToTree(amount);\n        } else {\n            // NOTE: All other tokens are sent to bribes processor\n            _sendTokenToBribesProcessor(token, amount);\n        }\n    }\n\n    /// @dev Notify the BribesProcessor that a new round of bribes has happened\n    function _notifyBribesProcessor() internal {\n        bribesProcessor.notifyNewRound();\n    }\n\n    /// @dev Send funds to the bribes receiver\n    function _sendTokenToBribesProcessor(address token, uint256 amount) internal {\n        // TODO: Too many SLOADs\n        IERC20Upgradeable(token).safeTransfer(address(bribesProcessor), amount);\n        emit RewardsCollected(token, amount);\n    }\n\n    /// @dev Send the BADGER token to the badgerTree\n    function _sendBadgerToTree(uint256 amount) internal {\n        IERC20Upgradeable(BADGER).safeTransfer(BADGER_TREE, amount);\n        _processExtraToken(address(BADGER), amount);\n    }\n\n    /// PAYABLE FUNCTIONS ///\n\n    /// @dev Can only receive ether from Hidden Hand\n    receive() external payable {\n        require(isClaimingBribes, \"onlyWhileClaiming\");\n    }\n}"
    },
    {
      "filename": "contracts/MyStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {IERC20Upgradeable} from \"@openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin-contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {SafeMathUpgradeable} from \"@openzeppelin-contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin-contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport {BaseStrategy} from \"@badger-finance/BaseStrategy.sol\";\n\nimport {IVault} from \"../interfaces/badger/IVault.sol\";\nimport {IAsset} from \"../interfaces/balancer/IAsset.sol\";\nimport {ExitKind, IBalancerVault} from \"../interfaces/balancer/IBalancerVault.sol\";\nimport {IAuraLocker} from \"../interfaces/aura/IAuraLocker.sol\";\nimport {IRewardDistributor} from \"../interfaces/hiddenhand/IRewardDistributor.sol\";\nimport {IBribesProcessor} from \"../interfaces/badger/IBribesProcessor.sol\";\nimport {IWeth} from \"../interfaces/weth/IWeth.sol\";\n\ncontract MyStrategy is BaseStrategy, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMathUpgradeable for uint256;\n\n    bool public withdrawalSafetyCheck;\n    // If nothing is unlocked, processExpiredLocks will revert\n    bool public processLocksOnReinvest;\n\n    bool private isClaimingBribes;\n\n    IBribesProcessor public bribesProcessor;\n\n    IBalancerVault public constant BALANCER_VAULT = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n\n    address public constant BADGER = 0x3472A5A71965499acd81997a54BBA8D852C6E53d;\n    address public constant BADGER_TREE = 0x660802Fc641b154aBA66a62137e71f331B6d787A;\n\n    IAuraLocker public constant LOCKER = IAuraLocker(0x3Fa73f1E5d8A792C80F426fc8F84FBF7Ce9bBCAC);\n\n    IERC20Upgradeable public constant BAL = IERC20Upgradeable(0xba100000625a3754423978a60c9317c58a424e3D);\n    IERC20Upgradeable public constant WETH = IERC20Upgradeable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20Upgradeable public constant AURA = IERC20Upgradeable(0xC0c293ce456fF0ED870ADd98a0828Dd4d2903DBF);\n    IERC20Upgradeable public constant AURABAL = IERC20Upgradeable(0x616e8BfA43F920657B3497DBf40D6b1A02D4608d);\n    IERC20Upgradeable public constant BALETH_BPT = IERC20Upgradeable(0x5c6Ee304399DBdB9C8Ef030aB642B10820DB8F56);\n\n    bytes32 public constant AURABAL_BALETH_BPT_POOL_ID = 0x3dd0843a028c86e0b760b1a76929d1c5ef93a2dd000200000000000000000249;\n    bytes32 public constant BAL_ETH_POOL_ID = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;\n    bytes32 public constant AURA_ETH_POOL_ID = 0xc29562b045d80fd77c69bec09541f5c16fe20d9d000200000000000000000251;\n\n    uint256 private constant BPT_WETH_INDEX = 1;\n\n    event RewardsCollected(address token, uint256 amount);\n\n    /// @dev Initialize the Strategy with security settings as well as tokens\n    /// @notice Proxies will set any non constant variable you declare as default value\n    /// @dev add any extra changeable variable at end of initializer as shown\n    function initialize(address _vault) public initializer {\n        assert(IVault(_vault).token() == address(AURA));\n\n        __BaseStrategy_init(_vault);\n\n        want = address(AURA);\n\n        /// @dev do one off approvals here\n        // Permissions for Locker\n        AURA.safeApprove(address(LOCKER), type(uint256).max);\n\n        AURABAL.safeApprove(address(BALANCER_VAULT), type(uint256).max);\n        WETH.safeApprove(address(BALANCER_VAULT), type(uint256).max);\n\n        // Set Safe Defaults\n        withdrawalSafetyCheck = true;\n\n        // Process locks on reinvest is best left false as gov can figure out if they need to save that gas\n    }\n\n    /// ===== Extra Functions =====\n\n    /// @dev Change Delegation to another address\n    function manualSetDelegate(address delegate) external {\n        _onlyGovernance();\n        // Set delegate is enough as it will clear previous delegate automatically\n        LOCKER.delegate(delegate);\n    }\n\n    ///@dev Should we check if the amount requested is more than what we can return on withdrawal?\n    function setWithdrawalSafetyCheck(bool newWithdrawalSafetyCheck) external {\n        _onlyGovernance();\n        withdrawalSafetyCheck = newWithdrawalSafetyCheck;\n    }\n\n    ///@dev Should we processExpiredLocks during reinvest?\n    function setProcessLocksOnReinvest(bool newProcessLocksOnReinvest) external {\n        _onlyGovernance();\n        processLocksOnReinvest = newProcessLocksOnReinvest;\n    }\n\n     ///@dev Change the contract that handles bribes\n    function setBribesProcessor(IBribesProcessor newBribesProcessor) external {\n        _onlyGovernance();\n        bribesProcessor = newBribesProcessor;\n    }\n\n    /// @dev Function to move rewards that are not protected\n    /// @notice Only not protected, moves the whole amount using _handleRewardTransfer\n    /// @notice because token paths are hardcoded, this function is safe to be called by anyone\n    /// @notice Will not notify the BRIBES_PROCESSOR as this could be triggered outside bribes\n    function sweepRewardToken(address token) public nonReentrant {\n        _onlyGovernanceOrStrategist();\n        _onlyNotProtectedTokens(token);\n\n        uint256 toSend = IERC20Upgradeable(token).balanceOf(address(this));\n        _handleRewardTransfer(token, toSend);\n    }\n\n    /// @dev Bulk function for sweepRewardToken\n    function sweepRewards(address[] calldata tokens) external {\n        uint256 length = tokens.length;\n        for(uint i = 0; i < length; i++){\n            sweepRewardToken(tokens[i]);\n        }\n    }\n\n   /// ===== View Functions =====\n\n    /// @dev Return the name of the strategy\n    function getName() external pure override returns (string memory) {\n        return \"vlAURA Voting Strategy\";\n    }\n\n    /// @dev Specify the version of the Strategy, for upgrades\n    function version() external pure returns (string memory) {\n        return \"1.0\";\n    }\n\n    /// @dev Does this function require `tend` to be called?\n    function _isTendable() internal pure override returns (bool) {\n        return false; // Change to true if the strategy should be tended\n    }\n\n    /// @dev Return the balance (in want) that the strategy has invested somewhere\n    function balanceOfPool() public view override returns (uint256) {\n        // Return the balance in locker\n        IAuraLocker.Balances memory balances = LOCKER.balances(address(this));\n        return balances.locked;\n    }\n\n    /// @dev Return the balance of rewards that the strategy has accrued\n    /// @notice Used for offChain APY and Harvest Health monitoring\n    function balanceOfRewards() external view override returns (TokenAmount[] memory rewards) {\n        IAuraLocker.EarnedData[] memory earnedData = LOCKER.claimableRewards(address(this));\n        uint256 numRewards = earnedData.length;\n        rewards = new TokenAmount[](numRewards);\n        for (uint256 i; i < numRewards; ++i) {\n            rewards[i] = TokenAmount(earnedData[i].token, earnedData[i].amount);\n        }\n    }\n\n    /// @dev Return a list of protected tokens\n    /// @notice It's very important all tokens that are meant to be in the strategy to be marked as protected\n    /// @notice this provides security guarantees to the depositors they can't be sweeped away\n    function getProtectedTokens() public view virtual override returns (address[] memory) {\n        address[] memory protectedTokens = new address[](2);\n        protectedTokens[0] = want; // AURA\n        protectedTokens[1] = address(AURABAL);\n        return protectedTokens;\n    }\n\n    /// ===== Internal Core Implementations =====\n\n    /// @dev Deposit `_amount` of want, investing it to earn yield\n    function _deposit(uint256 _amount) internal override {\n        // Lock tokens for 16 weeks, send credit to strat\n        LOCKER.lock(address(this), _amount);\n    }\n\n    /// @dev utility function to withdraw all AURA that we can from the lock\n    function prepareWithdrawAll() external {\n        manualProcessExpiredLocks();\n    }\n\n    /// @dev Withdraw all funds, this is used for migrations, most of the time for emergency reasons\n    function _withdrawAll() internal override {\n        //NOTE: This probably will always fail unless we have all tokens expired\n        require(\n            balanceOfPool() == 0 && LOCKER.balanceOf(address(this)) == 0,\n            \"You have to wait for unlock or have to manually rebalance out of it\"\n        );\n\n        // Make sure to call prepareWithdrawAll before _withdrawAll\n    }\n\n    /// @dev Withdraw `_amount` of want, so that it can be sent to the vault / depositor\n    /// @notice just unlock the funds and return the amount you could unlock\n    function _withdrawSome(uint256 _amount) internal override returns (uint256) {\n        uint256 max = balanceOfWant();\n\n        if (_amount > max) {\n            // Try to unlock, as much as possible\n            // @notice Reverts if no locks expired\n            LOCKER.processExpiredLocks(false);\n            max = balanceOfWant();\n        }\n\n        if (withdrawalSafetyCheck) {\n            require(max >= _amount.mul(9_980).div(MAX_BPS), \"Withdrawal Safety Check\"); // 20 BP of slippage\n        }\n\n        if (_amount > max) {\n            return max;\n        }\n\n        return _amount;\n    }\n\n    /// @notice Autocompound auraBAL rewards into AURA.\n    /// @dev Anyone can claim bribes for this contract from hidden hands with \n    ///      the correct merkle proof. Therefore, only tokens that are gained\n    ///      after claiming rewards or swapping are auto-compunded.\n    function _harvest() internal override returns (TokenAmount[] memory harvested) {\n        uint256 auraBalBalanceBefore = AURABAL.balanceOf(address(this));\n\n        // Claim auraBAL from locker\n        LOCKER.getReward(address(this));\n\n        harvested = new TokenAmount[](1);\n        harvested[0].token = address(AURA);\n\n        uint256 auraBalEarned = AURABAL.balanceOf(address(this)).sub(auraBalBalanceBefore);\n        // auraBAL -> BAL/ETH BPT -> WETH -> AURA\n        if (auraBalEarned > 0) {\n            // Common structs for swaps\n            IBalancerVault.SingleSwap memo"
    }
  ]
}