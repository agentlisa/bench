{
  "Title": "Precision loss on large values transformed between log2 scale and the normal scale",
  "Content": "In `GeoEmaAndCumSmaPump.sol::_init`, the reserve values are transformed into log2 scale:\n\n```solidity\nbyteReserves[i] = reserves[i].fromUIntToLog2();\n```\n\nThis transformation implies a precision loss, particularly for large `uint256` values, as demonstrated by the following test:\n\n```solidity\nfunction testUIntMaxToLog2() public {\nuint x = type(uint).max;\nbytes16 y = ABDKMathQuad.fromUIntToLog2(x);\nconsole.log(x);\nconsole.logBytes16(y);\nassertEq(ABDKMathQuad.fromUInt(x).log_2(), ABDKMathQuad.fromUIntToLog2(x));\nuint x_recover = ABDKMathQuad.pow_2ToUInt(y);\nconsole.log(ABDKMathQuad.toUInt(y));\nconsole.log(x_recover);\n}\n```\n\nConsider explicit limiting of the reserve values to avoid precision loss.\n\n**Beanstalk:** This is expected. Compressing a uint256 into a bytes16 can't possibly not lose precision as it is compressing 256 bits into 128 bits. E.g. there is only 113-bit decimal precision on the log operation. See [here](https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMathQuad.md#ieee-754-quadruple-precision-floating-point-numbers).\n\n**Cyfrin:** Acknowledged.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "ABDKMathQuad.md",
      "content": "ABDK Math Quad\n==============\n\nLibrary of mathematical functions operating with IEEE 754 quadruple precision\n(128 bit) floating point numbers.\n\nCopyright (c) 2019, [ABDK Consulting](https://abdk.consulting/)\n\nAll rights reserved.\n\nIEEE 754 Quadruple Precision Floating Point Numbers\n---------------------------------------------------\n\nIEEE 754 standard specifies quadruple precision floating point numbers to have:\n\n* sign bit: 1 bit,\n* exponent: 15 bits,\n* significand precision: 113 bits (112 explicitly stored).\n\nThis gives from 33 to 36 significant decimal digits precision.\n\nThe minimum strictly positive (subnormal) value is `2^−16494 ≈ 10^−4965`\nand has a precision of only one bit.  The minimum positive normal value is\n`2^−16382 ≈ 3.3621 × 10^−4932` and has a precision of 113 bits, i.e.\n`±2^−16494` as well.  The maximum representable value is\n`2^16384 − 2^16271 ≈ 1.1897 × 10^4932`.\n\nThe following special values are supported:\n\n* `NaN` (not a number),\n* `+Infinity`,\n* `-Infinity`.\n\nThe format has two zero values: `0` (positive zero) and `-0` (negative zero).\n\nComparison\n----------\n\nHere is the list of comparison functions provided by the library.\n\n    function isNaN (bytes16 x) internal pure returns (bool)\n\nTest whether given quadruple precision floating point number is NaN (not a\nnumber).\n\n    function isInfinity (bytes16 x) internal pure returns (bool)\n\nTest whether given quadruple precision floating point number is infinity, either\npositive or negative.\n\n    function sign (bytes16 x) internal pure returns (int8)\n\nGet the sign of a quadruple precision floating point number, i.e. `-1` if\nargument is negative, `0` if argument is zero, i.e. `0` or `-0`, and `1` if\nargument is positive.\n\n    function cmp (bytes16 x, bytes16 y) internal pure returns (int8)\n\nCompare two quadruple precision floating point numbers, and return `-1` if\n`x < y`, `0` if `x = y`, and `1` is `x > y`.  Basically, this function\nreturns `sign (x - y)`.\n\n    function eq (bytes16 x, bytes16 y) internal pure returns (bool)\n\nTest whether two quadruple precision floating point numbers are equal.\n\nSimple Arithmetic\n-----------------\n\nSimple arithmetic functions.\n\n    function add (bytes16 x, bytes16 y) internal pure returns (bytes16)\n\nAdd one quadruple precision floating point number to another and return the\nresult as a quadruple precision floating point number.\n\n    function sub (bytes16 x, bytes16 y) internal pure returns (bytes16)\n\nSubtract one quadruple precision floating point number from another and\nreturn the result as a quadruple precision floating point number.\n\n    function mul (bytes16 x, bytes16 y) internal pure returns (bytes16)\n\nMultiply one quadruple precision floating point number by another and return the\nresult as a quadruple precision floating point number.\n\n    function div (bytes16 x, bytes16 y) internal pure returns (bytes16)\n\nDivide one quadruple precision floating point number by another and return the\nresult as a quadruple precision floating point number.\n\n    function neg (bytes16 x) internal pure returns (bytes16)\n\nCalculate the opposite for a quadruple precision floating point number, i.e.\n`-x`, and return the result as a quadruple precision floating point number.\n\n    function abs (bytes16 x) internal pure returns (bytes16)\n\nCalculate absolute value of a quadruple precision floating point number and\nreturn the result as a quadruple precision floating point number.\n\nRoot, Logarithm, and Exponentiation\n-----------------------------------\n\nRoot, logarithm, and exponentiation functions.\n\n    function sqrt (bytes16 x) internal pure returns (bytes16)\n\nCalculate the square root of a quadruple precision floating point number and\nreturn the result as a quadruple precision floating point number.\n\n    function log_2 (bytes16 x) internal pure returns (bytes16)\n\nCalculate the binary logarithm of a quadruple precision floating point number\nand return the result as a quadruple precision floating point number.\n\n    function ln (bytes16 x) internal pure returns (bytes16)\n\nCalculate the natural logarithm of a quadruple precision floating point number\nand return the result as a quadruple precision floating point number.\n\n    function pow_2 (bytes16 x) internal pure returns (bytes16)\n\nRaise 2 to the power of a quadruple precision floating point number, i.e.\ncalculate `2^x`,  and return the result as a quadruple precision floating\npoint number.\n\n    function exp (bytes16 x) internal pure returns (bytes16)\n\nExponentiate a quadruple precision floating point number, i.e. calculate\n`e^x`,  and return the result as a quadruple precision floating point number.\n\nConversions\n-----------\n\nHere are conversion functions.\n\n    function fromInt (int256 x) internal pure returns (bytes16)\n\nConvert a signed 256 bit integer number into a quadruple precision floating\npoint number.\n\n    function toInt (bytes16 x) internal pure returns (int256)\n\nConvert a quadruple precision floating point number into a signed 256 bit\ninteger number.\n\n    function fromUInt (uint256 x) internal pure returns (bytes16)\n\nConvert an unsigned 256 bit integer number into a quadruple precision floating\npoint number.\n\n    function toUInt (bytes16 x) internal pure returns (uint256)\n\nConvert a quadruple precision floating point number into an unsigned 256 bit\ninteger number.\n\n    function from128x128 (int256 x) internal pure returns (bytes16)\n\nConvert a signed 128.128 bit fixed point number into a quadruple precision\nfloating point number.\n\n    function to128x128 (bytes16 x) internal pure returns (int256)\n\nConvert a quadruple precision floating point number into a signed 128.128 bit\nfixed point number.\n\n    function from64x64 (int128 x) internal pure returns (bytes16)\n\nConvert a signed 64.64 bit fixed point number into a quadruple precision\nfloating point number.\n\n    function to64x64 (bytes16 x) internal pure returns (int128)\n\nConvert a quadruple precision floating point number into a signed 64.64 bit\nfixed point number.\n\n    function fromOctuple (bytes32 x) internal pure returns (bytes16)\n\nConvert an octuple precision floating point number into a quadruple precision\nfloating point number.\n\n    function toOctuple (bytes16 x) internal pure returns (bytes32)\n\nConvert a quadruple precision floating point number into an octuple precision\nfloating point number.\n\n    function fromDouble (bytes8 x) internal pure returns (bytes16)\n\nConvert a double precision floating point number into a quadruple precision\nfloating point number.\n\n    function toDouble (bytes16 x) internal pure returns (bytes8)\n\nConvert a quadruple precision floating point number into a double precision\nfloating point number."
    }
  ]
}