{
  "Title": "[M-08] Insufficient support for tokens with different decimals on different chains lead to loss of funds on cross-chain bridging",
  "Content": "\nAccording to the [docs](https://github.com/code-423n4/2023-07-axelar/blob/main/DESIGN.md#custom-bridges), the Axelar network supports cross-chain bridging of **external** `ERC20` tokens, as well as their own `StandardizedToken` (using lock/unlock, mint/burn or liquidity pools).\n\n- However, there exists legitimate ERC20 tokens like USDT and USDC that have **6 decimals** on Ethereum (see [USDT on Etherscan](https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#readContract#F6) and [USDC on Etherscan](https://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48#readProxyContract#F11) but **18 decimals** on Binance Smart Chain (see [USDT on BSCScan](https://bscscan.com/address/0x55d398326f99059ff775485246999027b3197955#readContract#F6) and [USDC on BSCScan](https://bscscan.com/address/0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d#readProxyContract#F3)), just to name an example. So there are tokens which have different decimals on different chains.\n- Furthermore, the Axelar network allows to deploy and register `StandardizedToken` with the **same** `TokenId` but **different** decimals on different chains, see PoC.\n\n### Bug description\n\nA cross-chain bridging can be performed using the [TokenManager.sendToken(...)](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/token-manager/TokenManager.sol#L77-L100) method, which correctly collects the source tokens from the sender and subsequently calls the [InterchainTokenService.transmitSendToken(...)](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/interchain-token-service/InterchainTokenService.sol#L493-L523) method that generates the [payload](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/interchain-token-service/InterchainTokenService.sol#L512) for the remote `ContractCall` and also emits the `TokenSent` event.\n\nHowever, this payload, as well as the subsequently emitted `ContractCall` and `TokenSent` events (see [InterchainTokenService:L512-L514](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/interchain-token-service/InterchainTokenService.sol#L512-L514)) contain the unscaled **source amount with respect to the source token's decimals**.\n\nNext, this exact payload (actually it's `keccak256` hash) gets relayed on the remote chain as it is via [AxelarGateway.approveContractCall(...)](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/cgp/AxelarGateway.sol#L455-L467) and the `ContractCall` is now approved to be executed with the **source amount irrespective of the remote token's decimals**.\n\nTherefore, the bridged amounts are off by a factor of `10^abs(sourceDecimals - remoteDecimals)`.\n\n*Note that there are also other ways/entry points to reproduce this issue with the current codebase.*\n\n### Consequences\n\nThis leads to a loss of funds for user/protocol/pool when source token decimals are lower/higher than remote token decimals, because the token amount is just passed through instead of being scaled accordingly.\n\n### Proof of Concept\n\nThe first part of the PoC demonstrates the following:\n\n- The Axelar network allows to deploy and register `StandardizedToken` with the **same** `TokenId` but **different** decimals on different chains. In this example, 18 decimals on source chain and 16 decimals on remote chains.\n\n- The `sendToken` method creates the aforementioned payload (to be relayed) and the respective `ContractCall`/`TokenSent` events with the unscaled **source amount**.\n\nJust apply the *diff* below and run the test with `npm run test test/its/tokenServiceFullFlow.js`:\n\n```diff\ndiff --git a/test/its/tokenServiceFullFlow.js b/test/its/tokenServiceFullFlow.js\nindex c1d72a2..3eb873b 100644\n--- a/test/its/tokenServiceFullFlow.js\n+++ b/test/its/tokenServiceFullFlow.js\n@@ -31,6 +31,7 @@ describe('Interchain Token Service', () => {\n     const name = 'tokenName';\n     const symbol = 'tokenSymbol';\n     const decimals = 18;\n+    const otherDecimals = 16;\n \n     before(async () => {\n         const wallets = await ethers.getSigners();\n@@ -151,13 +152,13 @@ describe('Interchain Token Service', () => {\n         });\n     });\n \n-    describe('Full standardized token registration, remote deployment and token send', async () => {\n+    describe.only('Full standardized token registration, remote deployment and token send', async () => {\n         let token;\n         let tokenId;\n         const salt = getRandomBytes32();\n         const otherChains = ['chain 1', 'chain 2'];\n         const gasValues = [1234, 5678];\n-        const tokenCap = BigInt(1e18);\n+        const tokenCap = BigInt(10000e18);\n \n         before(async () => {\n             tokenId = await service.getCustomTokenId(wallet.address, salt);\n@@ -184,7 +185,7 @@ describe('Interchain Token Service', () => {\n                     salt,\n                     name,\n                     symbol,\n-                    decimals,\n+                    otherDecimals, // use other decimals on remote chains\n                     '0x',\n                     wallet.address,\n                     otherChains[i],\n@@ -197,19 +198,19 @@ describe('Interchain Token Service', () => {\n             const params = defaultAbiCoder.encode(['bytes', 'address'], [wallet.address, token.address]);\n             const payload = defaultAbiCoder.encode(\n                 ['uint256', 'bytes32', 'string', 'string', 'uint8', 'bytes', 'bytes'],\n-                [SELECTOR_DEPLOY_AND_REGISTER_STANDARDIZED_TOKEN, tokenId, name, symbol, decimals, '0x', wallet.address],\n+                [SELECTOR_DEPLOY_AND_REGISTER_STANDARDIZED_TOKEN, tokenId, name, symbol, otherDecimals, '0x', wallet.address],\n             );\n             await expect(service.multicall(data, { value }))\n                 .to.emit(service, 'TokenManagerDeployed')\n                 .withArgs(tokenId, LOCK_UNLOCK, params)\n                 .and.to.emit(service, 'RemoteStandardizedTokenAndManagerDeploymentInitialized')\n-                .withArgs(tokenId, name, symbol, decimals, '0x', wallet.address, otherChains[0], gasValues[0])\n+                .withArgs(tokenId, name, symbol, otherDecimals, '0x', wallet.address, otherChains[0], gasValues[0])\n                 .and.to.emit(gasService, 'NativeGasPaidForContractCall')\n                 .withArgs(service.address, otherChains[0], service.address.toLowerCase(), keccak256(payload), gasValues[0], wallet.address)\n                 .and.to.emit(gateway, 'ContractCall')\n                 .withArgs(service.address, otherChains[0], service.address.toLowerCase(), keccak256(payload), payload)\n                 .and.to.emit(service, 'RemoteStandardizedTokenAndManagerDeploymentInitialized')\n-                .withArgs(tokenId, name, symbol, decimals, '0x', wallet.address, otherChains[1], gasValues[1])\n+                .withArgs(tokenId, name, symbol, otherDecimals, '0x', wallet.address, otherChains[1], gasValues[1])\n                 .and.to.emit(gasService, 'NativeGasPaidForContractCall')\n                 .withArgs(service.address, otherChains[1], service.address.toLowerCase(), keccak256(payload), gasValues[1], wallet.address)\n                 .and.to.emit(gateway, 'ContractCall')\n@@ -217,30 +218,32 @@ describe('Interchain Token Service', () => {\n         });\n \n         it('Should send some token to another chain', async () => {\n-            const amount = 1234;\n+            const amountSrc = BigInt(1234e18); // same amount on source and destination chain\n+            const amountDst = BigInt(1234e16); // just scaled according to decimals\n             const destAddress = '0x1234';\n             const destChain = otherChains[0];\n             const gasValue = 6789;\n \n             const payload = defaultAbiCoder.encode(\n                 ['uint256', 'bytes32', 'bytes', 'uint256'],\n-                [SELECTOR_SEND_TOKEN, tokenId, destAddress, amount],\n+                [SELECTOR_SEND_TOKEN, tokenId, destAddress, amountDst], // expect scaled amount according to remote decimals\n             );\n             const payloadHash = keccak256(payload);\n \n-            await expect(token.approve(tokenManager.address, amount))\n+            await expect(token.approve(tokenManager.address, amountSrc))\n                 .to.emit(token, 'Approval')\n-                .withArgs(wallet.address, tokenManager.address, amount);\n-\n-            await expect(tokenManager.sendToken(destChain, destAddress, amount, '0x', { value: gasValue }))\n+                .withArgs(wallet.address, tokenManager.address, amountSrc);\n+            \n+            // call succeeds but doesn't take into account remote decimals\n+            await expect(tokenManager.sendToken(destChain, destAddress, amountSrc, '0x', { value: gasValue }))\n                 .and.to.emit(token, 'Transfer')\n-                .withArgs(wallet.address, tokenManager.address, amount)\n+                .withArgs(wallet.address, tokenManager.address, amountSrc)\n                 .and.to.emit(gateway, 'ContractCall')\n-                .withArgs(service.address, destChain, service.address.toLowerCase(), payloadHash, payload)\n+                .withArgs(service.address, destChain, service.address.toLowerCase(), payloadHash, payload) // should fail\n                 .and.to.emit(gasService, 'NativeGasPaidForContractCall')\n-                .withArgs(service.address, destChain, service.address.toLowerCase(), payloadHash, gasValue, wallet.address)\n+                .withArgs(service.address, destChain, service.address.toLowerCase(), payloadHash, gasValue, wallet.address) // should fail\n                 .to.emit(service, 'TokenSent')\n-                .withArgs(tokenId, destChain, destAddress, amount);\n+                .withArgs(tokenId, destChain, destAddress, amountDst); // should fail\n         });\n \n         // For this test the token must be a standardized token (or a distributable token in general)\n\n```\n\nThe second part of the PoC demonstrates that the aforementioned payload is relayed/approved as it is to the remote chain and the source token amount is received on the remote chain irrespective of the remote token's decimals.\n\nJust apply the *diff* below and run the test with `npm run test test/its/tokenService.js`:\n\n```diff\ndiff --git a/test/its/tokenService.js b/test/its/tokenService.js\nindex f9843c1..161ac8a 100644\n--- a/test/its/tokenService.js\n+++ b/test/its/tokenService.js\n@@ -797,10 +797,10 @@ describe('Interchain Token Service', () => {\n         }\n     });\n \n-    describe('Receive Remote Tokens', () => {\n+    describe.only('Receive Remote Tokens', () => {\n         const sourceChain = 'source chain';\n         let sourceAddress;\n-        const amount = 1234;\n+        const amount = 1234; // this unscaled source amount gets processed with respect to remote decimals\n         let destAddress;\n         before(async () => {\n             sourceAddress = service.address.toLowerCase();\n@@ -813,7 +813,7 @@ describe('Interchain Token Service', () => {\n \n             const payload = defaultAbiCoder.encode(\n                 ['uint256', 'bytes32', 'bytes', 'uint256'],\n-                [SELECTOR_SEND_TOKEN, tokenId, destAddress, amount],\n+                [SELECTOR_SEND_TOKEN, tokenId, destAddress, amount], // amount should have been scaled according to remote decimals before relaying\n             );\n             const commandId = await approveContractCall(gateway, sourceChain, sourceAddress, service.address, payload);\n \n@@ -825,11 +825,11 @@ describe('Interchain Token Service', () => {\n         });\n \n         it('Should be able to receive mint/burn token', async () => {\n-            const [token, , tokenId] = await deployFunctions.mintBurn(`Test Token Mint Burn`, 'TT', 12, 0);\n+            const [token, , tokenId] = await deployFunctions.mintBurn(`Test Token Mint Burn`, 'TT', 14, 0);\n \n             const payload = defaultAbiCoder.encode(\n                 ['uint256', 'bytes32', 'bytes', 'uint256'],\n-                [SELECTOR_SEND_TOKEN, tokenId, destAddress, amount],\n+                [SELECTOR_SEND_TOKEN, tokenId, destAddress, amount], // amount should have been scaled according to remote decimals before relaying\n             );\n             const commandId = await approveContractCall(gateway, sourceChain, sourceAddress, service.address, payload);\n \n@@ -841,11 +841,11 @@ describe('Interchain Token Service', () => {\n         });\n \n         it('Should be able to receive liquidity pool token', async () => {\n-            const [token, , tokenId] = await deployFunctions.liquidityPool(`Test Token Liquidity Pool`, 'TTLP', 12, amount);\n+            const [token, , tokenId] = await deployFunctions.liquidityPool(`Test Token Liquidity Pool`, 'TTLP', 16, amount);\n             (await await token.transfer(liquidityPool.address, amount)).wait();\n             const payload = defaultAbiCoder.encode(\n                 ['uint256', 'bytes32', 'bytes', 'uint256'],\n-                [SELECTOR_SEND_TOKEN, tokenId, destAddress, amount],\n+                [SELECTOR_SEND_TOKEN, tokenId, destAddress, amount], // amount should have been scaled according to remote decimals before relaying\n             );\n             const commandId = await approveContractCall(gateway, sourceChain, sourceAddress, service.address, payload);\n```\n\n### Tools Used\n\nVS Code, Hardhat\n\n### Recommended Mitigation Steps\n\nThis issue cannot be solved easily since the remote chain doesn't know about the token decimals on the source chain and vice versa. I suggest the following options:\n\n1. Explicitly exclude tokens with different decimals on different chains and emphasize this in the documentation. However, this would be a loss of opportunity and against the mantra \"Axelar is a decentralized interoperability network connecting all blockchains, assets and apps through a universal set of protocols and APIs.\"\n\n2. Normalize all bridged token amounts to e.g. 18 decimals (beware of loss of precision) before creating the aforementioned payload and the respective `ContractCall`/`TokenSent` events at all instances. De-normalize token amounts on the remote chain accordingly.\n\n### Assessed type\n\nDecimal\n\n**[deanamiel (Axelar) disagreed with severity and commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/52#issuecomment-1694543891):**\n> Corrected Severity: QA\n>\n> We might account for this if a better approach is found than rounding off decimals. For pre-existing tokens with different decimals, a wrapper can be made by the deployer that does the decimal handling, which is the current intended use for such tokens.\n\n**[berndartmueller (judge) decreased severity to QA and commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/52#issuecomment-1706289287):**\n> This is a very well-written submission!\n> \n> However, I agree with the sponsor that wrapper tokens are supposed to be used in case of different decimals across chains. For instance, see the wrapper ERC-20 token for USDC on BNB chain, `Axelar Wrapped USDC (axlUSDC)`, https://bscscan.com/address/0x4268B8F0B87b6Eae5d897996E6b845ddbD99Adf3#readContract.\n> \n> Thus, I'm downgrading to QA (Low).\n\n**[0xTheC0der (warden) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/52#issuecomment-1712186032):**\n> @berndartmueller - Please be aware that the sponsor's comment and severity suggestion is **only** about the first part of the issue (pre-existing tokens) and therefore not conclusive for the whole report.  \n> \n> 1. *Pre-existing tokens:*  \n> Even if the mentioned wrapper tokens were in scope of this audit (please correct me if I am mistaken and they are), they are not sufficiently mitigating the issue, since the codebase does not explicitly enforce their usage, nor does it require the *source* and *destination* decimals to be equal (should revert with error). Furthermore, the [docs](https://github.com/code-423n4/2023-07-axelar/blob/main/DESIGN.md#custom-bridges) explicitly mention the use of external ERC20 tokens but do not mention the wrappers; therefore, the issue is unmitigated as of now.  \n> As a result, pre-existing tokens, as well as potentially wrong wrappers with *different decimals on different chains*, can be used and subsequently lead to a loss of funds for the user or token pool.\n> \n> 2. *`StandardizedToken`* (not mentioned by the sponsor):  \n> The Axelar network allows to deploy and register `StandardizedToken` with the **same** `TokenId` but *different decimals on different chains*, see first part of PoC about (remote) deployment and [InterchainTokenService.getCustomTokenId(...)](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/interchain-token-service/InterchainTokenService.sol#L206-L215).\n> This should not be possible in the first place as long as the transfer amount does not get scaled according to decimals automatically, i.e. it's a bug which is even more severe than the above issue also leading to loss of funds.  \n> Both, the [InterchainTokenService.deployAndRegisterStandardizedToken(...)](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/interchain-token-service/InterchainTokenService.sol#L378-L402) method as well as the [InterchainTokenService.deployAndRegisterRemoteStandardizedToken(...)](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/interchain-token-service/InterchainTokenService.sol#L404-L429) method are lacking underlying checks to ensure that there is no other token with the **same** `TokenId` but **different** decimals already registered on another chain.  \n> \n> I am looking forward to more fact-based opinions about this and fair judgment considering the proven impacts, see also second part of PoC that demonstrates a loss of funds (wrong transfer of funds by factor 100).  \n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/52#issuecomment-1713570656):**\n> @0xTheC0der - According to the [Interchain token service docs](https://github.com/code-423n4/2023-07-axelar/blob/main/DESIGN.md#architecture), there are two types of bridges:\n> \n> 1. Canonical bridges\n> 2. Custom bridges\n> \n> *Canonical bridges* are used to enable bridging pre-existing ERC-20 tokens across chains. Such bridges are deployed via `InterchainTokenService.registerCanonicalToken` on the source chain and `InterchainTokenService.deployRemoteCanonicalToken` for the remote (destination) chains. Here, the trust assumption is that anyone can create canonical bridges - the resulting `StandardizedToken` on the remote chains will have matching decimals with the pre-existing ERC-20 token (see [InterchainTokenService.sol#L334](https://github.com/code-423n4/2023-07-axelar/blob/2f9b234bb8222d5fbe934beafede56bfb4522641/contracts/its/interchain-token-service/InterchainTokenService.sol#L334). Thus, there is no such issue with non-matching decimals for canonical bridges.\n> \n> In regards to _custom bridges_, the trust assumption is different ([docs](https://github.com/code-423n4/2023-07-axelar/blob/main/DESIGN.md#custom-bridges)):\n> \n> > Users using Custom Bridges **need to trust the deployers** as they could easily confiscate the funds of users if they wanted to, same as any ERC20 distributor could confiscate the funds of users.\n> \n> In the submission's PoC, the described issue is demonstrated by deploying a `StandardizedToken` with 18 decimals on the source chain and deploying corresponding `StandardizedToken` tokens with 16 decimals on remote chains (via `deployAndRegisterRemoteStandardizedToken`. In this case, it truly shows a mismatch of token decimals between the source and remote chain, leading to a loss of bridged funds.\n> \n> Even though the docs mention that the deployer of such a custom bridge has to be trusted, implementing the warden's second mitigation recommendation (normalizing token transfer amounts to, e.g., 18 decimals) certainly helps mitigate this issue and reduces the surface for potential errors (malicious or non-malicious) when deploying custom bridges. For example, the Wormhole bridge does this as well by [normalizing the token transfer amounts to 8 decimals](https://github.com/wormhole-foundation/wormhole/blob/44c8146c3f3d16db8a98214aaa7226f3cee5fb08/cosmwasm/contracts/token-bridge/src/contract.rs#L1215-L1223).\n> \n> Ultimately, this leads me to acknowledge the outlined issue and medium severity chosen by the warden.\n> \n> I kindly invite the sponsor's feedback before changing the severity back to medium - @deanamiel.\n\n**[berndartmueller (judge) increased severity to Medium](https://github.com/code-423n4/2023-07-axelar-findings/issues/52#issuecomment-1715258392)**\n\n**[deanamiel (Axelar) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/52#issuecomment-1715969297):**\n > The standardized token scenario would still not lead to a loss of funds. One could still bridge tokens back and get the same amount, the amounts seen would be mismatched (when divided by 10^ decimals) but this is only a cosmetic issue. We still believe this is a QA level issue.\n\n**[berndartmueller (judge) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/52#issuecomment-1716045219):**\n > Loss of funds may not be permanent, indeed. Still, it presents an issue for users bridging `StandardizedToken` tokens and the token pools themselves. Such tokens with mismatching decimals on the source- and destination chains can also be purposefully bridged to steal funds.\n\n**[milapsheth (Axelar) commented](https://github.com/code-423n4/2023-07-axelar-findings/issues/52#issuecomment-1801833029):**\n> We consider this QA or Low severity. As mentioned before, there is no actual loss of funds since you can always bridge the same amount back. Furthermore, Standardized tokens still require trusting the deployer, unlike Canonical tokens. Tokens deployed and whitelisted via the UI will make sure the same decimals are used for deployments. Users are not recommended to interact with arbitrary Standardized tokens given that the deployer can still be malicious in various ways.\n>\n> The ERC20 [spec](https://eips.ethereum.org/EIPS/eip-20) does not require the presence of `name`, `symbol`, `decimals`. While commonly supported, these are still optional fields, so we left it flexible in the main protocol.\n>\n> You can also build deployer contracts on top of this that do enforce various checks such as using the on-chain name, symbol, decimals before deploying.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "DESIGN.md",
      "content": "# Design\n\nThis doc covers the design of the Interchain governance and Interchain token service contracts.\n\n# Governance\n\n### Interchain Governance\n\nThe Interchain Governance Contract facilitates cross-chain governance actions within the Axelar network. It enables the creation, cancellation, and execution of governance proposals while incorporating a TimeLock mechanism. The TimeLock mechanism institutes a mandatory time delay before any proposal execution, thereby offering robust protection against sudden, potentially disruptive changes. This mechanism is used to govern upgrades of the Axelar Gateway contract.\n\n#### Timelock Mechanism\n\nThe TimeLock contract institutes a mechanism that guarantees the secure execution of functions after a designated time delay. This mechanism not only enables the scheduling, cancellation, and finalization of function calls, but it also enforces a minimum time delay before any function can be either scheduled or finalized, thereby enhancing the contract's security.\n\n#### Governance Operations\n\nThe TimeLock contract manages two types of governance operations: Proposal Scheduling and Proposal Cancellation.\n\n-   **Proposal Scheduling**: Facilitates the creation of new proposals. For each scheduled proposal, it sets a corresponding TimeLock that must expire before the proposal's execution.\n\n-   **Proposal Cancellation**: Facilitates the cancellation of an existing proposal by setting its corresponding TimeLock timestamp to zero and thereby blocking its execution.\n\nBoth operations require a match between the source chain and source address, and the governance chain and governance address in the contract. This check guarantees that only authorized entities can schedule or cancel actions.\n\n#### Secure Execution of Proposals\n\nOnce their corresponding TimeLock expires, proposals become executable. For ensured safety during execution, the contract revalidates the TimeLock right before initiating the proposal execution.\n\n#### Generating Proposal Hashes\n\nThe system ensures the uniqueness of each proposal by generating hashes with the Keccak256 algorithm. The hashes are derived from the target contract's address, encoded function call data, and the native token transfer value.\n\n### Multisig\n\nThe Multisig contract maintains a list of signer accounts and enforces a threshold or minimum number of signers required to execute certain functions. It plays a pivotal role in defining token mint limits for the gateway.\n\n#### Voting Procedure\n\nFor each transaction, a voting process is initiated among the signers. Every time a signer casts a vote, the counter increases, and the action is recorded under the signer's address. Once the threshold is met, the transaction is carried out, and the voting counter is reset.\n\n#### Rotation of Signers\n\nThe Multisig contract facilitates a rotation mechanism for signers. Existing signers can refresh the list of signatory addresses and the threshold value using the `rotateSigners` function. Each rotation is tracked by incrementing an epoch.\n\n#### Execution of External Contracts\n\nThe Multisig contract's `execute` function allows signers to call any function on any external contract if the threshold number of signers trigger the method with the same args.\n\n#### Safeguards\n\nThe Multisig contract incorporates safeguards to deter misuse. These safeguards enforce preventive measures such as prohibiting multiple votes from the same account within an epoch, preventing signer duplication, and requiring transactions to meet the voting threshold before execution.\n\n#### Multisig Operations\n\nMultisig operations demand multi-signatory authorization for proposal execution. A mapping mechanism tracks approvals for different proposals, requiring a proposal to garner sufficient approval to meet the predefined threshold before its execution.\n\n### Axelar Service Governance\n\nBuilding upon the Interchain Governance Contract, the Service Governance Contract is specifically designed to manage operations that require coordination. By incorporating `MultisigBase`, it introduces the functionality to approve, execute, and cancel multisig proposals, in addition to schedule and cancel TimeLock proposals. This is intended to be used as the owner for services such as the Interchain token service contract, allowing Axelar governance to manage it.\n\n#### Service Governance Operations\n\nThe contract orchestrates four governance operations:\n\n-   **Schedule TimeLock Proposal**: Similar to Interchain Governance, it schedules a new governance proposal with a TimeLock.\n\n-   **Cancel TimeLock Proposal**: Again, similar to Interchain Governance, it cancels an existing governance proposal.\n\n-   **Approve Multisig Proposal**: Enables multisig proposal approval, setting the approval status of the proposal to true and signaling successful approval via a `MultisigApproved` event.\n\n-   **Cancel Multisig Approval**: Cancels an approved multisig proposal, setting the approval status of the proposal to false and indicating successful cancellation through a `MultisigCancelled` event.\n\n#### Secure Execution of Multisig Proposals\n\nUpon receiving the necessary number of signatory approvals, a multisig proposal becomes eligible for execution. Before execution, the contract verifies the proposal's approval status; if the approval status is false, the transaction is reverted. Following successful execution, the proposal's approval status is reset, and a `MultisigExecuted` event is emitted.\n\n# Axelar Interchain Governance Executor\n\nAxelar Interchain Governance Executor is a project that enhances on-chain governance protocols to facilitate interchain proposal execution. We demonstrate the extension using Compound's governance contracts, but the approach can be applied to any governance protocol.\n\n## Key Components\n\nThere are two essential contracts in this interchain extension:\n\n1. `InterchainProposalSender`: Deployed on the source chain, this contract has a method called `sendProposal`. This method encodes a proposal into a payload for a remote chain and pays the Axelar Gas Service for the execution of the interchain call on the destination chain.\n\n2. `InterchainProposalExecutor`: Deployed on the destination chain, this contract has a callback method `_execute` that executes the proposal on the target contracts.\n\nFor a visual transaction flow of the interchain proposal, see the mermaid diagram below.\n\n```mermaid\nflowchart\n    subgraph \"Destination Chain Contracts\"\n        direction TB\n        PE{{InterchainProposalExecutor Contract}}\n        PE -.->|Calls| TargetA\n        PE -->|Calls| TargetB\n        PE -.->|Calls| Target\n        TargetA[Contract ..]\n        TargetB[Contract A]\n        Target[Contract ..]\n    end\n\n    subgraph \"Axelar Interchain Proposal Sender\"\n        direction TB\n        IPS -->|Encode & Submit| AxelarGateway\n        AxelarGateway -.->|Emit Events| Relayer\n        Relayer -.->|Execute| PE\n    end\n\n    subgraph \"Source Chain Governance\"\n        direction TB\n        Dev -->|Propose| Gov[Governor Contract]\n        Gov -->|Vote & Queue| Timelock[Timelock Contract]\n        Timelock -.->|Execute Proposal| IPS{{InterchainProposalSender Contract}}\n    end\n```\n\n# Interchain Token Service\n\n## Introduction\n\nThis project aims to provide a platform that enables tokens of all kinds to go cross-chain. To achieve this we need a cross-chain communication protocol, that can reliably pass information through chains. The Axelar Network is used for this design, but it is possible to adjust some of the contracts to use a different network.\n\nFor the purposes of this document we will use two keywords: deployer, the person who creates the bridge and user, the person using a bridge.\n\n## Architecture\n\nThe main workflow of a bridge is the following:\n\n-   Obtains `x` token from the user on chain A\n-   Send a message to chain B indicating that this happened, and where the token should go to\n-   Receive the above message, and hand `x` token to the appropriate address\n\nFor this to be a proper bridge it should be possible to perform the above steps for any supported chain being 'chain A' and 'chain B'. There are multiple different possible configurations for any bridge, and we wanted to make it as easy as possible for deployers to get what they want, while making it cheap and easy for users to get their tokens across chains as well.\n\nThe workflow described below is facilitated by 2 smart contracts the [`InterchainTokenService`](https://github.com/code-423n4/2023-07-axelar/blob/main/contracts/its/interchain-token-service/InterchainTokenService.sol) and the [`TokenManager`](https://github.com/code-423n4/2023-07-axelar/blob/main/contracts/its/token-manager/TokenManager.sol). The `TokenManager` handles tokens and is the input side for all requests, and the `InterchainTokenService` deploys `TokenManagers` and is responsible for sending and receiving messages. Each bridge will result in a new `TokenManager` with a unique `tokenId`. There are a few different options that deployers have to obtain different kinds of `TokenManagers` with different guarantees and flexibility.\n\nNote that a lot of the design choises were made with supporting non-EVM chains in mind.\n\n### Canonical Bridges\n\nMost current bridge designs aim to get a pre-existing, popular token to different chains that can benefit from the liquidity. When they do so the resulting token, called [`StandardizedToken`](https://github.com/code-423n4/2023-07-axelar/blob/main/contracts/its/token-implementations/StandardizedToken.sol) in this project, will only have basic functionality that enables users to transfer their token and use it with general use smart contracts like De-Fi applications. This is certainly powerfull, and has the benefit that as long as the pre-existing `ERC20` implemention and the bridge function properly everything run as expected. We wanted to include this design for the `InterchainTokenService` as well, so deployers can deploy a Canonical Bridge for any token they want, and this can be done only once per pre-existing `ERC20`. Who the deployer is does not matter for this, they just need to pay for the deployment gas, but they do not need to be trusted as they have no special powers over this kind of bridge\n\n### Custom Bridges\n\nMost projects that look to go cross-chain nowadays have more complex needs that the ones covered by Canonical Bridges: they often need custom `ERC20` designs, and will sometimes want to have additional power over the bridge. This is where the `InterchainTokenService` shines, deployers can claim certain `tokenIds` only based on their `address`, and a `salt` they provide, and specify any kind of `TokenManager` to be deployed and either manage an external `ERC20` or a `StandardizedToken`. Users using Custom Bridges need to trust the deployers as they could easily confiscate the funds of users if they wanted to, same as any `ERC20` distributor could confiscate the funds of users. There are currently three kinds of possible `TokenManagers` available, but this number might increase in the future, as we find more potential uses for the `InterchainTokenService`.\n\n-   Lock/Unlock: This `TokenManager` will simply transfer tokens from a user to itself or vice versa to initiate/fulfill cross-chain transfers\n-   Mint/Burn: This `TokenManager` will burn/mint tokens from/to the user to initiate/fulfill cross-chain transfers. Tokens used with this kind of `TokenManager` need to be properly permissioned to allow for this behaviour.\n-   Liquidity Pool: This `TokenManager` functions exaclty like a Lock/Unlock one, except the balance is kept at a separate, prespecified account. This allows for deployers to have more controll over the bridged funds.\n\n## Linker Router\n\nWe plan to finalize the design of the `InterchainTokenService` but we want to be able to support new chains as they get added to the Axelar Network. For this purpose, the service will ask a separate contract, the [`RemoteAddressValidator`](https://github.com/code-423n4/2023-07-axelar/blob/main/contracts/its/remote-address-validator/RemoteAddressValidator.sol) to obtain the destination address for outgoing messages, and for validation of incoming messages. This contract might eventually stop being upgradable but it will probalby be able to support new addresses for new chains indefinately.\n\n## Interchain Token\n\nWe designed an [interface](./contracts/interfaces/IInterchainToken.sol) allong a [example implementation](https://github.com/code-423n4/2023-07-axelar/blob/main/contracts/its/interchain-token/InterchainToken.sol) of an ERC20 that can use the `InterchainTokenService` internally. This has the main benefit that for `TokenManagers` that require user approval (Lock/Unlock and Liquidity Pool typically) the token can provide this approval within the same call, providing better UX for users, and saving them some gas."
    },
    {
      "filename": "contracts/its/token-manager/TokenManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ITokenManager } from '../interfaces/ITokenManager.sol';\nimport { IInterchainTokenService } from '../interfaces/IInterchainTokenService.sol';\nimport { ITokenManagerProxy } from '../interfaces/ITokenManagerProxy.sol';\n\nimport { Operatable } from '../utils/Operatable.sol';\nimport { FlowLimit } from '../utils/FlowLimit.sol';\nimport { AddressBytesUtils } from '../libraries/AddressBytesUtils.sol';\nimport { Implementation } from '../utils/Implementation.sol';\n\n/**\n * @title The main functionality of TokenManagers.\n * @notice This contract is responsible for handling tokens before initiating a cross chain token transfer, or after receiving one.\n */\nabstract contract TokenManager is ITokenManager, Operatable, FlowLimit, Implementation {\n    using AddressBytesUtils for bytes;\n\n    IInterchainTokenService public immutable interchainTokenService;\n\n    /**\n     * @notice Constructs the TokenManager contract.\n     * @param interchainTokenService_ The address of the interchain token service\n     */\n    constructor(address interchainTokenService_) {\n        if (interchainTokenService_ == address(0)) revert TokenLinkerZeroAddress();\n        interchainTokenService = IInterchainTokenService(interchainTokenService_);\n    }\n\n    /**\n     * @dev A modifier that allows only the interchain token service to execute the function.\n     */\n    modifier onlyService() {\n        if (msg.sender != address(interchainTokenService)) revert NotService();\n        _;\n    }\n\n    /**\n     * @dev A modifier that allows only the token to execute the function.\n     */\n    modifier onlyToken() {\n        if (msg.sender != tokenAddress()) revert NotToken();\n        _;\n    }\n\n    /**\n     * @notice A function that should return the address of the token.\n     * Must be overridden in the inheriting contract.\n     * @return address address of the token.\n     */\n    function tokenAddress() public view virtual returns (address);\n\n    /**\n     * @dev This function should only be called by the proxy, and only once from the proxy constructor\n     * @param params the parameters to be used to initialize the TokenManager. The exact format depends\n     * on the type of TokenManager used but the first 32 bytes are reserved for the address of the operator,\n     * stored as bytes (to be compatible with non-EVM chains)\n     */\n    function setup(bytes calldata params) external override onlyProxy {\n        bytes memory operatorBytes = abi.decode(params, (bytes));\n        address operator_;\n        /**\n         * @dev Specifying an empty operator will default to the service being the operator. This makes it easy to deploy\n         * remote standardized tokens without knowing anything about the service address at the destination.\n         */\n        if (operatorBytes.length == 0) {\n            operator_ = address(interchainTokenService);\n        } else {\n            operator_ = operatorBytes.toAddress();\n        }\n        _setOperator(operator_);\n        _setup(params);\n    }\n\n    /**\n     * @notice Calls the service to initiate the a cross-chain transfer after taking the appropriate amount of tokens from the user.\n     * @param destinationChain the name of the chain to send tokens to.\n     * @param destinationAddress the address of the user to send tokens to.\n     * @param amount the amount of tokens to take from msg.sender.\n     */\n    function sendToken(\n        string calldata destinationChain,\n        bytes calldata destinationAddress,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable virtual {\n        address sender = msg.sender;\n        amount = _takeToken(sender, amount);\n        _addFlowOut(amount);\n        interchainTokenService.transmitSendToken{ value: msg.value }(\n            _getTokenId(),\n            sender,\n            destinationChain,\n            destinationAddress,\n            amount,\n            metadata\n        );\n    }\n\n    /**\n     * @notice Calls the service to initiate the a cross-chain transfer with data after taking the appropriate amount of tokens from the user.\n     * @param destinationChain the name of the chain to send tokens to.\n     * @param destinationAddress the address of the user to send tokens to.\n     * @param amount the amount of tokens to take from msg.sender.\n     * @param data the data to pass to the destination contract.\n     */\n    function callContractWithInterchainToken(\n        string calldata destinationChain,\n        bytes calldata destinationAddress,\n        uint256 amount,\n        bytes calldata data\n    ) external payable virtual {\n        address sender = msg.sender;\n        amount = _takeToken(sender, amount);\n        _addFlowOut(amount);\n        uint32 version = 0;\n        interchainTokenService.transmitSendToken{ value: msg.value }(\n            _getTokenId(),\n            sender,\n            destinationChain,\n            destinationAddress,\n            amount,\n            abi.encodePacked(version, data)\n        );\n    }\n\n    /**\n     * @notice Calls the service to initiate the a cross-chain transfer after taking the appropriate amount of tokens from the user. This can only be called by the token itself.\n     * @param sender the address of the user paying for the cross chain transfer.\n     * @param destinationChain the name of the chain to send tokens to.\n     * @param destinationAddress the address of the user to send tokens to.\n     * @param amount the amount of tokens to take from msg.sender.\n     */\n    function transmitInterchainTransfer(\n        address sender,\n        string calldata destinationChain,\n        bytes calldata destinationAddress,\n        uint256 amount,\n        bytes calldata metadata\n    ) external payable virtual onlyToken {\n        amount = _takeToken(sender, amount);\n        _addFlowOut(amount);\n        interchainTokenService.transmitSendToken{ value: msg.value }(\n            _getTokenId(),\n            sender,\n            destinationChain,\n            destinationAddress,\n            amount,\n            metadata\n        );\n    }\n\n    /**\n     * @notice This function gives token to a specified address. Can only be called by the service.\n     * @param destinationAddress the address to give tokens to.\n     * @param amount the amount of token to give.\n     * @return the amount of token actually given, which will onle be differen than `amount` in cases where the token takes some on-transfer fee.\n     */\n    function giveToken(address destinationAddress, uint256 amount) external onlyService returns (uint256) {\n        amount = _giveToken(destinationAddress, amount);\n        _addFlowIn(amount);\n        return amount;\n    }\n\n    /**\n     * @notice This function sets the flow limit for this TokenManager. Can only be called by the operator.\n     * @param flowLimit the maximum difference between the tokens flowing in and/or out at any given interval of time (6h)\n     */\n    function setFlowLimit(uint256 flowLimit) external onlyOperator {\n        _setFlowLimit(flowLimit);\n    }\n\n    /**\n     * @notice Transfers tokens from a specific address to this contract.\n     * Must be overridden in the inheriting contract.\n     * @param from The address from which the tokens will be sent\n     * @param amount The amount of tokens to receive\n     * @return uint amount of tokens received\n     */\n    function _takeToken(address from, uint256 amount) internal virtual returns (uint256);\n\n    /**\n     * @notice Transfers tokens from this contract to a specific address.\n     * Must be overridden in the inheriting contract.\n     * @param from The address to which the tokens will be sent\n     * @param amount The amount of tokens to send\n     * @return uint amount of tokens sent\n     */\n    function _giveToken(address from, uint256 amount) internal virtual returns (uint256);\n\n    /**\n     * @dev Additional setup logic to perform\n     * Must be overridden in the inheriting contract.\n     * @param params The setup parameters\n     */\n    function _setup(bytes calldata params) internal virtual;\n\n    /**\n     * @notice Gets the token ID from the token manager proxy.\n     * @return tokenId The ID of the token\n     */\n    function _getTokenId() internal view returns (bytes32 tokenId) {\n        tokenId = ITokenManagerProxy(address(this)).tokenId();\n    }\n}"
    },
    {
      "filename": "contracts/its/interchain-token-service/InterchainTokenService.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarGateway } from '../../gmp-sdk/interfaces/IAxelarGateway.sol';\nimport { IAxelarGasService } from '../../gmp-sdk/interfaces/IAxelarGasService.sol';\nimport { AxelarExecutable } from '../../gmp-sdk/executable/AxelarExecutable.sol';\nimport { SafeTokenTransferFrom } from '../../gmp-sdk/util/SafeTransfer.sol';\nimport { IERC20 } from '../../gmp-sdk/interfaces/IERC20.sol';\n\nimport { IInterchainTokenService } from '../interfaces/IInterchainTokenService.sol';\nimport { ITokenManagerDeployer } from '../interfaces/ITokenManagerDeployer.sol';\nimport { IStandardizedTokenDeployer } from '../interfaces/IStandardizedTokenDeployer.sol';\nimport { IRemoteAddressValidator } from '../interfaces/IRemoteAddressValidator.sol';\nimport { IInterchainTokenExpressExecutable } from '../interfaces/IInterchainTokenExpressExecutable.sol';\nimport { ITokenManager } from '../interfaces/ITokenManager.sol';\nimport { ITokenManagerProxy } from '../interfaces/ITokenManagerProxy.sol';\nimport { IERC20Named } from '../interfaces/IERC20Named.sol';\n\nimport { AddressBytesUtils } from '../libraries/AddressBytesUtils.sol';\nimport { StringToBytes32, Bytes32ToString } from '../../gmp-sdk/util/Bytes32String.sol';\n\nimport { Upgradable } from '../../gmp-sdk/upgradable/Upgradable.sol';\nimport { Create3Deployer } from '../../gmp-sdk/deploy/Create3Deployer.sol';\n\nimport { ExpressCallHandler } from '../utils/ExpressCallHandler.sol';\nimport { Pausable } from '../utils/Pausable.sol';\nimport { Operatable } from '../utils/Operatable.sol';\nimport { Multicall } from '../utils/Multicall.sol';\n\n/**\n * @title The Interchain Token Service\n * @notice This contract is responsible for facilitating cross chain token transfers.\n * It (mostly) does not handle tokens, but is responsible for the messaging that needs to occur for cross chain transfers to happen.\n * @dev The only storage used here is for ExpressCalls\n */\ncontract InterchainTokenService is\n    IInterchainTokenService,\n    AxelarExecutable,\n    Upgradable,\n    Operatable,\n    ExpressCallHandler,\n    Pausable,\n    Multicall\n{\n    using StringToBytes32 for string;\n    using Bytes32ToString for bytes32;\n    using AddressBytesUtils for bytes;\n    using AddressBytesUtils for address;\n\n    address internal immutable implementationLockUnlock;\n    address internal immutable implementationMintBurn;\n    address internal immutable implementationLiquidityPool;\n    IAxelarGasService public immutable gasService;\n    IRemoteAddressValidator public immutable remoteAddressValidator;\n    address public immutable tokenManagerDeployer;\n    address public immutable standardizedTokenDeployer;\n    Create3Deployer internal immutable deployer;\n    bytes32 internal immutable chainNameHash;\n    bytes32 internal immutable chainName;\n\n    bytes32 internal constant PREFIX_CUSTOM_TOKEN_ID = keccak256('its-custom-token-id');\n    bytes32 internal constant PREFIX_STANDARDIZED_TOKEN_ID = keccak256('its-standardized-token-id');\n    bytes32 internal constant PREFIX_STANDARDIZED_TOKEN_SALT = keccak256('its-standardized-token-salt');\n\n    uint256 private constant SELECTOR_SEND_TOKEN = 1;\n    uint256 private constant SELECTOR_SEND_TOKEN_WITH_DATA = 2;\n    uint256 private constant SELECTOR_DEPLOY_TOKEN_MANAGER = 3;\n    uint256 private constant SELECTOR_DEPLOY_AND_REGISTER_STANDARDIZED_TOKEN = 4;\n\n    bytes32 private constant CONTRACT_ID = keccak256('interchain-token-service');\n\n    /**\n     * @dev All of the varaibles passed here are stored as immutable variables.\n     * @param tokenManagerDeployer_ the address of the TokenManagerDeployer.\n     * @param standardizedTokenDeployer_ the address of the StandardizedTokenDeployer.\n     * @param gateway_ the address of the AxelarGateway.\n     * @param gasService_ the address of the AxelarGasService.\n     * @param remoteAddressValidator_ the address of the RemoteAddressValidator.\n     * @param tokenManagerImplementations this need to have exactly 3 implementations in the following order: Lock/Unlock, mint/burn and then liquidity pool.\n     * @param chainName_ the name of the current chain.\n     */\n    constructor(\n        address tokenManagerDeployer_,\n        address standardizedTokenDeployer_,\n        address gateway_,\n        address gasService_,\n        address remoteAddressValidator_,\n        address[] memory tokenManagerImplementations,\n        string memory chainName_\n    ) AxelarExecutable(gateway_) {\n        if (\n            remoteAddressValidator_ == address(0) ||\n            gasService_ == address(0) ||\n            tokenManagerDeployer_ == address(0) ||\n            standardizedTokenDeployer_ == address(0)\n        ) revert ZeroAddress();\n        remoteAddressValidator = IRemoteAddressValidator(remoteAddressValidator_);\n        gasService = IAxelarGasService(gasService_);\n        tokenManagerDeployer = tokenManagerDeployer_;\n        standardizedTokenDeployer = standardizedTokenDeployer_;\n        deployer = ITokenManagerDeployer(tokenManagerDeployer_).deployer();\n\n        if (tokenManagerImplementations.length != uint256(type(TokenManagerType).max) + 1) revert LengthMismatch();\n\n        implementationLockUnlock = _sanitizeTokenManagerImplementation(tokenManagerImplementations, TokenManagerType.LOCK_UNLOCK);\n        implementationMintBurn = _sanitizeTokenManagerImplementation(tokenManagerImplementations, TokenManagerType.MINT_BURN);\n        implementationLiquidityPool = _sanitizeTokenManagerImplementation(tokenManagerImplementations, TokenManagerType.LIQUIDITY_POOL);\n\n        chainName = chainName_.toBytes32();\n        chainNameHash = keccak256(bytes(chainName_));\n    }\n\n    /*******\\\n    MODIFIERS\n    \\*******/\n\n    /**\n     * @notice This modifier is used to ensure that only a remote InterchainTokenService can _execute this one.\n     * @param sourceChain the source of the contract call.\n     * @param sourceAddress the address that the call came from.\n     */\n    modifier onlyRemoteService(string calldata sourceChain, string calldata sourceAddress) {\n        if (!remoteAddressValidator.validateSender(sourceChain, sourceAddress)) revert NotRemoteService();\n        _;\n    }\n\n    /**\n     * @notice This modifier is used to ensure certain functions can only be called by TokenManagers.\n     * @param tokenId the `tokenId` of the TokenManager trying to perform the call.\n     */\n    modifier onlyTokenManager(bytes32 tokenId) {\n        if (msg.sender != getTokenManagerAddress(tokenId)) revert NotTokenManager();\n        _;\n    }\n\n    /*****\\\n    GETTERS\n    \\*****/\n\n    /**\n     * @notice Getter for the contract id.\n     */\n    function contractId() external pure returns (bytes32) {\n        return CONTRACT_ID;\n    }\n\n    /**\n     * @notice Getter for the chain name.\n     * @return name the name of the chain\n     */\n    function getChainName() public view returns (string memory name) {\n        name = chainName.toTrimmedString();\n    }\n\n    /**\n     * @notice Calculates the address of a TokenManager from a specific tokenId. The TokenManager does not need to exist already.\n     * @param tokenId the tokenId.\n     * @return tokenManagerAddress deployement address of the TokenManager.\n     */\n    function getTokenManagerAddress(bytes32 tokenId) public view returns (address tokenManagerAddress) {\n        tokenManagerAddress = deployer.deployedAddress(address(this), tokenId);\n    }\n\n    /**\n     * @notice Returns the address of a TokenManager from a specific tokenId. The TokenManager needs to exist already.\n     * @param tokenId the tokenId.\n     * @return tokenManagerAddress deployment address of the TokenManager.\n     */\n    function getValidTokenManagerAddress(bytes32 tokenId) public view returns (address tokenManagerAddress) {\n        tokenManagerAddress = getTokenManagerAddress(tokenId);\n        if (ITokenManagerProxy(tokenManagerAddress).tokenId() != tokenId) revert TokenManagerDoesNotExist(tokenId);\n    }\n\n    /**\n     * @notice Returns the address of the token that an existing tokenManager points to.\n     * @param tokenId the tokenId.\n     * @return tokenAddress the address of the token.\n     */\n    function getTokenAddress(bytes32 tokenId) external view returns (address tokenAddress) {\n        address tokenManagerAddress = getValidTokenManagerAddress(tokenId);\n        tokenAddress = ITokenManager(tokenManagerAddress).tokenAddress();\n    }\n\n    /**\n     * @notice Returns the address of the standardized token that would be deployed with a given tokenId.\n     * The token does not need to exist.\n     * @param tokenId the tokenId.\n     * @return tokenAddress the address of the standardized token.\n     */\n    function getStandardizedTokenAddress(bytes32 tokenId) public view returns (address tokenAddress) {\n        tokenId = _getStandardizedTokenSalt(tokenId);\n        tokenAddress = deployer.deployedAddress(address(this), tokenId);\n    }\n\n    /**\n     * @notice Calculates the tokenId that would correspond to a canonical link for a given token.\n     * This will depend on what chain it is called from, unlike custom tokenIds.\n     * @param tokenAddress the address of the token.\n     * @return tokenId the tokenId that the canonical TokenManager would get (or has gotten) for the token.\n     */\n    function getCanonicalTokenId(address tokenAddress) public view returns (bytes32 tokenId) {\n        tokenId = keccak256(abi.encode(PREFIX_STANDARDIZED_TOKEN_ID, chainNameHash, tokenAddress));\n    }\n\n    /**\n     * @notice Calculates the tokenId that would correspond to a custom link for a given deployer with a specified salt.\n     * This will not depend on what chain it is called from, unlike canonical tokenIds.\n     * @param sender the address of the TokenManager deployer.\n     * @param salt the salt that the deployer uses for the deployment.\n     * @return tokenId the tokenId that the custom TokenManager would get (or has gotten).\n     */\n    function getCustomTokenId(address sender, bytes32 salt) public pure returns (bytes32 tokenId) {\n        tokenId = keccak256(abi.encode(PREFIX_CUSTOM_TOKEN_ID, sender, salt));\n    }\n\n    /**\n     * @notice Getter function for TokenManager implementations. This will mainly be called by TokenManagerProxies\n     * to figure out their implementations\n     * @param tokenManagerType the type of the TokenManager.\n     * @return tokenManagerAddress the address of the TokenManagerImplementation.\n     */\n    function getImplementation(uint256 tokenManagerType) external view returns (address tokenManagerAddress) {\n        // There could be a way to rewrite the following using assembly switch statements, which would be more gas efficient,\n        // but accessing immutable variables and/or enum values seems to be tricky, and would reduce code readability.\n        if (TokenManagerType(tokenManagerType) == TokenManagerType.LOCK_UNLOCK) {\n            return implementationLockUnlock;\n        } else if (TokenManagerType(tokenManagerType) == TokenManagerType.MINT_BURN) {\n            return implementationMintBurn;\n        } else if (TokenManagerType(tokenManagerType) == TokenManagerType.LIQUIDITY_POOL) {\n            return implementationLiquidityPool;\n        }\n    }\n\n    /**\n     * @notice Getter function for the parameters of a lock/unlock TokenManager. Mainly to be used by frontends.\n     * @param operator the operator of the TokenManager.\n     * @param tokenAddress the token to be managed.\n     * @return params the resulting params to be passed to custom TokenManager deployments.\n     */\n    f"
    }
  ]
}