{
  "Title": "[N-19]  Use scientific notation (e.g. `1e18`) rather than exponentiation (e.g. `10**18`)",
  "Content": "While the compiler knows to optimize away the exponentiation, it's still better coding practice to use idioms that do not require compiler optimization, if they exist.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol\n\n245:                      ((oracleData.token0Price * (10**18)) /\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L245\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-11-paraspace",
  "Code": [
    {
      "filename": "paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IUniswapV3OracleWrapper} from \"../interfaces/IUniswapV3OracleWrapper.sol\";\nimport {IPoolAddressesProvider} from \"../interfaces/IPoolAddressesProvider.sol\";\nimport {IPriceOracleGetter} from \"../interfaces/IPriceOracleGetter.sol\";\nimport {IUniswapV3Factory} from \"../dependencies/uniswap/IUniswapV3Factory.sol\";\nimport {IUniswapV3PoolState} from \"../dependencies/uniswap/IUniswapV3PoolState.sol\";\nimport {INonfungiblePositionManager} from \"../dependencies/uniswap/INonfungiblePositionManager.sol\";\nimport {LiquidityAmounts} from \"../dependencies/uniswap/LiquidityAmounts.sol\";\nimport {TickMath} from \"../dependencies/uniswap/libraries/TickMath.sol\";\nimport {SqrtLib} from \"../dependencies/math/SqrtLib.sol\";\nimport {FullMath} from \"../dependencies/uniswap/libraries/FullMath.sol\";\nimport {IERC20Detailed} from \"../dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport {UinswapV3PositionData} from \"../interfaces/IUniswapV3PositionInfoProvider.sol\";\n\ncontract UniswapV3OracleWrapper is IUniswapV3OracleWrapper {\n    IUniswapV3Factory immutable UNISWAP_V3_FACTORY;\n    INonfungiblePositionManager immutable UNISWAP_V3_POSITION_MANAGER;\n    IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n\n    constructor(\n        address _factory,\n        address _manager,\n        address _addressProvider\n    ) {\n        UNISWAP_V3_FACTORY = IUniswapV3Factory(_factory);\n        UNISWAP_V3_POSITION_MANAGER = INonfungiblePositionManager(_manager);\n        ADDRESSES_PROVIDER = IPoolAddressesProvider(_addressProvider);\n    }\n\n    struct FeeParams {\n        uint256 feeGrowthOutside0X128Lower;\n        uint256 feeGrowthOutside1X128Lower;\n        uint256 feeGrowthOutside0X128Upper;\n        uint256 feeGrowthOutside1X128Upper;\n    }\n\n    struct PairOracleData {\n        uint256 token0Price;\n        uint256 token1Price;\n        uint8 token0Decimal;\n        uint8 token1Decimal;\n        uint160 sqrtPriceX96;\n    }\n\n    /**\n     * @notice get onchain position data from uniswap for the specified tokenId.\n     */\n    function getOnchainPositionData(uint256 tokenId)\n        public\n        view\n        returns (UinswapV3PositionData memory)\n    {\n        (\n            ,\n            ,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint256 tokensOwed0,\n            uint256 tokensOwed1\n        ) = UNISWAP_V3_POSITION_MANAGER.positions(tokenId);\n\n        IUniswapV3PoolState pool = IUniswapV3PoolState(\n            UNISWAP_V3_FACTORY.getPool(token0, token1, fee)\n        );\n        (uint160 currentPrice, int24 currentTick, , , , , ) = pool.slot0();\n\n        return\n            UinswapV3PositionData({\n                token0: token0,\n                token1: token1,\n                fee: fee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                currentTick: currentTick,\n                currentPrice: currentPrice,\n                liquidity: liquidity,\n                feeGrowthInside0LastX128: feeGrowthInside0LastX128,\n                feeGrowthInside1LastX128: feeGrowthInside1LastX128,\n                tokensOwed0: tokensOwed0,\n                tokensOwed1: tokensOwed1\n            });\n    }\n\n    /**\n     * @notice get onchain liquidity amount for the specified tokenId.\n     */\n    function getLiquidityAmount(uint256 tokenId)\n        external\n        view\n        returns (uint256 token0Amount, uint256 token1Amount)\n    {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n        (token0Amount, token1Amount) = getLiquidityAmountFromPositionData(\n            positionData\n        );\n    }\n\n    /**\n     * @notice calculate liquidity amount for the position data.\n     * @param positionData The specified position data\n     */\n    function getLiquidityAmountFromPositionData(\n        UinswapV3PositionData memory positionData\n    ) public pure returns (uint256 token0Amount, uint256 token1Amount) {\n        (token0Amount, token1Amount) = LiquidityAmounts.getAmountsForLiquidity(\n            positionData.currentPrice,\n            TickMath.getSqrtRatioAtTick(positionData.tickLower),\n            TickMath.getSqrtRatioAtTick(positionData.tickUpper),\n            positionData.liquidity\n        );\n    }\n\n    /**\n     * @notice get liquidity provider fee amount for the specified tokenId.\n     */\n    function getLpFeeAmount(uint256 tokenId)\n        external\n        view\n        returns (uint256 token0Amount, uint256 token1Amount)\n    {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n        (token0Amount, token1Amount) = getLpFeeAmountFromPositionData(\n            positionData\n        );\n    }\n\n    /**\n     * @notice calculate liquidity provider fee amount for the position data.\n     * @param positionData The specified position data\n     */\n    function getLpFeeAmountFromPositionData(\n        UinswapV3PositionData memory positionData\n    ) public view returns (uint256 token0Amount, uint256 token1Amount) {\n        (token0Amount, token1Amount) = _getPendingFeeAmounts(positionData);\n\n        token0Amount += positionData.tokensOwed0;\n        token1Amount += positionData.tokensOwed1;\n    }\n\n    /**\n     * @notice Returns the price for the specified tokenId.\n     */\n    function getTokenPrice(uint256 tokenId) public view returns (uint256) {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n\n        PairOracleData memory oracleData = _getOracleData(positionData);\n\n        (uint256 liquidityAmount0, uint256 liquidityAmount1) = LiquidityAmounts\n            .getAmountsForLiquidity(\n                oracleData.sqrtPriceX96,\n                TickMath.getSqrtRatioAtTick(positionData.tickLower),\n                TickMath.getSqrtRatioAtTick(positionData.tickUpper),\n                positionData.liquidity\n            );\n\n        (\n            uint256 feeAmount0,\n            uint256 feeAmount1\n        ) = getLpFeeAmountFromPositionData(positionData);\n\n        return\n            (((liquidityAmount0 + feeAmount0) * oracleData.token0Price) /\n                10**oracleData.token0Decimal) +\n            (((liquidityAmount1 + feeAmount1) * oracleData.token1Price) /\n                10**oracleData.token1Decimal);\n    }\n\n    /**\n     * @notice Returns the price for the specified tokenId array.\n     */\n    function getTokensPrices(uint256[] calldata tokenIds)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory prices = new uint256[](tokenIds.length);\n\n        for (uint256 index = 0; index < tokenIds.length; index++) {\n            prices[index] = getTokenPrice(tokenIds[index]);\n        }\n\n        return prices;\n    }\n\n    /**\n     * @notice Returns the total price for the specified tokenId array.\n     */\n    function getTokensPricesSum(uint256[] calldata tokenIds)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 sum = 0;\n\n        for (uint256 index = 0; index < tokenIds.length; index++) {\n            sum += getTokenPrice(tokenIds[index]);\n        }\n\n        return sum;\n    }\n\n    function latestAnswer() external pure returns (int256) {\n        revert(\"unimplemented\");\n    }\n\n    function _getOracleData(UinswapV3PositionData memory positionData)\n        internal\n        view\n        returns (PairOracleData memory)\n    {\n        PairOracleData memory oracleData;\n        IPriceOracleGetter oracle = IPriceOracleGetter(\n            ADDRESSES_PROVIDER.getPriceOracle()\n        );\n        oracleData.token0Price = oracle.getAssetPrice(positionData.token0);\n        oracleData.token1Price = oracle.getAssetPrice(positionData.token1);\n\n        oracleData.token0Decimal = IERC20Detailed(positionData.token0)\n            .decimals();\n        oracleData.token1Decimal = IERC20Detailed(positionData.token1)\n            .decimals();\n\n        // TODO using bit shifting for the 2^96\n        // positionData.sqrtPriceX96;\n\n        if (oracleData.token1Decimal == oracleData.token0Decimal) {\n            // multiply by 10^18 then divide by 10^9 to preserve price in wei\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    ((oracleData.token0Price * (10**18)) /\n                        (oracleData.token1Price))\n                ) * 2**96) / 1E9\n            );\n        } else if (oracleData.token1Decimal > oracleData.token0Decimal) {\n            // multiple by 10^(decimalB - decimalA) to preserve price in wei\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (oracleData.token0Price *\n                        (10 **\n                            (18 +\n                                oracleData.token1Decimal -\n                                oracleData.token0Decimal))) /\n                        (oracleData.token1Price)\n                ) * 2**96) / 1E9\n            );\n        } else {\n            // multiple by 10^(decimalA - decimalB) to preserve price in wei then divide by the same number\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (oracleData.token0Price *\n                        (10 **\n                            (18 +\n                                oracleData.token0Decimal -\n                                oracleData.token1Decimal))) /\n                        (oracleData.token1Price)\n                ) * 2**96) /\n                    10 **\n                        (9 +\n                            oracleData.token0Decimal -\n                            oracleData.token1Decimal)\n            );\n        }\n\n        return oracleData;\n    }\n\n    function _getPendingFeeAmounts(UinswapV3PositionData memory positionData)\n        internal\n        view\n        returns (uint256 token0Amount, uint256 token1Amount)\n    {\n        IUniswapV3PoolState pool = IUniswapV3PoolState(\n            UNISWAP_V3_FACTORY.getPool(\n                positionData.token0,\n                positionData.token1,\n                positionData.fee\n            )\n        );\n        FeeParams memory feeParams;\n\n        (\n            ,\n            ,\n            feeParams.feeGrowthOutside0X128Lower,\n            feeParams.feeGrowthOutside1X128Lower,\n            ,\n            ,\n            ,\n\n        ) = pool.ticks(positionData.tickLower);\n        (\n            ,\n            ,\n            feeParams.feeGrowthOutside0X128Upper,\n            feeParams.feeGrowthOutside1X128Upper,\n            ,\n            ,\n            ,\n\n        ) = pool.ticks(positionData.tickUpper);\n\n        uint256 feeGrowthGlobal0X128 = pool.feeGrowthGlobal0X128();\n        uint256 feeGrowthGlobal1X128 = pool.feeGrowthGlobal1X128();\n\n        unchecked {\n            // calculate fee growth below\n            uint256 feeGrowthBelow0X128;\n            uint256 feeGrowthBelow1X128;\n            if (positionData.currentTick >= positionData.tickLower) {\n                feeGrowthBelow0X128 = feeParams.feeGrowthOutside0X128Lower;\n                feeGrowthBelow1X128 = feeParams.feeGrowthOutside1X128Lower;\n            } else {\n                feeGrowthBelow0X128 =\n                    feeGrowthGlobal0X128 -\n                    feeParams.feeGrowthOutside0X128Lower;\n                feeGrowthBelow1X128 =\n                    feeGrowthGlobal1X128 -\n                    feeParams.feeGrowthOutside1X128Lower;\n            }\n\n            // calculate fee growth above\n            uint256 feeGrowthAbove0X128;\n            uint256 feeGrowthAbove1X128;\n            if (positionData.currentTick < positionData.tickUpper) {\n                feeGrowthAbove0X128 = feeParams.feeGrowthOutside0X128Upper;\n                feeGrowthAbove1X128 = feeParams.feeGrowthOutside1X128Upper;\n            } else {\n                feeGrowthAbove0X128 =\n                    feeGrowthGlobal0X128 -\n                    feeParams.feeGrowthOutside0X128Upper;\n                feeGrowthAbove1X128 =\n                    feeGrowthGlobal1X128 -\n                    feeParams.feeGrowthOutside1X128Upper;\n            }\n            uint256 feeGrowthInside0X128;\n            uint256 feeGrowthInside1X128;\n\n            feeGrowthInside0X128 =\n                feeGrowthGlobal0X128 -\n                feeGrowthBelow0X128 -\n                feeGrowthAbove0X128;\n            feeGrowthInside1X128 =\n                feeGrowthGlobal1X128 -\n                feeGrowthBelow1X128 -\n                feeGrowthAbove1X128;\n\n            token0Amount = uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside0X128 -\n                        positionData.feeGrowthInside0LastX128,\n                    positionData.liquidity,\n                    Q128\n                )\n            );\n\n            token1Amount = uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside1X128 -\n                        positionData.feeGrowthInside1LastX128,\n                    positionData.liquidity,\n                    Q128\n                )\n            );\n        }\n    }\n}"
    }
  ]
}