{
  "Title": "[G-11] Write a more gas efficient assembly loop",
  "Content": "In the instance below, we can rewrite the assembly loop using a more gas efficient infinite loop, which performs the condition check at the end of the loop. See [this](https://www.youtube.com/watch?v=ew3pfnb2_V8&t=946s) for more information.\n\nhttps://github.com/code-423n4/2023-04-ens/blob/main/contracts/utils/HexUtils.sol#L44-L58\n\n*Gas Savings for `DNSRegistrar.proveAndClaimWithResolver`, obtained via protocol's tests: Avg 306 gas* \n\n|        |    Min   |    Max   |   Avg   | # calls  |\n| ------ | -------- | -------- | ------- | -------- |\n| Before |  301464  |  339399  |  320432 |    2     |\n| After  |  301158  |  339093  |  320126 |    2     |\n\n```solidity\nFile: contracts/utils/HexUtils.sol\n44:            for {\n45:                let i := idx\n46:            } lt(i, lastIdx) {\n47:                i := add(i, 2)\n48:            } {\n49:                let byte1 := getHex(byte(0, mload(add(ptr, i))))\n50:                let byte2 := getHex(byte(0, mload(add(ptr, add(i, 1)))))\n51:                // if either byte is invalid, set invalid and break loop\n52:                if or(eq(byte1, 0xff), eq(byte2, 0xff)) {\n53:                    valid := false\n54:                    break\n55:                }\n56:                let combined := or(shl(4, byte1), byte2)\n57:                r := or(shl(8, r), combined)\n58:            }\n```\n```diff\ndiff --git a/contracts/utils/HexUtils.sol b/contracts/utils/HexUtils.sol\nindex 3508390..b8579b7 100644\n--- a/contracts/utils/HexUtils.sol\n+++ b/contracts/utils/HexUtils.sol\n@@ -41,11 +41,8 @@ library HexUtils {\n             }\n\n             let ptr := add(str, 32)\n-            for {\n-                let i := idx\n-            } lt(i, lastIdx) {\n-                i := add(i, 2)\n-            } {\n+            let i := idx\n+            for {} 1 {} {\n                 let byte1 := getHex(byte(0, mload(add(ptr, i))))\n                 let byte2 := getHex(byte(0, mload(add(ptr, add(i, 1)))))\n                 // if either byte is invalid, set invalid and break loop\n@@ -55,6 +52,8 @@ library HexUtils {\n                 }\n                 let combined := or(shl(4, byte1), byte2)\n                 r := or(shl(8, r), combined)\n+                i := add(i, 2)\n+                if iszero(lt(i, lastIdx)) { break }\n             }\n         }\n     }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-04-ens",
  "Code": [
    {
      "filename": "contracts/utils/HexUtils.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary HexUtils {\n    /**\n     * @dev Attempts to parse bytes32 from a hex string\n     * @param str The string to parse\n     * @param idx The offset to start parsing at\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n     */\n    function hexStringToBytes32(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (bytes32 r, bool valid) {\n        valid = true;\n        assembly {\n            // check that the index to read to is not past the end of the string\n            if gt(lastIdx, mload(str)) {\n                revert(0, 0)\n            }\n\n            function getHex(c) -> ascii {\n                // chars 48-57: 0-9\n                if and(gt(c, 47), lt(c, 58)) {\n                    ascii := sub(c, 48)\n                    leave\n                }\n                // chars 65-70: A-F\n                if and(gt(c, 64), lt(c, 71)) {\n                    ascii := add(sub(c, 65), 10)\n                    leave\n                }\n                // chars 97-102: a-f\n                if and(gt(c, 96), lt(c, 103)) {\n                    ascii := add(sub(c, 97), 10)\n                    leave\n                }\n                // invalid char\n                ascii := 0xff\n            }\n\n            let ptr := add(str, 32)\n            for {\n                let i := idx\n            } lt(i, lastIdx) {\n                i := add(i, 2)\n            } {\n                let byte1 := getHex(byte(0, mload(add(ptr, i))))\n                let byte2 := getHex(byte(0, mload(add(ptr, add(i, 1)))))\n                // if either byte is invalid, set invalid and break loop\n                if or(eq(byte1, 0xff), eq(byte2, 0xff)) {\n                    valid := false\n                    break\n                }\n                let combined := or(shl(4, byte1), byte2)\n                r := or(shl(8, r), combined)\n            }\n        }\n    }\n\n    /**\n     * @dev Attempts to parse an address from a hex string\n     * @param str The string to parse\n     * @param idx The offset to start parsing at\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n     */\n    function hexToAddress(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (address, bool) {\n        if (lastIdx - idx < 40) return (address(0x0), false);\n        (bytes32 r, bool valid) = hexStringToBytes32(str, idx, lastIdx);\n        return (address(uint160(uint256(r))), valid);\n    }\n}"
    }
  ]
}