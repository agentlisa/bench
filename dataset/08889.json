{
  "Title": "[N-07] Constant redefined elsewhere",
  "Content": "Consider defining in only one contract so that values cannot become out of sync when only one location is updated. A [cheap way](https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678) to store constants in a single location is to create an `internal constant` in a `library`. If the variable is a local cache of another contract's value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers don't get out of sync.\n\n*There are 10 instances of this issue:*\n```solidity\nFile: protocol/contracts/Controller.sol\n\n/// @audit seen in protocol/contracts/StakerVault.sol \n21:       IAddressProvider public immutable override addressProvider;\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L21\n\n```solidity\nFile: protocol/contracts/RewardHandler.sol\n\n/// @audit seen in protocol/contracts/StakerVault.sol \n20:       IController public immutable controller;\n\n/// @audit seen in protocol/contracts/Controller.sol \n21:       IAddressProvider public immutable addressProvider;\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L20\n\n```solidity\nFile: protocol/contracts/tokenomics/Minter.sol\n\n/// @audit seen in protocol/contracts/RewardHandler.sol \n55:       IController public immutable controller;\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L55\n\n```solidity\nFile: protocol/contracts/tokenomics/InflationManager.sol\n\n/// @audit seen in protocol/contracts/RewardHandler.sol \n24:       IAddressProvider public immutable addressProvider;\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L24\n\n```solidity\nFile: protocol/contracts/tokenomics/AmmGauge.sol\n\n/// @audit seen in protocol/contracts/tokenomics/Minter.sol \n20:       IController public immutable controller;\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L20\n\n```solidity\nFile: protocol/contracts/tokenomics/KeeperGauge.sol\n\n/// @audit seen in protocol/contracts/tokenomics/AmmGauge.sol \n30:       IController public immutable controller;\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L30\n\n```solidity\nFile: protocol/contracts/tokenomics/LpGauge.sol\n\n/// @audit seen in protocol/contracts/tokenomics/KeeperGauge.sol \n19:       IController public immutable controller;\n\n/// @audit seen in protocol/contracts/StakerVault.sol \n21:       IInflationManager public immutable inflationManager;\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L19\n\n```solidity\nFile: protocol/contracts/access/RoleManager.sol\n\n/// @audit seen in protocol/contracts/tokenomics/InflationManager.sol \n25:       IAddressProvider public immutable addressProvider;\n```\nhttps://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/access/RoleManager.sol#L25\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-backd",
  "Code": [
    {
      "filename": "protocol/contracts/Controller.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"../interfaces/actions/IAction.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IStakerVault.sol\";\nimport \"../interfaces/pool/ILiquidityPool.sol\";\nimport \"../interfaces/tokenomics/IInflationManager.sol\";\n\nimport \"../libraries/AddressProviderHelpers.sol\";\nimport \"../libraries/UncheckedMath.sol\";\n\nimport \"./utils/Preparable.sol\";\nimport \"./access/Authorization.sol\";\n\ncontract Controller is IController, Authorization, Preparable {\n    using UncheckedMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IAddressProvider public immutable override addressProvider;\n\n    IInflationManager public inflationManager;\n\n    bytes32 internal constant _KEEPER_REQUIRED_STAKED_BKD = \"KEEPER_REQUIRED_STAKED_BKD\";\n\n    constructor(IAddressProvider _addressProvider)\n        Authorization(_addressProvider.getRoleManager())\n    {\n        addressProvider = _addressProvider;\n    }\n\n    function setInflationManager(address _inflationManager) external onlyGovernance {\n        require(address(inflationManager) == address(0), Error.ADDRESS_ALREADY_SET);\n        require(_inflationManager != address(0), Error.INVALID_ARGUMENT);\n        inflationManager = IInflationManager(_inflationManager);\n    }\n\n    function addStakerVault(address stakerVault)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)\n        returns (bool)\n    {\n        if (!addressProvider.addStakerVault(stakerVault)) {\n            return false;\n        }\n        if (address(inflationManager) != address(0)) {\n            address lpGauge = IStakerVault(stakerVault).getLpGauge();\n            if (lpGauge != address(0)) {\n                inflationManager.whitelistGauge(lpGauge);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Delists pool.\n     * @param pool Address of pool to delist.\n     * @return `true` if successful.\n     */\n    function removePool(address pool) external override onlyGovernance returns (bool) {\n        if (!addressProvider.removePool(pool)) {\n            return false;\n        }\n        address lpToken = ILiquidityPool(pool).getLpToken();\n\n        if (address(inflationManager) != address(0)) {\n            (bool exists, address stakerVault) = addressProvider.tryGetStakerVault(lpToken);\n            if (exists) {\n                inflationManager.removeStakerVaultFromInflation(stakerVault, lpToken);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Prepares the minimum amount of staked BKD required by a keeper\n     */\n    function prepareKeeperRequiredStakedBKD(uint256 amount) external override onlyGovernance {\n        require(addressProvider.getBKDLocker() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        _prepare(_KEEPER_REQUIRED_STAKED_BKD, amount);\n    }\n\n    /**\n     * @notice Resets the minimum amount of staked BKD required by a keeper\n     */\n    function resetKeeperRequiredStakedBKD() external override onlyGovernance {\n        _resetUInt256Config(_KEEPER_REQUIRED_STAKED_BKD);\n    }\n\n    /**\n     * @notice Sets the minimum amount of staked BKD required by a keeper to the prepared value\n     */\n    function executeKeeperRequiredStakedBKD() external override {\n        _executeUInt256(_KEEPER_REQUIRED_STAKED_BKD);\n    }\n\n    /**\n     * @notice Returns true if the given keeper has enough staked BKD to execute actions\n     */\n    function canKeeperExecuteAction(address keeper) external view override returns (bool) {\n        uint256 requiredBKD = getKeeperRequiredStakedBKD();\n        return\n            requiredBKD == 0 ||\n            IERC20(addressProvider.getBKDLocker()).balanceOf(keeper) >= requiredBKD;\n    }\n\n    /**\n     * @return Returns the minimum amount of staked BKD required by a keeper\n     */\n    function getKeeperRequiredStakedBKD() public view override returns (uint256) {\n        return currentUInts256[_KEEPER_REQUIRED_STAKED_BKD];\n    }\n\n    /**\n     * @return the total amount of ETH require by `payer` to cover the fees for\n     * positions registered in all actions\n     */\n    function getTotalEthRequiredForGas(address payer) external view override returns (uint256) {\n        // solhint-disable-previous-line ordering\n        uint256 totalEthRequired;\n        address[] memory actions = addressProvider.allActions();\n        uint256 numActions = actions.length;\n        for (uint256 i; i < numActions; i = i.uncheckedInc()) {\n            totalEthRequired += IAction(actions[i]).getEthRequiredForGas(payer);\n        }\n        return totalEthRequired;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/RewardHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IFeeBurner.sol\";\nimport \"../interfaces/IBkdLocker.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IRewardHandler.sol\";\nimport \"./utils/Preparable.sol\";\nimport \"./access/Authorization.sol\";\nimport \"../libraries/AddressProviderHelpers.sol\";\nimport \"../libraries/UncheckedMath.sol\";\n\ncontract RewardHandler is IRewardHandler, Preparable, Authorization {\n    using UncheckedMath for uint256;\n    using SafeERC20 for IERC20;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = IAddressProvider(controller.addressProvider());\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Burns all accumulated fees and pays these out to the BKD locker.\n     */\n    function burnFees() external override {\n        IBkdLocker bkdLocker = IBkdLocker(addressProvider.getBKDLocker());\n        IFeeBurner feeBurner = addressProvider.getFeeBurner();\n        address targetLpToken = bkdLocker.rewardToken();\n        address[] memory pools = addressProvider.allPools();\n        uint256 ethBalance = address(this).balance;\n        address[] memory tokens = new address[](pools.length);\n        for (uint256 i; i < pools.length; i = i.uncheckedInc()) {\n            ILiquidityPool pool = ILiquidityPool(pools[i]);\n            address underlying = pool.getUnderlying();\n            if (underlying != address(0)) {\n                _approve(underlying, address(feeBurner));\n            }\n            tokens[i] = underlying;\n        }\n        feeBurner.burnToTarget{value: ethBalance}(tokens, targetLpToken);\n        uint256 burnedAmount = IERC20(targetLpToken).balanceOf(address(this));\n        IERC20(targetLpToken).safeApprove(address(bkdLocker), burnedAmount);\n        bkdLocker.depositFees(burnedAmount);\n        emit Burned(targetLpToken, burnedAmount);\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) > 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n}"
    },
    {
      "filename": "protocol/contracts/tokenomics/Minter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/tokenomics/IBkdToken.sol\";\nimport \"../../interfaces/tokenomics/IMinter.sol\";\n\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\n\nimport \"./BkdToken.sol\";\nimport \"../access/Authorization.sol\";\n\ncontract Minter is IMinter, Authorization, ReentrancyGuard {\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    uint256 private constant _INFLATION_DECAY_PERIOD = 365 days;\n\n    // Lp Rates\n    uint256 public immutable initialAnnualInflationRateLp;\n    uint256 public immutable annualInflationDecayLp;\n    uint256 public currentInflationAmountLp;\n\n    // Keeper Rates\n    uint256 public immutable initialPeriodKeeperInflation;\n    uint256 public immutable initialAnnualInflationRateKeeper;\n    uint256 public immutable annualInflationDecayKeeper;\n    uint256 public currentInflationAmountKeeper;\n\n    // AMM Rates\n    uint256 public immutable initialPeriodAmmInflation;\n    uint256 public immutable initialAnnualInflationRateAmm;\n    uint256 public immutable annualInflationDecayAmm;\n    uint256 public currentInflationAmountAmm;\n\n    bool public initialPeriodEnded;\n\n    // Non-inflation rates\n    uint256 public immutable nonInflationDistribution;\n    uint256 public issuedNonInflationSupply;\n\n    uint256 public lastInflationDecay;\n    uint256 public currentTotalInflation;\n\n    // Used for final safety check to ensure inflation is not exceeded\n    uint256 public totalAvailableToNow;\n    uint256 public totalMintedToNow;\n    uint256 public lastEvent;\n\n    IController public immutable controller;\n    BkdToken public token;\n\n    event TokensMinted(address beneficiary, uint256 amount);\n\n    constructor(\n        uint256 _annualInflationRateLp,\n        uint256 _annualInflationRateKeeper,\n        uint256 _annualInflationRateAmm,\n        uint256 _annualInflationDecayLp,\n        uint256 _annualInflationDecayKeeper,\n        uint256 _annualInflationDecayAmm,\n        uint256 _initialPeriodKeeperInflation,\n        uint256 _initialPeriodAmmInflation,\n        uint256 _nonInflationDistribution,\n        IController _controller\n    ) Authorization(_controller.addressProvider().getRoleManager()) {\n        require(_annualInflationDecayLp < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);\n        require(_annualInflationDecayKeeper < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);\n        require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);\n        initialAnnualInflationRateLp = _annualInflationRateLp;\n        initialAnnualInflationRateKeeper = _annualInflationRateKeeper;\n        initialAnnualInflationRateAmm = _annualInflationRateAmm;\n\n        annualInflationDecayLp = _annualInflationDecayLp;\n        annualInflationDecayKeeper = _annualInflationDecayKeeper;\n        annualInflationDecayAmm = _annualInflationDecayAmm;\n\n        initialPeriodKeeperInflation = _initialPeriodKeeperInflation;\n        initialPeriodAmmInflation = _initialPeriodAmmInflation;\n\n        currentInflationAmountLp = _annualInflationRateLp / _INFLATION_DECAY_PERIOD;\n        currentInflationAmountKeeper = _initialPeriodKeeperInflation / _INFLATION_DECAY_PERIOD;\n        currentInflationAmountAmm = _initialPeriodAmmInflation / _INFLATION_DECAY_PERIOD;\n\n        currentTotalInflation =\n            currentInflationAmountLp +\n            currentInflationAmountKeeper +\n            currentInflationAmountAmm;\n\n        nonInflationDistribution = _nonInflationDistribution;\n        controller = _controller;\n    }\n\n    function setToken(address _token) external override onlyGovernance {\n        require(address(token) == address(0), \"Token already set!\");\n        token = BkdToken(_token);\n    }\n\n    function startInflation() external override onlyGovernance {\n        require(lastEvent == 0, \"Inflation has already started.\");\n        lastEvent = block.timestamp;\n        lastInflationDecay = block.timestamp;\n    }\n\n    /**\n     * @notice Update the inflation rate according to the piecewise linear schedule.\n     * @dev This updates the inflation rate to the next linear segment in the inflations schedule.\n     * @return `true` if successful.\n     */\n    function executeInflationRateUpdate() external override returns (bool) {\n        return _executeInflationRateUpdate();\n    }\n\n    /**\n     * @notice Mints BKD tokens to a specified address.\n     * @dev Can only be called by the controller.\n     * @param beneficiary Address to mint tokens for.\n     * @param amount Amount of tokens to mint.\n     * @return `true` if successful.\n     */\n    function mint(address beneficiary, uint256 amount)\n        external\n        override\n        nonReentrant\n        returns (bool)\n    {\n        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);\n        if (lastEvent == 0) return false;\n        return _mint(beneficiary, amount);\n    }\n\n    /**\n     * @notice Mint tokens that are not part of the inflation schedule.\n     * @dev The amount of tokens that can be minted in total is subject to a pre-set upper limit.\n     * @param beneficiary Address to mint tokens for.\n     * @param amount Amount of tokens to mint.\n     * @return `true` if successful.\n     */\n    function mintNonInflationTokens(address beneficiary, uint256 amount)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            issuedNonInflationSupply + amount <= nonInflationDistribution,\n            \"Maximum non-inflation amount exceeded.\"\n        );\n        issuedNonInflationSupply += amount;\n        token.mint(beneficiary, amount);\n        emit TokensMinted(beneficiary, amount);\n        return true;\n    }\n\n    /**\n     * @notice Supplies the inflation rate for LPs per unit of time (seconds).\n     * @return LP inflation rate.\n     */\n    function getLpInflationRate() external view override returns (uint256) {\n        if (lastEvent == 0) return 0;\n        return currentInflationAmountLp;\n    }\n\n    /**\n     * @notice Supplies the inflation rate for keepers per unit of time (seconds).\n     * @return keeper inflation rate.\n     */\n    function getKeeperInflationRate() external view override returns (uint256) {\n        if (lastEvent == 0) return 0;\n        return currentInflationAmountKeeper;\n    }\n\n    /**\n     * @notice Supplies the inflation rate for LPs on AMMs per unit of time (seconds).\n     * @return AMM inflation rate.\n     */\n    function getAmmInflationRate() external view override returns (uint256) {\n        if (lastEvent == 0) return 0;\n        return currentInflationAmountAmm;\n    }\n\n    function _executeInflationRateUpdate() internal returns (bool) {\n        totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));\n        lastEvent = block.timestamp;\n        if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {\n            currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);\n            if (initialPeriodEnded) {\n                currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(\n                    annualInflationDecayKeeper\n                );\n                currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(\n                    annualInflationDecayAmm\n                );\n            } else {\n                currentInflationAmountKeeper =\n                    initialAnnualInflationRateKeeper /\n                    _INFLATION_DECAY_PERIOD;\n\n                currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;\n                initialPeriodEnded = true;\n            }\n            currentTotalInflation =\n                currentInflationAmountLp +\n                currentInflationAmountKeeper +\n                currentInflationAmountAmm;\n            controller.inflationManager().checkpointAllGauges();\n            lastInflationDecay = block.timestamp;\n        }\n        return true;\n    }\n\n    function _mint(address beneficiary, uint256 amount) internal returns (bool) {\n        totalAvailableToNow += ((block.timestamp - lastEvent) * currentTotalInflation);\n        uint256 newTotalMintedToNow = totalMintedToNow + amount;\n        require(newTotalMintedToNow <= totalAvailableToNow, \"Mintable amount exceeded\");\n        totalMintedToNow = newTotalMintedToNow;\n        lastEvent = block.timestamp;\n        token.mint(beneficiary, amount);\n        _executeInflationRateUpdate();\n        emit TokensMinted(beneficiary, amount);\n        return true;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/tokenomics/InflationManager.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"../../interfaces/IStakerVault.sol\";\nimport \"../../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../../interfaces/tokenomics/IKeeperGauge.sol\";\nimport \"../../interfaces/tokenomics/IAmmGauge.sol\";\n\nimport \"../../libraries/EnumerableMapping.sol\";\nimport \"../../libraries/EnumerableExtensions.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../libraries/UncheckedMath.sol\";\n\nimport \"./Minter.sol\";\nimport \"../utils/Preparable.sol\";\nimport \"../access/Authorization.sol\";\n\ncontract InflationManager is Authorization, IInflationManager, Preparable {\n    using UncheckedMath for uint256;\n    using EnumerableMapping for EnumerableMapping.AddressToAddressMap;\n    using EnumerableExtensions for EnumerableMapping.AddressToAddressMap;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IAddressProvider public immutable addressProvider;\n\n    bytes32 internal constant _KEEPER_WEIGHT_KEY = \"keeperWeight\";\n    bytes32 internal constant _AMM_WEIGHT_KEY = \"ammWeight\";\n    bytes32 internal constant _LP_WEIGHT_KEY = \"lpWeight\";\n\n    address public minter;\n    bool public weightBasedKeeperDistributionDeactivated;\n    uint256 public totalKeeperPoolWeight;\n    uint256 public totalLpPoolWeight;\n    uint256 public totalAmmTokenWeight;\n\n    // Pool -> keeperGauge\n    EnumerableMapping.AddressToAddressMap private _keeperGauges;\n    // AMM token -> ammGauge\n    EnumerableMapping.AddressToAddressMap private _ammGauges;\n\n    mapping(address => bool) public gauges;\n\n    event NewKeeperWeight(address indexed pool, uint256 newWeight);\n    event NewLpWeight(address indexed pool, uint256 newWeight);\n    event NewAmmTokenWeight(address indexed token, uint256 newWeight);\n\n    modifier onlyGauge() {\n        require(gauges[msg.sender], Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor(IAddressProvider _addressProvider)\n        Authorization(_addressProvider.getRoleManager())\n    {\n        addressProvider = _addressProvider;\n    }\n\n    function setMinter(address _minter) external override onlyGovernance returns (bool) {\n        require(minter == address(0), Error.ADDRESS_ALREADY_SET);\n        require(_minter != address(0), Error.INVALID_MINTER);\n        minter = _minter;\n        return true;\n    }\n\n    /**\n     * @notice Advance the keeper gauge for a pool by on epoch.\n     * @param pool Pool for which the keeper gauge is advanced.\n     * @return `true` if successful.\n     */\n    function advanceKeeperGaugeEpoch(address pool) external override onlyGovernance returns (bool) {\n        IKeeperGauge(_keeperGauges.get(pool)).advanceEpoch();\n        return true;\n    }\n\n    /**\n     * @notice Mints BKD tokens.\n     * @param beneficiary Address to receive the tokens.\n     * @param amount Amount of tokens to mint.\n     */\n    function mintRewards(address beneficiary, uint256 amount) external override onlyGauge {\n        Minter(minter).mint(beneficiary, amount);\n    }\n\n    /**\n     * @notice Deactivates the weight-based distribution of keeper inflation.\n     * @dev This can only be done once, when the keeper inflation mechanism is altered.\n     * @return `true` if successful.\n     */\n    function deactivateWeightBasedKeeperDistribution()\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(!weightBasedKeeperDistributionDeactivated, \"Weight-based dist. deactivated.\");\n        address[] memory liquidityPools = addressProvider.allPools();\n        uint256 length = liquidityPools.length;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            _removeKeeperGauge(address(liquidityPools[i]));\n        }\n        weightBasedKeeperDistributionDeactivated = true;\n        return true;\n    }\n\n    /**\n     * @notice Checkpoints all gauges.\n     * @dev This is mostly used upon inflation rate updates.\n     * @return `true` if successful.\n     */\n    function checkpointAllGauges() external override returns (bool) {\n        uint256 length = _keeperGauges.length();\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            IKeeperGauge(_keeperGauges.valueAt(i)).poolCheckpoint();\n        }\n        address[] memory stakerVaults = addressProvider.allStakerVaults();\n        for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {\n            IStakerVault(stakerVaults[i]).poolCheckpoint();\n        }\n\n        length = _ammGauges.length();\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            IAmmGauge(_ammGauges.valueAt(i)).poolCheckpoint();\n        }\n        return true;\n    }\n\n    /**\n     * @notice Prepare update of a keeper pool weight (with time delay enforced).\n     * @param pool Pool to update the keeper weight for.\n     * @param newPoolWeight New weight for the keeper inflation for the pool.\n     * @return `true` if successful.\n     */\n    function prepareKeeperPoolWeight(address pool, uint256 newPoolWeight)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(_keeperGauges.contains(pool), Error.INVALID_ARGUMENT);\n        bytes32 key = _getKeeperGaugeKey(pool);\n        _prepare(key, newPoolWeight);\n        return true;\n    }\n\n    /**\n     * @notice Execute update of keeper pool weight (with time delay enforced).\n     * @param pool Pool to execute the keeper weight update for.\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return New keeper pool weight.\n     */\n    function executeKeeperPoolWeight(address pool) external override returns (uint256) {\n        bytes32 key = _getKeeperGaugeKey(pool);\n        _executeKeeperPoolWeight(key, pool, isInflationWeightManager(msg.sender));\n        return currentUInts256[key];\n    }\n\n    /**\n     * @notice Prepare update of a batch of keeperGauge weights (with time delay enforced).\n     * @dev Each entry in the pools array corresponds to an entry in the weights array.\n     * @param pools Pools to update the keeper weight for.\n     * @param weights New weights for the keeper inflation for the pools.\n     * @return `true` if successful.\n     */\n    function batchPrepareKeeperPoolWeights(address[] calldata pools, uint256[] calldata weights)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        uint256 length = pools.length;\n        require(length == weights.length, Error.INVALID_ARGUMENT);\n        bytes32 key;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            require(_keeperGauges.contains(pools[i]), Error.INVALID_ARGUMENT);\n            key = _getKeeperGaugeKey(pools[i]);\n            _prepare(key, weights[i]);\n        }\n        return true;\n    }\n\n    function whitelistGauge(address gauge) external override onlyRole(Roles.CONTROLLER) {\n        gauges[gauge] = true;\n    }\n\n    /**\n     * @notice Execute weight updates for a batch of _keeperGauges.\n     * @param pools Pools to execute the keeper weight updates for.\n     * @return `true` if successful.\n     */\n    function batchExecuteKeeperPoolWeights(address[] calldata pools)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = pools.length;\n        bytes32 key;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            key = _getKeeperGaugeKey(pools[i]);\n            _executeKeeperPoolWeight(key, pools[i], isInflationWeightManager(msg.sender));\n        }\n        return true;\n    }\n\n    function removeStakerVaultFromInflation(address stakerVault, address lpToken)\n        external\n        override\n        onlyRole(Roles.CONTROLLER)\n    {\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        _prepare(key, 0);\n        _executeLpPoolWeight(key, lpToken, stakerVault, true);\n    }\n\n    /**\n     * @notice Prepare update of a lp pool weight (with time delay enforced).\n     * @param lpToken LP token to update the weight for.\n     * @param newPoolWeight New LP inflation weight.\n     * @return `true` if successful.\n     */\n    function prepareLpPoolWeight(address lpToken, uint256 newPoolWeight)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        address stakerVault = addressProvider.getStakerVault(lpToken);\n        // Require both that gauge is registered and that pool is still in action\n        require(gauges[IStakerVault(stakerVault).getLpGauge()], Error.GAUGE_DOES_NOT_EXIST);\n        _ensurePoolExists(lpToken);\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        _prepare(key, newPoolWeight);\n        return true;\n    }\n\n    /**\n     * @notice Execute update of lp pool weight (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return New lp pool weight.\n     */\n    function executeLpPoolWeight(address lpToken) external override returns (uint256) {\n        address stakerVault = addressProvider.getStakerVault(lpToken);\n        // Require both that gauge is registered and that pool is still in action\n        require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);\n        _ensurePoolExists(lpToken);\n        bytes32 key = _getLpStakerVaultKey(stakerVault);\n        _executeLpPoolWeight(key, lpToken, stakerVault, isInflationWeightManager(msg.sender));\n        return currentUInts256[key];\n    }\n\n    /**\n     * @notice Prepare update of a batch of LP token weights (with time delay enforced).\n     * @dev Each entry in the lpTokens array corresponds to an entry in the weights array.\n     * @param lpTokens LpTokens to update the inflation weight for.\n     * @param weights New weights for the inflation for the LpTokens.\n     * @return `true` if successful.\n     */\n    function batchPrepareLpPoolWeights(address[] calldata lpTokens, uint256[] calldata weights)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = lpTokens.length;\n        require(length == weights.length, \"Invalid length of arguments\");\n        bytes32 key;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            address stakerVault = addressProvider.getStakerVault(lpTokens[i]);\n            // Require both that gauge is registered and that pool is still in action\n            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);\n            _ensurePoolExists(lpTokens[i]);\n            key = _getLpStakerVaultKey(stakerVault);\n            _prepare(key, weights[i]);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Execute weight updates for a batch of LpTokens.\n     * @dev If this is called by the INFLATION_MANAGER role address, no time delay is enforced.\n     * @param lpTokens LpTokens to execute the weight updates for.\n     * @return `true` if successful.\n     */\n    function batchExecuteLpPoolWeights(address[] calldata lpTokens)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = lpTokens.length;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            address lpToken = lpTokens[i];\n            address stakerVault = addressProvider.getStakerVault(lpToken);\n            // Require both that gauge is registered and that pool is still in action\n            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);\n            _ensurePoolExists(lpToken);\n            bytes32 key = _getLpStakerVaultKey(stakerVault);\n            _executeLpPoolWeight(key, lpToken, stakerVault, isInflationWeightManager(msg.sender));\n        }\n        return true;\n    }\n\n    /**\n     * @notice Prepare an inflation weight update for an AMM token (with time delay enforced).\n     * @param token AMM token to update the weight for.\n     * @param newTokenWeight New AMM token inflation weight.\n     * @return `true` if successful.\n     */\n    function prepareAmmTokenWeight(address token, uint256 newTokenWeight)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        require(_ammGauges.contains(token), \"amm gauge not found\");\n        bytes32 key = _getAmmGaugeKey(token);\n        _prepare(key, newTokenWeight);\n        return true;\n    }\n\n    /**\n     * @notice Execute update of lp pool weight (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return New lp pool weight.\n     */\n    function executeAmmTokenWeight(address token) external override returns (uint256) {\n        bytes32 key = _getAmmGaugeKey(token);\n        _executeAmmTokenWeight(token, key, isInflationWeightManager(msg.sender));\n        return currentUInts256[key];\n    }\n\n    /**\n     * @notice Registers a pool's strategy with the stakerVault of the pool where the strategy deposits.\n     * @dev This simply avoids the strategy accumulating tokens in the deposit pool.\n     * @param depositStakerVault StakerVault of the pool where the strategy deposits.\n     * @param strategyPool The pool of the strategy to register (avoids blacklisting other addresses).\n     * @return `true` if successful.\n     */\n    function addStrategyToDepositStakerVault(address depositStakerVault, address strategyPool)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        IVault _vault = ILiquidityPool(strategyPool).getVault();\n        IStakerVault(depositStakerVault).addStrategy(address(_vault.getStrategy()));\n        return true;\n    }\n\n    /**\n     * @notice Prepare update of a batch of AMM token weights (with time delay enforced).\n     * @dev Each entry in the tokens array corresponds to an entry in the weights array.\n     * @param tokens AMM tokens to update the inflation weight for.\n     * @param weights New weights for the inflation for the AMM tokens.\n     * @return `true` if successful.\n     */\n    function batchPrepareAmmTokenWeights(address[] calldata tokens, uint256[] calldata weights)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = tokens.length;\n        bytes32 key;\n        require(length == weights.length, \"Invalid length of arguments\");\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            require(_ammGauges.contains(tokens[i]), \"amm gauge not found\");\n            key = _getAmmGaugeKey(tokens[i]);\n            _prepare(key, weights[i]);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Execute weight updates for a batch of AMM tokens.\n     * @dev If this is called by the INFLATION_MANAGER role address, no time delay is enforced.\n     * @param tokens AMM tokens to execute the weight updates for.\n     * @return `true` if successful.\n     */\n    function batchExecuteAmmTokenWeights(address[] calldata tokens)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)\n        returns (bool)\n    {\n        uint256 length = tokens.length;\n        bool isWeightManager = isInflationWeightManager(msg.sender);\n        bytes32 key;\n        address token;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            token = tokens[i];\n            key = _getAmmGaugeKey(token);\n            _executeAmmTokenWeight(token, key, isWeightManager);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Sets the KeeperGauge for a pool.\n     * @dev Multiple pools can have the same KeeperGauge.\n     * @param pool Address of pool to set the KeeperGauge for.\n     * @param _keeperGauge Address of KeeperGauge.\n     * @return `true` if successful.\n     */\n    function setKeeperGauge(address pool, address _keeperGauge)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        uint256 length = _keeperGauges.length();\n        bool keeperGaugeExists = false;\n        for (uint256 i; i < length; i = i.uncheckedInc()) {\n            if (address(_keeperGauges.valueAt(i)) == _keeperGauge) {\n                keeperGaugeExists = true;\n                break;\n            }\n        }\n        // Check to make sure that once weight-based dist is deactivated, only one gauge can exist\n        if (!keeperGaugeExists && weightBased"
    }
  ]
}