{
  "Title": "[L-05] `updateDesiredAPR` might revert when `aprFloor` < `maxAdjustment`, so aprFloor(2%) must be greater than maxAdjustment(0.5%)",
  "Content": "\n- https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/RewardSystem/RewardThrottle.sol#L131-L183\n\n\n```solidity\n  function updateDesiredAPR() public onlyActive {\n    ...\n    uint256 newAPR = targetAPR; // gas\n    uint256 adjustmentCap = maxAdjustment; // gas\n    \n    ...\n\n      if (adjustment > adjustmentCap) {\n        adjustment = adjustmentCap;\n      }\n\n      newAPR -= adjustment;\n    }\n\n    uint256 cap = aprCap; // gas\n    uint256 floor = aprFloor; // gas\n    if (newAPR > cap) {\n      newAPR = cap;\n    } else if (newAPR < floor) {\n      newAPR = floor;\n    }\n\n    targetAPR = newAPR;\n    aprLastUpdated = block.timestamp;\n    emit UpdateDesiredAPR(newAPR);\n  }\n```\n\nIf `aprFloor` < `maxAdjustment`, `newAPR` can be `aprFloor` and `adjustment` can be `maxAdjustment`, so \n`newAPR -= adjustment` will revert. So it needs to make sure that `aprFloor` > `maxAdjustment`.\n\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2023-02-malt-protocol-versus-contest",
  "Code": [
    {
      "filename": "contracts/RewardSystem/RewardThrottle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"openzeppelin/utils/math/Math.sol\";\nimport \"openzeppelin/token/ERC20/ERC20.sol\";\nimport \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../StabilizedPoolExtensions/StabilizedPoolUnit.sol\";\nimport \"../StabilizedPoolExtensions/BondingExtension.sol\";\nimport \"../StabilizedPoolExtensions/RewardOverflowExtension.sol\";\nimport \"../interfaces/ITimekeeper.sol\";\nimport \"../interfaces/IOverflow.sol\";\nimport \"../interfaces/IBonding.sol\";\nimport \"../interfaces/IDistributor.sol\";\n\nstruct State {\n  uint256 profit;\n  uint256 rewarded;\n  uint256 bondedValue;\n  uint256 epochsPerYear;\n  uint256 desiredAPR;\n  uint256 cumulativeCashflowApr;\n  uint256 cumulativeApr;\n  bool active;\n}\n\n/// @title Reward Throttle\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The contract in charge of smoothing out rewards and attempting to find a steady APR\ncontract RewardThrottle is\n  StabilizedPoolUnit,\n  BondingExtension,\n  RewardOverflowExtension\n{\n  using SafeERC20 for ERC20;\n\n  ITimekeeper public timekeeper;\n\n  // Admin updatable params\n  uint256 public smoothingPeriod = 24; // 24 epochs = 12 hours\n  uint256 public desiredRunway = 15778800; // 6 months\n  // uint256 public desiredRunway = 2629800; // 1 months\n  uint256 public aprCap = 5000; // 50%\n  uint256 public aprFloor = 200; // 2%\n  uint256 public aprUpdatePeriod = 2 hours;\n  uint256 public cushionBps = 10000; // 100%\n  uint256 public maxAdjustment = 50; // 0.5%\n  uint256 public proportionalGainBps = 1000; // 10% ie proportional gain factor of 0.1\n\n  // Not externall updatable\n  uint256 public targetAPR = 1000; // 10%\n  uint256 public aprLastUpdated;\n\n  uint256 public activeEpoch;\n  mapping(uint256 => State) public state;\n\n  event RewardOverflow(uint256 epoch, uint256 overflow);\n  event HandleReward(uint256 epoch, uint256 amount);\n  event UpdateDesiredAPR(uint256 apr);\n\n  constructor(\n    address timelock,\n    address repository,\n    address poolFactory,\n    address _timekeeper\n  ) StabilizedPoolUnit(timelock, repository, poolFactory) {\n    require(_timekeeper != address(0), \"Throttle: Timekeeper addr(0)\");\n\n    timekeeper = ITimekeeper(_timekeeper);\n    aprLastUpdated = block.timestamp;\n  }\n\n  function setupContracts(\n    address _collateralToken,\n    address _overflowPool,\n    address _bonding,\n    address pool\n  ) external onlyRoleMalt(POOL_FACTORY_ROLE, \"Only pool factory role\") {\n    require(!contractActive, \"RewardThrottle: Already setup\");\n    require(_collateralToken != address(0), \"RewardThrottle: Col addr(0)\");\n    require(_overflowPool != address(0), \"RewardThrottle: Overflow addr(0)\");\n    require(_bonding != address(0), \"RewardThrottle: Bonding addr(0)\");\n\n    contractActive = true;\n\n    collateralToken = ERC20(_collateralToken);\n    overflowPool = IOverflow(_overflowPool);\n    bonding = IBonding(_bonding);\n\n    (, address updater, ) = poolFactory.getPool(pool);\n    _setPoolUpdater(updater);\n  }\n\n  function handleReward() external onlyActive {\n    updateDesiredAPR();\n\n    uint256 balance = collateralToken.balanceOf(address(this));\n\n    uint256 epoch = timekeeper.epoch();\n\n    uint256 _activeEpoch = activeEpoch; // gas\n\n    state[_activeEpoch].profit += balance;\n\n    // Fetch targetAPR before we update current epoch state\n    uint256 aprTarget = targetAPR; // gas\n\n    // Distribute balance to the correct places\n    if (aprTarget > 0 && _epochAprGivenReward(epoch, balance) > aprTarget) {\n      uint256 remainder = _getRewardOverflow(balance, aprTarget, _activeEpoch);\n      emit RewardOverflow(_activeEpoch, remainder);\n\n      if (remainder > 0) {\n        collateralToken.safeTransfer(address(overflowPool), remainder);\n\n        if (balance > remainder) {\n          balance -= remainder;\n        } else {\n          balance = 0;\n        }\n      }\n    }\n\n    if (balance > 0) {\n      _sendToDistributor(balance, _activeEpoch);\n    }\n\n    emit HandleReward(epoch, balance);\n  }\n\n  function updateDesiredAPR() public onlyActive {\n    checkRewardUnderflow();\n\n    if (aprLastUpdated + aprUpdatePeriod > block.timestamp) {\n      // Too early to update\n      return;\n    }\n\n    uint256 cashflowAverageApr = averageCashflowAPR(smoothingPeriod);\n\n    uint256 newAPR = targetAPR; // gas\n    uint256 adjustmentCap = maxAdjustment; // gas\n    uint256 targetCashflowApr = (newAPR * (10000 + cushionBps)) / 10000;\n\n    if (cashflowAverageApr > targetCashflowApr) {\n      uint256 delta = cashflowAverageApr - targetCashflowApr;\n      uint256 adjustment = (delta * proportionalGainBps) / 10000;\n\n      if (adjustment > adjustmentCap) {\n        adjustment = adjustmentCap;\n      }\n\n      newAPR += adjustment;\n    } else if (cashflowAverageApr < targetCashflowApr) {\n      uint256 deficit = runwayDeficit();\n\n      if (deficit == 0) {\n        aprLastUpdated = block.timestamp;\n        return;\n      }\n\n      uint256 delta = targetCashflowApr - cashflowAverageApr;\n      uint256 adjustment = (delta * proportionalGainBps) / 10000;\n\n      if (adjustment > adjustmentCap) {\n        adjustment = adjustmentCap;\n      }\n\n      newAPR -= adjustment;\n    }\n\n    uint256 cap = aprCap; // gas\n    uint256 floor = aprFloor; // gas\n    if (newAPR > cap) {\n      newAPR = cap;\n    } else if (newAPR < floor) {\n      newAPR = floor;\n    }\n\n    targetAPR = newAPR;\n    aprLastUpdated = block.timestamp;\n    emit UpdateDesiredAPR(newAPR);\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function epochAPR(uint256 epoch) public view returns (uint256) {\n    // This returns an implied APR based on the distributed rewards and bonded LP at the given epoch\n    State memory epochState = state[epoch];\n\n    uint256 bondedValue = epochState.bondedValue;\n    if (bondedValue == 0) {\n      bondedValue = bonding.averageBondedValue(epoch);\n      if (bondedValue == 0) {\n        return 0;\n      }\n    }\n\n    uint256 epochsPerYear = epochState.epochsPerYear;\n\n    if (epochsPerYear == 0) {\n      epochsPerYear = timekeeper.epochsPerYear();\n    }\n\n    // 10000 = 100%\n    return (epochState.rewarded * 10000 * epochsPerYear) / bondedValue;\n  }\n\n  function averageCashflowAPR(uint256 averagePeriod)\n    public\n    view\n    returns (uint256 apr)\n  {\n    uint256 currentEpoch = activeEpoch; // gas\n    uint256 endEpoch = currentEpoch; // previous epoch\n    uint256 startEpoch;\n\n    if (endEpoch < averagePeriod) {\n      averagePeriod = currentEpoch;\n    } else {\n      startEpoch = endEpoch - averagePeriod;\n    }\n\n    if (startEpoch == endEpoch || averagePeriod == 0) {\n      return epochCashflowAPR(endEpoch);\n    }\n\n    State memory startEpochState = state[startEpoch];\n    State memory endEpochState = state[endEpoch];\n\n    if (\n      startEpochState.cumulativeCashflowApr >=\n      endEpochState.cumulativeCashflowApr\n    ) {\n      return 0;\n    }\n\n    uint256 delta = endEpochState.cumulativeCashflowApr -\n      startEpochState.cumulativeCashflowApr;\n\n    apr = delta / averagePeriod;\n  }\n\n  function averageCashflowAPR(uint256 startEpoch, uint256 endEpoch)\n    public\n    view\n    returns (uint256 apr)\n  {\n    require(startEpoch <= endEpoch, \"Start cannot be before the end\");\n\n    if (startEpoch == endEpoch) {\n      return epochCashflowAPR(endEpoch);\n    }\n\n    uint256 averagePeriod = endEpoch - startEpoch;\n\n    State memory startEpochState = state[startEpoch];\n    State memory endEpochState = state[endEpoch];\n\n    if (\n      startEpochState.cumulativeCashflowApr >=\n      endEpochState.cumulativeCashflowApr\n    ) {\n      return 0;\n    }\n\n    uint256 delta = endEpochState.cumulativeCashflowApr -\n      startEpochState.cumulativeCashflowApr;\n\n    apr = delta / averagePeriod;\n  }\n\n  function epochCashflow(uint256 epoch) public view returns (uint256 cashflow) {\n    State memory epochState = state[epoch];\n\n    cashflow = epochState.profit;\n\n    if (epochState.rewarded > cashflow) {\n      cashflow = epochState.rewarded;\n    }\n  }\n\n  function epochCashflowAPR(uint256 epoch)\n    public\n    view\n    returns (uint256 cashflowAPR)\n  {\n    State memory epochState = state[epoch];\n\n    uint256 cashflow = epochState.profit;\n\n    if (epochState.rewarded > cashflow) {\n      cashflow = epochState.rewarded;\n    }\n\n    uint256 bondedValue = epochState.bondedValue;\n    if (bondedValue == 0) {\n      bondedValue = bonding.averageBondedValue(epoch);\n      if (bondedValue == 0) {\n        return 0;\n      }\n    }\n\n    uint256 epochsPerYear = epochState.epochsPerYear;\n\n    if (epochsPerYear == 0) {\n      epochsPerYear = timekeeper.epochsPerYear();\n    }\n\n    // 10000 = 100%\n    return (cashflow * 10000 * epochsPerYear) / bondedValue;\n  }\n\n  function averageAPR(uint256 startEpoch, uint256 endEpoch)\n    public\n    view\n    returns (uint256 apr)\n  {\n    require(startEpoch <= endEpoch, \"Start cannot be before the end\");\n\n    if (startEpoch == endEpoch) {\n      return epochAPR(startEpoch);\n    }\n\n    uint256 averagePeriod = endEpoch - startEpoch;\n\n    State memory startEpochState = state[startEpoch];\n    State memory endEpochState = state[endEpoch];\n\n    if (startEpochState.cumulativeApr >= endEpochState.cumulativeApr) {\n      return 0;\n    }\n\n    uint256 delta = endEpochState.cumulativeApr - startEpochState.cumulativeApr;\n\n    apr = delta / averagePeriod;\n  }\n\n  function targetEpochProfit() public view returns (uint256) {\n    uint256 epoch = timekeeper.epoch();\n    (, uint256 epochProfitTarget) = getTargets(epoch);\n    return epochProfitTarget;\n  }\n\n  function getTargets(uint256 epoch)\n    public\n    view\n    returns (uint256 aprTarget, uint256 profitTarget)\n  {\n    State memory epochState = state[epoch];\n\n    aprTarget = epochState.desiredAPR;\n\n    if (aprTarget == 0) {\n      aprTarget = targetAPR;\n    }\n\n    uint256 bondedValue = epochState.bondedValue;\n    if (bondedValue == 0) {\n      bondedValue = bonding.averageBondedValue(epoch);\n    }\n\n    uint256 epochsPerYear = epochState.epochsPerYear;\n    if (epochsPerYear == 0) {\n      epochsPerYear = timekeeper.epochsPerYear();\n    }\n\n    profitTarget = (aprTarget * bondedValue) / epochsPerYear / 10000;\n\n    return (aprTarget, profitTarget);\n  }\n\n  function runwayDeficit() public view returns (uint256) {\n    uint256 overflowBalance = collateralToken.balanceOf(address(overflowPool));\n\n    uint256 epochTargetProfit = targetEpochProfit();\n    // 31557600 is seconds in a year\n    uint256 runwayEpochs = (timekeeper.epochsPerYear() * desiredRunway) /\n      31557600;\n    uint256 requiredProfit = epochTargetProfit * runwayEpochs;\n\n    if (overflowBalance < requiredProfit) {\n      return requiredProfit - overflowBalance;\n    }\n\n    return 0;\n  }\n\n  /// @notice Returns the number of epochs of APR we have in runway\n  function runway()\n    external\n    view\n    returns (uint256 runwayEpochs, uint256 runwayDays)\n  {\n    uint256 overflowBalance = collateralToken.balanceOf(address(overflowPool));\n    uint256 epochTargetProfit = targetEpochProfit();\n    // 86400 seconds in a day\n    uint256 epochsPerDay = 86400 / timekeeper.epochLength();\n\n    if (epochTargetProfit == 0 || epochsPerDay == 0) {\n      return (0, 0);\n    }\n\n    runwayEpochs = overflowBalance / epochTargetProfit;\n    runwayDays = runwayEpochs / epochsPerDay;\n  }\n\n  function epochState(uint256 epoch) public view returns (State memory) {\n    return state[epoch];\n  }\n\n  function epochData(uint256 epoch)\n    public\n    view\n    returns (\n      uint256 profit,\n      uint256 rewarded,\n      uint256 bondedValue,\n      uint256 desiredAPR,\n      uint256 epochsPerYear,\n      uint256 cumulativeCashflowApr,\n      uint256 cumulativeApr\n    )\n  {\n    return (\n      state[epoch].profit,\n      state[epoch].rewarded,\n      state[epoch].bondedValue,\n      state[epoch].desiredAPR,\n      state[epoch].epochsPerYear,\n      state[epoch].cumulativeCashflowApr,\n      state[epoch].cumulativeApr\n    );\n  }\n\n  function checkRewardUnderflow() public onlyActive {\n    uint256 epoch = timekeeper.epoch();\n\n    uint256 _activeEpoch = activeEpoch; // gas\n\n    // Fill in gaps so we have a fresh foundation to calculate from\n    _fillInEpochGaps(epoch);\n\n    if (epoch > _activeEpoch) {\n      for (uint256 i = _activeEpoch; i < epoch; ++i) {\n        uint256 underflow = _getRewardUnderflow(i);\n\n        if (underflow > 0) {\n          uint256 balance = overflowPool.requestCapital(underflow);\n\n          _sendToDistributor(balance, i);\n        }\n      }\n    }\n  }\n\n  function fillInEpochGaps() external {\n    uint256 epoch = timekeeper.epoch();\n\n    _fillInEpochGaps(epoch);\n  }\n\n  function fillInEpochGaps(uint256 epoch) external {\n    uint256 actualEpoch = timekeeper.epoch();\n    require(epoch <= actualEpoch && epoch > activeEpoch, \"Invalid epoch\");\n\n    _fillInEpochGaps(epoch);\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _epochAprGivenReward(uint256 epoch, uint256 reward)\n    internal\n    view\n    returns (uint256)\n  {\n    // This returns an implied APR based on the distributed rewards and bonded LP at the given epoch\n    State memory epochState = state[epoch];\n    uint256 bondedValue = epochState.bondedValue;\n\n    if (bondedValue == 0) {\n      bondedValue = bonding.averageBondedValue(epoch);\n      if (bondedValue == 0) {\n        return 0;\n      }\n    }\n\n    uint256 epochsPerYear = epochState.epochsPerYear;\n\n    if (epochsPerYear == 0) {\n      epochsPerYear = timekeeper.epochsPerYear();\n    }\n\n    // 10000 = 100%\n    return\n      ((epochState.rewarded + reward) * 10000 * epochsPerYear) / bondedValue;\n  }\n\n  function _getRewardOverflow(\n    uint256 declaredReward,\n    uint256 desiredAPR,\n    uint256 epoch\n  ) internal view returns (uint256 remainder) {\n    State memory epochState = state[epoch];\n\n    if (desiredAPR == 0) {\n      // If desired APR is zero then just allow all rewards through\n      return 0;\n    }\n\n    uint256 epochsPerYear = epochState.epochsPerYear;\n\n    if (epochsPerYear == 0) {\n      epochsPerYear = timekeeper.epochsPerYear();\n    }\n\n    uint256 bondedValue = epochState.bondedValue;\n\n    if (bondedValue == 0) {\n      bondedValue = bonding.averageBondedValue(epoch);\n    }\n\n    uint256 targetProfit = (desiredAPR * bondedValue) / epochsPerYear / 10000;\n\n    if (targetProfit <= epochState.rewarded) {\n      return declaredReward;\n    }\n\n    uint256 undeclaredReward = targetProfit - epochState.rewarded;\n\n    if (undeclaredReward >= declaredReward) {\n      // Declared reward doesn't make up for the difference yet\n      return 0;\n    }\n\n    remainder = declaredReward - undeclaredReward;\n  }\n\n  function _getRewardUnderflow(uint256 epoch)\n    internal\n    view\n    returns (uint256 amount)\n  {\n    State memory epochState = state[epoch];\n\n    uint256 epochsPerYear = epochState.epochsPerYear;\n\n    if (epochsPerYear == 0) {\n      epochsPerYear = timekeeper.epochsPerYear();\n    }\n\n    uint256 bondedValue = epochState.bondedValue;\n\n    if (bondedValue == 0) {\n      bondedValue = bonding.averageBondedValue(epoch);\n    }\n\n    uint256 targetProfit = (epochState.desiredAPR * bondedValue) /\n      epochsPerYear /\n      10000;\n\n    if (targetProfit <= epochState.rewarded) {\n      // Rewarded more than target already. 0 underflow\n      return 0;\n    }\n\n    return targetProfit - epochState.rewarded;\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _sendToDistributor(uint256 amount, uint256 epoch) internal {\n    if (amount == 0) {\n      return;\n    }\n\n    (\n      uint256[] memory poolIds,\n      uint256[] memory allocations,\n      address[] memory distributors\n    ) = bonding.poolAllocations();\n\n    uint256 length = poolIds.length;\n    uint256 balance = collateralToken.balanceOf(address(this));\n    uint256 rewarded;\n\n    for (uint256 i; i < length; ++i) {\n      uint256 share = (amount * allocations[i]) / 1e18;\n\n      if (share == 0) {\n        continue;\n      }\n\n      if (share > balance) {\n        share = balance;\n      }\n\n      collateralToken.safeTransfer(distributors[i], share);\n      IDistributor(distributors[i]).declareReward(share);\n      balance -= share;\n      rewarded += share;\n\n      if (balance == 0) {\n        break;\n      }\n    }\n\n    state[epoch].rewarded = state[epoch].rewarded + rewarded;\n    state[epoch + 1].cumulativeCashflowApr =\n      state[epoch].cumulativeCashflowApr +\n      epochCashflowAPR(epoch);\n    state[epoch + 1].cumulativeApr =\n      state[epoch].cumulativeApr +\n      epochAPR(epoch);\n    state[epoch].bondedValue = bonding.averageBondedValue(epoch);\n  }\n\n  function _fillInEpochGaps(uint256 epoch) internal {\n    uint256 epochsPerYear = timekeeper.epochsPerYear();\n    uint256 _activeEpoch = activeEpoch; // gas\n\n    state[_activeEpoch].bondedValue = bonding.averageBondedValue(_activeEpoch);\n    state[_activeEpoch].epochsPerYear = epochsPerYear;\n    state[_activeEpoch].desiredAPR = targetAPR;\n\n    if (_activeEpoch > 0) {\n      state[_activeEpoch].cumulativeCashflowApr =\n        state[_activeEpoch - 1].cumulativeCashflowApr +\n        epochCashflowAPR(_activeEpoch - 1);\n      state[_activeEpoch].cumulativeApr =\n        state[_activeEpoch - 1].cumulativeApr +\n        epochAPR(_activeEpoch - 1);\n    }\n\n    // Avoid issues if gap between rewards is greater than one epoch\n    for (uint256 i = _activeEpoch + 1; i <= epoch; ++i) {\n      if (!state[i].active) {\n        state[i].bondedValue = bonding.averageBondedValue(i);\n        state[i].profit = 0;\n        state[i].rewarded = 0;\n        state[i].epochsPerYear = epochsPerYear;\n        state[i].desiredAPR = targetAPR;\n        state[i].cumulativeCashflowApr =\n          state[i - 1].cumulativeCashflowApr +\n          epochCashflowAPR(i - 1);\n        state[i].cumulativeApr = state[i - 1].cumulativeApr + epochAPR(i - 1);\n        state[i].active = true;\n      }\n    }\n\n    activeEpoch = epoch;\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function populateFromPreviousThrottle(address previousThrottle, uint256 epoch)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Only admin role\")\n  {\n    RewardThrottle previous = RewardThrottle(previousThrottle);\n    uint256 _activeEpoch = activeEpoch; // gas\n\n    for (uint256 i = _activeEpoch; i < epoch; ++i) {\n      (\n        uint256 profit,\n        uint256 rewarded,\n        uint256 bondedValue,\n        uint256 desiredAPR,\n        uint256 epochsPerYear,\n        uint256 cumulativeCashflowApr,\n        uint256 cumulativeApr\n      ) = previous.epochData(i);\n\n      state[i].bondedValue = bondedValue;\n      state[i].profit = profit;\n      state[i].rewarded = rewarded;\n      state[i].epochsPerYear = epochsPerYear;\n      state[i].desiredAPR = desiredAPR;\n      state[i].cumulativeCashflowApr = cumulativeCashflowApr;\n      state[i].cumulativeApr = cumulativeApr;\n    }\n\n    activeEpoch = epoch;\n  }\n\n  function setTimekeeper(address _timekeeper)\n    external\n    onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater privs\")\n  {\n    require(_timekeeper != address(0), \"Not address 0\");\n    timekeeper = ITimekeeper(_timekeeper);\n  }\n\n  function setSmoothingPeriod(uint256 _smoothingPeriod)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_smoothingPeriod > 0, \"No zero smoothing period\");\n    smoothingPeriod = _smoothingPeriod;\n  }\n\n  function setDesiredRunway(uint256 _runway)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_runway > 604800, \"Runway must be > 1 week\");\n    desiredRunway = _runway;\n  }\n\n  function setAprCap(uint256 _aprCap)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_aprCap != 0, \"Cap cannot be 0\");\n    aprCap = _aprCap;\n  }\n\n  function setAprFloor(uint256 _aprFloor)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_aprFloor != 0, \"Floor cannot be 0\");\n    aprFloor = _aprFloor;\n  }\n\n  function setUpdatePeriod(uint256 _period)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_period >= timekeeper.epochLength(), \"< 1 epoch\");\n    aprUpdatePeriod = _period;\n  }\n\n  function setCushionBps(uint256 _cushionBps)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_cushionBps != 0, \"Cannot be 0\");\n    cushionBps = _cushionBps;\n  }\n\n  function setMaxAdjustment(uint256 _max)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_max != 0, \"Cannot be 0\");\n    maxAdjustment = _max;\n  }\n\n  function setProportionalGain(uint256 _gain)\n    external\n    onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_gain != 0 && _gain < 10000, \"Between 1-9999 inc\");\n    proportionalGainBps = _gain;\n  }\n\n  function _accessControl()\n    internal\n    override(BondingExtension, RewardOverflowExtension)\n  {\n    _onlyRoleMalt(POOL_UPDATER_ROLE, \"Must have pool updater role\");\n  }\n}"
    }
  ]
}