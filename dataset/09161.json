{
  "Title": "[G-08] `internal` functions only called once can be inlined to save gas",
  "Content": "\nNot inlining costs 20 to 40 gas because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: contracts/AuraClaimZap.sol   #1\n\n171       function _claimExtras( // solhint-disable-line \n172           uint256 depositCrvMaxAmount,\n173           uint256 minAmountOut,\n174           uint256 depositCvxMaxAmount,\n175           uint256 removeCrvBalance,\n176           uint256 removeCvxBalance,\n177:          uint256 options\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraClaimZap.sol#L171-L177>\n\n```solidity\nFile: convex-platform/contracts/contracts/VoterProxy.sol   #2\n\n230:      function _withdrawSome(address _gauge, uint256 _amount) internal returns (uint256) {\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/VoterProxy.sol#L230>\n\n```solidity\nFile: convex-platform/contracts/contracts/ExtraRewardStashV3.sol   #3\n\n124       function checkForNewRewardTokens() internal {\n125:          for(uint256 i = 0; i < maxRewards; i++){\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ExtraRewardStashV3.sol#L124-L125>\n\n```solidity\nFile: convex-platform/contracts/contracts/Booster.sol   #4\n\n572:      function _earmarkRewards(uint256 _pid) internal {\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/Booster.sol#L572>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "contracts/AuraClaimZap.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { AuraMath } from \"./AuraMath.sol\";\nimport \"./Interfaces.sol\";\nimport \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IBasicRewards {\n    function getReward(address _account, bool _claimExtras) external;\n\n    function getReward(address _account) external;\n\n    function getReward(address _account, address _token) external;\n\n    function stakeFor(address, uint256) external;\n}\n\ninterface ICrvDepositorWrapper {\n    function deposit(\n        uint256,\n        uint256,\n        bool,\n        address\n    ) external;\n}\n\n/**\n * @title   ClaimZap\n * @author  ConvexFinance -> AuraFinance\n * @notice  Claim zap to bundle various reward claims\n * @dev     Claims from all pools, and stakes cvxCrv and CVX if wanted.\n *          v2:\n *           - change exchange to use curve pool\n *           - add getReward(address,token) type\n *           - add option to lock cvx\n *           - add option use all funds in wallet\n */\ncontract AuraClaimZap {\n    using SafeERC20 for IERC20;\n    using AuraMath for uint256;\n\n    address public immutable crv;\n    address public immutable cvx;\n    address public immutable cvxCrv;\n    address public immutable crvDepositWrapper;\n    address public immutable cvxCrvRewards;\n    address public immutable locker;\n    address public immutable owner;\n\n    enum Options {\n        ClaimCvxCrv, //1\n        ClaimLockedCvx, //2\n        ClaimLockedCvxStake, //4\n        LockCrvDeposit, //8\n        UseAllWalletFunds, //16\n        LockCvx //32\n    }\n\n    /**\n     * @param _crv                CRV token (0xD533a949740bb3306d119CC777fa900bA034cd52);\n     * @param _cvx                CVX token (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n     * @param _cvxCrv             cvxCRV token (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n     * @param _crvDepositWrapper  crvDepositWrapper (0x8014595F2AB54cD7c604B00E9fb932176fDc86Ae);\n     * @param _cvxCrvRewards      cvxCrvRewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);\n     * @param _locker             vlCVX (0xD18140b4B819b895A3dba5442F959fA44994AF50);\n     */\n    constructor(\n        address _crv,\n        address _cvx,\n        address _cvxCrv,\n        address _crvDepositWrapper,\n        address _cvxCrvRewards,\n        address _locker\n    ) {\n        crv = _crv;\n        cvx = _cvx;\n        cvxCrv = _cvxCrv;\n        crvDepositWrapper = _crvDepositWrapper;\n        cvxCrvRewards = _cvxCrvRewards;\n        locker = _locker;\n        owner = msg.sender;\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"ClaimZap V2.0\";\n    }\n\n    /**\n     * @notice Approve spending of:\n     *          crv     -> crvDepositor\n     *          cvxCrv  -> cvxCrvRewards\n     *          cvx     -> Locker\n     */\n    function setApprovals() external {\n        require(msg.sender == owner, \"!auth\");\n\n        IERC20(crv).safeApprove(crvDepositWrapper, 0);\n        IERC20(crv).safeApprove(crvDepositWrapper, type(uint256).max);\n\n        IERC20(cvxCrv).safeApprove(cvxCrvRewards, 0);\n        IERC20(cvxCrv).safeApprove(cvxCrvRewards, type(uint256).max);\n\n        IERC20(cvx).safeApprove(locker, 0);\n        IERC20(cvx).safeApprove(locker, type(uint256).max);\n    }\n\n    /**\n     * @notice Use bitmask to check if option flag is set\n     */\n    function _checkOption(uint256 _mask, uint256 _flag) internal pure returns (bool) {\n        return (_mask & (1 << _flag)) != 0;\n    }\n\n    /**\n     * @notice Claim all the rewards\n     * @param rewardContracts       Array of addresses for LP token rewards\n     * @param extraRewardContracts  Array of addresses for extra rewards\n     * @param tokenRewardContracts  Array of addresses for token rewards e.g vlCvxExtraRewardDistribution\n     * @param tokenRewardTokens     Array of token reward addresses to use with tokenRewardContracts\n     * @param depositCrvMaxAmount   The max amount of CRV to deposit if converting to crvCvx\n     * @param minAmountOut          The min amount out for crv:cvxCrv swaps if swapping. Set this to zero if you\n     *                              want to use CrvDepositor instead of balancer swap\n     * @param depositCvxMaxAmount   The max amount of CVX to deposit if locking CVX\n     * @param options               Claim options\n     */\n    function claimRewards(\n        address[] calldata rewardContracts,\n        address[] calldata extraRewardContracts,\n        address[] calldata tokenRewardContracts,\n        address[] calldata tokenRewardTokens,\n        uint256 depositCrvMaxAmount,\n        uint256 minAmountOut,\n        uint256 depositCvxMaxAmount,\n        uint256 options\n    ) external {\n        require(tokenRewardContracts.length == tokenRewardTokens.length, \"!parity\");\n\n        uint256 crvBalance = IERC20(crv).balanceOf(msg.sender);\n        uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender);\n\n        //claim from main curve LP pools\n        for (uint256 i = 0; i < rewardContracts.length; i++) {\n            IBasicRewards(rewardContracts[i]).getReward(msg.sender, true);\n        }\n        //claim from extra rewards\n        for (uint256 i = 0; i < extraRewardContracts.length; i++) {\n            IBasicRewards(extraRewardContracts[i]).getReward(msg.sender);\n        }\n        //claim from multi reward token contract\n        for (uint256 i = 0; i < tokenRewardContracts.length; i++) {\n            IBasicRewards(tokenRewardContracts[i]).getReward(msg.sender, tokenRewardTokens[i]);\n        }\n\n        // claim others/deposit/lock/stake\n        _claimExtras(depositCrvMaxAmount, minAmountOut, depositCvxMaxAmount, crvBalance, cvxBalance, options);\n    }\n\n    /**\n     * @notice  Claim additional rewards from:\n     *          - cvxCrvRewards\n     *          - cvxLocker\n     * @param depositCrvMaxAmount see claimRewards\n     * @param minAmountOut        see claimRewards\n     * @param depositCvxMaxAmount see claimRewards\n     * @param removeCrvBalance    crvBalance to ignore and not redeposit (starting Crv balance)\n     * @param removeCvxBalance    cvxBalance to ignore and not redeposit (starting Cvx balance)\n     * @param options             see claimRewards\n     */\n    // prettier-ignore\n    function _claimExtras( // solhint-disable-line \n        uint256 depositCrvMaxAmount,\n        uint256 minAmountOut,\n        uint256 depositCvxMaxAmount,\n        uint256 removeCrvBalance,\n        uint256 removeCvxBalance,\n        uint256 options\n    ) internal {\n        //claim from cvxCrv rewards\n        if (_checkOption(options, uint256(Options.ClaimCvxCrv))) {\n            IBasicRewards(cvxCrvRewards).getReward(msg.sender, true);\n        }\n\n        //claim from locker\n        if (_checkOption(options, uint256(Options.ClaimLockedCvx))) {\n            IAuraLocker(locker).getReward(msg.sender, _checkOption(options, uint256(Options.ClaimLockedCvxStake)));\n        }\n\n        //reset remove balances if we want to also stake/lock funds already in our wallet\n        if (_checkOption(options, uint256(Options.UseAllWalletFunds))) {\n            removeCrvBalance = 0;\n            removeCvxBalance = 0;\n        }\n\n        //lock upto given amount of crv and stake\n        if (depositCrvMaxAmount > 0) {\n            uint256 crvBalance = IERC20(crv).balanceOf(msg.sender).sub(removeCrvBalance);\n            crvBalance = AuraMath.min(crvBalance, depositCrvMaxAmount);\n\n            if (crvBalance > 0) {\n                //pull crv\n                IERC20(crv).safeTransferFrom(msg.sender, address(this), crvBalance);\n                //deposit\n                ICrvDepositorWrapper(crvDepositWrapper).deposit(\n                    crvBalance,\n                    minAmountOut,\n                    _checkOption(options, uint256(Options.LockCrvDeposit)),\n                    address(0)\n                );\n\n                uint256 cvxCrvBalance = IERC20(cvxCrv).balanceOf(address(this));\n                //stake for msg.sender\n                IBasicRewards(cvxCrvRewards).stakeFor(msg.sender, cvxCrvBalance);\n            }\n        }\n\n        //stake up to given amount of cvx\n        if (depositCvxMaxAmount > 0) {\n            uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);\n            cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);\n            if (cvxBalance > 0) {\n                //pull cvx\n                IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);\n                if (_checkOption(options, uint256(Options.LockCvx))) {\n                    IAuraLocker(locker).lock(msg.sender, cvxBalance);\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "convex-platform/contracts/contracts/VoterProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n/**\n * @title   VoterProxy\n * @author  ConvexFinance\n * @notice  VoterProxy whitelisted in the curve SmartWalletWhitelist that\n *          participates in Curve governance. Also handles all deposits since this is \n *          the address that has the voting power.\n */\ncontract VoterProxy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public mintr;\n    address public immutable crv;\n    address public immutable crvBpt;\n\n    address public immutable escrow;\n    address public gaugeController;\n    address public rewardDeposit;\n    address public withdrawer;\n\n    address public owner;\n    address public operator;\n    address public depositor;\n    \n    mapping (address => bool) private stashPool;\n    mapping (address => bool) private protectedTokens;\n    mapping (bytes32 => bool) private votes;\n\n    bytes4 constant internal EIP1271_MAGIC_VALUE = 0x1626ba7e;\n\n    event VoteSet(bytes32 hash, bool valid);\n\n    /**\n     * @param _mintr            CRV minter\n     * @param _crv              CRV Token address\n     * @param _crvBpt           CRV:ETH 80-20 BPT Token address\n     * @param _escrow           Curve Voting escrow contract\n     * @param _gaugeController  Curve Gauge Controller\n     *                          Controls liquidity gauges and the issuance of coins through the gauges\n     */\n    constructor(\n        address _mintr,\n        address _crv,\n        address _crvBpt,\n        address _escrow,\n        address _gaugeController\n    ) public {\n        mintr = _mintr; \n        crv = _crv;\n        crvBpt = _crvBpt;\n        escrow = _escrow;\n        gaugeController = _gaugeController;\n        owner = msg.sender;\n\n        protectedTokens[_crv] = true;\n        protectedTokens[_crvBpt] = true;\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"BalancerVoterProxy\";\n    }\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n    }\n\n    /**\n     * @notice Allows dao to set the reward withdrawal address\n     * @param _withdrawer Whitelisted withdrawer\n     * @param _rewardDeposit Distributor address\n     */\n    function setRewardDeposit(address _withdrawer, address _rewardDeposit) external {\n        require(msg.sender == owner, \"!auth\");\n        withdrawer = _withdrawer;\n        rewardDeposit = _rewardDeposit;\n    }\n\n    /**\n     * @notice Allows dao to set the external system config, should it change in the future\n     * @param _gaugeController External gauge controller address\n     * @param _mintr Token minter address for claiming rewards\n     */\n    function setSystemConfig(address _gaugeController, address _mintr) external returns (bool) {\n        require(msg.sender == owner, \"!auth\");\n        gaugeController = _gaugeController;\n        mintr = _mintr;\n        return true;\n    }\n\n    /**\n     * @notice Set the operator of the VoterProxy\n     * @param _operator Address of the operator (Booster)\n     */\n    function setOperator(address _operator) external {\n        require(msg.sender == owner, \"!auth\");\n        require(operator == address(0) || IDeposit(operator).isShutdown() == true, \"needs shutdown\");\n        \n        operator = _operator;\n    }\n\n    /**\n     * @notice Set the depositor of the VoterProxy\n     * @param _depositor Address of the depositor (CrvDepositor)\n     */\n    function setDepositor(address _depositor) external {\n        require(msg.sender == owner, \"!auth\");\n\n        depositor = _depositor;\n    }\n\n    function setStashAccess(address _stash, bool _status) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        if(_stash != address(0)){\n            stashPool[_stash] = _status;\n        }\n        return true;\n    }\n\n    /**\n     * @notice Save a vote hash so when snapshot.org asks this contract if \n     *          a vote signature is valid we are able to check for a valid hash\n     *          and return the appropriate response inline with EIP 1721\n     * @param _hash  Hash of vote signature that was sent to snapshot.org\n     * @param _valid Is the hash valid\n     */\n    function setVote(bytes32 _hash, bool _valid) external {\n        require(msg.sender == operator, \"!auth\");\n        votes[_hash] = _valid;\n        emit VoteSet(_hash, _valid);\n    }\n\n    /**\n     * @notice  Verifies that the hash is valid\n     * @dev     Snapshot Hub will call this function when a vote is submitted using\n     *          snapshot.js on behalf of this contract. Snapshot Hub will call this\n     *          function with the hash and the signature of the vote that was cast.\n     * @param _hash Hash of the message that was sent to Snapshot Hub to cast a vote\n     * @return EIP1271 magic value if the signature is value \n     */\n    function isValidSignature(bytes32 _hash, bytes memory) public view returns (bytes4) {\n        if(votes[_hash]) {\n            return EIP1271_MAGIC_VALUE;\n        } else {\n            return 0xffffffff;\n        }  \n    }\n\n    /**\n     * @notice  Deposit tokens into the Curve Gauge\n     * @dev     Only can be called by the operator (Booster) once this contract has been\n     *          whitelisted by the Curve DAO\n     * @param _token  Deposit LP token address\n     * @param _gauge  Gauge contract to deposit to \n     */ \n    function deposit(address _token, address _gauge) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        if(protectedTokens[_token] == false){\n            protectedTokens[_token] = true;\n        }\n        if(protectedTokens[_gauge] == false){\n            protectedTokens[_gauge] = true;\n        }\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        if (balance > 0) {\n            IERC20(_token).safeApprove(_gauge, 0);\n            IERC20(_token).safeApprove(_gauge, balance);\n            ICurveGauge(_gauge).deposit(balance);\n        }\n        return true;\n    }\n\n    /**\n     * @notice  Withdraw ERC20 tokens that have been distributed as extra rewards\n     * @dev     Tokens shouldn't end up here if they can help it. However, dao can\n     *          set a withdrawer that can process these to some ExtraRewardDistribution.\n     */\n    function withdraw(IERC20 _asset) external returns (uint256 balance) {\n        require(msg.sender == withdrawer, \"!auth\");\n        require(protectedTokens[address(_asset)] == false, \"protected\");\n\n        balance = _asset.balanceOf(address(this));\n        _asset.safeApprove(rewardDeposit, 0);\n        _asset.safeApprove(rewardDeposit, balance);\n        IRewardDeposit(rewardDeposit).addReward(address(_asset), balance);\n        return balance;\n    }\n\n    /**\n     * @notice  Withdraw LP tokens from a gauge \n     * @dev     Only callable by the operator \n     * @param _token    LP token address\n     * @param _gauge    Gauge for this LP token\n     * @param _amount   Amount of LP token to withdraw\n     */\n    function withdraw(address _token, address _gauge, uint256 _amount) public returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_gauge, _amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice  Withdraw all LP tokens from a gauge \n     * @dev     Only callable by the operator \n     * @param _token  LP token address\n     * @param _gauge  Gauge for this LP token\n     */\n    function withdrawAll(address _token, address _gauge) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        uint256 amount = balanceOfPool(_gauge).add(IERC20(_token).balanceOf(address(this)));\n        withdraw(_token, _gauge, amount);\n        return true;\n    }\n\n    function _withdrawSome(address _gauge, uint256 _amount) internal returns (uint256) {\n        ICurveGauge(_gauge).withdraw(_amount);\n        return _amount;\n    }\n    \n    \n    /**\n     * @notice  Lock CRV in curves voting escrow contract\n     * @dev     Called by the CrvDepositor contract\n     * @param _value      Amount of crv to lock\n     * @param _unlockTime Timestamp to unlock (max is 4 years)\n     */\n    function createLock(uint256 _value, uint256 _unlockTime) external returns(bool){\n        require(msg.sender == depositor, \"!auth\");\n        IERC20(crvBpt).safeApprove(escrow, 0);\n        IERC20(crvBpt).safeApprove(escrow, _value);\n        ICurveVoteEscrow(escrow).create_lock(_value, _unlockTime);\n        return true;\n    }\n  \n    /**\n     * @notice Called by the CrvDepositor to increase amount of locked curve\n     */\n    function increaseAmount(uint256 _value) external returns(bool){\n        require(msg.sender == depositor, \"!auth\");\n        IERC20(crvBpt).safeApprove(escrow, 0);\n        IERC20(crvBpt).safeApprove(escrow, _value);\n        ICurveVoteEscrow(escrow).increase_amount(_value);\n        return true;\n    }\n\n    /**\n     * @notice Called by the CrvDepositor to increase unlocked time of curve\n     * @param _value Timestamp to increase locking to\n     */\n    function increaseTime(uint256 _value) external returns(bool){\n        require(msg.sender == depositor, \"!auth\");\n        ICurveVoteEscrow(escrow).increase_unlock_time(_value);\n        return true;\n    }\n\n    /**\n     * @notice  Withdraw all CRV from Curve's voting escrow contract\n     * @dev     Only callable by CrvDepositor and can only withdraw if lock has expired\n     */\n    function release() external returns(bool){\n        require(msg.sender == depositor, \"!auth\");\n        ICurveVoteEscrow(escrow).withdraw();\n        return true;\n    }\n\n    /**\n     * @notice Vote on CRV DAO for proposal\n     */\n    function vote(uint256 _voteId, address _votingAddress, bool _support) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        IVoting(_votingAddress).vote(_voteId,_support,false);\n        return true;\n    }\n\n    /**\n     * @notice Vote for a single gauge weight via the controller\n     */\n    function voteGaugeWeight(address _gauge, uint256 _weight) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n\n        //vote\n        IVoting(gaugeController).vote_for_gauge_weights(_gauge, _weight);\n        return true;\n    }\n\n    /**\n     * @notice  Claim CRV from Curve\n     * @dev     Claim CRV for LP token staking from the CRV minter contract\n     */\n    function claimCrv(address _gauge) external returns (uint256){\n        require(msg.sender == operator, \"!auth\");\n        \n        uint256 _balance = 0;\n        try IMinter(mintr).mint(_gauge){\n            _balance = IERC20(crv).balanceOf(address(this));\n            IERC20(crv).safeTransfer(operator, _balance);\n        }catch{}\n\n        return _balance;\n    }\n\n    /**\n     * @notice  Claim extra rewards from gauge\n     * @dev     Called by operator (Booster) to claim extra rewards \n     */\n    function claimRewards(address _gauge) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        ICurveGauge(_gauge).claim_rewards();\n        return true;\n    }\n\n    /**\n     * @notice  Claim fees (3crv) from staking lp tokens\n     * @dev     Only callable by the operator Booster\n     * @param _distroContract   Fee distribution contract\n     * @param _token            LP token to claim fees for\n     */\n    function claimFees(address _distroContract, address _token) external returns (uint256){\n        require(msg.sender == operator, \"!auth\");\n        IFeeDistributor(_distroContract).claimToken(address(this), _token);\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(operator, _balance);\n        return _balance;\n    }    \n\n    function balanceOfPool(address _gauge) public view returns (uint256) {\n        return ICurveGauge(_gauge).balanceOf(address(this));\n    }\n\n    function execute(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bool, bytes memory) {\n        require(msg.sender == operator,\"!auth\");\n\n        (bool success, bytes memory result) = _to.call{value:_value}(_data);\n        require(success, \"!success\");\n\n        return (success, result);\n    }\n\n}"
    },
    {
      "filename": "convex-platform/contracts/contracts/ExtraRewardStashV3.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"./interfaces/IRewardHook.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n\n/**\n * @title   ExtraRewardStashV3\n * @author  ConvexFinance\n * @notice  ExtraRewardStash for pools added to the Booster to handle extra rewards\n *          that aren't CRV that can be claimed from a gauge.\n *          - v3.0: Support for curve gauge reward redirect\n *            The Booster contract has a function called setGaugeRedirect. This function calls set_rewards_receiver\n *            On the Curve Guage. This tells the Gauge where to send rewards. The Booster crafts the calldata for this\n *            transaction and then calls execute on the VoterProxy which executes this transaction on the Curve Gauge\n *          - v3.1: Support for arbitrary token rewards outside of gauge rewards add \n *            reward hook to pull rewards during claims\n *          - v3.2: Move constuctor to init function for proxy creation\n */\ncontract ExtraRewardStashV3 {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public immutable crv;\n    uint256 private constant maxRewards = 8;\n\n    uint256 public pid;\n    address public operator;\n    address public staker;\n    address public gauge;\n    address public rewardFactory;\n   \n    mapping(address => uint256) public historicalRewards;\n    bool public hasRedirected;\n    bool public hasCurveRewards;\n\n    struct TokenInfo {\n        address token;\n        address rewardAddress;\n    }\n\n    //use mapping+array so that we dont have to loop check each time setToken is called\n    mapping(address => TokenInfo) public tokenInfo;\n    address[] public tokenList;\n\n    //address to call for reward pulls\n    address public rewardHook;\n  \n    /**\n     * @param _crv CRV token address\n     */\n    constructor(address _crv) public {\n      crv = _crv;\n    }\n\n    /**\n     * @param _pid        Pool ID\n     * @param _operator   Operator (Booster)\n     * @param _staker     Staker (VoterProxy)\n     * @param _gauge      Gauge\n     * @param _rFactory   Reward factory\n     */\n    function initialize(uint256 _pid, address _operator, address _staker, address _gauge, address _rFactory) external {\n        require(gauge == address(0),\"!init\");\n        pid = _pid;\n        operator = _operator;\n        staker = _staker;\n        gauge = _gauge;\n        rewardFactory = _rFactory;\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"ExtraRewardStashV3.2\";\n    }\n\n    function tokenCount() external view returns (uint256){\n        return tokenList.length;\n    }\n\n    /**\n     * @notice  Claim rewards from the gauge\n     * @dev     The Stash's claimRewards function calls claimRewards on the Booster contract\n     *          which calls claimRewards on the VoterProxy which calls claim_rewards on the gauge\n     *          If a RewardHook is set onRewardClaim is also called on that\n     *          Called by Booster earmarkRewards\n     *          Guage rewards are sent directly to this stash even though the Curve method claim_rewards\n     *          is being called by the VoterProxy. This is because Curves guages have the ability to redirect\n     *          rewards to somewhere other than msg.sender. This is setup in Booster setGaugeRedirect\n     */\n    function claimRewards() external returns (bool) {\n        require(msg.sender == operator, \"!operator\");\n\n        //this is updateable from v2 gauges now so must check each time.\n        checkForNewRewardTokens();\n\n        //make sure we're redirected\n        if(!hasRedirected){\n            IDeposit(operator).setGaugeRedirect(pid);\n            hasRedirected = true;\n        }\n\n        if(hasCurveRewards){\n            //claim rewards on gauge for staker\n            //using reward_receiver so all rewards will be moved to this stash\n            IDeposit(operator).claimRewards(pid,gauge);\n        }\n\n        //hook for reward pulls\n        if(rewardHook != address(0)){\n            try IRewardHook(rewardHook).onRewardClaim(){\n            }catch{}\n        }\n        return true;\n    }\n   \n\n    //check if gauge rewards have changed\n    function checkForNewRewardTokens() internal {\n        for(uint256 i = 0; i < maxRewards; i++){\n            address token = ICurveGauge(gauge).reward_tokens(i);\n            if (token == address(0)) {\n                break;\n            }\n            if(!hasCurveRewards){\n                hasCurveRewards = true;\n            }\n            setToken(token);\n        }\n    }\n\n    //register an extra reward token to be handled\n    // (any new incentive that is not directly on curve gauges)\n    function setExtraReward(address _token) external{\n        //owner of booster can set extra rewards\n        require(IDeposit(operator).owner() == msg.sender, \"!owner\");\n        setToken(_token);\n    }\n\n    function setRewardHook(address _hook) external{\n        //owner of booster can set reward hook\n        require(IDeposit(operator).owner() == msg.sender, \"!owner\");\n        rewardHook = _hook;\n    }\n\n\n    /**\n     * @notice  Add a reward token to the token list so it can be claimed\n     * @dev     For each token that is added as a claimable reward a VirtualRewardsPool\n     *          is deployed to handle virtual distribution of tokens \n     */\n    function setToken(address _token) internal {\n        TokenInfo storage t = tokenInfo[_token];\n\n        if(t.token == address(0)){\n            //set token address\n            t.token = _token;\n\n            //check if crv\n            if(_token != crv){\n                //create new reward contract (for NON-crv tokens only)\n                (,,,address mainRewardContract,,) = IDeposit(operator).poolInfo(pid);\n                address rewardContract = IRewardFactory(rewardFactory).CreateTokenRewards(\n                    _token,\n                    mainRewardContract,\n                    address(this));\n                \n                t.rewardAddress = rewardContract;\n            }\n            //add token to list of known rewards\n            tokenList.push(_token);\n        }\n    }\n\n    //pull assigned tokens from staker to stash\n    function stashRewards() external pure returns(bool){\n\n        //after depositing/withdrawing, extra incentive tokens are claimed\n        //but from v3 this is default to off, and this stash is the reward receiver too.\n\n        return true;\n    }\n\n    /**\n     * @notice  Distribute rewards\n     * @dev     Send all CRV to the Booster contract and send all extra token\n     *          rewards to the rewardContract VirtualRewardsPool\n     *          Called by Booster earmarkRewards\n     */\n    function processStash() external returns(bool){\n        require(msg.sender == operator, \"!operator\");\n\n        uint256 tCount = tokenList.length;\n        for(uint i=0; i < tCount; i++){\n            TokenInfo storage t = tokenInfo[tokenList[i]];\n            address token = t.token;\n            if(token == address(0)) continue;\n            \n            uint256 amount = IERC20(token).balanceOf(address(this));\n            if (amount > 0) {\n                historicalRewards[token] = historicalRewards[token].add(amount);\n                if(token == crv){\n                    //if crv, send back to booster to distribute\n                    IERC20(token).safeTransfer(operator, amount);\n                    continue;\n                }\n            \t//add to reward contract\n            \taddress rewards = t.rewardAddress;\n            \tif(rewards == address(0)) continue;\n            \tIERC20(token).safeTransfer(rewards, amount);\n            \tIRewards(rewards).queueNewRewards(amount);\n            }\n        }\n        return true;\n    }\n\n}"
    },
    {
      "filename": "convex-platform/contracts/contracts/Booster.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n/**\n * @title   Booster\n * @author  ConvexFinance\n * @notice  Main deposit contract; keeps track of pool info & user deposits; distributes rewards.\n * @dev     They say all paths lead to Rome, and the cvxBooster is no different. This is where it all goes down.\n *          It is responsible for tracking all the pools, it collects rewards from all pools and redirects it.\n */\ncontract Booster{\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public immutable crv;\n    address public immutable voteOwnership;\n    address public immutable voteParameter;\n\n    uint256 public lockIncentive = 825; //incentive to crv stakers\n    uint256 public stakerIncentive = 825; //incentive to native token stakers\n    uint256 public earmarkIncentive = 50; //incentive to users who spend gas to make calls\n    uint256 public platformFee = 0; //possible fee to build treasury\n    uint256 public constant MaxFees = 2500;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public owner;\n    address public feeManager;\n    address public poolManager;\n    address public immutable staker;\n    address public immutable minter;\n    address public rewardFactory;\n    address public stashFactory;\n    address public tokenFactory;\n    address public rewardArbitrator;\n    address public voteDelegate;\n    address public treasury;\n    address public stakerRewards; //cvx rewards\n    address public lockRewards; //cvxCrv rewards(crv)\n\n    mapping(address => FeeDistro) public feeTokens;\n    struct FeeDistro {\n        address distro;\n        address rewards;\n        bool active;\n    }\n\n    bool public isShutdown;\n\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address gauge;\n        address crvRewards;\n        address stash;\n        bool shutdown;\n    }\n\n    //index(pid) -> pool\n    PoolInfo[] public poolInfo;\n    mapping(address => bool) public gaugeMap;\n\n    event Deposited(address indexed user, uint256 indexed poolid, uint256 amount);\n    event Withdrawn(address indexed user, uint256 indexed poolid, uint256 amount);\n\n    event PoolAdded(address lpToken, address gauge, address token, address rewardPool, address stash, uint256 pid);\n    event PoolShutdown(uint256 poolId);\n\n    event OwnerUpdated(address newOwner);\n    event FeeManagerUpdated(address newFeeManager);\n    event PoolManagerUpdated(address newPoolManager);\n    event FactoriesUpdated(address rewardFactory, address stashFactory, address tokenFactory);\n    event ArbitratorUpdated(address newArbitrator);\n    event VoteDelegateUpdated(address newVoteDelegate);\n    event RewardContractsUpdated(address lockRewards, address stakerRewards);\n    event FeesUpdated(uint256 lockIncentive, uint256 stakerIncentive, uint256 earmarkIncentive, uint256 platformFee);\n    event TreasuryUpdated(address newTreasury);\n    event FeeInfoUpdated(address feeDistro, address lockFees, address feeToken);\n    event FeeInfoChanged(address feeDistro, bool active);\n\n    /**\n     * @dev Constructor doing what constructors do. It is noteworthy that\n     *      a lot of ba"
    }
  ]
}