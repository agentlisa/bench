{
  "Title": "[M-10] Infinite approval to an arbitrary address can be used to steal all the funds from the contract",
  "Content": "_Submitted by WatchPug, also found by catchup, csanuragjain, rayn, and VAD37_\n\n[AnyswapFacet.sol#L131-L157](https://github.com/code-423n4/2022-03-lifinance/blob/699c2305fcfb6fe8862b75b26d1d8a2f46a551e6/src/Facets/AnyswapFacet.sol#L131-L157)<br>\n\n```solidity\nfunction _startBridge(AnyswapData memory _anyswapData) internal {\n    // Check chain id\n    require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");\n    address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n\n    if (underlyingToken == IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n        IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(\n            _anyswapData.token,\n            _anyswapData.recipient,\n            _anyswapData.toChainId\n        );\n        return;\n    }\n\n    if (_anyswapData.token != address(0)) {\n        // Has underlying token?\n        if (underlyingToken != address(0)) {\n            // Give Anyswap approval to bridge tokens\n            LibAsset.approveERC20(IERC20(underlyingToken), _anyswapData.router, _anyswapData.amount);\n\n            IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(\n                _anyswapData.token,\n                _anyswapData.recipient,\n                _anyswapData.amount,\n                _anyswapData.toChainId\n            );\n        } else {\n```\n\n[LibAsset.sol#L59-L70](https://github.com/code-423n4/2022-03-lifinance/blob/699c2305fcfb6fe8862b75b26d1d8a2f46a551e6/src/Libraries/LibAsset.sol#L59-L70)<br>\n\n```solidity\nfunction approveERC20(\n    IERC20 assetId,\n    address spender,\n    uint256 amount\n) internal {\n    if (isNativeAsset(address(assetId))) return;\n    uint256 allowance = assetId.allowance(address(this), spender);\n    if (allowance < amount) {\n        if (allowance > 0) SafeERC20.safeApprove(IERC20(assetId), spender, 0);\n        SafeERC20.safeApprove(IERC20(assetId), spender, MAX_INT);\n    }\n}\n```\n\nIn the `AnyswapFacet.sol`, `_anyswapData.router` is from the caller's calldata, which can really be any contract, including a fake Anyswap router contract, as long as it complies to the interfaces used.\n\nAnd in `_startBridge`, it will grant infinite approval for the `_anyswapData.token` to the `_anyswapData.router`.\n\nThis makes it possible for a attacker to steal all the funds from the contract.\n\nWhich we explained in [#159](https://github.com/code-423n4/2022-03-lifinance-findings/issues/159), the diamond contract may be holding some funds for various of reasons.\n\n### Proof of Concept\n\nGiven:\n\nThere are 100 USDC tokens in the contract.\n\n1.  The attacker can submit a `startBridgeTokensViaAnyswap()` with a FAKE `_anyswapData.router`.\n2.  Once the FAKE router contract deployed by the attacker got the infinite approval from the diamond contract, the attacker can call `transferFrom()` and take all the funds, including the 100 USDC in the contract anytime.\n\n### Recommended Mitigation Steps\n\n1.  Whitelisting the `_anyswapData.router` rather than trusting user's inputs;\n2.  Or, only `approve()` for the amount that required for the current transaction instead of infinite approval.\n\n**[H3xept (Li.Fi) acknowledged, but disagreed with High severity and commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/160#issuecomment-1096471540):**\n > We are aware that the contract allows users to use latent funds, although we disagree on it being an issue as no funds (ERC20 or native) should ever lay in the contract. To make sure that no value is ever kept by the diamond, we now provide refunds for outstanding user value (after bridges/swaps).\n\n**[gzeon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-03-lifinance-findings/issues/160#issuecomment-1100709584):**\n > Warden highlighted the vulnerability in `AnyswapFacet` which would allow attacker to grant approval to arbitrary contract. \n> \n> There can be fund leftover in the contract under normal operation, for example [this tx](https://etherscan.io/tx/0xe78c36dd2c2f21cade00a4099701b9c9f82acc8da568e1048a4d7287ce2e45b0). In fact, ~\\$300 worth of token is left in the LI.Fi smart contract on ETH mainnet [0x5a9fd7c39a6c488e715437d7b1f3c823d5596ed1](https://etherscan.io/address/0x5a9fd7c39a6c488e715437d7b1f3c823d5596ed1) as of block 14597316. I don't think this is High Risk because the max amount lost is no more than allowed slippage, which can be loss to MEV too.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-03-lifinance",
  "Code": [
    {
      "filename": "src/Facets/AnyswapFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Anyswap Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through Multichain (Prev. AnySwap)\n */\ncontract AnyswapFacet is ILiFi, Swapper {\n    /* ========== Types ========== */\n\n    struct AnyswapData {\n        address token;\n        address router;\n        uint256 amount;\n        address recipient;\n        uint256 toChainId;\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via Anyswap\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _anyswapData data specific to Anyswap\n     */\n    function startBridgeTokensViaAnyswap(LiFiData memory _lifiData, AnyswapData calldata _anyswapData) public payable {\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            if (underlyingToken == address(0)) {\n                underlyingToken = _anyswapData.token;\n            }\n\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n            LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);\n\n            require(\n                LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        } else {\n            require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via Anyswap\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _anyswapData data specific to Anyswap\n     */\n    function swapAndStartBridgeTokensViaAnyswap(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        AnyswapData memory _anyswapData\n    ) public payable {\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            if (underlyingToken == address(0)) {\n                underlyingToken = _anyswapData.token;\n            }\n\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /**\n     * @dev Conatains the business logic for the bridge via Anyswap\n     * @param _anyswapData data specific to Anyswap\n     */\n    function _startBridge(AnyswapData memory _anyswapData) internal {\n        // Check chain id\n        require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n\n        if (underlyingToken == IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(\n                _anyswapData.token,\n                _anyswapData.recipient,\n                _anyswapData.toChainId\n            );\n            return;\n        }\n\n        if (_anyswapData.token != address(0)) {\n            // Has underlying token?\n            if (underlyingToken != address(0)) {\n                // Give Anyswap approval to bridge tokens\n                LibAsset.approveERC20(IERC20(underlyingToken), _anyswapData.router, _anyswapData.amount);\n\n                IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(\n                    _anyswapData.token,\n                    _anyswapData.recipient,\n                    _anyswapData.amount,\n                    _anyswapData.toChainId\n                );\n            } else {\n                // Give Anyswap approval to bridge tokens\n                LibAsset.approveERC20(IERC20(_anyswapData.token), _anyswapData.router, _anyswapData.amount);\n\n                IAnyswapRouter(_anyswapData.router).anySwapOut(\n                    _anyswapData.token,\n                    _anyswapData.recipient,\n                    _anyswapData.amount,\n                    _anyswapData.toChainId\n                );\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/Libraries/LibAsset.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title LibAsset\n * @author Connext <support@connext.network>\n * @notice This library contains helpers for dealing with onchain transfers\n *         of assets, including accounting for the native asset `assetId`\n *         conventions and any noncompliant ERC20 transfers\n */\nlibrary LibAsset {\n    uint256 private constant MAX_INT = 2**256 - 1;\n\n    /**\n     * @dev All native assets use the empty address for their asset id\n     *      by convention\n     */\n    address internal constant NATIVE_ASSETID = address(0);\n\n    /**\n     * @notice Determines whether the given assetId is the native asset\n     * @param assetId The asset identifier to evaluate\n     * @return Boolean indicating if the asset is the native asset\n     */\n    function isNativeAsset(address assetId) internal pure returns (bool) {\n        return assetId == NATIVE_ASSETID;\n    }\n\n    /**\n     * @notice Gets the balance of the inheriting contract for the given asset\n     * @param assetId The asset identifier to get the balance of\n     * @return Balance held by contracts using this library\n     */\n    function getOwnBalance(address assetId) internal view returns (uint256) {\n        return isNativeAsset(assetId) ? address(this).balance : IERC20(assetId).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Transfers ether from the inheriting contract to a given\n     *         recipient\n     * @param recipient Address to send ether to\n     * @param amount Amount to send to given recipient\n     */\n    function transferNativeAsset(address payable recipient, uint256 amount) internal {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"#TNA:028\");\n    }\n\n    /**\n     * @notice Gives approval for another address to spend tokens\n     * @param assetId Token address to transfer\n     * @param spender Address to give spend approval to\n     * @param amount Amount to approve for spending\n     */\n    function approveERC20(\n        IERC20 assetId,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (isNativeAsset(address(assetId))) return;\n        uint256 allowance = assetId.allowance(address(this), spender);\n        if (allowance < amount) {\n            if (allowance > 0) SafeERC20.safeApprove(IERC20(assetId), spender, 0);\n            SafeERC20.safeApprove(IERC20(assetId), spender, MAX_INT);\n        }\n    }\n\n    /**\n     * @notice Transfers tokens from the inheriting contract to a given\n     *         recipient\n     * @param assetId Token address to transfer\n     * @param recipient Address to send ether to\n     * @param amount Amount to send to given recipient\n     */\n    function transferERC20(\n        address assetId,\n        address recipient,\n        uint256 amount\n    ) internal {\n        SafeERC20.safeTransfer(IERC20(assetId), recipient, amount);\n    }\n\n    /**\n     * @notice Transfers tokens from a sender to a given recipient\n     * @param assetId Token address to transfer\n     * @param from Address of sender/owner\n     * @param to Address of recipient/spender\n     * @param amount Amount to transfer from owner to spender\n     */\n    function transferFromERC20(\n        address assetId,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        SafeERC20.safeTransferFrom(IERC20(assetId), from, to, amount);\n    }\n\n    /**\n     * @notice Increases the allowance of a token to a spender\n     * @param assetId Token address of asset to increase allowance of\n     * @param spender Account whos allowance is increased\n     * @param amount Amount to increase allowance by\n     */\n    function increaseERC20Allowance(\n        address assetId,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(!isNativeAsset(assetId), \"#IA:034\");\n        SafeERC20.safeIncreaseAllowance(IERC20(assetId), spender, amount);\n    }\n\n    /**\n     * @notice Decreases the allowance of a token to a spender\n     * @param assetId Token address of asset to decrease allowance of\n     * @param spender Account whos allowance is decreased\n     * @param amount Amount to decrease allowance by\n     */\n    function decreaseERC20Allowance(\n        address assetId,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(!isNativeAsset(assetId), \"#DA:034\");\n        SafeERC20.safeDecreaseAllowance(IERC20(assetId), spender, amount);\n    }\n\n    /**\n     * @notice Wrapper function to transfer a given asset (native or erc20) to\n     *         some recipient. Should handle all non-compliant return value\n     *         tokens as well by using the SafeERC20 contract by open zeppelin.\n     * @param assetId Asset id for transfer (address(0) for native asset,\n     *                token address for erc20s)\n     * @param recipient Address to send asset to\n     * @param amount Amount to send to given recipient\n     */\n    function transferAsset(\n        address assetId,\n        address payable recipient,\n        uint256 amount\n    ) internal {\n        isNativeAsset(assetId) ? transferNativeAsset(recipient, amount) : transferERC20(assetId, recipient, amount);\n    }\n}"
    }
  ]
}