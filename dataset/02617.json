{
  "Title": "Gas inefficiencies",
  "Content": "There are many instances throughout the codebase where changes can be made to improve gas consumption. For example:\n\n\n* `public` functions might consume more gas than external functions. This is because with public functions, the EVM copies inputs (especially dynamic-sized arrays) into `memory`, while it reads from `calldata` if the function is `external`, which is cheaper. Throughout the codebase there are `public` functions like [`mintWithPermit`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L131), [`convertToSTETH`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/proxy/ETHAdapter.sol#L27), [`convertToETH`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/proxy/ETHAdapter.sol#L31), [`decimals`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L84), [`symbol`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/STETHVault.sol#L56), [name](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/STETHVault.sol#L49) and [`assetsOf`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L273) that might be declared as `external`. Consider reviewing the entire codebase for more instances.\n* The function `toAddress` has a [conditional statement](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/libs/CastUint.sol#L10) that returns the zero address if the value passed is equal to zero. This additional check increases the gas consumption and does not add any benefit even if the provided value is equal to zero.\n* Initializing a variable to its default value causes unnecessary gas expense. Consider correcting such instances in [`processedDeposits`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L46), [`isProcessingDeposits`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L30), [`roundAccruedInterest`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/STETHVault.sol#L71), [`endSharePrice`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/STETHVault.sol#L72) and the [while loop counter](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/libs/DepositQueueLib.sol#L33) inside the `remove` function.\n* The `for` loop inside the [`refund`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L333-L347) function does not cache the result of `depositQueue.size()` and perform unnecessary operations on each iteration. The same issue occurs in the last while loop of the [`remove`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/libs/DepositQueueLib.sol#L53) function.\n* Performing calculations for values that will not change is suboptimal. Some examples are: [`name`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/STETHVault.sol#L49), [`symbol`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/STETHVault.sol#L56) and the operation [`10**sharePriceDecimals`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/STETHVault.sol#L66).\n* Use shorter string messages for required statements or switch entirely to a [custom errors implementation](https://blog.soliditylang.org/2021/04/21/custom-errors/) to save on deployment cost and failed execution gas cost.\n\n\nWhen performing these changes, aim to reach an optimal tradeoff between gas optimization and readability. Having a codebase that is easy to understand reduces the chance of future errors and improves community transparency.\n\n\n**Update:** *Partially fixed in [PR#81](https://github.com/pods-finance/yield-contracts/pull/81), with commit `6f1bb8e` being the last one added.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/BaseVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IConfigurationManager.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../libs/AuxMath.sol\";\nimport \"../libs/DepositQueueLib.sol\";\nimport \"../libs/CastUint.sol\";\nimport \"../mixins/Capped.sol\";\n\n/**\n * @title A Vault that tokenize shares of strategy\n * @author Pods Finance\n */\nabstract contract BaseVault is IVault, ERC20Permit, Capped {\n    using SafeERC20 for IERC20Metadata;\n    using AuxMath for uint256;\n    using CastUint for uint256;\n    using DepositQueueLib for DepositQueueLib.DepositQueue;\n\n    IConfigurationManager public immutable configuration;\n    IERC20Metadata internal immutable _asset;\n\n    uint256 public currentRoundId;\n    bool public isProcessingDeposits = false;\n\n    /*\n    DENOMINATOR represents the precision for the following system variables:\n    - MAX_WITHDRAW_FEE\n    - InvestorRatio\n    */\n\n    uint256 public constant DENOMINATOR = 10000;\n    /*\n    MAX_WITDRAW_FEE is a safe check in case the ConfiguratorManager sets\n    a fee high enough that can be used as a way to drain funds. \n    The precision of this number is set by constant DENOMINATOR.\n    */\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    uint256 public constant EMERGENCY_INTERVAL = 604800;\n    uint256 public processedDeposits = 0;\n    uint256 private _lastEndRound;\n\n    DepositQueueLib.DepositQueue internal depositQueue;\n\n    constructor(IConfigurationManager _configuration, IERC20Metadata _asset_)\n        ERC20(\n            string(abi.encodePacked(\"Pods Yield \", _asset_.symbol())),\n            string(abi.encodePacked(\"py\", _asset_.symbol()))\n        )\n        ERC20Permit(string(abi.encodePacked(\"Pods Yield \", _asset_.symbol())))\n        Capped(_configuration)\n    {\n        configuration = _configuration;\n        _asset = _asset_;\n\n        // Vault starts in `start` state\n        emit StartRound(currentRoundId, 0);\n        _lastEndRound = block.timestamp;\n    }\n\n    modifier onlyController() {\n        if (msg.sender != controller()) revert IVault__CallerIsNotTheController();\n        _;\n    }\n\n    modifier onlyRoundStarter() {\n        bool lastRoundEndedAWeekAgo = block.timestamp >= _lastEndRound + EMERGENCY_INTERVAL;\n\n        if (!lastRoundEndedAWeekAgo && msg.sender != controller()) {\n            revert IVault__CallerIsNotTheController();\n        }\n        _;\n    }\n\n    /**\n     * @inheritdoc ERC20\n     */\n    function decimals() public view override returns (uint8) {\n        return _asset.decimals();\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function asset() public view returns (address) {\n        return address(_asset);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function deposit(uint256 assets, address receiver) external virtual override returns (uint256 shares) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        shares = previewDeposit(assets);\n\n        if (shares == 0) revert IVault__ZeroShares();\n        _deposit(assets, shares, receiver);\n    }\n\n    function depositWithPermit(\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 shares) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        shares = previewDeposit(assets);\n\n        if (shares == 0) revert IVault__ZeroShares();\n        IERC20Permit(address(_asset)).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        _deposit(assets, shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function mint(uint256 shares, address receiver) external virtual override returns (uint256 assets) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        assets = previewMint(shares);\n        assets = _deposit(assets, shares, receiver);\n    }\n\n    function mintWithPermit(\n        uint256 shares,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public returns (uint256 assets) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        assets = previewMint(shares);\n        IERC20Permit(address(_asset)).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        assets = _deposit(assets, shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256 assets) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        assets = convertToAssets(shares);\n\n        if (assets == 0) revert IVault__ZeroAssets();\n        (assets, ) = _withdraw(assets, shares, receiver, owner);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external virtual override returns (uint256 shares) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        shares = convertToShares(assets);\n        (, shares) = _withdraw(assets, shares, receiver, owner);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function totalAssets() public view virtual returns (uint256);\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewDeposit(uint256 assets) public view override returns (uint256 shares) {\n        return convertToShares(assets);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewMint(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        shares = convertToShares(assets);\n        uint256 invertedFee = DENOMINATOR - withdrawFeeRatio();\n        return shares.mulDivUp(DENOMINATOR, invertedFee);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        assets = convertToAssets(shares);\n        return assets - _getFee(assets);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxDeposit(address) public pure override returns (uint256 assets) {\n        return type(uint256).max;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxMint(address) public pure override returns (uint256 shares) {\n        return type(uint256).max;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxWithdraw(address owner) public view override returns (uint256 assets) {\n        return previewRedeem(balanceOf(owner));\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxRedeem(address owner) public view override returns (uint256 shares) {\n        return balanceOf(owner);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function withdrawFeeRatio() public view override returns (uint256) {\n        uint256 _withdrawFeeRatio = configuration.getParameter(address(this), \"WITHDRAW_FEE_RATIO\");\n        // Fee is limited to MAX_WITHDRAW_FEE\n        return AuxMath.min(_withdrawFeeRatio, MAX_WITHDRAW_FEE);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function idleAssetsOf(address owner) public view virtual returns (uint256) {\n        return depositQueue.balanceOf(owner);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function assetsOf(address owner) public view virtual returns (uint256) {\n        uint256 supply = totalSupply();\n        uint256 shares = balanceOf(owner);\n        uint256 committedAssets = supply == 0 ? 0 : shares.mulDivDown(_asset.balanceOf(address(this)), supply);\n        return convertToAssets(shares) + idleAssetsOf(owner) + committedAssets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function totalIdleAssets() public view virtual returns (uint256) {\n        return depositQueue.totalDeposited;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function depositQueueSize() public view returns (uint256) {\n        return depositQueue.size();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function controller() public view returns (address) {\n        return configuration.getParameter(address(this), \"VAULT_CONTROLLER\").toAddress();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function startRound() external virtual onlyRoundStarter returns (uint256 roundId) {\n\n        if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        isProcessingDeposits = false;\n\n        _afterRoundStart(processedDeposits);\n        emit StartRound(currentRoundId, processedDeposits);\n        processedDeposits = 0;\n\n        return currentRoundId;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function endRound() external virtual onlyController {\n        if (isProcessingDeposits) revert IVault__AlreadyProcessingDeposits();\n\n        isProcessingDeposits = true;\n        _afterRoundEnd();\n        _lastEndRound = block.timestamp;\n\n        emit EndRound(currentRoundId++);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function refund() external returns (uint256 assets) {\n        assets = depositQueue.balanceOf(msg.sender);\n        if (assets == 0) revert IVault__ZeroAssets();\n\n        for (uint256 i = 0; i < depositQueue.size(); i++) {\n            DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);\n            if (depositEntry.owner == msg.sender) {\n                depositQueue.remove(i, i + 1);\n                break;\n            }\n        }\n\n        emit DepositRefunded(msg.sender, currentRoundId, assets);\n        _asset.safeTransfer(msg.sender, assets);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function migrate(IVault newVault) external override {\n        if (address(_asset) != newVault.asset() || !configuration.isVaultAllowed(address(newVault))) {\n            revert IVault__MigrationNotAllowed();\n        }\n\n        // Redeem owner assets from this Vault\n        uint256 shares = balanceOf(msg.sender);\n        uint256 assets = redeem(shares, address(this), msg.sender);\n\n        // Deposit assets to `newVault`\n        _asset.safeApprove(address(newVault), assets);\n        newVault.deposit(assets, msg.sender);\n\n        emit Migrated(msg.sender, address(this), address(newVault), assets, shares);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n        if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        uint256 _totalAssets = totalAssets();\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            uint256 currentAssets = _totalAssets + processedDeposits;\n            DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);\n            _processDeposit(depositEntry, currentAssets);\n            processedDeposits += depositEntry.amount;\n        }\n        depositQueue.remove(startIndex, endIndex);\n    }\n\n    /** Internals **/\n\n    /**\n     * @notice Mint new shares, effectively representing user participation in the Vault.\n     */\n    function _processDeposit(DepositQueueLib.DepositEntry memory depositEntry, uint256 currentAssets) internal virtual {\n        uint256 supply = totalSupply();\n        uint256 assets = depositEntry.amount;\n        uint256 shares = currentAssets == 0 || supply == 0 ? assets : assets.mulDivUp(supply, currentAssets);\n        _mint(depositEntry.owner, shares);\n        emit DepositProcessed(depositEntry.owner, currentRoundId, assets, shares);\n    }\n\n    /**\n     * @notice Calculate the fee amount on withdraw.\n     */\n    function _getFee(uint256 assets) internal view returns (uint256) {\n        return assets.mulDivDown(withdrawFeeRatio(), DENOMINATOR);\n    }\n\n    /**\n     * @dev Pull assets from the caller and create shares to the receiver\n     */\n    function _deposit(\n        uint256 assets,\n        uint256 shares,\n        address receiver\n    ) internal virtual returns (uint256 depositedAssets) {\n        _spendCap(shares);\n\n        depositQueue.push(DepositQueueLib.DepositEntry(receiver, assets));\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n        _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        return assets;\n    }\n\n    /**\n     * @dev Burn shares from the caller and release assets to the receiver\n     */\n    function _withdraw(\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address owner\n    ) internal virtual returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        // Apply custom withdraw logic\n        _beforeWithdraw(shares, assets);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(msg.sender, receiver, owner, receiverAssets, shares);\n        _asset.safeTransfer(receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            _asset.safeTransfer(controller(), fee);\n        }\n    }\n\n    /** Hooks **/\n\n    // solhint-disable-next-line no-empty-blocks\n    /* This hook should be implemented in the contract implementation.\n        It will trigger after the shares were burned\n    */\n    function _beforeWithdraw(uint256 shares, uint256 assets) internal virtual {}\n\n    // solhint-disable-next-line no-empty-blocks\n    /* This hook should be implemented in the contract implementation.\n        It will trigger after setting isProcessingDeposits to false\n    */\n    function _afterRoundStart(uint256 assets) internal virtual {}\n\n    // solhint-disable-next-line no-empty-blocks\n    /* This hook should be implemented in the contract implementation.\n        It will trigger after setting isProcessingDeposits to true\n    */\n    function _afterRoundEnd() internal virtual {}\n}"
    },
    {
      "filename": "contracts/libs/CastUint.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nlibrary CastUint {\n    /**\n     * @dev Converts a `uint256` to `address`\n     */\n    function toAddress(uint256 value) internal pure returns (address) {\n        if (value == 0) return address(0);\n        return address(uint160(value));\n    }\n}"
    },
    {
      "filename": "contracts/vaults/BaseVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IConfigurationManager.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../libs/AuxMath.sol\";\nimport \"../libs/DepositQueueLib.sol\";\nimport \"../libs/CastUint.sol\";\nimport \"../mixins/Capped.sol\";\n\n/**\n * @title A Vault that tokenize shares of strategy\n * @author Pods Finance\n */\nabstract contract BaseVault is IVault, ERC20Permit, Capped {\n    using SafeERC20 for IERC20Metadata;\n    using AuxMath for uint256;\n    using CastUint for uint256;\n    using DepositQueueLib for DepositQueueLib.DepositQueue;\n\n    IConfigurationManager public immutable configuration;\n    IERC20Metadata internal immutable _asset;\n\n    uint256 public currentRoundId;\n    bool public isProcessingDeposits = false;\n\n    /*\n    DENOMINATOR represents the precision for the following system variables:\n    - MAX_WITHDRAW_FEE\n    - InvestorRatio\n    */\n\n    uint256 public constant DENOMINATOR = 10000;\n    /*\n    MAX_WITDRAW_FEE is a safe check in case the ConfiguratorManager sets\n    a fee high enough that can be used as a way to drain funds. \n    The precision of this number is set by constant DENOMINATOR.\n    */\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    uint256 public constant EMERGENCY_INTERVAL = 604800;\n    uint256 public processedDeposits = 0;\n    uint256 private _lastEndRound;\n\n    DepositQueueLib.DepositQueue internal depositQueue;\n\n    constructor(IConfigurationManager _configuration, IERC20Metadata _asset_)\n        ERC20(\n            string(abi.encodePacked(\"Pods Yield \", _asset_.symbol())),\n            string(abi.encodePacked(\"py\", _asset_.symbol()))\n        )\n        ERC20Permit(string(abi.encodePacked(\"Pods Yield \", _asset_.symbol())))\n        Capped(_configuration)\n    {\n        configuration = _configuration;\n        _asset = _asset_;\n\n        // Vault starts in `start` state\n        emit StartRound(currentRoundId, 0);\n        _lastEndRound = block.timestamp;\n    }\n\n    modifier onlyController() {\n        if (msg.sender != controller()) revert IVault__CallerIsNotTheController();\n        _;\n    }\n\n    modifier onlyRoundStarter() {\n        bool lastRoundEndedAWeekAgo = block.timestamp >= _lastEndRound + EMERGENCY_INTERVAL;\n\n        if (!lastRoundEndedAWeekAgo && msg.sender != controller()) {\n            revert IVault__CallerIsNotTheController();\n        }\n        _;\n    }\n\n    /**\n     * @inheritdoc ERC20\n     */\n    function decimals() public view override returns (uint8) {\n        return _asset.decimals();\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function asset() public view returns (address) {\n        return address(_asset);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function deposit(uint256 assets, address receiver) external virtual override returns (uint256 shares) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        shares = previewDeposit(assets);\n\n        if (shares == 0) revert IVault__ZeroShares();\n        _deposit(assets, shares, receiver);\n    }\n\n    function depositWithPermit(\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 shares) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        shares = previewDeposit(assets);\n\n        if (shares == 0) revert IVault__ZeroShares();\n        IERC20Permit(address(_asset)).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        _deposit(assets, shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function mint(uint256 shares, address receiver) external virtual override returns (uint256 assets) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        assets = previewMint(shares);\n        assets = _deposit(assets, shares, receiver);\n    }\n\n    function mintWithPermit(\n        uint256 shares,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public returns (uint256 assets) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        assets = previewMint(shares);\n        IERC20Permit(address(_asset)).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        assets = _deposit(assets, shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256 assets) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        assets = convertToAssets(shares);\n\n        if (assets == 0) revert IVault__ZeroAssets();\n        (assets, ) = _withdraw(assets, shares, receiver, owner);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external virtual override returns (uint256 shares) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        shares = convertToShares(assets);\n        (, shares) = _withdraw(assets, shares, receiver, owner);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function totalAssets() public view virtual returns (uint256);\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewDeposit(uint256 assets) public view override returns (uint256 shares) {\n        return convertToShares(assets);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewMint(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        shares = convertToShares(assets);\n        uint256 invertedFee = DENOMINATOR - withdrawFeeRatio();\n        return shares.mulDivUp(DENOMINATOR, invertedFee);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        assets = convertToAssets(shares);\n        return assets - _getFee(assets);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxDeposit(address) public pure override returns (uint256 assets) {\n        return type(uint256).max;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxMint(address) public pure override returns (uint256 shares) {\n        return type(uint256).max;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxWithdraw(address owner) public view override returns (uint256 assets) {\n        return previewRedeem(balanceOf(owner));\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxRedeem(address owner) public view override returns (uint256 shares) {\n        return balanceOf(owner);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function withdrawFeeRatio() public view override returns (uint256) {\n        uint256 _withdrawFeeRatio = configuration.getParameter(address(this), \"WITHDRAW_FEE_RATIO\");\n        // Fee is limited to MAX_WITHDRAW_FEE\n        return AuxMath.min(_withdrawFeeRatio, MAX_WITHDRAW_FEE);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function idleAssetsOf(address owner) public view virtual returns (uint256) {\n        return depositQueue.balanceOf(owner);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function assetsOf(address owner) public view virtual returns (uint256) {\n        uint256 supply = totalSupply();\n        uint256 shares = balanceOf(owner);\n        uint256 committedAssets = supply == 0 ? 0 : shares.mulDivDown(_asset.balanceOf(address(this)), supply);\n        return convertToAssets(shares) + idleAssetsOf(owner) + committedAssets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function totalIdleAssets() public view virtual returns (uint256) {\n        return depositQueue.totalDeposited;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function depositQueueSize() public view returns (uint256) {\n        return depositQueue.size();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function controller() public view returns (address) {\n        return configuration.getParameter(address(this), \"VAULT_CONTROLLER\").toAddress();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function startRound() external virtual onlyRoundStarter returns (uint256 roundId) {\n\n        if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        isProcessingDeposits = false;\n\n        _afterRoundStart(processedDeposits);\n        emit StartRound(currentRoundId, processedDeposits);\n        processedDeposits = 0;\n\n        return currentRoundId;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function endRound() external virtual onlyController {\n        if (isProcessingDeposits) revert IVault__AlreadyProcessingDeposits();\n\n        isProcessingDeposits = true;\n        _afterRoundEnd();\n        _lastEndRound = block.timestamp;\n\n        emit EndRound(currentRoundId++);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function refund() external returns (uint256 assets) {\n        assets = depositQueue.balanceOf(msg.sender);\n        if (assets == 0) revert IVault__ZeroAssets();\n\n        for (uint256 i = 0; i < depositQueue.size(); i++) {\n            DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);\n            if (depositEntry.owner == msg.sender) {\n                depositQueue.remove(i, i + 1);\n                break;\n            }\n        }\n\n        emit DepositRefunded(msg.sender, currentRoundId, assets);\n        _asset.safeTransfer(msg.sender, assets);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function migrate(IVault newVault) external override {\n        if (address(_asset) != newVault.asset() || !configuration.isVaultAllowed(address(newVault))) {\n            revert IVault__MigrationNotAllowed();\n        }\n\n        // Redeem owner assets from this Vault\n        uint256 shares = balanceOf(msg.sender);\n        uint256 assets = redeem(shares, address(this), msg.sender);\n\n        // Deposit assets to `newVault`\n        _asset.safeApprove(address(newVault), assets);\n        newVault.deposit(assets, msg.sender);\n\n        emit Migrated(msg.sender, address(this), address(newVault), assets, shares);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n        if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        uint256 _totalAssets = totalAssets();\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            uint256 currentAssets = _totalAssets + processedDeposits;\n            DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);\n            _processDeposit(depositEntry, currentAssets);\n            processedDeposits += depositEntry.amount;\n        }\n        depositQueue.remove(startIndex, endIndex);\n    }\n\n    /** Internals **/\n\n    /**\n     * @notice Mint new shares, effectively representing user participation in the Vault.\n     */\n    function _processDeposit(DepositQueueLib.DepositEntry memory depositEntry, uint256 currentAssets) internal virtual {\n        uint256 supply = totalSupply();\n        uint256 assets = depositEntry.amount;\n        uint256 shares = currentAssets == 0 || supply == 0 ? assets : assets.mulDivUp(supply, currentAssets);\n        _mint(depositEntry.owner, shares);\n        emit DepositProcessed(depositEntry.owner, currentRoundId, assets, shares);\n    }\n\n    /**\n     * @notice Calculate the fee amount on withdraw.\n     */\n    function _getFee(uint256 assets) internal view returns (uint256) {\n        return assets.mulDivDown(withdrawFeeRatio(), DENOMINATOR);\n    }\n\n    /**\n     * @dev Pull assets from the caller and create shares to the receiver\n     */\n    function _deposit(\n        uint256 assets,\n        uint256 shares,\n        address receiver\n    ) internal virtual returns (uint256 depositedAssets) {\n        _spendCap(shares);\n\n        depositQueue.push(DepositQueueLib.DepositEntry(receiver, assets));\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n        _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        return assets;\n    }\n\n    /**\n     * @dev Burn shares from the caller and release assets to the receiver\n     */\n    function _withdraw(\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address owner\n    ) internal virtual returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        // Apply custom withdraw logic\n        _beforeWithdraw(shares, assets);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(msg.sender, receiver, owner, receiverAssets, shares);\n        _asset.safeTransfer(receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            _asset.safeTransfer(controller(), fee);\n        }\n    }\n\n    /** Hooks **/\n\n    // solhint-disable-next-line no-empty-blocks\n    /* This hook should be implemented in the contract implementation.\n        It will trigger after the shares were burned\n    */\n    function _beforeWithdraw(uint256 shares, uint256 assets) internal virtual {}\n\n    // solhint-disable-next-line no-empty-blocks\n    /* This hook should be implemented in the contract implementation.\n        It will trigger after setting isProcessingDeposits to false\n    */\n    function _afterRoundStart(uint256 assets) internal virtual {}\n\n    // solhint-disable-next-line no-empty-blocks\n    /* This hook should be implemented in the contract implementation.\n        It will trigger after setting isProcessingDeposits to true\n    */\n    function _afterRoundEnd() internal virtual {}\n}"
    },
    {
      "filename": "contracts/vaults/BaseVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IConfigurationManager.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../libs/AuxMath.sol\";\nimport \"../libs/DepositQueueLib.sol\";\nimport \"../libs/CastUint.sol\";\nimport \"../mixins/Capped.sol\";\n\n/**\n * @title A Vault that tokenize shares of strategy\n * @author Pods Finance\n */\nabstract contract BaseVault is IVault, ERC20Permit, Capped {\n    using SafeERC20 for IERC20Metadata;\n    using AuxMath for uint256;\n    using CastUint for uint256;\n    using DepositQueueLib for DepositQueueLib.DepositQueue;\n\n    IConfigurationManager public immutable configuration;\n    IERC20Metadata internal immutable _asset;\n\n    uint256 public currentRoundId;\n    bool public isProcessingDeposits = false;\n\n    /*\n    DENOMINATOR represents the precision for the following system variables:\n    - MAX_WITHDRAW_FEE\n    - InvestorRatio\n    */\n\n    uint256 public constant DENOMINATOR = 10000;\n    /*\n    MAX_WITDRAW_FEE is a safe check in case the ConfiguratorManager sets\n    a fee high enough that can be used as a way to drain funds. \n    The precision of this number is set by constant DENOMINATOR.\n    */\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    uint256 public constant EMERGENCY_INTERVAL = 604800;\n    uint256 public processedDeposits = 0;\n    uint256 private _lastEndRound;\n\n    DepositQueueLib.DepositQueue internal depositQueue;\n\n    constructor(IConfigurationManager _configuration, IERC20Metadata _asset_)\n        ERC20(\n            string(abi.encodePacked(\"Pods Yield \", _asset_.symbol())),\n            string(abi.encodePacked(\"py\", _asset_.symbol()))\n        )\n        ERC20Permit(string(abi.encodePacked(\"Pods Yield \", _asset_.symbol())))\n        Capped(_configuration)\n    {\n        configuration = _configuration;\n        _asset = _asset_;\n\n        // Vault starts in `start` state\n        emit StartRound(currentRoundId, 0);\n        _lastEndRound = block.timestamp;\n    }\n\n    modifier onlyController() {\n        if (msg.sender != controller()) revert IVault__CallerIsNotTheController();"
    }
  ]
}