{
  "Title": "[M-06] Batched liquidations doesn't distribute bad debt on next batches in the list",
  "Content": "\nLiquidationLibrary.batchLiquidateCdps is called from `CDPManager` in order to liquidate list of cdps.\nDepending if system is currently in recovery mode liquidations will be done [inside `_getTotalFromBatchLiquidate_RecoveryMode` or `_getTotalsFromBatchLiquidate_NormalMode` function](https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/LiquidationLibrary.sol#L698-L708).\n\nAfter that `_finalizeLiquidation` function [will be called](https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/LiquidationLibrary.sol#L717C9-L726), which will then do several important system updates, token transfer and what is important for this report [bad debt redistribution](https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/LiquidationLibrary.sol#L525-L527). In case if new bad debt occurs in the system, then this [debt amount is redistributed to all stakers that are still in the system](https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/LiquidationLibrary.sol#L862-L892).\n\nNow, let's check how liquidations occur by `_getTotalsFromBatchLiquidate_NormalMode` function.\nThis function loops through all cpds one by one. It [fetches `ICR` for them](https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/LiquidationLibrary.sol#L820) using `getSyncedICR` function. This function will calculate `ICR` not on stored `debt` and `coll` of cdp, but it will update this values, according to new fee rate(which means that `coll` will be reduced) and redistribute rate(which means that debt will increase, if rate is bigger than stored for cdp).\n\nThis is how it will be done for redistribution. <br><https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/CdpManagerStorage.sol#L864-L868>\n\n```solidity\n    function getSyncedICR(bytes32 _cdpId, uint256 _price) public view returns (uint256) {\n        uint256 _debt = getSyncedCdpDebt(_cdpId);\n        uint256 _collShare = getSyncedCdpCollShares(_cdpId);\n        return _calculateCR(_collShare, _debt, _price);\n    }\n```\n\nThen `getSyncedCdpDebt` is called, which calls `_getSyncedCdpDebtAndRedistribution` function. <br><https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/CdpManagerStorage.sol#L822-L833>\n\n```solidity\n    function _getSyncedCdpDebtAndRedistribution(\n        bytes32 _cdpId\n    ) internal view returns (uint256, uint256, uint256) {\n        (uint256 pendingDebtRedistributed, uint256 _debtIndexDelta) = _getPendingRedistributedDebt(\n            _cdpId\n        );\n        uint256 _newDebt = Cdps[_cdpId].debt;\n        if (pendingDebtRedistributed > 0) {\n            _newDebt = _newDebt + pendingDebtRedistributed;\n        }\n        return (_newDebt, pendingDebtRedistributed, _debtIndexDelta);\n    }\n```\n\nSo debt of cdp will be increased `pendingDebtRedistributed`, which depends on [redistribution rate of position and current redistribution rate](https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/CdpManagerStorage.sol#L313).\n\nLater, for each cdp `_getLiquidationValuesNormalMode` function [will be called](https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/LiquidationLibrary.sol#L824), which will actually do the liquidation. It will [call `_liquidateIndividualCdpSetupCDPInNormalMode` function](https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/LiquidationLibrary.sol#L630-L632). Inside of it [`_calculateFullLiquidationSurplusAndCap` function is called](https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/LiquidationLibrary.sol#L251-L260) and it's purpose is to calculate shares that liquidator and cdp owner should receive and bad debt to redistribute.\n\nSo after liquidation has finished, then [`_addLiquidationValuesToTotals` function is called](https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/LiquidationLibrary.sol#L827), which will add values from previous liquidation(including redistribution debt) [to the total accumulator](https://github.com/code-423n4/2023-10-badger/blob/main/packages/contracts/contracts/LiquidationLibrary.sol#L851-L853).\n\nSo finally, I can explain the problem. In case if in batch there is cdp, that will create bad debt after liquidation, then this debt will not be redistributed to all next liquidations, as redistribution index is not updated after each liquidation. And as result, next liquidations will have incorrect `debt` value, which means that smaller amount of debt will be liquidated and bigger amount of `coll` will be received by cdp owner. And also all else users in the system will have to cover that delta debt that was not redistributed to next liquidations.\n\n### Impact\n\nBad debt is distributed incorrectly.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nYou need to redistribute bad debt after each liquidation in the batch (in case if bad debt occured).\n\n**[Alex the Entreprenerd (Badger) acknowledged and commented](https://github.com/code-423n4/2023-10-badger-findings/issues/36#issuecomment-1818533285):**\n > This is a known finding from Cantina that unfortunately was not added to the report.\n> \n> The finding specifically means that 3% of bad debt generated in a batch liquidation will be skipped, effectively making liquidations more favourable.\n> \n> That said, it's worth noting that since partial liquidations don't cause a redistribution, the 3% bad debt could have been skipped under other circumstances.\n> \n> https://github.com/GalloDaSballo/Cdp-Demo/blob/main/scripts/insolvency_cascade.py\n> \n> <details>\n> \n> ```python\n> \n> MAX_BPS = 10_000\n> \n> def cr(debt, coll):\n>     return coll / debt * 100\n> \n> def getDebtByCr(coll, cr_bps):\n>    return coll / cr_bps * MAX_BPS\n> \n> LICR = 103_00\n> \n> \n> def max(a, b):\n>    if(a > b):\n>       return a\n>    return b\n> \n> def min(a, b):\n>    if(a > b):\n>       return b\n>    return a\n> \n> def full_liq(COLL):\n>   ## burn all\n>   return [COLL, COLL / LICR * MAX_BPS]\n> \n> def partial_liq(COLL, percent):\n>    return [COLL * percent / 100, COLL * percent / 100 / LICR * MAX_BPS]\n> \n> def loop_full(cr_bps):\n>   COLL = 100\n>   DEBT = getDebtByCr(COLL, cr_bps)\n>   print(\"DEBT\", DEBT)\n>   print(\"cr\", cr(DEBT, COLL))\n> \n>   ## Liquidate Partially based on premium\n>   while(COLL > 2):\n>      [sub_coll, sub_debt] = partial_liq(COLL, 10)\n>     #  [sub_coll, sub_debt] = full_liq(COLL)\n>      print(\"DEBT\", DEBT)\n>      print(\"COLL\", COLL)\n>      DEBT -= sub_debt\n>      COLL -= sub_coll\n>   \n>   print(\"DEBT\", DEBT)\n>      \n> \n> \n> \n> CRS = [\n>    100_00,\n>    90_00,\n>    80_00,\n>    70_00\n> ]\n> \n> def main():\n>    print(\"Simulate Total Liquidation with Bad debt\")\n>    print(\"Coll is always 100\")\n>    print(\"No price means 1 coll = 1 debt for price\")\n>    for cr in CRS:\n>     print(\"\")\n>     print(\"\")\n>     print(\"\")\n>     loop_full(cr)\n>   \n> \n>    \n> \n> \n> \n> main()\n> \n> ```\n> </details>\n> \n\n**[ronnyx2017 (Judge) commented](https://github.com/code-423n4/2023-10-badger-findings/issues/36#issuecomment-1827401911):**\n > I didn't find a public record about the issue. So I'll mark it as Medium severity.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-badger",
  "Code": [
    {
      "filename": "packages/contracts/contracts/LiquidationLibrary.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\nimport \"./Interfaces/ICdpManagerData.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/IEBTCToken.sol\";\nimport \"./Interfaces/ISortedCdps.sol\";\nimport \"./Dependencies/ICollateralTokenOracle.sol\";\nimport \"./CdpManagerStorage.sol\";\n\n/// @title LiquidationLibrary mainly provide necessary logic to fulfill liquidation for eBTC Cdps.\n/// @dev This contract shares same base and storage layout with CdpManager and is the delegatecall destination from CdpManager\ncontract LiquidationLibrary is CdpManagerStorage {\n    constructor(\n        address _borrowerOperationsAddress,\n        address _collSurplusPool,\n        address _ebtcToken,\n        address _sortedCdps,\n        address _activePool,\n        address _priceFeed,\n        address _collateral\n    )\n        CdpManagerStorage(\n            address(0),\n            address(0),\n            _borrowerOperationsAddress,\n            _collSurplusPool,\n            _ebtcToken,\n            _sortedCdps,\n            _activePool,\n            _priceFeed,\n            _collateral\n        )\n    {}\n\n    /// @notice Fully liquidate a single Cdp by ID. Cdp must meet the criteria for liquidation at the time of execution.\n    /// @notice callable by anyone, attempts to liquidate the CdpId. Executes successfully if Cdp meets the conditions for liquidation (e.g. in Normal Mode, it liquidates if the Cdp's ICR < the system MCR).\n    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function\n    /// @param _cdpId ID of the Cdp to liquidate.\n    function liquidate(bytes32 _cdpId) external nonReentrantSelfAndBOps {\n        _liquidateIndividualCdpSetup(_cdpId, 0, _cdpId, _cdpId);\n    }\n\n    /// @notice Partially liquidate a single Cdp.\n    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function\n    /// @param _cdpId ID of the Cdp to partially liquidate.\n    /// @param _partialAmount Amount to partially liquidate.\n    /// @param _upperPartialHint Upper hint for reinsertion of the Cdp into the linked list.\n    /// @param _lowerPartialHint Lower hint for reinsertion of the Cdp into the linked list.\n    function partiallyLiquidate(\n        bytes32 _cdpId,\n        uint256 _partialAmount,\n        bytes32 _upperPartialHint,\n        bytes32 _lowerPartialHint\n    ) external nonReentrantSelfAndBOps {\n        require(_partialAmount != 0, \"LiquidationLibrary: use `liquidate` for 100%\");\n        _liquidateIndividualCdpSetup(_cdpId, _partialAmount, _upperPartialHint, _lowerPartialHint);\n    }\n\n    // Single CDP liquidation function.\n    function _liquidateIndividualCdpSetup(\n        bytes32 _cdpId,\n        uint256 _partialAmount,\n        bytes32 _upperPartialHint,\n        bytes32 _lowerPartialHint\n    ) internal {\n        _requireCdpIsActive(_cdpId);\n\n        _syncAccounting(_cdpId);\n\n        uint256 _price = priceFeed.fetchPrice();\n\n        // prepare local variables\n        uint256 _ICR = getCachedICR(_cdpId, _price); // @audit syncAccounting already called, guarenteed to be synced\n        (uint256 _TCR, uint256 systemColl, uint256 systemDebt) = _getTCRWithSystemDebtAndCollShares(\n            _price\n        );\n\n        // If CDP is above MCR\n        if (_ICR >= MCR) {\n            // We must be in RM\n            require(\n                _checkICRAgainstLiqThreshold(_ICR, _TCR),\n                \"LiquidationLibrary: ICR is not below liquidation threshold in current mode\"\n            );\n\n            // == Grace Period == //\n            uint128 cachedLastGracePeriodStartTimestamp = lastGracePeriodStartTimestamp;\n            require(\n                cachedLastGracePeriodStartTimestamp != UNSET_TIMESTAMP,\n                \"LiquidationLibrary: Recovery Mode grace period not started\"\n            );\n            require(\n                block.timestamp >\n                    cachedLastGracePeriodStartTimestamp + recoveryModeGracePeriodDuration,\n                \"LiquidationLibrary: Recovery mode grace period still in effect\"\n            );\n        } // Implicit Else Case, Implies ICR < MRC, meaning the CDP is liquidatable\n\n        bool _recoveryModeAtStart = _TCR < CCR ? true : false;\n        LiquidationLocals memory _liqState = LiquidationLocals(\n            _cdpId,\n            _partialAmount,\n            _price,\n            _ICR,\n            _upperPartialHint,\n            _lowerPartialHint,\n            (_recoveryModeAtStart),\n            _TCR,\n            0,\n            0,\n            0,\n            0,\n            0\n        );\n\n        LiquidationRecoveryModeLocals memory _rs = LiquidationRecoveryModeLocals(\n            systemDebt,\n            systemColl,\n            0,\n            0,\n            0,\n            _cdpId,\n            _price,\n            _ICR,\n            0,\n            0\n        );\n\n        _liquidateIndividualCdpSetupCDP(_liqState, _rs);\n    }\n\n    // liquidate given CDP by repaying debt in full or partially if its ICR is below MCR or TCR in recovery mode.\n    // For partial liquidation, caller should use HintHelper smart contract to get correct hints for reinsertion into sorted CDP list\n    function _liquidateIndividualCdpSetupCDP(\n        LiquidationLocals memory _liqState,\n        LiquidationRecoveryModeLocals memory _recoveryState\n    ) internal {\n        LiquidationValues memory liquidationValues;\n\n        uint256 startingSystemDebt = _recoveryState.entireSystemDebt;\n        uint256 startingSystemColl = _recoveryState.entireSystemColl;\n\n        if (_liqState.partialAmount == 0) {\n            (\n                liquidationValues.debtToBurn,\n                liquidationValues.totalCollToSendToLiquidator,\n                liquidationValues.debtToRedistribute,\n                liquidationValues.liquidatorCollSharesReward,\n                liquidationValues.collSurplus\n            ) = _liquidateCdpInGivenMode(_liqState, _recoveryState);\n        } else {\n            (\n                liquidationValues.debtToBurn,\n                liquidationValues.totalCollToSendToLiquidator\n            ) = _liquidateCDPPartially(_liqState);\n            if (\n                liquidationValues.totalCollToSendToLiquidator == 0 &&\n                liquidationValues.debtToBurn == 0\n            ) {\n                // retry with fully liquidation\n                (\n                    liquidationValues.debtToBurn,\n                    liquidationValues.totalCollToSendToLiquidator,\n                    liquidationValues.debtToRedistribute,\n                    liquidationValues.liquidatorCollSharesReward,\n                    liquidationValues.collSurplus\n                ) = _liquidateCdpInGivenMode(_liqState, _recoveryState);\n            }\n        }\n\n        _finalizeLiquidation(\n            liquidationValues.debtToBurn,\n            liquidationValues.totalCollToSendToLiquidator,\n            liquidationValues.debtToRedistribute,\n            liquidationValues.liquidatorCollSharesReward,\n            liquidationValues.collSurplus,\n            startingSystemColl,\n            startingSystemDebt,\n            _liqState.price\n        );\n    }\n\n    // liquidate (and close) the CDP from an external liquidator\n    // this function would return the liquidated debt and collateral of the given CDP\n    function _liquidateCdpInGivenMode(\n        LiquidationLocals memory _liqState,\n        LiquidationRecoveryModeLocals memory _recoveryState\n    ) private returns (uint256, uint256, uint256, uint256, uint256) {\n        if (_liqState.recoveryModeAtStart) {\n            LiquidationRecoveryModeLocals\n                memory _outputState = _liquidateIndividualCdpSetupCDPInRecoveryMode(_recoveryState);\n\n            // housekeeping leftover collateral for liquidated CDP\n            if (_outputState.totalSurplusCollShares > 0) {\n                activePool.transferSystemCollShares(\n                    address(collSurplusPool),\n                    _outputState.totalSurplusCollShares\n                );\n            }\n\n            return (\n                _outputState.totalDebtToBurn,\n                _outputState.totalCollSharesToSend,\n                _outputState.totalDebtToRedistribute,\n                _outputState.totalLiquidatorRewardCollShares,\n                _outputState.totalSurplusCollShares\n            );\n        } else {\n            LiquidationLocals memory _outputState = _liquidateIndividualCdpSetupCDPInNormalMode(\n                _liqState\n            );\n            return (\n                _outputState.totalDebtToBurn,\n                _outputState.totalCollSharesToSend,\n                _outputState.totalDebtToRedistribute,\n                _outputState.totalLiquidatorRewardCollShares,\n                _outputState.totalSurplusCollShares\n            );\n        }\n    }\n\n    function _liquidateIndividualCdpSetupCDPInNormalMode(\n        LiquidationLocals memory _liqState\n    ) private returns (LiquidationLocals memory) {\n        // liquidate entire debt\n        (\n            uint256 _totalDebtToBurn,\n            uint256 _totalColToSend,\n            uint256 _liquidatorReward\n        ) = _closeCdpByLiquidation(_liqState.cdpId);\n        uint256 _cappedColPortion;\n        uint256 _collSurplus;\n        uint256 _debtToRedistribute;\n        address _borrower = sortedCdps.getOwnerAddress(_liqState.cdpId);\n\n        // I don't see an issue emitting the CdpUpdated() event up here and avoiding this extra cache, any objections?\n        emit CdpUpdated(\n            _liqState.cdpId,\n            _borrower,\n            msg.sender,\n            _totalDebtToBurn,\n            _totalColToSend,\n            0,\n            0,\n            0,\n            CdpOperation.liquidateInNormalMode\n        );\n\n        {\n            (\n                _cappedColPortion,\n                _collSurplus,\n                _debtToRedistribute\n            ) = _calculateFullLiquidationSurplusAndCap(\n                _liqState.ICR,\n                _liqState.price,\n                _totalDebtToBurn,\n                _totalColToSend\n            );\n            if (_collSurplus > 0) {\n                // due to division precision loss, should be zero surplus in normal mode\n                _cappedColPortion = _cappedColPortion + _collSurplus;\n                _collSurplus = 0;\n            }\n            if (_debtToRedistribute > 0) {\n                _totalDebtToBurn = _totalDebtToBurn - _debtToRedistribute;\n            }\n        }\n        _liqState.totalDebtToBurn = _liqState.totalDebtToBurn + _totalDebtToBurn;\n        _liqState.totalCollSharesToSend = _liqState.totalCollSharesToSend + _cappedColPortion;\n        _liqState.totalDebtToRedistribute = _liqState.totalDebtToRedistribute + _debtToRedistribute;\n        _liqState.totalLiquidatorRewardCollShares =\n            _liqState.totalLiquidatorRewardCollShares +\n            _liquidatorReward;\n\n        // Emit events\n        uint _debtToColl = (_totalDebtToBurn * DECIMAL_PRECISION) / _liqState.price;\n        uint _cappedColl = collateral.getPooledEthByShares(_cappedColPortion + _liquidatorReward);\n\n        emit CdpLiquidated(\n            _liqState.cdpId,\n            _borrower,\n            _totalDebtToBurn,\n            // please note this is the collateral share of the liquidated CDP\n            _cappedColPortion,\n            CdpOperation.liquidateInNormalMode,\n            msg.sender,\n            _cappedColl > _debtToColl ? (_cappedColl - _debtToColl) : 0\n        );\n\n        return _liqState;\n    }\n\n    function _liquidateIndividualCdpSetupCDPInRecoveryMode(\n        LiquidationRecoveryModeLocals memory _recoveryState\n    ) private returns (LiquidationRecoveryModeLocals memory) {\n        // liquidate entire debt\n        (\n            uint256 _totalDebtToBurn,\n            uint256 _totalColToSend,\n            uint256 _liquidatorReward\n        ) = _closeCdpByLiquidation(_recoveryState.cdpId);\n\n        // cap the liquidated collateral if required\n        uint256 _cappedColPortion;\n        uint256 _collSurplus;\n        uint256 _debtToRedistribute;\n        address _borrower = sortedCdps.getOwnerAddress(_recoveryState.cdpId);\n\n        // I don't see an issue emitting the CdpUpdated() event up here and avoiding an extra cache of the values, any objections?\n        emit CdpUpdated(\n            _recoveryState.cdpId,\n            _borrower,\n            msg.sender,\n            _totalDebtToBurn,\n            _totalColToSend,\n            0,\n            0,\n            0,\n            CdpOperation.liquidateInRecoveryMode\n        );\n\n        // avoid stack too deep\n        {\n            (\n                _cappedColPortion,\n                _collSurplus,\n                _debtToRedistribute\n            ) = _calculateFullLiquidationSurplusAndCap(\n                _recoveryState.ICR,\n                _recoveryState.price,\n                _totalDebtToBurn,\n                _totalColToSend\n            );\n            if (_collSurplus > 0) {\n                collSurplusPool.increaseSurplusCollShares(_borrower, _collSurplus);\n                _recoveryState.totalSurplusCollShares =\n                    _recoveryState.totalSurplusCollShares +\n                    _collSurplus;\n            }\n            if (_debtToRedistribute > 0) {\n                _totalDebtToBurn = _totalDebtToBurn - _debtToRedistribute;\n            }\n        }\n        _recoveryState.totalDebtToBurn = _recoveryState.totalDebtToBurn + _totalDebtToBurn;\n        _recoveryState.totalCollSharesToSend =\n            _recoveryState.totalCollSharesToSend +\n            _cappedColPortion;\n        _recoveryState.totalDebtToRedistribute =\n            _recoveryState.totalDebtToRedistribute +\n            _debtToRedistribute;\n        _recoveryState.totalLiquidatorRewardCollShares =\n            _recoveryState.totalLiquidatorRewardCollShares +\n            _liquidatorReward;\n\n        // check if system back to normal mode\n        _recoveryState.entireSystemDebt = _recoveryState.entireSystemDebt > _totalDebtToBurn\n            ? _recoveryState.entireSystemDebt - _totalDebtToBurn\n            : 0;\n        _recoveryState.entireSystemColl = _recoveryState.entireSystemColl > _totalColToSend\n            ? _recoveryState.entireSystemColl - _totalColToSend\n            : 0;\n\n        uint _debtToColl = (_totalDebtToBurn * DECIMAL_PRECISION) / _recoveryState.price;\n        uint _cappedColl = collateral.getPooledEthByShares(_cappedColPortion + _liquidatorReward);\n        emit CdpLiquidated(\n            _recoveryState.cdpId,\n            _borrower,\n            _totalDebtToBurn,\n            // please note this is the collateral share of the liquidated CDP\n            _cappedColPortion,\n            CdpOperation.liquidateInRecoveryMode,\n            msg.sender,\n            _cappedColl > _debtToColl ? (_cappedColl - _debtToColl) : 0\n        );\n\n        return _recoveryState;\n    }\n\n    // liquidate (and close) the CDP from an external liquidator\n    // this function would return the liquidated debt and collateral of the given CDP\n    // without emmiting events\n    function _closeCdpByLiquidation(bytes32 _cdpId) private returns (uint256, uint256, uint256) {\n        // calculate entire debt to repay\n        (uint256 entireDebt, uint256 entireColl) = getSyncedDebtAndCollShares(_cdpId);\n\n        // housekeeping after liquidation by closing the CDP\n        uint256 _liquidatorReward = Cdps[_cdpId].liquidatorRewardShares;\n        _closeCdp(_cdpId, Status.closedByLiquidation);\n\n        return (entireDebt, entireColl, _liquidatorReward);\n    }\n\n    // Liquidate partially the CDP by an external liquidator\n    // This function would return the liquidated debt and collateral of the given CDP\n    function _liquidateCDPPartially(\n        LiquidationLocals memory _partialState\n    ) private returns (uint256, uint256) {\n        bytes32 _cdpId = _partialState.cdpId;\n        uint256 _partialDebt = _partialState.partialAmount;\n\n        // calculate entire debt to repay\n        CdpDebtAndCollShares memory _debtAndColl = _getSyncedDebtAndCollShares(_cdpId);\n        _requirePartialLiqDebtSize(_partialDebt, _debtAndColl.debt, _partialState.price);\n        uint256 newDebt = _debtAndColl.debt - _partialDebt;\n\n        // credit to https://arxiv.org/pdf/2212.07306.pdf for details\n        (uint256 _partialColl, uint256 newColl, ) = _calculatePartialLiquidationSurplusAndCap(\n            _partialState.ICR,\n            _partialState.price,\n            _partialDebt,\n            _debtAndColl.collShares\n        );\n\n        // early return: if new collateral is zero, we have a full liqudiation\n        if (newColl == 0) {\n            return (0, 0);\n        }\n\n        // If we have coll remaining, it must meet minimum CDP size requirements\n        _requirePartialLiqCollSize(collateral.getPooledEthByShares(newColl));\n\n        // updating the CDP accounting for partial liquidation\n        _partiallyReduceCdpDebt(_cdpId, _partialDebt, _partialColl);\n\n        // reInsert into sorted CDP list after partial liquidation\n        {\n            _reInsertPartialLiquidation(\n                _partialState,\n                EbtcMath._computeNominalCR(newColl, newDebt),\n                _debtAndColl.debt,\n                _debtAndColl.collShares\n            );\n            uint _debtToColl = (_partialDebt * DECIMAL_PRECISION) / _partialState.price;\n            uint _cappedColl = collateral.getPooledEthByShares(_partialColl);\n            emit CdpPartiallyLiquidated(\n                _cdpId,\n                sortedCdps.getOwnerAddress(_cdpId),\n                _partialDebt,\n                _partialColl,\n                CdpOperation.partiallyLiquidate,\n                msg.sender,\n                _cappedColl > _debtToColl ? (_cappedColl - _debtToColl) : 0\n            );\n        }\n        return (_partialDebt, _partialColl);\n    }\n\n    function _partiallyReduceCdpDebt(\n        bytes32 _cdpId,\n        uint256 _partialDebt,\n        uint256 _partialColl\n    ) internal {\n        Cdp storage _cdp = Cdps[_cdpId];\n\n        uint256 _coll = _cdp.coll;\n        uint256 _debt = _cdp.debt;\n\n        _cdp.coll = _coll - _partialColl;\n        _cdp.debt = _debt - _partialDebt;\n        _updateStakeAndTotalStakes(_cdpId);\n    }\n\n    // Re-Insertion into SortedCdp list after partial liquidation\n    function _reInsertPartialLiquidation(\n        LiquidationLocals memory _partialState,\n        uint256 _newNICR,\n        uint256 _oldDebt,\n        uint256 _oldColl\n    ) internal {\n        bytes32 _cdpId = _partialState.cdpId;\n\n        // ensure new ICR does NOT decrease due to partial liquidation\n        // if original ICR is above LICR\n        if (_partialState.ICR > LICR) {\n            require(\n                getCachedICR(_cdpId, _partialState.price) >= _partialState.ICR,\n                \"LiquidationLibrary: !_newICR>=_ICR\"\n            );\n        }\n\n        // reInsert into sorted CDP list\n        sortedCdps.reInsert(\n            _cdpId,\n            _newNICR,\n            _partialState.upperPartialHint,\n            _partialState.lowerPartialHint\n        );\n        emit CdpUpdated(\n            _cdpId,\n            sortedCdps.getOwnerAddress(_cdpId),\n            msg.sender,\n            _oldDebt,\n            _oldColl,\n            Cdps[_cdpId].debt,\n            Cdps[_cdpId].coll,\n            Cdps[_cdpId].stake,\n            CdpOperation.partiallyLiquidate\n        );\n    }\n\n    function _finalizeLiquidation(\n        uint256 totalDebtToBurn,\n        uint256 totalCollSharesToSend,\n        uint256 totalDebtToRedistribute,\n        uint256 totalLiquidatorRewardCollShares,\n        uint256 totalSurplusCollShares,\n        uint256 systemInitialCollShares,\n        uint256 systemInitialDebt,\n        uint256 price\n    ) internal {\n        // update the staking and collateral snapshots\n        _updateSystemSnapshotsExcludeCollRemainder(totalCollSharesToSend);\n\n        emit Liquidation(totalDebtToBurn, totalCollSharesToSend, totalLiquidatorRewardCollShares);\n\n        _syncGracePeriodForGivenValues(\n            systemInitialCollShares - totalCollSharesToSend - totalSurplusCollShares,\n            systemInitialDebt - totalDebtToBurn,\n            price\n        );\n\n        // redistribute debt if any\n        if (totalDebtToRedistribute > 0) {\n            _redistributeDebt(totalDebtToRedistribute);\n        }\n\n        // burn the debt from liquidator\n        ebtcToken.burn(msg.sender, totalDebtToBurn);\n\n        // offset debt from Active Pool\n        activePool.decreaseSystemDebt(totalDebtToBurn);\n\n        // CEI: ensure sending back collateral to liquidator is last thing to do\n        activePool.transferSystemCollSharesAndLiquidatorReward(\n            msg.sender,\n            totalCollSharesToSend,\n            totalLiquidatorRewardCollShares\n        );\n    }\n\n    // Partial Liquidation Cap Logic\n    function _calculatePartialLiquidationSurplusAndCap(\n        uint256 _ICR,\n        uint256 _price,\n        uint256 _totalDebtToBurn,\n        uint256 _totalColToSend\n    ) private view returns (uint256 toLiquidator, uint256 collSurplus, uint256 debtToRedistribute) {\n        uint256 _incentiveColl;\n\n        // CLAMP\n        if (_ICR > LICR) {\n            // Cap at 10%\n            _incentiveColl = (_totalDebtToBurn * (_ICR > MCR ? MCR : _ICR)) / _price;\n        } else {\n            // Min 103%\n            _incentiveColl = (_totalDebtToBurn * LICR) / _price;\n        }\n\n        toLiquidator = collateral.getSharesByPooledEth(_incentiveColl);\n\n        /// @audit MUST be like so, else we have debt redistribution, which we assume cannot happen in partial\n        assert(toLiquidator < _totalColToSend); // Assert is correct here for Echidna\n\n        /// Because of above we can subtract\n        collSurplus = _totalColToSend - toLiquidator; // Can use unchecked but w/e\n    }\n\n    function _calculateFullLiquidationSurplusAndCap(\n        uint256 _ICR,\n        uint256 _price,\n        uint256 _totalDebtToBurn,\n        uint256 _totalColToSend\n    ) private view returns (uint256 toLiquidator, uint256 collSurplus, uint256 debtToRedistribute) {\n        uint256 _incentiveColl;\n\n        if (_ICR > LICR) {\n            _incentiveColl = (_totalDebtToBurn * (_ICR > MCR ? MCR : _ICR)) / _price;\n\n            // Convert back to shares\n            toLiquidator = collateral.getSharesByPooledEth(_incentiveColl);\n        } else {\n            // for full liquidation, there would be some bad debt to redistribute\n            _incentiveColl = collateral.getPooledEthByShares(_totalColToSend);\n\n            // Since it's full and there's bad debt we use spot conversion to\n            // Determine the amount of debt that willl be repaid after adding the LICR discount\n            // Basically this is buying underwater Coll\n            // By repaying debt at 3% discount\n            // Can there be a rounding error where the _debtToRepay > debtToBurn?\n            uint256 _debtToRepay = (_incentiveColl * _price) / LICR;\n\n            debtToRedistribute = _debtToRepay < _totalDebtToBurn\n                ? _totalDebtToBurn - _debtToRepay //  Bad Debt (to be redistributed) is (CdpDebt - Repaid)\n                : 0; // Else 0 (note we may underpay per the comment above, althought that may be imaginary)\n\n            // now CDP owner should have zero surplus to claim\n            toLiquidator = _totalColToSend;\n        }\n\n        toLiquidator = toLiquidator < _totalColToSend ? toLiquidator : _totalColToSend;\n        collSurplus = (toLiquidator == _totalColToSend) ? 0 : _totalColToSend - toLiquidator;\n    }\n\n    // --- Batch liquidation functions ---\n\n    function _getLiquidationValuesNormalMode(\n        uint256 _price,\n        uint256 _TCR,\n        LocalVariables_LiquidationSequence memory vars,\n        LiquidationValues memory singleLiquidation\n    ) internal {\n        LiquidationLocals memory _liqState = LiquidationLocals(\n            vars.cdpId,\n            0,\n            _price,\n            vars.ICR,\n            vars.cdpId,\n            vars.cdpId,\n            (false),\n            _TCR,\n            0,\n            0,\n            0,\n            0,\n            0\n        );\n\n        LiquidationLocals memory _outputState = _liquidateIndividualCdpSetupCDPInNormalMode(\n            _liqState\n        );\n\n        singleLiquidation.entireCdpDebt = _outputState.totalDebtToBurn;\n        singleLiquidation.debtToBurn = _outputState.totalDebtToBurn;\n        singleLiquidation.totalCollToSendToLiquidator = _outputState.totalCollSharesToSend;\n        singleLiquidation.collSurplus = _outputState.totalSurplusCollShares;\n        singleLiquidation.debtToRedistribute = _outputState.totalDebtToRedistribute;\n        singleLiquidation.liquidatorCollSharesReward = _outputState.totalLiquidatorRewardCollShares;\n    }\n\n    function _getLiquidationValuesRecoveryMode(\n        uint256 _price,\n        uint256 _systemDebt,\n        uint256 _systemCollShares,\n        LocalVariables_LiquidationSequence memory vars,\n        LiquidationValues memory singleLiquidation\n    ) internal {\n        LiquidationRecoveryModeLocals memory _recState = LiquidationRecoveryModeLocals(\n            _systemDebt,\n            _systemCollShares,\n            0,\n            0,\n            0,\n            vars.cdpId,\n            _price,\n            vars.ICR,\n            0,\n            0\n        );\n\n        LiquidationRecoveryModeLocals\n            memory _outputState = _liquidateIndividualCdpSetupCDPInRecoveryMode(_recState);\n\n        singleLiquidation.entireCdpDebt = _outputState.totalDebtToBurn;\n        singleLiquidation.debtToBurn = _outputState.totalDebtToBurn;\n        singleLiquidation.totalCollToSendToLiquidator = _outputState.totalCollSharesToSend;\n        singleLiquidation.collSurplus = _outputState.totalSurplusCollShares;\n        singleLiquidation.debtToRedistribute = _outputState.totalDebtToRedistribute;\n        singleLiquidation.liquidatorCollSharesReward = _outputState.totalLiquidatorRewardCollShares;\n    }\n\n    /// @notice Attempt to liquidate a custom list of Cdps provided by the caller\n    /// @notice Callable by anyone, accepts a custom list of Cdps addresses as an argument.\n    /// @notice Steps through the provided list and attempts to liquidate every Cdp, until it reaches the end or it runs out of gas.\n    /// @notice A Cdp is liquidated only if it meets the conditions for liquidation.\n    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function\n    /// @param _cdpArray Array of Cdps to liquidate.\n    function batchLiquidateCdps(bytes32[] memory _cdpArray) external nonReentrantSelfAndBOps {\n        require(\n            _cdpArray.length != 0,\n            \"LiquidationLibrary: Calldata address array must not be empty\"\n        );\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        // taking fee to avoid accounted for the calculation of the TCR\n        _syncGlobalAccounting();\n\n        vars.price = priceFeed.fetchPrice();\n        (uint256 _TCR, uint256 systemColl, uint256 systemDebt) = _getTCRWithSystemDebtAndCollShares(\n            vars.price\n        );\n        vars.recoveryModeAtStart = _TCR < CCR ? true : false;\n\n        // Perform the appropriate batch liquidation - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(\n                vars.price,\n                systemColl,\n                systemDebt,\n                _cdpArray\n            );\n        } else {\n            //  if !vars.recoveryModeAtStart\n            totals = _getTotalsFromBatchLiquidate_NormalMode(vars.price, _TCR, _cdpArray);\n        }\n\n        require(totals.totalDebtInSequence > 0, \"LiquidationLibrary: nothing to liquidate\");\n\n        // housekeeping leftover collateral for liquidated CDPs\n        if (totals.totalCollSurplus > 0) {\n            activePool.transferSystemCollShares(address(collSurplusPool), totals.totalCollSurplus);\n        }\n\n        _finalizeLiquidation(\n            totals.totalDebtToBurn,\n            totals.totalCollToSendToLiquidator,\n            totals.totalDebtToRedistribute,\n            totals.totalCollReward,\n            totals.totalCollSurplus,\n            systemColl,\n            systemDebt,\n            vars.price\n        );\n    }\n\n    /*\n     * This function is used when the batch liquidation starts during Recovery Mode. However, it\n     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation processing\n     */\n    function _getTotalFromBatchLiquidate_RecoveryMode(\n        uint256 _price,\n        uint256 _systemCollShares,\n        uint256 _systemDebt,\n        bytes32[] memory _cdpArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = _systemDebt;\n        vars.entireSystemColl = _systemCollShares;\n        uint256 _TCR = _computeTCRWithGivenSystemValues(\n            vars.entireSystemColl,\n            vars.entireSystemDebt,\n            _price\n        );\n        uint256 _cnt = _cdpArray.length;\n        bool[] memory _liqFlags = new bool[](_cnt);\n        uint256 _start;\n        for (vars.i = _start; ; ) {\n            vars.cdpId = _cdpArray[vars.i];\n            // only for active cdps\n            if (vars.cdpId != bytes32(0) && Cdps[vars.cdpId].status == Status.active) {\n                vars.ICR = getSyncedICR(vars.cdpId, _price);\n\n                if (\n                    !vars.backToNormalMode &&\n                    (_checkICRAgainstMCR(vars.ICR) || canLiquidateRecoveryMode(vars.ICR, _TCR))\n                ) {\n                    vars.price = _price;\n                    _syncAccounting(vars.cdpId);\n                    _getLiquidationValuesRecoveryMode(\n                        _price,\n                        vars.entireSystemDebt,\n                        vars.entireSystemColl,\n                        vars,\n                        singleLiquidation\n                    );\n\n                    // Update aggregate trackers\n                    vars.entireSystemDebt = vars.entireSystemDebt - singleLiquidation.debtToBurn;\n                    vars.entireSystemColl =\n                        vars.entireSystemColl -\n                        singleLiquidation.totalCollToSendToLiquidator -\n                        singleLiquidation.collSurplus;\n\n                    // Add liquidation values to their respective running totals\n                    totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n                    _TCR = _computeTCRWithGivenSystemValues(\n                        vars.entireSystemColl,\n                        vars.entireSystemDebt,\n                        _price\n                    );\n                    vars.backToNormalMode = _TCR < CCR ? false : true;\n                    _liqFlags[vars.i] = true;\n                } else if (vars.backToNormalMode && _checkICRAgainstMCR(vars.ICR)) {\n                    _syncAccounting(vars.cdpId);\n                    _getLiquidationValuesNormalMode(_price, _TCR, vars, singleLiquidation);\n\n                    // Add liquidation values to their respective running totals\n                    totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n                    _liqFlags[vars.i] = true;\n                }\n                // In Normal Mode skip cdps with ICR >= MCR\n            }\n            ++vars.i;\n            if (vars.i == _cnt) {\n                break;\n            }\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode(\n        uint256 _price,\n        uint256 _TCR,\n        bytes32[] memory _cdpArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n        uint256 _cnt = _cdpArray.length;\n        uint256 _start;\n        for (vars.i = _start; ; ) {\n            vars.cdpId = _cdpArray[vars.i];\n            // only for active cdps\n            if (vars.cdpId != bytes32(0) && Cdps[vars.cdpId].status == Status.active) {\n                vars.ICR = getSyncedICR(vars.cdpId, _price);\n\n                if (_checkICRAgainstMCR(vars.ICR)) {\n                    _syncAccounting(vars.cdpId);\n                    _getLiquidationValuesNormalMode(_price, _TCR, vars, singleLiquidation);\n\n                    // Add liquidation values to their respective running totals\n                    totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n                }\n            }\n            ++vars.i;\n            if (vars.i == _cnt) {\n                break;\n            }\n        }\n    }\n\n    // --- Liquidation helper functions ---\n\n    function _addLiquidationValuesToTotals(\n        LiquidationTotals memory oldTotals,\n        LiquidationVa"
    }
  ]
}