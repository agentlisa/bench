{
  "Title": "Incorrect comment",
  "Content": "##### Description\nComment for this variable is incorrect:\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/core/AccountFactory.sol#L54\n##### Recommendation\nWe recommend changing the comment.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/AccountFactory.sol",
      "content": "// SPDX-License-Identifier: BSL-1.1\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\n// (c) Gearbox.fi, 2021\npragma solidity ^0.7.4;\npragma abicoder v2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {IAccountFactory} from \"../interfaces/IAccountFactory.sol\";\nimport {IAccountMiner} from \"../interfaces/IAccountMiner.sol\";\nimport {ICreditAccount} from \"../interfaces/ICreditAccount.sol\";\nimport {ICreditManager} from \"../interfaces/ICreditManager.sol\";\n\nimport {AddressProvider} from \"./AddressProvider.sol\";\nimport {ContractsRegister} from \"./ContractsRegister.sol\";\nimport {CreditAccount} from \"../credit/CreditAccount.sol\";\nimport {ACLTrait} from \"./ACLTrait.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {DataTypes} from \"../libraries/data/Types.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @title Abstract reusable credit accounts factory\n/// @notice Creates, holds & lend credit accounts to pool contract\ncontract AccountFactory is IAccountFactory, ACLTrait, ReentrancyGuard {\n    //\n    //     head\n    //      ⬇\n    //    -------       -------        -------        -------\n    //   |  VA1  | ->  |  VA2  |  ->  |  VA3  |  ->  |  VA4  |  ->  address(0)\n    //    -------       -------        -------        -------\n    //                                                   ⬆\n    //                                                  tail\n    //\n\n    // Credit accounts connected list\n    mapping(address => address) private _nextCreditAccount;\n\n    // Head on connected list\n    address public override head;\n\n    // Tail of connected list\n    address public override tail;\n\n    // Address of master credit account for cloning\n    address public masterCreditAccount;\n\n    // Credit accounts list\n    address[] public override creditAccounts;\n\n    // Credit accounts list\n    DataTypes.MiningApproval[] public miningApprovals;\n\n    // Contracts register\n    ContractsRegister public _contractsRegister;\n\n    // Flag that there is no mining yet\n    bool public isMiningFinished;\n\n    modifier creditManagerOnly() {\n        require(\n            _contractsRegister.isCreditManager(msg.sender),\n            Errors.CR_CREDIT_ACCOUNT_MANAGERS_ONLY\n        );\n        _;\n    }\n\n    /**\n     * @dev constructor\n     * After constructor the list should be as following\n     *\n     *     head\n     *      ⬇\n     *    -------\n     *   |  VA1  | ->   address(0)\n     *    -------\n     *      ⬆\n     *     tail\n     *\n     * @param addressProvider Address of address repository\n     */\n    constructor(address addressProvider) ACLTrait(addressProvider) {\n        _contractsRegister = ContractsRegister(\n            AddressProvider(addressProvider).getContractsRegister()\n        ); // T:[AF-1]\n\n        masterCreditAccount = address(new CreditAccount());\n\n        addCreditAccount(); // T:[AF-1]\n        head = tail; // T:[AF-1]\n    }\n\n    /**\n     * @dev Provides a new credit account to the pool. Creates a new one, if needed\n     *\n     *   Before:\n     *  ---------\n     *\n     *     head\n     *      ⬇\n     *    -------       -------        -------        -------\n     *   |  VA1  | ->  |  VA2  |  ->  |  VA3  |  ->  |  VA4  |  ->  address(0)\n     *    -------       -------        -------        -------\n     *                                                   ⬆\n     *                                                  tail\n     *\n     *   After:\n     *  ---------\n     *\n     *    head\n     *     ⬇\n     *   -------        -------        -------\n     *  |  VA2  |  ->  |  VA3  |  ->  |  VA4  |  ->  address(0)\n     *   -------        -------        -------\n     *                                    ⬆\n     *                                   tail\n     *\n     *\n     *   -------\n     *  |  VA1  |  ->  address(0)\n     *   -------\n     *\n     *  If had points the last credit account, it adds a new one\n     *\n     *    head\n     *     ⬇\n     *   -------\n     *  |  VA2  |  ->   address(0)     =>    _addNewCreditAccount()\n     *   -------\n     *     ⬆\n     *    tail\n     *\n     * @return Address of credit account\n     */\n    function takeCreditAccount()\n        external\n        override\n        creditManagerOnly // T:[AF-12]\n        returns (address)\n    {\n        // Create a new credit account if no one in stock\n        _checkStock(); // T:[AF-3]\n\n        address result = head;\n        head = _nextCreditAccount[head]; // T:[AF-2]\n        _nextCreditAccount[result] = address(0); // T:[AF-2]\n\n        // Initialize creditManager\n        ICreditAccount(result).connectTo(msg.sender); // T:[AF-11]\n\n        emit InitializeCreditAccount(result, msg.sender); // T:[AF-5]\n        return result; // T:[AF-14]\n    }\n\n    /**\n     * @dev Takes credit account back and adds it to the stock\n     *\n     *   Before:\n     *  ---------\n     *\n     *     head\n     *      ⬇\n     *    -------       -------        -------        -------\n     *   |  VA1  | ->  |  VA2  |  ->  |  VA3  |  ->  |  VA4  |  ->  address(0)\n     *    -------       -------        -------        -------\n     *                                                   ⬆\n     *                                                  tail\n     *\n     *   After:\n     *  ---------\n     *\n     *     head\n     *      ⬇\n     *    -------       -------        -------        -------       ---------------\n     *   |  VA1  | ->  |  VA2  |  ->  |  VA3  |  ->  |  VA4  |  -> |  usedAccount  |  ->  address(0)\n     *    -------       -------        -------        -------       ---------------\n     *                                                                     ⬆\n     *                                                                    tail\n     *\n     *\n     * @param usedAccount Address of used credit account\n     */\n    function returnCreditAccount(address usedAccount)\n        external\n        override\n        creditManagerOnly // T:[AF-12]\n    {\n        require(\n            ICreditAccount(usedAccount).since() != block.number,\n            Errors.AF_CANT_CLOSE_CREDIT_ACCOUNT_IN_THE_SAME_BLOCK\n        ); // T:[CM-20]\n\n        _nextCreditAccount[tail] = usedAccount; // T:[AF-7]\n        tail = usedAccount; // T:[AF-7]\n        emit ReturnCreditAccount(usedAccount); // T:[AF-8]\n    }\n\n    /// @dev Gets next available credit account or address(0) if you are in tail\n    function getNext(address creditAccount)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _nextCreditAccount[creditAccount];\n    }\n\n    /**\n     * @dev Deploys new credit account and adds it to list tail\n     *\n     *   Before:\n     *  ---------\n     *\n     *     head\n     *      ⬇\n     *    -------       -------        -------        -------\n     *   |  VA1  | ->  |  VA2  |  ->  |  VA3  |  ->  |  VA4  |  ->  address(0)\n     *    -------       -------        -------        -------\n     *                                                   ⬆\n     *                                                  tail\n     *\n     *   After:\n     *  ---------\n     *\n     *     head\n     *      ⬇\n     *    -------       -------        -------        -------       --------------\n     *   |  VA1  | ->  |  VA2  |  ->  |  VA3  |  ->  |  VA4  |  -> |  newAccount  |  ->  address(0)\n     *    -------       -------        -------        -------       --------------\n     *                                                                    ⬆\n     *                                                                   tail\n     *\n     *\n     */\n    function addCreditAccount() public {\n        address clonedAccount = Clones.clone(masterCreditAccount); // T:[AF-2]\n        ICreditAccount(clonedAccount).initialize();\n        _nextCreditAccount[tail] = clonedAccount; // T:[AF-2]\n        tail = clonedAccount; // T:[AF-2]\n        creditAccounts.push(clonedAccount); // T:[AF-10]\n        emit NewCreditAccount(clonedAccount);\n    }\n\n    /// @dev Takes unused credit account from list forever and connects it with \"to\" parameter\n    function takeOut(\n        address prev,\n        address creditAccount,\n        address to\n    )\n        external\n        configuratorOnly // T:[AF-13]\n    {\n        require(\n            _nextCreditAccount[prev] == creditAccount,\n            Errors.AF_CREDIT_ACCOUNT_NOT_IN_STOCK\n        ); // T:[AF-15]\n        _nextCreditAccount[prev] = _nextCreditAccount[creditAccount]; // T: [AF-16]\n        ICreditAccount(creditAccount).connectTo(to); // T: [AF-16]\n        emit TakeForever(creditAccount, to); // T: [AF-16]\n    }\n\n    ///\n    /// MINING\n    ///\n\n    /// @dev Adds credit account token to factory and provide approvals\n    /// for protocols & tokens which will be offered to accept by DAO\n    /// All protocols & tokens in the list should be non-upgradable contracts\n    /// Account mining will be finished before deployment any pools & credit managers\n    function mineCreditAccount() external nonReentrant {\n        require(!isMiningFinished, Errors.AF_MINING_IS_FINISHED); // T:[AF-17]\n        addCreditAccount(); // T:[AF-18]\n        ICreditAccount(tail).connectTo(address(this)); // T:[AF-18]\n        ICreditAccount(tail).setGenericParameters(1, 1); // T:[AF-18]\n        for (uint256 i = 0; i < miningApprovals.length; i++) {\n            ICreditAccount(tail).approveToken(\n                miningApprovals[i].token,\n                miningApprovals[i].swapContract\n            ); // T:[AF-18]\n        }\n    }\n\n    /// @dev Adds pair token-contract to initial mining approval list\n    /// These pairs will be used during accoutn mining which is designed\n    /// to reduce gas prices for the first N reusable credit accounts\n    function addMiningApprovals(\n        DataTypes.MiningApproval[] calldata _miningApprovals\n    )\n        external\n        configuratorOnly // T:[AF-13]\n    {\n        require(!isMiningFinished, Errors.AF_MINING_IS_FINISHED); // T:[AF-17]\n        for (uint256 i = 0; i < _miningApprovals.length; i++) {\n            DataTypes.MiningApproval memory item = DataTypes.MiningApproval(\n                _miningApprovals[i].token,\n                _miningApprovals[i].swapContract\n            ); // T:[AF-19]\n            miningApprovals.push(item); // T:[AF-19]\n        }\n    }\n\n    /// @dev Finishes mining activity. Account mining is desinged as one-time\n    /// activity and should be finished before deployment pools & credit managers.\n    function finishMining()\n        external\n        configuratorOnly // T:[AF-13]\n    {\n        isMiningFinished = true; // T:[AF-17]\n    }\n\n    /**\n     * @dev Checks available accounts in stock and deploys new one if there is the last one\n     *\n     *   If:\n     *  ---------\n     *\n     *     head\n     *      ⬇\n     *    -------\n     *   |  VA1  | ->   address(0)\n     *    -------\n     *      ⬆\n     *     tail\n     *\n     *   Then:\n     *  ---------\n     *\n     *     head\n     *      ⬇\n     *    -------       --------------\n     *   |  VA1  | ->  |  newAccount  |  ->  address(0)\n     *    -------       --------------\n     *                       ⬆\n     *                      tail\n     *\n     */\n    function _checkStock() internal {\n        // T:[AF-9]\n        if (_nextCreditAccount[head] == address(0)) {\n            addCreditAccount(); // T:[AF-3]\n        }\n    }\n\n    /// @dev Cancels allowance for particular contract\n    /// @param account Address of credit account to be cancelled allowance\n    /// @param token Address of token for allowance\n    /// @param targetContract Address of contract to cancel allowance\n    function cancelAllowance(\n        address account,\n        address token,\n        address targetContract\n    )\n        external\n        configuratorOnly // T:[AF-13]\n    {\n        ICreditAccount(account).cancelAllowance(token, targetContract); // T:[AF-20]\n    }\n\n    //\n    // GETTERS\n    //\n\n    /// @dev Counts how many credit accounts are in stock\n    function countCreditAccountsInStock()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 count = 0;\n        address pointer = head;\n        while (pointer != address(0)) {\n            pointer = _nextCreditAccount[pointer];\n            count++;\n        }\n        return count;\n    }\n\n    /// @dev Count of deployed credit accounts\n    function countCreditAccounts() external view override returns (uint256) {\n        return creditAccounts.length; // T:[AF-10]\n    }\n}"
    }
  ]
}