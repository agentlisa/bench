{
  "Title": "[N-01] Missing calls to base initializers in `rUSDY`",
  "Content": "\nhttps://github.com/code-423n4/2023-09-ondo/blob/main/contracts/usdy/rUSDY.sol#L120\n\nThe `__rUSDY_init()` function doesn't call the initializers for some of the base contracts:\n\n- `Initializable`\n- `ContextUpgradeable`\n- `PausableUpgradeable`\n- `AccessControlEnumerableUpgradeable`\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-ondo",
  "Code": [
    {
      "filename": "contracts/usdy/rUSDY.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20MetadataUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"contracts/usdy/blocklist/BlocklistClientUpgradeable.sol\";\nimport \"contracts/usdy/allowlist/AllowlistClientUpgradeable.sol\";\nimport \"contracts/sanctions/SanctionsListClientUpgradeable.sol\";\nimport \"contracts/interfaces/IUSDY.sol\";\nimport \"contracts/rwaOracles/IRWADynamicOracle.sol\";\n\n/**\n * @title Interest-bearing ERC20-like token for rUSDY.\n *\n * rUSDY balances are dynamic and represent the holder's share of the underlying USDY\n * controlled by the protocol. To calculate each account's balance, we do\n *\n *   shares[account] * usdyPrice\n *\n * For example, assume that we have:\n *\n *   usdyPrice = 1.05\n *   sharesOf(user1) -> 100\n *   sharesOf(user2) -> 400\n *\n * Therefore:\n *\n *   balanceOf(user1) -> 105 tokens which corresponds 105 rUSDY\n *   balanceOf(user2) -> 420 tokens which corresponds 420 rUSDY\n *\n * Since balances of all token holders change when the price of USDY changes, this\n * token cannot fully implement ERC20 standard: it only emits `Transfer` events\n * upon explicit transfer between holders. In contrast, when total amount of pooled\n * Cash increases, no `Transfer` events are generated: doing so would require emitting\n * an event for each token holder and thus running an unbounded loop.\n *\n */\n\ncontract rUSDY is\n  Initializable,\n  ContextUpgradeable,\n  PausableUpgradeable,\n  AccessControlEnumerableUpgradeable,\n  BlocklistClientUpgradeable,\n  AllowlistClientUpgradeable,\n  SanctionsListClientUpgradeable,\n  IERC20Upgradeable,\n  IERC20MetadataUpgradeable\n{\n  /**\n   * @dev rUSDY balances are dynamic and are calculated based on the accounts' shares (USDY)\n   * and the the price of USDY. Account shares aren't\n   * normalized, so the contract also stores the sum of all shares to calculate\n   * each account's token balance which equals to:\n   *\n   *   shares[account] * usdyPrice\n   */\n  mapping(address => uint256) private shares;\n\n  /// @dev Allowances are nominated in tokens, not token shares.\n  mapping(address => mapping(address => uint256)) private allowances;\n\n  // Total shares in existence\n  uint256 private totalShares;\n\n  // Address of the oracle that updates `usdyPrice`\n  IRWADynamicOracle public oracle;\n\n  // Address of the USDY token\n  IUSDY public usdy;\n\n  // Used to scale up usdy amount -> shares\n  uint256 public constant BPS_DENOMINATOR = 10_000;\n\n  // Error when redeeming shares < `BPS_DENOMINATOR`\n  error UnwrapTooSmall();\n\n  /// @dev Role based access control roles\n  bytes32 public constant USDY_MANAGER_ROLE = keccak256(\"ADMIN_ROLE\");\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant BURNER_ROLE = keccak256(\"BURN_ROLE\");\n  bytes32 public constant LIST_CONFIGURER_ROLE =\n    keccak256(\"LIST_CONFIGURER_ROLE\");\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(\n    address blocklist,\n    address allowlist,\n    address sanctionsList,\n    address _usdy,\n    address guardian,\n    address _oracle\n  ) public virtual initializer {\n    __rUSDY_init(blocklist, allowlist, sanctionsList, _usdy, guardian, _oracle);\n  }\n\n  function __rUSDY_init(\n    address blocklist,\n    address allowlist,\n    address sanctionsList,\n    address _usdy,\n    address guardian,\n    address _oracle\n  ) internal onlyInitializing {\n    __BlocklistClientInitializable_init(blocklist);\n    __AllowlistClientInitializable_init(allowlist);\n    __SanctionsListClientInitializable_init(sanctionsList);\n    __rUSDY_init_unchained(_usdy, guardian, _oracle);\n  }\n\n  function __rUSDY_init_unchained(\n    address _usdy,\n    address guardian,\n    address _oracle\n  ) internal onlyInitializing {\n    usdy = IUSDY(_usdy);\n    oracle = IRWADynamicOracle(_oracle);\n    _grantRole(DEFAULT_ADMIN_ROLE, guardian);\n    _grantRole(USDY_MANAGER_ROLE, guardian);\n    _grantRole(PAUSER_ROLE, guardian);\n    _grantRole(MINTER_ROLE, guardian);\n    _grantRole(BURNER_ROLE, guardian);\n    _grantRole(LIST_CONFIGURER_ROLE, guardian);\n  }\n\n  /**\n   * @notice An executed shares transfer from `sender` to `recipient`.\n   *\n   * @dev emitted in pair with an ERC20-defined `Transfer` event.\n   */\n  event TransferShares(\n    address indexed from,\n    address indexed to,\n    uint256 sharesValue\n  );\n\n  /**\n   * @notice An executed `burnShares` request\n   *\n   * @dev Reports simultaneously burnt shares amount\n   * and corresponding rUSDY amount.\n   * The shares amount is calculated twice: before and after the burning incurred rebase.\n   *\n   * @param account holder of the burnt shares\n   * @param preRebaseTokenAmount amount of rUSDY the burnt shares (USDY) corresponded to before the burn\n   * @param postRebaseTokenAmount amount of rUSDY the burnt shares (USDY) corresponded to after the burn\n   * @param sharesAmount amount of burnt shares\n   */\n  event SharesBurnt(\n    address indexed account,\n    uint256 preRebaseTokenAmount,\n    uint256 postRebaseTokenAmount,\n    uint256 sharesAmount\n  );\n\n  /**\n   * @notice An executed `burnShares` request\n   *\n   * @dev Reports simultaneously burnt shares amount\n   * and corresponding rUSDY amount.\n   * The rUSDY amount is calculated twice: before and after the burning incurred rebase.\n   *\n   * @param account holder of the burnt shares\n   * @param tokensBurnt amount of burnt tokens\n   */\n  event TokensBurnt(address indexed account, uint256 tokensBurnt);\n\n  /**\n   * @return the name of the token.\n   */\n  function name() public pure returns (string memory) {\n    return \"Rebasing Ondo U.S. Dollar Yield\";\n  }\n\n  /**\n   * @return the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public pure returns (string memory) {\n    return \"rUSDY\";\n  }\n\n  /**\n   * @return the number of decimals for getting user representation of a token amount.\n   */\n  function decimals() public pure returns (uint8) {\n    return 18;\n  }\n\n  /**\n   * @return the amount of tokens in existence.\n   */\n  function totalSupply() public view returns (uint256) {\n    return (totalShares * oracle.getPrice()) / (1e18 * BPS_DENOMINATOR);\n  }\n\n  /**\n   * @return the amount of tokens owned by the `_account`.\n   *\n   * @dev Balances are dynamic and equal the `_account`'s USDY shares multiplied\n   *      by the price of USDY\n   */\n  function balanceOf(address _account) public view returns (uint256) {\n    return (_sharesOf(_account) * oracle.getPrice()) / (1e18 * BPS_DENOMINATOR);\n  }\n\n  /**\n   * @notice Moves `_amount` tokens from the caller's account to the `_recipient` account.\n   *\n   * @return a boolean value indicating whether the operation succeeded.\n   * Emits a `Transfer` event.\n   * Emits a `TransferShares` event.\n   *\n   * Requirements:\n   *\n   * - `_recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `_amount`.\n   * - the contract must not be paused.\n   *\n   * @dev The `_amount` argument is the amount of tokens, not shares.\n   */\n  function transfer(address _recipient, uint256 _amount) public returns (bool) {\n    _transfer(msg.sender, _recipient, _amount);\n    return true;\n  }\n\n  /**\n   * @return the remaining number of tokens that `_spender` is allowed to spend\n   * on behalf of `_owner` through `transferFrom`. This is zero by default.\n   *\n   * @dev This value changes when `approve` or `transferFrom` is called.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n  ) public view returns (uint256) {\n    return allowances[_owner][_spender];\n  }\n\n  /**\n   * @notice Sets `_amount` as the allowance of `_spender` over the caller's tokens.\n   *\n   * @return a boolean value indicating whether the operation succeeded.\n   * Emits an `Approval` event.\n   *\n   * Requirements:\n   *\n   * - `_spender` cannot be the zero address.\n   * - the contract must not be paused.\n   *\n   * @dev The `_amount` argument is the amount of tokens, not shares.\n   */\n  function approve(address _spender, uint256 _amount) public returns (bool) {\n    _approve(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  /**\n   * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n   * allowance mechanism. `_amount` is then deducted from the caller's\n   * allowance.\n   *\n   * @return a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a `Transfer` event.\n   * Emits a `TransferShares` event.\n   * Emits an `Approval` event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `_sender` and `_recipient` cannot be the zero addresses.\n   * - `_sender` must have a balance of at least `_amount`.\n   * - the caller must have allowance for `_sender`'s tokens of at least `_amount`.\n   * - the contract must not be paused.\n   *\n   * @dev The `_amount` argument is the amount of tokens, not shares.\n   */\n  function transferFrom(\n    address _sender,\n    address _recipient,\n    uint256 _amount\n  ) public returns (bool) {\n    uint256 currentAllowance = allowances[_sender][msg.sender];\n    require(currentAllowance >= _amount, \"TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE\");\n\n    _transfer(_sender, _recipient, _amount);\n    _approve(_sender, msg.sender, currentAllowance - _amount);\n    return true;\n  }\n\n  /**\n   * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n   *\n   * This is an alternative to `approve` that can be used as a mitigation for\n   * problems described in:\n   * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n   * Emits an `Approval` event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `_spender` cannot be the the zero address.\n   * - the contract must not be paused.\n   */\n  function increaseAllowance(\n    address _spender,\n    uint256 _addedValue\n  ) public returns (bool) {\n    _approve(\n      msg.sender,\n      _spender,\n      allowances[msg.sender][_spender] + _addedValue\n    );\n    return true;\n  }\n\n  /**\n   * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n   *\n   * This is an alternative to `approve` that can be used as a mitigation for\n   * problems described in:\n   * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n   * Emits an `Approval` event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `_spender` cannot be the zero address.\n   * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n   * - the contract must not be paused.\n   */\n  function decreaseAllowance(\n    address _spender,\n    uint256 _subtractedValue\n  ) public returns (bool) {\n    uint256 currentAllowance = allowances[msg.sender][_spender];\n    require(\n      currentAllowance >= _subtractedValue,\n      \"DECREASED_ALLOWANCE_BELOW_ZERO\"\n    );\n    _approve(msg.sender, _spender, currentAllowance - _subtractedValue);\n    return true;\n  }\n\n  /**\n   * @return the total amount of shares in existence.\n   *\n   * @dev The sum of all accounts' shares can be an arbitrary number, therefore\n   * it is necessary to store it in order to calculate each account's relative share.\n   */\n  function getTotalShares() public view returns (uint256) {\n    return totalShares;\n  }\n\n  /**\n   * @return the amount of shares owned by `_account`.\n   *\n   * @dev This is the equivalent to the amount of USDY wrapped by `_account`.\n   */\n  function sharesOf(address _account) public view returns (uint256) {\n    return _sharesOf(_account);\n  }\n\n  /**\n   * @return the amount of USDY that corresponds to `_rUSDYAmount` of rUSDY\n   */\n  function getSharesByRUSDY(\n    uint256 _rUSDYAmount\n  ) public view returns (uint256) {\n    return (_rUSDYAmount * 1e18 * BPS_DENOMINATOR) / oracle.getPrice();\n  }\n\n  /**\n   * @return the amount of rUSDY that corresponds to `_shares` of usdy.\n   */\n  function getRUSDYByShares(uint256 _shares) public view returns (uint256) {\n    return (_shares * oracle.getPrice()) / (1e18 * BPS_DENOMINATOR);\n  }\n\n  /**\n   * @notice Moves `_sharesAmount` token shares from the caller's account to the `_recipient` account.\n   *\n   * @return amount of transferred tokens.\n   * Emits a `TransferShares` event.\n   * Emits a `Transfer` event.\n   *\n   * Requirements:\n   *\n   * - `_recipient` cannot be the zero address.\n   * - the caller must have at least `_sharesAmount` shares.\n   * - the contract must not be paused.\n   *\n   * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n   */\n  function transferShares(\n    address _recipient,\n    uint256 _sharesAmount\n  ) public returns (uint256) {\n    _transferShares(msg.sender, _recipient, _sharesAmount);\n    emit TransferShares(msg.sender, _recipient, _sharesAmount);\n    uint256 tokensAmount = getRUSDYByShares(_sharesAmount);\n    emit Transfer(msg.sender, _recipient, tokensAmount);\n    return tokensAmount;\n  }\n\n  /**\n   * @notice Function called by users to wrap their USDY tokens\n   *\n   * @param _USDYAmount The amount of USDY Tokens to wrap\n   *\n   * @dev Sanctions, Blocklist, and Allowlist checks implicit in USDY Transfer\n   */\n  function wrap(uint256 _USDYAmount) external whenNotPaused {\n    require(_USDYAmount > 0, \"rUSDY: can't wrap zero USDY tokens\");\n    _mintShares(msg.sender, _USDYAmount * BPS_DENOMINATOR);\n    usdy.transferFrom(msg.sender, address(this), _USDYAmount);\n    emit Transfer(address(0), msg.sender, getRUSDYByShares(_USDYAmount));\n    emit TransferShares(address(0), msg.sender, _USDYAmount);\n  }\n\n  /**\n   * @notice Function called by users to unwrap their rUSDY tokens\n   *\n   * @param _rUSDYAmount The amount of rUSDY to unwrap\n   *\n   * @dev Sanctions, Blocklist, and Allowlist checks implicit in USDY Transfer\n   */\n  function unwrap(uint256 _rUSDYAmount) external whenNotPaused {\n    require(_rUSDYAmount > 0, \"rUSDY: can't unwrap zero rUSDY tokens\");\n    uint256 usdyAmount = getSharesByRUSDY(_rUSDYAmount);\n    if (usdyAmount < BPS_DENOMINATOR) revert UnwrapTooSmall();\n    _burnShares(msg.sender, usdyAmount);\n    usdy.transfer(msg.sender, usdyAmount / BPS_DENOMINATOR);\n    emit TokensBurnt(msg.sender, _rUSDYAmount);\n  }\n\n  /**\n   * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n   * Emits a `Transfer` event.\n   * Emits a `TransferShares` event.\n   */\n  function _transfer(\n    address _sender,\n    address _recipient,\n    uint256 _amount\n  ) internal {\n    uint256 _sharesToTransfer = getSharesByRUSDY(_amount);\n    _transferShares(_sender, _recipient, _sharesToTransfer);\n    emit Transfer(_sender, _recipient, _amount);\n    emit TransferShares(_sender, _recipient, _sharesToTransfer);\n  }\n\n  /**\n   * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n   *\n   * Emits an `Approval` event.\n   *\n   * Requirements:\n   *\n   * - `_owner` cannot be the zero address.\n   * - `_spender` cannot be the zero address.\n   * - the contract must not be paused.\n   */\n  function _approve(\n    address _owner,\n    address _spender,\n    uint256 _amount\n  ) internal whenNotPaused {\n    require(_owner != address(0), \"APPROVE_FROM_ZERO_ADDRESS\");\n    require(_spender != address(0), \"APPROVE_TO_ZERO_ADDRESS\");\n\n    allowances[_owner][_spender] = _amount;\n    emit Approval(_owner, _spender, _amount);\n  }\n\n  /**\n   * @return the amount of shares owned by `_account`.\n   */\n  function _sharesOf(address _account) internal view returns (uint256) {\n    return shares[_account];\n  }\n\n  /**\n   * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n   *\n   * Requirements:\n   *\n   * - `_sender` cannot be the zero address.\n   * - `_recipient` cannot be the zero address.\n   * - `_sender` must hold at least `_sharesAmount` shares.\n   * - the contract must not be paused.\n   */\n  function _transferShares(\n    address _sender,\n    address _recipient,\n    uint256 _sharesAmount\n  ) internal whenNotPaused {\n    require(_sender != address(0), \"TRANSFER_FROM_THE_ZERO_ADDRESS\");\n    require(_recipient != address(0), \"TRANSFER_TO_THE_ZERO_ADDRESS\");\n\n    _beforeTokenTransfer(_sender, _recipient, _sharesAmount);\n\n    uint256 currentSenderShares = shares[_sender];\n    require(\n      _sharesAmount <= currentSenderShares,\n      \"TRANSFER_AMOUNT_EXCEEDS_BALANCE\"\n    );\n\n    shares[_sender] = currentSenderShares - _sharesAmount;\n    shares[_recipient] = shares[_recipient] + _sharesAmount;\n  }\n\n  /**\n   * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n   * @dev This doesn't increase the token total supply.\n   *\n   * Requirements:\n   *\n   * - `_recipient` cannot be the zero address.\n   * - the contract must not be paused.\n   */\n  function _mintShares(\n    address _recipient,\n    uint256 _sharesAmount\n  ) internal whenNotPaused returns (uint256) {\n    require(_recipient != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n\n    _beforeTokenTransfer(address(0), _recipient, _sharesAmount);\n\n    totalShares += _sharesAmount;\n\n    shares[_recipient] = shares[_recipient] + _sharesAmount;\n\n    return totalShares;\n\n    // Notice: we're not emitting a Transfer event from the zero address here since shares mint\n    // works by taking the amount of tokens corresponding to the minted shares from all other\n    // token holders, proportionally to their share. The total supply of the token doesn't change\n    // as the result. This is equivalent to performing a send from each other token holder's\n    // address to `address`, but we cannot reflect this as it would require sending an unbounded\n    // number of events.\n  }\n\n  /**\n   * @notice Destroys `_sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\n   * @dev This doesn't decrease the token total supply.\n   *\n   * Requirements:\n   *\n   * - `_account` cannot be the zero address.\n   * - `_account` must hold at least `_sharesAmount` shares.\n   * - the contract must not be paused.\n   */\n  function _burnShares(\n    address _account,\n    uint256 _sharesAmount\n  ) internal whenNotPaused returns (uint256) {\n    require(_account != address(0), \"BURN_FROM_THE_ZERO_ADDRESS\");\n\n    _beforeTokenTransfer(_account, address(0), _sharesAmount);\n\n    uint256 accountShares = shares[_account];\n    require(_sharesAmount <= accountShares, \"BURN_AMOUNT_EXCEEDS_BALANCE\");\n\n    uint256 preRebaseTokenAmount = getRUSDYByShares(_sharesAmount);\n\n    totalShares -= _sharesAmount;\n\n    shares[_account] = accountShares - _sharesAmount;\n\n    uint256 postRebaseTokenAmount = getRUSDYByShares(_sharesAmount);\n\n    emit SharesBurnt(\n      _account,\n      preRebaseTokenAmount,\n      postRebaseTokenAmount,\n      _sharesAmount\n    );\n\n    return totalShares;\n\n    // Notice: we're not emitting a Transfer event to the zero address here since shares burn\n    // works by redistributing the amount of tokens corresponding to the burned shares between\n    // all other token holders. The total supply of the token doesn't change as the result.\n    // This is equivalent to performing a send from `address` to each other token holder address,\n    // but we cannot reflect this as it would require sending an unbounded number of events.\n\n    // We're emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256\n  ) internal view {\n    // Check constraints when `transferFrom` is called to facliitate\n    // a transfer between two parties that are not `from` or `to`.\n    if (from != msg.sender && to != msg.sender) {\n      require(!_isBlocked(msg.sender), \"rUSDY: 'sender' address blocked\");\n      require(!_isSanctioned(msg.sender), \"rUSDY: 'sender' address sanctioned\");\n      require(\n        _isAllowed(msg.sender),\n        \"rUSDY: 'sender' address not on allowlist\"\n      );\n    }\n\n    if (from != address(0)) {\n      // If not minting\n      require(!_isBlocked(from), \"rUSDY: 'from' address blocked\");\n      require(!_isSanctioned(from), \"rUSDY: 'from' address sanctioned\");\n      require(_isAllowed(from), \"rUSDY: 'from' address not on allowlist\");\n    }\n\n    if (to != address(0)) {\n      // If not burning\n      require(!_isBlocked(to), \"rUSDY: 'to' address blocked\");\n      require(!_isSanctioned(to), \"rUSDY: 'to' address sanctioned\");\n      require(_isAllowed(to), \"rUSDY: 'to' address not on allowlist\");\n    }\n  }\n\n  /**\n   * @notice Sets the Oracle address\n   * @dev The new oracle must comply with the `IPricerReader` interface\n   * @param _oracle Address of the new oracle\n   */\n  function setOracle(address _oracle) external onlyRole(USDY_MANAGER_ROLE) {\n    oracle = IRWADynamicOracle(_oracle);\n  }\n\n  /**\n   * @notice Admin burn function to burn rUSDY tokens from any account\n   * @param _account The account to burn tokens from\n   * @param _amount  The amount of rUSDY tokens to burn\n   * @dev Transfers burned shares (USDY) to `msg.sender`\n   */\n  function burn(\n    address _account,\n    uint256 _amount\n  ) external onlyRole(BURNER_ROLE) {\n    uint256 sharesAmount = getSharesByRUSDY(_amount);\n\n    _burnShares(_account, sharesAmount);\n\n    usdy.transfer(msg.sender, sharesAmount / BPS_DENOMINATOR);\n\n    emit TokensBurnt(_account, _amount);\n  }\n\n  function pause() external onlyRole(PAUSER_ROLE) {\n    _pause();\n  }\n\n  function unpause() external onlyRole(USDY_MANAGER_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Sets the blocklist address\n   *\n   * @param blocklist New blocklist address\n   */\n  function setBlocklist(\n    address blocklist\n  ) external override onlyRole(LIST_CONFIGURER_ROLE) {\n    _setBlocklist(blocklist);\n  }\n\n  /**\n   * @notice Sets the allowlist address\n   *\n   * @param allowlist New allowlist address\n   */\n  function setAllowlist(\n    address allowlist\n  ) external override onlyRole(LIST_CONFIGURER_ROLE) {\n    _setAllowlist(allowlist);\n  }\n\n  /**\n   * @notice Sets the sanctions list address\n   *\n   * @param sanctionsList New sanctions list address\n   */\n  function setSanctionsList(\n    address sanctionsList\n  ) external override onlyRole(LIST_CONFIGURER_ROLE) {\n    _setSanctionsList(sanctionsList);\n  }\n}"
    }
  ]
}