{
  "Title": "Lack of Expiration for Retrying Transactions",
  "Content": "The `L1ScrollMessenger` contract provides a [mechanism to retry failed transactions](https://github.com/scroll-tech/scroll/blob/2eb458cf4224d82fc56254e91e297a9ed261cefb/contracts/src/L1/L1ScrollMessenger.sol#L175) from L1 to L2 at any time. Therefore, if a user creates an L1 to L2 transaction and it fails, it can be retried indefinitely at a later time. A scenario could occur where a user erroneously sends an L1 to L2 transaction, which fails at the L2 level. The user may be inclined to send another transaction, which would succeed at the L2 level. However, a malicious recipient could later retry the user's first transaction against their will, which could succeed.\n\n\nMore generally, if a transaction is sent from L1 to L2 and fails, it can be retried indefinitely at a later time. Consider adding an expiration time to replay failed transactions, limiting the timeframe during which a failed transaction can be retried.\n\n\n***Update:** Partially resolved in [pull request #840](https://github.com/scroll-tech/scroll/pull/840) at commit [0d7d73f](https://github.com/scroll-tech/scroll/pull/840/commits/0d7d73ff1a6e463d58efe2073d1dbd590f5da0f1). The `L1ScrollMessenger` and `L2ScrollMessenger` contracts were updated to store the timestamp of when the message was sent. However, checking for expiration was not implemented. The Scroll team stated:*\n\n\n\n> *Only the timestamp is added for each message, the expiration check will be added together with the refund feature.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/L1ScrollMessenger.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.16;\n\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IScrollChain} from \"./rollup/IScrollChain.sol\";\nimport {IL1MessageQueue} from \"./rollup/IL1MessageQueue.sol\";\nimport {IL1ScrollMessenger} from \"./IL1ScrollMessenger.sol\";\nimport {ScrollConstants} from \"../libraries/constants/ScrollConstants.sol\";\nimport {IScrollMessenger} from \"../libraries/IScrollMessenger.sol\";\nimport {ScrollMessengerBase} from \"../libraries/ScrollMessengerBase.sol\";\nimport {AddressAliasHelper} from \"../libraries/common/AddressAliasHelper.sol\";\nimport {WithdrawTrieVerifier} from \"../libraries/verifier/WithdrawTrieVerifier.sol\";\n\nimport {IMessageDropCallback} from \"../libraries/callbacks/IMessageDropCallback.sol\";\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable reason-string\n\n/// @title L1ScrollMessenger\n/// @notice The `L1ScrollMessenger` contract can:\n///\n/// 1. send messages from layer 1 to layer 2;\n/// 2. relay messages from layer 2 layer 1;\n/// 3. replay failed message by replacing the gas limit;\n/// 4. drop expired message due to sequencer problems.\n///\n/// @dev All deposited Ether (including `WETH` deposited throng `L1WETHGateway`) will locked in\n/// this contract.\ncontract L1ScrollMessenger is PausableUpgradeable, ScrollMessengerBase, IL1ScrollMessenger {\n    /***********\n     * Structs *\n     ***********/\n\n    struct ReplayState {\n        // The number of replayed times.\n        uint128 times;\n        // The queue index of lastest replayed one. If it is zero, it means the message has not been replayed.\n        uint128 lastIndex;\n    }\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice Mapping from L1 message hash to sent status.\n    mapping(bytes32 => bool) public isL1MessageSent;\n\n    /// @notice Mapping from L2 message hash to a boolean value indicating if the message has been successfully executed.\n    mapping(bytes32 => bool) public isL2MessageExecuted;\n\n    /// @notice Mapping from L1 message hash to drop status.\n    mapping(bytes32 => bool) public isL1MessageDropped;\n\n    /// @notice The address of Rollup contract.\n    address public rollup;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public messageQueue;\n\n    /// @notice The maximum number of times each L1 message can be replayed.\n    uint256 public maxReplayTimes;\n\n    /// @notice Mapping from L1 message hash to replay state.\n    mapping(bytes32 => ReplayState) public replayStates;\n\n    /// @notice Mapping from queue index to previous replay queue index.\n    ///\n    /// @dev If a message `x` was replayed 3 times with index `q1`, `q2` and `q3`, the\n    /// value of `prevReplayIndex` and `replayStates` will be `replayStates[hash(x)].lastIndex = q3`,\n    /// `replayStates[hash(x)].times = 3`, `prevReplayIndex[q3] = q2`, `prevReplayIndex[q2] = q1`,\n    /// `prevReplayIndex[q1] = x` and `prevReplayIndex[x]=nil`.\n    ///\n    /// @dev The index `x` that `prevReplayIndex[x]=nil` is used as the termination of the list.\n    /// Usually we use `0` to represent `nil`, but we cannot distinguish it with the first message\n    /// with index zero. So a nonzero offset `1` is added to the value of `prevReplayIndex[x]` to\n    /// avoid such situation.\n    mapping(uint256 => uint256) public prevReplayIndex;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @notice Initialize the storage of L1ScrollMessenger.\n    /// @param _counterpart The address of L2ScrollMessenger contract in L2.\n    /// @param _feeVault The address of fee vault, which will be used to collect relayer fee.\n    /// @param _rollup The address of ScrollChain contract.\n    /// @param _messageQueue The address of L1MessageQueue contract.\n    function initialize(\n        address _counterpart,\n        address _feeVault,\n        address _rollup,\n        address _messageQueue\n    ) public initializer {\n        PausableUpgradeable.__Pausable_init();\n        ScrollMessengerBase._initialize(_counterpart, _feeVault);\n\n        rollup = _rollup;\n        messageQueue = _messageQueue;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, msg.sender);\n    }\n\n    /// @inheritdoc IScrollMessenger\n    function sendMessage(\n        address _to,\n        uint256 _value,\n        bytes calldata _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused {\n        _sendMessage(_to, _value, _message, _gasLimit, _refundAddress);\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _nonce,\n        bytes memory _message,\n        L2MessageProof memory _proof\n    ) external override whenNotPaused notInExecution {\n        bytes32 _xDomainCalldataHash = keccak256(_encodeXDomainCalldata(_from, _to, _value, _nonce, _message));\n        require(!isL2MessageExecuted[_xDomainCalldataHash], \"Message was already successfully executed\");\n\n        {\n            address _rollup = rollup;\n            require(IScrollChain(_rollup).isBatchFinalized(_proof.batchIndex), \"Batch is not finalized\");\n            bytes32 _messageRoot = IScrollChain(_rollup).withdrawRoots(_proof.batchIndex);\n            require(\n                WithdrawTrieVerifier.verifyMerkleProof(_messageRoot, _xDomainCalldataHash, _nonce, _proof.merkleProof),\n                \"Invalid proof\"\n            );\n        }\n\n        // @note check more `_to` address to avoid attack in the future when we add more gateways.\n        require(_to != messageQueue, \"Forbid to call message queue\");\n        require(_to != address(this), \"Forbid to call self\");\n\n        // @note This usually will never happen, just in case.\n        require(_from != xDomainMessageSender, \"Invalid message sender\");\n\n        xDomainMessageSender = _from;\n        (bool success, ) = _to.call{value: _value}(_message);\n        // reset value to refund gas.\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n\n        if (success) {\n            isL2MessageExecuted[_xDomainCalldataHash] = true;\n            emit RelayedMessage(_xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(_xDomainCalldataHash);\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function replayMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message,\n        uint32 _newGasLimit,\n        address _refundAddress\n    ) external payable override whenNotPaused notInExecution {\n        // We will use a different `queueIndex` for the replaced message. However, the original `queueIndex` or `nonce`\n        // is encoded in the `_message`. We will check the `xDomainCalldata` in layer 2 to avoid duplicated execution.\n        // So, only one message will succeed in layer 2. If one of the message is executed successfully, the other one\n        // will revert with \"Message was already successfully executed\".\n        address _messageQueue = messageQueue;\n        address _counterpart = counterpart;\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        require(isL1MessageSent[_xDomainCalldataHash], \"Provided message has not been enqueued\");\n        // cannot replay dropped message\n        require(!isL1MessageDropped[_xDomainCalldataHash], \"Message already dropped\");\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(_messageQueue).estimateCrossDomainMessageFee(_newGasLimit);\n\n        // charge relayer fee\n        require(msg.value >= _fee, \"Insufficient msg.value for fee\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // enqueue the new transaction\n        uint256 _nextQueueIndex = IL1MessageQueue(_messageQueue).nextCrossDomainMessageIndex();\n        IL1MessageQueue(_messageQueue).appendCrossDomainMessage(_counterpart, _newGasLimit, _xDomainCalldata);\n\n        ReplayState memory _replayState = replayStates[_xDomainCalldataHash];\n        // update the replayed message chain.\n        unchecked {\n            if (_replayState.lastIndex == 0) {\n                // the message has not been replayed before.\n                prevReplayIndex[_nextQueueIndex] = _messageNonce + 1;\n            } else {\n                prevReplayIndex[_nextQueueIndex] = _replayState.lastIndex + 1;\n            }\n        }\n        _replayState.lastIndex = uint128(_nextQueueIndex);\n\n        // update replay times\n        require(_replayState.times < maxReplayTimes, \"Exceed maximum replay times\");\n        unchecked {\n            _replayState.times += 1;\n        }\n        replayStates[_xDomainCalldataHash] = _replayState;\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n\n    /// @inheritdoc IL1ScrollMessenger\n    function dropMessage(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _messageNonce,\n        bytes memory _message\n    ) external override whenNotPaused notInExecution {\n        // The criteria for dropping a message:\n        // 1. The message is a L1 message.\n        // 2. The message has not been dropped before.\n        // 3. the message and all of its replacement are finalized in L1.\n        // 4. the message and all of its replacement are skipped.\n        //\n        // Possible denial of service attack:\n        // + replayMessage is called every time someone want to drop the message.\n        // + replayMessage is called so many times for a skipped message, thus results a long list.\n        //\n        // We limit the number of `replayMessage` calls of each message, which may solve the above problem.\n\n        address _messageQueue = messageQueue;\n\n        // check message exists\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(_from, _to, _value, _messageNonce, _message);\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n        require(isL1MessageSent[_xDomainCalldataHash], \"Provided message has not been enqueued\");\n\n        // check message not dropped\n        require(!isL1MessageDropped[_xDomainCalldataHash], \"Message already dropped\");\n\n        // check message is finalized\n        uint256 _lastIndex = replayStates[_xDomainCalldataHash].lastIndex;\n        if (_lastIndex == 0) _lastIndex = _messageNonce;\n\n        // check message is skipped and drop it.\n        // @note If the list is very long, the message may never be dropped.\n        while (true) {\n            IL1MessageQueue(_messageQueue).dropCrossDomainMessage(_lastIndex);\n            _lastIndex = prevReplayIndex[_lastIndex];\n            if (_lastIndex == 0) break;\n            unchecked {\n                _lastIndex = _lastIndex - 1;\n            }\n        }\n\n        isL1MessageDropped[_xDomainCalldataHash] = true;\n\n        // set execution context\n        xDomainMessageSender = ScrollConstants.DROP_XDOMAIN_MESSAGE_SENDER;\n        IMessageDropCallback(_from).onDropMessage{value: _value}(_message);\n        // clear execution context\n        xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Pause the contract\n    /// @dev This function can only called by contract owner.\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /// @notice Update max replay times.\n    /// @dev This function can only called by contract owner.\n    /// @param _maxReplayTimes The new max replay times.\n    function updateMaxReplayTimes(uint256 _maxReplayTimes) external onlyOwner {\n        maxReplayTimes = _maxReplayTimes;\n\n        emit UpdateMaxReplayTimes(_maxReplayTimes);\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _sendMessage(\n        address _to,\n        uint256 _value,\n        bytes memory _message,\n        uint256 _gasLimit,\n        address _refundAddress\n    ) internal nonReentrant {\n        address _messageQueue = messageQueue; // gas saving\n        address _counterpart = counterpart; // gas saving\n\n        // compute the actual cross domain message calldata.\n        uint256 _messageNonce = IL1MessageQueue(_messageQueue).nextCrossDomainMessageIndex();\n        bytes memory _xDomainCalldata = _encodeXDomainCalldata(msg.sender, _to, _value, _messageNonce, _message);\n\n        // compute and deduct the messaging fee to fee vault.\n        uint256 _fee = IL1MessageQueue(_messageQueue).estimateCrossDomainMessageFee(_gasLimit);\n        require(msg.value >= _fee + _value, \"Insufficient msg.value\");\n        if (_fee > 0) {\n            (bool _success, ) = feeVault.call{value: _fee}(\"\");\n            require(_success, \"Failed to deduct the fee\");\n        }\n\n        // append message to L1MessageQueue\n        IL1MessageQueue(_messageQueue).appendCrossDomainMessage(_counterpart, _gasLimit, _xDomainCalldata);\n\n        // record the message hash for future use.\n        bytes32 _xDomainCalldataHash = keccak256(_xDomainCalldata);\n\n        // normally this won't happen, since each message has different nonce, but just in case.\n        require(!isL1MessageSent[_xDomainCalldataHash], \"Duplicated message\");\n        isL1MessageSent[_xDomainCalldataHash] = true;\n\n        emit SentMessage(msg.sender, _to, _value, _messageNonce, _gasLimit, _message);\n\n        // refund fee to `_refundAddress`\n        unchecked {\n            uint256 _refund = msg.value - _fee - _value;\n            if (_refund > 0) {\n                (bool _success, ) = _refundAddress.call{value: _refund}(\"\");\n                require(_success, \"Failed to refund the fee\");\n            }\n        }\n    }\n}"
    }
  ]
}