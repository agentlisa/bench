{
  "Title": "[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10\nhttps://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76\nhttps://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92\nhttps://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105\n\n\n# Vulnerability details\n\n## Impact\nThe `Lock` contract ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10)) allows end-users to interact with bonds.  \n\nThere are two functions that allow to lock some amount of assets. The first function is `Lock.lock` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76)) which creates a new bond. The second function is `Lock.extendLock` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92)). This function extends the lock for some `_period` and / or increases the locked amount by some `_amount`.  \n\nThe issue is that the `Lock.extendLock` function does not increase the value in `totalLocked[_asset]`. This however is necessary because `totalLocked[_asset]` is reduced when `Lock.release` ([https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105)) is called.  \n\nTherefore only the amount of assets deposited via `Lock.lock` can be released again. The amount of assets deposited using `Lock.extendLock` can never be released again because reducing `totalLocked[_asset]` will cause a revert due to underflow.  \n\nSo the amount of assets deposited using `Lock.extendLock` is lost.  \n\n## Proof of Concept\n1. User A calls `Lock.lock` to lock a certain `_amount` (amount1) of `_asset` for a certain `_period`.\n2. User A calls then `Lock.extendLock` and increases the locked amount of the bond by some amount2\n3. User A waits until the bond has expired\n4. User A calls `Lock.release`. This function calculates `totalLocked[asset] -= lockAmount;`. Which will cause a revert because the value of `totalLocked[asset]` is only amount1\n\nYou can add the following test to the `Bonds` test in `Bonds.js`:  \n```javascript\ndescribe(\"ReleaseUnderflow\", function () {\n    it(\"release can cause underflow\", async function () {\n        await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther(\"110\"));\n        // Lock 100 for 9 days\n        await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther(\"100\"), 9);\n\n        await bond.connect(owner).setManager(lock.address);\n\n        await stabletoken.connect(user).approve(lock.address, ethers.utils.parseEther(\"10\"));\n\n        // Lock another 10\n        await lock.connect(user).extendLock(1, ethers.utils.parseEther(\"10\"), 0);\n\n        await network.provider.send(\"evm_increaseTime\", [864000]); // Skip 10 days\n        await network.provider.send(\"evm_mine\");\n\n        // Try to release 110 after bond has expired -> Underflow\n        await lock.connect(user).release(1);\n    });\n});\n```\nRun it with `npx hardhat test --grep \"release can cause underflow\"`.  \nYou can see that it fails because it causes an underflow.  \n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nAdd `totalLocked[_asset] += amount` to the `Lock.extendLock` function.  ",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-12-tigris-trade-contest",
  "Code": [
    {
      "filename": "contracts/Lock.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IBondNFT.sol\";\nimport \"./interfaces/IGovNFT.sol\";\n\ncontract Lock is Ownable{\n\n    uint public constant minPeriod = 7;\n    uint public constant maxPeriod = 365;\n\n    IBondNFT public immutable bondNFT;\n    IGovNFT public immutable govNFT;\n\n    mapping(address => bool) public allowedAssets;\n    mapping(address => uint) public totalLocked;\n\n    constructor(\n        address _bondNFTAddress,\n        address _govNFT\n    ) {\n        bondNFT = IBondNFT(_bondNFTAddress);\n        govNFT = IGovNFT(_govNFT);\n    }\n\n    /**\n     * @notice Claim pending rewards from a bond\n     * @param _id Bond NFT id\n     * @return address claimed tigAsset address\n     */\n    function claim(\n        uint256 _id\n    ) public returns (address) {\n        claimGovFees();\n        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);\n        IERC20(_tigAsset).transfer(msg.sender, _amount);\n        return _tigAsset;\n    }\n\n    /**\n     * @notice Claim pending rewards left over from a bond transfer\n     * @param _tigAsset token address being claimed\n     */\n    function claimDebt(\n        address _tigAsset\n    ) external {\n        claimGovFees();\n        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);\n        IERC20(_tigAsset).transfer(msg.sender, amount);\n    }\n\n    /**\n     * @notice Lock up tokens to create a bond\n     * @param _asset tigAsset being locked\n     * @param _amount tigAsset amount\n     * @param _period number of days to be locked for\n     */\n    function lock(\n        address _asset,\n        uint _amount,\n        uint _period\n    ) public {\n        require(_period <= maxPeriod, \"MAX PERIOD\");\n        require(_period >= minPeriod, \"MIN PERIOD\");\n        require(allowedAssets[_asset], \"!asset\");\n\n        claimGovFees();\n\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        totalLocked[_asset] += _amount;\n        \n        bondNFT.createLock( _asset, _amount, _period, msg.sender);\n    }\n\n    /**\n     * @notice Reset the lock time and extend the period and/or token amount\n     * @param _id Bond id being extended\n     * @param _amount tigAsset amount being added\n     * @param _period number of days being added\n     */\n    function extendLock(\n        uint _id,\n        uint _amount,\n        uint _period\n    ) public {\n        address _asset = claim(_id);\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);\n    }\n\n    /**\n     * @notice Release the bond once it's expired\n     * @param _id Bond id being released\n     */\n    function release(\n        uint _id\n    ) public {\n        claimGovFees();\n        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);\n        totalLocked[asset] -= lockAmount;\n        IERC20(asset).transfer(_owner, amount);\n    }\n\n    /**\n     * @notice Claim rewards from gov nfts and distribute them to bonds\n     */\n    function claimGovFees() public {\n        address[] memory assets = bondNFT.getAssets();\n\n        for (uint i=0; i < assets.length; i++) {\n            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n            IGovNFT(govNFT).claim(assets[i]);\n            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);\n            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);\n        }\n    }\n\n    /**\n     * @notice Whitelist an asset\n     * @param _tigAsset tigAsset token address\n     * @param _isAllowed set tigAsset as allowed\n     */\n    function editAsset(\n        address _tigAsset,\n        bool _isAllowed\n    ) external onlyOwner() {\n        allowedAssets[_tigAsset] = _isAllowed;\n    }\n\n    /**\n     * @notice Owner can retreive Gov NFTs\n     * @param _ids array of gov nft ids\n     */\n    function sendNFTs(\n        uint[] memory _ids\n    ) external onlyOwner() {\n        govNFT.safeTransferMany(msg.sender, _ids);\n    }\n}"
    },
    {
      "filename": "contracts/Lock.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IBondNFT.sol\";\nimport \"./interfaces/IGovNFT.sol\";\n\ncontract Lock is Ownable{\n\n    uint public constant minPeriod = 7;\n    uint public constant maxPeriod = 365;\n\n    IBondNFT public immutable bondNFT;\n    IGovNFT public immutable govNFT;\n\n    mapping(address => bool) public allowedAssets;\n    mapping(address => uint) public totalLocked;\n\n    constructor(\n        address _bondNFTAddress,\n        address _govNFT\n    ) {\n        bondNFT = IBondNFT(_bondNFTAddress);\n        govNFT = IGovNFT(_govNFT);\n    }\n\n    /**\n     * @notice Claim pending rewards from a bond\n     * @param _id Bond NFT id\n     * @return address claimed tigAsset address\n     */\n    function claim(\n        uint256 _id\n    ) public returns (address) {\n        claimGovFees();\n        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);\n        IERC20(_tigAsset).transfer(msg.sender, _amount);\n        return _tigAsset;\n    }\n\n    /**\n     * @notice Claim pending rewards left over from a bond transfer\n     * @param _tigAsset token address being claimed\n     */\n    function claimDebt(\n        address _tigAsset\n    ) external {\n        claimGovFees();\n        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);\n        IERC20(_tigAsset).transfer(msg.sender, amount);\n    }\n\n    /**\n     * @notice Lock up tokens to create a bond\n     * @param _asset tigAsset being locked\n     * @param _amount tigAsset amount\n     * @param _period number of days to be locked for\n     */\n    function lock(\n        address _asset,\n        uint _amount,\n        uint _period\n    ) public {\n        require(_period <= maxPeriod, \"MAX PERIOD\");\n        require(_period >= minPeriod, \"MIN PERIOD\");\n        require(allowedAssets[_asset], \"!asset\");\n\n        claimGovFees();\n\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        totalLocked[_asset] += _amount;\n        \n        bondNFT.createLock( _asset, _amount, _period, msg.sender);\n    }\n\n    /**\n     * @notice Reset the lock time and extend the period and/or token amount\n     * @param _id Bond id being extended\n     * @param _amount tigAsset amount being added\n     * @param _period number of days being added\n     */\n    function extendLock(\n        uint _id,\n        uint _amount,\n        uint _period\n    ) public {\n        address _asset = claim(_id);\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);\n    }\n\n    /**\n     * @notice Release the bond once it's expired\n     * @param _id Bond id being released\n     */\n    function release(\n        uint _id\n    ) public {\n        claimGovFees();\n        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);\n        totalLocked[asset] -= lockAmount;\n        IERC20(asset).transfer(_owner, amount);\n    }\n\n    /**\n     * @notice Claim rewards from gov nfts and distribute them to bonds\n     */\n    function claimGovFees() public {\n        address[] memory assets = bondNFT.getAssets();\n\n        for (uint i=0; i < assets.length; i++) {\n            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n            IGovNFT(govNFT).claim(assets[i]);\n            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);\n            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);\n        }\n    }\n\n    /**\n     * @notice Whitelist an asset\n     * @param _tigAsset tigAsset token address\n     * @param _isAllowed set tigAsset as allowed\n     */\n    function editAsset(\n        address _tigAsset,\n        bool _isAllowed\n    ) external onlyOwner() {\n        allowedAssets[_tigAsset] = _isAllowed;\n    }\n\n    /**\n     * @notice Owner can retreive Gov NFTs\n     * @param _ids array of gov nft ids\n     */\n    function sendNFTs(\n        uint[] memory _ids\n    ) external onlyOwner() {\n        govNFT.safeTransferMany(msg.sender, _ids);\n    }\n}"
    },
    {
      "filename": "contracts/Lock.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IBondNFT.sol\";\nimport \"./interfaces/IGovNFT.sol\";\n\ncontract Lock is Ownable{\n\n    uint public constant minPeriod = 7;\n    uint public constant maxPeriod = 365;\n\n    IBondNFT public immutable bondNFT;\n    IGovNFT public immutable govNFT;\n\n    mapping(address => bool) public allowedAssets;\n    mapping(address => uint) public totalLocked;\n\n    constructor(\n        address _bondNFTAddress,\n        address _govNFT\n    ) {\n        bondNFT = IBondNFT(_bondNFTAddress);\n        govNFT = IGovNFT(_govNFT);\n    }\n\n    /**\n     * @notice Claim pending rewards from a bond\n     * @param _id Bond NFT id\n     * @return address claimed tigAsset address\n     */\n    function claim(\n        uint256 _id\n    ) public returns (address) {\n        claimGovFees();\n        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);\n        IERC20(_tigAsset).transfer(msg.sender, _amount);\n        return _tigAsset;\n    }\n\n    /**\n     * @notice Claim pending rewards left over from a bond transfer\n     * @param _tigAsset token address being claimed\n     */\n    function claimDebt(\n        address _tigAsset\n    ) external {\n        claimGovFees();\n        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);\n        IERC20(_tigAsset).transfer(msg.sender, amount);\n    }\n\n    /**\n     * @notice Lock up tokens to create a bond\n     * @param _asset tigAsset being locked\n     * @param _amount tigAsset amount\n     * @param _period number of days to be locked for\n     */\n    function lock(\n        address _asset,\n        uint _amount,\n        uint _period\n    ) public {\n        require(_period <= maxPeriod, \"MAX PERIOD\");\n        require(_period >= minPeriod, \"MIN PERIOD\");\n        require(allowedAssets[_asset], \"!asset\");\n\n        claimGovFees();\n\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        totalLocked[_asset] += _amount;\n        \n        bondNFT.createLock( _asset, _amount, _period, msg.sender);\n    }\n\n    /**\n     * @notice Reset the lock time and extend the period and/or token amount\n     * @param _id Bond id being extended\n     * @param _amount tigAsset amount being added\n     * @param _period number of days being added\n     */\n    function extendLock(\n        uint _id,\n        uint _amount,\n        uint _period\n    ) public {\n        address _asset = claim(_id);\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);\n    }\n\n    /**\n     * @notice Release the bond once it's expired\n     * @param _id Bond id being released\n     */\n    function release(\n        uint _id\n    ) public {\n        claimGovFees();\n        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);\n        totalLocked[asset] -= lockAmount;\n        IERC20(asset).transfer(_owner, amount);\n    }\n\n    /**\n     * @notice Claim rewards from gov nfts and distribute them to bonds\n     */\n    function claimGovFees() public {\n        address[] memory assets = bondNFT.getAssets();\n\n        for (uint i=0; i < assets.length; i++) {\n            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n            IGovNFT(govNFT).claim(assets[i]);\n            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);\n            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);\n        }\n    }\n\n    /**\n     * @notice Whitelist an asset\n     * @param _tigAsset tigAsset token address\n     * @param _isAllowed set tigAsset as allowed\n     */\n    function editAsset(\n        address _tigAsset,\n        bool _isAllowed\n    ) external onlyOwner() {\n        allowedAssets[_tigAsset] = _isAllowed;\n    }\n\n    /**\n     * @notice Owner can retreive Gov NFTs\n     * @param _ids array of gov nft ids\n     */\n    function sendNFTs(\n        uint[] memory _ids\n    ) external onlyOwner() {\n        govNFT.safeTransferMany(msg.sender, _ids);\n    }\n}"
    },
    {
      "filename": "contracts/Lock.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IBondNFT.sol\";\nimport \"./interfaces/IGovNFT.sol\";\n\ncontract Lock is Ownable{\n\n    uint public constant minPeriod = 7;\n    uint public constant maxPeriod = 365;\n\n    IBondNFT public immutable bondNFT;\n    IGovNFT public immutable govNFT;\n\n    mapping(address => bool) public allowedAssets;\n    mapping(address => uint) public totalLocked;\n\n    constructor(\n        address _bondNFTAddress,\n        address _govNFT\n    ) {\n        bondNFT = IBondNFT(_bondNFTAddress);\n        govNFT = IGovNFT(_govNFT);\n    }\n\n    /**\n     * @notice Claim pending rewards from a bond\n     * @param _id Bond NFT id\n     * @return address claimed tigAsset address\n     */\n    function claim(\n        uint256 _id\n    ) public returns (address) {\n        claimGovFees();\n        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);\n        IERC20(_tigAsset).transfer(msg.sender, _amount);\n        return _tigAsset;\n    }\n\n    /**\n     * @notice Claim pending rewards left over from a bond transfer\n     * @param _tigAsset token address being claimed\n     */\n    function claimDebt(\n        address _tigAsset\n    ) external {\n        claimGovFees();\n        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);\n        IERC20(_tigAsset).transfer(msg.sender, amount);\n    }\n\n    /**\n     * @notice Lock up tokens to create a bond\n     * @param _asset tigAsset being locked\n     * @param _amount tigAsset amount\n     * @param _period number of days to be locked for\n     */\n    function lock(\n        address _asset,\n        uint _amount,\n        uint _period\n    ) public {\n        require(_period <= maxPeriod, \"MAX PERIOD\");\n        require(_period >= minPeriod, \"MIN PERIOD\");\n        require(allowedAssets[_asset], \"!asset\");\n\n        claimGovFees();\n\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        totalLocked[_asset] += _amount;\n        \n        bondNFT.createLock( _asset, _amount, _period, msg.sender);\n    }\n\n    /**\n     * @notice Reset the lock time and extend the period and/or token amount\n     * @param _id Bond id being extended\n     * @param _amount tigAsset amount being added\n     * @param _period number of days being added\n     */\n    function extendLock(\n        uint _id,\n        uint _amount,\n        uint _period\n    ) public {\n        address _asset = claim(_id);\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);\n    }\n\n    /**\n     * @notice Release the bond once it's expired\n     * @param _id Bond id being released\n     */\n    function release(\n        uint _id\n    ) public {\n        claimGovFees();\n        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);\n        totalLocked[asset] -= lockAmount;\n        IERC20(asset).transfer(_owner, amount);\n    }\n\n    /**\n     * @notice Claim rewards from gov nfts and distribute them to bonds\n     */\n    function claimGovFees() public {\n        address[] memory assets = bondNFT.getAssets();\n\n        for (uint i=0; i < assets.length; i++) {\n            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n            IGovNFT(govNFT).claim(assets[i]);\n            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);\n            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);\n        }\n    }\n\n    /**\n     * @notice Whitelist an asset\n     * @param _tigAsset tigAsset token address\n     * @param _isAllowed set tigAsset as allowed\n     */\n    function editAsset(\n        address _tigAsset,\n        bool _isAllowed\n    ) external onlyOwner() {\n        allowedAssets[_tigAsset] = _isAllowed;\n    }\n\n    /**\n     * @notice Owner can retreive Gov NFTs\n     * @param _ids array of gov nft ids\n     */\n    function sendNFTs(\n        uint[] memory _ids\n    ) external onlyOwner() {\n        govNFT.safeTransferMany(msg.sender, _ids);\n    }\n}"
    }
  ]
}