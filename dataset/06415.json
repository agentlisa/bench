{
  "Title": "[G-07] Refactor `If`/`require` statements to save SLOADs in case of early revert",
  "Content": "Checks that involve calldata should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before using excessive gas in a call that may ultimately revert in an unhappy case.\n\nTotal Instances: `4`\n\nhttps://github.com/code-423n4/2023-06-llama/blob/main/src/strategies/LlamaAbsoluteQuorum.sol#L27-L35\n\nThe check in [line 35](https://github.com/code-423n4/2023-06-llama/blob/main/src/strategies/LlamaAbsoluteQuorum.sol#L35) performs an SLOAD, while the check in [lines 32-33](https://github.com/code-423n4/2023-06-llama/blob/main/src/strategies/LlamaAbsoluteQuorum.sol#L32-L33) perform an external call and two SLOADs. We can move the check in [line 35](https://github.com/code-423n4/2023-06-llama/blob/main/src/strategies/LlamaAbsoluteQuorum.sol#L35) above [lines 32-33](https://github.com/code-423n4/2023-06-llama/blob/main/src/strategies/LlamaAbsoluteQuorum.sol#L32-L33) to potentially save an SLOAD & External call in the unhappy path.\n\n*Note: This view function is called in the state mutating `_createAction` function in `LlamaCore.sol`*\n```solidity\nFile: src/strategies/LlamaAbsoluteQuorum.sol\n27:  function validateActionCreation(ActionInfo calldata /* actionInfo */ ) external view override {\n28:    LlamaPolicy llamaPolicy = policy; // Reduce SLOADs.\n29:    uint256 approvalPolicySupply = llamaPolicy.getRoleSupplyAsQuantitySum(approvalRole);\n30:    if (approvalPolicySupply == 0) revert RoleHasZeroSupply(approvalRole);\n31:\n32:    uint256 disapprovalPolicySupply = llamaPolicy.getRoleSupplyAsQuantitySum(disapprovalRole); // @audit: 1 SLOAD + External call\n33:    if (disapprovalPolicySupply == 0) revert RoleHasZeroSupply(disapprovalRole); // @audit: 1 SLOAD\n34:\n35:    if (minApprovals > approvalPolicySupply) revert InsufficientApprovalQuantity(); // @audit: 1 SLOAD\n```\n```diff\ndiff --git a/src/strategies/LlamaAbsoluteQuorum.sol b/src/strategies/LlamaAbsoluteQuorum.sol\nindex 66130c0..aee2ce3 100644\n--- a/src/strategies/LlamaAbsoluteQuorum.sol\n+++ b/src/strategies/LlamaAbsoluteQuorum.sol\n@@ -29,10 +29,11 @@ contract LlamaAbsoluteQuorum is LlamaAbsoluteStrategyBase {\n     uint256 approvalPolicySupply = llamaPolicy.getRoleSupplyAsQuantitySum(approvalRole);\n     if (approvalPolicySupply == 0) revert RoleHasZeroSupply(approvalRole);\n\n+    if (minApprovals > approvalPolicySupply) revert InsufficientApprovalQuantity();\n+\n     uint256 disapprovalPolicySupply = llamaPolicy.getRoleSupplyAsQuantitySum(disapprovalRole);\n     if (disapprovalPolicySupply == 0) revert RoleHasZeroSupply(disapprovalRole);\n\n-    if (minApprovals > approvalPolicySupply) revert InsufficientApprovalQuantity();\n     if (minDisapprovals != type(uint128).max && minDisapprovals > disapprovalPolicySupply) {\n       revert InsufficientDisapprovalQuantity();\n     }\n```\n\nhttps://github.com/code-423n4/2023-06-llama/blob/main/src/strategies/LlamaAbsolutePeerReview.sol#L74-L82\n\nThe check in [line 79](https://github.com/code-423n4/2023-06-llama/blob/main/src/strategies/LlamaAbsolutePeerReview.sol#L79) accesses storage, while the check in [line 80](https://github.com/code-423n4/2023-06-llama/blob/main/src/strategies/LlamaAbsolutePeerReview.sol#L80) only accesses calldata. Move the check in [line 80](https://github.com/code-423n4/2023-06-llama/blob/main/src/strategies/LlamaAbsolutePeerReview.sol#L80) above [line 79](https://github.com/code-423n4/2023-06-llama/blob/main/src/strategies/LlamaAbsolutePeerReview.sol#L79) to potentially save an SLOAD in the unhappy path.\n\n*Note: This view function is called in the state mutating `_preCastAssertions` function in `LlamaCore.sol`*\n```solidity\nFile: src/strategies/LlamaAbsolutePeerReview.sol\n74:  function isDisapprovalEnabled(ActionInfo calldata actionInfo, address policyholder, uint8 role)\n75:    external\n76:    view\n77:    override\n78:  {\n79:    if (minDisapprovals == type(uint128).max) revert DisapprovalDisabled(); // @audit: accesses storage\n80:    if (actionInfo.creator == policyholder) revert ActionCreatorCannotCast(); // @audit: accesses calldata\n81:    if (role != disapprovalRole && !forceDisapprovalRole[role]) revert InvalidRole(disapprovalRole);\n82:  }\n```\n```diff\ndiff --git a/src/strategies/LlamaAbsolutePeerReview.sol b/src/strategies/LlamaAbsolutePeerReview.sol\nindex 85feb92..2df24ec 100644\n--- a/src/strategies/LlamaAbsolutePeerReview.sol\n+++ b/src/strategies/LlamaAbsolutePeerReview.sol\n@@ -76,8 +76,9 @@ contract LlamaAbsolutePeerReview is LlamaAbsoluteStrategyBase {\n     view\n     override\n   {\n-    if (minDisapprovals == type(uint128).max) revert DisapprovalDisabled();\n     if (actionInfo.creator == policyholder) revert ActionCreatorCannotCast();\n+    if (minDisapprovals == type(uint128).max) revert DisapprovalDisabled();\n     if (role != disapprovalRole && !forceDisapprovalRole[role]) revert InvalidRole(disapprovalRole);\n   }\n }\n```\n\nhttps://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaPolicy.sol#L412-L418\n\nThe check in [line 414](https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaPolicy.sol#L414) accesses storage, while the check in [line 418](https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaPolicy.sol#L418) only accesses a stack variable. Move the check in [line 418](https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaPolicy.sol#L418) above [line 414](https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaPolicy.sol#L414) to potentially save 1 SLOAD on the unhappy path.\n\n*Note: This view function is called within state mutating functions in `LlamaPolicy.sol`.*\n```solidity\nFile: src/LlamaPolicy.sol\n412:  function _assertValidRoleHolderUpdate(uint8 role, uint128 quantity, uint64 expiration) internal view {\n413:    // Ensure role is initialized.\n414:    if (role > numRoles) revert RoleNotInitialized(role); // @audit: accesses storage\n415:\n416:    // Cannot set the ALL_HOLDERS_ROLE because this is handled in the _mint / _burn methods and can\n417:    // create duplicate entries if set here.\n418:    if (role == ALL_HOLDERS_ROLE) revert AllHoldersRole(); // @audit: accesses stack variable\n```\n```diff\ndiff --git a/src/LlamaPolicy.sol b/src/LlamaPolicy.sol\nindex 3fca63e..443e74c 100644\n--- a/src/LlamaPolicy.sol\n+++ b/src/LlamaPolicy.sol\n@@ -410,13 +410,13 @@ contract LlamaPolicy is ERC721NonTransferableMinimalProxy {\n\n   /// @dev Checks if the conditions are met for a `role` to be updated.\n   function _assertValidRoleHolderUpdate(uint8 role, uint128 quantity, uint64 expiration) internal view {\n-    // Ensure role is initialized.\n-    if (role > numRoles) revert RoleNotInitialized(role);\n-\n     // Cannot set the ALL_HOLDERS_ROLE because this is handled in the _mint / _burn methods and can\n     // create duplicate entries if set here.\n     if (role == ALL_HOLDERS_ROLE) revert AllHoldersRole();\n\n+    // Ensure role is initialized.\n+    if (role > numRoles) revert RoleNotInitialized(role);\n+\n     // An expiration of zero is only allowed if the role is being removed. Roles are removed when\n     // the quantity is zero. In other words, the relationships that are required between the role\n     // quantity and expiration fields are:\n```\n\nhttps://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaCore.sol#L317-L324\n\nThe check in [line 324](https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaCore.sol#L324) accesses calldata, the check in [line 323](https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaCore.sol#L323) accesses storage, and the check in [lines 320-322](https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaCore.sol#L320-L322) accesses storage at least once and potentially multiple times. To save at least one SLOAD in unhappy path, place the checks in the following order:\n\n1. Check in [line 324](https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaCore.sol#L324)\n2. Check in [line 323](https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaCore.sol#L323)\n3. Check in [lines 320-322](https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaCore.sol#L320-L322)\n\n```solidity\nFile: src/LlamaCore.sol\n317:  function executeAction(ActionInfo calldata actionInfo) external payable {\n318:    // Initial checks that action is ready to execute.\n319:    Action storage action = actions[actionInfo.id];\n320:    ActionState currentState = getActionState(actionInfo); // @audit: accesses storage (at least 1 SLOAD, potentially more)\n321:\n322:    if (currentState != ActionState.Queued) revert InvalidActionState(currentState); // @audit: depends on line 320\n323:    if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached(); // @audit: accesses storage (1 SLOAD)\n324:    if (msg.value != actionInfo.value) revert IncorrectMsgValue(); // @audit: accesses calldata\n```\n```diff\ndiff --git a/src/LlamaCore.sol b/src/LlamaCore.sol\nindex 89d60de..594e9f4 100644\n--- a/src/LlamaCore.sol\n+++ b/src/LlamaCore.sol\n@@ -316,12 +316,13 @@ contract LlamaCore is Initializable {\n   /// @param actionInfo Data required to create an action.\n   function executeAction(ActionInfo calldata actionInfo) external payable {\n     // Initial checks that action is ready to execute.\n+    if (msg.value != actionInfo.value) revert IncorrectMsgValue();\n+\n     Action storage action = actions[actionInfo.id];\n-    ActionState currentState = getActionState(actionInfo);\n+    if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();\n\n+    ActionState currentState = getActionState(actionInfo);\n     if (currentState != ActionState.Queued) revert InvalidActionState(currentState);\n-    if (block.timestamp < action.minExecutionTime) revert MinExecutionTimeNotReached();\n-    if (msg.value != actionInfo.value) revert IncorrectMsgValue();\n\n     action.executed = true;\n```\n\n\n***\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-llama",
  "Code": [
    {
      "filename": "src/strategies/LlamaAbsoluteQuorum.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Initializable} from \"@openzeppelin/proxy/utils/Initializable.sol\";\n\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\nimport {ILlamaStrategy} from \"src/interfaces/ILlamaStrategy.sol\";\nimport {LlamaAbsoluteStrategyBase} from \"src/strategies/LlamaAbsoluteStrategyBase.sol\";\nimport {ActionState} from \"src/lib/Enums.sol\";\nimport {LlamaUtils} from \"src/lib/LlamaUtils.sol\";\nimport {Action, ActionInfo} from \"src/lib/Structs.sol\";\nimport {LlamaCore} from \"src/LlamaCore.sol\";\nimport {LlamaPolicy} from \"src/LlamaPolicy.sol\";\n\n/// @title Llama Absolute Quorum Strategy\n/// @author Llama (devsdosomething@llama.xyz)\n/// @notice This is a Llama strategy which has the following properties:\n///   - Approval/disapproval thresholds are specified as absolute numbers.\n///   - Action creators are allowed to cast approvals or disapprovals on their own actions within this strategy.\ncontract LlamaAbsoluteQuorum is LlamaAbsoluteStrategyBase {\n  // ==========================================\n  // ======== Interface Implementation ========\n  // ==========================================\n\n  /// @inheritdoc ILlamaStrategy\n  function validateActionCreation(ActionInfo calldata /* actionInfo */ ) external view override {\n    LlamaPolicy llamaPolicy = policy; // Reduce SLOADs.\n    uint256 approvalPolicySupply = llamaPolicy.getRoleSupplyAsQuantitySum(approvalRole);\n    if (approvalPolicySupply == 0) revert RoleHasZeroSupply(approvalRole);\n\n    uint256 disapprovalPolicySupply = llamaPolicy.getRoleSupplyAsQuantitySum(disapprovalRole);\n    if (disapprovalPolicySupply == 0) revert RoleHasZeroSupply(disapprovalRole);\n\n    if (minApprovals > approvalPolicySupply) revert InsufficientApprovalQuantity();\n    if (minDisapprovals != type(uint128).max && minDisapprovals > disapprovalPolicySupply) {\n      revert InsufficientDisapprovalQuantity();\n    }\n  }\n\n  // -------- When Casting Approval --------\n\n  /// @inheritdoc ILlamaStrategy\n  function isApprovalEnabled(ActionInfo calldata, /* actionInfo */ address, /* policyholder */ uint8 role)\n    external\n    view\n    override\n  {\n    if (role != approvalRole && !forceApprovalRole[role]) revert InvalidRole(approvalRole);\n  }\n\n  // -------- When Casting Disapproval --------\n\n  /// @inheritdoc ILlamaStrategy\n  function isDisapprovalEnabled(ActionInfo calldata, /* actionInfo */ address, /* policyholder */ uint8 role)\n    external\n    view\n    override\n  {\n    if (minDisapprovals == type(uint128).max) revert DisapprovalDisabled();\n    if (role != disapprovalRole && !forceDisapprovalRole[role]) revert InvalidRole(disapprovalRole);\n  }\n}"
    },
    {
      "filename": "src/strategies/LlamaAbsoluteQuorum.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Initializable} from \"@openzeppelin/proxy/utils/Initializable.sol\";\n\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\nimport {ILlamaStrategy} from \"src/interfaces/ILlamaStrategy.sol\";\nimport {LlamaAbsoluteStrategyBase} from \"src/strategies/LlamaAbsoluteStrategyBase.sol\";\nimport {ActionState} from \"src/lib/Enums.sol\";\nimport {LlamaUtils} from \"src/lib/LlamaUtils.sol\";\nimport {Action, ActionInfo} from \"src/lib/Structs.sol\";\nimport {LlamaCore} from \"src/LlamaCore.sol\";\nimport {LlamaPolicy} from \"src/LlamaPolicy.sol\";\n\n/// @title Llama Absolute Quorum Strategy\n/// @author Llama (devsdosomething@llama.xyz)\n/// @notice This is a Llama strategy which has the following properties:\n///   - Approval/disapproval thresholds are specified as absolute numbers.\n///   - Action creators are allowed to cast approvals or disapprovals on their own actions within this strategy.\ncontract LlamaAbsoluteQuorum is LlamaAbsoluteStrategyBase {\n  // ==========================================\n  // ======== Interface Implementation ========\n  // ==========================================\n\n  /// @inheritdoc ILlamaStrategy\n  function validateActionCreation(ActionInfo calldata /* actionInfo */ ) external view override {\n    LlamaPolicy llamaPolicy = policy; // Reduce SLOADs.\n    uint256 approvalPolicySupply = llamaPolicy.getRoleSupplyAsQuantitySum(approvalRole);\n    if (approvalPolicySupply == 0) revert RoleHasZeroSupply(approvalRole);\n\n    uint256 disapprovalPolicySupply = llamaPolicy.getRoleSupplyAsQuantitySum(disapprovalRole);\n    if (disapprovalPolicySupply == 0) revert RoleHasZeroSupply(disapprovalRole);\n\n    if (minApprovals > approvalPolicySupply) revert InsufficientApprovalQuantity();\n    if (minDisapprovals != type(uint128).max && minDisapprovals > disapprovalPolicySupply) {\n      revert InsufficientDisapprovalQuantity();\n    }\n  }\n\n  // -------- When Casting Approval --------\n\n  /// @inheritdoc ILlamaStrategy\n  function isApprovalEnabled(ActionInfo calldata, /* actionInfo */ address, /* policyholder */ uint8 role)\n    external\n    view\n    override\n  {\n    if (role != approvalRole && !forceApprovalRole[role]) revert InvalidRole(approvalRole);\n  }\n\n  // -------- When Casting Disapproval --------\n\n  /// @inheritdoc ILlamaStrategy\n  function isDisapprovalEnabled(ActionInfo calldata, /* actionInfo */ address, /* policyholder */ uint8 role)\n    external\n    view\n    override\n  {\n    if (minDisapprovals == type(uint128).max) revert DisapprovalDisabled();\n    if (role != disapprovalRole && !forceDisapprovalRole[role]) revert InvalidRole(disapprovalRole);\n  }\n}"
    },
    {
      "filename": "src/strategies/LlamaAbsolutePeerReview.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Initializable} from \"@openzeppelin/proxy/utils/Initializable.sol\";\n\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\nimport {ILlamaStrategy} from \"src/interfaces/ILlamaStrategy.sol\";\nimport {LlamaAbsoluteStrategyBase} from \"src/strategies/LlamaAbsoluteStrategyBase.sol\";\nimport {ActionState} from \"src/lib/Enums.sol\";\nimport {LlamaUtils} from \"src/lib/LlamaUtils.sol\";\nimport {Action, ActionInfo} from \"src/lib/Structs.sol\";\nimport {LlamaCore} from \"src/LlamaCore.sol\";\nimport {LlamaPolicy} from \"src/LlamaPolicy.sol\";\n\n/// @title Llama Absolute Peer Review Strategy\n/// @author Llama (devsdosomething@llama.xyz)\n/// @notice This is a Llama strategy which has the following properties:\n///   - Approval/disapproval thresholds are specified as absolute numbers.\n///   - Action creators are not allowed to cast approvals or disapprovals on their own actions,\n///     regardless of the roles they hold.\n///   - By not allowing action creators to cast approvals or disapprovals on their own actions,\n///     this strategy is useful for when a group of policyholders have permission to both create\n///     and approve an action. You can design a strategy where anyone in this group can propose\n///     but they need N number of approvals from their peers in this group for the action to be\n///     approved.\ncontract LlamaAbsolutePeerReview is LlamaAbsoluteStrategyBase {\n  // ========================\n  // ======== Errors ========\n  // ========================\n\n  /// @dev The action creator cannot approve or disapprove an action.\n  error ActionCreatorCannotCast();\n\n  // ==========================================\n  // ======== Interface Implementation ========\n  // ==========================================\n\n  /// @inheritdoc ILlamaStrategy\n  function validateActionCreation(ActionInfo calldata actionInfo) external view override {\n    LlamaPolicy llamaPolicy = policy; // Reduce SLOADs.\n    uint256 approvalPolicySupply = llamaPolicy.getRoleSupplyAsQuantitySum(approvalRole);\n    if (approvalPolicySupply == 0) revert RoleHasZeroSupply(approvalRole);\n\n    uint256 disapprovalPolicySupply = llamaPolicy.getRoleSupplyAsQuantitySum(disapprovalRole);\n    if (disapprovalPolicySupply == 0) revert RoleHasZeroSupply(disapprovalRole);\n    unchecked {\n      // Safety: We check the supply of the role above, and this supply is inclusive of the quantity\n      // held by the action creator. Therefore we can reduce the total supply by the quantity held by\n      // the action creator without overflow, since a policyholder can never have a quantity greater than\n      // the total supply.\n      uint256 actionCreatorApprovalRoleQty = llamaPolicy.getQuantity(actionInfo.creator, approvalRole);\n      if (minApprovals > approvalPolicySupply - actionCreatorApprovalRoleQty) revert InsufficientApprovalQuantity();\n\n      uint256 actionCreatorDisapprovalRoleQty = llamaPolicy.getQuantity(actionInfo.creator, disapprovalRole);\n      if (\n        minDisapprovals != type(uint128).max\n          && minDisapprovals > disapprovalPolicySupply - actionCreatorDisapprovalRoleQty\n      ) revert InsufficientDisapprovalQuantity();\n    }\n  }\n\n  // -------- When Casting Approval --------\n\n  /// @inheritdoc ILlamaStrategy\n  function isApprovalEnabled(ActionInfo calldata actionInfo, address policyholder, uint8 role) external view override {\n    if (actionInfo.creator == policyholder) revert ActionCreatorCannotCast();\n    if (role != approvalRole && !forceApprovalRole[role]) revert InvalidRole(approvalRole);\n  }\n\n  // -------- When Casting Disapproval --------\n\n  /// @inheritdoc ILlamaStrategy\n  function isDisapprovalEnabled(ActionInfo calldata actionInfo, address policyholder, uint8 role)\n    external\n    view\n    override\n  {\n    if (minDisapprovals == type(uint128).max) revert DisapprovalDisabled();\n    if (actionInfo.creator == policyholder) revert ActionCreatorCannotCast();\n    if (role != disapprovalRole && !forceDisapprovalRole[role]) revert InvalidRole(disapprovalRole);\n  }\n}"
    },
    {
      "filename": "src/strategies/LlamaAbsolutePeerReview.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Initializable} from \"@openzeppelin/proxy/utils/Initializable.sol\";\n\nimport {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\nimport {ILlamaStrategy} from \"src/interfaces/ILlamaStrategy.sol\";\nimport {LlamaAbsoluteStrategyBase} from \"src/strategies/LlamaAbsoluteStrategyBase.sol\";\nimport {ActionState} from \"src/lib/Enums.sol\";\nimport {LlamaUtils} from \"src/lib/LlamaUtils.sol\";\nimport {Action, ActionInfo} from \"src/lib/Structs.sol\";\nimport {LlamaCore} from \"src/LlamaCore.sol\";\nimport {LlamaPolicy} from \"src/LlamaPolicy.sol\";\n\n/// @title Llama Absolute Peer Review Strategy\n/// @author Llama (devsdosomething@llama.xyz)\n/// @notice This is a Llama strategy which has the following properties:\n///   - Approval/disapproval thresholds are specified as absolute numbers.\n///   - Action creators are not allowed to cast approvals or disapprovals on their own actions,\n///     regardless of the roles they hold.\n///   - By not allowing action creators to cast approvals or disapprovals on their own actions,\n///     this strategy is useful for when a group of policyholders have permission to both create\n///     and approve an action. You can design a strategy where anyone in this group can propose\n///     but they need N number of approvals from their peers in this group for the action to be\n///     approved.\ncontract LlamaAbsolutePeerReview is LlamaAbsoluteStrategyBase {\n  // ========================\n  // ======== Errors ========\n  // ========================\n\n  /// @dev The action creator cannot approve or disapprove an action.\n  error ActionCreatorCannotCast();\n\n  // ==========================================\n  // ======== Interface Implementation ========\n  // ==========================================\n\n  /// @inheritdoc ILlamaStrategy\n  function validateActionCreation(ActionInfo calldata actionInfo) external view override {\n    LlamaPolicy llamaPolicy = policy; // Reduce SLOADs.\n    uint256 approvalPolicySupply = llamaPolicy.getRoleSupplyAsQuantitySum(approvalRole);\n    if (approvalPolicySupply == 0) revert RoleHasZeroSupply(approvalRole);\n\n    uint256 disapprovalPolicySupply = llamaPolicy.getRoleSupplyAsQuantitySum(disapprovalRole);\n    if (disapprovalPolicySupply == 0) revert RoleHasZeroSupply(disapprovalRole);\n    unchecked {\n      // Safety: We check the supply of the role above, and this supply is inclusive of the quantity\n      // held by the action creator. Therefore we can reduce the total supply by the quantity held by\n      // the action creator without overflow, since a policyholder can never have a quantity greater than\n      // the total supply.\n      uint256 actionCreatorApprovalRoleQty = llamaPolicy.getQuantity(actionInfo.creator, approvalRole);\n      if (minApprovals > approvalPolicySupply - actionCreatorApprovalRoleQty) revert InsufficientApprovalQuantity();\n\n      uint256 actionCreatorDisapprovalRoleQty = llamaPolicy.getQuantity(actionInfo.creator, disapprovalRole);\n      if (\n        minDisapprovals != type(uint128).max\n          && minDisapprovals > disapprovalPolicySupply - actionCreatorDisapprovalRoleQty\n      ) revert InsufficientDisapprovalQuantity();\n    }\n  }\n\n  // -------- When Casting Approval --------\n\n  /// @inheritdoc ILlamaStrategy\n  function isApprovalEnabled(ActionInfo calldata actionInfo, address policyholder, uint8 role) external view override {\n    if (actionInfo.creator == policyholder) revert ActionCreatorCannotCast();\n    if (role != approvalRole && !forceApprovalRole[role]) revert InvalidRole(approvalRole);\n  }\n\n  // -------- When Casting Disapproval --------\n\n  /// @inheritdoc ILlamaStrategy\n  function isDisapprovalEnabled(ActionInfo calldata actionInfo, address policyholder, uint8 role)\n    external\n    view\n    override\n  {\n    if (minDisapprovals == type(uint128).max) revert DisapprovalDisabled();\n    if (actionInfo.creator == policyholder) revert ActionCreatorCannotCast();\n    if (role != disapprovalRole && !forceDisapprovalRole[role]) revert InvalidRole(disapprovalRole);\n  }\n}"
    },
    {
      "filename": "src/LlamaPolicy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {LibString} from \"@solady/utils/LibString.sol\";\n\nimport {Checkpoints} from \"src/lib/Checkpoints.sol\";\nimport {ERC721NonTransferableMinimalProxy} from \"src/lib/ERC721NonTransferableMinimalProxy.sol\";\nimport {LlamaUtils} from \"src/lib/LlamaUtils.sol\";\nimport {RoleHolderData, RolePermissionData} from \"src/lib/Structs.sol\";\nimport {RoleDescription} from \"src/lib/UDVTs.sol\";\nimport {LlamaCore} from \"src/LlamaCore.sol\";\nimport {LlamaExecutor} from \"src/LlamaExecutor.sol\";\nimport {LlamaFactory} from \"src/LlamaFactory.sol\";\n\n/// @title Llama Policy\n/// @author Llama (devsdosomething@llama.xyz)\n/// @notice An ERC721 contract where each token is non-transferable, functions as the respective policy for a given\n/// policyholder and has roles assigned to `create`, `approve` and `disapprove` actions.\n/// @dev The roles and permissions determine how the policyholder can interact with the Llama core contract.\ncontract LlamaPolicy is ERC721NonTransferableMinimalProxy {\n  using Checkpoints for Checkpoints.History;\n\n  // =========================\n  // ======== Structs ========\n  // =========================\n\n  /// @dev Stores the two different supply values for a role.\n  struct RoleSupply {\n    uint128 numberOfHolders; // The total number of unique policyholders holding a role.\n    uint128 totalQuantity; // The sum of the quantity field for all unique policyholders holding a role.\n  }\n\n  // ======================================\n  // ======== Errors and Modifiers ========\n  // ======================================\n\n  /// @dev Roleholder cannot be set at the same timestamp as an action creation.\n  error ActionCreationAtSameTimestamp();\n\n  /// @dev Thrown when revoking a policy from an address without one\n  /// @param userAddress The address of the possible policyholder.\n  error AddressDoesNotHoldPolicy(address userAddress);\n\n  /// @dev Cannot set \"all holders\" role.\n  error AllHoldersRole();\n\n  /// @dev Policy can only be initialized once.\n  error AlreadyInitialized();\n\n  /// @dev The indices would result in `Panic: Index Out of Bounds`.\n  /// @dev Thrown when the `end` index is greater than array length or when the `start` index is greater than the `end`\n  /// index.\n  error InvalidIndices();\n\n  /// @dev Thrown when the provided policyholder and role are not in the expected state for the function.\n  error InvalidRoleHolderInput();\n\n  /// @dev Policy tokens cannot be transferred.\n  error NonTransferableToken();\n\n  /// @dev Only callable by a Llama instance's executor.\n  error OnlyLlama();\n\n  /// @dev Operations can only occur on initialized roles.\n  error RoleNotInitialized(uint8 role);\n\n  /// @dev Checks that the caller is the Llama executor and reverts if not.\n  modifier onlyLlama() {\n    if (msg.sender != llamaExecutor) revert OnlyLlama();\n    _;\n  }\n\n  /// @dev Ensures that none of the ERC721 `transfer` and `approval` functions can be called, so that the policies are\n  /// soulbound.\n  modifier nonTransferableToken() {\n    _; // We put this ahead of the revert so we don't get an unreachable code warning.\n    revert NonTransferableToken();\n  }\n\n  // ========================\n  // ======== Events ========\n  // ========================\n\n  /// @dev Emitted when a policyholder is assigned a role.\n  event RoleAssigned(address indexed policyholder, uint8 indexed role, uint64 expiration, uint128 quantity);\n\n  /// @dev Emitted when a role is initialized with a description.\n  event RoleInitialized(uint8 indexed role, RoleDescription description);\n\n  /// @dev Emitted when a permission ID is assigned to a role.\n  event RolePermissionAssigned(uint8 indexed role, bytes32 indexed permissionId, bool hasPermission);\n\n  // =================================================\n  // ======== Constants and Storage Variables ========\n  // =================================================\n\n  /// @dev Checkpoints a token ID's \"balance\" (quantity) of a given role. The quantity of the\n  /// role is how much quantity the role-holder gets when approving/disapproving (regardless of\n  /// strategy).\n  mapping(uint256 tokenId => mapping(uint8 role => Checkpoints.History)) internal roleBalanceCkpts;\n\n  /// @notice A special role used to reference all policyholders.\n  /// @dev DO NOT assign policyholders this role directly. Doing so can result in the wrong total supply\n  /// values for this role.\n  uint8 public constant ALL_HOLDERS_ROLE = 0;\n\n  /// @notice At deployment, this role is given permission to call the `setRolePermission` function.\n  /// However, this may change depending on how the Llama instance is configured.\n  /// @dev This is done to mitigate the chances of deploying a misconfigured Llama instance that is\n  /// unusable. See the documentation for more info.\n  uint8 public constant BOOTSTRAP_ROLE = 1;\n\n  /// @notice Returns `true` if the role can create actions with the given permission ID.\n  mapping(uint8 role => mapping(bytes32 permissionId => bool)) public canCreateAction;\n\n  /// @notice Checkpoints the total supply of a given role.\n  /// @dev At a given timestamp, the total supply of a role must equal the sum of the quantity of\n  /// the role for each token ID that holds the role.\n  mapping(uint8 role => RoleSupply) public roleSupply;\n\n  /// @notice The highest role ID that has been initialized.\n  uint8 public numRoles;\n\n  /// @notice The address of the `LlamaExecutor` of this instance.\n  address public llamaExecutor;\n\n  /// @notice The address of the `LlamaFactory` contract.\n  LlamaFactory public factory;\n\n  // ======================================================\n  // ======== Contract Creation and Initialization ========\n  // ======================================================\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @notice Initializes a new `LlamaPolicy` clone.\n  /// @param _name The name of the policy.\n  /// @param roleDescriptions The role descriptions.\n  /// @param roleHolders The `role`, `policyholder`, `quantity` and `expiration` of the role holders.\n  /// @param rolePermissions The `role`, `permissionId` and whether the role has the permission of the role permissions.\n  function initialize(\n    string calldata _name,\n    RoleDescription[] calldata roleDescriptions,\n    RoleHolderData[] calldata roleHolders,\n    RolePermissionData[] calldata rolePermissions\n  ) external initializer {\n    __initializeERC721MinimalProxy(_name, string.concat(\"LL-\", LibString.replace(LibString.upper(_name), \" \", \"-\")));\n    factory = LlamaFactory(msg.sender);\n    for (uint256 i = 0; i < roleDescriptions.length; i = LlamaUtils.uncheckedIncrement(i)) {\n      _initializeRole(roleDescriptions[i]);\n    }\n\n    for (uint256 i = 0; i < roleHolders.length; i = LlamaUtils.uncheckedIncrement(i)) {\n      _setRoleHolder(\n        roleHolders[i].role, roleHolders[i].policyholder, roleHolders[i].quantity, roleHolders[i].expiration\n      );\n    }\n\n    for (uint256 i = 0; i < rolePermissions.length; i = LlamaUtils.uncheckedIncrement(i)) {\n      _setRolePermission(rolePermissions[i].role, rolePermissions[i].permissionId, rolePermissions[i].hasPermission);\n    }\n\n    // Must have assigned roles during initialization, otherwise the system cannot be used. However,\n    // we do not check that roles were assigned \"properly\" as there is no single correct way, so\n    // this is more of a sanity check, not a guarantee that the system will work after initialization.\n    if (numRoles == 0 || getRoleSupplyAsNumberOfHolders(ALL_HOLDERS_ROLE) == 0) revert InvalidRoleHolderInput();\n  }\n\n  // ===========================================\n  // ======== External and Public Logic ========\n  // ===========================================\n\n  /// @notice Sets the address of the `LlamaExecutor` contract and gives holders of role ID 1 permission\n  /// to change role permissions.\n  /// @dev This method can only be called once.\n  /// @param _llamaExecutor The address of the `LlamaExecutor` contract.\n  /// @param bootstrapPermissionId The permission ID that allows holders to change role permissions.\n  function finalizeInitialization(address _llamaExecutor, bytes32 bootstrapPermissionId) external {\n    if (llamaExecutor != address(0)) revert AlreadyInitialized();\n\n    llamaExecutor = _llamaExecutor;\n    _setRolePermission(BOOTSTRAP_ROLE, bootstrapPermissionId, true);\n  }\n\n  // -------- Role and Permission Management --------\n\n  /// @notice Initializes a new role with the given role ID and description\n  function initializeRole(RoleDescription description) external onlyLlama {\n    _initializeRole(description);\n  }\n\n  /// @notice Assigns a role to a policyholder.\n  /// @param role ID of the role to set (uint8 ensures on-chain enumerability when burning policies).\n  /// @param policyholder Policyholder to assign the role to.\n  /// @param quantity Quantity of the role to assign to the policyholder, i.e. their (dis)approval quantity.\n  /// @param expiration When the role expires.\n  function setRoleHolder(uint8 role, address policyholder, uint128 quantity, uint64 expiration) external onlyLlama {\n    _setRoleHolder(role, policyholder, quantity, expiration);\n  }\n\n  /// @notice Assigns a permission ID to a role.\n  /// @param role Name of the role to set.\n  /// @param permissionId Permission ID to assign to the role.\n  /// @param hasPermission Whether to assign the permission or remove the permission.\n  function setRolePermission(uint8 role, bytes32 permissionId, bool hasPermission) external onlyLlama {\n    _setRolePermission(role, permissionId, hasPermission);\n  }\n\n  /// @notice Revokes a policyholder's expired role.\n  /// @param role Role that has expired.\n  /// @param policyholder Policyholder that held the role.\n  /// @dev WARNING: This function needs to be explicitly called to revoke expired roles by monitoring through offchain\n  /// infrastructure, otherwise expired roles can continue to create actions (if they have the right permissions) and\n  /// take part in the approval/disapproval process if the strategy allows it.\n  function revokeExpiredRole(uint8 role, address policyholder) external {\n    _revokeExpiredRole(role, policyholder);\n  }\n\n  /// @notice Revokes all roles from the `policyholder` and burns their policy.\n  function revokePolicy(address policyholder) external onlyLlama {\n    if (balanceOf(policyholder) == 0) revert AddressDoesNotHoldPolicy(policyholder);\n    // We start from i = 1 here because a value of zero is reserved for the \"all holders\" role, and\n    // that will get removed automatically when the token is burned. Similarly, use we `<=` to make sure\n    // the last role is also revoked.\n    for (uint256 i = 1; i <= numRoles; i = LlamaUtils.uncheckedIncrement(i)) {\n      if (hasRole(policyholder, uint8(i))) _setRoleHolder(uint8(i), policyholder, 0, 0);\n    }\n    _burn(_tokenId(policyholder));\n  }\n\n  /// @notice Updates the description of a role.\n  /// @param role ID of the role to update.\n  /// @param description New description of the role.\n  function updateRoleDescription(uint8 role, RoleDescription description) external onlyLlama {\n    if (role > numRoles) revert RoleNotInitialized(role);\n    emit RoleInitialized(role, description);\n  }\n\n  // -------- Role and Permission Getters --------\n\n  /// @notice Returns the quantity of the `role` for the given `policyholder`. The returned value is the\n  /// quantity of the role when approving/disapproving (regardless of strategy).\n  function getQuantity(address policyholder, uint8 role) external view returns (uint128) {\n    uint256 tokenId = _tokenId(policyholder);\n    return roleBalanceCkpts[tokenId][role].latest();\n  }\n\n  /// @notice Returns the quantity of the `role` for the given `policyholder` at `timestamp`. The returned\n  /// value is the quantity of the role when approving/disapproving (regardless of strategy).\n  function getPastQuantity(address policyholder, uint8 role, uint256 timestamp) external view returns (uint128) {\n    uint256 tokenId = _tokenId(policyholder);\n    return roleBalanceCkpts[tokenId][role].getAtProbablyRecentTimestamp(timestamp);\n  }\n\n  /// @notice Returns the total number of role holders for given `role`.\n  function getRoleSupplyAsNumberOfHolders(uint8 role) public view returns (uint128) {\n    return roleSupply[role].numberOfHolders;\n  }\n\n  /// @notice Returns the sum of quantity across all role holders for given `role`.\n  function getRoleSupplyAsQuantitySum(uint8 role) public view returns (uint128) {\n    return roleSupply[role].totalQuantity;\n  }\n\n  /// @notice Returns all checkpoints for the given `policyholder` and `role`.\n  function roleBalanceCheckpoints(address policyholder, uint8 role) external view returns (Checkpoints.History memory) {\n    uint256 tokenId = _tokenId(policyholder);\n    return roleBalanceCkpts[tokenId][role];\n  }\n\n  /// @notice Returns all checkpoints for the given policyholder and role between `start` and\n  /// `end`, where `start` is inclusive and `end` is exclusive.\n  /// @param policyholder Policyholder to get the checkpoints for.\n  /// @param role Role held by policyholder to get the checkpoints for.\n  /// @param start Start index of the checkpoints to get from their checkpoint history array. This index is inclusive.\n  /// @param end End index of the checkpoints to get from their checkpoint history array. This index is exclusive.\n  function roleBalanceCheckpoints(address policyholder, uint8 role, uint256 start, uint256 end)\n    external\n    view\n    returns (Checkpoints.History memory)\n  {\n    if (start > end) revert InvalidIndices();\n    uint256 checkpointsLength = roleBalanceCkpts[_tokenId(policyholder)][role]._checkpoints.length;\n    if (end > checkpointsLength) revert InvalidIndices();\n\n    uint256 tokenId = _tokenId(policyholder);\n    uint256 sliceLength = end - start;\n    Checkpoints.Checkpoint[] memory checkpoints = new Checkpoints.Checkpoint[](sliceLength);\n    for (uint256 i = start; i < end; i = LlamaUtils.uncheckedIncrement(i)) {\n      checkpoints[i - start] = roleBalanceCkpts[tokenId][role]._checkpoints[i];\n    }\n    return Checkpoints.History(checkpoints);\n  }\n\n  /// @notice Returns the number of checkpoints for the given `policyholder` and `role`.\n  /// @dev Useful for knowing the max index when requesting a range of checkpoints in `roleBalanceCheckpoints`.\n  function roleBalanceCheckpointsLength(address policyholder, uint8 role) external view returns (uint256) {\n    uint256 tokenId = _tokenId(policyholder);\n    return roleBalanceCkpts[tokenId][role]._checkpoints.length;\n  }\n\n  /// @notice Returns `true` if the `policyholder` has the `role`, `false` otherwise.\n  function hasRole(address policyholder, uint8 role) public view returns (bool) {\n    uint128 quantity = roleBalanceCkpts[_tokenId(policyholder)][role].latest();\n    return quantity > 0;\n  }\n\n  /// @notice Returns `true` if the `policyholder` has the `role` at `timestamp`, `false` otherwise.\n  function hasRole(address policyholder, uint8 role, uint256 timestamp) external view returns (bool) {\n    uint256 quantity = roleBalanceCkpts[_tokenId(policyholder)][role].getAtProbablyRecentTimestamp(timestamp);\n    return quantity > 0;\n  }\n\n  /// @notice Returns `true` if the given `policyholder` has a given `permissionId` under the `role`,\n  /// `false` otherwise.\n  function hasPermissionId(address policyholder, uint8 role, bytes32 permissionId) external view returns (bool) {\n    uint128 quantity = roleBalanceCkpts[_tokenId(policyholder)][role].latest();\n    return quantity > 0 && canCreateAction[role][permissionId];\n  }\n\n  /// @notice Returns `true` if the `role` held by `policyholder` is expired, `false` otherwise.\n  function isRoleExpired(address policyholder, uint8 role) public view returns (bool) {\n    (,, uint64 expiration, uint128 quantity) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();\n    return quantity > 0 && block.timestamp > expiration;\n  }\n\n  /// @notice Returns the expiration timestamp of the `role` held by `policyholder`.\n  function roleExpiration(address policyholder, uint8 role) external view returns (uint64) {\n    (,, uint64 expiration,) = roleBalanceCkpts[_tokenId(policyholder)][role].latestCheckpoint();\n    return expiration;\n  }\n\n  /// @notice Returns the total number of policies in existence.\n  /// @dev This is just an alias for convenience/familiarity.\n  function totalSupply() public view returns (uint256) {\n    return getRoleSupplyAsNumberOfHolders(ALL_HOLDERS_ROLE);\n  }\n\n  // -------- ERC-721 Getters --------\n\n  /// @notice Returns the token URI for the given `tokenId` of this Llama instance.\n  /// @param tokenId The ID of the policy token.\n  /// @return The token URI for the given `tokenId` of this Llama instance.\n  function tokenURI(uint256 tokenId) public view override returns (string memory) {\n    return factory.tokenURI(LlamaExecutor(llamaExecutor), name, tokenId);\n  }\n\n  /// @notice Returns a URI for the storefront-level metadata for your contract.\n  /// @return The contract URI for the given Llama instance.\n  function contractURI() public view returns (string memory) {\n    return factory.contractURI(name);\n  }\n\n  // -------- ERC-721 Methods --------\n\n  /// @dev overriding `transferFrom` to disable transfers\n  function transferFrom(address, /* from */ address, /* to */ uint256 /* policyId */ )\n    public\n    pure\n    override\n    nonTransferableToken\n  {}\n\n  /// @dev overriding `safeTransferFrom` to disable transfers\n  function safeTransferFrom(address, /* from */ address, /* to */ uint256 /* id */ )\n    public\n    pure\n    override\n    nonTransferableToken\n  {}\n\n  /// @dev overriding `safeTransferFrom` to disable transfers\n  function safeTransferFrom(address, /* from */ address, /* to */ uint256, /* policyId */ bytes calldata /* data */ )\n    public\n    pure\n    override\n    nonTransferableToken\n  {}\n\n  /// @dev overriding `approve` to disable approvals\n  function approve(address, /* spender */ uint256 /* id */ ) public pure override nonTransferableToken {}\n\n  /// @dev overriding `approve` to disable approvals\n  function setApprovalForAll(address, /* operator */ bool /* approved */ ) public pure override nonTransferableToken {}\n\n  // ================================\n  // ======== Internal Logic ========\n  // ================================\n\n  /// @dev Initializes the next unassigned role with the given `description`.\n  function _initializeRole(RoleDescription description) internal {\n    numRoles += 1;\n    emit RoleInitialized(numRoles, description);\n  }\n\n  /// @dev Because role supplies are not checkpointed for simplicity, the following issue can occur\n  /// if each of the below is executed within the same timestamp:\n  //    1. An action is created that saves off the current role supply.\n  //    2. A policyholder is given a new role.\n  //    3. Now the total supply in that block is different than what it was at action creation.\n  // As a result, we disallow changes to roles if an action was created in the same block.\n  function _assertNoActionCreationsAtCurrentTimestamp() internal view {\n    if (llamaExecutor == address(0)) return; // Skip check during initialization.\n    address llamaCore = Lla"
    }
  ]
}