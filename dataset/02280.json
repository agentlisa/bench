{
  "Title": "H-3: HatsSignerGateBase: valid signer threshold can be bypassed because HSG checks signatures differently from Safe which allows exploitation",
  "Content": "# Issue H-3: HatsSignerGateBase: valid signer threshold can be bypassed because HSG checks signatures differently from Safe which allows exploitation \n\nSource: https://github.com/sherlock-audit/2023-02-hats-judging/issues/50 \n\n## Found by \nbin2chen, roguereddwarf\n\n## Summary\nThis report deals with how the `HatsSignerGate` and the `Safe` check signatures differently which opens the door to exploitation.\n\nI will show how this allows a valid signer that has become invalid but not yet removed from the `owners` of the Safe to continue signing transactions. The invalid signer can effectively sign transactions as though he was valid.\n\nAlso there is the possibility of valid signers calling `Safe.addOwnerWithThreshold`. When an owner is added to the Safe but not a valid signer he can still sign transactions and the HSG will not recognize that there are not enough valid signatures.\n\nTo summarize, the issue is caused by this:\n1. Signatures are first checked by the Safe then by the HSG logic\n2. We can pass an arbitrary amount of signatures when executing a transaction\n3. The Safe checks that the first `threshold` signatures are valid. However the HSG logic checks that ANY of the signatures are signed by valid signers. The HSG logic does not check the same signatures as the Safe. \n\nEssentially the Safe and HSG logic are applying different checks to different signatures.\n\n## Vulnerability Detail\nA transaction is executed by calling [Safe.execTransaction](https://github.com/safe-global/safe-contracts/blob/cb22537c89ea4187f4ad141ab2e1abf15b27416b/contracts/Safe.sol#L135-L217)\n\nFirst the signatures are checked by the Safe [Link](https://github.com/safe-global/safe-contracts/blob/cb22537c89ea4187f4ad141ab2e1abf15b27416b/contracts/Safe.sol#L168) then the `checkTransaction` function is executed on the guard (HatsSignerGate) [Link](https://github.com/safe-global/safe-contracts/blob/cb22537c89ea4187f4ad141ab2e1abf15b27416b/contracts/Safe.sol#L173-L188)\n\nThe HatsSignerGate then executes `countValidSignatures` to check if enough signatures were signed by valid signers [Link](https://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L488)\n\nWith all prerequisites out of the way, we can now get into the actual issue.\n\nThe Safe calls `checkNSignatures` to check if the first `threshold` signatures in the `signatures` bytes are valid [Link](https://github.com/safe-global/safe-contracts/blob/cb22537c89ea4187f4ad141ab2e1abf15b27416b/contracts/Safe.sol#L280-L329)\n\nSo if `threshold=5` but we provide say 7 signatures, the last two signatures are not checked.\nIf the first 5 signatures are valid the check passes successfully.\n\nThe issue is that the HSG `countValidSignatures` function iterates over ALL signatures and tries to find enough valid signers such that `threshold` is reached [Link](https://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L559).\n\nSo imagine the following scenario:\n\n1. There are 4 owners in the Safe, `threshold=3` and 3 owners are valid signers.\n2. One of the owners is no longer a valid signer (I'll call him Bob). He is not yet removed from the `owners`.\n3. Bob wants to sign a transaction and submit it to the Safe. He already has 2 signatures from valid signers.\n4. Bob signs the transaction and appends his signature to the `signatures` bytes. He also appends a signature of a valid signer from a previous transaction. So there are now 4 signatures in the `signatures` bytes.\n5. Bob calls `Safe.execTransaction`. The Safe checks the first 3 signatures to be valid signatures from owners. The check passes. The HSG checks that there are at least 3 signatures signed by valid signers. Which also passes.\n\nImportant: Bob can pass a 4th signature from a previous transaction because two of the signature types used in HSG do not check that the correct data has been signed [https://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L561-L568](https://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L561-L568). \n\nTo summarize: Bob was able to sign a transaction even though he was no longer a valid signer.\n\n### Further notes\nAnother thing to note is that HSG does not check signatures for uniqueness so if Bob would have to append multiple signatures from valid signers he could just add the same signature multiple times.\n\nAlso the HSG does not check that `ecrecover` does not return the zero address as owner which it does if the signature is invalid.\nThese checks are implemented in the Safe. So by implementing the mitigation I suggest below the Safe and HSG will check the same signatures. So there is no need to have these checks in the HSG as well.\nHowever due to this bug (checking different signatures), the signer hat might be transferred to `address(0)` which then causes invalid signatures to be considered valid.\n\n## Impact\nOwners of the Safe that are not valid signers can sign transactions.\n\n## Code Snippet\nAlso have a look at the `@audit-info` comments that further explain the issue.\n\nhttps://github.com/safe-global/safe-contracts/blob/cb22537c89ea4187f4ad141ab2e1abf15b27416b/contracts/Safe.sol#L135-L217\n```solidity\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable virtual returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData = encodeTransactionData(\n                // Transaction info\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                // Payment info\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                // Signature info\n                nonce\n            );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            // @audit-info first the Safe checks the signatures\n            checkSignatures(txHash, txHashData, signatures);\n        }\n        address guard = getGuard();\n        {\n            if (guard != address(0)) {\n                // @audit-info then signatures are checked by HSG\n                Guard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, \"GS010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || safeTxGas != 0 || gasPrice != 0, \"GS013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkAfterExecution(txHash, success);\n            }\n        }\n    }\n```\n\nhttps://github.com/safe-global/safe-contracts/blob/cb22537c89ea4187f4ad141ab2e1abf15b27416b/contracts/Safe.sol#L270-L330\n```solidity\n    // @audit-info requiredSignatures is equal to threshold\n    function checkNSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures, uint256 requiredSignatures) public view {\n        // Check that the provided signature data is not too short\n        require(signatures.length >= requiredSignatures.mul(65), \"GS020\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        // @audit-info only the first threshold signatures are checked\n        for (i = 0; i < requiredSignatures; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                require(keccak256(data) == dataHash, \"GS027\");\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= requiredSignatures.mul(65), \"GS021\");\n\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s).add(32) <= signatures.length, \"GS022\");\n\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"GS023\");\n\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"GS024\");\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"GS025\");\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n            require(currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS, \"GS026\");\n            lastOwner = currentOwner;\n        }\n    }\n```\n\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L445-L503\n```solidity\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address // msgSender\n    ) external override {\n        if (msg.sender != address(safe)) revert NotCalledFromSafe();\n\n\n        uint256 safeOwnerCount = safe.getOwners().length;\n        // uint256 validSignerCount = _countValidSigners(safe.getOwners());\n\n\n        // ensure that safe threshold is correct\n        reconcileSignerCount();\n\n\n        if (safeOwnerCount < minThreshold) {\n            revert BelowMinThreshold(minThreshold, safeOwnerCount);\n        }\n\n\n        // get the tx hash; view function\n        bytes32 txHash = safe.getTransactionHash(\n            // Transaction info\n            to,\n            value,\n            data,\n            operation,\n            safeTxGas,\n            // Payment info\n            baseGas,\n            gasPrice,\n            gasToken,\n            refundReceiver,\n            // Signature info\n            // We subtract 1 since nonce was just incremented in the parent function call\n            safe.nonce() - 1 // view function\n        );\n\n        // @audit-info all signatures are checked (signatures.length / 65) as opposed to first threshold ones in the Safe\n        uint256 validSigCount = countValidSignatures(txHash, signatures, signatures.length / 65);\n\n\n        // revert if there aren't enough valid signatures\n        if (validSigCount < safe.getThreshold() || validSigCount < minThreshold) {\n            revert InvalidSigners();\n        }\n\n\n        // record existing modules for post-flight check\n        // SENTINEL_OWNERS and SENTINEL_MODULES are both address(0x1)\n        (address[] memory modules,) = safe.getModulesPaginated(SENTINEL_OWNERS, enabledModuleCount);\n        _existingModulesHash = keccak256(abi.encode(modules));\n\n\n        unchecked {\n            ++_guardEntries;\n        }\n    }\n```\n\nhttps://github.com/Hats-Protocol/hats-zodiac/blob/9455cc0957762f5dbbd8e62063d970199109b977/src/HatsSignerGateBase.sol#L547-L591\n```solidity\n    function countValidSignatures(bytes32 dataHash, bytes memory signatures, uint256 sigCount)\n        public\n        view\n        returns (uint256 validSigCount)\n    {\n        // There cannot be an owner with address 0.\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n\n        // @audit-info all signatures are checked\n        for (i; i < sigCount;) {\n            (v, r, s) = signatureSplit(signatures, i);\n            // @audit-info old signature is counted as valid because transaction data is not verified\n            if (v == 0) {\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n            // @audit-info old signature is counted as valid because transaction data is not verified\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner =\n                    ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n\n\n            if (isValidSigner(currentOwner)) {\n                // shouldn't overflow given reasonable sigCount\n                unchecked {\n                    ++validSigCount;\n                }\n            }\n            // shouldn't overflow given reasonable sigCount\n            unchecked {\n                ++i;\n            }\n        }\n    }\n```\n\n## Tool used\nManual Review\n\n## Recommendation\nI propose that in the HatsSignerGate only the first `threshold` signatures are checked. Such that both the Safe and HSG check the SAME signatures.\n\nFix:\n```diff\ndiff --git a/src/HatsSignerGateBase.sol b/src/HatsSignerGateBase.sol\nindex 3e8bb5f..05f85a3 100644\n--- a/src/HatsSignerGateBase.sol\n+++ b/src/HatsSignerGateBase.sol\n@@ -485,7 +485,7 @@ abstract contract HatsSignerGateBase is BaseGuard, SignatureDecoder, HatsOwnedIn\n             safe.nonce() - 1 // view function\n         );\n \n-        uint256 validSigCount = countValidSignatures(txHash, signatures, signatures.length / 65);\n+        uint256 validSigCount = countValidSignatures(txHash, signatures, safe.getThreshold());\n \n         // revert if there aren't enough valid signatures\n         if (validSigCount < safe.getThreshold() || validSigCount < minThreshold) {\n```\n\nInstead of checking all signatures, only the first `threshold` ones will be checked.\nAlso there is no need to check the length of the `signatures` bytes. All those checks are done by the Safe already.\n\n## Discussion\n\n**spengrah**\n\nExcellent find. The recommended fix makes sense.\n\n**spengrah**\n\nhttps://github.com/Hats-Protocol/hats-zodiac/pull/11\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/48",
  "Code": [
    {
      "filename": "contracts/Safe.sol",
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./base/ModuleManager.sol\";\nimport \"./base/OwnerManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./base/GuardManager.sol\";\nimport \"./common/NativeCurrencyPaymentFallback.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./common/StorageAccessible.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./external/SafeMath.sol\";\n\n/**\n * @title Safe - A multisignature wallet with support for confirmations using signed messages based on EIP-712.\n * @dev Most important concepts:\n *      - Threshold: Number of required confirmations for a Safe transaction.\n *      - Owners: List of addresses that control the Safe. They are the only ones that can add/remove owners, change the threshold and\n *        approve transactions. Managed in `OwnerManager`.\n *      - Transaction Hash: Hash of a transaction is calculated using the EIP-712 typed structured data hashing scheme.\n *      - Nonce: Each transaction should have a different nonce to prevent replay attacks.\n *      - Signature: A valid signature of an owner of the Safe for a transaction hash.\n *      - Guard: Guard is a contract that can execute pre- and post- transaction checks. Managed in `GuardManager`.\n *      - Modules: Modules are contracts that can be used to extend the write functionality of a Safe. Managed in `ModuleManager`.\n *      - Fallback: Fallback handler is a contract that can provide additional read-only functional for Safe. Managed in `FallbackManager`.\n *      Note: This version of the implementation contract doesn't emit events for the sake of gas efficiency and therefore requires a tracing node for indexing/\n *      For the events-based implementation see `SafeL2.sol`.\n * @author Stefan George - @Georgi87\n * @author Richard Meissner - @rmeissner\n */\ncontract Safe is\n    Singleton,\n    NativeCurrencyPaymentFallback,\n    ModuleManager,\n    OwnerManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    ISignatureValidatorConstants,\n    FallbackManager,\n    StorageAccessible,\n    GuardManager\n{\n    using SafeMath for uint256;\n\n    string public constant VERSION = \"1.4.0\";\n\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\n    event SignMsg(bytes32 indexed msgHash);\n    event ExecutionFailure(bytes32 txHash, uint256 payment);\n    event ExecutionSuccess(bytes32 txHash, uint256 payment);\n\n    uint256 public nonce;\n    bytes32 private _deprecatedDomainSeparator;\n    // Mapping to keep track of all message hashes that have been approved by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approved by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a singleton for Proxy contracts\n    constructor() {\n        /**\n         * By setting the threshold it is not possible to call setup anymore,\n         * so we create a Safe with 0 owners and threshold 1.\n         * This is an unusable Safe, perfect for the singleton\n         */\n        threshold = 1;\n    }\n\n    /**\n     * @notice Sets an initial storage of the Safe contract.\n     * @dev This method can only be called once.\n     *      If a proxy was created without setting up, anyone can call setup and claim the proxy.\n     * @param _owners List of Safe owners.\n     * @param _threshold Number of required confirmations for a Safe transaction.\n     * @param to Contract address for optional delegate call.\n     * @param data Data payload for optional delegate call.\n     * @param fallbackHandler Handler for fallback calls to this contract\n     * @param paymentToken Token that should be used for the payment (0 is ETH)\n     * @param payment Value that should be paid\n     * @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\n     */\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external {\n        // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n        emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);\n    }\n\n    /** @notice Executes a `operation` {0: Call, 1: DelegateCall}} transaction to `to` with `value` (Native Currency)\n     *          and pays `gasPrice` * `gasLimit` in `gasToken` token to `refundReceiver`.\n     * @dev The fees are always transferred, even if the user transaction fails.\n     * @param to Destination address of Safe transaction.\n     * @param value Ether value of Safe transaction.\n     * @param data Data payload of Safe transaction.\n     * @param operation Operation type of Safe transaction.\n     * @param safeTxGas Gas that should be used for the Safe transaction.\n     * @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n     * @param gasPrice Gas price that should be used for the payment calculation.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     * @return success Boolean indicating transaction's success.\n     */\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable virtual returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData = encodeTransactionData(\n                // Transaction info\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                // Payment info\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                // Signature info\n                nonce\n            );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n        address guard = getGuard();\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, \"GS010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || safeTxGas != 0 || gasPrice != 0, \"GS013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkAfterExecution(txHash, success);\n            }\n        }\n    }\n\n    /**\n     * @notice Handles the payment for a Safe transaction.\n     * @param gasUsed Gas used by the Safe transaction.\n     * @param baseGas Gas costs that are independent of the transaction execution (e.g. base transaction fee, signature check, payment of the refund).\n     * @param gasPrice Gas price that should be used for the payment calculation.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @return payment The amount of payment made in the specified token.\n     */\n    function handlePayment(\n        uint256 gasUsed,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver\n    ) private returns (uint256 payment) {\n        // solhint-disable-next-line avoid-tx-origin\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n        if (gasToken == address(0)) {\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n            require(receiver.send(payment), \"GS011\");\n        } else {\n            payment = gasUsed.add(baseGas).mul(gasPrice);\n            require(transferToken(gasToken, receiver, payment), \"GS012\");\n        }\n    }\n\n    /**\n     * @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     */\n    function checkSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures) public view {\n        // Load threshold to avoid multiple storage loads\n        uint256 _threshold = threshold;\n        // Check that a threshold is set\n        require(_threshold > 0, \"GS001\");\n        checkNSignatures(dataHash, data, signatures, _threshold);\n    }\n\n    /**\n     * @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.\n     * @dev Since the EIP-1271 does an external call, be mindful of reentrancy attacks.\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\n     * @param data That should be signed (this is passed to an external validator contract)\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     * @param requiredSignatures Amount of required valid signatures.\n     */\n    function checkNSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures, uint256 requiredSignatures) public view {\n        // Check that the provided signature data is not too short\n        require(signatures.length >= requiredSignatures.mul(65), \"GS020\");\n        // There cannot be an owner with address 0.\n        address lastOwner = address(0);\n        address currentOwner;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 i;\n        for (i = 0; i < requiredSignatures; i++) {\n            (v, r, s) = signatureSplit(signatures, i);\n            if (v == 0) {\n                require(keccak256(data) == dataHash, \"GS027\");\n                // If v is 0 then it is a contract signature\n                // When handling contract signatures the address of the contract is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n                require(uint256(s) >= requiredSignatures.mul(65), \"GS021\");\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n                require(uint256(s).add(32) <= signatures.length, \"GS022\");\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                uint256 contractSignatureLen;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n                }\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"GS023\");\n\n                // Check signature\n                bytes memory contractSignature;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n                    contractSignature := add(add(signatures, s), 0x20)\n                }\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"GS024\");\n            } else if (v == 1) {\n                // If v is 1 then it is an approved hash\n                // When handling approved hashes the address of the approver is encoded into r\n                currentOwner = address(uint160(uint256(r)));\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"GS025\");\n            } else if (v > 30) {\n                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n            } else {\n                // Default is the ecrecover flow with the provided data hash\n                // Use ecrecover with the messageHash for EOA signatures\n                currentOwner = ecrecover(dataHash, v, r, s);\n            }\n            require(currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS, \"GS026\");\n            lastOwner = currentOwner;\n        }\n    }\n\n    /**\n     * @notice Marks hash `hashToApprove` as approved.\n     * @dev This can be used with a pre-approved hash transaction signature.\n     * @param hashToApprove The hash to mark as approved for signatures that are verified by this contract.\n     */\n    function approveHash(bytes32 hashToApprove) external {\n        require(owners[msg.sender] != address(0), \"GS030\");\n        approvedHashes[msg.sender][hashToApprove] = 1;\n        emit ApproveHash(hashToApprove, msg.sender);\n    }\n\n    /**\n     * @notice Returns the ID of the chain the contract is currently deployed on.\n     * @return The ID of the current chain as a uint256.\n     */\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    /**\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\n     * @return bytes32 The domain separator hash.\n     */\n    function domainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\n    }\n\n    /**\n     * @notice Returns the pre-image of the transaction hash (see getTransactionHash).\n     * @param to Destination address.\n     * @param value Ether value.\n     * @param data Data payload.\n     * @param operation Operation type.\n     * @param safeTxGas Gas that should be used for the safe transaction.\n     * @param baseGas Gas costs for that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n     * @param gasPrice Maximum gas price that should be used for this transaction.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param _nonce Transaction nonce.\n     * @return Transaction hash bytes.\n     */\n    function encodeTransactionData(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes memory) {\n        bytes32 safeTxHash = keccak256(\n            abi.encode(\n                SAFE_TX_TYPEHASH,\n                to,\n                value,\n                keccak256(data),\n                operation,\n                safeTxGas,\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                _nonce\n            )\n        );\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\n    }\n\n    /**\n     * @notice Returns transaction hash to be signed by owners.\n     * @param to Destination address.\n     * @param value Ether value.\n     * @param data Data payload.\n     * @param operation Operation type.\n     * @param safeTxGas Fas that should be used for the safe transaction.\n     * @param baseGas Gas costs for data used to trigger the safe transaction.\n     * @param gasPrice Maximum gas price that should be used for this transaction.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param _nonce Transaction nonce.\n     * @return Transaction hash.\n     */\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) public view returns (bytes32) {\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n    }\n}"
    },
    {
      "filename": "contracts/Safe.sol",
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./base/ModuleManager.sol\";\nimport \"./base/OwnerManager.sol\";\nimport \"./base/FallbackManager.sol\";\nimport \"./base/GuardManager.sol\";\nimport \"./common/NativeCurrencyPaymentFallback.sol\";\nimport \"./common/Singleton.sol\";\nimport \"./common/SignatureDecoder.sol\";\nimport \"./common/SecuredTokenTransfer.sol\";\nimport \"./common/StorageAccessible.sol\";\nimport \"./interfaces/ISignatureValidator.sol\";\nimport \"./external/SafeMath.sol\";\n\n/**\n * @title Safe - A multisignature wallet with support for confirmations using signed messages based on EIP-712.\n * @dev Most important concepts:\n *      - Threshold: Number of required confirmations for a Safe transaction.\n *      - Owners: List of addresses that control the Safe. They are the only ones that can add/remove owners, change the threshold and\n *        approve transactions. Managed in `OwnerManager`.\n *      - Transaction Hash: Hash of a transaction is calculated using the EIP-712 typed structured data hashing scheme.\n *      - Nonce: Each transaction should have a different nonce to prevent replay attacks.\n *      - Signature: A valid signature of an owner of the Safe for a transaction hash.\n *      - Guard: Guard is a contract that can execute pre- and post- transaction checks. Managed in `GuardManager`.\n *      - Modules: Modules are contracts that can be used to extend the write functionality of a Safe. Managed in `ModuleManager`.\n *      - Fallback: Fallback handler is a contract that can provide additional read-only functional for Safe. Managed in `FallbackManager`.\n *      Note: This version of the implementation contract doesn't emit events for the sake of gas efficiency and therefore requires a tracing node for indexing/\n *      For the events-based implementation see `SafeL2.sol`.\n * @author Stefan George - @Georgi87\n * @author Richard Meissner - @rmeissner\n */\ncontract Safe is\n    Singleton,\n    NativeCurrencyPaymentFallback,\n    ModuleManager,\n    OwnerManager,\n    SignatureDecoder,\n    SecuredTokenTransfer,\n    ISignatureValidatorConstants,\n    FallbackManager,\n    StorageAccessible,\n    GuardManager\n{\n    using SafeMath for uint256;\n\n    string public constant VERSION = \"1.4.0\";\n\n    // keccak256(\n    //     \"EIP712Domain(uint256 chainId,address verifyingContract)\"\n    // );\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\n\n    // keccak256(\n    //     \"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\"\n    // );\n    bytes32 private constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\n\n    event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);\n    event ApproveHash(bytes32 indexed approvedHash, address indexed owner);\n    event SignMsg(bytes32 indexed msgHash);\n    event ExecutionFailure(bytes32 txHash, uint256 payment);\n    event ExecutionSuccess(bytes32 txHash, uint256 payment);\n\n    uint256 public nonce;\n    bytes32 private _deprecatedDomainSeparator;\n    // Mapping to keep track of all message hashes that have been approved by ALL REQUIRED owners\n    mapping(bytes32 => uint256) public signedMessages;\n    // Mapping to keep track of all hashes (message or transaction) that have been approved by ANY owners\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\n\n    // This constructor ensures that this contract can only be used as a singleton for Proxy contracts\n    constructor() {\n        /**\n         * By setting the threshold it is not possible to call setup anymore,\n         * so we create a Safe with 0 owners and threshold 1.\n         * This is an unusable Safe, perfect for the singleton\n         */\n        threshold = 1;\n    }\n\n    /**\n     * @notice Sets an initial storage of the Safe contract.\n     * @dev This method can only be called once.\n     *      If a proxy was created without setting up, anyone can call setup and claim the proxy.\n     * @param _owners List of Safe owners.\n     * @param _threshold Number of required confirmations for a Safe transaction.\n     * @param to Contract address for optional delegate call.\n     * @param data Data payload for optional delegate call.\n     * @param fallbackHandler Handler for fallback calls to this contract\n     * @param paymentToken Token that should be used for the payment (0 is ETH)\n     * @param payment Value that should be paid\n     * @param paymentReceiver Address that should receive the payment (or 0 if tx.origin)\n     */\n    function setup(\n        address[] calldata _owners,\n        uint256 _threshold,\n        address to,\n        bytes calldata data,\n        address fallbackHandler,\n        address paymentToken,\n        uint256 payment,\n        address payable paymentReceiver\n    ) external {\n        // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\n        setupOwners(_owners, _threshold);\n        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n        setupModules(to, data);\n\n        if (payment > 0) {\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n        }\n        emit SafeSetup(msg.sender, _owners, _threshold, to, fallbackHandler);\n    }\n\n    /** @notice Executes a `operation` {0: Call, 1: DelegateCall}} transaction to `to` with `value` (Native Currency)\n     *          and pays `gasPrice` * `gasLimit` in `gasToken` token to `refundReceiver`.\n     * @dev The fees are always transferred, even if the user transaction fails.\n     * @param to Destination address of Safe transaction.\n     * @param value Ether value of Safe transaction.\n     * @param data Data payload of Safe transaction.\n     * @param operation Operation type of Safe transaction.\n     * @param safeTxGas Gas that should be used for the Safe transaction.\n     * @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\n     * @param gasPrice Gas price that should be used for the payment calculation.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\n     * @param signatures Signature data that should be verified.\n     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.\n     * @return success Boolean indicating transaction's success.\n     */\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures\n    ) public payable virtual returns (bool success) {\n        bytes32 txHash;\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            bytes memory txHashData = encodeTransactionData(\n                // Transaction info\n                to,\n                value,\n                data,\n                operation,\n                safeTxGas,\n                // Payment info\n                baseGas,\n                gasPrice,\n                gasToken,\n                refundReceiver,\n                // Signature info\n                nonce\n            );\n            // Increase nonce and execute transaction.\n            nonce++;\n            txHash = keccak256(txHashData);\n            checkSignatures(txHash, txHashData, signatures);\n        }\n        address guard = getGuard();\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkTransaction(\n                    // Transaction info\n                    to,\n                    value,\n                    data,\n                    operation,\n                    safeTxGas,\n                    // Payment info\n                    baseGas,\n                    gasPrice,\n                    gasToken,\n                    refundReceiver,\n                    // Signature info\n                    signatures,\n                    msg.sender\n                );\n            }\n        }\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n        require(gasleft() >= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, \"GS010\");\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n        {\n            uint256 gasUsed = gasleft();\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n            gasUsed = gasUsed.sub(gasleft());\n            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n            require(success || safeTxGas != 0 || gasPrice != 0, \"GS013\");\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\n            uint256 payment = 0;\n            if (gasPrice > 0) {\n                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n            }\n            if (success) emit ExecutionSuccess(txHash, payment);\n            else emit ExecutionFailure(txHash, payment);\n        }\n        {\n            if (guard != address(0)) {\n                Guard(guard).checkAfterExecution(txHash, success);\n            }\n        }\n    }\n\n    /**\n     * @notice Handles the payment for a Safe transaction.\n     * @param gasUsed Gas used by the Safe transaction.\n     * @param baseGas Gas costs that are independent of the transaction execution (e.g. base transaction fee, signature check, payment of the refund).\n     * @param gasPrice Gas price that should be used for the payment calculation.\n     * @param gasToken Token address (or 0 if ETH) that is used for the payment.\n     * @return payment The amount of payment made in the specified token.\n     */\n    function handlePayment(\n        uint256 gasUsed,\n        ui"
    }
  ]
}