{
  "Title": "[L-01] Prevent gas griefing attacks that's possible with custom `address.call`",
  "Content": "\nThere are 3 instances of this:\n- https://github.com/code-423n4/2024-01-decent/blob/07ef78215e3d246d47a410651906287c6acec3ef/src/UTBExecutor.sol#L52\n- https://github.com/code-423n4/2024-01-decent/blob/07ef78215e3d246d47a410651906287c6acec3ef/src/UTBExecutor.sol#L65\n- https://github.com/code-423n4/2024-01-decent/blob/07ef78215e3d246d47a410651906287c6acec3ef/src/UTBExecutor.sol#L70\n\nWhenever the returned `bytes data` is not required, using the `.call()` function with non TRUSTED addresses opens the transaction to unnecessary gas griefing by return huge `bytes data`.\n\nNote that this:\n```\n(success, ) = target.call{value: amount}(payload);\n```\nIs the same thing as this:\n```\n(success, bytes data ) = target.call{value: amount}(payload);\n```\nSo in both cases, the `bytes data` is returned and copied to memory. Malicious `target address` can return huge `bytes data` to cause gas grief to the sender. \n\n### Impact: \n\nMalicious `target address` can gas grief the sender making the sender waste more gas than necessary.\n\n### Recommendation:\n\nShort term: When returned data is not required, use a low level call:\n```\nbool status;\nassembly {\n    status := call(gas(), receiver, amount, 0, 0, 0, 0)\n}\nrequire(status, \"call failed\");\n```\nLong Term: Consider using https://github.com/nomad-xyz/ExcessivelySafeCall\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-decent",
  "Code": [
    {
      "filename": "src/UTBExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\n\ncontract UTBExecutor is Owned {\n    constructor() Owned(msg.sender) {}\n\n    /**\n     * @dev Executes a payment transaction with native OR ERC20.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param token The token being transferred, zero address for native.\n     * @param amount The amount of native or ERC20 being sent with the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA that initiated the transaction.\n     */\n    function execute(\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address token,\n        uint amount,\n        address payable refund\n    ) public payable onlyOwner {\n        return\n            execute(target, paymentOperator, payload, token, amount, refund, 0);\n    }\n\n    /**\n     * @dev Executes a payment transaction with native AND/OR ERC20.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param token The token being transferred, zero address for native.\n     * @param amount The amount of native or ERC20 being sent with the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA that initiated the transaction.\n     * @param extraNative Forwards additional gas or native fees required to executing the payment transaction.\n     */\n    function execute(\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address token,\n        uint amount,\n        address payable refund,\n        uint extraNative\n    ) public onlyOwner {\n        bool success;\n        if (token == address(0)) {\n            (success, ) = target.call{value: amount}(payload);\n            if (!success) {\n                (refund.call{value: amount}(\"\"));\n            }\n            return;\n        }\n\n        uint initBalance = IERC20(token).balanceOf(address(this));\n\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n        IERC20(token).approve(paymentOperator, amount);\n\n        if (extraNative > 0) {\n            (success, ) = target.call{value: extraNative}(payload);\n            if (!success) {\n                (refund.call{value: extraNative}(\"\"));\n            }\n        } else {\n            (success, ) = target.call(payload);\n        }\n\n        uint remainingBalance = IERC20(token).balanceOf(address(this)) -\n            initBalance;\n\n        if (remainingBalance == 0) {\n            return;\n        }\n\n        IERC20(token).transfer(refund, remainingBalance);\n    }\n}"
    },
    {
      "filename": "src/UTBExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\n\ncontract UTBExecutor is Owned {\n    constructor() Owned(msg.sender) {}\n\n    /**\n     * @dev Executes a payment transaction with native OR ERC20.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param token The token being transferred, zero address for native.\n     * @param amount The amount of native or ERC20 being sent with the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA that initiated the transaction.\n     */\n    function execute(\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address token,\n        uint amount,\n        address payable refund\n    ) public payable onlyOwner {\n        return\n            execute(target, paymentOperator, payload, token, amount, refund, 0);\n    }\n\n    /**\n     * @dev Executes a payment transaction with native AND/OR ERC20.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param token The token being transferred, zero address for native.\n     * @param amount The amount of native or ERC20 being sent with the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA that initiated the transaction.\n     * @param extraNative Forwards additional gas or native fees required to executing the payment transaction.\n     */\n    function execute(\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address token,\n        uint amount,\n        address payable refund,\n        uint extraNative\n    ) public onlyOwner {\n        bool success;\n        if (token == address(0)) {\n            (success, ) = target.call{value: amount}(payload);\n            if (!success) {\n                (refund.call{value: amount}(\"\"));\n            }\n            return;\n        }\n\n        uint initBalance = IERC20(token).balanceOf(address(this));\n\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n        IERC20(token).approve(paymentOperator, amount);\n\n        if (extraNative > 0) {\n            (success, ) = target.call{value: extraNative}(payload);\n            if (!success) {\n                (refund.call{value: extraNative}(\"\"));\n            }\n        } else {\n            (success, ) = target.call(payload);\n        }\n\n        uint remainingBalance = IERC20(token).balanceOf(address(this)) -\n            initBalance;\n\n        if (remainingBalance == 0) {\n            return;\n        }\n\n        IERC20(token).transfer(refund, remainingBalance);\n    }\n}"
    },
    {
      "filename": "src/UTBExecutor.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\n\ncontract UTBExecutor is Owned {\n    constructor() Owned(msg.sender) {}\n\n    /**\n     * @dev Executes a payment transaction with native OR ERC20.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param token The token being transferred, zero address for native.\n     * @param amount The amount of native or ERC20 being sent with the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA that initiated the transaction.\n     */\n    function execute(\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address token,\n        uint amount,\n        address payable refund\n    ) public payable onlyOwner {\n        return\n            execute(target, paymentOperator, payload, token, amount, refund, 0);\n    }\n\n    /**\n     * @dev Executes a payment transaction with native AND/OR ERC20.\n     * @param target The address of the target contract for the payment transaction.\n     * @param paymentOperator The operator address for payment transfers requiring ERC20 approvals.\n     * @param payload The calldata to execute the payment transaction.\n     * @param token The token being transferred, zero address for native.\n     * @param amount The amount of native or ERC20 being sent with the payment transaction.\n     * @param refund The account receiving any refunds, typically the EOA that initiated the transaction.\n     * @param extraNative Forwards additional gas or native fees required to executing the payment transaction.\n     */\n    function execute(\n        address target,\n        address paymentOperator,\n        bytes memory payload,\n        address token,\n        uint amount,\n        address payable refund,\n        uint extraNative\n    ) public onlyOwner {\n        bool success;\n        if (token == address(0)) {\n            (success, ) = target.call{value: amount}(payload);\n            if (!success) {\n                (refund.call{value: amount}(\"\"));\n            }\n            return;\n        }\n\n        uint initBalance = IERC20(token).balanceOf(address(this));\n\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n        IERC20(token).approve(paymentOperator, amount);\n\n        if (extraNative > 0) {\n            (success, ) = target.call{value: extraNative}(payload);\n            if (!success) {\n                (refund.call{value: extraNative}(\"\"));\n            }\n        } else {\n            (success, ) = target.call(payload);\n        }\n\n        uint remainingBalance = IERC20(token).balanceOf(address(this)) -\n            initBalance;\n\n        if (remainingBalance == 0) {\n            return;\n        }\n\n        IERC20(token).transfer(refund, remainingBalance);\n    }\n}"
    }
  ]
}