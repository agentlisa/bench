{
  "Title": "[H-12] Modifier VaultController._verifyCreatorOrOwner does not work as intented",
  "Content": "\n<https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L666-L670> \n\n<https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L448> \n\n<https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L608> \n\n<https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L621> \n\n<https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L634>\n\n<https://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L647>\n\n### Impact\n\nModifier `VaultController._verifyCreatorOrOwner` does not work. Instead of checking the condition `msg.sender is creator OR owner`, it makes `msg.sender is creator AND owner`. This would block access to all created Vaults for creators and the owner (if he did not create them).\n\nSpecifically, the following functions in the `VaultController` are affected:\n\n*   `addStakingRewardsTokens()`;\n*   `deployVault()`, which has a call to `addStakingRewardsTokens()`, cannot be executed if the argument `rewardsData.length != 0`;\n*   `pauseAdapters()`;\n*   `pauseVaults()`;\n*   `unpauseAdapters()`;\n*   `unpauseVaults()`.\n\n### Proof of Concept\n\nTo check this concept, we can make a truth table for the main condition in the modifier `msg.sender != metadata.creator || msg.sender != owner`. The table shows that the condition will equal `false` only in the one case where `msg.sender` is both creator and owner.\n\n| msg.sender != metadata.creator | msg.sender != owner | msg.sender != metadata.creator \\|\\| msg.sender != owner |\n| ------------------------------ | ------------------- | ------------------------------------------------------- |\n| 0                              | 0                   | 0                                                       |\n| 0                              | 1                   | 1                                                       |\n| 1                              | 0                   | 1                                                       |\n| 1                              | 1                   | 1                                                       |\n\nThe correct condition should be the following: `msg.sender != metadata.creator && msg.sender != owner`.\n\n| msg.sender != metadata.creator | msg.sender != owner | msg.sender != metadata.creator && msg.sender != owner |\n| ------------------------------ | ------------------- | ----------------------------------------------------- |\n| 0                              | 0                   | 0                                                     |\n| 0                              | 1                   | 0                                                     |\n| 1                              | 0                   | 0                                                     |\n| 1                              | 1                   | 1                                                     |\n\nIn this case, a revert will only happen when `msg.sender` is neither a creator nor the owner, as it should be according to the documentation.\n\nYou can also use the following test to check; add it to the file `test\\vault\\VaultController.t.sol`:\n\n```solidity\nfunction testFail__deployVault_creator_is_not_owner_audit() public {\n    addTemplate(\"Adapter\", templateId, adapterImpl, true, true);\n    addTemplate(\"Strategy\", \"MockStrategy\", strategyImpl, false, true);\n    addTemplate(\"Vault\", \"V1\", vaultImpl, true, true);\n    controller.setPerformanceFee(uint256(1000));\n    controller.setHarvestCooldown(1 days);\n    rewardToken.mint(bob, 10 ether);\n    rewardToken.approve(address(controller), 10 ether);\n\n    swapTokenAddresses[0] = address(0x9999);\n    address adapterClone = 0xD6C5fA22BBE89db86245e111044a880213b35705;\n    address strategyClone = 0xe8a41C57AB0019c403D35e8D54f2921BaE21Ed66;\n    address stakingClone = 0xE64C695617819cE724c1d35a37BCcFbF5586F752;\n\n    uint256 callTimestamp = block.timestamp;\n    vm.prank(bob);\n    address vaultClone = controller.deployVault(\n        VaultInitParams({\n            asset: iAsset,\n            adapter: IERC4626(address(0)),\n            fees: VaultFees({\n                deposit: 100,\n                withdrawal: 200,\n                management: 300,\n                performance: 400\n            }),\n            feeRecipient: feeRecipient,\n            owner: bob\n        }),\n        DeploymentArgs({id: templateId, data: abi.encode(uint256(100))}),\n        DeploymentArgs({id: \"MockStrategy\", data: \"\"}),\n        address(0),\n        abi.encode(\n            address(rewardToken),\n            0.1 ether,\n            1 ether,\n            true,\n            10000000,\n            2 days,\n            1 days\n        ),\n        VaultMetadata({\n            vault: address(0),\n            staking: address(0),\n            creator: bob,\n            metadataCID: metadataCid,\n            swapTokenAddresses: swapTokenAddresses,\n            swapAddress: address(0x5555),\n            exchange: uint256(1)\n        }),\n        0\n    );\n}\n```\n\nIn the test's log (`forge test --match-test \"testFail__deployVault_creator_is_not_owner\" -vvvv`), you can see that the call ended with revert `NotSubmitterNorOwner(0x000000000000000000000000000000000000000000000000DCbA)`.\n\n### Tools Used\n\nVSCodium, Forge\n\n### Recommended Mitigation Steps\n\nChange the condition to `msg.sender != metadata.creator && msg.sender != owner`.\n\n**[RedVeil (Popcorn) confirmed, but disagreed with severity](https://github.com/code-423n4/2023-01-popcorn-findings/issues/45)** \n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-01-popcorn",
  "Code": [
    {
      "filename": "src/vault/VaultController.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\npragma solidity ^0.8.15;\n\nimport { SafeERC20Upgradeable as SafeERC20 } from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { Owned } from \"../utils/Owned.sol\";\nimport { IVault, VaultInitParams, VaultFees } from \"../interfaces/vault/IVault.sol\";\nimport { IMultiRewardStaking } from \"../interfaces/IMultiRewardStaking.sol\";\nimport { IMultiRewardEscrow } from \"../interfaces/IMultiRewardEscrow.sol\";\nimport { IDeploymentController, ICloneRegistry } from \"../interfaces/vault/IDeploymentController.sol\";\nimport { ITemplateRegistry, Template } from \"../interfaces/vault/ITemplateRegistry.sol\";\nimport { IPermissionRegistry, Permission } from \"../interfaces/vault/IPermissionRegistry.sol\";\nimport { IVaultRegistry, VaultMetadata } from \"../interfaces/vault/IVaultRegistry.sol\";\nimport { IAdminProxy } from \"../interfaces/vault/IAdminProxy.sol\";\nimport { IERC4626, IERC20 } from \"../interfaces/vault/IERC4626.sol\";\nimport { IStrategy } from \"../interfaces/vault/IStrategy.sol\";\nimport { IAdapter } from \"../interfaces/vault/IAdapter.sol\";\nimport { IPausable } from \"../interfaces/IPausable.sol\";\nimport { DeploymentArgs } from \"../interfaces/vault/IVaultController.sol\";\n\n/**\n * @title   VaultController\n * @author  RedVeil\n * @notice  Admin contract for the vault ecosystem.\n *\n * Deploys Vaults, Adapter, Strategies and Staking contracts.\n * Calls admin functions on deployed contracts.\n */\ncontract VaultController is Owned {\n  using SafeERC20 for IERC20;\n\n  /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n  bytes32 public immutable VAULT = \"Vault\";\n  bytes32 public immutable ADAPTER = \"Adapter\";\n  bytes32 public immutable STRATEGY = \"Strategy\";\n  bytes32 public immutable STAKING = \"Staking\";\n  bytes4 internal immutable DEPLOY_SIG = bytes4(keccak256(\"deploy(bytes32,bytes32,bytes)\"));\n\n  error UnderlyingError(bytes revertReason);\n\n  /**\n   * @notice Constructor of this contract.\n   * @param _owner Owner of the contract. Controls management functions.\n   * @param _adminProxy `AdminProxy` ownes contracts in the vault ecosystem.\n   * @param _deploymentController `DeploymentController` with auxiliary deployment contracts.\n   * @param _vaultRegistry `VaultRegistry` to safe vault metadata.\n   * @param _permissionRegistry `permissionRegistry` to add endorsements and rejections.\n   * @param _escrow `MultiRewardEscrow` To escrow rewards of staking contracts.\n   */\n  constructor(\n    address _owner,\n    IAdminProxy _adminProxy,\n    IDeploymentController _deploymentController,\n    IVaultRegistry _vaultRegistry,\n    IPermissionRegistry _permissionRegistry,\n    IMultiRewardEscrow _escrow\n  ) Owned(_owner) {\n    adminProxy = _adminProxy;\n    vaultRegistry = _vaultRegistry;\n    permissionRegistry = _permissionRegistry;\n    escrow = _escrow;\n\n    _setDeploymentController(_deploymentController);\n\n    activeTemplateId[STAKING] = \"MultiRewardStaking\";\n    activeTemplateId[VAULT] = \"V1\";\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          VAULT DEPLOYMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  event VaultDeployed(address indexed vault, address indexed staking, address indexed adapter);\n\n  /**\n   * @notice Deploy a new Vault. Optionally with an Adapter and Staking. Caller must be owner.\n   * @param vaultData Vault init params.\n   * @param adapterData Encoded adapter init data.\n   * @param strategyData Encoded strategy init data.\n   * @param staking Address of staking contract to use for the vault. If 0, a new staking contract will be deployed.\n   * @param rewardsData Encoded data to add a rewards to the staking contract\n   * @param metadata Vault metadata for the `VaultRegistry` (Will be used by the frontend for additional informations)\n   * @param initialDeposit Initial deposit to the vault. If 0, no deposit will be made.\n   * @dev This function is the one stop solution to create a new vault with all necessary admin functions or auxiliery contracts.\n   */\n  function deployVault(\n    VaultInitParams memory vaultData,\n    DeploymentArgs memory adapterData,\n    DeploymentArgs memory strategyData,\n    address staking,\n    bytes memory rewardsData,\n    VaultMetadata memory metadata,\n    uint256 initialDeposit\n  ) external canCreate returns (address vault) {\n    IDeploymentController _deploymentController = deploymentController;\n\n    _verifyToken(address(vaultData.asset));\n    _verifyAdapterConfiguration(address(vaultData.adapter), adapterData.id);\n\n    if (adapterData.id > 0)\n      vaultData.adapter = IERC4626(_deployAdapter(vaultData.asset, adapterData, strategyData, _deploymentController));\n\n    vault = _deployVault(vaultData, _deploymentController);\n\n    if (staking == address(0)) staking = _deployStaking(IERC20(address(vault)), _deploymentController);\n\n    _registerCreatedVault(vault, staking, metadata);\n\n    if (rewardsData.length > 0) _handleVaultStakingRewards(vault, rewardsData);\n\n    emit VaultDeployed(vault, staking, address(vaultData.adapter));\n\n    _handleInitialDeposit(initialDeposit, IERC20(vaultData.asset), IERC4626(vault));\n  }\n\n  /// @notice Deploys a new vault contract using the `activeTemplateId`.\n  function _deployVault(VaultInitParams memory vaultData, IDeploymentController _deploymentController)\n    internal\n    returns (address vault)\n  {\n    vaultData.owner = address(adminProxy);\n\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(\n        DEPLOY_SIG,\n        VAULT,\n        activeTemplateId[VAULT],\n        abi.encodeWithSelector(IVault.initialize.selector, vaultData)\n      )\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    vault = abi.decode(returnData, (address));\n  }\n\n  /// @notice Registers newly created vault metadata.\n  function _registerCreatedVault(\n    address vault,\n    address staking,\n    VaultMetadata memory metadata\n  ) internal {\n    metadata.vault = vault;\n    metadata.staking = staking;\n    metadata.creator = msg.sender;\n\n    _registerVault(vault, metadata);\n  }\n\n  /// @notice Prepares and calls `addStakingRewardsTokens` for the newly created staking contract.\n  function _handleVaultStakingRewards(address vault, bytes memory rewardsData) internal {\n    address[] memory vaultContracts = new address[](1);\n    bytes[] memory rewardsDatas = new bytes[](1);\n\n    vaultContracts[0] = vault;\n    rewardsDatas[0] = rewardsData;\n\n    addStakingRewardsTokens(vaultContracts, rewardsDatas);\n  }\n\n  function _handleInitialDeposit(\n    uint256 initialDeposit,\n    IERC20 asset,\n    IERC4626 target\n  ) internal {\n    if (initialDeposit > 0) {\n      asset.safeTransferFrom(msg.sender, address(this), initialDeposit);\n      asset.approve(address(target), initialDeposit);\n      target.deposit(initialDeposit, msg.sender);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      ADAPTER DEPLOYMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Deploy a new Adapter with our without a strategy. Caller must be owner.\n   * @param asset Asset which will be used by the adapter.\n   * @param adapterData Encoded adapter init data.\n   * @param strategyData Encoded strategy init data.\n   */\n  function deployAdapter(\n    IERC20 asset,\n    DeploymentArgs memory adapterData,\n    DeploymentArgs memory strategyData,\n    uint256 initialDeposit\n  ) external canCreate returns (address adapter) {\n    _verifyToken(address(asset));\n\n    adapter = _deployAdapter(asset, adapterData, strategyData, deploymentController);\n\n    _handleInitialDeposit(initialDeposit, asset, IERC4626(adapter));\n  }\n\n  /**\n   * @notice Deploys an adapter and optionally a strategy.\n   * @dev Adds the newly deployed strategy to the adapter.\n   */\n  function _deployAdapter(\n    IERC20 asset,\n    DeploymentArgs memory adapterData,\n    DeploymentArgs memory strategyData,\n    IDeploymentController _deploymentController\n  ) internal returns (address) {\n    address strategy;\n    bytes4[8] memory requiredSigs;\n    if (strategyData.id > 0) {\n      strategy = _deployStrategy(strategyData, _deploymentController);\n      requiredSigs = templateRegistry.getTemplate(STRATEGY, strategyData.id).requiredSigs;\n    }\n\n    return\n      __deployAdapter(\n        adapterData,\n        abi.encode(asset, address(adminProxy), IStrategy(strategy), harvestCooldown, requiredSigs, strategyData.data),\n        _deploymentController\n      );\n  }\n\n  /// @notice Deploys an adapter and sets the management fee via `AdminProxy`\n  function __deployAdapter(\n    DeploymentArgs memory adapterData,\n    bytes memory baseAdapterData,\n    IDeploymentController _deploymentController\n  ) internal returns (address adapter) {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(DEPLOY_SIG, ADAPTER, adapterData.id, _encodeAdapterData(adapterData, baseAdapterData))\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    adapter = abi.decode(returnData, (address));\n\n    adminProxy.execute(adapter, abi.encodeWithSelector(IAdapter.setPerformanceFee.selector, performanceFee));\n  }\n\n  /// @notice Encodes adapter init call. Was moved into its own function to fix \"stack too deep\" error.\n  function _encodeAdapterData(DeploymentArgs memory adapterData, bytes memory baseAdapterData)\n    internal\n    returns (bytes memory)\n  {\n    return\n      abi.encodeWithSelector(\n        IAdapter.initialize.selector,\n        baseAdapterData,\n        templateRegistry.getTemplate(ADAPTER, adapterData.id).registry,\n        adapterData.data\n      );\n  }\n\n  /// @notice Deploys a new strategy contract.\n  function _deployStrategy(DeploymentArgs memory strategyData, IDeploymentController _deploymentController)\n    internal\n    returns (address strategy)\n  {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(DEPLOY_SIG, STRATEGY, strategyData.id, \"\")\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    strategy = abi.decode(returnData, (address));\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    STAKING DEPLOYMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Deploy a new staking contract. Caller must be owner.\n   * @param asset The staking token for the new contract.\n   * @dev Deploys `MultiRewardsStaking` based on the latest templateTemplateKey.\n   */\n  function deployStaking(IERC20 asset) external canCreate returns (address) {\n    _verifyToken(address(asset));\n    return _deployStaking(asset, deploymentController);\n  }\n\n  /// @notice Deploys a new staking contract using the activeTemplateId.\n  function _deployStaking(IERC20 asset, IDeploymentController _deploymentController)\n    internal\n    returns (address staking)\n  {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(\n        DEPLOY_SIG,\n        STAKING,\n        activeTemplateId[STAKING],\n        abi.encodeWithSelector(IMultiRewardStaking.initialize.selector, asset, escrow, adminProxy)\n      )\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    staking = abi.decode(returnData, (address));\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    VAULT MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  error DoesntExist(address adapter);\n\n  /**\n   * @notice Propose a new Adapter. Caller must be creator of the vaults.\n   * @param vaults Vaults to propose the new adapter for.\n   * @param newAdapter New adapters to propose.\n   */\n  function proposeVaultAdapters(address[] calldata vaults, IERC4626[] calldata newAdapter) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, newAdapter.length);\n\n    ICloneRegistry _cloneRegistry = cloneRegistry;\n    for (uint8 i = 0; i < len; i++) {\n      _verifyCreator(vaults[i]);\n      if (!_cloneRegistry.cloneExists(address(newAdapter[i]))) revert DoesntExist(address(newAdapter[i]));\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.proposeAdapter.selector, newAdapter[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Change adapter of a vault to the previously proposed adapter.\n   * @param vaults Addresses of the vaults to change\n   */\n  function changeVaultAdapters(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint8 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.changeAdapter.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Sets new fees per vault. Caller must be creator of the vaults.\n   * @param vaults Addresses of the vaults to change\n   * @param fees New fee structures for these vaults\n   * @dev Value is in 1e18, e.g. 100% = 1e18 - 1 BPS = 1e12\n   */\n  function proposeVaultFees(address[] calldata vaults, VaultFees[] calldata fees) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, fees.length);\n\n    for (uint8 i = 0; i < len; i++) {\n      _verifyCreator(vaults[i]);\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.proposeFees.selector, fees[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Change adapter of a vault to the previously proposed adapter.\n   * @param vaults Addresses of the vaults\n   */\n  function changeVaultFees(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint8 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.changeFees.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          REGISTER VAULT\n    //////////////////////////////////////////////////////////////*/\n\n  IVaultRegistry public vaultRegistry;\n\n  /// @notice Call the `VaultRegistry` to register a vault via `AdminProxy`\n  function _registerVault(address vault, VaultMetadata memory metadata) internal {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(vaultRegistry),\n      abi.encodeWithSelector(IVaultRegistry.registerVault.selector, metadata)\n    );\n    if (!success) revert UnderlyingError(returnData);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    ENDORSEMENT / REJECTION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Set permissions for an array of target. Caller must be owner.\n   * @param targets `AdminProxy`\n   * @param newPermissions An array of permissions to set for the targets.\n   * @dev See `PermissionRegistry` for more details\n   */\n  function setPermissions(address[] calldata targets, Permission[] calldata newPermissions) external onlyOwner {\n    // No need to check matching array length since its already done in the permissionRegistry\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(permissionRegistry),\n      abi.encodeWithSelector(IPermissionRegistry.setPermissions.selector, targets, newPermissions)\n    );\n    if (!success) revert UnderlyingError(returnData);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      STAKING MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n  /**\n   * @notice Adds a new rewardToken which can be earned via staking. Caller must be creator of the Vault or owner.\n   * @param vaults Vaults of which the staking contracts should be targeted\n   * @param rewardTokenData Token that can be earned by staking.\n   * @dev `rewardToken` - Token that can be earned by staking.\n   * @dev `rewardsPerSecond` - The rate in which `rewardToken` will be accrued.\n   * @dev `amount` - Initial funding amount for this reward.\n   * @dev `useEscrow Bool` - if the rewards should be escrowed on claim.\n   * @dev `escrowPercentage` - The percentage of the reward that gets escrowed in 1e18. (1e18 = 100%, 1e14 = 1 BPS)\n   * @dev `escrowDuration` - The duration of the escrow.\n   * @dev `offset` - A cliff after claim before the escrow starts.\n   * @dev See `MultiRewardsStaking` for more details.\n   */\n  function addStakingRewardsTokens(address[] memory vaults, bytes[] memory rewardTokenData) public {\n    _verifyEqualArrayLength(vaults.length, rewardTokenData.length);\n    address staking;\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      (\n        address rewardsToken,\n        uint160 rewardsPerSecond,\n        uint256 amount,\n        bool useEscrow,\n        uint224 escrowDuration,\n        uint24 escrowPercentage,\n        uint256 offset\n      ) = abi.decode(rewardTokenData[i], (address, uint160, uint256, bool, uint224, uint24, uint256));\n      _verifyToken(rewardsToken);\n      staking = _verifyCreatorOrOwner(vaults[i]).staking;\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        rewardsToken,\n        abi.encodeWithSelector(IERC20.approve.selector, staking, type(uint256).max)\n      );\n      if (!success) revert UnderlyingError(returnData);\n\n      IERC20(rewardsToken).approve(staking, type(uint256).max);\n      IERC20(rewardsToken).transferFrom(msg.sender, address(adminProxy), amount);\n\n      (success, returnData) = adminProxy.execute(\n        staking,\n        abi.encodeWithSelector(\n          IMultiRewardStaking.addRewardToken.selector,\n          rewardsToken,\n          rewardsPerSecond,\n          amount,\n          useEscrow,\n          escrowDuration,\n          escrowPercentage,\n          offset\n        )\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Changes rewards speed for a rewardToken. This works only for rewards that accrue over time. Caller must be creator of the Vault.\n   * @param vaults Vaults of which the staking contracts should be targeted\n   * @param rewardTokens Token that can be earned by staking.\n   * @param rewardsSpeeds The rate in which `rewardToken` will be accrued.\n   * @dev See `MultiRewardsStaking` for more details.\n   */\n  function changeStakingRewardsSpeeds(\n    address[] calldata vaults,\n    IERC20[] calldata rewardTokens,\n    uint160[] calldata rewardsSpeeds\n  ) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, rewardTokens.length);\n    _verifyEqualArrayLength(len, rewardsSpeeds.length);\n\n    address staking;\n    for (uint256 i = 0; i < len; i++) {\n      staking = _verifyCreator(vaults[i]).staking;\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        staking,\n        abi.encodeWithSelector(IMultiRewardStaking.changeRewardSpeed.selector, rewardTokens[i], rewardsSpeeds[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Funds rewards for a rewardToken.\n   * @param vaults Vaults of which the staking contracts should be targeted\n   * @param rewardTokens Token that can be earned by staking.\n   * @param amounts The amount of rewardToken that will fund this reward.\n   * @dev See `MultiRewardStaking` for more details.\n   */\n  function fundStakingRewards(\n    address[] calldata vaults,\n    IERC20[] calldata rewardTokens,\n    uint256[] calldata amounts\n  ) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, rewardTokens.length);\n    _verifyEqualArrayLength(len, amounts.length);\n\n    address staking;\n    for (uint256 i = 0; i < len; i++) {\n      staking = vaultRegistry.getVault(vaults[i]).staking;\n\n      rewardTokens[i].transferFrom(msg.sender, address(this), amounts[i]);\n      IMultiRewardStaking(staking).fundReward(rewardTokens[i], amounts[i]);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      ESCROW MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  IMultiRewardEscrow public escrow;\n\n  /**\n   * @notice Set fees for multiple tokens. Caller must be the owner.\n   * @param tokens Array of tokens.\n   * @param fees Array of fees for `tokens` in 1e18. (1e18 = 100%, 1e14 = 1 BPS)\n   * @dev See `MultiRewardEscrow` for more details.\n   */\n  function setEscrowTokenFees(IERC20[] calldata tokens, uint256[] calldata fees) external onlyOwner {\n    _verifyEqualArrayLength(tokens.length, fees.length);\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(escrow),\n      abi.encodeWithSelector(IMultiRewardEscrow.setFees.selector, tokens, fees)\n    );\n    if (!success) revert UnderlyingError(returnData);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          TEMPLATE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Adds a new templateCategory to the registry. Caller must be owner.\n   * @param templateCategories A new category of templates.\n   * @dev See `TemplateRegistry` for more details.\n   */\n  function addTemplateCategories(bytes32[] calldata templateCategories) external onlyOwner {\n    address _deploymentController = address(deploymentController);\n    uint8 len = uint8(templateCategories.length);\n    for (uint256 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        _deploymentController,\n        abi.encodeWithSelector(IDeploymentController.addTemplateCategory.selector, templateCategories[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Toggles the endorsement of a templates. Caller must be owner.\n   * @param templateCategories TemplateCategory of the template to endorse.\n   * @param templateIds TemplateId of the template to endorse.\n   * @dev See `TemplateRegistry` for more details.\n   */\n  function toggleTemplateEndorsements(bytes32[] calldata templateCategories, bytes32[] calldata templateIds)\n    external\n    onlyOwner\n  {\n    uint8 len = uint8(templateCategories.length);\n    _verifyEqualArrayLength(len, templateIds.length);\n\n    address _deploymentController = address(deploymentController);\n    for (uint256 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        address(_deploymentController),\n        abi.encodeWithSelector(\n          ITemplateRegistry.toggleTemplateEndorsement.selector,\n          templateCategories[i],\n          templateIds[i]\n        )\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          PAUSING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Pause Deposits and withdraw all funds from the underlying protocol. Caller must be owner or creator of the Vault.\n  function pauseAdapters(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      _verifyCreatorOrOwner(vaults[i]);\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        IVault(vaults[i]).adapter(),\n        abi.encodeWithSelector(IPausable.pause.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /// @notice Pause deposits. Caller must be owner or creator of the Vault.\n  function pauseVaults(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      _verifyCreatorOrOwner(vaults[i]);\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IPausable.pause.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /// @notice Unpause Deposits and deposit all funds into the underlying protocol. Caller must be owner or creator of the Vault.\n  function unpauseAdapters(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      _verifyCreatorOrOwner(vaults[i]);\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        IVault(vaults[i]).adapter(),\n        abi.encodeWithSelector(IPausable.unpause.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /// @notice Unpause deposits. Caller must be owner or creator of the Vault.\n  function unpauseVaults(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      _verifyCreatorOrOwner(vaults[i]);\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IPausable.unpause.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                       VERIFICATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  error NotSubmitterNorOwner(address caller);\n  error NotSubmitter(address caller);\n  error NotAllowed(address subject);\n  error AdapterConfigFaulty();\n  error ArrayLengthMissmatch();\n\n  /// @notice Verify that the caller is the creator of the vault or owner of `VaultController` (admin rights).\n  function _verifyCreatorOrOwner(address vault) internal returns (VaultMetadata memory metadata) {\n    metadata = vaultRegistry.getVault(vault);\n    if (msg.sender != metadata.creator || msg.sender != owner) revert NotSubmitterNorOwner(msg.sender);\n  }\n\n  /// @notice Verify that the caller is the creator of the vault.\n  function _verifyCreator(address vault) internal view returns (VaultMetadata memory metadata) {\n    metadata = vaultRegistry.getVault(vault);\n    if (msg.sender != metadata.creator) revert NotSubmitter(msg.sender);\n  }\n\n  /// @notice Verify that the token is not rejected nor a clone.\n  function _verifyToken(address token) internal view {\n    if (\n      (\n        permissionRegistry.endorsed(address(0))\n          ? !permissionRegistry.endorsed(token)\n          : permissionRegistry.rejected(token)\n      ) ||\n      cloneRegistry.cloneExists(token) ||\n      token == address(0)\n    ) revert NotAllowed(token);\n  }\n\n  /// @notice Verify that the adapter configuration is valid.\n  function _verifyAdapterConfiguration(address adapter, bytes32 adapterId) internal view {\n    if (adapter != address(0)) {\n      if (adapterId > 0) revert AdapterConfigFaulty();\n      if (!cloneRegistry.cloneExists(adapter)) revert AdapterConfigFaulty();\n    }\n  }\n\n  /// @notice Verify that the array lengths are equal.\n  function _verifyEqualArrayLength(uint256 length1, uint256 length2) internal pure {\n    if (length1 != length2) revert ArrayLengthMissmatch();\n  }\n\n  modifier canCreate() {\n    if (\n      permissionRegistry.endorsed(address(1))\n        ? !permissionRegistry.endorsed(msg.sender)\n        : permissionRegistry.rejected(msg.sender)\n    ) revert NotAllowed(msg.sender);\n    _;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  IAdminProxy public adminProxy;\n\n  /**\n   * @notice Nominates a new owner of `AdminProxy`. Caller must be owner.\n   * @dev Must be called if the `VaultController` gets swapped out or upgraded\n   */\n  function nominateNewAdminProxyOwner(address newOwner) external onlyOwner {\n    adminProxy.nominateNewOwner(newOwner);\n  }\n\n  /**\n   * @notice Accepts ownership of `AdminProxy`. Caller must be nominated owner.\n   * @dev Must be called after construction\n   */\n  function acceptAdminProxyOwnership() external {\n    adminProxy.acceptOwnership();\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          MANAGEMENT FEE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  uint256 public performanceFee;\n\n  event PerformanceFeeChanged(uint256 oldFee, uint256 newFee);\n\n  error InvalidPerformanceFee(uint256 fee);\n\n  /**\n   * @notice Set a new performanceFee for all new adapters. Caller must be owner.\n   * @param newFee performance fee in 1e18.\n   * @dev Fees can be 0 but never more than 2e17 (1e18 = 100%, 1e14 = 1 BPS)\n   * @dev Can be retroactively applied to existing adapters.\n   */\n  function setPerformanceFee(uint256 newFee) external onlyOwner {\n    // Dont take more than 20% performanceFee\n    if (newFee > 2e17) revert InvalidPerformanceFee(newFee);\n\n    emit PerformanceFeeChanged(performanceFee, newFee);\n\n    performanceFee = newFee;\n  }\n\n  /**\n   * @notice Set a new performanceFee for existing adapters. Caller must be owner.\n   * @param adapters array of adapters to set the management fee for.\n   */\n  function setAdapterPerformanceFees(address[] calldata adapters) external onlyOwner {\n    uint8 len = uint8(adapters.length);\n    for (uint256 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        adapters[i],\n        abi.encodeWithSelector(IAdapter.setPerformanceFee.selector, performanceFee)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          HARVEST COOLDOWN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  uint256 public harvestCooldown;\n\n  event HarvestCooldownChanged(uint256 oldCooldown, uint256 newCooldown);\n\n  error InvalidHarvestCooldown(uint256 cooldown);\n\n  /**\n   * @notice Set a new harvestCooldown for all new adapters. Caller must be owner.\n   * @param newCooldown Time in seconds that must pass before a harvest can be called again.\n   * @dev Cant be longer than 1 day.\n   * @dev Can be retroactively applied to existing adapters.\n   */\n  function setHarvestCooldown(uint256 newCooldown) external onlyOwner {\n    // Dont wait more than X seconds\n    if (newCooldown > 1 days) revert InvalidHarvestCooldown(newCooldown);\n\n    emit HarvestCooldownChanged(harvestCooldown, newCooldown);\n\n    harvestCooldown = newCooldown;\n  }\n\n  /**\n   * @notice Set a new harvestCooldown for existing adapters. Caller must be owner.\n   * @param adapters Array of adapters to set the cooldown for.\n   */\n  function setAdapterHarvestCooldowns(address[] calldata adapters) external onlyOwner {\n    uint8 len = uint8(adapters.length);\n    for (uint256 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        adapters[i],\n        abi.encodeWithSelector(IAdapter.setHarvestCooldown.selector, harvestCooldown)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      DEPLYOMENT CONTROLLER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  IDeploymentController public deploymentController;\n  ICloneRegistry public cloneRegistry;\n  ITemplateRegistry public templateRegistry;\n  IPermissionRegistry public permissionRegistry;\n\n  event DeploymentControllerChanged(address oldController, address newController);\n\n  error InvalidDeploymentController(address deploymentController);\n\n  /**\n   * @notice Sets a new `DeploymentController` and saves its auxilary contracts. Caller must be owner.\n   * @param _deploymentController New DeploymentController.\n   */\n  function setDeploymentController(IDeploymentController _deploymentController) external onlyOwner {\n    _setDeploymentController(_deploymentController);\n  }\n\n  function _setDeploymentController(IDeploymentController _deploymentController) internal {\n    if (address(_deploymentController) == address(0) || address(deploymentController) == address(_deploymentController))\n      revert InvalidDeploymentController(address(_deploymentController));\n\n    emit DeploymentControllerChanged(address(deploymentController), address(_deploymentController));\n\n    deploymentController = _deploymentController;\n    cloneRegistry = _deploymentController.cloneRegistry();\n    templateRegistry = _deploymentController.templateRegistry();\n  }\n\n  /*//////////////////////////////////////////////////////////////"
    }
  ]
}