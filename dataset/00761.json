{
  "Title": "M-7: External lending can exceed the threshold",
  "Content": "# Issue M-7: External lending can exceed the threshold \n\nSource: https://github.com/sherlock-audit/2023-12-notional-update-5-judging/issues/38 \n\n## Found by \nxiaoming90\n## Summary\n\nDue to an incorrect calculation of the max lending amount, external lending can exceed the external withdrawal threshold. If this restriction/threshold is not adhered to, users or various core functionalities within the protocol will have issues redeeming or withdrawing their prime cash.\n\n## Vulnerability Detail\n\nThe following is the extract from the [Audit Scope Documentation](https://docs.google.com/document/d/1-2iaTM8lBaurrfItOJRRveHnwKq1lEWGnewrEfXMzrI/edit) provided by the protocol team on the [contest page](https://audits.sherlock.xyz/contests/142) that describes the external withdraw threshold:\n\n> ●\tExternal Withdraw Threshold: ensures that Notional has sufficient liquidity to withdraw from an external lending market. If Notional has 1000 units of underlying lent out on Aave, it requires 1000 * externalWithdrawThreshold units of underlying to be available on Aave for withdraw. This ensures there is sufficient buffer to process the redemption of Notional funds. If available liquidity on Aave begins to drop due to increased utilization, Notional will automatically begin to withdraw its funds from Aave to ensure that they are available for withdrawal on Notional itself.\n\nTo ensure the redeemability of Notional’s funds on external lending markets, Notional requires there to be redeemable funds on the external lending market that are a multiple of the funds that Notional has lent on that market itself.\n\nAssume that the `externalWithdrawThreshold` is 200% and the underlying is USDC. Therefore, `PERCENTAGE_DECIMALS/externalWithdrawThreshold = 100/200 = 0.5` (Line 83-84 below). This means that the number of USDC to be available on AAVE for withdrawal must be two (2) times the number of USDC Notional lent out on AAVE (A multiple of 2).\n\nThe `externalUnderlyingAvailableForWithdraw` stores the number of liquidity in USDC on the AAVE pool available to be withdrawn.\n\nIf `externalUnderlyingAvailableForWithdraw` is 1000 USDC and `currentExternalUnderlyingLend` is 400 USDC, this means that the remaining 600 USDC liquidity on the AAVE pool is not owned by Notional. \n\nThe `maxExternalUnderlyingLend` will be  `600 * 0.5 = 300`. Thus, the maximum amount that Notional can lend externally at this point is 300 USDC.\n\nAssume that after Notional has lent 300 USDC externally to the AAVE pool.\n\nThe `currentExternalUnderlyingLend` will become `400+300=700`, and the `externalUnderlyingAvailableForWithdraw` will become `1000+300=1300`\n\nFollowing is the percentage of USDC in AAVE that belong to Notional\n\n```solidity\n700/1300 = 0.5384615385 (53%).\n```\n\nAt this point, the invariant is broken as the number of USDC to be available on AAVE for withdrawal is less than two (2) times the number of USDC lent out on AAVE after the lending.\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/internal/balances/ExternalLending.sol#L81\n\n```solidity\nFile: ExternalLending.sol\n36:     function getTargetExternalLendingAmount(\n..SNIP..\n79:         uint256 maxExternalUnderlyingLend;\n80:         if (oracleData.currentExternalUnderlyingLend < oracleData.externalUnderlyingAvailableForWithdraw) {\n81:             maxExternalUnderlyingLend =\n82:                 (oracleData.externalUnderlyingAvailableForWithdraw - oracleData.currentExternalUnderlyingLend)\n83:                 .mul(uint256(Constants.PERCENTAGE_DECIMALS))\n84:                 .div(rebalancingTargetData.externalWithdrawThreshold);\n85:         } else {\n86:             maxExternalUnderlyingLend = 0;\n87:         }\n```\n\nThe root cause is that when USDC is deposited to AAVE to get aUSDC, the total USDC in the pool increases. Therefore, using the current amount of USDC in the pool to determine the maximum deposit amount is not an accurate measure of liquidity risk.\n\n## Impact\n\nTo ensure the redeemability of Notional’s funds on external lending markets, Notional requires there to be redeemable funds on the external lending market that are a multiple of the funds that Notional has lent on that market itself.\n\nIf this restriction is not adhered to, users or various core functionalities within the protocol will have issues redeeming or withdrawing their prime cash. For instance, users might not be able to withdraw their assets from the protocol due to insufficient liquidity, or liquidation cannot be carried out due to lack of liquidity, resulting in bad debt accumulating within the protocol and negatively affecting the protocol's solvency.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/internal/balances/ExternalLending.sol#L81\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo ensure that a deposit does not exceed the threshold, the following formula should be used to determine the maximum deposit amount:\n\nLet's denote:\n\n$T$ as the externalWithdrawThreshold\n$L$ as the currentExternalUnderlyingLend\n$W$ as the externalUnderlyingAvailableForWithdraw\n$D$ as the Deposit (the variable we want to solve for)\n\n$$\nT = \\frac{L + D}{W + D}\n$$\n\nSolving $D$, the formula for calculating the maximum deposit ($D$) is\n\n$$\nD = \\frac{TW-L}{1-T}\n$$\n\nUsing back the same example in the \"Vulnerability Detail\" section.\n\nThe maximum deposit amount is as follows:\n\n```solidity\nD = (TW - L) / (1 - T)\nD = (0.5 * 1000 - 400) / (1 - 0.5)\nD = (500 - 400) / 0.5 = 200\n```\n\nIf 200 USDC is lent out, it will still not exceed the threshold of 200%, which demonstrates that the formula is working as intended in keeping the multiple of two (200%) constant before and after the deposit.\n\n```solidity\n(400 + 200) / (1000 + 200) = 0.5\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { valid and a duplicate of 035 and even seem to be by same user}\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/142",
  "Code": [
    {
      "filename": "contracts-v3/contracts/internal/balances/ExternalLending.sol",
      "content": "// SPDX-License-Identifier: BSUL-1.1\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    Token,\n    PrimeRate,\n    PrimeCashFactors,\n    RebalancingTargetData\n} from \"../../global/Types.sol\";\nimport {\n    IPrimeCashHoldingsOracle,\n    OracleData,\n    RedeemData,\n    DepositData\n} from \"../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\";\nimport {TokenHandler} from \"./TokenHandler.sol\";\n\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\n\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\nimport {PrimeCashExchangeRate} from \"../pCash/PrimeCashExchangeRate.sol\";\nimport {GenericToken} from \"./protocols/GenericToken.sol\";\n\n\nlibrary ExternalLending {\n    using PrimeRateLib for PrimeRate;\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n    using TokenHandler for Token;\n\n    function getTargetExternalLendingAmount(\n        Token memory underlyingToken,\n        PrimeCashFactors memory factors,\n        RebalancingTargetData memory rebalancingTargetData,\n        OracleData memory oracleData,\n        PrimeRate memory pr\n    ) internal pure returns (uint256 targetAmount) {\n        // Short circuit a zero target\n        if (rebalancingTargetData.targetUtilization == 0) return 0;\n\n        int256 totalPrimeCashInUnderlying = pr.convertToUnderlying(int256(factors.totalPrimeSupply));\n        int256 totalPrimeDebtInUnderlying = pr.convertDebtStorageToUnderlying(int256(factors.totalPrimeDebt).neg()).abs();\n\n        // The target amount to lend is based on a target \"utilization\" of the total prime supply. For example, for\n        // a target utilization of 80%, if the prime cash utilization is 70% (totalPrimeSupply / totalPrimeDebt) then\n        // we want to lend 10% of the total prime supply. This ensures that 20% of the totalPrimeSupply will not be held\n        // in external money markets which run the risk of becoming unredeemable.\n        int256 targetExternalUnderlyingLend = totalPrimeCashInUnderlying\n            .mul(rebalancingTargetData.targetUtilization)\n            .div(Constants.PERCENTAGE_DECIMALS)\n            .sub(totalPrimeDebtInUnderlying);\n        // Floor this value at zero. This will be negative above the target utilization. We do not want to be lending at\n        // all above the target.\n        if (targetExternalUnderlyingLend < 0) targetExternalUnderlyingLend = 0;\n\n        // To ensure redeemability of Notional’s funds on external lending markets,\n        // Notional requires there to be redeemable funds on the external lending market\n        // that are a multiple of the funds that Notional has lent on that market itself.\n        //\n        // The max amount that Notional can lend on that market is a function\n        // of the excess redeemable funds on that market\n        // (funds that are redeemable in excess of Notional’s own funds on that market)\n        // and the externalWithdrawThreshold.\n        //\n        // excessFunds = externalUnderlyingAvailableForWithdraw - currentExternalUnderlyingLend\n        //\n        // maxExternalUnderlyingLend * (externalWithdrawThreshold + 1) = maxExternalUnderlyingLend + excessFunds\n        //\n        // maxExternalUnderlyingLend * (externalWithdrawThreshold + 1) - maxExternalUnderlyingLend = excessFunds\n        //\n        // maxExternalUnderlyingLend * externalWithdrawThreshold = excessFunds\n        //\n        // maxExternalUnderlyingLend = excessFunds / externalWithdrawThreshold\n        uint256 maxExternalUnderlyingLend;\n        if (oracleData.currentExternalUnderlyingLend < oracleData.externalUnderlyingAvailableForWithdraw) {\n            maxExternalUnderlyingLend =\n                (oracleData.externalUnderlyingAvailableForWithdraw - oracleData.currentExternalUnderlyingLend)\n                .mul(uint256(Constants.PERCENTAGE_DECIMALS))\n                .div(rebalancingTargetData.externalWithdrawThreshold);\n        } else {\n            maxExternalUnderlyingLend = 0;\n        }\n\n        targetAmount = SafeUint256.min(\n            // totalPrimeCashInUnderlying and totalPrimeDebtInUnderlying are in 8 decimals, convert it to native\n            // token precision here for accurate comparison. No underflow possible since targetExternalUnderlyingLend\n            // is floored at zero.\n            uint256(underlyingToken.convertToExternal(targetExternalUnderlyingLend)),\n            // maxExternalUnderlyingLend is limit enforced by setting externalWithdrawThreshold\n            // maxExternalDeposit is limit due to the supply cap on external pools\n            SafeUint256.min(maxExternalUnderlyingLend, oracleData.maxExternalDeposit)\n        );\n        // in case of redemption, make sure there is enough to withdraw, important for health check so that\n        // it does not trigger rebalances (redemptions) when there is nothing to redeem\n        if (targetAmount < oracleData.currentExternalUnderlyingLend) {\n            uint256 forRedemption = oracleData.currentExternalUnderlyingLend - targetAmount;\n            if (oracleData.externalUnderlyingAvailableForWithdraw < forRedemption) {\n                // increase target amount so that redemptions amount match externalUnderlyingAvailableForWithdraw\n                targetAmount = targetAmount.add(\n                    // unchecked - is safe here, overflow is not possible due to above if conditional\n                    forRedemption - oracleData.externalUnderlyingAvailableForWithdraw\n                );\n            }\n        }\n    }\n\n    /// @notice Prime cash holdings may be in underlying tokens or they may be held in other money market\n    /// protocols like Compound, Aave or Euler. If there is insufficient underlying tokens to withdraw on\n    /// the contract, this method will redeem money market tokens in order to gain sufficient underlying\n    /// to withdraw from the contract.\n    /// @param currencyId associated currency id\n    /// @param underlying underlying token information\n    /// @param withdrawAmountExternal amount of underlying to withdraw in external token precision\n    function redeemMoneyMarketIfRequired(\n        uint16 currencyId,\n        Token memory underlying,\n        uint256 withdrawAmountExternal\n    ) internal {\n        // If there is sufficient balance of the underlying to withdraw from the contract\n        // immediately, just return.\n        mapping(address => uint256) storage store = LibStorage.getStoredTokenBalances();\n        uint256 currentBalance = store[underlying.tokenAddress];\n        if (withdrawAmountExternal <= currentBalance) return;\n\n        IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n        // Redemption data returns an array of contract calls to make from the Notional proxy (which\n        // is holding all of the money market tokens).\n        (RedeemData[] memory data) = oracle.getRedemptionCalldata(withdrawAmountExternal - currentBalance);\n\n        // This is the total expected underlying that we should redeem after all redemption calls\n        // are executed.\n        uint256 totalUnderlyingRedeemed = executeMoneyMarketRedemptions(underlying, data);\n\n        // Ensure that we have sufficient funds before we exit\n        require(withdrawAmountExternal <= currentBalance.add(totalUnderlyingRedeemed)); // dev: insufficient redeem\n    }\n\n    /// @notice It is critical that this method measures and records the balanceOf changes before and after\n    /// every token change. If not, then external donations can affect the valuation of pCash and pDebt\n    /// tokens which may be exploitable.\n    /// @param redeemData parameters from the prime cash holding oracle\n    function executeMoneyMarketRedemptions(\n        Token memory underlyingToken,\n        RedeemData[] memory redeemData\n    ) internal returns (uint256 totalUnderlyingRedeemed) {\n        for (uint256 i; i < redeemData.length; i++) {\n            RedeemData memory data = redeemData[i];\n            // Measure the token balance change if the `assetToken` value is set in the\n            // current redemption data struct. \n            uint256 oldAssetBalance = IERC20(data.assetToken).balanceOf(address(this));\n\n            // Measure the underlying balance change before and after the call.\n            uint256 oldUnderlyingBalance = TokenHandler.balanceOf(underlyingToken, address(this));\n\n            // Some asset tokens may require multiple calls to redeem if there is an unstake\n            // or redemption from WETH involved. We only measure the asset token balance change\n            // on the final redemption call, as dictated by the prime cash holdings oracle.\n            for (uint256 j; j < data.targets.length; j++) {\n                GenericToken.executeLowLevelCall(data.targets[j], 0, data.callData[j]);\n            }\n\n            // Ensure that we get sufficient underlying on every redemption\n            uint256 newUnderlyingBalance = TokenHandler.balanceOf(underlyingToken, address(this));\n            uint256 underlyingBalanceChange = newUnderlyingBalance.sub(oldUnderlyingBalance);\n            // If the call is not the final redemption, then expectedUnderlying should\n            // be set to zero.\n            require(data.expectedUnderlying <= underlyingBalanceChange);\n\n            // Measure and update the asset token\n            uint256 newAssetBalance = IERC20(data.assetToken).balanceOf(address(this));\n            require(newAssetBalance <= oldAssetBalance);\n\n            if (\n                (data.rebasingTokenBalanceAdjustment != 0) &&\n                // This equation only makes sense when the \"asset token\" is a rebasing token\n                // in the same denomination as the underlying token. This will only be reached\n                // if the rebasingTokenBalanceAdjustment is set to a non-zero value\n                (underlyingBalanceChange != oldAssetBalance.sub(newAssetBalance))\n            ) {\n                newAssetBalance = newAssetBalance.add(data.rebasingTokenBalanceAdjustment);\n            }\n\n            TokenHandler.updateStoredTokenBalance(data.assetToken, oldAssetBalance, newAssetBalance);\n\n            // Update the total value with the net change\n            totalUnderlyingRedeemed = totalUnderlyingRedeemed.add(underlyingBalanceChange);\n\n            // totalUnderlyingRedeemed is always positive or zero.\n            TokenHandler.updateStoredTokenBalance(underlyingToken.tokenAddress, oldUnderlyingBalance, newUnderlyingBalance);\n        }\n    }\n\n    /// @notice Executes deposits to an external lending protocol. Only called during a rebalance executed\n    /// by the TreasuryAction contract.\n    function executeDeposits(Token memory underlyingToken, DepositData[] memory deposits) internal {\n        for (uint256 i; i < deposits.length; i++) {\n            DepositData memory depositData = deposits[i];\n            // Measure the token balance change if the `assetToken` value is set in the\n            // current deposit data struct.\n            uint256 oldAssetBalance = IERC20(depositData.assetToken).balanceOf(address(this));\n\n            // Measure the underlying balance change before and after the call.\n            uint256 oldUnderlyingBalance = underlyingToken.balanceOf(address(this));\n\n            for (uint256 j; j < depositData.targets.length; ++j) {\n                GenericToken.executeLowLevelCall(\n                    depositData.targets[j],\n                    depositData.msgValue[j],\n                    depositData.callData[j]\n                );\n            }\n\n            // Ensure that the underlying balance change matches the deposit amount\n            uint256 newUnderlyingBalance = underlyingToken.balanceOf(address(this));\n            uint256 underlyingBalanceChange = oldUnderlyingBalance.sub(newUnderlyingBalance);\n            // Ensure that only the specified amount of underlying has left the protocol\n            require(underlyingBalanceChange <= depositData.underlyingDepositAmount);\n\n            // Measure and update the asset token\n            uint256 newAssetBalance = IERC20(depositData.assetToken).balanceOf(address(this));\n            require(oldAssetBalance <= newAssetBalance);\n\n            if (\n                (depositData.rebasingTokenBalanceAdjustment != 0) &&\n                // This equation only makes sense when the \"asset token\" is a rebasing token\n                // in the same denomination as the underlying token. This will only be reached\n                // if the rebasingTokenBalanceAdjustment is set to a non-zero value\n                (underlyingBalanceChange != newAssetBalance.sub(oldAssetBalance))\n            ) {\n                newAssetBalance = newAssetBalance.add(depositData.rebasingTokenBalanceAdjustment);\n            }\n\n            TokenHandler.updateStoredTokenBalance(depositData.assetToken, oldAssetBalance, newAssetBalance);\n            TokenHandler.updateStoredTokenBalance(\n                underlyingToken.tokenAddress, oldUnderlyingBalance, newUnderlyingBalance\n            );\n        }\n    }\n\n}"
    },
    {
      "filename": "contracts-v3/contracts/internal/balances/ExternalLending.sol",
      "content": "// SPDX-License-Identifier: BSUL-1.1\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    Token,\n    PrimeRate,\n    PrimeCashFactors,\n    RebalancingTargetData\n} from \"../../global/Types.sol\";\nimport {\n    IPrimeCashHoldingsOracle,\n    OracleData,\n    RedeemData,\n    DepositData\n} from \"../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\";\nimport {TokenHandler} from \"./TokenHandler.sol\";\n\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\n\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\nimport {PrimeCashExchangeRate} from \"../pCash/PrimeCashExchangeRate.sol\";\nimport {GenericToken} from \"./protocols/GenericToken.sol\";\n\n\nlibrary ExternalLending {\n    using PrimeRateLib for PrimeRate;\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n    using TokenHandler for Token;\n\n    function getTargetExternalLendingAmount(\n        Token memory underlyingToken,\n        PrimeCashFactors memory factors,\n        RebalancingTargetData memory rebalancingTargetData,\n        OracleData memory oracleData,\n        PrimeRate memory pr\n    ) internal pure returns (uint256 targetAmount) {\n        // Short circuit a zero target\n        if (rebalancingTargetData.targetUtilization == 0) return 0;\n\n        int256 totalPrimeCashInUnderlying = pr.convertToUnderlying(int256(factors.totalPrimeSupply));\n        int256 totalPrimeDebtInUnderlying = pr.convertDebtStorageToUnderlying(int256(factors.totalPrimeDebt).neg()).abs();\n\n        // The target amount to lend is based on a target \"utilization\" of the total prime supply. For example, for\n        // a target utilization of 80%, if the prime cash utilization is 70% (totalPrimeSupply / totalPrimeDebt) then\n        // we want to lend 10% of the total prime supply. This ensures that 20% of the totalPrimeSupply will not be held\n        // in external money markets which run the risk of becoming unredeemable.\n        int256 targetExternalUnderlyingLend = totalPrimeCashInUnderlying\n            .mul(rebalancingTargetData.targetUtilization)\n            .div(Constants.PERCENTAGE_DECIMALS)\n            .sub(totalPrimeDebtInUnderlying);\n        // Floor this value at zero. This will be negative above the target utilization. We do not want to be lending at\n        // all above the target.\n        if (targetExternalUnderlyingLend < 0) targetExternalUnderlyingLend = 0;\n\n        // To ensure redeemability of Notional’s funds on external lending markets,\n        // Notional requires there to be redeemable funds on the external lending market\n        // that are a multiple of the funds that Notional has lent on that market itself.\n        //\n        // The max amount that Notional can lend on that market is a function\n        // of the excess redeemable funds on that market\n        // (funds that are redeemable in excess of Notional’s own funds on that market)\n        // and the externalWithdrawThreshold.\n        //\n        // excessFunds = externalUnderlyingAvailableForWithdraw - currentExternalUnderlyingLend\n        //\n        // maxExternalUnderlyingLend * (externalWithdrawThreshold + 1) = maxExternalUnderlyingLend + excessFunds\n        //\n        // maxExternalUnderlyingLend * (externalWithdrawThreshold + 1) - maxExternalUnderlyingLend = excessFunds\n        //\n        // maxExternalUnderlyingLend * externalWithdrawThreshold = excessFunds\n        //\n        // maxExternalUnderlyingLend = excessFunds / externalWithdrawThreshold\n        uint256 maxExternalUnderlyingLend;\n        if (oracleData.currentExternalUnderlyingLend < oracleData.externalUnderlyingAvailableForWithdraw) {\n            maxExternalUnderlyingLend =\n                (oracleData.externalUnderlyingAvailableForWithdraw - oracleData.currentExternalUnderlyingLend)\n                .mul(uint256(Constants.PERCENTAGE_DECIMALS))\n                .div(rebalancingTargetData.externalWithdrawThreshold);\n        } else {\n            maxExternalUnderlyingLend = 0;\n        }\n\n        targetAmount = SafeUint256.min(\n            // totalPrimeCashInUnderlying and totalPrimeDebtInUnderlying are in 8 decimals, convert it to native\n            // token precision here for accurate comparison. No underflow possible since targetExternalUnderlyingLend\n            // is floored at zero.\n            uint256(underlyingToken.convertToExternal(targetExternalUnderlyingLend)),\n            // maxExternalUnderlyingLend is limit enforced by setting externalWithdrawThreshold\n            // maxExternalDeposit is limit due to the supply cap on external pools\n            SafeUint256.min(maxExternalUnderlyingLend, oracleData.maxExternalDeposit)\n        );\n        // in case of redemption, make sure there is enough to withdraw, important for health check so that\n        // it does not trigger rebalances (redemptions) when there is nothing to redeem\n        if (targetAmount < oracleData.currentExternalUnderlyingLend) {\n            uint256 forRedemption = oracleData.currentExternalUnderlyingLend - targetAmount;\n            if (oracleData.externalUnderlyingAvailableForWithdraw < forRedemption) {\n                // increase target amount so that redemptions amount match externalUnderlyingAvailableForWithdraw\n                targetAmount = targetAmount.add(\n                    // unchecked - is safe here, overflow is not possible due to above if conditional\n                    forRedemption - oracleData.externalUnderlyingAvailableForWithdraw\n                );\n            }\n        }\n    }\n\n    /// @notice Prime cash holdings may be in underlying tokens or they may be held in other money market\n    /// protocols like Compound, Aave or Euler. If there is insufficient underlying tokens to withdraw on\n    /// the contract, this method will redeem money market tokens in order to gain sufficient underlying\n    /// to withdraw from the contract.\n    /// @param currencyId associated currency id\n    /// @param underlying underlying token information\n    /// @param withdrawAmountExternal amount of underlying to withdraw in external token precision\n    function redeemMoneyMarketIfRequired(\n        uint16 currencyId,\n        Token memory underlying,\n        uint256 withdrawAmountExternal\n    ) internal {\n        // If there is sufficient balance of the underlying to withdraw from the contract\n        // immediately, just return.\n        mapping(address => uint256) storage store = LibStorage.getStoredTokenBalances();\n        uint256 currentBalance = store[underlying.tokenAddress];\n        if (withdrawAmountExternal <= currentBalance) return;\n\n        IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\n        // Redemption data returns an array of contract calls to make from the Notional proxy (which\n        // is holding all of the money market tokens).\n        (RedeemData[] memory data) = oracle.getRedemptionCalldata(withdrawAmountExternal - currentBalance);\n\n        // This is the total expected underlying that we should redeem after all redemption calls\n        // are executed.\n        uint256 totalUnderlyingRedeemed = executeMoneyMarketRedemptions(underlying, data);\n\n        // Ensure that we have sufficient funds before we exit\n        require(withdrawAmountExternal <= currentBalance.add(totalUnderlyingRedeemed)); // dev: insufficient redeem\n    }\n\n    /// @notice It is critical that this method measures and records the balanceOf changes before and after\n    /// every token change. If not, then external donations can affect the valuation of pCash and pDebt\n    /// tokens which may be exploitable.\n    /// @param redeemData parameters from the prime cash holding oracle\n    function executeMoneyMarketRedemptions(\n        Token memory underlyingToken,\n        RedeemData[] memory redeemData\n    ) internal returns (uint256 totalUnderlyingRedeemed) {\n        for (uint256 i; i < redeemData.length; i++) {\n            RedeemData memory data = redeemData[i];\n            // Measure the token balance change if the `assetToken` value is set in the\n            // current redemption data struct. \n            uint256 oldAssetBalance = IERC20(data.assetToken).balanceOf(address(this));\n\n            // Measure the underlying balance change before and after the call.\n            uint256 oldUnderlyingBalance = TokenHandler.balanceOf(underlyingToken, address(this));\n\n            // Some asset tokens may require multiple calls to redeem if there is an unstake\n            // or redemption from WETH involved. We only measure the asset token balance change\n            // on the final redemption call, as dictated by the prime cash holdings oracle.\n            for (uint256 j; j < data.targets.length; j++) {\n                GenericToken.executeLowLevelCall(data.targets[j], 0, data.callData[j]);\n            }\n\n            // Ensure that we get sufficient underlying on every redemption\n            uint256 newUnderlyingBalance = TokenHandler.balanceOf(underlyingToken, address(this));\n            uint256 underlyingBalanceChange = newUnderlyingBalance.sub(oldUnderlyingBalance);\n            // If the call is not the final redemption, then expectedUnderlying should\n            // be set to zero.\n            require(data.expectedUnderlying <= underlyingBalanceChange);\n\n            // Measure and update the asset token\n            uint256 newAssetBalance = IERC20(data.assetToken).balanceOf(address(this));\n            require(newAssetBalance <= oldAssetBalance);\n\n            if (\n                (data.rebasingTokenBalanceAdjustment != 0) &&\n                // This equation only makes sense when the \"asset token\" is a rebasing token\n                // in the same denomination as the underlying token. This will only be reached\n                // if the rebasingTokenBalanceAdjustment is set to a non-zero value\n                (underlyingBalanceChange != oldAssetBalance.sub(newAssetBalance))\n            ) {\n                newAssetBalance = newAssetBalance.add(data.rebasingTokenBalanceAdjustment);\n            }\n\n            TokenHandler.updateStoredTokenBalance(data.assetToken, oldAssetBalance, newAssetBalance);\n\n            // Update the total value with the net change\n            totalUnderlyingRedeemed = totalUnderlyingRedeemed.add(underlyingBalanceChange);\n\n            // totalUnderlyingRedeemed is always positive or zero.\n            TokenHandler.updateStoredTokenBalance(underlyingToken.tokenAddress, oldUnderlyingBalance, newUnderlyingBalance);\n        }\n    }\n\n    /// @notice Executes deposits to an external lending protocol. Only called during a rebalance executed\n    /// by the TreasuryAction contract.\n    function executeDeposits(Token memory underlyingToken, DepositData[] memory deposits) internal {\n        for (uint256 i; i < deposits.length; i++) {\n            DepositData memory depositData = deposits[i];\n            // Measure the token balance change if the `assetToken` value is set in the\n            // current deposit data struct.\n            uint256 oldAssetBalance = IERC20(depositData.assetToken).balanceOf(address(this));\n\n            // Measure the underlying balance change before and after the call.\n            uint256 oldUnderlyingBalance = underlyingToken.balanceOf(address(this));\n\n            for (uint256 j; j < depositData.targets.length; ++j) {\n                GenericToken.executeLowLevelCall(\n                    depositData.targets[j],\n                    depositData.msgValue[j],\n                    depositData.callData[j]\n                );\n            }\n\n            // Ensure that the underlying balance change matches the deposit amount\n            uint256 newUnderlyingBalance = underlyingToken.balanceOf(address(this));\n            uint256 underlyingBalanceChange = oldUnderlyingBalance.sub(newUnderlyingBalance);\n            // Ensure that only the specified amount of underlying has left the protocol\n            require(underlyingBalanceChange <= depositData.underlyingDepositAmount);\n\n            // Measure and update the asset token\n            uint256 newAssetBalance = IERC20(depositData.assetToken).balanceOf(address(this));\n            require(oldAssetBalance <= newAssetBalance);\n\n            if (\n                (depositData.rebasingTokenBalanceAdjustment != 0) &&\n                // This equation only makes sense when the \"asset token\" is a rebasing token\n                // in the same denomination as the underlying token. This will only be reached\n                // if the rebasingTokenBalanceAdjustment is set to a non-zero value\n                (underlyingBalanceChange != newAssetBalance.sub(oldAssetBalance))\n            ) {\n                newAssetBalance = newAssetBalance.add(depositData.rebasingTokenBalanceAdjustment);\n            }\n\n            TokenHandler.updateStoredTokenBalance(depositData.assetToken, oldAssetBalance, newAssetBalance);\n            TokenHandler.updateStoredTokenBalance(\n                underlyingToken.tokenAddress, oldUnderlyingBalance, newUnderlyingBalance\n            );\n        }\n    }\n\n}"
    }
  ]
}