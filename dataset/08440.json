{
  "Title": "[N-17]  Inconsistent method of specifying a floating pragma",
  "Content": "Some files use `>=`, some use `^`. The instances below are examples of the method that has the fewest instances for a specific version. Note that using `>=` without also specifying `<=` will lead to failures to compile, or external project incompatability, when the major version changes and there are breaking-changes, so `^` should be preferred regardless of the instance counts\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/governance/GolomToken.sol\n\n2:    pragma solidity ^0.8.11;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/governance/GolomToken.sol#L2\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-07-golom",
  "Code": [
    {
      "filename": "contracts/governance/GolomToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\n/// @title Golom ERC20 governance token\n/// @notice Explain to an end user what this does\n/// @dev Implements ERC20, ERC20Votes and ERC20Permits from OpenZepellin\n\n// Tokens are minted on the initial mint\n// Additionally mint function is called to mint the tokens, only the reward distributor contract will be able to mint the token\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol';\n\ncontract GolomToken is ERC20Votes, Ownable {\n    address public minter;\n\n    uint256 public minterEnableDate;\n    address public pendingMinter;\n\n    bool public isAirdropMinted;\n    bool public isGenesisRewardMinted;\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, 'GolomToken: only reward distributor can enable');\n        _;\n    }\n\n    constructor(address _governance) ERC20('Golom', 'GOL') ERC20Permit('Golom') {\n        _transferOwnership(_governance); // set the new owner\n    }\n\n    /// @notice Mints the tokens\n    /// @dev only minter can mint the tokens, minter will be RewardDistributor.sol\n    /// @param _account Address where the tokens will be minted\n    /// @param _amount Number of tokens to be minted\n    function mint(address _account, uint256 _amount) external onlyMinter {\n        _mint(_account, _amount);\n    }\n\n    /// @notice Mints 150M for the airdrop\n    /// @param _airdrop Airdrop contract\n    function mintAirdrop(address _airdrop) external onlyOwner {\n        require(!isAirdropMinted, 'already minted');\n        _mint(_airdrop, 150_000_000 * 1e18);\n        isAirdropMinted = true;\n    }\n\n    /// @notice Mint Genesis Reward\n    /// @param _rewardDistributor Address of the rewardDistributor\n    function mintGenesisReward(address _rewardDistributor) external onlyOwner {\n        require(!isGenesisRewardMinted, 'already minted');\n        _mint(_rewardDistributor, 62_500_000 * 1e18);\n        isGenesisRewardMinted = true;\n    }\n\n    /// @notice sets the minter with timelock, once setup admin needs to call executeSetMinter()\n    /// @param _minter Address of the new minter\n    function setMinter(address _minter) external onlyOwner {\n        pendingMinter = _minter;\n        minterEnableDate = block.timestamp + 1 days;\n    }\n\n    /// @notice Executes the set minter function after the timelock\n    /// @dev If being called first time, there won't be any timelock\n    function executeSetMinter() external onlyOwner {\n        if (minter == address(0)) {\n            minter = pendingMinter;\n        } else {\n            require(minterEnableDate <= block.timestamp, 'GolomToken: wait for timelock');\n            minter = pendingMinter;\n        }\n    }\n}"
    }
  ]
}