{
  "Title": "[M-02] When using BaseBranchRouter as a router on the 'Arbitrum' branch, we are unable to invoke the 'callOutAndBridge' function.",
  "Content": "\nAll branches have one core router and several subsidiary branches. The core branches handle system calls, and users can create deposits using subsidiary branches. The function utilized for creating deposits is the `callOutAndBridge` function. However, in the `Arbitrum` branch, this function is not available for use. This restriction has system-wide implications because the Arbitrum branch should function similarly to other local branches.\n\n### Proof of Concept\n\nWhen a user attempts to make a deposit in other branches, the `local hTokens` are transferred from the user to the `local branch port` and subsequently burned.\n\nHowever, in `Arbitrum`, there is no differentiation between `local` and `global hTokens`. Consequently, they are sent directly to the `root port`.\nWhen a user invokes the `callOutAndBridge` function in a branch, it involves the transfer of `hTokens` and `underlying tokens` from the `user` to the `router`. Additionally, the `router` approves the `local port` to access and utilize these tokens.\n\n<https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BaseBranchRouter.sol#L95>\n\n    _transferAndApproveToken(_dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit);\n\n<https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BaseBranchRouter.sol#L167-L168>\n\n    _hToken.safeTransferFrom(msg.sender, address(this), _amount - _deposit);\n    ERC20(_hToken).approve(_localPortAddress, _amount - _deposit);\n\n    _token.safeTransferFrom(msg.sender, address(this), _deposit);\n    ERC20(_token).approve(_localPortAddress, _deposit);\n\nThen we call the 'callOutAndBridge' function within the `bridge agent`. Within this function, a deposit is created. \n\n<https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L224>\n\n    _createDeposit(_depositNonce, _refundee, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit);\n\n<https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchBridgeAgent.sol#L824>\n\n    IPort(localPortAddress).bridgeOut(msg.sender, _hToken, _token, _amount, _deposit);\n\nWe've now reached the `_bridgeOut` function in `ArbitrumBranchPort`. \n\n<https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/ArbitrumBranchPort.sol#L134>\n\n    IRootPort(rootPortAddress).bridgeToRootFromLocalBranch(_depositor, _localAddress, _amount - _deposit);\n\nHere, the `_depositor` is the router, and `ArbitrumBranchPort` is authorized to access these tokens, but not `RootPort`. \n\n<https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootPort.sol#L301>\n\n    _hToken.safeTransferFrom(_from, address(this), _amount);\n\nConsequently, we are unable to bridge these tokens to the `RootPort` from `_depositor`.\n\nAdd test below to `test/ulysses-omnichain/ArbitrumBranchTest.t.sol` and run test. You can see that the test will fail:\n\n        function testCallOutAndBridge() public {\n            testAddLocalTokenArbitrum();\n            address _user = address(this);\n            arbitrumNativeToken.mint(_user, 150 ether);\n            // Approve Tokens\n            arbitrumNativeToken.approve(address(localPortAddress), 50 ether);\n            // Call deposit to port\n            arbitrumMulticallBridgeAgent.depositToPort(\n                address(arbitrumNativeToken),\n                50 ether\n            );\n\n            require(\n                MockERC20(arbitrumNativeToken).balanceOf(_user) == 100 ether,\n                \"_user has 100 underlying tokens\"\n            );\n            require(\n                MockERC20(newArbitrumAssetGlobalAddress).balanceOf(_user) ==\n                    50 ether,\n                \"_user has 50 global(local) tokens\"\n            );\n\n            arbitrumNativeToken.approve(\n                address(arbitrumMulticallRouter),\n                100 ether\n            );\n            ERC20hTokenRoot(newArbitrumAssetGlobalAddress).approve(\n                address(arbitrumMulticallRouter),\n                50 ether\n            );\n\n            DepositInput memory depositInput = DepositInput({\n                hToken: address(newArbitrumAssetGlobalAddress),\n                token: address(arbitrumNativeToken),\n                amount: 150 ether,\n                deposit: 100 ether\n            });\n            GasParams memory gasParams = GasParams(0.5 ether, 0.5 ether);\n            // Get some gas.\n            hevm.deal(address(this), 1 ether);\n\n            // test will be failed\n            arbitrumMulticallRouter.callOutAndBridge{value: 1 ether}(\n                \"\",\n                depositInput,\n                gasParams\n            );\n        }\n\n### Recommended Mitigation Steps\n\nChange this:\n\n    IRootPort(rootPortAddress).bridgeToRootFromLocalBranch(_depositor, _localAddress, _amount - _deposit);\n\nto:\n\n    _localAddress.safeTransferFrom(_depositor, address(this), _amount - _deposit);\n    ERC20(_localAddress).approve(rootPortAddress, _amount - _deposit);\n    IRootPort(rootPortAddress).bridgeToRootFromLocalBranch(address(this), _localAddress, _amount - _deposit);\n\nYou can observe that the test will pass successfully. It's important to note that when users attempt to use the `callOutAndBridge` function within the `bridge agent`, they allow the `local port` to access their funds, just as in other branches.\n\n### Assessed type\n\nToken-Transfer\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-09-maia-findings/issues/744#issuecomment-1764964557)**\n\n**[0xBugsy (Maia) disagreed with severity](https://github.com/code-423n4/2023-09-maia-findings/issues/744#issuecomment-1766188271)**\n\n**[alcueca (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-09-maia-findings/issues/744#issuecomment-1778884824):**\n > No funds at risk. Medium at best, since there is a workaround. Since this is also a router contract, users can always interact directly with the bridgeAgent and approve funds to be spent by the correct Port themselves (approve rootPort instead of ArbitrumBranchPort).\n\n**[alcueca (judge) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/744#issuecomment-1784004225):**\n > From the sponsor:\n> > We believe it is accurate. We need to increase the allowance/approve to the root port in arbitrum base branch routers.\n\n**[0xBugsy (Maia) commented](https://github.com/code-423n4/2023-09-maia-findings/issues/744#issuecomment-1807195400):**\n > Addressed [here](https://github.com/Maia-DAO/2023-09-maia-remediations/commit/cbdd6e25ce9c4190282eb6ebf8f3c1425d1236aa).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/BaseBranchRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IBranchRouter} from \"./interfaces/IBranchRouter.sol\";\n\nimport {\n    IBranchBridgeAgent as IBridgeAgent,\n    GasParams,\n    Deposit,\n    DepositInput,\n    DepositParams,\n    DepositMultipleInput,\n    DepositMultipleParams,\n    SettlementParams,\n    SettlementMultipleParams\n} from \"./interfaces/IBranchBridgeAgent.sol\";\n\n/// @title Base Branch Router Contract\n/// @author MaiaDAO\ncontract BaseBranchRouter is IBranchRouter, Ownable {\n    using SafeTransferLib for address;\n\n    /*///////////////////////////////////////////////////////////////\n                    BASE BRANCH ROUTER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchRouter\n    address public localPortAddress;\n\n    /// @inheritdoc IBranchRouter\n    address public override localBridgeAgentAddress;\n\n    /// @inheritdoc IBranchRouter\n    address public override bridgeAgentExecutorAddress;\n\n    /// @notice Re-entrancy lock modifier state.\n    uint256 internal _unlocked = 1;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        _initializeOwner(msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INITIALIZATION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Initializes the Base Branch Router.\n     * @param _localBridgeAgentAddress The address of the local Bridge Agent.\n     */\n    function initialize(address _localBridgeAgentAddress) external onlyOwner {\n        require(_localBridgeAgentAddress != address(0), \"Bridge Agent address cannot be 0\");\n        localBridgeAgentAddress = _localBridgeAgentAddress;\n        localPortAddress = IBridgeAgent(_localBridgeAgentAddress).localPortAddress();\n        bridgeAgentExecutorAddress = IBridgeAgent(_localBridgeAgentAddress).bridgeAgentExecutorAddress();\n        \n        renounceOwnership();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchRouter\n    function getDepositEntry(uint32 _depositNonce) external view override returns (Deposit memory) {\n        return IBridgeAgent(localBridgeAgentAddress).getDepositEntry(_depositNonce);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchRouter\n    function callOut(bytes calldata _params, GasParams calldata _gParams) external payable override lock {\n        IBridgeAgent(localBridgeAgentAddress).callOut{value: msg.value}(payable(msg.sender), _params, _gParams);\n    }\n\n    /// @inheritdoc IBranchRouter\n    function callOutAndBridge(bytes calldata _params, DepositInput calldata _dParams, GasParams calldata _gParams)\n        external\n        payable\n        override\n        lock\n    {\n        //Transfer tokens to this contract.\n        _transferAndApproveToken(_dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit);\n\n        //Perform call to bridge agent.\n        IBridgeAgent(localBridgeAgentAddress).callOutAndBridge{value: msg.value}(\n            payable(msg.sender), _params, _dParams, _gParams\n        );\n    }\n\n    /// @inheritdoc IBranchRouter\n    function callOutAndBridgeMultiple(\n        bytes calldata _params,\n        DepositMultipleInput calldata _dParams,\n        GasParams calldata _gParams\n    ) external payable override lock {\n        //Transfer tokens to this contract.\n        _transferAndApproveMultipleTokens(_dParams.hTokens, _dParams.tokens, _dParams.amounts, _dParams.deposits);\n\n        //Perform call to bridge agent.\n        IBridgeAgent(localBridgeAgentAddress).callOutAndBridgeMultiple{value: msg.value}(\n            payable(msg.sender), _params, _dParams, _gParams\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                BRIDGE AGENT EXECUTOR EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchRouter\n    function executeNoSettlement(bytes calldata) external payable virtual override requiresAgentExecutor {\n        revert UnrecognizedFunctionId();\n    }\n\n    /// @inheritdoc IBranchRouter\n    function executeSettlement(bytes calldata, SettlementParams memory)\n        external\n        payable\n        virtual\n        override\n        requiresAgentExecutor\n    {\n        revert UnrecognizedFunctionId();\n    }\n\n    /// @inheritdoc IBranchRouter\n    function executeSettlementMultiple(bytes calldata, SettlementMultipleParams memory)\n        external\n        payable\n        virtual\n        override\n        requiresAgentExecutor\n    {\n        revert UnrecognizedFunctionId();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function to transfer token into a contract.\n     *   @param _hToken The address of the hToken.\n     *   @param _token The address of the token.\n     *   @param _amount The amount of the hToken.\n     *   @param _deposit The amount of the token.\n     */\n    function _transferAndApproveToken(address _hToken, address _token, uint256 _amount, uint256 _deposit) internal {\n        // Cache local port address\n        address _localPortAddress = localPortAddress;\n\n        // Check if the local branch tokens are being spent\n        if (_amount - _deposit > 0) {\n            unchecked {\n                _hToken.safeTransferFrom(msg.sender, address(this), _amount - _deposit);\n                ERC20(_hToken).approve(_localPortAddress, _amount - _deposit);\n            }\n        }\n\n        // Check if the underlying tokens are being spent\n        if (_deposit > 0) {\n            _token.safeTransferFrom(msg.sender, address(this), _deposit);\n            ERC20(_token).approve(_localPortAddress, _deposit);\n        }\n    }\n\n    /**\n     * @notice Internal function to transfer multiple tokens into a contract.\n     *   @param _hTokens The addresses of the hTokens.\n     *   @param _tokens The addresses of the tokens.\n     *   @param _amounts The amounts of the hTokens.\n     *   @param _deposits The amounts of the tokens.\n     */\n    function _transferAndApproveMultipleTokens(\n        address[] memory _hTokens,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits\n    ) internal {\n        for (uint256 i = 0; i < _hTokens.length;) {\n            _transferAndApproveToken(_hTokens[i], _tokens[i], _amounts[i], _deposits[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is the Bridge Agent Executor.\n    modifier requiresAgentExecutor() {\n        if (msg.sender != bridgeAgentExecutorAddress) revert UnrecognizedBridgeAgentExecutor();\n        _;\n    }\n\n    /// @notice Modifier for a simple re-entrancy check.\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n}"
    },
    {
      "filename": "src/BaseBranchRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IBranchRouter} from \"./interfaces/IBranchRouter.sol\";\n\nimport {\n    IBranchBridgeAgent as IBridgeAgent,\n    GasParams,\n    Deposit,\n    DepositInput,\n    DepositParams,\n    DepositMultipleInput,\n    DepositMultipleParams,\n    SettlementParams,\n    SettlementMultipleParams\n} from \"./interfaces/IBranchBridgeAgent.sol\";\n\n/// @title Base Branch Router Contract\n/// @author MaiaDAO\ncontract BaseBranchRouter is IBranchRouter, Ownable {\n    using SafeTransferLib for address;\n\n    /*///////////////////////////////////////////////////////////////\n                    BASE BRANCH ROUTER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchRouter\n    address public localPortAddress;\n\n    /// @inheritdoc IBranchRouter\n    address public override localBridgeAgentAddress;\n\n    /// @inheritdoc IBranchRouter\n    address public override bridgeAgentExecutorAddress;\n\n    /// @notice Re-entrancy lock modifier state.\n    uint256 internal _unlocked = 1;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        _initializeOwner(msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INITIALIZATION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Initializes the Base Branch Router.\n     * @param _localBridgeAgentAddress The address of the local Bridge Agent.\n     */\n    function initialize(address _localBridgeAgentAddress) external onlyOwner {\n        require(_localBridgeAgentAddress != address(0), \"Bridge Agent address cannot be 0\");\n        localBridgeAgentAddress = _localBridgeAgentAddress;\n        localPortAddress = IBridgeAgent(_localBridgeAgentAddress).localPortAddress();\n        bridgeAgentExecutorAddress = IBridgeAgent(_localBridgeAgentAddress).bridgeAgentExecutorAddress();\n        \n        renounceOwnership();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchRouter\n    function getDepositEntry(uint32 _depositNonce) external view override returns (Deposit memory) {\n        return IBridgeAgent(localBridgeAgentAddress).getDepositEntry(_depositNonce);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchRouter\n    function callOut(bytes calldata _params, GasParams calldata _gParams) external payable override lock {\n        IBridgeAgent(localBridgeAgentAddress).callOut{value: msg.value}(payable(msg.sender), _params, _gParams);\n    }\n\n    /// @inheritdoc IBranchRouter\n    function callOutAndBridge(bytes calldata _params, DepositInput calldata _dParams, GasParams calldata _gParams)\n        external\n        payable\n        override\n        lock\n    {\n        //Transfer tokens to this contract.\n        _transferAndApproveToken(_dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit);\n\n        //Perform call to bridge agent.\n        IBridgeAgent(localBridgeAgentAddress).callOutAndBridge{value: msg.value}(\n            payable(msg.sender), _params, _dParams, _gParams\n        );\n    }\n\n    /// @inheritdoc IBranchRouter\n    function callOutAndBridgeMultiple(\n        bytes calldata _params,\n        DepositMultipleInput calldata _dParams,\n        GasParams calldata _gParams\n    ) external payable override lock {\n        //Transfer tokens to this contract.\n        _transferAndApproveMultipleTokens(_dParams.hTokens, _dParams.tokens, _dParams.amounts, _dParams.deposits);\n\n        //Perform call to bridge agent.\n        IBridgeAgent(localBridgeAgentAddress).callOutAndBridgeMultiple{value: msg.value}(\n            payable(msg.sender), _params, _dParams, _gParams\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                BRIDGE AGENT EXECUTOR EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchRouter\n    function executeNoSettlement(bytes calldata) external payable virtual override requiresAgentExecutor {\n        revert UnrecognizedFunctionId();\n    }\n\n    /// @inheritdoc IBranchRouter\n    function executeSettlement(bytes calldata, SettlementParams memory)\n        external\n        payable\n        virtual\n        override\n        requiresAgentExecutor\n    {\n        revert UnrecognizedFunctionId();\n    }\n\n    /// @inheritdoc IBranchRouter\n    function executeSettlementMultiple(bytes calldata, SettlementMultipleParams memory)\n        external\n        payable\n        virtual\n        override\n        requiresAgentExecutor\n    {\n        revert UnrecognizedFunctionId();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function to transfer token into a contract.\n     *   @param _hToken The address of the hToken.\n     *   @param _token The address of the token.\n     *   @param _amount The amount of the hToken.\n     *   @param _deposit The amount of the token.\n     */\n    function _transferAndApproveToken(address _hToken, address _token, uint256 _amount, uint256 _deposit) internal {\n        // Cache local port address\n        address _localPortAddress = localPortAddress;\n\n        // Check if the local branch tokens are being spent\n        if (_amount - _deposit > 0) {\n            unchecked {\n                _hToken.safeTransferFrom(msg.sender, address(this), _amount - _deposit);\n                ERC20(_hToken).approve(_localPortAddress, _amount - _deposit);\n            }\n        }\n\n        // Check if the underlying tokens are being spent\n        if (_deposit > 0) {\n            _token.safeTransferFrom(msg.sender, address(this), _deposit);\n            ERC20(_token).approve(_localPortAddress, _deposit);\n        }\n    }\n\n    /**\n     * @notice Internal function to transfer multiple tokens into a contract.\n     *   @param _hTokens The addresses of the hTokens.\n     *   @param _tokens The addresses of the tokens.\n     *   @param _amounts The amounts of the hTokens.\n     *   @param _deposits The amounts of the tokens.\n     */\n    function _transferAndApproveMultipleTokens(\n        address[] memory _hTokens,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits\n    ) internal {\n        for (uint256 i = 0; i < _hTokens.length;) {\n            _transferAndApproveToken(_hTokens[i], _tokens[i], _amounts[i], _deposits[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is the Bridge Agent Executor.\n    modifier requiresAgentExecutor() {\n        if (msg.sender != bridgeAgentExecutorAddress) revert UnrecognizedBridgeAgentExecutor();\n        _;\n    }\n\n    /// @notice Modifier for a simple re-entrancy check.\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n}"
    },
    {
      "filename": "src/BranchBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ExcessivelySafeCall} from \"lib/ExcessivelySafeCall.sol\";\n\nimport {IBranchPort as IPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {BridgeAgentConstants} from \"./interfaces/BridgeAgentConstants.sol\";\nimport {\n    Deposit,\n    DepositInput,\n    DepositMultipleInput,\n    GasParams,\n    IBranchBridgeAgent,\n    ILayerZeroReceiver,\n    SettlementMultipleParams\n} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {ILayerZeroEndpoint} from \"./interfaces/ILayerZeroEndpoint.sol\";\n\nimport {BranchBridgeAgentExecutor, DeployBranchBridgeAgentExecutor} from \"./BranchBridgeAgentExecutor.sol\";\n\n/// @title Library for Branch Bridge Agent Deployment\nlibrary DeployBranchBridgeAgent {\n    function deploy(\n        uint16 _rootChainId,\n        uint16 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _lzEndpointAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) external returns (BranchBridgeAgent) {\n        return new BranchBridgeAgent(\n            _rootChainId,\n            _localChainId,\n            _rootBridgeAgentAddress,\n            _lzEndpointAddress,\n            _localRouterAddress,\n            _localPortAddress\n        );\n    }\n}\n\n/// @title Branch Bridge Agent Contract\n/// @author MaiaDAO\ncontract BranchBridgeAgent is IBranchBridgeAgent, BridgeAgentConstants {\n    using ExcessivelySafeCall for address;\n\n    /*///////////////////////////////////////////////////////////////\n                         BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain Id for Root Chain where liquidity is virtualized(e.g. 4).\n    uint16 public immutable rootChainId;\n\n    /// @notice Chain Id for Local Chain.\n    uint16 public immutable localChainId;\n\n    /// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address\n    ///         where cross-chain requests are executed in the Root Chain.\n    address public immutable rootBridgeAgentAddress;\n\n    /// @notice Layer Zero messaging layer path for Root Bridge Agent Address where cross-chain requests\n    ///         are sent to the Root Chain Router.\n    bytes private rootBridgeAgentPath;\n\n    /// @notice Local Layerzero Endpoint Address where cross-chain requests are sent to the Root Chain Router.\n    address public immutable lzEndpointAddress;\n\n    /// @notice Address for Local Router used for custom actions for different hApps.\n    address public immutable localRouterAddress;\n\n    /// @notice Address for Local Port Address\n    ///         where funds deposited from this chain are kept, managed and supplied to different Port Strategies.\n    address public immutable localPortAddress;\n\n    /// @notice Address for Bridge Agent Executor used for executing cross-chain requests.\n    address public immutable bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                            DEPOSITS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying the transaction.\n    uint32 public depositNonce;\n\n    /// @notice Mapping from Pending deposits hash to Deposit Struct.\n    mapping(uint256 depositNonce => Deposit depositInfo) public getDeposit;\n\n    /*///////////////////////////////////////////////////////////////\n                        SETTLEMENT EXECUTION STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, the bridge agent has already served a request with this nonce from a given chain.\n    mapping(uint256 settlementNonce => uint256 state) public executionState;\n\n    /*///////////////////////////////////////////////////////////////\n                           REENTRANCY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Re-entrancy lock modifier state.\n    uint256 internal _unlocked = 1;\n\n    /*///////////////////////////////////////////////////////////////\n                             CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Branch Bridge Agent.\n     * @param _rootChainId Chain Id for Root Chain where liquidity is virtualized and assets are managed.\n     * @param _localChainId Chain Id for Local Chain.\n     * @param _rootBridgeAgentAddress Address for Bridge Agent who processes requests sent to and from the Root Chain.\n     * @param _lzEndpointAddress Local Layerzero Endpoint Address where cross-chain requests are sent to the Root Chain Router.\n     * @param _localRouterAddress Address for Local Router used for custom actions for different Omnichain dApps.\n     * @param _localPortAddress Address for Local Port Address where funds deposited from this chain are kept, managed\n     *                          and supplied to different Port Strategies.\n     */\n    constructor(\n        uint16 _rootChainId,\n        uint16 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _lzEndpointAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) {\n        require(_rootBridgeAgentAddress != address(0), \"Root Bridge Agent Address cannot be the zero address.\");\n        require(\n            _lzEndpointAddress != address(0) || _rootChainId == _localChainId,\n            \"Layerzero Endpoint Address cannot be the zero address.\"\n        );\n        require(_localRouterAddress != address(0), \"Local Router Address cannot be the zero address.\");\n        require(_localPortAddress != address(0), \"Local Port Address cannot be the zero address.\");\n\n        localChainId = _localChainId;\n        rootChainId = _rootChainId;\n        rootBridgeAgentAddress = _rootBridgeAgentAddress;\n        lzEndpointAddress = _lzEndpointAddress;\n        localRouterAddress = _localRouterAddress;\n        localPortAddress = _localPortAddress;\n        bridgeAgentExecutorAddress = DeployBranchBridgeAgentExecutor.deploy();\n        depositNonce = 1;\n\n        rootBridgeAgentPath = abi.encodePacked(_rootBridgeAgentAddress, address(this));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        FALLBACK FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    receive() external payable {}\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function getDepositEntry(uint32 _depositNonce) external view override returns (Deposit memory) {\n        return getDeposit[_depositNonce];\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function getFeeEstimate(uint256 _gasLimit, uint256 _remoteBranchExecutionGas, bytes calldata _payload)\n        external\n        view\n        returns (uint256 _fee)\n    {\n        (_fee,) = ILayerZeroEndpoint(lzEndpointAddress).estimateFees(\n            rootChainId,\n            address(this),\n            _payload,\n            false,\n            abi.encodePacked(uint16(2), _gasLimit, _remoteBranchExecutionGas, rootBridgeAgentAddress)\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    USER / BRANCH ROUTER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSystem(address payable _refundee, bytes calldata _params, GasParams calldata _gParams)\n        external\n        payable\n        override\n        lock\n        requiresRouter\n    {\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(bytes1(0x00), depositNonce++, _params);\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOut(address payable _refundee, bytes calldata _params, GasParams calldata _gParams)\n        external\n        payable\n        override\n        lock\n    {\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(bytes1(0x01), depositNonce++, _params);\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridge(\n        address payable _refundee,\n        bytes calldata _params,\n        DepositInput memory _dParams,\n        GasParams calldata _gParams\n    ) external payable override lock {\n        //Cache Deposit Nonce\n        uint32 _depositNonce = depositNonce;\n\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(\n            bytes1(0x02), _depositNonce, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit, _params\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _createDeposit(_depositNonce, _refundee, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit);\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridgeMultiple(\n        address payable _refundee,\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        GasParams calldata _gParams\n    ) external payable override lock {\n        //Cache Deposit Nonce\n        uint32 _depositNonce = depositNonce;\n\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(\n            bytes1(0x03),\n            uint8(_dParams.hTokens.length),\n            _depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            _params\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _createDepositMultiple(\n            _depositNonce, _refundee, _dParams.hTokens, _dParams.tokens, _dParams.amounts, _dParams.deposits\n        );\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSigned(address payable _refundee, bytes calldata _params, GasParams calldata _gParams)\n        external\n        payable\n        override\n        lock\n    {\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(bytes1(0x04), msg.sender, depositNonce++, _params);\n\n        //Perform Signed Call without deposit\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridge(\n        address payable _refundee,\n        bytes calldata _params,\n        DepositInput memory _dParams,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock {\n        //Cache Deposit Nonce\n        uint32 _depositNonce = depositNonce;\n\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(\n            _hasFallbackToggled ? bytes1(0x85) : bytes1(0x05),\n            msg.sender,\n            _depositNonce,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _dParams.deposit,\n            _params\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _createDeposit(_depositNonce, _refundee, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit);\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridgeMultiple(\n        address payable _refundee,\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock {\n        // Cache Deposit Nonce\n        uint32 _depositNonce = depositNonce;\n\n        // Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(\n            _hasFallbackToggled ? bytes1(0x86) : bytes1(0x06),\n            msg.sender,\n            uint8(_dParams.hTokens.length),\n            _depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            _params\n        );\n\n        // Create a Deposit and Send Cross-Chain request\n        _createDepositMultiple(\n            _depositNonce, _refundee, _dParams.hTokens, _dParams.tokens, _dParams.amounts, _dParams.deposits\n        );\n\n        //Perform Call\n        _performCall(_refundee, payload, _gParams);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    DEPOSIT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retryDeposit(\n        bool _isSigned,\n        uint32 _depositNonce,\n        bytes calldata _params,\n        GasParams calldata _gParams,\n        bool _hasFallbackToggled\n    ) external payable override lock {\n        // Get Settlement Reference\n        Deposit storage deposit = getDeposit[_depositNonce];\n\n        //Check if deposit belongs to message sender\n        if (deposit.owner != msg.sender) revert NotDepositOwner();\n\n        //Encode Data for cross-chain call.\n        bytes memory payload;\n\n        if (uint8(deposit.hTokens.length) == 1) {\n            if (_isSigned) {\n                //Pack new Data\n                payload = abi.encodePacked(\n                    _hasFallbackToggled ? bytes1(0x85) : bytes1(0x05),\n                    msg.sender,\n                    _depositNonce,\n                    deposit.hTokens[0],\n                    deposit.tokens[0],\n                    deposit.amounts[0],\n                    deposit.deposits[0],\n                    _params\n                );\n            } else {\n                payload = abi.encodePacked(\n                    bytes1(0x02),\n                    _depositNonce,\n                    deposit.hTokens[0],\n                    deposit.tokens[0],\n                    deposit.amounts[0],\n                    deposit.deposits[0],\n                    _params\n                );\n            }\n        } else if (uint8(deposit.hTokens.length) > 1) {\n            if (_isSigned) {\n                //Pack new Data\n                payload = abi.encodePacked(\n                    _hasFallbackToggled ? bytes1(0x86) : bytes1(0x06),\n                    msg.sender,\n                    uint8(deposit.hTokens.length),\n                    _depositNonce,\n                    deposit.hTokens,\n                    deposit.tokens,\n                    deposit.amounts,\n                    deposit.deposits,\n                    _params\n                );\n            } else {\n                payload = abi.encodePacked(\n                    bytes1(0x03),\n                    uint8(deposit.hTokens.length),\n                    _depositNonce,\n                    deposit.hTokens,\n                    deposit.tokens,\n                    deposit.amounts,\n                    deposit.deposits,\n                    _params\n                );\n            }\n        }\n\n        // Check if payload is empty\n        if (payload.length == 0) revert DepositRetryUnavailableUseCallout();\n\n        // Ensure success Status\n        deposit.status = STATUS_SUCCESS;\n\n        // Perform Call\n        _performCall(payable(msg.sender), payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retrieveDeposit(uint32 _depositNonce, GasParams calldata _gParams) external payable override lock {\n        // Check if the deposit belongs to the message sender\n        if (getDeposit[_depositNonce].owner != msg.sender) revert NotDepositOwner();\n\n        //Encode Data for cross-chain call.\n        bytes memory payload = abi.encodePacked(bytes1(0x08), msg.sender, _depositNonce);\n\n        //Update State and Perform Call\n        _performCall(payable(msg.sender), payload, _gParams);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function redeemDeposit(uint32 _depositNonce) external override lock {\n        // Get storage reference\n        Deposit storage deposit = getDeposit[_depositNonce];\n\n        // Check Deposit\n        if (deposit.status == STATUS_SUCCESS) revert DepositRedeemUnavailable();\n        if (deposit.owner == address(0)) revert DepositRedeemUnavailable();\n        if (deposit.owner != msg.sender) revert NotDepositOwner();\n\n        // Zero out owner\n        deposit.owner = address(0);\n\n        // Transfer token to depositor / user\n        for (uint256 i = 0; i < deposit.tokens.length;) {\n            _clearToken(msg.sender, deposit.hTokens[i], deposit.tokens[i], deposit.amounts[i], deposit.deposits[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Delete Failed Deposit Token Info\n        delete getDeposit[_depositNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    SETTLEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retrySettlement(\n        uint3"
    }
  ]
}