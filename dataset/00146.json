{
  "Title": "H-12: Not transferring collateral when submitting bids allows malicious users to create honeypot-style attacks",
  "Content": "# Issue H-12: Not transferring collateral when submitting bids allows malicious users to create honeypot-style attacks \n\nSource: https://github.com/sherlock-audit/2024-04-teller-finance-judging/issues/219 \n\nThe protocol has acknowledged this issue.\n\n## Found by \n0xadrii\n## Summary\nCurrently, Teller does not require collateral to be transferred when a bid request with collateral is submitted. Instead, the collateral is pulled from the borrower when the bid is accepted by the lender in a different transaction. This pattern allows attackers to leverage certain collaterals to perform honeypot-style attacks.\n\n## Vulnerability Detail\n\nThe current flow to create a bid in Teller putting some collateral consists in the following steps:\n\n1. Call `submitBid` with an array of `Collateral`. This creates the bid request, but **does not transfer the collateral to Teller**. Instead, Teller only check that Teller performs is checking the collateral balance of the borrower to guarantee that he actually owns the collateral assets.\n2. After submitting the bid request, an interested lender can lend his assets to the borrower by calling `lenderAcceptBid`. This is the step where collateral will actually be transferred from the borrower, as shown in the following code snippet:\n    \n    ```solidity\n    // TellerV2.sol\n    \n    function lenderAcceptBid(uint256 _bidId)\n            external\n            override\n            pendingBid(_bidId, \"lenderAcceptBid\")\n            whenNotPaused\n            returns (\n                uint256 amountToProtocol,\n                uint256 amountToMarketplace,\n                uint256 amountToBorrower\n            )\n        {\n            ...\n    \n            // Tell the collateral manager to deploy the escrow and pull funds from the borrower if applicable\n            collateralManager.deployAndDeposit(_bidId);\n            \n            ...\n            \n        }\n    ```\n    \n\nAlthough this pattern (checking the borrower’s collateral balance in step 1 to ensure he actually owns the assets) might look like a correct approach, it’s actually incorrect and can lead to honeypot-style attacks when specific NFTs are used as collateral.\n\nConsider the following scenario: a malicious borrower holds a Uniswap V3 liquidity position NFT with liquidity worth 10 ETH. He decides to trick borrowers in Teller, and submits a loan request asking for only 1 ETH (a very attractive offer, given that on default, the lender will gain access to 10 ETH worth of collateral):\n\n1. Borrower creates the borrow request by calling `submitBid`. `submitBid` then checks and guarantees that the borrower indeed holds the Uniswap liquidity position.\n2. After some time, a lender sees the borrow request and decides that they want to lend their assets to the borrower by calling `lenderAcceptBid`, as the Uniswap liquidity position (which is worth 10 ETH) is attractive enough to cover the possibility of borrowed assets never being repaid. \n3. The malicious borrower then frontruns the lender transaction and decreases the Uniswap liquidity position to nearly 0 (because collateral has not been transferred when submitting the bid request, the NFT owner is still the borrower, hence why liquidity can be decreased by him). \n4. After decreasing the Uniswap position liquidity, the lender’s `lenderAcceptBid` transaction actually gets executed. Uniswap’s liquidity position NFT gets transferred to Teller from the borrower, and the borrowed funds are transferred to the borrower.\n\nAs we can see, not transferring the collateral when the bid request is submitted can lead to these type of situations. Borrowers can easily trick lenders, making them believe that their loaned assets are backed by an NFT worth an X amount, when in reality the NFT will be worth nearly 0 when the transactions actually get executed.\n\n## Impact\n\nHigh. Attackers can easily steal all the borrowed assets from lenders with no collateral cost at all, given that the collateral NFT will be worth 0 when the borrow is actually executed.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2.sol#L334\n\nhttps://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2.sol#L521\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOne way to mitigate this type of attack is to force users to transfer their collateral to Teller when a borrow request is submitted. This approach would easily mitigate this issue, as users won’t be able to perform any action over the collateral NFTs as they won’t be the owners. In the situation where the loan is never accepted and the bidExpirationTime is reached, borrowers should be able to withdraw their collateral assets.\n\n\n\n## Discussion\n\n**nevillehuang**\n\nrequest poc\n\nNot sure if we can call this an issue, because the lender would have to take the risk before accepting such NFTs to be used as collateral. They can simply choose not to do so to avoid the exploit.\n\n**sherlock-admin4**\n\nPoC requested from @0xadrii\n\nRequests remaining: **14**\n\n**0xadrii**\n\nHey @nevillehuang ,\n\nI understand your reasoning, however I believe that this must be considered as an issue due to the following reasons.\n\nThe root cause of the issue is inherently bound to the flawed submit-accept loan creation approach used in Teller. As mentioned in my report, the main problem is the process in which new loans are created. \nCurrently this process involves two separate steps:\n1.⁠ ⁠A borrower submitting a loan request. In this step, only the collateral balance of the borrower is checked, but collateral is never transferred to the protocol. Not transferring the collateral in this step is the main root cause of the issue and what allows the attack vector I mentioned to take place, given that collateral is still held in the borrower's address until the loan is accepted by the lender.\n2.⁠ ⁠A lender accepting the loan request. It is in this step where the collateral is actually transferred.\n\nSo there's an invariant here that must always hold: the collateral value before and after a lender accepts a loan should only be subject to changes derived from market conditions, and nothing else. This invariant must hold for any type of collateral supported in Teller. Usually, changing the value of a collateral is not possible because the value of the assets simply can't be modified and is given by the market. However, Uniswap liquidity positions are a type of asset whose value isn't only derived from the market, but also can actually be changed by adding or substracting liquidity to/from them. This is a risk that must be considered in Teller and can't be overlooked, given that any type of collateral is accepted in the protocol (Uniswap liquidity positions included, which are likely to be used as collateral in a real life scenario). \n\nIn addition, all loans must be accepted by lenders given the peer-to-peer nature of Teller, so, as you mentioned, they will always be taking a risk when accepting loans (the risk that anyone would incur when interacting with a DEFI protocol). However, the type of risk shown by the attack I described should not be expected by the lenders. It is extremely probable that they will be willing to take these kind of loans given that they will assume (as it should be with all collaterals) that the value of the collateral before and after accepting the loan won't change drastically and that they won't be exposed to an attack such as the one described.\n\nLet me know if you still need the poc and I'll be happy to provide it! \n\n**ethereumdegen**\n\nThis was a design decision made by leadership years ago.  We opted to NOT transfer collateral in on submit bid in order to allow for the same collateral to be used across multiple loans.   The recommendation to our users is to not accept collateral that can change (use a bored ape, dont use a Uni liq pool nft ) or make sure that token is wrapped (wrap the Liq Pool NFT) so it cant be attacked in that way at the last moment.   \n\nThank you for your research and report.  \n\n**0xadrii**\n\nHey @ethereumdegen , I get your point. However, as per [Sherlock's hierarchy of truth](https://docs.sherlock.xyz/audits/judging/judging#iii.-sherlocks-standards), this issue must be accepted. \n\n [Teller's contest page](https://audits.sherlock.xyz/contests/295) explicitly mentions that any token is supported in the protocol (from [Teller's first contest](https://audits.sherlock.xyz/contests/62)):  _\"Any tokens are acceptable and this is one area where research is needed to ensure that functionality is not taken advantage of and that assumptions are not broken in the protocol. This includes tokens (principal or collateral) which attempt to use re-entrancy to break assumptions.\"_ The only restriction is for ERC20 tokens, where only the ones accepted in Uniswap are supported.\n\nMoreover, [Teller's documentation](https://docs.teller.org/teller-lite/borrowing-on-teller#what-collateral-can-i-use) explicitly mentions that _\"any ERC-721, ERC-721A (NFTs) can be used\"_.\n\nI understand that you don't want to fix it, but as per Sherlock's rules, this must be accepted as an issue given that both the README and documentation mention that any NFT could be used.\n\n**nevillehuang**\n\n@ethereumdegen Was there public information stating this recommendation/design choice on teller docs?\n\n**spacegliderrrr**\n\nThe lender has to **manually** accept every loan they'd like to take. They must acknowledge all the risks that come with it. UniV3 positions do not have a stable price, hence any lender willing to take such position must know the risk that comes with it.\n\nEven if collateral was transferred prior to bid's accept, there would still be ways for borrower to lower its value. E.g. if borrower offers a 1 WETH position as collateral in WETH/USDC pool at 1:1 price range, borrower would still be able to decrease position's value after transferring it, by simply swapping 1 USDC for it (making the collateral worth 1 USDC total in the same manner of a 'honey-pot' attack)\n\n\n**0xadrii**\n\nYou are right, the lender needs to acknowledge all the risks, but these are market risks, not risks derived from a wrong smart contract implementation. \n\nObviously, users interacting with a lending protocol should be aware that market conditions can affect them, and that interacting with certain assets might be more risky than others. However, when the attack comes from an issue in the smart contracts you are interacting with (as the one I shown), rather than market conditions, the user must not be responsible for it. Otherwise, we could say that users interacting with a protocol that appraises Uniswap positions wrongly should be aware of the fact that these type of risks are possible.  \n\nBesides this, the honey-pot attack you mention is completely different to the attack that I reported. In your attack, an uncommon and unreasonable price range in the pool is required. This would already be a huge red flag for the borrower. On the other hand, the attack I detailed is possible with **any price range in any Uniswap pool**, which would give the lender a completely different sense on how legit the loan might be if a proper range is used. But even if we consider that a user would be willing to accept such a loan with a weird price range, the risk should still be mitigated instead of leaving the vulnerability in the protocol. For example, lenders could pass a minimum expected collateral value when accepting a loan. If the collateral is detected to be a Uniswap position, then the price of the position could be calculated and compared with the minimum required value. This would easily prevent these type of attacks. But saying that the vulnerability should be left in the contract is not a good way to protect the protocol.\n\nAs @ethereumdegen mentioned, they will be alerting their users recommending them to use wrappers or not interact with these types of assets. But as detailed in [my comment](https://github.com/sherlock-audit/2024-04-teller-finance-judging/issues/219#issuecomment-2098959108), this should have been explicitly mentioned in the contest README/protocol documentation. However, both the contest README and documentation clearly stated that **any type of NFT will be accepted as collateral**, so this attack must be accepted as an issue.\n\n\n**nevillehuang**\n\nSince teller intends to support all types of ERC721 and it was not explicitly mentioned that this was a design decision/known risk for such NFTs I believe it to be a valid issue. The design choice is suboptimal and **does** imply a loss of funds for lenders when such NFTs are utilized, since they can accept such bids with when such collateral are used (details at time when bids are accepted is accurate). This is exacerbated by the fact that teller has no value-based liquidation in place.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/295",
  "Code": [
    {
      "filename": "teller-protocol-v2-audit-2024/packages/contracts/contracts/TellerV2.sol",
      "content": "pragma solidity >=0.8.0 <0.9.0;\n// SPDX-License-Identifier: MIT\n\n// Contracts\nimport \"./ProtocolFee.sol\";\nimport \"./TellerV2Storage.sol\";\nimport \"./TellerV2Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\n\n// Interfaces\nimport \"./interfaces/IMarketRegistry.sol\";\nimport \"./interfaces/IReputationManager.sol\";\nimport \"./interfaces/ITellerV2.sol\";\nimport { Collateral } from \"./interfaces/escrow/ICollateralEscrowV1.sol\";\nimport \"./interfaces/IEscrowVault.sol\";\n\nimport { ILoanRepaymentCallbacks } from \"./interfaces/ILoanRepaymentCallbacks.sol\";\nimport \"./interfaces/ILoanRepaymentListener.sol\";\n\n// Libraries\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./libraries/NumbersLib.sol\";\n\nimport { V2Calculations, PaymentCycleType } from \"./libraries/V2Calculations.sol\";\n\n/* Errors */\n/**\n * @notice This error is reverted when the action isn't allowed\n * @param bidId The id of the bid.\n * @param action The action string (i.e: 'repayLoan', 'cancelBid', 'etc)\n * @param message The message string to return to the user explaining why the tx was reverted\n */\nerror ActionNotAllowed(uint256 bidId, string action, string message);\n\n/**\n * @notice This error is reverted when repayment amount is less than the required minimum\n * @param bidId The id of the bid the borrower is attempting to repay.\n * @param payment The payment made by the borrower\n * @param minimumOwed The minimum owed value\n */\nerror PaymentNotMinimum(uint256 bidId, uint256 payment, uint256 minimumOwed);\n\ncontract TellerV2 is\n    ITellerV2,\n    ILoanRepaymentCallbacks,\n    OwnableUpgradeable,\n    ProtocolFee,\n    PausableUpgradeable,\n    TellerV2Storage,\n    TellerV2Context\n{\n    using Address for address;\n    using SafeERC20 for IERC20;\n    using NumbersLib for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    //the first 20 bytes of keccak256(\"lender manager\")\n    address constant USING_LENDER_MANAGER =\n        0x84D409EeD89F6558fE3646397146232665788bF8;\n\n    /** Events */\n\n    /**\n     * @notice This event is emitted when a new bid is submitted.\n     * @param bidId The id of the bid submitted.\n     * @param borrower The address of the bid borrower.\n     * @param metadataURI URI for additional bid information as part of loan bid.\n     */\n    event SubmittedBid(\n        uint256 indexed bidId,\n        address indexed borrower,\n        address receiver,\n        bytes32 indexed metadataURI\n    );\n\n    /**\n     * @notice This event is emitted when a bid has been accepted by a lender.\n     * @param bidId The id of the bid accepted.\n     * @param lender The address of the accepted bid lender.\n     */\n    event AcceptedBid(uint256 indexed bidId, address indexed lender);\n\n    /**\n     * @notice This event is emitted when a previously submitted bid has been cancelled.\n     * @param bidId The id of the cancelled bid.\n     */\n    event CancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when market owner has cancelled a pending bid in their market.\n     * @param bidId The id of the bid funded.\n     *\n     * Note: The `CancelledBid` event will also be emitted.\n     */\n    event MarketOwnerCancelledBid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a payment is made towards an active loan.\n     * @param bidId The id of the bid/loan to which the payment was made.\n     */\n    event LoanRepayment(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanRepaid(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been closed by a lender to claim collateral.\n     * @param bidId The id of the bid accepted.\n     */\n    event LoanClosed(uint256 indexed bidId);\n\n    /**\n     * @notice This event is emitted when a loan has been fully repaid.\n     * @param bidId The id of the bid/loan which was repaid.\n     */\n    event LoanLiquidated(uint256 indexed bidId, address indexed liquidator);\n\n    /**\n     * @notice This event is emitted when a fee has been paid related to a bid.\n     * @param bidId The id of the bid.\n     * @param feeType The name of the fee being paid.\n     * @param amount The amount of the fee being paid.\n     */\n    event FeePaid(\n        uint256 indexed bidId,\n        string indexed feeType,\n        uint256 indexed amount\n    );\n\n    /** Modifiers */\n\n    /**\n     * @notice This modifier is used to check if the state of a bid is pending, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier pendingBid(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.PENDING) {\n            revert ActionNotAllowed(_bidId, _action, \"Bid must be pending\");\n        }\n\n        _;\n    }\n\n    /**\n     * @notice This modifier is used to check if the state of a loan has been accepted, before running an action.\n     * @param _bidId The id of the bid to check the state for.\n     * @param _action The desired action to run on the bid.\n     */\n    modifier acceptedLoan(uint256 _bidId, string memory _action) {\n        if (bids[_bidId].state != BidState.ACCEPTED) {\n            revert ActionNotAllowed(_bidId, _action, \"Loan must be accepted\");\n        }\n\n        _;\n    }\n\n    /** Constant Variables **/\n\n    uint8 public constant CURRENT_CODE_VERSION = 10;\n\n    uint32 public constant LIQUIDATION_DELAY = 86400; //ONE DAY IN SECONDS\n\n    /** Constructor **/\n\n    constructor(address trustedForwarder) TellerV2Context(trustedForwarder) {}\n\n    /** External Functions **/\n\n    /**\n     * @notice Initializes the proxy.\n     * @param _protocolFee The fee collected by the protocol for loan processing.\n     * @param _marketRegistry The address of the market registry contract for the protocol.\n     * @param _reputationManager The address of the reputation manager contract.\n     * @param _lenderCommitmentForwarder The address of the lender commitment forwarder contract.\n     * @param _collateralManager The address of the collateral manager contracts.\n     * @param _lenderManager The address of the lender manager contract for loans on the protocol.\n     */\n    function initialize(\n        uint16 _protocolFee,\n        address _marketRegistry,\n        address _reputationManager,\n        address _lenderCommitmentForwarder,\n        address _collateralManager,\n        address _lenderManager,\n        address _escrowVault\n    ) external initializer {\n        __ProtocolFee_init(_protocolFee);\n\n        __Pausable_init();\n\n        require(\n            _lenderCommitmentForwarder.isContract(),\n            \"LenderCommitmentForwarder must be a contract\"\n        );\n        lenderCommitmentForwarder = _lenderCommitmentForwarder;\n\n        require(\n            _marketRegistry.isContract(),\n            \"MarketRegistry must be a contract\"\n        );\n        marketRegistry = IMarketRegistry(_marketRegistry);\n\n        require(\n            _reputationManager.isContract(),\n            \"ReputationManager must be a contract\"\n        );\n        reputationManager = IReputationManager(_reputationManager);\n\n        require(\n            _collateralManager.isContract(),\n            \"CollateralManager must be a contract\"\n        );\n        collateralManager = ICollateralManager(_collateralManager);\n\n        _setLenderManager(_lenderManager);\n        _setEscrowVault(_escrowVault);\n    }\n\n    /* function setEscrowVault(address _escrowVault) external reinitializer(9) {\n        _setEscrowVault(_escrowVault);\n    }\n    */\n\n    function _setLenderManager(address _lenderManager)\n        internal\n        onlyInitializing\n    {\n        require(\n            _lenderManager.isContract(),\n            \"LenderManager must be a contract\"\n        );\n        lenderManager = ILenderManager(_lenderManager);\n    }\n\n    function _setEscrowVault(address _escrowVault) internal onlyInitializing {\n        require(_escrowVault.isContract(), \"EscrowVault must be a contract\");\n        escrowVault = IEscrowVault(_escrowVault);\n    }\n\n    /**\n     * @notice Gets the metadataURI for a bidId.\n     * @param _bidId The id of the bid to return the metadataURI for\n     * @return metadataURI_ The metadataURI for the bid, as a string.\n     */\n    function getMetadataURI(uint256 _bidId)\n        public\n        view\n        returns (string memory metadataURI_)\n    {\n        // Check uri mapping first\n        metadataURI_ = uris[_bidId];\n        // If the URI is not present in the mapping\n        if (\n            keccak256(abi.encodePacked(metadataURI_)) ==\n            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 // hardcoded constant of keccak256('')\n        ) {\n            // Return deprecated bytes32 uri as a string\n            uint256 convertedURI = uint256(bids[_bidId]._metadataURI);\n            metadataURI_ = StringsUpgradeable.toHexString(convertedURI, 32);\n        }\n    }\n\n    /**\n     * @notice Function for a borrower to create a bid for a loan without Collateral.\n     * @param _lendingToken The lending token asset requested to be borrowed.\n     * @param _marketplaceId The unique id of the marketplace for the bid.\n     * @param _principal The principal amount of the loan bid.\n     * @param _duration The recurrent length of time before which a payment is due.\n     * @param _APR The proposed interest rate for the loan bid.\n     * @param _metadataURI The URI for additional borrower loan information as part of loan bid.\n     * @param _receiver The address where the loan amount will be sent to.\n     */\n    function submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver\n    ) public override whenNotPaused returns (uint256 bidId_) {\n        bidId_ = _submitBid(\n            _lendingToken,\n            _marketplaceId,\n            _principal,\n            _duration,\n            _APR,\n            _metadataURI,\n            _receiver\n        );\n    }\n\n    /**\n     * @notice Function for a borrower to create a bid for a loan with Collateral.\n     * @param _lendingToken The lending token asset requested to be borrowed.\n     * @param _marketplaceId The unique id of the marketplace for the bid.\n     * @param _principal The principal amount of the loan bid.\n     * @param _duration The recurrent length of time before which a payment is due.\n     * @param _APR The proposed interest rate for the loan bid.\n     * @param _metadataURI The URI for additional borrower loan information as part of loan bid.\n     * @param _receiver The address where the loan amount will be sent to.\n     * @param _collateralInfo Additional information about the collateral asset.\n     */\n    function submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver,\n        Collateral[] calldata _collateralInfo\n    ) public override whenNotPaused returns (uint256 bidId_) {\n        bidId_ = _submitBid(\n            _lendingToken,\n            _marketplaceId,\n            _principal,\n            _duration,\n            _APR,\n            _metadataURI,\n            _receiver\n        );\n\n        bool validation = collateralManager.commitCollateral(\n            bidId_,\n            _collateralInfo\n        );\n\n        require(\n            validation == true,\n            \"Collateral balance could not be validated\"\n        );\n    }\n\n    function _submitBid(\n        address _lendingToken,\n        uint256 _marketplaceId,\n        uint256 _principal,\n        uint32 _duration,\n        uint16 _APR,\n        string calldata _metadataURI,\n        address _receiver\n    ) internal virtual returns (uint256 bidId_) {\n        address sender = _msgSenderForMarket(_marketplaceId);\n\n        (bool isVerified, ) = marketRegistry.isVerifiedBorrower(\n            _marketplaceId,\n            sender\n        );\n\n        require(isVerified, \"Not verified borrower\");\n\n        require(\n            marketRegistry.isMarketOpen(_marketplaceId),\n            \"Market is not open\"\n        );\n\n        // Set response bid ID.\n        bidId_ = bidId;\n\n        // Create and store our bid into the mapping\n        Bid storage bid = bids[bidId];\n        bid.borrower = sender;\n        bid.receiver = _receiver != address(0) ? _receiver : bid.borrower;\n        bid.marketplaceId = _marketplaceId;\n        bid.loanDetails.lendingToken = IERC20(_lendingToken);\n        bid.loanDetails.principal = _principal;\n        bid.loanDetails.loanDuration = _duration;\n        bid.loanDetails.timestamp = uint32(block.timestamp);\n\n        // Set payment cycle type based on market setting (custom or monthly)\n        (bid.terms.paymentCycle, bidPaymentCycleType[bidId]) = marketRegistry\n            .getPaymentCycle(_marketplaceId);\n\n        bid.terms.APR = _APR;\n\n        bidDefaultDuration[bidId] = marketRegistry.getPaymentDefaultDuration(\n            _marketplaceId\n        );\n\n        bidExpirationTime[bidId] = marketRegistry.getBidExpirationTime(\n            _marketplaceId\n        );\n\n        bid.paymentType = marketRegistry.getPaymentType(_marketplaceId);\n\n        bid.terms.paymentCycleAmount = V2Calculations\n            .calculatePaymentCycleAmount(\n                bid.paymentType,\n                bidPaymentCycleType[bidId],\n                _principal,\n                _duration,\n                bid.terms.paymentCycle,\n                _APR\n            );\n\n        uris[bidId] = _metadataURI;\n        bid.state = BidState.PENDING;\n\n        emit SubmittedBid(\n            bidId,\n            bid.borrower,\n            bid.receiver,\n            keccak256(abi.encodePacked(_metadataURI))\n        );\n\n        // Store bid inside borrower bids mapping\n        borrowerBids[bid.borrower].push(bidId);\n\n        // Increment bid id counter\n        bidId++;\n    }\n\n    /**\n     * @notice Function for a borrower to cancel their pending bid.\n     * @param _bidId The id of the bid to cancel.\n     */\n    function cancelBid(uint256 _bidId) external {\n        if (\n            _msgSenderForMarket(bids[_bidId].marketplaceId) !=\n            bids[_bidId].borrower\n        ) {\n            revert ActionNotAllowed({\n                bidId: _bidId,\n                action: \"cancelBid\",\n                message: \"Only the bid owner can cancel!\"\n            });\n        }\n        _cancelBid(_bidId);\n    }\n\n    /**\n     * @notice Function for a market owner to cancel a bid in the market.\n     * @param _bidId The id of the bid to cancel.\n     */\n    function marketOwnerCancelBid(uint256 _bidId) external {\n        if (\n            _msgSender() !=\n            marketRegistry.getMarketOwner(bids[_bidId].marketplaceId)\n        ) {\n            revert ActionNotAllowed({\n                bidId: _bidId,\n                action: \"marketOwnerCancelBid\",\n                message: \"Only the market owner can cancel!\"\n            });\n        }\n        _cancelBid(_bidId);\n        emit MarketOwnerCancelledBid(_bidId);\n    }\n\n    /**\n     * @notice Function for users to cancel a bid.\n     * @param _bidId The id of the bid to be cancelled.\n     */\n    function _cancelBid(uint256 _bidId)\n        internal\n        virtual\n        pendingBid(_bidId, \"cancelBid\")\n    {\n        // Set the bid state to CANCELLED\n        bids[_bidId].state = BidState.CANCELLED;\n\n        // Emit CancelledBid event\n        emit CancelledBid(_bidId);\n    }\n\n    /**\n     * @notice Function for a lender to accept a proposed loan bid.\n     * @param _bidId The id of the loan bid to accept.\n     */\n    function lenderAcceptBid(uint256 _bidId)\n        external\n        override\n        pendingBid(_bidId, \"lenderAcceptBid\")\n        whenNotPaused\n        returns (\n            uint256 amountToProtocol,\n            uint256 amountToMarketplace,\n            uint256 amountToBorrower\n        )\n    {\n        // Retrieve bid\n        Bid storage bid = bids[_bidId];\n\n        address sender = _msgSenderForMarket(bid.marketplaceId);\n\n        (bool isVerified, ) = marketRegistry.isVerifiedLender(\n            bid.marketplaceId,\n            sender\n        );\n        require(isVerified, \"Not verified lender\");\n\n        require(\n            !marketRegistry.isMarketClosed(bid.marketplaceId),\n            \"Market is closed\"\n        );\n\n        require(!isLoanExpired(_bidId), \"Bid has expired\");\n\n        // Set timestamp\n        bid.loanDetails.acceptedTimestamp = uint32(block.timestamp);\n        bid.loanDetails.lastRepaidTimestamp = uint32(block.timestamp);\n\n        // Mark borrower's request as accepted\n        bid.state = BidState.ACCEPTED;\n\n        // Declare the bid acceptor as the lender of the bid\n        bid.lender = sender;\n\n        // Tell the collateral manager to deploy the escrow and pull funds from the borrower if applicable\n        collateralManager.deployAndDeposit(_bidId);\n\n        // Transfer funds to borrower from the lender\n        amountToProtocol = bid.loanDetails.principal.percent(protocolFee());\n        amountToMarketplace = bid.loanDetails.principal.percent(\n            marketRegistry.getMarketplaceFee(bid.marketplaceId)\n        );\n        amountToBorrower =\n            bid.loanDetails.principal -\n            amountToProtocol -\n            amountToMarketplace;\n\n        //transfer fee to protocol\n        if (amountToProtocol > 0) {\n            bid.loanDetails.lendingToken.safeTransferFrom(\n                sender,\n                owner(),\n                amountToProtocol\n            );\n        }\n\n        //transfer fee to marketplace\n        if (amountToMarketplace > 0) {\n            bid.loanDetails.lendingToken.safeTransferFrom(\n                sender,\n                marketRegistry.getMarketFeeRecipient(bid.marketplaceId),\n                amountToMarketplace\n            );\n        }\n\n        //transfer funds to borrower\n        if (amountToBorrower > 0) {\n            bid.loanDetails.lendingToken.safeTransferFrom(\n                sender,\n                bid.receiver,\n                amountToBorrower\n            );\n        }\n\n        // Record volume filled by lenders\n        lenderVolumeFilled[address(bid.loanDetails.lendingToken)][sender] += bid\n            .loanDetails\n            .principal;\n        totalVolumeFilled[address(bid.loanDetails.lendingToken)] += bid\n            .loanDetails\n            .principal;\n\n        // Add borrower's active bid\n        _borrowerBidsActive[bid.borrower].add(_bidId);\n\n        // Emit AcceptedBid\n        emit AcceptedBid(_bidId, sender);\n\n        emit FeePaid(_bidId, \"protocol\", amountToProtocol);\n        emit FeePaid(_bidId, \"marketplace\", amountToMarketplace);\n    }\n\n    function claimLoanNFT(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"claimLoanNFT\")\n        whenNotPaused\n    {\n        // Retrieve bid\n        Bid storage bid = bids[_bidId];\n\n        address sender = _msgSenderForMarket(bid.marketplaceId);\n        require(sender == bid.lender, \"only lender can claim NFT\");\n\n        // set lender address to the lender manager so we know to check the owner of the NFT for the true lender\n        bid.lender = address(USING_LENDER_MANAGER);\n\n        // mint an NFT with the lender manager\n        lenderManager.registerLoan(_bidId, sender);\n    }\n\n    /**\n     * @notice Function for users to make the minimum amount due for an active loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function repayLoanMinimum(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        (\n            uint256 owedPrincipal,\n            uint256 duePrincipal,\n            uint256 interest\n        ) = V2Calculations.calculateAmountOwed(\n                bids[_bidId],\n                block.timestamp,\n                _getBidPaymentCycleType(_bidId),\n                _getBidPaymentCycleDuration(_bidId)\n            );\n        _repayLoan(\n            _bidId,\n            Payment({ principal: duePrincipal, interest: interest }),\n            owedPrincipal + interest,\n            true\n        );\n    }\n\n    /**\n     * @notice Function for users to repay an active loan in full.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function repayLoanFull(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        _repayLoanFull(_bidId, true);\n    }\n\n    // function that the borrower (ideally) sends to repay the loan\n    /**\n     * @notice Function for users to make a payment towards an active loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     * @param _amount The amount of the payment.\n     */\n    function repayLoan(uint256 _bidId, uint256 _amount)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        _repayLoanAtleastMinimum(_bidId, _amount, true);\n    }\n\n    /**\n     * @notice Function for users to repay an active loan in full.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function repayLoanFullWithoutCollateralWithdraw(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        _repayLoanFull(_bidId, false);\n    }\n\n    function repayLoanWithoutCollateralWithdraw(uint256 _bidId, uint256 _amount)\n        external\n        acceptedLoan(_bidId, \"repayLoan\")\n    {\n        _repayLoanAtleastMinimum(_bidId, _amount, false);\n    }\n\n    function _repayLoanFull(uint256 _bidId, bool withdrawCollateral) internal {\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(\n                bids[_bidId],\n                block.timestamp,\n                _getBidPaymentCycleType(_bidId),\n                _getBidPaymentCycleDuration(_bidId)\n            );\n        _repayLoan(\n            _bidId,\n            Payment({ principal: owedPrincipal, interest: interest }),\n            owedPrincipal + interest,\n            withdrawCollateral\n        );\n    }\n\n    function _repayLoanAtleastMinimum(\n        uint256 _bidId,\n        uint256 _amount,\n        bool withdrawCollateral\n    ) internal {\n        (\n            uint256 owedPrincipal,\n            uint256 duePrincipal,\n            uint256 interest\n        ) = V2Calculations.calculateAmountOwed(\n                bids[_bidId],\n                block.timestamp,\n                _getBidPaymentCycleType(_bidId),\n                _getBidPaymentCycleDuration(_bidId)\n            );\n        uint256 minimumOwed = duePrincipal + interest;\n\n        // If amount is less than minimumOwed, we revert\n        if (_amount < minimumOwed) {\n            revert PaymentNotMinimum(_bidId, _amount, minimumOwed);\n        }\n\n        _repayLoan(\n            _bidId,\n            Payment({ principal: _amount - interest, interest: interest }),\n            owedPrincipal + interest,\n            withdrawCollateral\n        );\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol implement an emergency stop mechanism.\n     */\n    function pauseProtocol() public virtual onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @notice Lets the DAO/owner of the protocol undo a previously implemented emergency stop.\n     */\n    function unpauseProtocol() public virtual onlyOwner whenPaused {\n        _unpause();\n    }\n\n    function lenderCloseLoan(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"lenderClaimCollateral\")\n    {\n        Bid storage bid = bids[_bidId];\n        address _collateralRecipient = bid.lender;\n\n        _lenderCloseLoanWithRecipient(_bidId, _collateralRecipient);\n    }\n\n    /**\n     * @notice Function for lender to claim collateral for a defaulted loan. The only purpose of a CLOSED loan is to make collateral claimable by lender.\n     * @param _bidId The id of the loan to set to CLOSED status.\n     */\n    function lenderCloseLoanWithRecipient(\n        uint256 _bidId,\n        address _collateralRecipient\n    ) external {\n        _lenderCloseLoanWithRecipient(_bidId, _collateralRecipient);\n    }\n\n    function _lenderCloseLoanWithRecipient(\n        uint256 _bidId,\n        address _collateralRecipient\n    ) internal acceptedLoan(_bidId, \"lenderClaimCollateral\") {\n        require(isLoanDefaulted(_bidId), \"Loan must be defaulted.\");\n\n        Bid storage bid = bids[_bidId];\n        bid.state = BidState.CLOSED;\n\n        address sender = _msgSenderForMarket(bid.marketplaceId);\n        require(sender == bid.lender, \"only lender can close loan\");\n\n        /*\n\n\n          address collateralManagerForBid = address(_getCollateralManagerForBid(_bidId)); \n\n          if( collateralManagerForBid == address(collateralManagerV2) ){\n             ICollateralManagerV2(collateralManagerForBid).lenderClaimCollateral(_bidId,_collateralRecipient);\n          }else{\n             require( _collateralRecipient == address(bid.lender));\n             ICollateralManager(collateralManagerForBid).lenderClaimCollateral(_bidId );\n          }\n          \n          */\n\n        collateralManager.lenderClaimCollateral(_bidId);\n\n        emit LoanClosed(_bidId);\n    }\n\n    /**\n     * @notice Function for users to liquidate a defaulted loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function liquidateLoanFull(uint256 _bidId)\n        external\n        acceptedLoan(_bidId, \"liquidateLoan\")\n    {\n        Bid storage bid = bids[_bidId];\n\n        // If loan is backed by collateral, withdraw and send to the liquidator\n        address recipient = _msgSenderForMarket(bid.marketplaceId);\n\n        _liquidateLoanFull(_bidId, recipient);\n    }\n\n    function liquidateLoanFullWithRecipient(uint256 _bidId, address _recipient)\n        external\n        acceptedLoan(_bidId, \"liquidateLoan\")\n    {\n        _liquidateLoanFull(_bidId, _recipient);\n    }\n\n    /**\n     * @notice Function for users to liquidate a defaulted loan.\n     * @param _bidId The id of the loan to make the payment towards.\n     */\n    function _liquidateLoanFull(uint256 _bidId, address _recipient)\n        internal\n        acceptedLoan(_bidId, \"liquidateLoan\")\n    {\n        require(isLoanLiquidateable(_bidId), \"Loan must be liquidateable.\");\n\n        Bid storage bid = bids[_bidId];\n\n        // change state here to prevent re-entrancy\n        bid.state = BidState.LIQUIDATED;\n\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(\n                bid,\n                block.timestamp,\n                _getBidPaymentCycleType(_bidId),\n                _getBidPaymentCycleDuration(_bidId)\n            );\n\n        //this sets the state to 'repaid'\n        _repayLoan(\n            _bidId,\n            Payment({ principal: owedPrincipal, interest: interest }),\n            owedPrincipal + interest,\n            false\n        );\n\n        /*\n         _getCollateralManagerForBid(_bidId).liquidateCollateral(\n            _bidId,\n            _recipient\n        ); \n      */\n\n        collateralManager.liquidateCollateral(_bidId, _recipient);\n\n        address liquidator = _msgSenderForMarket(bid.marketplaceId);\n\n        emit LoanLiquidated(_bidId, liquidator);\n    }\n\n    /**\n     * @notice Internal function to make a loan payment.\n     * @dev Updates the bid's `status` to `PAID` only if it is not already marked as `LIQUIDATED`\n     * @param _bidId The id of the loan to make the payment towards.\n     * @param _payment The Payment struct with payments amounts towards principal and interest respectively.\n     * @param _owedAmount The total amount owed on the loan.\n     */\n    function _repayLoan(\n        uint256 _bidId,\n        Payment memory _payment,\n        uint256 _owedAmount,\n        bool _shouldWithdrawCollateral\n    ) internal virtual {\n        Bid storage bid = bids[_bidId];\n        uint256 paymentAmount = _payment.principal + _payment.interest;\n\n        RepMark mark = reputationManager.updateAccountReputation(\n            bid.borrower,\n            _bidId\n        );\n\n        // Check if we are sending a payment or amount remaining\n        if (paymentAmount >= _owedAmount) {\n            paymentAmount = _owedAmount;\n\n            if (bid.state != BidState.LIQUIDATED) {\n                bid.state = BidState.PAID;\n            }\n\n            // Remove borrower's active bid\n            _borrowerBidsActive[bid.borrower].remove(_bidId);\n\n            // If loan is is being liquidated and backed by collateral, withdraw and send to borrower\n            if (_shouldWithdrawCollateral) {\n                //   _getCollateralManagerForBid(_bidId).withdraw(_bidId);\n                collateralManager.withdraw(_bidId);\n            }\n\n            emit LoanRepaid(_bidId);\n        } else {\n            emit LoanRepayment(_bidId);\n        }\n\n        _sendOrEscrowFunds(_bidId, _payment); //send or escrow the funds\n\n        // update our mappings\n        bid.loanDetails.totalRepaid.principal += _payment.principal;\n        bid.loanDetails.totalRepaid.interest += _payment.interest;\n        bid.loanDetails.lastRepaidTimestamp = uint32(block.timestamp);\n\n        // If the loan is paid in full and has a mark, we should update the current reputation\n        if (mark != RepMark.Good) {\n            reputationManager.updateAccountReputation(bid.borrower, _bidId);\n        }\n    }\n\n\n    function _sendOrEscrowFunds(uint256 _bidId, Payment memory _payment)\n        internal\n    {\n        Bid storage bid = bids[_bidId];\n        address lender = getLoanLender(_bidId);\n\n        uint256 _paymentAmount = _payment.principal + _payment.interest;\n\n        try \n\n            bid.loanDetails.lendingToken.transferFrom{ gas: 100000 }(\n                _msgSenderForMarket(bid.marketplaceId),\n                lender,\n                _paymentAmount\n            )\n        {} catch {\n            address sender = _msgSenderForMarket(bid.marketplaceId);\n\n            uint256 balanceBefore = bid.loanDetails.lendingToken.balanceOf(\n                address(this)\n            ); \n\n            //if unable, pay to escrow\n            bid.loanDetails.lendingToken.safeTransferFrom(\n                sender,\n                address(this),\n                _paymentAmount\n            );\n\n            uint256 balanceAfter = bid.loanDetails.lendingToken.balanceOf(\n                address(this)\n            );\n\n            //used for fee-on-send tokens\n            uint256 paymentAmountReceived = balanceAfter - balanceBefore;\n\n            bid.loanDetails.lendingToken.approve(\n                address(escrowVault),\n                paymentAmountReceived\n            );\n\n            IEscrowVault(escrowVault).deposit(\n                lender,\n                address(bid.loanDetails.lendingToken),\n                paymentAmountReceived\n            );\n        }\n\n        address loanRepaymentListener = repaymentListenerForBid[_bidId];\n\n        if (loanRepaymentListener != address(0)) {\n            try\n                ILoanRepaymentListener(loanRepaymentListener).repayLoanCallback{\n                    gas: 80000\n                }( //limit gas costs to prevent lender griefing repayments\n                    _bidId,\n                    _msgSenderForMarket(bid.marketplaceId),\n                    _payment.principal,\n                    _payment.interest\n                )\n            {} catch {}\n        }\n    }\n\n\n\n\n    /**\n     * @notice Calculates the total amount owed for a loan bid at a specific timestamp.\n     * @param _bidId The id of the loan bid to calculate the owed amount for.\n     * @param _timestamp The timestamp at which to calculate the loan owed amount at.\n     */\n    function calculateAmountOwed(uint256 _bidId, uint256 _timestamp)\n        public\n        view\n        returns (Payment memory owed)\n    {\n        Bid storage bid = bids[_bidId];\n        if (\n            bid.state != BidState.ACCEPTED ||\n            bid.loanDetails.acceptedTimestamp >= _timestamp\n        ) return owed;\n\n        (uint256 owedPrincipal, , uint256 interest) = V2Calculations\n            .calculateAmountOwed(\n                bid,\n                _timestamp,\n                _getBidPaymentCycleType(_bidId),\n                _getBidPaymentCycleDuration(_bidId)\n            );\n\n        owed.principal = owedPrincipal;\n        owed.interest = interest;\n    }\n\n    /**\n     * @notice Calculates the minimum payment amount due"
    }
  ]
}