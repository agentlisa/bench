{
  "Title": "[N-08] Move IF/validation statements to the top of the function when validating input parameters",
  "Content": "\nFILE : 2023-03-canto-identity/canto-pfp-protocol/src/ProfilePicture.sol\n\n\n     function mint(address _nftContract, uint256 _nftID) external {\n        uint256 tokenId = ++numMinted;\n        if (ERC721(_nftContract).ownerOf(_nftID) != msg.sender)\n            revert PFPNotOwnedByCaller(msg.sender, _nftContract, _nftID);\n        ProfilePictureData storage pictureData = pfp[tokenId];\n        pictureData.nftContract = _nftContract;\n\n[ProfilePicture.sol#L79-L88](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-pfp-protocol/src/ProfilePicture.sol#L79-L88)\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-03-canto-identity",
  "Code": [
    {
      "filename": "canto-pfp-protocol/src/ProfilePicture.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport \"../interface/Turnstile.sol\";\nimport \"../interface/ICidNFT.sol\";\n\ncontract ProfilePicture is ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Reference to the CID NFT\n    ICidNFT private immutable cidNFT;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Data that is stored per PFP\n    struct ProfilePictureData {\n        /// @notice Reference to the NFT contract\n        address nftContract;\n        /// @notice Referenced nft ID\n        uint256 nftID;\n    }\n\n    /// @notice Number of tokens minted\n    uint256 public numMinted;\n\n    /// @notice Stores the pfp data per NFT\n    mapping(uint256 => ProfilePictureData) private pfp;\n\n    /// @notice Name with which the subprotocol is registered\n    string public subprotocolName;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event PfpAdded(\n        address indexed minter,\n        uint256 indexed pfpNftID,\n        address indexed referencedContract,\n        uint256 referencedNftId\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error PFPNoLongerOwnedByOriginalOwner(uint256 tokenID);\n    error PFPNotOwnedByCaller(address caller, address nftContract, uint256 nftID);\n\n    /// @notice Initiates CSR on mainnet\n    /// @param _cidNFT Address of the CID NFT\n    /// @param _subprotocolName Name with which the subprotocol is / will be registered in the registry. Registration will not be performed automatically\n    constructor(address _cidNFT, string memory _subprotocolName) ERC721(\"Profile Picture\", \"PFP\") {\n        cidNFT = ICidNFT(_cidNFT);\n        subprotocolName = _subprotocolName;\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @param _id ID to query for\n    /// @dev Reverts if PFP is no longer owned by owner of associated CID NFT\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        (address nftContract, uint256 nftID) = getPFP(_id);\n        if (nftContract == address(0)) revert PFPNoLongerOwnedByOriginalOwner(_id);\n        return ERC721(nftContract).tokenURI(nftID);\n    }\n\n    /// @notice Mint a new PFP NFT\n    /// @param _nftContract The nft contract address to reference\n    /// @param _nftID The nft ID to reference\n    function mint(address _nftContract, uint256 _nftID) external {\n        uint256 tokenId = ++numMinted;\n        if (ERC721(_nftContract).ownerOf(_nftID) != msg.sender)\n            revert PFPNotOwnedByCaller(msg.sender, _nftContract, _nftID);\n        ProfilePictureData storage pictureData = pfp[tokenId];\n        pictureData.nftContract = _nftContract;\n        pictureData.nftID = _nftID;\n        _mint(msg.sender, tokenId);\n        emit PfpAdded(msg.sender, tokenId, _nftContract, _nftID);\n    }\n\n    /// @notice Query the referenced profile picture\n    /// @dev Checks if the PFP is still owned by the owner of the CID NFT\n    /// @param _pfpID Profile picture NFT ID to query\n    /// @return nftContract The referenced NFT contract (address(0) if no longer owned), nftID The referenced NFT ID\n    function getPFP(uint256 _pfpID) public view returns (address nftContract, uint256 nftID) {\n        if (_ownerOf[_pfpID] == address(0)) revert TokenNotMinted(_pfpID);\n        ProfilePictureData storage pictureData = pfp[_pfpID];\n        nftContract = pictureData.nftContract;\n        nftID = pictureData.nftID;\n        uint256 cidNFTID = cidNFT.getPrimaryCIDNFT(subprotocolName, _pfpID);\n        IAddressRegistry addressRegistry = cidNFT.addressRegistry();\n        if (cidNFTID == 0 || addressRegistry.getAddress(cidNFTID) != ERC721(nftContract).ownerOf(nftID)) {\n            nftContract = address(0);\n            nftID = 0; // Strictly not needed because nftContract has to be always checked, but reset nevertheless to 0\n        }\n    }\n}"
    }
  ]
}