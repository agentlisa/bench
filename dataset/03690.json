{
  "Title": "[L06] Not handling approve return value",
  "Content": "As defined in the [ERC20 Specification](https://eips.ethereum.org/EIPS/eip-20), the `approve` function returns a `bool` that signals the success of the call. However, throughout the codebase, the value returned from calls to `approve` is ignored. Examples of this are:\n\n\n* [Line 29 of `WStakingRewards`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/wrapper/WStakingRewards.sol#L29)\n* [Line 63 of `WMasterChef`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/wrapper/WMasterChef.sol#L63)\n\n\nIn other places in the codebase, calls to `approve` are within a `require` statement which does handle the boolean return. Examples of this are:\n\n\n* [Lines 90-92 of `IbETHRouterV2`](https://github.com/AlphaFinanceLab/homora-v2/blob/5efa332f2ecf8e9705c326cffda5305bc6f752f7/contracts/IbETHRouterV2.sol#L90-L92) (this contract is out of scope).\n\n\nTo handle calls to `approve` safely, even when interacting with ERC20 implementations that, incorrectly, *do not* return a boolean, consider using the [`safeApprove` function in OpenZeppelinâ€™s SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cec0800c541c809f883a37f2dfb91ec4c90263c5/contracts/token/ERC20/SafeERC20.sol#L36) contract for all approvals.\n\n\n***Update:** Fixed in [PR#101](https://github.com/AlphaFinanceLab/homora-v2/pull/101).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/wrapper/WStakingRewards.sol",
      "content": "pragma solidity 0.6.12;\n\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/ERC1155.sol';\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/SafeERC20.sol';\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/utils/ReentrancyGuard.sol';\n\nimport '../utils/HomoraMath.sol';\nimport '../../interfaces/IERC20Wrapper.sol';\nimport '../../interfaces/IStakingRewards.sol';\n\ncontract WStakingRewards is ERC1155('WStakingRewards'), ReentrancyGuard, IERC20Wrapper {\n  using SafeMath for uint;\n  using HomoraMath for uint;\n  using SafeERC20 for IERC20;\n\n  address public immutable staking; // Staking reward contract address\n  address public immutable underlying; // Underlying token address\n  address public immutable reward; // Reward token address\n\n  constructor(\n    address _staking,\n    address _underlying,\n    address _reward\n  ) public {\n    staking = _staking;\n    underlying = _underlying;\n    reward = _reward;\n    IERC20(_underlying).approve(_staking, uint(-1));\n  }\n\n  /// @dev Return the underlying ERC20 for the given ERC1155 token id.\n  function getUnderlyingToken(uint) external view override returns (address) {\n    return underlying;\n  }\n\n  /// @dev Return the conversion rate from ERC1155 to ERC20, multiplied 2**112.\n  function getUnderlyingRate(uint) external view override returns (uint) {\n    return 2**112;\n  }\n\n  /// @dev Mint ERC1155 token for the specified amount\n  /// @param amount Token amount to wrap\n  function mint(uint amount) external nonReentrant returns (uint) {\n    IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);\n    IStakingRewards(staking).stake(amount);\n    uint rewardPerToken = IStakingRewards(staking).rewardPerToken();\n    _mint(msg.sender, rewardPerToken, amount, '');\n    return rewardPerToken;\n  }\n\n  /// @dev Burn ERC1155 token to redeem ERC20 token back.\n  /// @param id Token id to burn\n  /// @param amount Token amount to burn\n  function burn(uint id, uint amount) external nonReentrant returns (uint) {\n    if (amount == uint(-1)) {\n      amount = balanceOf(msg.sender, id);\n    }\n    _burn(msg.sender, id, amount);\n    IStakingRewards(staking).withdraw(amount);\n    IStakingRewards(staking).getReward();\n    IERC20(underlying).safeTransfer(msg.sender, amount);\n    uint stRewardPerToken = id;\n    uint enRewardPerToken = IStakingRewards(staking).rewardPerToken();\n    uint stReward = stRewardPerToken.mul(amount).divCeil(1e18);\n    uint enReward = enRewardPerToken.mul(amount).div(1e18);\n    if (enReward > stReward) {\n      IERC20(reward).safeTransfer(msg.sender, enReward.sub(stReward));\n    }\n    return enRewardPerToken;\n  }\n}"
    },
    {
      "filename": "contracts/wrapper/WMasterChef.sol",
      "content": "pragma solidity 0.6.12;\n\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC1155/ERC1155.sol';\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/SafeERC20.sol';\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/utils/ReentrancyGuard.sol';\n\nimport '../utils/HomoraMath.sol';\nimport '../../interfaces/IERC20Wrapper.sol';\nimport '../../interfaces/IMasterChef.sol';\n\ncontract WMasterChef is ERC1155('WMasterChef'), ReentrancyGuard, IERC20Wrapper {\n  using SafeMath for uint;\n  using HomoraMath for uint;\n  using SafeERC20 for IERC20;\n\n  IMasterChef public immutable chef; // Sushiswap masterChef\n  IERC20 public immutable sushi; // Sushi token\n\n  constructor(IMasterChef _chef) public {\n    chef = _chef;\n    sushi = IERC20(_chef.sushi());\n  }\n\n  /// @dev Encode pid, sushiPerShare to ERC1155 token id\n  /// @param pid Pool id (16-bit)\n  /// @param sushiPerShare Sushi amount per share, multiplied by 1e18 (240-bit)\n  function encodeId(uint pid, uint sushiPerShare) public pure returns (uint id) {\n    require(pid < (1 << 16), 'bad pid');\n    require(sushiPerShare < (1 << 240), 'bad sushi per share');\n    return (pid << 240) | sushiPerShare;\n  }\n\n  /// @dev Decode ERC1155 token id to pid, sushiPerShare\n  /// @param id Token id\n  function decodeId(uint id) public pure returns (uint pid, uint sushiPerShare) {\n    pid = id >> 240; // First 16 bits\n    sushiPerShare = id & ((1 << 240) - 1); // Last 240 bits\n  }\n\n  /// @dev Return the underlying ERC-20 for the given ERC-1155 token id.\n  /// @param id Token id\n  function getUnderlyingToken(uint id) external view override returns (address) {\n    (uint pid, ) = decodeId(id);\n    (address lpToken, , , ) = chef.poolInfo(pid);\n    return lpToken;\n  }\n\n  /// @dev Return the conversion rate from ERC-1155 to ERC-20, multiplied by 2**112.\n  function getUnderlyingRate(uint) external view override returns (uint) {\n    return 2**112;\n  }\n\n  /// @dev Mint ERC1155 token for the given pool id.\n  /// @param pid Pool id\n  /// @param amount Token amount to wrap\n  /// @return The token id that got minted.\n  function mint(uint pid, uint amount) external nonReentrant returns (uint) {\n    (address lpToken, , , ) = chef.poolInfo(pid);\n    IERC20(lpToken).safeTransferFrom(msg.sender, address(this), amount);\n    if (IERC20(lpToken).allowance(address(this), address(chef)) != uint(-1)) {\n      // We only need to do this once per pool, as LP token's allowance won't decrease if it's -1.\n      IERC20(lpToken).approve(address(chef), uint(-1));\n    }\n    chef.deposit(pid, amount);\n    (, , , uint sushiPerShare) = chef.poolInfo(pid);\n    uint id = encodeId(pid, sushiPerShare);\n    _mint(msg.sender, id, amount, '');\n    return id;\n  }\n\n  /// @dev Burn ERC1155 token to redeem LP ERC20 token back plus SUSHI rewards.\n  /// @param id Token id\n  /// @param amount Token amount to burn\n  /// @return The pool id that that you received LP token back.\n  function burn(uint id, uint amount) external nonReentrant returns (uint) {\n    if (amount == uint(-1)) {\n      amount = balanceOf(msg.sender, id);\n    }\n    (uint pid, uint stSushiPerShare) = decodeId(id);\n    _burn(msg.sender, id, amount);\n    chef.withdraw(pid, amount);\n    (address lpToken, , , uint enSushiPerShare) = chef.poolInfo(pid);\n    IERC20(lpToken).safeTransfer(msg.sender, amount);\n    uint stSushi = stSushiPerShare.mul(amount).divCeil(1e12);\n    uint enSushi = enSushiPerShare.mul(amount).div(1e12);\n    if (enSushi > stSushi) {\n      sushi.safeTransfer(msg.sender, enSushi.sub(stSushi));\n    }\n    return pid;\n  }\n\n  /// @dev Burn ERC1155 token to redeem LP ERC20 token back without taking SUSHI rewards.\n  /// @param id Token id\n  /// @param amount Token amount to emergency burn\n  /// @return The pool id that that you received LP token back.\n  function emergencyBurn(uint id, uint amount) external nonReentrant returns (uint) {\n    (uint pid, ) = decodeId(id);\n    _burn(msg.sender, id, amount);\n    chef.withdraw(pid, amount);\n    (address lpToken, , , ) = chef.poolInfo(pid);\n    IERC20(lpToken).safeTransfer(msg.sender, amount);\n    return pid;\n  }\n}"
    },
    {
      "filename": "contracts/IbETHRouterV2.sol",
      "content": "pragma solidity 0.6.12;\n\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/math/SafeMath.sol';\nimport 'OpenZeppelin/openzeppelin-contracts@3.2.0/contracts/token/ERC20/IERC20.sol';\nimport './utils/HomoraMath.sol';\n\ninterface IbETHRouterV2IbETHv2 is IERC20 {\n  function deposit() external payable;\n\n  function withdraw(uint amount) external;\n}\n\ninterface IbETHRouterV2UniswapPair is IERC20 {\n  function token0() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint,\n      uint,\n      uint\n    );\n}\n\ninterface IbETHRouterV2UniswapRouter {\n  function factory() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  )\n    external\n    returns (\n      uint amountA,\n      uint amountB,\n      uint liquidity\n    );\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountA, uint amountB);\n\n  function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n}\n\ninterface IbETHRouterV2UniswapFactory {\n  function getPair(address tokenA, address tokenB) external view returns (address);\n}\n\ncontract IbETHRouterV2 {\n  using SafeMath for uint;\n\n  IERC20 public immutable alpha;\n  IbETHRouterV2IbETHv2 public immutable ibETHv2;\n  IbETHRouterV2UniswapPair public immutable lpToken;\n  IbETHRouterV2UniswapRouter public immutable router;\n\n  constructor(\n    IERC20 _alpha,\n    IbETHRouterV2IbETHv2 _ibETHv2,\n    IbETHRouterV2UniswapRouter _router\n  ) public {\n    IbETHRouterV2UniswapPair _lpToken =\n      IbETHRouterV2UniswapPair(\n        IbETHRouterV2UniswapFactory(_router.factory()).getPair(address(_alpha), address(_ibETHv2))\n      );\n    alpha = _alpha;\n    ibETHv2 = _ibETHv2;\n    lpToken = _lpToken;\n    router = _router;\n    require(_alpha.approve(address(_router), uint(-1)));\n    require(_ibETHv2.approve(address(_router), uint(-1)));\n    require(_lpToken.approve(address(_router), uint(-1)));\n  }\n\n  function optimalDeposit(\n    uint amtA,\n    uint amtB,\n    uint resA,\n    uint resB\n  ) internal pure returns (uint swapAmt, bool isReversed) {\n    if (amtA.mul(resB) >= amtB.mul(resA)) {\n      swapAmt = _optimalDepositA(amtA, amtB, resA, resB);\n      isReversed = false;\n    } else {\n      swapAmt = _optimalDepositA(amtB, amtA, resB, resA);\n      isReversed = true;\n    }\n  }\n\n  function _optimalDepositA(\n    uint amtA,\n    uint amtB,\n    uint resA,\n    uint resB\n  ) internal pure returns (uint) {\n    require(amtA.mul(resB) >= amtB.mul(resA), 'Reversed');\n    uint a = 997;\n    uint b = uint(1997).mul(resA);\n    uint _c = (amtA.mul(resB)).sub(amtB.mul(resA));\n    uint c = _c.mul(1000).div(amtB.add(resB)).mul(resA);\n    uint d = a.mul(c).mul(4);\n    uint e = HomoraMath.sqrt(b.mul(b).add(d));\n    uint numerator = e.sub(b);\n    uint denominator = a.mul(2);\n    return numerator.div(denominator);\n  }\n\n  function swapExactETHToAlpha(\n    uint amountOutMin,\n    address to,\n    uint deadline\n  ) external payable {\n    ibETHv2.deposit{value: msg.value}();\n    address[] memory path = new address[](2);\n    path[0] = address(ibETHv2);\n    path[1] = address(alpha);\n    router.swapExactTokensForTokens(\n      ibETHv2.balanceOf(address(this)),\n      amountOutMin,\n      path,\n      to,\n      deadline\n    );\n  }\n\n  function swapExactAlphaToETH(\n    uint amountIn,\n    uint amountOutMin,\n    address to,\n    uint deadline\n  ) external {\n    alpha.transferFrom(msg.sender, address(this), amountIn);\n    address[] memory path = new address[](2);\n    path[0] = address(alpha);\n    path[1] = address(ibETHv2);\n    router.swapExactTokensForTokens(amountIn, 0, path, address(this), deadline);\n    ibETHv2.withdraw(ibETHv2.balanceOf(address(this)));\n    uint ethBalance = address(this).balance;\n    require(ethBalance >= amountOutMin, '!amountOutMin');\n    (bool success, ) = to.call{value: ethBalance}(new bytes(0));\n    require(success, '!eth');\n  }\n\n  function addLiquidityETHAlphaOptimal(\n    uint amountAlpha,\n    uint minLp,\n    address to,\n    uint deadline\n  ) external payable {\n    if (amountAlpha > 0) alpha.transferFrom(msg.sender, address(this), amountAlpha);\n    ibETHv2.deposit{value: msg.value}();\n    uint amountIbETHv2 = ibETHv2.balanceOf(address(this));\n    uint swapAmt;\n    bool isReversed;\n    {\n      (uint r0, uint r1, ) = lpToken.getReserves();\n      (uint ibETHv2Reserve, uint alphaReserve) =\n        lpToken.token0() == address(ibETHv2) ? (r0, r1) : (r1, r0);\n      (swapAmt, isReversed) = optimalDeposit(\n        amountIbETHv2,\n        amountAlpha,\n        ibETHv2Reserve,\n        alphaReserve\n      );\n    }\n    if (swapAmt > 0) {\n      address[] memory path = new address[](2);\n      (path[0], path[1]) = isReversed\n        ? (address(alpha), address(ibETHv2))\n        : (address(ibETHv2), address(alpha));\n      router.swapExactTokensForTokens(swapAmt, 0, path, address(this), deadline);\n    }\n    (, , uint liquidity) =\n      router.addLiquidity(\n        address(alpha),\n        address(ibETHv2),\n        alpha.balanceOf(address(this)),\n        ibETHv2.balanceOf(address(this)),\n        0,\n        0,\n        to,\n        deadline\n      );\n    require(liquidity >= minLp, '!minLP');\n  }\n\n  function addLiquidityIbETHv2AlphaOptimal(\n    uint amountIbETHv2,\n    uint amountAlpha,\n    uint minLp,\n    address to,\n    uint deadline\n  ) external {\n    if (amountAlpha > 0) alpha.transferFrom(msg.sender, address(this), amountAlpha);\n    if (amountIbETHv2 > 0) ibETHv2.transferFrom(msg.sender, address(this), amountIbETHv2);\n    uint swapAmt;\n    bool isReversed;\n    {\n      (uint r0, uint r1, ) = lpToken.getReserves();\n      (uint ibETHv2Reserve, uint alphaReserve) =\n        lpToken.token0() == address(ibETHv2) ? (r0, r1) : (r1, r0);\n      (swapAmt, isReversed) = optimalDeposit(\n        amountIbETHv2,\n        amountAlpha,\n        ibETHv2Reserve,\n        alphaReserve\n      );\n    }\n    if (swapAmt > 0) {\n      address[] memory path = new address[](2);\n      (path[0], path[1]) = isReversed\n        ? (address(alpha), address(ibETHv2))\n        : (address(ibETHv2), address(alpha));\n      router.swapExactTokensForTokens(swapAmt, 0, path, address(this), deadline);\n    }\n    (, , uint liquidity) =\n      router.addLiquidity(\n        address(alpha),\n        address(ibETHv2),\n        alpha.balanceOf(address(this)),\n        ibETHv2.balanceOf(address(this)),\n        0,\n        0,\n        to,\n        deadline\n      );\n    require(liquidity >= minLp, '!minLP');\n  }\n\n  function removeLiquidityETHAlpha(\n    uint liquidity,\n    uint minETH,\n    uint minAlpha,\n    address to,\n    uint deadline\n  ) external {\n    lpToken.transferFrom(msg.sender, address(this), liquidity);\n    router.removeLiquidity(\n      address(alpha),\n      address(ibETHv2),\n      liquidity,\n      minAlpha,\n      0,\n      address(this),\n      deadline\n    );\n    alpha.transfer(msg.sender, alpha.balanceOf(address(this)));\n    ibETHv2.withdraw(ibETHv2.balanceOf(address(this)));\n    uint ethBalance = address(this).balance;\n    require(ethBalance >= minETH, '!minETH');\n    (bool success, ) = to.call{value: ethBalance}(new bytes(0));\n    require(success, '!eth');\n  }\n\n  function removeLiquidityAlphaOnly(\n    uint liquidity,\n    uint minAlpha,\n    address to,\n    uint deadline\n  ) external {\n    lpToken.transferFrom(msg.sender, address(this), liquidity);\n    router.removeLiquidity(\n      address(alpha),\n      address(ibETHv2),\n      liquidity,\n      0,\n      0,\n      address(this),\n      deadline\n    );\n    address[] memory path = new address[](2);\n    path[0] = address(ibETHv2);\n    path[1] = address(alpha);\n    router.swapExactTokensForTokens(\n      ibETHv2.balanceOf(address(this)),\n      0,\n      path,\n      address(this),\n      deadline\n    );\n    uint alphaBalance = alpha.balanceOf(address(this));\n    require(alphaBalance >= minAlpha, '!minAlpha');\n    alpha.transfer(to, alphaBalance);\n  }\n\n  receive() external payable {\n    require(msg.sender == address(ibETHv2), '!ibETHv2');\n  }\n}"
    },
    {
      "filename": "contracts/token/ERC20/SafeERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"
    }
  ]
}