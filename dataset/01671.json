{
  "Title": "Users Can Be Locked From Voting",
  "Content": "In the `VoterV3` contract, users [vote](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L410-L416) in order to receive rewards from `gauges`. During each epoch, rewards are reset and users need to vote again, either by calling the [`poke`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L390-L403) or [`vote`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L410-L416) functions. If a user does not vote in an epoch, they will not receive rewards. Votes do not roll over from epoch to epoch.\n\n\nThrough each method of voting, the [`_reset` function](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L352-L378) is first called, clearing out the `tokenId`'s previous vote allocation to the gauges. During this reset, internal and external bribes from the votes are cleared [by calling the `withdraw` function of the `Bribes` contract](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L371-L372).\n\n\nHowever, if a gauge is destroyed via the [`killGaugeTotally` function](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L316-L332), these [internal and external `Bribes` addresses will be cleared](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L320-L321) while leaving the [`poolVote` mapping populated](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L353) with votes for pools that are linked to non-existent gauges. This results in the `withdraw` calls reverting for any voter escrow token that contains uncleared votes for a gauge killed with `killGaugeTotally`.\n\n\nInterestingly, these calls should fail during the [`gauges[_pool]` lookup](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L371) in the `_withdraw` execution, as that is [supposed to be cleared](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L327-L328) during `killGaugeTotally` call, but due to [another bug](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L322), this will return the killed gauge's address.\n\n\nSimilarly, this should be able to be remedied by creating a new gauge for the pool, but in the [`_createGauge` function, there is a requirement for the `gauges` mapping to hold the zero address](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/VoterV3.sol#L556), which will not be the case due to the previously mentioned bug.\n\n\nIn order to avoid locking users out of voting, consider adding logic to avoid reverts during `_reset` calls to tokens which have outstanding votes to totally killed gauges.\n\n\n***Update:** Resolved in [pull request #3](https://github.com/ThenafiBNB/THENA-Contracts/pull/3) at commit [35c01c8](https://github.com/ThenafiBNB/THENA-Contracts/pull/3/commits/35c01c8709bb61cc893b79f9b425be2a353fcb6e). The `killGaugeTotally` function has been completely removed.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/VoterV3.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IBribeFactory.sol';\nimport './interfaces/IGauge.sol';\nimport './interfaces/IGaugeFactory.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IMinter.sol';\nimport './interfaces/IPairInfo.sol';\nimport './interfaces/IPairFactory.sol';\nimport './interfaces/IVoter.sol';\nimport './interfaces/IVotingEscrow.sol';\nimport './interfaces/IPermissionsRegistry.sol';\nimport './interfaces/IAlgebraFactory.sol';\nimport \"hardhat/console.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n\ninterface IHypervisor {\n    function pool() external view returns(address);\n}\n\ncontract VoterV3 is IVoter, OwnableUpgradeable, ReentrancyGuardUpgradeable {\n\n    \n    bool internal initflag;\n\n    address public _ve;                                         // the ve token that governs these contracts\n    address public factory;                                     // classic stable and volatile Pair Factory\n    address[] public factories;                                 // Array with all the pair factories\n    address internal base;                                      // $the token\n    address public gaugefactory;                                // gauge factory\n    address[] public gaugeFactories;                            // array with all the gauge factories\n    address public bribefactory;                                // bribe factory (internal and external)\n    address public minter;                                      // minter mints $the each epoch\n    address public permissionRegistry;                          // registry to check accesses\n    address[] public pools;                                     // all pools viable for incentives\n\n\n    uint internal index;                                        // gauge index\n    uint internal constant DURATION = 7 days;                   // rewards are released over 7 days\n    uint public VOTE_DELAY;                                     // delay between votes in seconds\n    uint public constant MAX_VOTE_DELAY = 7 days;               // Max vote delay allowed\n\n\n    mapping(address => uint) internal supplyIndex;              // gauge    => index\n    mapping(address => uint) public claimable;                  // gauge    => claimable $the\n    mapping(address => address) public gauges;                  // pool     => gauge\n    mapping(address => uint) public gaugesDistributionTimestmap;// gauge    => last Distribution Time\n    mapping(address => address) public poolForGauge;            // gauge    => pool\n    mapping(address => address) public internal_bribes;         // gauge    => internal bribe (only fees)\n    mapping(address => address) public external_bribes;         // gauge    => external bribe (real bribes)\n    mapping(uint => mapping(address => uint256)) public votes;  // nft      => pool     => votes\n    mapping(uint => address[]) public poolVote;                 // nft      => pools\n    mapping(uint => mapping(address => uint)) internal weightsPerEpoch; // timestamp => pool => weights\n    mapping(uint => uint) internal totWeightsPerEpoch;         // timestamp => total weights\n    mapping(uint => uint) public usedWeights;                   // nft      => total voting weight of user\n    mapping(uint => uint) public lastVoted;                     // nft      => timestamp of last vote\n    mapping(address => bool) public isGauge;                    // gauge    => boolean [is a gauge?]\n    mapping(address => bool) public isWhitelisted;              // token    => boolean [is an allowed token?]\n    mapping(address => bool) public isAlive;                    // gauge    => boolean [is the gauge alive?]\n    mapping(address => bool) public isFactory;                  // factory  => boolean [the pair factory exists?]\n    mapping(address => bool) public isGaugeFactory;             // g.factory=> boolean [the gauge factory exists?]\n\n    event GaugeCreated(address indexed gauge, address creator, address internal_bribe, address indexed external_bribe, address indexed pool);\n    event GaugeKilled(address indexed gauge);\n    event GaugeRevived(address indexed gauge);\n    event Voted(address indexed voter, uint tokenId, uint256 weight);\n    event Abstained(uint tokenId, uint256 weight);\n    event NotifyReward(address indexed sender, address indexed reward, uint amount);\n    event DistributeReward(address indexed sender, address indexed gauge, uint amount);\n    event Attach(address indexed owner, address indexed gauge, uint tokenId);\n    event Detach(address indexed owner, address indexed gauge, uint tokenId);\n    event Whitelisted(address indexed whitelister, address indexed token);\n    event Blacklisted(address indexed blacklister, address indexed token);\n\n    constructor() {}\n\n    function initialize(address __ve, address _factory, address  _gauges, address _bribes) initializer public {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        _ve = __ve;\n        base = IVotingEscrow(__ve).token();\n\n        factory = _factory;\n        factories.push(factory);\n        isFactory[factory] = true;\n\n        gaugefactory = _gauges;\n        gaugeFactories.push(_gauges);\n        isGaugeFactory[_gauges] = true;\n\n        bribefactory = _bribes;\n\n        minter = msg.sender;\n        permissionRegistry = msg.sender;\n\n        VOTE_DELAY = 0;\n        initflag = false;\n    }\n\n \n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    MODIFIERS\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    modifier VoterAdmin() {\n        require(IPermissionsRegistry(permissionRegistry).hasRole(\"VOTER_ADMIN\",msg.sender), 'ERR: VOTER_ADMIN');\n        _;\n    }\n\n    modifier Governance() {\n        require(IPermissionsRegistry(permissionRegistry).hasRole(\"GOVERNANCE\",msg.sender), 'ERR: GOVERNANCE');\n        _;\n    }\n\n    \n    /// @notice initialize the voter contract \n    /// @param  _tokens array of tokens to whitelist\n    /// @param  _minter the minter of $the\n    function _init(address[] memory _tokens, address _permissionsRegistry, address _minter) external {\n        require(msg.sender == minter || IPermissionsRegistry(permissionRegistry).hasRole(\"VOTER_ADMIN\",msg.sender));\n        require(!initflag);\n        for (uint i = 0; i < _tokens.length; i++) {\n            _whitelist(_tokens[i]);\n        }\n        minter = _minter;\n        permissionRegistry = _permissionsRegistry;\n        initflag = true;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    VoterAdmin\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice set vote delay in seconds\n    function setVoteDelay(uint _delay) external VoterAdmin {\n        require(_delay != VOTE_DELAY);\n        require(_delay <= MAX_VOTE_DELAY);\n        VOTE_DELAY = _delay;\n    }\n\n    /// @notice Set a new Minter\n    function setMinter(address _minter) external VoterAdmin {\n        require(_minter != address(0));\n        minter = _minter;\n    }\n\n    /// @notice Set a new Bribe Factory\n    function setBribeFactory(address _bribeFactory) external VoterAdmin {\n        bribefactory = _bribeFactory;\n    }\n\n    /// @notice Set a new Gauge Factory\n    function setGaugeFactory(address _gaugeFactory) external VoterAdmin {\n        gaugefactory = _gaugeFactory;\n    }\n\n    /// @notice Set a new Pair Factory\n    function setPairFactory(address _factory) external VoterAdmin {\n        factory = _factory;\n    }\n\n    /// @notice Set a new PermissionRegistry\n    function setPermissionsRegistry(address _permissionRegistry) external VoterAdmin {\n        permissionRegistry = _permissionRegistry;\n    }\n\n    /// @notice Set a new bribes for a given gauge\n    function setNewBribes(address _gauge, address _internal, address _external) external VoterAdmin {\n        require(isGauge[_gauge] == true);\n        _setInternalBribe(_gauge, _internal);\n        _setExternalBribe(_gauge, _external);\n    }\n\n    /// @notice Set a new internal bribe for a given gauge\n    function setInternalBribeFor(address _gauge, address _internal) external VoterAdmin {\n        require(isGauge[_gauge]);\n        _setInternalBribe(_gauge, _internal);\n    }\n\n    /// @notice Set a new External bribe for a given gauge\n    function setExternalBribeFor(address _gauge, address _external) external VoterAdmin {\n        require(isGauge[_gauge]);\n        _setExternalBribe(_gauge, _external);\n    }\n\n    function _setInternalBribe(address _gauge, address _internal) private {\n        internal_bribes[_gauge] = _internal;\n    }\n\n    function _setExternalBribe(address _gauge, address _external) private {\n        external_bribes[_gauge] = _external;\n    }\n    \n    \n    /// @notice Increase gauge approvals if max is type(uint).max is reached    [very long run could happen]\n    function increaseGaugeApprovals(address _gauge) external VoterAdmin {\n        require(isGauge[_gauge]);\n        IERC20(base).approve(_gauge, 0);\n        IERC20(base).approve(_gauge, type(uint).max);\n    }\n\n    \n    function addFactory(address _pairFactory, address _gaugeFactory) external VoterAdmin {\n        require(_pairFactory != address(0), 'addr 0');\n        require(_gaugeFactory != address(0), 'addr 0');\n        require(!isFactory[_pairFactory], 'factory true');\n        require(!isGaugeFactory[_gaugeFactory], 'g.fact true');\n\n        factories.push(_pairFactory);\n        gaugeFactories.push(_gaugeFactory);\n        isFactory[_pairFactory] = true;\n        isGaugeFactory[_gaugeFactory] = true;\n    }\n\n    function replaceFactory(address _pairFactory, address _gaugeFactory, uint256 _pos) external VoterAdmin {\n        require(_pairFactory != address(0), 'addr 0');\n        require(_gaugeFactory != address(0), 'addr 0');\n        require(isFactory[_pairFactory], 'factory false');\n        require(isGaugeFactory[_gaugeFactory], 'g.fact false');\n        address oldPF = factories[_pos];\n        address oldGF = gaugeFactories[_pos];\n        isFactory[oldPF] = false;\n        isGaugeFactory[oldGF] = false;\n\n        factories[_pos] = (_pairFactory);\n        gaugeFactories[_pos] = (_gaugeFactory);\n        isFactory[_pairFactory] = true;\n        isGaugeFactory[_gaugeFactory] = true;\n    }\n\n    function removeFactory(uint256 _pos) external VoterAdmin {\n        address oldPF = factories[_pos];\n        address oldGF = gaugeFactories[_pos];\n        require(isFactory[oldPF], 'factory false');\n        require(isGaugeFactory[oldGF], 'g.fact false');\n        factories[_pos] = address(0);\n        gaugeFactories[_pos] = address(0);\n        isFactory[oldPF] = false;\n        isGaugeFactory[oldGF] = false;\n    }\n\n    \n    \n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    GOVERNANCE\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n    \n    \n    /// @notice Whitelist a token for gauge creation\n    function whitelist(address[] memory _token) external Governance {\n        uint256 i = 0;\n        for(i = 0; i < _token.length; i++){\n            _whitelist(_token[i]);\n        }\n    }\n       \n    function _whitelist(address _token) private {\n        require(!isWhitelisted[_token]);\n        isWhitelisted[_token] = true;\n        emit Whitelisted(msg.sender, _token);\n    }\n    \n    /// @notice Blacklist a malicious token\n    function blacklist(address[] memory _token) external Governance {\n        uint256 i = 0;\n        for(i = 0; i < _token.length; i++){\n            _blacklist(_token[i]);\n        }\n    }\n       \n    function _blacklist(address _token) private {\n        require(isWhitelisted[_token]);\n        isWhitelisted[_token] = false;\n        emit Blacklisted(msg.sender, _token);\n    }\n\n     /// @notice Kill a malicious gauge \n    /// @param  _gauge gauge to kill\n    function killGauge(address _gauge) external Governance {\n        require(isAlive[_gauge], \"gauge already dead\");\n        isAlive[_gauge] = false;\n        claimable[_gauge] = 0;\n        emit GaugeKilled(_gauge);\n    }\n\n    /// @notice Revive a malicious gauge \n    /// @param  _gauge gauge to revive\n    function reviveGauge(address _gauge) external Governance {\n        require(!isAlive[_gauge], \"gauge already alive\");\n        require(isGauge[_gauge], 'gauge killed totally');\n        isAlive[_gauge] = true;\n        emit GaugeRevived(_gauge);\n    }\n    \n    /// @notice Kill a malicious gauge completly\n    /// @param  _gauge gauge to kill\n    function killGaugeTotally(address _gauge) external Governance {\n        require(isAlive[_gauge], \"gauge already dead\");\n\n        delete isAlive[_gauge];\n        delete internal_bribes[_gauge];\n        delete external_bribes[_gauge];\n        delete poolForGauge[_gauge];\n        delete isGauge[_gauge];\n        delete claimable[_gauge];\n        delete supplyIndex[_gauge];\n\n        address _pool = poolForGauge[_gauge];\n        gauges[_pool] = address(0);\n        \n\n        emit GaugeKilled(_gauge);\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    USER INTERACTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    \n    /// @notice Reset the votes of a given TokenID\n    function reset(uint _tokenId) external nonReentrant {\n        _voteDelay(_tokenId);\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\n        _reset(_tokenId);\n        IVotingEscrow(_ve).abstain(_tokenId);\n        lastVoted[_tokenId] = _epochTimestamp() + 1;\n    }\n\n    function _reset(uint _tokenId) internal {\n        address[] storage _poolVote = poolVote[_tokenId];\n        uint _poolVoteCnt = _poolVote.length;\n        uint256 _totalWeight = 0;\n        uint256 _time = _epochTimestamp();\n\n        for (uint i = 0; i < _poolVoteCnt; i ++) {\n            address _pool = _poolVote[i];\n            uint256 _votes = votes[_tokenId][_pool];\n\n            if (_votes != 0) {\n                _updateFor(gauges[_pool]);\n\n                // if user last vote is < than epochTimestamp then votes are 0! IF not underflow occur\n                if(lastVoted[_tokenId] > _epochTimestamp()) weightsPerEpoch[_time][_pool] -= _votes;\n\n                votes[_tokenId][_pool] -= _votes;\n\n                if (_votes > 0) {\n                    IBribe(internal_bribes[gauges[_pool]])._withdraw(uint256(_votes), _tokenId);\n                    IBribe(external_bribes[gauges[_pool]])._withdraw(uint256(_votes), _tokenId);\n                    _totalWeight += _votes;\n                }\n                \n                emit Abstained(_tokenId, _votes);\n            }\n        }\n\n        \n        // if user last vote is < than epochTimestamp then _totalWeight is 0! IF not underflow occur\n        if(lastVoted[_tokenId] < _epochTimestamp()) _totalWeight = 0;\n        \n        totWeightsPerEpoch[_time] -= _totalWeight;\n        usedWeights[_tokenId] = 0;\n        delete poolVote[_tokenId];\n    }\n\n    /// @notice Recast the saved votes of a given TokenID\n    function poke(uint _tokenId) external nonReentrant {\n        _voteDelay(_tokenId);\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\n        address[] memory _poolVote = poolVote[_tokenId];\n        uint _poolCnt = _poolVote.length;\n        uint256[] memory _weights = new uint256[](_poolCnt);\n\n        for (uint i = 0; i < _poolCnt; i ++) {\n            _weights[i] = votes[_tokenId][_poolVote[i]];\n        }\n\n        _vote(_tokenId, _poolVote, _weights);\n        lastVoted[_tokenId] = _epochTimestamp() + 1;\n    }\n\n    \n    /// @notice Vote for pools\n    /// @param  _tokenId    veNFT tokenID used to vote\n    /// @param  _poolVote   array of LPs addresses to vote  (eg.: [sAMM usdc-usdt   , sAMM busd-usdt, vAMM wbnb-the ,...])\n    /// @param  _weights    array of weights for each LPs   (eg.: [10               , 90            , 45             ,...])  \n    function vote(uint _tokenId, address[] calldata _poolVote, uint256[] calldata _weights) external nonReentrant {\n        _voteDelay(_tokenId);\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\n        require(_poolVote.length == _weights.length);\n        _vote(_tokenId, _poolVote, _weights);\n        lastVoted[_tokenId] = _epochTimestamp() + 1;\n    }\n    \n    function _vote(uint _tokenId, address[] memory _poolVote, uint256[] memory _weights) internal {\n        _reset(_tokenId);\n        uint _poolCnt = _poolVote.length;\n        uint256 _weight = IVotingEscrow(_ve).balanceOfNFT(_tokenId);\n        uint256 _totalVoteWeight = 0;\n        uint256 _totalWeight = 0;\n        uint256 _usedWeight = 0;\n        uint256 _time = _epochTimestamp();\n\n        for (uint i = 0; i < _poolCnt; i++) {\n            _totalVoteWeight += _weights[i];\n        }\n\n        for (uint i = 0; i < _poolCnt; i++) {\n            address _pool = _poolVote[i];\n            address _gauge = gauges[_pool];\n\n            if (isGauge[_gauge]) {\n                uint256 _poolWeight = _weights[i] * _weight / _totalVoteWeight;\n                require(votes[_tokenId][_pool] == 0);\n                require(_poolWeight != 0);\n                _updateFor(_gauge);\n\n                poolVote[_tokenId].push(_pool);\n                weightsPerEpoch[_time][_pool] += _poolWeight;\n\n                votes[_tokenId][_pool] += _poolWeight;\n\n                IBribe(internal_bribes[_gauge])._deposit(uint256(_poolWeight), _tokenId);\n                IBribe(external_bribes[_gauge])._deposit(uint256(_poolWeight), _tokenId);\n                \n                _usedWeight += _poolWeight;\n                _totalWeight += _poolWeight;\n                emit Voted(msg.sender, _tokenId, _poolWeight);\n            }\n        }\n        if (_usedWeight > 0) IVotingEscrow(_ve).voting(_tokenId);\n        totWeightsPerEpoch[_time] += _totalWeight;\n        usedWeights[_tokenId] = (_usedWeight);\n    }\n\n    /// @notice claim LP gauge rewards\n    function claimRewards(address[] memory _gauges) external {\n        for (uint i = 0; i < _gauges.length; i++) {\n            IGauge(_gauges[i]).getReward(msg.sender);\n        }\n    }\n\n    /// @notice claim bribes rewards given a TokenID\n    function claimBribes(address[] memory _bribes, address[][] memory _tokens, uint _tokenId) external {\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\n        for (uint i = 0; i < _bribes.length; i++) {\n            IBribe(_bribes[i]).getRewardForOwner(_tokenId, _tokens[i]);\n        }\n    }\n\n    /// @notice claim fees rewards given a TokenID\n    function claimFees(address[] memory _fees, address[][] memory _tokens, uint _tokenId) external {\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\n        for (uint i = 0; i < _fees.length; i++) {\n            IBribe(_fees[i]).getRewardForOwner(_tokenId, _tokens[i]);\n        }\n    }\n\n    /// @notice claim bribes rewards given an address\n    function claimBribes(address[] memory _bribes, address[][] memory _tokens) external {\n        for (uint i = 0; i < _bribes.length; i++) {\n            IBribe(_bribes[i]).getRewardForAddress(msg.sender, _tokens[i]);\n        }\n    }\n\n    /// @notice claim fees rewards given an address\n    function claimFees(address[] memory _bribes, address[][] memory _tokens) external {\n        for (uint i = 0; i < _bribes.length; i++) {\n            IBribe(_bribes[i]).getRewardForAddress(msg.sender, _tokens[i]);\n        }\n    }    \n\n    /// @notice attach a veNFT tokenID to a gauge. This is used for boost farming \n    /// @dev boost not available in Thena. Keep the function in case we need it for future updates. \n    function attachTokenToGauge(uint tokenId, address account) external {\n        require(isGauge[msg.sender]);\n        require(isAlive[msg.sender]); // killed gauges cannot attach tokens to themselves\n        if (tokenId > 0) IVotingEscrow(_ve).attach(tokenId);\n        emit Attach(account, msg.sender, tokenId);\n    }\n\n    \n    /// @notice detach a veNFT tokenID to a gauge. This is used for boost farming \n    /// @dev boost not available in Thena. Keep the function in case we need it for future updates. \n    function detachTokenFromGauge(uint tokenId, address account) external {\n        require(isGauge[msg.sender]);\n        if (tokenId > 0) IVotingEscrow(_ve).detach(tokenId);\n        emit Detach(account, msg.sender, tokenId);\n    }\n\n    /// @notice check if user can vote\n    function _voteDelay(uint _tokenId) internal view {\n        require(block.timestamp > lastVoted[_tokenId] + VOTE_DELAY, \"ERR: VOTE_DELAY\");\n    }\n\n\n\n     /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    GAUGE CREATION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n    /// @notice create multiple gauges\n    function createGauges(address[] memory _pool, uint256[] memory _gaugeTypes) external nonReentrant returns(address[] memory, address[] memory, address[] memory)  {\n        require(_pool.length == _gaugeTypes.length);\n        require(_pool.length <= 10);\n        address[] memory _gauge = new address[](_pool.length);\n        address[] memory _int = new address[](_pool.length);\n        address[] memory _ext = new address[](_pool.length);\n\n        uint i = 0;\n        for(i; i < _pool.length; i++){\n            (_gauge[i], _int[i], _ext[i]) = _createGauge(_pool[i], _gaugeTypes[i]);\n        }\n        return (_gauge, _int, _ext);\n    }\n\n     /// @notice create a gauge  \n    function createGauge(address _pool, uint256 _gaugeType) external nonReentrant returns (address _gauge, address _internal_bribe, address _external_bribe)  {\n        (_gauge, _internal_bribe, _external_bribe) = _createGauge(_pool, _gaugeType);\n    }\n\n    /// @notice create a gauge\n    /// @param  _pool       LP address \n    /// @param  _gaugeType  the type of the gauge you want to create\n    /// @dev    To create stable/Volatile pair gaugeType = 0, Concentrated liqudity = 1, ...\n    ///         Make sure to use the corrcet gaugeType or it will fail\n\n    function _createGauge(address _pool, uint256 _gaugeType) internal returns (address _gauge, address _internal_bribe, address _external_bribe) {\n        require(_gaugeType < factories.length, \"gaugetype\");\n        require(gauges[_pool] == address(0x0), \"!exists\");\n        bool isPair;\n        address _factory = factories[_gaugeType];\n        address _gaugeFactory = gaugeFactories[_gaugeType];\n        require(_factory != address(0));\n        require(_gaugeFactory != address(0));\n        \n\n        address tokenA = address(0);\n        address tokenB = address(0);\n        (tokenA) = IPairInfo(_pool).token0();\n        (tokenB) = IPairInfo(_pool).token1();\n\n        // for future implementation add isPair() in factory\n        if(_gaugeType == 0){\n            isPair = IPairFactory(_factory).isPair(_pool);\n        } \n        if(_gaugeType == 1) {\n            address _pool_factory = IAlgebraFactory(_factory).poolByPair(tokenA, tokenB);\n            address _pool_hyper = IHypervisor(_pool).pool();\n            require(_pool_hyper == _pool_factory, 'wrong tokens');    \n            isPair = true;\n        } else {\n            //update\n            //isPair = false;\n        }\n\n        // gov can create for any pool, even non-Thena pairs\n        if (!IPermissionsRegistry(permissionRegistry).hasRole(\"GOVERNANCE\",msg.sender)) { \n            require(isPair, \"!_pool\");\n            require(isWhitelisted[tokenA] && isWhitelisted[tokenB], \"!whitelisted\");\n            require(tokenA != address(0) && tokenB != address(0), \"!pair.tokens\");\n        }\n\n        // create internal and external bribe\n        address _owner = IPermissionsRegistry(permissionRegistry).thenaTeamMultisig();\n        string memory _type =  string.concat(\"Thena LP Fees: \", IERC20(_pool).symbol() );\n        _internal_bribe = IBribeFactory(bribefactory).createBribe(_owner, tokenA, tokenB, _type);\n\n        _type = string.concat(\"Thena Bribes: \", IERC20(_pool).symbol() );\n        _external_bribe = IBribeFactory(bribefactory).createBribe(_owner, tokenA, tokenB, _type);\n\n        // create gauge\n        _gauge = IGaugeFactory(_gaugeFactory).createGaugeV2(base, _ve, _pool, address(this), _internal_bribe, _external_bribe, isPair);\n     \n        // approve spending for $the\n        IERC20(base).approve(_gauge, type(uint).max);\n\n        // save data\n        internal_bribes[_gauge] = _internal_bribe;\n        external_bribes[_gauge] = _external_bribe;\n        gauges[_pool] = _gauge;\n        poolForGauge[_gauge] = _pool;\n        isGauge[_gauge] = true;\n        isAlive[_gauge] = true;\n        pools.push(_pool);\n\n        // update index\n        _updateFor(_gauge);\n\n        emit GaugeCreated(_gauge, msg.sender, _internal_bribe, _external_bribe, _pool);\n    }\n\n   \n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    VIEW FUNCTIONS\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice view the total length of the pools\n    function length() external view returns (uint) {\n        return pools.length;\n    }\n\n    /// @notice view the total length of the voted pools given a tokenId\n    function poolVoteLength(uint tokenId) external view returns(uint) { \n        return poolVote[tokenId].length;\n    }\n\n    function _factories() external view returns(address[] memory){\n        return factories;\n    }\n    \n    function factoryLength() external view returns(uint){\n        return factories.length;\n    }\n    \n    function _gaugeFactories() external view returns(address[] memory){\n        return gaugeFactories;\n    }\n    \n    function gaugeFactoriesLength() external view returns(uint) {\n        return gaugeFactories.length;\n    }\n\n    function weights(address _pool) public view returns(uint) {\n        uint _time = _epochTimestamp();\n        return weightsPerEpoch[_time][_pool];\n    }\n\n    function weightsAt(address _pool, uint _time) public view returns(uint) {\n        return weightsPerEpoch[_time][_pool];\n    }\n\n    function totalWeight() public view returns(uint) {\n        uint _time = _epochTimestamp();\n        return totWeightsPerEpoch[_time];\n    }\n\n    function totalWeightAt(uint _time) public view returns(uint) {\n        return totWeightsPerEpoch[_time];\n    }\n\n    function _epochTimestamp() public view returns(uint) {\n        return IMinter(minter).active_period();\n    }\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    DISTRIBUTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice notify reward amount for gauge\n    /// @dev    the function is called by the minter each epoch. Anyway anyone can top up some extra rewards.\n    /// @param  amount  amount to distribute\n    function notifyRewardAmount(uint amount) external {\n        require(msg.sender == minter);\n        _safeTransferFrom(base, msg.sender, address(this), amount);     // transfer the distro in\n        uint _totalWeight = totalWeightAt(_epochTimestamp() - 604800);   // minter call notify after updates active_period, loads votes - 1 week\n        uint256 _ratio = 0;\n\n        if(_totalWeight > 0) _ratio = amount * 1e18 / _totalWeight;     // 1e18 adjustment is removed during claim\n        if (_ratio > 0) {\n            index += _ratio;\n        }\n\n        emit NotifyReward(msg.sender, base, amount);\n    }\n\n    /// @notice notify reward amount for gauge\n    /// @dev    the function is called by the minter each epoch. Anyway anyone can top up some extra rewards.\n    /// @param  amount  amount to distribute\n    function _notifyRewardAmount(uint amount) external {\n        _safeTransferFrom(base, msg.sender, address(this), amount); // transfer the distro in\n        uint _totalWeight = totalWeight();\n        require(_totalWeight > 0);\n        uint256 _ratio = amount * 1e18 / _totalWeight; // 1e18 adjustment is removed during claim\n        if (_ratio > 0) {\n            index += _ratio;\n        }\n        emit NotifyReward(msg.sender, base, amount);\n    }\n\n  \n\n    /// @notice distribute the LP Fees to the internal bribes\n    /// @param  _gauges  gauge address where to claim the fees \n    /// @dev    the gauge is the owner of the LPs so it has to claim\n    function distributeFees(address[] memory _gauges) external {\n        for (uint i = 0; i < _gauges.length; i++) {\n            if (isGauge[_gauges[i]] && isAlive[_gauges[i]]){\n                IGauge(_gauges[i]).claimFees();\n            }\n        }\n    }\n\n    \n    /// @notice Distribute the emission for ALL gauges \n    function distributeAll() external nonReentrant {\n        \n        IMinter(minter).update_period();\n\n        uint x = 0;\n        uint stop = pools.length;\n        for (x; x < stop; x++) {\n            _distribute(gauges[pools[x]]);\n        }\n    }\n\n    /// @notice distribute the emission for N gauges\n    /// @param  start   start index point of the pools array\n    /// @param  finish  finish index point of the pools array\n    /// @dev    this function is used in case we have too many pools and gasLimit is reached\n    function distribute(uint start, uint finish) public nonReentrant {\n        IMinter(minter).update_period();\n        for (uint x = start; x < finish; x++) {\n            _distribute(gauges[pools[x]]);\n        }\n    }\n\n    /// @notice distribute reward onyl for given gauges\n    /// @dev    this function is used in case some distribution fails\n    function distribute(address[] memory _gauges) external nonReentrant {\n        IMinter(minter).update_period();\n        for (uint x = 0; x < _gauges.length; x++) {\n            _distribute(_gauges[x]);\n        }\n    }\n\n    /// @notice distribute the emission\n    function _distribute(address _gauge) internal {\n\n        uint lastTimestamp = gaugesDistributionTimestmap[_gauge];\n        uint currentTimestamp = _epochTimestamp();\n        if(lastTimestamp < currentTimestamp){\n            _updateForAfterDistribution(_gauge); // should set claimable to 0 if killed\n\n            uint _claimable = claimable[_gauge];"
    }
  ]
}