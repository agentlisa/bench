{
  "Title": "[M-07] `Mint` function does not update `LiquidityPosition` state of caller before minting LP tokens. This",
  "Content": "\n<https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L302> \n\n<https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/LiquidityPosition.sol#L60>\n\n### Impact\n\nWhen a LP mints V2 Pool tokens, `mint` function in [PoolLibrary](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L302) gets called. Inside this function `updateDurationWeightBeforeMaturity` updates global `short`, `long0` and `long1` fee growth.\n\nChange in global fee growth necessitates an update to `LiquidityPosition` state of caller (specifically updating fees & fee growth rates) when there are state changes made to that position (in this case, increasing liquidity). This principle is followed in functions such as `burn`, `transferLiquidity`, `transferFees`. However when calling `mint`, this update is missing. As a result, `growth` & `fee` levels in liquidity position of caller are inconsistent with global fee growth rates.\n\nInconsistent state leads to incorrect calculations of long0/long1 and short fees of LP holders which in turn can lead to loss of fees. Since this impacts actual rewards for users, I've marked it as MEDIUM risk.\n\n### Proof of Concept\n\nLet's say, Bob has following sequence of events\n\n*   MINT at T0: Bob is a LP who mints N pool tokens at T0\n\n*   MINT at T1: Bob mints another M pool tokens at T1. At this point, had the protocol correctly updated fees before minting new pool tokens, Bob's fees & growth rate would be a function of current liquidity (N), global updated short fee growth rate at t1 (s_t1) and Bob's previous growth rate at t\\_0 (b_t0)\n\n*   BURN at T2: Bob burns N + M tokens at T2. At this point, Bob's fees should be a function of previous liquidity (N+M), global short fee growth rate (s_t2) and Bob's previous growth rate at t\\_1(b_t1) -> since this update never happened, Bob's previous growth rate is wrongly referenced b_t0 instead of b_t1.\n\nBob could collect a lower fees because of this state inconsistency.\n\n### Recommended Mitigation Steps\n\nUpdate the liquidity position state right before minting.\n\nAfter [line 302 of Pool.sol](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L302), update the LiquidityPosition by adding\n\n      liquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n\n**[vhawk19 (Timeswap) confirmed](https://github.com/code-423n4/2023-01-timeswap-findings/issues/158)**\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-pool/src/structs/Pool.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {SafeCast} from \"@timeswap-labs/v2-library/src/SafeCast.sol\";\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\nimport {Math} from \"@timeswap-labs/v2-library/src/Math.sol\";\n\nimport {ITimeswapV2Option} from \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\";\n\nimport {StrikeConversion} from \"@timeswap-labs/v2-library/src/StrikeConversion.sol\";\n\nimport {DurationCalculation} from \"../libraries/DurationCalculation.sol\";\nimport {DurationWeight} from \"../libraries/DurationWeight.sol\";\nimport {ConstantProduct} from \"../libraries/ConstantProduct.sol\";\nimport {ConstantSum} from \"../libraries/ConstantSum.sol\";\nimport {FeeCalculation} from \"../libraries/FeeCalculation.sol\";\n\nimport {ITimeswapV2PoolMintCallback} from \"../interfaces/callbacks/ITimeswapV2PoolMintCallback.sol\";\nimport {ITimeswapV2PoolBurnCallback} from \"../interfaces/callbacks/ITimeswapV2PoolBurnCallback.sol\";\nimport {ITimeswapV2PoolDeleverageCallback} from \"../interfaces/callbacks/ITimeswapV2PoolDeleverageCallback.sol\";\nimport {ITimeswapV2PoolLeverageCallback} from \"../interfaces/callbacks/ITimeswapV2PoolLeverageCallback.sol\";\n\nimport {LiquidityPosition, LiquidityPositionLibrary} from \"./LiquidityPosition.sol\";\n\nimport {TimeswapV2PoolMint, TimeswapV2PoolBurn, TimeswapV2PoolDeleverage, TimeswapV2PoolLeverage, TimeswapV2PoolRebalance, TransactionLibrary} from \"../enums/Transaction.sol\";\n\nimport {TimeswapV2PoolCollectParam, TimeswapV2PoolMintParam, TimeswapV2PoolBurnParam, TimeswapV2PoolDeleverageParam, TimeswapV2PoolLeverageParam, TimeswapV2PoolRebalanceParam} from \"./Param.sol\";\nimport {TimeswapV2PoolMintChoiceCallbackParam, TimeswapV2PoolBurnChoiceCallbackParam, TimeswapV2PoolDeleverageChoiceCallbackParam, TimeswapV2PoolLeverageChoiceCallbackParam} from \"./CallbackParam.sol\";\n/// @param liquidity The current total liquidity of the pool.\n/// @param lastTimestamp The last block timestamp the pool was interacted with.\n/// @param sqrtInterestRate The current square root interest rate of the pool. Follows UQ64.96.\n/// @param long0Balance The current amount of long0 positions in the pool.\n/// @param long1Balance The current amount of long1 positions in the pool.\n/// @param long0FeeGrowth The global long0 position fee growth the last time the pool was interacted with.\n/// @param long1FeeGrowth The global long1 position fee growth the last time the pool was interacted with.\n/// @param shortFeeGrowth The global short position fee growth the last time the pool was interacted with.\n/// @param long0ProtocolFees The amount of long0 position protocol fees earned.\n/// @param long1ProtocolFees The amount of long1 position protocol fees earned.\n/// @param shortProtocolFees The amount of short position protocol fees earned.\n/// @param liquidityPositions The mapping of liquidity positions owned by liquidity providers.\nstruct Pool {\n    uint160 liquidity;\n    uint96 lastTimestamp;\n    uint160 sqrtInterestRate;\n    uint256 long0Balance;\n    uint256 long1Balance;\n    uint256 long0FeeGrowth;\n    uint256 long1FeeGrowth;\n    uint256 shortFeeGrowth;\n    uint256 long0ProtocolFees;\n    uint256 long1ProtocolFees;\n    uint256 shortProtocolFees;\n    mapping(address => LiquidityPosition) liquidityPositions;\n}\n\nlibrary PoolLibrary {\n    using LiquidityPositionLibrary for LiquidityPosition;\n    using Math for uint256;\n    using SafeCast for uint256;\n\n    /// @dev It calculates the global fee growth, which is fee increased per unit of liquidity token.\n    /// @param pool The state of the pool.\n    /// @return long0FeeGrowth The global fee increased per unit of liquidity token for long0.\n    /// @return long1FeeGrowth The global fee increased per unit of liquidity token for long1.\n    /// @return  shortFeeGrowth The global fee increased per unit of liquidity token for short.\n    function feeGrowth(Pool storage pool) external view returns (uint256 long0FeeGrowth, uint256 long1FeeGrowth, uint256 shortFeeGrowth) {\n        return (pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n    }\n\n    /// @param pool The state of the pool.\n    /// @param owner The address to query the fees earned of.\n    /// @return long0Fees The amount of long0 fees owned by the given address.\n    /// @return long1Fees The amount of long1 fees owned by the given address.\n    /// @return shortFees The amount of short fees owned by the given address.\n    function feesEarnedOf(Pool storage pool, address owner) external view returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees) {\n        return pool.liquidityPositions[owner].feesEarnedOf(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n    }\n\n    /// @param pool The state of the pool.\n    /// @return long0ProtocolFees The amount of long0 protocol fees owned by the owner of the factory contract.\n    /// @return long1ProtocolFees The amount of long1 protocol fees owned by the owner of the factory contract.\n    /// @return shortProtocolFees The amount of short protocol fees owned by the owner of the factory contract.\n    function protocolFeesEarned(Pool storage pool) external view returns (uint256 long0ProtocolFees, uint256 long1ProtocolFees, uint256 shortProtocolFees) {\n        return (pool.long0ProtocolFees, pool.long1ProtocolFees, pool.shortProtocolFees);\n    }\n\n    /// @dev Returns the amount of long0 and long1 adjusted for the protocol and transaction fee.\n    /// @param pool The state of the pool.\n    /// @return long0Amount The amount of long0 in the pool, adjusted for the protocol and transaction fee.\n    /// @return long1Amount The amount of long1 in the pool, adjusted for the protocol and transaction fee.\n    function totalLongBalanceAdjustFees(Pool storage pool, uint256 transactionFee) external view returns (uint256 long0Amount, uint256 long1Amount) {\n        long0Amount = FeeCalculation.removeFees(pool.long0Balance, transactionFee);\n        long1Amount = FeeCalculation.removeFees(pool.long1Balance, transactionFee);\n    }\n\n    /// @dev Returns the amount of sum of long0 and long1 converted to base denomination in the pool.\n    /// @dev Returns the amount of short positions in the pool.\n    /// @param pool The state of the pool.\n    /// @return longAmount The amount of sum of long0 and long1 converted to base denomination in the pool.\n    /// @return shortAmount The amount of short in the pool.\n    function totalPositions(Pool storage pool, uint256 maturity, uint96 blockTimestamp) external view returns (uint256 longAmount, uint256 shortAmount) {\n        longAmount = ConstantProduct.getLong(pool.liquidity, pool.sqrtInterestRate, false);\n        shortAmount = ConstantProduct.getShort(pool.liquidity, pool.sqrtInterestRate, DurationCalculation.unsafeDurationFromNowToMaturity(maturity, blockTimestamp), false);\n    }\n\n    /// @dev Move short positions to short fee growth due to duration of the pool decreasing as time moves forward.\n    /// @param liquidity The liquidity in the pool.\n    /// @param rate The square root interest rate in the pool.\n    /// @param shortFeeGrowth The previous short fee growth from last transaction in the pool.\n    /// @param duration The duration time of the pool.\n    /// @param blockTimestamp The block timestamp.\n    /// @return newLastTimestamp The new current last timestamp.\n    /// @return newShortFeeGrowth The newly updated short fee growth.\n    function updateDurationWeight(\n        uint160 liquidity,\n        uint160 rate,\n        uint256 shortFeeGrowth,\n        uint96 duration,\n        uint96 blockTimestamp\n    ) private pure returns (uint96 newLastTimestamp, uint256 newShortFeeGrowth) {\n        newLastTimestamp = blockTimestamp;\n        newShortFeeGrowth = DurationWeight.update(liquidity, shortFeeGrowth, ConstantProduct.getShort(liquidity, rate, duration, false));\n    }\n\n    /// @dev Move short positions to short fee growth due to duration of the pool decreasing as time moves forward when pool is before maturity.\n    /// @param pool The state of the pool.\n    /// @param blockTimestamp The block timestamp.\n    function updateDurationWeightBeforeMaturity(Pool storage pool, uint96 blockTimestamp) private {\n        if (pool.lastTimestamp < blockTimestamp)\n            (pool.lastTimestamp, pool.shortFeeGrowth) = updateDurationWeight(\n                pool.liquidity,\n                pool.sqrtInterestRate,\n                pool.shortFeeGrowth,\n                DurationCalculation.unsafeDurationFromLastTimestampToNow(pool.lastTimestamp, blockTimestamp),\n                blockTimestamp\n            );\n    }\n\n    /// @dev Move short positions to short fee growth due to duration of the pool decreasing as time moves forward when pool is after maturity.\n    /// @param pool The state of the pool.\n    /// @param blockTimestamp The block timestamp.\n    function updateDurationWeightAfterMaturity(Pool storage pool, uint256 maturity, uint96 blockTimestamp) private {\n        (pool.lastTimestamp, pool.shortFeeGrowth) = updateDurationWeight(\n            pool.liquidity,\n            pool.sqrtInterestRate,\n            pool.shortFeeGrowth,\n            DurationCalculation.unsafeDurationFromLastTimestampToMaturity(pool.lastTimestamp, maturity),\n            blockTimestamp\n        );\n    }\n\n    /// @dev Transfer liquidity positions to another address.\n    /// @notice Does not transfer the transaction fees earned by the sender.\n    /// @param pool The state of the pool.\n    /// @param to The receipient of the liquidity positions.\n    /// @param liquidityAmount The amount of liquidity positions transferred.\n    /// @param blockTimestamp The current block timestamp.\n    function transferLiquidity(Pool storage pool, address to, uint160 liquidityAmount, uint96 blockTimestamp) external {\n        // Update the state of the pool first for the short fee growth.\n        if (pool.liquidity != 0) updateDurationWeightBeforeMaturity(pool, blockTimestamp);\n\n        // Update the fee growth and fees of msg.sender.\n        LiquidityPosition storage liquidityPosition = pool.liquidityPositions[msg.sender];\n\n        liquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n        liquidityPosition.burn(liquidityAmount);\n\n        // Update the fee growth and fees of receipient.\n        LiquidityPosition storage newLiquidityPosition = pool.liquidityPositions[to];\n\n        newLiquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n        newLiquidityPosition.mint(liquidityAmount);\n    }\n\n    /// @dev Transfer fees earned of the sender to another address.\n    /// @notice Does not transfer the liquidity positions of the sender.\n    /// @param pool The state of the pool.\n    /// @param to The receipient of the transaction fees.\n    /// @param long0Fees The amount of long0 position fees transferrred.\n    /// @param long1Fees The amount of long1 position fees transferrred.\n    /// @param shortFees The amount of short position fees transferrred.\n    /// @param blockTimestamp The current block timestamp.\n    function transferFees(Pool storage pool, uint256 maturity, address to, uint256 long0Fees, uint256 long1Fees, uint256 shortFees, uint96 blockTimestamp) external {\n        // Update the state of the pool first for the short fee growth.\n        if (pool.liquidity != 0) {\n            if (maturity > blockTimestamp) updateDurationWeightBeforeMaturity(pool, blockTimestamp);\n            else if (pool.lastTimestamp < maturity) updateDurationWeightAfterMaturity(pool, maturity, blockTimestamp);\n        }\n        // Update the fee growth and fees of msg.sender.\n        LiquidityPosition storage liquidityPosition = pool.liquidityPositions[msg.sender];\n\n        liquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n        liquidityPosition.burnFees(long0Fees, long1Fees, shortFees);\n\n        // Update the fee growth and fees of recipient.\n        liquidityPosition = pool.liquidityPositions[to];\n\n        liquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n        liquidityPosition.mintFees(long0Fees, long1Fees, shortFees);\n    }\n\n    /// @dev initializes the pool with the given parameters.\n    /// @param pool The state of the pool.\n    /// @param rate The square root of the interest rate of the pool.\n    function initialize(Pool storage pool, uint160 rate) external {\n        if (pool.liquidity != 0) Error.alreadyHaveLiquidity(pool.liquidity);\n        pool.sqrtInterestRate = rate;\n    }\n\n    /// @dev Collects the protocol fees of the pool.\n    /// @dev only protocol owner can call this function.\n    /// @dev if the owner enters an amount which is greater than the fee amount they have earned, withdraw only the amount they have.\n    /// @param pool The state of the pool.\n    /// @param long0Requested The maximum amount of long0 positions wanted.\n    /// @param long1Requested The maximum amount of long1 positions wanted.\n    /// @param shortRequested The maximum amount of short positions wanted.\n    /// @return long0Amount The amount of long0 collected.\n    /// @return long1Amount The amount of long1 collected.\n    /// @return shortAmount The amount of short collected.\n    function collectProtocolFees(\n        Pool storage pool,\n        uint256 long0Requested,\n        uint256 long1Requested,\n        uint256 shortRequested\n    ) external returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) {\n        if (long0Requested >= pool.long0ProtocolFees) {\n            long0Amount = pool.long0ProtocolFees;\n            pool.long0ProtocolFees = 0;\n        } else {\n            long0Amount = long0Requested;\n            pool.long0ProtocolFees = pool.long0ProtocolFees.unsafeSub(long0Requested);\n        }\n\n        if (long1Requested >= pool.long1ProtocolFees) {\n            long1Amount = pool.long1ProtocolFees;\n            pool.long1ProtocolFees = 0;\n        } else {\n            long1Amount = long1Requested;\n            pool.long1ProtocolFees = pool.long1ProtocolFees.unsafeSub(long1Requested);\n        }\n\n        if (shortRequested >= pool.shortProtocolFees) {\n            shortAmount = pool.shortProtocolFees;\n            pool.shortProtocolFees = 0;\n        } else {\n            shortAmount = shortRequested;\n            pool.shortProtocolFees = pool.shortProtocolFees.unsafeSub(shortRequested);\n        }\n    }\n\n    /// @dev Collects the transaction fees of the pool.\n    /// @dev only liquidity provider can call this function.\n    /// @dev if the owner enters an amount which is greater than the fee amount they have earned, withdraw only the amount they have.\n    /// @param pool The state of the pool.\n    /// @param blockTimestamp The current block timestamp.\n    /// @param long0Requested The maximum amount of long0 positions wanted.\n    /// @param long1Requested The maximum amount of long1 positions wanted.\n    /// @param shortRequested The maximum amount of short positions wanted.\n    /// @return long0Amount The amount of long0 collected.\n    /// @return long1Amount The amount of long1 collected.\n    /// @return shortAmount The amount of short collected.\n    function collectTransactionFees(\n        Pool storage pool,\n        uint256 maturity,\n        uint256 long0Requested,\n        uint256 long1Requested,\n        uint256 shortRequested,\n        uint96 blockTimestamp\n    ) external returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) {\n        // Update the state of the pool first for the short fee growth.\n        if (pool.liquidity != 0) {\n            if (maturity > blockTimestamp) updateDurationWeightBeforeMaturity(pool, blockTimestamp);\n            else if (pool.lastTimestamp < maturity) updateDurationWeightAfterMaturity(pool, maturity, blockTimestamp);\n        }\n\n        // Update the fee growth and fees of caller.\n        LiquidityPosition storage liquidityPosition = pool.liquidityPositions[msg.sender];\n\n        if (pool.liquidity != 0) liquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n\n        (long0Amount, long1Amount, shortAmount) = liquidityPosition.collectTransactionFees(long0Requested, long1Requested, shortRequested);\n    }\n\n    /// @dev deposit Short and Long tokens and mints Liquidity\n    /// @dev can be only called before the maturity.\n    /// @param pool The state of the pool.\n    /// @param param it is a struct that contains the parameters of the mint function.\n    /// @param blockTimestamp The current block timestamp.\n    /// @return liquidityAmount The amount of liquidity minted.\n    /// @return long0Amount The amount of long0 deposited.\n    /// @return long1Amount The amount of long1 deposited.\n    /// @return shortAmount The amount of short deposited.\n    /// @return data the data used for the callbacks.\n    function mint(\n        Pool storage pool,\n        TimeswapV2PoolMintParam memory param,\n        uint96 blockTimestamp\n    ) external returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        // Update the state of the pool first for the short fee growth.\n        if (pool.liquidity != 0) updateDurationWeightBeforeMaturity(pool, blockTimestamp);\n        // Update the fee growth and fees of caller.\n        LiquidityPosition storage liquidityPosition = pool.liquidityPositions[param.to];\n\n        uint256 longAmount;\n        if (param.transaction == TimeswapV2PoolMint.GivenLiquidity) {\n            (longAmount, shortAmount) = ConstantProduct.calculateGivenLiquidityDelta(\n                pool.sqrtInterestRate,\n                liquidityAmount = param.delta.toUint160(),\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                true\n            );\n\n            if (longAmount == 0) Error.zeroOutput();\n            if (shortAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolMint.GivenLong) {\n            (liquidityAmount, shortAmount) = ConstantProduct.calculateGivenLiquidityLong(\n                pool.sqrtInterestRate,\n                longAmount = param.delta,\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                true\n            );\n\n            if (liquidityAmount == 0) Error.zeroOutput();\n            if (shortAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolMint.GivenShort) {\n            (liquidityAmount, longAmount) = ConstantProduct.calculateGivenLiquidityShort(\n                pool.sqrtInterestRate,\n                shortAmount = param.delta,\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                true\n            );\n\n            if (liquidityAmount == 0) Error.zeroOutput();\n            if (longAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolMint.GivenLarger) {\n            (liquidityAmount, longAmount, shortAmount) = ConstantProduct.calculateGivenLiquidityLargerOrSmaller(\n                pool.sqrtInterestRate,\n                param.delta,\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                true\n            );\n\n            if (liquidityAmount == 0) Error.zeroOutput();\n            if (longAmount == 0) Error.zeroOutput();\n            if (shortAmount == 0) Error.zeroOutput();\n        }\n\n        // Ask the msg.sender how much long0 position and long1 position wanted.\n        (long0Amount, long1Amount, data) = ITimeswapV2PoolMintCallback(msg.sender).timeswapV2PoolMintChoiceCallback(\n            TimeswapV2PoolMintChoiceCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                longAmount: longAmount,\n                shortAmount: shortAmount,\n                liquidityAmount: liquidityAmount,\n                data: param.data\n            })\n        );\n        Error.checkEnough(StrikeConversion.combine(long0Amount, long1Amount, param.strike, false), longAmount);\n\n        if (long0Amount != 0) pool.long0Balance += long0Amount;\n        if (long1Amount != 0) pool.long1Balance += long1Amount;\n\n        liquidityPosition.mint(liquidityAmount);\n        pool.liquidity += liquidityAmount;\n    }\n\n    /// @dev burn Liquidity and receive Short and Long tokens\n    /// @dev can be only called before the maturity.\n    /// @dev after the maturity of the pool, the long0 and long1 tokens are zero. And the short tokens are added into the transaction fees.\n    /// @dev if the user wants to burn the liquidity after the maturity, they should call the collectTransactionFee function.\n    /// @param pool The state of the pool.\n    /// @param param it is a struct that contains the parameters of the burn function.\n    /// @param blockTimestamp The current block timestamp.\n    /// @return liquidityAmount The amount of liquidity burned.\n    /// @return long0Amount The amount of long0 withdrawn.\n    /// @return long1Amount The amount of long1 withdrawn.\n    /// @return shortAmount The amount of short withdrawn.\n    /// @return data the data used for the callbacks.\n    function burn(\n        Pool storage pool,\n        TimeswapV2PoolBurnParam memory param,\n        uint96 blockTimestamp\n    ) external returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        if (pool.liquidity == 0) Error.requireLiquidity();\n\n        // Update the state of the pool first for the short fee growth.\n        updateDurationWeightBeforeMaturity(pool, blockTimestamp);\n\n        LiquidityPosition storage liquidityPosition = pool.liquidityPositions[msg.sender];\n\n        liquidityPosition.update(pool.long0FeeGrowth, pool.long1FeeGrowth, pool.shortFeeGrowth);\n\n        uint256 longAmount;\n        if (param.transaction == TimeswapV2PoolBurn.GivenLiquidity) {\n            (longAmount, shortAmount) = ConstantProduct.calculateGivenLiquidityDelta(\n                pool.sqrtInterestRate,\n                liquidityAmount = param.delta.toUint160(),\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                false\n            );\n\n            if (longAmount == 0) Error.zeroOutput();\n            if (shortAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolBurn.GivenLong) {\n            (liquidityAmount, shortAmount) = ConstantProduct.calculateGivenLiquidityLong(\n                pool.sqrtInterestRate,\n                longAmount = param.delta,\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                false\n            );\n\n            if (liquidityAmount == 0) Error.zeroOutput();\n            if (shortAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolBurn.GivenShort) {\n            (liquidityAmount, longAmount) = ConstantProduct.calculateGivenLiquidityShort(\n                pool.sqrtInterestRate,\n                shortAmount = param.delta,\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                false\n            );\n\n            if (liquidityAmount == 0) Error.zeroOutput();\n            if (longAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolBurn.GivenSmaller) {\n            (liquidityAmount, longAmount, shortAmount) = ConstantProduct.calculateGivenLiquidityLargerOrSmaller(\n                pool.sqrtInterestRate,\n                param.delta,\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                false\n            );\n\n            if (liquidityAmount == 0) Error.zeroOutput();\n            if (longAmount == 0) Error.zeroOutput();\n            if (shortAmount == 0) Error.zeroOutput();\n        }\n\n        (long0Amount, long1Amount, data) = ITimeswapV2PoolBurnCallback(msg.sender).timeswapV2PoolBurnChoiceCallback(\n            TimeswapV2PoolBurnChoiceCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                long0Balance: pool.long0Balance,\n                long1Balance: pool.long1Balance,\n                longAmount: longAmount,\n                shortAmount: shortAmount,\n                liquidityAmount: liquidityAmount,\n                data: param.data\n            })\n        );\n        Error.checkEnough(longAmount, StrikeConversion.combine(long0Amount, long1Amount, param.strike, true));\n\n        if (long0Amount != 0) pool.long0Balance -= long0Amount;\n        if (long1Amount != 0) pool.long1Balance -= long1Amount;\n\n        pool.liquidity -= liquidityAmount;\n    }\n\n    /// @dev deposit Long tokens and receive Short tokens\n    /// @dev can be only called before the maturity.\n    /// @param pool The state of the pool.\n    /// @param param it is a struct that contains the parameters of the deleverage function\n    /// @param transactionFee The transaction fee rate.\n    /// @param protocolFee The protocol fee rate.\n    /// @param blockTimestamp The current block timestamp.\n    /// @return long0Amount The amount of long0 deposited.\n    /// @return long1Amount The amount of long1 deposited.\n    /// @return shortAmount The amount of short received.\n    /// @return data the data used for the callbacks.\n    function deleverage(\n        Pool storage pool,\n        TimeswapV2PoolDeleverageParam memory param,\n        uint256 transactionFee,\n        uint256 protocolFee,\n        uint96 blockTimestamp\n    ) external returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        if (pool.liquidity == 0) Error.requireLiquidity();\n        // Update the state of the pool first for the short fee growth.\n        updateDurationWeightBeforeMaturity(pool, blockTimestamp);\n\n        uint256 longAmount;\n        uint256 shortFees;\n        if (param.transaction == TimeswapV2PoolDeleverage.GivenDeltaSqrtInterestRate) {\n            (pool.sqrtInterestRate, longAmount, shortAmount, shortFees) = ConstantProduct.updateGivenSqrtInterestRateDelta(\n                pool.liquidity,\n                pool.sqrtInterestRate,\n                param.delta.toUint160(),\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                transactionFee,\n                false\n            );\n\n            if (longAmount == 0) Error.zeroOutput();\n            if (shortAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolDeleverage.GivenLong) {\n            (pool.sqrtInterestRate, shortAmount, shortFees) = ConstantProduct.updateGivenLong(\n                pool.liquidity,\n                pool.sqrtInterestRate,\n                longAmount = param.delta,\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                transactionFee,\n                true\n            );\n\n            if (shortAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolDeleverage.GivenShort) {\n            (pool.sqrtInterestRate, longAmount, shortFees) = ConstantProduct.updateGivenShort(\n                pool.liquidity,\n                pool.sqrtInterestRate,\n                shortAmount = param.delta,\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                transactionFee,\n                false\n            );\n\n            if (longAmount == 0) Error.zeroOutput();\n        } else if (param.transaction == TimeswapV2PoolDeleverage.GivenSum) {\n            (pool.sqrtInterestRate, longAmount, shortAmount, shortFees) = ConstantProduct.updateGivenSumLong(\n                pool.liquidity,\n                pool.sqrtInterestRate,\n                param.delta,\n                DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                transactionFee,\n                true\n            );\n\n            if (longAmount == 0) Error.zeroOutput();\n            if (shortAmount == 0) Error.zeroOutput();\n        }\n\n        (pool.shortFeeGrowth, pool.shortProtocolFees) = FeeCalculation.update(pool.liquidity, pool.shortFeeGrowth, pool.shortProtocolFees, shortFees, protocolFee);\n\n        (long0Amount, long1Amount, data) = ITimeswapV2PoolDeleverageCallback(msg.sender).timeswapV2PoolDeleverageChoiceCallback(\n            TimeswapV2PoolDeleverageChoiceCallbackParam({strike: param.strike, maturity: param.maturity, longAmount: longAmount, shortAmount: shortAmount, data: param.data})\n        );\n        Error.checkEnough(StrikeConversion.combine(long0Amount, long1Amount, param.strike, false), longAmount);\n\n        if (long0Amount != 0) pool.long0Balance += long0Amount;\n        if (long1Amount != 0) pool.long1Balance += long1Amount;\n    }\n\n    /// @dev deposit Short tokens and receive Long tokens\n    /// @dev can be only called before the maturity.\n    /// @param pool The state of the pool.\n    /// @param param it is a struct that contains the parameters of the leverage function.\n    /// @param transactionFee The transaction fee rate.\n    /// @param protocolFee The protocol fee rate.\n    /// @param blockTimestamp The current block timestamp.\n    /// @return long0Amount The amount of long0 received.\n    /// @return long1Amount The amount of long1 received.\n    /// @return shortAmount The amount of short deposited.\n    /// @return data the data used for the callbacks.\n    function leverage(\n        Pool storage pool,\n        TimeswapV2PoolLeverageParam memory param,\n        uint256 transactionFee,\n        uint256 protocolFee,\n        uint96 blockTimestamp\n    ) external returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        if (pool.liquidity == 0) Error.requireLiquidity();\n\n        // Update the state of the pool first for the short fee growth.\n        updateDurationWeightBeforeMaturity(pool, blockTimestamp);\n\n        uint256 long0BalanceAdjustFees = FeeCalculation.removeFees(pool.long0Balance, transactionFee);\n        uint256 long1BalanceAdjustFees = FeeCalculation.removeFees(pool.long1Balance, transactionFee);\n        {\n            uint256 longAmount;\n            if (param.transaction == TimeswapV2PoolLeverage.GivenDeltaSqrtInterestRate) {\n                (pool.sqrtInterestRate, longAmount, shortAmount, ) = ConstantProduct.updateGivenSqrtInterestRateDelta(\n                    pool.liquidity,\n                    pool.sqrtInterestRate,\n                    param.delta.toUint160(),\n                    DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                    transactionFee,\n                    true\n                );\n\n                if (longAmount == 0) Error.zeroOutput();\n                if (shortAmount == 0) Error.zeroOutput();\n            } else if (param.transaction == TimeswapV2PoolLeverage.GivenLong) {\n                (pool.sqrtInterestRate, shortAmount, ) = ConstantProduct.updateGivenLong(\n                    pool.liquidity,\n                    pool.sqrtInterestRate,\n                    longAmount = param.delta,\n                    DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                    transactionFee,\n                    false\n                );\n\n                if (shortAmount == 0) Error.zeroOutput();\n            } else if (param.transaction == TimeswapV2PoolLeverage.GivenShort) {\n                (pool.sqrtInterestRate, longAmount, ) = ConstantProduct.updateGivenShort(\n                    pool.liquidity,\n                    pool.sqrtInterestRate,\n                    shortAmount = param.delta,\n                    DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                    transactionFee,\n                    true\n                );\n\n                if (longAmount == 0) Error.zeroOutput();\n            } else if (param.transaction == TimeswapV2PoolLeverage.GivenSum) {\n                (pool.sqrtInterestRate, longAmount, shortAmount, ) = ConstantProduct.updateGivenSumLong(\n                    pool.liquidity,\n                    pool.sqrtInterestRate,\n                    param.delta,\n                    DurationCalculation.unsafeDurationFromNowToMaturity(param.maturity, blockTimestamp),\n                    transactionFee,\n                    false\n                );\n                if (longAmount == 0) Error.zeroOutput();\n                if (shortAmount == 0) Error.zeroOutput();\n            }\n\n            (long0Amount, long1Amount, data) = ITimeswapV2PoolLeverageCallback(msg.sender).timeswapV2PoolLeverageChoiceCallback(\n                TimeswapV2PoolLeverageChoiceCallbackParam({"
    }
  ]
}