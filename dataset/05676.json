{
  "Title": "[M-12] Timestamp Constraints Leading to Number of Blocks Creation Limitations",
  "Content": "\nThe timestamp constraints and batch creation limitations in zkSync have several significant impacts on the platform's functionality and operations:\n\n1. **Limited Block Inclusion:** The constraints on timestamp differences between batches and their respective blocks restrict the number of blocks that can be included in each batch. This leads to smaller batch sizes, making it challenging to efficiently process transactions and utilize the available block space.\n\n2. **Responsiveness Issue:** Due to these constraints, if two batches are intended to be committed on L1 at the same time (in the same Ethereum block), it's not allowed. This can create bottlenecks during batch commitments, especially when zkSync experiences high transaction volumes leading to an increased number of pending transactions and potentially longer finality times, affecting zkSync's overall responsiveness.\n\n3. **Operator-Induced Limitations:** These constraints can be exploited by the operator by setting timestamps much further in the future to intentionally limit the number of blocks in batches. This could lead to various operational issues and inefficiencies.\n\n### Proof of Concept\n\nUpon initiating transaction processing in the bootloader, the first step involves creating a new batch using the `setNewBatch` function in the `SystemContext` contract.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/bootloader/bootloader.yul#L3675><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/SystemContext.sol#L416>\n\nThis operation enforces that the timestamp of the new batch must be greater than the timestamp of the previous batch and the timestamp of the last block in the previous batch.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/SystemContext.sol#L423><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/SystemContext.sol#L402>\n\nSubsequently, when processing a specific transaction, an L2 block is designated by invoking the `setL2Block` function within the `SystemContext` contract. This action ensures that the timestamp of the block is not lower than the timestamp of the current batch.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/bootloader/bootloader.yul#L559><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/SystemContext.sol#L323>\n\nOnce the processing of all transactions is completed, an additional fictive block is generated, serving as the final block within the batch. \n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/bootloader/bootloader.yul#L3812>\n\nFinally, the timestamp data is disclosed to L1 for verification.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/bootloader/bootloader.yul#L3816>\n\nOn the L1 side, during batch commitment, the `_verifyBatchTimestamp` function is called to confirm the accuracy of the timestamps. It enforces that the batch's timestamp is later than the previous batch and not less than `block.timestamp - COMMIT_TIMESTAMP_NOT_OLDER`. Additionally, it ensures that the timestamp of the last block in this batch is not greater than `block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA`.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L85><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L93><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L94>\n\nA critical concern arises when the operator, during the creation of a new batch on L2, sets its timestamp in close proximity to the value `block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA`. To illustrate this point, consider the following example:\n\nImagine a new batch, numbered 1000, is created with a timestamp of `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA - 1`. This batch includes a block with a timestamp of `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA - 1` and a fictive block with a timestamp of `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA`. Importantly, these values adhere to all the timestamp requirements outlined in the `SystemContext` contract, as explained earlier.\n\nWhen this batch 1000, is committed on L1 at a specific time `blockTimestamp1000` (meaning the time at which the batch 1000 is committed on L1), during timestamp verification, the following requirement is met (assuming `X <= blockTimestamp1000`):\n\n    require(lastL2BlockTimestamp <= block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA, \"h2\");\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L94>\n\nBecause:\n\n    assuming: X <= blockTimestamp1000 ==>\n    X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA <= blockTimestamp1000 + COMMIT_TIMESTAMP_APPROXIMATION_DELTA\n\nThis results in a successful proof and execution of the batch 1000. Now, when a new batch, 1001, is to be created on L2, its timestamp must be higher than `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA` because a batch's timestamp should surpass the timestamp of the last block in the previous batch.\n\nSuppose the timestamp of batch 1001 is `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA + Y`, and the last block within this batch carries a timestamp of `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA + Y + K`.\n\nTo summarize:\n- Batch 1000:\n    - Batch timestamp: `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA - 1`.\n    - Timestamp of the last block (fictive block) in this batch: `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA`.\n    - The time this batch is committed on L1: `blockTimestamp1000`.\n    - `X <= blockTimestamp1000`.\n\n- Batch 1001:\n    - Batch timestamp: `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA + Y`.\n    - Timestamp of the last block (fictive block) in this batch: `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA + Y + K`.\n    - The time this batch is committed on L1: `blockTimestamp1001`.\n\nDuring the timestamp verification of batch 1001 on L1, to meet the requirement:\n\n    require(lastL2BlockTimestamp <= block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA, \"h2\");\n\nWe must have:\n\n    X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA + Y + K <= blockTimestamp1001 + COMMIT_TIMESTAMP_APPROXIMATION_DELTA\n\nSimplifying the condition yields:\n\n    Y + K <= blockTimestamp1001 - X\n\nHere, `X` represents the time set by the operator, where `X <= blockTimestamp1000` as explained earlier. In the worst case scenario, if `X = blockTimestamp1000`, the condition becomes:\n\n    Y + K <= blockTimestamp1001 - blockTimestamp1000\n\nThe variable `Y` signifies the amount of time required for the timestamp of batch 1001 to be higher than the timestamp of the last block in batch 1000. The minimum value of `Y` is 1 second. Assuming it is equal to 1 second (please note that if `Y` is higher than 1, the situation becomes even worse), the condition simplifies to:\n\n    K <= blockTimestamp1001 - blockTimestamp1000 - 1\n\nThis condition imposes a critical limitation on the number of blocks that can be included in a batch. As a reminder, the timestamp of the first block in batch 1001 is `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA + Y`, while the timestamp of the last block in this batch is `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA + Y + K` (the fictive block). The difference between these two timestamps equals `K`, and since each block's timestamp must be greater than the previous block, `K` defines the maximum number of blocks allowed in a batch.\n\nThis condition has several implications:\n\n- If both batches 1001 and 1000 are to be committed on L1 at the same time `blockTimestamp1000  = blockTimestamp1001` (in the same Ethereum block), it is not allowed, as `K <= -1`.\n- Examining zkSync Era Explorer, it is evident that batches are frequently committed in the same Ethereum block. For example, by observing Ethereum block number 18383261, the function `commitBlocks` is called 19 times, with block positions ranging from 0 to 18. The following two transactions show just the first and the last `commitBlocks` in this Ethereum block.\n\n<https://etherscan.io/tx/0xbfec43599bb73af95eaf4ac9ff83a62cdbe084382dd6f5d12bc8e817ce3574e5><br>\n<https://etherscan.io/tx/0x1826d459ce7f2ab233374595569a13c4098e8e1eeb26517a98e42d9b5aab7374>\n\n- The explorer demonstrates that the interval between committing batches is relatively short. For instance, if the interval is 30 seconds, a maximum of 29 blocks can be included in a batch.\n\n- It's important to emphasize that batch 1000 has already undergone commitment, proof, and execution processes, and once these steps are completed, they are irreversible. Therefore, this issue will persist within the system.\n\n- As mentioned in the document, L2 blocks are employed to reduce the time required for soft confirmation. However, due to the vulnerability explained earlier, there exists a stringent constraint on the number of blocks, resulting in an extended soft confirmation duration.\n\n> L2 blocks were created for fast soft confirmation on wallets and block explorer. For example, MetaMask shows transactions as confirmed only after the block in which transaction execution was mined. So if the user needs to wait for the batch confirmation it would take at least minutes (for soft confirmation) and hours for full confirmation which is very bad UX. But API could return soft confirmation much earlier through L2 blocks.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/Batches%20%26%20L2%20blocks%20on%20zkSync.md#motivation>\n\nOne potential solution is to commit batches on L1 with a longer delay to allow for more blocks to be included in batches. However, this approach may lead to other issues, such as an increased number of pending transactions and significantly extended finality.\n\nAddressing this issue is not straightforward, and it would necessitate an upgrade of the `Executor` facet and a redesign of the timestamp verification process.\n\nIn summary, if the operator sets the timestamp of a batch too far into the future while still complying with L1 requirements, it can restrict the number of blocks that can be included in batches, resulting in a variety of challenges.\n\n### Recommended Mitigation Steps\n\nIt is recommended that a more stricter timestamp constraint currently enforced in the `_verifyBatchTimestamp` function on L1 to also apply on L2. This will help prevent the creation and submission of batches with timestamps set in the distant future to L1. \n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L94>\n\n### Assessed type\n\nContext\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium](https://github.com/code-423n4/2023-10-zksync-findings/issues/316#issuecomment-1826735946)**\n\n**[anon (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/316#issuecomment-1837474089):**\n>  If the timestamp of a batch is set to its maximum valid value (which is `block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA`, in this case, `block.timestamp + 365 days`), it results in limitations on the speed of blocks and batches creation. Given that `L2_TX_MAX_GAS_LIMIT` is [equal](https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/SystemConfig.json#L2) to `80,000,000`, and the maximum computation gas per batch is equal to `2^32` (explained [here](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/docs/Smart%20contract%20Section/zkSync%20fee%20model.md#system-wide-constants) and set [here](https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/SystemContext.sol#L37)), roughly 53 transactions (calculated as `2^32 / 80,000,000`), each consuming the maximum `80,000,000` gas, will exhaust the gas capacity of a batch.\n> \n> Consequently, the batch must be sealed, and another batch needs to be created to include additional transactions. If there is a high volume of transactions on the network, numerous batches must be created and committed on L1. Since the timestamp of the batch is set to the current timestamp plus 365 days, committing batches in a single L1 transaction becomes impossible. This is due to each batch's timestamp needing to be higher than the previous batch's timestamp, requiring the validator to wait between each batch commitment for the timestamp on L1 to elapse, thus passing this [check](https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L94). This scenario can lead to several issues:\n> \n> - Firstly, as indicated in the documentation, the value of `2^32` is arbitrary to prevent the state keeper from taking too much time. \n>   > The maximum number of computation gas per batch. This is the maximal number of gas that can be spent within a batch. This constant is rather arbitrary and is needed to prevent transactions from taking too much time from the state keeper. It can not be larger than the hard limit of `2^32` of gas for VM.\n> \n>   The operator may also seal the batch earlier, as mentioned [here](https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/bootloader/bootloader.yul#L3806). While this speeds up batch commitment on L1, the timestamp of the batch being set to the far future necessitates a delay between each commitment for the timestamp on L1 to elapse.\n> \n> - Secondly, the assumption so far was that each batch consists of one block containing all transactions. However, the primary objective of having multiple blocks in a batch is to enhance the speed of soft confirmation, as explained [here](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/Batches%20%26%20L2%20blocks%20on%20zkSync.md#motivation):\n>   > L2 blocks were created for fast soft confirmation on wallets and block explorer. For example, MetaMask shows transactions as confirmed only after the block in which transaction execution was mined. So if the user needs to wait for the batch confirmation it would take at least minutes (for soft confirmation) and hours for full confirmation which is very bad UX. But API could return soft confirmation much earlier through L2 blocks.\n> \n>   If the operator includes multiple blocks in a batch, it becomes limited on the L1 side during timestamp verification. Suppose batch 100 has a timestamp of `timestamp of the to-be-committed batch 100 + 365 days` and has 20 blocks. The 20th block must have a timestamp of at least `timestamp of the to-be-committed batch 100 + 365 days + 20 seconds`. When the validator commits this batch, it will be reverted [here](https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L94) because `block.timestamp + 365 days + 20 seconds > block.timestamp + 365 days`. This indicates that having multiple blocks in a batch while the timestamp of the batch is set to the far future (to the edge of acceptable timestamp) will limit the frequency of batch commitment on L1 and restrict the number of blocks in a batch. In such a case, the validator should wait between each batch commitment on L1, potentially causing slow finality, impacting third parties dependent on that.\n> \n> **Summary:**\n> \n> Setting the timestamp of a batch to the far future will limit the speed of blocks and batches creation:\n> - Including multiple blocks in a batch will be restricted during timestamp verification on L1 since the timestamp of the batch is already at the edge of the accepted timestamp.\n> - Having only one block in a batch (to bypass the limitation mentioned above) contradicts the goal of having a block for fast finality.\n> \n> Furthermore, in the case of a high volume of transactions on the network, this issue will be a significant limiting factor. If such a batch with a timestamp in the far future is executed, this limitation will persist in the protocol, as an executed batch cannot be reverted.\n\n\n**[unforgiven (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/316#issuecomment-1837501912):**\n> I want to add that the underlying cause of Issue #316 is a security check that restricts the operator to submitting batches with timestamp far in the future(`ZKbatch.timestamp < Etherem.timestamp + DELTA`). This issue persists regardless of the DELTA value, even if set to zero. While this vulnerability exists, there are mitigating factors that diminish its severity:\n> \n> - Due to the 12-second interval between Ethereum blocks, the operator can consistently generate and submit 12 batches within the next Ethereum block. The upper bound for batch timestamps, `Etherem.timestamp + DELTA`, increases by 12 seconds with each Ethereum block.\n> - zkSync can always accommodate approximately 12 batch submissions in each subsequent Ethereum block, even under this attack. Batch timestamps can be set as `Etherem.timestamp + DELTA`, `Etherem.timestamp + DELTA +1`, `Etherem.timestamp + DELTA +2`,... `Etherem.timestamp + DELTA +11` and submitted to Ethereum. These timestamps will pass the `batch.timestamp < Etherem.timestamp + DELTA` check in the next Ethereum blocks due to the 12-second increase in Ethereum's timestamp.\n> - Block numbers are determined by the operator, who can choose to include one block per batch or each transaction in a separate block within a batch. This is an operator-trusted function, and the number of blocks within each batch has no practical impact.\n> - Operators and validators are trusted to submit batches. A malicious operator could simply refrain from submitting batches.\n> \n> In conclusion, the security check `ZKbatch.timestamp < Etherem.timestamp + DELTA` does not impacts the average 12 batch submissions per Ethereum block, even if the operator sets batch timestamps to `Etherem.timestamp + DELTA`.\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/316#issuecomment-1838287149):**\n> I agree with anon's comment [here](https://github.com/code-423n4/2023-10-zksync-findings/issues/316#issuecomment-1837474089).\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/316#issuecomment-1848898451):**\n > The finding highlights a way for batch creation to be interrupted, this pertains to any configuration and is something that the operator could do under specific circumstances either willingly or by mistake. \n\n**[vladbochok (zkSync) disputed, disagreed with severity and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/316#issuecomment-1838287149):**\n> The issue is highly theoretical and has a low impact in principle.\n>\n> Firstly validator should submit the batch with a timestamp in the future (+365 days). Even the validator is not trusted - this already has a huge impact on L2 protocols (all time-sensitive projects such as DeFi or oracles).\n> \n> And then the only impact is that the validator can't commit batches for times of high load. Please note, that the validator can create batches and generate zkp for them, just can't submit `commitBatches` transaction by that moment. So, the validator can wait for a couple of minutes and then submit all batches. Moreover, currently, there is a delay between batch commits and batch execution by 21 hours. Due to this delay minutes in commits don't affect the time of execution, not saying that proof generation takes minutes, and sequencing in such a high load is questionable.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/bootloader/bootloader.yul",
      "content": "object \"Bootloader\" {\n    code {\n    }\n    object \"Bootloader_deployed\" {\n        code {\n            ////////////////////////////////////////////////////////////////////////////\n            //                      Function Declarations\n            ////////////////////////////////////////////////////////////////////////////\n\n            // While we definitely cannot control the gas price on L1,\n            // we need to check the operator does not provide any absurd numbers there\n            function MAX_ALLOWED_L1_GAS_PRICE() -> ret {\n                // 100k gwei\n                ret := 100000000000000\n            }\n\n            function MAX_ALLOWED_FAIR_L2_GAS_PRICE() -> ret {\n                // 10k gwei\n                ret := 10000000000000\n            }\n\n            /// @dev This method ensures that the prices provided by the operator\n            /// are not absurdly high\n            function validateOperatorProvidedPrices(l1GasPrice, fairL2GasPrice) {\n                if gt(l1GasPrice, MAX_ALLOWED_L1_GAS_PRICE()) {\n                    assertionError(\"L1 gas price too high\")\n                }\n\n                if gt(fairL2GasPrice, MAX_ALLOWED_FAIR_L2_GAS_PRICE()) {\n                    assertionError(\"L2 fair gas price too high\")\n                }\n            }\n\n            /// @dev Returns the baseFee for this batch based on the\n            /// L1 gas price and the fair L2 gas price.\n            function getBaseFee(l1GasPrice, fairL2GasPrice) -> baseFee, gasPricePerPubdata {\n                // By default, we want to provide the fair L2 gas price.\n                // That it means that the operator controls\n                // what the value of the baseFee will be. In the future, \n                // a better system, aided by EIP1559 should be added. \n\n                let pubdataBytePriceETH := safeMul(l1GasPrice, L1_GAS_PER_PUBDATA_BYTE(), \"aoa\")\n\n                baseFee := max(\n                    fairL2GasPrice,\n                    ceilDiv(pubdataBytePriceETH, MAX_L2_GAS_PER_PUBDATA())\n                )\n                gasPricePerPubdata := ceilDiv(pubdataBytePriceETH, baseFee)\n            }\n\n            /// @dev It should be always possible to submit a transaction \n            /// that consumes such amount of public data.\n            function GUARANTEED_PUBDATA_PER_TX() -> ret {\n                ret := {{GUARANTEED_PUBDATA_BYTES}}\n            }\n\n            /// @dev The maximal gasPerPubdata, which allows users to still be \n            /// able to send `GUARANTEED_PUBDATA_PER_TX` onchain.\n            function MAX_L2_GAS_PER_PUBDATA() -> ret {\n                ret := div(MAX_GAS_PER_TRANSACTION(), GUARANTEED_PUBDATA_PER_TX())\n            }\n\n            /// @dev The computational overhead for a batch.\n            /// It includes the combined price for 1 instance of all the circuits \n            /// (since they might be partially filled), the price for running\n            /// the common parts of the bootloader as well as general maintainance of the system.\n            function BATCH_OVERHEAD_L2_GAS() -> ret {\n                ret := {{BATCH_OVERHEAD_L2_GAS}}\n            }\n\n            /// @dev The overhead for the interaction with L1.\n            /// It should cover proof verification as well as other minor \n            /// overheads for committing/executing a transaction in a batch.\n            function BATCH_OVERHEAD_L1_GAS() -> ret {\n                ret := {{BATCH_OVERHEAD_L1_GAS}}\n            }\n\n            /// @dev The maximal number of gas available to the transaction\n            function MAX_GAS_PER_TRANSACTION() -> ret {\n                ret := {{MAX_GAS_PER_TRANSACTION}}\n            }\n\n            /// @dev The number of L1 gas needed to be spent for\n            /// L1 byte. While a single pubdata byte costs `16` gas, \n            /// we demand at least 17 to cover up for the costs of additional\n            /// hashing of it, etc.\n            function L1_GAS_PER_PUBDATA_BYTE() -> ret {\n                ret := 17\n            }\n\n            /// @dev The size of the bootloader memory that is to spent by the transaction's\n            /// encodings.\n            function BOOTLOADER_MEMORY_FOR_TXS() -> ret {\n                ret := {{BOOTLOADER_MEMORY_FOR_TXS}}\n            }\n\n            /// @dev Whether the batch is allowed to accept transactions with\n            /// gasPerPubdataByteLimit = 0. On mainnet, this is forbidden for safety reasons.\n            function FORBID_ZERO_GAS_PER_PUBDATA() -> ret {\n                ret := {{FORBID_ZERO_GAS_PER_PUBDATA}}\n            }\n            \n            /// @dev The maximum number of transactions per L1 batch.\n            function MAX_TRANSACTIONS_IN_BATCH() -> ret {\n                ret := {{MAX_TRANSACTIONS_IN_BATCH}}\n            }\n\n            /// @dev The slot from which the scratch space starts.\n            /// Scatch space is used for various temporary values\n            function SCRATCH_SPACE_BEGIN_SLOT() -> ret {\n                ret := 8\n            }\n\n            /// @dev The byte from which the scratch space starts.\n            /// Scratch space is used for various temporary values\n            function SCRATCH_SPACE_BEGIN_BYTE() -> ret {\n                ret := mul(SCRATCH_SPACE_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The first 32 slots are reserved for event emitting for the \n            /// debugging purposes\n            function SCRATCH_SPACE_SLOTS() -> ret {\n                ret := 32\n            }\n\n            /// @dev Slots reserved for saving the paymaster context\n            /// @dev The paymasters are allowed to consume at most \n            /// 32 slots (1024 bytes) for their context.\n            /// The 33 slots are required since the first one stores the length of the calldata.\n            function PAYMASTER_CONTEXT_SLOTS() -> ret {\n                ret := 33\n            }\n        \n            /// @dev Bytes reserved for saving the paymaster context\n            function PAYMASTER_CONTEXT_BYTES() -> ret {\n                ret := mul(PAYMASTER_CONTEXT_SLOTS(), 32)\n            }\n\n            /// @dev Slot from which the paymaster context starts\n            function PAYMASTER_CONTEXT_BEGIN_SLOT() -> ret {\n                ret := add(SCRATCH_SPACE_BEGIN_SLOT(), SCRATCH_SPACE_SLOTS())\n            }\n\n            /// @dev The byte from which the paymaster context starts\n            function PAYMASTER_CONTEXT_BEGIN_BYTE() -> ret {\n                ret := mul(PAYMASTER_CONTEXT_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev Each tx must have at least this amount of unused bytes before them to be able to \n            /// encode the postOp operation correctly.\n            function MAX_POSTOP_SLOTS() -> ret {\n                // Before the actual transaction encoding, the postOp contains 6 slots:\n                // 1. Context offset\n                // 2. Transaction offset\n                // 3. Transaction hash\n                // 4. Suggested signed hash\n                // 5. Transaction result\n                // 6. Maximum refunded gas\n                // And one more slot for the padding selector\n                ret := add(PAYMASTER_CONTEXT_SLOTS(), 7)\n            }\n\n            /// @dev Slots needed to store the canonical and signed hash for the current L2 transaction.\n            function CURRENT_L2_TX_HASHES_RESERVED_SLOTS() -> ret {\n                ret := 2\n            }\n\n            /// @dev Slot from which storing of the current canonical and signed hashes begins\n            function CURRENT_L2_TX_HASHES_BEGIN_SLOT() -> ret {\n                ret := add(PAYMASTER_CONTEXT_BEGIN_SLOT(), PAYMASTER_CONTEXT_SLOTS())\n            }\n\n            /// @dev The byte from which storing of the current canonical and signed hashes begins\n            function CURRENT_L2_TX_HASHES_BEGIN_BYTE() -> ret {\n                ret := mul(CURRENT_L2_TX_HASHES_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The maximum number of new factory deps that are allowed in a transaction\n            function MAX_NEW_FACTORY_DEPS() -> ret {\n                ret := 32\n            }\n\n            /// @dev Besides the factory deps themselves, we also need another 4 slots for: \n            /// selector, marker of whether the user should pay for the pubdata,\n            /// the offset for the encoding of the array as well as the length of the array.\n            function NEW_FACTORY_DEPS_RESERVED_SLOTS() -> ret {\n                ret := add(MAX_NEW_FACTORY_DEPS(), 4)\n            }\n\n            /// @dev The slot starting from which the factory dependencies are stored\n            function NEW_FACTORY_DEPS_BEGIN_SLOT() -> ret {\n                ret := add(CURRENT_L2_TX_HASHES_BEGIN_SLOT(), CURRENT_L2_TX_HASHES_RESERVED_SLOTS())\n            }\n\n            /// @dev The byte starting from which the factory dependencies are stored\n            function NEW_FACTORY_DEPS_BEGIN_BYTE() -> ret {\n                ret := mul(NEW_FACTORY_DEPS_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The slot starting from which the refunds provided by the operator are stored\n            function TX_OPERATOR_REFUND_BEGIN_SLOT() -> ret {\n                ret := add(NEW_FACTORY_DEPS_BEGIN_SLOT(), NEW_FACTORY_DEPS_RESERVED_SLOTS())\n            }\n\n            /// @dev The byte starting from which the refunds provided by the operator are stored\n            function TX_OPERATOR_REFUND_BEGIN_BYTE() -> ret {\n                ret := mul(TX_OPERATOR_REFUND_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the refunds for the transactions.\n            /// It is equal to the number of transactions in the batch.\n            function TX_OPERATOR_REFUNDS_SLOTS() -> ret {\n                ret := MAX_TRANSACTIONS_IN_BATCH()\n            }\n\n            /// @dev The slot starting from which the overheads proposed by the operator will be stored\n            function TX_SUGGESTED_OVERHEAD_BEGIN_SLOT() -> ret {\n                ret := add(TX_OPERATOR_REFUND_BEGIN_SLOT(), TX_OPERATOR_REFUNDS_SLOTS())\n            }\n\n            /// @dev The byte starting from which the overheads proposed by the operator will be stored\n            function TX_SUGGESTED_OVERHEAD_BEGIN_BYTE() -> ret {\n                ret := mul(TX_SUGGESTED_OVERHEAD_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the overheads for the transactions.\n            /// It is equal to the number of transactions in the batch.\n            function TX_SUGGESTED_OVERHEAD_SLOTS() -> ret {\n                ret := MAX_TRANSACTIONS_IN_BATCH()\n            }\n\n            /// @dev The slot starting from which the maximum number of gas that the operator \"trusts\"\n            /// the transaction to use for its execution is stored. Sometimes, the operator may know that\n            /// a certain transaction can be allowed more gas that what the protocol-level worst-case allows.\n            function TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT() -> ret {\n                ret := add(TX_SUGGESTED_OVERHEAD_BEGIN_SLOT(), TX_SUGGESTED_OVERHEAD_SLOTS())\n            }\n\n            /// @dev byte starting from which the maximum number of gas that the operator \"trusts\"\n            /// the transaction to use for its execution is stored. \n            function TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_BYTE() -> ret {\n                ret := mul(TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the trusted gas limits for the transactions.\n            /// It is equal to the number of transactions in the batch.\n            function TX_OPERATOR_TRUSTED_GAS_LIMIT_SLOTS() -> ret {\n                ret := MAX_TRANSACTIONS_IN_BATCH()\n            }\n\n            /// @dev The slot starting from the L2 block information for transactions is stored.\n            function TX_OPERATOR_L2_BLOCK_INFO_BEGIN_SLOT() -> ret {\n                ret := add(TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT(), TX_OPERATOR_TRUSTED_GAS_LIMIT_SLOTS())\n            }\n\n            /// @dev The byte starting from which the L2 block information for transactions is stored.\n            function TX_OPERATOR_L2_BLOCK_INFO_BEGIN_BYTE() -> ret {\n                ret := mul(TX_OPERATOR_L2_BLOCK_INFO_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The size of each of the L2 block information. Each L2 block information contains four fields:\n            /// - number of the block\n            /// - timestamp of the block\n            /// - hash of the previous block\n            /// - the maximal number of virtual blocks to create\n            function TX_OPERATOR_L2_BLOCK_INFO_SLOT_SIZE() -> ret {\n                ret := 4\n            }\n\n            /// @dev The size of each of the L2 block information in bytes.\n            function TX_OPERATOR_L2_BLOCK_INFO_SIZE_BYTES() -> ret {\n                ret := mul(TX_OPERATOR_L2_BLOCK_INFO_SLOT_SIZE(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the L2 block information for the transactions.\n            /// Note, that an additional slot is required for the fictive L2 block at the end of the batch. \n            /// For technical reasons inside the sequencer implementation, \n            /// each batch ends with a fictive block with no transactions.\n            function TX_OPERATOR_L2_BLOCK_INFO_SLOTS() -> ret {\n                ret := mul(add(MAX_TRANSACTIONS_IN_BATCH(), 1), TX_OPERATOR_L2_BLOCK_INFO_SLOT_SIZE())\n            }\n\n            /// @dev The slot starting from which the compressed bytecodes are located in the bootloader's memory.\n            /// Each compressed bytecode is provided in the following format:\n            /// - 32 byte formatted bytecode hash\n            /// - 32 byte of zero (it will be replaced within the code with left-padded selector of the `publishCompressedBytecode`).\n            /// - ABI-encoding of the parameters of the `publishCompressedBytecode` method. \n            /// \n            /// At the slot `TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT()` the pointer to the currently processed compressed bytecode\n            /// is stored, i.e. this pointer will be increased once the current bytecode which the pointer points to is published.\n            /// At the start of the bootloader, the value stored at the `TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT` is equal to \n            /// `TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT + 32`, where the hash of the first compressed bytecode to publish should be stored.\n            function COMPRESSED_BYTECODES_BEGIN_SLOT() -> ret {\n                ret := add(TX_OPERATOR_L2_BLOCK_INFO_BEGIN_SLOT(), TX_OPERATOR_L2_BLOCK_INFO_SLOTS())\n            }\n\n            /// @dev The byte starting from which the compressed bytecodes are located in the bootloader's memory.\n            function COMPRESSED_BYTECODES_BEGIN_BYTE() -> ret {\n                ret := mul(COMPRESSED_BYTECODES_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated to the compressed bytecodes.\n            function COMPRESSED_BYTECODES_SLOTS() -> ret {\n                ret := {{COMPRESSED_BYTECODES_SLOTS}}\n            }\n\n            /// @dev The slot right after the last slot of the compressed bytecodes memory area.\n            function COMPRESSED_BYTECODES_END_SLOT() -> ret {\n                ret := add(COMPRESSED_BYTECODES_BEGIN_SLOT(), COMPRESSED_BYTECODES_SLOTS())\n            }\n\n            /// @dev The first byte in memory right after the compressed bytecodes memory area.\n            function COMPRESSED_BYTECODES_END_BYTE() -> ret {\n                ret := mul(COMPRESSED_BYTECODES_END_SLOT(), 32)\n            }\n\n            /// @dev Slots needed to store priority txs L1 data (`chainedPriorityTxsHash` and `numberOfLayer1Txs`).\n            function PRIORITY_TXS_L1_DATA_RESERVED_SLOTS() -> ret {\n                ret := 2\n            }\n\n            /// @dev Slot from which storing of the priority txs L1 data begins.\n            function PRIORITY_TXS_L1_DATA_BEGIN_SLOT() -> ret {\n                ret := add(COMPRESSED_BYTECODES_BEGIN_SLOT(), COMPRESSED_BYTECODES_SLOTS())\n            }\n\n            /// @dev The byte from which storing of the priority txs L1 data begins.\n            function PRIORITY_TXS_L1_DATA_BEGIN_BYTE() -> ret {\n                ret := mul(PRIORITY_TXS_L1_DATA_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev Slot from which storing of the L1 Messenger pubdata begins.\n            function OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_BEGIN_SLOT() -> ret {\n                ret := add(PRIORITY_TXS_L1_DATA_BEGIN_SLOT(), PRIORITY_TXS_L1_DATA_RESERVED_SLOTS())\n            }\n\n            /// @dev The byte storing of the L1 Messenger pubdata begins.\n            function OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_BEGIN_BYTE() -> ret {\n                ret := mul(OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev Slots needed to store L1 Messenger pubdata.\n            /// @dev Note that are many more these than the maximal pubdata in batch, since \n            /// it needs to also accomodate uncompressed state diffs that are required for the state diff\n            /// compression verification.\n            function OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_SLOTS() -> ret {\n                ret := {{OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_SLOTS}}\n            }\n\n            /// @dev The slot right after the last slot of the L1 Messenger pubdata memory area.\n            function OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_END_SLOT() -> ret {\n                ret := add(OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_BEGIN_SLOT(), OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_SLOTS())\n            }\n\n            /// @dev The slot from which the bootloader transactions' descriptions begin\n            function TX_DESCRIPTION_BEGIN_SLOT() -> ret {\n                ret := OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_END_SLOT()\n            }\n\n            /// @dev The byte from which the bootloader transactions' descriptions begin\n            function TX_DESCRIPTION_BEGIN_BYTE() -> ret {\n                ret := mul(TX_DESCRIPTION_BEGIN_SLOT(), 32)\n            }\n\n            // Each tx description has the following structure\n            // \n            // struct BootloaderTxDescription {\n            //     uint256 txMeta;\n            //     uint256 txDataOffset;\n            // }\n            //\n            // `txMeta` contains flags to manipulate the transaction execution flow.\n            // For playground batches:\n            //      It can have the following information (0 byte is LSB and 31 byte is MSB):\n            //      0 byte: `execute`, bool. Denotes whether transaction should be executed by the bootloader.\n            //      31 byte: server-side tx execution mode\n            // For proved batches:\n            //      It can simply denotes whether to execute the transaction (0 to stop executing the batch, 1 to continue) \n            //\n            // Each such encoded struct consumes 2 words\n            function TX_DESCRIPTION_SIZE() -> ret {\n                ret := 64\n            }\n\n            /// @dev The byte right after the basic description of bootloader transactions\n            function TXS_IN_BATCH_LAST_PTR() -> ret {\n                ret := add(TX_DESCRIPTION_BEGIN_BYTE(), mul(MAX_TRANSACTIONS_IN_BATCH(), TX_DESCRIPTION_SIZE()))\n            }\n\n            /// @dev The memory page consists of 2^19 VM words.\n            /// Each execution result is a single boolean, but \n            /// for the sake of simplicity we will spend 32 bytes on each\n            /// of those for now. \n            function MAX_MEM_SIZE() -> ret {\n                ret := 0x1000000 // 2^24 bytes\n            }\n\n            function L1_TX_INTRINSIC_L2_GAS() -> ret {\n                ret := {{L1_TX_INTRINSIC_L2_GAS}}\n            }\n\n            function L1_TX_INTRINSIC_PUBDATA() -> ret {\n                ret := {{L1_TX_INTRINSIC_PUBDATA}}\n            }\n\n            function L2_TX_INTRINSIC_GAS() -> ret {\n                ret := {{L2_TX_INTRINSIC_GAS}}\n            }\n\n            function L2_TX_INTRINSIC_PUBDATA() -> ret {\n                ret := {{L2_TX_INTRINSIC_PUBDATA}}\n            }\n\n            /// @dev The byte from which the pointers on the result of transactions are stored\n            function RESULT_START_PTR() -> ret {\n                ret := sub(MAX_MEM_SIZE(), mul(MAX_TRANSACTIONS_IN_BATCH(), 32))\n            }\n\n            /// @dev The pointer writing to which invokes the VM hooks\n            function VM_HOOK_PTR() -> ret {\n                ret := sub(RESULT_START_PTR(), 32)\n            }\n\n            /// @dev The maximum number the VM hooks may accept\n            function VM_HOOK_PARAMS() -> ret {\n                ret := 2\n            }\n\n            /// @dev The offset starting from which the parameters for VM hooks are located\n            function VM_HOOK_PARAMS_OFFSET() -> ret {\n                ret := sub(VM_HOOK_PTR(), mul(VM_HOOK_PARAMS(), 32))\n            }\n\n            function LAST_FREE_SLOT() -> ret {\n                // The slot right before the vm hooks is the last slot that\n                // can be used for transaction's descriptions\n                ret := sub(VM_HOOK_PARAMS_OFFSET(), 32)\n            }\n\n            /// @dev The formal address of the bootloader\n            function BOOTLOADER_FORMAL_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008001\n            }\n\n            function MAX_SYSTEM_CONTRACT_ADDR() -> ret {\n                ret := 0x000000000000000000000000000000000000ffff\n            }\n\n            function ACCOUNT_CODE_STORAGE_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008002\n            }\n\n            function NONCE_HOLDER_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008003\n            }\n\n            function KNOWN_CODES_CONTRACT_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008004\n            }\n\n            function CONTRACT_DEPLOYER_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008006\n            }\n            \n            function FORCE_DEPLOYER() -> ret {\n                ret := 0x0000000000000000000000000000000000008007\n            }\n\n            function MSG_VALUE_SIMULATOR_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008009\n            }\n\n            function ETH_L2_TOKEN_ADDR() -> ret {\n                ret := 0x000000000000000000000000000000000000800a\n            }\n\n            function SYSTEM_CONTEXT_ADDR() -> ret {\n                ret := 0x000000000000000000000000000000000000800b\n            }\n\n            function BOOTLOADER_UTILITIES() -> ret {\n                ret := 0x000000000000000000000000000000000000800c\n            }\n\n            function BYTECODE_COMPRESSOR_ADDR() -> ret {\n                ret := 0x000000000000000000000000000000000000800e\n            }\n\n            function L1_MESSENGER_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008008\n            }\n\n            /// @dev The minimal allowed distance in bytes between the pointer to the compressed data\n            /// and the end of the area dedicated for the compressed bytecodes. \n            /// In fact, only distance of 192 should be sufficient: there it would be possible to insert\n            /// the hash of the bytecode, the 32 bytes buffer for selector and 2 offsets of the calldata,\n            /// but we keep it at 512 just in case.\n            function MIN_ALLOWED_OFFSET_FOR_COMPRESSED_BYTES_POINTER() -> ret {\n                ret := 512\n            }\n\n            /// @dev Whether the bootloader should enforce that accounts have returned the correct\n            /// magic value for signature. This value is enforced to be \"true\" on the main proved batch, but \n            /// we need the ability to ignore invalid signature results during fee estimation,\n            /// where the signature for the transaction is usually not known beforehand.\n            function SHOULD_ENSURE_CORRECT_RETURNED_MAGIC() -> ret {\n                ret := {{ENSURE_RETURNED_MAGIC}}\n            }\n\n            /// @notice The type of the transaction used for system upgrades.\n            function UPGRADE_TRANSACTION_TX_TYPE() -> ret {\n                ret := 254\n            }\n\n            /// @notice The type of every non-upgrade transaction that comes from L1.\n            function L1_TX_TYPE() -> ret {\n                ret := 255\n            }\n\n            /// @dev The overhead in gas that will be used when checking whether the context has enough gas, i.e. \n            /// when checking for X gas, the context should have at least X+CHECK_ENOUGH_GAS_OVERHEAD() gas.\n            function CHECK_ENOUGH_GAS_OVERHEAD() -> ret {\n                ret := 1000000\n            }\n\n            /// @dev Ceil division of integers\n            function ceilDiv(x, y) -> ret {\n                switch or(eq(x, 0), eq(y, 0))\n                case 0 {\n                    // (x + y - 1) / y can overflow on addition, so we distribute.\n                    ret := add(div(sub(x, 1), y), 1)\n                }\n                default {\n                    ret := 0\n                }\n            }\n            \n            /// @dev Calculates the length of a given number of bytes rounded up to the nearest multiple of 32.\n            function lengthRoundedByWords(len) -> ret {\n                let neededWords := div(add(len, 31), 32)\n                ret := safeMul(neededWords, 32, \"xv\")\n            }\n\n            /// @dev Function responsible for processing the transaction\n            /// @param txDataOffset The offset to the ABI-encoding of the structure\n            /// @param resultPtr The pointer at which the result of the transaction's execution should be stored\n            /// @param transactionIndex The index of the transaction in the batch\n            /// @param isETHCall Whether the call is an ethCall. \n            /// @param gasPerPubdata The number of L2 gas to charge users for each byte of pubdata \n            /// On proved batch this value should always be zero\n            function processTx(\n                txDataOffset, \n                resultPtr,\n                transactionIndex,\n                isETHCall,\n                gasPerPubdata\n            ) {\n                // We set the L2 block info for this particular transaction\n                setL2Block(transactionIndex)\n\n                let innerTxDataOffset := add(txDataOffset, 32)\n\n                // By default we assume that the transaction has failed.\n                mstore(resultPtr, 0)\n\n                let userProvidedPubdataPrice := getGasPerPubdataByteLimit(innerTxDataOffset)\n                debugLog(\"userProvidedPubdataPrice:\", userProvidedPubdataPrice)\n\n                debugLog(\"gasPerPubdata:\", gasPerPubdata)\n\n                switch getTxType(innerTxDataOffset) \n                    case 254 {\n                        // This is an upgrade transaction.\n                        // Protocol upgrade transactions are processed totally in the same manner as the normal L1->L2 transactions,\n                        // the only difference are:\n                        // - They must be the first one in the batch\n                        // - They have a different type to prevent tx hash collisions and preserve the expectation that the \n                        // L1->L2 transactions have priorityTxId inside them.\n                        if transactionIndex {    \n                            assertionError(\"Protocol upgrade tx not first\")\n                        }\n\n                        // This is to be called in the event that the L1 Transaction is a protocol upgrade txn.\n                        // Since this is upgrade transactions, we are okay that the gasUsed by the transaction will \n                        // not cover this additional hash computation\n                        let canonicalL1TxHash := getCanonicalL1TxHash(txDataOffset)\n                        sendToL1Native(true, protocolUpgradeTxHashKey(), canonicalL1TxHash)\n\n                        processL1Tx(txDataOffset, resultPtr, transactionIndex, userProvidedPubdataPrice, false)\n                    }\n                    case 255 {\n                        // This is an L1->L2 transaction.\n                        processL1Tx(txDataOffset, resultPtr, transactionIndex, userProvidedPubdataPrice, true)\n                    }\n                    default {\n                        // The user has not agreed to this pubdata price\n                        if lt(userProvidedPubdataPrice, gasPerPubdata) {\n                            revertWithReason(UNACCEPTABLE_GAS_PRICE_ERR_CODE(), 0)\n                        }\n                        \n                        setPricePerPubdataByte(gasPerPubdata)\n\n                        <!-- @if BOOTLOADER_TYPE=='proved_batch' -->\n                        processL2Tx(txDataOffset, resultPtr, transactionIndex, gasPerPubdata)\n                        <!-- @endif -->\n\n                        <!-- @if BOOTLOADER_TYPE=='playground_batch' -->\n                        switch isETHCall \n                            case 1 {\n                                let gasLimit := getGasLimit(innerTxDataOffset)\n                                let nearCallAbi := getNearCallABI(gasLimit)\n                                checkEnoughGas(gasLimit)\n\n                                if iszero(gasLimit) {\n                                    // If success is 0, we need to revert\n                                    revertWithReason(\n                                        ETH_CALL_ERR_CODE(),\n                                        0\n                                    )\n                                }\n\n                                ZKSYNC_NEAR_CALL_ethCall(\n                                    nearCallAbi,\n                                    txDataOffset,\n                                    resultPtr\n                                )\n                            }\n                            default { \n                                processL2Tx(txDataOffset, resultPtr, transactionIndex, gasPerPubdata)\n                            }\n                        <!-- @endif -->\n                    }\n            }\n\n            /// @dev Calculates the canonical hash of the L1->L2 transaction that will be\n            /// sent to L1 as a message to the L1 contract that a certain operation has been processed.\n            function getCanonicalL1TxHash(txDataOffset) -> ret {\n                // Putting the correct value at the `txDataOffset` just in case, since \n                // the correctness of this value is not part of the system invariants.\n                // Note, that the correct ABI encoding of the Transaction structure starts with 0x20\n                mstore(txDataOffset, 32)\n\n                let innerTxDataOffset := add(txDataOffset, 32)\n                let dataLength := safeAdd(32, getDataLength(innerTxDataOffset), \"qev\")\n\n                debugLog(\"HASH_OFFSET\", innerTxDataOffset)\n                debugLog(\"DATA_LENGTH\", dataLength)\n\n                ret := keccak256(txDataOffset, dataLength)\n            }\n\n            /// @dev The purpose of this function is to make sure that the operator\n            /// gets paid for the transaction. Note, that the beneficiary of the payment is \n            /// bootloader.\n            /// The operator will be paid at the end of the batch.\n            function ensurePayment(txDataOffset, gasPrice) {\n                // Skipping the first 0x20 byte in the encoding of the transaction.\n                let innerTxDataOffset := add(txDataOffset, 32)\n                let from := getFrom(innerTxDataOffset)\n                let requiredETH := safeMul(getGasLimit(innerTxDataOffset), gasPrice, \"lal\")\n\n                let bootloaderBalanceETH := balance(BOOTLOADER_FORMAL_ADDR())\n                let paymaster := getPaymaster(innerTxDataOffset)\n\n                let payer := 0\n\n                switch paymaster\n                case 0 {\n                    payer := from\n\n                    // There is no paymaster, the user should pay for the execution.\n                    // Calling for the `payForTransaction` method of the account.\n                    setHook(VM_HOOK_ACCOUNT_VALIDATION_ENTERED())\n                    let res := accountPayForTx(from, txDataOffset)\n                    setHook(VM_HOOK_NO_VALIDATION_ENTERED())\n\n\n                    if iszero(res) {\n                        revertWithReason(\n                            PAY_FOR_TX_FAILED_ERR_CODE(),\n                            1\n                        )\n                    }\n                }   \n                default {\n                    // There is some paymaster present."
    }
  ]
}