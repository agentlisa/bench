{
  "Title": "[L-09] `wfCashERC4626` contract does not conform to `EIP4626`",
  "Content": "\nThe `wfCashERC4626` contract implements the `EIP4626` standard ([EIP-4626: Tokenized Vault Standard](https://eips.ethereum.org/EIPS/eip-4626)).\n\nHowever, according to `EIP4626`, the below-mentioned functions do not fully adhere to the specs. They possibly revert due to `require` checks or revert due to external calls reverting.\n\n### Findings\n\n[L47](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L47) - `function totalAssets() public view override returns (uint256)`\n\nPossibly reverts due to `_getMaturedValue` and `_getPresentValue` reverting.\n\n[L52](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L52) - `function convertToShares(uint256 assets) public view override returns (uint256 shares)`\n\nPossibly reverts due to `_getPresentValue` and `totalAssets` reverting.\n\n[L64](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L64) - `function convertToAssets(uint256 shares) public view override returns (uint256 assets)`\n\nPossibly reverts due to `_getPresentValue` and `totalAssets` reverting.\n\n[L85](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L85) - `function maxWithdraw(address owner) public view override returns (uint256)`\n\nPossibly reverts due to `convertToShares` within `previewWithdraw` reverting.\n\n### Recommended Mitigation Steps\n\nGiven the circumstances, in most of the mentioned cases, it's not possible to implement it without ever reverting. Nevertheless, I want to point out that this contract does not fully conform with the `EIP4626` standard.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-06-notional-coop",
  "Code": [
    {
      "filename": "notional-wrapped-fcash/contracts/wfCashERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./wfCashLogic.sol\";\nimport \"../interfaces/IERC4626.sol\";\n\ncontract wfCashERC4626 is IERC4626, wfCashLogic {\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashLogic(_notional, _weth) {}\n\n    /** @dev See {IERC4626-asset} */\n    function asset() public view override returns (address) {\n        (IERC20 underlyingToken, bool isETH) = getToken(true);\n        return isETH ? address(WETH) : address(underlyingToken);\n    }\n\n    function _getMaturedValue() private view returns (uint256) {\n        // If the fCash has matured we use the cash balance instead.\n        uint16 currencyId = getCurrencyId();\n        // We cannot settle an account in a view method, so this may fail if the account has not been settled\n        // after maturity. This can be done by anyone so it should not be an issue\n        (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\n        int256 underlyingExternal = NotionalV2.convertCashBalanceToExternal(currencyId, cashBalance, true);\n        require(underlyingExternal > 0, \"Must Settle\");\n\n        return uint256(underlyingExternal);\n    }\n\n    function _getPresentValue(uint256 fCashAmount) private view returns (uint256) {\n        (/* */, int256 precision) = getUnderlyingToken();\n        // Get the present value of the fCash held by the contract, this is returned in 8 decimal precision\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        int256 pvInternal = NotionalV2.getPresentfCashValue(\n            currencyId,\n            maturity,\n            int256(fCashAmount), // total supply cannot overflow as fCash overflows at uint88\n            block.timestamp,\n            false\n        );\n\n        int256 pvExternal = (pvInternal * precision) / Constants.INTERNAL_TOKEN_PRECISION;\n        // PV should always be >= 0 since we are lending\n        require(pvExternal >= 0);\n        return uint256(pvExternal);\n    }\n\n    /** @dev See {IERC4626-totalAssets} */\n    function totalAssets() public view override returns (uint256) {\n        return hasMatured() ?  _getMaturedValue() : _getPresentValue(totalSupply());\n    }\n\n    /** @dev See {IERC4626-convertToShares} */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Scales assets by the value of a single unit of fCash\n            uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));\n            return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;\n        }\n\n        return (assets * totalSupply()) / totalAssets();\n    }\n\n    /** @dev See {IERC4626-convertToAssets} */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Catch the edge case where totalSupply causes a divide by zero error\n            return _getPresentValue(shares);\n        }\n\n        return (shares * totalAssets()) / supply;\n    }\n\n    /** @dev See {IERC4626-maxDeposit} */\n    function maxDeposit(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint} */\n    function maxMint(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint88).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw} */\n    function maxWithdraw(address owner) public view override returns (uint256) {\n        return previewWithdraw(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4626-maxRedeem} */\n    function maxRedeem(address owner) public view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit} */\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 fCashAmount, /* */, /* */) = NotionalV2.getfCashLendFromDeposit(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n\n            return fCashAmount;\n        }\n    }\n\n    /** @dev See {IERC4626-previewMint} */\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 depositAmountUnderlying, /* */, /* */, /* */) = NotionalV2.getDepositFromfCashLend(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n\n            return depositAmountUnderlying;\n        }\n    }\n\n    /** @dev See {IERC4626-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        if (hasMatured()) {\n            shares = convertToShares(assets);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-previewRedeem} */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        if (hasMatured()) {\n            assets = convertToAssets(shares);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (assets, /* */, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-deposit} */\n    function deposit(uint256 assets, address receiver) public override returns (uint256) {\n        uint256 shares = previewDeposit(assets);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint} */\n    function mint(uint256 shares, address receiver) public override returns (uint256) {\n        uint256 assets = previewMint(shares);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw} */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        uint256 shares = previewWithdraw(assets);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem} */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        // It is more accurate and gas efficient to check the balance of the\n        // receiver here than rely on the previewRedeem method.\n        uint256 balanceBefore = IERC20(asset()).balanceOf(receiver);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        uint256 balanceAfter = IERC20(asset()).balanceOf(receiver);\n        uint256 assets = balanceAfter - balanceBefore;\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n        return assets;\n    }\n\n    function _redeemInternal(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) private {\n        bytes memory userData = abi.encode(\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: 0\n            })\n        );\n\n        // No operator data\n        _burn(owner, shares, userData, \"\");\n    }\n\n    function _safeNegInt88(uint256 x) private pure returns (int88) {\n        int256 y = -int256(x);\n        require(int256(type(int88).min) <= y);\n        return int88(y);\n    }\n}"
    },
    {
      "filename": "notional-wrapped-fcash/contracts/wfCashERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./wfCashLogic.sol\";\nimport \"../interfaces/IERC4626.sol\";\n\ncontract wfCashERC4626 is IERC4626, wfCashLogic {\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashLogic(_notional, _weth) {}\n\n    /** @dev See {IERC4626-asset} */\n    function asset() public view override returns (address) {\n        (IERC20 underlyingToken, bool isETH) = getToken(true);\n        return isETH ? address(WETH) : address(underlyingToken);\n    }\n\n    function _getMaturedValue() private view returns (uint256) {\n        // If the fCash has matured we use the cash balance instead.\n        uint16 currencyId = getCurrencyId();\n        // We cannot settle an account in a view method, so this may fail if the account has not been settled\n        // after maturity. This can be done by anyone so it should not be an issue\n        (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\n        int256 underlyingExternal = NotionalV2.convertCashBalanceToExternal(currencyId, cashBalance, true);\n        require(underlyingExternal > 0, \"Must Settle\");\n\n        return uint256(underlyingExternal);\n    }\n\n    function _getPresentValue(uint256 fCashAmount) private view returns (uint256) {\n        (/* */, int256 precision) = getUnderlyingToken();\n        // Get the present value of the fCash held by the contract, this is returned in 8 decimal precision\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        int256 pvInternal = NotionalV2.getPresentfCashValue(\n            currencyId,\n            maturity,\n            int256(fCashAmount), // total supply cannot overflow as fCash overflows at uint88\n            block.timestamp,\n            false\n        );\n\n        int256 pvExternal = (pvInternal * precision) / Constants.INTERNAL_TOKEN_PRECISION;\n        // PV should always be >= 0 since we are lending\n        require(pvExternal >= 0);\n        return uint256(pvExternal);\n    }\n\n    /** @dev See {IERC4626-totalAssets} */\n    function totalAssets() public view override returns (uint256) {\n        return hasMatured() ?  _getMaturedValue() : _getPresentValue(totalSupply());\n    }\n\n    /** @dev See {IERC4626-convertToShares} */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Scales assets by the value of a single unit of fCash\n            uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));\n            return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;\n        }\n\n        return (assets * totalSupply()) / totalAssets();\n    }\n\n    /** @dev See {IERC4626-convertToAssets} */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Catch the edge case where totalSupply causes a divide by zero error\n            return _getPresentValue(shares);\n        }\n\n        return (shares * totalAssets()) / supply;\n    }\n\n    /** @dev See {IERC4626-maxDeposit} */\n    function maxDeposit(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint} */\n    function maxMint(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint88).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw} */\n    function maxWithdraw(address owner) public view override returns (uint256) {\n        return previewWithdraw(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4626-maxRedeem} */\n    function maxRedeem(address owner) public view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit} */\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 fCashAmount, /* */, /* */) = NotionalV2.getfCashLendFromDeposit(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n\n            return fCashAmount;\n        }\n    }\n\n    /** @dev See {IERC4626-previewMint} */\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 depositAmountUnderlying, /* */, /* */, /* */) = NotionalV2.getDepositFromfCashLend(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n\n            return depositAmountUnderlying;\n        }\n    }\n\n    /** @dev See {IERC4626-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        if (hasMatured()) {\n            shares = convertToShares(assets);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-previewRedeem} */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        if (hasMatured()) {\n            assets = convertToAssets(shares);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (assets, /* */, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-deposit} */\n    function deposit(uint256 assets, address receiver) public override returns (uint256) {\n        uint256 shares = previewDeposit(assets);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint} */\n    function mint(uint256 shares, address receiver) public override returns (uint256) {\n        uint256 assets = previewMint(shares);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw} */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        uint256 shares = previewWithdraw(assets);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem} */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        // It is more accurate and gas efficient to check the balance of the\n        // receiver here than rely on the previewRedeem method.\n        uint256 balanceBefore = IERC20(asset()).balanceOf(receiver);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        uint256 balanceAfter = IERC20(asset()).balanceOf(receiver);\n        uint256 assets = balanceAfter - balanceBefore;\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n        return assets;\n    }\n\n    function _redeemInternal(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) private {\n        bytes memory userData = abi.encode(\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: 0\n            })\n        );\n\n        // No operator data\n        _burn(owner, shares, userData, \"\");\n    }\n\n    function _safeNegInt88(uint256 x) private pure returns (int88) {\n        int256 y = -int256(x);\n        require(int256(type(int88).min) <= y);\n        return int88(y);\n    }\n}"
    },
    {
      "filename": "notional-wrapped-fcash/contracts/wfCashERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./wfCashLogic.sol\";\nimport \"../interfaces/IERC4626.sol\";\n\ncontract wfCashERC4626 is IERC4626, wfCashLogic {\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashLogic(_notional, _weth) {}\n\n    /** @dev See {IERC4626-asset} */\n    function asset() public view override returns (address) {\n        (IERC20 underlyingToken, bool isETH) = getToken(true);\n        return isETH ? address(WETH) : address(underlyingToken);\n    }\n\n    function _getMaturedValue() private view returns (uint256) {\n        // If the fCash has matured we use the cash balance instead.\n        uint16 currencyId = getCurrencyId();\n        // We cannot settle an account in a view method, so this may fail if the account has not been settled\n        // after maturity. This can be done by anyone so it should not be an issue\n        (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\n        int256 underlyingExternal = NotionalV2.convertCashBalanceToExternal(currencyId, cashBalance, true);\n        require(underlyingExternal > 0, \"Must Settle\");\n\n        return uint256(underlyingExternal);\n    }\n\n    function _getPresentValue(uint256 fCashAmount) private view returns (uint256) {\n        (/* */, int256 precision) = getUnderlyingToken();\n        // Get the present value of the fCash held by the contract, this is returned in 8 decimal precision\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        int256 pvInternal = NotionalV2.getPresentfCashValue(\n            currencyId,\n            maturity,\n            int256(fCashAmount), // total supply cannot overflow as fCash overflows at uint88\n            block.timestamp,\n            false\n        );\n\n        int256 pvExternal = (pvInternal * precision) / Constants.INTERNAL_TOKEN_PRECISION;\n        // PV should always be >= 0 since we are lending\n        require(pvExternal >= 0);\n        return uint256(pvExternal);\n    }\n\n    /** @dev See {IERC4626-totalAssets} */\n    function totalAssets() public view override returns (uint256) {\n        return hasMatured() ?  _getMaturedValue() : _getPresentValue(totalSupply());\n    }\n\n    /** @dev See {IERC4626-convertToShares} */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Scales assets by the value of a single unit of fCash\n            uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));\n            return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;\n        }\n\n        return (assets * totalSupply()) / totalAssets();\n    }\n\n    /** @dev See {IERC4626-convertToAssets} */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Catch the edge case where totalSupply causes a divide by zero error\n            return _getPresentValue(shares);\n        }\n\n        return (shares * totalAssets()) / supply;\n    }\n\n    /** @dev See {IERC4626-maxDeposit} */\n    function maxDeposit(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint} */\n    function maxMint(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint88).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw} */\n    function maxWithdraw(address owner) public view override returns (uint256) {\n        return previewWithdraw(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4626-maxRedeem} */\n    function maxRedeem(address owner) public view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit} */\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 fCashAmount, /* */, /* */) = NotionalV2.getfCashLendFromDeposit(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n\n            return fCashAmount;\n        }\n    }\n\n    /** @dev See {IERC4626-previewMint} */\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 depositAmountUnderlying, /* */, /* */, /* */) = NotionalV2.getDepositFromfCashLend(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n\n            return depositAmountUnderlying;\n        }\n    }\n\n    /** @dev See {IERC4626-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        if (hasMatured()) {\n            shares = convertToShares(assets);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-previewRedeem} */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        if (hasMatured()) {\n            assets = convertToAssets(shares);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (assets, /* */, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-deposit} */\n    function deposit(uint256 assets, address receiver) public override returns (uint256) {\n        uint256 shares = previewDeposit(assets);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint} */\n    function mint(uint256 shares, address receiver) public override returns (uint256) {\n        uint256 assets = previewMint(shares);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw} */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        uint256 shares = previewWithdraw(assets);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem} */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        // It is more accurate and gas efficient to check the balance of the\n        // receiver here than rely on the previewRedeem method.\n        uint256 balanceBefore = IERC20(asset()).balanceOf(receiver);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        uint256 balanceAfter = IERC20(asset()).balanceOf(receiver);\n        uint256 assets = balanceAfter - balanceBefore;\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n        return assets;\n    }\n\n    function _redeemInternal(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) private {\n        bytes memory userData = abi.encode(\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: 0\n            })\n        );\n\n        // No operator data\n        _burn(owner, shares, userData, \"\");\n    }\n\n    function _safeNegInt88(uint256 x) private pure returns (int88) {\n        int256 y = -int256(x);\n        require(int256(type(int88).min) <= y);\n        return int88(y);\n    }\n}"
    },
    {
      "filename": "notional-wrapped-fcash/contracts/wfCashERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./wfCashLogic.sol\";\nimport \"../interfaces/IERC4626.sol\";\n\ncontract wfCashERC4626 is IERC4626, wfCashLogic {\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashLogic(_notional, _weth) {}\n\n    /** @dev See {IERC4626-asset} */\n    function asset() public view override returns (address) {\n        (IERC20 underlyingToken, bool isETH) = getToken(true);\n        return isETH ? address(WETH) : address(underlyingToken);\n    }\n\n    function _getMaturedValue() private view returns (uint256) {\n        // If the fCash has matured we use the cash balance instead.\n        uint16 currencyId = getCurrencyId();\n        // We cannot settle an account in a view method, so this may fail if the account has not been settled\n        // after maturity. This can be done by anyone so it should not be an issue\n        (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\n        int256 underlyingExternal = NotionalV2.convertCashBalanceToExternal(currencyId, cashBalance, true);\n        require(underlyingExternal > 0, \"Must Settle\");\n\n        return uint256(underlyingExternal);\n    }\n\n    function _getPresentValue(uint256 fCashAmount) private view returns (uint256) {\n        (/* */, int256 precision) = getUnderlyingToken();\n        // Get the present value of the fCash held by the contract, this is returned in 8 decimal precision\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        int256 pvInternal = NotionalV2.getPresentfCashValue(\n            currencyId,\n            maturity,\n            int256(fCashAmount), // total supply cannot overflow as fCash overflows at uint88\n            block.timestamp,\n            false\n        );\n\n        int256 pvExternal = (pvInternal * precision) / Constants.INTERNAL_TOKEN_PRECISION;\n        // PV should always be >= 0 since we are lending\n        require(pvExternal >= 0);\n        return uint256(pvExternal);\n    }\n\n    /** @dev See {IERC4626-totalAssets} */\n    function totalAssets() public view override returns (uint256) {\n        return hasMatured() ?  _getMaturedValue() : _getPresentValue(totalSupply());\n    }\n\n    /** @dev See {IERC4626-convertToShares} */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Scales assets by the value of a single unit of fCash\n            uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));\n            return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;\n        }\n\n        return (assets * totalSupply()) / totalAssets();\n    }\n\n    /** @dev See {IERC4626-convertToAssets} */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Catch the edge case where totalSupply causes a divide by zero error\n            return _getPresentValue(shares);\n        }\n\n        return (shares * totalAssets()) / supply;\n    }\n\n    /** @dev See {IERC4626-maxDeposit} */\n    function maxDeposit(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint} */\n    function maxMint(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint88).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw} */\n    function maxWithdraw(address owner) public view override returns (uint256) {\n        return previewWithdraw(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4626-maxRedeem} */\n    function maxRedeem(address owner) public view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit} */\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 fCashAmount, /* */, /* */) = NotionalV2.getfCashLendFromDeposit(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n\n            return fCashAmount;\n        }\n    }\n\n    /** @dev See {IERC4626-previewMint} */\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 depositAmountUnderlying, /* */, /* */, /* */) = NotionalV2.getDepositFromfCashLend(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n\n            return depositAmountUnderlying;\n        }\n    }\n\n    /** @dev See {IERC4626-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        if (hasMatured()) {\n            shares = convertToShares(assets);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(\n                currencyId,\n                assets,"
    }
  ]
}