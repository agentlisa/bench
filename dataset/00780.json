{
  "Title": "M-14: `wfCashERC4626`",
  "Content": "# Issue M-14: `wfCashERC4626` \n\nSource: https://github.com/sherlock-audit/2023-12-notional-update-5-judging/issues/58 \n\n## Found by \neol\n## Summary\nThe `wfCash` vault is credited less prime cash than the `wfCash` it mints to the depositor when its underlying asset is a fee-on-transfer token. This leads to the vault being insolvent because it has issued more shares than can be redeemed. \n\n## Vulnerability Detail\nWhen minting `wfCash` shares more than the `maxFCash` available, the `wfCashERC4626` vault lends the deposited assets at 0% interest. The assets are deposited by the vault into Notional and the depositor gets 1:1 `wfCash` in return. This works fine for assets that are not fee-on-transfer tokens. \nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/wrapped-fcash/contracts/wfCashLogic.sol#L60-L68\n```solidity\n    if (maxFCash < fCashAmount) {\n        // NOTE: lending at zero\n        uint256 fCashAmountExternal = fCashAmount * precision / uint256(Constants.INTERNAL_TOKEN_PRECISION);\n        require(fCashAmountExternal <= depositAmountExternal);\n\n        // NOTE: Residual (depositAmountExternal - fCashAmountExternal) will be transferred\n        // back to the account\n        NotionalV2.depositUnderlyingToken{value: msgValue}(address(this), currencyId, fCashAmountExternal);\n    } else if (isETH || hasTransferFee || getCashBalance() > 0) {\n```\nFor fee-on-transfer tokens, the vault is credited prime cash based on the actual amount it received, which is `deposit amount - transfer fee`. \nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/internal/balances/TokenHandler.sol#L204-L214\n```solidity\n        } else {\n            // In the case of deposits, we use a balance before and after check\n            // to ensure that we record the proper balance change.\n            actualTransferExternal = GenericToken.safeTransferIn(\n                underlying.tokenAddress, account, underlyingExternalDeposit\n            ).toInt();\n        }\n\n        netPrimeSupplyChange = _postTransferPrimeCashUpdate(\n            account, currencyId, actualTransferExternal, underlying, primeRate\n        );\n```\n\nHowever, the vault mints `fCashAmount` of shares to the depositor. \nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/wrapped-fcash/contracts/wfCashLogic.sol#L84-L85\n```solidity\n    // Mints ERC20 tokens for the receiver\n    _mint(receiver, fCashAmount);\n```\n\nIn the case of lending at 0% interest, `fCashAmount` is equal to `depositAmount` but at 1e8 precision. \n\nTo simplify the example, let us assume that there are no other depositors. When the sole depositor redeems all their `wfCash` shares at maturity, they will be unable to redeem all their shares because the `wfCash` vault does not hold enough prime cash.\n\n## Impact\nAlthough the example used to display the vulnerability is for the case of lending at 0% interest, the issue exists for minting any amount of shares. \n\nThe `wfCashERC4626` vault will become insolvent and unable to buy back all shares. The larger the total amount deposited, the larger the deficit. The deficit is equal to the transfer fee. Given a total deposit amount of 100M USDT and a transfer fee of 2% (assuming a transfer fee was set and enabled for USDT), 2M USDT will be the deficit. \n\nThe last depositors to redeem their shares will be shouldering the loss.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/wrapped-fcash/contracts/wfCashLogic.sol#L60-L68\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/internal/balances/TokenHandler.sol#L204-L214\nhttps://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/wrapped-fcash/contracts/wfCashLogic.sol#L84-L85\n\n## Tool used\nManual Review\n\n## Recommendation\nConsider adding the following:\n1. A flag in `wfCashERC4626` that signals that the vault's asset is a fee-on-transfer token. \n2. In `wfCashERC4626._previewMint()` and `wfCashERC46262._previewDeposit`, all calculations related to `assets` should account for the transfer fee of the token.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  vlaid because { This is valid and a duplicate of 016 due to the same underlying cause of zero lending }\n\n\n\n**jeffywu**\n\nI think the issue is valid, although the contention that the vault becomes insolvent is not completely true. When lending at 0% interest the vault also accrues variable rate interest, which may or may not accrue sufficient value to recover the loss from the transfer fee.\n\nAgree that some sort of flag here would be appropriate to ensure that these tokens do not trigger an immediate loss is appropriate.\n\n**jeffywu**\n\nFix will be that we do not allow tokens with fee on transfer to perform lend at zero.\n\n**gjaldon**\n\nEscalate\n\n> I think the issue is valid, although the contention that the vault becomes insolvent is not completely true. When lending at 0% interest the vault also accrues variable rate interest, which may or may not accrue sufficient value to recover the loss from the transfer fee.\n\nI think this is a High because the vault still stays insolvent even when the vault accrues variable rate interest. This is because any variable rate interest accrual is only applied to the prime cash's exchange rate (like a cToken.) \n\nThe issue here is that the total `wfCash` minted is supposed to be 1:1 with the vault's primeCash balance in Notional. However, there is more `wfCash` minted than the vault's prime cash balance in Notional because the Vault's `wfCash` minting does not subtract the transfer fees when computing for the amount to mint, which leads to the discrepancy.\n\nAny variable interest rate accrual will not increase the prime cash balance of the Vault because it is non-rebasing. That means that the Vault's prime cash balance in Notional will not increase due to accrual and it will remain less than the Vault's total `wfCash` minted and the vault will remain insolvent.\n\nFor example:\nVault `wfCash` supply - 1000\nVault's prime cash balance in Notional - 975 (1000 - 2.5% transfer fee)\nVariable interest rate accrual - increases the exchange rate from, for example, 110% to 115%\n\nTotal `wfCash` that can be redeemed is still capped at 975 even with the variable interest rate accrual. Vault remains insolvent because not all shares can be redeemed.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> > I think the issue is valid, although the contention that the vault becomes insolvent is not completely true. When lending at 0% interest the vault also accrues variable rate interest, which may or may not accrue sufficient value to recover the loss from the transfer fee.\n> \n> I think this is a High because the vault still stays insolvent even when the vault accrues variable rate interest. This is because any variable rate interest accrual is only applied to the prime cash's exchange rate (like a cToken.) \n> \n> The issue here is that the total `wfCash` minted is supposed to be 1:1 with the vault's primeCash balance in Notional. However, there is more `wfCash` minted than the vault's prime cash balance in Notional because the Vault's `wfCash` minting does not subtract the transfer fees when computing for the amount to mint, which leads to the discrepancy.\n> \n> Any variable interest rate accrual will not increase the prime cash balance of the Vault because it is non-rebasing. That means that the Vault's prime cash balance in Notional will not increase due to accrual and it will remain less than the Vault's total `wfCash` minted and the vault will remain insolvent.\n> \n> For example:\n> Vault `wfCash` supply - 1000\n> Vault's prime cash balance in Notional - 975 (1000 - 2.5% transfer fee)\n> Variable interest rate accrual - increases the exchange rate from, for example, 110% to 115%\n> \n> Total `wfCash` that can be redeemed is still capped at 975 even with the variable interest rate accrual. Vault remains insolvent because not all shares can be redeemed.\n\nThe escalation could not be created because you are not exceeding the escalation threshold.\n\nYou can view the required number of additional valid issues/judging contest payouts in your Profile page,\nin the [Sherlock webapp](https://app.sherlock.xyz/audits/).\n\n\n**JeffCX**\n\nEscalate\n\n> I think the issue is valid, although the contention that the vault becomes insolvent is not completely true. When lending at 0% interest the vault also accrues variable rate interest, which may or may not accrue sufficient value to recover the loss from the transfer fee.\n\nI think this is a High because the vault still stays insolvent even when the vault accrues variable rate interest. This is because any variable rate interest accrual is only applied to the prime cash's exchange rate (like a cToken.)\n\nThe issue here is that the total wfCash minted is supposed to be 1:1 with the vault's primeCash balance in Notional. However, there is more wfCash minted than the vault's prime cash balance in Notional because the Vault's wfCash minting does not subtract the transfer fees when computing for the amount to mint, which leads to the discrepancy.\n\nAny variable interest rate accrual will not increase the prime cash balance of the Vault because it is non-rebasing. That means that the Vault's prime cash balance in Notional will not increase due to accrual and it will remain less than the Vault's total wfCash minted and the vault will remain insolvent.\n\nFor example:\nVault wfCash supply - 1000\nVault's prime cash balance in Notional - 975 (1000 - 2.5% transfer fee)\nVariable interest rate accrual - increases the exchange rate from, for example, 110% to 115%\n\nTotal wfCash that can be redeemed is still capped at 975 even with the variable interest rate accrual. Vault remains insolvent because not all shares can be redeemed.\n\n\n**sherlock-admin2**\n\n> Escalate\n> \n> > I think the issue is valid, although the contention that the vault becomes insolvent is not completely true. When lending at 0% interest the vault also accrues variable rate interest, which may or may not accrue sufficient value to recover the loss from the transfer fee.\n> \n> I think this is a High because the vault still stays insolvent even when the vault accrues variable rate interest. This is because any variable rate interest accrual is only applied to the prime cash's exchange rate (like a cToken.)\n> \n> The issue here is that the total wfCash minted is supposed to be 1:1 with the vault's primeCash balance in Notional. However, there is more wfCash minted than the vault's prime cash balance in Notional because the Vault's wfCash minting does not subtract the transfer fees when computing for the amount to mint, which leads to the discrepancy.\n> \n> Any variable interest rate accrual will not increase the prime cash balance of the Vault because it is non-rebasing. That means that the Vault's prime cash balance in Notional will not increase due to accrual and it will remain less than the Vault's total wfCash minted and the vault will remain insolvent.\n> \n> For example:\n> Vault wfCash supply - 1000\n> Vault's prime cash balance in Notional - 975 (1000 - 2.5% transfer fee)\n> Variable interest rate accrual - increases the exchange rate from, for example, 110% to 115%\n> \n> Total wfCash that can be redeemed is still capped at 975 even with the variable interest rate accrual. Vault remains insolvent because not all shares can be redeemed.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**jeffywu**\n\nI won't opine the severity of the issue but I will say the understanding of the prime cash balance is not entirely correct in the escalation comment:\n\nfCash is denominated in underlying (i.e. 1 fETH = 1 ETH at maturity) while prime cash is a non-rebasing token with a monotonically increasing exchange rate to ETH. If we mint 1 fETH \"share\" while lending at zero interest but only deposit 0.975 ETH worth of pCash prior to maturity...it would be appropriate to say that the vault is insolvent at this moment in time.\n\nHowever, if the 0.975 ETH worth of pCash accrues interest over X days and is now worth 1 ETH and no other deposits / withdraws occur, the vault is no longer insolvent. The rebasing / non-rebasing nature of pCash does not affect the solvency issue, the vault has full access to the underlying value of the pCash to accommodate withdraws.\n\n**gjaldon**\n\n@jeffywu isn't it that a positive cash balance is non-rebasing and any interest accruals do not change the account's cash balance? If I'm not mistaken, any interest accruals only change the prime cash factors:\nref: https://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/internal/pCash/PrimeCashExchangeRate.sol#L589-L613\n```solidity\n    function getPrimeCashRateStateful(\n        uint16 currencyId,\n        uint256 blockTime\n    ) internal returns (PrimeRate memory rate) {\n        PrimeCashFactors memory factors = getPrimeCashFactors(currencyId);\n\n        // Only accrue if the block time has increased\n        if (factors.lastAccrueTime < blockTime) {\n            uint256 primeSupplyToReserve;\n            uint256 currentUnderlyingValue = getTotalUnderlyingStateful(currencyId);\n            (factors, primeSupplyToReserve) = _updatePrimeCashScalars(\n                currencyId, factors, currentUnderlyingValue, blockTime\n            );\n            _setPrimeCashFactorsOnAccrue(currencyId, primeSupplyToReserve, factors);\n        } else {\n            require(factors.lastAccrueTime == blockTime); // dev: revert invalid blocktime\n        }\n\n        rate = PrimeRate({\n            supplyFactor: factors.supplyScalar.mul(factors.underlyingScalar).toInt(),\n            debtFactor: factors.debtScalar.mul(factors.underlyingScalar).toInt(),\n            oracleSupplyRate: factors.oracleSupplyRate\n        });\n    }\n```\n\n`_updatePrimeCashScalars()` computes the interest accrual and updates the factors. `PrimeRate.supplyFactor` is the exchange rate that's used to compute for the total ETH that can be withdrawn.\n\nGiven a Vault that had deposited 1000 tokens into pCash and the following are true:\n\nVault has 1000 wfCash total supply\nVault has pCash balance of 975 in Notional (1000 - 2.5% transfer fee)\nPR.supplyFactor is 100%\n\nLet's say the PR.supplyFactor has increased to 120% due to interest accrual. When the Vault withdraws, it calls `AccountAction.withdraw()` which also ends up calling [`BalanceHandler._finalize()`](https://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/internal/balances/BalanceHandler.sol#L164-L204). \n\n```solidity\n        transferAmountExternal = TokenHandler.withdrawPrimeCash(\n            account,\n            receiver,\n            balanceState.currencyId,\n            balanceState.primeCashWithdraw,\n            balanceState.primeRate,\n            withdrawWrapped // if true, withdraws ETH as WETH\n        );\n\n        {\n            // No changes to total cash after this point\n            int256 totalCashChange = balanceState.netCashChange.add(balanceState.primeCashWithdraw);\n           \n            if (\n                checkAllowPrimeBorrow &&\n                totalCashChange < 0 &&\n                balanceState.storedCashBalance.add(totalCashChange) < 0\n            ) {\n                // ... snip ...\n                require(accountContext.allowPrimeBorrow, \"No Prime Borrow\");\n                checkDebtCap = true;\n            }\n\n            if (totalCashChange != 0) {\n                balanceState.storedCashBalance = balanceState.storedCashBalance.add(totalCashChange);\n                mustUpdate = true;\n            }\n        }\n```\n\nIn `BalanceHandler.finalize()`, `balanceState.primeCashWithdraw` is the amount being withdrawn, which is -1000 (all the wfCash supply.) It is negative since withdrawal amounts are turned negative to represent decrease in cash balance. `totalCashChange` will be equal to `balanceState.primeCashWithdraw`, which is -1000. `balanceState.storedCashBalance` will be the Vault's cash  balance of 975. Adding both will result in -25 and will lead to the `\"No Prime Borrow\"` revert since there is not enough cash balance for the withdrawal and prime borrowing is not enabled for the vault.\n\nIn [`TokenHandler.withdrawPrimeCash()`](https://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/internal/balances/TokenHandler.sol#L236-L240) is where the exchange rate is applied so that we get the principal plus the interest accrual. \n\n```solidity\n// TokenHandler.withdrawPrimeCash()\n\n    Token memory underlying = getUnderlyingToken(currencyId);\n    netTransferExternal = convertToExternal(\n        underlying, \n        primeRate.convertToUnderlying(primeCashToWithdraw) \n    );\n```\n\n[`primeRate.convertToUnderlying`](https://github.com/sherlock-audit/2023-12-notional-update-5/blob/main/contracts-v3/contracts/internal/pCash/PrimeRateLib.sol#L300-L306) converts the prime cash value (principal) into its accrued value (principal + interest accrual.) \n\n```solidity\n    function convertToUnderlying(\n        PrimeRate memory pr,\n        int256 primeCashBalance\n    ) internal pure returns (int256) {\n        int256 result = primeCashBalance.mul(pr.supplyFactor).div(Constants.DOUBLE_SCALAR_PRECISION);\n        return primeCashBalance < 0 ? SafeInt256.min(result, -1) : result;\n    }\n```\n\nWe see above how `primeRate.supplyFactor`, which is an exchange rate that represents interest accrual for lending, is multiplied to the prime cash balance. \n\nI think the details above show that the  prime cash balance (`balanceState.storedCashBalance`) does not increase due to interest accrual. With the example above, it will stay at 975 even when interest accrues. This is because interest accruals are only applied to the Prime Cash factors and do not modify every account's cash balances, which would be expensive.\n\nAm I missing anything @jeffywu?\n\n**jeffywu**\n\nYeah, but 0.975 pETH units can be worth 1 ETH which is what is required for the vault to be solvent. If you call withdraw and expect to get 1 ETH, the vault will be able to satisfy the request and therefore it would be solvent.\n\n**gjaldon**\n\nI see. I think the user would expect interest accrual to make their 1 ETH larger than 1 ETH. Also, even though 0.975 pETH can become 1 ETH eventually due to variable interest accrual, there is still the 0.025 pETH that can not be redeemed. A Vault is insolvent when all of its shares can not be redeemed. When there are multiple depositors, this can lead to situations where the last depositor to withdraw will be unable to withdraw any assets.\n\n**jeffywu**\n\nWell the user could only expect up to 1 ETH because they have a claim on 1\nfETH. They are not lending variable they are lending fixed\n\nOn Mon, Feb 5, 2024 at 4:06 PM G ***@***.***> wrote:\n\n> I see. I think the user would expect interest accrual to make their 1 ETH\n> larger than 1 ETH. Also, even though 0.975 pETH can become 1 ETH eventually\n> due to variable interest accrual, there is still the 0.025 pETH that can\n> not be redeemed. A Vault is insolvent when all of its shares can not be\n> redeemed. When there are multiple depositors, this can lead to situations\n> where the last depositor to withdraw will be unable to withdraw any assets.\n>\n> —\n> Reply to this email directly, view it on GitHub\n> <https://github.com/sherlock-audit/2023-12-notional-update-5-judging/issues/58#issuecomment-1928538045>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAHOUGSOW62TRY3ZX3MLMDTYSFXX5AVCNFSM6AAAAABCAQ65JCVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTSMRYGUZTQMBUGU>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> <sherlock-audit/2023-12-notional-update-5-judging/issues/58/1928538045@\n> github.com>\n>\n\n\n**gjaldon**\n\nFair point. I think you are looking at it from the perspective of calling `Vault.withdraw()` where the user sets the amount of assets to be withdrawn. When using `Vault.redeem()`, the user sets the amount of shares to be redeemed. In this case, the amount to be redeemed would be the total shares of 1000. This is what I mean by insolvency, since only up to 975 shares can be redeemed and not all the shares are redeemable.\n\nThank you for the time and the discussion @jeffywu. I appreciate it and will do my best to carry over all my learnings to future Notional contests. \n\n**Evert0x**\n\nPlanning to reject escalation and keep issue state as is @gjaldon \n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [JEFFCX](https://github.com/sherlock-audit/2023-12-notional-update-5-judging/issues/58/#issuecomment-1926889075): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/142",
  "Code": [
    {
      "filename": "wrapped-fcash/contracts/wfCashLogic.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\npragma experimental ABIEncoderV2;\n\nimport \"./wfCashBase.sol\";\nimport \"@openzeppelin-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n\n/// @dev This implementation contract is deployed as an UpgradeableBeacon. Each BeaconProxy\n/// that uses this contract as an implementation will call initialize to set its own fCash id.\n/// That identifier will represent the fCash that this ERC20 wrapper can hold.\nabstract contract wfCashLogic is wfCashBase, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\n\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashBase(_notional, _weth) {}\n\n    /***** Mint Methods *****/\n\n    /// @notice Lends deposit amount in return for fCashAmount using underlying tokens\n    /// @param depositAmountExternal amount of cash to deposit into this method\n    /// @param fCashAmount amount of fCash to purchase (lend)\n    /// @param receiver address to receive the fCash shares\n    /// @param minImpliedRate minimum annualized interest rate to lend at\n    function mintViaUnderlying(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate\n    ) external override {\n        (/* */, uint256 maxFCash) = getTotalFCashAvailable();\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, maxFCash);\n    }\n\n    function _mintInternal(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate,\n        uint256 maxFCash\n    ) internal nonReentrant {\n        require(!hasMatured(), \"fCash matured\");\n        (IERC20 token, bool isETH, bool hasTransferFee, uint256 precision) = _getTokenForMintInternal();\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n        uint256 msgValue;\n        uint16 currencyId = getCurrencyId();\n        \n        if (isETH) {\n            // Use WETH if lending ETH. Although Notional natively supports ETH, we use WETH here for integration\n            // contracts so they only have to support ERC20 token transfers.\n            // NOTE: safeTransferFrom not required since WETH is known to be compatible\n            IERC20((address(WETH))).transferFrom(msg.sender, address(this), depositAmountExternal);\n            WETH.withdraw(depositAmountExternal);\n            msgValue = depositAmountExternal;\n        } else {\n            token.safeTransferFrom(msg.sender, address(this), depositAmountExternal);\n            depositAmountExternal = token.balanceOf(address(this)) - balanceBefore;\n        }\n\n        if (maxFCash < fCashAmount) {\n            // NOTE: lending at zero\n            uint256 fCashAmountExternal = fCashAmount * precision / uint256(Constants.INTERNAL_TOKEN_PRECISION);\n            require(fCashAmountExternal <= depositAmountExternal);\n\n            // NOTE: Residual (depositAmountExternal - fCashAmountExternal) will be transferred\n            // back to the account\n            NotionalV2.depositUnderlyingToken{value: msgValue}(address(this), currencyId, fCashAmountExternal);\n        } else if (isETH || hasTransferFee || getCashBalance() > 0) {\n            _lendLegacy(currencyId, depositAmountExternal, fCashAmount, minImpliedRate, msgValue, isETH);\n        } else {\n            // Executes a lending action on Notional. Since this lending action uses an existing cash balance\n            // prior to pulling payment, we cannot use it if there is a cash balance on the wrapper contract,\n            // it will cause existing cash balances to be minted into fCash and create a shortfall. In normal\n            // conditions, this method is more gas efficient.\n            BatchLend[] memory action = EncodeDecode.encodeLendTrade(\n                currencyId,\n                getMarketIndex(),\n                fCashAmount,\n                minImpliedRate\n            );\n            NotionalV2.batchLend(address(this), action);\n        }\n\n        // Mints ERC20 tokens for the receiver\n        _mint(receiver, fCashAmount);\n\n        // Residual tokens will be sent back to msg.sender, not the receiver. The msg.sender\n        // was used to transfer tokens in and these are any residual tokens left that were not\n        // lent out. Sending these tokens back to the receiver risks them getting locked on a\n        // contract that does not have the capability to transfer them off\n        _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);\n    }\n\n    function _lendLegacy(\n        uint16 currencyId,\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        uint32 minImpliedRate,\n        uint256 msgValue,\n        bool isETH\n    ) internal {\n        // If dealing in ETH, we use WETH in the wrapper instead of ETH. NotionalV2 uses\n        // ETH natively but due to pull payment requirements for batchLend, it does not support\n        // ETH. batchLend only supports ERC20 tokens. Since the wrapper is a compatibility\n        // layer, it will support WETH so integrators can deal solely in ERC20 tokens. Instead of using\n        // \"batchLend\" we will use \"batchBalanceActionWithTrades\". The difference is that \"batchLend\"\n        // is more gas efficient.\n\n        // If deposit amount external is in excess of the cost to purchase fCash amount (often the case),\n        // then we need to return the difference between postTradeCash - preTradeCash. This is done because\n        // the encoded trade does not automatically withdraw the entire cash balance in case the wrapper\n        // is holding a cash balance.\n        uint256 preTradeCash = getCashBalance();\n\n        BalanceActionWithTrades[] memory action = EncodeDecode.encodeLegacyLendTrade(\n            currencyId,\n            getMarketIndex(),\n            depositAmountExternal,\n            fCashAmount,\n            minImpliedRate\n        );\n        // Notional will return any residual ETH as the native token. When we _sendTokensToReceiver those\n        // native ETH tokens will be wrapped back to WETH.\n        NotionalV2.batchBalanceAndTradeAction{value: msgValue}(address(this), action);\n\n        uint256 postTradeCash = getCashBalance();\n\n        if (preTradeCash != postTradeCash) {\n            // If ETH, then redeem to WETH (redeemToUnderlying == false)\n            NotionalV2.withdraw(currencyId, _safeUint88(postTradeCash - preTradeCash), !isETH);\n        }\n    }\n\n    /// @notice This hook will be called every time this contract receives fCash, will validate that\n    /// this is the correct fCash and then mint the corresponding amount of wrapped fCash tokens\n    /// back to the user.\n    function onERC1155Received(\n        address /* _operator */,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata /* _data */\n    ) external nonReentrant returns (bytes4) {\n        uint256 fCashID = getfCashId();\n        // Only accept erc1155 transfers from NotionalV2\n        require(msg.sender == address(NotionalV2), \"Invalid\");\n        // Only accept the fcash id that corresponds to the listed currency and maturity\n        require(_id == fCashID, \"Invalid\");\n        // Protect against signed value underflows\n        require(int256(_value) > 0, \"Invalid\");\n\n        // Double check the account's position, these are not strictly necessary and add gas costs\n        // but might be good safe guards\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n        PortfolioAsset[] memory assets = NotionalV2.getAccountPortfolio(address(this));\n        require(ac.hasDebt == 0x00);\n        require(assets.length == 1);\n        require(EncodeDecode.encodeERC1155Id(\n                assets[0].currencyId,\n                assets[0].maturity,\n                assets[0].assetType) == fCashID\n        );\n\n        // Mint ERC20 tokens for the sender\n        _mint(_from, _value);\n\n        // This will allow the fCash to be accepted\n        return ERC1155_ACCEPTED;\n    }\n\n    /***** Redeem (Burn) Methods *****/\n\n    /// @notice Redeems tokens using custom options\n    /// @dev re-entrancy is protected on _burn\n    function redeem(uint256 amount, RedeemOpts memory opts) external override {\n        _burnInternal(msg.sender, amount, opts);\n    }\n\n    /// @notice Redeems tokens to underlying\n    /// @dev re-entrancy is protected on _burn\n    function redeemToUnderlying(\n        uint256 amount,\n        address receiver,\n        uint32 maxImpliedRate\n    ) external override {\n        _burnInternal(\n            msg.sender,\n            amount,\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: maxImpliedRate\n            })\n        );\n    }\n\n    /// @notice This method is here only in the case where someone has transferred invalid fCash\n    /// to the contract and would prevent ERC1155 transfer hooks from succeeding. In this case the\n    /// owner can recover the invalid fCash to a designated receiver. This can only occur if the fCash\n    /// is transferred prior to contract creation.\n    function recoverInvalidfCash(uint256 fCashId, address receiver) external {\n        // Only the Notional owner can call this method\n        require(msg.sender == NotionalV2.owner());\n        // Cannot transfer the native fCash id of this wrapper\n        require(fCashId != getfCashId());\n        uint256 balance = NotionalV2.balanceOf(address(this), fCashId);\n        // There should be a positive balance before we try to transfer this\n        require(balance > 0);\n        NotionalV2.safeTransferFrom(address(this), receiver, fCashId, balance, \"\");\n        \n        // Double check that we don't incur debt\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n        require(ac.hasDebt == 0x00);\n    }\n\n    /// @notice Called before tokens are burned (redemption) and so we will handle\n    /// the fCash properly before and after maturity.\n    function _burnInternal(\n        address from,\n        uint256 fCashShares,\n        RedeemOpts memory opts\n    ) internal nonReentrant {\n        require(opts.receiver != address(0), \"Receiver is zero address\");\n        require(opts.redeemToUnderlying || opts.transferfCash);\n        // This will validate that the account has sufficient tokens to burn and make\n        // any relevant underlying stateful changes to balances.\n        super._burn(from, fCashShares);\n\n        if (hasMatured()) {\n            require(opts.transferfCash == false);\n            // If the fCash has matured, then we need to ensure that the account is settled\n            // and then we will transfer back the account's share of asset tokens.\n\n            // This is a noop if the account is already settled, it is cheaper to call this method than\n            // cache it in storage locally\n            NotionalV2.settleAccount(address(this));\n            uint16 currencyId = getCurrencyId();\n            uint256 primeCashClaim = _getMaturedCashValue(fCashShares);\n\n            // Transfer withdrawn tokens to the `from` address\n            _withdrawCashToAccount(currencyId, opts.receiver, _safeUint88(primeCashClaim));\n        } else if (opts.transferfCash) {\n            // If the fCash has not matured, then we can transfer it via ERC1155.\n            // NOTE: this may fail if the destination is a contract and it does not implement \n            // the `onERC1155Received` hook. If that is the case it is possible to use a regular\n            // ERC20 transfer on this contract instead.\n            NotionalV2.safeTransferFrom(\n                address(this), // Sending from this contract\n                opts.receiver, // Where to send the fCash\n                getfCashId(), // fCash identifier\n                fCashShares, // Amount of fCash to send\n                \"\"\n            );\n        } else {\n            _sellfCash(opts.receiver, fCashShares, opts.maxImpliedRate);\n        }\n    }\n\n    /// @notice After maturity, withdraw cash back to account\n    function _withdrawCashToAccount(\n        uint16 currencyId,\n        address receiver,\n        uint88 primeCashToWithdraw\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(true);\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n\n        NotionalV2.withdraw(currencyId, primeCashToWithdraw, !isETH);\n\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    /// @dev Sells an fCash share back on the Notional AMM\n    function _sellfCash(\n        address receiver,\n        uint256 fCashToSell,\n        uint32 maxImpliedRate\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(true);\n        uint256 balanceBefore = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n        uint16 currencyId = getCurrencyId();\n\n        (uint256 initialCashBalance, uint256 fCashBalance) = getBalances();\n        bool hasInsufficientfCash = fCashBalance < fCashToSell;\n\n        uint256 primeCashToWithdraw;\n        if (hasInsufficientfCash) {\n            // If there is insufficient fCash, calculate how much prime cash would be purchased if the\n            // given fCash amount would be sold and that will be how much the wrapper will withdraw and\n            // send to the receiver. Since fCash always sells at a discount to underlying prior to maturity,\n            // the wrapper is guaranteed to have sufficient cash to send to the account.\n            (/* */, primeCashToWithdraw, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                fCashToSell,\n                getMaturity(),\n                0,\n                block.timestamp\n            );\n            // If this is zero then it signifies that the trade will fail.\n            require(primeCashToWithdraw > 0, \"Redeem Failed\");\n\n            // Re-write the fCash to sell to the entire fCash balance.\n            fCashToSell = fCashBalance;\n        }\n\n        if (fCashToSell > 0) {\n            // Sells fCash on Notional AMM (via borrowing)\n            BalanceActionWithTrades[] memory action = EncodeDecode.encodeBorrowTrade(\n                currencyId,\n                getMarketIndex(),\n                _safeUint88(fCashToSell),\n                maxImpliedRate\n            );\n            NotionalV2.batchBalanceAndTradeAction(address(this), action);\n        }\n\n        uint256 postTradeCash = getCashBalance();\n\n        // If the account did not have insufficient fCash, then the amount of cash change here is what\n        // the receiver is owed. In the other case, we transfer to the receiver the total calculated amount\n        // above without modification.\n        if (!hasInsufficientfCash) primeCashToWithdraw = postTradeCash - initialCashBalance;\n        require(primeCashToWithdraw <= postTradeCash);\n\n        // Withdraw the total amount of cash and send it to the receiver\n        NotionalV2.withdraw(currencyId, _safeUint88(primeCashToWithdraw), !isETH);\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    function _sendTokensToReceiver(\n        IERC20 token,\n        address receiver,\n        bool isETH,\n        uint256 balanceBefore\n    ) private returns (uint256 tokensTransferred) {\n        uint256 balanceAfter = isETH ? WETH.balanceOf(address(this)) : token.balanceOf(address(this));\n        tokensTransferred = balanceAfter - balanceBefore;\n\n        if (isETH) {\n            // No need to use safeTransfer for WETH since it is known to be compatible\n            IERC20(address(WETH)).transfer(receiver, tokensTransferred);\n        } else if (tokensTransferred > 0) {\n            token.safeTransfer(receiver, tokensTransferred);\n        }\n    }\n\n    function _safeUint88(uint256 x) internal pure returns (uint88) {\n        require(x <= uint256(type(uint88).max));\n        return uint88(x);\n    }\n}"
    },
    {
      "filename": "contracts-v3/contracts/internal/balances/TokenHandler.sol",
      "content": "// SPDX-License-Identifier: BSUL-1.1\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    Token,\n    TokenType,\n    TokenStorage,\n    PrimeRate\n} from \"../../global/Types.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\n\nimport {Emitter} from \"../Emitter.sol\";\nimport {PrimeCashExchangeRate} from \"../pCash/PrimeCashExchangeRate.sol\";\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\n\nimport {ExternalLending} from \"./ExternalLending.sol\";\nimport {CompoundHandler} from \"./protocols/CompoundHandler.sol\";\nimport {GenericToken} from \"./protocols/GenericToken.sol\";\n\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\n\n/// @notice Handles all external token transfers and events\nlibrary TokenHandler {\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n    using PrimeRateLib for PrimeRate;\n\n    function getDeprecatedAssetToken(uint256 currencyId) internal view returns (Token memory) {\n        return _getToken(currencyId, false);\n    }\n\n    function getUnderlyingToken(uint256 currencyId) internal view returns (Token memory) {\n        return _getToken(currencyId, true);\n    }\n\n    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns\n    /// the underlying token. (These may not always exist)\n    function _getToken(uint256 currencyId, bool underlying) private view returns (Token memory) {\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\n        TokenStorage storage tokenStorage = store[currencyId][underlying];\n\n        return\n            Token({\n                tokenAddress: tokenStorage.tokenAddress,\n                hasTransferFee: tokenStorage.hasTransferFee,\n                // No overflow, restricted on storage\n                decimals: int256(10**tokenStorage.decimalPlaces),\n                tokenType: tokenStorage.tokenType,\n                deprecated_maxCollateralBalance: 0\n            });\n    }\n\n    /// @notice Sets a token for a currency id. After the prime cash migration, only\n    /// underlying tokens may be set by this method.\n    function setToken(uint256 currencyId, TokenStorage memory tokenStorage) internal {\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\n\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\n            // Hardcoded parameters for ETH just to make sure we don't get it wrong.\n            TokenStorage storage ts = store[currencyId][true];\n            ts.tokenAddress = address(0);\n            ts.hasTransferFee = false;\n            ts.tokenType = TokenType.Ether;\n            ts.decimalPlaces = Constants.ETH_DECIMAL_PLACES;\n\n            return;\n        }\n\n        // Check token address\n        require(tokenStorage.tokenAddress != address(0));\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\n        // then we should explicitly upgrade this method to allow for a token to be changed.\n        Token memory token = _getToken(currencyId, true);\n        require(token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0));\n\n        require(0 < tokenStorage.decimalPlaces && tokenStorage.decimalPlaces <= Constants.MAX_DECIMAL_PLACES);\n\n        // Validate token type\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\n        // Only underlying tokens allowed after migration\n        require(tokenStorage.tokenType == TokenType.UnderlyingToken); // dev: only underlying token\n\n        // Underlying is always true.\n        store[currencyId][true] = tokenStorage;\n    }\n\n    /**\n     * @notice Transfers a deprecated asset token into Notional and redeems it for underlying,\n     * updates prime cash supply and returns the total prime cash to add to the account.\n     * @param assetToken asset token to redeem\n     * @param currencyId the currency id of the token\n     * @param assetAmountExternal the amount to transfer in asset token denomination and external precision\n     * @param primeRate the prime rate for the given currency\n     * @param account the address of the account to transfer from\n     * @return primeCashDeposited the amount of prime cash to mint back to the account\n     */\n    function depositDeprecatedAssetToken(\n        Token memory assetToken,\n        uint16 currencyId,\n        uint256 assetAmountExternal,\n        address account,\n        PrimeRate memory primeRate\n    ) internal returns (int256 primeCashDeposited) {\n        // Transfer the asset token into the contract\n        assetAmountExternal = GenericToken.safeTransferIn(\n            assetToken.tokenAddress, account, assetAmountExternal\n        );\n\n        Token memory underlyingToken = getUnderlyingToken(currencyId);\n        int256 underlyingExternalAmount;\n        // Only cTokens will be listed at the time of the migration. Redeem\n        // those cTokens to underlying (to be held by the Notional contract)\n        // and then run the post transfer update\n        if (assetToken.tokenType == TokenType.cETH) {\n            underlyingExternalAmount = CompoundHandler.redeemCETH(\n                assetToken, assetAmountExternal\n            ).toInt();\n        } else if (assetToken.tokenType == TokenType.cToken) {\n            underlyingExternalAmount = CompoundHandler.redeem(\n                assetToken, underlyingToken, assetAmountExternal\n            ).toInt();\n        } else {\n            // No other asset token variants can be called here.\n            revert();\n        }\n        \n        primeCashDeposited = _postTransferPrimeCashUpdate(\n            account, currencyId, underlyingExternalAmount, underlyingToken, primeRate\n        );\n    }\n\n    /// @notice Deposits an exact amount of underlying tokens to mint the specified amount of prime cash.\n    /// @param account account to transfer tokens from\n    /// @param currencyId the associated currency id\n    /// @param primeCashToMint the amount of prime cash to mint\n    /// @param primeRate the current accrued prime rate\n    /// @param returnNativeTokenWrapped if true, return excess msg.value ETH payments as WETH\n    /// @return actualTransferExternal the actual amount of tokens transferred in external precision\n    function depositExactToMintPrimeCash(\n        address account,\n        uint16 currencyId,\n        int256 primeCashToMint,\n        PrimeRate memory primeRate,\n        bool returnNativeTokenWrapped\n    ) internal returns (int256 actualTransferExternal) {\n        if (primeCashToMint == 0) return 0;\n        require(primeCashToMint > 0);\n        Token memory underlying = getUnderlyingToken(currencyId);\n        int256 netTransferExternal = convertToUnderlyingExternalWithAdjustment(\n            underlying, \n            primeRate.convertToUnderlying(primeCashToMint) \n        );\n\n        int256 netPrimeSupplyChange;\n        (actualTransferExternal, netPrimeSupplyChange) = depositUnderlyingExternal(\n            account, currencyId, netTransferExternal, primeRate, returnNativeTokenWrapped\n        );\n\n        // Ensures that the prime cash minted is positive and always greater than\n        // the amount of prime cash that will be credited to the depositor. Any dust\n        // amounts here will accrue to the protocol. primeCashToMint is asserted to be\n        // positive so if netPrimeSupplyChange is negative (which it should never be),\n        // then this will revert as well.\n        int256 diff = netPrimeSupplyChange - primeCashToMint;\n        require(0 <= diff); // dev: diff above zero\n    }\n\n    /// @notice Deposits an amount of underlying tokens to mint prime cash\n    /// @param account account to transfer tokens from\n    /// @param currencyId the associated currency id\n    /// @param _underlyingExternalDeposit the amount of underlying tokens to deposit\n    /// @param primeRate the current accrued prime rate\n    /// @param returnNativeTokenWrapped if true, return excess msg.value ETH payments as WETH\n    /// @return actualTransferExternal the actual amount of tokens transferred in external precision\n    /// @return netPrimeSupplyChange the amount of prime supply created\n    function depositUnderlyingExternal(\n        address account,\n        uint16 currencyId,\n        int256 _underlyingExternalDeposit,\n        PrimeRate memory primeRate,\n        bool returnNativeTokenWrapped\n    ) internal returns (int256 actualTransferExternal, int256 netPrimeSupplyChange) {\n        uint256 underlyingExternalDeposit = _underlyingExternalDeposit.toUint();\n        if (underlyingExternalDeposit == 0) return (0, 0);\n\n        Token memory underlying = getUnderlyingToken(currencyId);\n        if (underlying.tokenType == TokenType.Ether) {\n            // Underflow checked above\n            if (underlyingExternalDeposit < msg.value) {\n                // Transfer any excess ETH back to the account\n                GenericToken.transferNativeTokenOut(\n                    account, msg.value - underlyingExternalDeposit, returnNativeTokenWrapped\n                );\n            } else {\n                require(underlyingExternalDeposit == msg.value, \"ETH Balance\");\n            }\n\n            actualTransferExternal = _underlyingExternalDeposit;\n        } else {\n            // In the case of deposits, we use a balance before and after check\n            // to ensure that we record the proper balance change.\n            actualTransferExternal = GenericToken.safeTransferIn(\n                underlying.tokenAddress, account, underlyingExternalDeposit\n            ).toInt();\n        }\n\n        netPrimeSupplyChange = _postTransferPrimeCashUpdate(\n            account, currencyId, actualTransferExternal, underlying, primeRate\n        );\n    }\n\n    /// @notice Withdraws an amount of prime cash and returns it to the account as underlying tokens\n    /// @param account account to transfer tokens to\n    /// @param currencyId the associated currency id\n    /// @param primeCashToWithdraw the amount of prime cash to burn\n    /// @param primeRate the current accrued prime rate\n    /// @param withdrawWrappedNativeToken if true, return ETH as WETH\n    /// @return netTransferExternal the amount of underlying tokens withdrawn in native precision, this is\n    /// negative to signify that tokens have left the protocol\n    function withdrawPrimeCash(\n        address account,\n        address receiver,\n        uint16 currencyId,\n        int256 primeCashToWithdraw,\n        PrimeRate memory primeRate,\n        bool withdrawWrappedNativeToken\n    ) internal returns (int256 netTransferExternal) {\n        if (primeCashToWithdraw == 0) return 0;\n        require(primeCashToWithdraw < 0);\n\n        Token memory underlying = getUnderlyingToken(currencyId);\n        netTransferExternal = convertToExternal(\n            underlying, \n            primeRate.convertToUnderlying(primeCashToWithdraw) \n        );\n\n        // Overflow not possible due to int256\n        uint256 withdrawAmount = uint256(netTransferExternal.neg());\n        ExternalLending.redeemMoneyMarketIfRequired(currencyId, underlying, withdrawAmount);\n\n        if (underlying.tokenType == TokenType.Ether) {\n            GenericToken.transferNativeTokenOut(receiver, withdrawAmount, withdrawWrappedNativeToken);\n        } else {\n            GenericToken.safeTransferOut(underlying.tokenAddress, receiver, withdrawAmount);\n        }\n\n        _postTransferPrimeCashUpdate(account, currencyId, netTransferExternal, underlying, primeRate);\n    }\n\n    /// @notice Every time tokens are transferred into or out of the protocol, the prime supply\n    /// and total underlying held must be updated.\n    function _postTransferPrimeCashUpdate(\n        address account,\n        uint16 currencyId,\n        int256 netTransferUnderlyingExternal,\n        Token memory underlyingToken,\n        PrimeRate memory primeRate\n    ) private returns (int256 netPrimeSupplyChange) {\n        int256 netUnderlyingChange = convertToInternal(underlyingToken, netTransferUnderlyingExternal);\n\n        netPrimeSupplyChange = primeRate.convertFromUnderlying(netUnderlyingChange);\n\n        Emitter.emitMintOrBurnPrimeCash(account, currencyId, netPrimeSupplyChange);\n        PrimeCashExchangeRate.updateTotalPrimeSupply(currencyId, netPrimeSupplyChange, netUnderlyingChange);\n\n        _updateNetStoredTokenBalance(underlyingToken.tokenAddress, netTransferUnderlyingExternal);\n    }\n\n    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {\n        // If token decimals > INTERNAL_TOKEN_PRECISION:\n        //  on deposit: resulting dust will accumulate to protocol\n        //  on withdraw: protocol may lose dust amount. However, withdraws are only calculated based\n        //    on a conversion from internal token precision to external token precision so therefore dust\n        //    amounts cannot be specified for withdraws.\n        // If token decimals < INTERNAL_TOKEN_PRECISION then this will add zeros to the\n        // end of amount and will not result in dust.\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);\n    }\n\n    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\n        // If token decimals > INTERNAL_TOKEN_PRECISION then this will increase amount\n        // by adding a number of zeros to the end and will not result in dust.\n        // If token decimals < INTERNAL_TOKEN_PRECISION:\n        //  on deposit: Deposits are specified in external token precision and there is no loss of precision when\n        //      tokens are converted from external to internal precision\n        //  on withdraw: this calculation will round down such that the protocol retains the residual cash balance\n        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);\n    }\n\n    /// @notice Converts a token to an underlying external amount with adjustments for rounding errors when depositing\n    function convertToUnderlyingExternalWithAdjustment(\n        Token memory token,\n        int256 underlyingInternalAmount\n    ) internal pure returns (int256 underlyingExternalAmount) {\n        if (token.decimals < Constants.INTERNAL_TOKEN_PRECISION) {\n            // If external < 8, we could truncate down and cause an off by one error, for example we need\n            // 1.00000011 cash and we deposit only 1.000000, missing 11 units. Therefore, we add a unit at the\n            // lower precision (external) to get around off by one errors\n            underlyingExternalAmount = convertToExternal(token, underlyingInternalAmount).add(1);\n        } else {\n            // If external > 8, we may not mint enough asset tokens because in the case of 1e18 precision \n            // an off by 1 error at 1e8 precision is 1e10 units of the underlying token. In this case we\n            // add 1 at the internal precision which has the effect of rounding up by 1e10\n            underlyingExternalAmount = convertToExternal(token, underlyingInternalAmount.add(1));\n        }\n    }\n\n    /// @notice Convenience method for getting the balance using a token object\n    function balanceOf(Token memory token, address account) internal view returns (uint256) {\n        if (token.tokenType == TokenType.Ether) {\n            return account.balance;\n        } else {\n            return IERC20(token.tokenAddress).balanceOf(account);\n        }\n    }\n\n    function transferIncentive(address account, uint256 tokensToTransfer) internal {\n        GenericToken.safeTransferOut(Deployments.NOTE_TOKEN_ADDRESS, account, tokensToTransfer);\n    }\n\n    function updateStoredTokenBalance(address token, uint256 oldBalance, uint256 newBalance) internal {\n        mapping(address => uint256) storage store = LibStorage.getStoredTokenBalances();\n        uint256 storedBalance = store[token];\n        // The stored balance must always be less than or equal to the previous balance of. oldBalance\n        // will be larger in the case when there is a donation or dust value present. If stored balance somehow\n        // goes above the oldBalance"
    }
  ]
}