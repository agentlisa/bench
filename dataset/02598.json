{
  "Title": "Vault can be placed back into vulnerable low supply state",
  "Content": "The `BaseVault` contract inherits an issue common to ERC-4626 implementations known as the donation attack. When shares are minted to users, they are calculated by [multiplying the deposited assets by a ratio of the existing shares to current assets](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.7.3/contracts/token/ERC20/extensions/ERC4626.sol#L153-L157). The result of this calculation is then rounded down, following the [ERC specifications](https://eips.ethereum.org/EIPS/eip-4626#security-considerations). The problem arises when the value of `totalAssets` is manipulated to induce unfavorable rounding for new users depositing into the vault at the benefit of users who already own shares of the vault. Since `totalAssets` is calculated using the balance of underlying assets, it can be manipulated via direct transfers or donations of stETH to the vault. The most extreme example of this attack could occur when a user is the first to enter the vault, because when supply is sufficiently low, the capital requirement to perform an economically beneficial donation attack is also low.\n\n\nThe Pods Finance team is aware of this issue and has taken measures to make the attack more difficult to execute, such as by creating a [minimum initial deposit requirement](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/vaults/BaseVault.sol#L43-L47). While this does successfully [enforce a minimum initial deposit](https://github.com/pods-finance/yield-contracts/blob/c4b401ce674c24798de5f9d02c82e466ee0a2600/contracts/vaults/BaseVault.sol#L395-L397) for the first round, it does not prevent the total supply of shares from falling below the safety threshold throughout the life of the vault. For example, if an early user put forth the minimum initial deposit and then the rest of the queue held dust amounts, the same user could withdraw far below the minimum initial deposit amount in the next round and the vault would be back in a vulnerable state.\n\n\nConsider taking steps to ensure the supply of vault shares does not go below the minimum initial deposit amount. One way to do this would be for the Pods Finance team to contribute their own initial deposit to the vault that they can guarantee will not be withdrawn. Discussions around other techniques used to protect from this attack can be seen in issue [3706](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3706) of the openzeppelin-contracts repository.\n\n\n**Update:** *Acknowledged, will resolve. Pods Finance team stated:*\n\n\n\n> *Pods Finance will follow the recommendations and will contribute their own initial deposit to the vault that they can guarantee will not be withdrawn.*\n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/token/ERC20/extensions/ERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../utils/SafeERC20.sol\";\nimport \"../../../interfaces/IERC4626.sol\";\nimport \"../../../utils/math/Math.sol\";\n\n/**\n * @dev Implementation of the ERC4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * CAUTION: Deposits and withdrawals may incur unexpected slippage. Users should verify that the amount received of\n * shares or assets is as expected. EOAs should operate through a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * _Available since v4.7._\n */\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using Math for uint256;\n\n    IERC20Metadata private immutable _asset;\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\n     */\n    constructor(IERC20Metadata asset_) {\n        _asset = asset_;\n    }\n\n    /** @dev See {IERC4262-asset}. */\n    function asset() public view virtual override returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4262-totalAssets}. */\n    function totalAssets() public view virtual override returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    /** @dev See {IERC4262-convertToShares}. */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\n        return _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-convertToAssets}. */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-maxDeposit}. */\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return _isVaultCollateralized() ? type(uint256).max : 0;\n    }\n\n    /** @dev See {IERC4262-maxMint}. */\n    function maxMint(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4262-maxWithdraw}. */\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-maxRedeem}. */\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4262-previewDeposit}. */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-previewMint}. */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Up);\n    }\n\n    /** @dev See {IERC4262-previewWithdraw}. */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /** @dev See {IERC4262-previewRedeem}. */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-deposit}. */\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\n        require(assets <= maxDeposit(receiver), \"ERC4626: deposit more than max\");\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-mint}. */\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\n        require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4262-withdraw}. */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max\");\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-redeem}. */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     *\n     * Will revert if assets > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset\n     * would represent an infinite amout of shares.\n     */\n    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        return\n            (assets == 0 || supply == 0)\n                ? assets.mulDiv(10**decimals(), 10**_asset.decimals(), rounding)\n                : assets.mulDiv(supply, totalAssets(), rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return\n            (supply == 0)\n                ? shares.mulDiv(10**_asset.decimals(), 10**decimals(), rounding)\n                : shares.mulDiv(totalAssets(), supply, rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        // If _asset is ERC777, `transferFrom` can trigger a reenterancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transfered and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If _asset is ERC777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transfered, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _isVaultCollateralized() private view returns (bool) {\n        return totalAssets() > 0 || totalSupply() == 0;\n    }\n}"
    },
    {
      "filename": "contracts/vaults/BaseVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport { IERC4626 } from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { EnumerableMap } from \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport { IConfigurationManager } from \"../interfaces/IConfigurationManager.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { CastUint } from \"../libs/CastUint.sol\";\nimport { Capped } from \"../mixins/Capped.sol\";\n\n/**\n * @title BaseVault\n * @notice A Vault that tokenize shares of strategy\n * @author Pods Finance\n */\nabstract contract BaseVault is IVault, ERC20Permit, ERC4626, Capped {\n    using SafeERC20 for IERC20Metadata;\n    using Math for uint256;\n    using CastUint for uint256;\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n    /**\n     * @dev DENOMINATOR represents the precision for the following system variables:\n     * - MAX_WITHDRAW_FEE\n     * - INVESTOR_RATIO\n     */\n    uint256 public constant DENOMINATOR = 10000;\n    /**\n     * @dev MAX_WITHDRAW_FEE is a safe check in case the ConfigurationManager sets\n     * a fee high enough that can be used as a way to drain funds.\n     * The precision of this number is set by constant DENOMINATOR.\n     */\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    /**\n     * @notice Minimum asset amount for the first deposit\n     * @dev This amount that prevents the first depositor to steal funds from subsequent depositors.\n     * See https://code4rena.com/reports/2022-01-sherlock/#h-01-first-user-can-steal-everyone-elses-tokens\n     */\n    uint256 public immutable MIN_INITIAL_ASSETS;\n\n    IConfigurationManager public immutable configuration;\n    VaultState internal vaultState;\n    EnumerableMap.AddressToUintMap internal depositQueue;\n\n    constructor(\n        IConfigurationManager configuration_,\n        IERC20Metadata asset_,\n        string memory name_,\n        string memory symbol_\n    ) ERC20(name_, symbol_) ERC20Permit(name_) ERC4626(asset_) Capped(configuration_) {\n        configuration = configuration_;\n\n        // Vault starts in `start` state\n        emit RoundStarted(vaultState.currentRoundId, 0);\n        vaultState.lastEndRoundTimestamp = uint32(block.timestamp);\n\n        MIN_INITIAL_ASSETS = 10**uint256(asset_.decimals());\n    }\n\n    modifier onlyController() {\n        if (msg.sender != controller()) revert IVault__CallerIsNotTheController();\n        _;\n    }\n\n    modifier onlyRoundStarter() {\n        bool lastRoundEndedAWeekAgo = block.timestamp >= vaultState.lastEndRoundTimestamp + 1 weeks;\n\n        if (!lastRoundEndedAWeekAgo && msg.sender != controller()) {\n            revert IVault__CallerIsNotTheController();\n        }\n        _;\n    }\n\n    modifier whenNotProcessingDeposits() {\n        if (vaultState.isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        _;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function currentRoundId() external view returns (uint32) {\n        return vaultState.currentRoundId;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function isProcessingDeposits() external view returns (bool) {\n        return vaultState.isProcessingDeposits;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function processedDeposits() external view returns (uint256) {\n        return vaultState.processedDeposits;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function deposit(uint256 assets, address receiver)\n        public\n        virtual\n        override(ERC4626, IERC4626)\n        whenNotProcessingDeposits\n        returns (uint256)\n    {\n        return super.deposit(assets, receiver);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function depositWithPermit(\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override whenNotProcessingDeposits returns (uint256) {\n        IERC20Permit(asset()).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        return super.deposit(assets, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        override(ERC4626, IERC4626)\n        whenNotProcessingDeposits\n        returns (uint256)\n    {\n        return super.mint(shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function mintWithPermit(\n        uint256 shares,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override whenNotProcessingDeposits returns (uint256) {\n        uint256 assets = previewMint(shares);\n        IERC20Permit(asset()).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        return super.mint(shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override(ERC4626, IERC4626) whenNotProcessingDeposits returns (uint256 assets) {\n        assets = convertToAssets(shares);\n\n        if (assets == 0) revert IVault__ZeroAssets();\n        (assets, ) = _withdrawWithFees(msg.sender, receiver, owner, assets, shares);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override(ERC4626, IERC4626) whenNotProcessingDeposits returns (uint256 shares) {\n        shares = _convertToShares(assets, Math.Rounding.Up);\n        (, shares) = _withdrawWithFees(msg.sender, receiver, owner, assets, shares);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewWithdraw(uint256 assets) public view override(ERC4626, IERC4626) returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewRedeem(uint256 shares) public view override(ERC4626, IERC4626) returns (uint256) {\n        uint256 assets = _convertToAssets(shares, Math.Rounding.Down);\n        return assets - _getFee(assets);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxDeposit(address) public view override(ERC4626, IERC4626) returns (uint256) {\n        uint256 _availableCap = availableCap();\n        if (_availableCap != type(uint256).max) {\n            return previewMint(_availableCap);\n        }\n        return _availableCap;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxMint(address) public view override(ERC4626, IERC4626) returns (uint256) {\n        return availableCap();\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxWithdraw(address owner) public view override(ERC4626, IERC4626) returns (uint256) {\n        return previewRedeem(balanceOf(owner));\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function getWithdrawFeeRatio() public view override returns (uint256) {\n        uint256 _withdrawFeeRatio = configuration.getParameter(address(this), \"WITHDRAW_FEE_RATIO\");\n        // Fee is limited to MAX_WITHDRAW_FEE\n        return Math.min(_withdrawFeeRatio, MAX_WITHDRAW_FEE);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function idleAssetsOf(address owner) public view virtual returns (uint256) {\n        (, uint256 assets) = depositQueue.tryGet(owner);\n        return assets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function assetsOf(address owner) external view virtual returns (uint256) {\n        uint256 supply = totalSupply();\n        uint256 shares = balanceOf(owner);\n        uint256 committedAssets = supply == 0\n            ? 0\n            : shares.mulDiv(IERC20Metadata(asset()).balanceOf(address(this)), supply, Math.Rounding.Down);\n        return convertToAssets(shares) + idleAssetsOf(owner) + committedAssets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function totalIdleAssets() public view virtual returns (uint256) {\n        return vaultState.totalIdleAssets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function depositQueueSize() public view returns (uint256) {\n        return depositQueue.length();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function queuedDeposits() public view returns (address[] memory) {\n        address[] memory addresses = new address[](depositQueue.length());\n        for (uint256 i = 0; i < addresses.length; i++) {\n            (address owner, ) = depositQueue.at(i);\n            addresses[i] = owner;\n        }\n        return addresses;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function controller() public view returns (address) {\n        return configuration.getParameter(address(this), \"VAULT_CONTROLLER\").toAddress();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function startRound() external virtual onlyRoundStarter returns (uint32) {\n        if (!vaultState.isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        vaultState.isProcessingDeposits = false;\n\n        _afterRoundStart();\n        emit RoundStarted(vaultState.currentRoundId, vaultState.processedDeposits);\n        vaultState.processedDeposits = 0;\n\n        return vaultState.currentRoundId;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function endRound() external virtual onlyController {\n        if (vaultState.isProcessingDeposits) revert IVault__AlreadyProcessingDeposits();\n\n        vaultState.isProcessingDeposits = true;\n        _afterRoundEnd();\n        vaultState.lastEndRoundTimestamp = uint32(block.timestamp);\n\n        emit RoundEnded(vaultState.currentRoundId);\n\n        vaultState.currentRoundId += 1;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function refund() external returns (uint256 assets) {\n        (, assets) = depositQueue.tryGet(msg.sender);\n        if (assets == 0) revert IVault__ZeroAssets();\n\n        if (depositQueue.remove(msg.sender)) {\n            vaultState.totalIdleAssets -= assets;\n            _restoreCap(convertToShares(assets));\n        }\n\n        emit DepositRefunded(msg.sender, vaultState.currentRoundId, assets);\n        IERC20Metadata(asset()).safeTransfer(msg.sender, assets);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function migrate(IVault newVault) external override {\n        if (!configuration.isVaultMigrationAllowed(address(this), address(newVault))) {\n            revert IVault__MigrationNotAllowed();\n        }\n\n        // Redeem owner assets from this Vault\n        uint256 shares = balanceOf(msg.sender);\n        uint256 assets = redeem(shares, address(this), msg.sender);\n\n        // Deposit assets to `newVault`\n        IERC20Metadata(asset()).safeApprove(address(newVault), assets);\n        newVault.handleMigration(assets, msg.sender);\n\n        emit Migrated(msg.sender, address(this), address(newVault), assets, shares);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function handleMigration(uint256 assets, address receiver) external override returns (uint256) {\n        if (!configuration.isVaultMigrationAllowed(msg.sender, address(this))) {\n            revert IVault__MigrationNotAllowed();\n        }\n\n        return deposit(assets, receiver);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function processQueuedDeposits(address[] calldata depositors) external {\n        if (!vaultState.isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        for (uint256 i = 0; i < depositors.length; i++) {\n            if (depositQueue.contains(depositors[i])) {\n                vaultState.processedDeposits += _processDeposit(depositors[i]);\n            }\n        }\n    }\n\n    /** Internals **/\n\n    /**\n     * @notice Mint new shares, effectively representing user participation in the Vault.\n     */\n    function _processDeposit(address depositor) internal virtual returns (uint256) {\n        uint256 currentAssets = totalAssets();\n        uint256 supply = totalSupply();\n        uint256 assets = depositQueue.get(depositor);\n        uint256 shares = currentAssets == 0 || supply == 0\n            ? assets\n            : assets.mulDiv(supply, currentAssets, Math.Rounding.Down);\n\n        if (supply == 0 && assets < MIN_INITIAL_ASSETS) {\n            revert IVault__AssetsUnderMinimumAmount(assets);\n        }\n\n        depositQueue.remove(depositor);\n        vaultState.totalIdleAssets -= assets;\n        _mint(depositor, shares);\n        emit DepositProcessed(depositor, vaultState.currentRoundId, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @notice Add a new entry to the deposit to queue\n     */\n    function _addToDepositQueue(address receiver, uint256 assets) internal {\n        (, uint256 previous) = depositQueue.tryGet(receiver);\n        vaultState.totalIdleAssets += assets;\n        depositQueue.set(receiver, previous + assets);\n    }\n\n    /**\n     * @notice Calculate the fee amount on withdraw.\n     */\n    function _getFee(uint256 assets) internal view returns (uint256) {\n        return assets.mulDiv(getWithdrawFeeRatio(), DENOMINATOR, Math.Rounding.Down);\n    }\n\n    /**\n     * @dev Pull assets from the caller and add it to the deposit queue\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override {\n        IERC20Metadata(asset()).safeTransferFrom(caller, address(this), assets);\n\n        _spendCap(shares);\n        _addToDepositQueue(receiver, assets);\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Burn shares from the caller and release assets to the receiver\n     */\n    function _withdrawWithFees(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        // Apply custom withdraw logic\n        _beforeWithdraw(shares, assets);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(caller, receiver, owner, receiverAssets, shares);\n        IERC20Metadata(asset()).safeTransfer(receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            IERC20Metadata(asset()).safeTransfer(controller(), fee);\n        }\n    }\n\n    /** Hooks **/\n\n    /* solhint-disable no-empty-blocks */\n\n    /**\n     * @dev This hook should be implemented in the contract implementation.\n     * It will trigger after the shares were burned\n     */\n    function _beforeWithdraw(uint256 shares, uint256 assets) internal virtual {}\n\n    /**\n     * @dev This hook should be implemented in the contract implementation.\n     * It will trigger after setting isProcessingDeposits to false\n     */\n    function _afterRoundStart() internal virtual {}\n\n    /**\n     * @dev This hook should be implemented in the contract implementation.\n     * It will trigger after setting isProcessingDeposits to true\n     */\n    function _afterRoundEnd() internal virtual {}\n\n    /* solhint-enable no-empty-blocks */\n}"
    }
  ]
}