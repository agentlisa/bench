{
  "Title": "M-1: JUSD borrow fee rate is less than it should be",
  "Content": "# Issue M-1: JUSD borrow fee rate is less than it should be \n\nSource: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/73 \n\n## Found by \nBenRai, RaymondFam, Ruhum, carrotsmuggler, y1cunhui\n## Summary\nThe borrow fee rate calculation is wrong causing the protocol to take less fees than it should.\n\n## Vulnerability Detail\nThe borrowFeeRate is calculated through `getTRate()`:\n\n```sol\n    function getTRate() public view returns (uint256) {\n        uint256 timeDifference = block.timestamp - uint256(lastUpdateTimestamp);\n        return\n            t0Rate +\n            (borrowFeeRate * timeDifference) /\n            JOJOConstant.SECONDS_PER_YEAR;\n    }\n```\n`t0Rate` is initialized as `1e18` in the test contracts:\n\n```sol\n    constructor(\n        uint256 _maxReservesNum,\n        address _insurance,\n        address _JUSD,\n        address _JOJODealer,\n        uint256 _maxPerAccountBorrowAmount,\n        uint256 _maxTotalBorrowAmount,\n        uint256 _borrowFeeRate,\n        address _primaryAsset\n    ) {\n        // ...\n        t0Rate = JOJOConstant.ONE;\n    }\n```\n\n`SECONDS_PER_YEAR` is equal to `365 days` which is `60 * 60 * 24 * 365 = 31536000`:\n\n```sol\nlibrary JOJOConstant {\n    uint256 public constant SECONDS_PER_YEAR = 365 days;\n}\n```\n\nAs time passes, `getTRate()` value will increase. When a user borrows JUSD the contract doesn't save the actual amount of JUSD they borrow, `tAmount`. Instead, it saves the current \"value\" of it, `t0Amount`:\n\n```sol\n    function _borrow(\n        DataTypes.UserInfo storage user,\n        bool isDepositToJOJO,\n        address to,\n        uint256 tAmount,\n        address from\n    ) internal {\n        uint256 tRate = getTRate();\n        //        tAmount % tRate ？ tAmount / tRate + 1 ： tAmount % tRate\n        uint256 t0Amount = tAmount.decimalRemainder(tRate)\n            ? tAmount.decimalDiv(tRate)\n            : tAmount.decimalDiv(tRate) + 1;\n        user.t0BorrowBalance += t0Amount;\n```\n\nWhen you repay the JUSD, the same calculation is done again to decrease the borrowed amount. Meaning, as time passes, you have to repay more JUSD.\n\nLet's say that JUSDBank was live for a year with a borrowing fee rate of 10% (1e17). `getTRate()` would then return:\n$1e18 + 1e17 * 31536000 / 31536000 = 1.1e18$\n\nIf the user now borrows 1 JUSD we get: $1e6 * 1e18 / 1.1e18 ~= 909091$ for `t0Amount`. That's not the expected 10% decrease. Instead, it's about 9.1%.\n\n## Impact\nUsers are able to borrow JUSD for cheaper than expected\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L274-L286\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/lib/JOJOConstant.sol#L7\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L37\n## Tool used\n\nManual Review\n\n## Recommendation\nChange formula to:\n`t0Amount = tAmount - tAmount.decimalMul(tRate)` where `t0Rate` is initialized with `0` instead of `1e18`.\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nfix link:\nhttps://github.com/JOJOexchange/JUSDV1/commit/334fb691eea57a96fb7220e67e31517638725a80\n\n**IAm0x52**\n\nFix looks good. Interest is now accumulated with each state update rather than only when the rate is changed. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/70",
  "Code": [
    {
      "filename": "JUSDV1/src/Impl/JUSDBank.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1*/\npragma solidity 0.8.9;\n\nimport \"../Interface/IJUSDBank.sol\";\nimport \"../Interface/IFlashLoanReceive.sol\";\nimport \"./JUSDBankStorage.sol\";\nimport \"./JUSDOperation.sol\";\nimport \"./JUSDView.sol\";\nimport \"./JUSDMulticall.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@JOJO/contracts/intf/IDealer.sol\";\nimport {IPriceChainLink} from \"../Interface/IPriceChainLink.sol\";\n\ncontract JUSDBank is IJUSDBank, JUSDOperation, JUSDView, JUSDMulticall {\n    using DecimalMath for uint256;\n    using SafeERC20 for IERC20;\n\n    constructor(\n        uint256 _maxReservesNum,\n        address _insurance,\n        address _JUSD,\n        address _JOJODealer,\n        uint256 _maxPerAccountBorrowAmount,\n        uint256 _maxTotalBorrowAmount,\n        uint256 _borrowFeeRate,\n        address _primaryAsset\n    ) {\n        maxReservesNum = _maxReservesNum;\n        JUSD = _JUSD;\n        JOJODealer = _JOJODealer;\n        insurance = _insurance;\n        maxPerAccountBorrowAmount = _maxPerAccountBorrowAmount;\n        maxTotalBorrowAmount = _maxTotalBorrowAmount;\n        borrowFeeRate = _borrowFeeRate;\n        t0Rate = JOJOConstant.ONE;\n        primaryAsset = _primaryAsset;\n        lastUpdateTimestamp = uint32(block.timestamp);\n    }\n\n    // --------------------------event-----------------------\n\n    event HandleBadDebt(address indexed liquidatedTrader, uint256 borrowJUSDT0);\n    event Deposit(\n        address indexed collateral,\n        address indexed from,\n        address indexed to,\n        address operator,\n        uint256 amount\n    );\n    event Borrow(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bool isDepositToJOJO\n    );\n    event Repay(address indexed from, address indexed to, uint256 amount);\n    event Withdraw(\n        address indexed collateral,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bool ifInternal\n    );\n    event Liquidate(\n        address indexed collateral,\n        address indexed liquidator,\n        address indexed liquidated,\n        address operator,\n        uint256 collateralAmount,\n        uint256 liquidatedAmount,\n        uint256 insuranceFee\n    );\n    event FlashLoan(address indexed collateral, uint256 amount);\n\n    /// @notice to ensure msg.sender is from account or msg.sender is the sub account of from\n    /// so that msg.sender can send the transaction\n    modifier isValidOperator(address operator, address client) {\n        require(\n            msg.sender == client || operatorRegistry[client][operator],\n            JUSDErrors.CAN_NOT_OPERATE_ACCOUNT\n        );\n        _;\n    }\n    modifier isLiquidator(address liquidator) {\n        if(isLiquidatorWhitelistOpen){\n            require(isLiquidatorWhiteList[liquidator], \"liquidator is not in the liquidator white list\");\n        }\n        _;\n    }\n\n    function deposit(\n        address from,\n        address collateral,\n        uint256 amount,\n        address to\n    ) external override nonReentrant isValidOperator(msg.sender, from) {\n        DataTypes.ReserveInfo storage reserve = reserveInfo[collateral];\n        DataTypes.UserInfo storage user = userInfo[to];\n        //        deposit\n        _deposit(reserve, user, amount, collateral, to, from);\n    }\n\n    function borrow(\n        uint256 amount,\n        address to,\n        bool isDepositToJOJO\n    ) external override nonReentrant nonFlashLoanReentrant{\n        //     t0BorrowedAmount = borrowedAmount /  getT0Rate\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _borrow(user, isDepositToJOJO, to, amount, msg.sender);\n        require(\n            _isAccountSafeAfterBorrow(user, getTRate()),\n            JUSDErrors.AFTER_BORROW_ACCOUNT_IS_NOT_SAFE\n        );\n    }\n\n    function repay(\n        uint256 amount,\n        address to\n    ) external override nonReentrant returns (uint256) {\n        DataTypes.UserInfo storage user = userInfo[to];\n        uint256 tRate = getTRate();\n        return _repay(user, msg.sender, to, amount, tRate);\n    }\n\n    function withdraw(\n        address collateral,\n        uint256 amount,\n        address to,\n        bool isInternal\n    ) external override nonReentrant nonFlashLoanReentrant{\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _withdraw(amount, collateral, to, msg.sender, isInternal);\n        uint256 tRate = getTRate();\n        require(\n            _isAccountSafe(user, tRate),\n            JUSDErrors.AFTER_WITHDRAW_ACCOUNT_IS_NOT_SAFE\n        );\n    }\n\n    function liquidate(\n        address liquidated,\n        address collateral,\n        address liquidator,\n        uint256 amount,\n        bytes memory afterOperationParam,\n        uint256 expectPrice\n    )\n        external\n        override\n        isValidOperator(msg.sender, liquidator)\n        nonFlashLoanReentrant\n        returns (DataTypes.LiquidateData memory liquidateData)\n    {\n        uint256 JUSDBorrowedT0 = userInfo[liquidated].t0BorrowBalance;\n        uint256 primaryLiquidatedAmount = IERC20(primaryAsset).balanceOf(\n            liquidated\n        );\n        uint256 primaryInsuranceAmount = IERC20(primaryAsset).balanceOf(\n            insurance\n        );\n        isValidLiquidator(liquidated, liquidator);\n        // 1. calculate the liquidate amount\n        liquidateData = _calculateLiquidateAmount(\n            liquidated,\n            collateral,\n            amount\n        );\n        require(\n        // condition: actual liquidate price < max buy price,\n        // price lower, better\n            (liquidateData.insuranceFee + liquidateData.actualLiquidated).decimalDiv(liquidateData.actualCollateral)\n                <= expectPrice,\n            JUSDErrors.LIQUIDATION_PRICE_PROTECTION\n        );\n        // 2. after liquidation flashloan operation\n        _afterLiquidateOperation(\n            afterOperationParam,\n            amount,\n            collateral,\n            liquidated,\n            liquidateData\n        );\n\n        // 3. price protect\n        require(\n            JUSDBorrowedT0 - userInfo[liquidated].t0BorrowBalance >=\n                liquidateData.actualLiquidatedT0,\n            JUSDErrors.REPAY_AMOUNT_NOT_ENOUGH\n        );\n        require(\n            IERC20(primaryAsset).balanceOf(insurance) -\n                primaryInsuranceAmount >=\n                liquidateData.insuranceFee,\n            JUSDErrors.INSURANCE_AMOUNT_NOT_ENOUGH\n        );\n        require(\n            IERC20(primaryAsset).balanceOf(liquidated) -\n                primaryLiquidatedAmount >=\n                liquidateData.liquidatedRemainUSDC,\n            JUSDErrors.LIQUIDATED_AMOUNT_NOT_ENOUGH\n        );\n        emit Liquidate(\n            collateral,\n            liquidator,\n            liquidated,\n            msg.sender,\n            liquidateData.actualCollateral,\n            liquidateData.actualLiquidated,\n            liquidateData.insuranceFee\n        );\n    }\n\n    function handleDebt(\n        address[] calldata liquidatedTraders\n    ) external onlyOwner {\n        for (uint256 i; i < liquidatedTraders.length; i = i + 1) {\n            _handleBadDebt(liquidatedTraders[i]);\n        }\n    }\n\n    function flashLoan(\n        address receiver,\n        address collateral,\n        uint256 amount,\n        address to,\n        bytes memory param\n    ) external nonFlashLoanReentrant {\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _withdraw(amount, collateral, receiver, msg.sender, false);\n        // repay\n        IFlashLoanReceive(receiver).JOJOFlashLoan(\n            collateral,\n            amount,\n            to,\n            param\n        );\n        require(\n            _isAccountSafe(user, getTRate()),\n            JUSDErrors.AFTER_FLASHLOAN_ACCOUNT_IS_NOT_SAFE\n        );\n        emit FlashLoan(collateral, amount);\n    }\n\n    function _deposit(\n        DataTypes.ReserveInfo storage reserve,\n        DataTypes.UserInfo storage user,\n        uint256 amount,\n        address collateral,\n        address to,\n        address from\n    ) internal {\n        require(reserve.isDepositAllowed, JUSDErrors.RESERVE_NOT_ALLOW_DEPOSIT);\n        require(amount != 0, JUSDErrors.DEPOSIT_AMOUNT_IS_ZERO);\n        IERC20(collateral).safeTransferFrom(from, address(this), amount);\n        _addCollateralIfNotExists(user, collateral);\n        user.depositBalance[collateral] += amount;\n        reserve.totalDepositAmount += amount;\n        require(\n            user.depositBalance[collateral] <=\n                reserve.maxDepositAmountPerAccount,\n            JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n        );\n        require(\n            reserve.totalDepositAmount <= reserve.maxTotalDepositAmount,\n            JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_TOTAL\n        );\n        emit Deposit(collateral, from, to, msg.sender, amount);\n    }\n\n    //    Pass parameter checking, excluding checking legality\n    function _borrow(\n        DataTypes.UserInfo storage user,\n        bool isDepositToJOJO,\n        address to,\n        uint256 tAmount,\n        address from\n    ) internal {\n        uint256 tRate = getTRate();\n        //        tAmount % tRate ？ tAmount / tRate + 1 ： tAmount % tRate\n        uint256 t0Amount = tAmount.decimalRemainder(tRate)\n            ? tAmount.decimalDiv(tRate)\n            : tAmount.decimalDiv(tRate) + 1;\n        user.t0BorrowBalance += t0Amount;\n        t0TotalBorrowAmount += t0Amount;\n        if (isDepositToJOJO) {\n            IERC20(JUSD).approve(address(JOJODealer), tAmount);\n            IDealer(JOJODealer).deposit(0, tAmount, to);\n        } else {\n            IERC20(JUSD).safeTransfer(to, tAmount);\n        }\n        // Personal account hard cap\n        require(\n            user.t0BorrowBalance.decimalMul(tRate) <= maxPerAccountBorrowAmount,\n            JUSDErrors.EXCEED_THE_MAX_BORROW_AMOUNT_PER_ACCOUNT\n        );\n        // Global account hard cap\n        require(\n            t0TotalBorrowAmount.decimalMul(tRate) <= maxTotalBorrowAmount,\n            JUSDErrors.EXCEED_THE_MAX_BORROW_AMOUNT_TOTAL\n        );\n        emit Borrow(from, to, tAmount, isDepositToJOJO);\n    }\n\n    function _repay(\n        DataTypes.UserInfo storage user,\n        address payer,\n        address to,\n        uint256 amount,\n        uint256 tRate\n    ) internal returns (uint256) {\n        require(amount != 0, JUSDErrors.REPAY_AMOUNT_IS_ZERO);\n        uint256 JUSDBorrowed = user.t0BorrowBalance.decimalMul(tRate);\n        uint256 tBorrowAmount;\n        uint256 t0Amount;\n        if (JUSDBorrowed <= amount) {\n            tBorrowAmount = JUSDBorrowed;\n            t0Amount = user.t0BorrowBalance;\n        } else {\n            tBorrowAmount = amount;\n            t0Amount = amount.decimalDiv(tRate);\n        }\n        IERC20(JUSD).safeTransferFrom(payer, address(this), tBorrowAmount);\n        user.t0BorrowBalance -= t0Amount;\n        t0TotalBorrowAmount -= t0Amount;\n        emit Repay(payer, to, tBorrowAmount);\n        return tBorrowAmount;\n    }\n\n    function _withdraw(\n        uint256 amount,\n        address collateral,\n        address to,\n        address from,\n        bool isInternal\n    ) internal {\n        DataTypes.ReserveInfo storage reserve = reserveInfo[collateral];\n        DataTypes.UserInfo storage fromAccount = userInfo[from];\n        require(amount != 0, JUSDErrors.WITHDRAW_AMOUNT_IS_ZERO);\n        require(\n            amount <= fromAccount.depositBalance[collateral],\n            JUSDErrors.WITHDRAW_AMOUNT_IS_TOO_BIG\n        );\n\n        fromAccount.depositBalance[collateral] -= amount;\n        if (isInternal) {\n            DataTypes.UserInfo storage toAccount = userInfo[to];\n            _addCollateralIfNotExists(toAccount, collateral);\n            toAccount.depositBalance[collateral] += amount;\n            require(\n                toAccount.depositBalance[collateral] <=\n                    reserve.maxDepositAmountPerAccount,\n                JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n            );\n        } else {\n            reserve.totalDepositAmount -= amount;\n            IERC20(collateral).safeTransfer(to, amount);\n        }\n        emit Withdraw(collateral, from, to, amount, isInternal);\n        _removeEmptyCollateral(fromAccount, collateral);\n    }\n\n    function isValidLiquidator(address liquidated, address liquidator) internal view {\n        require(\n            liquidator != liquidated,\n            JUSDErrors.SELF_LIQUIDATION_NOT_ALLOWED\n        );\n        if(isLiquidatorWhitelistOpen){\n            require(isLiquidatorWhiteList[liquidator], JUSDErrors.LIQUIDATOR_NOT_IN_THE_WHITELIST);\n        }\n    }\n\n    /// @notice liquidate is divided into three steps,\n    // 1. determine whether liquidatedTrader is safe\n    // 2. calculate the collateral amount actually liquidated\n    // 3. transfer the insurance fee\n    function _calculateLiquidateAmount(\n        address liquidated,\n        address collateral,\n        uint256 amount\n    ) internal view returns (DataTypes.LiquidateData memory liquidateData) {\n        DataTypes.UserInfo storage liquidatedInfo = userInfo[liquidated];\n        require(amount != 0, JUSDErrors.LIQUIDATE_AMOUNT_IS_ZERO);\n        require(\n            amount <= liquidatedInfo.depositBalance[collateral],\n            JUSDErrors.LIQUIDATE_AMOUNT_IS_TOO_BIG\n        );\n        uint256 tRate = getTRate();\n        require(\n            _isStartLiquidation(liquidatedInfo, tRate),\n            JUSDErrors.ACCOUNT_IS_SAFE\n        );\n        DataTypes.ReserveInfo memory reserve = reserveInfo[collateral];\n        uint256 price = IPriceChainLink(reserve.oracle).getAssetPrice();\n        uint256 priceOff = price.decimalMul(\n            DecimalMath.ONE - reserve.liquidationPriceOff\n        );\n        uint256 liquidateAmount = amount.decimalMul(priceOff).decimalMul(\n            JOJOConstant.ONE - reserve.insuranceFeeRate\n        );\n        uint256 JUSDBorrowed = liquidatedInfo.t0BorrowBalance.decimalMul(tRate);\n        /*\n        liquidateAmount <= JUSDBorrowed\n        liquidateAmount = amount * priceOff * (1-insuranceFee)\n        actualJUSD = actualCollateral * priceOff\n        insuranceFee = actualCollateral * priceOff * insuranceFeeRate\n        */\n        if (liquidateAmount <= JUSDBorrowed) {\n            liquidateData.actualCollateral = amount;\n            liquidateData.insuranceFee = amount.decimalMul(priceOff).decimalMul(\n                reserve.insuranceFeeRate\n            );\n            liquidateData.actualLiquidatedT0 = liquidateAmount.decimalDiv(\n                tRate\n            );\n            liquidateData.actualLiquidated = liquidateAmount;\n        } else {\n            //            actualJUSD = actualCollateral * priceOff\n            //            = JUSDBorrowed * priceOff / priceOff * (1-insuranceFeeRate)\n            //            = JUSDBorrowed / (1-insuranceFeeRate)\n            //            insuranceFee = actualJUSD * insuranceFeeRate\n            //            = actualCollateral * priceOff * insuranceFeeRate\n            //            = JUSDBorrowed * insuranceFeeRate / (1- insuranceFeeRate)\n            liquidateData.actualCollateral = JUSDBorrowed\n                .decimalDiv(priceOff)\n                .decimalDiv(JOJOConstant.ONE - reserve.insuranceFeeRate);\n            liquidateData.insuranceFee = JUSDBorrowed\n                .decimalMul(reserve.insuranceFeeRate)\n                .decimalDiv(JOJOConstant.ONE - reserve.insuranceFeeRate);\n            liquidateData.actualLiquidatedT0 = liquidatedInfo.t0BorrowBalance;\n            liquidateData.actualLiquidated = JUSDBorrowed;\n        }\n\n        liquidateData.liquidatedRemainUSDC = (amount -\n            liquidateData.actualCollateral).decimalMul(price);\n    }\n\n    function _addCollateralIfNotExists(\n        DataTypes.UserInfo storage user,\n        address collateral\n    ) internal {\n        if (!user.hasCollateral[collateral]) {\n            user.hasCollateral[collateral] = true;\n            user.collateralList.push(collateral);\n        }\n    }\n\n    function _removeEmptyCollateral(\n        DataTypes.UserInfo storage user,\n        address collateral\n    ) internal {\n        if (user.depositBalance[collateral] == 0) {\n            user.hasCollateral[collateral] = false;\n            address[] storage collaterals = user.collateralList;\n            for (uint256 i; i < collaterals.length; i = i + 1) {\n                if (collaterals[i] == collateral) {\n                    collaterals[i] = collaterals[collaterals.length - 1];\n                    collaterals.pop();\n                    break;\n                }\n            }\n        }\n    }\n\n    function _afterLiquidateOperation(\n        bytes memory afterOperationParam,\n        uint256 flashloanAmount,\n        address collateral,\n        address liquidated,\n        DataTypes.LiquidateData memory liquidateData\n    ) internal {\n        (address flashloanAddress, bytes memory param) = abi.decode(\n            afterOperationParam,\n            (address, bytes)\n        );\n        _withdraw(\n            flashloanAmount,\n            collateral,\n            flashloanAddress,\n            liquidated,\n            false\n        );\n        param = abi.encode(liquidateData, param);\n        IFlashLoanReceive(flashloanAddress).JOJOFlashLoan(\n            collateral,\n            flashloanAmount,\n            liquidated,\n            param\n        );\n    }\n\n    /// @notice handle the bad debt\n    /// @param liquidatedTrader need to be liquidated\n    function _handleBadDebt(address liquidatedTrader) internal {\n        DataTypes.UserInfo storage liquidatedTraderInfo = userInfo[\n            liquidatedTrader\n        ];\n        uint256 tRate = getTRate();\n        if (\n            liquidatedTraderInfo.collateralList.length == 0 &&\n            _isStartLiquidation(liquidatedTraderInfo, tRate)\n        ) {\n            DataTypes.UserInfo storage insuranceInfo = userInfo[insurance];\n            uint256 borrowJUSDT0 = liquidatedTraderInfo.t0BorrowBalance;\n            insuranceInfo.t0BorrowBalance += borrowJUSDT0;\n            liquidatedTraderInfo.t0BorrowBalance = 0;\n            emit HandleBadDebt(liquidatedTrader, borrowJUSDT0);\n        }\n    }\n}"
    },
    {
      "filename": "JUSDV1/src/lib/JOJOConstant.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1*/\npragma solidity ^0.8.0;\n\nlibrary JOJOConstant {\n    uint256 public constant SECONDS_PER_YEAR = 365 days;\n\n    uint256 public constant ONE = 1e18;\n}"
    },
    {
      "filename": "JUSDV1/src/Impl/JUSDBank.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1*/\npragma solidity 0.8.9;\n\nimport \"../Interface/IJUSDBank.sol\";\nimport \"../Interface/IFlashLoanReceive.sol\";\nimport \"./JUSDBankStorage.sol\";\nimport \"./JUSDOperation.sol\";\nimport \"./JUSDView.sol\";\nimport \"./JUSDMulticall.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@JOJO/contracts/intf/IDealer.sol\";\nimport {IPriceChainLink} from \"../Interface/IPriceChainLink.sol\";\n\ncontract JUSDBank is IJUSDBank, JUSDOperation, JUSDView, JUSDMulticall {\n    using DecimalMath for uint256;\n    using SafeERC20 for IERC20;\n\n    constructor(\n        uint256 _maxReservesNum,\n        address _insurance,\n        address _JUSD,\n        address _JOJODealer,\n        uint256 _maxPerAccountBorrowAmount,\n        uint256 _maxTotalBorrowAmount,\n        uint256 _borrowFeeRate,\n        address _primaryAsset\n    ) {\n        maxReservesNum = _maxReservesNum;\n        JUSD = _JUSD;\n        JOJODealer = _JOJODealer;\n        insurance = _insurance;\n        maxPerAccountBorrowAmount = _maxPerAccountBorrowAmount;\n        maxTotalBorrowAmount = _maxTotalBorrowAmount;\n        borrowFeeRate = _borrowFeeRate;\n        t0Rate = JOJOConstant.ONE;\n        primaryAsset = _primaryAsset;\n        lastUpdateTimestamp = uint32(block.timestamp);\n    }\n\n    // --------------------------event-----------------------\n\n    event HandleBadDebt(address indexed liquidatedTrader, uint256 borrowJUSDT0);\n    event Deposit(\n        address indexed collateral,\n        address indexed from,\n        address indexed to,\n        address operator,\n        uint256 amount\n    );\n    event Borrow(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bool isDepositToJOJO\n    );\n    event Repay(address indexed from, address indexed to, uint256 amount);\n    event Withdraw(\n        address indexed collateral,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bool ifInternal\n    );\n    event Liquidate(\n        address indexed collateral,\n        address indexed liquidator,\n        address indexed liquidated,\n        address operator,\n        uint256 collateralAmount,\n        uint256 liquidatedAmount,\n        uint256 insuranceFee\n    );\n    event FlashLoan(address indexed collateral, uint256 amount);\n\n    /// @notice to ensure msg.sender is from account or msg.sender is the sub account of from\n    /// so that msg.sender can send the transaction\n    modifier isValidOperator(address operator, address client) {\n        require(\n            msg.sender == client || operatorRegistry[client][operator],\n            JUSDErrors.CAN_NOT_OPERATE_ACCOUNT\n        );\n        _;\n    }\n    modifier isLiquidator(address liquidator) {\n        if(isLiquidatorWhitelistOpen){\n            require(isLiquidatorWhiteList[liquidator], \"liquidator is not in the liquidator white list\");\n        }\n        _;\n    }\n\n    function deposit(\n        address from,\n        address collateral,\n        uint256 amount,\n        address to\n    ) external override nonReentrant isValidOperator(msg.sender, from) {\n        DataTypes.ReserveInfo storage reserve = reserveInfo[collateral];\n        DataTypes.UserInfo storage user = userInfo[to];\n        //        deposit\n        _deposit(reserve, user, amount, collateral, to, from);\n    }\n\n    function borrow(\n        uint256 amount,\n        address to,\n        bool isDepositToJOJO\n    ) external override nonReentrant nonFlashLoanReentrant{\n        //     t0BorrowedAmount = borrowedAmount /  getT0Rate\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _borrow(user, isDepositToJOJO, to, amount, msg.sender);\n        require(\n            _isAccountSafeAfterBorrow(user, getTRate()),\n            JUSDErrors.AFTER_BORROW_ACCOUNT_IS_NOT_SAFE\n        );\n    }\n\n    function repay(\n        uint256 amount,\n        address to\n    ) external override nonReentrant returns (uint256) {\n        DataTypes.UserInfo storage user = userInfo[to];\n        uint256 tRate = getTRate();\n        return _repay(user, msg.sender, to, amount, tRate);\n    }\n\n    function withdraw(\n        address collateral,\n        uint256 amount,\n        address to,\n        bool isInternal\n    ) external override nonReentrant nonFlashLoanReentrant{\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _withdraw(amount, collateral, to, msg.sender, isInternal);\n        uint256 tRate = getTRate();\n        require(\n            _isAccountSafe(user, tRate),\n            JUSDErrors.AFTER_WITHDRAW_ACCOUNT_IS_NOT_SAFE\n        );\n    }\n\n    function liquidate(\n        address liquidated,\n        address collateral,\n        address liquidator,\n        uint256 amount,\n        bytes memory afterOperationParam,\n        uint256 expectPrice\n    )\n        external\n        override\n        isValidOperator(msg.sender, liquidator)\n        nonFlashLoanReentrant\n        returns (DataTypes.LiquidateData memory liquidateData)\n    {\n        uint256 JUSDBorrowedT0 = userInfo[liquidated].t0BorrowBalance;\n        uint256 primaryLiquidatedAmount = IERC20(primaryAsset).balanceOf(\n            liquidated\n        );\n        uint256 primaryInsuranceAmount = IERC20(primaryAsset).balanceOf(\n            insurance\n        );\n        isValidLiquidator(liquidated, liquidator);\n        // 1. calculate the liquidate amount\n        liquidateData = _calculateLiquidateAmount(\n            liquidated,\n            collateral,\n            amount\n        );\n        require(\n        // condition: actual liquidate price < max buy price,\n        // price lower, better\n            (liquidateData.insuranceFee + liquidateData.actualLiquidated).decimalDiv(liquidateData.actualCollateral)\n                <= expectPrice,\n            JUSDErrors.LIQUIDATION_PRICE_PROTECTION\n        );\n        // 2. after liquidation flashloan operation\n        _afterLiquidateOperation(\n            afterOperationParam,\n            amount,\n            collateral,\n            liquidated,\n            liquidateData\n        );\n\n        // 3. price protect\n        require(\n            JUSDBorrowedT0 - userInfo[liquidated].t0BorrowBalance >=\n                liquidateData.actualLiquidatedT0,\n            JUSDErrors.REPAY_AMOUNT_NOT_ENOUGH\n        );\n        require(\n            IERC20(primaryAsset).balanceOf(insurance) -\n                primaryInsuranceAmount >=\n                liquidateData.insuranceFee,\n            JUSDErrors.INSURANCE_AMOUNT_NOT_ENOUGH\n        );\n        require(\n            IERC20(primaryAsset).balanceOf(liquidated) -\n                primaryLiquidatedAmount >=\n                liquidateData.liquidatedRemainUSDC,\n            JUSDErrors.LIQUIDATED_AMOUNT_NOT_ENOUGH\n        );\n        emit Liquidate(\n            collateral,\n            liquidator,\n            liquidated,\n            msg.sender,\n            liquidateData.actualCollateral,\n            liquidateData.actualLiquidated,\n            liquidateData.insuranceFee\n        );\n    }\n\n    function handleDebt(\n        address[] calldata liquidatedTraders\n    ) external onlyOwner {\n        for (uint256 i; i < liquidatedTraders.length; i = i + 1) {\n            _handleBadDebt(liquidatedTraders[i]);\n        }\n    }\n\n    function flashLoan(\n        address receiver,\n        address collateral,\n        uint256 amount,\n        address to,\n        bytes memory param\n    ) external nonFlashLoanReentrant {\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _withdraw(amount, collateral, receiver, msg.sender, false);\n        // repay\n        IFlashLoanReceive(receiver).JOJOFlashLoan(\n            collateral,\n            amount,\n            to,\n            param\n        );\n        require(\n            _isAccountSafe(user, getTRate()),\n            JUSDErrors.AFTER_FLASHLOAN_ACCOUNT_IS_NOT_SAFE\n        );\n        emit FlashLoan(collateral, amount);\n    }\n\n    function _deposit(\n        DataTypes.ReserveInfo storage reserve,\n        DataTypes.UserInfo storage user,\n        uint256 amount,\n        address collateral,\n        address to,\n        address from\n    ) internal {\n        require(reserve.isDepositAllowed, JUSDErrors.RESERVE_NOT_ALLOW_DEPOSIT);\n        require(amount != 0, JUSDErrors.DEPOSIT_AMOUNT_IS_ZERO);\n        IERC20(collateral).safeTransferFrom(from, address(this), amount);\n        _addCollateralIfNotExists(user, collateral);\n        user.depositBalance[collateral] += amount;\n        reserve.totalDepositAmount += amount;\n        require(\n            user.depositBalance[collateral] <=\n                reserve.maxDepositAmountPerAccount,\n            JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n        );\n        require(\n            reserve.totalDepositAmount <= reserve.maxTotalDepositAmount,\n            JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_TOTAL\n        );\n        emit Deposit(collateral, from, to, msg.sender, amount);\n    }\n\n    //    Pass parameter checking, excluding checking legality\n    function _borrow(\n        DataTypes.UserInfo storage user,\n        bool isDepositToJOJO,\n        address to,\n        uint256 tAmount,\n        address from\n    ) internal {\n        uint256 tRate = getTRate();\n        //        tAmount % tRate ？ tAmount / tRate + 1 ： tAmount % tRate\n        uint256 t0Amount = tAmount.decimalRemainder(tRate)\n            ? tAmount.decimalDiv(tRate)\n            : tAmount.decimalDiv(tRate) + 1;\n        user.t0BorrowBalance += t0Amount;\n        t0TotalBorrowAmount += t0Amount;\n        if (isDepositToJOJO) {\n            IERC20(JUSD).approve(address(JOJODealer), tAmount);\n            IDealer(JOJODealer).deposit(0, tAmount, to);\n        } else {\n            IERC20(JUSD).safeTransfer(to, tAmount);\n        }\n        // Personal account hard cap\n        require(\n            user.t0BorrowBalance.decimalMul(tRate) <= maxPerAccountBorrowAmount,\n            JUSDErrors.EXCEED_THE_MAX_BORROW_AMOUNT_PER_ACCOUNT\n        );\n        // Global account hard cap\n        require(\n            t0TotalBorrowAmount.decimalMul(tRate) <= maxTotalBorrowAmount,\n            JUSDErrors.EXCEED_THE_MAX_BORROW_AMOUNT_TOTAL\n        );\n        emit Borrow(from, to, tAmount, isDepositToJOJO);\n    }\n\n    function _repay(\n        DataTypes.UserInfo storage user,\n        address payer,\n        address to,\n        uint256 amount,\n        uint256 tRate\n    ) internal returns (uint256) {\n        require(amount != 0, JUSDErrors.REPAY_AMOUNT_IS_ZERO);\n        uint256 JUSDBorrowed = user.t0BorrowBalance.decimalMul(tRate);\n        uint256 tBorrowAmount;\n        uint256 t0Amount;\n        if (JUSDBorrowed <= amount) {\n            tBorrowAmount = JUSDBorrowed;\n            t0Amount = user.t0BorrowBalance;\n        } else {\n            tBorrowAmount = amount;\n            t0Amount = amount.decimalDiv(tRate);\n        }\n        IERC20(JUSD).safeTransferFrom(payer, address(this), tBorrowAmount);\n        user.t0BorrowBalance -= t0Amount;\n        t0TotalBorrowAmount -= t0Amount;\n        emit Repay(payer, to, tBorrowAmount);\n        return tBorrowAmount;\n    }\n\n    function _withdraw(\n        uint256 amount,\n        address collateral,\n        address to,\n        address from,\n        bool isInternal\n    ) internal {\n        DataTypes.ReserveInfo storage reserve = reserveInfo[collateral];\n        DataTypes.UserInfo storage fromAccount = userInfo[from];\n        require(amount != 0, JUSDErrors.WITHDRAW_AMOUNT_IS_ZERO);\n        require(\n            amount <= fromAccount.depositBalance[collateral],\n            JUSDErrors.WITHDRAW_AMOUNT_IS_TOO_BIG\n        );\n\n        fromAccount.depositBalance[collateral] -= amount;\n        if (isInternal) {\n            DataTypes.UserInfo storage toAccount = userInfo[to];\n            _addCollateralIfNotExists(toAccount, collateral);\n            toAccount.depositBalance[collateral] += amount;\n            require(\n                toAccount.depositBalance[collateral] <=\n                    reserve.maxDepositAmountPerAccount,\n                JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n            );\n        } else {\n            reserve.totalDepositAmount -= amount;\n            IERC20(collateral).safeTransfer(to, amount);\n        }\n        emit Withdraw(collateral, from, to, amount, isInternal);\n        _removeEmptyCollateral(fromAccount, collateral);\n    }\n\n    function isValidLiquidator(address liquidated, address liquidator) internal view {\n        require(\n            liquidator != liquidated,\n            JUSDErrors.SELF_LIQUIDATION_NOT_ALLOWED\n        );\n        if(isLiquidatorWhitelistOpen){\n            require(isLiquidatorWhiteList[liquidator], JUSDErrors.LIQUIDATOR_NOT_IN_THE_WHITELIST);\n        }\n    }\n\n    /// @notice liquidate is divided into three steps,\n    // 1. determine whether liquidatedTrader is safe\n    // 2. calculate the collateral amount actually liquidated\n    // 3. transfer the insurance fee\n    function _calculateLiquidateAmount(\n        address liquidated,\n        address collateral,\n        uint256 amount\n    ) internal view returns (DataTypes.LiquidateData memory liquidateData) {\n        DataTypes.UserInfo storage liquidatedInfo = userInfo[liquidated];\n        require(amount != 0, JUSDErrors.LIQUIDATE_AMOUNT_IS_ZERO);\n        require(\n            amount <= liquidatedInfo.depositBalance[collateral],\n            JUSDErrors.LIQUIDATE_AMOUNT_IS_TOO_BIG\n        );\n        uint256 tRate = getTRate();\n        require(\n            _isStartLiquidation(liquidatedInfo, tRate),\n            JUSDErrors.ACCOUNT_IS_SAFE\n        );\n        DataTypes.ReserveInfo memory reserve = reserveInfo[collateral];\n        uint256 price = IPriceChainLink(reserve.oracle).getAssetPrice();\n        uint256 priceOff = price.decimalMul(\n            DecimalMath.ONE - reserve.liquidationPriceOff\n        );\n        uint256 liquidateAmount = amount.decimalMul(priceOff).decimalMul(\n            JOJOConstant.ONE - reserve.insuranceFeeRate\n        );\n        uint256 JUSDBorrowed = liquidatedInfo.t0BorrowBalance.decimalMul(tRate);\n        /*\n        liquidateAmount <= JUSDBorrowed\n        liquidateAmount = amount * priceOff * (1-insuranceFee)\n        actualJUSD = actualCollateral * priceOff\n        insuranceFee = actualCollateral * priceOff * insuranceFeeRate\n        */\n        if (liquidateAmount <= JUSDBorrowed) {\n            liqu"
    }
  ]
}