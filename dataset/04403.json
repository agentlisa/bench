{
  "Title": "[M01] daiJoin.cage prevents withdrawals",
  "Content": "Part of the functionality of the DSS system is the ability of the Maker admins to call the function [`cage` in join.sol](https://github.com/makerdao/dss/blob/870d6fddb75090eb177290b1db4e255d2c31075e/src/join.sol#L157), which sets `live = 0`. If this happens, the call to [`daiJoin.exit` within CDaiDelegate’s `doTransferOut` function](https://github.com/compound-finance/compound-protocol/blob/9ea64ddd166a78b264ba8006f688880085eeed13/contracts/CDaiDelegate.sol#L166) will revert upon reaching the [`require` statement on line 169 of join.sol](https://github.com/makerdao/dss/blob/870d6fddb75090eb177290b1db4e255d2c31075e/src/join.sol#L169). Users would not be able to withdraw their funds.\n\n\nConsider informing users of the risk associated with using Compound’s DAI market. Also consider a course of action for the `pauseGuardian` and/or `admin` roles should the `DaiJoin` contract ever be “caged”.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/join.sol",
      "content": "/// join.sol -- Basic token adapters\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.5.12;\n\nimport \"./lib.sol\";\n\ncontract GemLike {\n    function decimals() public view returns (uint);\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n}\n\ncontract DSTokenLike {\n    function mint(address,uint) external;\n    function burn(address,uint) external;\n}\n\ncontract VatLike {\n    function slip(bytes32,address,int) external;\n    function move(address,address,uint) external;\n}\n\n/*\n    Here we provide *adapters* to connect the Vat to arbitrary external\n    token implementations, creating a bounded context for the Vat. The\n    adapters here are provided as working examples:\n\n      - `GemJoin`: For well behaved ERC20 tokens, with simple transfer\n                   semantics.\n\n      - `ETHJoin`: For native Ether.\n\n      - `DaiJoin`: For connecting internal Dai balances to an external\n                   `DSToken` implementation.\n\n    In practice, adapter implementations will be varied and specific to\n    individual collateral types, accounting for different transfer\n    semantics and token standards.\n\n    Adapters need to implement two basic methods:\n\n      - `join`: enter collateral into the system\n      - `exit`: remove collateral from the system\n\n*/\n\ncontract GemJoin is LibNote {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external note auth { wards[usr] = 1; }\n    function deny(address usr) external note auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"GemJoin/not-authorized\");\n        _;\n    }\n\n    VatLike public vat;\n    bytes32 public ilk;\n    GemLike public gem;\n    uint    public dec;\n    uint    public live;  // Access Flag\n\n    constructor(address vat_, bytes32 ilk_, address gem_) public {\n        wards[msg.sender] = 1;\n        live = 1;\n        vat = VatLike(vat_);\n        ilk = ilk_;\n        gem = GemLike(gem_);\n        dec = gem.decimals();\n    }\n    function cage() external note auth {\n        live = 0;\n    }\n    function join(address usr, uint wad) external note {\n        require(live == 1, \"GemJoin/not-live\");\n        require(int(wad) >= 0, \"GemJoin/overflow\");\n        vat.slip(ilk, usr, int(wad));\n        require(gem.transferFrom(msg.sender, address(this), wad), \"GemJoin/failed-transfer\");\n    }\n    function exit(address usr, uint wad) external note {\n        require(wad <= 2 ** 255, \"GemJoin/overflow\");\n        vat.slip(ilk, msg.sender, -int(wad));\n        require(gem.transfer(usr, wad), \"GemJoin/failed-transfer\");\n    }\n}\n\ncontract ETHJoin is LibNote {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external note auth { wards[usr] = 1; }\n    function deny(address usr) external note auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"ETHJoin/not-authorized\");\n        _;\n    }\n\n    VatLike public vat;\n    bytes32 public ilk;\n    uint    public live;  // Access Flag\n\n    constructor(address vat_, bytes32 ilk_) public {\n        wards[msg.sender] = 1;\n        live = 1;\n        vat = VatLike(vat_);\n        ilk = ilk_;\n    }\n    function cage() external note auth {\n        live = 0;\n    }\n    function join(address usr) external payable note {\n        require(live == 1, \"ETHJoin/not-live\");\n        require(int(msg.value) >= 0, \"ETHJoin/overflow\");\n        vat.slip(ilk, usr, int(msg.value));\n    }\n    function exit(address payable usr, uint wad) external note {\n        require(int(wad) >= 0, \"ETHJoin/overflow\");\n        vat.slip(ilk, msg.sender, -int(wad));\n        usr.transfer(wad);\n    }\n}\n\ncontract DaiJoin is LibNote {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external note auth { wards[usr] = 1; }\n    function deny(address usr) external note auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"DaiJoin/not-authorized\");\n        _;\n    }\n\n    VatLike public vat;\n    DSTokenLike public dai;\n    uint    public live;  // Access Flag\n\n    constructor(address vat_, address dai_) public {\n        wards[msg.sender] = 1;\n        live = 1;\n        vat = VatLike(vat_);\n        dai = DSTokenLike(dai_);\n    }\n    function cage() external note auth {\n        live = 0;\n    }\n    uint constant ONE = 10 ** 27;\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function join(address usr, uint wad) external note {\n        vat.move(address(this), usr, mul(ONE, wad));\n        dai.burn(msg.sender, wad);\n    }\n    function exit(address usr, uint wad) external note {\n        require(live == 1, \"DaiJoin/not-live\");\n        vat.move(msg.sender, address(this), mul(ONE, wad));\n        dai.mint(usr, wad);\n    }\n}"
    }
  ]
}