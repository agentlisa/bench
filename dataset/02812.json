{
  "Title": "M-5: Fee-on-transfer underlyings can be used to mint Illuminate PTs without fees",
  "Content": "# Issue M-5: Fee-on-transfer underlyings can be used to mint Illuminate PTs without fees \n\nSource: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/116 \n\n## Found by \nIllIllI, Bnke0x0, Tomo\n\n## Summary\n\nFee-on-transfer underlyings can be used to mint Illuminate PTs without fees\n\n\n## Vulnerability Detail\n\nIlluminate's `Lender` does not confirm that the amount of underlying received is the amount provided in the transfer call. If the token is a fee-on-transfer token (e.g. USDT which is [currently](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/test/fork/Contracts.sol#L98) [supported](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/test/fork/Contracts.sol#L61-L62)), then the amount may be less. As long as the fee is smaller than Illuminate's fee, Illuminate will incorrectly trust that the fee has properly been deducted from the contract's balance, and then will swap the funds and mint an Illuminate PT.\n\n\n## Impact\n\n_Theft of unclaimed yield_\n\nAttackers can mint free PT at the expense of Illuminate's fees.\n\n\n## Code Snippet\n\nThis is one example from one of the `lend()` functions, but they all have the same issue:\n\n```solidity\n// File: src/Lender.sol : Lender.lend()   #1\n\n750        function lend(\n751            uint8 p,\n752            address u,\n753            uint256 m,\n754            uint256 a,\n755            uint256 r\n756        ) external unpaused(u, m, p) returns (uint256) {\n757            // Instantiate Notional princpal token\n758            address token = IMarketPlace(marketPlace).token(u, m, p);\n759    \n760            // Transfer funds from user to Illuminate\n761  @>        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n762    \n763            // Add the accumulated fees to the total\n764            uint256 fee = a / feenominator;\n765            fees[u] = fees[u] + fee;\n766    \n767            // Swap on the Notional Token wrapper\n768  @>        uint256 received = INotional(token).deposit(a - fee, address(this));\n769    \n770            // Verify that we received the principal tokens\n771            if (received < r) {\n772                revert Exception(16, received, r, address(0), address(0));\n773            }\n774    \n775            // Mint Illuminate zero coupons\n776  @>        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n777    \n778            emit Lend(p, u, m, received, a, msg.sender);\n779            return received;\n780:       }\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L750-L780\n\n\nAnd separately, if any of the external PTs ever become fee-on-transfer (e.g. CTokens, which are upgradeable), users would be able to mint Illuminate PT directly without having to worry about the FOT fee being smaller than the illuminate one, and the difference would be made up by other PT holders' principal, rather than Illuminate's fees:\n\n```solidity\n// File: src/Lender.sol : Lender.mint()   #2\n\n270        function mint(\n271            uint8 p,\n272            address u,\n273            uint256 m,\n274            uint256 a\n275        ) external unpaused(u, m, p) returns (bool) {\n276            // Fetch the desired principal token\n277            address principal = IMarketPlace(marketPlace).token(u, m, p);\n278    \n279            // Transfer the users principal tokens to the lender contract\n280 @>         Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n281    \n282            // Mint the tokens received from the user\n283 @>         IERC5095(principalToken(u, m)).authMint(msg.sender, a);\n284    \n285            emit Mint(p, u, m, a);\n286    \n287            return true;\n288:       }\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L270-L288\n\n\n## POC\n\nImagine that the Illuminate fee is 1%, and the fee-on-transfer fee for USDT is also 1%\n1. A random unaware user calls one of the `lend()` functions for 100 USDT\n2. `lend()` does the `transferFrom()` for the user and gets 99 USDT due to the USDT 1% fee\n3. `lend()` calculates its own fee as 1% of 100, resulting in 99 USDT remaining\n4. `lend()` swaps the 99 USDT for a external PT\n5. the user is given 99 IPT and only had to spend 100 USDT, and Illuminate got zero actual fee, and actually has to make up the difference itself in order to withdraw _any_ fees (see other issue I've filed about this).\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nCheck the actual balance before and after the transfer, and ensure the amount is correct, or use the difference as the amount\n\n\n## Discussion\n\n**sourabhmarathe**\n\nSet label to `high` because based on what the report indicated.\n\n**IllIllI000**\n\n@sourabhmarathe can you elaborate on what aspect of the report made this a high? https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/104 describes a separate way of how to mint IPT using protocol fees\n\n**sourabhmarathe**\n\nI was just updating the issue to reflect what the Watson had put on the report. To me, it appeared mislabeled as the original report had a high level severity at the top of the report.\n\n**sourabhmarathe**\n\nRe #104: It should not be marked as a duplicate. It's a separate issue in it's own right. That said, it doesn't put user funds at risk, so I think it should remain at a Medium.\n\n**JTraversa**\n\nI dont quite think this should be valid all given we are not planning to accept any niche tokens that would include fee on transfers. (We are launching DAI, USDC, stETH)\n\nThe admin currently has complete control over market creation meaning suggested remediations increase gas costs for our users with very minimal or no benefit at the moment!\n\n**0x00052**\n\nEscalate for 1 USDC\n\nReminder @Evert0x \n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Reminder @Evert0x \n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**KenzoAgada**\n\nEscalate for 50 USDC\nSee sponsor's comments.\n\n> I dont quite think this should be valid all given we are not planning to accept any niche tokens that would include fee on transfers. (We are launching DAI, USDC, stETH)\n> \n> The admin currently has complete control over market creation meaning suggested remediations increase gas costs for our users with very minimal or no benefit at the moment!\n\nWhile USDT can be upgraded to have FoT, this is an external condition, therefore this issue might be more properly described as a medium at best.\n\n\n**sherlock-admin**\n\n > Escalate for 50 USDC\n> See sponsor's comments.\n> \n> > I dont quite think this should be valid all given we are not planning to accept any niche tokens that would include fee on transfers. (We are launching DAI, USDC, stETH)\n> > \n> > The admin currently has complete control over market creation meaning suggested remediations increase gas costs for our users with very minimal or no benefit at the moment!\n> \n> While USDT can be upgraded to have FoT, this is an external condition, therefore this issue might be more properly described as a medium at best.\n> \n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/12",
  "Code": [
    {
      "filename": "test/fork/Contracts.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nlibrary Contracts {\n    // Sent to the lender contract constructor\n    // Swivel.sol v2 deployed contract\n    address constant SWIVEL = 0x093e4D20D9b2c3c8f68E8a20262D8Fb8EBCE08FA;\n    // Sushiswap router (https://docs.sushi.com/docs/Developers/Deployment%20Addresses)\n    // note used on lender\n    address constant PENDLE = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\n    // note used on redeemer\n    address constant PENDLE_ROUTER = 0x1b6d3E5Da9004668E14Ca39d1553E9a46Fe842B3;\n    // https://docs.tempus.finance/docs/deployed-contracts (controller)\n    address constant TEMPUS = 0xdB5fD0678eED82246b599da6BC36B56157E4beD8;\n\n    // Prinicpal Tokens---------------------------------------------------------\n    // Notional deployed contracts: https://docs.notional.finance/developer-documentation/\n    // NOTE this is the DAI wrapped-fcash address\n    address constant NOTIONAL_TOKEN =\n        0xfcB060E09e452EEFf142949Bec214c187CDF25fA;\n    // Via the marketplace's markets call with USDC underlying and a maturity of 1664550000 (v2)\n    address constant SWIVEL_TOKEN = 0xC812c7aA52c97FacdE14b7FfFf4e0A9b1a1Dd179;\n    // Via sushi swap market (Dec 2022 - https://app.pendle.finance/market)\n    address constant PENDLE_TOKEN = 0x8fcb1783bF4b71A51F702aF0c266729C4592204a;\n    // via contracts.json (https://etherscan.io/address/0x53C2a1bA37FF3cDaCcb3EA030DB3De39358e5593#readContract)\n    address constant YIELD_TOKEN = 0x53C2a1bA37FF3cDaCcb3EA030DB3De39358e5593;\n    // (principal share) https://etherscan.io/address/0xb3ec7facb30b163b1375285ea7ebfeefc41920b9#readContract\n    address constant TEMPUS_TOKEN = 0xB3EC7FACb30b163b1375285EA7EbfEeFc41920B9;\n    // NOTE for apwine, we have to use the amm pool to get the APWine token. From there, we use the PT that the\n    // amm points to in order to continue with verification purposes\n    // AMM Registry -> getFutureVaultAt(futureVaultAt via ProtocolRegistry) -> getFutureAMMPool\n    address constant APWINE_AMM_POOL =\n        0xb932c4801240753604c768c991eb640BCD7C06EB;\n    // (element token) https://app.element.fi/fixedrates/0xCFe60a1535ecc5B0bc628dC97111C8bb01637911\n    address constant ELEMENT_TOKEN = 0xf38c3E836Be9cD35072055Ff6a9Ba570e0B70797;\n    // (sense adapter)\n    // NOTE for sense, we have to use the adapter contract to verify the underlying/maturity\n    // NOTE also we had to use the wsteth pools.... (maturity: 1659312000)\n    address constant SENSE_ADAPTER = 0x880E5caBB22D24F3E278C4C760e763f239AccA95;\n\n    // Misc. contracts/values --------------------------------------------------\n    // found via etherscan via contracts.json or something\n    address constant YIELD_POOL_USDC =\n        0xf5Fd5A9Db9CcCc6dc9f5EF1be3A859C39983577C;\n    address constant YIELD_POOL_USDC_2 = // DEC 22\n        0xB2fff7FEA1D455F0BCdd38DA7DeE98af0872a13a;\n    address constant YIELD_POOL_DAI =\n        0x6BaC09a67Ed1e1f42c29563847F77c28ec3a04FC;\n    // (amm) https://etherscan.io/address/0x811f4F0241A9A4583C052c08BDA7F6339DBb13f7#readContract\n    address constant TEMPUS_AMM = 0x811f4F0241A9A4583C052c08BDA7F6339DBb13f7;\n    // (pool) https://etherscan.io/address/0x443297de16c074fdee19d2c9ecf40fde2f5f62c2#readContract\n    address constant TEMPUS_POOL = 0x443297DE16C074fDeE19d2C9eCF40fdE2f5F62C2;\n\n    // (pool) https://etherscan.io/address/0xf5ba2E5DdED276fc0f7a7637A61157a4be79C626#writeProxyContract\n    address constant APWINE_ROUTER = 0xf5ba2E5DdED276fc0f7a7637A61157a4be79C626;\n    // (pool id) via getFutureVaultAt in Protocol Registry (https://docs.apwine.fi/dev/introduction/deployed-contracts)\n    // APWINE POOL ID is 4 (for tests)\n    // (controller, used to call getNextPeriodStart (for maturity check))\n    address constant APWINE_CONTROLLER =\n        0x4bA30FA240047c17FC557b8628799068d4396790;\n    // (apwine PT - USDT market) https://etherscan.io/address/0x2b8692963c8ec4cdf30047a20f12c43e4d9aef6c\n    address constant APWINE_TOKEN = 0x2d31591f7a650579125bC9BC1622E07fFD219033;\n    address constant APWINE_FUTURE_VAULT = 0xb524c16330A76182Ef617F08F5E6996f577AC64A;\n    // (element router)\n    address constant ELEMENT_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;\n    // (element USDC pool) https://raw.githubusercontent.com/element-fi/elf-deploy/main/changelog/releases/mainnet/v1.1.0:7/addresses.json\n    // tranches -> usdc -> ptPool -> poolId\n    bytes32 constant ELEMENT_POOL_ID =\n        0x787546bf2c05e3e19e2b6bde57a203da7f682eff00020000000000000000007c;\n\n    // aUSDC in this case\n    address constant PENDLE_UNDERLYING_YIELD_TOKEN =\n        0xBcca60bB61934080951369a648Fb03DF4F96263C;\n\n    // (sense periphery (executes swap)) https://docs.sense.finance/developers/deployed-contracts/\n    address constant SENSE_PERIPHERY =\n        0xFff11417a58781D3C72083CB45EF54d79Cd02437;\n    address constant SENSE_TOKEN = 0x6BEf7922EBA9fDd6BEca781cD21E3a25f872Aa97;\n    uint256 constant SENSE_MATURITY = 1659312000;\n    address constant SENSE_DIVIDER = 0x86bA3E96Be68563E41c2f5769F1AF9fAf758e6E0;\n    uint256 constant SENSE_VALID_SETTLEMENT_TS = 1659322801;\n\n    // Underlyings--------------------------------------------------------------\n    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    // https://api-main.swivel.exchange/v2/markets?status=active\n    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    // Foundry specific\n    address constant DEPLOYER = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;\n\n    // converter tokens\n    address constant AUSDC = 0xBcca60bB61934080951369a648Fb03DF4F96263C;\n    address constant CUSDC = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\n    address constant AAVE_POOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\n    address constant WSTETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n    address constant STETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address constant CDAI = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\n\n    address constant EUDAI = 0xe025E3ca2bE02316033184551D4d3Aa22024D9DC;\n}"
    },
    {
      "filename": "src/Lender.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/MarketPlace.sol'; // library of MarketPlace specific constructs\nimport 'src/lib/Swivel.sol'; // library of Swivel specific constructs\nimport 'src/lib/Element.sol'; // library of Element specific constructs\nimport 'src/lib/Safe.sol';\nimport 'src/lib/Cast.sol';\nimport 'src/lib/RevertMsgExtractor.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/ITempus.sol';\nimport 'src/interfaces/ITempusAMM.sol';\nimport 'src/interfaces/ITempusPool.sol';\nimport 'src/interfaces/ITempusToken.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/ISensePeriphery.sol';\nimport 'src/interfaces/ISenseAdapter.sol';\nimport 'src/interfaces/ISenseDivider.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/interfaces/IYieldToken.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/IElementToken.sol';\nimport 'src/interfaces/IElementVault.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/IAPWineAMMPool.sol';\nimport 'src/interfaces/IAPWineRouter.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\nimport 'src/interfaces/IAPWineController.sol';\nimport 'src/interfaces/INotional.sol';\nimport 'src/interfaces/IPendle.sol';\nimport 'src/interfaces/IPendleToken.sol';\n\n/// @title Lender\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The lender contract executes loans on behalf of users\n/// @notice The contract holds the principal tokens and mints an ERC-5095 tokens to users to represent their loans\ncontract Lender {\n    /// @notice minimum wait before the admin may withdraw funds or change the fee rate\n    uint256 public constant HOLD = 3 days;\n\n    /// @notice address that is allowed to set and withdraw fees, disable principals, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice mapping that determines if a principal token has been paused by the admin\n    mapping(address => mapping(uint256 => bool[9])) public paused;\n\n    /// @notice contract used to execute swaps on Swivel's exchange\n    address public immutable swivelAddr;\n    /// @notice a SushiSwap router used by Pendle to execute swaps\n    address public immutable pendleAddr;\n\n    /// @notice this value determines the amount of fees paid on loans\n    uint256 public feenominator;\n    /// @notice represents a point in time where the feenominator may change\n    uint256 public feeChange;\n    /// @notice represents a minimum that the feenominator must exceed\n    uint256 public constant MIN_FEENOMINATOR = 500;\n\n    /// @notice maps underlying tokens to the amount of fees accumulated for that token\n    mapping(address => uint256) public fees;\n    /// @notice maps a token address to a point in time, a hold, after which a withdrawal can be made\n    mapping(address => uint256) public withdrawals;\n\n    /// @notice emitted upon lending to a protocol\n    event Lend(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 returned,\n        uint256 spent,\n        address sender\n    );\n    /// @notice emitted upon minting Illuminate principal tokens\n    event Mint(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 amount\n    );\n    /// @notice emitted upon scheduling a withdrawal\n    event ScheduleWithdrawal(address indexed token, uint256 hold);\n    /// @notice emitted upon blocking a scheduled withdrawal\n    event BlockWithdrawal(address indexed token);\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon setting the fee rate\n    event SetFee(uint256 indexed fee);\n    /// @notice emitted upon scheduling a fee change\n    event ScheduleFeeChange(uint256 when);\n    /// @notice emitted upon blocking a scheduled fee change\n    event BlockFeeChange();\n    /// @notice emitted upon pausing or unpausing of a principal token\n    event PauseMarket(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        address token,\n        bool indexed state\n    );\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    modifier unpaused(\n        address u,\n        uint256 m,\n        uint8 p\n    ) {\n        if (paused[u][m][p]) {\n            revert Exception(1, p, 0, address(0), address(0));\n        }\n        _;\n    }\n\n    /// @notice initializes the Lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    constructor(address s, address p) {\n        admin = msg.sender;\n        swivelAddr = s;\n        pendleAddr = p;\n        feenominator = 1000;\n    }\n\n    /// @notice approves the redeemer contract to spend the principal tokens held by the lender contract.\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param r the address being approved, in this case the redeemer contract\n    /// @return bool true if the approval was successful\n    function approve(\n        address u,\n        uint256 m,\n        address r\n    ) external authorized(admin) returns (bool) {\n        // approve the underlying for max per given principal\n        for (uint8 i; i != 9; ) {\n            // get the principal token's address\n            address token = IMarketPlace(marketPlace).token(u, m, i);\n            // check that the token is defined for this particular market\n            if (token != address(0)) {\n                // max approve the token\n                Safe.approve(IERC20(token), r, type(uint256).max);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /// @notice bulk approves the usage of addresses at the given ERC20 addresses.\n    /// @dev the lengths of the inputs must match because the arrays are paired by index\n    /// @param u array of ERC20 token addresses that will be approved on\n    /// @param a array of addresses that will be approved\n    /// @return true if successful\n    function approve(address[] calldata u, address[] calldata a)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        for (uint256 i; i != u.length; ) {\n            IERC20 uToken = IERC20(u[i]);\n            if (address(0) != (address(uToken))) {\n                Safe.approve(uToken, a[i], type(uint256).max);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /// @notice approves market contracts that require lender approval\n    /// @param u address of an underlying asset\n    /// @param a APWine's router contract\n    /// @param e Element's vault contract\n    /// @param n Notional's token contract\n    function approve(\n        address u,\n        address a,\n        address e,\n        address n\n    ) external authorized(marketPlace) {\n        uint256 max = type(uint256).max;\n        IERC20 uToken = IERC20(u);\n        if (a != address(0)) {\n            Safe.approve(uToken, a, max);\n        }\n        if (e != address(0)) {\n            Safe.approve(uToken, e, max);\n        }\n        if (n != address(0)) {\n            Safe.approve(uToken, n, max);\n        }\n        if (IERC20(u).allowance(address(this), swivelAddr) == 0) {\n            Safe.approve(uToken, swivelAddr, max);\n        }\n    }\n\n    /// @notice sets the admin address\n    /// @param a address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        uint256 feeTime = feeChange;\n        if (feeTime == 0) {\n            revert Exception(23, 0, 0, address(0), address(0));\n        } else if (block.timestamp < feeTime) {\n            revert Exception(\n                24,\n                block.timestamp,\n                feeTime,\n                address(0),\n                address(0)\n            );\n        } else if (f < MIN_FEENOMINATOR) {\n            revert Exception(25, 0, 0, address(0), address(0));\n        }\n        feenominator = f;\n        delete feeChange;\n        emit SetFee(f);\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set\n    function setMarketPlace(address m)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        if (marketPlace != address(0)) {\n            revert Exception(5, 0, 0, marketPlace, address(0));\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice mint swaps the sender's principal tokens for Illuminate's ERC5095 tokens in effect, this opens a new fixed rate position for the sender on Illuminate\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount being minted\n    /// @return bool true if the mint was successful\n    function mint(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) external unpaused(u, m, p) returns (bool) {\n        // Fetch the desired principal token\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer the users principal tokens to the lender contract\n        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n\n        // Mint the tokens received from the user\n        IERC5095(principalToken(u, m)).authMint(msg.sender, a);\n\n        emit Mint(p, u, m, a);\n\n        return true;\n    }\n\n    /// @notice lend method for the Illuminate and Yield protocols\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param y Yield Space Pool for the principal token\n    /// @param minimum slippage limit, minimum amount to PTs to buy\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        address y,\n        uint256 minimum\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Check that the principal is Illuminate or Yield\n        if (\n            p != uint8(MarketPlace.Principals.Illuminate) &&\n            p != uint8(MarketPlace.Principals.Yield)\n        ) {\n            revert Exception(6, 0, 0, address(0), address(0));\n        }\n\n        // Get principal token for this market\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Extract fee\n        fees[u] = fees[u] + a / feenominator;\n\n        // Transfer underlying from user to the lender contract\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Make sure the Yield Space Pool matches principal token\n            address fyToken = IYield(y).fyToken();\n            if (IYield(y).fyToken() != principal) {\n                revert Exception(12, 0, 0, fyToken, principal);\n            }\n        }\n\n        // Swap underlying for PTs to lender\n        uint256 returned = yield(\n            u,\n            y,\n            a - a / feenominator,\n            address(this),\n            principal,\n            minimum\n        );\n\n        // Mint Illuminate PTs to msg.sender\n        IERC5095(principalToken(u, m)).authMint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned, a, msg.sender);\n\n        return returned;\n    }\n\n    /// @notice lend method signature for Swivel\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a array of amounts of underlying tokens lent to each order in the orders array\n    /// @param y Yield Space Pool for the Illuminate PT in this market\n    /// @param o array of Swivel orders being filled\n    /// @param s array of signatures for each order in the orders array\n    /// @param e flag to indicate if returned funds should be swapped in Yield Space Pool\n    /// @param premiumSlippage slippage limit, minimum amount to PTs to buy\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] memory a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s,\n        bool e,\n        uint256 premiumSlippage\n    ) external unpaused(u, m, p) returns (uint256) {\n        {\n            // Check that the principal is Swivel\n            if (p != uint8(MarketPlace.Principals.Swivel)) {\n                revert Exception(\n                    6,\n                    p,\n                    uint8(MarketPlace.Principals.Swivel),\n                    address(0),\n                    address(0)\n                );\n            }\n\n            // Lent represents the total amount of underlying to be lent\n            uint256 lent = swivelAmount(a);\n\n            // Transfer underlying token from user to Illuminate\n            Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n\n            // Get the underlying balance prior to calling initiate\n            uint256 starting = IERC20(u).balanceOf(address(this));\n\n            // Verify and collect the fee\n            {\n                // Calculate fee for the total amount to be lent\n                uint256 fee = lent / feenominator;\n\n                // Get last order to be processed's index\n                uint256 lastIndex = a.length - 1;\n\n                // Add the accumulated fees to the total\n                a[lastIndex] = a[lastIndex] - fee; // Revert here if fee not paid\n\n                // Extract fee\n                fees[u] += fee;\n            }\n\n            uint256 received;\n            {\n                // Get the starting amount of principal tokens\n                uint256 startingZcTokens = IERC20(\n                    IMarketPlace(marketPlace).token(u, m, p)\n                ).balanceOf(address(this));\n\n                // Fill the given orders on Swivel\n                ISwivel(swivelAddr).initiate(o, a, s);\n\n                if (e) {\n                    // Calculate the premium\n                    uint256 premium = IERC20(u).balanceOf(address(this)) -\n                        starting;\n\n                    // Swap the premium for Illuminate principal tokens\n                    swivelLendPremium(u, m, y, premium, premiumSlippage);\n                }\n\n                // Compute how many principal tokens were received\n                received =\n                    IERC20(IMarketPlace(marketPlace).token(u, m, p)).balanceOf(\n                        address(this)\n                    ) -\n                    startingZcTokens;\n            }\n\n            // Mint Illuminate principal tokens to the user\n            IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n            {\n                emit Lend(\n                    uint8(MarketPlace.Principals.Swivel),\n                    u,\n                    m,\n                    received,\n                    lent,\n                    msg.sender\n                );\n            }\n            return received;\n        }\n    }\n\n    /// @notice lend method signature for Element\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param e Element pool that is lent to\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address e,\n        bytes32 i\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Get the principal token for this market for Element\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer underlying token from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Track the accumulated fees\n        fees[u] = fees[u] + a / feenominator;\n\n        uint256 purchased;\n        {\n            // Calculate the amount to be lent\n            uint256 lent = a - a / feenominator;\n\n            // Create the variables needed to execute an Element swap\n            Element.FundManagement memory fund = Element.FundManagement({\n                sender: address(this),\n                recipient: payable(address(this)),\n                fromInternalBalance: false,\n                toInternalBalance: false\n            });\n\n            Element.SingleSwap memory swap = Element.SingleSwap({\n                poolId: i,\n                amount: lent,\n                kind: Element.SwapKind.GIVEN_IN,\n                assetIn: IAny(u),\n                assetOut: IAny(principal),\n                userData: '0x00000000000000000000000000000000000000000000000000000000000000'\n            });\n\n            // Conduct the swap on Element\n            purchased = elementSwap(e, swap, fund, r, d);\n        }\n\n        // Mint tokens to the user\n        IERC5095(principalToken(u, m)).authMint(msg.sender, purchased);\n\n        emit Lend(p, u, m, purchased, a, msg.sender);\n        return purchased;\n    }\n\n    /// @notice lend method signature for Pendle\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 returned;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = a / feenominator;\n            fees[u] = fees[u] + fee;\n\n            address[] memory path = new address[](2);\n            path[0] = u;\n            path[1] = principal;\n\n            // Swap on the Pendle Router using the provided market and params\n            returned = IPendle(pendleAddr).swapExactTokensForTokens(\n                a - fee,\n                r,\n                path,\n                address(this),\n                d\n            )[1];\n        }\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned, a, msg.sender);\n        return returned;\n    }\n\n    /// @notice lend method signature for APWine\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param x APWine router that executes the swap\n    /// @param pool the AMM pool used by APWine to execute the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address x,\n        address pool\n    ) external unpaused(u, m, p) returns (uint256) {\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 lent;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = a / feenominator;\n            fees[u] = fees[u] + fee;\n\n            // Calculate amount to be lent out\n            lent = a - fee;\n        }\n\n        // Get the starting APWine token balance\n        uint256 starting = IERC20(principal).balanceOf(address(this));\n\n        // Swap on the APWine Pool using the provided market and params\n        IAPWineRouter(x).swapExactAmountIn(\n            pool,\n            apwinePairPath(),\n            apwineTokenPath(),\n            lent,\n            r,\n            address(this),\n            d,\n            address(0)\n        );\n\n        // Calculate the amount of APWine principal tokens received after the swap\n        uint256 received = IERC20(principal).balanceOf(address(this)) -\n            starting;\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n        emit Lend(p, u, m, received, a, msg.sender);\n        return received;\n    }\n\n    /// @notice lend method signature for Tempus\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return when executing the swap (sets a limit to slippage)\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param x Tempus AMM that executes the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address x\n    ) external unpaused(u, m, p) returns (uint256) {\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 lent;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = a / feenominator;\n            fees[u] = fees[u] + fee;\n\n            // Calculate amount to be lent out\n            lent = a - fee;\n        }\n\n        // Get the starting balance of the principal token\n        uint256 start = IERC20(principal).balanceOf(address(this));\n\n        // Get the Tempus Router from the principal token\n        address controller = ITempusPool(ITempusToken(principal).pool())\n            .controller();\n\n        // Swap on the Tempus Router using the provided market and params\n        ITempus(controller).depositAndFix(x, lent, true, r, d);\n\n        // Calculate the amount of Tempus principal tokens received after the deposit\n        uint256 received = IERC20(principal).balanceOf(address(this)) - start;\n\n        // Verify that a minimum number of principal tokens were received\n        if (received < r) {\n            revert Exception(11, received, r, address(0), address(0));\n        }\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n        emit Lend(p, u, m, received, a, msg.sender);\n        return received;\n    }\n\n    /// @notice lend method signature for Sense\n    /// @dev this method can be called before maturity to lend to Sense while minting Illuminate tokens\n    /// @dev Sense provides a [divider] contract that splits [target] assets (underlying) into PTs and YTs. Each [target] asset has a [series] of contracts, each identifiable by their [maturity].\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param x AMM that is used to conduct the swap\n    /// @param s Sense's maturity for the given market\n    /// @param adapter Sense's adapter necessary to facilitate the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint128 a,\n        uint256 r,\n        address x,\n        uint256 s,\n        address adapter\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Retrieve the principal token for this market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).token(u, m, p));\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Determine the fee\n        uint256 fee = a / feenominator;\n\n        // Add the accumulated fees to the total\n        fees[u] = fees[u] + fee;\n\n        // Determine lent amount after fees\n        uint256 lent = a - fee;\n\n        // Stores the amount of principal tokens received in swap for underlying\n        uint256 received;\n        {\n            // Get the starting balance of the principal token\n            uint256 starting = token.balanceOf(address(this));\n\n            // Swap those t"
    }
  ]
}