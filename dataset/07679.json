{
  "Title": "[M-04] Pool designed to be upgradeable but does not set owner, making it un-upgradeable",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Pool.sol#L13\n\n\n# Vulnerability details\n\n## Description\n\nThe docs state:\n\"*The pool allows user to predeposit ETH so that it can be used when a seller takes their bid. It uses an ERC1967 proxy pattern and only the exchange contract is permitted to make transfers.*\"\n\nPool is designed as an ERC1967 upgradeable proxy which handles balances of users in Not Fungible. Users may interact via deposit and withdraw with the pool, and use the funds in it to pay for orders in the Exchange.\n\nPool is declared like so:\n```\ncontract Pool is IPool, OwnableUpgradeable, UUPSUpgradeable {\n\tfunction _authorizeUpgrade(address) internal override onlyOwner {}\n\t...\n```\n\nImportantly, it has no constructor and no initializers. The issue is that when using upgradeable contracts, it is important to implement an initializer which will call the base contract's initializers in turn. See how this is done correctly in Exchange.sol:\n\n```\n/* Constructor (for ERC1967) */\nfunction initialize(\n    IExecutionDelegate _executionDelegate,\n    IPolicyManager _policyManager,\n    address _oracle,\n    uint _blockRange\n) external initializer {\n    __Ownable_init();\n    isOpen = 1;\n\t  ...\n}\n```\n\nSince Pool skips the \\_\\_Ownable_init initialization call, this logic is skipped:\n```\nfunction __Ownable_init() internal onlyInitializing {\n    __Ownable_init_unchained();\n}\nfunction __Ownable_init_unchained() internal onlyInitializing {\n    _transferOwnership(_msgSender());\n}\n```\n\nTherefore, the contract owner stays zero initialized, and this means any use of onlyOwner will always revert.\n\nThe only use of onlyOwner in Pool is here:\n```\nfunction _authorizeUpgrade(address) internal override onlyOwner {}\n```\n\nThe impact is that when the upgrade mechanism will check caller is authorized, it will revert. Therefore, the contract is unexpectedly unupgradeable. Whenever the EXCHANGE or SWAP address, or some functionality needs to be changed, it would not be possible.\n\n## Impact\n\nThe Pool contract is designed to be upgradeable but is actually not upgradeable\n\n## Proof of Concept\n\nIn the 'pool' test in execution.test.ts, add the following lines:\n```\nit('owner configured correctly', async () => {\n  expect(await pool.owner()).to.be.equal(admin.address);\n});\n```\n\nIt shows that the pool after deployment has owner as 0x0000...00\n\n## Tools Used\n\nManual audit, hardhat\n\n## Recommended Mitigation Steps\n\nImplement an initializer for Pool similarly to the Exchange.sol contract.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-non-fungible-trading-contest",
  "Code": [
    {
      "filename": "contracts/Pool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"./interfaces/IPool.sol\";\n\n/**\n * @title Pool\n * @dev ETH pool; funds can only be transferred by Exchange or Swap\n */\ncontract Pool is IPool, OwnableUpgradeable, UUPSUpgradeable {\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    address private constant EXCHANGE = 0x707531c9999AaeF9232C8FEfBA31FBa4cB78d84a;\n    // TODO: set proper address before deployment\n    address private constant SWAP = 0x707531c9999AaeF9232C8FEfBA31FBa4cB78d84a;\n\n    mapping(address => uint256) private _balances;\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /**\n     * @dev receive deposit function\n     */\n    receive() external payable {\n        deposit();\n    }\n\n    /**\n     * @dev deposit ETH into pool\n     */\n    function deposit() public payable {\n        _balances[msg.sender] += msg.value;\n        emit Transfer(msg.sender, address(0), msg.value);\n    }\n\n    /**\n     * @dev withdraw ETH from pool\n     * @param amount Amount to withdraw\n     */\n    function withdraw(uint256 amount) public {\n        require(_balances[msg.sender] >= amount);\n        _balances[msg.sender] -= amount;\n        (bool success,) = payable(msg.sender).call{value: amount}(\"\");\n        require(success);\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    /**\n     * @dev transferFrom Transfer balances within pool; only callable by Swap and Exchange\n     * @param from Pool fund sender\n     * @param to Pool fund recipient\n     * @param amount Amount to transfer\n     */\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        returns (bool)\n    {\n        if (msg.sender != EXCHANGE && msg.sender != SWAP) {\n            revert('Caller is not authorized to transfer');\n        }\n        _transfer(from, to, amount);\n\n        return true;\n    }\n\n    function _transfer(address from, address to, uint256 amount) private {\n        require(_balances[from] >= amount);\n        require(to != address(0));\n        _balances[from] -= amount;\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n    }\n\n    function balanceOf(address user) public view returns (uint256) {\n        return _balances[user];\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n}"
    }
  ]
}