{
  "Title": "[G-01]  Save gas by checking against default WETH address",
  "Content": "You can save a Gcoldsload (**2100 gas**) in the address provider, plus the **100 gas** overhead of the external call, for every `receive()`, by creating an immutable `DEFAULT_WETH` variable which will store the initial WETH address, and change the require statement to be: `require(msg.ender == DEFAULT_WETH || msg.sender == <etc>)`.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /paraspace-core/contracts/protocol/pool/PoolCore.sol\n\n802      receive() external payable {\n803          require(\n804              msg.sender ==\n805                  address(IPoolAddressesProvider(ADDRESSES_PROVIDER).getWETH()),\n806              \"Receive not allowed\"\n807          );\n808:     }\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/pool/PoolCore.sol#L802-L808\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-11-paraspace",
  "Code": [
    {
      "filename": "paraspace-core/contracts/protocol/pool/PoolCore.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {ParaVersionedInitializable} from \"../libraries/paraspace-upgradeability/ParaVersionedInitializable.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {PoolLogic} from \"../libraries/logic/PoolLogic.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {SupplyLogic} from \"../libraries/logic/SupplyLogic.sol\";\nimport {MarketplaceLogic} from \"../libraries/logic/MarketplaceLogic.sol\";\nimport {BorrowLogic} from \"../libraries/logic/BorrowLogic.sol\";\nimport {LiquidationLogic} from \"../libraries/logic/LiquidationLogic.sol\";\nimport {AuctionLogic} from \"../libraries/logic/AuctionLogic.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {IERC20WithPermit} from \"../../interfaces/IERC20WithPermit.sol\";\nimport {IPoolAddressesProvider} from \"../../interfaces/IPoolAddressesProvider.sol\";\nimport {IPoolCore} from \"../../interfaces/IPoolCore.sol\";\nimport {INToken} from \"../../interfaces/INToken.sol\";\nimport {IACLManager} from \"../../interfaces/IACLManager.sol\";\nimport {PoolStorage} from \"./PoolStorage.sol\";\nimport {FlashClaimLogic} from \"../libraries/logic/FlashClaimLogic.sol\";\nimport {Address} from \"../../dependencies/openzeppelin/contracts/Address.sol\";\nimport {IERC721Receiver} from \"../../dependencies/openzeppelin/contracts/IERC721Receiver.sol\";\nimport {IMarketplace} from \"../../interfaces/IMarketplace.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {ParaReentrancyGuard} from \"../libraries/paraspace-upgradeability/ParaReentrancyGuard.sol\";\nimport {IAuctionableERC721} from \"../../interfaces/IAuctionableERC721.sol\";\nimport {IReserveAuctionStrategy} from \"../../interfaces/IReserveAuctionStrategy.sol\";\nimport {IWETH} from \"../../misc/interfaces/IWETH.sol\";\n\n/**\n * @title Pool contract\n *\n * @notice Main point of interaction with an ParaSpace protocol's market\n * - Users can:\n *   - Supply\n *   - Withdraw\n *   - Borrow\n *   - Repay\n *   - Liquidate positions\n * @dev To be covered by a proxy contract, owned by the PoolAddressesProvider of the specific market\n * @dev All admin functions are callable by the PoolConfigurator contract defined also in the\n *   PoolAddressesProvider\n **/\ncontract PoolCore is\n    ParaVersionedInitializable,\n    ParaReentrancyGuard,\n    PoolStorage,\n    IPoolCore\n{\n    using ReserveLogic for DataTypes.ReserveData;\n\n    uint256 public constant POOL_REVISION = 1;\n    IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return POOL_REVISION;\n    }\n\n    /**\n     * @dev Constructor.\n     * @param provider The address of the PoolAddressesProvider contract\n     */\n    constructor(IPoolAddressesProvider provider) {\n        ADDRESSES_PROVIDER = provider;\n    }\n\n    /**\n     * @notice Initializes the Pool.\n     * @dev Function is invoked by the proxy contract when the Pool contract is added to the\n     * PoolAddressesProvider of the market.\n     * @dev Caching the address of the PoolAddressesProvider in order to reduce gas consumption on subsequent operations\n     * @param provider The address of the PoolAddressesProvider\n     **/\n    function initialize(IPoolAddressesProvider provider)\n        external\n        virtual\n        initializer\n    {\n        require(\n            provider == ADDRESSES_PROVIDER,\n            Errors.INVALID_ADDRESSES_PROVIDER\n        );\n\n        RGStorage storage rgs = rgStorage();\n\n        rgs._status = _NOT_ENTERED;\n    }\n\n    /// @inheritdoc IPoolCore\n    function supply(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external virtual override nonReentrant {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        SupplyLogic.executeSupply(\n            ps._reserves,\n            ps._usersConfig[onBehalfOf],\n            DataTypes.ExecuteSupplyParams({\n                asset: asset,\n                amount: amount,\n                onBehalfOf: onBehalfOf,\n                payer: msg.sender,\n                referralCode: referralCode\n            })\n        );\n    }\n\n    /// @inheritdoc IPoolCore\n    function supplyERC721(\n        address asset,\n        DataTypes.ERC721SupplyParams[] calldata tokenData,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external virtual override nonReentrant {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        SupplyLogic.executeSupplyERC721(\n            ps._reserves,\n            ps._usersConfig[onBehalfOf],\n            DataTypes.ExecuteSupplyERC721Params({\n                asset: asset,\n                tokenData: tokenData,\n                onBehalfOf: onBehalfOf,\n                payer: msg.sender,\n                referralCode: referralCode\n            })\n        );\n    }\n\n    /// @inheritdoc IPoolCore\n    function supplyERC721FromNToken(\n        address asset,\n        DataTypes.ERC721SupplyParams[] calldata tokenData,\n        address onBehalfOf\n    ) external virtual override nonReentrant {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        SupplyLogic.executeSupplyERC721FromNToken(\n            ps._reserves,\n            ps._usersConfig[onBehalfOf],\n            DataTypes.ExecuteSupplyERC721Params({\n                asset: asset,\n                tokenData: tokenData,\n                onBehalfOf: onBehalfOf,\n                payer: address(0),\n                referralCode: 0\n            })\n        );\n    }\n\n    /// @inheritdoc IPoolCore\n    function supplyWithPermit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external virtual override nonReentrant {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        // Need to accommodate ERC721 and ERC1155 here\n        IERC20WithPermit(asset).permit(\n            msg.sender,\n            address(this),\n            amount,\n            deadline,\n            permitV,\n            permitR,\n            permitS\n        );\n        SupplyLogic.executeSupply(\n            ps._reserves,\n            ps._usersConfig[onBehalfOf],\n            DataTypes.ExecuteSupplyParams({\n                asset: asset,\n                amount: amount,\n                onBehalfOf: onBehalfOf,\n                payer: msg.sender,\n                referralCode: referralCode\n            })\n        );\n    }\n\n    /// @inheritdoc IPoolCore\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external virtual override nonReentrant returns (uint256) {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        return\n            SupplyLogic.executeWithdraw(\n                ps._reserves,\n                ps._reservesList,\n                ps._usersConfig[msg.sender],\n                DataTypes.ExecuteWithdrawParams({\n                    asset: asset,\n                    amount: amount,\n                    to: to,\n                    reservesCount: ps._reservesCount,\n                    oracle: ADDRESSES_PROVIDER.getPriceOracle()\n                })\n            );\n    }\n\n    /// @inheritdoc IPoolCore\n    function withdrawERC721(\n        address asset,\n        uint256[] calldata tokenIds,\n        address to\n    ) external virtual override nonReentrant returns (uint256) {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        return\n            SupplyLogic.executeWithdrawERC721(\n                ps._reserves,\n                ps._reservesList,\n                ps._usersConfig[msg.sender],\n                DataTypes.ExecuteWithdrawERC721Params({\n                    asset: asset,\n                    tokenIds: tokenIds,\n                    to: to,\n                    reservesCount: ps._reservesCount,\n                    oracle: ADDRESSES_PROVIDER.getPriceOracle()\n                })\n            );\n    }\n\n    function decreaseUniswapV3Liquidity(\n        address asset,\n        uint256 tokenId,\n        uint128 liquidityDecrease,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        bool receiveEthAsWeth\n    ) external virtual override nonReentrant {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        return\n            SupplyLogic.executeDecreaseUniswapV3Liquidity(\n                ps._reserves,\n                ps._reservesList,\n                ps._usersConfig[msg.sender],\n                DataTypes.ExecuteDecreaseUniswapV3LiquidityParams({\n                    user: msg.sender,\n                    asset: asset,\n                    tokenId: tokenId,\n                    reservesCount: ps._reservesCount,\n                    liquidityDecrease: liquidityDecrease,\n                    amount0Min: amount0Min,\n                    amount1Min: amount1Min,\n                    receiveEthAsWeth: receiveEthAsWeth,\n                    oracle: ADDRESSES_PROVIDER.getPriceOracle()\n                })\n            );\n    }\n\n    /// @inheritdoc IPoolCore\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external virtual override nonReentrant {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        BorrowLogic.executeBorrow(\n            ps._reserves,\n            ps._reservesList,\n            ps._usersConfig[onBehalfOf],\n            DataTypes.ExecuteBorrowParams({\n                asset: asset,\n                user: msg.sender,\n                onBehalfOf: onBehalfOf,\n                amount: amount,\n                referralCode: referralCode,\n                releaseUnderlying: true,\n                reservesCount: ps._reservesCount,\n                oracle: ADDRESSES_PROVIDER.getPriceOracle(),\n                priceOracleSentinel: ADDRESSES_PROVIDER.getPriceOracleSentinel()\n            })\n        );\n    }\n\n    /// @inheritdoc IPoolCore\n    function repay(\n        address asset,\n        uint256 amount,\n        address onBehalfOf\n    ) external virtual override nonReentrant returns (uint256) {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        return\n            BorrowLogic.executeRepay(\n                ps._reserves,\n                ps._usersConfig[onBehalfOf],\n                DataTypes.ExecuteRepayParams({\n                    asset: asset,\n                    amount: amount,\n                    onBehalfOf: onBehalfOf,\n                    usePTokens: false\n                })\n            );\n    }\n\n    /// @inheritdoc IPoolCore\n    function repayWithPTokens(address asset, uint256 amount)\n        external\n        virtual\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        return\n            BorrowLogic.executeRepay(\n                ps._reserves,\n                ps._usersConfig[msg.sender],\n                DataTypes.ExecuteRepayParams({\n                    asset: asset,\n                    amount: amount,\n                    onBehalfOf: msg.sender,\n                    usePTokens: true\n                })\n            );\n    }\n\n    /// @inheritdoc IPoolCore\n    function repayWithPermit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external virtual override nonReentrant returns (uint256) {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        {\n            IERC20WithPermit(asset).permit(\n                msg.sender,\n                address(this),\n                amount,\n                deadline,\n                permitV,\n                permitR,\n                permitS\n            );\n        }\n        {\n            DataTypes.ExecuteRepayParams memory params = DataTypes\n                .ExecuteRepayParams({\n                    asset: asset,\n                    amount: amount,\n                    onBehalfOf: onBehalfOf,\n                    usePTokens: false\n                });\n            return\n                BorrowLogic.executeRepay(\n                    ps._reserves,\n                    ps._usersConfig[onBehalfOf],\n                    params\n                );\n        }\n    }\n\n    /// @inheritdoc IPoolCore\n    function setUserUseERC20AsCollateral(address asset, bool useAsCollateral)\n        external\n        virtual\n        override\n        nonReentrant\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        SupplyLogic.executeUseERC20AsCollateral(\n            ps._reserves,\n            ps._reservesList,\n            ps._usersConfig[msg.sender],\n            asset,\n            useAsCollateral,\n            ps._reservesCount,\n            ADDRESSES_PROVIDER.getPriceOracle()\n        );\n    }\n\n    function setUserUseERC721AsCollateral(\n        address asset,\n        uint256[] calldata tokenIds,\n        bool useAsCollateral\n    ) external virtual override nonReentrant {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        if (useAsCollateral) {\n            SupplyLogic.executeCollateralizeERC721(\n                ps._reserves,\n                ps._usersConfig[msg.sender],\n                asset,\n                tokenIds,\n                msg.sender\n            );\n        } else {\n            SupplyLogic.executeUncollateralizeERC721(\n                ps._reserves,\n                ps._reservesList,\n                ps._usersConfig[msg.sender],\n                asset,\n                tokenIds,\n                msg.sender,\n                ps._reservesCount,\n                ADDRESSES_PROVIDER.getPriceOracle()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolCore\n    function liquidateERC20(\n        address collateralAsset,\n        address liquidationAsset,\n        address borrower,\n        uint256 liquidationAmount,\n        bool receivePToken\n    ) external payable virtual override nonReentrant {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        LiquidationLogic.executeLiquidateERC20(\n            ps._reserves,\n            ps._reservesList,\n            ps._usersConfig,\n            DataTypes.ExecuteLiquidateParams({\n                reservesCount: ps._reservesCount,\n                liquidationAmount: liquidationAmount,\n                auctionRecoveryHealthFactor: ps._auctionRecoveryHealthFactor,\n                weth: ADDRESSES_PROVIDER.getWETH(),\n                collateralAsset: collateralAsset,\n                liquidationAsset: liquidationAsset,\n                borrower: borrower,\n                liquidator: msg.sender,\n                receiveXToken: receivePToken,\n                priceOracle: ADDRESSES_PROVIDER.getPriceOracle(),\n                priceOracleSentinel: ADDRESSES_PROVIDER.getPriceOracleSentinel(),\n                collateralTokenId: 0\n            })\n        );\n    }\n\n    /// @inheritdoc IPoolCore\n    function liquidateERC721(\n        address collateralAsset,\n        address borrower,\n        uint256 collateralTokenId,\n        uint256 maxLiquidationAmount,\n        bool receiveNToken\n    ) external payable virtual override nonReentrant {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        LiquidationLogic.executeLiquidateERC721(\n            ps._reserves,\n            ps._reservesList,\n            ps._usersConfig,\n            DataTypes.ExecuteLiquidateParams({\n                reservesCount: ps._reservesCount,\n                liquidationAmount: maxLiquidationAmount,\n                auctionRecoveryHealthFactor: ps._auctionRecoveryHealthFactor,\n                weth: ADDRESSES_PROVIDER.getWETH(),\n                collateralAsset: collateralAsset,\n                liquidationAsset: ADDRESSES_PROVIDER.getWETH(),\n                collateralTokenId: collateralTokenId,\n                borrower: borrower,\n                liquidator: msg.sender,\n                receiveXToken: receiveNToken,\n                priceOracle: ADDRESSES_PROVIDER.getPriceOracle(),\n                priceOracleSentinel: ADDRESSES_PROVIDER.getPriceOracleSentinel()\n            })\n        );\n    }\n\n    /// @inheritdoc IPoolCore\n    function startAuction(\n        address user,\n        address collateralAsset,\n        uint256 collateralTokenId\n    ) external override nonReentrant {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        AuctionLogic.executeStartAuction(\n            ps._reserves,\n            ps._reservesList,\n            ps._usersConfig,\n            DataTypes.ExecuteAuctionParams({\n                reservesCount: ps._reservesCount,\n                auctionRecoveryHealthFactor: ps._auctionRecoveryHealthFactor,\n                collateralAsset: collateralAsset,\n                collateralTokenId: collateralTokenId,\n                user: user,\n                priceOracle: ADDRESSES_PROVIDER.getPriceOracle()\n            })\n        );\n    }\n\n    /// @inheritdoc IPoolCore\n    function endAuction(\n        address user,\n        address collateralAsset,\n        uint256 collateralTokenId\n    ) external override nonReentrant {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        AuctionLogic.executeEndAuction(\n            ps._reserves,\n            ps._reservesList,\n            ps._usersConfig,\n            DataTypes.ExecuteAuctionParams({\n                reservesCount: ps._reservesCount,\n                auctionRecoveryHealthFactor: ps._auctionRecoveryHealthFactor,\n                collateralAsset: collateralAsset,\n                collateralTokenId: collateralTokenId,\n                user: user,\n                priceOracle: ADDRESSES_PROVIDER.getPriceOracle()\n            })\n        );\n    }\n\n    /// @inheritdoc IPoolCore\n    function flashClaim(\n        address receiverAddress,\n        address nftAsset,\n        uint256[] calldata nftTokenIds,\n        bytes calldata params\n    ) external virtual override nonReentrant {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        FlashClaimLogic.executeFlashClaim(\n            ps,\n            DataTypes.ExecuteFlashClaimParams({\n                receiverAddress: receiverAddress,\n                nftAsset: nftAsset,\n                nftTokenIds: nftTokenIds,\n                params: params,\n                oracle: ADDRESSES_PROVIDER.getPriceOracle()\n            })\n        );\n    }\n\n    /// @inheritdoc IPoolCore\n    function getReserveData(address asset)\n        external\n        view\n        virtual\n        override\n        returns (DataTypes.ReserveData memory)\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        return ps._reserves[asset];\n    }\n\n    /// @inheritdoc IPoolCore\n    function getConfiguration(address asset)\n        external\n        view\n        virtual\n        override\n        returns (DataTypes.ReserveConfigurationMap memory)\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        return ps._reserves[asset].configuration;\n    }\n\n    /// @inheritdoc IPoolCore\n    function getUserConfiguration(address user)\n        external\n        view\n        virtual\n        override\n        returns (DataTypes.UserConfigurationMap memory)\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        return ps._usersConfig[user];\n    }\n\n    /// @inheritdoc IPoolCore\n    function getReserveNormalizedIncome(address asset)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        return ps._reserves[asset].getNormalizedIncome();\n    }\n\n    /// @inheritdoc IPoolCore\n    function getReserveNormalizedVariableDebt(address asset)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        return ps._reserves[asset].getNormalizedDebt();\n    }\n\n    /// @inheritdoc IPoolCore\n    function getReservesList()\n        external\n        view\n        virtual\n        override\n        returns (address[] memory)\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        uint256 reservesListCount = ps._reservesCount;\n        uint256 droppedReservesCount = 0;\n        address[] memory reservesList = new address[](reservesListCount);\n\n        for (uint256 i = 0; i < reservesListCount; i++) {\n            if (ps._reservesList[i] != address(0)) {\n                reservesList[i - droppedReservesCount] = ps._reservesList[i];\n            } else {\n                droppedReservesCount++;\n            }\n        }\n\n        // Reduces the length of the reserves array by `droppedReservesCount`\n        assembly {\n            mstore(reservesList, sub(reservesListCount, droppedReservesCount))\n        }\n        return reservesList;\n    }\n\n    /// @inheritdoc IPoolCore\n    function getReserveAddressById(uint16 id) external view returns (address) {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        return ps._reservesList[id];\n    }\n\n    /// @inheritdoc IPoolCore\n    function MAX_NUMBER_RESERVES()\n        external\n        view\n        virtual\n        override\n        returns (uint16)\n    {\n        return ReserveConfiguration.MAX_RESERVES_COUNT;\n    }\n\n    /// @inheritdoc IPoolCore\n    function AUCTION_RECOVERY_HEALTH_FACTOR()\n        external\n        view\n        virtual\n        override\n        returns (uint64)\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        return ps._auctionRecoveryHealthFactor;\n    }\n\n    /// @inheritdoc IPoolCore\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        bool usedAsCollateral,\n        uint256 amount,\n        uint256 balanceFromBefore,\n        uint256 balanceToBefore\n    ) external virtual override {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        require(\n            msg.sender == ps._reserves[asset].xTokenAddress,\n            Errors.CALLER_NOT_XTOKEN\n        );\n        SupplyLogic.executeFinalizeTransferERC20(\n            ps._reserves,\n            ps._reservesList,\n            ps._usersConfig,\n            DataTypes.FinalizeTransferParams({\n                asset: asset,\n                from: from,\n                to: to,\n                usedAsCollateral: usedAsCollateral,\n                amount: amount,\n                balanceFromBefore: balanceFromBefore,\n                balanceToBefore: balanceToBefore,\n                reservesCount: ps._reservesCount,\n                oracle: ADDRESSES_PROVIDER.getPriceOracle()\n            })\n        );\n    }\n\n    /// @inheritdoc IPoolCore\n    function finalizeTransferERC721(\n        address asset,\n        uint256 tokenId,\n        address from,\n        address to,\n        bool usedAsCollateral,\n        uint256 balanceFromBefore,\n        uint256 balanceToBefore\n    ) external virtual override {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        require(\n            msg.sender == ps._reserves[asset].xTokenAddress,\n            Errors.CALLER_NOT_XTOKEN\n        );\n        SupplyLogic.executeFinalizeTransferERC721(\n            ps._reserves,\n            ps._reservesList,\n            ps._usersConfig,\n            DataTypes.FinalizeTransferERC721Params({\n                asset: asset,\n                from: from,\n                to: to,\n                usedAsCollateral: usedAsCollateral,\n                tokenId: tokenId,\n                balanceFromBefore: balanceFromBefore,\n                balanceToBefore: balanceToBefore,\n                reservesCount: ps._reservesCount,\n                oracle: ADDRESSES_PROVIDER.getPriceOracle()\n            })\n        );\n    }\n\n    /// @inheritdoc IPoolCore\n    function getAuctionData(address ntokenAsset, uint256 tokenId)\n        external\n        view\n        virtual\n        override\n        returns (DataTypes.AuctionData memory auctionData)\n    {\n        DataTypes.PoolStorage storage ps = poolStorage();\n\n        address underlyingAsset = INToken(ntokenAsset)\n            .UNDERLYING_ASSET_ADDRESS();\n        DataTypes.ReserveData storage reserve = ps._reserves[underlyingAsset];\n        require(\n            reserve.id != 0 || ps._reservesList[0] == underlyingAsset,\n            Errors.ASSET_NOT_LISTED\n        );\n\n        if (reserve.auctionStrategyAddress != address(0)) {\n            uint256 startTime = IAuctionableERC721(ntokenAsset)\n                .getAuctionData(tokenId)\n                .startTime;\n            IReserveAuctionStrategy auctionStrategy = IReserveAuctionStrategy(\n                reserve.auctionStrategyAddress\n            );\n\n            auctionData.startTime = startTime;\n            auctionData.asset = underlyingAsset;\n            auctionData.tokenId = tokenId;\n            auctionData.currentPriceMultiplier = auctionStrategy\n                .calculateAuctionPriceMultiplier(startTime, block.timestamp);\n\n            auctionData.maxPriceMultiplier = auctionStrategy\n                .getMaxPriceMultiplier();\n            auctionData.minExpPriceMultiplier = auctionStrategy\n                .getMinExpPriceMultiplier();\n            auctionData.minPriceMultiplier = auctionStrategy\n                .getMinPriceMultiplier();\n            auctionData.stepLinear = auctionStrategy.getStepLinear();\n            auctionData.stepExp = auctionStrategy.getStepExp();\n            auctionData.tickLength = auctionStrategy.getTickLength();\n        }\n    }\n\n    // This function is necessary when receive erc721 from looksrare\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) external virtual returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    receive() external payable {\n        require(\n            msg.sender ==\n                address(IPoolAddressesProvider(ADDRESSES_PROVIDER).getWETH()),\n            \"Receive not allowed\"\n        );\n    }\n}"
    }
  ]
}