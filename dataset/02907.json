{
  "Title": "H-6: UNION rewards issuance can be maximized without providing credit",
  "Content": "# Issue H-6: UNION rewards issuance can be maximized without providing credit \n\nSource: https://github.com/sherlock-audit/2022-10-union-finance-judging/issues/49 \n\n## Found by \nhyh\n\n## Summary\n\nUNION rewards accounting is run on user direct request and stake/unstake only, and due to this can be gamed to obtain maximal rewards without any involvement in UNION, and in a risk-free way.\n\n## Vulnerability Detail\n\nReward calculation currently is being invoked only as a part of user-facing stake(), unstake() and withdrawRewards(). Notice that withdrawRewards() calculates the rewards for `msg.sender`, so it cannot be triggered automatically by a script for all active users to refresh their accounting. This way UNION rewards are calculated only per user request and there are no updates on key account state changing operations.\n\nThis combination allows a malicious user to receive rewards with maximal `2x` multiplier without participating in UNION, particularly without bearing any credit risk or interest expenses. \n\nSay Bob the staker wants to maximize UNION rewards and minimize the corresponding risk. Bob stakes and do nothing else for a prolonged period, say 2 years. Then he becomes a member, loans to himself the full stake via another account and immediately calls withdrawRewards(), obtaining rewards for the whole 2 year period, his full stake, with the maximal multiplier, i.e. with `_getRewardsMultiplier` of `2`.\n\n## Impact\n\nBloated UNION rewards emissions attacker initiates dilute holdings of the honest members who do not time their withdrawRewards() calls to the points of reward multiplier maximization.\n\nThis is monetary loss for all UNION holders (as total emission is increased), and particularly for the stakers who actually use the system (as specifically new emission is increased), i.e. in result the attacker steals from all holders/stakers by inflating UNION emission.\n\nSetting severity to be high as there are no specific preconditions for the attack, it can be carried out by any UNION staker.\n\n## Code Snippet \n\nThe only function that updates the rewards due to a particular user is Comptroller's _calculateRewardsByBlocks().\n\n_calculateRewardsByBlocks() calculates the rewards based on the current state of a user:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/token/Comptroller.sol#L396-L429\n\n```solidity\n    function _calculateRewardsByBlocks(\n        address account,\n        address token,\n        uint256 pastBlocks,\n        Info memory userInfo,\n        UserManagerState memory userManagerState,\n        UserManagerAccountState memory userManagerAccountState\n    ) internal view returns (uint256) {\n        IUserManager userManagerContract = _getUserManager(token);\n\n        // Lookup account state from UserManager\n        userManagerAccountState.totalStaked = userManagerContract.getStakerBalance(account);\n        userManagerAccountState.totalLocked = userManagerContract.getTotalLockedStake(account);\n        userManagerAccountState.isMember = userManagerContract.checkIsMember(account);\n\n        uint256 inflationIndex = _getRewardsMultiplier(\n            userManagerAccountState.totalStaked,\n            userManagerAccountState.totalLocked,\n            userManagerAccountState.totalFrozen,\n            userManagerAccountState.isMember\n        );\n\n        return\n            userInfo.accrued +\n            _calculateRewards(\n                account,\n                token,\n                userManagerState.totalStaked,\n                userManagerAccountState.totalStaked,\n                userManagerAccountState.pastBlocksFrozenCoinAge,\n                pastBlocks,\n                inflationIndex\n            );\n    }\n```\n\nSpecifically, `inflationIndex` is based solely on the current state of user's account:\n\n```solidity\ninflationIndex = _getRewardsMultiplier(\n            userManagerAccountState.totalStaked,\n            userManagerAccountState.totalLocked,\n            userManagerAccountState.totalFrozen,\n            userManagerAccountState.isMember\n        )\n```\n\n_calculateRewards() multiplies the whole `(curInflationIndex - startInflationIndex).wadMul(effectiveStakeAmount)` by the `inflationIndex`:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/token/Comptroller.sol#L443-L466\n\n```solidity\n    function _calculateRewards(\n        address account,\n        address token,\n        uint256 totalStaked,\n        uint256 userStaked,\n        uint256 frozenCoinAge,\n        uint256 pastBlocks,\n        uint256 inflationIndex\n    ) internal view returns (uint256) {\n        uint256 startInflationIndex = users[account][token].inflationIndex;\n        if (userStaked * pastBlocks < frozenCoinAge) revert FrozenCoinAge();\n\n        if (userStaked == 0 || totalStaked == 0 || startInflationIndex == 0 || pastBlocks == 0) {\n            return 0;\n        }\n\n        uint256 effectiveStakeAmount = (userStaked * pastBlocks - frozenCoinAge) / pastBlocks;\n\n        uint256 curInflationIndex = _getInflationIndexNew(totalStaked, pastBlocks);\n\n        if (curInflationIndex < startInflationIndex) revert InflationIndexTooSmall();\n\n        return (curInflationIndex - startInflationIndex).wadMul(effectiveStakeAmount).wadMul(inflationIndex);\n    }\n```\n\n`inflationIndex = _getRewardsMultiplier(...)` is based on the current state of a user:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/token/Comptroller.sol#L523-L543\n\n```solidity\n    function _getRewardsMultiplier(\n        uint256 userStaked,\n        uint256 lockedStake,\n        uint256 totalFrozen_,\n        bool isMember_\n    ) internal pure returns (uint256) {\n        if (isMember_) {\n            if (userStaked == 0 || totalFrozen_ >= lockedStake) {\n                return memberRatio;\n            }\n\n            uint256 effectiveLockedAmount = lockedStake - totalFrozen_;\n            uint256 effectiveStakeAmount = userStaked - totalFrozen_;\n\n            uint256 lendingRatio = effectiveLockedAmount.wadDiv(effectiveStakeAmount);\n\n            return lendingRatio + memberRatio;\n        } else {\n            return nonMemberRatio;\n        }\n    }\n```\n\n_calculateRewardsByBlocks() is invoked in Comptroller only as a part of two call sequences:\n\ncalculateRewards() -> calculateRewardsByBlocks() -> _calculateRewardsByBlocks(),\n\nwithdrawRewards() -> _calculateRewardsByBlocks().\n\nComptroller's calculateRewards() and calculateRewardsByBlocks() are public views, not used elsewhere:\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/token/Comptroller.sol#L175-L211\n\n```solidity\n    /**\n     *  @dev Calculate unclaimed rewards based on blocks\n     *  @param account User address\n     *  @param token Staking token address\n     *  @param futureBlocks Number of blocks in the future\n     *  @return Unclaimed rewards\n     */\n    function calculateRewardsByBlocks(\n        address account,\n        address token,\n        uint256 futureBlocks\n    ) public view override returns (uint256) {\n        IUserManager userManager = _getUserManager(token);\n\n        // Lookup account stataddress accounte from UserManager\n        (\n            UserManagerAccountState memory userManagerAccountState,\n            Info memory userInfo,\n            uint256 pastBlocks\n        ) = _getUserInfoView(userManager, account, token, futureBlocks);\n\n        // Lookup global state from UserManager\n        UserManagerState memory userManagerState = _getUserManagerState(userManager);\n\n        return\n            _calculateRewardsByBlocks(account, token, pastBlocks, userInfo, userManagerState, userManagerAccountState);\n    }\n\n    /**\n     *  @dev Calculate currently unclaimed rewards\n     *  @param account Account address\n     *  @param token Staking token address\n     *  @return Unclaimed rewards\n     */\n    function calculateRewards(address account, address token) external view override returns (uint256) {\n        return calculateRewardsByBlocks(account, token, 0);\n    }\n```\n\nThis way the only rewards accounting update is Comptroller's withdrawRewards(), which is `onlyUserManager`, and is called via user facing UserManager's stake(), unstake() and withdrawRewards():\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/token/Comptroller.sol#L231-L257\n\n```solidity\n    function withdrawRewards(address account, address token)\n        external\n        override\n        whenNotPaused\n        onlyUserManager(token)\n        returns (uint256)\n    {\n        IUserManager userManager = _getUserManager(token);\n\n        // Lookup account state from UserManager\n        (\n            UserManagerAccountState memory userManagerAccountState,\n            Info memory userInfo,\n            uint256 pastBlocks\n        ) = _getUserInfo(userManager, account, token, 0);\n\n        // Lookup global state from UserManager\n        UserManagerState memory userManagerState = _getUserManagerState(userManager);\n\n        uint256 amount = _calculateRewardsByBlocks(\n            account,\n            token,\n            pastBlocks,\n            userInfo,\n            userManagerState,\n            userManagerAccountState\n        );\n```\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L710-L715\n\n```solidity\n    /**\n     *  @dev collect staker rewards from the comptroller\n     */\n    function withdrawRewards() external whenNotPaused nonReentrant {\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n    }\n```\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L664-L667\n\n```solidity\n    function stake(uint96 amount) public whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n```\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L691-L698\n\n```solidity\n    function unstake(uint96 amount) external whenNotPaused nonReentrant {\n        Staker storage staker = stakers[msg.sender];\n\n        // Stakers can only unstaked stake balance that is unlocked. Stake balance\n        // becomes locked when it is used to underwrite a borrow.\n        if (staker.stakedAmount - staker.locked < amount) revert InsufficientBalance();\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n```\n\nI.e. there are no others means to actualize the rewards, the users can update whenever they want and this can be the only update for them.\n\nThis allows to remove both credit risk and interest expenses. I.e. there is no dilemma either lend to self and pay the interest or lend to someone else and bear the credit risk: it's possible to do nothing, wait for any desired time, then lend to self for 1 block, neither paying any meaningful interest, nor bearing any credit risk, and reap the UNION rewards for the whole period with the maximal multiplier.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nMember registration and trust utilization change, i.e. borrowings and repayments, should trigger reward accounting update to correctly reflect the timing of changes in the reward formula.\n\nAs the most direct mitigation consider adding the staker's reward update to `registerMember`, `updateLocked` and `debtWriteOff` functions that change the account state and the values of the corresponding reward formula components.\n\nregisterMember():\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L633-L654\n\n```solidity\n    function registerMember(address newMember) public virtual whenNotPaused {\n        if (stakers[newMember].isMember) revert NoExistingMember();\n\n        uint256 count = 0;\n        uint256 vouchersLength = vouchers[newMember].length;\n\n        // Loop through all the vouchers to count how many active vouches there\n        // are that are greater than 0. Vouch is the min of stake and trust\n        for (uint256 i = 0; i < vouchersLength; i++) {\n            Vouch memory vouch = vouchers[newMember][i];\n            Staker memory staker = stakers[vouch.staker];\n            if (staker.stakedAmount > 0) count++;\n            if (count >= effectiveCount) break;\n        }\n\n        if (count < effectiveCount) revert NotEnoughStakers();\n+\tcomptroller.withdrawRewards(newMember, stakingToken);\n\n        stakers[newMember].isMember = true;\n        IUnionToken(unionToken).burnFrom(msg.sender, newMemberFee);\n\n        emit LogRegisterMember(msg.sender, newMember);\n    }\n```\n\nupdateLocked():\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L800-L841\n\n```solidity\n    function updateLocked(\n        address borrower,\n        uint96 amount,\n        bool lock\n    ) external onlyMarket {\n        uint96 remaining = amount;\n\n        for (uint256 i = 0; i < vouchers[borrower].length; i++) {\n            Vouch storage vouch = vouchers[borrower][i];\n            uint96 innerAmount;\n\n            if (lock) {\n                // Look up the staker and determine how much unlock stake they\n                // have available for the borrower to borrow. If there is 0\n                // then continue to the next voucher in the array\n                uint96 stakerLocked = stakers[vouch.staker].locked;\n                uint96 stakerStakedAmount = stakers[vouch.staker].stakedAmount;\n                uint96 availableStake = stakerStakedAmount - stakerLocked;\n                uint96 lockAmount = _min(availableStake, vouch.trust - vouch.locked);\n                if (lockAmount == 0) continue;\n\n                // Calculate the amount to add to the lock then\n                // add the extra amount to lock to the stakers locked amount\n                // and also update the vouches locked amount and lastUpdated block\n                innerAmount = _min(remaining, lockAmount);\n+\t\tcomptroller.withdrawRewards(vouch.staker, stakingToken);                \n                stakers[vouch.staker].locked = stakerLocked + innerAmount;\n                vouch.locked += innerAmount;\n                vouch.lastUpdated = uint64(block.number);\n            } else {\n                // Look up how much this vouch has locked. If it is 0 then\n                // continue to the next voucher. Then calculate the amount to\n                // unlock which is the min of the vouches lock and what is\n                // remaining to unlock\n                uint96 locked = vouch.locked;\n                if (locked == 0) continue;\n                innerAmount = _min(locked, remaining);\n\n                // Update the stored locked values and last updated block\n+\t\tcomptroller.withdrawRewards(vouch.staker, stakingToken);                \n                stakers[vouch.staker].locked -= innerAmount;\n                vouch.locked -= innerAmount;\n                vouch.lastUpdated = uint64(block.number);\n            }\n```\n\ndebtWriteOff():\n\nhttps://github.com/sherlock-audit/2022-10-union-finance/blob/main/union-v2-contracts/contracts/user/UserManager.sol#L726-L755\n\n```solidity\n    function debtWriteOff(\n        address staker,\n        address borrower,\n        uint96 amount\n    ) external {\n        if (amount == 0) revert AmountZero();\n        uint256 overdueBlocks = uToken.overdueBlocks();\n        uint256 lastRepay = uToken.getLastRepay(borrower);\n\n        // This function is only callable by the public if the loan is overdue by\n        // overdue blocks + maxOverdueBlocks. This stops the system being left with\n        // debt that is overdue indefinitely and no ability to do anything about it.\n        if (block.number <= lastRepay + overdueBlocks + maxOverdueBlocks) {\n            if (staker != msg.sender) revert AuthFailed();\n        }\n\n        Index memory index = voucherIndexes[borrower][staker];\n        if (!index.isSet) revert VoucherNotFound();\n        Vouch storage vouch = vouchers[borrower][index.idx];\n\n        if (amount > vouch.locked) revert ExceedsLocked();\n\n+\tcomptroller.withdrawRewards(staker, stakingToken);  \n        // update staker staked amount\n        stakers[staker].stakedAmount -= amount;\n        stakers[staker].locked -= amount;\n        totalStaked -= amount;\n\n        // update vouch trust amount\n        vouch.trust -= amount;\n        vouch.locked -= amount;\n```\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/11",
  "Code": [
    {
      "filename": "union-v2-contracts/contracts/token/Comptroller.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {Controller} from \"../Controller.sol\";\nimport {WadRayMath} from \"../WadRayMath.sol\";\nimport {IComptroller} from \"../interfaces/IComptroller.sol\";\nimport {IMarketRegistry} from \"../interfaces/IMarketRegistry.sol\";\nimport {IUserManager} from \"../interfaces/IUserManager.sol\";\n\n/**\n *  @author Compound -> Union Finance\n *  @title Comptroller\n *  @dev  For the time being, only the reward calculation of a single\n *        token is supported, and the contract needs to be revised after\n *        determining the reward calculation scheme of multiple tokens\n */\ncontract Comptroller is Controller, IComptroller {\n    using WadRayMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /* -------------------------------------------------------------------\n      Types \n    ------------------------------------------------------------------- */\n\n    struct Info {\n        uint256 updatedBlock; //last withdraw rewards block\n        uint256 inflationIndex; //last withdraw rewards inflationIndex\n        uint256 accrued; //the unionToken accrued but not yet transferred to each user\n    }\n\n    struct UserManagerState {\n        uint256 totalFrozen;\n        uint256 totalStaked;\n    }\n\n    struct UserManagerAccountState {\n        uint256 totalStaked;\n        uint256 totalFrozen;\n        uint256 totalLocked;\n        uint256 pastBlocksFrozenCoinAge;\n        bool isMember;\n    }\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Initial inflation index\n     */\n    uint256 public constant INIT_INFLATION_INDEX = 10**18;\n\n    /**\n     * @dev Non member reward multiplier rate (75%)\n     */\n    uint256 public constant nonMemberRatio = 75 * 10**16; // 75%;\n\n    /**\n     * @dev Member reward multiplier rate (100%)\n     */\n    uint256 public constant memberRatio = 10**18;\n\n    /**\n     * @dev Half decay point to reduce rewards at\n     */\n    uint256 public halfDecayPoint;\n\n    /**\n     * @dev store the latest inflation index\n     */\n    uint256 public gInflationIndex;\n\n    /**\n     * @dev block number when updating the inflation index\n     */\n    uint256 public gLastUpdatedBlock;\n\n    /**\n     * @dev $UNION token contract\n     */\n    IERC20Upgradeable public unionToken;\n\n    /**\n     * @dev The market registry contract\n     */\n    IMarketRegistry public marketRegistry;\n\n    /**\n     * @dev Map account to token to Info\n     */\n    mapping(address => mapping(address => Info)) public users;\n\n    /* -------------------------------------------------------------------\n      Events \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Withdraw rewards event\n     *  @param account The staker's address\n     *  @param amount The amount of Union tokens to withdraw\n     */\n    event LogWithdrawRewards(address indexed account, uint256 amount);\n\n    /* -------------------------------------------------------------------\n      Errors\n    ------------------------------------------------------------------- */\n\n    error SenderNotUserManager();\n    error NotZero();\n    error FrozenCoinAge();\n    error InflationIndexTooSmall();\n\n    /* -------------------------------------------------------------------\n      Constructor/Initializer \n    ------------------------------------------------------------------- */\n\n    function __Comptroller_init(\n        address unionToken_,\n        address marketRegistry_,\n        uint256 _halfDecayPoint\n    ) public initializer {\n        Controller.__Controller_init(msg.sender);\n\n        gInflationIndex = INIT_INFLATION_INDEX;\n        gLastUpdatedBlock = block.number;\n\n        unionToken = IERC20Upgradeable(unionToken_);\n        marketRegistry = IMarketRegistry(marketRegistry_);\n        halfDecayPoint = _halfDecayPoint;\n    }\n\n    /* -------------------------------------------------------------------\n      Modifiers \n    ------------------------------------------------------------------- */\n\n    modifier onlyUserManager(address token) {\n        if (msg.sender != address(_getUserManager(token))) revert SenderNotUserManager();\n        _;\n    }\n\n    /* -------------------------------------------------------------------\n      Setters \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Set the half decay point\n     */\n    function setHalfDecayPoint(uint256 point) public onlyAdmin {\n        if (point == 0) revert NotZero();\n        halfDecayPoint = point;\n    }\n\n    /* -------------------------------------------------------------------\n      View Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Get the reward multipier based on the account status\n     *  @param account Account address\n     *  @param token ERC20 token address\n     *  @return Multiplier number (in wei)\n     */\n    function getRewardsMultiplier(address account, address token) external view override returns (uint256) {\n        IUserManager userManagerContract = _getUserManager(token);\n        uint256 stakingAmount = userManagerContract.getStakerBalance(account);\n        uint256 lockedStake = userManagerContract.getTotalLockedStake(account);\n        (uint256 totalFrozen, ) = userManagerContract.getFrozenInfo(account, block.number);\n        bool isMember = userManagerContract.checkIsMember(account);\n        return _getRewardsMultiplier(stakingAmount, lockedStake, totalFrozen, isMember);\n    }\n\n    /**\n     *  @dev Calculate unclaimed rewards based on blocks\n     *  @param account User address\n     *  @param token Staking token address\n     *  @param futureBlocks Number of blocks in the future\n     *  @return Unclaimed rewards\n     */\n    function calculateRewardsByBlocks(\n        address account,\n        address token,\n        uint256 futureBlocks\n    ) public view override returns (uint256) {\n        IUserManager userManager = _getUserManager(token);\n\n        // Lookup account stataddress accounte from UserManager\n        (\n            UserManagerAccountState memory userManagerAccountState,\n            Info memory userInfo,\n            uint256 pastBlocks\n        ) = _getUserInfoView(userManager, account, token, futureBlocks);\n\n        // Lookup global state from UserManager\n        UserManagerState memory userManagerState = _getUserManagerState(userManager);\n\n        return\n            _calculateRewardsByBlocks(account, token, pastBlocks, userInfo, userManagerState, userManagerAccountState);\n    }\n\n    /**\n     *  @dev Calculate currently unclaimed rewards\n     *  @param account Account address\n     *  @param token Staking token address\n     *  @return Unclaimed rewards\n     */\n    function calculateRewards(address account, address token) external view override returns (uint256) {\n        return calculateRewardsByBlocks(account, token, 0);\n    }\n\n    /**\n     *  @dev Calculate inflation per block\n     *  @param effectiveTotalStake Effective total stake\n     *  @return Inflation amount, div totalSupply is the inflation rate\n     */\n    function inflationPerBlock(uint256 effectiveTotalStake) public view returns (uint256) {\n        return _inflationPerBlock(effectiveTotalStake);\n    }\n\n    /* -------------------------------------------------------------------\n      Core Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Withdraw rewards\n     *  @param token Staking token address\n     *  @return Amount of rewards\n     */\n    function withdrawRewards(address account, address token)\n        external\n        override\n        whenNotPaused\n        onlyUserManager(token)\n        returns (uint256)\n    {\n        IUserManager userManager = _getUserManager(token);\n\n        // Lookup account state from UserManager\n        (\n            UserManagerAccountState memory userManagerAccountState,\n            Info memory userInfo,\n            uint256 pastBlocks\n        ) = _getUserInfo(userManager, account, token, 0);\n\n        // Lookup global state from UserManager\n        UserManagerState memory userManagerState = _getUserManagerState(userManager);\n\n        uint256 amount = _calculateRewardsByBlocks(\n            account,\n            token,\n            pastBlocks,\n            userInfo,\n            userManagerState,\n            userManagerAccountState\n        );\n\n        // update the global states\n        uint256 totalStaked_ = userManagerState.totalStaked - userManagerState.totalFrozen;\n        gInflationIndex = _getInflationIndexNew(totalStaked_, block.number - gLastUpdatedBlock);\n        gLastUpdatedBlock = block.number;\n        users[account][token].updatedBlock = block.number;\n        users[account][token].inflationIndex = gInflationIndex;\n        if (unionToken.balanceOf(address(this)) >= amount && amount > 0) {\n            unionToken.safeTransfer(account, amount);\n            users[account][token].accrued = 0;\n            emit LogWithdrawRewards(account, amount);\n\n            return amount;\n        } else {\n            users[account][token].accrued = amount;\n            emit LogWithdrawRewards(account, 0);\n\n            return 0;\n        }\n    }\n\n    /**\n     *  @dev When total staked change update inflation index\n     *  @param totalStaked totalStaked amount\n     *  @return Whether succeeded\n     */\n    function updateTotalStaked(address token, uint256 totalStaked)\n        external\n        override\n        whenNotPaused\n        onlyUserManager(token)\n        returns (bool)\n    {\n        if (totalStaked > 0) {\n            gInflationIndex = _getInflationIndexNew(totalStaked, block.number - gLastUpdatedBlock);\n        }\n        gLastUpdatedBlock = block.number;\n\n        return true;\n    }\n\n    /* -------------------------------------------------------------------\n       Internal Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Get UserManager global state values\n     */\n    function _getUserManagerState(IUserManager userManager) internal view returns (UserManagerState memory) {\n        UserManagerState memory userManagerState;\n\n        userManagerState.totalFrozen = userManager.totalFrozen();\n        userManagerState.totalStaked = userManager.totalStaked() - userManagerState.totalFrozen;\n        if (userManagerState.totalStaked < 1e18) {\n            userManagerState.totalStaked = 1e18;\n        }\n\n        return userManagerState;\n    }\n\n    /**\n     * @dev Get UserManager user specific state (view function does NOT update UserManage state)\n     * @param userManager UserManager contract\n     * @param account Account address\n     * @param token Token address\n     * @param futureBlocks Blocks in the future\n     */\n    function _getUserInfoView(\n        IUserManager userManager,\n        address account,\n        address token,\n        uint256 futureBlocks\n    )\n        internal\n        view\n        returns (\n            UserManagerAccountState memory,\n            Info memory,\n            uint256\n        )\n    {\n        Info memory userInfo = users[account][token];\n        uint256 lastUpdatedBlock = userInfo.updatedBlock;\n        if (block.number < lastUpdatedBlock) {\n            lastUpdatedBlock = block.number;\n        }\n\n        uint256 pastBlocks = block.number - lastUpdatedBlock + futureBlocks;\n\n        UserManagerAccountState memory userManagerAccountState;\n        (userManagerAccountState.totalFrozen, userManagerAccountState.pastBlocksFrozenCoinAge) = userManager\n            .getFrozenInfo(account, pastBlocks);\n\n        return (userManagerAccountState, userInfo, pastBlocks);\n    }\n\n    /**\n     * @dev Get UserManager user specific state (function does update UserManage state)\n     * @param userManager UserManager contract\n     * @param account Account address\n     * @param token Token address\n     * @param futureBlocks Blocks in the future\n     */\n    function _getUserInfo(\n        IUserManager userManager,\n        address account,\n        address token,\n        uint256 futureBlocks\n    )\n        internal\n        returns (\n            UserManagerAccountState memory,\n            Info memory,\n            uint256\n        )\n    {\n        Info memory userInfo = users[account][token];\n        uint256 lastUpdatedBlock = userInfo.updatedBlock;\n        if (block.number < lastUpdatedBlock) {\n            lastUpdatedBlock = block.number;\n        }\n\n        uint256 pastBlocks = block.number - lastUpdatedBlock + futureBlocks;\n\n        UserManagerAccountState memory userManagerAccountState;\n        (userManagerAccountState.totalFrozen, userManagerAccountState.pastBlocksFrozenCoinAge) = userManager\n            .updateFrozenInfo(account, pastBlocks);\n\n        return (userManagerAccountState, userInfo, pastBlocks);\n    }\n\n    /**\n     *  @dev Calculate currently unclaimed rewards\n     *  @param account Account address\n     *  @param token Staking token address\n     *  @param userManagerState User manager global state\n     *  @return Unclaimed rewards\n     */\n    function _calculateRewardsByBlocks(\n        address account,\n        address token,\n        uint256 pastBlocks,\n        Info memory userInfo,\n        UserManagerState memory userManagerState,\n        UserManagerAccountState memory userManagerAccountState\n    ) internal view returns (uint256) {\n        IUserManager userManagerContract = _getUserManager(token);\n\n        // Lookup account state from UserManager\n        userManagerAccountState.totalStaked = userManagerContract.getStakerBalance(account);\n        userManagerAccountState.totalLocked = userManagerContract.getTotalLockedStake(account);\n        userManagerAccountState.isMember = userManagerContract.checkIsMember(account);\n\n        uint256 inflationIndex = _getRewardsMultiplier(\n            userManagerAccountState.totalStaked,\n            userManagerAccountState.totalLocked,\n            userManagerAccountState.totalFrozen,\n            userManagerAccountState.isMember\n        );\n\n        return\n            userInfo.accrued +\n            _calculateRewards(\n                account,\n                token,\n                userManagerState.totalStaked,\n                userManagerAccountState.totalStaked,\n                userManagerAccountState.pastBlocksFrozenCoinAge,\n                pastBlocks,\n                inflationIndex\n            );\n    }\n\n    /**\n     *  @dev Calculate new inflation index based on # of blocks\n     *  @param totalStaked_ Number of total staked tokens in the system\n     *  @param blockDelta Number of blocks\n     *  @return New inflation index\n     */\n    function _getInflationIndexNew(uint256 totalStaked_, uint256 blockDelta) internal view returns (uint256) {\n        if (totalStaked_ == 0) return INIT_INFLATION_INDEX;\n        if (blockDelta == 0) return gInflationIndex;\n        return _getInflationIndex(totalStaked_, gInflationIndex, blockDelta);\n    }\n\n    function _calculateRewards(\n        address account,\n        address token,\n        uint256 totalStaked,\n        uint256 userStaked,\n        uint256 frozenCoinAge,\n        uint256 pastBlocks,\n        uint256 inflationIndex\n    ) internal view returns (uint256) {\n        uint256 startInflationIndex = users[account][token].inflationIndex;\n        if (userStaked * pastBlocks < frozenCoinAge) revert FrozenCoinAge();\n\n        if (userStaked == 0 || totalStaked == 0 || startInflationIndex == 0 || pastBlocks == 0) {\n            return 0;\n        }\n\n        uint256 effectiveStakeAmount = (userStaked * pastBlocks - frozenCoinAge) / pastBlocks;\n\n        uint256 curInflationIndex = _getInflationIndexNew(totalStaked, pastBlocks);\n\n        if (curInflationIndex < startInflationIndex) revert InflationIndexTooSmall();\n\n        return (curInflationIndex - startInflationIndex).wadMul(effectiveStakeAmount).wadMul(inflationIndex);\n    }\n\n    /**\n     * @dev Get the UserManager contract. First try and load it from state\n     * if it has been previously saved and fallback to loading it from the marketRegistry\n     * @return userManager contract\n     */\n    function _getUserManager(address token) internal view returns (IUserManager) {\n        return IUserManager(marketRegistry.userManagers(token));\n    }\n\n    /**\n     *  @dev See Comptroller.inflationPerBlock\n     */\n    function _inflationPerBlock(uint256 effectiveTotalStake) internal view returns (uint256) {\n        uint256 index = effectiveTotalStake / halfDecayPoint;\n        return _lookup(index);\n    }\n\n    function _lookup(uint256 index) internal pure returns (uint256) {\n        if (index <= 0.00001 * 10**18) {\n            return 1 * 10**18;\n        } else if (index <= 0.0001 * 10**18) {\n            return 0.9 * 10**18;\n        } else if (index <= 0.001 * 10**18) {\n            return 0.8 * 10**18;\n        } else if (index <= 0.01 * 10**18) {\n            return 0.7 * 10**18;\n        } else if (index <= 0.1 * 10**18) {\n            return 0.6 * 10**18;\n        } else if (index <= 1 * 10**18) {\n            return 0.5 * 10**18;\n        } else if (index <= 5 * 10**18) {\n            return 0.25 * 10**18;\n        } else if (index <= 10 * 10**18) {\n            return 0.1 * 10**18;\n        } else if (index <= 100 * 10**18) {\n            return 0.01 * 10**18;\n        } else if (index <= 1000 * 10**18) {\n            return 0.001 * 10**18;\n        } else if (index <= 10000 * 10**18) {\n            return 0.0001 * 10**18;\n        } else if (index <= 100000 * 10**18) {\n            return 0.00001 * 10**18;\n        } else {\n            return 0.000001 * 10**18;\n        }\n    }\n\n    function _getInflationIndex(\n        uint256 effectiveAmount,\n        uint256 inflationIndex,\n        uint256 blockDelta\n    ) internal view returns (uint256) {\n        return blockDelta * _inflationPerBlock(effectiveAmount).wadDiv(effectiveAmount) + inflationIndex;\n    }\n\n    function _getRewardsMultiplier(\n        uint256 userStaked,\n        uint256 lockedStake,\n        uint256 totalFrozen_,\n        bool isMember_\n    ) internal pure returns (uint256) {\n        if (isMember_) {\n            if (userStaked == 0 || totalFrozen_ >= lockedStake) {\n                return memberRatio;\n            }\n\n            uint256 effectiveLockedAmount = lockedStake - totalFrozen_;\n            uint256 effectiveStakeAmount = userStaked - totalFrozen_;\n\n            uint256 lendingRatio = effectiveLockedAmount.wadDiv(effectiveStakeAmount);\n\n            return lendingRatio + memberRatio;\n        } else {\n            return nonMemberRatio;\n        }\n    }\n}"
    },
    {
      "filename": "union-v2-contracts/contracts/token/Comptroller.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {Controller} from \"../Controller.sol\";\nimport {WadRayMath} from \"../WadRayMath.sol\";\nimport {IComptroller} from \"../interfaces/IComptroller.sol\";\nimport {IMarketRegistry} from \"../interfaces/IMarketRegistry.sol\";\nimport {IUserManager} from \"../interfaces/IUserManager.sol\";\n\n/**\n *  @author Compound -> Union Finance\n *  @title Comptroller\n *  @dev  For the time being, only the reward calculation of a single\n *        token is supported, and the contract needs to be revised after\n *        determining the reward calculation scheme of multiple tokens\n */\ncontract Comptroller is Controller, IComptroller {\n    using WadRayMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /* -------------------------------------------------------------------\n      Types \n    ------------------------------------------------------------------- */\n\n    struct Info {\n        uint256 updatedBlock; //last withdraw rewards block\n        uint256 inflationIndex; //last withdraw rewards inflationIndex\n        uint256 accrued; //the unionToken accrued but not yet transferred to each user\n    }\n\n    struct UserManagerState {\n        uint256 totalFrozen;\n        uint256 totalStaked;\n    }\n\n    struct UserManagerAccountState {\n        uint256 totalStaked;\n        uint256 totalFrozen;\n        uint256 totalLocked;\n        uint256 pastBlocksFrozenCoinAge;\n        bool isMember;\n    }\n\n    /* -------------------------------------------------------------------\n      Storage \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Initial inflation index\n     */\n    uint256 public constant INIT_INFLATION_INDEX = 10**18;\n\n    /**\n     * @dev Non member reward multiplier rate (75%)\n     */\n    uint256 public constant nonMemberRatio = 75 * 10**16; // 75%;\n\n    /**\n     * @dev Member reward multiplier rate (100%)\n     */\n    uint256 public constant memberRatio = 10**18;\n\n    /**\n     * @dev Half decay point to reduce rewards at\n     */\n    uint256 public halfDecayPoint;\n\n    /**\n     * @dev store the latest inflation index\n     */\n    uint256 public gInflationIndex;\n\n    /**\n     * @dev block number when updating the inflation index\n     */\n    uint256 public gLastUpdatedBlock;\n\n    /**\n     * @dev $UNION token contract\n     */\n    IERC20Upgradeable public unionToken;\n\n    /**\n     * @dev The market registry contract\n     */\n    IMarketRegistry public marketRegistry;\n\n    /**\n     * @dev Map account to token to Info\n     */\n    mapping(address => mapping(address => Info)) public users;\n\n    /* -------------------------------------------------------------------\n      Events \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Withdraw rewards event\n     *  @param account The staker's address\n     *  @param amount The amount of Union tokens to withdraw\n     */\n    event LogWithdrawRewards(address indexed account, uint256 amount);\n\n    /* -------------------------------------------------------------------\n      Errors\n    ------------------------------------------------------------------- */\n\n    error SenderNotUserManager();\n    error NotZero();\n    error FrozenCoinAge();\n    error InflationIndexTooSmall();\n\n    /* -------------------------------------------------------------------\n      Constructor/Initializer \n    ------------------------------------------------------------------- */\n\n    function __Comptroller_init(\n        address unionToken_,\n        address marketRegistry_,\n        uint256 _halfDecayPoint\n    ) public initializer {\n        Controller.__Controller_init(msg.sender);\n\n        gInflationIndex = INIT_INFLATION_INDEX;\n        gLastUpdatedBlock = block.number;\n\n        unionToken = IERC20Upgradeable(unionToken_);\n        marketRegistry = IMarketRegistry(marketRegistry_);\n        halfDecayPoint = _halfDecayPoint;\n    }\n\n    /* -------------------------------------------------------------------\n      Modifiers \n    ------------------------------------------------------------------- */\n\n    modifier onlyUserManager(address token) {\n        if (msg.sender != address(_getUserManager(token))) revert SenderNotUserManager();\n        _;\n    }\n\n    /* -------------------------------------------------------------------\n      Setters \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Set the half decay point\n     */\n    function setHalfDecayPoint(uint256 point) public onlyAdmin {\n        if (point == 0) revert NotZero();\n        halfDecayPoint = point;\n    }\n\n    /* -------------------------------------------------------------------\n      View Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Get the reward multipier based on the account status\n     *  @param account Account address\n     *  @param token ERC20 token address\n     *  @return Multiplier number (in wei)\n     */\n    function getRewardsMultiplier(address account, address token) external view override returns (uint256) {\n        IUserManager userManagerContract = _getUserManager(token);\n        uint256 stakingAmount = userManagerContract.getStakerBalance(account);\n        uint256 lockedStake = userManagerContract.getTotalLockedStake(account);\n        (uint256 totalFrozen, ) = userManagerContract.getFrozenInfo(account, block.number);\n        bool isMember = userManagerContract.checkIsMember(account);\n        return _getRewardsMultiplier(stakingAmount, lockedStake, totalFrozen, isMember);\n    }\n\n    /**\n     *  @dev Calculate unclaimed rewards based on blocks\n     *  @param account User address\n     *  @param token Staking token address\n     *  @param futureBlocks Number of blocks in the future\n     *  @return Unclaimed rewards\n     */\n    function calculateRewardsByBlocks(\n        address account,\n        address token,\n        uint256 futureBlocks\n    ) public view override returns (uint256) {\n        IUserManager userManager = _getUserManager(token);\n\n        // Lookup account stataddress accounte from UserManager\n        (\n            UserManagerAccountState memory userManagerAccountState,\n            Info memory userInfo,\n            uint256 pastBlocks\n        ) = _getUserInfoView(userManager, account, token, futureBlocks);\n\n        // Lookup global state from UserManager\n        UserManagerState memory userManagerState = _getUserManagerState(userManager);\n\n        return\n            _calculateRewardsByBlocks(account, token, pastBlocks, userInfo, userManagerState, userManagerAccountState);\n    }\n\n    /**\n     *  @dev Calculate currently unclaimed rewards\n     *  @param account Account address\n     *  @param token Staking token address\n     *  @return Unclaimed rewards\n     */\n    function calculateRewards(address account, address token) external view override returns (uint256) {\n        return calculateRewardsByBlocks(account, token, 0);\n    }\n\n    /**\n     *  @dev Calculate inflation per block\n     *  @param effectiveTotalStake Effective total stake\n     *  @return Inflation amount, div totalSupply is the inflation rate\n     */\n    function inflationPerBlock(uint256 effectiveTotalStake) public view returns (uint256) {\n        return _inflationPerBlock(effectiveTotalStake);\n    }\n\n    /* -------------------------------------------------------------------\n      Core Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     *  @dev Withdraw rewards\n     *  @param token Staking token address\n     *  @return Amount of rewards\n     */\n    function withdrawRewards(address account, address token)\n        external\n        override\n        whenNotPaused\n        onlyUserManager(token)\n        returns (uint256)\n    {\n        IUserManager userManager = _getUserManager(token);\n\n        // Lookup account state from UserManager\n        (\n            UserManagerAccountState memory userManagerAccountState,\n            Info memory userInfo,\n            uint256 pastBlocks\n        ) = _getUserInfo(userManager, account, token, 0);\n\n        // Lookup global state from UserManager\n        UserManagerState memory userManagerState = _getUserManagerState(userManager);\n\n        uint256 amount = _calculateRewardsByBlocks(\n            account,\n            token,\n            pastBlocks,\n            userInfo,\n            userManagerState,\n            userManagerAccountState\n        );\n\n        // update the global states\n        uint256 totalStaked_ = userManagerState.totalStaked - userManagerState.totalFrozen;\n        gInflationIndex = _getInflationIndexNew(totalStaked_, block.number - gLastUpdatedBlock);\n        gLastUpdatedBlock = block.number;\n        users[account][token].updatedBlock = block.number;\n        users[account][token].inflationIndex = gInflationIndex;\n        if (unionToken.balanceOf(address(this)) >= amount && amount > 0) {\n            unionToken.safeTransfer(account, amount);\n            users[account][token].accrued = 0;\n            emit LogWithdrawRewards(account, amount);\n\n            return amount;\n        } else {\n            users[account][token].accrued = amount;\n            emit LogWithdrawRewards(account, 0);\n\n            return 0;\n        }\n    }\n\n    /**\n     *  @dev When total staked change update inflation index\n     *  @param totalStaked totalStaked amount\n     *  @return Whether succeeded\n     */\n    function updateTotalStaked(address token, uint256 totalStaked)\n        external\n        override\n        whenNotPaused\n        onlyUserManager(token)\n        returns (bool)\n    {\n        if (totalStaked > 0) {\n            gInflationIndex = _getInflationIndexNew(totalStaked, block.number - gLastUpdatedBlock);\n        }\n        gLastUpdatedBlock = block.number;\n\n        return true;\n    }\n\n    /* -------------------------------------------------------------------\n       Internal Functions \n    ------------------------------------------------------------------- */\n\n    /**\n     * @dev Get UserManager global state values\n     */\n    function _getUserManagerState(IUserManager userManager) internal view returns (UserManagerState memory) {\n        UserManagerState memory userManagerState;\n\n        userManagerState.totalFrozen = userManager.totalFrozen();\n        userManagerState.totalStaked = userManager.totalStaked() - userManagerState.totalFrozen;\n        if (userManagerState.totalStaked < 1e18) {\n            userManagerState.totalStaked = 1e18;\n        }\n\n        return userManagerState;\n    }\n\n    /**\n     * @dev Get UserManager user specific state (view function does NOT update UserManage state)\n     * @param userManager UserManager contract\n     * @param account Account address\n     * @param token Token address\n     * @param futureBlocks Blocks in the future\n     */\n    function _getUserInfoView(\n        IUserManager userManager,\n        address account,\n        address token,\n        uint256 futureBlocks\n    )\n        internal\n        view\n        returns (\n            UserManagerAccountState memory,\n            Info memory,\n            uint256\n        )\n    {\n        Info memory userInfo = users[account][token];\n        uint256 lastUpdatedBlock = userInfo.updatedBlock;\n        if (block.number < lastUpdatedBlock) {\n            lastUpdatedBlock = block.number;\n        }\n\n        uint256 pastBlocks = block.number - lastUpdatedBlock + futureBlocks;\n\n        UserManagerAccountState memory userManagerAccountState;\n        (userManagerAccountState.totalFrozen, userManagerAccountState.pastBlocksFrozenCoinAge) = userManager\n            .getFrozenInfo(account, pastBlocks);\n\n        return (userManagerAccountState, userInfo, pastBlocks);\n    }\n\n    /**\n     * @dev Get UserManager user specific state (function does update UserManage state)\n     * @param userManager UserManager contract\n     * @param account Account address\n     * @param token Token address\n     * @param futureBlocks Blocks in the future\n     */\n    function _getUserInfo(\n        IUserManager userManager,\n        address account,\n        address token,\n        uint256 futureBlocks\n    )\n        internal\n        returns (\n            UserManagerAccountState memory,\n            Info memory,\n            uint256\n        )\n    {\n        Info memory userInfo = users[account][token];\n        uint256 lastUpdatedBlock = userInfo.updatedBlock;\n        if (block.number < lastUpdatedBlock) {\n            lastUpdatedBlock = block.number;\n        }\n\n        uint256 pastBlocks = block.number - lastUpdatedBlock + futureBlocks;\n\n        UserManagerAccountState memory userManagerAccountState;\n        (userManagerAccountState.totalFrozen, userManagerAccountState.pastBlocksFrozenCoinAge) = userManager\n            .updateFrozenInfo(account, pastBlocks);\n\n        return (userManagerAccountState, userInfo, pastBlocks);\n    }\n\n    /**\n     *  @dev Calculate currently unclaimed rewards\n     *  @param account Account address\n     *  @param token Staking token address\n     *  @param userManagerState User manager global state\n     *  @return Unclaimed rewards\n     */\n    function _calculateRewardsByBlocks(\n        address account,\n        address token,\n        uint256 pastBlocks,\n        Info memory userInfo,\n        UserManagerState memory userManagerState,\n        UserManagerAccountState memory userManagerAccountState\n    ) internal view returns (uint256) {\n        IUserManager userManagerContract = _getUserManager(token);\n\n        // Lookup account state from UserManager\n        userManagerAccountState.totalStaked = userManagerContract.getStakerBalance(account);\n        userManagerAccountState.totalLocked = userManagerContract.getTotalL"
    }
  ]
}