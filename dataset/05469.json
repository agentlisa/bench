{
  "Title": "[H-01] Owner cannot withdraw all interest due to wrong calculation of accrued interest in `WithdrawCarry`",
  "Content": "\nThe current `withdrawCarry` function in the contract underestimates the accrued interest due to a miscalculation. This error prevents the rightful owner from withdrawing their accrued interest, effectively locking the assets. The primary issue lies in the calculation of `maximumWithdrawable` within `withdrawCarry`.\n\n### Flawed Calculation\n\nThe following code segment is used to determine `maximumWithdrawable`:\n\n    uint256 exchangeRate = CTokenInterface(cNote).exchangeRateCurrent(); // Scaled by 1 * 10^(18 - 8 + Underlying Token Decimals), i.e. 10^(28) in our case\n    // The amount of cNOTE the contract has to hold (based on the current exchange rate which is always increasing) such that it is always possible to receive 1 NOTE when burning 1 asD\n    uint256 maximumWithdrawable = (CTokenInterface(cNote).balanceOf(address(this)) * exchangeRate) / 1e28 - totalSupply();\n\nThe problem arises with the scaling of `exchangeRate`, which is assumed to be scaled by `10^28`. However, for `CNOTE` in the Canto network, the `exchangeRate` is actually scaled by `10^18`. This discrepancy causes the owner to withdraw only `10^(-10)` times the actual interest amount. \n\nConsequently, when a non-zero `_amount` is specified, `withdrawCarry` often fails due to the `require(_amount <= maximumWithdrawable, \"Too many tokens requested\");` condition.\n\n### Proof of Concept\n\n**CNOTE Scaling Verification**\n\nAn essential aspect of this audit involves verifying the scaling factor of the `CNOTE` exchange rate. The `exchangeRate` scale for `CNOTE` can be verified in the [Canto Network's GitHub repository](https://github.com/Canto-Network/clm/blob/298377c8711a067a2a49d75a8bf2f90bbbe3de9e/src/CErc20.sol#L15).  Evidence confirming that the exponent of the `CNOTE` exchange rate is indeed `18` can be found through [this link to the token tracker](https://tuber.build/token/0xEe602429Ef7eCe0a13e4FfE8dBC16e101049504C?tab=read_proxy). The data provided there shows the current value of the stored exchange rate (`exchangeRateStored`) as approximately `1004161485744613000`. This value corresponds to `1.00416 * 1e18`, reaffirming the `10^18` scaling factor.\n\nThis information is critical for accurately understanding the mechanics of CNOTE and ensuring the smart contract's calculations align with the actual scaling used in the token's implementation. The verification of this scaling factor supports the recommendations for adjusting the main contract's calculations and the associated test cases, as previously outlined.\n\n**Testing with Solidity Codes**\n\nTesting with the following Solidity code illustrates the actual `CNOTE` values:\n\n```solidity\nfunction updateBalance() external {\n    updatedUnderlyingBalance = ICNoteSimple(cnote).balanceOfUnderlying(msg.sender);\n    updatedExchangeRate = ICNoteSimple(cnote).exchangeRateCurrent();\n\n    uint256 balance = IERC20(cnote).balanceOf(msg.sender);\n    calculatedUnderlying = balance * updatedExchangeRate / 1e28;\n}\n```\n\nThe corresponding TypeScript logs show a clear discrepancy between the expected and calculated underlying balances:\n\n    console.log(\"balanceCnote: \", (Number(balanceCnote) / 1e18).toString());\n    console.log(\"exchangeRate: \", Number(exchangeRate).toString());\n    console.log(\"underlyingBalance: \", Number(underlyingBalance).toString());\n    console.log(\"calculatedUnderlying: \", Number(calculatedUnderlying).toString());\n\nWith the logs:\n\n    balanceCnote:  400100.9100006097\n    exchangeRate:  1004122567006264000\n    underlyingBalance:  4.017503528113544e+23\n    calculatedUnderlying:  40175035281135\n\n### Tools Used\n\n- Solidity for interacting with the Canto mainnet.\n- TypeScript for testing and validation.\n\n### Recommended Mitigation Steps\n\n**Using `balanceOfUnderlying` Function** - Replace the flawed calculation with the `balanceOfUnderlying` function. This function accurately calculates the underlying `NOTE` balance and is defined in `CToken.sol` ([source](https://github.com/Canto-Network/clm/blob/298377c8711a067a2a49d75a8bf2f90bbbe3de9e/src/CToken.sol#L175)).\n\n**Proposed Code Modifications** - Two alternative implementations are suggested:\n\n1. Without `balanceOfUnderlying`: Modify the scaling factor in the existing calculation from `1e28` to `1e18`.\n\n```\n\n    function withdrawCarry(uint256 _amount) external onlyOwner {\n        uint256 exchangeRate = CTokenInterface(cNote).exchangeRateCurrent(); // Scaled by 10^18\n        // The amount of cNOTE the contract has to hold (based on the current exchange rate which is always increasing) such that it is always possible to receive 1 NOTE when burning 1 asD\n        uint256 maximumWithdrawable = (CTokenInterface(cNote).balanceOf(address(this)) * exchangeRate) /\n            1e18 -\n            totalSupply();\n        if (_amount == 0) {\n            _amount = maximumWithdrawable;\n        } else {\n            require(_amount <= maximumWithdrawable, \"Too many tokens requested\");\n        }\n        // Technically, _amount can still be 0 at this point, which would make the following two calls unnecessary.\n        // But we do not handle this case specifically, as the only consequence is that the owner wastes a bit of gas when there is nothing to withdraw\n        uint256 returnCode = CErc20Interface(cNote).redeemUnderlying(_amount);\n        require(returnCode == 0, \"Error when redeeming\"); // 0 on success: https://docs.compound.finance/v2/ctokens/#redeem\n        IERC20 note = IERC20(CErc20Interface(cNote).underlying());\n        SafeERC20.safeTransfer(note, msg.sender, _amount);\n        emit CarryWithdrawal(_amount);\n    }\n```\n\n2. With `balanceOfUnderlying` (Recommended): Utilize the `balanceOfUnderlying` function for a simpler calculation of `maximumWithdrawable`.\n\n```\n\n    function withdrawCarry(uint256 _amount) external onlyOwner {\n        // The amount of cNOTE the contract has to hold (based on the current exchange rate which is always increasing) such that it is always possible to receive 1 NOTE when burning 1 asD\n        uint256 maximumWithdrawable = CTokenInterface(cNote).balanceOfUnderlying(address(this)) - totalSupply();\n        if (_amount == 0) {\n            _amount = maximumWithdrawable;\n        } else {\n            require(_amount <= maximumWithdrawable, \"Too many tokens requested\");\n        }\n        // Technically, _amount can still be 0 at this point, which would make the following two calls unnecessary.\n        // But we do not handle this case specifically, as the only consequence is that the owner wastes a bit of gas when there is nothing to withdraw\n        uint256 returnCode = CErc20Interface(cNote).redeemUnderlying(_amount);\n        require(returnCode == 0, \"Error when redeeming\"); // 0 on success: https://docs.compound.finance/v2/ctokens/#redeem\n        IERC20 note = IERC20(CErc20Interface(cNote).underlying());\n        SafeERC20.safeTransfer(note, msg.sender, _amount);\n        emit CarryWithdrawal(_amount);\n    }\n```\n\nThe second option is highly recommended for its accuracy and simplicity.\n\n### Modification of Related Test Codes\n\nFor post-modifications to the main contract code, it's essential to update the associated test cases. In the [`MockCNOTE`](https://github.com/code-423n4/2023-11-canto/blob/main/asD/src/test/asD.t.sol#L16-L49) test contract, all scaling is currently set to `10^28`. To align with the main contract changes, the following modifications are recommended for `MockCNOTE`:\n\n    contract MockCNOTE is MockERC20 {\n        address public underlying;\n        uint256 public constant SCALE = 1e18;\n        uint256 public exchangeRateCurrent = SCALE;\n\n        constructor(string memory symbol, string memory name, address _underlying) MockERC20(symbol, name) {\n            underlying = _underlying;\n        }\n\n        function mint(uint256 amount) public returns (uint256 statusCode) {\n            SafeERC20.safeTransferFrom(IERC20(underlying), msg.sender, address(this), amount);\n            _mint(msg.sender, (amount * SCALE) / exchangeRateCurrent);\n            statusCode = 0;\n        }\n\n        function redeemUnderlying(uint256 amount) public returns (uint256 statusCode) {\n            SafeERC20.safeTransfer(IERC20(underlying), msg.sender, amount);\n            _burn(msg.sender, (amount * exchangeRateCurrent) / SCALE);\n            statusCode = 0;\n        }\n\n        function redeem(uint256 amount) public returns (uint256 statusCode) {\n            SafeERC20.safeTransfer(IERC20(underlying), msg.sender, (amount * exchangeRateCurrent) / SCALE);\n            _burn(msg.sender, amount);\n            statusCode = 0;\n        }\n\n        function setExchangeRate(uint256 _exchangeRate) public {\n            exchangeRateCurrent = _exchangeRate;\n        }\n    }\n\nThis revised `MockCNOTE` contract reflects the updated scale factor and aligns with the main contract's logic.\n\n### Scenario Testing with Mainnet Forking\n\nFor comprehensive validation, scenario testing using a fork of the mainnet is highly recommended. This approach allows for real-world testing conditions by simulating interactions with existing contracts on the mainnet. It provides a robust environment to verify the correctness and reliability of the contract modifications in real-world scenarios, ensuring that the contract behaves as expected when interfacing with other mainnet contracts.\n\nThis step is crucial to identify potential issues that might not be apparent in isolated or simulated environments, enhancing the overall reliability of the contract before deployment.\n\n### Assessed type\n\nMath\n\n**[OpenCoreCH (Canto) confirmed and commented via duplicate issue #227](https://github.com/code-423n4/2023-11-canto-findings/issues/227#issuecomment-1827562804):**\n> True, `cNOTE` only has 8 decimals unlike all other cTokens that have 18 decimals, causing this discrepancy. Will be fixed.\n\n**[OpenCoreCH (Canto) commented](https://github.com/code-423n4/2023-11-canto-findings/issues/181#issuecomment-1838419120):**\n > Fixed.\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-11-canto",
  "Code": [
    {
      "filename": "src/CErc20.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CToken.sol\";\n\ninterface CompLike {\n    function delegate(address delegatee) external;\n}\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @author Compound\n */\ncontract CErc20 is CToken, CErc20Interface {\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     */\n    function initialize(\n        address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        uint256 initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    )\n        public\n    {\n        // CToken initialize does the bulk of the work\n        super.initialize(\n            comptroller_,\n            interestRateModel_,\n            initialExchangeRateMantissa_,\n            name_,\n            symbol_,\n            decimals_\n        );\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }\n\n    /**\n     ** User Interface **\n     */\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint256 mintAmount) external override returns (uint256) {\n        mintInternal(mintAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint256 redeemTokens)\n        external\n        override\n        returns (uint256)\n    {\n        redeemInternal(redeemTokens);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint256 redeemAmount)\n        external\n        override\n        returns (uint256)\n    {\n        redeemUnderlyingInternal(redeemAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrow(uint256 borrowAmount)\n        external\n        override\n        returns (uint256)\n    {\n        borrowInternal(borrowAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint256 repayAmount)\n        external\n        override\n        returns (uint256)\n    {\n        repayBorrowInternal(repayAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\n        external\n        override\n        returns (uint256)\n    {\n        repayBorrowBehalfInternal(borrower, repayAmount);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        CTokenInterface cTokenCollateral\n    )\n        external\n        override\n        returns (uint256)\n    {\n        liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\n     * @param token The address of the ERC-20 token to sweep\n     */\n    function sweepToken(EIP20NonStandardInterface token) external override {\n        require(\n            msg.sender == admin, \"CErc20::sweepToken: only admin can sweep tokens\"\n        );\n        require(\n            address(token) != underlying,\n            \"CErc20::sweepToken: can not sweep underlying token\"\n        );\n        uint256 balance = token.balanceOf(address(this));\n        token.transfer(admin, balance);\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint256 addAmount)\n        external\n        override\n        returns (uint256)\n    {\n        return _addReservesInternal(addAmount);\n    }\n\n    /**\n     ** Safe Token **\n     */\n\n    /**\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior()\n        internal\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        EIP20Interface token = EIP20Interface(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint256 amount)\n        internal\n        virtual\n        override\n        returns (uint256)\n    {\n        // Read from storage once\n        address underlying_ = underlying;\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying_);\n        uint256 balanceBefore =\n            EIP20Interface(underlying_).balanceOf(address(this));\n        token.transferFrom(from, address(this), amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                       // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                      // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of override external call\n                }\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n        // Calculate the amount that was *actually* transferred\n        uint256 balanceAfter =\n            EIP20Interface(underlying_).balanceOf(address(this));\n        return balanceAfter - balanceBefore; // underflow already checked above, just subtract\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint256 amount)\n        internal\n        virtual\n        override\n    {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        token.transfer(to, amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                      // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                     // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of override external call\n                }\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n    }\n\n    /**\n     * @notice Admin call to delegate the votes of the COMP-like underlying\n     * @param compLikeDelegatee The address to delegate votes to\n     * @dev CTokens whose underlying are not CompLike should revert here\n     */\n    function _delegateCompLikeTo(address compLikeDelegatee) external {\n        require(\n            msg.sender == admin, \"only the admin may set the comp-like delegate\"\n        );\n        CompLike(underlying).delegate(compLikeDelegatee);\n    }\n}"
    },
    {
      "filename": "src/CToken.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./CTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\nabstract contract CToken is CTokenInterface, ExponentialNoError, TokenErrorReporter {\n    /**\n     * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n    function initialize(ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_\n                        ) public {\n        require(msg.sender == admin, \"only admin may initialize the market\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n        // Set the comptroller\n        uint err = _setComptroller(comptroller_);\n        require(err == NO_ERROR, \"setting comptroller failed\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == NO_ERROR, \"setting interest rate model failed\");\n\n        name = name_;   \n        symbol = symbol_;\n        decimals = decimals_;\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }\n\n    /**\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return 0 if the transfer succeeded, else revert\n     */\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        /* Fail if transfer not allowed */\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            revert TransferComptrollerRejection(allowed);\n        }\n\n        /* Do not allow self-transfers */\n        if (src == dst) {\n            revert TransferNotAllowed();\n        }\n\n        /* Get the allowance, infinite for the account owner */\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = type(uint).max;\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        /* Do the calculations, checking for {under,over}flow */\n        uint allowanceNew = startingAllowance - tokens;\n        uint srcTokensNew = accountTokens[src] - tokens;\n        uint dstTokensNew = accountTokens[dst] + tokens;\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        /* Eat some of the allowance (if necessary) */\n        if (startingAllowance != type(uint).max) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        /* We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n\n        // unused function\n        // comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) override external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) override external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (uint256.max means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) override external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) override external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) override external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) override external returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\n    }\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) {\n        return (\n            NO_ERROR,\n            accountTokens[account],\n            borrowBalanceStoredInternal(account),\n            exchangeRateStoredInternal()\n        );\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() virtual internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() override view external returns (uint) {\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() override view external returns (uint) {\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() override external nonReentrant returns (uint) {\n        accrueInterest();\n        return totalBorrows;\n    }\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) override external nonReentrant returns (uint) {\n        accrueInterest();\n        return borrowBalanceStored(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) override public view returns (uint) {\n        return borrowBalanceStoredInternal(account);\n    }\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (uint) {\n        /* Get borrowBalance and borrowIndex */\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (borrowSnapshot.principal == 0) {\n            return 0;\n        }\n\n        /* Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         */\n        uint principalTimesIndex = borrowSnapshot.principal * borrowIndex;\n        return principalTimesIndex / borrowSnapshot.interestIndex;\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() override public nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() override public view returns (uint) {\n        return exchangeRateStoredInternal();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue efore calculating the exchange rate\n     * @return calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStoredInternal() virtual internal view returns (uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /*\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             */\n            return initialExchangeRateMantissa;\n        } else {\n            /*\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             */\n\n            uint totalCash = getCashPrior();\n\n            uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\n            uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;\n\n            return exchangeRate;\n        }\n    }\n\n    /**\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() override external view returns (uint) {\n        return getCashPrior();\n    }\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() virtual override public returns (uint) {\n        /* Remember the initial block number */\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        /* Short-circuit accumulating 0 interest */\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return NO_ERROR;\n        }\n\n        /* Read the previous values out of storage */\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n        uint borrowIndexPrior = borrowIndex;\n\n        /* Calculate the current borrow interest rate */\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n        /* Calculate the number of blocks elapsed since the last accrual */\n        uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;\n\n        /*\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         */\n\n        Exp memory simpleInterestFactor = mul_(Exp({mantissa: borrowRateMantissa}), blockDelta);\n        uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\n        uint totalBorrowsNew = interestAccumulated + borrowsPrior;\n        uint totalReservesNew = mul_ScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /* We write the previously calculated values into storage */\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        /* We emit an AccrueInterest event */\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n        return NO_ERROR;\n    }\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n    function mintInternal(uint mintAmount) internal nonReentrant {\n        accrueInterest();\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n        mintFresh(msg.sender, mintAmount);\n    }\n\n    /**\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n    function mintFresh(address minter, uint mintAmount) internal virtual {\n        /* Fail if mint not allowed */\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            revert MintComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {\n            revert MintFreshnessCheck();\n        }\n\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /*\n         *  We call `doTransferIn` for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n         *  side-effects occurred. The function returns the amount ac\n         tually transferred,\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n         *  of cash.\n         */\n        uint actualMintAmount = doTransferIn(minter, mintAmount);\n\n        /*\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         */\n\n        uint mintTokens = div_(actualMintAmount, exchangeRate);\n        /*\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         * And write them into storage\n         */\n        totalSupply = totalSupply + mintTokens;\n        accountTokens[minter] = accountTokens[minter] + mintTokens;\n\n        /* We emit a Mint event, and a Transfer event */\n        emit Mint(minter, actualMintAmount, mintTokens);\n        emit Transfer(address(this), minter, mintTokens);\n\n        /* We call the defense hook */\n        // unused function\n        // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     */\n    function redeemInternal(uint redeemTokens) internal nonReentrant {\n        accrueInterest(); \n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(payable(msg.sender), redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n     */\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\n        redeemFresh(payable(msg.sender), 0, redeemAmount);\n    }\n\n    /**\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     */\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal virtual {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n        /* exchangeRate = invoke Exchange Rate Stored() */\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal() });\n        uint redeemTokens;\n        uint redeemAmount;\n        /* If redeemTokensIn > 0: */\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            redeemTokens = redeemTokensIn;\n            redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n            redeemTokens = div_(redeemAmountIn, exchangeRate);\n            redeemAmount = redeemAmountIn;\n        }\n\n        /* Fail if redeem not allowed */\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, redeemTokens);\n        if (allowed != 0) {\n            revert RedeemComptrollerRejection(allowed);\n        }\n\n        /* Verify market's block number equals current block number */\n        if (accrualBlockNumber != getBlockNumber()) {"
    }
  ]
}