{
  "Title": "Missing modifier onlyIfNotMigrated enables new price requests on migrated contracts",
  "Content": "The modifier [`onlyIfNotMigrated`](https://github.com/UMAprotocol/protocol/blob/69f577cb7aa7c903b7d97a79d4e3b42911d1c3a0/packages/core/contracts/oracle/implementation/VotingV2.sol#L281) and its underlying private function [`_requireNotMigrated`](https://github.com/UMAprotocol/protocol/blob/69f577cb7aa7c903b7d97a79d4e3b42911d1c3a0/packages/core/contracts/oracle/implementation/VotingV2.sol#L1211) are used to ensure that the voting contract being called is the most recent voting contract deployed. This prevents users from requesting prices and voting on price requests on an outdated voting contract. However, `onlyIfNotMigrated` is missing from the functions [`requestGovernanceAction`](https://github.com/UMAprotocol/protocol/blob/69f577cb7aa7c903b7d97a79d4e3b42911d1c3a0/packages/core/contracts/oracle/implementation/VotingV2.sol#L314) and [`signalRequestsAsSpamForDeletion`](https://github.com/UMAprotocol/protocol/blob/69f577cb7aa7c903b7d97a79d4e3b42911d1c3a0/packages/core/contracts/oracle/implementation/VotingV2.sol#L917). Both of these functions will call `_requestPrice`, which initiates a new price request. Consequently, users will not be able to vote on this request due to the `onlyIfNotMigrated` modifier being present on `commitVote`, and could potentially be slashed as a result.\n\n\nConsider adding the `onlyIfNotMigrated` modifier to the functions `requestGovernanceAction` and `signalRequestsAsSpamForDeletion`.\n\n\n**Update:** *Fixed as of commit [`e62b25249441fc827f3fd6a336ed31d887c93dad`](https://github.com/UMAprotocol/protocol/pull/4157/commits/e62b25249441fc827f3fd6a336ed31d887c93dad) in [PR #4157](https://github.com/UMAprotocol/protocol/pull/4157).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/core/contracts/oracle/implementation/VotingV2.sol",
      "content": "// TODO: this whole /oracle/implementation directory should be restructured to separate the DVM and the OO.\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nimport \"./ResultComputationV2.sol\";\nimport \"./SpamGuardIdentifierLib.sol\";\nimport \"./Staker.sol\";\nimport \"./VoteTimingV2.sol\";\nimport \"./Constants.sol\";\n\nimport \"../interfaces/MinimumVotingAncillaryInterface.sol\";\nimport \"../interfaces/FinderInterface.sol\";\nimport \"../interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../interfaces/OracleAncillaryInterface.sol\";\nimport \"../interfaces/OracleGovernanceInterface.sol\";\nimport \"../interfaces/OracleInterface.sol\";\nimport \"../interfaces/VotingV2Interface.sol\";\nimport \"../interfaces/RegistryInterface.sol\";\nimport \"../interfaces/SlashingLibraryInterface.sol\";\n\n/**\n * @title VotingV2 contract for the UMA DVM.\n * @dev Handles receiving and resolving price requests via a commit-reveal voting schelling scheme.\n */\n\ncontract VotingV2 is Staker, OracleInterface, OracleAncillaryInterface, OracleGovernanceInterface, VotingV2Interface {\n    using VoteTimingV2 for VoteTimingV2.Data;\n    using ResultComputationV2 for ResultComputationV2.Data;\n\n    /****************************************\n     *        VOTING DATA STRUCTURES        *\n     ****************************************/\n\n    // Identifies a unique price request. Tracks ongoing votes as well as the result of the vote.\n    struct PriceRequest {\n        // If in the past, this was the voting round where this price was resolved. If current or the upcoming round,\n        // this is the voting round where this price will be voted on, but not necessarily resolved.\n        uint32 lastVotingRound;\n        // Denotes whether this is a governance request or not.\n        bool isGovernance;\n        // The pendingRequestIndex in the pendingPriceRequests that references this PriceRequest. A value of UINT64_MAX\n        // means that this PriceRequest is resolved and has been cleaned up from pendingPriceRequests.\n        uint64 pendingRequestIndex;\n        // Each request has a unique requestIndex number that is used to order all requests. This is the index within\n        // the priceRequestIds array and is incremented on each request.\n        uint64 priceRequestIndex;\n        // Timestamp that should be used when evaluating the request.\n        // Note: this is a uint64 to allow better variable packing while still leaving more than ample room for\n        // timestamps to stretch far into the future.\n        uint64 time;\n        // Identifier that defines how the voters should resolve the request.\n        bytes32 identifier;\n        // A map containing all votes for this price in various rounds.\n        mapping(uint256 => VoteInstance) voteInstances;\n        // Additional data used to resolve the request.\n        bytes ancillaryData;\n    }\n\n    struct VoteInstance {\n        mapping(address => VoteSubmission) voteSubmissions; // Maps (voterAddress) to their submission.\n        ResultComputationV2.Data resultComputation; // The data structure containing the computed voting results.\n    }\n\n    struct VoteSubmission {\n        bytes32 commit; // A bytes32 of 0 indicates no commit or a commit that was already revealed.\n        bytes32 revealHash; // The hash of the value that was revealed. This is only used for computation of rewards.\n    }\n\n    struct Round {\n        uint256 gat; // GAT is the required number of tokens to vote to not roll the vote.\n        uint256 cumulativeActiveStakeAtRound; // Total staked tokens at the start of the round.\n    }\n\n    // Represents the status a price request has.\n    enum RequestStatus {\n        NotRequested, // Was never requested.\n        Active, // Is being voted on in the current round.\n        Resolved, // Was resolved in a previous round.\n        Future // Is scheduled to be voted on in a future round.\n    }\n\n    // Only used as a return value in view methods -- never stored in the contract.\n    struct RequestState {\n        RequestStatus status;\n        uint256 lastVotingRound;\n    }\n\n    /****************************************\n     *          INTERNAL TRACKING           *\n     ****************************************/\n\n    // Maps round numbers to the rounds.\n    mapping(uint256 => Round) public rounds;\n\n    // Maps price request IDs to the PriceRequest struct.\n    mapping(bytes32 => PriceRequest) public priceRequests;\n\n    bytes32[] public priceRequestIds;\n\n    mapping(uint64 => uint64) public skippedRequestIndexes;\n\n    // Price request ids for price requests that haven't yet been resolved. These requests may be for future rounds.\n    bytes32[] public pendingPriceRequests;\n\n    VoteTimingV2.Data public voteTiming;\n\n    // Number of tokens that must participate to resolve a vote.\n    uint256 public gat;\n\n    // Reference to the Finder.\n    FinderInterface private immutable finder;\n\n    // Reference to Slashing Library.\n    SlashingLibraryInterface public slashingLibrary;\n\n    // If non-zero, this contract has been migrated to this address.\n    address public migratedAddress;\n\n    // If non-zero, this is the previous voting contract, deployed before this one. Used to facilitate retrieval of\n    // previous price requests from DVM deployments before this one and claiming of rewards.\n    OracleAncillaryInterface public immutable previousVotingContract;\n\n    // Max value of an unsigned integer.\n    uint64 private constant UINT64_MAX = type(uint64).max;\n\n    // Max length in bytes of ancillary data that can be appended to a price request.\n    uint256 public constant ANCILLARY_BYTES_LIMIT = 8192;\n\n    /****************************************\n     *          SLASHING TRACKERS           *\n     ****************************************/\n\n    // Only used as a return value in view methods -- never stored in the contract.\n    struct SlashingTracker {\n        uint256 wrongVoteSlashPerToken;\n        uint256 noVoteSlashPerToken;\n        uint256 totalSlashed;\n        uint256 totalCorrectVotes;\n    }\n\n    /****************************************\n     *        SPAM DELETION TRACKERS        *\n     ****************************************/\n\n    uint256 public spamDeletionProposalBond;\n\n    struct SpamDeletionRequest {\n        uint256[2][] spamRequestIndices;\n        uint256 requestTime;\n        bool executed;\n        address proposer;\n        uint256 bond;\n    }\n\n    SpamDeletionRequest[] internal spamDeletionProposals;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event VoteCommitted(\n        address indexed voter,\n        address indexed caller,\n        uint256 roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        bytes ancillaryData\n    );\n\n    event EncryptedVote(\n        address indexed caller,\n        uint256 indexed roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        bytes ancillaryData,\n        bytes encryptedVote\n    );\n\n    event VoteRevealed(\n        address indexed voter,\n        address indexed caller,\n        uint256 roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        int256 price,\n        bytes ancillaryData,\n        uint256 numTokens\n    );\n\n    event PriceRequestAdded(\n        address indexed requester,\n        uint256 indexed roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        uint256 requestIndex,\n        bytes ancillaryData,\n        bool isGovernance\n    );\n\n    event PriceResolved(\n        uint256 indexed roundId,\n        bytes32 indexed identifier,\n        uint256 time,\n        uint256 requestIndex,\n        int256 price,\n        bytes ancillaryData\n    );\n\n    event VotingContractMigrated(address newAddress);\n\n    event GatChanged(uint256 newGat);\n\n    event SlashingLibraryChanged(address newAddress);\n\n    event SpamDeletionProposalBondChanged(uint256 newBond);\n\n    event VoterSlashed(address indexed voter, int256 slashedTokens, uint256 postActiveStake);\n\n    event SignaledRequestsAsSpamForDeletion(\n        uint256 indexed proposalId,\n        address indexed sender,\n        uint256[2][] spamRequestIndices\n    );\n\n    event ExecutedSpamDeletion(uint256 indexed proposalId, bool indexed executed);\n\n    /**\n     * @notice Construct the VotingV2 contract.\n     * @param _emissionRate amount of voting tokens that are emitted per second, split prorate between stakers.\n     * @param _spamDeletionProposalBond amount of voting tokens that are required to propose a spam deletion.\n     * @param _unstakeCoolDown time that a voter must wait to unstake after requesting to unstake.\n     * @param _phaseLength length of the voting phases in seconds.\n     * @param _minRollToNextRoundLength time before the end of a round in which a request must be made for the request\n     *  to be voted on in the next round. If after this, the request is rolled to a round after the next round.\n     * @param _startingRequestIndex offset index to increment the first index in the priceRequestIds array.\n     * @param _gat number of tokens that must participate to resolve a vote.\n     * @param _votingToken address of the UMA token contract used to commit votes.\n     * @param _finder keeps track of all contracts within the system based on their interfaceName.\n     * Must be set to 0x0 for production environments that use live time.\n     * @param _slashingLibrary contract used to calculate voting slashing penalties based on voter participation.\n     */\n    constructor(\n        uint256 _emissionRate,\n        uint256 _spamDeletionProposalBond,\n        uint64 _unstakeCoolDown,\n        uint64 _phaseLength,\n        uint64 _minRollToNextRoundLength,\n        uint256 _gat,\n        uint64 _startingRequestIndex,\n        address _votingToken,\n        address _finder,\n        address _slashingLibrary,\n        address _previousVotingContract\n    ) Staker(_emissionRate, _unstakeCoolDown, _votingToken) {\n        voteTiming.init(_phaseLength, _minRollToNextRoundLength);\n        require(_gat < IERC20(_votingToken).totalSupply() && _gat > 0);\n        gat = _gat;\n        finder = FinderInterface(_finder);\n        slashingLibrary = SlashingLibraryInterface(_slashingLibrary);\n        previousVotingContract = OracleAncillaryInterface(_previousVotingContract);\n        setSpamDeletionProposalBond(_spamDeletionProposalBond);\n\n        // We assume indices never get above 2^64. So we should never start with an index above half that range.\n        require(_startingRequestIndex < type(uint64).max / 2);\n\n        assembly {\n            sstore(priceRequestIds.slot, _startingRequestIndex)\n        }\n    }\n\n    /***************************************\n                    MODIFIERS\n    ****************************************/\n\n    modifier onlyRegisteredContract() {\n        _requireRegisteredContract();\n        _;\n    }\n\n    modifier onlyIfNotMigrated() {\n        _requireNotMigrated();\n        _;\n    }\n\n    /****************************************\n     *  PRICE REQUEST AND ACCESS FUNCTIONS  *\n     ****************************************/\n\n    /**\n     * @notice Enqueues a request (if a request isn't already present) for the identifier, time pair.\n     * @dev Time must be in the past and the identifier must be supported. The length of the ancillary data\n     * is limited such that this method abides by the EVM transaction gas limit.\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public override nonReentrant() onlyIfNotMigrated() onlyRegisteredContract() {\n        _requestPrice(identifier, time, ancillaryData, false);\n    }\n\n    /**\n     * @notice Enqueues a governance action request (if a request isn't already present) for identifier, time pair.\n     * @dev Time must be in the past and the identifier must be supported. The length of the ancillary data\n     * is limited such that this method abides by the EVM transaction gas limit.\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     */\n    function requestGovernanceAction(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) external override onlyOwner() {\n        _requestPrice(identifier, time, ancillaryData, true);\n    }\n\n    /**\n     * @notice Enqueues a request (if a request isn't already present) for the given identifier, time pair.\n     * @dev Time must be in the past and the identifier must be supported. The length of the ancillary data is limited\n     * such that this method abides by the EVM transaction gas limit.\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param isGovernance indicates whether the request is for a governance action.\n     */\n    function _requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bool isGovernance\n    ) internal {\n        uint256 blockTime = getCurrentTime();\n        require(time <= blockTime, \"Can only request in past\");\n        require(\n            isGovernance || _getIdentifierWhitelist().isIdentifierSupported(identifier),\n            \"Unsupported identifier request\"\n        );\n        require(ancillaryData.length <= ANCILLARY_BYTES_LIMIT, \"Invalid ancillary data\");\n\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, ancillaryData);\n        PriceRequest storage priceRequest = priceRequests[priceRequestId];\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\n\n        RequestStatus requestStatus = _getRequestStatus(priceRequest, currentRoundId);\n\n        // Price has never been requested.\n        if (requestStatus == RequestStatus.NotRequested) {\n            // If the price request is a governance action then always place it in the following round. If the price\n            // request is a normal request then either place it in the next round or the following round based off\n            // the minRollToNextRoundLength. This limits when a request must be made for it to occur in the next round.\n            uint256 roundIdToVoteOnPriceRequest =\n                isGovernance ? currentRoundId + 1 : voteTiming.computeRoundToVoteOnPriceRequest(blockTime);\n            PriceRequest storage newPriceRequest = priceRequests[priceRequestId];\n            newPriceRequest.identifier = identifier;\n            newPriceRequest.time = SafeCast.toUint64(time);\n            newPriceRequest.lastVotingRound = SafeCast.toUint32(roundIdToVoteOnPriceRequest);\n            newPriceRequest.pendingRequestIndex = SafeCast.toUint64(pendingPriceRequests.length);\n            newPriceRequest.priceRequestIndex = SafeCast.toUint64(priceRequestIds.length);\n            newPriceRequest.ancillaryData = ancillaryData;\n            if (isGovernance) newPriceRequest.isGovernance = isGovernance;\n\n            pendingPriceRequests.push(priceRequestId);\n            priceRequestIds.push(priceRequestId);\n\n            emit PriceRequestAdded(\n                msg.sender,\n                roundIdToVoteOnPriceRequest,\n                identifier,\n                time,\n                newPriceRequest.priceRequestIndex,\n                ancillaryData,\n                isGovernance\n            );\n        }\n    }\n\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    function requestPrice(bytes32 identifier, uint256 time) external override {\n        requestPrice(identifier, time, \"\");\n    }\n\n    /**\n     * @notice Whether the price for identifier and time is available.\n     * @dev Time must be in the past and the identifier must be supported.\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp of the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @return _hasPrice bool if the DVM has resolved to a price for the given identifier and timestamp.\n     */\n    function hasPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override onlyRegisteredContract() returns (bool) {\n        (bool _hasPrice, , ) = _getPriceOrError(identifier, time, ancillaryData);\n        return _hasPrice;\n    }\n\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    function hasPrice(bytes32 identifier, uint256 time) public view override returns (bool) {\n        return hasPrice(identifier, time, \"\");\n    }\n\n    /**\n     * @notice Gets the price for identifier and time if it has already been requested and resolved.\n     * @dev If the price is not available, the method reverts.\n     * @param identifier uniquely identifies the price requested. E.g. BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp of the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @return int256 representing the resolved price for the given identifier and timestamp.\n     */\n    function getPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override onlyRegisteredContract() returns (int256) {\n        (bool _hasPrice, int256 price, string memory message) = _getPriceOrError(identifier, time, ancillaryData);\n\n        // If the price wasn't available, revert with the provided message.\n        require(_hasPrice, message);\n        return price;\n    }\n\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    function getPrice(bytes32 identifier, uint256 time) external view override returns (int256) {\n        return getPrice(identifier, time, \"\");\n    }\n\n    /**\n     * @notice Gets the status of a list of price requests, identified by their identifier and time.\n     * @dev If the status for a particular request is NotRequested, the lastVotingRound will always be 0.\n     * @param requests array of type PendingRequestAncillary which includes an identifier and timestamp for each request.\n     * @return requestStates a list, in the same order as the input list, giving the status of the specified requests.\n     */\n    function getPriceRequestStatuses(PendingRequestAncillary[] memory requests)\n        public\n        view\n        returns (RequestState[] memory)\n    {\n        RequestState[] memory requestStates = new RequestState[](requests.length);\n        uint256 currentRoundId = getCurrentRoundId();\n        for (uint256 i = 0; i < requests.length; i = unsafe_inc(i)) {\n            PriceRequest storage priceRequest =\n                _getPriceRequest(requests[i].identifier, requests[i].time, requests[i].ancillaryData);\n\n            RequestStatus status = _getRequestStatus(priceRequest, currentRoundId);\n\n            // If it's an active request, its true lastVotingRound is the current one, even if it hasn't been updated.\n            if (status == RequestStatus.Active) requestStates[i].lastVotingRound = currentRoundId;\n            else requestStates[i].lastVotingRound = priceRequest.lastVotingRound;\n            requestStates[i].status = status;\n        }\n        return requestStates;\n    }\n\n    /****************************************\n     *          VOTING FUNCTIONS            *\n     ****************************************/\n\n    /**\n     * @notice Commit a vote for a price request for identifier at time.\n     * @dev identifier, time must correspond to a price request that's currently in the commit phase.\n     * Commits can be changed.\n     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the system’s\n     * expected behavior, voters should never reuse salts. If someone else is able to guess the voted price and knows\n     * that a salt will be reused, then they can determine the vote pre-reveal.\n     * @param identifier uniquely identifies the committed vote. E.g. BTC/USD price pair.\n     * @param time unix timestamp of the price being voted on.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param hash keccak256 hash of the price, salt, voter address, time, ancillaryData, current roundId, identifier.\n     */\n    function commitVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash\n    ) public override nonReentrant() onlyIfNotMigrated() {\n        uint256 currentRoundId = getCurrentRoundId();\n        address voter = getVoterFromDelegate(msg.sender);\n        _updateTrackers(voter);\n        require(hash != bytes32(0));\n        require(getVotePhase() == Phase.Commit, \"Cannot commit in reveal phase\");\n\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time, ancillaryData);\n        require(\n            _getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active,\n            \"Cannot commit inactive request\"\n        );\n\n        VoteInstance storage voteInstance = priceRequest.voteInstances[currentRoundId];\n        voteInstance.voteSubmissions[voter].commit = hash;\n\n        emit VoteCommitted(voter, msg.sender, currentRoundId, identifier, time, ancillaryData);\n    }\n\n    /**\n     * @notice Reveal a previously committed vote for identifier at time.\n     * @dev The revealed price, salt, voter address, time, ancillaryData, current roundId, identifier must hash to the\n     * latest hash that commitVote() was called with. Only the committer can reveal their vote.\n     * @param identifier voted on in the commit phase. E.g. BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price being voted on.\n     * @param price voted on during the commit phase.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param salt value used to hide the commitment price during the commit phase.\n     */\n    function revealVote(\n        bytes32 identifier,\n        uint256 time,\n        int256 price,\n        bytes memory ancillaryData,\n        int256 salt\n    ) public override nonReentrant() onlyIfNotMigrated() {\n        // Note: computing the current round is required to disallow people from revealing an old commit after the round is over.\n        uint256 currentRoundId = getCurrentRoundId();\n        _freezeRoundVariables(currentRoundId);\n        VoteInstance storage voteInstance =\n            _getPriceRequest(identifier, time, ancillaryData).voteInstances[currentRoundId];\n        address voter = getVoterFromDelegate(msg.sender);\n        VoteSubmission storage voteSubmission = voteInstance.voteSubmissions[voter];\n\n        // Scoping to get rid of a stack too deep errors for require messages.\n        {\n            // Can only reveal in the reveal phase.\n            require(getVotePhase() == Phase.Reveal, \"Reveal phase has not started yet\");\n            // 0 hashes are disallowed in the commit phase, so they indicate a different error.\n            // Cannot reveal an uncommitted or previously revealed hash\n            require(voteSubmission.commit != bytes32(0), \"Invalid hash reveal\");\n\n            // Check that the hash that was committed matches to the one that was revealed. Note that if the voter had\n            // delegated this means that they must reveal with the same account they had committed with.\n            require(\n                keccak256(abi.encodePacked(price, salt, msg.sender, time, ancillaryData, currentRoundId, identifier)) ==\n                    voteSubmission.commit,\n                \"Revealed data != commit hash\"\n            );\n        }\n\n        delete voteSubmission.commit; // Small gas refund for clearing up storage.\n\n        voteSubmission.revealHash = keccak256(abi.encode(price)); // Set the voter's submission.\n        uint256 activeStake = voterStakes[voter].activeStake;\n        voteInstance.resultComputation.addVote(price, activeStake); // Add vote to the results.\n        emit VoteRevealed(voter, msg.sender, currentRoundId, identifier, time, price, ancillaryData, activeStake);\n    }\n\n    /**\n     * @notice Commits a vote and logs an event with a data blob, typically an encrypted version of the vote\n     * @dev An encrypted version of the vote is emitted in an event EncryptedVote to allow off-chain infrastructure to\n     * retrieve the commit. The contents of encryptedVote are never used on chain: it is purely for convenience.\n     * @param identifier unique price pair identifier. E.g. BTC/USD price pair.\n     * @param time unix timestamp of the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param hash keccak256 hash of the price you want to vote for and a int256 salt.\n     * @param encryptedVote offchain encrypted blob containing the voter's amount, time and salt.\n     */\n    function commitAndEmitEncryptedVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash,\n        bytes memory encryptedVote\n    ) public override {\n        commitVote(identifier, time, ancillaryData, hash);\n        emit EncryptedVote(msg.sender, getCurrentRoundId(), identifier, time, ancillaryData, encryptedVote);\n    }\n\n    /****************************************\n     *        VOTING GETTER FUNCTIONS       *\n     ****************************************/\n\n    /**\n     * @notice Gets the queries that are being voted on this round.\n     * @return pendingRequests array containing identifiers of type PendingRequestAncillary.\n     */\n    function getPendingRequests() external view override returns (PendingRequestAncillaryAugmented[] memory) {\n        // Solidity memory arrays aren't resizable (and reading storage is expensive). Hence this hackery to filter\n        // pendingPriceRequests only to those requests that have an Active RequestStatus.\n        PendingRequestAncillaryAugmented[] memory unresolved =\n            new PendingRequestAncillaryAugmented[](pendingPriceRequests.length);\n        uint256 numUnresolved = 0;\n\n        for (uint256 i = 0; i < pendingPriceRequests.length; i = unsafe_inc(i)) {\n            PriceRequest storage priceRequest = priceRequests[pendingPriceRequests[i]];\n            if (_getRequestStatus(priceRequest, getCurrentRoundId()) == RequestStatus.Active) {\n                unresolved[numUnresolved] = PendingRequestAncillaryAugmented({\n                    identifier: priceRequest.identifier,\n                    time: priceRequest.time,\n                    ancillaryData: priceRequest.ancillaryData,\n                    priceRequestIndex: priceRequest.priceRequestIndex\n                });\n                numUnresolved++;\n            }\n        }\n\n        PendingRequestAncillaryAugmented[] memory pendingRequests =\n            new PendingRequestAncillaryAugmented[](numUnresolved);\n        for (uint256 i = 0; i < numUnresolved; i = unsafe_inc(i)) {\n            pendingRequests[i] = unresolved[i];\n        }\n        return pendingRequests;\n    }\n\n    /**\n     * @notice Checks if there are current active requests.\n     * @return bool true if there are active requests, false otherwise.\n     */\n    function currentActiveRequests() public view returns (bool) {\n        uint256 currentRoundId = getCurrentRoundId();\n        for (uint256 i = 0; i < pendingPriceRequests.length; i = unsafe_inc(i)) {\n            if (_getRequestStatus(priceRequests[pendingPriceRequests[i]], currentRoundId) == RequestStatus.Active)\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Returns the current voting phase, as a function of the current time.\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES }.\n     */\n    function getVotePhase() public view override returns (Phase) {\n        return voteTiming.computeCurrentPhase(getCurrentTime());\n    }\n\n    /**\n     * @notice Returns the current round ID, as a function of the current time.\n     * @return uint256 the unique round ID.\n     */\n    function getCurrentRoundId() public view override returns (uint256) {\n        return voteTiming.computeCurrentRoundId(getCurrentTime());\n    }\n\n    /**\n     * @notice Returns the round end time, as a function of the round number.\n     * @param roundId representing the unique round ID.\n     * @return uint256 representing the unique round ID.\n     */\n    function getRoundEndTime(uint256 roundId) external view returns (uint256) {\n        return voteTiming.computeRoundEndTime(roundId);\n    }\n\n    /**\n     * @notice Returns the total number of price requests enqueued into the oracle over all time.\n     * Note that a rolled vote is re-enqueued and as such will increment the number of requests, when rolled.\n     * @return uint256 the total number of prices requested.\n     */\n    function getNumberOfPriceRequests() external view returns (uint256) {\n        return priceRequestIds.length;\n    }\n\n    /**\n     * @notice Returns aggregate slashing trackers for a given request index.\n     * @param requestIndex requestIndex the index of the request to fetch slashing trackers for.\n     * @return SlashingTracker Tracker object contains the slashed UMA per staked UMA per wrong vote and no vote, the\n     * total UMA slashed in the round and the total number of correct votes in the round.\n     */\n    function requestSlashingTrackers(uint256 requestIndex) public view returns (SlashingTracker memory) {\n        uint256 currentRoundId = getCurrentRoundId();\n        PriceRequest storage priceRequest = priceRequests[priceRequestIds[requestIndex]];\n\n        // If the request is not resolved return zeros for everything.\n        if (_getRequestStatus(priceRequest, currentRoundId) != RequestStatus.Resolved)\n            return SlashingTracker(0, 0, 0, 0);\n\n        VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n\n        uint256 totalVotes = voteInstance.resultComputation.totalVotes;\n        uint256 totalCorrectVotes = voteInstance.resultComputation.getTotalCorrectlyVotedTokens();\n        uint256 stakedAtRound = rounds[priceRequest.lastVotingRound].cumulativeActiveStakeAtRound;\n\n        (uint256 wrongVoteSlash, uint256 noVoteSlash) =\n            slashingLibrary.calcSlashing(stakedAtRound, totalVotes, totalCorrectVotes, priceRequest.isGovernance);\n\n        uint256 totalSlashed =\n            ((noVoteSlash * (stakedAtRound - totalVotes)) / 1e18) +\n                ((wrongVoteSlash * (totalVotes - totalCorrectVotes)) / 1e18);\n\n        return SlashingTracker(wrongVoteSlash, noVoteSlash, totalSlashed, totalCorrectVotes);\n    }\n\n    /****************************************\n     *        OWNER ADMIN FUNCTIONS         *\n     ****************************************/\n\n    /**\n     * @notice Disables this Voting contract in favor of the migrated one.\n     * @dev Can only be called by the contract owner.\n     * @param newVotingAddress the newly migrated contract address.\n     */\n    function setMigrated(address newVotingAddress) external override onlyOwner {\n        migratedAddress = newVotingAddress;\n        emit VotingContractMigrated(newVotingAddress);\n    }\n\n    /**\n     * @notice Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.\n     * @param newGat sets the next round's Gat.\n     */\n    function setGat(uint256 newGat) external override onlyOwner {\n        require(newGat < votingToken.totalSupply() && newGat > 0);\n        gat = newGat;\n        emit GatChanged(newGat);\n    }\n\n    // Here for abi compatibility. to be removed.\n    function setRewardsExpirationTimeout(uint256 NewRewardsExpirationTimeout) external override onlyOwner {}\n\n    /**\n     * @notice Changes the slashing library used by this contract.\n     * @param _newSlashingLibrary new slashing library address.\n     */\n    function setSlashingLibrary(ad"
    }
  ]
}