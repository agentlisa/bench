{
  "Title": "Unexpected deployer privileges",
  "Content": "The deployer address of the `Store` contract is [recorded as a protocol member](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/store/StoreBase.sol#L30), which allows it to update the storage arbitrarily. The same address [is set](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.4/contracts/access/Ownable.sol#L29) as the contract’s `owner` role, which allows it to [pause and unpause](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/contracts/core/store/StoreBase.sol#L65-L83) storage updates. We believe these are intended to be the same role, but they are not programmatically connected. In particular, if the owner address is [renounced or transferred](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.4/contracts/access/Ownable.sol#L47-L65), the deployer will still be able to update storage.\n\n\nMoreover, it is unclear why the `Store` owner or deployer requires the ability to modify storage arbitrarily.\n\n\nConsider documenting the role in the [Security overview](https://github.com/neptune-mutual-blue/protocol/blob/73fc82fbe0d1388867b7df669983fe42760daeb1/security.md) if the role is required. Otherwise, consider renouncing protocol member privileges from the deployer address after the deployment is finished.\n\n\n**Update:** *Fixed as of commit `0b278019c01dbce22923d0bb6968ddb48bcc3e2d` in [pull request #123](https://github.com/neptune-mutual-blue/protocol/pull/123). The deployer address is removed as a protocol member, assuming the deployer is the address that calls the `initialize` function.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/core/store/StoreBase.sol",
      "content": "// Neptune Mutual Protocol (https://neptunemutual.com)\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\nimport \"../../interfaces/IStore.sol\";\nimport \"openzeppelin-solidity/contracts/security/Pausable.sol\";\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nabstract contract StoreBase is IStore, Pausable, Ownable {\n  using SafeERC20 for IERC20;\n\n  mapping(bytes32 => int256) public intStorage;\n  mapping(bytes32 => uint256) public uintStorage;\n  mapping(bytes32 => uint256[]) public uintsStorage;\n  mapping(bytes32 => address) public addressStorage;\n  mapping(bytes32 => mapping(address => bool)) public addressBooleanStorage;\n  mapping(bytes32 => string) public stringStorage;\n  mapping(bytes32 => bytes) public bytesStorage;\n  mapping(bytes32 => bytes32) public bytes32Storage;\n  mapping(bytes32 => bool) public boolStorage;\n  mapping(bytes32 => address[]) public addressArrayStorage;\n  mapping(bytes32 => mapping(address => uint256)) public addressArrayPositionMap;\n  mapping(bytes32 => bytes32[]) public bytes32ArrayStorage;\n  mapping(bytes32 => mapping(bytes32 => uint256)) public bytes32ArrayPositionMap;\n\n  bytes32 private constant _NS_MEMBERS = \"ns:members\";\n\n  constructor() {\n    boolStorage[keccak256(abi.encodePacked(_NS_MEMBERS, msg.sender))] = true;\n    boolStorage[keccak256(abi.encodePacked(_NS_MEMBERS, address(this)))] = true;\n  }\n\n  /**\n   * @dev Recover all Ether held by the contract.\n   * @custom:suppress-reentrancy Risk tolerable. Can only be called by the owner.\n   * @custom:suppress-pausable Risk tolerable. Can only be called by the owner.\n   */\n  function recoverEther(address sendTo) external onlyOwner {\n    // slither-disable-next-line arbitrary-send\n    payable(sendTo).transfer(address(this).balance);\n  }\n\n  /**\n   * @dev Recover all IERC-20 compatible tokens sent to this address.\n   *\n   * @custom:suppress-reentrancy Risk tolerable. Can only be called by the owner.\n   * @custom:suppress-pausable Risk tolerable. Can only be called by the owner.\n   * @custom:suppress-malicious-erc Risk tolerable. Although the token can't be trusted, the owner has to check the token code manually.\n   * @custom:suppress-address-trust-issue Risk tolerable. Although the token can't be trusted, the owner has to check the token code manually.\n   *\n   * @param token IERC-20 The address of the token contract\n   */\n  function recoverToken(address token, address sendTo) external onlyOwner {\n    IERC20 erc20 = IERC20(token);\n\n    uint256 balance = erc20.balanceOf(address(this));\n\n    if (balance > 0) {\n      // slither-disable-next-line unchecked-transfer\n      erc20.safeTransfer(sendTo, balance);\n    }\n  }\n\n  /**\n   * @dev Pauses the store\n   *\n   * @custom:suppress-reentrancy Risk tolerable. Can only be called by the owner.\n   *\n   */\n  function pause() external onlyOwner {\n    super._pause();\n  }\n\n  /**\n   * @dev Unpauses the store\n   *\n   * @custom:suppress-reentrancy Risk tolerable. Can only be called by the owner.\n   *\n   */\n  function unpause() external onlyOwner {\n    super._unpause();\n  }\n\n  function isProtocolMember(address contractAddress) public view returns (bool) {\n    return boolStorage[keccak256(abi.encodePacked(_NS_MEMBERS, contractAddress))];\n  }\n\n  function _throwIfPaused() internal view {\n    require(!super.paused(), \"Pausable: paused\");\n  }\n\n  function _throwIfSenderNotProtocolMember() internal view {\n    require(isProtocolMember(msg.sender), \"Forbidden\");\n  }\n}"
    }
  ]
}