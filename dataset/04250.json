{
  "Title": "[L04] Lack of indexed parameters in events",
  "Content": "Some events are defined with no indexed parameters. For example, [`ClaimProcessed` in the `ClaimsManager` contract](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ClaimsManager.sol#L66) and [`RegisteredServiceProvider` in the `ServiceProviderFactory` contract](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L87).\n\n\nConsider [indexing event parameters](https://solidity.readthedocs.io/en/latest/contracts.html#events) to avoid hindering the task of off-chain services searching and filtering for specific events.\n\n\n***Update**: Partially fixed in [pull request #614](https://github.com/AudiusProject/audius-protocol/pull/614/files). Some [important events](https://github.com/AudiusProject/audius-protocol/blob/mainnet-audit-feedback/eth-contracts/contracts/DelegateManager.sol#L70-L92) still lack of indexed parameters.*\n\n\n***Update**: Fixed in [pull request #657](https://github.com/AudiusProject/audius-protocol/pull/657).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "eth-contracts/contracts/ClaimsManager.sol",
      "content": "pragma solidity ^0.5.0;\nimport \"./Staking.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\";\nimport \"./ServiceProviderFactory.sol\";\n/// @notice SafeMath imported via ServiceProviderFactory.sol\n\n\n/**\n * Designed to automate claim funding, minting tokens as necessary\n * @notice - will call InitializableV2 constructor\n */\ncontract ClaimsManager is InitializableV2 {\n    using SafeMath for uint256;\n    address private tokenAddress;\n    address private governanceAddress;\n    address private stakingAddress;\n    address private serviceProviderFactoryAddress;\n    address private delegateManagerAddress;\n\n    // Claim related configurations\n    /**\n      * @notice - Minimum number of blocks between funding rounds\n      *       604800 seconds / week\n      *       Avg block time - 13s\n      *       604800 / 13 = 46523.0769231 blocks\n      */\n    uint private fundingRoundBlockDiff;\n\n    /**\n      * @notice - Configures the current funding amount per round\n      *  Weekly rounds, 7% PA inflation = 70,000,000 new tokens in first year\n      *                                 = 70,000,000/365*7 (year is slightly more than a week)\n      *                                 = 1342465.75342 new AUDS per week\n      *                                 = 1342465753420000000000000 new wei units per week\n      * @dev - Past a certain block height, this schedule will be updated\n      *      - Logic determining schedule will be sourced from an external contract\n      */\n    uint private fundingAmount;\n\n    // Denotes current round\n    uint private roundNumber;\n\n    // Staking contract ref\n    ERC20Mintable private audiusToken;\n\n    // Struct representing round state\n    // 1) Block at which round was funded\n    // 2) Total funded for this round\n    // 3) Total claimed in round\n    struct Round {\n        uint fundBlock;\n        uint fundingAmount;\n        uint totalClaimedInRound;\n    }\n\n    // Current round information\n    Round currentRound;\n\n    event RoundInitiated(\n      uint _blockNumber,\n      uint _roundNumber,\n      uint _fundAmount\n    );\n\n    event ClaimProcessed(\n      address _claimer,\n      uint _rewards,\n      uint _oldTotal,\n      uint _newTotal\n    );\n\n    /**\n     * @notice Function to initialize the contract\n     * @param _tokenAddress - address of ERC20 token that will be claimed\n     * @param _governanceAddress - address for Governance proxy contract\n     */\n    function initialize(\n        address _tokenAddress,\n        address _governanceAddress\n    ) public initializer\n    {\n        tokenAddress = _tokenAddress;\n        governanceAddress = _governanceAddress;\n\n        audiusToken = ERC20Mintable(tokenAddress);\n\n        fundingRoundBlockDiff = 46523;\n        fundingAmount = 1342465753420000000000000; // 1342465.75342 AUDS\n        roundNumber = 0;\n\n        currentRound = Round({\n            fundBlock: 0,\n            fundingAmount: 0,\n            totalClaimedInRound: 0\n        });\n\n        InitializableV2.initialize();\n    }\n\n    /// @notice Get the duration of a funding round in blocks\n    function getFundingRoundBlockDiff() external view returns (uint blockDiff)\n    {\n        return fundingRoundBlockDiff;\n    }\n\n    /// @notice Get the last block where a funding round was initiated\n    function getLastFundBlock() external view returns (uint lastFundBlock)\n    {\n        return currentRound.fundBlock;\n    }\n\n    /// @notice Get the amount funded per round in wei\n    function getFundsPerRound() external view returns (uint amount)\n    {\n        return fundingAmount;\n    }\n\n    /// @notice Get the total amount claimed in the current round\n    function getTotalClaimedInRound() external view returns (uint claimedAmount)\n    {\n        return currentRound.totalClaimedInRound;\n    }\n\n    /// @notice Get the Governance address\n    function getGovernanceAddress() external view returns (address addr) {\n        return governanceAddress;\n    }\n\n    /// @notice Get the ServiceProviderFactory address\n    function getServiceProviderFactoryAddress() external view returns (address addr) {\n        return serviceProviderFactoryAddress;\n    }\n\n    /// @notice Get the DelegateManager address\n    function getDelegateManagerAddress() external view returns (address addr) {\n        return delegateManagerAddress;\n    }\n\n    /**\n     * @notice Get the Staking address\n     */\n    function getStakingAddress() external view returns (address addr)\n    {\n        return stakingAddress;\n    }\n\n    /**\n     * @notice Set the Governance address\n     * @dev Only callable by Governance address\n     * @param _governanceAddress - address for new Governance contract\n     */\n    function setGovernanceAddress(address _governanceAddress) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        governanceAddress = _governanceAddress;\n    }\n\n    /**\n     * @notice Set the Staking address\n     * @dev Only callable by Governance address\n     * @param _address - address for new Staking contract\n     */\n    function setStakingAddress(address _address) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        stakingAddress = _address;\n    }\n\n    /**\n     * @notice Set the ServiceProviderFactory address\n     * @dev Only callable by Governance address\n     * @param _spFactory - address for new ServiceProviderFactory contract\n     */\n    function setServiceProviderFactoryAddress(address _spFactory) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        serviceProviderFactoryAddress = _spFactory;\n    }\n\n    /**\n     * @notice Set the DelegateManager address\n     * @dev Only callable by Governance address\n     * @param _delegateManager - address for new DelegateManager contract\n     */\n    function setDelegateManagerAddress(address _delegateManager) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        delegateManagerAddress = _delegateManager;\n    }\n\n    /**\n     * @notice Start a new funding round\n     * @dev Permissioned to be callable by stakers or governance contract\n     */\n    function initiateRound() external {\n        _requireIsInitialized();\n\n        bool senderStaked = Staking(stakingAddress).totalStakedFor(msg.sender) > 0;\n        require(\n            senderStaked || (msg.sender == governanceAddress),\n            \"Only callable by staked account or Governance contract\"\n        );\n\n        require(\n            block.number.sub(currentRound.fundBlock) > fundingRoundBlockDiff,\n            \"Required block difference not met\"\n        );\n\n        currentRound = Round({\n            fundBlock: block.number,\n            fundingAmount: fundingAmount,\n            totalClaimedInRound: 0\n        });\n\n        roundNumber = roundNumber.add(1);\n\n        emit RoundInitiated(\n            currentRound.fundBlock,\n            roundNumber,\n            currentRound.fundingAmount\n        );\n    }\n\n    /**\n     * @notice Mints and stakes tokens on behalf of ServiceProvider + delegators\n     * @dev Callable through DelegateManager by Service Provider\n     * @param _claimer  - service provider address\n     * @param _totalLockedForSP - amount of tokens locked up across DelegateManager + ServiceProvider\n     */\n    function processClaim(\n        address _claimer,\n        uint _totalLockedForSP\n    ) external\n    {\n        _requireIsInitialized();\n        require(\n            msg.sender == delegateManagerAddress,\n            \"ProcessClaim only accessible to DelegateManager\"\n        );\n\n        Staking stakingContract = Staking(stakingAddress);\n        // Prevent duplicate claim\n        uint lastUserClaimBlock = stakingContract.lastClaimedFor(_claimer);\n        require(lastUserClaimBlock <= currentRound.fundBlock, \"Claim already processed for user\");\n        uint totalStakedAtFundBlockForClaimer = stakingContract.totalStakedForAt(\n            _claimer,\n            currentRound.fundBlock);\n\n        (,,bool withinBounds,,,) = (\n            ServiceProviderFactory(serviceProviderFactoryAddress).getServiceProviderDetails(_claimer)\n        );\n\n        // Once they claim the zero reward amount, stake can be modified once again\n        // Subtract total locked amount for SP from stake at fund block\n        uint claimerTotalStake = totalStakedAtFundBlockForClaimer.sub(_totalLockedForSP);\n        uint totalStakedAtFundBlock = stakingContract.totalStakedAt(currentRound.fundBlock);\n\n        // Calculate claimer rewards\n        uint rewardsForClaimer = (\n          claimerTotalStake.mul(fundingAmount)\n        ).div(totalStakedAtFundBlock);\n\n        // For a claimer violating bounds, no new tokens are minted\n        // Claim history is marked to zero and function is short-circuited\n        // Total rewards can be zero if all stake is currently locked up\n        if (!withinBounds || rewardsForClaimer == 0) {\n            stakingContract.updateClaimHistory(0, _claimer);\n            return;\n        }\n\n        // ERC20Mintable always returns true\n        audiusToken.mint(address(this), rewardsForClaimer);\n\n        // ERC20 always returns true\n        audiusToken.approve(stakingAddress, rewardsForClaimer);\n\n        // Transfer rewards\n        stakingContract.stakeRewards(rewardsForClaimer, _claimer);\n\n        // Update round claim value\n        currentRound.totalClaimedInRound = currentRound.totalClaimedInRound.add(rewardsForClaimer);\n\n        // Update round claim value\n        uint newTotal = stakingContract.totalStakedFor(_claimer);\n\n        emit ClaimProcessed(\n            _claimer,\n            rewardsForClaimer,\n            totalStakedAtFundBlockForClaimer,\n            newTotal\n        );\n    }\n\n    /**\n     * @notice Modify funding amount per round\n     * @param _newAmount - new amount to fund per round in wei\n     */\n    function updateFundingAmount(uint _newAmount)\n    external returns (uint newAmount)\n    {\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n        fundingAmount = _newAmount;\n        return _newAmount;\n    }\n\n    /**\n     * @notice Returns boolean indicating whether a claim is considered pending\n     * @dev Note that an address with no endpoints can never have a pending claim\n     * @param _sp - address of the service provider to check\n     * @return boolean - true if eligible for claim, false if not\n     */\n    function claimPending(address _sp) external view returns (bool pending) {\n        uint lastClaimedForSP = Staking(stakingAddress).lastClaimedFor(_sp);\n        (,,,uint numEndpoints,,) = (\n            ServiceProviderFactory(serviceProviderFactoryAddress).getServiceProviderDetails(_sp)\n        );\n        return (lastClaimedForSP < currentRound.fundBlock && numEndpoints > 0);\n    }\n\n    /**\n     * @notice Modify minimum block difference between funding rounds\n     * @param _newFundingRoundBlockDiff - new min block difference to set\n     */\n    function updateFundingRoundBlockDiff(uint _newFundingRoundBlockDiff) external {\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n        fundingRoundBlockDiff = _newFundingRoundBlockDiff;\n    }\n}"
    }
  ]
}