{
  "Title": "[L07] Excessive code coupling",
  "Content": "During a transfer of Pool Tokens, the balance [gets added to the recipient’s committed draw tree](https://github.com/pooltogether/pooltogether-contracts/tree/78ac6863f4616269f7d04a0ddd1d60bdfc454937/contracts/ERC777Pool.sol#L459). If the recipient does not have any committed balance, it is [added to a newly created balance associated with the previous draw](https://github.com/pooltogether/pooltogether-contracts/tree/78ac6863f4616269f7d04a0ddd1d60bdfc454937/contracts/DrawManager.sol#L160-L161).\n\n\nHowever, if the pool is currently in the first draw, [which starts at index 1](https://github.com/pooltogether/pooltogether-contracts/blob/78ac6863f4616269f7d04a0ddd1d60bdfc454937/contracts/DrawManager.sol#L98), this will associate the new balance with the invalid zero draw, and will also leave the user’s first draw index at zero. This is an inconsistent state that would prevent the recipient from withdrawing, transferring or receiving awards based on their balance.\n\n\nFortunately, the overall semantics of the system prevent this scenario. In particular, no user should have any Pool Tokens during the first draw, so the situation could not arise.\n\n\nNevertheless, it is bad practice to rely on global properties of the system to prevent local edge cases and it makes the code fragile to unrelated changes (for example, if a version of the code that pre-minted tokens was released, it would reintroduce this vulnerability).\n\n\nConsider confirming that the first draw is committed before assigning deposits to the previous draw.\n\n\n**Update**: *Fixed in [PR#9](https://github.com/pooltogether/pooltogether-contracts/pull/9/commits/a97bbbb8f5bbf17ca4b53d705ab7e3468e07b496). The `depositCommitted` and `withdrawCommitted` functions now require at least one draw to be committed.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/DrawManager.sol",
      "content": "/**\nCopyright 2019 PoolTogether LLC\n\nThis file is part of PoolTogether.\n\nPoolTogether is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation under version 3 of the License.\n\nPoolTogether is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.5.12;\n\nimport \"./UniformRandomNumber.sol\";\nimport \"@kleros/kleros/contracts/data-structures/SortitionSumTreeFactory.sol\";\nimport \"@openzeppelin/contracts/contracts/math/SafeMath.sol\";\n\n/**\n * @author Brendan Asselstine\n * @notice Tracks committed and open balances for addresses.  Affords selection of an address by indexing all committed balances.\n *\n * Balances are tracked in Draws.  There is always one open Draw.  Deposits are always added to the open Draw.\n * When a new draw is opened, the previous opened draw is committed.\n *\n * The committed balance for an address is the total of their balances for committed Draws.\n * An address's open balance is their balance in the open Draw.\n */\nlibrary DrawManager {\n    using SortitionSumTreeFactory for SortitionSumTreeFactory.SortitionSumTrees;\n    using SafeMath for uint256;\n\n    /**\n     * The ID to use for the selection tree.\n     */\n    bytes32 public constant TREE_OF_DRAWS = \"TreeOfDraws\";\n\n    uint8 public constant MAX_LEAVES = 10;\n\n    /**\n     * Stores information for all draws.\n     */\n    struct State {\n        /**\n         * Each Draw stores it's address balances in a sortitionSumTree.  Draw trees are indexed using the Draw index.\n         * There is one root sortitionSumTree that stores all of the draw totals.  The root tree is indexed using the constant TREE_OF_DRAWS.\n         */\n        SortitionSumTreeFactory.SortitionSumTrees sortitionSumTrees;\n\n        /**\n         * Stores the first Draw index that an address deposited to.\n         */\n        mapping(address => uint256) usersFirstDrawIndex;\n\n        /**\n         * Stores the last Draw index that an address deposited to.\n         */\n        mapping(address => uint256) usersSecondDrawIndex;\n\n        /**\n         * Stores a mapping of Draw index => Draw total\n         */\n        mapping(uint256 => uint256) __deprecated__drawTotals;\n\n        /**\n         * The current open Draw index\n         */\n        uint256 openDrawIndex;\n\n        /**\n         * The total of committed balances\n         */\n        uint256 __deprecated__committedSupply;\n    }\n\n    /**\n     * @notice Opens the next Draw and commits the previous open Draw (if any).\n     * @param self The drawState this library is attached to\n     * @return The index of the new open Draw\n     */\n    function openNextDraw(State storage self) public returns (uint256) {\n        if (self.openDrawIndex == 0) {\n            // If there is no previous draw, we must initialize\n            self.sortitionSumTrees.createTree(TREE_OF_DRAWS, MAX_LEAVES);\n        } else {\n            // else add current draw to sortition sum trees\n            bytes32 drawId = bytes32(self.openDrawIndex);\n            uint256 drawTotal = openSupply(self);\n            self.sortitionSumTrees.set(TREE_OF_DRAWS, drawTotal, drawId);\n        }\n        // now create a new draw\n        uint256 drawIndex = self.openDrawIndex.add(1);\n        self.sortitionSumTrees.createTree(bytes32(drawIndex), MAX_LEAVES);\n        self.openDrawIndex = drawIndex;\n\n        return drawIndex;\n    }\n\n    /**\n     * @notice Deposits the given amount into the current open draw by the given user.\n     * @param self The DrawManager state\n     * @param _addr The address to deposit for\n     * @param _amount The amount to deposit\n     */\n    function deposit(State storage self, address _addr, uint256 _amount) public requireOpenDraw(self) onlyNonZero(_addr) {\n        bytes32 userId = bytes32(uint256(_addr));\n        uint256 openDrawIndex = self.openDrawIndex;\n\n        // update the current draw\n        uint256 currentAmount = self.sortitionSumTrees.stakeOf(bytes32(openDrawIndex), userId);\n        currentAmount = currentAmount.add(_amount);\n        drawSet(self, openDrawIndex, currentAmount, _addr);\n\n        uint256 firstDrawIndex = self.usersFirstDrawIndex[_addr];\n        uint256 secondDrawIndex = self.usersSecondDrawIndex[_addr];\n\n        // if this is the users first draw, set it\n        if (firstDrawIndex == 0) {\n            self.usersFirstDrawIndex[_addr] = openDrawIndex;\n        // otherwise, if the first draw is not this draw\n        } else if (firstDrawIndex != openDrawIndex) {\n            // if a second draw does not exist\n            if (secondDrawIndex == 0) {\n                // set the second draw to the current draw\n                self.usersSecondDrawIndex[_addr] = openDrawIndex;\n            // otherwise if a second draw exists but is not the current one\n            } else if (secondDrawIndex != openDrawIndex) {\n                // merge it into the first draw, and update the second draw index to this one\n                uint256 firstAmount = self.sortitionSumTrees.stakeOf(bytes32(firstDrawIndex), userId);\n                uint256 secondAmount = self.sortitionSumTrees.stakeOf(bytes32(secondDrawIndex), userId);\n                drawSet(self, firstDrawIndex, firstAmount.add(secondAmount), _addr);\n                drawSet(self, secondDrawIndex, 0, _addr);\n                self.usersSecondDrawIndex[_addr] = openDrawIndex;\n            }\n        }\n    }\n\n    /**\n     * @notice Deposits into a user's committed balance, thereby bypassing the open draw.\n     * @param self The DrawManager state\n     * @param _addr The address of the user for whom to deposit\n     * @param _amount The amount to deposit\n     */\n    function depositCommitted(State storage self, address _addr, uint256 _amount) public requireOpenDraw(self) onlyNonZero(_addr) {\n        bytes32 userId = bytes32(uint256(_addr));\n        uint256 firstDrawIndex = self.usersFirstDrawIndex[_addr];\n\n        // if they have a committed balance\n        if (firstDrawIndex != 0 && firstDrawIndex != self.openDrawIndex) {\n            uint256 firstAmount = self.sortitionSumTrees.stakeOf(bytes32(firstDrawIndex), userId);\n            drawSet(self, firstDrawIndex, firstAmount.add(_amount), _addr);\n        } else { // they must not have any committed balance\n            self.usersSecondDrawIndex[_addr] = firstDrawIndex;\n            self.usersFirstDrawIndex[_addr] = self.openDrawIndex.sub(1);\n            drawSet(self, self.usersFirstDrawIndex[_addr], _amount, _addr);\n        }\n    }\n\n    /**\n     * @notice Withdraws a user's committed and open draws.\n     * @param self The DrawManager state\n     * @param _addr The address whose balance to withdraw\n     */\n    function withdraw(State storage self, address _addr) public requireOpenDraw(self) onlyNonZero(_addr) {\n        uint256 firstDrawIndex = self.usersFirstDrawIndex[_addr];\n        uint256 secondDrawIndex = self.usersSecondDrawIndex[_addr];\n\n        if (firstDrawIndex != 0) {\n            drawSet(self, firstDrawIndex, 0, _addr);\n            delete self.usersFirstDrawIndex[_addr];\n        }\n\n        if (secondDrawIndex != 0) {\n            drawSet(self, secondDrawIndex, 0, _addr);\n            delete self.usersSecondDrawIndex[_addr];\n        }\n    }\n\n    /**\n     * @notice Withdraw's from a user's committed balance.  Fails if the user attempts to take more than available.\n     * @param self The DrawManager state\n     * @param _addr The user to withdraw from\n     * @param _amount The amount to withdraw.\n     */\n    function withdrawCommitted(State storage self, address _addr, uint256 _amount) public requireOpenDraw(self) onlyNonZero(_addr) {\n        bytes32 userId = bytes32(uint256(_addr));\n        uint256 firstDrawIndex = self.usersFirstDrawIndex[_addr];\n        uint256 secondDrawIndex = self.usersSecondDrawIndex[_addr];\n\n        uint256 firstAmount = 0;\n        uint256 secondAmount = 0;\n        uint256 total = 0;\n\n        if (secondDrawIndex != 0 && secondDrawIndex != self.openDrawIndex) {\n            secondAmount = self.sortitionSumTrees.stakeOf(bytes32(secondDrawIndex), userId);\n            total = total.add(secondAmount);\n        }\n\n        if (firstDrawIndex != 0 && firstDrawIndex != self.openDrawIndex) {\n            firstAmount = self.sortitionSumTrees.stakeOf(bytes32(firstDrawIndex), userId);\n            total = total.add(firstAmount);\n        }\n\n        require(_amount <= total, \"cannot withdraw more than available\");\n\n        uint256 remaining = total.sub(_amount);\n\n        // if there was a second amount that needs to be updated\n        if (remaining > firstAmount) {\n            uint256 secondRemaining = remaining.sub(firstAmount);\n            drawSet(self, secondDrawIndex, secondRemaining, _addr);\n        } else if (secondAmount > 0) { // else delete the second amount if it exists\n            delete self.usersSecondDrawIndex[_addr];\n            drawSet(self, secondDrawIndex, 0, _addr);\n        }\n\n        // if the first amount needs to be destroyed\n        if (remaining == 0) {\n            delete self.usersFirstDrawIndex[_addr];\n            drawSet(self, firstDrawIndex, 0, _addr);\n        } else if (remaining < firstAmount) {\n            drawSet(self, firstDrawIndex, remaining, _addr);\n        }\n    }\n\n    /**\n     * @notice Returns the total balance for an address, including committed balances and the open balance.\n     */\n    function balanceOf(State storage drawState, address _addr) public view returns (uint256) {\n        return committedBalanceOf(drawState, _addr).add(openBalanceOf(drawState, _addr));\n    }\n\n    /**\n     * @notice Returns the total committed balance for an address.\n     * @param self The DrawManager state\n     * @param _addr The address whose committed balance should be returned\n     * @return The total committed balance\n     */\n    function committedBalanceOf(State storage self, address _addr) public view returns (uint256) {\n        uint256 balance = 0;\n\n        uint256 firstDrawIndex = self.usersFirstDrawIndex[_addr];\n        uint256 secondDrawIndex = self.usersSecondDrawIndex[_addr];\n\n        if (firstDrawIndex != 0 && firstDrawIndex != self.openDrawIndex) {\n            balance = balance.add(self.sortitionSumTrees.stakeOf(bytes32(firstDrawIndex), bytes32(uint256(_addr))));\n        }\n\n        if (secondDrawIndex != 0 && secondDrawIndex != self.openDrawIndex) {\n            balance = balance.add(self.sortitionSumTrees.stakeOf(bytes32(secondDrawIndex), bytes32(uint256(_addr))));\n        }\n\n        return balance;\n    }\n\n    /**\n     * @notice Returns the open balance for an address\n     * @param self The DrawManager state\n     * @param _addr The address whose open balance should be returned\n     * @return The open balance\n     */\n    function openBalanceOf(State storage self, address _addr) public view returns (uint256) {\n        if (self.openDrawIndex == 0) {\n            return 0;\n        } else {\n            return self.sortitionSumTrees.stakeOf(bytes32(self.openDrawIndex), bytes32(uint256(_addr)));\n        }\n    }\n\n    /**\n     * @notice Returns the open Draw balance for the DrawManager\n     * @param self The DrawManager state\n     * @return The open draw total balance\n     */\n    function openSupply(State storage self) public view returns (uint256) {\n        return self.sortitionSumTrees.total(bytes32(self.openDrawIndex));\n    }\n\n    /**\n     * @notice Returns the committed balance for the DrawManager\n     * @param self The DrawManager state\n     * @return The total committed balance\n     */\n    function committedSupply(State storage self) public view returns (uint256) {\n        return self.sortitionSumTrees.total(TREE_OF_DRAWS);\n    }\n\n    /**\n     * @notice Updates the Draw balance for an address.\n     * @param self The DrawManager state\n     * @param _drawIndex The Draw index\n     * @param _amount The new balance\n     * @param _addr The address whose balance should be updated\n     */\n    function drawSet(State storage self, uint256 _drawIndex, uint256 _amount, address _addr) internal {\n        bytes32 drawId = bytes32(_drawIndex);\n        bytes32 userId = bytes32(uint256(_addr));\n        uint256 oldAmount = self.sortitionSumTrees.stakeOf(drawId, userId);\n\n        if (oldAmount != _amount) {\n            // If the amount has changed\n\n            // Update the Draw's balance for that address\n            self.sortitionSumTrees.set(drawId, _amount, userId);\n\n            // Get the new draw total\n            uint256 newDrawTotal = self.sortitionSumTrees.total(drawId);\n\n            // if the draw is committed\n            if (_drawIndex != self.openDrawIndex) {\n                // update the draw in the committed tree\n                self.sortitionSumTrees.set(TREE_OF_DRAWS, newDrawTotal, drawId);\n            }\n        }\n    }\n\n   /**\n     * @notice Selects an address by indexing into the committed tokens using the passed token\n     * @param self The DrawManager state\n     * @param _token The token index to select\n     * @return The selected address\n     */\n    function draw(State storage self, uint256 _token) public view returns (address) {\n        // If there is no one to select, just return the zero address\n        if (committedSupply(self) == 0) {\n            return address(0);\n        }\n        require(_token < committedSupply(self), \"token is beyond the eligible supply\");\n        uint256 drawIndex = uint256(self.sortitionSumTrees.draw(TREE_OF_DRAWS, _token));\n        uint256 drawSupply = self.sortitionSumTrees.total(bytes32(drawIndex));\n        uint256 drawToken = _token % drawSupply;\n        return address(uint256(self.sortitionSumTrees.draw(bytes32(drawIndex), drawToken)));\n    }\n\n    /**\n     * @notice Selects an address using the entropy as an index into the committed tokens\n     * The entropy is passed into the UniformRandomNumber library to remove modulo bias.\n     * @param self The DrawManager state\n     * @param _entropy The random entropy to use\n     * @return The selected address\n     */\n    function drawWithEntropy(State storage self, bytes32 _entropy) public view returns (address) {\n        return draw(self, UniformRandomNumber.uniform(uint256(_entropy), committedSupply(self)));\n    }\n\n    modifier requireOpenDraw(State storage self) {\n        require(self.openDrawIndex > 0, \"there is no open draw\");\n        _;\n    }\n\n    modifier onlyNonZero(address _addr) {\n        require(_addr != address(0), \"address cannot be zero\");\n        _;\n    }\n}"
    }
  ]
}