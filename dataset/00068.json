{
  "Title": "Redstone Oracle Adapter Is Flawed",
  "Content": "The [Redstone adapter](https://github.com/euler-xyz/euler-price-oracle/blob/eeb1847df7d9d58029de37225dabf963bf1a65e6/src/adapter/redstone/RedstoneCoreOracle.sol) works by locally caching the prices received through the Redstone pull-based oracle. The user supplies the off-chain verified price by calling the [`updatePrice`](https://github.com/euler-xyz/euler-price-oracle/blob/eeb1847df7d9d58029de37225dabf963bf1a65e6/src/adapter/redstone/RedstoneCoreOracle.sol#L70-L77) function on the adapter. This call is supposed to be part of a batch transaction to the Ethereum Vault Connector. This design makes the RedstoneCore Adapter function like a push-based oracle.\n\n\nThe `updatePrice` function does not let you update the price if `maxCacheStaleness` has not passed since the time of the last update. During times of high volatility, the price cannot be updated in a timely manner opening the doors for:\n\n\n* Borrowing more of an underpriced asset\n* Borrowing more value due to overpriced collaterals\n* Not being able to liquidate in a timely manner\n\n\nAnother notable observation is that the adapter can return a price that is `block.timestamp - (maxCacheStaleness + maxPriceStaleness)` old. This can lead to prices being more stalled than assumed.\n\n\nThe impact and consequences of this issue are very high. However, the likelihood is ultimately determined by the `maxCacheStaleness` and `maxPriceStaleness` time periods. If these are short enough, combined with the low likelihood of flash crashes, the overall chances of this being a serious issue are contained.\n\n\nConsider allowing `updatePrice` to be called when the `block.timestamp` is greater than the [`cacheUpdatedAt`](https://github.com/euler-xyz/euler-price-oracle/blob/eeb1847df7d9d58029de37225dabf963bf1a65e6/src/adapter/redstone/RedstoneCoreOracle.sol#L37) and devising a way where the staleness check includes both the `cacheStaleness` and the `priceStaleness`. Alternatively, use the Redstone pull-based oracle as intended without locally caching the values in the `RedstoneCoreOracle` adapter.\n\n\n***Update:** Resolved in [pull request #40](https://github.com/euler-xyz/euler-price-oracle/pull/40) at commit [b422959](https://github.com/euler-xyz/euler-price-oracle/tree/cbaa331f25569186f2fe9c365fc9932aa441e323/src)*.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/adapter/redstone/RedstoneCoreOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.23;\n\nimport {RedstoneDefaultsLib} from \"@redstone/evm-connector/core/RedstoneDefaultsLib.sol\";\nimport {PrimaryProdDataServiceConsumerBase} from\n    \"@redstone/evm-connector/data-services/PrimaryProdDataServiceConsumerBase.sol\";\nimport {BaseAdapter, Errors} from \"src/adapter/BaseAdapter.sol\";\nimport {ScaleUtils, Scale} from \"src/lib/ScaleUtils.sol\";\n\n/// @title RedstoneCoreOracle\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice Adapter for Redstone pull-based price feeds.\ncontract RedstoneCoreOracle is PrimaryProdDataServiceConsumerBase, BaseAdapter {\n    /// @notice The address of the base asset corresponding to the feed.\n    address public immutable base;\n    /// @notice The address of the quote asset corresponding to the feed.\n    address public immutable quote;\n    /// @notice The identifier of the price feed.\n    /// @dev See https://app.redstone.finance/#/app/data-services/redstone-primary-prod\n    bytes32 public immutable feedId;\n    /// @notice The decimals of the Redstone price feed.\n    /// @dev Redstone price feeds have 8 decimals by default, however certain exceptions exist.\n    uint8 public immutable feedDecimals;\n    /// @notice The maximum allowed age of the Redstone price.\n    /// @dev Compares `block.timestamp` against the timestamp of the Redstone data package in `updatePrice`.\n    uint256 public immutable maxPriceStaleness;\n    /// @notice The maximum allowed age of the cached price.\n    /// @dev Compares `block.timestamp` against the timestamp of the cached price `_getQuote`.\n    uint256 public immutable maxCacheStaleness;\n    /// @notice The scale factors used for decimal conversions.\n    Scale internal immutable scale;\n    /// @notice The last updated price.\n    /// @dev This gets updated after calling `updatePrice`.\n    uint208 public cachedPrice;\n    /// @notice The timestamp of the last update.\n    /// @dev Gets updated to `block.timestamp` after calling `updatePrice`.\n    uint48 public cacheUpdatedAt;\n\n    /// @notice Deploy a RedstoneCoreOracle.\n    /// @param _base The address of the base asset corresponding to the feed.\n    /// @param _quote The address of the quote asset corresponding to the feed.\n    /// @param _feedId The identifier of the price feed.\n    /// @param _feedDecimals The decimals of the price feed.\n    /// @param _maxPriceStaleness The maximum allowed age of the Redstone price in `updatePrice`.\n    /// @param _maxCacheStaleness The maximum allowed age of the cached price in `_getQuote`.\n    /// @dev Since Redstone prices are verified locally, callers can pass data to `maxPriceStaleness` seconds old.\n    /// It effectively imposes a deadline on the transaction, so a staleness window that is too short\n    /// increases the probability that the transaction reverts, especially during chain congestion.\n    constructor(\n        address _base,\n        address _quote,\n        bytes32 _feedId,\n        uint8 _feedDecimals,\n        uint256 _maxPriceStaleness,\n        uint256 _maxCacheStaleness\n    ) {\n        base = _base;\n        quote = _quote;\n        feedId = _feedId;\n        feedDecimals = _feedDecimals;\n        maxPriceStaleness = _maxPriceStaleness;\n        maxCacheStaleness = _maxCacheStaleness;\n        uint8 baseDecimals = _getDecimals(base);\n        uint8 quoteDecimals = _getDecimals(quote);\n        scale = ScaleUtils.calcScale(baseDecimals, quoteDecimals, _feedDecimals);\n    }\n\n    /// @notice Ingest a signed update message and cache it on the contract.\n    /// @dev Validation logic inherited from PrimaryProdDataServiceConsumerBase.\n    function updatePrice() external {\n        // Use the cache if it has not expired.\n        if (block.timestamp <= maxCacheStaleness + cacheUpdatedAt) return;\n        uint256 price = getOracleNumericValueFromTxMsg(feedId);\n        if (price > type(uint208).max) revert Errors.PriceOracle_Overflow();\n        cachedPrice = uint208(price);\n        cacheUpdatedAt = uint48(block.timestamp);\n    }\n\n    /// @notice Validate the timestamp of a Redstone signed price data package.\n    /// @param timestampMillis Data package timestamp in milliseconds.\n    /// @dev This function will be called in `getOracleNumericValueFromTxMsg` in `getQuote`,\n    /// overriding the accepted range to `[now - maxPriceStaleness, now + 1 min]`.\n    /// Notably there are cases where the data timestamp is ahead of `block.timestamp`.\n    /// This is an artifact of the Redstone system and we don't override this behavior.\n    function validateTimestamp(uint256 timestampMillis) public view virtual override {\n        uint256 timestamp = timestampMillis / 1000;\n        if (block.timestamp > timestamp) {\n            uint256 staleness = block.timestamp - timestamp;\n            if (staleness > maxPriceStaleness) revert Errors.PriceOracle_TooStale(staleness, maxPriceStaleness);\n        } else if (timestamp - block.timestamp > RedstoneDefaultsLib.DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS) {\n            revert Errors.PriceOracle_InvalidAnswer();\n        }\n    }\n\n    /// @notice Get the quote from the Redstone feed.\n    /// @param inAmount The amount of `base` to convert.\n    /// @param _base The token that is being priced.\n    /// @param _quote The token that is the unit of account.\n    /// @return The converted amount using the Redstone feed.\n    function _getQuote(uint256 inAmount, address _base, address _quote) internal view override returns (uint256) {\n        bool inverse = ScaleUtils.getDirectionOrRevert(_base, base, _quote, quote);\n\n        uint256 staleness = block.timestamp - cacheUpdatedAt;\n        if (staleness > maxCacheStaleness) revert Errors.PriceOracle_TooStale(staleness, maxCacheStaleness);\n\n        return ScaleUtils.calcOutAmount(inAmount, cachedPrice, scale, inverse);\n    }\n}"
    }
  ]
}