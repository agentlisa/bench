{
  "Title": "[M-05]",
  "Content": "<h2 id=\"m-05\" style=\"position:relative;\"><a href=\"#m-05\" aria-label=\"m 05 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[M-05]</h2>\n<p><em>Submitted by jessicapointing</em></p>\n<h3 id=\"description-of-the-problem-1\" style=\"position:relative;\"><a href=\"#description-of-the-problem-1\" aria-label=\"description of the problem 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Description of the problem</h3>\n<p>An inactive KNOT can successfully stake.</p>\n<p>Expected behaviour of the system: The stake function should revert if an inactive KNOT is trying to stake.</p>\n<p>Actual behaviour of the system: The stake function succeeds and the inactive KNOT stakes.</p>\n<p>Property Violated: <code>cannotStakeIfKnotIsInActive</code></p>\n<p>In this rule, the <code>isActive</code> state of the <code>blsPubKey</code> is set to <code>false</code>. The stake function is then called with this <code>blsPubKey</code> and the expected behaviour is that the function would revert because the KNOT is inactive. However, the stake function succeeds and an inactive KNOT can therefore successfully stake. The stake function checks if KNOT is not registered (<code>!isKNOTRegistered</code>) and if it is no longer part of the syndicate (<code>!isNoLongerPartOfSyndicate</code>) and reverts accordingly but does not check whether the KNOT is inactive.</p>\n<p>Lines of code: <a href=\"https://github.com/Certora/2023-01-blockswap-fv/blob/certora/contracts/syndicate/Syndicate.sol#L216\">https://github.com/Certora/2023-01-blockswap-fv/blob/certora/contracts/syndicate/Syndicate.sol#L216</a></p>\n<h3 id=\"potential-fix\" style=\"position:relative;\"><a href=\"#potential-fix\" aria-label=\"potential fix permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Potential Fix</h3>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">(,,,,,bool isActive) = getStakeHouseUniverse().stakeHouseKnotInfo(blsPubKey);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">if (!isKnotRegistered[_blsPubKey] || isNoLongerPartOfSyndicate[_blsPubKey] || !isActive) revert KnotIsNotRegisteredWithSyndicate();</span></span></code></pre>\n<p><strong>jessicapointing (warden) commented:</strong><br></p>\n<p>The principle found here can be applied to other functions in the code which reveal potentially more bugs. In other words, just as I have pointed out here that an <code>inActive</code> KNOT can successfully call stake and succeed, an <code>inActive</code> KNOT (or <code>!isKnotRegistered</code> or <code>isNoLongerPartOfSyndicate</code> KNOT) can successfully call other functions it shouldn’t be able to and succeed. To fix these bugs, check the <code>isActive</code>/<code>isKnotRegistered</code>/<code>isNoLongerPartOfSyndicate</code> state of a KNOT before executing the function. Maybe the lack of checks are intentional because inactive/deregistered knots can still call some functions but I’m including them here for completeness and in case they shouldn’t be able to execute such functions. Here are some of the other functions and lines of code:</p>\n<p><a href=\"https://github.com/Certora/2023-01-blockswap-fv/blob/certora/contracts/syndicate/Syndicate.sol#L269\"><code>unstake</code>:</a><br>\n<code>isActive</code> and <code>isKnotRegistered</code> is not checked.</p>\n<p><a href=\"https://github.com/Certora/2023-01-blockswap-fv/blob/certora/contracts/syndicate/Syndicate.sol#L310\"><code>claimAsCollateralizedSLOTOwner</code>:</a><br>\n<code>isActive</code> and <code>isNoLongerPartOfSyndicate</code> is not checked.</p>\n<p><a href=\"https://github.com/Certora/2023-01-blockswap-fv/blob/certora/contracts/syndicate/Syndicate.sol#L537\"><code>_updateCollateralizedSlotOwnersLiabilitySnapshot</code>:</a><br>\n<code>isActive</code> and <code>isKnotRegistered</code> is not checked.</p>\n<p><a href=\"https://github.com/Certora/2023-01-blockswap-fv/blob/certora/contracts/syndicate/Syndicate.sol#L691\"><code>_claimAsStaker</code>:</a><br>\n<code>isActive</code> and <code>isNoLongerPartOfSyndicate</code> is not checked.</p>\n<p><strong>vince0656 (Blockswap) commented:</strong><br></p>\n<blockquote>\n<p>Assessment: Low severity because if you stake without an active knot, you don’t earn rewards but you can always get your stake back.</p>\n<p>We will check for active status when staking - thanks.</p>\n</blockquote>\n<p><strong>teryanarmen (Certora) commented:</strong><br></p>\n<blockquote>\n<p>Inactive knots can earn rewards since all rewards are compiled together, but since deregistering a knot is done when the collateralized staker claims rewards and can be triggered at any time by anyone I think this is medium severity.</p>\n</blockquote>\n<hr>\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-blockswap-formal-verification-contest-with-certora",
  "Code": [
    {
      "filename": "contracts/syndicate/Syndicate.sol",
      "content": "pragma solidity 0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ISyndicateInit } from \"../interfaces/ISyndicateInit.sol\";\nimport { ETHTransferHelper } from \"../transfer/ETHTransferHelper.sol\";\nimport {\n    ZeroAddress,\n    EmptyArray,\n    InconsistentArrayLengths,\n    InvalidBLSPubKey,\n    InvalidNumberOfCollateralizedOwners,\n    KnotSlashed,\n    FreeFloatingStakeAmountTooSmall,\n    KnotIsNotRegisteredWithSyndicate,\n    NotPriorityStaker,\n    KnotIsFullyStakedWithFreeFloatingSlotTokens,\n    InvalidStakeAmount,\n    KnotIsNotAssociatedWithAStakeHouse,\n    UnableToStakeFreeFloatingSlot,\n    NothingStaked,\n    TransferFailed,\n    NotCollateralizedOwnerAtIndex,\n    InactiveKnot,\n    DuplicateArrayElements,\n    KnotIsAlreadyRegistered,\n    KnotHasAlreadyBeenDeRegistered\n} from \"./SyndicateErrors.sol\";\n\n/// @notice Syndicate registry and funds splitter for EIP1559 execution layer transaction tips across SLOT shares\n/// @dev This contract can be extended to allow lending and borrowing of time slots for borrower to redeem any revenue generated within the specified window\ncontract Syndicate is ISyndicateInit, Initializable, Ownable, ReentrancyGuard, StakehouseAPI, ETHTransferHelper {\n\n    /// @notice Emitted when the contract is initially deployed\n    event ContractDeployed();\n\n    /// @notice Emitted when accrued ETH per SLOT share type is updated\n    event UpdateAccruedETH(uint256 unprocessed);\n\n    /// @notice Emitted when new collateralized SLOT owners for a knot prompts re-calibration\n    event CollateralizedSLOTReCalibrated(bytes BLSPubKey);\n\n    /// @notice Emitted when a new KNOT is associated with the syndicate contract\n    event KNOTRegistered(bytes BLSPubKey);\n\n    /// @notice Emitted when a KNOT is de-registered from the syndicate\n    event KnotDeRegistered(bytes BLSPubKey);\n\n    /// @notice Emitted when a priority staker is added to the syndicate\n    event PriorityStakerRegistered(address indexed staker);\n\n    /// @notice Emitted when a user stakes free floating sETH tokens\n    event Staked(bytes BLSPubKey, uint256 amount);\n\n    /// @notice Emitted when a user unstakes free floating sETH tokens\n    event UnStaked(bytes BLSPubKey, uint256 amount);\n\n    /// @notice Emitted when either an sETH staker or collateralized SLOT owner claims ETH\n    event ETHClaimed(bytes BLSPubKey, address indexed user, address recipient, uint256 claim, bool indexed isCollateralizedClaim);\n\n    /// @notice Precision used in rewards calculations for scaling up and down\n    uint256 public constant PRECISION = 1e24;\n\n    /// @notice Total accrued ETH per free floating share for new and old stakers\n    uint256 public accumulatedETHPerFreeFloatingShare;\n\n    /// @notice Total accrued ETH for all collateralized SLOT holders per knot which is then distributed based on individual balances\n    uint256 public accumulatedETHPerCollateralizedSlotPerKnot;\n\n    /// @notice Last cached highest seen balance for all collateralized shares\n    uint256 public lastSeenETHPerCollateralizedSlotPerKnot;\n\n    /// @notice Last cached highest seen balance for all free floating shares\n    uint256 public lastSeenETHPerFreeFloating;\n\n    /// @notice Total number of sETH token shares staked across all houses\n    uint256 public totalFreeFloatingShares;\n\n    /// @notice Total amount of ETH drawn down by syndicate beneficiaries regardless of SLOT type\n    uint256 public totalClaimed;\n\n    /// @notice Number of knots registered with the syndicate which can be across any house\n    uint256 public numberOfRegisteredKnots;\n\n    /// @notice Informational - is the knot registered to this syndicate or not - the node should point to this contract\n    mapping(bytes => bool) public isKnotRegistered;\n\n    /// @notice Block number after which if there are sETH staking slots available, it can be supplied by anyone on the market\n    uint256 public priorityStakingEndBlock;\n\n    /// @notice Syndicate deployer can highlight addresses that get priority for staking free floating house sETH up to a certain block before anyone can do it\n    mapping(address => bool) public isPriorityStaker;\n\n    /// @notice Total amount of free floating sETH staked\n    mapping(bytes => uint256) public sETHTotalStakeForKnot;\n\n    /// @notice Amount of sETH staked by user against a knot\n    mapping(bytes => mapping(address => uint256)) public sETHStakedBalanceForKnot;\n\n    /// @notice Amount of ETH claimed by user from sETH staking\n    mapping(bytes => mapping(address => uint256)) public sETHUserClaimForKnot;\n\n    /// @notice Total amount of ETH that has been allocated to the collateralized SLOT owners of a KNOT\n    mapping(bytes => uint256) public totalETHProcessedPerCollateralizedKnot;\n\n    /// @notice Total amount of ETH accrued for the collateralized SLOT owner of a KNOT\n    mapping(bytes => mapping(address => uint256)) public accruedEarningPerCollateralizedSlotOwnerOfKnot;\n\n    /// @notice Total amount of ETH claimed by the collateralized SLOT owner of a KNOT\n    mapping(bytes => mapping(address => uint256)) public claimedPerCollateralizedSlotOwnerOfKnot;\n\n    /// @notice Whether a BLS public key, that has been previously registered, is no longer part of the syndicate and its shares (free floating or SLOT) cannot earn any more rewards\n    mapping(bytes => bool) public isNoLongerPartOfSyndicate;\n\n    /// @notice Once a BLS public key is no longer part of the syndicate, the accumulated ETH per free floating SLOT share is snapshotted so historical earnings can be drawn down correctly\n    mapping(bytes => uint256) public lastAccumulatedETHPerFreeFloatingShare;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @param _contractOwner Ethereum public key that will receive management rights of the contract\n    /// @param _priorityStakingEndBlock Block number when priority sETH staking ends and anyone can stake\n    /// @param _priorityStakers Optional list of addresses that will have priority for staking sETH against each knot registered\n    /// @param _blsPubKeysForSyndicateKnots List of BLS public keys of Stakehouse protocol registered KNOTs participating in syndicate\n    function initialize(\n        address _contractOwner,\n        uint256 _priorityStakingEndBlock,\n        address[] memory _priorityStakers,\n        bytes[] memory _blsPubKeysForSyndicateKnots\n    ) external virtual override initializer {\n        _initialize(\n            _contractOwner,\n            _priorityStakingEndBlock,\n            _priorityStakers,\n            _blsPubKeysForSyndicateKnots\n        );\n    }\n\n    /// @notice Allows the contract owner to append to the list of knots that are part of the syndicate\n    /// @param _newBLSPublicKeyBeingRegistered List of BLS public keys being added to the syndicate\n    function registerKnotsToSyndicate(\n        bytes[] calldata _newBLSPublicKeyBeingRegistered\n    ) external onlyOwner {\n        // update accrued ETH per SLOT type\n        updateAccruedETHPerShares();\n        _registerKnotsToSyndicate(_newBLSPublicKeyBeingRegistered);\n    }\n\n    /// @notice Make knot shares of a registered list of BLS public keys inactive - the action cannot be undone and no further ETH accrued\n    function deRegisterKnots(bytes[] calldata _blsPublicKeys) external onlyOwner {\n        updateAccruedETHPerShares();\n        _deRegisterKnots(_blsPublicKeys);\n    }\n\n    /// @notice Allows the contract owner to append to the list of priority sETH stakers\n    /// @param _priorityStakers List of staker addresses eligible for sETH staking\n    function addPriorityStakers(address[] calldata _priorityStakers) external onlyOwner {\n        updateAccruedETHPerShares();\n        _addPriorityStakers(_priorityStakers);\n    }\n\n    /// @notice Should this block be in the future, it means only those listed in the priority staker list can stake sETH\n    /// @param _endBlock Arbitrary block number after which anyone can stake up to 4 SLOT in sETH per KNOT\n    function updatePriorityStakingBlock(uint256 _endBlock) external onlyOwner {\n        updateAccruedETHPerShares();\n        priorityStakingEndBlock = _endBlock;\n    }\n\n    /// @notice Update accrued ETH per SLOT share without distributing ETH as users of the syndicate individually pull funds\n    function updateAccruedETHPerShares() public {\n        // Ensure there are registered KNOTs. Syndicates are deployed with at least 1 registered but this can fall to zero.\n        // Fee recipient should be re-assigned in the event that happens as any further ETH can be collected by owner\n        if (numberOfRegisteredKnots > 0) {\n            // All time, total ETH that was earned per slot type (free floating or collateralized)\n            uint256 totalEthPerSlotType = calculateETHForFreeFloatingOrCollateralizedHolders();\n\n            // Process free floating if there are staked shares\n            uint256 freeFloatingUnprocessed;\n            if (totalFreeFloatingShares > 0) {\n                freeFloatingUnprocessed = getUnprocessedETHForAllFreeFloatingSlot();\n                accumulatedETHPerFreeFloatingShare += _calculateNewAccumulatedETHPerFreeFloatingShare(freeFloatingUnprocessed);\n                lastSeenETHPerFreeFloating = totalEthPerSlotType;\n            }\n\n            uint256 collateralizedUnprocessed = ((totalEthPerSlotType - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n            accumulatedETHPerCollateralizedSlotPerKnot += collateralizedUnprocessed;\n            lastSeenETHPerCollateralizedSlotPerKnot = totalEthPerSlotType;\n\n            emit UpdateAccruedETH(freeFloatingUnprocessed + collateralizedUnprocessed);\n        }\n    }\n\n    /// @notice Stake up to 4 collateralized SLOT worth of sETH per KNOT to get a portion of syndicate rewards\n    /// @param _blsPubKeys List of BLS public keys for KNOTs registered with the syndicate\n    /// @param _sETHAmounts Per BLS public key, the total amount of sETH that will be staked (up to 4 collateralized SLOT per KNOT)\n    /// @param _onBehalfOf Allows a caller to specify an address that will be assigned stake ownership and rights to claim\n    function stake(bytes[] calldata _blsPubKeys, uint256[] calldata _sETHAmounts, address _onBehalfOf) external {\n        uint256 numOfKeys = _blsPubKeys.length;\n        if (numOfKeys == 0) revert EmptyArray();\n        if (numOfKeys != _sETHAmounts.length) revert InconsistentArrayLengths();\n        if (_onBehalfOf == address(0)) revert ZeroAddress();\n\n        // Make sure we have the latest accrued information\n        updateAccruedETHPerShares();\n\n        for (uint256 i; i < numOfKeys; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            uint256 _sETHAmount = _sETHAmounts[i];\n\n            if (_sETHAmount < 1 gwei) revert FreeFloatingStakeAmountTooSmall();\n            if (!isKnotRegistered[_blsPubKey] || isNoLongerPartOfSyndicate[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();\n\n            if (block.number < priorityStakingEndBlock && !isPriorityStaker[_onBehalfOf]) revert NotPriorityStaker();\n\n            uint256 totalStaked = sETHTotalStakeForKnot[_blsPubKey];\n            if (totalStaked == 12 ether) revert KnotIsFullyStakedWithFreeFloatingSlotTokens();\n\n            if (_sETHAmount + totalStaked > 12 ether) revert InvalidStakeAmount();\n\n            totalFreeFloatingShares += _sETHAmount;\n            sETHTotalStakeForKnot[_blsPubKey] += _sETHAmount;\n            sETHStakedBalanceForKnot[_blsPubKey][_onBehalfOf] += _sETHAmount;\n            sETHUserClaimForKnot[_blsPubKey][_onBehalfOf] += (_sETHAmount * accumulatedETHPerFreeFloatingShare) / PRECISION;\n\n            (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n            if (stakeHouse == address(0)) revert KnotIsNotAssociatedWithAStakeHouse();\n            IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakeHouse));\n            bool transferResult = sETH.transferFrom(msg.sender, address(this), _sETHAmount);\n            if (!transferResult) revert UnableToStakeFreeFloatingSlot();\n\n            emit Staked(_blsPubKey, _sETHAmount);\n        }\n    }\n\n    /// @notice Unstake an sETH position against a particular KNOT and claim ETH on exit\n    /// @param _unclaimedETHRecipient The address that will receive any unclaimed ETH received to the syndicate\n    /// @param _sETHRecipient The address that will receive the sETH that is being unstaked\n    /// @param _blsPubKeys List of BLS public keys for KNOTs registered with the syndicate\n    /// @param _sETHAmounts Per BLS public key, the total amount of sETH that will be unstaked\n    function unstake(\n        address _unclaimedETHRecipient,\n        address _sETHRecipient,\n        bytes[] calldata _blsPubKeys,\n        uint256[] calldata _sETHAmounts\n    ) external nonReentrant {\n        uint256 numOfKeys = _blsPubKeys.length;\n        if (numOfKeys == 0) revert EmptyArray();\n        if (numOfKeys != _sETHAmounts.length) revert InconsistentArrayLengths();\n        if (_unclaimedETHRecipient == address(0)) revert ZeroAddress();\n        if (_sETHRecipient == address(0)) revert ZeroAddress();\n\n        // Claim all ETH owed before unstaking but even if nothing is owed `updateAccruedETHPerShares` will be called\n        _claimAsStaker(_unclaimedETHRecipient, _blsPubKeys);\n\n        for (uint256 i; i < numOfKeys; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            uint256 _sETHAmount = _sETHAmounts[i];\n            if (sETHStakedBalanceForKnot[_blsPubKey][msg.sender] < _sETHAmount) revert NothingStaked();\n\n            (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n            IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakeHouse));\n\n            // Only decrease totalFreeFloatingShares in the event that the knot is still active in the syndicate\n            if (!isNoLongerPartOfSyndicate[_blsPubKey]) {\n                totalFreeFloatingShares -= _sETHAmount;\n            }\n\n            sETHTotalStakeForKnot[_blsPubKey] -= _sETHAmount;\n            sETHStakedBalanceForKnot[_blsPubKey][msg.sender] -= _sETHAmount;\n\n            uint256 accumulatedETHPerShare = _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(_blsPubKey);\n            sETHUserClaimForKnot[_blsPubKey][msg.sender] =\n                (accumulatedETHPerShare * sETHStakedBalanceForKnot[_blsPubKey][msg.sender]) / PRECISION;\n\n            bool transferResult = sETH.transfer(_sETHRecipient, _sETHAmount);\n            if (!transferResult) revert TransferFailed();\n\n            emit UnStaked(_blsPubKey, _sETHAmount);\n        }\n    }\n\n    /// @notice Claim ETH cashflow from the syndicate as an sETH staker proportional to how much the user has staked\n    /// @param _recipient Address that will receive the share of ETH funds\n    /// @param _blsPubKeys List of BLS public keys that the caller has staked against\n    function claimAsStaker(address _recipient, bytes[] calldata _blsPubKeys) public nonReentrant {\n        _claimAsStaker(_recipient, _blsPubKeys);\n    }\n\n    /// @param _blsPubKeys List of BLS public keys that the caller has staked against\n    function claimAsCollateralizedSLOTOwner(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        uint256 numOfKeys = _blsPubKeys.length;\n        if (numOfKeys == 0) revert EmptyArray();\n        if (_recipient == address(0)) revert ZeroAddress();\n        if (_recipient == address(this)) revert ZeroAddress();\n\n        // Make sure we have the latest accrued information for all shares\n        updateAccruedETHPerShares();\n\n        uint256 totalToTransfer;\n        for (uint256 i; i < numOfKeys; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            if (!isKnotRegistered[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();\n\n            // process newly accrued ETH and distribute it to collateralized SLOT owners for the given knot\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKey);\n\n            // Calculate total amount of unclaimed ETH\n            uint256 userShare = accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender];\n\n            // This is designed to cope with falling SLOT balances i.e. when collateralized SLOT is burnt after applying penalties\n            uint256 unclaimedUserShare = userShare - claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender];\n\n            // Send ETH to the user if there is an unclaimed amount\n            if (unclaimedUserShare > 0) {\n                // Increase total claimed and claimed at the user level\n                totalClaimed += unclaimedUserShare;\n                claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender] = userShare;\n\n                // Send ETH to user\n                totalToTransfer += unclaimedUserShare;\n\n                emit ETHClaimed(\n                    _blsPubKey,\n                    msg.sender,\n                    _recipient,\n                    unclaimedUserShare,\n                    true\n                );\n            }\n        }\n\n        _transferETH(_recipient, totalToTransfer);\n    }\n\n    /// @notice For any new ETH received by the syndicate, at the knot level allocate ETH owed to each collateralized owner\n    /// @param _blsPubKey BLS public key relating to the collateralized owners that need updating\n    function updateCollateralizedSlotOwnersAccruedETH(bytes memory _blsPubKey) external {\n        _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKey);\n    }\n\n    /// @notice For any new ETH received by the syndicate, at the knot level allocate ETH owed to each collateralized owner and do it for a batch of knots\n    /// @param _blsPubKeys List of BLS public keys related to the collateralized owners that need updating\n    function batchUpdateCollateralizedSlotOwnersAccruedETH(bytes[] memory _blsPubKeys) external {\n        uint256 numOfKeys = _blsPubKeys.length;\n        if (numOfKeys == 0) revert EmptyArray();\n        for (uint256 i; i < numOfKeys; ++i) {\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKeys[i]);\n        }\n    }\n\n    /// @notice Syndicate contract can receive ETH\n    receive() external payable {\n        // No logic here because one cannot assume that more than 21K GAS limit is forwarded\n    }\n\n    /// @notice Calculate the amount of unclaimed ETH for a given BLS publice key + free floating SLOT staker without factoring in unprocessed rewards\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    /// @param _user The address of a user that has staked sETH against the BLS public key\n    function calculateUnclaimedFreeFloatingETHShare(bytes memory _blsPubKey, address _user) public view returns (uint256) {\n        // Check the user has staked sETH for the KNOT\n        uint256 stakedBal = sETHStakedBalanceForKnot[_blsPubKey][_user];\n        if (stakedBal < 1 gwei) return 0;\n\n        // Get the amount of ETH eligible for the user based on their staking amount\n        uint256 accumulatedETHPerShare = _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(_blsPubKey);\n        uint256 userShare = (accumulatedETHPerShare * stakedBal) / PRECISION;\n\n        // Calculate how much their unclaimed share of ETH is based on total ETH claimed so far\n        return userShare - sETHUserClaimForKnot[_blsPubKey][_user];\n    }\n\n    /// @notice Using `highestSeenBalance`, this is the amount that is separately allocated to either free floating or collateralized SLOT holders\n    function calculateETHForFreeFloatingOrCollateralizedHolders() public view returns (uint256) {\n        // Get total amount of ETH that can be drawn down by all SLOT holders associated with a knot\n        uint256 ethPerKnot = totalETHReceived();\n\n        // Get the amount of ETH eligible for free floating sETH or collateralized SLOT stakers\n        return ethPerKnot / 2;\n    }\n\n    /// @notice Calculate the total unclaimed ETH across an array of BLS public keys for a free floating staker\n    function batchPreviewUnclaimedETHAsFreeFloatingStaker(\n        address _staker,\n        bytes[] calldata _blsPubKeys\n    ) external view returns (uint256) {\n        uint256 accumulated;\n        uint256 numOfKeys = _blsPubKeys.length;\n        for (uint256 i; i < numOfKeys; ++i) {\n            accumulated += previewUnclaimedETHAsFreeFloatingStaker(_staker, _blsPubKeys[i]);\n        }\n\n        return accumulated;\n    }\n\n    /// @notice Preview the amount of unclaimed ETH available for an sETH staker against a KNOT which factors in unprocessed rewards from new ETH sent to contract\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    /// @param _staker The address of a user that has staked sETH against the BLS public key\n    function previewUnclaimedETHAsFreeFloatingStaker(\n        address _staker,\n        bytes calldata _blsPubKey\n    ) public view returns (uint256) {\n        uint256 currentAccumulatedETHPerFreeFloatingShare = accumulatedETHPerFreeFloatingShare;\n        uint256 updatedAccumulatedETHPerFreeFloatingShare =\n                            currentAccumulatedETHPerFreeFloatingShare + calculateNewAccumulatedETHPerFreeFloatingShare();\n\n        uint256 stakedBal = sETHStakedBalanceForKnot[_blsPubKey][_staker];\n        uint256 userShare = (updatedAccumulatedETHPerFreeFloatingShare * stakedBal) / PRECISION;\n\n        return userShare - sETHUserClaimForKnot[_blsPubKey][_staker];\n    }\n\n    /// @notice Calculate the total unclaimed ETH across an array of BLS public keys for a collateralized SLOT staker\n    function batchPreviewUnclaimedETHAsCollateralizedSlotOwner(\n        address _staker,\n        bytes[] calldata _blsPubKeys\n    ) external view returns (uint256) {\n        uint256 accumulated;\n        uint256 numOfKeys = _blsPubKeys.length;\n        for (uint256 i; i < numOfKeys; ++i) {\n            accumulated += previewUnclaimedETHAsCollateralizedSlotOwner(_staker, _blsPubKeys[i]);\n        }\n\n        return accumulated;\n    }\n\n    /// @notice Preview the amount of unclaimed ETH available for a collatearlized SLOT staker against a KNOT which factors in unprocessed rewards from new ETH sent to contract\n    /// @param _staker Address of a collateralized SLOT owner for a KNOT\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    function previewUnclaimedETHAsCollateralizedSlotOwner(\n        address _staker,\n        bytes calldata _blsPubKey\n    ) public view returns (uint256) {\n        // Per collateralized SLOT per KNOT before distributing to individual collateralized owners\n        uint256 accumulatedSoFar = accumulatedETHPerCollateralizedSlotPerKnot\n                    + ((calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n\n        uint256 unprocessedForKnot = accumulatedSoFar - totalETHProcessedPerCollateralizedKnot[_blsPubKey];\n\n        // Fetch information on what has been processed so far against the ECDSA address of the collateralized SLOT owner\n        uint256 currentAccrued = accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][_staker];\n\n        // Fetch information about the knot including total slashed amount\n        uint256 currentSlashedAmount = getSlotRegistry().currentSlashedAmountOfSLOTForKnot(_blsPubKey);\n        uint256 numberOfCollateralisedSlotOwnersForKnot = getSlotRegistry().numberOfCollateralisedSlotOwnersForKnot(_blsPubKey);\n        (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n\n        // Find the collateralized SLOT owner and work out how much they're owed\n        for (uint256 i; i < numberOfCollateralisedSlotOwnersForKnot; ++i) {\n            address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, i);\n            if (collateralizedOwnerAtIndex == _staker) {\n                uint256 balance = getSlotRegistry().totalUserCollateralisedSLOTBalanceForKnot(\n                    stakeHouse,\n                    collateralizedOwnerAtIndex,\n                    _blsPubKey\n                );\n\n                if (currentSlashedAmount < 4 ether) {\n                    currentAccrued +=\n                    numberOfCollateralisedSlotOwnersForKnot > 1 ? balance * unprocessedForKnot / (4 ether - currentSlashedAmount)\n                    : unprocessedForKnot;\n                }\n                break;\n            }\n        }\n\n        return currentAccrued - claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][_staker];\n    }\n\n    /// @notice Amount of ETH per free floating share that hasn't yet been allocated to each share\n    function getUnprocessedETHForAllFreeFloatingSlot() public view returns (uint256) {\n        return calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerFreeFloating;\n    }\n\n    /// @notice Amount of ETH per collateralized share that hasn't yet been allocated to each share\n    function getUnprocessedETHForAllCollateralizedSlot() public view returns (uint256) {\n        return ((calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n    }\n\n    /// @notice New accumulated ETH per free floating share that hasn't yet been applied\n    /// @dev The return value is scaled by 1e24\n    function calculateNewAccumulatedETHPerFreeFloatingShare() public view returns (uint256) {\n        uint256 ethSinceLastUpdate = getUnprocessedETHForAllFreeFloatingSlot();\n        return _calculateNewAccumulatedETHPerFreeFloatingShare(ethSinceLastUpdate);\n    }\n\n    /// @notice New accumulated ETH per collateralized share per knot that hasn't yet been applied\n    function calculateNewAccumulatedETHPerCollateralizedSharePerKnot() public view returns (uint256) {\n        uint256 ethSinceLastUpdate = getUnprocessedETHForAllCollateralizedSlot();\n        return accumulatedETHPerCollateralizedSlotPerKnot + ethSinceLastUpdate;\n    }\n\n    /// @notice Total amount of ETH received by the contract\n    function totalETHReceived() public view returns (uint256) {\n        return address(this).balance + totalClaimed;\n    }\n\n    /// @dev Internal logic for initializing the syndicate contract\n    function _initialize(\n        address _contractOwner,\n        uint256 _priorityStakingEndBlock,\n        address[] memory _priorityStakers,\n        bytes[] memory _blsPubKeysForSyndicateKnots\n    ) internal {\n        // Transfer ownership from the deployer to the address specified as the owner\n        _transferOwnership(_contractOwner);\n\n        // Add the initial set of knots to the syndicate\n        _registerKnotsToSyndicate(_blsPubKeysForSyndicateKnots);\n\n        // Optionally process priority staking if the required params and array is configured\n        if (_priorityStakingEndBlock > block.number) {\n            priorityStakingEndBlock = _priorityStakingEndBlock;\n            _addPriorityStakers(_priorityStakers);\n        }\n\n        emit ContractDeployed();\n    }\n\n    /// Given an amount of ETH allocated to the collateralized SLOT owners of a KNOT, distribute this amongs the current set of collateralized owners (a dynamic set of addresses and balances)\n    function _updateCollateralizedSlotOwnersLiabilitySnapshot(bytes memory _blsPubKey) internal {\n        // Establish how much new ETH is for the new KNOT\n        uint256 unprocessedETHForCurrentKnot =\n                    accumulatedETHPerCollateralizedSlotPerKnot - totalETHProcessedPerCollateralizedKnot[_blsPubKey];\n\n        // Get information about the knot i.e. associated house and whether its active\n        (address stakeHouse,,,,,bool isActive) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n\n        // Assuming that there is unprocessed ETH and the knot is still part of the syndicate\n        if (unprocessedETHForCurrentKnot > 0 && !isNoLongerPartOfSyndicate[_blsPubKey]) {\n            uint256 currentSlashedAmount = getSlotRegistry().currentSlashedAmountOfSLOTForKnot(_blsPubKey);\n\n            // Don't allocate ETH when the current slashed amount is four. Syndicate will wait until ETH is topped up to claim revenue\n            if (currentSlashedAmount < 4 ether) {\n                // This copes with increasing numbers of collateralized slot owners and also copes with SLOT that has been slashed but not topped up\n                uint256 numberOfCollateralisedSlotOwnersForKnot = getSlotRegistry().numberOfCollateralisedSlotOwnersForKnot(_blsPubKey);\n\n                if (numberOfCollateralisedSlotOwnersForKnot == 1) {\n                    // For only 1 collateralized SLOT owner, they get the full amount of unprocessed ETH for the knot\n                    address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, 0);\n                    accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][collateralizedOwnerAtIndex] += unprocessedETHForCurrentKnot;\n                } else {\n                    for (uint256 i; i < numberOfCollateralisedSlotOwnersForKnot; ++i) {\n                        address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, i);\n                        uint256 balance = getSlotRegistry().totalUserCollateralisedSLOTBalanceForKnot(\n                            stakeHouse,\n                            collateralizedOwnerAtIndex,\n                            _blsPubKey\n                        );\n\n                        accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][collateralizedOwnerAtIndex] +=\n                            balance * unprocessedETHForCurrentKnot / (4 ether - currentSlashedAmount);\n                    }\n                }\n\n                // record so unprocessed goes to zero\n                totalETHProcessedPerCollateralizedKnot[_blsPubKey] = accumulatedETHPerCollateralizedSlotPerKnot;\n            }\n        }\n\n        // if the knot is no longer active, no further accrual of rewards are possible snapshots are possible but ETH accrued up to that point\n        // Basically, under a rage quit or voluntary withdrawal from the beacon chain, the knot kick is auto-propagated to syndicate\n        if (!isActive && !isNoLongerPartOfSyndicate[_blsPubKey]) {\n            _deRegisterKnot(_blsPubKey);\n        }\n    }\n\n    function _calculateCollateralizedETHOwedPerKnot() internal view returns (uint256) {\n        uint256 collateralizedSLOTShareOfETH = calculateETHForFreeFloatingOrCollateralizedHolders();\n        uint256 collateralizedSLOTShareOfETHPerKnot = (collateralizedSLOTShareOfETH / numberOfRegisteredKnots);\n        return collateralizedSLOTShareOfETHPerKnot;\n    }\n\n    /// @dev Business logic for calculating per collateralized share how much ETH from 1559 rewards is owed\n    function _calculateNewAccumulatedETHPerCollateralizedShare(uint256 _ethSinceLastUpdate) internal view returns (uint256) {\n        return (_ethSinceLastUpdate * PRECISION) / (numberOfRegisteredKnots * 4 ether);\n    }\n\n    /// @dev Business logic for calculating per free floating share how much ETH from 1559 rewards is owed\n    function _calculateNewAccumulatedETHPerFreeFloatingShare(uint256 _ethSinceLastUpdate) internal view returns (uint256) {\n        return totalFreeFloatingShares > 0 ? (_ethSinceLastUpdate * PRECISION) / totalFreeFloatingShares : 0;\n    }\n\n    /// @dev Business logic for adding a new set of knots to the syndicate for collecting revenue\n    function _registerKnotsToSyndicate(bytes[] memory _blsPubKeysForSyndicateKnots) internal {\n        uint256 knotsToRegister = _blsPubKeysForSyndicateKnots.length;\n        if (knotsToRegister == 0) revert EmptyArray();\n        numberOfRegisteredKnots += knotsToRegister;\n\n        for (uint256 i; i < knotsToRegister; ++i) {\n            bytes memory blsPubKey = _blsPubKeysForSyndicateKnots[i];\n\n            if (isKnotRegistered[blsPubKey]) revert KnotIsAlreadyRegistered();\n\n            // incomming knot collateralized SLOT holders do not get historical earnings\n            totalETHProcessedPerCollateralizedKnot[blsPubKey] = accumulatedETHPerCollateralizedSlotPerKnot;\n\n            // Health check - if knot is inactive or slashed, should it really be part of the syndicate?\n            // KNOTs closer to 32 effective at all times is the target\n            (,,,,,bool isActive) = getStakeHouseUniverse().stakeHouseKnotInfo(blsPubKey"
    }
  ]
}