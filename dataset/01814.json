{
  "Title": "H-5: `initialCollateralDeltaAmount` is incorrectly interpreted as a USD value when calculating estimated remaining collateral",
  "Content": "# Issue H-5: `initialCollateralDeltaAmount` is incorrectly interpreted as a USD value when calculating estimated remaining collateral \n\nSource: https://github.com/sherlock-audit/2023-04-gmx-judging/issues/249 \n\n## Found by \nChinmay, IllIllI, bin2chen, ten-on-ten\n## Summary\n\nDecrease orders have checks to ensure that if collateral is withdrawn, that there is enough left that the liquidation checks will still pass. The code that calculates the remaining collateral incorrectly adds a token amount to a USD value.\n\n\n## Vulnerability Detail\n\n`initialCollateralDeltaAmount` is incorrectly interpreted as a USD value when calculating estimated remaining collateral which means, depending on the token's decimals, the collateral will either be accepted or not accepted, when it shouldn't be.\n\n\n## Impact\n\nIf the remaining collateral is over-estimated, the `MIN_COLLATERAL_USD` checks later in the function will pass, and the user will be able decrease their collateral, but then will immediately be liquidatable by liquidation keepers, since liquidation orders don't attempt to change the collateral amount. \n\nIf the remaining collateral is under-estimated, the user will be incorrectly locked into their position.\n\n\n## Code Snippet\n\n`initialCollateralDeltaAmount()` isn't converted to a USD amount before being added to `estimatedRemainingCollateralUsd`, which is a USD amount:\n```solidity\n// File: gmx-synthetics/contracts/position/DecreasePositionUtils.sol : DecreasePositionUtils.decreasePosition()   #1\n\n139                    // the estimatedRemainingCollateralUsd subtracts the initialCollateralDeltaAmount\n140                    // since the initialCollateralDeltaAmount will be set to zero, the initialCollateralDeltaAmount\n141                    // should be added back to the estimatedRemainingCollateralUsd\n142 @>                 estimatedRemainingCollateralUsd += params.order.initialCollateralDeltaAmount().toInt256();\n143                    params.order.setInitialCollateralDeltaAmount(0);\n144                }\n145    \n146                // if the remaining collateral including position pnl will be below\n147                // the min collateral usd value, then close the position\n148                //\n149                // if the position has sufficient remaining collateral including pnl\n150                // then allow the position to be partially closed and the updated\n151                // position to remain open\n152:@>             if ((estimatedRemainingCollateralUsd + cache.estimatedRemainingPnlUsd) < params.contracts.dataStore.getUint(Keys.MIN_COLLATERAL_USD).toInt256()) {\n```\nhttps://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/position/DecreasePositionUtils.sol#L132-L152\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nConvert to a USD amount before doing the addition\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/74",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/position/DecreasePositionUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Precision.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../pricing/PositionPricingUtils.sol\";\n\nimport \"./Position.sol\";\nimport \"./PositionStoreUtils.sol\";\nimport \"./PositionUtils.sol\";\nimport \"./PositionEventUtils.sol\";\nimport \"../order/BaseOrderUtils.sol\";\nimport \"../order/OrderEventUtils.sol\";\n\nimport \"./DecreasePositionCollateralUtils.sol\";\n\n// @title DecreasePositionUtils\n// @dev Library for functions to help with decreasing a position\nlibrary DecreasePositionUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    // @dev DecreasePositionResult struct for the results of decreasePosition\n    // @param outputToken the output token\n    // @param outputAmount the output amount\n    // @param secondaryOutputToken the secondary output token\n    // @param secondaryOutputAmount the secondary output amount\n    struct DecreasePositionResult {\n        address outputToken;\n        uint256 outputAmount;\n        address secondaryOutputToken;\n        uint256 secondaryOutputAmount;\n    }\n\n    // @dev decreases a position\n    // The decreasePosition function decreases the size of an existing position\n    // in a market. It takes a PositionUtils.UpdatePositionParams object as an input, which\n    // includes information about the position to be decreased, the market in\n    // which the position exists, and the order that is being used to decrease the position.\n    //\n    // The function first calculates the prices of the tokens in the market, and then\n    // checks whether the position is liquidatable based on the current market prices.\n    // If the order is a liquidation order and the position is not liquidatable, the function reverts.\n    //\n    // If there is not enough collateral in the position to complete the decrease,\n    // the function reverts. Otherwise, the function updates the position's size and\n    // collateral amount, and increments the claimable funding amount for\n    // the market if necessary.\n    //\n    // Finally, the function returns a DecreasePositionResult object containing\n    // information about the outcome of the decrease operation, including the amount\n    // of collateral removed from the position and any fees that were paid.\n    // @param params PositionUtils.UpdatePositionParams\n    function decreasePosition(\n        PositionUtils.UpdatePositionParams memory params\n    ) external returns (DecreasePositionResult memory) {\n        PositionUtils.DecreasePositionCache memory cache;\n\n        cache.prices = MarketUtils.getMarketPricesForPosition(\n            params.contracts.oracle,\n            params.market\n        );\n\n        // cap the order size to the position size\n        if (params.order.sizeDeltaUsd() > params.position.sizeInUsd()) {\n            if (params.order.orderType() == Order.OrderType.LimitDecrease ||\n                params.order.orderType() == Order.OrderType.StopLossDecrease) {\n\n                OrderEventUtils.emitOrderSizeDeltaAutoUpdated(\n                    params.contracts.eventEmitter,\n                    params.orderKey,\n                    params.order.sizeDeltaUsd(),\n                    params.position.sizeInUsd()\n                );\n\n                params.order.setSizeDeltaUsd(params.position.sizeInUsd());\n            } else {\n                revert Errors.InvalidDecreaseOrderSize(params.order.sizeDeltaUsd(), params.position.sizeInUsd());\n            }\n        }\n\n        // if the position will be partially decreased then do a check on the\n        // remaining collateral amount and update the order attributes if needed\n        if (params.order.sizeDeltaUsd() < params.position.sizeInUsd()) {\n            // estimate pnl based on indexTokenPrice\n            (cache.estimatedPositionPnlUsd, /* uint256 sizeDeltaInTokens */) = PositionUtils.getPositionPnlUsd(\n                params.contracts.dataStore,\n                params.market,\n                cache.prices,\n                params.position,\n                cache.prices.indexTokenPrice.pickPriceForPnl(params.position.isLong(), false),\n                params.position.sizeInUsd()\n            );\n\n            cache.estimatedRealizedPnlUsd = cache.estimatedPositionPnlUsd * params.order.sizeDeltaUsd().toInt256() / params.position.sizeInUsd().toInt256();\n            cache.estimatedRemainingPnlUsd = cache.estimatedPositionPnlUsd - cache.estimatedRealizedPnlUsd;\n\n            PositionUtils.WillPositionCollateralBeSufficientValues memory positionValues = PositionUtils.WillPositionCollateralBeSufficientValues(\n                params.position.sizeInUsd() - params.order.sizeDeltaUsd(), // positionSizeInUsd\n                params.position.collateralAmount() - params.order.initialCollateralDeltaAmount(), // positionCollateralAmount\n                cache.estimatedRealizedPnlUsd,  // realizedPnlUsd\n                -params.order.sizeDeltaUsd().toInt256() // openInterestDelta\n            );\n\n            (bool willBeSufficient, int256 estimatedRemainingCollateralUsd) = PositionUtils.willPositionCollateralBeSufficient(\n                params.contracts.dataStore,\n                params.market,\n                cache.prices,\n                params.position.collateralToken(),\n                params.position.isLong(),\n                positionValues\n            );\n\n            // do not allow withdrawal of collateral if it would lead to the position\n            // having an insufficient amount of collateral\n            // this helps to prevent gaming by opening a position then reducing collateral\n            // to increase the leverage of the position\n            if (!willBeSufficient) {\n                if (params.order.sizeDeltaUsd() == 0) {\n                    revert Errors.UnableToWithdrawCollateralDueToLeverage(estimatedRemainingCollateralUsd);\n                }\n\n                OrderEventUtils.emitOrderCollateralDeltaAmountAutoUpdated(\n                    params.contracts.eventEmitter,\n                    params.orderKey,\n                    params.order.initialCollateralDeltaAmount(),\n                    0\n                );\n\n                // the estimatedRemainingCollateralUsd subtracts the initialCollateralDeltaAmount\n                // since the initialCollateralDeltaAmount will be set to zero, the initialCollateralDeltaAmount\n                // should be added back to the estimatedRemainingCollateralUsd\n                estimatedRemainingCollateralUsd += params.order.initialCollateralDeltaAmount().toInt256();\n                params.order.setInitialCollateralDeltaAmount(0);\n            }\n\n            // if the remaining collateral including position pnl will be below\n            // the min collateral usd value, then close the position\n            //\n            // if the position has sufficient remaining collateral including pnl\n            // then allow the position to be partially closed and the updated\n            // position to remain open\n            if ((estimatedRemainingCollateralUsd + cache.estimatedRemainingPnlUsd) < params.contracts.dataStore.getUint(Keys.MIN_COLLATERAL_USD).toInt256()) {\n                OrderEventUtils.emitOrderSizeDeltaAutoUpdated(\n                    params.contracts.eventEmitter,\n                    params.orderKey,\n                    params.order.sizeDeltaUsd(),\n                    params.position.sizeInUsd()\n                );\n\n                params.order.setSizeDeltaUsd(params.position.sizeInUsd());\n            }\n\n            if (\n                params.position.sizeInUsd() > params.order.sizeDeltaUsd()  &&\n                params.position.sizeInUsd() - params.order.sizeDeltaUsd() < params.contracts.dataStore.getUint(Keys.MIN_POSITION_SIZE_USD)\n            ) {\n                OrderEventUtils.emitOrderSizeDeltaAutoUpdated(\n                    params.contracts.eventEmitter,\n                    params.orderKey,\n                    params.order.sizeDeltaUsd(),\n                    params.position.sizeInUsd()\n                );\n\n                params.order.setSizeDeltaUsd(params.position.sizeInUsd());\n            }\n        }\n\n        // if the position will be closed, set the initial collateral delta amount\n        // to zero to help ensure that the order can be executed\n        if (params.order.sizeDeltaUsd() == params.position.sizeInUsd() && params.order.initialCollateralDeltaAmount() > 0) {\n            params.order.setInitialCollateralDeltaAmount(0);\n        }\n\n        cache.pnlToken = params.position.isLong() ? params.market.longToken : params.market.shortToken;\n        cache.pnlTokenPrice = params.position.isLong() ? cache.prices.longTokenPrice : cache.prices.shortTokenPrice;\n\n        if (params.order.decreasePositionSwapType() != Order.DecreasePositionSwapType.NoSwap &&\n            cache.pnlToken == params.position.collateralToken()) {\n            params.order.setDecreasePositionSwapType(Order.DecreasePositionSwapType.NoSwap);\n        }\n\n        PositionUtils.updateFundingAndBorrowingState(params, cache.prices);\n\n        if (BaseOrderUtils.isLiquidationOrder(params.order.orderType()) && !PositionUtils.isPositionLiquidatable(\n            params.contracts.dataStore,\n            params.contracts.referralStorage,\n            params.position,\n            params.market,\n            cache.prices,\n            false, // isIncrease\n            true // shouldValidateMinCollateralUsd\n        )) {\n            revert Errors.PositionShouldNotBeLiquidated();\n        }\n\n        cache.initialCollateralAmount = params.position.collateralAmount();\n        (\n            PositionUtils.DecreasePositionCollateralValues memory values,\n            PositionPricingUtils.PositionFees memory fees\n        ) = DecreasePositionCollateralUtils.processCollateral(\n            params,\n            cache\n        );\n\n        cache.nextPositionSizeInUsd = params.position.sizeInUsd() - params.order.sizeDeltaUsd();\n        cache.nextPositionBorrowingFactor = MarketUtils.getCumulativeBorrowingFactor(params.contracts.dataStore, params.market.marketToken, params.position.isLong());\n\n        PositionUtils.updateTotalBorrowing(\n            params,\n            cache.nextPositionSizeInUsd,\n            cache.nextPositionBorrowingFactor\n        );\n\n        params.position.setSizeInUsd(cache.nextPositionSizeInUsd);\n        params.position.setSizeInTokens(params.position.sizeInTokens() - values.sizeDeltaInTokens);\n        params.position.setCollateralAmount(values.remainingCollateralAmount.toUint256());\n        params.position.setDecreasedAtBlock(Chain.currentBlockNumber());\n\n        PositionUtils.incrementClaimableFundingAmount(params, fees);\n\n        if (params.position.sizeInUsd() == 0 || params.position.sizeInTokens() == 0) {\n            // withdraw all collateral if the position will be closed\n            values.output.outputAmount += params.position.collateralAmount();\n\n            params.position.setSizeInUsd(0);\n            params.position.setSizeInTokens(0);\n            params.position.setCollateralAmount(0);\n\n            PositionStoreUtils.remove(params.contracts.dataStore, params.positionKey, params.order.account());\n        } else {\n            params.position.setLongTokenFundingAmountPerSize(fees.funding.latestLongTokenFundingAmountPerSize);\n            params.position.setShortTokenFundingAmountPerSize(fees.funding.latestShortTokenFundingAmountPerSize);\n            params.position.setBorrowingFactor(cache.nextPositionBorrowingFactor);\n\n            // validate position which validates liquidation state is only called\n            // if the remaining position size is not zero\n            // due to this, a user can still manually close their position if\n            // it is in a partially liquidatable state\n            // this should not cause any issues as a liquidation is the same\n            // as automatically closing a position\n            // the only difference is that if the position has insufficient / negative\n            // collateral a liquidation transaction should still complete\n            // while a manual close transaction should revert\n            PositionUtils.validatePosition(\n                params.contracts.dataStore,\n                params.contracts.referralStorage,\n                params.position,\n                params.market,\n                cache.prices,\n                false, // isIncrease\n                false, // shouldValidateMinPositionSize\n                false // shouldValidateMinCollateralUsd\n            );\n\n            PositionStoreUtils.set(params.contracts.dataStore, params.positionKey, params.position);\n        }\n\n        MarketUtils.applyDeltaToCollateralSum(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.position.market(),\n            params.position.collateralToken(),\n            params.position.isLong(),\n            -(cache.initialCollateralAmount - params.position.collateralAmount()).toInt256()\n        );\n\n        PositionUtils.updateOpenInterest(\n            params,\n            -params.order.sizeDeltaUsd().toInt256(),\n            -values.sizeDeltaInTokens.toInt256()\n        );\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            values.pnlTokenForPool,\n            values.pnlAmountForPool\n        );\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            params.position.collateralToken(),\n            fees.feeAmountForPool.toInt256()\n        );\n\n        // affiliate rewards are still distributed even if the order is a liquidation order\n        // this is expected as a partial liquidation is considered the same as an automatic\n        // closing of a position\n        PositionUtils.handleReferral(params, fees);\n\n        PositionEventUtils.emitPositionFeesCollected(\n            params.contracts.eventEmitter,\n            params.orderKey,\n            params.market.marketToken,\n            params.position.collateralToken(),\n            params.order.sizeDeltaUsd(),\n            false,\n            fees\n        );\n\n        PositionEventUtils.emitPositionDecrease(\n            params.contracts.eventEmitter,\n            params.orderKey,\n            params.positionKey,\n            params.position,\n            params.order.sizeDeltaUsd(),\n            cache.initialCollateralAmount - params.position.collateralAmount(),\n            params.order.orderType(),\n            values\n        );\n\n        values = DecreasePositionCollateralUtils.swapWithdrawnCollateralToPnlToken(params, values);\n\n        return DecreasePositionResult(\n            values.output.outputToken,\n            values.output.outputAmount,\n            values.output.secondaryOutputToken,\n            values.output.secondaryOutputAmount\n        );\n    }\n}"
    }
  ]
}