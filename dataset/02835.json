{
  "Title": "Missing docstrings",
  "Content": "The [`setMaxWithdrawalSlippage` function](https://github.com/OriginProtocol/origin-dollar/blob/bfe0ac8e5d7c05b9bf1021fafb25e0aed8a6ed45/contracts/contracts/strategies/BaseConvexMetaStrategy.sol#L174) of the `BaseConvexMetaStrategy` contract is missing its `@param` statement. Consider including it.\n\n\n**Update:** *Fixed in [commit `689d527252ec78932d4bf422be3ac6b8245a777d`](https://github.com/OriginProtocol/origin-dollar/commit/ea5154feaa97b64a36bd49d83d38be6b9d526524).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/strategies/BaseConvexMetaStrategy.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title Curve Convex Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IRewardStaking } from \"./IRewardStaking.sol\";\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { ICurveMetaPool } from \"./ICurveMetaPool.sol\";\nimport { IERC20, BaseCurveStrategy } from \"./BaseCurveStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\nabstract contract BaseConvexMetaStrategy is BaseCurveStrategy {\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n    event MaxWithdrawalSlippageUpdated(\n        uint256 _prevMaxSlippagePercentage,\n        uint256 _newMaxSlippagePercentage\n    );\n\n    // used to circumvent the stack too deep issue\n    struct InitState {\n        address platformAddress; //Address of the Curve 3pool\n        address vaultAddress; //Address of the vault\n        address cvxDepositorAddress; //Address of the Convex depositor(AKA booster) for this pool\n        address metapoolAddress; //Address of the Curve MetaPool\n        address metapoolMainToken; //Address of Main metapool token\n        address cvxRewardStakerAddress; //Address of the CVX rewards staker\n        address metapoolLPToken; //Address of metapool LP token\n        uint256 cvxDepositorPTokenId; //Pid of the pool referred to by Depositor and staker\n    }\n\n    address internal cvxDepositorAddress;\n    address internal cvxRewardStakerAddress;\n    uint256 internal cvxDepositorPTokenId;\n    ICurveMetaPool internal metapool;\n    IERC20 internal metapoolMainToken;\n    IERC20 internal metapoolLPToken;\n    // Ordered list of metapool assets\n    address[] internal metapoolAssets;\n    // Max withdrawal slippage denominated in 1e18 (1e18 == 100%)\n    uint256 public maxWithdrawalSlippage = 1e16;\n    uint128 crvCoinIndex;\n    uint128 mainCoinIndex;\n\n    int256[30] private __reserved;\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of CRV & CVX\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                DAI, USDC, USDT\n     * @param _pTokens Platform Token corresponding addresses\n     * @param initState Various addresses and info for initialization state\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // CRV + CVX\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        InitState calldata initState\n    ) external onlyGovernor initializer {\n        require(_assets.length == 3, \"Must have exactly three assets\");\n        // Should be set prior to abstract initialize call otherwise\n        // abstractSetPToken calls will fail\n        cvxDepositorAddress = initState.cvxDepositorAddress;\n        pTokenAddress = _pTokens[0];\n        metapool = ICurveMetaPool(initState.metapoolAddress);\n        metapoolMainToken = IERC20(initState.metapoolMainToken);\n        cvxRewardStakerAddress = initState.cvxRewardStakerAddress;\n        metapoolLPToken = IERC20(initState.metapoolLPToken);\n        cvxDepositorPTokenId = initState.cvxDepositorPTokenId;\n\n        metapoolAssets = [metapool.coins(0), metapool.coins(1)];\n        crvCoinIndex = _getMetapoolCoinIndex(pTokenAddress);\n        mainCoinIndex = _getMetapoolCoinIndex(initState.metapoolMainToken);\n        super._initialize(\n            initState.platformAddress,\n            initState.vaultAddress,\n            _rewardTokenAddresses,\n            _assets,\n            _pTokens\n        );\n        _approveBase();\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        virtual\n        override\n        returns (uint256 balance)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n        balance = 0;\n\n        // LP tokens in this contract. This should generally be nothing as we\n        // should always stake the full balance in the Gauge, but include for\n        // safety\n        uint256 contractPTokens = IERC20(pTokenAddress).balanceOf(\n            address(this)\n        );\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        if (contractPTokens > 0) {\n            uint256 virtual_price = curvePool.get_virtual_price();\n            uint256 value = contractPTokens.mulTruncate(virtual_price);\n            balance += value;\n        }\n\n        uint256 metapoolPTokens = metapoolLPToken.balanceOf(address(this));\n        uint256 metapoolGaugePTokens = IRewardStaking(cvxRewardStakerAddress)\n            .balanceOf(address(this));\n        uint256 metapoolTotalPTokens = metapoolPTokens + metapoolGaugePTokens;\n\n        if (metapoolTotalPTokens > 0) {\n            uint256 metapool_virtual_price = metapool.get_virtual_price();\n            uint256 value = (metapoolTotalPTokens * metapool_virtual_price) /\n                1e18;\n            balance += value;\n        }\n\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        balance = balance.scaleBy(assetDecimals, 18) / 3;\n    }\n\n    function _approveBase() internal override {\n        IERC20 pToken = IERC20(pTokenAddress);\n        // 3Pool for LP token (required for removing liquidity)\n        pToken.safeApprove(platformAddress, 0);\n        pToken.safeApprove(platformAddress, type(uint256).max);\n        // Gauge for LP token\n        metapoolLPToken.safeApprove(cvxDepositorAddress, 0);\n        metapoolLPToken.safeApprove(cvxDepositorAddress, type(uint256).max);\n        // Metapool for LP token\n        pToken.safeApprove(address(metapool), 0);\n        pToken.safeApprove(address(metapool), type(uint256).max);\n        // Metapool for Metapool main token\n        metapoolMainToken.safeApprove(address(metapool), 0);\n        metapoolMainToken.safeApprove(address(metapool), type(uint256).max);\n    }\n\n    /**\n     * @dev Get the index of the coin\n     */\n    function _getMetapoolCoinIndex(address _asset)\n        internal\n        view\n        returns (uint128)\n    {\n        for (uint128 i = 0; i < 2; i++) {\n            if (metapoolAssets[i] == _asset) return i;\n        }\n        revert(\"Invalid Metapool asset\");\n    }\n\n    /**\n     * @dev Sets max withdrawal slippage that is considered when removing\n     * liquidity from Metapools.\n     *\n     * 1e18 == 100%, 1e16 == 1%\n     */\n    function setMaxWithdrawalSlippage(uint256 _maxWithdrawalSlippage)\n        external\n        onlyVaultOrGovernorOrStrategist\n    {\n        require(\n            _maxWithdrawalSlippage >= 1e15 && _maxWithdrawalSlippage <= 1e17,\n            \"Max withdrawal slippage needs to be between 0.1% - 10%\"\n        );\n        emit MaxWithdrawalSlippageUpdated(\n            maxWithdrawalSlippage,\n            _maxWithdrawalSlippage\n        );\n        maxWithdrawalSlippage = _maxWithdrawalSlippage;\n    }\n\n    /**\n     * @dev Collect accumulated CRV and CVX and send to Vault.\n     */\n    function collectRewardTokens()\n        external\n        override\n        onlyHarvester\n        nonReentrant\n    {\n        // Collect CRV and CVX\n        IRewardStaking(cvxRewardStakerAddress).getReward();\n        _collectRewardTokens();\n    }\n\n    /**\n     * @dev If x a negative number return 0 else return x\n     */\n    function toPositive(int256 x) internal pure returns (uint256) {\n        return x >= 0 ? uint256(x) : uint256(0);\n    }\n}"
    }
  ]
}