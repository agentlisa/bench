{
  "Title": "M-2: ERC721Pool taker callback misreports quote funds whenever there was collateral amount rounding",
  "Content": "# Issue M-2: ERC721Pool taker callback misreports quote funds whenever there was collateral amount rounding \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/162 \n\n## Found by \nhyh\n\n## Summary\n\natomicSwapCallback() now reports `tokensTaken` higher than one corresponding to `quoteTokenAmount` whenever the rounding took place as the `excessQuoteToken` is omitted.\n\n## Vulnerability Detail\n\nERC721Pool's take() `atomicSwapCallback` needs to have full quote amount, `(result.quoteTokenAmount + result.excessQuoteToken)`, when there is a quote token part added to have the whole integer amount of the collateral asset.\n\nNow the callback quote value, `quoteTokenAmount`, is inconsistent with the collateral amount `tokensTaken` when there was rounding.\n\n## Impact\n\nThe impact depends on the logic on `callee_` side, but asset amounts are usually used in the downstream asset management logic, so misreporting such amounts can lead to the asset losses on the taker's side.\n\nAs that's the precondition, setting the severity to be medium.\n\n## Code Snippet\n\nERC721Pool's take() reports `result.quoteTokenAmount` and `tokensTaken` as take result to the `callee_`, ignoring collateral rounding part:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L452-L463\n\n```solidity\n        if (data_.length != 0) {\n            IERC721Taker(callee_).atomicSwapCallback(\n                tokensTaken,\n                result.quoteTokenAmount / _getArgUint256(QUOTE_SCALE), \n                data_\n            );\n        }\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n\n        // transfer from taker to pool the amount of quote tokens needed to cover collateral auctioned (including excess for rounded collateral)\n        _transferQuoteTokenFrom(callee_, result.quoteTokenAmount + result.excessQuoteToken);\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding the `excessQuoteToken` to the reported value:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L452-L463\n\n```solidity\n        if (data_.length != 0) {\n            IERC721Taker(callee_).atomicSwapCallback(\n                tokensTaken,\n-               result.quoteTokenAmount / _getArgUint256(QUOTE_SCALE), \n+               (result.quoteTokenAmount + result.excessQuoteToken) / _getArgUint256(QUOTE_SCALE), \n                data_\n            );\n        }\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n\n        // transfer from taker to pool the amount of quote tokens needed to cover collateral auctioned (including excess for rounded collateral)\n        _transferQuoteTokenFrom(callee_, result.quoteTokenAmount + result.excessQuoteToken);\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "contracts/src/ERC721Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport {\n    IERC721Token,\n    IPoolErrors,\n    IPoolLenderActions,\n    IPoolLiquidationActions\n}                           from './interfaces/pool/IPool.sol';\nimport {\n    BucketTakeResult,\n    DrawDebtResult,\n    RepayDebtResult,\n    SettleParams,\n    TakeResult\n}                           from './interfaces/pool/commons/IPoolInternals.sol';\nimport { PoolState }        from './interfaces/pool/commons/IPoolState.sol';\n\nimport {\n    IERC721Pool,\n    IERC721PoolBorrowerActions,\n    IERC721PoolImmutables,\n    IERC721PoolLenderActions\n}                               from './interfaces/pool/erc721/IERC721Pool.sol';\nimport { IERC721Taker }         from './interfaces/pool/erc721/IERC721Taker.sol';\nimport {\n    ICryptoPunks,\n    ICryptoKitties,\n    NFTTypes\n}                               from './interfaces/pool/erc721/IERC721NonStandard.sol';\n\nimport { FlashloanablePool } from './base/FlashloanablePool.sol';\n\nimport { _revertIfAuctionClearable } from './libraries/helpers/RevertsHelper.sol';\n\nimport { Maths }    from './libraries/internal/Maths.sol';\nimport { Deposits } from './libraries/internal/Deposits.sol';\nimport { Loans }    from './libraries/internal/Loans.sol';\n\nimport { Auctions }        from './libraries/external/Auctions.sol';\nimport { LenderActions }   from './libraries/external/LenderActions.sol';\nimport { BorrowerActions } from './libraries/external/BorrowerActions.sol';\n\n/**\n *  @title  ERC721 Pool contract\n *  @notice Entrypoint of ERC721 Pool actions for pool actors:\n *          - Lenders: add, remove and move quote tokens; transfer LPs\n *          - Borrowers: draw and repay debt\n *          - Traders: add, remove and move quote tokens; add and remove collateral\n *          - Kickers: auction undercollateralized loans; settle auctions; claim bond rewards\n *          - Bidders: take auctioned collateral\n *          - Reserve purchasers: start auctions; take reserves\n *          - Flash borrowers: initiate flash loans on ERC20 quote tokens\n *  @dev    Contract is FlashloanablePool with flash loan logic.\n *  @dev    Contract is base Pool with logic to handle ERC721 collateral.\n *  @dev    Calls logic from external PoolCommons, LenderActions, BorrowerActions and Auctions libraries.\n */\ncontract ERC721Pool is FlashloanablePool, IERC721Pool {\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    // immutable args offset\n    uint256 internal constant SUBSET   = 93;\n    uint256 internal constant NFT_TYPE = 125;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    mapping(uint256 => bool)      public tokenIdsAllowed;  // set of tokenIds that can be used for a given NFT Subset type pool\n    mapping(address => uint256[]) public borrowerTokenIds; // borrower address => array of tokenIds pledged by borrower\n    uint256[]                     public bucketTokenIds;   // array of tokenIds added in pool buckets\n\n    /****************************/\n    /*** Initialize Functions ***/\n    /****************************/\n\n    /// @inheritdoc IERC721Pool\n    function initialize(\n        uint256[] memory tokenIds_,\n        uint256 rate_\n    ) external override {\n        if (isPoolInitialized) revert AlreadyInitialized();\n\n        inflatorState.inflator       = uint208(1e18);\n        inflatorState.inflatorUpdate = uint48(block.timestamp);\n\n        interestState.interestRate       = uint208(rate_);\n        interestState.interestRateUpdate = uint48(block.timestamp);\n\n        uint256 noOfTokens = tokenIds_.length;\n\n        if (noOfTokens != 0) {\n            // add subset of tokenIds allowed in the pool\n            for (uint256 id = 0; id < noOfTokens;) {\n                tokenIdsAllowed[tokenIds_[id]] = true;\n\n                unchecked { ++id; }\n            }\n        }\n\n        Loans.init(loans);\n\n        // increment initializations count to ensure these values can't be updated\n        isPoolInitialized = true;\n    }\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IERC721PoolImmutables\n    function isSubset() external pure override returns (bool) {\n        return _getArgUint256(SUBSET) != 0;\n    }\n\n    /***********************************/\n    /*** Borrower External Functions ***/\n    /***********************************/\n\n    /**\n     *  @inheritdoc IERC721PoolBorrowerActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - increment poolBalances.pledgedCollateral accumulator\n     *          - increment poolBalances.t0Debt accumulator\n     *          - update borrowerTokenIds and bucketTokenIds arrays\n     *  @dev emit events:\n     *          - DrawDebtNFT\n     */\n    function drawDebt(\n        address borrowerAddress_,\n        uint256 amountToBorrow_,\n        uint256 limitIndex_,\n        uint256[] calldata tokenIdsToPledge_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        DrawDebtResult memory result = BorrowerActions.drawDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            amountToBorrow_,\n            limitIndex_,\n            Maths.wad(tokenIdsToPledge_.length)\n        );\n\n        emit DrawDebtNFT(borrowerAddress_, amountToBorrow_, tokenIdsToPledge_, result.newLup);\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral = result.poolCollateral;\n        _updateInterestState(poolState, result.newLup);\n\n        if (tokenIdsToPledge_.length != 0) {\n            // update pool balances state\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction -= result.t0DebtInAuctionChange;\n            }\n            poolBalances.pledgedCollateral += Maths.wad(tokenIdsToPledge_.length);\n\n            // move collateral from sender to pool\n            _transferFromSenderToPool(borrowerTokenIds[borrowerAddress_], tokenIdsToPledge_);\n        }\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n\n        // move borrowed amount from pool to sender\n        if (amountToBorrow_ != 0) {\n            // update pool balances state\n            poolBalances.t0Debt += result.t0DebtChange;\n\n            // move borrowed amount from pool to sender\n            _transferQuoteToken(msg.sender, amountToBorrow_);\n        }\n    }\n\n    /**\n     *  @inheritdoc IERC721PoolBorrowerActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     *          - update borrowerTokenIds arrays\n     *  @dev emit events:\n     *          - RepayDebt\n     */\n    function repayDebt(\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 noOfNFTsToPull_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        RepayDebtResult memory result = BorrowerActions.repayDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            maxQuoteTokenAmountToRepay_,\n            Maths.wad(noOfNFTsToPull_)\n        );\n\n        emit RepayDebt(borrowerAddress_, result.quoteTokenToRepay, noOfNFTsToPull_, result.newLup);\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral = result.poolCollateral;\n        _updateInterestState(poolState, result.newLup);\n\n        if (result.quoteTokenToRepay != 0) {\n            // update pool balances state\n            poolBalances.t0Debt -= result.t0RepaidDebt;\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction -= result.t0DebtInAuctionChange;\n            }\n\n            // move amount to repay from sender to pool\n            _transferQuoteTokenFrom(msg.sender, result.quoteTokenToRepay);\n        }\n        if (noOfNFTsToPull_ != 0) {\n            // update pool balances state\n            poolBalances.pledgedCollateral = result.poolCollateral;\n\n            // move collateral from pool to sender\n            _transferFromPoolToAddress(msg.sender, borrowerTokenIds[msg.sender], noOfNFTsToPull_);\n        }\n    }\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IERC721PoolLenderActions\n     *  @dev write state:\n     *          - update borrowerTokenIds arrays\n     *  @dev emit events:\n     *          - AddCollateralNFT\n     */\n    function addCollateral(\n        uint256[] calldata tokenIdsToAdd_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 bucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        bucketLPs_ = LenderActions.addCollateral(\n            buckets,\n            deposits,\n            Maths.wad(tokenIdsToAdd_.length),\n            index_\n        );\n\n        emit AddCollateralNFT(msg.sender, index_, tokenIdsToAdd_, bucketLPs_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        // move required collateral from sender to pool\n        _transferFromSenderToPool(bucketTokenIds, tokenIdsToAdd_);\n    }\n\n    /**\n     *  @inheritdoc IERC721PoolLenderActions\n     *  @dev write state:\n     *          - update bucketTokenIds arrays\n     *  @dev emit events:\n     *          - MergeOrRemoveCollateralNFT\n     */\n    function mergeOrRemoveCollateral(\n        uint256[] calldata removalIndexes_,\n        uint256 noOfNFTsToRemove_,\n        uint256 toIndex_\n    ) external override nonReentrant returns (uint256 collateralMerged_, uint256 bucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n        uint256 collateralAmount = Maths.wad(noOfNFTsToRemove_);\n\n        (\n            collateralMerged_,\n            bucketLPs_\n        ) = LenderActions.mergeOrRemoveCollateral(\n            buckets,\n            deposits,\n            removalIndexes_,\n            collateralAmount,\n            toIndex_\n        );\n\n        emit MergeOrRemoveCollateralNFT(msg.sender, collateralMerged_, bucketLPs_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        if (collateralMerged_ == collateralAmount) {\n            // Total collateral in buckets meets the requested removal amount, noOfNFTsToRemove_\n            _transferFromPoolToAddress(msg.sender, bucketTokenIds, noOfNFTsToRemove_);\n        }\n\n    }\n\n    /**\n     *  @inheritdoc IPoolLenderActions\n     *  @dev write state:\n     *          - update bucketTokenIds arrays\n     *  @dev emit events:\n     *          - RemoveCollateral\n     */\n    function removeCollateral(\n        uint256 noOfNFTsToRemove_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 collateralAmount_, uint256 lpAmount_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        collateralAmount_ = Maths.wad(noOfNFTsToRemove_);\n        lpAmount_ = LenderActions.removeCollateral(\n            buckets,\n            deposits,\n            collateralAmount_,\n            index_\n        );\n\n        emit RemoveCollateral(msg.sender, index_, noOfNFTsToRemove_, lpAmount_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        _transferFromPoolToAddress(msg.sender, bucketTokenIds, noOfNFTsToRemove_);\n    }\n\n    /*******************************/\n    /*** Pool Auctions Functions ***/\n    /*******************************/\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function settle(\n        address borrowerAddress_,\n        uint256 maxDepth_\n    ) external nonReentrant override {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 assets = Maths.wmul(poolBalances.t0Debt, poolState.inflator) + _getPoolQuoteTokenBalance();\n        uint256 liabilities = Deposits.treeSum(deposits) + auctions.totalBondEscrowed + reserveAuction.unclaimed;\n\n        SettleParams memory params = SettleParams(\n            {\n                borrower:    borrowerAddress_,\n                reserves:    (assets > liabilities) ? (assets-liabilities) : 0,\n                inflator:    poolState.inflator,\n                bucketDepth: maxDepth_,\n                poolType:    poolState.poolType\n            }\n        );\n        (\n            uint256 collateralRemaining,\n            uint256 t0DebtRemaining,\n            uint256 collateralSettled,\n            uint256 t0DebtSettled\n        ) = Auctions.settlePoolDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            params\n        );\n\n        // slither-disable-next-line incorrect-equality\n        if (t0DebtRemaining == 0) _rebalanceTokens(params.borrower, collateralRemaining);\n\n        // update pool balances state\n        poolBalances.t0Debt            -= t0DebtSettled;\n        poolBalances.t0DebtInAuction   -= t0DebtSettled;\n        poolBalances.pledgedCollateral -= collateralSettled;\n\n        // update pool interest rate state\n        poolState.debt       -= Maths.wmul(t0DebtSettled, poolState.inflator);\n        poolState.collateral -= collateralSettled;\n        _updateInterestState(poolState, _lup(poolState.debt));\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function take(\n        address        borrowerAddress_,\n        uint256        collateral_,\n        address        callee_,\n        bytes calldata data_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        TakeResult memory result = Auctions.take(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            Maths.wad(collateral_),\n            1\n        );\n\n        // update pool balances state\n        uint256 t0PoolDebt      = poolBalances.t0Debt;\n        uint256 t0DebtInAuction = poolBalances.t0DebtInAuction;\n\n        if (result.t0DebtPenalty != 0) {\n            t0PoolDebt      += result.t0DebtPenalty;\n            t0DebtInAuction += result.t0DebtPenalty;\n        }\n\n        t0PoolDebt      -= result.t0RepayAmount;\n        t0DebtInAuction -= result.t0DebtInAuctionChange;\n\n        poolBalances.t0Debt            =  t0PoolDebt;\n        poolBalances.t0DebtInAuction   =  t0DebtInAuction;\n        poolBalances.pledgedCollateral -= result.collateralAmount;\n\n        // update pool interest rate state\n        poolState.debt       =  result.poolDebt;\n        poolState.collateral -= result.collateralAmount;\n        _updateInterestState(poolState, result.newLup);\n\n        // transfer rounded collateral from pool to taker\n        uint256[] memory tokensTaken = _transferFromPoolToAddress(\n            callee_,\n            borrowerTokenIds[borrowerAddress_],\n            result.collateralAmount / 1e18\n        );\n\n        if (data_.length != 0) {\n            IERC721Taker(callee_).atomicSwapCallback(\n                tokensTaken,\n                result.quoteTokenAmount / _getArgUint256(QUOTE_SCALE), \n                data_\n            );\n        }\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n\n        // transfer from taker to pool the amount of quote tokens needed to cover collateral auctioned (including excess for rounded collateral)\n        _transferQuoteTokenFrom(callee_, result.quoteTokenAmount + result.excessQuoteToken);\n\n        // transfer from pool to borrower the excess of quote tokens after rounding collateral auctioned\n        if (result.excessQuoteToken != 0) _transferQuoteToken(borrowerAddress_, result.excessQuoteToken);\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function bucketTake(\n        address borrowerAddress_,\n        bool    depositTake_,\n        uint256 index_\n    ) external override nonReentrant {\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        BucketTakeResult memory result = Auctions.bucketTake(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            depositTake_,\n            index_,\n            1\n        );\n\n        // update pool balances state\n        uint256 t0PoolDebt      = poolBalances.t0Debt;\n        uint256 t0DebtInAuction = poolBalances.t0DebtInAuction;\n\n        if (result.t0DebtPenalty != 0) {\n            t0PoolDebt      += result.t0DebtPenalty;\n            t0DebtInAuction += result.t0DebtPenalty;\n        }\n\n        t0PoolDebt      -= result.t0RepayAmount;\n        t0DebtInAuction -= result.t0DebtInAuctionChange;\n\n        poolBalances.t0Debt            =  t0PoolDebt;\n        poolBalances.t0DebtInAuction   =  t0DebtInAuction;\n        poolBalances.pledgedCollateral -= result.collateralAmount;\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral -= result.collateralAmount;\n        _updateInterestState(poolState, result.newLup);\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Rebalance NFT token and transfer difference to floor collateral from borrower to pool claimable array\n     *  @dev    write state:\n     *              - update borrowerTokens and bucketTokenIds arrays\n     *  @dev    emit events:\n     *              - RemoveCollateral\n     *  @param  borrowerAddress_    Address of borrower.\n     *  @param  borrowerCollateral_ Current borrower collateral to be rebalanced.\n     */\n    function _rebalanceTokens(\n        address borrowerAddress_,\n        uint256 borrowerCollateral_\n    ) internal {\n        // rebalance borrower's collateral, transfer difference to floor collateral from borrower to pool claimable array\n        uint256[] storage borrowerTokens = borrowerTokenIds[borrowerAddress_];\n\n        uint256 noOfTokensPledged    = borrowerTokens.length;\n        uint256 noOfTokensToTransfer = borrowerCollateral_ != 0 ? noOfTokensPledged - borrowerCollateral_ / 1e18 : noOfTokensPledged;\n\n        for (uint256 i = 0; i < noOfTokensToTransfer;) {\n            uint256 tokenId = borrowerTokens[--noOfTokensPledged]; // start with moving the last token pledged by borrower\n            borrowerTokens.pop();                                  // remove token id from borrower\n            bucketTokenIds.push(tokenId);                          // add token id to pool claimable tokens\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     *  @notice Helper function for transferring multiple NFT tokens from msg.sender to pool.\n     *  @notice Reverts in case token id is not supported by subset pool.\n     *  @param  poolTokens_ Array in pool that tracks NFT ids (could be tracking NFTs pledged by borrower or NFTs added by a lender in a specific bucket).\n     *  @param  tokenIds_   Array of NFT token ids to transfer from msg.sender to pool.\n     */\n    function _transferFromSenderToPool(\n        uint256[] storage poolTokens_,\n        uint256[] calldata tokenIds_\n    ) internal {\n        bool subset   = _getArgUint256(SUBSET) != 0;\n        uint8 nftType = _getArgUint8(NFT_TYPE);\n\n        for (uint256 i = 0; i < tokenIds_.length;) {\n            uint256 tokenId = tokenIds_[i];\n            if (subset && !tokenIdsAllowed[tokenId]) revert OnlySubset();\n            poolTokens_.push(tokenId);\n\n            if (nftType == uint8(NFTTypes.STANDARD_ERC721)){\n                _transferNFT(msg.sender, address(this), tokenId);\n            }\n            else if (nftType == uint8(NFTTypes.CRYPTOKITTIES)) {\n                ICryptoKitties(_getArgAddress(COLLATERAL_ADDRESS)).transferFrom(msg.sender ,address(this), tokenId);\n            }\n            else{\n                ICryptoPunks(_getArgAddress(COLLATERAL_ADDRESS)).buyPunk(tokenId);\n            }\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     *  @notice Helper function for transferring multiple NFT tokens from pool to given address.\n     *  @notice It transfers NFTs from the most recent one added into the pool (pop from array tracking NFTs in pool).\n     *  @param  toAddress_      Address where pool should transfer tokens to.\n     *  @param  poolTokens_     Array in pool that tracks NFT ids (could be tracking NFTs pledged by borrower or NFTs added by a lender in a specific bucket).\n     *  @param  amountToRemove_ Number of NFT tokens to transfer from pool to given address.\n     *  @return Array containing token ids that were transferred from pool to address.\n     */\n    function _transferFromPoolToAddress(\n        address toAddress_,\n        uint256[] storage poolTokens_,\n        uint256 amountToRemove_\n    ) internal returns (uint256[] memory) {\n        uint256[] memory tokensTransferred = new uint256[](amountToRemove_);\n\n        uint256 noOfNFTsInPool = poolTokens_.length;\n\n        uint8 nftType = _getArgUint8(NFT_TYPE);\n\n        for (uint256 i = 0; i < amountToRemove_;) {\n            uint256 tokenId = poolTokens_[--noOfNFTsInPool]; // start with transferring the last token added in bucket\n            poolTokens_.pop();\n\n            if (nftType == uint8(NFTTypes.STANDARD_ERC721)){\n                _transferNFT(address(this), toAddress_, tokenId);\n            }\n            else if (nftType == uint8(NFTTypes.CRYPTOKITTIES)) {\n                ICryptoKitties(_getArgAddress(COLLATERAL_ADDRESS)).transfer(toAddress_, tokenId);\n            }\n            else {\n                ICryptoPunks(_getArgAddress(COLLATERAL_ADDRESS)).transferPunk(toAddress_, tokenId);\n            }\n\n            tokensTransferred[i] = tokenId;\n\n            unchecked { ++i; }\n        }\n\n        return tokensTransferred;\n    }\n\n    /**\n     *  @dev Helper function to transfer an NFT from owner to target address (reused in code to reduce contract deployment bytecode size).\n     *  @param from_    NFT owner address.\n     *  @param to_      New NFT owner address.\n     *  @param tokenId_ NFT token id to be transferred.\n     */\n    function _transferNFT(address from_, address to_, uint256 tokenId_) internal {\n        // slither-disable-next-line calls-loop\n        IERC721Token(_getArgAddress(COLLATERAL_ADDRESS)).safeTransferFrom(from_, to_, tokenId_);\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    /** @notice Implementing this method allows contracts to receive ERC721 tokens\n     *  @dev https://forum.openzeppelin.com/t/erc721holder-ierc721receiver-and-onerc721received/11828\n     */\n    function onERC721Received(address, address, uint256, bytes memory) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n}"
    },
    {
      "filename": "contracts/src/ERC721Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport {\n    IERC721Token,\n    IPoolErrors,\n    IPoolLenderActions,\n    IPoolLiquidationActions\n}                           from './interfaces/pool/IPool.sol';\nimport {\n    BucketTakeResult,\n    DrawDebtResult,\n    RepayDebtResult,\n    SettleParams,\n    TakeResult\n}                           from './interfaces/pool/commons/IPoolInternals.sol';\nimport { PoolState }        from './interfaces/pool/commons/IPoolState.sol';\n\nimport {\n    IERC721Pool,\n    IERC721PoolBorrowerActions,\n    IERC721PoolImmutables,\n    IERC721PoolLenderActions\n}                               from './interfaces/pool/erc721/IERC721Pool.sol';\nimport { IERC721Taker }         from './interfaces/pool/erc721/IERC721Taker.sol';\nimport {\n    ICryptoPunks,\n    ICryptoKitties,\n    NFTTypes\n}                               from './interfaces/pool/erc721/IERC721NonStandard.sol';\n\nimport { FlashloanablePool } from './base/FlashloanablePool.sol';\n\nimport { _revertIfAuctionClearable } from './libraries/helpers/RevertsHelper.sol';\n\nimport { Maths }    from './libraries/internal/Maths.sol';\nimport { Deposits } from './libraries/internal/Deposits.sol';\nimport { Loans }    from './libraries/internal/Loans.sol';\n\nimport { Auctions }        from './libraries/external/Auctions.sol';\nimport { LenderActions }   from './libraries/external/LenderActions.sol';\nimport { BorrowerActions } from './libraries/external/BorrowerActions.sol';\n\n/**\n *  @title  ERC721 Pool contract\n *  @notice Entrypoint of ERC721 Pool actions for pool actors:\n *          - Lenders: add, remove and move quote tokens; transfer LPs\n *          - Borrowers: draw and repay debt\n *          - Traders: add, remove and move quote tokens; add and remove collateral\n *          - Kickers: auction undercollateralized loans; settle auctions; claim bond rewards\n *          - Bidders: take auctioned collateral\n *          - Reserve purchasers: start auctions; take reserves\n *          - Flash borrowers: initiate flash loans on ERC20 quote tokens\n *  @dev    Contract is FlashloanablePool with flash loan logic.\n *  @dev    Contract is base Pool with logic to handle ERC721 collateral.\n *  @dev    Calls logic from external PoolCommons, LenderActions, BorrowerActions and Auctions libraries.\n */\ncontract ERC721Pool is FlashloanablePool, IERC721Pool {\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    // immutable args offset\n    uint256 internal constant SUBSET   = 93;\n    uint256 internal constant NFT_TYPE = 125;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    mapping(uint256 => bool)      public tokenIdsAllowed;  // set of tokenIds that can be used for a given NFT Subset type pool\n    mapping(address => uint256[]) public borrowerTokenIds; // borrower address => array of tokenIds pledged by borrower\n    uint256[]                     public bucketTokenIds;   // array of tokenIds added in pool buckets\n\n    /****************************/\n    /*** Initialize Functions ***/\n    /****************************/\n\n    /// @inheritdoc IERC721Pool\n    function initialize(\n        uint256[] memory tokenIds_,\n        uint256 rate_\n    ) external override {\n        if (isPoolInitialized) revert AlreadyInitialized();\n\n        inflatorState.inflator       = uint208(1e18);\n        inflatorState.inflatorUpdate = uint48(block.timestamp);\n\n        interestState.interestRate       = uint208(rate_);\n        interestState.interestRateUpdate = uint48(block.timestamp);\n\n        uint256 noOfTokens = tokenIds_.length;\n\n        if (noOfTokens != 0) {\n            // add subset of tokenIds allowed in the pool\n            for (uint256 id = 0; id < noOfTokens;) {\n                tokenIdsAllowed[tokenIds_[id]] = true;\n\n                unchecked { ++id; }\n            }\n        }\n\n        Loans.init(loans);\n\n        // increment initializations count to ensure these values can't be updated\n        isPoolInitialized = true;\n    }\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IERC721PoolImmutables\n    function isSubset() external pure override returns (bool) {\n        return _getArgUint256(SUBSET) != 0;\n    }\n\n    /***********************************/\n    /*** Borrower External Functions ***/\n    /***********************************/\n\n    /**\n     *  @inheritdoc IERC721PoolBorrowerActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - increment poolBalances.pledgedCollateral accumulator\n     *          - increment poolBalances.t0Debt accumulator\n     *          - update borrowerTokenIds and bucketTokenIds arrays\n     *  @dev emit events:\n     *          - DrawDebtNFT\n     */\n    function drawDebt(\n        address borrowerAddress_,\n        uint256 amountToBorrow_,\n        uint256 limitIndex_,\n        uint256[] calldata tokenIdsToPledge_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        DrawDebtResult memory result = BorrowerActions.drawDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            amountToBorrow_,\n            limitIndex_,\n            Maths.wad(tokenIdsToPledge_.length)\n        );\n\n        emit DrawDebtNFT(borrowerAddress_, amountToBorrow_, tokenIdsToPledge_, result.newLup);\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral = result.poolCollateral;\n        _updateInterestState(poolState, result.newLup);\n\n        if (tokenIdsToPledge_.length != 0) {\n            // update pool balances state\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction -= result.t0DebtInAuctionChange;\n            }\n            poolBalances.pledgedCollateral += Maths.wad(tokenIdsToPledge_.length);\n\n            // move collateral from sender to pool\n            _transferFromSenderToPool(borrowerTokenIds[borrowerAddress_], tokenIdsToPledge_);\n        }\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n\n        // move borrowed amount from pool to sender\n        if (amountToBorrow_ != 0) {\n            // update pool balances state\n            poolBalances.t0Debt += result.t0DebtChange;\n\n            // move borrowed amount from pool to sender\n            _transferQuoteToken(msg.sender, amountToBorrow_);\n        }\n    }\n\n    /**\n     *  @inheritdoc IERC721PoolBorrowerActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     *          - update borrowerTokenIds arrays\n     *  @dev emit events:\n     *          - RepayDebt\n     */\n    function repayDebt(\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 noOfNFTsToPull_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        RepayDebtResult memory result = BorrowerActions.repayDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            maxQuoteTokenAmountToRepay_,\n            Maths.wad(noOfNFTsToPull_)\n        );\n\n        emit RepayDebt(borrowerAddress_, result.quoteTokenToRepay, noOfNFTsToPull_, result.newLup);\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral = result.poolCollateral;\n        _updateInterestState(poolState, result.newLup);\n\n        if (result.quoteTokenToRepay != 0) {\n            // update pool balances state\n            poolBalances.t0Debt -= result.t0RepaidDebt;\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction -= result.t0DebtInAuctionChange;\n            }\n\n            // move amount to repay from sender to pool\n            _transferQuoteTokenFrom(msg.sender, result.quoteTokenToRepay);\n        }\n        if (noOfNFTsToPull_ != 0) {\n            // update pool balances state\n            poolBalances.pledgedCollateral = result.poolCollateral;\n\n            // move collateral from pool to sender\n            _transferFromPoolToAddress(msg.sender, borrowerTokenIds[msg.sender], noOfNFTsToPull_);\n        }\n    }\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IERC721PoolLenderAct"
    }
  ]
}