{
  "Title": "[02] Unnecessary approval in `MagnetarMintModule`",
  "Content": "\n[`MagnetarMintCommonModule::_participateOnTOLP`](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/modules/MagnetarMintCommonModule.sol#L88-L89):\n\n```solidity\nFile: tapioca-periph/contracts/Magnetar/modules/MagnetarMintCommonModule.sol\n\n88:        IERC721(lockDataTarget).approve(participateData.target, tOLPTokenId);\n89:        uint256 oTAPTokenId = ITapiocaOptionBroker(participateData.target).participate(tOLPTokenId);\n```\n\nThis approval is unnecessary as `TapiocaOptionBroker::participate` uses `Pearlmit` to transfer the token. Hence, the approval is needed against `Pearlmit`, not `TapiocaOptionBroker`.\n\n### Recommendation\n\nConsider approving `Pearlmit` instead of `participateData.target`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/Magnetar/modules/MagnetarMintCommonModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n// Tapioca\nimport {\n    MintFromBBAndLendOnSGLData,\n    CrossChainMintFromBBAndLendOnSGLData,\n    IMintData,\n    IDepositData,\n    IOptionsLockData,\n    IOptionsParticipateData,\n    DepositAndSendForLockingData,\n    LockAndParticipateData,\n    MagnetarWithdrawData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {SafeApprove} from \"tapioca-periph/libraries/SafeApprove.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {MagnetarBaseModule} from \"./MagnetarBaseModule.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title MagnetarMintCommonModule\n * @author TapiocaDAO\n */\nabstract contract MagnetarMintCommonModule is MagnetarBaseModule {\n    using SafeApprove for address;\n    using SafeERC20 for IERC20;\n\n    error Magnetar_ActionParamsMismatch();\n    error Magnetar_tOLPTokenMismatch();\n\n    /// Internal\n    /// =====================\n    function _wrapSglReceipt(IYieldBox yieldBox, address sgl, address user, uint256 fraction, uint256 assetId)\n        internal\n        returns (uint256 toftAmount)\n    {\n        IERC20(sgl).safeTransferFrom(user, address(this), fraction);\n\n        (, address tReceiptAddress,,) = yieldBox.assets(assetId);\n\n        IERC20(sgl).approve(tReceiptAddress, fraction);\n        toftAmount = ITOFT(tReceiptAddress).wrap(address(this), address(this), fraction);\n        IERC20(tReceiptAddress).safeTransfer(user, toftAmount);\n    }\n\n    function _participateOnTOLP(\n        IOptionsParticipateData memory participateData,\n        address user,\n        address lockDataTarget,\n        uint256 tOLPTokenId\n    ) internal {\n        if (!cluster.isWhitelisted(0, participateData.target)) {\n            revert Magnetar_TargetNotWhitelisted(participateData.target);\n        }\n\n        // Check tOLPTokenId\n        if (participateData.tOLPTokenId != 0) {\n            if (participateData.tOLPTokenId != tOLPTokenId && tOLPTokenId != 0) {\n                revert Magnetar_tOLPTokenMismatch();\n            }\n\n            tOLPTokenId = participateData.tOLPTokenId;\n        }\n        if (tOLPTokenId == 0) revert Magnetar_ActionParamsMismatch();\n\n        IERC721(lockDataTarget).approve(participateData.target, tOLPTokenId);\n        uint256 oTAPTokenId = ITapiocaOptionBroker(participateData.target).participate(tOLPTokenId);\n\n        address oTapAddress = ITapiocaOptionBroker(participateData.target).oTAP();\n        IERC721(oTapAddress).safeTransferFrom(address(this), user, oTAPTokenId, \"0x\");\n    }\n\n    function _lockOnTOB(\n        IOptionsLockData memory lockData,\n        IYieldBox yieldBox_,\n        uint256 fraction,\n        bool participate,\n        address user,\n        address singularityAddress\n    ) internal returns (uint256 tOLPTokenId) {\n        tOLPTokenId = 0;\n        if (lockData.lock) {\n            if (!cluster.isWhitelisted(0, lockData.target)) {\n                revert Magnetar_TargetNotWhitelisted(lockData.target);\n            }\n            if (lockData.fraction > 0) fraction = lockData.fraction;\n\n            // retrieve and deposit SGLAssetId registered in tOLP\n            (uint256 tOLPSglAssetId,,) =\n                ITapiocaOptionLiquidityProvision(lockData.target).activeSingularities(singularityAddress);\n            if (fraction == 0) revert Magnetar_ActionParamsMismatch();\n\n            //deposit to YieldBox\n            _extractTokens(user, singularityAddress, fraction);\n            yieldBox_.depositAsset(tOLPSglAssetId, address(this), address(this), fraction, 0);\n\n            _setApprovalForYieldBox(lockData.target, yieldBox_);\n            tOLPTokenId = ITapiocaOptionLiquidityProvision(lockData.target).lock(\n                participate ? address(this) : user, singularityAddress, lockData.lockDuration, lockData.amount\n            );\n            _revertYieldBoxApproval(lockData.target, yieldBox_);\n        }\n    }\n\n    function _depositYBLendSGL(\n        IDepositData memory depositData,\n        address singularityAddress,\n        IYieldBox yieldBox_,\n        address user,\n        uint256 lendAmount\n    ) internal returns (uint256 fraction) {\n        if (singularityAddress != address(0)) {\n            if (!cluster.isWhitelisted(0, singularityAddress)) {\n                revert Magnetar_TargetNotWhitelisted(singularityAddress);\n            }\n            _setApprovalForYieldBox(singularityAddress, yieldBox_);\n\n            IMarket singularity_ = IMarket(singularityAddress);\n\n            // if `depositData.deposit`:\n            //      - deposit SGL asset to YB for `user`\n            uint256 sglAssetId = singularity_.assetId();\n            (, address sglAssetAddress,,) = yieldBox_.assets(sglAssetId);\n            if (depositData.deposit) {\n                depositData.amount = _extractTokens(user, sglAssetAddress, depositData.amount);\n\n                sglAssetAddress.safeApprove(address(yieldBox_), depositData.amount);\n                yieldBox_.depositAsset(sglAssetId, address(this), user, depositData.amount, 0);\n            }\n\n            // if `lendAmount` > 0:\n            //      - add asset to SGL\n            fraction = 0;\n            if (lendAmount == 0 && depositData.deposit) {\n                lendAmount = depositData.amount;\n            }\n            if (lendAmount > 0) {\n                uint256 lendShare = yieldBox_.toShare(sglAssetId, lendAmount, false);\n                fraction = ISingularity(singularityAddress).addAsset(user, user, false, lendShare);\n            }\n\n            _revertYieldBoxApproval(singularityAddress, yieldBox_);\n        }\n    }\n\n    function _depositYBBorrowBB(\n        IMintData memory mintData,\n        address bigBangAddress,\n        IYieldBox yieldBox_,\n        address user,\n        address marketHelper\n    ) internal {\n        if (bigBangAddress != address(0)) {\n            if (!cluster.isWhitelisted(0, bigBangAddress)) {\n                revert Magnetar_TargetNotWhitelisted(bigBangAddress);\n            }\n\n            if (!cluster.isWhitelisted(0, marketHelper)) {\n                revert Magnetar_TargetNotWhitelisted(marketHelper);\n            }\n\n            _setApprovalForYieldBox(bigBangAddress, yieldBox_);\n\n            IMarket bigBang_ = IMarket(bigBangAddress);\n\n            // retrieve collateral id & address\n            uint256 bbCollateralId = bigBang_.collateralId();\n            (, address bbCollateralAddress,,) = yieldBox_.assets(bbCollateralId);\n\n            // compute collateral share\n            uint256 bbCollateralShare = yieldBox_.toShare(bbCollateralId, mintData.collateralDepositData.amount, false);\n\n            // deposit collateral to YB\n            if (mintData.collateralDepositData.deposit) {\n                mintData.collateralDepositData.amount =\n                    _extractTokens(user, bbCollateralAddress, mintData.collateralDepositData.amount);\n                bbCollateralShare = yieldBox_.toShare(bbCollateralId, mintData.collateralDepositData.amount, false);\n\n                bbCollateralAddress.safeApprove(address(yieldBox_), mintData.collateralDepositData.amount);\n                yieldBox_.depositAsset(\n                    bbCollateralId, address(this), address(this), mintData.collateralDepositData.amount, 0\n                );\n            }\n\n            // add collateral to BB\n            if (mintData.collateralDepositData.amount > 0) {\n                _setApprovalForYieldBox(address(bigBang_), yieldBox_);\n\n                (Module[] memory modules, bytes[] memory calls) = IMarketHelper(marketHelper).addCollateral(\n                    mintData.collateralDepositData.deposit ? address(this) : user,\n                    user,\n                    false,\n                    mintData.collateralDepositData.amount,\n                    bbCollateralShare\n                );\n                bigBang_.execute(modules, calls, true);\n            }\n\n            // mints from BB\n            {\n                (Module[] memory modules, bytes[] memory calls) =\n                    IMarketHelper(marketHelper).borrow(user, user, mintData.mintAmount);\n                bigBang_.execute(modules, calls, true);\n            }\n\n            _revertYieldBoxApproval(bigBangAddress, yieldBox_);\n        }\n    }\n}"
    }
  ]
}