{
  "Title": "Restricting Solidity Version",
  "Content": "In [`renderedSolidityHeader`](https://github.com/latticexyz/mud/blob/f6133591a86eb169a7b1b2b8d342733a887af610/packages/common/src/codegen/render-solidity/common.ts#L13), the Solidity version has been hardcoded to `>= 0.8.21`. This was chosen to match the manually created part of the codebase. However, this can cause restrictions when developing contracts on other EVM-compatible chains that often do not support certain opcodes (e.g., the [`PUSH0` opcode](https://eips.ethereum.org/EIPS/eip-3855) that was introduced in Solidity version [`0.8.20`](https://github.com/ethereum/solidity/releases/tag/v0.8.20)).\n\n\nConsider making the Solidity version a configurable parameter to increase the possible applicability of the codebase.\n\n\n***Update:** Acknowledged, not resolved. The Lattice Labs team stated:*\n\n\n\n> *We are going to punt on this because we want to make use of some recent Solidity features and many of our contracts, libraries, etc. are meant to be used together as a whole (i.e., a framework) rather than in isolation.*\n> \n> \n> *While it might be better to set each Solidity file to its minimum viable Solidity version, this is not something we have seen users ask for and probably does not make sense for us to maintain.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/common/src/codegen/render-solidity/common.ts",
      "content": "import path from \"path\";\nimport {\n  AbsoluteImportDatum,\n  RelativeImportDatum,\n  ImportDatum,\n  StaticResourceData,\n  RenderKeyTuple,\n  RenderType,\n} from \"./types\";\nimport { posixPath } from \"../utils\";\n\nexport const renderedSolidityHeader = `// SPDX-License-Identifier: MIT\npragma solidity >=0.8.21;\n\n/* Autogenerated file. Do not edit manually. */`;\n\n/**\n * Renders a list of lines\n */\nexport function renderList<T>(list: T[], renderItem: (item: T, index: number) => string): string {\n  return internalRenderList(\"\", list, renderItem);\n}\n\n/**\n * Renders a comma-separated list of arguments for solidity functions, ignoring empty and undefined ones\n */\nexport function renderArguments(args: (string | undefined)[]): string {\n  const filteredArgs = args.filter((arg) => arg !== undefined && arg !== \"\") as string[];\n  return internalRenderList(\",\", filteredArgs, (arg) => arg);\n}\n\nexport function renderCommonData({\n  staticResourceData,\n  keyTuple,\n}: {\n  staticResourceData?: StaticResourceData;\n  keyTuple: RenderKeyTuple[];\n}): {\n  _tableId: string;\n  _typedTableId: string;\n  _keyArgs: string;\n  _typedKeyArgs: string;\n  _keyTupleDefinition: string;\n} {\n  // static resource means static tableId as well, and no tableId arguments\n  const _tableId = staticResourceData ? \"\" : \"_tableId\";\n  const _typedTableId = staticResourceData ? \"\" : \"ResourceId _tableId\";\n\n  const _keyArgs = renderArguments(keyTuple.map(({ name }) => name));\n  const _typedKeyArgs = renderArguments(keyTuple.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`));\n\n  const _keyTupleDefinition = `\n    bytes32[] memory _keyTuple = new bytes32[](${keyTuple.length});\n    ${renderList(keyTuple, (key, index) => `_keyTuple[${index}] = ${renderValueTypeToBytes32(key.name, key)};`)}\n  `;\n\n  return {\n    _tableId,\n    _typedTableId,\n    _keyArgs,\n    _typedKeyArgs,\n    _keyTupleDefinition,\n  };\n}\n\n/** For 2 paths which are relative to a common root, create a relative import path from one to another */\nexport function solidityRelativeImportPath(fromPath: string, usedInPath: string): string {\n  // 1st \"./\" must be added because path strips it,\n  // but solidity expects it unless there's \"../\" (\"./../\" is fine).\n  // 2nd and 3rd \"./\" forcefully avoid absolute paths (everything is relative to `src`).\n  return posixPath(\"./\" + path.relative(\"./\" + usedInPath, \"./\" + fromPath));\n}\n\n/**\n * Aggregates, deduplicates and renders imports for symbols per path.\n * Identical symbols from different paths are NOT handled, they should be checked before rendering.\n */\nexport function renderImports(imports: ImportDatum[]): string {\n  return renderAbsoluteImports(\n    imports.map((importDatum) => {\n      if (\"path\" in importDatum) {\n        return importDatum;\n      } else {\n        return {\n          symbol: importDatum.symbol,\n          path: solidityRelativeImportPath(importDatum.fromPath, importDatum.usedInPath),\n        };\n      }\n    })\n  );\n}\n\n/**\n * Aggregates, deduplicates and renders imports for symbols per path.\n * Identical symbols from different paths are NOT handled, they should be checked before rendering.\n */\nexport function renderRelativeImports(imports: RelativeImportDatum[]): string {\n  return renderAbsoluteImports(\n    imports.map(({ symbol, fromPath, usedInPath }) => ({\n      symbol,\n      path: solidityRelativeImportPath(fromPath, usedInPath),\n    }))\n  );\n}\n\n/**\n * Aggregates, deduplicates and renders imports for symbols per path.\n * Identical symbols from different paths are NOT handled, they should be checked before rendering.\n */\nexport function renderAbsoluteImports(imports: AbsoluteImportDatum[]): string {\n  // Aggregate symbols by import path, also deduplicating them\n  const aggregatedImports = new Map<string, Set<string>>();\n  for (const { symbol, path } of imports) {\n    if (!aggregatedImports.has(path)) {\n      aggregatedImports.set(path, new Set());\n    }\n    aggregatedImports.get(path)?.add(symbol);\n  }\n  // Render imports\n  const renderedImports = [];\n  for (const [path, symbols] of aggregatedImports) {\n    const renderedSymbols = [...symbols].join(\", \");\n    renderedImports.push(`import { ${renderedSymbols} } from \"${posixPath(path)}\";`);\n  }\n  return renderedImports.join(\"\\n\");\n}\n\nexport function renderWithStore(\n  storeArgument: boolean,\n  callback: (\n    _typedStore: string | undefined,\n    _store: string,\n    _commentSuffix: string,\n    _untypedStore: string | undefined,\n    _methodPrefix: string,\n    _internal?: boolean\n  ) => string\n): string {\n  let result = \"\";\n  result += callback(undefined, \"StoreSwitch\", \"\", undefined, \"\");\n  result += callback(undefined, \"StoreCore\", \"\", undefined, \"_\", true);\n\n  if (storeArgument) {\n    result += \"\\n\" + callback(\"IStore _store\", \"_store\", \" (using the specified store)\", \"_store\", \"\");\n  }\n\n  return result;\n}\n\nexport function renderWithFieldSuffix(\n  withSuffixlessFieldMethods: boolean,\n  fieldName: string,\n  callback: (_methodNameSuffix: string) => string\n): string {\n  const methodNameSuffix = `${fieldName[0].toUpperCase()}${fieldName.slice(1)}`;\n  let result = \"\";\n  result += callback(methodNameSuffix);\n\n  if (withSuffixlessFieldMethods) {\n    result += \"\\n\" + callback(\"\");\n  }\n\n  return result;\n}\n\nexport function renderTableId({ namespace, name, offchainOnly, tableIdName }: StaticResourceData): {\n  hardcodedTableId: string;\n  tableIdDefinition: string;\n} {\n  const hardcodedTableId = `\n    ResourceId.wrap(\n      bytes32(\n        abi.encodePacked(\n          ${offchainOnly ? \"RESOURCE_OFFCHAIN_TABLE\" : \"RESOURCE_TABLE\"},\n          bytes14(\"${namespace}\"),\n          bytes16(\"${name}\")\n        )\n      )\n    )\n  `;\n\n  const tableIdDefinition = `\n    ResourceId constant _tableId = ${hardcodedTableId};\n    ResourceId constant ${tableIdName} = _tableId;\n  `;\n  return {\n    hardcodedTableId,\n    tableIdDefinition,\n  };\n}\n\nexport function renderValueTypeToBytes32(name: string, { typeUnwrap, internalTypeId }: RenderType): string {\n  const innerText = typeUnwrap.length ? `${typeUnwrap}(${name})` : name;\n\n  if (internalTypeId === \"bytes32\") {\n    return innerText;\n  } else if (internalTypeId.match(/^bytes\\d{1,2}$/)) {\n    return `bytes32(${innerText})`;\n  } else if (internalTypeId.match(/^uint\\d{1,3}$/)) {\n    return `bytes32(uint256(${innerText}))`;\n  } else if (internalTypeId.match(/^int\\d{1,3}$/)) {\n    return `bytes32(uint256(int256(${innerText})))`;\n  } else if (internalTypeId === \"address\") {\n    return `bytes32(uint256(uint160(${innerText})))`;\n  } else if (internalTypeId === \"bool\") {\n    return `_boolToBytes32(${innerText})`;\n  } else {\n    throw new Error(`Unknown value type id ${internalTypeId}`);\n  }\n}\n\nexport function isLeftAligned(field: Pick<RenderType, \"internalTypeId\">): boolean {\n  return field.internalTypeId.match(/^bytes\\d{1,2}$/) !== null;\n}\n\nexport function getLeftPaddingBits(field: Pick<RenderType, \"internalTypeId\" | \"staticByteLength\">): number {\n  if (isLeftAligned(field)) {\n    return 0;\n  } else {\n    return 256 - field.staticByteLength * 8;\n  }\n}\n\nfunction internalRenderList<T>(\n  lineTerminator: string,\n  list: T[],\n  renderItem: (item: T, index: number) => string\n): string {\n  return list\n    .map((item, index) => renderItem(item, index) + (index === list.length - 1 ? \"\" : lineTerminator))\n    .join(\"\\n\");\n}"
    }
  ]
}