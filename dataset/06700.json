{
  "Title": "[N-15] Don't use named return variables, it's confusing",
  "Content": "\n```solidity\nFILE: 2023-04-ens/contracts/dnsregistrar/DNSRegistrar.sol\n\n113: function _claim(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input\n    ) internal returns (bytes32 parentNode, bytes32 labelHash, address addr) {\n\n166: function enableNode(bytes memory domain) public returns (bytes32 node) {\n\n174: function _enableNode(\n        bytes memory domain,\n        uint256 offset\n    ) internal returns (bytes32 node) {\n\n```\n[DNSRegistrar.sol#L133-L136](https://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/DNSRegistrar.sol#L133-L136)\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnsregistrar/RecordParser.sol#L14-L21\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/dnssec-oracle/algorithms/ModexpPrecompile.sol#L7-L11\n\nhttps://github.com/code-423n4/2023-04-ens/blob/45ea10bacb2a398e14d711fe28d1738271cd7640/contracts/utils/HexUtils.sol#L11-L15\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-04-ens",
  "Code": [
    {
      "filename": "contracts/dnsregistrar/DNSRegistrar.sol",
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\nimport \"../dnssec-oracle/BytesUtils.sol\";\nimport \"../dnssec-oracle/DNSSEC.sol\";\nimport \"../dnssec-oracle/RRUtils.sol\";\nimport \"../registry/ENSRegistry.sol\";\nimport \"../root/Root.sol\";\nimport \"../resolvers/profiles/AddrResolver.sol\";\nimport \"./DNSClaimChecker.sol\";\nimport \"./PublicSuffixList.sol\";\nimport \"./IDNSRegistrar.sol\";\n\n/**\n * @dev An ENS registrar that allows the owner of a DNS name to claim the\n *      corresponding name in ENS.\n */\ncontract DNSRegistrar is IDNSRegistrar, IERC165 {\n    using BytesUtils for bytes;\n    using Buffer for Buffer.buffer;\n    using RRUtils for *;\n\n    ENS public immutable ens;\n    DNSSEC public immutable oracle;\n    PublicSuffixList public suffixes;\n    address public immutable previousRegistrar;\n    address public immutable resolver;\n    // A mapping of the most recent signatures seen for each claimed domain.\n    mapping(bytes32 => uint32) public inceptions;\n\n    error NoOwnerRecordFound();\n    error PermissionDenied(address caller, address owner);\n    error PreconditionNotMet();\n    error StaleProof();\n    error InvalidPublicSuffix(bytes name);\n\n    struct OwnerRecord {\n        bytes name;\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    event Claim(\n        bytes32 indexed node,\n        address indexed owner,\n        bytes dnsname,\n        uint32 inception\n    );\n    event NewPublicSuffixList(address suffixes);\n\n    constructor(\n        address _previousRegistrar,\n        address _resolver,\n        DNSSEC _dnssec,\n        PublicSuffixList _suffixes,\n        ENS _ens\n    ) {\n        previousRegistrar = _previousRegistrar;\n        resolver = _resolver;\n        oracle = _dnssec;\n        suffixes = _suffixes;\n        emit NewPublicSuffixList(address(suffixes));\n        ens = _ens;\n    }\n\n    /**\n     * @dev This contract's owner-only functions can be invoked by the owner of the ENS root.\n     */\n    modifier onlyOwner() {\n        Root root = Root(ens.owner(bytes32(0)));\n        address owner = root.owner();\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setPublicSuffixList(PublicSuffixList _suffixes) public onlyOwner {\n        suffixes = _suffixes;\n        emit NewPublicSuffixList(address(suffixes));\n    }\n\n    /**\n     * @dev Submits proofs to the DNSSEC oracle, then claims a name using those proofs.\n     * @param name The name to claim, in DNS wire format.\n     * @param input A chain of signed DNS RRSETs ending with a text record.\n     */\n    function proveAndClaim(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input\n    ) public override {\n        (bytes32 rootNode, bytes32 labelHash, address addr) = _claim(\n            name,\n            input\n        );\n        ens.setSubnodeOwner(rootNode, labelHash, addr);\n    }\n\n    function proveAndClaimWithResolver(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input,\n        address resolver,\n        address addr\n    ) public override {\n        (bytes32 rootNode, bytes32 labelHash, address owner) = _claim(\n            name,\n            input\n        );\n        if (msg.sender != owner) {\n            revert PermissionDenied(msg.sender, owner);\n        }\n        ens.setSubnodeRecord(rootNode, labelHash, owner, resolver, 0);\n        if (addr != address(0)) {\n            if (resolver == address(0)) {\n                revert PreconditionNotMet();\n            }\n            bytes32 node = keccak256(abi.encodePacked(rootNode, labelHash));\n            // Set the resolver record\n            AddrResolver(resolver).setAddr(node, addr);\n        }\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure override returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IDNSRegistrar).interfaceId;\n    }\n\n    function _claim(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input\n    ) internal returns (bytes32 parentNode, bytes32 labelHash, address addr) {\n        (bytes memory data, uint32 inception) = oracle.verifyRRSet(input);\n\n        // Get the first label\n        uint256 labelLen = name.readUint8(0);\n        labelHash = name.keccak(1, labelLen);\n\n        bytes memory parentName = name.substring(\n            labelLen + 1,\n            name.length - labelLen - 1\n        );\n\n        // Make sure the parent name is enabled\n        parentNode = enableNode(parentName);\n\n        bytes32 node = keccak256(abi.encodePacked(parentNode, labelHash));\n        if (!RRUtils.serialNumberGte(inception, inceptions[node])) {\n            revert StaleProof();\n        }\n        inceptions[node] = inception;\n\n        bool found;\n        (addr, found) = DNSClaimChecker.getOwnerAddress(name, data);\n        if (!found) {\n            revert NoOwnerRecordFound();\n        }\n\n        emit Claim(node, addr, name, inception);\n    }\n\n    function enableNode(bytes memory domain) public returns (bytes32 node) {\n        // Name must be in the public suffix list.\n        if (!suffixes.isPublicSuffix(domain)) {\n            revert InvalidPublicSuffix(domain);\n        }\n        return _enableNode(domain, 0);\n    }\n\n    function _enableNode(\n        bytes memory domain,\n        uint256 offset\n    ) internal returns (bytes32 node) {\n        uint256 len = domain.readUint8(offset);\n        if (len == 0) {\n            return bytes32(0);\n        }\n\n        bytes32 parentNode = _enableNode(domain, offset + len + 1);\n        bytes32 label = domain.keccak(offset + 1, len);\n        node = keccak256(abi.encodePacked(parentNode, label));\n        address owner = ens.owner(node);\n        if (owner == address(0) || owner == previousRegistrar) {\n            if (parentNode == bytes32(0)) {\n                Root root = Root(ens.owner(bytes32(0)));\n                root.setSubnodeOwner(label, address(this));\n                ens.setResolver(node, resolver);\n            } else {\n                ens.setSubnodeRecord(\n                    parentNode,\n                    label,\n                    address(this),\n                    resolver,\n                    0\n                );\n            }\n        } else if (owner != address(this)) {\n            revert PreconditionNotMet();\n        }\n        return node;\n    }\n}"
    },
    {
      "filename": "contracts/dnsregistrar/RecordParser.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"../dnssec-oracle/BytesUtils.sol\";\n\nlibrary RecordParser {\n    using BytesUtils for bytes;\n\n    /**\n     * @dev Parses a key-value record into a key and value.\n     * @param input The input string\n     * @param offset The offset to start reading at\n     */\n    function readKeyValue(\n        bytes memory input,\n        uint256 offset,\n        uint256 len\n    )\n        internal\n        pure\n        returns (bytes memory key, bytes memory value, uint256 nextOffset)\n    {\n        uint256 separator = input.find(offset, len, \"=\");\n        if (separator == type(uint256).max) {\n            return (\"\", \"\", type(uint256).max);\n        }\n\n        uint256 terminator = input.find(\n            separator,\n            len + offset - separator,\n            \" \"\n        );\n        if (terminator == type(uint256).max) {\n            terminator = input.length;\n        }\n\n        key = input.substring(offset, separator - offset);\n        value = input.substring(separator + 1, terminator - separator - 1);\n        nextOffset = terminator + 1;\n    }\n}"
    },
    {
      "filename": "contracts/dnssec-oracle/algorithms/ModexpPrecompile.sol",
      "content": "pragma solidity ^0.8.4;\n\nlibrary ModexpPrecompile {\n    /**\n     * @dev Computes (base ^ exponent) % modulus over big numbers.\n     */\n    function modexp(\n        bytes memory base,\n        bytes memory exponent,\n        bytes memory modulus\n    ) internal view returns (bool success, bytes memory output) {\n        bytes memory input = abi.encodePacked(\n            uint256(base.length),\n            uint256(exponent.length),\n            uint256(modulus.length),\n            base,\n            exponent,\n            modulus\n        );\n\n        output = new bytes(modulus.length);\n\n        assembly {\n            success := staticcall(\n                gas(),\n                5,\n                add(input, 32),\n                mload(input),\n                add(output, 32),\n                mload(modulus)\n            )\n        }\n    }\n}"
    },
    {
      "filename": "contracts/utils/HexUtils.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary HexUtils {\n    /**\n     * @dev Attempts to parse bytes32 from a hex string\n     * @param str The string to parse\n     * @param idx The offset to start parsing at\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n     */\n    function hexStringToBytes32(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (bytes32 r, bool valid) {\n        valid = true;\n        assembly {\n            // check that the index to read to is not past the end of the string\n            if gt(lastIdx, mload(str)) {\n                revert(0, 0)\n            }\n\n            function getHex(c) -> ascii {\n                // chars 48-57: 0-9\n                if and(gt(c, 47), lt(c, 58)) {\n                    ascii := sub(c, 48)\n                    leave\n                }\n                // chars 65-70: A-F\n                if and(gt(c, 64), lt(c, 71)) {\n                    ascii := add(sub(c, 65), 10)\n                    leave\n                }\n                // chars 97-102: a-f\n                if and(gt(c, 96), lt(c, 103)) {\n                    ascii := add(sub(c, 97), 10)\n                    leave\n                }\n                // invalid char\n                ascii := 0xff\n            }\n\n            let ptr := add(str, 32)\n            for {\n                let i := idx\n            } lt(i, lastIdx) {\n                i := add(i, 2)\n            } {\n                let byte1 := getHex(byte(0, mload(add(ptr, i))))\n                let byte2 := getHex(byte(0, mload(add(ptr, add(i, 1)))))\n                // if either byte is invalid, set invalid and break loop\n                if or(eq(byte1, 0xff), eq(byte2, 0xff)) {\n                    valid := false\n                    break\n                }\n                let combined := or(shl(4, byte1), byte2)\n                r := or(shl(8, r), combined)\n            }\n        }\n    }\n\n    /**\n     * @dev Attempts to parse an address from a hex string\n     * @param str The string to parse\n     * @param idx The offset to start parsing at\n     * @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n     */\n    function hexToAddress(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (address, bool) {\n        if (lastIdx - idx < 40) return (address(0x0), false);\n        (bytes32 r, bool valid) = hexStringToBytes32(str, idx, lastIdx);\n        return (address(uint160(uint256(r))), valid);\n    }\n}"
    }
  ]
}