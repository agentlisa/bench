{
  "Title": "[G-01] Unused variables can be omitted",
  "Content": "\nIn the `LibOracle.getBurnOracle()` function, declares the `uint256 oracleValueTmp` memory variable and later initializes it as follows by calling the `readBurn` function:\n\n        (oracleValueTmp, ratioObserved) = readBurn(ts.collaterals[collateralList[i]].oracleConfig);\n\nBut the `oracleValueTmp` variable is never used within the scope of the function and is used only as a place holder. Hene we can omit this variable and save extra `MSTORE` for each iteration of the `for` loop. Hence the gas saved will be equal to `3 * collateralList.length`; As a result if the list of collateral assets supported by this system is higher this will save considerable amount of gas.\n\nThe line of code can be edited as follows:\n\n        ( , ratioObserved) = readBurn(ts.collaterals[collateralList[i]].oracleConfig);\n\nhttps://github.com/AngleProtocol/angle-transmuter/blob/9707ee4ed3d221e02dcfcd2ebaa4b4d38d280936/contracts/transmuter/libraries/LibOracle.sol#L79-L84\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-01-dev-test-repo",
  "Code": [
    {
      "filename": "contracts/transmuter/libraries/LibOracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { ITransmuterOracle } from \"interfaces/ITransmuterOracle.sol\";\nimport { AggregatorV3Interface } from \"interfaces/external/chainlink/AggregatorV3Interface.sol\";\n\nimport { LibStorage as s } from \"./LibStorage.sol\";\n\nimport \"../../utils/Constants.sol\";\nimport \"../../utils/Errors.sol\";\nimport \"../Storage.sol\";\n\n/// @title LibOracle\n/// @author Angle Labs, Inc.\nlibrary LibOracle {\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                               ACTIONS SPECIFIC ORACLES                                             \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Reads the oracle value used during a redemption to compute collateral ratio for `oracleConfig`\n    /// @dev This value is only sensitive to compute the collateral ratio and deduce a penalty factor\n    function readRedemption(bytes memory oracleConfig) internal view returns (uint256) {\n        (OracleReadType readType, OracleTargetType targetType, bytes memory data) = _parseOracle(oracleConfig);\n        if (readType == OracleReadType.EXTERNAL) {\n            ITransmuterOracle externalOracle = abi.decode(data, (ITransmuterOracle));\n            return externalOracle.readRedemption();\n        } else return read(readType, targetPrice(targetType), data);\n    }\n\n    /// @notice Reads the oracle value used during mint operations for an asset with `oracleConfig`\n    /// @dev For assets which do not rely on external oracles, this value is the minimum between the oracle\n    /// value through the `read` function and the target price.\n    function readMint(bytes memory oracleConfig) internal view returns (uint256 oracleValue) {\n        (OracleReadType readType, OracleTargetType targetType, bytes memory data) = _parseOracle(oracleConfig);\n        if (readType == OracleReadType.EXTERNAL) {\n            ITransmuterOracle externalOracle = abi.decode(data, (ITransmuterOracle));\n            return externalOracle.readMint();\n        }\n        uint256 _targetPrice = targetPrice(targetType);\n        oracleValue = read(readType, _targetPrice, data);\n        if (_targetPrice < oracleValue) oracleValue = _targetPrice;\n    }\n\n    /// @notice Reads the oracle value that will be used for a burn operation for an asset with `oracleConfig`\n    /// @return oracleValue The actual oracle value obtained\n    /// @return ratio If `oracle value < target price`, the ratio between the oracle value and the target\n    /// price, otherwise `BASE_18`\n    function readBurn(bytes memory oracleConfig) internal view returns (uint256 oracleValue, uint256 ratio) {\n        (OracleReadType readType, OracleTargetType targetType, bytes memory data) = _parseOracle(oracleConfig);\n        if (readType == OracleReadType.EXTERNAL) {\n            ITransmuterOracle externalOracle = abi.decode(data, (ITransmuterOracle));\n            return externalOracle.readBurn();\n        }\n        uint256 _targetPrice = targetPrice(targetType);\n        oracleValue = read(readType, _targetPrice, data);\n        ratio = BASE_18;\n        if (oracleValue < _targetPrice) ratio = (oracleValue * BASE_18) / _targetPrice;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                    VIEW FUNCTIONS                                                  \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal version of the `getOracle` function\n    function getOracle(address collateral) internal view returns (OracleReadType, OracleTargetType, bytes memory) {\n        return _parseOracle(s.transmuterStorage().collaterals[collateral].oracleConfig);\n    }\n\n    /// @notice Gets the oracle value and the ratio with respect to the target price when it comes to\n    /// burning for `collateral`\n    function getBurnOracle(\n        address collateral,\n        bytes memory oracleConfig\n    ) internal view returns (uint256 minRatio, uint256 oracleValue) {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        minRatio = BASE_18;\n        address[] memory collateralList = ts.collateralList;\n        uint256 length = collateralList.length;\n        for (uint256 i; i < length; ++i) {\n            uint256 ratioObserved = BASE_18;\n            if (collateralList[i] != collateral) {\n                uint256 oracleValueTmp;\n                (oracleValueTmp, ratioObserved) = readBurn(ts.collaterals[collateralList[i]].oracleConfig);\n            } else (oracleValue, ratioObserved) = readBurn(oracleConfig);\n            if (ratioObserved < minRatio) minRatio = ratioObserved;\n        }\n    }\n\n    /// @notice Gets a targetPrice depending on a `targetType`\n    function targetPrice(OracleTargetType targetType) internal view returns (uint256) {\n        if (targetType == OracleTargetType.STABLE) return BASE_18;\n        else if (targetType == OracleTargetType.WSTETH) return STETH.getPooledEthByShares(1 ether);\n        else if (targetType == OracleTargetType.CBETH) return CBETH.exchangeRate();\n        else if (targetType == OracleTargetType.RETH) return RETH.getExchangeRate();\n        else return SFRXETH.pricePerShare();\n    }\n\n    /// @notice Computes the `quoteAmount` (for Chainlink oracles) depending on a `quoteType` encoded in the\n    /// `oracleConfig` and the target price of the asset\n    /// @dev For cases where the Chainlink feed directly looks into the value of the asset, `quoteAmount` is `BASE_18`.\n    /// For others, like wstETH for which Chainlink only has an oracle for stETH, `quoteAmount` is the target price\n    function quoteAmount(OracleQuoteType quoteType, uint256 _targetPrice) internal pure returns (uint256) {\n        if (quoteType == OracleQuoteType.UNIT) return BASE_18;\n        else return _targetPrice;\n    }\n\n    /// @notice Reads an oracle value for an asset based on its parsed `oracleConfig`\n    function read(OracleReadType readType, uint256 _targetPrice, bytes memory data) internal view returns (uint256) {\n        if (readType == OracleReadType.CHAINLINK_FEEDS) {\n            (\n                AggregatorV3Interface[] memory circuitChainlink,\n                uint32[] memory stalePeriods,\n                uint8[] memory circuitChainIsMultiplied,\n                uint8[] memory chainlinkDecimals,\n                OracleQuoteType quoteType\n            ) = abi.decode(data, (AggregatorV3Interface[], uint32[], uint8[], uint8[], OracleQuoteType));\n            uint256 quotePrice = quoteAmount(quoteType, _targetPrice);\n            uint256 listLength = circuitChainlink.length;\n            for (uint256 i; i < listLength; ++i) {\n                quotePrice = readChainlinkFeed(\n                    quotePrice,\n                    circuitChainlink[i],\n                    circuitChainIsMultiplied[i],\n                    chainlinkDecimals[i],\n                    stalePeriods[i]\n                );\n            }\n            return quotePrice;\n        } else return _targetPrice;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                   SPECIFIC HELPERS                                                 \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Reads a Chainlink feed using a quote amount and converts the quote amount to\n    /// the out-currency\n    /// @param _quoteAmount The amount for which to compute the price expressed in `BASE_18`\n    /// @param feed Chainlink feed to query\n    /// @param multiplied Whether the ratio outputted by Chainlink should be multiplied or divided\n    /// to the `quoteAmount`\n    /// @param decimals Number of decimals of the corresponding Chainlink pair\n    /// @return The `quoteAmount` converted in out-currency\n    function readChainlinkFeed(\n        uint256 _quoteAmount,\n        AggregatorV3Interface feed,\n        uint8 multiplied,\n        uint256 decimals,\n        uint32 stalePeriod\n    ) internal view returns (uint256) {\n        (uint80 roundId, int256 ratio, , uint256 updatedAt, uint80 answeredInRound) = feed.latestRoundData();\n        if (ratio <= 0 || roundId > answeredInRound || block.timestamp - updatedAt > stalePeriod)\n            revert InvalidChainlinkRate();\n        // Checking whether we should multiply or divide by the ratio computed\n        if (multiplied == 1) return (_quoteAmount * uint256(ratio)) / (10 ** decimals);\n        else return (_quoteAmount * (10 ** decimals)) / uint256(ratio);\n    }\n\n    /// @notice Parses an `oracleConfig` into several sub fields\n    function _parseOracle(\n        bytes memory oracleConfig\n    ) private pure returns (OracleReadType, OracleTargetType, bytes memory) {\n        return abi.decode(oracleConfig, (OracleReadType, OracleTargetType, bytes));\n    }\n}"
    }
  ]
}