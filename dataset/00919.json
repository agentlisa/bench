{
  "Title": "PSP22 Is Vulnerable to Double-Spending",
  "Content": "The PSP22 contract defines the [`approve` function](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/contracts/src/token/psp22/psp22.rs#L97), which permits a user to specify the number of tokens that another user can expend on their behalf.\n\n\nHowever, this function is susceptible to the well-known double-spending attack, functioning as follows:\n\n\n* Alice grants Bob the authority to expend 1000 tokens on her behalf.\n* After some time, Alice decides to decrease the allowance from 1000 tokens to 500 tokens through the `approve` function, using Bob's `AccountId` and the new allowance as parameters.\n* Bob anticipates this action and spends 1000 tokens on Alice's behalf, diminishing the allowance from 1000 tokens to 0.\n* Alice's action is executed, establishing the new allowance amount as 500 tokens.\n* Bob spends 500 tokens on Alice's behalf, resulting in a total of 1500 tokens spent.\n\n\nSince the PSP22 implementation introduced the [`increaseAllowance`](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/contracts/src/token/psp22/psp22.rs#L103) and [`decreaseAllowance`](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/contracts/src/token/psp22/psp22.rs#L108) functions to modify token allowances for user expenditure, and considering the discussions with the OpenBrush team about potentially redefining the PSP22 or proposing a new fungible token contract standard, consider removing the `approve` function from the PSP22 implementation.\n\n\n***Update:** Acknowledged, not resolved. The Brushfam team stated:*\n\n\n\n> *It is not worth to break the standard to incorporate this change.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/token/psp22/psp22.rs",
      "content": "// Copyright (c) 2012-2022 Supercolony\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\"Software\"),\n// to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npub use crate::{\n    psp22,\n    traits::psp22::*,\n};\nuse ink::prelude::vec::Vec;\nuse openbrush::{\n    storage::{\n        Mapping,\n        TypeGuard,\n    },\n    traits::{\n        AccountId,\n        Balance,\n        Storage,\n    },\n};\npub use psp22::{\n    Internal as _,\n    InternalImpl as _,\n    PSP22Impl as _,\n};\n\n#[derive(Default, Debug)]\n#[openbrush::storage_item]\npub struct Data {\n    #[lazy]\n    pub supply: Balance,\n    pub balances: Mapping<AccountId, Balance>,\n    pub allowances: Mapping<(AccountId, AccountId), Balance, AllowancesKey>,\n}\n\npub struct AllowancesKey;\n\nimpl<'a> TypeGuard<'a> for AllowancesKey {\n    type Type = &'a (&'a AccountId, &'a AccountId);\n}\n\npub trait PSP22Impl: Storage<Data> + Internal {\n    fn total_supply(&self) -> Balance {\n        self._total_supply()\n    }\n\n    fn balance_of(&self, owner: AccountId) -> Balance {\n        self._balance_of(&owner)\n    }\n\n    fn allowance(&self, owner: AccountId, spender: AccountId) -> Balance {\n        self._allowance(&owner, &spender)\n    }\n\n    fn transfer(&mut self, to: AccountId, value: Balance, data: Vec<u8>) -> Result<(), PSP22Error> {\n        let from = Self::env().caller();\n        self._transfer_from_to(from, to, value, data)?;\n        Ok(())\n    }\n\n    fn transfer_from(\n        &mut self,\n        from: AccountId,\n        to: AccountId,\n        value: Balance,\n        data: Vec<u8>,\n    ) -> Result<(), PSP22Error> {\n        let caller = Self::env().caller();\n        let allowance = self._allowance(&from, &caller);\n\n        if allowance < value {\n            return Err(PSP22Error::InsufficientAllowance)\n        }\n\n        self._approve_from_to(from, caller, allowance - value)?;\n        self._transfer_from_to(from, to, value, data)?;\n        Ok(())\n    }\n\n    fn approve(&mut self, spender: AccountId, value: Balance) -> Result<(), PSP22Error> {\n        let owner = Self::env().caller();\n        self._approve_from_to(owner, spender, value)?;\n        Ok(())\n    }\n\n    fn increase_allowance(&mut self, spender: AccountId, delta_value: Balance) -> Result<(), PSP22Error> {\n        let owner = Self::env().caller();\n        self._approve_from_to(owner, spender, self._allowance(&owner, &spender) + delta_value)\n    }\n\n    fn decrease_allowance(&mut self, spender: AccountId, delta_value: Balance) -> Result<(), PSP22Error> {\n        let owner = Self::env().caller();\n        let allowance = self._allowance(&owner, &spender);\n\n        if allowance < delta_value {\n            return Err(PSP22Error::InsufficientAllowance)\n        }\n\n        self._approve_from_to(owner, spender, allowance - delta_value)\n    }\n}\n\npub trait Internal {\n    /// User must override those methods in their contract.\n    fn _emit_transfer_event(&self, _from: Option<AccountId>, _to: Option<AccountId>, _amount: Balance);\n\n    fn _emit_approval_event(&self, _owner: AccountId, _spender: AccountId, _amount: Balance);\n\n    fn _total_supply(&self) -> Balance;\n\n    fn _balance_of(&self, owner: &AccountId) -> Balance;\n\n    fn _allowance(&self, owner: &AccountId, spender: &AccountId) -> Balance;\n\n    fn _transfer_from_to(\n        &mut self,\n        from: AccountId,\n        to: AccountId,\n        amount: Balance,\n        data: Vec<u8>,\n    ) -> Result<(), PSP22Error>;\n\n    fn _approve_from_to(&mut self, owner: AccountId, spender: AccountId, amount: Balance) -> Result<(), PSP22Error>;\n\n    fn _mint_to(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error>;\n\n    fn _burn_from(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error>;\n\n    fn _before_token_transfer(\n        &mut self,\n        _from: Option<&AccountId>,\n        _to: Option<&AccountId>,\n        _amount: &Balance,\n    ) -> Result<(), PSP22Error>;\n\n    fn _after_token_transfer(\n        &mut self,\n        _from: Option<&AccountId>,\n        _to: Option<&AccountId>,\n        _amount: &Balance,\n    ) -> Result<(), PSP22Error>;\n}\n\npub trait InternalImpl: Storage<Data> + Internal {\n    fn _emit_transfer_event(&self, _from: Option<AccountId>, _to: Option<AccountId>, _amount: Balance) {}\n\n    fn _emit_approval_event(&self, _owner: AccountId, _spender: AccountId, _amount: Balance) {}\n\n    fn _total_supply(&self) -> Balance {\n        self.data().supply.get_or_default()\n    }\n\n    fn _balance_of(&self, owner: &AccountId) -> Balance {\n        self.data().balances.get(owner).unwrap_or(0)\n    }\n\n    fn _allowance(&self, owner: &AccountId, spender: &AccountId) -> Balance {\n        self.data().allowances.get(&(owner, spender)).unwrap_or(0)\n    }\n\n    fn _transfer_from_to(\n        &mut self,\n        from: AccountId,\n        to: AccountId,\n        amount: Balance,\n        _data: Vec<u8>,\n    ) -> Result<(), PSP22Error> {\n        let from_balance = Internal::_balance_of(self, &from);\n\n        if from_balance < amount {\n            return Err(PSP22Error::InsufficientBalance)\n        }\n\n        Internal::_before_token_transfer(self, Some(&from), Some(&to), &amount)?;\n\n        self.data().balances.insert(&from, &(from_balance - amount));\n\n        let to_balance = Internal::_balance_of(self, &to);\n        self.data().balances.insert(&to, &(to_balance + amount));\n\n        Internal::_after_token_transfer(self, Some(&from), Some(&to), &amount)?;\n        Internal::_emit_transfer_event(self, Some(from), Some(to), amount);\n\n        Ok(())\n    }\n\n    fn _approve_from_to(&mut self, owner: AccountId, spender: AccountId, amount: Balance) -> Result<(), PSP22Error> {\n        self.data().allowances.insert(&(&owner, &spender), &amount);\n        Internal::_emit_approval_event(self, owner, spender, amount);\n        Ok(())\n    }\n\n    fn _mint_to(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error> {\n        Internal::_before_token_transfer(self, None, Some(&account), &amount)?;\n        let mut new_balance = Internal::_balance_of(self, &account);\n        new_balance += amount;\n        self.data().balances.insert(&account, &new_balance);\n\n        let new_supply = self.data().supply.get_or_default() + amount;\n        self.data().supply.set(&new_supply);\n\n        Internal::_after_token_transfer(self, None, Some(&account), &amount)?;\n        Internal::_emit_transfer_event(self, None, Some(account), amount);\n\n        Ok(())\n    }\n\n    fn _burn_from(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error> {\n        let mut from_balance = Internal::_balance_of(self, &account);\n\n        if from_balance < amount {\n            return Err(PSP22Error::InsufficientBalance)\n        }\n\n        Internal::_before_token_transfer(self, Some(&account), None, &amount)?;\n\n        from_balance -= amount;\n        self.data().balances.insert(&account, &from_balance);\n\n        let new_supply = self.data().supply.get_or_default() - amount;\n        self.data().supply.set(&new_supply);\n\n        Internal::_after_token_transfer(self, Some(&account), None, &amount)?;\n        Internal::_emit_transfer_event(self, Some(account), None, amount);\n\n        Ok(())\n    }\n\n    fn _before_token_transfer(\n        &mut self,\n        _from: Option<&AccountId>,\n        _to: Option<&AccountId>,\n        _amount: &Balance,\n    ) -> Result<(), PSP22Error> {\n        Ok(())\n    }\n\n    fn _after_token_transfer(\n        &mut self,\n        _from: Option<&AccountId>,\n        _to: Option<&AccountId>,\n        _amount: &Balance,\n    ) -> Result<(), PSP22Error> {\n        Ok(())\n    }\n}"
    },
    {
      "filename": "contracts/src/token/psp22/psp22.rs",
      "content": "// Copyright (c) 2012-2022 Supercolony\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\"Software\"),\n// to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npub use crate::{\n    psp22,\n    traits::psp22::*,\n};\nuse ink::prelude::vec::Vec;\nuse openbrush::{\n    storage::{\n        Mapping,\n        TypeGuard,\n    },\n    traits::{\n        AccountId,\n        Balance,\n        Storage,\n    },\n};\npub use psp22::{\n    Internal as _,\n    InternalImpl as _,\n    PSP22Impl as _,\n};\n\n#[derive(Default, Debug)]\n#[openbrush::storage_item]\npub struct Data {\n    #[lazy]\n    pub supply: Balance,\n    pub balances: Mapping<AccountId, Balance>,\n    pub allowances: Mapping<(AccountId, AccountId), Balance, AllowancesKey>,\n}\n\npub struct AllowancesKey;\n\nimpl<'a> TypeGuard<'a> for AllowancesKey {\n    type Type = &'a (&'a AccountId, &'a AccountId);\n}\n\npub trait PSP22Impl: Storage<Data> + Internal {\n    fn total_supply(&self) -> Balance {\n        self._total_supply()\n    }\n\n    fn balance_of(&self, owner: AccountId) -> Balance {\n        self._balance_of(&owner)\n    }\n\n    fn allowance(&self, owner: AccountId, spender: AccountId) -> Balance {\n        self._allowance(&owner, &spender)\n    }\n\n    fn transfer(&mut self, to: AccountId, value: Balance, data: Vec<u8>) -> Result<(), PSP22Error> {\n        let from = Self::env().caller();\n        self._transfer_from_to(from, to, value, data)?;\n        Ok(())\n    }\n\n    fn transfer_from(\n        &mut self,\n        from: AccountId,\n        to: AccountId,\n        value: Balance,\n        data: Vec<u8>,\n    ) -> Result<(), PSP22Error> {\n        let caller = Self::env().caller();\n        let allowance = self._allowance(&from, &caller);\n\n        if allowance < value {\n            return Err(PSP22Error::InsufficientAllowance)\n        }\n\n        self._approve_from_to(from, caller, allowance - value)?;\n        self._transfer_from_to(from, to, value, data)?;\n        Ok(())\n    }\n\n    fn approve(&mut self, spender: AccountId, value: Balance) -> Result<(), PSP22Error> {\n        let owner = Self::env().caller();\n        self._approve_from_to(owner, spender, value)?;\n        Ok(())\n    }\n\n    fn increase_allowance(&mut self, spender: AccountId, delta_value: Balance) -> Result<(), PSP22Error> {\n        let owner = Self::env().caller();\n        self._approve_from_to(owner, spender, self._allowance(&owner, &spender) + delta_value)\n    }\n\n    fn decrease_allowance(&mut self, spender: AccountId, delta_value: Balance) -> Result<(), PSP22Error> {\n        let owner = Self::env().caller();\n        let allowance = self._allowance(&owner, &spender);\n\n        if allowance < delta_value {\n            return Err(PSP22Error::InsufficientAllowance)\n        }\n\n        self._approve_from_to(owner, spender, allowance - delta_value)\n    }\n}\n\npub trait Internal {\n    /// User must override those methods in their contract.\n    fn _emit_transfer_event(&self, _from: Option<AccountId>, _to: Option<AccountId>, _amount: Balance);\n\n    fn _emit_approval_event(&self, _owner: AccountId, _spender: AccountId, _amount: Balance);\n\n    fn _total_supply(&self) -> Balance;\n\n    fn _balance_of(&self, owner: &AccountId) -> Balance;\n\n    fn _allowance(&self, owner: &AccountId, spender: &AccountId) -> Balance;\n\n    fn _transfer_from_to(\n        &mut self,\n        from: AccountId,\n        to: AccountId,\n        amount: Balance,\n        data: Vec<u8>,\n    ) -> Result<(), PSP22Error>;\n\n    fn _approve_from_to(&mut self, owner: AccountId, spender: AccountId, amount: Balance) -> Result<(), PSP22Error>;\n\n    fn _mint_to(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error>;\n\n    fn _burn_from(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error>;\n\n    fn _before_token_transfer(\n        &mut self,\n        _from: Option<&AccountId>,\n        _to: Option<&AccountId>,\n        _amount: &Balance,\n    ) -> Result<(), PSP22Error>;\n\n    fn _after_token_transfer(\n        &mut self,\n        _from: Option<&AccountId>,\n        _to: Option<&AccountId>,\n        _amount: &Balance,\n    ) -> Result<(), PSP22Error>;\n}\n\npub trait InternalImpl: Storage<Data> + Internal {\n    fn _emit_transfer_event(&self, _from: Option<AccountId>, _to: Option<AccountId>, _amount: Balance) {}\n\n    fn _emit_approval_event(&self, _owner: AccountId, _spender: AccountId, _amount: Balance) {}\n\n    fn _total_supply(&self) -> Balance {\n        self.data().supply.get_or_default()\n    }\n\n    fn _balance_of(&self, owner: &AccountId) -> Balance {\n        self.data().balances.get(owner).unwrap_or(0)\n    }\n\n    fn _allowance(&self, owner: &AccountId, spender: &AccountId) -> Balance {\n        self.data().allowances.get(&(owner, spender)).unwrap_or(0)\n    }\n\n    fn _transfer_from_to(\n        &mut self,\n        from: AccountId,\n        to: AccountId,\n        amount: Balance,\n        _data: Vec<u8>,\n    ) -> Result<(), PSP22Error> {\n        let from_balance = Internal::_balance_of(self, &from);\n\n        if from_balance < amount {\n            return Err(PSP22Error::InsufficientBalance)\n        }\n\n        Internal::_before_token_transfer(self, Some(&from), Some(&to), &amount)?;\n\n        self.data().balances.insert(&from, &(from_balance - amount));\n\n        let to_balance = Internal::_balance_of(self, &to);\n        self.data().balances.insert(&to, &(to_balance + amount));\n\n        Internal::_after_token_transfer(self, Some(&from), Some(&to), &amount)?;\n        Internal::_emit_transfer_event(self, Some(from), Some(to), amount);\n\n        Ok(())\n    }\n\n    fn _approve_from_to(&mut self, owner: AccountId, spender: AccountId, amount: Balance) -> Result<(), PSP22Error> {\n        self.data().allowances.insert(&(&owner, &spender), &amount);\n        Internal::_emit_approval_event(self, owner, spender, amount);\n        Ok(())\n    }\n\n    fn _mint_to(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error> {\n        Internal::_before_token_transfer(self, None, Some(&account), &amount)?;\n        let mut new_balance = Internal::_balance_of(self, &account);\n        new_balance += amount;\n        self.data().balances.insert(&account, &new_balance);\n\n        let new_supply = self.data().supply.get_or_default() + amount;\n        self.data().supply.set(&new_supply);\n\n        Internal::_after_token_transfer(self, None, Some(&account), &amount)?;\n        Internal::_emit_transfer_event(self, None, Some(account), amount);\n\n        Ok(())\n    }\n\n    fn _burn_from(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error> {\n        let mut from_balance = Internal::_balance_of(self, &account);\n\n        if from_balance < amount {\n            return Err(PSP22Error::InsufficientBalance)\n        }\n\n        Internal::_before_token_transfer(self, Some(&account), None, &amount)?;\n\n        from_balance -= amount;\n        self.data().balances.insert(&account, &from_balance);\n\n        let new_supply = self.data().supply.get_or_default() - amount;\n        self.data().supply.set(&new_supply);\n\n        Internal::_after_token_transfer(self, Some(&account), None, &amount)?;\n        Internal::_emit_transfer_event(self, Some(account), None, amount);\n\n        Ok(())\n    }\n\n    fn _before_token_transfer(\n        &mut self,\n        _from: Option<&AccountId>,\n        _to: Option<&AccountId>,\n        _amount: &Balance,\n    ) -> Result<(), PSP22Error> {\n        Ok(())\n    }\n\n    fn _after_token_transfer(\n        &mut self,\n        _from: Option<&AccountId>,\n        _to: Option<&AccountId>,\n        _amount: &Balance,\n    ) -> Result<(), PSP22Error> {\n        Ok(())\n    }\n}"
    }
  ]
}