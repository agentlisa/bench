{
  "Title": "Lack of events for critical actions",
  "Content": "# Lack of events for critical actions\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L161\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L161</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXCompound.sol#L35\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXCompound.sol#L35</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L72\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L72</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L225\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L225</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L244\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L244</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXRebalance.sol#L35\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXRebalance.sol#L35</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXRebalance.sol#L149\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXRebalance.sol#L149</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXVault.sol#L334\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXVault.sol#L334</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L231\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWithdraw.sol#L231</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWorker.sol#L23\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWorker.sol#L23</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWorker.sol#L72\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWorker.sol#L72</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWorker.sol#L114\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWorker.sol#L114</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWorker.sol#L129\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXWorker.sol#L129</a>\n\n\n## Summary\n\nThere are functions that don’t emit events.\n\n## Vulnerability Details\n\nFunctions: \n\n`GMXDeposit::processDepositFailure`\n\n`GMXCompound::compound`\n\n`GMXEmergency::emergencyResume`\n\n`GMXManager::borrow`\n\n`GMXManager::repay`\n\n`GMXRebalance::rebalanceAdd`\n\n`GMXRebalance::rebalanceRemove`\n\n`GMXVault::mintFee`\n\n`GMXWithdraw::processWithdrawFailure`\n\n`GMXWorker::addLiquidity`\n\n`GMXWorker::removeLiquidity`\n\n`GMXWorker::swapExactTokensForTokens`\n\n`GMXWorker::swapTokensForExactTokens`\n\n## Impact\n\nExternal users, frontend, or blockchain monitoring won’t announce for these critical functions.\n\n## Tools Used\n\nManual\n\n## Recommendations\n\nAdd events where possible for critical operations.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXDeposit.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessDeposit } from \"./GMXProcessDeposit.sol\";\n\n/**\n  * @title GMXDeposit\n  * @author Steadefi\n  * @notice Re-usable library functions for deposit operations for Steadefi leveraged vaults\n*/\nlibrary GMXDeposit {\n  using SafeERC20 for IERC20;\n\n  /* ======================= CONSTANTS ======================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event DepositCreated(\n    address indexed user,\n    address asset,\n    uint256 assetAmt\n  );\n  event DepositCompleted(\n    address indexed user,\n    uint256 shareAmt,\n    uint256 equityBefore,\n    uint256 equityAfter\n  );\n  event DepositCancelled(\n    address indexed user\n  );\n  event DepositFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n    * @param isNative Boolean as to whether user is depositing native asset (e.g. ETH, AVAX, etc.)\n  */\n  function deposit(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp,\n    bool isNative\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of depositor's assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    // Transfer assets from user to vault\n    if (isNative) {\n      GMXChecks.beforeNativeDepositChecks(self, dp);\n\n      self.WNT.deposit{ value: dp.amt }();\n    } else {\n      IERC20(dp.token).safeTransferFrom(msg.sender, address(this), dp.amt);\n    }\n\n    GMXTypes.DepositCache memory _dc;\n\n    _dc.user = payable(msg.sender);\n\n    if (dp.token == address(self.lpToken)) {\n      // If LP token deposited\n      _dc.depositValue = self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      * dp.amt\n      / SAFE_MULTIPLIER;\n    } else {\n      // If tokenA or tokenB deposited\n      _dc.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(dp.token),\n        dp.amt\n      );\n    }\n    _dc.depositParams = dp;\n    _dc.healthParams = _hp;\n\n    self.depositCache = _dc;\n\n    GMXChecks.beforeDepositChecks(self, _dc.depositValue);\n\n    self.status = GMXTypes.Status.Deposit;\n\n    self.vault.mintFee();\n\n    // Borrow assets and create deposit in GMX\n    (\n      uint256 _borrowTokenAAmt,\n      uint256 _borrowTokenBAmt\n    ) = GMXManager.calcBorrow(self, _dc.depositValue);\n\n    _dc.borrowParams.borrowTokenAAmt = _borrowTokenAAmt;\n    _dc.borrowParams.borrowTokenBAmt = _borrowTokenBAmt;\n\n    GMXManager.borrow(self, _borrowTokenAAmt, _borrowTokenBAmt);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _dc.depositValue,\n      dp.slippage\n    );\n    _alp.executionFee = dp.executionFee;\n\n    _dc.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n\n    self.depositCache = _dc;\n\n    emit DepositCreated(\n      _dc.user,\n      _dc.depositParams.token,\n      _dc.depositParams.amt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDeposit(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessDeposit.processDeposit()\n    // to allow try/catch here to catch for any issues or any checks in afterDepositChecks() failing.\n    // If there are any issues, a DepositFailed event will be emitted and processDepositFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessDeposit.processDeposit(self) {\n      // Mint shares to depositor\n      self.vault.mint(self.depositCache.user, self.depositCache.sharesToUser);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit DepositCompleted(\n        self.depositCache.user,\n        self.depositCache.sharesToUser,\n        self.depositCache.healthParams.equityBefore,\n        self.depositCache.healthParams.equityAfter\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Deposit_Failed;\n\n      emit DepositFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositCancellationChecks(self);\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      self.depositCache.borrowParams.borrowTokenAAmt,\n      self.depositCache.borrowParams.borrowTokenBAmt\n    );\n\n    // Return user's deposited asset\n    // If native token is being withdrawn, we convert wrapped to native\n    if (self.depositCache.depositParams.token == address(self.WNT)) {\n      self.WNT.withdraw(self.WNT.balanceOf(address(this)));\n      (bool success, ) = self.depositCache.user.call{value: address(this).balance}(\"\");\n      require(success, \"Transfer failed.\");\n    } else {\n      // Transfer requested withdraw asset to user\n      IERC20(self.depositCache.depositParams.token).safeTransfer(\n        self.depositCache.user,\n        self.depositCache.depositParams.amt\n      );\n    }\n\n    self.status = GMXTypes.Status.Open;\n\n    emit DepositCancelled(self.depositCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterDepositFailureChecks(self);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If current LP amount is somehow less or equal to amount before, we do not remove any liquidity\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore) {\n      processDepositFailureLiquidityWithdrawal(self);\n    } else {\n      // Remove only the newly added LP amount\n      _rlp.lpAmt = GMXReader.lpAmt(self) - self.depositCache.healthParams.lpAmtBefore;\n\n      // If delta strategy is Long, remove all in tokenB to make it more\n      // efficent to repay tokenB debt as Long strategy only borrows tokenB\n      if (self.delta == GMXTypes.Delta.Long) {\n        address[] memory _tokenASwapPath = new address[](1);\n        _tokenASwapPath[0] = address(self.lpToken);\n        _rlp.tokenASwapPath = _tokenASwapPath;\n\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenB),\n          address(self.tokenB),\n          slippage\n        );\n      } else {\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenA),\n          address(self.tokenB),\n          slippage\n        );\n      }\n\n      _rlp.executionFee = executionFee;\n\n      // Remove liqudity\n      self.depositCache.withdrawKey = GMXManager.removeLiquidity(\n        self,\n        _rlp\n      );\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailureLiquidityWithdrawal(\n    GMXTypes.Store storage self\n  ) public {\n    GMXChecks.beforeProcessAfterDepositFailureLiquidityWithdrawal(self);\n\n    GMXTypes.RepayParams memory _rp;\n\n    _rp.repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    _rp.repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n\n    // Check if swap between assets are needed for repayment based on previous borrow\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = block.timestamp;\n      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      // We allow deadline to be set as the current block timestamp whenever this function\n      // is called because this function is triggered as a follow up function (by a callback/keeper)\n      // and not directly by a user/keeper. If this follow on function flow reverts due to this tx\n      // being processed after a set deadline, this will cause the vault to be in a \"stuck\" state.\n      // To resolve this, this function will have to be called again with an updated deadline until it\n      // succeeds/a miner processes the tx.\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    // Adjust amount to repay for both tokens due to slight differences\n    // from liqudiity withdrawal and swaps. If the amount to repay based on previous borrow\n    // is more than the available balance vault has, we simply repay what the vault has\n    uint256 _repayTokenAAmt;\n    uint256 _repayTokenBAmt;\n\n    if (self.depositCache.borrowParams.borrowTokenAAmt > self.tokenA.balanceOf(address(this))) {\n      _repayTokenAAmt = self.tokenA.balanceOf(address(this));\n    } else {\n      _repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    }\n\n    if (self.depositCache.borrowParams.borrowTokenBAmt > self.tokenB.balanceOf(address(this))) {\n      _repayTokenBAmt = self.tokenB.balanceOf(address(this));\n    } else {\n      _repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n    }\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      _repayTokenAAmt,\n      _repayTokenBAmt\n    );\n\n    // Refund user the rest of the remaining withdrawn LP assets\n    // Will be in tokenA/tokenB only; so if user deposited LP tokens\n    // they will still be refunded in tokenA/tokenB\n    self.tokenA.safeTransfer(self.depositCache.user, self.tokenA.balanceOf(address(this)));\n    self.tokenB.safeTransfer(self.depositCache.user, self.tokenB.balanceOf(address(this)));\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXCompound.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\n\n/**\n  * @title GMXCompound\n  * @author Steadefi\n  * @notice Re-usable library functions for compound operations for Steadefi leveraged vaults\n*/\nlibrary GMXCompound {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event CompoundCompleted();\n  event CompoundCancelled();\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function compound(\n    GMXTypes.Store storage self,\n    GMXTypes.CompoundParams memory cp\n  ) external {\n    // Transfer any tokenA/B from trove to vault\n    if (self.tokenA.balanceOf(address(self.trove)) > 0) {\n      self.tokenA.safeTransferFrom(\n        address(self.trove),\n        address(this),\n        self.tokenA.balanceOf(address(self.trove))\n      );\n    }\n    if (self.tokenB.balanceOf(address(self.trove)) > 0) {\n      self.tokenB.safeTransferFrom(\n        address(self.trove),\n        address(this),\n        self.tokenB.balanceOf(address(self.trove))\n      );\n    }\n\n    uint256 _tokenInAmt = IERC20(cp.tokenIn).balanceOf(address(this));\n\n    // Only compound if tokenIn amount is more than 0\n    if (_tokenInAmt > 0) {\n      self.refundee = payable(msg.sender);\n\n      self.compoundCache.compoundParams = cp;\n\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = cp.tokenIn;\n      _sp.tokenOut = cp.tokenOut;\n      _sp.amountIn = _tokenInAmt;\n      _sp.amountOut = 0; // amount out minimum calculated in Swap\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = cp.deadline;\n\n      GMXManager.swapExactTokensForTokens(self, _sp);\n\n      GMXTypes.AddLiquidityParams memory _alp;\n\n      _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n      _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n\n      self.compoundCache.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenA),\n        self.tokenA.balanceOf(address(this))\n      )\n      + GMXReader.convertToUsdValue(\n        self,\n        address(self.tokenB),\n        self.tokenB.balanceOf(address(this))\n      );\n\n      GMXChecks.beforeCompoundChecks(self);\n\n      self.status = GMXTypes.Status.Compound;\n\n      _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n        self,\n        self.compoundCache.depositValue,\n        cp.slippage\n      );\n\n      _alp.executionFee = cp.executionFee;\n\n      self.compoundCache.depositKey = GMXManager.addLiquidity(\n        self,\n        _alp\n      );\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processCompound(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessCompoundChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit CompoundCompleted();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processCompoundCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessCompoundCancellationChecks(self);\n\n    self.status = GMXTypes.Status.Compound_Failed;\n\n    emit CompoundCancelled();\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXEmergency.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\n\n/**\n  * @title GMXEmergency\n  * @author Steadefi\n  * @notice Re-usable library functions for emergency operations for Steadefi leveraged vaults\n*/\nlibrary GMXEmergency {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant DUST_AMOUNT = 1e17;\n\n  /* ======================== EVENTS ========================= */\n\n  event EmergencyPause();\n  event EmergencyResume();\n  event EmergencyClose(\n    uint256 repayTokenAAmt,\n    uint256 repayTokenBAmt\n  );\n  event EmergencyWithdraw(\n    address indexed user,\n    uint256 sharesAmt,\n    address assetA,\n    uint256 assetAAmt,\n    address assetB,\n    uint256 assetBAmt\n  );\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyPause(\n    GMXTypes.Store storage self\n  ) external {\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // Remove all of the vault's LP tokens\n    _rlp.lpAmt = self.lpToken.balanceOf(address(this));\n    _rlp.executionFee = msg.value;\n\n    GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    self.status = GMXTypes.Status.Paused;\n\n    emit EmergencyPause();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Resume;\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.executionFee = msg.value;\n\n    GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processEmergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit EmergencyResume();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyClose(\n    GMXTypes.Store storage self,\n    uint256 deadline\n  ) external {\n    GMXChecks.beforeEmergencyCloseChecks(self);\n\n    // Repay all borrowed assets; 1e18 == 100% shareRatio to repay\n    GMXTypes.RepayParams memory _rp;\n    (\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    ) = GMXManager.calcRepay(self, 1e18);\n\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = deadline;\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    GMXManager.repay(\n      self,\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n\n    self.status = GMXTypes.Status.Closed;\n\n    emit EmergencyClose(\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyWithdraw(\n    GMXTypes.Store storage self,\n    uint256 shareAmt\n  ) external {\n    // check to ensure shares withdrawn does not exceed user's balance\n    uint256 _userShareBalance = IERC20(address(self.vault)).balanceOf(msg.sender);\n\n    // to avoid leaving dust behind\n    unchecked {\n      if (_userShareBalance - shareAmt < DUST_AMOUNT) {\n        shareAmt = _userShareBalance;\n      }\n    }\n\n    GMXChecks.beforeEmergencyWithdrawChecks(self, shareAmt);\n\n    // share ratio calculation must be before burn()\n    uint256 _shareRatio = shareAmt * SAFE_MULTIPLIER\n                          / IERC20(address(self.vault)).totalSupply();\n\n    self.vault.burn(msg.sender, shareAmt);\n\n    uint256 _withdrawAmtTokenA = _shareRatio\n                                 * self.tokenA.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n    uint256 _withdrawAmtTokenB = _shareRatio\n                                 * self.tokenB.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n\n    self.tokenA.safeTransfer(msg.sender, _withdrawAmtTokenA);\n    self.tokenB.safeTransfer(msg.sender, _withdrawAmtTokenB);\n\n    emit EmergencyWithdraw(\n      msg.sender,\n      shareAmt,\n      address(self.tokenA),\n      _withdrawAmtTokenA,\n      address(self.tokenB),\n      _withdrawAmtTokenB\n    );\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXWorker } from \"./GMXWorker.sol\";\n\n/**\n  * @title GMXManager\n  * @author Steadefi\n  * @notice Re-usable library functions for calculations and operations of borrows, repays, swaps\n  * adding and removal of liquidity to yield source\n*/\nlibrary GMXManager {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Calculate if token swap is needed to ensure enough repayment for both tokenA and tokenB\n    * @notice Assume that after swapping one token for the other, there is still enough to repay both tokens\n    * @param self GMXTypes.Store\n    * @param rp GMXTypes.RepayParams\n    * @return swapNeeded boolean if swap is needed\n    * @return tokenFrom address of token to swap from\n    * @return tokenTo address of token to swap to\n    * @return tokenToAmt amount of tokenFrom to swap in token decimals\n  */\n  function calcSwapForRepay(\n    GMXTypes.Store storage self,\n    GMXTypes.RepayParams memory rp\n  ) external view returns (bool, address, address, uint256) {\n    address _tokenFrom;\n    address _tokenTo;\n    uint256 _tokenToAmt;\n\n    if (rp.repayTokenAAmt > self.tokenA.balanceOf(address(this))) {\n      // If more tokenA is needed for repayment\n      _tokenToAmt = rp.repayTokenAAmt - self.tokenA.balanceOf(address(this));\n      _tokenFrom = address(self.tokenB);\n      _tokenTo = address(self.tokenA);\n\n      return (true, _tokenFrom, _tokenTo, _tokenToAmt);\n    } else if (rp.repayTokenBAmt > self.tokenB.balanceOf(address(this))) {\n      // If more tokenB is needed for repayment\n      _tokenToAmt = rp.repayTokenBAmt - self.tokenB.balanceOf(address(this));\n      _tokenFrom = address(self.tokenA);\n      _tokenTo = address(self.tokenB);\n\n      return (true, _tokenFrom, _tokenTo, _tokenToAmt);\n    } else {\n      // If more there is enough to repay both tokens\n      return (false, address(0), address(0), 0);\n    }\n  }\n\n  /**\n    * @notice Calculate amount of tokenA and tokenB to borrow\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n  */\n  function calcBorrow(\n    GMXTypes.Store storage self,\n    uint256 depositValue\n  ) external view returns (uint256, uint256) {\n    // Calculate final position value based on deposit value\n    uint256 _positionValue = depositValue * self.leverage / SAFE_MULTIPLIER;\n\n    // Obtain the value to borrow\n    uint256 _borrowValue = _positionValue - depositValue;\n\n    uint256 _tokenADecimals = IERC20Metadata(address(self.tokenA)).decimals();\n    uint256 _tokenBDecimals = IERC20Metadata(address(self.tokenB)).decimals();\n    uint256 _borrowLongTokenAmt;\n    uint256 _borrowShortTokenAmt;\n\n    // If delta is long, borrow all in short token\n    if (self.delta == GMXTypes.Delta.Long) {\n      _borrowShortTokenAmt = _borrowValue * SAFE_MULTIPLIER\n                             / GMXReader.convertToUsdValue(self, address(self.tokenB), 10**(_tokenBDecimals))\n                             / (10 ** (18 - _tokenBDecimals));\n    }\n\n    // If delta is neutral, borrow appropriate amount in long token to hedge, and the rest in short token\n    if (self.delta == GMXTypes.Delta.Neutral) {\n      // Get token weights in LP, e.g. 50% = 5e17\n      (uint256 _tokenAWeight,) = GMXReader.tokenWeights(self);\n\n      // Get value of long token (typically tokenA)\n      uint256 _longTokenWeightedValue = _tokenAWeight * _positionValue / SAFE_MULTIPLIER;\n\n      // Borrow appropriate amount in long token to hedge\n      _borrowLongTokenAmt = _longTokenWeightedValue * SAFE_MULTIPLIER\n                            / GMXReader.convertToUsdValue(self, address(self.tokenA), 10**(_tokenADecimals))\n                            / (10 ** (18 - _tokenADecimals));\n\n      // Borrow the shortfall value in short token\n      _borrowShortTokenAmt = (_borrowValue - _longTokenWeightedValue) * SAFE_MULTIPLIER\n                             / GMXReader.convertToUsdValue(self, address(self.tokenB), 10**(_tokenBDecimals))\n                             / (10 ** (18 - _tokenBDecimals));\n    }\n\n    return (_borrowLongTokenAmt, _borrowShortTokenAmt);\n  }\n\n  /**\n    * @notice Calculate amount of tokenA and tokenB to repay based on token shares ratio being withdrawn\n    * @param self GMXTypes.Store\n    * @param shareRatio Amount of vault token shares relative to total supply in 1e18\n  */\n  function calcRepay(\n    GMXTypes.Store storage self,\n    uint256 shareRatio\n  ) external view returns (uint256, uint256) {\n    (uint256 tokenADebtAmt, uint256 tokenBDebtAmt) = GMXReader.debtAmt(self);\n\n    uint256 _repayTokenAAmt = shareRatio * tokenADebtAmt / SAFE_MULTIPLIER;\n    uint256 _repayTokenBAmt = shareRatio * tokenBDebtAmt / SAFE_MULTIPLIER;\n\n    return (_repayTokenAAmt, _repayTokenBAmt);\n  }\n\n  /**\n    * @notice Calculate minimum market (GM LP) tokens to receive when adding liquidity\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n    * @param slippage Slippage value in 1e4\n    * @return minMarketTokenAmt in 1e18\n  */\n  function calcMinMarketSlippageAmt(\n    GMXTypes.Store storage self,\n    uint256 depositValue,\n    uint256 slippage\n  ) external view returns (uint256) {\n    uint256 _lpTokenValue = self.gmxOracle.getLpTokenValue(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB),\n      false,\n      false\n    );\n\n    return depositValue\n      * SAFE_MULTIPLIER\n      / _lpTokenValue\n      * (10000 - slippage) / 10000;\n  }\n\n  /**\n    * @notice Calculate minimum tokens to receive when removing liquidity\n    * @dev minLongToken and minShortToken should be the token which we want to receive\n    * after liquidity withdrawal and swap\n    * @param self GMXTypes.Store\n    * @param lpAmt Amt of lp tokens to remove liquidity in 1e18\n    * @param minLongToken Address of token to receive longToken in\n    * @param minShortToken Address of token to receive shortToken in\n    * @param slippage Slippage value in 1e4\n    * @return minTokenAAmt in 1e18\n    * @return minTokenBAmt in 1e18\n  */\n  function calcMinTokensSlippageAmt(\n    GMXTypes.Store storage self,\n    uint256 lpAmt,\n    address minLongToken,\n    address minShortToken,\n    uint256 slippage\n  ) external view returns (uint256, uint256) {\n    uint256 _withdrawValue = lpAmt\n      * self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      / SAFE_MULTIPLIER;\n\n    (uint256 _tokenAWeight, uint256 _tokenBWeight) = GMXReader.tokenWeights(self);\n\n    uint256 _minLongTokenAmt = _withdrawValue\n      * _tokenAWeight / SAFE_MULTIPLIER\n      * SAFE_MULTIPLIER\n      / GMXReader.convertToUsdValue(\n        self,\n        minLongToken,\n        10**(IERC20Metadata(minLongToken).decimals())\n      )\n      / (10 ** (18 - IERC20Metadata(minLongToken).decimals()));\n\n    uint256 _minShortTokenAmt = _withdrawValue\n      * _tokenBWeight / SAFE_MULTIPLIER\n      * SAFE_MULTIPLIER\n      / GMXReader.convertToUsdValue(\n        self,\n        minShortToken,\n        10**(IERC20Metadata(minShortToken).decimals())\n      )\n      / (10 ** (18 - IERC20Metadata(minShortToken).decimals()));\n\n    return (\n      _minLongTokenAmt * (10000 - slippage) / 10000,\n      _minShortTokenAmt * (10000 - slippage) / 10000\n    );\n  }\n\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice Borrow tokens from lending vaults\n    * @param self GMXTypes.Store\n    * @param borrowTokenAAmt Amount of tokenA to borrow in token decimals\n    * @param borrowTokenBAmt Amount of tokenB to borrow in token decimals\n  */\n  function borrow(\n    GMXTypes.Store storage self,\n    uint256 borrowTokenAAmt,\n    uint256 borrowTokenBAmt\n  ) public {\n    if (borrowTokenAAmt > 0) {\n      self.tokenALendingVault.borrow(borrowTokenAAmt);\n    }\n    if (borrowTokenBAmt > 0) {\n      self.tokenBLendingVault.borrow(borrowTokenBAmt);\n    }\n  }\n\n  /**\n    * @notice Repay tokens to lending vaults\n    * @param self GMXTypes.Store\n    * @param repayTokenAAmt Amount of tokenA to repay in token decimals\n    * @param repayTokenBAmt Amount of tokenB to repay in token decimals\n  */\n  function repay(\n    GMXTypes.Store storage self,\n    uint256 repayTokenAAmt,\n    uint256 repayTokenBAmt\n  ) public {\n    if (repayTokenAAmt > 0) {\n      self.tokenALendingVault.repay(repayTokenAAmt);\n    }\n    if (repayTokenBAmt > 0) {\n      self.tokenBLendingVault.repay(repayTokenBAmt);\n    }\n  }\n\n  /**\n    * @notice Add liquidity to yield source\n    * @param self GMXTypes.Store\n    * @param alp GMXTypes.AddLiquidityParams\n    * @return depositKey\n  */\n  function addLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.AddLiquidityParams memory alp\n  ) public returns (bytes32) {\n    return GMXWorker.addLiquidity(self, alp);\n  }\n\n  /**\n    * @notice Remove liquidity from yield source\n    * @param self GMXTypes.Store\n    * @param rlp GMXTypes.RemoveLiquidityParams\n    * @return withdrawKey\n  */\n  function removeLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.RemoveLiquidityParams memory rlp\n  ) public returns (bytes32) {\n    return GMXWorker.removeLiquidity(self, rlp);\n  }\n\n  /**\n    * @notice Swap exact amount of tokenIn for as many possible amount of tokenOut\n    * @param self GMXTypes.Store\n    * @param sp ISwap.SwapParams\n    * @return amountOut in token decimals\n  */\n  function swapExactTokensForTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    if (sp.amountIn > 0) {\n      return GMXWorker.swapExactTokensForTokens(self, sp);\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n    * @notice Swap as little posible tokenIn for exact amount of tokenOut\n    * @param self GMXTypes.Store\n    * @param sp ISwap.SwapParams\n    * @return amountIn in token decimals\n  */\n  function swapTokensForExactTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    if (sp.amountIn > 0) {\n      return GMXWorker.swapTokensForExactTokens(self, sp);\n    } else {\n      return 0;\n    }\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXWorker } from \"./GMXWorker.sol\";\n\n/**\n  * @title GMXManager\n  * @author Steadefi\n  * @notice Re-usable library functions for calculations and operations of borrows, repays, swaps\n  * adding and removal of liquidity to yield source\n*/\nlibrary GMXManager {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Calculate if token swap is needed to ensure enough repayment for both tokenA and tokenB\n    * @notice Assume that after swapping one token for the other, there is still enough to repay both tokens\n    * @param self GMXTypes.Store\n    * @param rp GMXTypes.RepayParams\n    * @return swapNeeded boolean if swap is needed\n    * @return tokenFrom address of token to swap from\n    * @return tokenTo address of token to swap to\n    * @return tokenToAmt amount of tokenFrom to swap in token decimals\n  */\n  function calcSwapForRepay(\n    GMXTypes.Store storage self,\n    GMXTypes.RepayParams memory rp\n  ) external view returns (bool, address,"
    }
  ]
}