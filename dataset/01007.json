{
  "Title": "Pointer Arithmetic Error in RLP Library",
  "Content": "During finalization, L1 to L2 transactions that have been transmitted to L2 by the coordinator are marked as [received](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/messageService/l1/L1MessageManager.sol#L85) back on L1. To do so, the transactions relaying the [message hashes](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/messageService/l2/L2MessageManager.sol#L43-L58) to the L2 message service are [RLP-decoded](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/ZkEvmV2.sol#L232) to extract the hashes marked as received during finalization.\n\n\nHowever, the RLP library used for decoding includes a pointer arithmetic error when computing the bounds of the RLP-encoded transactions. When decoding long lists, the [`endPtr`](https://github.com/Consensys/linea-contracts/blob/f08c1906855198e2dc0413a47dcb38291b7087e5/contracts/messageService/lib/Rlp.sol#L86) is computed as `_self.item.memPtr + 1 + lenX` while it should be computed as `_self.item.memPtr + 1 + byteLen + lenX`.\n\n\n\n\n```\nÂ Long list RLP-encoded transaction:\n|-----------------------|-----------------------------|------------------|\n|  length of length     | length of payload in bytes  |      payload     |\n|         1 byte        |        (byteLen bytes)      |   (lenX bytes)   |\n|-----------------------|-----------------------------|------------------|\n^                                                               ^        ^\n_self.item.memPtr (initial memPtrStart)                     endPtr   endPtr + byteLen\n\n```\n\n\nGiven the current usage of the library, this arithmetic error will not result in adverse effects. This is because `byteLen` will never exceed 5 bytes in practice, while the abi encoding of the hashes will always be over 64 bytes in length. Still, for correctness and to avoid potential future issues, consider fixing the end pointer calculation.\n\n\n***Update**: Acknowledged, will resolve. The Linea team stated:*\n\n\n\n> *Will resolve, using extensive sample testing for generic use.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/messageService/l1/L1MessageManager.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.19;\n\nimport { IL1MessageManager } from \"../../interfaces/IL1MessageManager.sol\";\n\n/**\n * @title Contract to manage cross-chain message hashes storage and status on L1.\n * @author ConsenSys Software Inc.\n */\nabstract contract L1MessageManager is IL1MessageManager {\n  uint8 public constant INBOX_STATUS_UNKNOWN = 0;\n  uint8 public constant INBOX_STATUS_RECEIVED = 1;\n\n  uint8 public constant OUTBOX_STATUS_UNKNOWN = 0;\n  uint8 public constant OUTBOX_STATUS_SENT = 1;\n  uint8 public constant OUTBOX_STATUS_RECEIVED = 2;\n\n  /// @dev There is a uint216 worth of storage layout here.\n\n  /// @dev Mapping to store L1->L2 message hashes status.\n  /// @dev messageHash => messageStatus (0: unknown, 1: sent, 2: received).\n  mapping(bytes32 => uint256) public outboxL1L2MessageStatus;\n\n  /// @dev Mapping to store L2->L1 message hashes status.\n  /// @dev messageHash => messageStatus (0: unknown, 1: received).\n  mapping(bytes32 => uint256) public inboxL2L1MessageStatus;\n\n  /// @dev Keep free storage slots for future implementation updates to avoid storage collision.\n  uint256[50] private __gap;\n\n  /**\n   * @notice Add a cross-chain L2->L1 message hash in storage.\n   * @dev Once the event is emitted, it should be ready for claiming (post block finalization).\n   * @param  _messageHash Hash of the message.\n   */\n  function _addL2L1MessageHash(bytes32 _messageHash) internal {\n    if (inboxL2L1MessageStatus[_messageHash] != INBOX_STATUS_UNKNOWN) {\n      revert MessageAlreadyReceived(_messageHash);\n    }\n\n    inboxL2L1MessageStatus[_messageHash] = INBOX_STATUS_RECEIVED;\n\n    emit L2L1MessageHashAddedToInbox(_messageHash);\n  }\n\n  /**\n   * @notice Update the status of L2->L1 message when a user claims a message on L1.\n   * @dev The L2->L1 message is removed from storage.\n   * @dev Due to the nature of the rollup, we should not get a second entry of this.\n   * @param  _messageHash Hash of the message.\n   */\n  function _updateL2L1MessageStatusToClaimed(bytes32 _messageHash) internal {\n    if (inboxL2L1MessageStatus[_messageHash] != INBOX_STATUS_RECEIVED) {\n      revert MessageDoesNotExistOrHasAlreadyBeenClaimed();\n    }\n\n    delete inboxL2L1MessageStatus[_messageHash];\n  }\n\n  /**\n   * @notice Add L1->L2 message hash in storage when a message is sent on L1.\n   * @param  _messageHash Hash of the message.\n   */\n  function _addL1L2MessageHash(bytes32 _messageHash) internal {\n    outboxL1L2MessageStatus[_messageHash] = OUTBOX_STATUS_SENT;\n  }\n\n  /**\n   * @notice Update the status of L1->L2 messages as received when messages has been stored on L2.\n   * @dev The expectation here is that the rollup is limited to 100 hashes being added here - array is not open ended.\n   * @param  _messageHashes List of message hashes.\n   */\n  function _updateL1L2MessageStatusToReceived(bytes32[] memory _messageHashes) internal {\n    uint256 messageHashArrayLength = _messageHashes.length;\n\n    for (uint256 i; i < messageHashArrayLength; ) {\n      bytes32 messageHash = _messageHashes[i];\n      uint256 existingStatus = outboxL1L2MessageStatus[messageHash];\n\n      if (existingStatus == OUTBOX_STATUS_UNKNOWN) {\n        revert L1L2MessageNotSent(messageHash);\n      }\n\n      if (existingStatus != OUTBOX_STATUS_RECEIVED) {\n        outboxL1L2MessageStatus[messageHash] = OUTBOX_STATUS_RECEIVED;\n      }\n\n      unchecked {\n        i++;\n      }\n    }\n\n    emit L1L2MessagesReceivedOnL2(_messageHashes);\n  }\n}"
    },
    {
      "filename": "contracts/messageService/lib/Rlp.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * @notice Please reach out with any questions or concerns.\n */\npragma solidity ^0.8.19;\n\nerror NotList();\nerror WrongBytesLength();\nerror NoNext();\nerror MemoryOutOfBounds(uint256 inde);\n\nlibrary RLPReader {\n  uint8 internal constant STRING_SHORT_START = 0x80;\n  uint8 internal constant STRING_LONG_START = 0xb8;\n  uint8 internal constant LIST_SHORT_START = 0xc0;\n  uint8 internal constant LIST_LONG_START = 0xf8;\n  uint8 internal constant LIST_SHORT_START_MAX = 0xf7;\n  uint8 internal constant WORD_SIZE = 32;\n\n  struct RLPItem {\n    uint256 len;\n    uint256 memPtr;\n  }\n\n  struct Iterator {\n    RLPItem item; // Item that's being iterated over.\n    uint256 nextPtr; // Position of the next item in the list.\n  }\n\n  /**\n   * @dev Returns the next element in the iteration. Reverts if it has no next element.\n   * @param _self The iterator.\n   * @return nextItem The next element in the iteration.\n   */\n  function _next(Iterator memory _self) internal pure returns (RLPItem memory nextItem) {\n    if (!_hasNext(_self)) {\n      revert NoNext();\n    }\n\n    uint256 ptr = _self.nextPtr;\n    uint256 itemLength = _itemLength(ptr);\n    _self.nextPtr = ptr + itemLength;\n\n    nextItem.len = itemLength;\n    nextItem.memPtr = ptr;\n  }\n\n  /**\n   * @dev Returns the number 'skiptoNum' element in the iteration.\n   * @param _self The iterator.\n   * @param _skipToNum Element position in the RLP item iterator to return.\n   * @return item The number 'skipToNum' element in the iteration.\n   */\n  function _skipTo(Iterator memory _self, uint256 _skipToNum) internal pure returns (RLPItem memory item) {\n    uint256 lenX;\n    uint256 memPtrStart = _self.item.memPtr;\n    uint256 endPtr;\n    uint256 byte0;\n    uint256 byteLen;\n\n    assembly {\n      // get first byte to know if it is a short/long list\n      byte0 := byte(0, mload(memPtrStart))\n\n      // yul has no if/else so if it a short list ( < long list start )\n      switch lt(byte0, LIST_LONG_START)\n      case 1 {\n        // the length is just the difference in bytes\n        lenX := sub(byte0, 0xc0)\n      }\n      case 0 {\n        // at this point we care only about lists, so this is the default\n        // get how many next bytes indicate the list length\n        byteLen := sub(byte0, 0xf7)\n\n        // move one over to the list length start\n        memPtrStart := add(memPtrStart, 1)\n\n        // shift over grabbing the bytelen elements\n        lenX := div(mload(memPtrStart), exp(256, sub(32, byteLen)))\n      }\n\n      // get the end\n      endPtr := add(memPtrStart, lenX)\n    }\n\n    uint256 ptr = _self.nextPtr;\n    uint256 itemLength = _itemLength(ptr);\n    _self.nextPtr = ptr + itemLength;\n\n    for (uint256 i; i < _skipToNum - 1; ) {\n      ptr = _self.nextPtr;\n      if (ptr > endPtr) revert MemoryOutOfBounds(endPtr);\n      itemLength = _itemLength(ptr);\n      _self.nextPtr = ptr + itemLength;\n\n      unchecked {\n        i++;\n      }\n    }\n\n    item.len = itemLength;\n    item.memPtr = ptr;\n  }\n\n  /**\n   * @dev Returns true if the iteration has more elements.\n   * @param _self The iterator.\n   * @return True if the iteration has more elements.\n   */\n  function _hasNext(Iterator memory _self) internal pure returns (bool) {\n    RLPItem memory item = _self.item;\n    return _self.nextPtr < item.memPtr + item.len;\n  }\n\n  /**\n   * @param item RLP encoded bytes.\n   * @return newItem The RLP item.\n   */\n  function _toRlpItem(bytes memory item) internal pure returns (RLPItem memory newItem) {\n    uint256 memPtr;\n\n    assembly {\n      memPtr := add(item, 0x20)\n    }\n\n    newItem.len = item.length;\n    newItem.memPtr = memPtr;\n  }\n\n  /**\n   * @dev Creates an iterator. Reverts if item is not a list.\n   * @param _self The RLP item.\n   * @return iterator 'Iterator' over the item.\n   */\n  function _iterator(RLPItem memory _self) internal pure returns (Iterator memory iterator) {\n    if (!_isList(_self)) {\n      revert NotList();\n    }\n\n    uint256 ptr = _self.memPtr + _payloadOffset(_self.memPtr);\n    iterator.item = _self;\n    iterator.nextPtr = ptr;\n  }\n\n  /**\n   * @param _item The RLP item.\n   * @return (memPtr, len) Tuple: Location of the item's payload in memory.\n   */\n  function _payloadLocation(RLPItem memory _item) internal pure returns (uint256, uint256) {\n    uint256 offset = _payloadOffset(_item.memPtr);\n    uint256 memPtr = _item.memPtr + offset;\n    uint256 len = _item.len - offset; // data length\n    return (memPtr, len);\n  }\n\n  /**\n   * @param _item The RLP item.\n   * @return Indicator whether encoded payload is a list.\n   */\n  function _isList(RLPItem memory _item) internal pure returns (bool) {\n    if (_item.len == 0) return false;\n\n    uint8 byte0;\n    uint256 memPtr = _item.memPtr;\n    assembly {\n      byte0 := byte(0, mload(memPtr))\n    }\n\n    if (byte0 < LIST_SHORT_START) return false;\n    return true;\n  }\n\n  /**\n   * @param _item The RLP item.\n   * @return result Returns the item as an address.\n   */\n  function _toAddress(RLPItem memory _item) internal pure returns (address) {\n    // 1 byte for the length prefix\n    if (_item.len != 21) {\n      revert WrongBytesLength();\n    }\n\n    return address(uint160(_toUint(_item)));\n  }\n\n  /**\n   * @param _item The RLP item.\n   * @return result Returns the item as a uint256.\n   */\n  function _toUint(RLPItem memory _item) internal pure returns (uint256 result) {\n    if (_item.len == 0 || _item.len > 33) {\n      revert WrongBytesLength();\n    }\n\n    (uint256 memPtr, uint256 len) = _payloadLocation(_item);\n\n    assembly {\n      result := mload(memPtr)\n\n      // Shfit to the correct location if neccesary.\n      if lt(len, 32) {\n        result := div(result, exp(256, sub(32, len)))\n      }\n    }\n  }\n\n  /**\n   * @param _item The RLP item.\n   * @return result Returns the item as bytes.\n   */\n  function _toBytes(RLPItem memory _item) internal pure returns (bytes memory result) {\n    if (_item.len == 0) {\n      revert WrongBytesLength();\n    }\n\n    (uint256 memPtr, uint256 len) = _payloadLocation(_item);\n    result = new bytes(len);\n\n    uint256 destPtr;\n    assembly {\n      destPtr := add(0x20, result)\n    }\n\n    _copy(memPtr, destPtr, len);\n  }\n\n  /*\n   * Private Helpers\n   */\n\n  /**\n   * @param _memPtr Item memory pointer.\n   * @return Entire RLP item byte length.\n   */\n  function _itemLength(uint256 _memPtr) private pure returns (uint256) {\n    uint256 itemLen;\n    uint256 dataLen;\n    uint256 byte0;\n    assembly {\n      byte0 := byte(0, mload(_memPtr))\n    }\n\n    if (byte0 < STRING_SHORT_START) itemLen = 1;\n    else if (byte0 < STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;\n    else if (byte0 < LIST_SHORT_START) {\n      assembly {\n        let byteLen := sub(byte0, 0xb7) // # Of bytes the actual length is.\n        _memPtr := add(_memPtr, 1) // Skip over the first byte.\n\n        /* 32 byte word size */\n        dataLen := div(mload(_memPtr), exp(256, sub(32, byteLen))) // Right shifting to get the len.\n        itemLen := add(dataLen, add(byteLen, 1))\n      }\n    } else if (byte0 < LIST_LONG_START) {\n      itemLen = byte0 - LIST_SHORT_START + 1;\n    } else {\n      assembly {\n        let byteLen := sub(byte0, 0xf7)\n        _memPtr := add(_memPtr, 1)\n\n        dataLen := div(mload(_memPtr), exp(256, sub(32, byteLen))) // Right shifting to the correct length.\n        itemLen := add(dataLen, add(byteLen, 1))\n      }\n    }\n\n    return itemLen;\n  }\n\n  /**\n   * @param _memPtr Item memory pointer.\n   * @return Number of bytes until the data.\n   */\n  function _payloadOffset(uint256 _memPtr) private pure returns (uint256) {\n    uint256 byte0;\n    assembly {\n      byte0 := byte(0, mload(_memPtr))\n    }\n\n    if (byte0 < STRING_SHORT_START) return 0;\n    else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) return 1;\n    else if (byte0 < LIST_SHORT_START)\n      // being explicit\n      return byte0 - (STRING_LONG_START - 1) + 1;\n    else return byte0 - (LIST_LONG_START - 1) + 1;\n  }\n\n  /**\n   * @param _src Pointer to source.\n   * @param _dest Pointer to destination.\n   * @param _len Amount of memory to copy from the source.\n   */\n  function _copy(uint256 _src, uint256 _dest, uint256 _len) private pure {\n    if (_len == 0) return;\n\n    // copy as many word sizes as possible\n    for (; _len >= WORD_SIZE; _len -= WORD_SIZE) {\n      assembly {\n        mstore(_dest, mload(_src))\n      }\n\n      _src += WORD_SIZE;\n      _dest += WORD_SIZE;\n    }\n\n    if (_len > 0) {\n      // Left over bytes. Mask is used to remove unwanted bytes from the word.\n      uint256 mask = 256 ** (WORD_SIZE - _len) - 1;\n      assembly {\n        let srcpart := and(mload(_src), not(mask)) // Zero out src.\n        let destpart := and(mload(_dest), mask) // Retrieve the bytes.\n        mstore(_dest, or(destpart, srcpart))\n      }\n    }\n  }\n}"
    }
  ]
}