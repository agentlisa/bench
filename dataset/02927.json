{
  "Title": "M-1: `abi.encodePacked` Allows Hash Collision",
  "Content": "# Issue M-1: `abi.encodePacked` Allows Hash Collision \n\nSource: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/118 \n\n## Found by \nkeccak123, 0xheynacho\n\n## Summary\n\nFrom the solidity documentation:\nhttps://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode\n    > If you use `keccak256(abi.encodePacked(a, b))` and both `a` and `b` are dynamic types, it is easy to craft collisions in the hash value by moving parts of `a` into `b` and vice-versa. More specifically, `abi.encodePacked(\"a\", \"bc\") == abi.encodePacked(\"ab\", \"c\")`.\n\nThis issue exists in the Factory contract can results in hash collisions, bypassing the `signedOnly` modifier.\n\n## Vulnerability Detail\n\nThe issue is in these lines of code:\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L171\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L195\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L222\n\nAs the solidity docs describe, two or more dynamic types are passed to `abi.encodePacked`. Moreover, these dynamic values are user-specified function arguments in external functions, meaning anyone can directly specify the value of these arguments when calling the function. The `signedOnly` modifier is supposed to protect functions to permit only function arguments that have been properly signed to be passed to the function logic, but because a collision can be created, the modifier can be bypassed for certain select inputs that result in the same `encodePacked` value.\n\n## Impact\n\nThe `signedOnly` modifier ([line 537](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L537)) is not effective because the modifier can be bypassed by different function arguments that result in the same signature when the values are `encodePacked` together. This can result in the submission of values that were not actually signed.\n\n## Code Snippet\n\nAll instances of `abi.encodePacked` in the contract pass multiple dynamic type arguments\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L171\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L195\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L222\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInstead of writing functions to accept several arguments that are hashed inside the function, consider rewriting the function to take the hashed value as a function argument directly so that the hashing process happens off-chain. This approach would solve the issue and save gas.\n\n## Discussion\n\n**Evert0x**\n\nDowngrading to medium severity, fails to show an exploit pattern.\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/18\n\n**rayn731**\n\nFixed, and it follows EIP-712 standard for hashing and signing data.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/14",
  "Code": [
    {
      "filename": "evm-minting-master/contracts/Factory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"./lib/ITemplate.sol\";\n\n/**\n * @title Factory\n * @notice Contract for managing contract templates, their implementations and deploying and calling template instances.\n * Uses {Clones} to deploy https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] compliant proxy contracts\n *\n * Upgradable contract, meaning it does not make use of a constructor but rather uses `initialize` with `initializer`\n * modifier, see {Initializable}\n *\n * Allows for registering new templates and delegating calls to deployed proxies.\n * Saves versions and names for each clone that can be deployed using this factory.\n *\n * Proxies can be deployed with a signature from an address with `SIGNER_ROLE` or by paying `deploymentFee`\n * Proxies can be called with a signature from an address with `SIGNER_ROLE` or by paying `callFee`\n */\ncontract Factory is AccessControlUpgradeable {\n    /*************\n     * Constants *\n     *************/\n\n    /// Contract code version\n    /// @dev Should follow semver-like format of `MAJOR_MINOR_PATCH`\n    uint256 public constant CODE_VERSION = 1_01_00;\n\n    /// Contract administrator role\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    /// Transaction signer role\n    bytes32 public constant SIGNER_ROLE = keccak256(\"SIGNER_ROLE\");\n\n    /**********\n     * Events *\n     **********/\n\n    /// A new version of a template implementation has been added to the Factory\n    event TemplateAdded(string name, uint256 version, address implementation);\n\n    /// An instance of a template has been deployed\n    event TemplateDeployed(string name, uint256 version, address destination);\n\n    /// Permissions for address `operator` to operate contract `instance` have changed to `allowed`\n    event OperatorChanged(address instance, address operator, bool allowed);\n\n    /***********\n     * Storage *\n     ***********/\n\n    /// Template names\n    string[] private _templateNames;\n\n    /// Latest template implementations for `_templateNames`\n    mapping(string => address) public latestImplementation;\n\n    /// Contracts that are whitelisted for proxy calls\n    mapping(address => bool) public whitelisted;\n\n    /// Deployment fee, used for deploying clones without a signature\n    uint256 public deploymentFee;\n\n    /// Call fee, used for calling clones without a signature\n    uint256 public callFee;\n\n    /// Current contract version\n    uint256 public version;\n\n    /// Latest template versions for `_templateNames`\n    mapping(string => uint256) public latestVersion;\n\n    /// All template versions for `_templateNames`\n    mapping(string => uint256[]) private _templateVersions;\n\n    /// Implementation addresses for all template versions\n    mapping(string => mapping(uint256 => address))\n        private _templateImplementations;\n\n    /****************************\n     * Contract init & upgrades *\n     ****************************/\n\n    /**\n     * @dev Empty constructor to disable direct initialization of this contract\n     */\n    constructor() initializer {}\n\n    /**\n     * Initialize the Factory\n     * @dev Callable only once\n     * @param factoryOwner The address that should be assigned ADMIN_ROLE\n     * @param factorySigner The address that should be assigned SIGNER_ROLE\n     */\n    function initialize(address factoryOwner, address factorySigner)\n        public\n        initializer\n    {\n        _grantRole(ADMIN_ROLE, factoryOwner);\n        _grantRole(SIGNER_ROLE, factorySigner);\n\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(SIGNER_ROLE, ADMIN_ROLE);\n    }\n\n    /**\n     * Perform any necessary state migrations between Factory versions\n     * @dev Callable by anyone but in practice will get called atomically when the Factory implementation is updated.\n     */\n    function upgrade() external {\n        require(version < CODE_VERSION, \"Already upgraded\");\n\n        /* Start migration code */\n        /* End migration code */\n\n        version = CODE_VERSION;\n    }\n\n    /***********\n     * Actions *\n     ***********/\n\n    /**\n     * Deploy an instance of the latest version of the specified template\n     * @dev Requires `deploymentFee` to be paid by the caller. Deprecated and will be removed.\n     * @param name The name of the template to be deployed\n     * @param initdata Payload for initializing the instance\n     */\n    function deploy(string calldata name, bytes calldata initdata)\n        external\n        payable\n        paidOnly(deploymentFee)\n    {\n        _deploy(name, latestVersion[name], initdata);\n    }\n\n    /**\n     * Call a deployed template instance\n     * @dev Requires `callFee` to be paid by the caller. Deprecated and will be removed.\n     * @param instance Address of the contract we want to call\n     * @param data Call data to be forwarded to the target contract\n     */\n    function call(address instance, bytes calldata data)\n        external\n        payable\n        operatorOnly(instance)\n        paidOnly(callFee)\n    {\n        _call(instance, data, msg.value - callFee);\n    }\n\n    /**\n     * Deploy the latest version of the specified template\n     * @dev Requires a signature of the deployment payload (caller, template name and initialization data) by a `SIGNER_ROLE` wallet. Deprecated and will be removed once the API has migrated to the version-specific deploy() method below.\n     * @param templateName Name of the template to be deployed\n     * @param initdata Payload for initializing the instance\n     * @param signature Signature for authorizing the deployment\n     */\n    function deploy(\n        string calldata templateName,\n        bytes calldata initdata,\n        bytes calldata signature\n    )\n        external\n        payable\n        signedOnly(\n            abi.encodePacked(msg.sender, templateName, initdata),\n            signature\n        )\n    {\n        _deploy(templateName, latestVersion[templateName], initdata);\n    }\n\n    /**\n     * Deploy a specific version of the specified template\n     * @dev Requires a signature of the deployment payload (caller, template name and initialization data) by a `SIGNER_ROLE` wallet\n     * @param templateName Name of the template to be deployed\n     * @param templateVersion Version to be deployed\n     * @param initdata Payload for initializing the instance\n     * @param signature Signature for authorizing the deployment\n     */\n    function deploy(\n        string calldata templateName,\n        uint256 templateVersion,\n        bytes calldata initdata,\n        bytes calldata signature\n    )\n        external\n        payable\n        signedOnly(\n            abi.encodePacked(\n                msg.sender,\n                templateName,\n                templateVersion,\n                initdata\n            ),\n            signature\n        )\n    {\n        _deploy(templateName, templateVersion, initdata);\n    }\n\n    /**\n     * Call a deployed template instance\n     * @dev Requires a signature of the call payload (caller, instance address and call data) by a `SIGNER_ROLE` wallet\n     * @param instance Address of the contract we want to call\n     * @param data Call data to be forwarded to the target contract\n     * @param signature Signature for authorizing the contract call\n     */\n    function call(\n        address instance,\n        bytes calldata data,\n        bytes calldata signature\n    )\n        external\n        payable\n        operatorOnly(instance)\n        signedOnly(abi.encodePacked(msg.sender, instance, data), signature)\n    {\n        _call(instance, data, msg.value);\n    }\n\n    /**\n     * Update the operator status of `instance` for `operator`\n     * @param instance The template instance that will be operated on\n     * @param operator The address of the operator that we want to update the status of\n     * @param allowed New operator status\n     */\n    function setOperator(\n        address instance,\n        address operator,\n        bool allowed\n    ) external operatorOnly(instance) {\n        require(msg.sender != operator, \"Cannot change own role\");\n\n        _setOperator(instance, operator, allowed);\n    }\n\n    /******************\n     * View functions *\n     ******************/\n\n    /**\n     * Get a list of all templates registered with the factory\n     * @return templateNames List of all template names that have been registered\n     */\n    function templates() external view returns (string[] memory templateNames) {\n        uint256 count = _templateNames.length;\n        templateNames = new string[](count);\n\n        for (uint256 i = 0; i < count; i++) {\n            templateNames[i] = _templateNames[i];\n        }\n    }\n\n    /**\n     * Get a list of all registered versions of a template\n     * @param templateName Name of the template\n     * @return templateVersions List of all version numbers that have been registered for that template\n     */\n    function versions(string memory templateName)\n        external\n        view\n        returns (uint256[] memory templateVersions)\n    {\n        uint256 count = _templateVersions[templateName].length;\n        templateVersions = new uint256[](count);\n\n        for (uint256 i = 0; i < count; i++) {\n            templateVersions[i] = _templateVersions[templateName][i];\n        }\n    }\n\n    /**\n     * Get the implementation address of a specific version of a template\n     * @param templateName Name of the template\n     * @param templateVersion Version of the implementation\n     * @return Address of the implementation contract\n     */\n    function implementation(string memory templateName, uint256 templateVersion)\n        external\n        view\n        returns (address)\n    {\n        return _templateImplementations[templateName][templateVersion];\n    }\n\n    /**\n     * Check if the `operator` address is allowed to operate on template instance `instance`\n     * @param instance Address of the template instance\n     * @param operator Address of the operator\n     */\n    function isOperator(address instance, address operator)\n        public\n        view\n        returns (bool)\n    {\n        return hasRole(OPERATOR_ROLE(instance), operator);\n    }\n\n    /**\n     * Update template instance deployment fee\n     * @dev Deprecated\n     * @param newFee New deployment fee\n     */\n    function setDeploymentFee(uint256 newFee) external onlyRole(ADMIN_ROLE) {\n        deploymentFee = newFee;\n    }\n\n    /**\n     * Update template instance call fee\n     * @dev deprecated\n     * @param newFee New call fee\n     */\n    function setCallFee(uint256 newFee) external onlyRole(ADMIN_ROLE) {\n        callFee = newFee;\n    }\n\n    /**\n     * Get the operator role for the specified instance\n     * @param instance Address of the template instance that the role will be operating on\n     * @return Operator role identifier\n     */\n    function OPERATOR_ROLE(address instance) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(instance, \"OPERATOR\"));\n    }\n\n    /*******************\n     * Admin functions *\n     *******************/\n\n    /**\n     * Register a new implementation with the Factory\n     * @dev Implementation details will be read and validated on-chain\n     * @param implementationAddress Address of the template implementation contract\n     */\n    function registerTemplate(address implementationAddress)\n        public\n        onlyRole(ADMIN_ROLE)\n    {\n        require(\n            Address.isContract(implementationAddress),\n            \"Not a valid contract\"\n        );\n\n        // Read template information from the implementation contract\n        ITemplate templateImplementation = ITemplate(implementationAddress);\n        string memory templateName = templateImplementation.NAME();\n        uint256 templateVersion = templateImplementation.VERSION();\n\n        // Store the template information\n        _setTemplate(templateName, templateVersion, implementationAddress);\n    }\n\n    /**\n     * Update contract whitelist status\n     * @dev For security reasons, we don't allow arbitrary contracts to be called via Factory. Contracts deployed via the Factory will be automatically whitelisted. This function is intended to allow us to disable any contracts that turn out to be vulnerable or malicious.\n     * @param instance Contract address\n     * @param newStatus New whitelist status\n     */\n    function setWhitelisted(address instance, bool newStatus)\n        external\n        onlyRole(ADMIN_ROLE)\n    {\n        _setWhitelisted(instance, newStatus);\n    }\n\n    /**\n     * Withdraw all fees from the contract to an address\n     * @dev Deprecated, originally intended for withdrawing deplyment and call fees.\n     */\n    function withdrawFees(address to) external onlyRole(ADMIN_ROLE) {\n        Address.sendValue(payable(to), address(this).balance);\n    }\n\n    /*************\n     * Internals *\n     *************/\n\n    /**\n     * @dev Internal function without access rights checks for storing template implemetation details\n     * @param templateName Name of the template\n     * @param templateVersion Template version\n     * @param implementationAddress Address of the implementation contract\n     */\n    function _setTemplate(\n        string memory templateName,\n        uint256 templateVersion,\n        address implementationAddress\n    ) internal {\n        require(\n            _templateImplementations[templateName][templateVersion] ==\n                address(0),\n            \"Version already exists\"\n        );\n\n        // Store the template implementation address\n        _templateImplementations[templateName][\n            templateVersion\n        ] = implementationAddress;\n\n        // Update the list of available versions for a template\n        _templateVersions[templateName].push(templateVersion);\n\n        // Check if we're adding a new template and update template list if needed\n        if (latestImplementation[templateName] == address(0)) {\n            _templateNames.push(templateName);\n        }\n\n        // Update the current implementation version & address if needed\n        if (templateVersion > latestVersion[templateName]) {\n            latestVersion[templateName] = templateVersion;\n            latestImplementation[templateName] = implementationAddress;\n        }\n\n        emit TemplateAdded(\n            templateName,\n            templateVersion,\n            implementationAddress\n        );\n    }\n\n    /**\n     * @dev Internal function for updating whitelist status\n     * @param instance Contract address\n     * @param newStatus New whitelist status\n     */\n    function _setWhitelisted(address instance, bool newStatus) internal {\n        whitelisted[instance] = newStatus;\n    }\n\n    /**\n     * @dev Internal function for granting or revoking contract operator role from an address\n     * @param instance Contract address\n     * @param operator Operator address\n     * @param allowed New operator status\n     */\n    function _setOperator(\n        address instance,\n        address operator,\n        bool allowed\n    ) internal {\n        if (allowed) {\n            _grantRole(OPERATOR_ROLE(instance), operator);\n        } else {\n            _revokeRole(OPERATOR_ROLE(instance), operator);\n        }\n\n        emit OperatorChanged(instance, operator, allowed);\n    }\n\n    /**\n     * @dev Internal function for deploying a template instance\n     * @param templateName Name of the template to be deployed\n     * @param templateVersion Version of the template implementation\n     * @param initdata Initialization data for the newly deployed instance\n     */\n    function _deploy(\n        string calldata templateName,\n        uint256 templateVersion,\n        bytes calldata initdata\n    ) internal {\n        address implementationAddress = _templateImplementations[templateName][\n            templateVersion\n        ];\n        require(implementationAddress != address(0), \"Missing implementation\");\n\n        address clone = Clones.clone(implementationAddress);\n        emit TemplateDeployed(templateName, templateVersion, clone);\n\n        _setOperator(clone, msg.sender, true);\n        _setWhitelisted(clone, true);\n\n        _call(clone, initdata, 0);\n    }\n\n    /**\n     * @dev Internal function for calling a template instance\n     * @param instance Address of the template instance\n     * @param data Call data to be forwarded to the instance\n     * @param value Fees to be forwarded with the call\n     */\n    function _call(\n        address instance,\n        bytes calldata data,\n        uint256 value\n    ) internal {\n        require(whitelisted[instance], \"Contract not whitelisted\");\n\n        assembly {\n            let _calldata := mload(0x40)\n            calldatacopy(_calldata, data.offset, data.length)\n\n            let result := call(\n                gas(),\n                instance,\n                value,\n                _calldata,\n                data.length,\n                0,\n                0\n            )\n\n            let returndata := mload(0x40)\n            let size := returndatasize()\n            returndatacopy(returndata, 0, size)\n\n            switch result\n            case 0 {\n                revert(returndata, size)\n            }\n            default {\n                return(returndata, size)\n            }\n        }\n    }\n\n    /*************\n     * Modifiers *\n     *************/\n\n    /**\n     * @dev Modifier for restricting the caller to be an operator of contract at address `instance`\n     */\n    modifier operatorOnly(address instance) {\n        require(isOperator(instance, msg.sender), \"Access denied\");\n        _;\n    }\n\n    /**\n     * @dev Modifier for checking if `signature` is a valid signature of `message` by a `SIGNER_ROLE` wallet\n     */\n    modifier signedOnly(bytes memory message, bytes calldata signature) {\n        // Gets the address that signed the message with signature\n        address messageSigner = ECDSA.recover(\n            ECDSA.toEthSignedMessageHash(message),\n            signature\n        );\n\n        require(hasRole(SIGNER_ROLE, messageSigner), \"Signer not recognized\");\n\n        _;\n    }\n\n    /**\n     * @dev Modifier for enforcing a minimum payment for the function call\n     */\n    modifier paidOnly(uint256 fee) {\n        require(msg.value >= fee, \"Insufficient payment\");\n        _;\n    }\n}"
    },
    {
      "filename": "evm-minting-master/contracts/Factory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"./lib/ITemplate.sol\";\n\n/**\n * @title Factory\n * @notice Contract for managing contract templates, their implementations and deploying and calling template instances.\n * Uses {Clones} to deploy https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] compliant proxy contracts\n *\n * Upgradable contract, meaning it does not make use of a constructor but rather uses `initialize` with `initializer`\n * modifier, see {Initializable}\n *\n * Allows for registering new templates and delegating calls to deployed proxies.\n * Saves versions and names for each clone that can be deployed using this factory.\n *\n * Proxies can be deployed with a signature from an address with `SIGNER_ROLE` or by paying `deploymentFee`\n * Proxies can be called with a signature from an address with `SIGNER_ROLE` or by paying `callFee`\n */\ncontract Factory is AccessControlUpgradeable {\n    /*************\n     * Constants *\n     *************/\n\n    /// Contract code version\n    /// @dev Should follow semver-like format of `MAJOR_MINOR_PATCH`\n    uint256 public constant CODE_VERSION = 1_01_00;\n\n    /// Contract administrator role\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    /// Transaction signer role\n    bytes32 public constant SIGNER_ROLE = keccak256(\"SIGNER_ROLE\");\n\n    /**********\n     * Events *\n     **********/\n\n    /// A new version of a template implementation has been added to the Factory\n    event TemplateAdded(string name, uint256 version, address implementation);\n\n    /// An instance of a template has been deployed\n    event TemplateDeployed(string name, uint256 version, address destination);\n\n    /// Permissions for address `operator` to operate contract `instance` have changed to `allowed`\n    event OperatorChanged(address instance, address operator, bool allowed);\n\n    /***********\n     * Storage *\n     ***********/\n\n    /// Template names\n    string[] private _templateNames;\n\n    /// Latest template implementations for `_templateNames`\n    mapping(string => address) public latestImplementation;\n\n    /// Contracts that are whitelisted for proxy calls\n    mapping(address => bool) public whitelisted;\n\n    /// Deployment fee, used for deploying clones without a signature\n    uint256 public deploymentFee;\n\n    /// Call fee, used for calling clones without a signature\n    uint256 public callFee;\n\n    /// Current contract version\n    uint256 public version;\n\n    /// Latest template versions for `_templateNames`\n    mapping(string => uint256) public latestVersion;\n\n    /// All template versions for `_templateNames`\n    mapping(string => uint256[]) private _templateVersions;\n\n    /// Implementation addresses for all template versions\n    mapping(string => mapping(uint256 => address))\n        private _templateImplementations;\n\n    /****************************\n     * Contract init & upgrades *\n     ****************************/\n\n    /**\n     * @dev Empty constructor to disable direct initialization of this contract\n     */\n    constructor() initializer {}\n\n    /**\n     * Initialize the Factory\n     * @dev Callable only once\n     * @param factoryOwner The address that should be assigned ADMIN_ROLE\n     * @param factorySigner The address that should be assigned SIGNER_ROLE\n     */\n    function initialize(address factoryOwner, address factorySigner)\n        public\n        initializer\n    {\n        _grantRole(ADMIN_ROLE, factoryOwner);\n        _grantRole(SIGNER_ROLE, factorySigner);\n\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(SIGNER_ROLE, ADMIN_ROLE);\n    }\n\n    /**\n     * Perform any necessary state migrations between Factory versions\n     * @dev Callable by anyone but in practice will get called atomically when the Factory implementation is updated.\n     */\n    function upgrade() external {\n        require(version < CODE_VERSION, \"Already upgraded\");\n\n        /* Start migration code */\n        /* End migration code */\n\n        version = CODE_VERSION;\n    }\n\n    /***********\n     * Actions *\n     ***********/\n\n    /**\n     * Deploy an instance of the latest version of the specified template\n     * @dev Requires `deploymentFee` to be paid by the caller. Deprecated and will be removed.\n     * @param name The name of the template to be deployed\n     * @param initdata Payload for initializing the instance\n     */\n    function deploy(string calldata name, bytes calldata initdata)\n        external\n        payable\n        paidOnly(deploymentFee)\n    {\n        _deploy(name, latestVersion[name], initdata);\n    }\n\n    /**\n     * Call a deployed template instance\n     * @dev Requires `callFee` to be paid by the caller. Deprecated and will be removed.\n     * @param instance Address of the contract we want to call\n     * @param data Call data to be forwarded to the target contract\n     */\n    function call(address instance, bytes calldata data)\n        external\n        payable\n        operatorOnly(instance)\n        paidOnly(callFee)\n    {\n        _call(instance, data, msg.value - callFee);\n    }\n\n    /**\n     * Deploy the latest version of the specified template\n     * @dev Requires a signature of the deployment payload (caller, template name and initialization data) by a `SIGNER_ROLE` wallet. Deprecated and will be removed once the API has migrated to the version-specific deploy() method below.\n     * @param templateName Name of the template to be deployed\n     * @param initdata Payload for initializing the instance\n     * @param signature Signature for authorizing the deployment\n     */\n    function deploy(\n        string calldata templateName,\n        bytes calldata initdata,\n        bytes calldata signature\n    )\n        external\n        payable\n        signedOnly(\n            abi.encodePacked(msg.sender, templateName, initdata),\n            signature\n        )\n    {\n        _deploy(templateName, latestVersion[templateName], initdata);\n    }\n\n    /**\n     * Deploy a specific version of the specified template\n     * @dev Requires a signature of the deployment payload (caller, template name and initialization data) by a `SIGNER_ROLE` wallet\n     * @param templateName Name of the template to be deployed\n     * @param templateVersion Version to be deployed\n     * @param initdata Payload for initializing the instance\n     * @param signature Signature for authorizing the deployment\n     */\n    function deploy(\n        string calldata templateName,\n        uint256 templateVersion,\n        bytes calldata initdata,\n        bytes calldata signature\n    )\n        external\n        payable\n        signedOnly(\n            abi.encodePacked(\n                msg.sender,\n                templateName,\n                templateVersion,\n                initdata\n            ),\n            signature\n        )\n    {\n        _deploy(templateName, templateVersion, initdata);\n    }\n\n    /**\n     * Call a deployed template instance\n     * @dev Requires a signature of the call payload (caller, instance address and call data) by a `SIGNER_ROLE` wallet\n     * @param instance Address of the contract we want to call\n     * @param data Call data to be forwarded to the target contract\n     * @param signature Signature for authorizing the contract call\n     */\n    function call(\n        address instance,\n        bytes calldata data,\n        bytes calldata signature\n    )\n        external\n        payable\n        operatorOnly(instance)\n        signedOnly(abi.encodePacked(msg.sender, instance, data), signature)\n    {\n        _call(instance, data, msg.value);\n    }\n\n    /**\n     * Update the operator status of `instance` for `operator`\n     * @param instance The template instance that will be operated on\n     * @param operator The address of the operator that we want to update the status of\n     * @param allowed New operator status\n     */\n    function setOperator(\n        address instance,\n        address operator,\n        bool allowed\n    ) external operatorOnly(instance) {\n        require(msg.sender != operator, \"Cannot change own role\");\n\n        _setOperator(instance, operator, allowed);\n    }\n\n    /******************\n     * View functions *\n     ******************/\n\n    /**\n     * Get a list of all templates registered with the factory\n     * @return templateNames List of all template names that have been registered\n     */\n    function templates() external view returns (string[] memory templateNames) {\n        uint256 count = _templateNames.length;\n        templateNames = new string[](count);\n\n        for (uint256 i = 0; i < count; i++) {\n            templateNames[i] = _templateNames[i];\n        }\n    }\n\n    /**\n     * Get a list of all registered versions of a template\n     * @param templateName Name of the template\n     * @return templateVersions List of all version numbers that have been registered for that template\n     */\n    function versions(string memory templateName)\n        external\n        view\n        returns (uint256[] memory templateVersions)\n    {\n        uint256 count = _templateVersions[templateName].length;\n        templateVersions = new uint256[](count);\n\n        for (uint256 i = 0; i < count; i++) {\n            templateVersions[i] = _templateVersions[templateName][i];\n        }\n    }\n\n    /**\n     * Get the implementation address of a specific version of a template\n     * @param templateName Name of the template\n     * @param templateVersion Version of the implementation\n     * @return Address of the implementation contract\n     */\n    function implementation(string memory templateName, uint256 templateVersion)\n        external\n        view\n        returns (address)\n    {\n        return _templateImplementations[templateName][templateVersion];\n    }\n\n    /**\n     * Check if the `operator` address is allowed to operate on template instance `instance`\n     * @param instance Address of the template instance\n     * @param operator Address of the operator\n     */\n    function isOperator(address instance, address operator)\n        public\n        view\n        returns (bool)\n    {\n        return hasRole(OPERATOR_ROLE(instance), operator);\n    }\n\n    /**\n     * Update template instance deployment fee\n     * @dev Deprecated\n     * @param newFee New deployment fee\n     */\n    function setDeploymentFee(uint256 newFee) external onlyRole(ADMIN_ROLE) {\n        deploymentFee = newFee;\n    }\n\n    /**\n     * Update template instance call fee\n     * @dev deprecated\n     * @param newFee New call fee\n     */\n    function setCallFee(uint256 newFee) external onlyRole(ADMIN_ROLE) {\n        callFee = newFee;\n    }\n\n    /**\n     * Get the operator role for the specified instance\n     * @param instance Address of the template instance that the role will be operating on\n     * @return Operator role identifier\n     */\n    function OPERATOR_ROLE(address instance) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(instance, \"OPERATOR\"));\n    }\n\n    /*******************\n     * Admin functions *\n     *******************/\n\n    /**\n     * Register a new implementation with the Factory\n     * @dev Implementation details will be read and validated on-chain\n     * @param implementationAddress Address of the template implementation contract\n     */\n    function registerTemplate(address implementationAddress)\n        public\n        onlyRole(ADMIN_ROLE)\n    {\n        require(\n            Address.isContract(implementationAddress),\n            \"Not a valid contract\"\n        );\n\n        // Read template information from the implementation contract\n        ITemplate templateImplementation = ITemplate(implementationAddress);\n        string memory templateName = templateImplementation.NAME();\n        uint256 templateVersion = templateImplementation.VERSION();\n\n        // Store the template information\n        _setTemplate(templateName, templateVersion, implementationAddress);\n    }\n\n    /**\n     * Update contract whitelist status\n     * @dev For security reasons, we don't allow arbitrary contracts to be called via Factory. Contracts deployed via the Factory will be automatically whitelisted. This function is intended to allow us to disable any contracts that turn out to be vulnerable or malicious.\n     * @param instance Contract address\n     * @param newStatus New whitelist status\n     */\n    function setWhitelisted(address instance, bool newStatus)\n        external\n        onlyRole(ADMIN_ROLE)\n    {\n        _setWhitelisted(instance, newStatus);\n    }\n\n    /**\n     * Withdraw all fees from the contract to an address\n     * @dev Deprecated, originally intended for withdrawing deplyment and call fees.\n     */\n    function withdrawFees(address to) external onlyRole(ADMIN_ROLE) {\n        Address.sendValue(payable(to), address(this).balance);\n    }\n\n    /*************\n     * Internals *\n     *************/\n\n    /**\n     * @dev Internal function without access rights checks for storing template implemetation details\n     * @param templateName Name of the template\n     * @param templateVersion Template version\n     * @param implementationAddress Address of the implementation contract\n     */\n    function _setTemplate(\n        string memory templateName,\n        uint256 templateVersion,\n        address implementationAddress\n    ) internal {\n        require(\n            _templateImplementations[templateName][templateVersion] ==\n                address(0),\n            \"Version already exists\"\n        );\n\n        // Store the template implementation address\n        _templateImplementations[templateName][\n            templateVersion\n        ] = implementationAddress;\n\n        // Update the list of available versions for a template\n        _templateVersions[templateName].push(templateVersion);\n\n        // Check if we're adding a new template and update template list if needed\n        if (latestImplementation[templateName] == address(0)) {\n            _templateNames.push(templateName);\n        }\n\n        // Update the current implementation version & address if needed\n        if (templateVersion > latestVersion[templateName]) {\n            lat"
    }
  ]
}