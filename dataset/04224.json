{
  "Title": "[C03] Proxy admin doesn’t entirely cede upgrade control to governance address",
  "Content": "In the [`AudiusAdminUpgradeabilityProxy` contract](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/AudiusAdminUpgradeabilityProxy.sol#L11), the [inline documentation](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/AudiusAdminUpgradeabilityProxy.sol#L18-L19) states that the proxy admin cedes upgrades control to the governance address, which is achieved by [overloading the `upgradeTo` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/AudiusAdminUpgradeabilityProxy.sol#L41-L47) of the parent contracts.  \n\nHowever, the contract does not overload the `upgradeToAndCall` function from [the OpenZeppelin’s `BaseAdminUpgradeabilityProxy` contract](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.8.0/packages/lib/contracts/upgradeability/BaseAdminUpgradeabilityProxy.sol#L13), allowing the deployer admin to bypass the governance and control the upgrades.\n\n\nThis is dangerous, as it gives the admin’s private key holder the possibility to upgrade the whole protocol without a proper governance’s consent. Furthermore, if the private key gets leaked after the deployment, it will allow any third party to modify the Audius bytecode on-chain.\n\n\nConsider modifying the current implementation to discard the upgrade permissions given to the admin address. Also, consider inheriting from a lower-level abstraction rather than overwriting existing functionality from a higher-level one. Finally, consider validating that the implementation contract does not have a signature clash with the proxy.\n\n\n***Update**: Fixed in pull request [#657](https://github.com/AudiusProject/audius-protocol/pull/657).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "eth-contracts/contracts/AudiusAdminUpgradeabilityProxy.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/upgradeability/AdminUpgradeabilityProxy.sol\";\n\n\n/**\n * Wrapper around OpenZeppelin's AdminUpgradeabilityProxy contract.\n * Permissions proxy upgrade logic to Audius Governance contract.\n * https://github.com/OpenZeppelin/openzeppelin-sdk/blob/release/2.8/packages/lib/contracts/upgradeability/AdminUpgradeabilityProxy.sol\n */\ncontract AudiusAdminUpgradeabilityProxy is AdminUpgradeabilityProxy {\n    address governanceAddress;\n\n    /**\n     * @notice Sets governance address for future upgrades\n     * @param _logic - address of underlying logic contract.\n     *      Passed to AdminUpgradeabilityProxy constructor.\n     * @param _proxyAdmin - address of proxy admin, but cedes upgrade control to _governanceAddress.\n     *      Passed to AdminUpgradeabilityProxy constructor.\n     * @param _data - data of function to be called on logic contract.\n     *      Passed to AdminUpgradeabilityProxy constructor.\n     * @param _governanceAddress - address of Audius governance contract, which has proxy upgrade control.\n     */\n    constructor(\n      address _logic,\n      address _proxyAdmin,\n      bytes memory _data,\n      address _governanceAddress\n    )\n    AdminUpgradeabilityProxy(_logic, _proxyAdmin, _data) public payable\n    {\n        governanceAddress = _governanceAddress;\n    }\n\n    /**\n     * @notice Upgrade the address of the logic contract for this proxy\n     * @dev Wrapper on AdminUpgradeabilityProxy._upgradeTo.\n     *      Adds a check to ensure msg.sender is the Audius Governance contract.\n     * @param _newImplementation - new address of logic contract that the proxy will point to\n     */\n    function upgradeTo(address _newImplementation) external {\n        require(\n            msg.sender == governanceAddress,\n            \"Caller must be current proxy governance address\"\n        );\n        _upgradeTo(_newImplementation);\n    }\n\n    /// @notice Returns the Audius governance address\n    function getAudiusGovernanceAddress() external view returns (address) {\n        return governanceAddress;\n    }\n\n    /**\n     * @notice Set the Audius Governance address\n     * @dev Callable by admin if governance address not yet set, else by Governance\n     * @param _governanceAddress - address of Governance contract\n     */\n    function setAudiusGovernanceAddress(address _governanceAddress) external {\n        require(\n            msg.sender == governanceAddress ||\n            (governanceAddress == address(0x0) && msg.sender == _admin()),\n            \"Caller must be proxy admin or proxy upgrader\"\n        );\n        governanceAddress = _governanceAddress;\n    }\n}"
    },
    {
      "filename": "packages/lib/contracts/upgradeability/BaseAdminUpgradeabilityProxy.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport './UpgradeabilityProxy.sol';\n\n/**\n * @title BaseAdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @return The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address) {\n    return _admin();\n  }\n\n  /**\n   * @return The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address) {\n    return _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n    _upgradeTo(newImplementation);\n    (bool success,) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @return The admin slot.\n   */\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n  function _setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal {\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n    super._willFallback();\n  }\n}"
    }
  ]
}