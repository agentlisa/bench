{
  "Title": "H-3: Underestimated gas estimation for executing withdrawals leads to insufficient keeper compensation",
  "Content": "# Issue H-3: Underestimated gas estimation for executing withdrawals leads to insufficient keeper compensation \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/195 \n\n## Found by \n0xAmanda, berndartmueller, bin2chen, rvierdiiev\n\n## Summary\n\nThe `GasUtils.estimateExecuteWithdrawalGasLimit` function underestimates the gas estimation for withdrawal execution, as it does not take into account token swaps, unlike the gas estimation in the `GasUtils.estimateExecuteDepositGasLimit` function (used to estimate executing deposits).\n\n## Vulnerability Detail\n\nWhen creating a withdrawal request, the `WithdrawalUtils.createWithdrawal` function estimates the gas required to execute the withdrawal and validates that the paid execution fee (`params.executionFee`) is sufficient to cover the estimated gas and to compensate the keeper executing the withdrawal fairly.\n\nHowever, the `GasUtils.estimateExecuteWithdrawalGasLimit` function used to estimate the gas for executing withdrawals does not account for token swaps that can occur at the end of the withdrawal logic and therefore underestimates the gas estimation.\n\nToken swaps are performed in the `WithdrawalUtils._executeWithdrawal` function in lines 354 and 365.\n\n## Impact\n\nThe keeper executing withdrawals receives fewer execution fees and is not fully compensated for the gas spent. Moreover, users can pay fewer execution fees than expected and required.\n\n## Code Snippet\n\n[contracts/gas/GasUtils.sol#L150](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/gas/GasUtils.sol#L150)\n\nThe gas estimate calculated in the `GasUtils.estimateExecuteWithdrawalGasLimit` function only uses a static gas limit plus the callback gas limit. Token swaps are not accounted for.\n\n```solidity\n149: function estimateExecuteWithdrawalGasLimit(DataStore dataStore, Withdrawal.Props memory withdrawal) internal view returns (uint256) {\n150:     return dataStore.getUint(Keys.withdrawalGasLimitKey(false)) + withdrawal.callbackGasLimit();\n151: }\n```\n\n[contracts/withdrawal/WithdrawalUtils.createWithdrawal() - L163](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/withdrawal/WithdrawalUtils.sol#L163)\n\nAs observed in the `createWithdrawal` function, the `GasUtils.estimateExecuteWithdrawalGasLimit` function estimates the gas required to execute the withdrawal and validates the paid execution fee accordingly.\n\n```solidity\n110: function createWithdrawal(\n111:     DataStore dataStore,\n112:     EventEmitter eventEmitter,\n113:     WithdrawalVault withdrawalVault,\n114:     address account,\n115:     CreateWithdrawalParams memory params\n116: ) external returns (bytes32) {\n...      // [...]\n160:\n161:     CallbackUtils.validateCallbackGasLimit(dataStore, withdrawal.callbackGasLimit());\n162:\n163:     uint256 estimatedGasLimit = GasUtils.estimateExecuteWithdrawalGasLimit(dataStore, withdrawal);\n164:     GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, params.executionFee);\n165:\n166:     bytes32 key = NonceUtils.getNextKey(dataStore);\n167:\n168:     WithdrawalStoreUtils.set(dataStore, key, withdrawal);\n169:\n170:     WithdrawalEventUtils.emitWithdrawalCreated(eventEmitter, key, withdrawal);\n171:\n172:     return key;\n173: }\n```\n\n[contracts/withdrawal/WithdrawalUtils.executeWithdrawal() - L206-L213](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/withdrawal/WithdrawalUtils.sol#L206-L213)\n\nThe execution fee is paid to the keeper at the end of the `executeWithdrawal` function.\n\n```solidity\n180: function executeWithdrawal(ExecuteWithdrawalParams memory params) external {\n181:     Withdrawal.Props memory withdrawal = WithdrawalStoreUtils.get(params.dataStore, params.key);\n...      // [...]\n205:\n206:     GasUtils.payExecutionFee(\n207:         params.dataStore,\n208:         params.withdrawalVault,\n209:         withdrawal.executionFee(),\n210:         params.startingGas,\n211:         params.keeper,\n212:         withdrawal.account()\n213:     );\n214: }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider incorporating the token swaps in the gas estimation for withdrawal execution, similar to how it is done in the `GasUtils.estimateExecuteDepositGasLimit` function.\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/commit/5cd83aaf9104aa6d826bc6676ac494e79db8cbd4\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/gas/GasUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\nimport \"../utils/Precision.sol\";\n\nimport \"../deposit/Deposit.sol\";\nimport \"../withdrawal/Withdrawal.sol\";\nimport \"../order/Order.sol\";\nimport \"../order/BaseOrderUtils.sol\";\n\nimport \"../bank/StrictBank.sol\";\n\n// @title GasUtils\n// @dev Library for execution fee estimation and payments\nlibrary GasUtils {\n    using Deposit for Deposit.Props;\n    using Withdrawal for Withdrawal.Props;\n    using Order for Order.Props;\n\n    // @param keeper address of the keeper\n    // @param amount the amount of execution fee received\n    event KeeperExecutionFee(address keeper, uint256 amount);\n    // @param user address of the user\n    // @param amount the amount of execution fee refunded\n    event UserRefundFee(address user, uint256 amount);\n\n    error InsufficientExecutionFee(uint256 minExecutionFee, uint256 executionFee);\n    error EmptyHoldingAddress();\n\n    // @dev pay the keeper the execution fee and refund any excess amount to the user\n    //\n    // @param dataStore DataStore\n    // @param bank the StrictBank contract holding the execution fee\n    // @param executionFee the executionFee amount\n    // @param startingGas the starting gas\n    // @param keeper the keeper to pay\n    // @param user the user to refund\n    function payExecutionFee(\n        DataStore dataStore,\n        StrictBank bank,\n        uint256 executionFee,\n        uint256 startingGas,\n        address keeper,\n        address user\n    ) external {\n        uint256 gasUsed = startingGas - gasleft();\n        uint256 executionFeeForKeeper = adjustGasUsage(dataStore, gasUsed) * tx.gasprice;\n\n        if (executionFeeForKeeper > executionFee) {\n            executionFeeForKeeper = executionFee;\n        }\n\n        bank.transferOutNativeToken(\n            keeper,\n            executionFeeForKeeper\n        );\n\n        emit KeeperExecutionFee(keeper, executionFeeForKeeper);\n\n        uint256 refundFeeForUser = executionFee - executionFeeForKeeper;\n        if (refundFeeForUser == 0) {\n            return;\n        }\n\n        bank.transferOutNativeToken(\n            user,\n            refundFeeForUser\n        );\n\n        emit UserRefundFee(user, refundFeeForUser);\n    }\n\n    // @dev validate that the provided executionFee is sufficient based on the estimatedGasLimit\n    // @param dataStore DataStore\n    // @param estimatedGasLimit the estimated gas limit\n    // @param executionFee the execution fee provided\n    function validateExecutionFee(DataStore dataStore, uint256 estimatedGasLimit, uint256 executionFee) internal view {\n        uint256 gasLimit = adjustGasLimitForEstimate(dataStore, estimatedGasLimit);\n        uint256 minExecutionFee = gasLimit * tx.gasprice;\n        if (executionFee < minExecutionFee) {\n            revert InsufficientExecutionFee(minExecutionFee, executionFee);\n        }\n    }\n\n    function handleExcessExecutionFee(\n        DataStore dataStore,\n        StrictBank bank,\n        uint256 wntAmount,\n        uint256 executionFee\n    ) internal {\n        uint256 excessWntAmount = wntAmount - executionFee;\n        if (excessWntAmount > 0) {\n            address holdingAddress = dataStore.getAddress(Keys.HOLDING_ACCOUNT);\n            if (holdingAddress == address(0)) {\n                revert EmptyHoldingAddress();\n            }\n\n            address wnt = TokenUtils.wnt(dataStore);\n            bank.transferOut(\n                wnt,\n                holdingAddress,\n                excessWntAmount\n            );\n        }\n    }\n\n    // @dev adjust the gas usage to pay a small amount to keepers\n    // @param dataStore DataStore\n    // @param gasUsed the amount of gas used\n    function adjustGasUsage(DataStore dataStore, uint256 gasUsed) internal view returns (uint256) {\n        uint256 baseGasLimit = dataStore.getUint(Keys.EXECUTION_GAS_FEE_BASE_AMOUNT);\n        uint256 multiplierFactor = dataStore.getUint(Keys.EXECUTION_GAS_FEE_MULTIPLIER_FACTOR);\n        uint256 gasLimit = baseGasLimit + Precision.applyFactor(gasUsed, multiplierFactor);\n        return gasLimit;\n    }\n\n    // @dev adjust the estimated gas limit to help ensure the execution fee is sufficient during\n    // the actual execution\n    // @param dataStore DataStore\n    // @param estimatedGasLimit the estimated gas limit\n    function adjustGasLimitForEstimate(DataStore dataStore, uint256 estimatedGasLimit) internal view returns (uint256) {\n        uint256 baseGasLimit = dataStore.getUint(Keys.ESTIMATED_GAS_FEE_BASE_AMOUNT);\n        uint256 multiplierFactor = dataStore.getUint(Keys.ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR);\n        uint256 gasLimit = baseGasLimit + Precision.applyFactor(estimatedGasLimit, multiplierFactor);\n        return gasLimit;\n    }\n\n    // @dev the estimated gas limit for deposits\n    // @param dataStore DataStore\n    // @param deposit the deposit to estimate the gas limit for\n    function estimateExecuteDepositGasLimit(DataStore dataStore, Deposit.Props memory deposit) internal view returns (uint256) {\n        uint256 gasPerSwap = dataStore.getUint(Keys.singleSwapGasLimitKey());\n        uint256 swapCount = deposit.longTokenSwapPath().length + deposit.shortTokenSwapPath().length;\n        uint256 gasForSwaps = swapCount * gasPerSwap;\n\n        if (deposit.initialLongTokenAmount() == 0 || deposit.initialShortTokenAmount() == 0) {\n            return dataStore.getUint(Keys.depositGasLimitKey(true)) + deposit.callbackGasLimit() + gasForSwaps;\n        }\n\n        return dataStore.getUint(Keys.depositGasLimitKey(false)) + deposit.callbackGasLimit() + gasForSwaps;\n    }\n\n    // @dev the estimated gas limit for withdrawals\n    // @param dataStore DataStore\n    // @param withdrawal the withdrawal to estimate the gas limit for\n    function estimateExecuteWithdrawalGasLimit(DataStore dataStore, Withdrawal.Props memory withdrawal) internal view returns (uint256) {\n        return dataStore.getUint(Keys.withdrawalGasLimitKey(false)) + withdrawal.callbackGasLimit();\n    }\n\n    // @dev the estimated gas limit for orders\n    // @param dataStore DataStore\n    // @param order the order to estimate the gas limit for\n    function estimateExecuteOrderGasLimit(DataStore dataStore, Order.Props memory order) internal view returns (uint256) {\n        if (BaseOrderUtils.isIncreaseOrder(order.orderType())) {\n            return estimateExecuteIncreaseOrderGasLimit(dataStore, order);\n        }\n\n        if (BaseOrderUtils.isDecreaseOrder(order.orderType())) {\n            return estimateExecuteDecreaseOrderGasLimit(dataStore, order);\n        }\n\n        if (BaseOrderUtils.isSwapOrder(order.orderType())) {\n            return estimateExecuteSwapOrderGasLimit(dataStore, order);\n        }\n\n        BaseOrderUtils.revertUnsupportedOrderType();\n    }\n\n    // @dev the estimated gas limit for increase orders\n    // @param dataStore DataStore\n    // @param order the order to estimate the gas limit for\n    function estimateExecuteIncreaseOrderGasLimit(DataStore dataStore, Order.Props memory order) internal view returns (uint256) {\n        uint256 gasPerSwap = dataStore.getUint(Keys.singleSwapGasLimitKey());\n        return dataStore.getUint(Keys.increaseOrderGasLimitKey()) + gasPerSwap * order.swapPath().length + order.callbackGasLimit();\n    }\n\n    // @dev the estimated gas limit for decrease orders\n    // @param dataStore DataStore\n    // @param order the order to estimate the gas limit for\n    function estimateExecuteDecreaseOrderGasLimit(DataStore dataStore, Order.Props memory order) internal view returns (uint256) {\n        uint256 gasPerSwap = dataStore.getUint(Keys.singleSwapGasLimitKey());\n        return dataStore.getUint(Keys.decreaseOrderGasLimitKey()) + gasPerSwap * order.swapPath().length + order.callbackGasLimit();\n    }\n\n    // @dev the estimated gas limit for swap orders\n    // @param dataStore DataStore\n    // @param order the order to estimate the gas limit for\n    function estimateExecuteSwapOrderGasLimit(DataStore dataStore, Order.Props memory order) internal view returns (uint256) {\n        uint256 gasPerSwap = dataStore.getUint(Keys.singleSwapGasLimitKey());\n        return dataStore.getUint(Keys.swapOrderGasLimitKey()) + gasPerSwap * order.swapPath().length + order.callbackGasLimit();\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/withdrawal/WithdrawalUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../adl/AdlUtils.sol\";\n\nimport \"../data/DataStore.sol\";\n\nimport \"./WithdrawalVault.sol\";\nimport \"./WithdrawalStoreUtils.sol\";\nimport \"./WithdrawalEventUtils.sol\";\n\nimport \"../nonce/NonceUtils.sol\";\nimport \"../pricing/SwapPricingUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleUtils.sol\";\n\nimport \"../gas/GasUtils.sol\";\nimport \"../callback/CallbackUtils.sol\";\n\nimport \"../utils/Array.sol\";\nimport \"../utils/ReceiverUtils.sol\";\n\n/**\n * @title WithdrawalUtils\n * @dev Library for withdrawal functions\n */\nlibrary WithdrawalUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Array for uint256[];\n    using Price for Price.Props;\n    using Withdrawal for Withdrawal.Props;\n\n    /**\n     * @param receiver The address that will receive the withdrawal tokens.\n     * @param callbackContract The contract that will be called back.\n     * @param market The market on which the withdrawal will be executed.\n     * @param marketTokenAmount The amount of market tokens that will be withdrawn.\n     * @param minLongTokenAmount The minimum amount of long tokens that must be withdrawn.\n     * @param minShortTokenAmount The minimum amount of short tokens that must be withdrawn.\n     * @param shouldUnwrapNativeToken Whether the native token should be unwrapped when executing the withdrawal.\n     * @param executionFee The execution fee for the withdrawal.\n     * @param callbackGasLimit The gas limit for calling the callback contract.\n     */\n    struct CreateWithdrawalParams {\n        address receiver;\n        address callbackContract;\n        address market;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n        uint256 marketTokenAmount;\n        uint256 minLongTokenAmount;\n        uint256 minShortTokenAmount;\n        bool shouldUnwrapNativeToken;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    /**\n     * @param dataStore The data store where withdrawal data is stored.\n     * @param eventEmitter The event emitter that is used to emit events.\n     * @param withdrawalVault WithdrawalVault.\n     * @param oracle The oracle that provides market prices.\n     * @param key The unique identifier of the withdrawal to execute.\n     * @param minOracleBlockNumbers The min block numbers for the oracle prices.\n     * @param maxOracleBlockNumbers The max block numbers for the oracle prices.\n     * @param keeper The keeper that is executing the withdrawal.\n     * @param startingGas The starting gas limit for the withdrawal execution.\n     */\n    struct ExecuteWithdrawalParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        WithdrawalVault withdrawalVault;\n        Oracle oracle;\n        bytes32 key;\n        uint256[] minOracleBlockNumbers;\n        uint256[] maxOracleBlockNumbers;\n        address keeper;\n        uint256 startingGas;\n    }\n\n    struct ExecuteWithdrawalCache {\n        uint256 longTokenOutputAmount;\n        uint256 shortTokenOutputAmount;\n        SwapPricingUtils.SwapFees longTokenFees;\n        SwapPricingUtils.SwapFees shortTokenFees;\n        uint256 longTokenPoolAmountDelta;\n        uint256 shortTokenPoolAmountDelta;\n    }\n\n    error MinLongTokens(uint256 received, uint256 expected);\n    error MinShortTokens(uint256 received, uint256 expected);\n    error InsufficientMarketTokens(uint256 balance, uint256 expected);\n    error InsufficientWntAmount(uint256 wntAmount, uint256 executionFee);\n    error EmptyWithdrawal();\n    error EmptyMarketTokenAmount();\n    error InvalidPoolValueForWithdrawal(int256 poolValue);\n\n    /**\n     * @dev Creates a withdrawal in the withdrawal store.\n     *\n     * @param dataStore The data store where withdrawal data is stored.\n     * @param eventEmitter The event emitter that is used to emit events.\n     * @param withdrawalVault WithdrawalVault.\n     * @param account The account that initiated the withdrawal.\n     * @param params The parameters for creating the withdrawal.\n     * @return The unique identifier of the created withdrawal.\n     */\n    function createWithdrawal(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        WithdrawalVault withdrawalVault,\n        address account,\n        CreateWithdrawalParams memory params\n    ) external returns (bytes32) {\n        address wnt = TokenUtils.wnt(dataStore);\n        uint256 wntAmount = withdrawalVault.recordTransferIn(wnt);\n\n        if (wntAmount < params.executionFee) {\n            revert InsufficientWntAmount(wntAmount, params.executionFee);\n        }\n\n        ReceiverUtils.validateReceiver(params.receiver);\n\n        if (params.marketTokenAmount == 0) {\n            revert EmptyMarketTokenAmount();\n        }\n\n        GasUtils.handleExcessExecutionFee(\n            dataStore,\n            withdrawalVault,\n            wntAmount,\n            params.executionFee\n        );\n\n        MarketUtils.validateEnabledMarket(dataStore, params.market);\n\n        Withdrawal.Props memory withdrawal = Withdrawal.Props(\n            Withdrawal.Addresses(\n                account,\n                params.receiver,\n                params.callbackContract,\n                params.market,\n                params.longTokenSwapPath,\n                params.shortTokenSwapPath\n            ),\n            Withdrawal.Numbers(\n                params.marketTokenAmount,\n                params.minLongTokenAmount,\n                params.minShortTokenAmount,\n                Chain.currentBlockNumber(),\n                params.executionFee,\n                params.callbackGasLimit\n            ),\n            Withdrawal.Flags(\n                params.shouldUnwrapNativeToken\n            )\n        );\n\n        CallbackUtils.validateCallbackGasLimit(dataStore, withdrawal.callbackGasLimit());\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteWithdrawalGasLimit(dataStore, withdrawal);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, params.executionFee);\n\n        bytes32 key = NonceUtils.getNextKey(dataStore);\n\n        WithdrawalStoreUtils.set(dataStore, key, withdrawal);\n\n        WithdrawalEventUtils.emitWithdrawalCreated(eventEmitter, key, withdrawal);\n\n        return key;\n    }\n\n    /**\n     * Executes a withdrawal on the market.\n     *\n     * @param params The parameters for executing the withdrawal.\n     */\n    function executeWithdrawal(ExecuteWithdrawalParams memory params) external {\n        Withdrawal.Props memory withdrawal = WithdrawalStoreUtils.get(params.dataStore, params.key);\n        if (withdrawal.account() == address(0)) {\n            revert EmptyWithdrawal();\n        }\n        if (withdrawal.marketTokenAmount() == 0) {\n            revert EmptyMarketTokenAmount();\n        }\n\n        OracleUtils.validateBlockNumberWithinRange(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            withdrawal.updatedAtBlock()\n        );\n\n        uint256 marketTokensBalance = MarketToken(payable(withdrawal.market())).balanceOf(withdrawal.account());\n        if (marketTokensBalance < withdrawal.marketTokenAmount()) {\n            revert InsufficientMarketTokens(marketTokensBalance, withdrawal.marketTokenAmount());\n        }\n\n        _executeWithdrawal(params, withdrawal);\n\n        WithdrawalEventUtils.emitWithdrawalExecuted(params.eventEmitter, params.key);\n\n        CallbackUtils.afterWithdrawalExecution(params.key, withdrawal);\n\n        GasUtils.payExecutionFee(\n            params.dataStore,\n            params.withdrawalVault,\n            withdrawal.executionFee(),\n            params.startingGas,\n            params.keeper,\n            withdrawal.account()\n        );\n    }\n\n    /**\n     * @dev Cancels a withdrawal.\n     * @param dataStore The data store.\n     * @param eventEmitter The event emitter.\n     * @param withdrawalVault The withdrawal vault.\n     * @param key The withdrawal key.\n     * @param keeper The keeper sending the transaction.\n     * @param startingGas The starting gas for the transaction.\n     */\n    function cancelWithdrawal(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        WithdrawalVault withdrawalVault,\n        bytes32 key,\n        address keeper,\n        uint256 startingGas,\n        string memory reason,\n        bytes memory reasonBytes\n    ) external {\n        Withdrawal.Props memory withdrawal = WithdrawalStoreUtils.get(dataStore, key);\n        if (withdrawal.account() == address(0)) {\n            revert EmptyWithdrawal();\n        }\n\n        WithdrawalStoreUtils.remove(dataStore, key, withdrawal.account());\n\n        WithdrawalEventUtils.emitWithdrawalCancelled(eventEmitter, key, reason, reasonBytes);\n\n        CallbackUtils.afterWithdrawalCancellation(key, withdrawal);\n\n        GasUtils.payExecutionFee(\n            dataStore,\n            withdrawalVault,\n            withdrawal.executionFee(),\n            startingGas,\n            keeper,\n            withdrawal.account()\n        );\n    }\n\n    /**\n     * @dev executes a withdrawal.\n     * @param params ExecuteWithdrawalParams.\n     * @param withdrawal The withdrawal to execute.\n     */\n    function _executeWithdrawal(\n        ExecuteWithdrawalParams memory params,\n        Withdrawal.Props memory withdrawal\n    ) internal {\n        Market.Props memory market = MarketUtils.getEnabledMarket(params.dataStore, withdrawal.market());\n\n        MarketUtils.MarketPrices memory prices = MarketUtils.getMarketPrices(\n            params.oracle,\n            market\n        );\n\n        ExecuteWithdrawalCache memory cache;\n\n        (cache.longTokenOutputAmount, cache.shortTokenOutputAmount) = _getOutputAmounts(params, market, prices, withdrawal.marketTokenAmount());\n\n        cache.longTokenFees = SwapPricingUtils.getSwapFees(\n            params.dataStore,\n            market.marketToken,\n            cache.longTokenOutputAmount\n        );\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.dataStore,\n            params.eventEmitter,\n            market.marketToken,\n            market.longToken,\n            cache.longTokenFees.feeReceiverAmount,\n            Keys.WITHDRAWAL_FEE\n        );\n\n        cache.shortTokenFees = SwapPricingUtils.getSwapFees(\n            params.dataStore,\n            market.marketToken,\n            cache.shortTokenOutputAmount\n        );\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.dataStore,\n            params.eventEmitter,\n            market.marketToken,\n            market.shortToken,\n            cache.shortTokenFees.feeReceiverAmount,\n            Keys.WITHDRAWAL_FEE\n        );\n\n        // the pool will be reduced by the outputAmount minus the fees for the pool\n        cache.longTokenPoolAmountDelta = cache.longTokenOutputAmount - cache.longTokenFees.feeAmountForPool;\n        cache.longTokenOutputAmount = cache.longTokenFees.amountAfterFees;\n\n        cache.shortTokenPoolAmountDelta = cache.shortTokenOutputAmount - cache.shortTokenFees.feeAmountForPool;\n        cache.shortTokenOutputAmount = cache.shortTokenFees.amountAfterFees;\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            market.marketToken,\n            market.longToken,\n            -cache.longTokenPoolAmountDelta.toInt256()\n        );\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            market.marketToken,\n            market.shortToken,\n            -cache.shortTokenPoolAmountDelta.toInt256()\n        );\n\n        MarketUtils.validateReserve(\n            params.dataStore,\n            market,\n            prices,\n            true\n        );\n\n        MarketUtils.validateReserve(\n            params.dataStore,\n            market,\n            prices,\n            false\n        );\n\n        MarketUtils.validateMaxPnl(\n            params.dataStore,\n            market,\n            prices,\n            Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS\n        );\n\n        WithdrawalStoreUtils.remove(params.dataStore, params.key, withdrawal.account());\n\n        MarketToken(payable(market.marketToken)).burn(withdrawal.account(), withdrawal.marketTokenAmount());\n\n        swap(\n            params,\n            market,\n            market.longToken,\n            cache.longTokenOutputAmount,\n            withdrawal.longTokenSwapPath(),\n            withdrawal.minLongTokenAmount(),\n            withdrawal.receiver(),\n            withdrawal.shouldUnwrapNativeToken()\n        );\n\n        swap(\n            params,\n            market,\n            market.shortToken,\n            cache.shortTokenOutputAmount,\n            withdrawal.shortTokenSwapPath(),\n            withdrawal.minShortTokenAmount(),\n            withdrawal.receiver(),\n            withdrawal.shouldUnwrapNativeToken()\n        );\n\n        SwapPricingUtils.emitSwapFeesCollected(\n            params.eventEmitter,\n            market.marketToken,\n            market.longToken,\n            \"withdrawal\",\n            cache.longTokenFees\n        );\n\n        SwapPricingUtils.emitSwapFeesCollected(\n            params.eventEmitter,\n            market.marketToken,\n            market.shortToken,\n            \"withdrawal\",\n            cache.shortTokenFees\n        );\n    }\n\n    function swap(\n        ExecuteWithdrawalParams memory params,\n        Market.Props memory market,\n        address tokenIn,\n        uint256 amountIn,\n        address[] memory swapPath,\n        uint256 minOutputAmount,\n        address receiver,\n        bool shouldUnwrapNativeToken\n    ) internal {\n        Market.Props[] memory swapPathMarkets = MarketUtils.getEnabledMarkets(params.dataStore, swapPath);\n\n        SwapUtils.swap(\n            SwapUtils.SwapParams(\n                params.dataStore, // dataStore\n                params.eventEmitter, // eventEmitter\n                params.oracle, // oracle\n                Bank(payable(market.marketToken)), // bank\n                tokenIn, // tokenIn\n                amountIn, // amountIn\n                swapPathMarkets, // swapPathMarkets\n                minOutputAmount, // minOutputAmount\n                receiver, // receiver\n                shouldUnwrapNativeToken // shouldUnwrapNativeToken\n            )\n        );\n    }\n\n    function _getOutputAmounts(\n        ExecuteWithdrawalParams memory params,\n        Market.Props memory market,\n        MarketUtils.MarketPrices memory prices,\n        uint256 marketTokenAmount\n    ) internal view returns (uint256, uint256) {\n        // the max pnl factor for withdrawals should be the lower of the max pnl factor values\n        // which means that pnl would be capped to a smaller amount and the pool\n        // value would be higher even if there is a large pnl\n        // this should be okay since MarketUtils.validateMaxPnl is called after the withdrawal\n        // which ensures that the max pnl factor for withdrawals was not exceeded\n        int256 _poolValue = MarketUtils.getPoolValue(\n            params.dataStore,\n            market,\n            prices.longTokenPrice,\n            prices.shortTokenPrice,\n            params.oracle.getPrimaryPrice(market.indexToken),\n            Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS,\n            false\n        );\n\n        if (_poolValue <= 0) {\n            revert InvalidPoolValueForWithdrawal(_poolValue);\n        }\n\n        uint256 poolValue = _poolValue.toUint256();\n        uint256 marketTokensSupply = MarketUtils.getMarketTokenSupply(MarketToken(payable(market.marketToken)));\n        uint256 marketTokensUsd = MarketUtils.marketTokenAmountToUsd(marketTokenAmount, poolValue, marketTokensSupply);\n\n        uint256 longTokenPoolAmount = MarketUtils.getPoolAmount(params.dataStore, market.marketToken, market.longToken);\n        uint256 shortTokenPoolAmount = MarketUtils.getPoolAmount(params.dataStore, market.marketToken, market.shortToken);\n\n        uint256 longTokenPoolUsd = longTokenPoolAmount * prices.longTokenPrice.max;\n        uint256 shortTokenPoolUsd = shortTokenPoolAmount * prices.shortTokenPrice.max;\n\n        uint256 longTokenOutputUsd = marketTokensUsd * longTokenPoolUsd / (longTokenPoolUsd + shortTokenPoolUsd);\n        uint256 shortTokenOutputUsd = marketTokensUsd * shortTokenPoolUsd / (longTokenPoolUsd + shortTokenPoolUsd);\n\n        return (\n            longTokenOutputUsd / prices.longTokenPrice.max,\n            shortTokenOutputUsd / prices.shortTokenPrice.max\n        );\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/withdrawal/WithdrawalUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../adl/AdlUtils.sol\";\n\nimport \"../data/DataStore.sol\";\n\nimport \"./WithdrawalVault.sol\";\nimport \"./WithdrawalStoreUtils.sol\";\nimport \"./WithdrawalEventUtils.sol\";\n\nimport \"../nonce/NonceUtils.sol\";\nimport \"../pricing/SwapPricingUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleUtils.sol\";\n\nimport \"../gas/GasUtils.sol\";\nimport \"../callback/CallbackUtils.sol\";\n\nimport \"../utils/Array.sol\";\nimport \"../utils/ReceiverUtils.sol\";\n\n/**\n * @title WithdrawalUtils\n * @dev Library for withdrawal functions\n */\nlibrary WithdrawalUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Array for uint256[];\n    using Price for Price.Props;\n    using Withdrawal for Withdrawal.Props;\n\n    /**\n     * @param receiver The address that will receive the withdrawal tokens.\n     * @param callbackContract The contract that will be called back.\n     * @param market The market on which the withdrawal will be executed.\n     * @param marketTokenAmount The amount of market tokens that will be withdrawn.\n     * @param minLongTokenAmount The minimum amount of long tokens that must be withdrawn.\n     * @param minShortTokenAmount The minimum amount of short tokens that must be withdrawn.\n     * @param shouldUnwrapNativeToken Whether the native token should be unwrapped when executing the withdrawal.\n     * @param executionFee The execution fee for the withdrawal.\n     * @param callbackGasLimit The gas limit for calling the callback contract.\n     */\n    struct CreateWithdrawalParams {\n        address receiver;\n        address callbackContract;\n        address market;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n        uint256 marketTokenAmount;\n        uint256 minLongTokenAmount;\n        uint256 minShortTokenAmount;\n        bool shouldUnwrapNativeToken;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    /**\n     * @param dataStore The data store where withdrawal data is stored.\n     * @param eventEmitter The event emitter that is used to emit events.\n     * @param withdrawalVault WithdrawalVault.\n     * @param oracle The oracle that provides market prices.\n     * @param key The unique identifier of the withdrawal to execute.\n     * @param minOracleBlockNumbers The min block numbers for the oracle prices.\n     * @param maxOracleBlockNumbers The max block numbers for the oracle prices.\n     * @param keeper The keeper that is executing the withdrawal.\n     * @param startingGas The starting gas limit for the withdrawal execution.\n     */\n    struct ExecuteWithdrawalParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        WithdrawalVault withdrawalVault;\n        Oracle oracle;\n        bytes32 key;\n        uint256[] minOracleBlockNumbers;\n        uint256[] maxOracleBlockNumbers;\n        address keeper;\n        uint256 startingGas;\n    }\n\n    struct ExecuteWithdrawalCache {\n        uint256 longTokenOutputAmount;\n        uint256 shortTokenOutputAmount;\n        SwapPricingUtils.SwapFees longTokenFees;\n        SwapPricingUtils.SwapFees shortTokenFees;\n        uint256 longTokenPoolAmountDelta;\n        uint256 shortTokenPoolAmountDelta;\n    }\n\n    error MinLongTokens(uint256 received, uint256 expected);\n    error MinShortTokens(uint256 received, uint256 expected);\n    error InsufficientMarketTokens(uint256 balance, uint256 expected);\n    error InsufficientWntAmount(uint256 wntAmount, uint256 executionFee);\n    error EmptyWithdrawal();\n    error EmptyMarketTokenAmount();\n    error InvalidPoolValueForWithdrawal(int256 poolValue);\n\n    /**\n     * @dev Creates a withdrawal in the withdrawal store.\n     *\n     * @param dataStore The data store where withdrawal data is stored.\n     * @param eventEmitter The event emitter that is used to emit events.\n     * @param withdrawalVault WithdrawalVault.\n     * @param account The account that initiated the withdrawal.\n     * @param params The parameters for creating the withdrawal.\n     * @return The unique identifier of the created withdrawal.\n     */\n    function createWithdrawal(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        WithdrawalVault withdrawalVault,\n        address account,\n        CreateWithdrawalParams memory params\n    ) external returns (bytes32) {\n        address wnt = TokenUtils.wnt(dataStore);\n        uint256 wntAmount = withdrawalVault.recordTransferIn(wnt);\n\n        if (wntAmount < params.executionFee) {\n            revert InsufficientWntAmount(wntAmount, params.executionFee);\n        }\n\n        ReceiverUtils.validateReceiver(params.receiver);\n\n        if (params.marketTokenAmount == 0) {\n            revert EmptyMarketTokenAmount();\n        }\n\n        GasUtils.handleExcessExecutionFee(\n            dataStore,\n            withdrawalVault,\n            wntAmount,\n            params.executionFee\n        );\n\n        MarketUtils.validateEnabledMarket(dataStore, params.market);\n\n        Withdrawal.Props memory withdrawal = Withdrawal.Props(\n            Withdrawal.Addresses(\n                account,\n                params.receiver,\n                params.callbackContract,\n                params.market,\n                params.longTokenSwapPath,\n                params.shortTokenSwapPath\n            ),\n            Withdrawal.Numbers(\n                params.marketTokenAmount,\n                params.minLongTokenAmount,\n                params.minShortTokenAmount,\n                Chain.currentBlockNumber(),\n                params.executionFee,\n                params.callbackGasLimit\n            ),\n            Withdrawal.Flags(\n                params.shouldUnwrapNativeToken\n            )\n        );\n\n        CallbackUtils.validateCallbackGasLimit(dataStore, withdrawal.callbackGasLimit());\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteWithdrawalGasLimit(dataStore, withdrawal);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, params.executionFee);\n\n        bytes32 key = NonceUtils.getNextKey(dataStore);\n\n        WithdrawalStoreUtils.set(dataStore, key, withdrawal);\n\n        WithdrawalEventUtils.emitWithdrawalCreated(eventEmitter, key, withdrawal);\n\n        return key;\n    }\n\n    /**\n     * Executes a withdrawal on the market.\n     *\n     * @param params The parameters for executing the withdrawal.\n     */\n    function executeWithdrawal(ExecuteWithdrawalParams memory params) external {\n        Withdrawal.Props memory withdrawal = WithdrawalStoreUtils.get(params.dataStore, params.key);\n        if (withdrawal.account() == address(0)) {\n            revert EmptyWithdrawal();\n        }\n        if (withdrawal.marketTokenAmount() == 0) {\n            revert EmptyMarketTokenAmount();\n        }\n\n        OracleUtils.validateBlockNumberWithinRange(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            withdrawal.updatedAtBlock()\n        );\n\n        uint256 marketTokensBalance = MarketToken(payable(withdrawal.market())).balanceOf(withdrawal.account());\n        if (marketTokensBalance < withdrawal.marketTokenAmount()) {\n            revert InsufficientMarketTokens(marketTokensBalance, withdrawal.marketTokenAmount());\n        }\n\n        _executeWithdrawal(params, withdrawal);\n\n        WithdrawalEventUtils.emitWithdrawalExecuted(params.eventEmitter, params.key);\n\n        CallbackUtils.afterWithdrawalExecution(params.key, withdrawal);\n\n        GasUtils.payExecutionFee(\n            params.dataStore,\n            params.withdrawalVault,\n            withdrawal.executionFee(),\n            params.startingGas,\n            params.keeper,\n            withdrawal.account()\n        );\n    }\n\n    /**\n     * @dev Cancels a withdrawal.\n     * @param dataStore The data store.\n     * @param eventEmitter The event emitter.\n     * @param withdrawalVault The withdrawal vault.\n     * @param key The withdrawal key.\n     * @param keeper The keeper sending the transaction.\n     *"
    }
  ]
}