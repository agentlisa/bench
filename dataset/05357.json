{
  "Title": "[M-11] API3 oracle timestamp can be set to future timestamp and block API3 Oracle usage to make code revert in underflow",
  "Content": "\nIn the Api3OracleReader.sol, the code assumes tha the timestamp returned from oracle is always in the past.\n\n```solidity\n    function getPrice_e36(address _token) external view returns (uint price_e36) {\n        // load and check\n        DataFeedInfo memory dataFeedInfo = dataFeedInfos[_token];\n        _require(dataFeedInfo.dataFeedId != bytes32(0), Errors.DATAFEED_ID_NOT_SET);\n        _require(dataFeedInfo.maxStaleTime != 0, Errors.MAX_STALETIME_NOT_SET);\n\n        // get price and token's decimals\n        uint decimals = uint(IERC20Metadata(_token).decimals());\n        // return price per token with 1e18 precisions\n        // e.g. 1 BTC = 35000 * 1e18 in USD_e18 unit\n        (int224 price, uint timestamp) = IApi3ServerV1(api3ServerV1).readDataFeedWithId(dataFeedInfo.dataFeedId);\n\n        // check if the last updated is not longer than the max stale time\n        _require(block.timestamp - timestamp <= dataFeedInfo.maxStaleTime, Errors.MAX_STALETIME_EXCEEDED);\n\n        // return as [USD_e36 per wei unit]\n        price_e36 = (price.toUint256() * ONE_E18) / 10 ** decimals;\n    }\n```\n\nNote the check:\n\n```solidity\n// e.g. 1 BTC = 35000 * 1e18 in USD_e18 unit\n(int224 price, uint timestamp) = IApi3ServerV1(api3ServerV1).readDataFeedWithId(dataFeedInfo.dataFeedId);\n\n// check if the last updated is not longer than the max stale time\n_require(block.timestamp - timestamp <= dataFeedInfo.maxStaleTime, Errors.MAX_STALETIME_EXCEEDED);\n```\n\nIf timestamp is greater than block.timestamp, the transaction will revert and block oracle lookup on APi3OracleReader.sol.\n\nThe relayer on api3 side can update both oracle price timestamp and value.\n\nLet us go over how the price is updated in Api3 code:\n\nThe function readDataFeedWithID basically just read the data from struct \\_dataFeeds\\[beaconId], [in this function](https://github.com/api3dao/airnode-protocol-v1/blob/fa95f043ce4b50e843e407b96f7ae3edcf899c32/contracts/api3-server-v1/DataFeedServer.sol#L75)\n\n```solidity\n    /// @notice Reads the data feed with ID\n    /// @param dataFeedId Data feed ID\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function _readDataFeedWithId(\n        bytes32 dataFeedId\n    ) internal view returns (int224 value, uint32 timestamp) {\n        DataFeed storage dataFeed = _dataFeeds[dataFeedId];\n        (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\n        require(timestamp > 0, \"Data feed not initialized\");\n    }\n```\n\nWhen the relayer updates the oracle data, first we are calling [processBeaconUpdate](https://github.com/api3dao/airnode-protocol-v1/blob/fa95f043ce4b50e843e407b96f7ae3edcf899c32/contracts/api3-server-v1/BeaconUpdatesWithSignedData.sol#L41).\n\nNote that is a [modifier onlyValidateTimestamp](https://github.com/api3dao/airnode-protocol-v1/blob/fa95f043ce4b50e843e407b96f7ae3edcf899c32/contracts/api3-server-v1/DataFeedServer.sol#L115).\n\n```solidity\n  function processBeaconUpdate(\n        bytes32 beaconId,\n        uint256 timestamp,\n        bytes calldata data\n    )\n        internal\n        onlyValidTimestamp(timestamp)\n        returns (int224 updatedBeaconValue)\n    {\n        updatedBeaconValue = decodeFulfillmentData(data);\n        require(\n            timestamp > _dataFeeds[beaconId].timestamp,\n            \"Does not update timestamp\"\n        );\n        _dataFeeds[beaconId] = DataFeed({\n            value: updatedBeaconValue,\n            timestamp: uint32(timestamp)\n        });\n    }\n```\n\nThe [check](https://github.com/api3dao/airnode-protocol-v1/blob/fa95f043ce4b50e843e407b96f7ae3edcf899c32/contracts/api3-server-v1/DataFeedServer.sol#L30) ensures that only when the timstamp is from more than 1 hour, the update reverts.\n\n```solidity\n    /// @dev Reverts if the timestamp is from more than 1 hour in the future\n    modifier onlyValidTimestamp(uint256 timestamp) virtual {\n        unchecked {\n            require(\n                timestamp < block.timestamp + 1 hours,\n                \"Timestamp not valid\"\n            );\n        }\n        _;\n    }\n```\n\nWhat does this mean?\n\nThe timestamp of an oracle can be set to the future within an hour, the relayer does not have to be malicious, it is a normal part of updating data.\n\nSuppose the current timestamp is 10000\n\n1 hour = 3600 seconds\n\nIf the relayer set timestamp to 12000, the price update will go through\n\nBut the code:\n\n```solidity\n_require(block.timestamp - timestamp <= dataFeedInfo.maxStaleTime, Errors.MAX_STALETIME_EXCEEDED);\n```\n\nWill revert when current timestamp is 10001.\n\n10001 - 12000 will revert in underflow.\n\n### Recommended Mitigation Steps\n\nIf the oracle timestamp comes from the future, the code should consider it not stale.\n\nCan change the code to:\n\n    if (block.timestamp > timestamp) {\n     _require(block.timestamp - timestamp <= dataFeedInfo.maxStaleTime, Errors.MAX_STALETIME_EXCEEDED);\n    }\n\n\n**[fez-init (INIT) confirmed](https://github.com/code-423n4/2023-12-initcapital-findings/issues/4#issuecomment-1869777419)**\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-initcapital",
  "Code": [
    {
      "filename": "contracts/api3-server-v1/DataFeedServer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../utils/ExtendedSelfMulticall.sol\";\nimport \"./aggregation/Median.sol\";\nimport \"./interfaces/IDataFeedServer.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/// @title Contract that serves Beacons and Beacon sets\n/// @notice A Beacon is a live data feed addressed by an ID, which is derived\n/// from an Airnode address and a template ID. This is suitable where the more\n/// recent data point is always more favorable, e.g., in the context of an\n/// asset price data feed. Beacons can also be seen as one-Airnode data feeds\n/// that can be used individually or combined to build Beacon sets.\ncontract DataFeedServer is ExtendedSelfMulticall, Median, IDataFeedServer {\n    using ECDSA for bytes32;\n\n    // Airnodes serve their fulfillment data along with timestamps. This\n    // contract casts the reported data to `int224` and the timestamp to\n    // `uint32`, which works until year 2106.\n    struct DataFeed {\n        int224 value;\n        uint32 timestamp;\n    }\n\n    /// @notice Data feed with ID\n    mapping(bytes32 => DataFeed) internal _dataFeeds;\n\n    /// @dev Reverts if the timestamp is from more than 1 hour in the future\n    modifier onlyValidTimestamp(uint256 timestamp) virtual {\n        unchecked {\n            require(\n                timestamp < block.timestamp + 1 hours,\n                \"Timestamp not valid\"\n            );\n        }\n        _;\n    }\n\n    /// @notice Updates the Beacon set using the current values of its Beacons\n    /// @dev As an oddity, this function still works if some of the IDs in\n    /// `beaconIds` belong to Beacon sets rather than Beacons. This can be used\n    /// to implement hierarchical Beacon sets.\n    /// @param beaconIds Beacon IDs\n    /// @return beaconSetId Beacon set ID\n    function updateBeaconSetWithBeacons(\n        bytes32[] memory beaconIds\n    ) public override returns (bytes32 beaconSetId) {\n        (int224 updatedValue, uint32 updatedTimestamp) = aggregateBeacons(\n            beaconIds\n        );\n        beaconSetId = deriveBeaconSetId(beaconIds);\n        DataFeed storage beaconSet = _dataFeeds[beaconSetId];\n        if (beaconSet.timestamp == updatedTimestamp) {\n            require(\n                beaconSet.value != updatedValue,\n                \"Does not update Beacon set\"\n            );\n        }\n        _dataFeeds[beaconSetId] = DataFeed({\n            value: updatedValue,\n            timestamp: updatedTimestamp\n        });\n        emit UpdatedBeaconSetWithBeacons(\n            beaconSetId,\n            updatedValue,\n            updatedTimestamp\n        );\n    }\n\n    /// @notice Reads the data feed with ID\n    /// @param dataFeedId Data feed ID\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function _readDataFeedWithId(\n        bytes32 dataFeedId\n    ) internal view returns (int224 value, uint32 timestamp) {\n        DataFeed storage dataFeed = _dataFeeds[dataFeedId];\n        (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\n        require(timestamp > 0, \"Data feed not initialized\");\n    }\n\n    /// @notice Derives the Beacon ID from the Airnode address and template ID\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @return beaconId Beacon ID\n    function deriveBeaconId(\n        address airnode,\n        bytes32 templateId\n    ) internal pure returns (bytes32 beaconId) {\n        beaconId = keccak256(abi.encodePacked(airnode, templateId));\n    }\n\n    /// @notice Derives the Beacon set ID from the Beacon IDs\n    /// @dev Notice that `abi.encode()` is used over `abi.encodePacked()`\n    /// @param beaconIds Beacon IDs\n    /// @return beaconSetId Beacon set ID\n    function deriveBeaconSetId(\n        bytes32[] memory beaconIds\n    ) internal pure returns (bytes32 beaconSetId) {\n        beaconSetId = keccak256(abi.encode(beaconIds));\n    }\n\n    /// @notice Called privately to process the Beacon update\n    /// @param beaconId Beacon ID\n    /// @param timestamp Timestamp used in the signature\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    /// @return updatedBeaconValue Updated Beacon value\n    function processBeaconUpdate(\n        bytes32 beaconId,\n        uint256 timestamp,\n        bytes calldata data\n    )\n        internal\n        onlyValidTimestamp(timestamp)\n        returns (int224 updatedBeaconValue)\n    {\n        updatedBeaconValue = decodeFulfillmentData(data);\n        require(\n            timestamp > _dataFeeds[beaconId].timestamp,\n            \"Does not update timestamp\"\n        );\n        _dataFeeds[beaconId] = DataFeed({\n            value: updatedBeaconValue,\n            timestamp: uint32(timestamp)\n        });\n    }\n\n    /// @notice Called privately to decode the fulfillment data\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    /// @return decodedData Decoded fulfillment data\n    function decodeFulfillmentData(\n        bytes memory data\n    ) internal pure returns (int224) {\n        require(data.length == 32, \"Data length not correct\");\n        int256 decodedData = abi.decode(data, (int256));\n        require(\n            decodedData >= type(int224).min && decodedData <= type(int224).max,\n            \"Value typecasting error\"\n        );\n        return int224(decodedData);\n    }\n\n    /// @notice Called privately to aggregate the Beacons and return the result\n    /// @param beaconIds Beacon IDs\n    /// @return value Aggregation value\n    /// @return timestamp Aggregation timestamp\n    function aggregateBeacons(\n        bytes32[] memory beaconIds\n    ) internal view returns (int224 value, uint32 timestamp) {\n        uint256 beaconCount = beaconIds.length;\n        require(beaconCount > 1, \"Specified less than two Beacons\");\n        int256[] memory values = new int256[](beaconCount);\n        int256[] memory timestamps = new int256[](beaconCount);\n        for (uint256 ind = 0; ind < beaconCount; ) {\n            DataFeed storage dataFeed = _dataFeeds[beaconIds[ind]];\n            values[ind] = dataFeed.value;\n            timestamps[ind] = int256(uint256(dataFeed.timestamp));\n            unchecked {\n                ind++;\n            }\n        }\n        value = int224(median(values));\n        timestamp = uint32(uint256(median(timestamps)));\n    }\n}"
    },
    {
      "filename": "contracts/api3-server-v1/BeaconUpdatesWithSignedData.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./DataFeedServer.sol\";\nimport \"./interfaces/IBeaconUpdatesWithSignedData.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/// @title Contract that updates Beacons using signed data\ncontract BeaconUpdatesWithSignedData is\n    DataFeedServer,\n    IBeaconUpdatesWithSignedData\n{\n    using ECDSA for bytes32;\n\n    /// @notice Updates a Beacon using data signed by the Airnode\n    /// @dev The signed data here is intentionally very general for practical\n    /// reasons. It is less demanding on the signer to have data signed once\n    /// and use that everywhere.\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @param timestamp Signature timestamp\n    /// @param data Update data (an `int256` encoded in contract ABI)\n    /// @param signature Template ID, timestamp and the update data signed by\n    /// the Airnode\n    /// @return beaconId Updated Beacon ID\n    function updateBeaconWithSignedData(\n        address airnode,\n        bytes32 templateId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external override returns (bytes32 beaconId) {\n        require(\n            (\n                keccak256(abi.encodePacked(templateId, timestamp, data))\n                    .toEthSignedMessageHash()\n            ).recover(signature) == airnode,\n            \"Signature mismatch\"\n        );\n        beaconId = deriveBeaconId(airnode, templateId);\n        int224 updatedValue = processBeaconUpdate(beaconId, timestamp, data);\n        emit UpdatedBeaconWithSignedData(\n            beaconId,\n            updatedValue,\n            uint32(timestamp)\n        );\n    }\n}"
    },
    {
      "filename": "contracts/api3-server-v1/DataFeedServer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../utils/ExtendedSelfMulticall.sol\";\nimport \"./aggregation/Median.sol\";\nimport \"./interfaces/IDataFeedServer.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/// @title Contract that serves Beacons and Beacon sets\n/// @notice A Beacon is a live data feed addressed by an ID, which is derived\n/// from an Airnode address and a template ID. This is suitable where the more\n/// recent data point is always more favorable, e.g., in the context of an\n/// asset price data feed. Beacons can also be seen as one-Airnode data feeds\n/// that can be used individually or combined to build Beacon sets.\ncontract DataFeedServer is ExtendedSelfMulticall, Median, IDataFeedServer {\n    using ECDSA for bytes32;\n\n    // Airnodes serve their fulfillment data along with timestamps. This\n    // contract casts the reported data to `int224` and the timestamp to\n    // `uint32`, which works until year 2106.\n    struct DataFeed {\n        int224 value;\n        uint32 timestamp;\n    }\n\n    /// @notice Data feed with ID\n    mapping(bytes32 => DataFeed) internal _dataFeeds;\n\n    /// @dev Reverts if the timestamp is from more than 1 hour in the future\n    modifier onlyValidTimestamp(uint256 timestamp) virtual {\n        unchecked {\n            require(\n                timestamp < block.timestamp + 1 hours,\n                \"Timestamp not valid\"\n            );\n        }\n        _;\n    }\n\n    /// @notice Updates the Beacon set using the current values of its Beacons\n    /// @dev As an oddity, this function still works if some of the IDs in\n    /// `beaconIds` belong to Beacon sets rather than Beacons. This can be used\n    /// to implement hierarchical Beacon sets.\n    /// @param beaconIds Beacon IDs\n    /// @return beaconSetId Beacon set ID\n    function updateBeaconSetWithBeacons(\n        bytes32[] memory beaconIds\n    ) public override returns (bytes32 beaconSetId) {\n        (int224 updatedValue, uint32 updatedTimestamp) = aggregateBeacons(\n            beaconIds\n        );\n        beaconSetId = deriveBeaconSetId(beaconIds);\n        DataFeed storage beaconSet = _dataFeeds[beaconSetId];\n        if (beaconSet.timestamp == updatedTimestamp) {\n            require(\n                beaconSet.value != updatedValue,\n                \"Does not update Beacon set\"\n            );\n        }\n        _dataFeeds[beaconSetId] = DataFeed({\n            value: updatedValue,\n            timestamp: updatedTimestamp\n        });\n        emit UpdatedBeaconSetWithBeacons(\n            beaconSetId,\n            updatedValue,\n            updatedTimestamp\n        );\n    }\n\n    /// @notice Reads the data feed with ID\n    /// @param dataFeedId Data feed ID\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function _readDataFeedWithId(\n        bytes32 dataFeedId\n    ) internal view returns (int224 value, uint32 timestamp) {\n        DataFeed storage dataFeed = _dataFeeds[dataFeedId];\n        (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\n        require(timestamp > 0, \"Data feed not initialized\");\n    }\n\n    /// @notice Derives the Beacon ID from the Airnode address and template ID\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @return beaconId Beacon ID\n    function deriveBeaconId(\n        address airnode,\n        bytes32 templateId\n    ) internal pure returns (bytes32 beaconId) {\n        beaconId = keccak256(abi.encodePacked(airnode, templateId));\n    }\n\n    /// @notice Derives the Beacon set ID from the Beacon IDs\n    /// @dev Notice that `abi.encode()` is used over `abi.encodePacked()`\n    /// @param beaconIds Beacon IDs\n    /// @return beaconSetId Beacon set ID\n    function deriveBeaconSetId(\n        bytes32[] memory beaconIds\n    ) internal pure returns (bytes32 beaconSetId) {\n        beaconSetId = keccak256(abi.encode(beaconIds));\n    }\n\n    /// @notice Called privately to process the Beacon update\n    /// @param beaconId Beacon ID\n    /// @param timestamp Timestamp used in the signature\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    /// @return updatedBeaconValue Updated Beacon value\n    function processBeaconUpdate(\n        bytes32 beaconId,\n        uint256 timestamp,\n        bytes calldata data\n    )\n        internal\n        onlyValidTimestamp(timestamp)\n        returns (int224 updatedBeaconValue)\n    {\n        updatedBeaconValue = decodeFulfillmentData(data);\n        require(\n            timestamp > _dataFeeds[beaconId].timestamp,\n            \"Does not update timestamp\"\n        );\n        _dataFeeds[beaconId] = DataFeed({\n            value: updatedBeaconValue,\n            timestamp: uint32(timestamp)\n        });\n    }\n\n    /// @notice Called privately to decode the fulfillment data\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    /// @return decodedData Decoded fulfillment data\n    function decodeFulfillmentData(\n        bytes memory data\n    ) internal pure returns (int224) {\n        require(data.length == 32, \"Data length not correct\");\n        int256 decodedData = abi.decode(data, (int256));\n        require(\n            decodedData >= type(int224).min && decodedData <= type(int224).max,\n            \"Value typecasting error\"\n        );\n        return int224(decodedData);\n    }\n\n    /// @notice Called privately to aggregate the Beacons and return the result\n    /// @param beaconIds Beacon IDs\n    /// @return value Aggregation value\n    /// @return timestamp Aggregation timestamp\n    function aggregateBeacons(\n        bytes32[] memory beaconIds\n    ) internal view returns (int224 value, uint32 timestamp) {\n        uint256 beaconCount = beaconIds.length;\n        require(beaconCount > 1, \"Specified less than two Beacons\");\n        int256[] memory values = new int256[](beaconCount);\n        int256[] memory timestamps = new int256[](beaconCount);\n        for (uint256 ind = 0; ind < beaconCount; ) {\n            DataFeed storage dataFeed = _dataFeeds[beaconIds[ind]];\n            values[ind] = dataFeed.value;\n            timestamps[ind] = int256(uint256(dataFeed.timestamp));\n            unchecked {\n                ind++;\n            }\n        }\n        value = int224(median(values));\n        timestamp = uint32(uint256(median(timestamps)));\n    }\n}"
    },
    {
      "filename": "contracts/api3-server-v1/DataFeedServer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../utils/ExtendedSelfMulticall.sol\";\nimport \"./aggregation/Median.sol\";\nimport \"./interfaces/IDataFeedServer.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/// @title Contract that serves Beacons and Beacon sets\n/// @notice A Beacon is a live data feed addressed by an ID, which is derived\n/// from an Airnode address and a template ID. This is suitable where the more\n/// recent data point is always more favorable, e.g., in the context of an\n/// asset price data feed. Beacons can also be seen as one-Airnode data feeds\n/// that can be used individually or combined to build Beacon sets.\ncontract DataFeedServer is ExtendedSelfMulticall, Median, IDataFeedServer {\n    using ECDSA for bytes32;\n\n    // Airnodes serve their fulfillment data along with timestamps. This\n    // contract casts the reported data to `int224` and the timestamp to\n    // `uint32`, which works until year 2106.\n    struct DataFeed {\n        int224 value;\n        uint32 timestamp;\n    }\n\n    /// @notice Data feed with ID\n    mapping(bytes32 => DataFeed) internal _dataFeeds;\n\n    /// @dev Reverts if the timestamp is from more than 1 hour in the future\n    modifier onlyValidTimestamp(uint256 timestamp) virtual {\n        unchecked {\n            require(\n                timestamp < block.timestamp + 1 hours,\n                \"Timestamp not valid\"\n            );\n        }\n        _;\n    }\n\n    /// @notice Updates the Beacon set using the current values of its Beacons\n    /// @dev As an oddity, this function still works if some of the IDs in\n    /// `beaconIds` belong to Beacon sets rather than Beacons. This can be used\n    /// to implement hierarchical Beacon sets.\n    /// @param beaconIds Beacon IDs\n    /// @return beaconSetId Beacon set ID\n    function updateBeaconSetWithBeacons(\n        bytes32[] memory beaconIds\n    ) public override returns (bytes32 beaconSetId) {\n        (int224 updatedValue, uint32 updatedTimestamp) = aggregateBeacons(\n            beaconIds\n        );\n        beaconSetId = deriveBeaconSetId(beaconIds);\n        DataFeed storage beaconSet = _dataFeeds[beaconSetId];\n        if (beaconSet.timestamp == updatedTimestamp) {\n            require(\n                beaconSet.value != updatedValue,\n                \"Does not update Beacon set\"\n            );\n        }\n        _dataFeeds[beaconSetId] = DataFeed({\n            value: updatedValue,\n            timestamp: updatedTimestamp\n        });\n        emit UpdatedBeaconSetWithBeacons(\n            beaconSetId,\n            updatedValue,\n            updatedTimestamp\n        );\n    }\n\n    /// @notice Reads the data feed with ID\n    /// @param dataFeedId Data feed ID\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function _readDataFeedWithId(\n        bytes32 dataFeedId\n    ) internal view returns (int224 value, uint32 timestamp) {\n        DataFeed storage dataFeed = _dataFeeds[dataFeedId];\n        (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\n        require(timestamp > 0, \"Data feed not initialized\");\n    }\n\n    /// @notice Derives the Beacon ID from the Airnode address and template ID\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @return beaconId Beacon ID\n    function deriveBeaconId(\n        address airnode,\n        bytes32 templateId\n    ) internal pure returns (bytes32 beaconId) {\n        beaconId = keccak256(abi.encodePacked(airnode, templateId));\n    }\n\n    /// @notice Derives the Beacon set ID from the Beacon IDs\n    /// @dev Notice that `abi.encode()` is used over `abi.encodePacked()`\n    /// @param beaconIds Beacon IDs\n    /// @return beaconSetId Beacon set ID\n    function deriveBeaconSetId(\n        bytes32[] memory beaconIds\n    ) internal pure returns (bytes32 beaconSetId) {\n        beaconSetId = keccak256(abi.encode(beaconIds));\n    }\n\n    /// @notice Called privately to process the Beacon update\n    /// @param beaconId Beacon ID\n    /// @param timestamp Timestamp used in the signature\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    /// @return updatedBeaconValue Updated Beacon value\n    function processBeaconUpdate(\n        bytes32 beaconId,\n        uint256 timestamp,\n        bytes calldata data\n    )\n        internal\n        onlyValidTimestamp(timestamp)\n        returns (int224 updatedBeaconValue)\n    {\n        updatedBeaconValue = decodeFulfillmentData(data);\n        require(\n            timestamp > _dataFeeds[beaconId].timestamp,\n            \"Does not update timestamp\"\n        );\n        _dataFeeds[beaconId] = DataFeed({\n            value: updatedBeaconValue,\n            timestamp: uint32(timestamp)\n        });\n    }\n\n    /// @notice Called privately to decode the fulfillment data\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    /// @return decodedData Decoded fulfillment data\n    function decodeFulfillmentData(\n        bytes memory data\n    ) internal pure returns (int224) {\n        require(data.length == 32, \"Data length not correct\");\n        int256 decodedData = abi.decode(data, (int256));\n        require(\n            decodedData >= type(int224).min && decodedData <= type(int224).max,\n            \"Value typecasting error\"\n        );\n        return int224(decodedData);\n    }\n\n    /// @notice Called privately to aggregate the Beacons and return the result\n    /// @param beaconIds Beacon IDs\n    /// @return value Aggregation value\n    /// @return timestamp Aggregation timestamp\n    function aggregateBeacons(\n        bytes32[] memory beaconIds\n    ) internal view returns (int224 value, uint32 timestamp) {\n        uint256 beaconCount = beaconIds.length;\n        require(beaconCount > 1, \"Specified less than two Beacons\");\n        int256[] memory values = new int256[](beaconCount);\n        int256[] memory timestamps = new int256[](beaconCount);\n        for (uint256 ind = 0; ind < beaconCount; ) {\n            DataFeed storage dataFeed = _dataFeeds[beaconIds[ind]];\n            values[ind] = dataFeed.value;\n            timestamps[ind] = int256(uint256(dataFeed.timestamp));\n            unchecked {\n                ind++;\n            }\n        }\n        value = int224(median(values));\n        timestamp = uint32(uint256(median(timestamps)));\n    }\n}"
    }
  ]
}