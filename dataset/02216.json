{
  "Title": "H-4: YearnProvider freezes yearn tokens on partial withdrawal",
  "Content": "# Issue H-4: YearnProvider freezes yearn tokens on partial withdrawal \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/355 \n\n## Found by \nhyh, spyrosonic10\n\n## Summary\n\nYearnProvider's withdraw() doesn't account for partial withdrawal situation, which isn't rare, so the unused part of user shares end up being stuck on the contract balance as there is no mechanics to retrieve them thereafter.\n\n## Vulnerability Detail\n\nFull amount of the shares user requested to be burned is transferred to YearnProvider, but only part of it can be utilized by Yearn withdrawal.\n\nLiquidity shortage (squeeze) is common enough situation, for example it can occur whenever part of the Yearn strategy is tied to a lending market that have high utilization at the moment of the call.\n\n## Impact\n\nPart of protocol funds can be permanently frozen on YearnProvider contract balance (as it's not operating the funds itself, always referencing the caller Vault).\n\nAs Provider's withdraw is routinely called by Vault managing the aggregated funds distribution, the freeze amount can be massive enough and will be translated to a loss for many users.\n\n## Code Snippet\n\nwithdraw() transfers all the requested `_amount` from the user, but do not return the remainder `_yToken` amount:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/YearnProvider.sol#L44-L66\n\n```solidity\n  function withdraw(\n    uint256 _amount,\n    address _yToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\n\n    require(\n      IYearn(_yToken).transferFrom(msg.sender, address(this), _amount) == true,\n      \"Error transferFrom\"\n    );\n\n    uint256 uAmountReceived = IYearn(_yToken).withdraw(_amount);\n    IERC20(_uToken).safeTransfer(msg.sender, uAmountReceived);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\n    require(\n      (balanceAfter - balanceBefore - uAmountReceived) == 0,\n      \"Error Withdraw: under/overflow\"\n    );\n\n    return uAmountReceived;\n  }\n```\n\n`uAmountReceived` can correspond only to a part of shares `_amount` obtained from the caller.\n\nYearn withdrawal is not guaranteed to be full, `value` returned and `shares` burned depend on availability (i.e. `shares < maxShares` is valid case):\n\nhttps://github.com/yearn/yearn-vaults/blob/master/contracts/Vault.vy#L1144-L1167\n\n```vyper\n        # NOTE: We have withdrawn everything possible out of the withdrawal queue\n        #       but we still don't have enough to fully pay them back, so adjust\n        #       to the total amount we've freed up through forced withdrawals\n        if value > vault_balance:\n            value = vault_balance\n            # NOTE: Burn # of shares that corresponds to what Vault has on-hand,\n            #       including the losses that were incurred above during withdrawals\n            shares = self._sharesForAmount(value + totalLoss)\n\n        # NOTE: This loss protection is put in place to revert if losses from\n        #       withdrawing are more than what is considered acceptable.\n        assert totalLoss <= maxLoss * (value + totalLoss) / MAX_BPS\n\n    # Burn shares (full value of what is being withdrawn)\n    self.totalSupply -= shares\n    self.balanceOf[msg.sender] -= shares\n    log Transfer(msg.sender, ZERO_ADDRESS, shares)\n    \n    self.totalIdle -= value\n    # Withdraw remaining balance to _recipient (may be different to msg.sender) (minus fee)\n    self.erc20_safe_transfer(self.token.address, recipient, value)\n    log Withdraw(recipient, shares, value)\n    \n    return value\n```\n\nThe remaining part of the shares, `maxShares - shares`, end up left on the YearnProvider balance.\n\nProvider's withdraw() is used by the Vault, where `amountReceived` is deemed corresponding to the full `shares` spent:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L303-L326\n\n```solidity\n  /// @notice Withdraw amount from underlying protocol\n  /// @dev shares = amount / PricePerShare\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount in VaultCurrency to withdraw\n  function withdrawFromProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    if (_amount <= 0) return;\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    _amount = (_amount * protocol.uScale) / uScale;\n    uint256 shares = IProvider(protocol.provider).calcShares(_amount, protocol.LPToken);\n    uint256 balance = IProvider(protocol.provider).balance(address(this), protocol.LPToken);\n\n    if (shares == 0) return;\n    if (balance < shares) shares = balance;\n\n    IERC20(protocol.LPToken).safeIncreaseAllowance(protocol.provider, shares);\n    uint256 amountReceived = IProvider(protocol.provider).withdraw(\n      shares,\n      protocol.LPToken,\n      protocol.underlying\n    );\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider returning the unused shares to the caller:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Providers/YearnProvider.sol#L44-L66\n\n```diff\n  function withdraw(\n    uint256 _amount,\n    address _yToken,\n    address _uToken\n  ) external override returns (uint256) {\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\n+   uint256 sharesBefore = IERC20(_yToken).balanceOf(address(this));\n\n    require(\n      IYearn(_yToken).transferFrom(msg.sender, address(this), _amount) == true,\n      \"Error transferFrom\"\n    );\n\n    uint256 uAmountReceived = IYearn(_yToken).withdraw(_amount);\n    IERC20(_uToken).safeTransfer(msg.sender, uAmountReceived);\n\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\n    require(\n      (balanceAfter - balanceBefore - uAmountReceived) == 0,\n      \"Error Withdraw: under/overflow\"\n    );\n+   uint256 sharesAfter = IERC20(_yToken).balanceOf(address(this)); \n+   if (sharesAfter > sharesBefore) {\n+       IERC20(_yToken).safeTransfer(msg.sender, sharesAfter - sharesBefore);\n+   }\n\n    return uAmountReceived;\n  }\n```\n\n\n\n## Discussion\n\n**Theezr**\n\nFix:\nhttps://github.com/derbyfinance/derby-yield-optimiser/pull/198\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/Providers/YearnProvider.sol",
      "content": "// SPDX-License-Identifier: MIT\r\n// Derby Finance - 2022\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../Interfaces/ExternalInterfaces/IYearn.sol\";\r\nimport \"../Interfaces/IProvider.sol\";\r\n\r\ncontract YearnProvider is IProvider {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Deposit the underlying asset in Yearn\r\n  /// @dev Pulls underlying asset from Vault, deposit them in Yearn, send yTokens back.\r\n  /// @param _amount Amount to deposit\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Tokens received and sent to vault\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _yToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(address(this));\r\n\r\n    IERC20(_uToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_uToken).safeIncreaseAllowance(_yToken, _amount);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(address(this));\r\n    require((balanceAfter - balanceBefore - _amount) == 0, \"Error Deposit: under/overflow\");\r\n\r\n    uint256 yTokenReceived = IYearn(_yToken).deposit(_amount);\r\n    IYearn(_yToken).transfer(msg.sender, yTokenReceived);\r\n\r\n    return yTokenReceived;\r\n  }\r\n\r\n  /// @notice Withdraw the underlying asset from Yearn\r\n  /// @dev Pulls cTokens from Vault, redeem them from Yearn, send underlying back.\r\n  /// @param _amount Amount to withdraw\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @param _uToken Address of underlying Token eg USDC\r\n  /// @return Underlying tokens received and sent to vault e.g USDC\r\n  function withdraw(\r\n    uint256 _amount,\r\n    address _yToken,\r\n    address _uToken\r\n  ) external override returns (uint256) {\r\n    uint256 balanceBefore = IERC20(_uToken).balanceOf(msg.sender);\r\n\r\n    require(\r\n      IYearn(_yToken).transferFrom(msg.sender, address(this), _amount) == true,\r\n      \"Error transferFrom\"\r\n    );\r\n\r\n    uint256 uAmountReceived = IYearn(_yToken).withdraw(_amount);\r\n    IERC20(_uToken).safeTransfer(msg.sender, uAmountReceived);\r\n\r\n    uint256 balanceAfter = IERC20(_uToken).balanceOf(msg.sender);\r\n    require(\r\n      (balanceAfter - balanceBefore - uAmountReceived) == 0,\r\n      \"Error Withdraw: under/overflow\"\r\n    );\r\n\r\n    return uAmountReceived;\r\n  }\r\n\r\n  /// @notice Get balance from address in shares i.e LP tokens\r\n  /// @param _address Address to request balance from, most likely an Vault\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @return Balance in VaultCurrency e.g USDC\r\n  function balanceUnderlying(\r\n    address _address,\r\n    address _yToken\r\n  ) public view override returns (uint256) {\r\n    uint256 balanceShares = balance(_address, _yToken);\r\n    uint256 price = exchangeRate(_yToken);\r\n    return (balanceShares * price) / 10 ** IYearn(_yToken).decimals();\r\n  }\r\n\r\n  /// @notice Calculates how many shares are equal to the amount\r\n  /// @dev Yearn scales price by 1E6\r\n  /// @param _amount Amount in underyling token e.g USDC\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function calcShares(uint256 _amount, address _yToken) external view override returns (uint256) {\r\n    uint256 shares = (_amount * (10 ** IYearn(_yToken).decimals())) / exchangeRate(_yToken);\r\n    return shares;\r\n  }\r\n\r\n  /// @notice Get balance of yToken from address\r\n  /// @param _address Address to request balance from\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @return number of shares i.e LP tokens\r\n  function balance(address _address, address _yToken) public view override returns (uint256) {\r\n    uint256 balanceShares = IYearn(_yToken).balanceOf(_address);\r\n    return balanceShares;\r\n  }\r\n\r\n  /// @notice Exchange rate of underyling protocol token\r\n  /// @param _yToken Address of protocol LP Token eg yUSDC\r\n  /// @return price of LP token\r\n  function exchangeRate(address _yToken) public view override returns (uint256) {\r\n    uint256 price = IYearn(_yToken).pricePerShare();\r\n    return price;\r\n  }\r\n\r\n  function claim(address _yToken, address _claimer) public override returns (bool) {}\r\n}"
    },
    {
      "filename": "contracts/Vault.vy",
      "content": "# @version 0.3.3\n\"\"\"\n@title Yearn Token Vault\n@license GNU AGPLv3\n@author yearn.finance\n@notice\n    Yearn Token Vault. Holds an underlying token, and allows users to interact\n    with the Yearn ecosystem through Strategies connected to the Vault.\n    Vaults are not limited to a single Strategy, they can have as many Strategies\n    as can be designed (however the withdrawal queue is capped at 20.)\n\n    Deposited funds are moved into the most impactful strategy that has not\n    already reached its limit for assets under management, regardless of which\n    Strategy a user's funds end up in, they receive their portion of yields\n    generated across all Strategies.\n\n    When a user withdraws, if there are no funds sitting undeployed in the\n    Vault, the Vault withdraws funds from Strategies in the order of least\n    impact. (Funds are taken from the Strategy that will disturb everyone's\n    gains the least, then the next least, etc.) In order to achieve this, the\n    withdrawal queue's order must be properly set and managed by the community\n    (through governance).\n\n    Vault Strategies are parameterized to pursue the highest risk-adjusted yield.\n\n    There is an \"Emergency Shutdown\" mode. When the Vault is put into emergency\n    shutdown, assets will be recalled from the Strategies as quickly as is\n    practical (given on-chain conditions), minimizing loss. Deposits are\n    halted, new Strategies may not be added, and each Strategy exits with the\n    minimum possible damage to position, while opening up deposits to be\n    withdrawn by users. There are no restrictions on withdrawals above what is\n    expected under Normal Operation.\n\n    For further details, please refer to the specification:\n    https://github.com/iearn-finance/yearn-vaults/blob/main/SPECIFICATION.md\n\"\"\"\n\nAPI_VERSION: constant(String[28]) = \"0.4.6\"\n\nfrom vyper.interfaces import ERC20\n\nimplements: ERC20\n\n\ninterface DetailedERC20:\n    def name() -> String[42]: view\n    def symbol() -> String[20]: view\n    def decimals() -> uint256: view\n\n\ninterface Strategy:\n    def want() -> address: view\n    def vault() -> address: view\n    def isActive() -> bool: view\n    def delegatedAssets() -> uint256: view\n    def estimatedTotalAssets() -> uint256: view\n    def withdraw(_amount: uint256) -> uint256: nonpayable\n    def migrate(_newStrategy: address): nonpayable\n    def emergencyExit() -> bool: view\n\nname: public(String[64])\nsymbol: public(String[32])\ndecimals: public(uint256)\n\nbalanceOf: public(HashMap[address, uint256])\nallowance: public(HashMap[address, HashMap[address, uint256]])\ntotalSupply: public(uint256)\n\ntoken: public(ERC20)\ngovernance: public(address)\nmanagement: public(address)\nguardian: public(address)\npendingGovernance: address\n\nstruct StrategyParams:\n    performanceFee: uint256  # Strategist's fee (basis points)\n    activation: uint256  # Activation block.timestamp\n    debtRatio: uint256  # Maximum borrow amount (in BPS of total assets)\n    minDebtPerHarvest: uint256  # Lower limit on the increase of debt since last harvest\n    maxDebtPerHarvest: uint256  # Upper limit on the increase of debt since last harvest\n    lastReport: uint256  # block.timestamp of the last time a report occured\n    totalDebt: uint256  # Total outstanding debt that Strategy has\n    totalGain: uint256  # Total returns that Strategy has realized for Vault\n    totalLoss: uint256  # Total losses that Strategy has realized for Vault\n\nevent Transfer:\n    sender: indexed(address)\n    receiver: indexed(address)\n    value: uint256\n\n\nevent Approval:\n    owner: indexed(address)\n    spender: indexed(address)\n    value: uint256\n\nevent Deposit:\n    recipient: indexed(address)\n    shares: uint256\n    amount: uint256\n\nevent Withdraw:\n    recipient: indexed(address)\n    shares: uint256\n    amount: uint256\n\nevent Sweep:\n    token: indexed(address)\n    amount: uint256\n\nevent LockedProfitDegradationUpdated:\n    value: uint256\n\nevent StrategyAdded:\n    strategy: indexed(address)\n    debtRatio: uint256  # Maximum borrow amount (in BPS of total assets)\n    minDebtPerHarvest: uint256  # Lower limit on the increase of debt since last harvest\n    maxDebtPerHarvest: uint256  # Upper limit on the increase of debt since last harvest\n    performanceFee: uint256  # Strategist's fee (basis points)\n\n\nevent StrategyReported:\n    strategy: indexed(address)\n    gain: uint256\n    loss: uint256\n    debtPaid: uint256\n    totalGain: uint256\n    totalLoss: uint256\n    totalDebt: uint256\n    debtAdded: uint256\n    debtRatio: uint256\n\nevent FeeReport:\n    management_fee: uint256\n    performance_fee: uint256\n    strategist_fee: uint256\n    duration: uint256\n\nevent WithdrawFromStrategy:\n    strategy: indexed(address)\n    totalDebt: uint256\n    loss: uint256\n\nevent UpdateGovernance:\n    governance: address # New active governance\n\n\nevent UpdateManagement:\n    management: address # New active manager\n\nevent UpdateRewards:\n    rewards: address # New active rewards recipient\n\n\nevent UpdateDepositLimit:\n    depositLimit: uint256 # New active deposit limit\n\n\nevent UpdatePerformanceFee:\n    performanceFee: uint256 # New active performance fee\n\n\nevent UpdateManagementFee:\n    managementFee: uint256 # New active management fee\n\n\nevent UpdateGuardian:\n    guardian: address # Address of the active guardian\n\n\nevent EmergencyShutdown:\n    active: bool # New emergency shutdown state (if false, normal operation enabled)\n\n\nevent UpdateWithdrawalQueue:\n    queue: address[MAXIMUM_STRATEGIES] # New active withdrawal queue\n\n\nevent StrategyUpdateDebtRatio:\n    strategy: indexed(address) # Address of the strategy for the debt ratio adjustment\n    debtRatio: uint256 # The new debt limit for the strategy (in BPS of total assets)\n\n\nevent StrategyUpdateMinDebtPerHarvest:\n    strategy: indexed(address) # Address of the strategy for the rate limit adjustment\n    minDebtPerHarvest: uint256  # Lower limit on the increase of debt since last harvest\n\n\nevent StrategyUpdateMaxDebtPerHarvest:\n    strategy: indexed(address) # Address of the strategy for the rate limit adjustment\n    maxDebtPerHarvest: uint256  # Upper limit on the increase of debt since last harvest\n\n\nevent StrategyUpdatePerformanceFee:\n    strategy: indexed(address) # Address of the strategy for the performance fee adjustment\n    performanceFee: uint256 # The new performance fee for the strategy\n\n\nevent StrategyMigrated:\n    oldVersion: indexed(address) # Old version of the strategy to be migrated\n    newVersion: indexed(address) # New version of the strategy\n\n\nevent StrategyRevoked:\n    strategy: indexed(address) # Address of the strategy that is revoked\n\n\nevent StrategyRemovedFromQueue:\n    strategy: indexed(address) # Address of the strategy that is removed from the withdrawal queue\n\n\nevent StrategyAddedToQueue:\n    strategy: indexed(address) # Address of the strategy that is added to the withdrawal queue\n\nevent NewPendingGovernance:\n    pendingGovernance: indexed(address)\n\n# NOTE: Track the total for overhead targeting purposes\nstrategies: public(HashMap[address, StrategyParams])\nMAXIMUM_STRATEGIES: constant(uint256) = 20\nDEGRADATION_COEFFICIENT: constant(uint256) = 10 ** 18\n\n# Ordering that `withdraw` uses to determine which strategies to pull funds from\n# NOTE: Does *NOT* have to match the ordering of all the current strategies that\n#       exist, but it is recommended that it does or else withdrawal depth is\n#       limited to only those inside the queue.\n# NOTE: Ordering is determined by governance, and should be balanced according\n#       to risk, slippage, and/or volatility. Can also be ordered to increase the\n#       withdrawal speed of a particular Strategy.\n# NOTE: The first time a ZERO_ADDRESS is encountered, it stops withdrawing\nwithdrawalQueue: public(address[MAXIMUM_STRATEGIES])\n\nemergencyShutdown: public(bool)\n\ndepositLimit: public(uint256)  # Limit for totalAssets the Vault can hold\ndebtRatio: public(uint256)  # Debt ratio for the Vault across all strategies (in BPS, <= 10k)\ntotalIdle: public(uint256)  # Amount of tokens that are in the vault\ntotalDebt: public(uint256)  # Amount of tokens that all strategies have borrowed\nlastReport: public(uint256)  # block.timestamp of last report\nactivation: public(uint256)  # block.timestamp of contract deployment\nlockedProfit: public(uint256) # how much profit is locked and cant be withdrawn\nlockedProfitDegradation: public(uint256) # rate per block of degradation. DEGRADATION_COEFFICIENT is 100% per block\nrewards: public(address)  # Rewards contract where Governance fees are sent to\n# Governance Fee for management of Vault (given to `rewards`)\nmanagementFee: public(uint256)\n# Governance Fee for performance of Vault (given to `rewards`)\nperformanceFee: public(uint256)\nMAX_BPS: constant(uint256) = 10_000  # 100%, or 10k basis points\n# NOTE: A four-century period will be missing 3 of its 100 Julian leap years, leaving 97.\n#       So the average year has 365 + 97/400 = 365.2425 days\n#       ERROR(Julian): -0.0078\n#       ERROR(Gregorian): -0.0003\n#       A day = 24 * 60 * 60 sec = 86400 sec\n#       365.2425 * 86400 = 31556952.0\nSECS_PER_YEAR: constant(uint256) = 31_556_952  # 365.2425 days\n# `nonces` track `permit` approvals with signature.\nnonces: public(HashMap[address, uint256])\nDOMAIN_TYPE_HASH: constant(bytes32) = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\nPERMIT_TYPE_HASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n\n\n@external\ndef initialize(\n    token: address,\n    governance: address,\n    rewards: address,\n    nameOverride: String[64],\n    symbolOverride: String[32],\n    guardian: address = msg.sender,\n    management: address =  msg.sender,\n):\n    \"\"\"\n    @notice\n        Initializes the Vault, this is called only once, when the contract is\n        deployed.\n        The performance fee is set to 10% of yield, per Strategy.\n        The management fee is set to 2%, per year.\n        The initial deposit limit is set to 0 (deposits disabled); it must be\n        updated after initialization.\n    @dev\n        If `nameOverride` is not specified, the name will be 'yearn'\n        combined with the name of `token`.\n\n        If `symbolOverride` is not specified, the symbol will be 'yv'\n        combined with the symbol of `token`.\n\n        The token used by the vault should not change balances outside transfers and \n        it must transfer the exact amount requested. Fee on transfer and rebasing are not supported.\n    @param token The token that may be deposited into this Vault.\n    @param governance The address authorized for governance interactions.\n    @param rewards The address to distribute rewards to.\n    @param management The address of the vault manager.\n    @param nameOverride Specify a custom Vault name. Leave empty for default choice.\n    @param symbolOverride Specify a custom Vault symbol name. Leave empty for default choice.\n    @param guardian The address authorized for guardian interactions. Defaults to caller.\n    \"\"\"\n    assert self.activation == 0  # dev: no devops199\n    self.token = ERC20(token)\n    if nameOverride == \"\":\n        self.name = concat(DetailedERC20(token).symbol(), \" yVault\")\n    else:\n        self.name = nameOverride\n    if symbolOverride == \"\":\n        self.symbol = concat(\"yv\", DetailedERC20(token).symbol())\n    else:\n        self.symbol = symbolOverride\n    decimals: uint256 = DetailedERC20(token).decimals()\n    self.decimals = decimals\n    assert decimals < 256 # dev: see VVE-2020-0001\n\n    self.governance = governance\n    log UpdateGovernance(governance)\n    self.management = management\n    log UpdateManagement(management)\n    self.rewards = rewards\n    log UpdateRewards(rewards)\n    self.guardian = guardian\n    log UpdateGuardian(guardian)\n    self.performanceFee = 1000  # 10% of yield (per Strategy)\n    log UpdatePerformanceFee(convert(1000, uint256))\n    self.managementFee = 200  # 2% per year\n    log UpdateManagementFee(convert(200, uint256))\n    self.lastReport = block.timestamp\n    self.activation = block.timestamp\n    self.lockedProfitDegradation = convert(DEGRADATION_COEFFICIENT * 46 / 10 ** 6 , uint256) # 6 hours in blocks\n    # EIP-712\n\n\n@pure\n@external\ndef apiVersion() -> String[28]:\n    \"\"\"\n    @notice\n        Used to track the deployed version of this contract. In practice you\n        can use this version number to compare with Yearn's GitHub and\n        determine which version of the source matches this deployed contract.\n    @dev\n        All strategies must have an `apiVersion()` that matches the Vault's\n        `API_VERSION`.\n    @return API_VERSION which holds the current version of this contract.\n    \"\"\"\n    return API_VERSION\n\n@view\n@internal\ndef domain_separator() -> bytes32:\n    return keccak256(\n        concat(\n            DOMAIN_TYPE_HASH,\n            keccak256(convert(\"Yearn Vault\", Bytes[11])),\n            keccak256(convert(API_VERSION, Bytes[28])),\n            convert(chain.id, bytes32),\n            convert(self, bytes32)\n        )\n    )\n\n@view\n@external\ndef DOMAIN_SEPARATOR() -> bytes32:\n    return self.domain_separator()\n\n@external\ndef setName(name: String[64]):\n    \"\"\"\n    @notice\n        Used to change the value of `name`.\n\n        This may only be called by governance.\n    @param name The new name to use.\n    \"\"\"\n    assert msg.sender == self.governance\n    self.name = name\n\n\n@external\ndef setSymbol(symbol: String[32]):\n    \"\"\"\n    @notice\n        Used to change the value of `symbol`.\n\n        This may only be called by governance.\n    @param symbol The new symbol to use.\n    \"\"\"\n    assert msg.sender == self.governance\n    self.symbol = symbol\n\n\n# 2-phase commit for a change in governance\n@external\ndef setGovernance(governance: address):\n    \"\"\"\n    @notice\n        Nominate a new address to use as governance.\n\n        The change does not go into effect immediately. This function sets a\n        pending change, and the governance address is not updated until\n        the proposed governance address has accepted the responsibility.\n\n        This may only be called by the current governance address.\n    @param governance The address requested to take over Vault governance.\n    \"\"\"\n    assert msg.sender == self.governance\n    log NewPendingGovernance(governance)\n    self.pendingGovernance = governance\n\n\n@external\ndef acceptGovernance():\n    \"\"\"\n    @notice\n        Once a new governance address has been proposed using setGovernance(),\n        this function may be called by the proposed address to accept the\n        responsibility of taking over governance for this contract.\n\n        This may only be called by the proposed governance address.\n    @dev\n        setGovernance() should be called by the existing governance address,\n        prior to calling this function.\n    \"\"\"\n    assert msg.sender == self.pendingGovernance\n    self.governance = msg.sender\n    log UpdateGovernance(msg.sender)\n\n\n@external\ndef setManagement(management: address):\n    \"\"\"\n    @notice\n        Changes the management address.\n        Management is able to make some investment decisions adjusting parameters.\n\n        This may only be called by governance.\n    @param management The address to use for managing.\n    \"\"\"\n    assert msg.sender == self.governance\n    self.management = management\n    log UpdateManagement(management)\n\n\n@external\ndef setRewards(rewards: address):\n    \"\"\"\n    @notice\n        Changes the rewards address. Any distributed rewards\n        will cease flowing to the old address and begin flowing\n        to this address once the change is in effect.\n\n        This will not change any Strategy reports in progress, only\n        new reports made after this change goes into effect.\n\n        This may only be called by governance.\n    @param rewards The address to use for collecting rewards.\n    \"\"\"\n    assert msg.sender == self.governance\n    assert not (rewards in [self, ZERO_ADDRESS])\n    self.rewards = rewards\n    log UpdateRewards(rewards)\n\n\n@external\ndef setLockedProfitDegradation(degradation: uint256):\n    \"\"\"\n    @notice\n        Changes the locked profit degradation.\n    @param degradation The rate of degradation in percent per second scaled to 1e18.\n    \"\"\"\n    assert msg.sender == self.governance\n    # Since \"degradation\" is of type uint256 it can never be less than zero\n    assert degradation <= DEGRADATION_COEFFICIENT\n    self.lockedProfitDegradation = degradation\n    log LockedProfitDegradationUpdated(degradation) \n\n\n@external\ndef setDepositLimit(limit: uint256):\n    \"\"\"\n    @notice\n        Changes the maximum amount of tokens that can be deposited in this Vault.\n\n        Note, this is not how much may be deposited by a single depositor,\n        but the maximum amount that may be deposited across all depositors.\n\n        This may only be called by governance.\n    @param limit The new deposit limit to use.\n    \"\"\"\n    assert msg.sender == self.governance\n    self.depositLimit = limit\n    log UpdateDepositLimit(limit)\n\n\n@external\ndef setPerformanceFee(fee: uint256):\n    \"\"\"\n    @notice\n        Used to change the value of `performanceFee`.\n\n        Should set this value below the maximum strategist performance fee.\n\n        This may only be called by governance.\n    @param fee The new performance fee to use.\n    \"\"\"\n    assert msg.sender == self.governance\n    assert fee <= MAX_BPS / 2\n    self.performanceFee = fee\n    log UpdatePerformanceFee(fee)\n\n\n@external\ndef setManagementFee(fee: uint256):\n    \"\"\"\n    @notice\n        Used to change the value of `managementFee`.\n\n        This may only be called by governance.\n    @param fee The new management fee to use.\n    \"\"\"\n    assert msg.sender == self.governance\n    assert fee <= MAX_BPS\n    self.managementFee = fee\n    log UpdateManagementFee(fee)\n\n\n@external\ndef setGuardian(guardian: address):\n    \"\"\"\n    @notice\n        Used to change the address of `guardian`.\n\n        This may only be called by governance or the existing guardian.\n    @param guardian The new guardian address to use.\n    \"\"\"\n    assert msg.sender in [self.guardian, self.governance]\n    self.guardian = guardian\n    log UpdateGuardian(guardian)\n\n\n@external\ndef setEmergencyShutdown(active: bool):\n    \"\"\"\n    @notice\n        Activates or deactivates Vault mode where all Strategies go into full\n        withdrawal.\n\n        During Emergency Shutdown:\n        1. No Users may deposit into the Vault (but may withdraw as usual.)\n        2. Governance may not add new Strategies.\n        3. Each Strategy must pay back their debt as quickly as reasonable to\n            minimally affect their position.\n        4. Only Governance may undo Emergency Shutdown.\n\n        See contract level note for further details.\n\n        This may only be called by governance or the guardian.\n    @param active\n        If true, the Vault goes into Emergency Shutdown. If false, the Vault\n        goes back into Normal Operation.\n    \"\"\"\n    if active:\n        assert msg.sender in [self.guardian, self.governance]\n    else:\n        assert msg.sender == self.governance\n    self.emergencyShutdown = active\n    log EmergencyShutdown(active)\n\n\n@external\ndef setWithdrawalQueue(queue: address[MAXIMUM_STRATEGIES]):\n    \"\"\"\n    @notice\n        Updates the withdrawalQueue to match the addresses and order specified\n        by `queue`.\n\n        There can be fewer strategies than the maximum, as well as fewer than\n        the total number of strategies active in the vault. `withdrawalQueue`\n        will be updated in a gas-efficient manner, assuming the input is well-\n        ordered with 0x0 only at the end.\n\n        This may only be called by governance or management.\n    @dev\n        This is order sensitive, specify the addresses in the order in which\n        funds should be withdrawn (so `queue`[0] is the first Strategy withdrawn\n        from, `queue`[1] is the second, etc.)\n\n        This means that the least impactful Strategy (the Strategy that will have\n        its core positions impacted the least by having funds removed) should be\n        at `queue`[0], then the next least impactful at `queue`[1], and so on.\n    @param queue\n        The array of addresses to use as the new withdrawal queue. This is\n        order sensitive.\n    \"\"\"\n    assert msg.sender in [self.management, self.governance]\n\n    # HACK: Temporary until Vyper adds support for Dynamic arrays\n    old_queue: address[MAXIMUM_STRATEGIES] = empty(address[MAXIMUM_STRATEGIES])\n    for i in range(MAXIMUM_STRATEGIES):\n        old_queue[i] = self.withdrawalQueue[i] \n        if queue[i] == ZERO_ADDRESS:\n            # NOTE: Cannot use this method to remove entries from the queue\n            assert old_queue[i] == ZERO_ADDRESS\n            break\n        # NOTE: Cannot use this method to add more entries to the queue\n        assert old_queue[i] != ZERO_ADDRESS\n\n        assert self.strategies[queue[i]].activation > 0\n\n        existsInOldQueue: bool = False\n        for j in range(MAXIMUM_STRATEGIES):\n            if queue[j] == ZERO_ADDRESS:\n                existsInOldQueue = True\n                break\n            if queue[i] == old_queue[j]:\n                # NOTE: Ensure that every entry in queue prior to reordering exists now\n                existsInOldQueue = True\n\n            if j <= i:\n                # NOTE: This will only check for duplicate entries in queue after `i`\n                continue\n            assert queue[i] != queue[j]  # dev: do not add duplicate strategies\n\n        assert existsInOldQueue # dev: do not add new strategies\n\n        self.withdrawalQueue[i] = queue[i]\n    log UpdateWithdrawalQueue(queue)\n\n\n@internal\ndef erc20_safe_transfer(token: address, receiver: address, amount: uint256):\n    # Used only to send tokens that are not the type managed by this Vault.\n    # HACK: Used to handle non-compliant tokens like USDT\n    response: Bytes[32] = raw_call(\n        token,\n        concat(\n            method_id(\"transfer(address,uint256)\"),\n            convert(receiver, bytes32),\n            convert(amount, bytes32),\n        ),\n        max_outsize=32,\n    )\n    if len(response) > 0:\n        assert convert(response, bool), \"Transfer failed!\"\n\n\n@internal\ndef erc20_safe_transferFrom(token: address, sender: address, receiver: address, amount: uint256):\n    # Used only to send tokens that are not the type managed by this Vault.\n    # HACK: Used to handle non-compliant tokens like USDT\n    response: Bytes[32] = raw_call(\n        token,\n        concat(\n            method_id(\"transferFrom(address,address,uint256)\"),\n            convert(sender, bytes32),\n            convert(receiver, bytes32),\n            convert(amount, bytes32),\n        ),\n        max_outsize=32,\n    )\n    if len(response) > 0:\n        assert convert(response, bool), \"Transfer failed!\"\n\n\n@internal\ndef _transfer(sender: address, receiver: address, amount: uint256):\n    # See note on `transfer()`.\n\n    # Protect people from accidentally sending their shares to bad places\n    assert receiver not in [self, ZERO_ADDRESS]\n    self.balanceOf[sender] -= amount\n    self.balanceOf[receiver] += amount\n    log Transfer(sender, receiver, amount)\n\n\n@external\ndef transfer(receiver: address, amount: uint256) -> bool:\n    \"\"\"\n    @notice\n        Transfers shares from the caller's address to `receiver`. This function\n        will always return true, unless the user is attempting to transfer\n        shares to this contract's address, or to 0x0.\n    @param receiver\n        The address shares are being transferred to. Must not be this contract's\n        address, must not be 0x0.\n    @param amount The quantity of shares to transfer.\n    @return\n        True if transfer is sent to an address other than this contract's or\n        0x0, otherwise the transaction will fail.\n    \"\"\"\n    self._transfer(msg.sender, receiver, amount)\n    return True\n\n\n@external\ndef transferFrom(sender: address, receiver: address, amount: uint256) -> bool:\n    \"\"\"\n    @notice\n        Transfers `amount` shares from `sender` to `receiver`. This operation will\n        always return true, unless the user is attempting to transfer shares\n        to this contract's address, or to 0x0.\n\n        Unless the caller has given this contract unlimited approval,\n        transfering shares will decrement the caller's `allowance` by `amount`.\n    @param sender The address shares are being transferred from.\n    @param receiver\n        The address shares are being transferred to. Must not be this contract's\n        address, must not be 0x0.\n    @param amount The quantity of shares to transfer.\n    @return\n        True if transfer is sent to an address other than this contract's or\n        0x0, otherwise the transaction will fail.\n    \"\"\"\n    # Unlimited approval (saves an SSTORE)\n    if (self.allowance[sender][msg.sender] < MAX_UINT256):\n        allowance: uint256 = self.allowance[sender][msg.sender] - amount\n        self.allowance[sender][msg.sender] = allowance\n        # NOTE: Allows log filters to have a full accounting of allowance changes\n        log Approval(sender, msg.sender, allowance)\n    self._transfer(sender, receiver, amount)\n    return True\n\n\n@external\ndef approve(spender: address, amount: uint256) -> bool:\n    \"\"\"\n    @dev Approve the passed address to spend the specified amount of tokens on behalf of\n         `msg.sender`. Beware that changing an allowance with this method brings the risk\n         that someone may use both the old and the new allowance by unfortunate transaction\n         ordering. See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    @param spender The address which will spend the funds.\n    @param amount The amount of tokens to be spent.\n    \"\"\"\n    self.allowance[msg.sender][spender] = amount\n    log Approval(msg.sender, spender, amount)\n    return True\n\n\n@external\ndef increaseAllowance(spender: address, amount: uint256) -> bool:\n    \"\"\"\n    @dev Increase the allowance of the passed address to spend the total amount of tokens\n         on behalf of msg.sender. This method mitigates the risk that someone may use both\n         the old and the new allowance by unfortunate transaction ordering.\n         See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    @param spender The address which will spend the funds.\n    @param amount The amount of tokens to increase the allowance by.\n    \"\"\"\n    self.allowance[msg.sender][spender] += amount\n    log Approval(msg.sender, spender, self.allowance[msg.sender][spender])\n    return True\n\n\n@external\ndef decreaseAllowance(spender: address, amount: uint256) -> bool:\n    \"\"\"\n    @dev Decrease the allowance of the passed address to spend the total amount of tokens\n         on behalf of msg.sender. This method mitigates the risk that someone may use both\n         the old and the new allowance by unfortunate transaction ordering.\n         See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    @param spender The address which will spend the funds.\n    @param amount The amount of tokens to decrease the allowance by.\n    \"\"\"\n    self.allowance[msg.sender][spender] -= amount\n    log Approval(msg.sender, spender, self.allowance[msg.sender][spender])\n    return True\n\n\n@external\ndef permit(owner: address, spender: address, amount: uint256, expiry: uint256, signature: Bytes[65]) -> bool:\n    \"\"\"\n    @notice\n        Approves spender by owner's signature to expend owner's tokens.\n        See https://eips.ethereum.org/EIPS/eip-2612.\n\n    @param owner The address which is a source of funds and has signed the Permit.\n    @param spender The address which is allowed to spend the funds.\n    @param amount The amount of tokens to be spent.\n    @param expiry The timestamp after which the Permit is no longer valid.\n    @param signature A valid secp256k1 signature of Permit by owner encoded as r, s, v.\n    @return True, if transaction completes successfully\n    \"\"\"\n    assert owner != ZERO_ADDRESS  # dev: invalid owner\n    assert expiry >= block.timestamp  # dev: permit expired\n    nonce: uint256 = self.nonces[owner]\n    digest: bytes32 = keccak256(\n        concat(\n            b'\\x19\\x01',\n            self.domain_separator(),\n            keccak256(\n                concat(\n                    PERMIT_TYPE_HASH,\n                    convert(owner, bytes32),\n                    convert(spender, bytes32),\n                    convert(am"
    }
  ]
}