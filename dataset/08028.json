{
  "Title": "[H-07] Attacker can DOS private party by donating ETH then calling buy",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfund.sol#L98-L116\n\n\n# Vulnerability details\n\n## Impact\n\nParty is DOS'd and may potentially lose access to NFT\n\n## Proof of Concept\n\n[Crowdfund.sol#L280-L298](https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/Crowdfund.sol#L280-L298)\n\n    party = party_ = partyFactory\n        .createParty(\n            address(this),\n            Party.PartyOptions({\n                name: name,\n                symbol: symbol,\n                governance: PartyGovernance.GovernanceOpts({\n                    hosts: governanceOpts.hosts,\n                    voteDuration: governanceOpts.voteDuration,\n                    executionDelay: governanceOpts.executionDelay,\n                    passThresholdBps: governanceOpts.passThresholdBps,\n                    totalVotingPower: _getFinalPrice().safeCastUint256ToUint96(),\n                    feeBps: governanceOpts.feeBps,\n                    feeRecipient: governanceOpts.feeRecipient\n                })\n            }),\n            preciousTokens,\n            preciousTokenIds\n        );\n\n[BuyCrowdfundBase.sol#L166-L173](https://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/crowdfund/BuyCrowdfundBase.sol#L166-L173)\n\n    function _getFinalPrice()\n        internal\n        override\n        view\n        returns (uint256)\n    {\n        return settledPrice;\n    }\n\nWhen BuyCrowdFund.sol successfully completes a buy, totalVotingPower is set to _getFinalPrice which in the case of BuyCrowdFundBase.sol returns the price at which the NFT was purchased. totalVotingPower is used by the governance contract to determine the number of votes needed for a proposal to pass. If there are not enough claimable votes to meet that threshold then the party is softlocked because it can't pass any proposals. An attacker could exploit this to DOS even a private party with the following steps:\n\n1. Wait for party to be filled to just under quorum threshold\n2. Donate ETH to the crowdfund contract\n3. Call BuyCrowdFund.sol#buy. Since it is unpermissioned even for parties with a gatekeeper, the call won't revert\n\nSince the voting power for the final amount of ETH cannot be claimed, the party is now softlocked. If emergencyExecuteDisabled is true then the party will be permanantly locked and the NFT would effectively be burned. If emergencyExecuteDisabled is false then users would have to wait for PartyDAO to reclaim the NFT.\n\n## Tools Used\n\n## Recommended Mitigation Steps\n\nPermission to call BuyCrowdFund.sol#buy should be gated if there is a gatekeeper",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/crowdfund/BuyCrowdfund.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../tokens/IERC721.sol\";\nimport \"../party/Party.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\nimport \"./BuyCrowdfundBase.sol\";\n\n/// @notice A crowdfund that purchases a specific NFT (i.e., with a known token\n///         ID) listing for a known price.\ncontract BuyCrowdfund is BuyCrowdfundBase {\n    using LibSafeERC721 for IERC721;\n    using LibSafeCast for uint256;\n\n    struct BuyCrowdfundOptions {\n        // The name of the crowdfund.\n        // This will also carry over to the governance party.\n        string name;\n        // The token symbol for both the crowdfund and the governance NFTs.\n        string symbol;\n        // The ERC721 contract of the NFT being bought.\n        IERC721 nftContract;\n        // ID of the NFT being bought.\n        uint256 nftTokenId;\n        // How long this crowdfund has to bid on the NFT, in seconds.\n        uint40 duration;\n        // Maximum amount this crowdfund will pay for the NFT.\n        // If zero, no maximum.\n        uint96 maximumPrice;\n        // An address that receives a portion of the final voting power\n        // when the party transitions into governance.\n        address payable splitRecipient;\n        // What percentage (in bps) of the final total voting power `splitRecipient`\n        // receives.\n        uint16 splitBps;\n        // If ETH is attached during deployment, it will be interpreted\n        // as a contribution. This is who gets credit for that contribution.\n        address initialContributor;\n        // If there is an initial contribution, this is who they will delegate their\n        // voting power to when the crowdfund transitions to governance.\n        address initialDelegate;\n        // The gatekeeper contract to use (if non-null) to restrict who can\n        // contribute to this crowdfund.\n        IGateKeeper gateKeeper;\n        // The gate ID within the gateKeeper contract to use.\n        bytes12 gateKeeperId;\n        // Fixed governance options (i.e. cannot be changed) that the governance\n        // `Party` will be created with if the crowdfund succeeds.\n        FixedGovernanceOpts governanceOpts;\n    }\n\n    /// @notice The NFT token ID to buy.\n    uint256 public nftTokenId;\n    /// @notice The NFT contract to buy.\n    IERC721 public nftContract;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) BuyCrowdfundBase(globals) {}\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param opts Options used to initialize the crowdfund. These are fixed\n    ///             and cannot be changed later.\n    function initialize(BuyCrowdfundOptions memory opts)\n        external\n        payable\n        onlyConstructor\n    {\n        BuyCrowdfundBase._initialize(BuyCrowdfundBaseOptions({\n            name: opts.name,\n            symbol: opts.symbol,\n            duration: opts.duration,\n            maximumPrice: opts.maximumPrice,\n            splitRecipient: opts.splitRecipient,\n            splitBps: opts.splitBps,\n            initialContributor: opts.initialContributor,\n            initialDelegate: opts.initialDelegate,\n            gateKeeper: opts.gateKeeper,\n            gateKeeperId: opts.gateKeeperId,\n            governanceOpts: opts.governanceOpts\n        }));\n        nftTokenId = opts.nftTokenId;\n        nftContract = opts.nftContract;\n    }\n\n    /// @notice Execute arbitrary calldata to perform a buy, creating a party\n    ///         if it successfully buys the NFT.\n    /// @param callTarget The target contract to call to buy the NFT.\n    /// @param callValue The amount of ETH to send with the call.\n    /// @param callData The calldata to execute.\n    /// @param governanceOpts The options used to initialize governance in the\n    ///                       `Party` instance created if the buy was successful.\n    /// @return party_ Address of the `Party` instance created after its bought.\n    function buy(\n        address payable callTarget,\n        uint96 callValue,\n        bytes calldata callData,\n        FixedGovernanceOpts memory governanceOpts\n    )\n        external\n        returns (Party party_)\n    {\n        return _buy(\n            nftContract,\n            nftTokenId,\n            callTarget,\n            callValue,\n            callData,\n            governanceOpts\n        );\n    }\n}"
    }
  ]
}