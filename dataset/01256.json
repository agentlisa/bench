{
  "Title": "Truncation in assetId if assets exceed 255",
  "Content": "# Truncation in assetId if assets exceed 255\n\n### Severity\nLow Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/OwnerFacet.sol#L55\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/facets/OwnerFacet.sol#L55</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/DataTypes.sol#L118C8-L118C23\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/DataTypes.sol#L118C8-L118C23</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/AppStorage.sol#L43\">https://github.com/Cyfrin/2023-09-ditto/blob/a93b4276420a092913f43169a353a6198d3c21b9/contracts/libraries/AppStorage.sol#L43</a>\n\n\n## Summary\nIn OwnerFacet.sol the createMarket function has an explicit conversion bug in which the higher order bits of an asset ID will be cut off if the number of assets exceeds 255.\n\n## Vulnerability Details\nIn OwnerFacet.sol the function createMarket has an explicit conversion in which the length of a dynamic array (uint256) is explicitly converted into type uint8. This conversion will have no errors as long as the number of assets does not exceed 255, (2^8 - 1). In the case the assets array in the AppStorage exceeds 255, the higher order bits of the value of the assetId in the Assets data structure will be truncated, resulting in non unique, and duplicate assetId's.\n\n## Impact\nThe main impact is that in the Asset Data Structure assetId will not be unique once the number of assets exceeds 255.\n\n## Tools Used\nManual Review\n\n## Recommendations\nSet a hard limit on the number of assets if these were not expected to exceed 255.\nIncrease the size of the assetId variable in the Assets struct.\nCompletely remove the assetId variable as it appears to have no impact to the functioning of the protocol.",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/facets/OwnerFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract OwnerFacet is Modifiers {\n    using U256 for uint256;\n\n    /**\n     * @notice Initialize data for newly deployed market\n     * @dev Single use only\n     *\n     * @param asset The market that will be impacted\n     * @param a The market settings\n     */\n\n    /*\n     * @param oracle The oracle for the asset\n     * @param initialMargin Initial margin value of the new market\n     * @param primaryLiquidationCR Liquidation ratio (Maintenance margin) value of the new market\n     * @param secondaryLiquidationCR CRatio threshold for secondary liquidations\n     * @param forcedBidPriceBuffer Liquidation limit value of the new market\n     * @param minimumCR Lowest threshold for shortRecord to not lose collateral during liquidation\n     * @param resetLiquidationTime Time limit for when flagged shorts get reset\n     * @param secondLiquidationTime Time limit for when flagged shorts can be liquidated by others, not just flagger\n     * @param firstLiquidationTime Time limit for when flagged shorts get be liquidated by flagger\n     * @param tappFeePct Primary liquidation fee sent to TAPP out of shorter collateral\n     * @param callerFeePct Primary liquidation fee sent to margin caller out of shorter collateral\n     * @param minBidEth Minimum bid dust amount\n     * @param minAskEth Minimum ask dust amount\n     * @param minShortErc Minimum short record debt amount\n    */\n\n    function createMarket(address asset, STypes.Asset memory a) external onlyDAO {\n        STypes.Asset storage Asset = s.asset[asset];\n        // can check non-zero ORDER_ID to prevent creating same asset\n        if (Asset.orderId != 0) revert Errors.MarketAlreadyCreated();\n\n        Asset.vault = a.vault;\n        _setAssetOracle(asset, a.oracle);\n\n        Asset.assetId = uint8(s.assets.length);\n        s.assetMapping[s.assets.length] = asset;\n        s.assets.push(asset);\n\n        STypes.Order memory guardOrder;\n        guardOrder.prevId = Constants.HEAD;\n        guardOrder.id = Constants.HEAD;\n        guardOrder.nextId = Constants.TAIL;\n        //@dev parts of OB depend on having sell's HEAD's price and creationTime = 0\n        s.asks[asset][Constants.HEAD] = s.shorts[asset][Constants.HEAD] = guardOrder;\n\n        //@dev Using Bid's HEAD's order contain oracle data\n        guardOrder.creationTime = LibOrders.getOffsetTime();\n        guardOrder.ercAmount = uint80(LibOracle.getOraclePrice(asset));\n        s.bids[asset][Constants.HEAD] = guardOrder;\n\n        //@dev hardcoded value\n        Asset.orderId = Constants.STARTING_ID; // 100\n        Asset.startingShortId = Constants.HEAD;\n\n        //@dev comment with initial values\n        _setInitialMargin(asset, a.initialMargin); // 500 -> 5 ether\n        _setPrimaryLiquidationCR(asset, a.primaryLiquidationCR); // 400 -> 4 ether\n        _setSecondaryLiquidationCR(asset, a.secondaryLiquidationCR); // 150 -> 1.5 ether\n        _setForcedBidPriceBuffer(asset, a.forcedBidPriceBuffer); // 110 -> 1.1 ether\n        _setMinimumCR(asset, a.minimumCR); // 110 -> 1.1 ether\n        _setResetLiquidationTime(asset, a.resetLiquidationTime); // 1600 -> 16 hours\n        _setSecondLiquidationTime(asset, a.secondLiquidationTime); // 1200 -> 12 hours\n        _setFirstLiquidationTime(asset, a.firstLiquidationTime); // 1000 -> 10 hours\n        _setTappFeePct(asset, a.tappFeePct); //25 -> .025 ether\n        _setCallerFeePct(asset, a.callerFeePct); //5 -> .005 ether\n        _setMinBidEth(asset, a.minBidEth); //1 -> 0.001 ether\n        _setMinAskEth(asset, a.minAskEth); //1 -> 0.001 ether\n        _setMinShortErc(asset, a.minShortErc); //2000 -> 2000 ether\n\n        // Create TAPP short\n        LibShortRecord.createShortRecord(\n            asset, address(this), SR.FullyFilled, 0, 0, 0, 0, 0\n        );\n        emit Events.CreateMarket(asset, Asset);\n    }\n\n    //@dev does not need read only re-entrancy\n    function owner() external view returns (address) {\n        return LibDiamond.contractOwner();\n    }\n\n    function admin() external view returns (address) {\n        return s.admin;\n    }\n\n    //@dev does not need read only re-entrancy\n    function ownerCandidate() external view returns (address) {\n        return s.ownerCandidate;\n    }\n\n    function transferOwnership(address newOwner) external onlyDAO {\n        s.ownerCandidate = newOwner;\n        emit Events.NewOwnerCandidate(newOwner);\n    }\n\n    //@dev event emitted in setContractOwner\n    function claimOwnership() external {\n        if (s.ownerCandidate != msg.sender) revert Errors.NotOwnerCandidate();\n        LibDiamond.setContractOwner(msg.sender);\n        delete s.ownerCandidate;\n    }\n\n    //No need for claim step because DAO can also set admin\n    function transferAdminship(address newAdmin) external onlyAdminOrDAO {\n        s.admin = newAdmin;\n        emit Events.NewAdmin(newAdmin);\n    }\n\n    //When deactivating an asset make sure to zero out the oracle.\n    function setAssetOracle(address asset, address oracle) external onlyDAO {\n        _setAssetOracle(asset, oracle);\n        emit Events.UpdateAssetOracle(asset, oracle);\n    }\n\n    function createVault(\n        address zeth,\n        uint256 vault,\n        MTypes.CreateVaultParams calldata params\n    ) external onlyDAO {\n        if (s.zethVault[zeth] != 0) revert Errors.VaultAlreadyCreated();\n        s.zethVault[zeth] = vault;\n        _setTithe(vault, params.zethTithePercent);\n        _setDittoMatchedRate(vault, params.dittoMatchedRate);\n        _setDittoShorterRate(vault, params.dittoShorterRate);\n        emit Events.CreateVault(zeth, vault);\n    }\n\n    // Update eligibility requirements for yield accrual\n    function setTithe(uint256 vault, uint16 zethTithePercent) external onlyAdminOrDAO {\n        _setTithe(vault, zethTithePercent);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    function setDittoMatchedRate(uint256 vault, uint16 rewardRate)\n        external\n        onlyAdminOrDAO\n    {\n        _setDittoMatchedRate(vault, rewardRate);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    function setDittoShorterRate(uint256 vault, uint16 rewardRate)\n        external\n        onlyAdminOrDAO\n    {\n        _setDittoShorterRate(vault, rewardRate);\n        emit Events.ChangeVaultSetting(vault);\n    }\n\n    // For Short Record collateral ratios\n    // initialMargin > primaryLiquidationCR > secondaryLiquidationCR > minimumCR\n    // After initial market creation. Set CRs from smallest to largest to prevent triggering the require checks\n\n    function setInitialMargin(address asset, uint16 value) external onlyAdminOrDAO {\n        require(value > s.asset[asset].primaryLiquidationCR, \"below primary liquidation\");\n        _setInitialMargin(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setPrimaryLiquidationCR(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        require(\n            value > s.asset[asset].secondaryLiquidationCR, \"below secondary liquidation\"\n        );\n        _setPrimaryLiquidationCR(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setSecondaryLiquidationCR(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setSecondaryLiquidationCR(asset, value);\n        require(\n            LibAsset.secondaryLiquidationCR(asset) > LibAsset.minimumCR(asset),\n            \"below minimum CR\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setForcedBidPriceBuffer(address asset, uint8 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setForcedBidPriceBuffer(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinimumCR(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinimumCR(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    // Used for Primary Margin Call\n    // resetLiquidationTime > secondLiquidationTime > firstLiquidationTime\n\n    function setResetLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setResetLiquidationTime(asset, value);\n        require(\n            value >= s.asset[asset].secondLiquidationTime, \"below secondLiquidationTime\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setSecondLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setSecondLiquidationTime(asset, value);\n        require(\n            value >= s.asset[asset].firstLiquidationTime, \"below firstLiquidationTime\"\n        );\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setFirstLiquidationTime(address asset, uint16 value)\n        external\n        onlyAdminOrDAO\n    {\n        _setFirstLiquidationTime(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setTappFeePct(address asset, uint8 value) external onlyAdminOrDAO {\n        _setTappFeePct(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setCallerFeePct(address asset, uint8 value) external onlyAdminOrDAO {\n        _setCallerFeePct(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinBidEth(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinBidEth(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinAskEth(address asset, uint8 value) external onlyAdminOrDAO {\n        _setMinAskEth(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function setMinShortErc(address asset, uint16 value) external onlyAdminOrDAO {\n        _setMinShortErc(asset, value);\n        emit Events.ChangeMarketSetting(asset);\n    }\n\n    function createBridge(\n        address bridge,\n        uint256 vault,\n        uint16 withdrawalFee,\n        uint8 unstakeFee\n    ) external onlyDAO {\n        s.vaultBridges[vault].push(bridge);\n        s.bridge[bridge].vault = uint8(vault);\n        _setWithdrawalFee(bridge, withdrawalFee);\n        _setUnstakeFee(bridge, unstakeFee);\n        emit Events.CreateBridge(bridge, s.bridge[bridge]);\n    }\n\n    function deleteBridge(address bridge) external onlyDAO {\n        uint256 vault = s.bridge[bridge].vault;\n        if (vault == 0) revert Errors.InvalidBridge();\n\n        address[] storage VaultBridges = s.vaultBridges[vault];\n        uint256 length = VaultBridges.length;\n        for (uint256 i; i < length; i++) {\n            if (VaultBridges[i] == bridge) {\n                if (i != length - 1) {\n                    VaultBridges[i] = VaultBridges[length - 1];\n                }\n                VaultBridges.pop();\n                break;\n            }\n        }\n        delete s.bridge[bridge];\n        emit Events.DeleteBridge(bridge);\n    }\n\n    function setWithdrawalFee(address bridge, uint16 withdrawalFee)\n        external\n        onlyAdminOrDAO\n    {\n        _setWithdrawalFee(bridge, withdrawalFee);\n        emit Events.ChangeBridgeSetting(bridge);\n    }\n\n    function setUnstakeFee(address bridge, uint8 unstakeFee) external onlyAdminOrDAO {\n        _setUnstakeFee(bridge, unstakeFee);\n        emit Events.ChangeBridgeSetting(bridge);\n    }\n\n    function _setAssetOracle(address asset, address oracle) private {\n        if (asset == address(0) || oracle == address(0)) revert Errors.ParameterIsZero();\n        s.asset[asset].oracle = oracle;\n    }\n\n    function _setTithe(uint256 vault, uint16 zethTithePercent) private {\n        if (zethTithePercent > 33_33) revert Errors.InvalidTithe();\n        s.vault[vault].zethTithePercent = zethTithePercent;\n    }\n\n    function _setDittoMatchedRate(uint256 vault, uint16 rewardRate) private {\n        require(rewardRate <= 100, \"above 100\");\n        s.vault[vault].dittoMatchedRate = rewardRate;\n    }\n\n    function _setDittoShorterRate(uint256 vault, uint16 rewardRate) private {\n        require(rewardRate <= 100, \"above 100\");\n        s.vault[vault].dittoShorterRate = rewardRate;\n    }\n\n    function _setInitialMargin(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\");\n        s.asset[asset].initialMargin = value;\n        require(LibAsset.initialMargin(asset) < Constants.CRATIO_MAX, \"above max CR\");\n    }\n\n    function _setPrimaryLiquidationCR(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\");\n        require(value <= 500, \"above 5.0\");\n        require(value < s.asset[asset].initialMargin, \"above initial margin\");\n        s.asset[asset].primaryLiquidationCR = value;\n    }\n\n    function _setSecondaryLiquidationCR(address asset, uint16 value) private {\n        require(value > 100, \"below 1.0\");\n        require(value <= 500, \"above 5.0\");\n        require(value < s.asset[asset].primaryLiquidationCR, \"above primary liquidation\");\n        s.asset[asset].secondaryLiquidationCR = value;\n    }\n\n    function _setForcedBidPriceBuffer(address asset, uint8 value) private {\n        require(value >= 100, \"below 1.0\");\n        require(value <= 200, \"above 2.0\");\n        s.asset[asset].forcedBidPriceBuffer = value;\n    }\n\n    function _setMinimumCR(address asset, uint8 value) private {\n        require(value >= 100, \"below 1.0\");\n        require(value <= 200, \"above 2.0\");\n        s.asset[asset].minimumCR = value;\n        require(\n            LibAsset.minimumCR(asset) < LibAsset.secondaryLiquidationCR(asset),\n            \"above secondary liquidation\"\n        );\n    }\n\n    // Used for Primary Margin Call\n    // resetLiquidationTime > secondLiquidationTime > firstLiquidationTime\n\n    function _setResetLiquidationTime(address asset, uint16 value) private {\n        require(value >= 100, \"below 1.00\");\n        require(value <= 4800, \"above 48.00\");\n        s.asset[asset].resetLiquidationTime = value;\n    }\n\n    function _setSecondLiquidationTime(address asset, uint16 value) private {\n        require(value >= 100, \"below 1.00\");\n        require(\n            value <= s.asset[asset].resetLiquidationTime, \"above resetLiquidationTime\"\n        );\n        s.asset[asset].secondLiquidationTime = value;\n    }\n\n    function _setFirstLiquidationTime(address asset, uint16 value) private {\n        require(value >= 100, \"below 1.00\");\n        require(\n            value <= s.asset[asset].secondLiquidationTime, \"above secondLiquidationTime\"\n        );\n        s.asset[asset].firstLiquidationTime = value;\n    }\n\n    function _setTappFeePct(address asset, uint8 value) private {\n        require(value > 0, \"Can't be zero\");\n        require(value <= 250, \"above 25.0\");\n        s.asset[asset].tappFeePct = value;\n    }\n\n    function _setCallerFeePct(address asset, uint8 value) private {\n        require(value > 0, \"Can't be zero\");\n        require(value <= 250, \"above 25.0\");\n        s.asset[asset].callerFeePct = value;\n    }\n\n    function _setMinBidEth(address asset, uint8 value) private {\n        //no upperboard check because uint8 max - 255\n        require(value > 0, \"Can't be zero\");\n        s.asset[asset].minBidEth = value;\n    }\n\n    function _setMinAskEth(address asset, uint8 value) private {\n        //no upperboard check because uint8 max - 255\n        require(value > 0, \"Can't be zero\");\n        s.asset[asset].minAskEth = value;\n    }\n\n    function _setMinShortErc(address asset, uint16 value) private {\n        //no upperboard check because uint8 max - 65,535\n        require(value > 0, \"Can't be zero\");\n        s.asset[asset].minShortErc = value;\n    }\n\n    function _setWithdrawalFee(address bridge, uint16 withdrawalFee) private {\n        require(withdrawalFee <= 1500, \"above 15.00%\");\n        s.bridge[bridge].withdrawalFee = withdrawalFee;\n    }\n\n    function _setUnstakeFee(address bridge, uint8 unstakeFee) private {\n        require(unstakeFee <= 250, \"above 2.50%\");\n        s.bridge[bridge].unstakeFee = unstakeFee;\n    }\n}"
    },
    {
      "filename": "contracts/libraries/DataTypes.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\n// import {console} from \"contracts/libraries/console.sol\";\n\n//@dev leave room for others frozen types\n//@dev Asset frozen status\nenum F {\n    Unfrozen,\n    Permanent\n}\n\n// @dev if this is changed, modify orderTypetoString in libraries/console.sol\n// @dev Order types\nenum O {\n    Uninitialized,\n    LimitBid,\n    LimitAsk,\n    MarketBid,\n    MarketAsk,\n    LimitShort,\n    Cancelled,\n    Matched\n}\n\n// @dev ShortRecord status\nenum SR {\n    PartialFill,\n    FullyFilled,\n    Cancelled\n}\n\n// @dev oracle frequency\nenum OF {\n    OneHour,\n    FifteenMinutes\n}\n\n// 2**n-1 with 18 decimals (prices, amount)\n// uint64 = 18.45\n// uint72 = 4.722k\n// uint80 = 1.2m\n// uint88 = 300m\n// uint96 = 79B\n// uint104 = 1.2t\n\n// DataTypes used in storage\nlibrary STypes {\n    // 2 slots\n    struct Order {\n        // SLOT 1: 88 + 80 + 16 + 16 + 16 + 8 + 8 + 16 + 8 = 256\n        uint88 ercAmount; // max 300m erc\n        uint80 price; // max 1.2m eth\n        // max orders 65k, with id re-use\n        uint16 prevId;\n        uint16 id;\n        uint16 nextId;\n        O orderType;\n        O prevOrderType;\n        // @dev storing as 500 with 2 decimals -> 5.00 ether\n        uint16 initialMargin; // @dev only used for LimitShort\n        uint8 shortRecordId; // @dev only used for LimitShort\n        // SLOT 2: 160 + 32 = 192 (64 unused)\n        address addr; // 160\n        // @dev diff against contract creation timestamp to prevent overflow in 2106\n        uint32 creationTime; // seconds\n        uint64 filler;\n    }\n\n    // 2 slots\n    // @dev zethYieldRate should match Vault\n    struct ShortRecord {\n        // SLOT 1: 88 + 88 + 8 + 8 + 8 + 8 = 208 (48 remaining)\n        uint88 collateral; // price * ercAmount * initialMargin\n        uint88 ercDebt; // same as Order.ercAmount\n        SR status;\n        uint8 prevId;\n        uint8 id;\n        uint8 nextId;\n        // SLOT 2: 80 + 64 + 40 + 24 + 24 = 224 (24 remaining)\n        uint80 zethYieldRate;\n        uint64 ercDebtRate; // socialized penalty rate\n        uint40 tokenId; //As of 2023, Ethereum had ~2B total tx. Uint40 max value is 1T, which is more than enough\n        uint24 flaggerId;\n        uint24 updatedAt; // hours\n    }\n\n    struct NFT {\n        // SLOT 1: 160 + 8 + 8 = 176 (80 unused)\n        address owner;\n        uint8 assetId;\n        uint8 shortRecordId;\n    }\n\n    // uint8:  [0-255]\n    // uint16: [0-65_535]\n    // @dev see testMultiAssetSettings()\n    struct Asset {\n        // SLOT 1: 104 + 88 + 16 + 16 + 16 + 8 + 8 = 256 (0 unused)\n        uint104 ercDebt; // max 20.2T\n        uint88 zethCollateral;\n        uint16 startingShortId;\n        uint16 orderId; // max is uint16 but need to throw/handle that?\n        uint16 initialMargin; // 5 ether -> [1-10, 2 decimals]\n        F frozen; // 0 or 1\n        uint8 vault;\n        // SLOT 2 (Liquidation Parameters)\n        // 64 + 16*6 + 8*7 = 216 (40 unused)\n        // socialized penalty rate\n        uint64 ercDebtRate; // max 18x\n        uint16 minShortErc; // 2000 -> (2000 * 10**18) -> 2000 ether\n        uint16 resetLiquidationTime; // 16 hours -> [1-48 hours, 2 decimals]\n        uint16 secondLiquidationTime; // 12 hours -> [1-48 hours, 2 decimals]\n        uint16 firstLiquidationTime; // 10 hours -> [1-48 hours, 2 decimals]\n        uint16 primaryLiquidationCR; // 4 ether -> [1-5, 2 decimals]\n        uint16 secondaryLiquidationCR; // 1.5 ether -> [1-5, 2 decimals]\n        uint8 minimumCR; // 1.1 ether -> [1-2, 2 decimals]\n        uint8 assetId;\n        uint8 minBidEth; // 1 -> (1 * 10**18 / 10**3) = .001 ether\n        uint8 minAskEth; // 1 -> (1 * 10**18 / 10**3) = .001 ether\n        uint8 forcedBidPriceBuffer; // 1.1 ether -> [1-2, 2 decimals]\n        uint8 tappFeePct;\n        uint8 callerFeePct;\n        uint40 filler2;\n        // SLOT 3 (Chainlink)\n        address oracle; // for non-usd asset\n        uint96 filler; // keep slots distinct\n    }\n\n    // 3 slots\n    // @dev zethYieldRate should match ShortRecord\n    struct Vault {\n        // SLOT 1: 88 + 88 + 80 = 256 (0 unused)\n        uint88 zethCollateral; // max 309m, 18 decimals\n        uint88 zethTotal; // max 309m, 18 decimals\n        uint80 zethYieldRate; // onlyUp\n        // SLOT 2: 88 + 32 + 16 = 136 (120 unused)\n        // tracked for shorter ditto rewards\n        uint88 zethCollateralReward; // onlyUp\n        uint32 dittoShorterRate; // per unit of zethCollateral\n        uint16 zethTithePercent; // [0-100, 2 decimals]\n        uint120 filler2;\n        // SLOT 3: 128 + 96 + 16 + 16 = 256\n        uint128 dittoMatchedShares;\n        uint96 dittoMatchedReward; // max 79B, 18 decimals\n        uint16 dittoMatchedRate;\n        uint16 dittoMatchedTime; // last claim (in days) from STARTING_TIME\n    }\n\n    // 1 slots\n    struct AssetUser {\n        // SLOT 1: 104 + 24 + 24 + 8 = 160 (96 unused)\n        uint104 ercEscrowed;\n        uint24 g_flaggerId;\n        uint24 g_updatedAt; // represents the most recent flag - in hours\n        uint8 shortRecordId;\n        uint96 filler;\n    }\n\n    // 1 slots\n    struct VaultUser {\n        // SLOT 1: 88 + 88 + 80 = 256 (0 unused)\n        uint88 ethEscrowed;\n        uint88 dittoMatchedShares;\n        uint80 dittoReward; // max 1.2m, 18 decimals\n    }\n\n    struct Bridge {\n        // SLOT 1: 16 + 8 + 8 = 32 (224 unused)\n        uint16 withdrawalFee;\n        uint8 unstakeFee;\n        uint8 vault;\n    }\n}\n\n// @dev DataTypes only used in memory\nlibrary MTypes {\n    struct OrderHint {\n        uint16 hintId;\n        uint256 creationTime;\n    }\n\n    struct BatchMC {\n        address shorter;\n        uint8 shortId;\n    }\n\n    struct Match {\n        uint88 fillEth;\n        uint88 fillErc;\n        uint88 colUsed;\n        uint88 dittoMatchedShares;\n        // Below used only for bids\n        uint88 shortFillEth; // Includes colUsed + fillEth from shorts\n        uint96 askFillErc; // Subset of fillErc\n        bool ratesQueried; // Save gas when matching shorts\n        uint80 zethYieldRate;\n        uint64 ercDebtRate;\n    }\n\n    struct ExitShort {\n        address asset;\n        uint256 ercDebt;\n        uint88 collateral;\n        uint88 ethFilled;\n        uint88 ercAmountLeft;\n        uint88 ercFilled;\n        uint256 beforeExitCR;\n    }\n\n    struct CombineShorts {\n        bool shortFlagExists;\n        uint24 shortUpdatedAt;\n    }\n\n    struct MarginCallPrimary {\n        address asset;\n        uint256 vault;\n        STypes.ShortRecord short;\n        address shorter;\n        uint256 cRatio;\n        uint80 oraclePrice;\n        uint256 forcedBidPriceBuffer;\n        uint256 ethDebt;\n        uint88 ethFilled;\n        uint88 ercDebtMatched;\n        bool loseCollateral;\n        uint256 tappFeePct;\n        uint256 callerFeePct;\n        uint88 gasFee;\n        uint88 totalFee; // gasFee + tappFee + callerFee\n        uint256 minimumCR;\n    }\n\n    struct MarginCallSecondary {\n        address asset;\n        uint256 vault;\n        STypes.ShortRecord short;\n        address shorter;\n        uint256 cRatio;\n        uint256 minimumCR;\n        uint88 liquidatorCollateral;\n    }\n\n    struct BidMatchAlgo {\n        uint16 askId;\n        uint16 shortHintId;\n        uint16 shortId;\n        uint16 prevShortId;\n        uint16 firstShortIdBelowOracle;\n        uint16 matchedAskId;\n        uint16 matchedShortId;\n        bool isMovingBack;\n        bool isMovingFwd;\n        uint256 oraclePrice;\n    }\n\n    struct CreateVaultParams {\n        uint16 zethTithePercent;\n        uint16 dittoMatchedRate;\n        uint16 dittoShorterRate;\n    }\n\n    struct CreateLimitShortParam {\n        address asset;\n        uint256 eth;\n        uint256 minShortErc;\n        uint256 minAskEth;\n        uint16 startingId;\n        uint256 oraclePrice;\n    }\n}"
    },
    {
      "filename": "contracts/libraries/AppStorage.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {STypes, F, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {LibDiamond} from \"contracts/libraries/LibDiamond.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nstruct AppStorage {\n    address admin;\n    address ownerCandidate;\n    address baseOracle;\n    uint24 flaggerIdCounter;\n    uint40 tokenIdCounter; //NFT - As of 2023, Ethereum had ~2B total tx. Uint40 max value is 1T, which is more than enough for NFTs\n    uint8 reentrantStatus;\n    // ZETH\n    mapping(address zeth => uint256 vault) zethVault;\n    // Bridge\n    mapping(address bridge => STypes.Bridge) bridge;\n    // Vault\n    mapping(uint256 vault => STypes.Vault) vault;\n    mapping(uint256 vault => address[]) vaultBridges;\n    mapping(uint256 vault => mapping(address account => STypes.VaultUser)) vaultUser;\n    // Assets\n    mapping(address asset => STypes.Asset) asset;\n    mapping(address asset => mapping(address account => STypes.AssetUser)) assetUser;\n    // Assets - Orderbook\n    mapping(address asset => mapping(uint16 id => STypes.Order)) bids;\n    mapping(address asset => mapping(uint16 id => STypes.Order)) asks;\n    mapping(address asset => mapping(uint16 id => STypes.Order)) shorts;\n    mapping(\n        address asset\n            => mapping(address account => mapping(uint8 id => STypes.ShortRecord))\n        ) shortRecords;\n    mapping(uint24 flaggerId => address flagger) flagMapping;\n    // ERC721\n    mapping(uint256 tokenId => STypes.NFT) nftMapping;\n    mapping(uint256 tokenId => address) getApproved;\n    mapping(address owner => mapping(address operator => bool)) isApprovedForAll;\n    // ERC721 - Assets\n    address[] assets;\n    mapping(uint256 assetId => address) assetMapping;\n    // ERC721 - METADATA STORAGE/LOGIC\n    string name;\n    string symbol;\n}\n\nfunction appStorage() pure returns (AppStorage storage s) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n        s.slot := 0\n    }\n}\n\ncontract Modifiers {\n    AppStorage internal s;\n\n    modifier onlyDAO() {\n        LibDiamond.enforceIsContractOwner();\n        _;\n    }\n\n    modifier onlyAdminOrDAO() {\n        if (msg.sender != LibDiamond.contractOwner() && msg.sender != s.admin) {\n            revert Errors.NotOwnerOrAdmin();\n        }\n        _;\n    }\n\n    modifier onlyDiamond() {\n        if (msg.sender != address(this)) revert Errors.NotDiamond();\n        _;\n    }\n\n    modifier onlyValidAsset(address asset) {\n        if (s.asset[asset].vault == 0) revert Errors.InvalidAsset();\n        _;\n    }\n\n    modifier isNotFrozen(address asset) {\n        if (s.asset[asset].frozen != F.Unfrozen) revert Errors.AssetIsFrozen();\n        _;\n    }\n\n    modifier isPermanentlyFrozen(address asset) {\n        if (s.asset[asset].frozen != F.Permanent) {\n            revert Errors.AssetIsNotPermanentlyFrozen();\n        }\n        _;\n    }\n\n    function _onlyValidShortRecord(address asset, address shorter, uint8 id)\n        internal\n        view\n    {\n        uint8 maxId = s.assetUser[asset][shorter].shortRecordId;\n        if (id >= maxId) revert Errors.InvalidShortId();\n        if (id < Constants.SHORT_STARTING_ID) revert Errors.InvalidShortId();\n        if (s.shortRecords[asset][shorter][id].status == SR.Cancelled) {\n            revert Errors.InvalidShortId();\n        }\n    }\n\n    modifier onlyValidShortRecord(address asset, address shorter, uint8 id) {\n        _onlyValidShortRecord(asset, shorter, id);\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (s.reentrantStatus == Constants.ENTERED) revert Errors.ReentrantCall();\n        s.reentrantStatus = Constants.ENTERED;\n        _;\n        s.reentrantStatus = Constants.NOT_ENTERED;\n    }\n\n    modifier nonReentrantView() {\n        if (s.reentrantStatus == Constants.ENTERED) revert Errors.ReentrantCallView();\n        _;\n    }\n\n    modifier onlyValidBridge(address bridge) {\n        if (s.bridge[bridge].vault == 0) revert Errors.InvalidBridge();\n        _;\n    }\n}"
    }
  ]
}