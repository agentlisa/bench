{
  "Title": "Wrong Cost Accounting",
  "Content": "The `Cost` function of the `transaction.go` file supposedly determines the L2 transaction cost that a user is charged. This is calculated as `GasPrice * GasLimit` for the maximum gas cost, adding the transaction `Value`, and optionally adding the blob transaction costs as `BlobGas * BlobGasFeeCap` (which is not yet supported). When the function was patched to add the optional blob costs, the team introduced a copy-paste mistake by removing the `Value` cost addition. As such, while the return value was interpreted to include the `Value`, it actually did not. This has a bad impact on the transaction validation of the transaction pools [[1](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/core/txpool/txpool.go#L690), [2](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/light/txpool.go#L404)] where it is checked whether the user's balance covers the transaction costs.\n\n\nHowever, as the cost does not include the transaction value, a transaction the user could not afford by value would still be added to the pool as valid. Then, when the transaction is processed during `state_transition.go` to buy gas, the [balance check is performed](https://github.com/mantlenetworkio/op-geth/blob/4d05b2cd9a2b8096680eb9b2e87e473a44a43922/core/state_transition.go#L308) again, this time with the `Value`, which causes the transaction to revert without charging the user. This leads to a DoS attack vector, where an attacker can spam the network with lucrative transactions that would be prioritized by the node, but never get executed at no cost while also preventing other transactions from being added to the transaction pool, effectively causing the blockchain to stop working.\n\n\nConsider adding the transaction `Value` to the transaction cost. Also, consider whether the code redundancy of cost calculation can be better managed with one or two methods.\n\n\n***Update:** Resolved in [pull request #41](https://github.com/mantlenetworkio/op-geth/pull/41) at commit [44c9a41](https://github.com/mantlenetworkio/op-geth/pull/41/commits/44c9a4154ba92dd32def5957f6b51d420aa382ad).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "core/txpool/txpool.go",
      "content": "// Copyright 2014 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage txpool\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\t\"sort\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/common/prque\"\n\t\"github.com/ethereum/go-ethereum/consensus/misc\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\t\"github.com/ethereum/go-ethereum/core/state\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/event\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/metrics\"\n\t\"github.com/ethereum/go-ethereum/params\"\n)\n\nconst (\n\t// chainHeadChanSize is the size of channel listening to ChainHeadEvent.\n\tchainHeadChanSize = 10\n\n\t// txSlotSize is used to calculate how many data slots a single transaction\n\t// takes up based on its size. The slots are used as DoS protection, ensuring\n\t// that validating a new transaction remains a constant operation (in reality\n\t// O(maxslots), where max slots are 4 currently).\n\ttxSlotSize = 32 * 1024\n\n\t// txMaxSize is the maximum size a single transaction can have. This field has\n\t// non-trivial consequences: larger transactions are significantly harder and\n\t// more expensive to propagate; larger transactions also take more resources\n\t// to validate whether they fit into the pool or not.\n\ttxMaxSize = 4 * txSlotSize // 128KB\n)\n\nvar (\n\t// ErrAlreadyKnown is returned if the transactions is already contained\n\t// within the pool.\n\tErrAlreadyKnown = errors.New(\"already known\")\n\n\t// ErrInvalidSender is returned if the transaction contains an invalid signature.\n\tErrInvalidSender = errors.New(\"invalid sender\")\n\n\t// ErrUnderpriced is returned if a transaction's gas price is below the minimum\n\t// configured for the transaction pool.\n\tErrUnderpriced = errors.New(\"transaction underpriced\")\n\n\t// ErrTxPoolOverflow is returned if the transaction pool is full and can't accept\n\t// another remote transaction.\n\tErrTxPoolOverflow = errors.New(\"txpool is full\")\n\n\t// ErrReplaceUnderpriced is returned if a transaction is attempted to be replaced\n\t// with a different one without the required price bump.\n\tErrReplaceUnderpriced = errors.New(\"replacement transaction underpriced\")\n\n\t// ErrGasLimit is returned if a transaction's requested gas limit exceeds the\n\t// maximum allowance of the current block.\n\tErrGasLimit = errors.New(\"exceeds block gas limit\")\n\n\t// ErrNegativeValue is a sanity error to ensure no one is able to specify a\n\t// transaction with a negative value.\n\tErrNegativeValue = errors.New(\"negative value\")\n\n\t// ErrOversizedData is returned if the input data of a transaction is greater\n\t// than some meaningful limit a user might use. This is not a consensus error\n\t// making the transaction invalid, rather a DOS protection.\n\tErrOversizedData = errors.New(\"oversized data\")\n\n\t// ErrFutureReplacePending is returned if a future transaction replaces a pending\n\t// transaction. Future transactions should only be able to replace other future transactions.\n\tErrFutureReplacePending = errors.New(\"future transaction tries to replace pending\")\n\n\t// ErrOverdraft is returned if a transaction would cause the senders balance to go negative\n\t// thus invalidating a potential large number of transactions.\n\tErrOverdraft = errors.New(\"transaction would cause overdraft\")\n)\n\nvar (\n\tevictionInterval    = time.Minute     // Time interval to check for evictable transactions\n\tstatsReportInterval = 8 * time.Second // Time interval to report transaction pool stats\n\n\t// L1 Info Gas Overhead is the amount of gas the the L1 info deposit consumes.\n\t// It is removed from the tx pool max gas to better indicate that L2 transactions\n\t// are not able to consume all of the gas in a L2 block as the L1 info deposit is always present.\n\tl1InfoGasOverhead = uint64(70_000)\n)\n\nvar (\n\t// Metrics for the pending pool\n\tpendingDiscardMeter   = metrics.NewRegisteredMeter(\"txpool/pending/discard\", nil)\n\tpendingReplaceMeter   = metrics.NewRegisteredMeter(\"txpool/pending/replace\", nil)\n\tpendingRateLimitMeter = metrics.NewRegisteredMeter(\"txpool/pending/ratelimit\", nil) // Dropped due to rate limiting\n\tpendingNofundsMeter   = metrics.NewRegisteredMeter(\"txpool/pending/nofunds\", nil)   // Dropped due to out-of-funds\n\n\t// Metrics for the queued pool\n\tqueuedDiscardMeter   = metrics.NewRegisteredMeter(\"txpool/queued/discard\", nil)\n\tqueuedReplaceMeter   = metrics.NewRegisteredMeter(\"txpool/queued/replace\", nil)\n\tqueuedRateLimitMeter = metrics.NewRegisteredMeter(\"txpool/queued/ratelimit\", nil) // Dropped due to rate limiting\n\tqueuedNofundsMeter   = metrics.NewRegisteredMeter(\"txpool/queued/nofunds\", nil)   // Dropped due to out-of-funds\n\tqueuedEvictionMeter  = metrics.NewRegisteredMeter(\"txpool/queued/eviction\", nil)  // Dropped due to lifetime\n\n\t// General tx metrics\n\tknownTxMeter       = metrics.NewRegisteredMeter(\"txpool/known\", nil)\n\tvalidTxMeter       = metrics.NewRegisteredMeter(\"txpool/valid\", nil)\n\tinvalidTxMeter     = metrics.NewRegisteredMeter(\"txpool/invalid\", nil)\n\tunderpricedTxMeter = metrics.NewRegisteredMeter(\"txpool/underpriced\", nil)\n\toverflowedTxMeter  = metrics.NewRegisteredMeter(\"txpool/overflowed\", nil)\n\n\t// throttleTxMeter counts how many transactions are rejected due to too-many-changes between\n\t// txpool reorgs.\n\tthrottleTxMeter = metrics.NewRegisteredMeter(\"txpool/throttle\", nil)\n\t// reorgDurationTimer measures how long time a txpool reorg takes.\n\treorgDurationTimer = metrics.NewRegisteredTimer(\"txpool/reorgtime\", nil)\n\t// dropBetweenReorgHistogram counts how many drops we experience between two reorg runs. It is expected\n\t// that this number is pretty low, since txpool reorgs happen very frequently.\n\tdropBetweenReorgHistogram = metrics.NewRegisteredHistogram(\"txpool/dropbetweenreorg\", nil, metrics.NewExpDecaySample(1028, 0.015))\n\n\tpendingGauge = metrics.NewRegisteredGauge(\"txpool/pending\", nil)\n\tqueuedGauge  = metrics.NewRegisteredGauge(\"txpool/queued\", nil)\n\tlocalGauge   = metrics.NewRegisteredGauge(\"txpool/local\", nil)\n\tslotsGauge   = metrics.NewRegisteredGauge(\"txpool/slots\", nil)\n\n\treheapTimer = metrics.NewRegisteredTimer(\"txpool/reheap\", nil)\n)\n\n// TxStatus is the current status of a transaction as seen by the pool.\ntype TxStatus uint\n\nconst (\n\tTxStatusUnknown TxStatus = iota\n\tTxStatusQueued\n\tTxStatusPending\n\tTxStatusIncluded\n)\n\n// blockChain provides the state of blockchain and current gas limit to do\n// some pre checks in tx pool and event subscribers.\ntype blockChain interface {\n\tCurrentBlock() *types.Header\n\tGetBlock(hash common.Hash, number uint64) *types.Block\n\tStateAt(root common.Hash) (*state.StateDB, error)\n\n\tSubscribeChainHeadEvent(ch chan<- core.ChainHeadEvent) event.Subscription\n}\n\n// Config are the configuration parameters of the transaction pool.\ntype Config struct {\n\tLocals    []common.Address // Addresses that should be treated by default as local\n\tNoLocals  bool             // Whether local transaction handling should be disabled\n\tJournal   string           // Journal of local transactions to survive node restarts\n\tRejournal time.Duration    // Time interval to regenerate the local transaction journal\n\n\t// JournalRemote controls whether journaling includes remote transactions or not.\n\t// When true, all transactions loaded from the journal are treated as remote.\n\tJournalRemote bool\n\n\tPriceLimit uint64 // Minimum gas price to enforce for acceptance into the pool\n\tPriceBump  uint64 // Minimum price bump percentage to replace an already existing transaction (nonce)\n\n\tAccountSlots uint64 // Number of executable transaction slots guaranteed per account\n\tGlobalSlots  uint64 // Maximum number of executable transaction slots for all accounts\n\tAccountQueue uint64 // Maximum number of non-executable transaction slots permitted per account\n\tGlobalQueue  uint64 // Maximum number of non-executable transaction slots for all accounts\n\n\tLifetime time.Duration // Maximum amount of time non-executable transaction are queued\n}\n\n// DefaultConfig contains the default configurations for the transaction\n// pool.\nvar DefaultConfig = Config{\n\tJournal:   \"transactions.rlp\",\n\tRejournal: time.Hour,\n\n\tPriceLimit: 0,\n\tPriceBump:  10,\n\n\tAccountSlots: 16,\n\tGlobalSlots:  4096 + 1024, // urgent + floating queue capacity with 4:1 ratio\n\tAccountQueue: 64,\n\tGlobalQueue:  1024,\n\n\tLifetime: 3 * time.Hour,\n}\n\n// sanitize checks the provided user configurations and changes anything that's\n// unreasonable or unworkable.\nfunc (config *Config) sanitize() Config {\n\tconf := *config\n\tif conf.Rejournal < time.Second {\n\t\tlog.Warn(\"Sanitizing invalid txpool journal time\", \"provided\", conf.Rejournal, \"updated\", time.Second)\n\t\tconf.Rejournal = time.Second\n\t}\n\tif conf.PriceLimit < 0 {\n\t\tlog.Warn(\"Sanitizing invalid txpool price limit\", \"provided\", conf.PriceLimit, \"updated\", DefaultConfig.PriceLimit)\n\t\tconf.PriceLimit = DefaultConfig.PriceLimit\n\t}\n\tif conf.PriceBump < 1 {\n\t\tlog.Warn(\"Sanitizing invalid txpool price bump\", \"provided\", conf.PriceBump, \"updated\", DefaultConfig.PriceBump)\n\t\tconf.PriceBump = DefaultConfig.PriceBump\n\t}\n\tif conf.AccountSlots < 1 {\n\t\tlog.Warn(\"Sanitizing invalid txpool account slots\", \"provided\", conf.AccountSlots, \"updated\", DefaultConfig.AccountSlots)\n\t\tconf.AccountSlots = DefaultConfig.AccountSlots\n\t}\n\tif conf.GlobalSlots < 1 {\n\t\tlog.Warn(\"Sanitizing invalid txpool global slots\", \"provided\", conf.GlobalSlots, \"updated\", DefaultConfig.GlobalSlots)\n\t\tconf.GlobalSlots = DefaultConfig.GlobalSlots\n\t}\n\tif conf.AccountQueue < 1 {\n\t\tlog.Warn(\"Sanitizing invalid txpool account queue\", \"provided\", conf.AccountQueue, \"updated\", DefaultConfig.AccountQueue)\n\t\tconf.AccountQueue = DefaultConfig.AccountQueue\n\t}\n\tif conf.GlobalQueue < 1 {\n\t\tlog.Warn(\"Sanitizing invalid txpool global queue\", \"provided\", conf.GlobalQueue, \"updated\", DefaultConfig.GlobalQueue)\n\t\tconf.GlobalQueue = DefaultConfig.GlobalQueue\n\t}\n\tif conf.Lifetime < 1 {\n\t\tlog.Warn(\"Sanitizing invalid txpool lifetime\", \"provided\", conf.Lifetime, \"updated\", DefaultConfig.Lifetime)\n\t\tconf.Lifetime = DefaultConfig.Lifetime\n\t}\n\treturn conf\n}\n\n// TxPool contains all currently known transactions. Transactions\n// enter the pool when they are received from the network or submitted\n// locally. They exit the pool when they are included in the blockchain.\n//\n// The pool separates processable transactions (which can be applied to the\n// current state) and future transactions. Transactions move between those\n// two states over time as they are received and processed.\ntype TxPool struct {\n\tconfig      Config\n\tchainconfig *params.ChainConfig\n\tchain       blockChain\n\tgasPrice    *big.Int\n\ttxFeed      event.Feed\n\tscope       event.SubscriptionScope\n\tsigner      types.Signer\n\tmu          sync.RWMutex\n\n\tistanbul bool // Fork indicator whether we are in the istanbul stage.\n\teip2718  bool // Fork indicator whether we are using EIP-2718 type transactions.\n\teip1559  bool // Fork indicator whether we are using EIP-1559 type transactions.\n\tshanghai bool // Fork indicator whether we are in the Shanghai stage.\n\n\tcurrentState  *state.StateDB // Current state in the blockchain head\n\tpendingNonces *noncer        // Pending state tracking virtual nonces\n\tcurrentMaxGas uint64         // Current gas limit for transaction caps\n\n\tl1CostFn func(dataGas types.RollupGasData, isDepositTx bool, to *common.Address) *big.Int // Current L1 fee cost function\n\n\tlocals  *accountSet // Set of local transaction to exempt from eviction rules\n\tjournal *journal    // Journal of local transaction to back up to disk\n\n\tpending map[common.Address]*list     // All currently processable transactions\n\tqueue   map[common.Address]*list     // Queued but non-processable transactions\n\tbeats   map[common.Address]time.Time // Last heartbeat from each known account\n\tall     *lookup                      // All transactions to allow lookups\n\tpriced  *pricedList                  // All transactions sorted by price\n\n\tchainHeadCh     chan core.ChainHeadEvent\n\tchainHeadSub    event.Subscription\n\treqResetCh      chan *txpoolResetRequest\n\treqPromoteCh    chan *accountSet\n\tqueueTxEventCh  chan *types.Transaction\n\treorgDoneCh     chan chan struct{}\n\treorgShutdownCh chan struct{}  // requests shutdown of scheduleReorgLoop\n\twg              sync.WaitGroup // tracks loop, scheduleReorgLoop\n\tinitDoneCh      chan struct{}  // is closed once the pool is initialized (for tests)\n\n\tchangesSinceReorg int // A counter for how many drops we've performed in-between reorg.\n}\n\ntype txpoolResetRequest struct {\n\toldHead, newHead *types.Header\n}\n\n// NewTxPool creates a new transaction pool to gather, sort and filter inbound\n// transactions from the network.\nfunc NewTxPool(config Config, chainconfig *params.ChainConfig, chain blockChain) *TxPool {\n\t// Sanitize the input to ensure no vulnerable gas prices are set\n\tconfig = (&config).sanitize()\n\n\t// Create the transaction pool with its initial settings\n\tpool := &TxPool{\n\t\tconfig:          config,\n\t\tchainconfig:     chainconfig,\n\t\tchain:           chain,\n\t\tsigner:          types.LatestSigner(chainconfig),\n\t\tpending:         make(map[common.Address]*list),\n\t\tqueue:           make(map[common.Address]*list),\n\t\tbeats:           make(map[common.Address]time.Time),\n\t\tall:             newLookup(),\n\t\tchainHeadCh:     make(chan core.ChainHeadEvent, chainHeadChanSize),\n\t\treqResetCh:      make(chan *txpoolResetRequest),\n\t\treqPromoteCh:    make(chan *accountSet),\n\t\tqueueTxEventCh:  make(chan *types.Transaction),\n\t\treorgDoneCh:     make(chan chan struct{}),\n\t\treorgShutdownCh: make(chan struct{}),\n\t\tinitDoneCh:      make(chan struct{}),\n\t\tgasPrice:        new(big.Int).SetUint64(config.PriceLimit),\n\t}\n\tpool.locals = newAccountSet(pool.signer)\n\tfor _, addr := range config.Locals {\n\t\tlog.Info(\"Setting new local account\", \"address\", addr)\n\t\tpool.locals.add(addr)\n\t}\n\tpool.priced = newPricedList(pool.all)\n\tpool.reset(nil, chain.CurrentBlock())\n\n\t// Start the reorg loop early so it can handle requests generated during journal loading.\n\tpool.wg.Add(1)\n\tgo pool.scheduleReorgLoop()\n\n\t// If journaling is enabled and has transactions to journal, load from disk\n\tif (!config.NoLocals || config.JournalRemote) && config.Journal != \"\" {\n\t\tpool.journal = newTxJournal(config.Journal)\n\n\t\tadd := pool.AddLocals\n\t\tif config.JournalRemote {\n\t\t\tadd = pool.AddRemotesSync // Use sync version to match pool.AddLocals\n\t\t}\n\t\tif err := pool.journal.load(add); err != nil {\n\t\t\tlog.Warn(\"Failed to load transaction journal\", \"err\", err)\n\t\t}\n\t\tif err := pool.journal.rotate(pool.toJournal()); err != nil {\n\t\t\tlog.Warn(\"Failed to rotate transaction journal\", \"err\", err)\n\t\t}\n\t}\n\n\t// Subscribe events from blockchain and start the main event loop.\n\tpool.chainHeadSub = pool.chain.SubscribeChainHeadEvent(pool.chainHeadCh)\n\tpool.wg.Add(1)\n\tgo pool.loop()\n\n\treturn pool\n}\n\n// loop is the transaction pool's main event loop, waiting for and reacting to\n// outside blockchain events as well as for various reporting and transaction\n// eviction events.\nfunc (pool *TxPool) loop() {\n\tdefer pool.wg.Done()\n\n\tvar (\n\t\tprevPending, prevQueued, prevStales int\n\t\t// Start the stats reporting and transaction eviction tickers\n\t\treport  = time.NewTicker(statsReportInterval)\n\t\tevict   = time.NewTicker(evictionInterval)\n\t\tjournal = time.NewTicker(pool.config.Rejournal)\n\t\t// Track the previous head headers for transaction reorgs\n\t\thead = pool.chain.CurrentBlock()\n\t)\n\tdefer report.Stop()\n\tdefer evict.Stop()\n\tdefer journal.Stop()\n\n\t// Notify tests that the init phase is done\n\tclose(pool.initDoneCh)\n\tfor {\n\t\tselect {\n\t\t// Handle ChainHeadEvent\n\t\tcase ev := <-pool.chainHeadCh:\n\t\t\tif ev.Block != nil {\n\t\t\t\tpool.requestReset(head, ev.Block.Header())\n\t\t\t\thead = ev.Block.Header()\n\t\t\t}\n\n\t\t// System shutdown.\n\t\tcase <-pool.chainHeadSub.Err():\n\t\t\tclose(pool.reorgShutdownCh)\n\t\t\treturn\n\n\t\t// Handle stats reporting ticks\n\t\tcase <-report.C:\n\t\t\tpool.mu.RLock()\n\t\t\tpending, queued := pool.stats()\n\t\t\tpool.mu.RUnlock()\n\t\t\tstales := int(pool.priced.stales.Load())\n\n\t\t\tif pending != prevPending || queued != prevQueued || stales != prevStales {\n\t\t\t\tlog.Debug(\"Transaction pool status report\", \"executable\", pending, \"queued\", queued, \"stales\", stales)\n\t\t\t\tprevPending, prevQueued, prevStales = pending, queued, stales\n\t\t\t}\n\n\t\t// Handle inactive account transaction eviction\n\t\tcase <-evict.C:\n\t\t\tpool.mu.Lock()\n\t\t\tfor addr := range pool.queue {\n\t\t\t\t// Skip local transactions from the eviction mechanism\n\t\t\t\tif pool.locals.contains(addr) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\t// Any non-locals old enough should be removed\n\t\t\t\tif time.Since(pool.beats[addr]) > pool.config.Lifetime {\n\t\t\t\t\tlist := pool.queue[addr].Flatten()\n\t\t\t\t\tfor _, tx := range list {\n\t\t\t\t\t\tpool.removeTx(tx.Hash(), true)\n\t\t\t\t\t}\n\t\t\t\t\tqueuedEvictionMeter.Mark(int64(len(list)))\n\t\t\t\t}\n\t\t\t}\n\t\t\tpool.mu.Unlock()\n\n\t\t// Handle local transaction journal rotation\n\t\tcase <-journal.C:\n\t\t\tif pool.journal != nil {\n\t\t\t\tpool.mu.Lock()\n\t\t\t\tif err := pool.journal.rotate(pool.toJournal()); err != nil {\n\t\t\t\t\tlog.Warn(\"Failed to rotate local tx journal\", \"err\", err)\n\t\t\t\t}\n\t\t\t\tpool.mu.Unlock()\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Stop terminates the transaction pool.\nfunc (pool *TxPool) Stop() {\n\t// Unsubscribe all subscriptions registered from txpool\n\tpool.scope.Close()\n\n\t// Unsubscribe subscriptions registered from blockchain\n\tpool.chainHeadSub.Unsubscribe()\n\tpool.wg.Wait()\n\n\tif pool.journal != nil {\n\t\tpool.journal.close()\n\t}\n\tlog.Info(\"Transaction pool stopped\")\n}\n\n// SubscribeNewTxsEvent registers a subscription of NewTxsEvent and\n// starts sending event to the given channel.\nfunc (pool *TxPool) SubscribeNewTxsEvent(ch chan<- core.NewTxsEvent) event.Subscription {\n\treturn pool.scope.Track(pool.txFeed.Subscribe(ch))\n}\n\n// GasPrice returns the current gas price enforced by the transaction pool.\nfunc (pool *TxPool) GasPrice() *big.Int {\n\tpool.mu.RLock()\n\tdefer pool.mu.RUnlock()\n\n\treturn new(big.Int).Set(pool.gasPrice)\n}\n\n// SetGasPrice updates the minimum price required by the transaction pool for a\n// new transaction, and drops all transactions below this threshold.\nfunc (pool *TxPool) SetGasPrice(price *big.Int) {\n\tpool.mu.Lock()\n\tdefer pool.mu.Unlock()\n\n\told := pool.gasPrice\n\tpool.gasPrice = price\n\t// if the min miner fee increased, remove transactions below the new threshold\n\tif price.Cmp(old) > 0 {\n\t\t// pool.priced is sorted by GasFeeCap, so we have to iterate through pool.all instead\n\t\tdrop := pool.all.RemotesBelowTip(price)\n\t\tfor _, tx := range drop {\n\t\t\tpool.removeTx(tx.Hash(), false)\n\t\t}\n\t\tpool.priced.Removed(len(drop))\n\t}\n\n\tlog.Info(\"Transaction pool price threshold updated\", \"price\", price)\n}\n\n// Nonce returns the next nonce of an account, with all transactions executable\n// by the pool already applied on top.\nfunc (pool *TxPool) Nonce(addr common.Address) uint64 {\n\tpool.mu.RLock()\n\tdefer pool.mu.RUnlock()\n\n\treturn pool.pendingNonces.get(addr)\n}\n\n// Stats retrieves the current pool stats, namely the number of pending and the\n// number of queued (non-executable) transactions.\nfunc (pool *TxPool) Stats() (int, int) {\n\tpool.mu.RLock()\n\tdefer pool.mu.RUnlock()\n\n\treturn pool.stats()\n}\n\n// stats retrieves the current pool stats, namely the number of pending and the\n// number of queued (non-executable) transactions.\nfunc (pool *TxPool) stats() (int, int) {\n\tpending := 0\n\tfor _, list := range pool.pending {\n\t\tpending += list.Len()\n\t}\n\tqueued := 0\n\tfor _, list := range pool.queue {\n\t\tqueued += list.Len()\n\t}\n\treturn pending, queued\n}\n\n// Content retrieves the data content of the transaction pool, returning all the\n// pending as well as queued transactions, grouped by account and sorted by nonce.\nfunc (pool *TxPool) Content() (map[common.Address]types.Transactions, map[common.Address]types.Transactions) {\n\tpool.mu.Lock()\n\tdefer pool.mu.Unlock()\n\n\tpending := make(map[common.Address]types.Transactions, len(pool.pending))\n\tfor addr, list := range pool.pending {\n\t\tpending[addr] = list.Flatten()\n\t}\n\tqueued := make(map[common.Address]types.Transactions, len(pool.queue))\n\tfor addr, list := range pool.queue {\n\t\tqueued[addr] = list.Flatten()\n\t}\n\treturn pending, queued\n}\n\n// ContentFrom retrieves the data content of the transaction pool, returning the\n// pending as well as queued transactions of this address, grouped by nonce.\nfunc (pool *TxPool) ContentFrom(addr common.Address) (types.Transactions, types.Transactions) {\n\tpool.mu.RLock()\n\tdefer pool.mu.RUnlock()\n\n\tvar pending types.Transactions\n\tif list, ok := pool.pending[addr]; ok {\n\t\tpending = list.Flatten()\n\t}\n\tvar queued types.Transactions\n\tif list, ok := pool.queue[addr]; ok {\n\t\tqueued = list.Flatten()\n\t}\n\treturn pending, queued\n}\n\n// Pending retrieves all currently processable transactions, grouped by origin\n// account and sorted by nonce. The returned transaction set is a copy and can be\n// freely modified by calling code.\n//\n// The enforceTips parameter can be used to do an extra filtering on the pending\n// transactions and only return those whose **effective** tip is large enough in\n// the next pending execution environment.\nfunc (pool *TxPool) Pending(enforceTips bool) map[common.Address]types.Transactions {\n\tpool.mu.Lock()\n\tdefer pool.mu.Unlock()\n\n\tpending := make(map[common.Address]types.Transactions)\n\tfor addr, list := range pool.pending {\n\t\ttxs := list.Flatten()\n\n\t\t// If the miner requests tip enforcement, cap the lists now\n\t\tif enforceTips && !pool.locals.contains(addr) {\n\t\t\tfor i, tx := range txs {\n\t\t\t\tif tx.EffectiveGasTipIntCmp(pool.gasPrice, pool.priced.urgent.baseFee) < 0 {\n\t\t\t\t\ttxs = txs[:i]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif len(txs) > 0 {\n\t\t\tpending[addr] = txs\n\t\t}\n\t}\n\treturn pending\n}\n\n// Locals retrieves the accounts currently considered local by the pool.\nfunc (pool *TxPool) Locals() []common.Address {\n\tpool.mu.Lock()\n\tdefer pool.mu.Unlock()\n\n\treturn pool.locals.flatten()\n}\n\n// local retrieves all currently known local transactions, grouped by origin\n// account and sorted by nonce. The returned transaction set is a copy and can be\n// freely modified by calling code.\nfunc (pool *TxPool) local() map[common.Address]types.Transactions {\n\ttxs := make(map[common.Address]types.Transactions)\n\tfor addr := range pool.locals.accounts {\n\t\tif pending := pool.pending[addr]; pending != nil {\n\t\t\ttxs[addr] = append(txs[addr], pending.Flatten()...)\n\t\t}\n\t\tif queued := pool.queue[addr]; queued != nil {\n\t\t\ttxs[addr] = append(txs[addr], queued.Flatten()...)\n\t\t}\n\t}\n\treturn txs\n}\n\n// toJournal retrieves all transactions that should be included in the journal,\n// grouped by origin account and sorted by nonce.\n// The returned transaction set is a copy and can be freely modified by calling code.\nfunc (pool *TxPool) toJournal() map[common.Address]types.Transactions {\n\tif !pool.config.JournalRemote {\n\t\treturn pool.local()\n\t}\n\ttxs := make(map[common.Address]types.Transactions)\n\tfor addr, pending := range pool.pending {\n\t\ttxs[addr] = append(txs[addr], pending.Flatten()...)\n\t}\n\tfor addr, queued := range pool.queue {\n\t\ttxs[addr] = append(txs[addr], queued.Flatten()...)\n\t}\n\treturn txs\n}\n\n// validateTx checks whether a transaction is valid according to the consensus\n// rules and adheres to some heuristic limits of the local node (price and size).\nfunc (pool *TxPool) validateTx(tx *types.Transaction, local bool) error {\n\t// No unauthenticated deposits allowed in the transaction pool.\n\t// This is for spam protection, not consensus,\n\t// as the external engine-API user authenticates deposits.\n\tif tx.Type() == types.DepositTxType {\n\t\treturn core.ErrTxTypeNotSupported\n\t}\n\tif tx.Type() == types.BlobTxType {\n\t\treturn errors.New(\"BlobTxType of transaction is currently not supported.\")\n\t}\n\t// Accept only legacy transactions until EIP-2718/2930 activates.\n\tif !pool.eip2718 && tx.Type() != types.LegacyTxType {\n\t\treturn core.ErrTxTypeNotSupported\n\t}\n\t// Reject dynamic fee transactions until EIP-1559 activates.\n\tif !pool.eip1559 && tx.Type() == types.DynamicFeeTxType {\n\t\treturn core.ErrTxTypeNotSupported\n\t}\n\t// Reject transactions over defined size to prevent DOS attacks\n\tif tx.Size() > txMaxSize {\n\t\treturn ErrOversizedData\n\t}\n\t// Check whether the init code size has been exceeded.\n\tif pool.shanghai && tx.To() == nil && len(tx.Data()) > params.MaxInitCodeSize {\n\t\treturn fmt.Errorf(\"%w: code size %v limit %v\", core.ErrMaxInitCodeSizeExceeded, len(tx.Data()), params.MaxInitCodeSize)\n\t}\n\t// Transactions can't be negative. This may never happen using RLP decoded\n\t// transactions but may occur if you create a transaction using the RPC.\n\tif tx.Value().Sign() < 0 {\n\t\treturn ErrNegativeValue\n\t}\n\t// Ensure the transaction doesn't exceed the current block limit gas.\n\tif pool.currentMaxGas < tx.Gas() {\n\t\treturn ErrGasLimit\n\t}\n\t// Sanity check for extremely large numbers\n\tif tx.GasFeeCap().BitLen() > 256 {\n\t\treturn core.ErrFeeCapVeryHigh\n\t}\n\tif tx.GasTipCap().BitLen() > 256 {\n\t\treturn core.ErrTipVeryHigh\n\t}\n\t// Ensure gasFeeCap is greater than or equal to gasTipCap.\n\tif tx.GasFeeCapIntCmp(tx.GasTipCap()) < 0 {\n\t\treturn core.ErrTipAboveFeeCap\n\t}\n\t// Make sure the transaction is signed properly.\n\tfrom, err := types.Sender(pool.signer, tx)\n\tif err != nil {\n\t\treturn ErrInvalidSender\n\t}\n\t// Drop non-local transactions under our own minimal accepted gas price or tip\n\tif tx.GasTipCapIntCmp(pool.gasPrice) < 0 {\n\t\treturn ErrUnderpriced\n\t}\n\t// Ensure the transaction adheres to nonce ordering\n\tif pool.currentState.GetNonce(from) > tx.Nonce() {\n\t\treturn core.ErrNonceTooLow\n\t}\n\t// Transactor should have enough funds to cover the costs\n\t// cost == V + GP * GL\n\tcost := tx.Cost()\n\tif l1Cost := pool.l1CostFn(tx.RollupDataGas(), tx.IsDepositTx(), tx.To()); l1Cost != nil { // add rollup cost\n\t\tcost = cost.Add(cost, l1Cost)\n\t}\n\n\tmetaTxParams, err := types.DecodeAndVerifyMetaTxParams(tx, pool.chainconfig.IsMetaTxV2(pool.chain.CurrentBlock().Time))\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar userBalance *big.Int\n\tif metaTxParams != nil {\n\t\tif metaTxParams.ExpireHeight < pool.chain.CurrentBlock().Number.Uint64() {\n\t\t\treturn types.ErrExpiredMetaTx\n\t\t}\n\t\ttxGasCost := new(big.Int).Sub(cost, tx.Value())\n\t\tsponsorAmount, selfPayAmount := types.CalculateSponsorPercentAmount(metaTxParams, txGasCost)\n\t\tselfPayAmount = new(big.Int).Add(selfPayAmount, tx.Value())\n\n\t\tsponsorBalance := pool.currentState.GetBalance(metaTxParams.GasFeeSponsor)\n\t\tif sponsorBalance.Cmp(sponsorAmount) < 0 {\n\t\t\treturn types.ErrSponsorBalanceNotEnough\n\t\t}\n\t\tselfBalance := pool.currentState.GetBalance(from)\n\t\tif selfBalance.Cmp(selfPayAmount) < 0 {\n\t\t\treturn core.ErrInsufficientFunds\n\t\t}\n\t\tuserBalance = new(big.Int).Add(selfBalance, sponsorBalance)\n\t} else {\n\t\tuserBalance = pool.currentState.GetBalance(from)\n\t\t// Transactor should have enough funds to cover the costs\n\t\t// cost == V + GP * GL\n\t\tif b := userBalance; b.Cmp(cost) < 0 {\n\t\t\treturn core.ErrInsufficientFunds\n\t\t}\n\t}\n\n\t// Verify that replacing transactions will not result in overdraft\n\tlist := pool.pending[from]\n\tif list != nil { // Sender already has pending txs\n\t\t_, sponsorCostSum := pool.validateMetaTxList(list)\n\t\tuserBalance = new(big.Int).Add(userBalance, sponsorCostSum)\n\t\tsum := new(big.Int).Add(cost, list.totalcost)\n\t\tif repl := list.txs.Get(tx.Nonce()); repl != nil {\n\t\t\t// Deduct the cost of a transaction replaced by this\n\t\t\treplL1Cost := repl.Cost()\n\t\t\tif l1Cost := pool.l1CostFn(tx.RollupDataGas(), tx.IsDepositTx(), tx.To()); l1Cost != nil { // add rollup cost\n\t\t\t\treplL1Cost = replL1Cost.Add(cost, l1Cost)\n\t\t\t}\n\t\t\tsum.Sub(sum, replL1Cost)\n\t\t}\n\t\tif userBalance.Cmp(sum) < 0 {\n\t\t\tlog.Trace(\"Replacing transactions would overdraft\", \"sender\", from, \"balance\", userBalance, \"required\", sum)\n\t\t\treturn ErrOverdraft\n\t\t}\n\t}\n\n\t// Ensure the transaction has more gas than the basic tx fee.\n\tintrGas, err := core.IntrinsicGas(tx.Data(), tx.AccessList(), tx.To() == nil, true, pool.istanbul, pool.shanghai)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttokenRatio := pool.currentState.GetState(types.GasOracleAddr, types.TokenRatioSlot).Big().Uint64()\n\n\tif tx.Gas() < intrGas*tokenRatio {\n\t\treturn core.ErrIntrinsicGas\n\t}\n\treturn nil\n}\n\n// add validates a transaction and inserts it into the non-executable queue for later\n// pending promotion and execution. If the transaction is a replacement for an already\n// pending or queued one, it overwrites the previous transaction if its price is higher.\n//\n// If a newly added transaction is marked as local, its sending account will be\n// be added to the allowlist, preventing any associated transaction from being dropped\n// out of the pool due to pricing constraints.\nfunc (pool *TxPool) add(tx *types.Transaction, local bool) (replaced bool, err error) {\n\t// If the transaction is already known, discard it\n\thash := tx.Hash()\n\tif pool.all.Get(hash) != nil {\n\t\tlog.Trace(\"Discarding already known transaction\", \"hash\", hash)\n\t\tknownTxMeter.Mark(1)\n\t\treturn false, ErrAlreadyKnown\n\t}\n\t// Make the local flag. If it's from local source or it's from the network but\n\t// the sender is marked as local previously, treat it as the local transaction.\n\tisLocal := local || pool.locals.containsTx(tx)\n\n\t// If the transaction fails basic validation, discard it\n\tif err := pool.validateTx(tx, isLocal); err != nil {\n\t\tlog.Trace(\"Discarding invalid transaction\", \"hash\", hash, \"err\", err)\n\t\tinvalidTxMeter.Mark(1)\n\t\treturn false, err\n\t}\n\n\t// already validated by this point\n\tfrom, _ := types.Sender(pool.signer, tx)\n\n\t// If the transaction pool is full, discard underpriced transactions\n\tif uint64(pool.all.Slots()+numSlots(tx)) > pool.config.GlobalSlots+pool.config.GlobalQueue {\n\t\t// If the new transaction is underpriced, don't accept it\n\t\tif !isLocal && pool.priced.Underpriced(tx) {\n\t\t\tlog.Trace(\"Discarding underpriced transaction\", \"hash\", hash, \"gasTipCap\", tx.GasTipCap(), \"gasFeeCap\", tx.GasFeeCap())\n\t\t\tunderpricedTxMeter.Mark(1)\n\t\t\treturn false, ErrUnderpriced\n\t\t}\n\n\t\t// We're about to replace a transaction. The reorg does a more thorough\n\t\t// analysis of what to remove and how, but it runs async. We don't want to\n\t\t// do too many replacements between reorg-runs, so we cap the number of\n\t\t// replacements to 25% of the slots\n\t\tif pool.changesSinceReorg > int(pool.config.GlobalSlots/4) {\n\t\t\tthrottleTxMeter.Mark(1)\n\t\t\treturn false, ErrTxPoolOverflow\n\t\t}\n\n\t\t// New transaction is better than our worse ones, make room for it.\n\t\t// If it's a local transaction, forcibly discard all available transactions.\n\t\t// Otherwise if we can't make enough room for new one, abort the operation.\n\t\tdrop, success := pool.priced.Discard(pool.all.Slots()-int(pool.config.GlobalSlots+pool.config.GlobalQueue)+numSlots(tx), isLocal)\n\n\t\t// Special case, we still can't make the room for the new remote one.\n\t\tif !isLocal && !success {\n\t\t\tlog.Trace(\"Discarding overflown transaction\", \"hash\", hash)\n\t\t\toverflowedTxMeter.Mark(1)\n\t\t\treturn false, ErrTxPoolOverflow\n\t\t}\n\n\t\t// If the new transaction is a future transaction it should never churn pending transactions\n\t\tif !isLocal && pool.isFuture(from, tx) {\n\t\t\tvar replacesPending bool\n\t\t\tfor _, dropTx := range drop {\n\t\t\t\tdropSender, _ := types.Sender(pool.signer, dropTx)\n\t\t\t\tif list := pool.pending[dropSender]; list != nil && list.Overlaps(dropTx) {\n\t\t\t\t\treplacesPending = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Add all transactions back to the priced queue\n\t\t\tif replacesPending {\n\t\t\t\tfor _, dropTx := range drop {\n\t\t\t\t\tpool.priced.Put(dropTx, false)\n\t\t\t\t}\n\t\t\t\tlog.Trace(\"Discarding future transaction replacing pending tx\", \"hash\", hash)\n\t\t\t\treturn false, ErrFutureReplacePending\n\t\t\t}\n\t\t}\n\n\t\t// Kick out the underpriced remote transactions.\n\t\tfor _, tx := range drop {\n\t\t\tlog.Trace(\"Discarding freshly underpriced transaction\", \"hash\", tx.Hash(), \"gasTipCap\", tx.GasTipCap(), \"gasFeeCap\", tx.GasFeeCap())\n\t\t\tunderpricedTxMeter.Mark(1)\n\t\t\tdropped := pool.removeTx(tx.Hash(), false)\n\t\t\tpool.changesSinceReorg += dropped\n\t\t}\n\t}\n\n\t// Try to replace an existing transaction in the pending pool\n\tif list := pool.pending[from]; list != nil && list.Overlaps(tx) {\n\t\t// Nonce already pending, check if required price bump is met\n\t\tinserted, old := list.Add(tx, pool.config.PriceBump)\n\t\tif !inserted {\n\t\t\tpendingDiscardMeter.Mark(1)\n\t\t\treturn false, ErrReplaceUnderpriced\n\t\t}\n\t\t// New transaction is b"
    }
  ]
}