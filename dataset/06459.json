{
  "Title": "[M-01] Although `ERC20Boost.decrementGaugesBoostIndexed` function would require the user to remove all of their boosts from a deprecated gauge at once, such a user can instead call `ERC20Boost.decrementGaugeBoost` function multiple times to utilize such deprecated gauge and decrement its `userGaugeBoost`",
  "Content": "\nWhen the `gauge` input corresponds to a deprecated gauge, calling the `ERC20Boost.decrementGaugeBoost` function can still execute `gaugeState.userGaugeBoost -= boost.toUint128()` if `boost >= gaugeState.userGaugeBoost` is false.\n\n<https://github.com/code-423n4/2023-05-maia/blob/62f4f01a522dcbb4b9abfe2f6783bbb67c0da022/src/erc-20/ERC20Boost.sol#L175-L187>\n\n```solidity\n    function decrementGaugeBoost(address gauge, uint256 boost) public {\n        GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n        if (boost >= gaugeState.userGaugeBoost) {\n            _userGauges[msg.sender].remove(gauge);\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n        } else {\n            gaugeState.userGaugeBoost -= boost.toUint128();\n\n            emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n        }\n    }\n```\n\nHowever, for the same deprecated gauge, calling the `ERC20Boost.decrementAllGaugesBoost` and `ERC20Boost.decrementGaugesBoostIndexed` functions would execute `_userGauges[msg.sender].remove(gauge)` and `delete getUserGaugeBoost[msg.sender][gauge]` without executing `gaugeState.userGaugeBoost -= boost.toUint128()` because `_deprecatedGauges.contains(gauge)` is true. Hence, an inconsistency exists between the `ERC20Boost.decrementGaugeBoost` and `ERC20Boost.decrementGaugesBoostIndexed` functions when the corresponding gauge is deprecated. As a result, although the `ERC20Boost.decrementGaugesBoostIndexed` function would require the user to remove all of their boost from a deprecated gauge at once, such user can instead call the `ERC20Boost.decrementGaugeBoost` function multiple times to utilize such deprecated gauge and decrement its `userGaugeBoost` if `boost >= gaugeState.userGaugeBoost` is false each time.\n\n<https://github.com/code-423n4/2023-05-maia/blob/62f4f01a522dcbb4b9abfe2f6783bbb67c0da022/src/erc-20/ERC20Boost.sol#L198-L200>\n\n```solidity\n    function decrementAllGaugesBoost(uint256 boost) external {\n        decrementGaugesBoostIndexed(boost, 0, _userGauges[msg.sender].length());\n    }\n```\n\n<https://github.com/code-423n4/2023-05-maia/blob/62f4f01a522dcbb4b9abfe2f6783bbb67c0da022/src/erc-20/ERC20Boost.sol#L203-L227>\n\n```solidity\n    function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) public {\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < num && i < length;) {\n            address gauge = gaugeList[offset + i];\n\n            GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n\n            if (_deprecatedGauges.contains(gauge) || boost >= gaugeState.userGaugeBoost) {\n                require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n                delete getUserGaugeBoost[msg.sender][gauge];\n\n                emit Detach(msg.sender, gauge);\n            } else {\n                gaugeState.userGaugeBoost -= boost.toUint128();\n\n                emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n```\n\n### Proof of Concept\n\nThe following steps can occur for the described scenario:\n\n1. Alice's 1e18 boost are attached to a gauge.\n2. Such gauge becomes deprecated.\n3. Alice calls the `ERC20Boost.decrementGaugeBoost` function to decrement 0.5e18 boost from such deprecated gauge.\n4. Alice calls the `ERC20Boost.decrementGaugeBoost` function to decrement 0.2e18 boost from such deprecated gauge.\n5. Alice still has 0.3e18 boost from such deprecated gauge so they can continue utilize and decrement boost from such deprecated gauge in the future.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nThe `ERC20Boost.decrementGaugeBoost` function can be updated to execute `require(_userGauges[msg.sender].remove(gauge))` and `delete getUserGaugeBoost[msg.sender][gauge]` if `_deprecatedGauges.contains(gauge) || boost >= gaugeState.userGaugeBoost` is true, which is similar to the `ERC20Boost.decrementGaugesBoostIndexed` function.\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/904#issuecomment-1632539247)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/904#issuecomment-1708796097):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/904).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-20/ERC20Boost.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20Boost} from \"./interfaces/IERC20Boost.sol\";\n\n/// @title An ERC20 with an embedded attachment mechanism to keep track of boost\n///        allocations to gauges.\nabstract contract ERC20Boost is ERC20, Ownable, IERC20Boost {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => mapping(address => GaugeState)) public override getUserGaugeBoost;\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => uint256) public override getUserBoost;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead boost\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                            VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function gauges() external view returns (address[] memory) {\n        return _gauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _gauges.at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isGauge(address gauge) external view returns (bool) {\n        return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numGauges() external view returns (uint256) {\n        return _gauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function deprecatedGauges() external view returns (address[] memory) {\n        return _deprecatedGauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numDeprecatedGauges() external view returns (uint256) {\n        return _deprecatedGauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function freeGaugeBoost(address user) public view returns (uint256) {\n        return balanceOf[user] - getUserBoost[user];\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user) external view returns (address[] memory) {\n        return _userGauges[user].values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isUserGauge(address user, address gauge) external view returns (bool) {\n        return _userGauges[user].contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user, uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _userGauges[user].at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numUserGauges(address user) external view returns (uint256) {\n        return _userGauges[user].length();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function attach(address user) external {\n        if (!_gauges.contains(msg.sender) || _deprecatedGauges.contains(msg.sender)) {\n            revert InvalidGauge();\n        }\n\n        // idempotent add\n        if (!_userGauges[user].add(msg.sender)) revert GaugeAlreadyAttached();\n\n        uint128 userGaugeBoost = balanceOf[user].toUint128();\n\n        if (getUserBoost[user] < userGaugeBoost) {\n            getUserBoost[user] = userGaugeBoost;\n            emit UpdateUserBoost(user, userGaugeBoost);\n        }\n\n        getUserGaugeBoost[user][msg.sender] =\n            GaugeState({userGaugeBoost: userGaugeBoost, totalGaugeBoost: totalSupply.toUint128()});\n\n        emit Attach(user, msg.sender, userGaugeBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function detach(address user) external {\n        require(_userGauges[user].remove(msg.sender));\n        delete getUserGaugeBoost[user][msg.sender];\n\n        emit Detach(user, msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function updateUserBoost(address user) external {\n        uint256 userBoost = 0;\n\n        address[] memory gaugeList = _userGauges[user].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < length;) {\n            address gauge = gaugeList[i];\n\n            if (!_deprecatedGauges.contains(gauge)) {\n                uint256 gaugeBoost = getUserGaugeBoost[user][gauge].userGaugeBoost;\n\n                if (userBoost < gaugeBoost) userBoost = gaugeBoost;\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n        getUserBoost[user] = userBoost;\n\n        emit UpdateUserBoost(user, userBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeBoost(address gauge, uint256 boost) public {\n        GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n        if (boost >= gaugeState.userGaugeBoost) {\n            _userGauges[msg.sender].remove(gauge);\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n        } else {\n            gaugeState.userGaugeBoost -= boost.toUint128();\n\n            emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeAllBoost(address gauge) external {\n        require(_userGauges[msg.sender].remove(gauge));\n        delete getUserGaugeBoost[msg.sender][gauge];\n\n        emit Detach(msg.sender, gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesBoost(uint256 boost) external {\n        decrementGaugesBoostIndexed(boost, 0, _userGauges[msg.sender].length());\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) public {\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < num && i < length;) {\n            address gauge = gaugeList[offset + i];\n\n            GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n\n            if (_deprecatedGauges.contains(gauge) || boost >= gaugeState.userGaugeBoost) {\n                require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n                delete getUserGaugeBoost[msg.sender][gauge];\n\n                emit Detach(msg.sender, gauge);\n            } else {\n                gaugeState.userGaugeBoost -= boost.toUint128();\n\n                emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesAllBoost() external {\n        // Loop through all user gauges, live and deprecated\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        // Free gauges until through the entire list\n        uint256 size = gaugeList.length;\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n\n            require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        getUserBoost[msg.sender] = 0;\n\n        emit UpdateUserBoost(msg.sender, 0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function addGauge(address gauge) external onlyOwner {\n        _addGauge(gauge);\n    }\n\n    function _addGauge(address gauge) internal {\n        bool newAdd = _gauges.add(gauge);\n        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);\n        // add and fail loud if zero address or already present and not deprecated\n        if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGauge();\n\n        emit AddGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function removeGauge(address gauge) external onlyOwner {\n        _removeGauge(gauge);\n    }\n\n    function _removeGauge(address gauge) internal {\n        // add to deprecated and fail loud if not present\n        if (!_deprecatedGauges.add(gauge)) revert InvalidGauge();\n\n        emit RemoveGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function replaceGauge(address oldGauge, address newGauge) external onlyOwner {\n        _removeGauge(oldGauge);\n        _addGauge(newGauge);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires notAttached < amount.\n\n    /**\n     * @notice Burns `amount` of tokens from `from` address.\n     * @dev User must have enough free boost.\n     * @param from The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address from, uint256 amount) internal override notAttached(from, amount) {\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `msg.sender` to `to` address.\n     * @dev User must have enough free boost.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transfer(address to, uint256 amount) public override notAttached(msg.sender, amount) returns (bool) {\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `from` address to `to` address.\n     * @dev User must have enough free boost.\n     * @param from the address to transfer from.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        override\n        notAttached(from, amount)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Reverts if the user does not have enough free boost.\n     * @param user The user address.\n     * @param amount The amount of boost.\n     */\n    modifier notAttached(address user, uint256 amount) {\n        if (freeGaugeBoost(user) < amount) revert AttachedBoost();\n        _;\n    }\n}"
    },
    {
      "filename": "src/erc-20/ERC20Boost.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20Boost} from \"./interfaces/IERC20Boost.sol\";\n\n/// @title An ERC20 with an embedded attachment mechanism to keep track of boost\n///        allocations to gauges.\nabstract contract ERC20Boost is ERC20, Ownable, IERC20Boost {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => mapping(address => GaugeState)) public override getUserGaugeBoost;\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => uint256) public override getUserBoost;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead boost\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                            VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function gauges() external view returns (address[] memory) {\n        return _gauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _gauges.at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isGauge(address gauge) external view returns (bool) {\n        return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numGauges() external view returns (uint256) {\n        return _gauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function deprecatedGauges() external view returns (address[] memory) {\n        return _deprecatedGauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numDeprecatedGauges() external view returns (uint256) {\n        return _deprecatedGauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function freeGaugeBoost(address user) public view returns (uint256) {\n        return balanceOf[user] - getUserBoost[user];\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user) external view returns (address[] memory) {\n        return _userGauges[user].values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isUserGauge(address user, address gauge) external view returns (bool) {\n        return _userGauges[user].contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user, uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _userGauges[user].at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numUserGauges(address user) external view returns (uint256) {\n        return _userGauges[user].length();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function attach(address user) external {\n        if (!_gauges.contains(msg.sender) || _deprecatedGauges.contains(msg.sender)) {\n            revert InvalidGauge();\n        }\n\n        // idempotent add\n        if (!_userGauges[user].add(msg.sender)) revert GaugeAlreadyAttached();\n\n        uint128 userGaugeBoost = balanceOf[user].toUint128();\n\n        if (getUserBoost[user] < userGaugeBoost) {\n            getUserBoost[user] = userGaugeBoost;\n            emit UpdateUserBoost(user, userGaugeBoost);\n        }\n\n        getUserGaugeBoost[user][msg.sender] =\n            GaugeState({userGaugeBoost: userGaugeBoost, totalGaugeBoost: totalSupply.toUint128()});\n\n        emit Attach(user, msg.sender, userGaugeBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function detach(address user) external {\n        require(_userGauges[user].remove(msg.sender));\n        delete getUserGaugeBoost[user][msg.sender];\n\n        emit Detach(user, msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function updateUserBoost(address user) external {\n        uint256 userBoost = 0;\n\n        address[] memory gaugeList = _userGauges[user].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < length;) {\n            address gauge = gaugeList[i];\n\n            if (!_deprecatedGauges.contains(gauge)) {\n                uint256 gaugeBoost = getUserGaugeBoost[user][gauge].userGaugeBoost;\n\n                if (userBoost < gaugeBoost) userBoost = gaugeBoost;\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n        getUserBoost[user] = userBoost;\n\n        emit UpdateUserBoost(user, userBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeBoost(address gauge, uint256 boost) public {\n        GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n        if (boost >= gaugeState.userGaugeBoost) {\n            _userGauges[msg.sender].remove(gauge);\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n        } else {\n            gaugeState.userGaugeBoost -= boost.toUint128();\n\n            emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeAllBoost(address gauge) external {\n        require(_userGauges[msg.sender].remove(gauge));\n        delete getUserGaugeBoost[msg.sender][gauge];\n\n        emit Detach(msg.sender, gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesBoost(uint256 boost) external {\n        decrementGaugesBoostIndexed(boost, 0, _userGauges[msg.sender].length());\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) public {\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < num && i < length;) {\n            address gauge = gaugeList[offset + i];\n\n            GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n\n            if (_deprecatedGauges.contains(gauge) || boost >= gaugeState.userGaugeBoost) {\n                require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n                delete getUserGaugeBoost[msg.sender][gauge];\n\n                emit Detach(msg.sender, gauge);\n            } else {\n                gaugeState.userGaugeBoost -= boost.toUint128();\n\n                emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesAllBoost() external {\n        // Loop through all user gauges, live and deprecated\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        // Free gauges until through the entire list\n        uint256 size = gaugeList.length;\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n\n            require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        getUserBoost[msg.sender] = 0;\n\n        emit UpdateUserBoost(msg.sender, 0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function addGauge(address gauge) external onlyOwner {\n        _addGauge(gauge);\n    }\n\n    function _addGauge(address gauge) internal {\n        bool newAdd = _gauges.add(gauge);\n        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);\n        // add and fail loud if zero address or already present and not deprecated\n        if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGauge();\n\n        emit AddGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function removeGauge(address gauge) external onlyOwner {\n        _removeGauge(gauge);\n    }\n\n    function _removeGauge(address gauge) internal {\n        // add to deprecated and fail loud if not present\n        if (!_deprecatedGauges.add(gauge)) revert InvalidGauge();\n\n        emit RemoveGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function replaceGauge(address oldGauge, address newGauge) external onlyOwner {\n        _removeGauge(oldGauge);\n        _addGauge(newGauge);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires notAttached < amount.\n\n    /**\n     * @notice Burns `amount` of tokens from `from` address.\n     * @dev User must have enough free boost.\n     * @param from The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address from, uint256 amount) internal override notAttached(from, amount) {\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `msg.sender` to `to` address.\n     * @dev User must have enough free boost.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transfer(address to, uint256 amount) public override notAttached(msg.sender, amount) returns (bool) {\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `from` address to `to` address.\n     * @dev User must have enough free boost.\n     * @param from the address to transfer from.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        override\n        notAttached(from, amount)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Reverts if the user does not have enough free boost.\n     * @param user The user address.\n     * @param amount The amount of boost.\n     */\n    modifier notAttached(address user, uint256 amount) {\n        if (freeGaugeBoost(user) < amount) revert AttachedBoost();\n        _;\n    }\n}"
    },
    {
      "filename": "src/erc-20/ERC20Boost.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20Boost} from \"./interfaces/IERC20Boost.sol\";\n\n/// @title An ERC20 with an embedded attachment mechanism to keep track of boost\n///        allocations to gauges.\nabstract contract ERC20Boost is ERC20, Ownable, IERC20Boost {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => mapping(address => GaugeState)) public override getUserGaugeBoost;\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => uint256) public override getUserBoost;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead boost\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                            VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function gauges() external view returns (address[] memory) {\n        return _gauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _gauges.at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isGauge(address gauge) external view returns (bool) {\n        return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numGauges() external view returns (uint256) {\n        return _gauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function deprecatedGauges() external view returns (address[] memory) {\n        return _deprecatedGauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numDeprecatedGauges() external view returns (uint256) {\n        return _deprecatedGauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function freeGaugeBoost(address user) public view returns (uint256) {\n        return balanceOf[user] - getUserBoost[user];\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user) external view returns (address[] memory) {\n        return _userGauges[user].values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isUserGauge(address user, address gauge) external view returns (bool) {\n        return _userGauges[user].contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user, uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _userGauges[user].at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numUserGauges(address user) external view returns (uint256) {\n        return _userGauges[user].length();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function attach(address user) external {\n        if (!_gauges.contains(msg.sender) || _deprecatedGauges.contains(msg.sender)) {\n            revert InvalidGauge();\n        }\n\n        // idempotent add\n        if (!_userGauges[user].add(msg.sender)) revert GaugeAlreadyAttached();\n\n        uint128 userGaugeBoost = balanceOf[user].toUint128();\n\n        if (getUserBoost[user] < userGaugeBoost) {\n            getUserBoost[user] = userGaugeBoost;\n            emit UpdateUserBoost(user, userGaugeBoost);\n        }\n\n        getUserGaugeBoost[user][msg.sender] =\n            GaugeState({userGaugeBoost: userGaugeBoost, totalGaugeBoost: totalSupply.toUint128()});\n\n        emit Attach(user, msg.sender, userGaugeBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function detach(address user) external {\n        require(_userGauges[user].remove(msg.sender));\n        delete getUserGaugeBoost[user][msg.sender];\n\n        emit Detach(user, msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function updateUserBoost(address user) external {\n        uint256 userBoost = 0;\n\n        address[] memory gaugeList = _userGauges[user].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < length;) {\n            address gauge = gaugeList[i];\n\n            if (!_deprecatedGauges.contains(gauge)) {\n                uint256 gaugeBoost = getUserGaugeBoost[user][gauge].userGaugeBoost;\n\n                if (userBoost < gaugeBoost) userBoost = gaugeBoost;\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n        getUserBoost[user] = userBoost;\n\n        emit UpdateUserBoost(user, userBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeBoost(address gauge, uint256 boost) public {\n        GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n        if (boost >= gaugeState.userGaugeBoost) {\n            _userGauges[msg.sender].remove(gauge);\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n        } else {\n            gaugeState.userGaugeBoost -= boost.toUint128();\n\n            emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeAllBoost(address gauge) external {\n        require(_userGauges[msg.sender].remove(gauge));\n        delete getUserGaugeBoost[msg.sender][gauge];\n\n        emit Detach(msg.sender, gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesBoost(uint256 boost) external {\n        decrementGaugesBoostIndexed(boost, 0, _userGauges[msg.sender].length());\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) public {\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < num && i < length;) {\n            address gauge = gaugeList[offset + i];\n\n            GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n\n            if (_deprecatedGauges.contains(gauge) || boost >= gaugeState.userGaugeBoost) {\n                require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n                delete getUserGaugeBoost[msg.sender][gauge];\n\n                emit Detach(msg.sender, gauge);\n            } else {\n                gaugeState.userGaugeBoost -= boost.toUint128();\n\n                emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesAllBoost() external {\n        // Loop through all user gauges, live and deprecated\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        // Free gauges until through the entire list\n        uint256 size = gaugeList.length;\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n\n            require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        getUserBoost[msg.sender] = 0;\n\n        emit UpdateUserBoost(msg.sender, 0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function addGauge(address gauge) external onlyOwner {\n        _addGauge(gauge);\n    }\n\n    function _addGauge(address gauge) internal {\n        bool newAdd = _gauges.add(gauge);\n        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);\n        // add and fail loud if zero address or already present and not deprecated\n        if (gauge == address(0) || !(newAdd || previouslyDepre"
    }
  ]
}