{
  "Title": "[L-11] If `onlyOwner` runs `renounceOwnership()` in the `PartnerManagerFactory` contract, the contract may become unavailable",
  "Content": "\nThere are two dynamic arrays in the `PartnerManagerFactory` contract, as values are added to these arrays with the `push` keyword. If the number in these arrays increases, the block may be over the gas limit. For such cases, it is necessary to have the feature of deleting elements from the array with the `pop` keyword. This is exactly what the contract has:\n\n```solidity\nsrc/maia/factories/PartnerManagerFactory.sol:\n  21:     PartnerManager[] public override partners;\n  24:     IBaseVault[] public override vaults;\n\n\nsrc/maia/factories/PartnerManagerFactory.sol:\n  79      /// @inheritdoc IPartnerManagerFactory\n  80:     function removePartner(PartnerManager partnerManager) external onlyOwner {\n  81:         if (partners[partnerIds[partnerManager]] != partnerManager) revert InvalidPartnerManager();\n  82:         delete partners[partnerIds[partnerManager]];\n  83:         delete partnerIds[partnerManager];\n  84: \n  85:         emit RemovedPartner(partnerManager);\n  86:     }\n\n  89:     function removeVault(IBaseVault vault) external onlyOwner {\n  90:         if (vaults[vaultIds[vault]] != vault) revert InvalidVault();\n  91:         delete vaults[vaultIds[vault]];\n  92:         delete vaultIds[vault];\n  93: \n  94:         emit RemovedVault(vault);\n  95:     }\n\n```\n\nTherefore, the `onlyOwner` authority here is very important for the contract; however, the `Ownable.sol` library imported has the `renounceOwnership()` feature. In case the owner accidentally triggers this function, the remove functions will not work and the contract will block gas due to arrays. This may have a continuous structure that exceeds its limit.\n\nhttps://github.com/Vectorized/solady/blob/main/src/auth/Ownable.sol#L136\n\n```solidity\n\nsrc/maia/factories/PartnerManagerFactory.sol:\n    4: import {Ownable} from \"solady/auth/Ownable.sol\";\n  12: contract PartnerManagerFactory is Ownable, IPartnerManagerFactory {\n```\n\n### Recommendation\n\nThe solution to this, is to override and disable the `renounceOwnership()` function, as implemented in many contracts in this project. It is important to include this code in the contract:\n\n```solidity\n function renounceOwnership() public payable override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n```\n\n### [L-12] There isnt a `skim` function\n\nA user can lose tokens which were sent directly to the `UlyssesPool` contract, without using special functions in [`UlyssesPool.sol`](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-amm/UlyssesPool.sol#L19).\n \nA user can't get back any tokens if they mistakenly send them directly to `pool.sol` (using the transfer function of the token contract).\n\nhttps://medium.com/coinmonks/how-to-sync-and-skim-in-uniswap-b536c921e66e\n\n### Recommendation\n\nAdd a `skim` function, like in uniswap, which allows users to transfer their tokens back. For this purpose, a contract should know the exact count of their loan/collateral tokens, which were transferred through `deposit`, `withdraw`, `borrow`, etc. functions.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/auth/Ownable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev Cannot double-initialize.\n    error AlreadyInitialized();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The owner slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    bytes32 internal constant _OWNER_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                if sload(ownerSlot) {\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\n                    revert(0x1c, 0x04)\n                }\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(_OWNER_SLOT, newOwner)\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, newOwner)\n            }\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}"
    },
    {
      "filename": "src/ulysses-amm/UlyssesPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {UlyssesERC4626} from \"@ERC4626/UlyssesERC4626.sol\";\n\nimport {UlyssesFactory} from \"./factories/UlyssesFactory.sol\";\n\nimport {IUlyssesPool} from \"./interfaces/IUlyssesPool.sol\";\n\n/// @title Ulysses Pool - Single Sided Stableswap LP\n/// @author Maia DAO (https://github.com/Maia-DAO)\ncontract UlyssesPool is UlyssesERC4626, Ownable, IUlyssesPool {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n    using SafeCastLib for uint256;\n\n    /// @notice ulysses factory associated with the Ulysses LP\n    UlyssesFactory public immutable factory;\n\n    /// @notice ID of this Ulysses LP\n    uint256 public immutable id;\n\n    /// @notice List of all added LPs\n    BandwidthState[] public bandwidthStateList;\n\n    /// @notice destinations[destinationId] => bandwidthStateList index\n    mapping(uint256 => uint256) public destinations;\n\n    /// @notice destinationIds[address] => destinationId\n    mapping(address => uint256) public destinationIds;\n\n    /// @notice Sum of all weights\n    uint256 public totalWeights;\n\n    /// @notice The minimum amount that can be swapped\n    uint256 private constant MIN_SWAP_AMOUNT = 1e4;\n\n    /// @notice The maximum sum of all weights\n    uint256 private constant MAX_TOTAL_WEIGHT = 256;\n\n    /// @notice The maximum destinations that can be added\n    uint256 private constant MAX_DESTINATIONS = 15;\n\n    /// @notice The maximum protocol fee that can be set (1%)\n    uint256 private constant MAX_PROTOCOL_FEE = 1e16;\n\n    /// @notice The maximum lambda1 that can be set (10%)\n    uint256 private constant MAX_LAMBDA1 = 1e17;\n\n    /// @notice The minimum sigma2 that can be set (1%)\n    uint256 private constant MIN_SIGMA2 = 1e16;\n\n    /*//////////////////////////////////////////////////////////////\n                            FEE PARAMETERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The divisioner for fee calculations\n    uint256 private constant DIVISIONER = 1 ether;\n\n    uint256 public protocolFee = 1e14;\n\n    /// @notice The current rebalancing fees\n    Fees public fees = Fees({lambda1: 20e14, lambda2: 4980e14, sigma1: 6000e14, sigma2: 500e14});\n\n    /**\n     * @param _id the Ulysses LP ID\n     * @param _asset the underlying asset\n     * @param _name the name of the LP\n     * @param _symbol the symbol of the LP\n     * @param _owner the owner of this contract\n     * @param _factory the Ulysses factory\n     */\n    constructor(\n        uint256 _id,\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        address _owner,\n        address _factory\n    ) UlyssesERC4626(_asset, _name, _symbol) {\n        require(_owner != address(0));\n        factory = UlyssesFactory(_factory);\n        _initializeOwner(_owner);\n        require(_id != 0);\n        id = _id;\n\n        bandwidthStateList.push(BandwidthState({bandwidth: 0, destination: UlyssesPool(address(0)), weight: 0}));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    // @inheritdoc UlyssesERC4626\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this)) - getProtocolFees();\n    }\n\n    // @inheritdoc UlyssesERC4626\n    function maxRedeem(address owner) public view override returns (uint256) {\n        return balanceOf[owner].min(asset.balanceOf(address(this)));\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function getBandwidth(uint256 destinationId) external view returns (uint256) {\n        /**\n         * @dev bandwidthStateList first element has always 0 bandwidth\n         *      so this line will never fail and return 0 instead\n         */\n        return bandwidthStateList[destinations[destinationId]].bandwidth;\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function getBandwidthStateList() external view returns (BandwidthState[] memory) {\n        return bandwidthStateList;\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function getProtocolFees() public view returns (uint256) {\n        uint256 balance = asset.balanceOf(address(this));\n        uint256 assets;\n\n        for (uint256 i = 1; i < bandwidthStateList.length; i++) {\n            uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);\n\n            assets += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);\n\n            assets += bandwidthStateList[i].bandwidth;\n        }\n\n        if (balance > assets) {\n            return balance - assets;\n        } else {\n            return 0;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUlyssesPool\n    function claimProtocolFees() external nonReentrant returns (uint256 claimed) {\n        claimed = getProtocolFees();\n\n        if (claimed > 0) {\n            asset.safeTransfer(factory.owner(), claimed);\n        }\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function addNewBandwidth(uint256 poolId, uint8 weight) external nonReentrant onlyOwner returns (uint256 index) {\n        if (weight == 0) revert InvalidWeight();\n\n        UlyssesPool destination = factory.pools(poolId);\n        uint256 destinationId = destination.id();\n\n        if (destinationIds[address(destination)] != 0 || destinationId == id) revert InvalidPool();\n\n        if (destinationId == 0) revert NotUlyssesLP();\n\n        index = bandwidthStateList.length;\n\n        if (index > MAX_DESTINATIONS) revert TooManyDestinations();\n\n        uint256 oldRebalancingFee;\n\n        for (uint256 i = 1; i < index; i++) {\n            uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);\n\n            oldRebalancingFee += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);\n        }\n\n        uint256 oldTotalWeights = totalWeights;\n        uint256 newTotalWeights = oldTotalWeights + weight;\n        totalWeights = newTotalWeights;\n\n        if (newTotalWeights > MAX_TOTAL_WEIGHT) revert InvalidWeight();\n\n        uint256 newBandwidth;\n\n        for (uint256 i = 1; i < index;) {\n            uint256 oldBandwidth = bandwidthStateList[i].bandwidth;\n            if (oldBandwidth > 0) {\n                bandwidthStateList[i].bandwidth = oldBandwidth.mulDivUp(oldTotalWeights, newTotalWeights).toUint248();\n\n                newBandwidth += oldBandwidth - bandwidthStateList[i].bandwidth;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        bandwidthStateList.push(\n            BandwidthState({bandwidth: newBandwidth.toUint248(), destination: destination, weight: weight})\n        );\n\n        destinations[destinationId] = index;\n        destinationIds[address(destination)] = index;\n\n        uint256 newRebalancingFee;\n\n        for (uint256 i = 1; i <= index; i++) {\n            uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);\n\n            newRebalancingFee += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);\n        }\n\n        if (oldRebalancingFee < newRebalancingFee) {\n            asset.safeTransferFrom(msg.sender, address(this), newRebalancingFee - oldRebalancingFee);\n        }\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function setWeight(uint256 poolId, uint8 weight) external nonReentrant onlyOwner {\n        if (weight == 0) revert InvalidWeight();\n\n        uint256 poolIndex = destinations[poolId];\n\n        if (poolIndex == 0) revert NotUlyssesLP();\n\n        uint256 oldRebalancingFee;\n\n        for (uint256 i = 1; i < bandwidthStateList.length; i++) {\n            uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);\n\n            oldRebalancingFee += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);\n        }\n\n        uint256 oldTotalWeights = totalWeights;\n        uint256 weightsWithoutPool = oldTotalWeights - bandwidthStateList[poolIndex].weight;\n        uint256 newTotalWeights = weightsWithoutPool + weight;\n        totalWeights = newTotalWeights;\n\n        if (totalWeights > MAX_TOTAL_WEIGHT || oldTotalWeights == newTotalWeights) {\n            revert InvalidWeight();\n        }\n\n        uint256 leftOverBandwidth;\n\n        BandwidthState storage poolState = bandwidthStateList[poolIndex];\n        poolState.weight = weight;\n\n        if (oldTotalWeights > newTotalWeights) {\n            for (uint256 i = 1; i < bandwidthStateList.length;) {\n                if (i != poolIndex) {\n                    uint256 oldBandwidth = bandwidthStateList[i].bandwidth;\n                    if (oldBandwidth > 0) {\n                        bandwidthStateList[i].bandwidth =\n                            oldBandwidth.mulDivUp(oldTotalWeights, newTotalWeights).toUint248();\n\n                        leftOverBandwidth += oldBandwidth - bandwidthStateList[i].bandwidth;\n                    }\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            poolState.bandwidth += leftOverBandwidth.toUint248();\n        } else {\n            uint256 oldBandwidth = poolState.bandwidth;\n            if (oldBandwidth > 0) {\n                poolState.bandwidth = oldBandwidth.mulDivUp(oldTotalWeights, newTotalWeights).toUint248();\n\n                leftOverBandwidth += oldBandwidth - poolState.bandwidth;\n            }\n\n            for (uint256 i = 1; i < bandwidthStateList.length;) {\n                if (i != poolIndex) {\n                    if (i == bandwidthStateList.length - 1) {\n                        bandwidthStateList[i].bandwidth += leftOverBandwidth.toUint248();\n                    } else if (leftOverBandwidth > 0) {\n                        bandwidthStateList[i].bandwidth +=\n                            leftOverBandwidth.mulDiv(bandwidthStateList[i].weight, weightsWithoutPool).toUint248();\n                    }\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        uint256 newRebalancingFee;\n\n        for (uint256 i = 1; i < bandwidthStateList.length; i++) {\n            uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);\n\n            newRebalancingFee += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);\n        }\n\n        if (oldRebalancingFee < newRebalancingFee) {\n            asset.safeTransferFrom(msg.sender, address(this), newRebalancingFee - oldRebalancingFee);\n        }\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function setFees(Fees calldata _fees) external nonReentrant onlyOwner {\n        // Lower fee must be lower than 1%\n        if (_fees.lambda1 > MAX_LAMBDA1) revert InvalidFee();\n        // Sum of both fees must be 50%\n        if (_fees.lambda1 + _fees.lambda2 != DIVISIONER / 2) revert InvalidFee();\n\n        // Upper bound must be lower than 100%\n        if (_fees.sigma1 > DIVISIONER) revert InvalidFee();\n        // Lower bound must be lower than Upper bound and higher than 1%\n        if (_fees.sigma1 <= _fees.sigma2 || _fees.sigma2 < MIN_SIGMA2) revert InvalidFee();\n\n        fees = _fees;\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function setProtocolFee(uint256 _protocolFee) external nonReentrant {\n        if (msg.sender != factory.owner()) revert Unauthorized();\n\n        // Revert if the protocol fee is larger than 1%\n        if (_protocolFee > MAX_PROTOCOL_FEE) revert InvalidFee();\n\n        protocolFee = _protocolFee;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ULYSSES LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Calculates the bandwidth increase/decrease amount.\n     * Is called when a user is doing a swap or adding/removing liquidity.\n     * @param roundUp Whether to round up or down\n     * @param positiveTransfer Whether the transfer is positive or negative\n     * @param amount The amount to transfer\n     * @param _totalWeights The total weights\n     * @param _totalSupply The total supply\n     */\n    function getBandwidthUpdateAmounts(\n        bool roundUp,\n        bool positiveTransfer,\n        uint256 amount,\n        uint256 _totalWeights,\n        uint256 _totalSupply\n    ) private view returns (uint256[] memory bandwidthUpdateAmounts, uint256 length) {\n        // Get the bandwidth state list length\n        length = bandwidthStateList.length;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the list is empty\n            if eq(length, 1) {\n                // Store the function selector of `NotInitialized()`.\n                mstore(0x00, 0x87138d5c)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Revert if the amount is too small\n            if lt(amount, MIN_SWAP_AMOUNT) {\n                // Store the function selector of `AmountTooSmall()`.\n                mstore(0x00, 0xc2f5625a)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // Initialize bandwidth update amounts\n        bandwidthUpdateAmounts = new uint256[](length);\n        // Initialize bandwidth differences from target bandwidth\n        uint256[] memory diffs = new uint256[](length);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store bandwidth state slot in memory\n            mstore(0x00, bandwidthStateList.slot)\n            // Hash the bandwidth state slot to get the bandwidth state list start\n            let bandwidthStateListStart := keccak256(0x00, 0x20)\n\n            // Total difference from target bandwidth of all bandwidth states\n            let totalDiff\n            // Total difference from target bandwidth of all bandwidth states\n            let transfered\n            // Total amount to be distributed according to each bandwidth weights\n            let transferedChange\n\n            for { let i := 1 } lt(i, length) { i := add(i, 1) } {\n                // Load bandwidth and weight from storage\n                // Each bandwidth state occupies two storage slots\n                let slot := sload(add(bandwidthStateListStart, mul(i, 2)))\n                // Bandwidth is the first 248 bits of the slot\n                let bandwidth := and(slot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n                // Weight is the last 8 bits of the slot\n                let weight := shr(248, slot)\n\n                // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n                if mul(weight, gt(_totalSupply, div(not(0), weight))) {\n                    // Store the function selector of `MulDivFailed()`.\n                    mstore(0x00, 0xad251c27)\n                    // Revert with (offset, size).\n                    revert(0x1c, 0x04)\n                }\n\n                // Calculate the target bandwidth\n                let targetBandwidth := div(mul(_totalSupply, weight), _totalWeights)\n\n                // Calculate the difference from the target bandwidth\n                switch positiveTransfer\n                // If the transfer is positive, calculate deficit from target bandwidth\n                case true {\n                    // If there is a deficit, store the difference\n                    if gt(targetBandwidth, bandwidth) {\n                        // Calculate the difference\n                        let diff := sub(targetBandwidth, bandwidth)\n                        // Add the difference to the total difference\n                        totalDiff := add(totalDiff, diff)\n                        // Store the difference in the diffs array\n                        mstore(add(diffs, add(mul(i, 0x20), 0x20)), diff)\n                    }\n                }\n                // If the transfer is negative, calculate surplus from target bandwidth\n                default {\n                    // If there is a surplus, store the difference\n                    if gt(bandwidth, targetBandwidth) {\n                        // Calculate the difference\n                        let diff := sub(bandwidth, targetBandwidth)\n                        // Add the difference to the total difference\n                        totalDiff := add(totalDiff, diff)\n                        // Store the difference in the diffs array\n                        mstore(add(diffs, add(mul(i, 0x20), 0x20)), diff)\n                    }\n                }\n            }\n\n            // Calculate the amount to be distributed according deficit/surplus\n            // and/or the amount to be distributed according to each bandwidth weights\n            switch gt(amount, totalDiff)\n            // If the amount is greater than the total deficit/surplus\n            case true {\n                // Total deficit/surplus is distributed\n                transfered := totalDiff\n                // Set rest to be distributed according to each bandwidth weights\n                transferedChange := sub(amount, totalDiff)\n            }\n            // If the amount is less than the total deficit/surplus\n            default {\n                // Amount will be distributed according to deficit/surplus\n                transfered := amount\n            }\n\n            for { let i := 1 } lt(i, length) { i := add(i, 1) } {\n                // Increase/decrease amount of bandwidth for each bandwidth state\n                let bandwidthUpdate\n\n                // If there is a deficit/surplus, calculate the amount to be distributed\n                if gt(transfered, 0) {\n                    // Load the difference from the diffs array\n                    let diff := mload(add(diffs, add(mul(i, 0x20), 0x20)))\n\n                    // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n                    if mul(diff, gt(transfered, div(not(0), diff))) {\n                        // Store the function selector of `MulDivFailed()`.\n                        mstore(0x00, 0xad251c27)\n                        // Revert with (offset, size).\n                        revert(0x1c, 0x04)\n                    }\n\n                    // Calculate the amount to be distributed according to deficit/surplus\n                    switch roundUp\n                    // If round up then do mulDivUp(transfered, diff, totalDiff)\n                    case true {\n                        bandwidthUpdate :=\n                            add(\n                                iszero(iszero(mod(mul(transfered, diff), totalDiff))), div(mul(transfered, diff), totalDiff)\n                            )\n                    }\n                    // If round down then do mulDiv(transfered, diff, totalDiff)\n                    default { bandwidthUpdate := div(mul(transfered, diff), totalDiff) }\n                }\n\n                // If there is a rest, calculate the amount to be distributed according to each bandwidth weights\n                if gt(transferedChange, 0) {\n                    // Load weight from storage\n                    let weight := shr(248, sload(add(bandwidthStateListStart, mul(i, 2))))\n\n                    // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n                    if mul(weight, gt(transferedChange, div(not(0), weight))) {\n                        // Store the function selector of `MulDivFailed()`.\n                        mstore(0x00, 0xad251c27)\n                        // Revert with (offset, size).\n                        revert(0x1c, 0x04)\n                    }\n\n                    // Calculate the amount to be distributed according to each bandwidth weights\n                    switch roundUp\n                    // If round up then do mulDivUp(transferedChange, weight, _totalWeights)\n                    case true {\n                        bandwidthUpdate :=\n                            add(\n                                bandwidthUpdate,\n                                add(\n                                    iszero(iszero(mod(mul(transferedChange, weight), _totalWeights))),\n                                    div(mul(transferedChange, weight), _totalWeights)\n                                )"
    }
  ]
}