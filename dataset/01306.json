{
  "Title": "M-15: CREATE3 is not available in the zkSync Era.",
  "Content": "# Issue M-15: CREATE3 is not available in the zkSync Era. \n\nSource: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/862 \n\n## Found by \n0xc0ffEE, 0xnirlin, carrotsmuggler, imsrybr0, jkoppel, pengun\n\n## Vulnerability Detail\nAccording to the contest README, the project can be deployed in zkSync Era. (https://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/README.md?plain=1#L11)\n\nThe zkSync Era docs explain how it differs from Ethereum.\n\nThe description of CREATE and CREATE2 (https://era.zksync.io/docs/reference/architecture/differences-with-ethereum.html#create-create2) states that Create cannot be used for arbitrary code unknown to the compiler.\n\nPOC: \n```solidity\n// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.0;\n\nimport \"./MiniContract.sol\";\nimport \"./CREATE3.sol\";\n\ncontract DeployTest {\n    address public deployedAddress;\n    event Deployed(address);\n    \n    function generateContract() public returns(address, address) {\n        bytes32 salt = keccak256(\"SALT\");\n\n        address preCalculatedAddress = CREATE3.getDeployed(salt);\n\n        // check if the contract has already been deployed by checking code size of address\n        bytes memory creationCode = abi.encodePacked(type(MiniContract).creationCode, abi.encode(777));\n\n        // Use CREATE3 to deploy the anchor contract\n        address deployed = CREATE3.deploy(salt, creationCode, 0);\n        return (preCalculatedAddress, deployed);\n    }\n}\n```\nYou can check sample POC code at zkSync Era Testnet(https://goerli.explorer.zksync.io/address/0x0f670f8AfcB09f4BC509Cb59D6e7CEC1A52BFA51#contract)\n\nAlso, the logic to compute the address of Create2 is different from Ethereum, as shown below, so the CREATE3 library cannot be used as it is.\n\nThis cause registry returns an incorrect `preCalculatedAddress`, causing the anchor to be registered to an address that is not the actual deployed address.\n\n```solidity \naddress ⇒ keccak256( \n    keccak256(\"zksyncCreate2\") ⇒ 0x2020dba91b30cc0006188af794c2fb30dd8520db7e2c088b7fc7c103c00ca494, \n    sender, \n    salt, \n    keccak256(bytecode), \n    keccak256(constructorInput)\n ) \n```\n\n\n\n## Impact\n`generateAnchor` doesn't work, so user can't do anything related to anchor.\n\n## Code Snippet\nhttps://github.com/allo-protocol/allo-v2/blob/851571c27df5c16f6586ece2a1cb6fd0acf04ec9/contracts/core/Registry.sol#L350\nhttps://github.com/allo-protocol/allo-v2/blob/851571c27df5c16f6586ece2a1cb6fd0acf04ec9/contracts/core/Registry.sol#L338\n## Tool used\n\nManual Review\n\n## Recommendation\nThis can be solved by implementing CREATE2 directly instead of CREATE3 and using `type(Anchor).creationCode`.\nAlso, the compute address logic needs to be modified for zkSync.\n\n\n\n## Discussion\n\n**0xdeadbeef0x**\n\nEscalate\n\nI argue that this and #411 show be low since there is no loss of funds. While this impacts the functionality of the protocol on zkSync, no funds are at risk.\n\nAlso, createPoolWithCustomStrategy can be used instead - see comment https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/411#issuecomment-1757462133\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> I argue that this and #411 show be low since there is no loss of funds. While this impacts the functionality of the protocol on zkSync, no funds are at risk.\n> \n> Also, createPoolWithCustomStrategy can be used instead - see comment https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/411#issuecomment-1757462133\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**neeksec**\n\nAgree with Escalation that this one and #411 is low.\n\nRe-read the docs. DoS without fund loss is not counted as medium.\n\n>Could Denial-of-Service (DOS), griefing, or locking of contracts count as a Medium (or High) issue?\nIt would not count if the DOS, etc. lasts a known, finite amount of time <1 year. **If it will result in funds being inaccessible for >=1 year, then it would count as a loss of funds and be eligible for a Medium or High designation**.\n\nAlso checked [a similar issue in Kyberswap](https://github.com/sherlock-audit/2023-07-kyber-swap-judging/issues/26#issuecomment-1711944172). Can agree with the Escalation.\n\n**imsrybr0**\n\nBoth of this and #411 break core contract functionality.\n\nEDIT:\nAlso, createPoolWithCustomStrategy cannot be used as it requires a valid profile which cannot be created because of this issue \n\n**jacksanford1**\n\nhttps://github.com/allo-protocol/allo-v2/pull/387\n\n**Evert0x**\n\nIf I understand correctly the complete zksync era deployment will be useless because of this. \n\nhttps://docs.sherlock.xyz/audits/judging/judging#v.-how-to-identify-a-medium-issue\n> Breaks core contract functionality, rendering the contract useless\n\nI believe this creates a very strong argument for Medium severity.\n\n> Also checked https://github.com/sherlock-audit/2023-07-kyber-swap-judging/issues/26#issuecomment-1711944172.\n\nKyberSwap didn't explicitly tag `zksync era` as an EVM chain they were planning to deploy on. \n\nPlanning to reject escalation and keep medium. \n\n**0xdeadbeef0x**\n\n@Evert0x \n\nI would appreciate to not reject the escalation because up until now only issues that result in loss of funds would get accepted by Sherlock (hence my reasoning for escalating this)\n\nIt was based on previous contests and for the clear definition in Sherlock docs: \nhttps://docs.sherlock.xyz/audits/judging/judging#ii.-criteria-for-issue-severity\n`There is a viable scenario (even if unlikely) that could cause the protocol to enter a state where a material amount of funds can be lost.` \n\nEven in the DOS rule it mentions there has to be loss of funds\n\n**0xRizwan**\n\n> KyberSwap didn't explicitly tag `zksync era` as an EVM chain they were planning to deploy on.\n\n@Evert0x That kyberswap report was submitted by me. It is supposed to deploy and will be deployed on `zkSync Era`, I would just draft a detail response on kyberswap issue. To be noted, I am in discussion on the kyber swap issue with `Hrishi` and `Jack` from last 2 weeks.\n\n**jack-the-pug**\n\nhttps://github.com/allo-protocol/allo-v2/pull/387/files#diff-342c707b787edfadc9b07ed13856c8915c85b47c3bb10e7190b005f6fd177e50R348-R350\n\n@0xKurt I believe that the way the address is computed in the updated version still returns an incorrect preCalculatedAddress on zkSync Era.\n\n**0xKurt**\n\nwe will look into it @jack-the-pug. If you have any suggestions for us, feel free to drop them.\ncc @codenamejason @thelostone-mc \n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n> Even in the DOS rule it mentions there has to be loss of funds\nThis not about the interpretation of the DOS rule but about the `How to identify a medium issue` rule.\n\nBesides the reasons mentioned earlier. The following is also a key rule in the judging\n> Hierarchy of truth: Contest README > Sherlock rules for valid issues > Historical decisions. \n\nAlthough the correct language is missing the intention of this sentence is that the protocol can thrive in the context defined by the protocol team. We will update to language to make this clear for future contests.\n\n\n\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xdeadbeef0x](https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/862/#issuecomment-1765822917): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/109",
  "Code": [
    {
      "filename": "README.md?plain=1",
      "content": "# Gitcoin Allo contest details\n\n- Join [Sherlock Discord](https://discord.gg/MABEWyASkp)\n- Submit findings using the issue page in your private contest repo (label issues as med or high)\n- [Read for more details](https://docs.sherlock.xyz/audits/watsons)\n\n# Q&A\n\n### Q: On what chains are the smart contracts going to be deployed?\nAll EVM compatible chains + Zkync Era\n___\n\n### Q: Which ERC20 tokens do you expect will interact with the smart contracts? \nAll \n___\n\n### Q: Which ERC721 tokens do you expect will interact with the smart contracts? \nNone\n___\n\n### Q: Which ERC777 tokens do you expect will interact with the smart contracts? \nNone\n___\n\n### Q: Are there any FEE-ON-TRANSFER tokens interacting with the smart contracts?\n\nYes. When funding a pool on Allo.sol\n___\n\n### Q: Are there any REBASING tokens interacting with the smart contracts?\n\nNone\n___\n\n### Q: Are the admins of the protocols your contracts integrate with (if any) TRUSTED or RESTRICTED?\nRESTRICTED\n___\n\n### Q: Is the admin/owner of the protocol/contracts TRUSTED or RESTRICTED?\nTRUSTED\n\nThe contracts are upgradable and the admin is trusted. \n\nThe owner of Allo.sol can\n- recover funds from Allo.sol \n- flag contracts as cloneable \n- set the base fee, percent fee , registry address and treasury address\n\nThe owner of Registry.sol can recover funds from Registry.sol \n\n___\n\n### Q: Are there any additional protocol roles? If yes, please explain in detail:\n* **Profile Owners:** Users who create profiles using the `Registry` contract. These profiles are central to protocol interactions, offering a unique identity for users and enabling secure external calls through the `Anchor` contract.\n    \n* **Profile Member:** Members of a Registry profile have specific access rights as defined by the profile's owner.\n\n* **Allo Owner:** Individuals who control the `Allo` contract, possessing the authority to manage fund recovery, fee parameters, and treasury addresses. Their role is pivotal in ensuring the protocol's financial stability.\n  \n\n* **Pool Creator** A user who can create new pools using custom or cloneable strategies. They can specify metadata, strategy addresses, managers, and other parameters during pool creation.\n    \n* **Pool Administrator** Users with administrative control over specific pools. They can manage pool managers, enabling effective pool governance.\n    \n* **Pool Manager** Users who manage funds within specific pools. They can allocate and distribute funds according to the pool's strategy\n___\n\n### Q: Is the code/contract expected to comply with any EIPs? Are there specific assumptions around adhering to those EIPs that Watsons should be aware of?\nERC20, EIP-712\n___\n\n### Q: Please list any known issues/acceptable risks that should not result in a valid finding.\nFee skirting where pool manager directly fund the pool without paying the fees\n___\n\n### Q: Please provide links to previous audits (if any).\nNew\n___\n\n### Q: Are there any off-chain mechanisms or off-chain procedures for the protocol (keeper bots, input validation expectations, etc)?\n- Metadata struct references IPFS \n- DonationVotingMerkleDistributionBaseMerkle has calculations which happens off-chain based on which a merkle root is generated and uploaded. The pool manager is a trusted role and is expected to use https://github.com/gitcoinco/pluralistic.js\n___\n\n### Q: In case of external protocol integrations, are the risks of external contracts pausing or executing an emergency withdrawal acceptable? If not, Watsons will submit issues related to these situations that can harm your protocol's functionality.\nNo\n___\n\n### Q: Do you expect to use any of the following tokens with non-standard behaviour with the smart contracts?\nYes as we support all ERC20 tokens.\n___\n\n### Q: Add links to relevant protocol resources\n- https://docs.allo.gitcoin.co/\n- https://github.com/allo-protocol/allo-v2/blob/main/audit-resources.md\n___\n\n\n\n# Audit scope\n\n\n[allo-v2 @ 0b881ef4a0013d2809374c9ea69f4cf1288dfe62](https://github.com/allo-protocol/allo-v2/tree/0b881ef4a0013d2809374c9ea69f4cf1288dfe62)\n- [allo-v2/contracts/core/Allo.sol](allo-v2/contracts/core/Allo.sol)\n- [allo-v2/contracts/core/Anchor.sol](allo-v2/contracts/core/Anchor.sol)\n- [allo-v2/contracts/core/Registry.sol](allo-v2/contracts/core/Registry.sol)\n- [allo-v2/contracts/core/interfaces/IAllo.sol](allo-v2/contracts/core/interfaces/IAllo.sol)\n- [allo-v2/contracts/core/interfaces/IRegistry.sol](allo-v2/contracts/core/interfaces/IRegistry.sol)\n- [allo-v2/contracts/core/interfaces/IStrategy.sol](allo-v2/contracts/core/interfaces/IStrategy.sol)\n- [allo-v2/contracts/core/libraries/Clone.sol](allo-v2/contracts/core/libraries/Clone.sol)\n- [allo-v2/contracts/core/libraries/Errors.sol](allo-v2/contracts/core/libraries/Errors.sol)\n- [allo-v2/contracts/core/libraries/Metadata.sol](allo-v2/contracts/core/libraries/Metadata.sol)\n- [allo-v2/contracts/core/libraries/Native.sol](allo-v2/contracts/core/libraries/Native.sol)\n- [allo-v2/contracts/core/libraries/Transfer.sol](allo-v2/contracts/core/libraries/Transfer.sol)\n- [allo-v2/contracts/strategies/BaseStrategy.sol](allo-v2/contracts/strategies/BaseStrategy.sol)\n- [allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol](allo-v2/contracts/strategies/donation-voting-merkle-base/DonationVotingMerkleDistributionBaseStrategy.sol)\n- [allo-v2/contracts/strategies/donation-voting-merkle-distribution-direct-transfer/DonationVotingMerkleDistributionDirectTransferStrategy.sol](allo-v2/contracts/strategies/donation-voting-merkle-distribution-direct-transfer/DonationVotingMerkleDistributionDirectTransferStrategy.sol)\n- [allo-v2/contracts/strategies/donation-voting-merkle-distribution-vault/DonationVotingMerkleDistributionVaultStrategy.sol](allo-v2/contracts/strategies/donation-voting-merkle-distribution-vault/DonationVotingMerkleDistributionVaultStrategy.sol)\n- [allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol](allo-v2/contracts/strategies/qv-base/QVBaseStrategy.sol)\n- [allo-v2/contracts/strategies/qv-simple/QVSimpleStrategy.sol](allo-v2/contracts/strategies/qv-simple/QVSimpleStrategy.sol)\n- [allo-v2/contracts/strategies/rfp-committee/RFPCommitteeStrategy.sol](allo-v2/contracts/strategies/rfp-committee/RFPCommitteeStrategy.sol)\n- [allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol](allo-v2/contracts/strategies/rfp-simple/RFPSimpleStrategy.sol)"
    },
    {
      "filename": "contracts/core/Registry.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport {AccessControl} from \"openzeppelin-contracts/contracts/access/AccessControl.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport {CREATE3} from \"solady/src/utils/CREATE3.sol\";\nimport {ERC20} from \"solady/src/tokens/ERC20.sol\";\n// Interfaces\nimport \"./interfaces/IRegistry.sol\";\n// Internal Libraries\nimport {Anchor} from \"./Anchor.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\nimport {Metadata} from \"./libraries/Metadata.sol\";\nimport \"./libraries/Native.sol\";\nimport \"./libraries/Transfer.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Registry Contract\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Registry contract for creating and managing profiles\n/// @dev This contract is used to create and manage profiles for the Allo protocol\n///      It is also used to deploy the anchor contract for each profile which acts as a proxy\n///      for the profile and is used to receive funds and execute transactions on behalf of the profile\n///      The Registry is also used to add and remove members from a profile and update the profile 'Metadata'\ncontract Registry is IRegistry, Native, AccessControl, Transfer, Initializable, Errors {\n    /// ==========================\n    /// === Storage Variables ====\n    /// ==========================\n\n    /// @notice This maps the anchor address to the profile ID\n    /// @dev anchor -> Profile.id\n    mapping(address => bytes32) public anchorToProfileId;\n\n    /// @notice This maps the profile ID to the profile details\n    /// @dev Profile.id -> Profile\n    mapping(bytes32 => Profile) public profilesById;\n\n    /// @notice This maps the profile ID to the pending owner\n    /// @dev Profile.id -> pending owner\n    mapping(bytes32 => address) public profileIdToPendingOwner;\n\n    /// @notice Allo Owner Role for fund recovery\n    bytes32 public constant ALLO_OWNER = keccak256(\"ALLO_OWNER\");\n\n    /// ====================================\n    /// =========== Modifier ===============\n    /// ====================================\n\n    /// @notice Checks if the caller is the profile owner\n    /// @dev Reverts `UNAUTHORIZED()` if the caller is not the profile owner\n    /// @param _profileId The ID of the profile\n    modifier onlyProfileOwner(bytes32 _profileId) {\n        _checkOnlyProfileOwner(_profileId);\n        _;\n    }\n\n    // ====================================\n    // =========== Initializer =============\n    // ====================================\n\n    /// @notice Initializes the contract after an upgrade\n    /// @dev During upgrade -> a higher version should be passed to reinitializer. Reverts if the '_owner' is the 'address(0)'\n    /// @param _owner The owner of the contract\n    function initialize(address _owner) external reinitializer(1) {\n        // Make sure the owner is not 'address(0)'\n        if (_owner == address(0)) revert ZERO_ADDRESS();\n\n        // Grant the role to the owner\n        _grantRole(ALLO_OWNER, _owner);\n    }\n\n    /// ====================================\n    /// ==== External/Public Functions =====\n    /// ====================================\n\n    /// @notice Retrieve profile by profileId\n    /// @dev Used when you have the 'profileId' and want to retrieve the profile\n    /// @param _profileId The ID of the profile\n    /// @return The Profile details for the `_profileId`\n    function getProfileById(bytes32 _profileId) external view returns (Profile memory) {\n        return profilesById[_profileId];\n    }\n\n    /// @notice Retrieve profile by anchor\n    /// @dev Used when you have the 'anchor' address and want to retrieve the profile\n    /// @param _anchor The anchor of the profile\n    /// @return Profile details for the `_anchor`\n    function getProfileByAnchor(address _anchor) external view returns (Profile memory) {\n        bytes32 profileId = anchorToProfileId[_anchor];\n        return profilesById[profileId];\n    }\n\n    /// @notice Creates a new profile\n    /// @dev This will also generate the 'profileId' and 'anchor' address, emits a 'ProfileCreated()' event\n    /// Note: The 'nonce' is used to generate the 'profileId' and should be unique for each profile\n    /// Note: The 'name' and 'profileId' are used to generate the 'anchor' address\n    /// @param _nonce Nonce used to generate profileId. Can be any integer, but should be unique\n    ///               for each profile.\n    /// @param _name The name of the profile\n    /// @param _metadata The metadata of the profile\n    /// @param _owner The owner of the profile\n    /// @param _members The members of the profile\n    /// @return The ID for the created profile\n    function createProfile(\n        uint256 _nonce,\n        string memory _name,\n        Metadata memory _metadata,\n        address _owner,\n        address[] memory _members\n    ) external returns (bytes32) {\n        // Generate a profile ID using a nonce and the msg.sender\n        bytes32 profileId = _generateProfileId(_nonce);\n\n        // Make sure the nonce is available\n        if (profilesById[profileId].anchor != address(0)) revert NONCE_NOT_AVAILABLE();\n\n        // Make sure the owner is not the zero address\n        if (_owner == address(0)) revert ZERO_ADDRESS();\n\n        // Create a new Profile instance, also generates the anchor address\n        Profile memory profile = Profile({\n            id: profileId,\n            nonce: _nonce,\n            name: _name,\n            metadata: _metadata,\n            owner: _owner,\n            anchor: _generateAnchor(profileId, _name)\n        });\n\n        profilesById[profileId] = profile;\n        anchorToProfileId[profile.anchor] = profileId;\n\n        // Assign roles for the profile members\n        uint256 memberLength = _members.length;\n        for (uint256 i; i < memberLength;) {\n            address member = _members[i];\n\n            // Will revert if any of the addresses are a zero address\n            if (member == address(0)) revert ZERO_ADDRESS();\n\n            // Grant the role to the member and emit the event for each member\n            _grantRole(profileId, member);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Emit the event that the profile was created\n        emit ProfileCreated(profileId, profile.nonce, profile.name, profile.metadata, profile.owner, profile.anchor);\n\n        // Return the profile ID\n        return profileId;\n    }\n\n    /// @notice Updates the name of the profile and generates new anchor.\n    ///         Emits a 'ProfileNameUpdated()' event.\n    /// @dev Use caution when updating your profile name as it will generate a new anchor address. You can always update the name\n    ///      back to the original name to get the original anchor address. 'msg.sender' must be the owner of the profile.\n    /// @param _profileId The profileId of the profile\n    /// @param _name The new name of the profile\n    /// @return anchor The new anchor\n    function updateProfileName(bytes32 _profileId, string memory _name)\n        external\n        onlyProfileOwner(_profileId)\n        returns (address anchor)\n    {\n        // Generate a new anchor address\n        anchor = _generateAnchor(_profileId, _name);\n\n        // Get the profile using the profileId from the mapping\n        Profile storage profile = profilesById[_profileId];\n\n        // Set the new name\n        profile.name = _name;\n\n        // Remove old anchor\n        anchorToProfileId[profile.anchor] = bytes32(0);\n\n        // Set the new anchor\n        profile.anchor = anchor;\n        anchorToProfileId[anchor] = _profileId;\n\n        // Emit the event that the name was updated with the new data\n        emit ProfileNameUpdated(_profileId, _name, anchor);\n\n        // Return the new anchor\n        return anchor;\n    }\n\n    /// @notice Update the 'Metadata' of the profile. Emits a 'ProfileMetadataUpdated()' event.\n    /// @dev 'msg.sender' must be the owner of the profile.\n    /// @param _profileId The ID of the profile\n    /// @param _metadata The new 'Metadata' of the profile\n    function updateProfileMetadata(bytes32 _profileId, Metadata memory _metadata)\n        external\n        onlyProfileOwner(_profileId)\n    {\n        // Get the profile using the 'profileId' from the mapping and update the 'Metadata' value\n        profilesById[_profileId].metadata = _metadata;\n\n        // Emit the event that the 'Metadata' was updated\n        emit ProfileMetadataUpdated(_profileId, _metadata);\n    }\n\n    /// @notice Checks if the address is an owner or member of the profile\n    /// @param _profileId The ID of the profile\n    /// @param _account The address to check\n    /// @return 'true' if the address is an owner or member of the profile, otherwise 'false'\n    function isOwnerOrMemberOfProfile(bytes32 _profileId, address _account) external view returns (bool) {\n        return _isOwnerOfProfile(_profileId, _account) || _isMemberOfProfile(_profileId, _account);\n    }\n\n    /// @notice Checks if the given address is an owner of the profile\n    /// @param _profileId The ID of the profile\n    /// @param _owner The address to check\n    /// @return 'true' if the address is an owner of the profile, otherwise 'false'\n    function isOwnerOfProfile(bytes32 _profileId, address _owner) external view returns (bool) {\n        return _isOwnerOfProfile(_profileId, _owner);\n    }\n\n    /// @notice Checks if the given address is a member of the profile\n    /// @param _profileId The ID of the profile\n    /// @param _member The address to check\n    /// @return 'true' if the address is a member of the profile, otherwise 'false'\n    function isMemberOfProfile(bytes32 _profileId, address _member) external view returns (bool) {\n        return _isMemberOfProfile(_profileId, _member);\n    }\n\n    /// @notice Updates the pending owner of the profile. Emits a 'ProfilePendingOwnership()' event.\n    /// @dev 'msg.sender' must be the owner of the profile. [1]*This is step one of two when transferring ownership.\n    /// @param _profileId The ID of the profile\n    /// @param _pendingOwner The new pending owner\n    function updateProfilePendingOwner(bytes32 _profileId, address _pendingOwner)\n        external\n        onlyProfileOwner(_profileId)\n    {\n        // Set the pending owner to the profile\n        profileIdToPendingOwner[_profileId] = _pendingOwner;\n\n        // Emit the event that the pending owner was updated\n        emit ProfilePendingOwnerUpdated(_profileId, _pendingOwner);\n    }\n\n    /// @notice Transfers the ownership of the profile to the pending owner and Emits a 'ProfileOwnerUdpated()' event.\n    /// @dev 'msg.sender' must be the pending owner of the profile. [2]*This is step two of two when transferring ownership.\n    /// @param _profileId The ID of the profile\n    function acceptProfileOwnership(bytes32 _profileId) external {\n        // Get the profile from the mapping\n        Profile storage profile = profilesById[_profileId];\n\n        // Get the pending owner from the mapping that was set when the owner was updated\n        address newOwner = profileIdToPendingOwner[_profileId];\n\n        // Revert if the 'msg.sender' is not the pending owner\n        if (msg.sender != newOwner) revert NOT_PENDING_OWNER();\n\n        // Set the new owner and delete the pending owner from the mapping\n        profile.owner = newOwner;\n        delete profileIdToPendingOwner[_profileId];\n\n        // Emit the event that the owner was accepted and updated\n        emit ProfileOwnerUpdated(_profileId, profile.owner);\n    }\n\n    /// @notice Adds members to the profile\n    /// @dev 'msg.sender' must be the owner of the profile.\n    /// @param _profileId The ID of the profile\n    /// @param _members The members to add\n    function addMembers(bytes32 _profileId, address[] memory _members) external onlyProfileOwner(_profileId) {\n        uint256 memberLength = _members.length;\n\n        // Loop through the members and add them to the profile by granting the role\n        for (uint256 i; i < memberLength;) {\n            address member = _members[i];\n\n            // Will revert if any of the addresses are a zero address\n            if (member == address(0)) revert ZERO_ADDRESS();\n\n            // Grant the role to the member and emit the event for each member\n            _grantRole(_profileId, member);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Removes members from the profile\n    /// @dev 'msg.sender' must be the pending owner of the profile.\n    /// @param _profileId The ID of the profile\n    /// @param _members The members to remove\n    function removeMembers(bytes32 _profileId, address[] memory _members) external onlyProfileOwner(_profileId) {\n        uint256 memberLength = _members.length;\n\n        // Loop through the members and remove them from the profile by revoking the role\n        for (uint256 i; i < memberLength;) {\n            // Revoke the role from the member and emit the event for each member\n            _revokeRole(_profileId, _members[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// ====================================\n    /// ======== Internal Functions ========\n    /// ====================================\n\n    /// @notice Checks if the caller is the owner of the profile\n    /// @dev Internal function used by modifier 'onlyProfileOwner'\n    /// @param _profileId The ID of the profile\n    function _checkOnlyProfileOwner(bytes32 _profileId) internal view {\n        if (!_isOwnerOfProfile(_profileId, msg.sender)) revert UNAUTHORIZED();\n    }\n\n    /// @notice Generates and deploys the anchor for the given 'profileId' and name\n    /// @dev Internal function used by 'createProfile()' and 'updateProfileName()' to create and anchor.\n    /// @param _profileId The ID of the profile\n    /// @param _name The name of the profile\n    /// @return anchor The address of the deployed anchor contract\n    function _generateAnchor(bytes32 _profileId, string memory _name) internal returns (address anchor) {\n        bytes32 salt = keccak256(abi.encodePacked(_profileId, _name));\n\n        address preCalculatedAddress = CREATE3.getDeployed(salt);\n\n        // check if the contract already exists and if the profileId matches\n        if (preCalculatedAddress.code.length > 0) {\n            if (Anchor(payable(preCalculatedAddress)).profileId() != _profileId) revert ANCHOR_ERROR();\n\n            anchor = preCalculatedAddress;\n        } else {\n            // check if the contract has already been deployed by checking code size of address\n            bytes memory creationCode = abi.encodePacked(type(Anchor).creationCode, abi.encode(_profileId));\n\n            // Use CREATE3 to deploy the anchor contract\n            anchor = CREATE3.deploy(salt, creationCode, 0);\n        }\n    }\n\n    /// @notice Generates the 'profileId' based on msg.sender and nonce\n    /// @dev Internal function used by 'createProfile()' to generate profileId.\n    /// @param _nonce Nonce provided by the caller to generate 'profileId'\n    /// @return 'profileId' The ID of the profile\n    function _generateProfileId(uint256 _nonce) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(_nonce, msg.sender));\n    }\n\n    /// @notice Checks if an address is the owner of the profile\n    /// @dev Internal function used to determine if an address is the profile owner\n    /// @param _profileId The 'profileId' of the profile\n    /// @param _owner The address to check\n    /// @return 'true' if the address is an owner of the profile, otherwise 'false'\n    function _isOwnerOfProfile(bytes32 _profileId, address _owner) internal view returns (bool) {\n        return profilesById[_profileId].owner == _owner;\n    }\n\n    /// @notice Checks if an address is a member of the profile\n    /// @dev Internal function used to determine if an address is a member of the profile\n    /// @param _profileId The 'profileId' of the profile\n    /// @param _member The address to check\n    /// @return 'true' if the address is a member of the profile, otherwise 'false'\n    function _isMemberOfProfile(bytes32 _profileId, address _member) internal view returns (bool) {\n        return hasRole(_profileId, _member);\n    }\n\n    /// @notice Transfers any fund balance in Allo to the recipient\n    /// @dev 'msg.sender' must be the Allo owner\n    /// @param _token The address of the token to transfer\n    /// @param _recipient The address of the recipient\n    function recoverFunds(address _token, address _recipient) external onlyRole(ALLO_OWNER) {\n        if (_recipient == address(0)) revert ZERO_ADDRESS();\n\n        uint256 amount = _token == NATIVE ? address(this).balance : ERC20(_token).balanceOf(address(this));\n        _transferAmount(_token, _recipient, amount);\n    }\n}"
    },
    {
      "filename": "contracts/core/Registry.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport {AccessControl} from \"openzeppelin-contracts/contracts/access/AccessControl.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport {CREATE3} from \"solady/src/utils/CREATE3.sol\";\nimport {ERC20} from \"solady/src/tokens/ERC20.sol\";\n// Interfaces\nimport \"./interfaces/IRegistry.sol\";\n// Internal Libraries\nimport {Anchor} from \"./Anchor.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\nimport {Metadata} from \"./libraries/Metadata.sol\";\nimport \"./libraries/Native.sol\";\nimport \"./libraries/Transfer.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Registry Contract\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Registry contract for creating and managing profiles\n/// @dev This contract is used to create and manage profiles for the Allo protocol\n///      It is also used to deploy the anchor contract for each profile which acts as a proxy\n///      for the profile and is used to receive funds and execute transactions on behalf of the profile\n///      The Registry is also used to add and remove members from a profile and update the profile 'Metadata'\ncontract Registry is IRegistry, Native, AccessControl, Transfer, Initializable, Errors {\n    /// ==========================\n    /// === Storage Variables ====\n    /// ==========================\n\n    /// @notice This maps the anchor address to the profile ID\n    /// @dev anchor -> Profile.id\n    mapping(address => bytes32) public anchorToProfileId;\n\n    /// @notice This maps the profile ID to the profile details\n    /// @dev Profile.id -> Profile\n    mapping(bytes32 => Profile) public profilesById;\n\n    /// @notice This maps the profile ID to the pending owner\n    /// @dev Profile.id -> pending owner\n    mapping(bytes32 => address) public profileIdToPendingOwner;\n\n    /// @notice Allo Owner Role for fund recovery\n    bytes32 public constant ALLO_OWNER = keccak256(\"ALLO_OWNER\");\n\n    /// ====================================\n    /// =========== Modifier ===============\n    /// ====================================\n\n    /// @notice Checks if the caller is the profile owner\n    /// @dev Reverts `UNAUTHORIZED()` if the caller is not the profile owner\n    /// @param _profileId The ID of the profile\n    modifier onlyProfileOwner(bytes32 _profileId) {\n        _checkOnlyProfileOwner(_profileId);\n        _;\n    }\n\n    // ====================================\n    // =========== Initializer =============\n    // ====================================\n\n    /// @notice Initializes the contract after an upgrade\n    /// @dev During upgrade -> a higher version should be passed to reinitializer. Reverts if the '_owner' is the 'address(0)'\n    /// @param _owner The owner of the contract\n    function initialize(address _owner) external reinitializer(1) {\n        // Make sure the owner is not 'address(0)'\n        if (_owner == address(0)) revert ZERO_ADDRESS();\n\n        // Grant the role to the owner\n        _grantRole(ALLO_OWNER, _owner);\n    }\n\n    /// ====================================\n    /// ==== External/Public Functions =====\n    /// ====================================\n\n    /// @notice Retrieve profile by profileId\n    /// @dev Used when you have the 'profileId' and want to retrieve the profile\n    /// @param _profileId The ID of the profile\n    /// @return The Profile details for the `_profileId`\n    function getProfileById(bytes32 _profileId) external view returns (Profile memory) {\n        return profilesById[_profileId];\n    }\n\n    /// @notice Retrieve profile by anchor\n    /// @dev Used when you have the 'anchor' address and want to retrieve the profile\n    /// @param _anchor The anchor of the profile\n    /// @return Profile details for the `_anchor`\n    function getProfileByAnchor(address _anchor) external view returns (Profile memory) {\n        bytes32 profileId = anchorToProfileId[_anchor];\n        return profilesById[profileId];\n    }\n\n    /// @notice Creates a new profile\n    /// @dev This will also generate the 'profileId' and 'anchor' address, emits a 'ProfileCreated()' event\n    /// Note: The 'nonce' is used to generate the 'profileId' and should be unique for each profile\n    /// Note: The 'name' and 'profileId' are used to generate the 'anchor' address\n    /// @param _nonce Nonce used to generate profileId. Can be any integer, but should be unique\n    ///               for each profile.\n    /// @param _name The name of the profile\n    /// @param _metadata The metadata of the profile\n    /// @param _owner The owner of the profile\n    /// @param _members The members of the profile\n    /// @return The ID for the created profile\n    function createProfile(\n        uint256 _nonce,\n        string memory _name,\n        Metadata memory _metadata,\n        address _owner,\n        address[] memory _members\n    ) external returns (bytes32) {\n        // Generate a profile ID using a nonce and the msg.sender\n        bytes32 profileId = _generateProfileId(_nonce);\n\n        // Make sure the nonce is available\n        if (profilesById[profileId].anchor != address(0)) revert NONCE_NOT_AVAILABLE();\n\n        // Make sure the owner is not the zero address\n        if (_owner == address(0)) revert ZERO_ADDRESS();\n\n        // Create a new Profile instance, also generates the anchor address\n        Profile memory profile = Profile({\n            id: profileId,\n            nonce: _nonce,\n            name: _name,\n            metadata: _metadata,\n            owner: _owner,\n            anchor: _generateAnchor(profileId, _name)\n        });\n\n        profilesById[profileId] = profile;\n        anchorToProfileId[profile.anchor] = profileId;\n\n        // Assign roles for the profile members\n        uint256 memberLength = _members.length;\n        for (uint256 i; i < memberLength;) {\n            address member = _members[i];\n\n            // Will revert if any of the addresses are a zero address\n            if (member == address(0)) revert ZERO_ADDRESS();\n\n            // Grant the role to the member and emit the event for each member\n            _grantRole(profileId, member);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Emit the event that the profile was created\n        emit ProfileCreated(profileId, profile.nonce, profile.name, profile.metadata, profile.owner, profile.anchor);\n\n        // Return the profile ID\n        return profileId;\n    }\n\n    /// @notice Updates the name of the profile and generates new anchor."
    }
  ]
}