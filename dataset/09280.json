{
  "Title": "[M-01] `CNft.sol` - revert inside `safeTransferFrom` will break composability & standard behaviour",
  "Content": "_Submitted by hubble_\n\n[CNft.sol#L204](https://github.com/bunkerfinance/bunker-protocol/blob/752126094691e7457d08fc62a6a5006df59bd2fe/contracts/CNft.sol#L204)<br>\n\nThe function safeTransferFrom is a standard interface in ERC1155, and its expected to succeed if all the parametes are valid, and revert on error, which is not the case here so its a deviation.\n\nRefer to the EIP-1155 safeTransferFrom rules:\n\n> MUST revert if \\_to is the zero address.<br>\n> MUST revert if balance of holder for token \\_id is lower than the \\_value sent to the recipient.<br>\n> MUST revert on any other error.<br>\n\nThere is no loss of assets, but the assets or tokens and CNft contract can be unusable by other protocols, and likelihood & impact of this issue is high.\n\n### Impact\n\nIf other protocols want to integrate CNft, then in that case just for CNft Contract / tokens, they have to take exception and use safeBatchTransferFrom, instead of safeTransferFrom. If they dont take care of this exception, then their protocol functions will fail while using CNft, even if valid values are given.\n\n### Proof of Concept\n\nContract : CNft.sol<br>\nFunction : safeTransferFrom\n\n> Line 204   revert(\"CNFT: Use safeBatchTransferFrom instead\");\n\n### Recommended Mitigation Steps\n\nInstead of revert, call function safeBatchTransferFrom with 1 item in the array, e.g.,\n\n> safeBatchTransferFrom(from, to, \\[id], \\[amount], data)\n\n**[bunkerfinance-dev (bunker.finance) confirmed, but disagreed with High severity and commented](https://github.com/code-423n4/2022-05-bunker-findings/issues/93#issuecomment-1129622001):**\n > We can fix this, but we do not feel like this is high severity at all.\n\n**[gzeon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-bunker-findings/issues/93#issuecomment-1140430665):**\n > I think this is a Med Risk issue as it impacts the function of the protocol.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-bunkerfinance-contest",
  "Code": [
    {
      "filename": "contracts/CNft.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./CNftInterface080.sol\";\nimport \"./ComptrollerInterface080.sol\";\nimport \"./ERC1155Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC1155.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\ncontract CNft is CNftInterface, ERC1155Enumerable, IERC1155Receiver, IERC721Receiver, ReentrancyGuardUpgradeable, OwnableUpgradeable {\n    function initialize (\n        string memory _uri,\n        address _underlying,\n        bool _isPunk,\n        bool _is1155,\n        address _comptroller\n    ) public initializer {\n        require(_underlying != address(0), \"CNFT: Asset should not be address(0)\");\n        require(ComptrollerInterface(_comptroller).isComptroller(), \"_comptroller is not a Comptroller contract\");\n        __ERC1155Enumerable_init(_uri);\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        underlying = _underlying;\n        isPunk = _isPunk;\n        is1155 = _is1155;\n        comptroller = _comptroller;\n    }\n\n    /// @notice If underlying is not ERC1155, amounts must be all 1s.\n    function mint(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts\n    ) external nonReentrant returns (uint256) {\n        require(tokenIds.length == amounts.length, \"CNFT: id/amounts length mismatch\");\n\n        // Check if the Comptroller allows minting.\n        // We set mintAmount to 0 because it is not used.\n        uint mintAllowedResult = ComptrollerInterface(comptroller).mintAllowed(address(this), msg.sender, 0);\n        require(mintAllowedResult == 0, \"CNFT: Mint is not allowed\");\n\n        // Receive NFTs.\n        uint256 length = tokenIds.length;\n        uint256 totalAmount = 0;\n        for (uint256 i; i < length; ++i) {\n            if (!is1155) {\n                require(amounts[i] == 1, \"CNFT: Amounts must be all 1s for non-ERC1155s.\");\n            }\n            totalAmount += amounts[i];\n        }\n        totalBalance[msg.sender] += totalAmount;\n        if (is1155) {\n            IERC1155(underlying).safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, \"\");\n        } else {\n            if (isPunk) {\n                // Adapted from https://github.com/NFTX-project/nftx-protocol-v2/blob/master/contracts/solidity/NFTXVaultUpgradeable.sol#L501\n                for (uint256 i; i < length; ++i) {\n                    bytes memory punkIndexToAddress = abi.encodeWithSignature(\"punkIndexToAddress(uint256)\", tokenIds[i]);\n                    (bool checkSuccess, bytes memory result) = underlying.staticcall(punkIndexToAddress);\n                    (address nftOwner) = abi.decode(result, (address));\n                    require(checkSuccess && nftOwner == msg.sender, \"Not the NFT owner\");\n                    bytes memory data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenIds[i]);\n                    (bool buyPunkSuccess, ) = underlying.call(data);\n                    require(buyPunkSuccess, \"CNFT: Calling buyPunk was unsuccessful\");\n                }\n            } else {\n                for (uint256 i; i < length; ++i) {\n                    IERC721(underlying).safeTransferFrom(msg.sender, address(this), tokenIds[i], \"\");\n                }\n            }\n        }\n        _mintBatch(msg.sender, tokenIds, amounts, \"\");\n        emit Mint(msg.sender, tokenIds, amounts);\n\n        return length;\n    }\n\n    // Adapted from the `seize` function in CToken.\n    function seize(address liquidator, address borrower, uint256[] calldata seizeIds, uint256[] calldata seizeAmounts) external nonReentrant override {\n        require(seizeIds.length == seizeAmounts.length, \"CNFT: id/amounts length mismatch\");\n\n        // Check if the Comptroller allows seizing.\n        // We set seizeAmount to 0 because it is not used.\n        uint siezeAllowedResult = ComptrollerInterface(comptroller).seizeAllowed(address(this), msg.sender, liquidator, borrower, 0);\n        require(siezeAllowedResult == 0, \"CNFT: Seize is not allowed\");\n\n        // Fail if borrower == liquidator.\n        require(borrower != liquidator, \"CNFT: Liquidator cannot be borrower\");\n\n        // Transfer cNFT.\n        uint256 length = seizeIds.length;\n        uint256 totalAmount = 0;\n        for (uint256 i; i < length; ++i) {\n            if (!is1155) {\n                require(seizeAmounts[i] == 1, \"CNFT: Amounts must be all 1s for non-ERC1155s.\");\n            }\n            totalAmount += seizeAmounts[i];\n        }\n        totalBalance[liquidator] += totalAmount;\n        totalBalance[borrower] -= totalAmount;\n        // We call the internal function instad of the public one because in liquidation, we\n        // forcibly seize the borrower's cNFTs without approval.\n        _safeBatchTransferFrom(borrower, liquidator, seizeIds, seizeAmounts, \"\");\n    }\n\n    /// @notice If underlying is not ERC1155, amounts must be all 1s.\n    function redeem(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts /* ignored for ERC721 */\n    ) external nonReentrant {\n        require(tokenIds.length == amounts.length, \"CNFT: id/amounts length mismatch\");\n\n        uint256 length = tokenIds.length;\n        uint256 totalAmount = 0;\n\n        // Check for ownership.\n        for (uint256 i; i < length; ++i) {\n            if (!is1155) {\n                require(amounts[i] == 1, \"CNFT: Amounts must be all 1s for non-ERC1155s.\");\n            }\n            totalAmount += amounts[i];\n            require(balanceOf(msg.sender, tokenIds[i]) >= amounts[i], \"CNFT: Not enough NFTs to redeem\");\n        }\n\n        // Check if we can redeem.\n        uint redeemAllowedResult = ComptrollerInterface(comptroller).redeemAllowed(address(this), msg.sender, totalAmount);\n        require(redeemAllowedResult == 0, \"CNFT: Redeem is not allowed\");\n\n        totalBalance[msg.sender] -= totalAmount;\n\n        // Burn CNfts.\n        _burnBatch(msg.sender, tokenIds, amounts);\n\n        // Transfer underlying to `to`.\n        if (is1155) {\n            IERC1155(underlying).safeBatchTransferFrom(address(this), msg.sender, tokenIds, amounts, \"\");\n        } else {\n            if (isPunk) {\n                // Adapted from https://github.com/NFTX-project/nftx-protocol-v2/blob/master/contracts/solidity/NFTXVaultUpgradeable.sol#L483\n                for (uint256 i; i < length; ++i) {\n                    bytes memory data = abi.encodeWithSignature(\"transferPunk(address,uint256)\", msg.sender, tokenIds[i]);\n                    (bool transferPunkSuccess, ) = underlying.call(data);\n                    require(transferPunkSuccess, \"CNFT: Calling transferPunk was unsuccessful\");\n                }\n            } else {\n                for (uint256 i; i < length; ++i) {\n                    IERC721(underlying).safeTransferFrom(address(this), msg.sender, tokenIds[i], \"\");\n                }\n            }\n        }\n\n        emit Redeem(msg.sender, tokenIds, amounts);\n    }\n\n    /// @dev To avoid \"stack too deep\" error.\n    struct BatchTransferLocalVars {\n        uint256 length;\n        uint256 totalAmount;\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual nonReentrant override {\n        BatchTransferLocalVars memory vars;\n        vars.length = ids.length;\n        vars.totalAmount = 0;\n        for (uint256 i; i < vars.length; ++i) {\n            vars.totalAmount += amounts[i];\n        }\n\n        // Check if we can transfer.\n        uint transferAllowedResult = ComptrollerInterface(comptroller).transferAllowed(address(this), from, to, vars.totalAmount);\n        require(transferAllowedResult == 0, \"CNFT: Redeem is not allowed\");\n\n        // Transfer cNFT.\n        totalBalance[to] += vars.totalAmount;\n        totalBalance[from] -= vars.totalAmount;\n        super.safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n        ) public virtual override {\n            // Unused.\n            from;\n            to;\n            id;\n            amount;\n            data;\n\n            revert(\"CNFT: Use safeBatchTransferFrom instead\");\n    }\n\n    modifier validReceive(address operator) {\n        require(msg.sender == underlying, \"CNFT: This contract can only receive the underlying NFT\");\n        require(operator == address(this), \"CNFT: Only the CNFT contract can be the operator\");\n        _;\n    }\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) public virtual override validReceive(operator) returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) public virtual override validReceive(operator) returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) public virtual override validReceive(operator) returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155Upgradeable, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId ||\n            interfaceId == type(IERC721Receiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function executeCall(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly {\n            success := call(\n                txGas,\n                to,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n        }\n    }\n\n    /**\n     * @notice Allows the admin to call arbitrary contracts, as long as the underlying balance is unchanged.\n     * @notice This allows the admin to retrieve and distribute NFT airdrops that would otherwise be locked up in this contract.\n     * @param to Contract address to call\n     * @param value ETH value to send, if any\n     * @param data Encoded data to send\n     */\n    function call(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external payable nonReentrant onlyOwner returns (bool success) {\n        require(to != underlying, \"CNFT: Cannot make an arbitrary call to underlying NFT\");\n        success = executeCall(to, value, data, gasleft());\n        emit Call(to, value, data);\n    }\n}"
    }
  ]
}