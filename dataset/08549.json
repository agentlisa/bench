{
  "Title": "[L-11] Vault Cannot Support More Than 6 Module Functions",
  "Content": "\nhttps://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L128\n\nhttps://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L34\n\n### Vulnerability Details\n\nThe vault creation only supports up to six (6) hashed permissions within a vault.\n\nThe following shows that the number of hashed permission (or leaf nodes) is hardcoded to six (6).  The `new bytes32[](6);` code initialises the `hashes` array with 6 empty items within the `baseVault.generateMerkleTree` function.\n\nThus, if there are more than six (6) permissions, the `hashes` array will overflow and the transaction will revert.\n\n[https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L128](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L128)\n\n```solidity\n/// @notice Generates a merkle tree from the hashed permission lists of the given modules\n/// @param _modules List of module contracts\n/// @return hashes A combined list of leaf nodes\nfunction generateMerkleTree(address[] calldata _modules)\n    public\n    view\n    returns (bytes32[] memory hashes)\n{\n    uint256 counter;\n    hashes = new bytes32[](6);\n    unchecked {\n        for (uint256 i; i < _modules.length; ++i) {\n            bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n            for (uint256 j; j < leaves.length; ++j) {\n                hashes[counter++] = leaves[j];\n            }\n        }\n    }\n}\n```\n\nAssume that Alice calls the `baseVault.deployVault` with the following module settings:\n\n- Module A - 5 functions (or 5 leaf nodes)\n- Module B - 1 function (or 1 leaf nodes)\n- Module C - 3 functions (or 3 leaf nodes)\n\nThus, the actual call will be as follows:\n\n```\nbaseVault.deployVault(1000, [Module A, Module B, Module C], [], [], mintProof)\n```\n\nWhen Alice calls `baseVault.deployVault` with the above three (3) modules, the `hashes` array will overflow and the transaction will revert.\n\n [https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L34](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/protoforms/BaseVault.sol#L34)\n\n```solidity\n/// @notice Deploys a new Vault and mints initial supply of fractions\n/// @param _fractionSupply Number of NFT Fractions minted to control the vault\n/// @param _modules The list of modules to be installed on the vault\n/// @param _plugins Addresses of plugin contracts\n/// @param _selectors List of function selectors\n/// @param _mintProof List of proofs to execute a mint function\nfunction deployVault(\n    uint256 _fractionSupply,\n    address[] calldata _modules,\n    address[] calldata _plugins,\n    bytes4[] calldata _selectors,\n    bytes32[] calldata _mintProof\n) external returns (address vault) {\n    bytes32[] memory leafNodes = generateMerkleTree(_modules);\n    bytes32 merkleRoot = getRoot(leafNodes);\n    vault = IVaultRegistry(registry).create(\n        merkleRoot,\n        _plugins,\n        _selectors\n    );\n    emit ActiveModules(vault, _modules);\n\n    _mintFractions(vault, msg.sender, _fractionSupply, _mintProof);\n}\n```\n\n### Impact\n\nThe vault creation only supports up to six (6) hashed permission within a vault, thus limiting the functionality of the vault and restricting the expandability of the vault.\n\n### Recommended Mitigation Steps\n\nIt is recommended not to hardcode the array size (6 in this case) for the `hashes` array within the `baseVault.generateMerkleTree` function to provide more flexibility to the vault creator.\n\nConsidering calculating the total number of leaf nodes first before initialising the `hashes` array.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
  "Code": [
    {
      "filename": "src/modules/protoforms/BaseVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBaseVault} from \"../../interfaces/IBaseVault.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {IERC721} from \"../../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../interfaces/IERC1155.sol\";\nimport {IModule} from \"../../interfaces/IProtoform.sol\";\nimport {IVaultRegistry, Permission} from \"../../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../../utils/MerkleBase.sol\";\nimport {Minter} from \"../Minter.sol\";\nimport {Multicall} from \"../../utils/Multicall.sol\";\n\n/// @title BaseVault\n/// @author Fractional Art\n/// @notice Protoform contract for vault deployments with a fixed supply and buyout mechanism\ncontract BaseVault is IBaseVault, MerkleBase, Minter, Multicall {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n\n    /// @notice Initializes registry and supply contracts\n    /// @param _registry Address of the VaultRegistry contract\n    /// @param _supply Address of the Supply target contract\n    constructor(address _registry, address _supply) Minter(_supply) {\n        registry = _registry;\n    }\n\n    /// @notice Deploys a new Vault and mints initial supply of fractions\n    /// @param _fractionSupply Number of NFT Fractions minted to control the vault\n    /// @param _modules The list of modules to be installed on the vault\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @param _mintProof List of proofs to execute a mint function\n    function deployVault(\n        uint256 _fractionSupply,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        bytes32[] calldata _mintProof\n    ) external returns (address vault) {\n        bytes32[] memory leafNodes = generateMerkleTree(_modules);\n        bytes32 merkleRoot = getRoot(leafNodes);\n        vault = IVaultRegistry(registry).create(\n            merkleRoot,\n            _plugins,\n            _selectors\n        );\n        emit ActiveModules(vault, _modules);\n\n        _mintFractions(vault, msg.sender, _fractionSupply, _mintProof);\n    }\n\n    /// @notice Transfers ERC-20 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _amounts[] Transfer amounts\n    function batchDepositERC20(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-721 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] IDs of the tokens\n    function batchDepositERC721(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-1155 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] Ids of the token types\n    /// @param _amounts[] Transfer amounts\n    /// @param _datas[] Additional transaction data\n    function batchDepositERC1155(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes[] calldata _datas\n    ) external {\n        unchecked {\n            for (uint256 i = 0; i < _tokens.length; ++i) {\n                IERC1155(_tokens[i]).safeTransferFrom(\n                    _from,\n                    _to,\n                    _ids[i],\n                    _amounts[i],\n                    _datas[i]\n                );\n            }\n        }\n    }\n\n    /// @notice Generates a merkle tree from the hashed permission lists of the given modules\n    /// @param _modules List of module contracts\n    /// @return hashes A combined list of leaf nodes\n    function generateMerkleTree(address[] calldata _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 counter;\n        hashes = new bytes32[](6);\n        unchecked {\n            for (uint256 i; i < _modules.length; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                for (uint256 j; j < leaves.length; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/modules/protoforms/BaseVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBaseVault} from \"../../interfaces/IBaseVault.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {IERC721} from \"../../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../interfaces/IERC1155.sol\";\nimport {IModule} from \"../../interfaces/IProtoform.sol\";\nimport {IVaultRegistry, Permission} from \"../../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../../utils/MerkleBase.sol\";\nimport {Minter} from \"../Minter.sol\";\nimport {Multicall} from \"../../utils/Multicall.sol\";\n\n/// @title BaseVault\n/// @author Fractional Art\n/// @notice Protoform contract for vault deployments with a fixed supply and buyout mechanism\ncontract BaseVault is IBaseVault, MerkleBase, Minter, Multicall {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n\n    /// @notice Initializes registry and supply contracts\n    /// @param _registry Address of the VaultRegistry contract\n    /// @param _supply Address of the Supply target contract\n    constructor(address _registry, address _supply) Minter(_supply) {\n        registry = _registry;\n    }\n\n    /// @notice Deploys a new Vault and mints initial supply of fractions\n    /// @param _fractionSupply Number of NFT Fractions minted to control the vault\n    /// @param _modules The list of modules to be installed on the vault\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @param _mintProof List of proofs to execute a mint function\n    function deployVault(\n        uint256 _fractionSupply,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        bytes32[] calldata _mintProof\n    ) external returns (address vault) {\n        bytes32[] memory leafNodes = generateMerkleTree(_modules);\n        bytes32 merkleRoot = getRoot(leafNodes);\n        vault = IVaultRegistry(registry).create(\n            merkleRoot,\n            _plugins,\n            _selectors\n        );\n        emit ActiveModules(vault, _modules);\n\n        _mintFractions(vault, msg.sender, _fractionSupply, _mintProof);\n    }\n\n    /// @notice Transfers ERC-20 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _amounts[] Transfer amounts\n    function batchDepositERC20(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-721 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] IDs of the tokens\n    function batchDepositERC721(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-1155 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] Ids of the token types\n    /// @param _amounts[] Transfer amounts\n    /// @param _datas[] Additional transaction data\n    function batchDepositERC1155(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes[] calldata _datas\n    ) external {\n        unchecked {\n            for (uint256 i = 0; i < _tokens.length; ++i) {\n                IERC1155(_tokens[i]).safeTransferFrom(\n                    _from,\n                    _to,\n                    _ids[i],\n                    _amounts[i],\n                    _datas[i]\n                );\n            }\n        }\n    }\n\n    /// @notice Generates a merkle tree from the hashed permission lists of the given modules\n    /// @param _modules List of module contracts\n    /// @return hashes A combined list of leaf nodes\n    function generateMerkleTree(address[] calldata _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 counter;\n        hashes = new bytes32[](6);\n        unchecked {\n            for (uint256 i; i < _modules.length; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                for (uint256 j; j < leaves.length; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/modules/protoforms/BaseVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBaseVault} from \"../../interfaces/IBaseVault.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {IERC721} from \"../../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../interfaces/IERC1155.sol\";\nimport {IModule} from \"../../interfaces/IProtoform.sol\";\nimport {IVaultRegistry, Permission} from \"../../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../../utils/MerkleBase.sol\";\nimport {Minter} from \"../Minter.sol\";\nimport {Multicall} from \"../../utils/Multicall.sol\";\n\n/// @title BaseVault\n/// @author Fractional Art\n/// @notice Protoform contract for vault deployments with a fixed supply and buyout mechanism\ncontract BaseVault is IBaseVault, MerkleBase, Minter, Multicall {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n\n    /// @notice Initializes registry and supply contracts\n    /// @param _registry Address of the VaultRegistry contract\n    /// @param _supply Address of the Supply target contract\n    constructor(address _registry, address _supply) Minter(_supply) {\n        registry = _registry;\n    }\n\n    /// @notice Deploys a new Vault and mints initial supply of fractions\n    /// @param _fractionSupply Number of NFT Fractions minted to control the vault\n    /// @param _modules The list of modules to be installed on the vault\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @param _mintProof List of proofs to execute a mint function\n    function deployVault(\n        uint256 _fractionSupply,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        bytes32[] calldata _mintProof\n    ) external returns (address vault) {\n        bytes32[] memory leafNodes = generateMerkleTree(_modules);\n        bytes32 merkleRoot = getRoot(leafNodes);\n        vault = IVaultRegistry(registry).create(\n            merkleRoot,\n            _plugins,\n            _selectors\n        );\n        emit ActiveModules(vault, _modules);\n\n        _mintFractions(vault, msg.sender, _fractionSupply, _mintProof);\n    }\n\n    /// @notice Transfers ERC-20 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _amounts[] Transfer amounts\n    function batchDepositERC20(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-721 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] IDs of the tokens\n    function batchDepositERC721(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-1155 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] Ids of the token types\n    /// @param _amounts[] Transfer amounts\n    /// @param _datas[] Additional transaction data\n    function batchDepositERC1155(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes[] calldata _datas\n    ) external {\n        unchecked {\n            for (uint256 i = 0; i < _tokens.length; ++i) {\n                IERC1155(_tokens[i]).safeTransferFrom(\n                    _from,\n                    _to,\n                    _ids[i],\n                    _amounts[i],\n                    _datas[i]\n                );\n            }\n        }\n    }\n\n    /// @notice Generates a merkle tree from the hashed permission lists of the given modules\n    /// @param _modules List of module contracts\n    /// @return hashes A combined list of leaf nodes\n    function generateMerkleTree(address[] calldata _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 counter;\n        hashes = new bytes32[](6);\n        unchecked {\n            for (uint256 i; i < _modules.length; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                for (uint256 j; j < leaves.length; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/modules/protoforms/BaseVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBaseVault} from \"../../interfaces/IBaseVault.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {IERC721} from \"../../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../interfaces/IERC1155.sol\";\nimport {IModule} from \"../../interfaces/IProtoform.sol\";\nimport {IVaultRegistry, Permission} from \"../../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../../utils/MerkleBase.sol\";\nimport {Minter} from \"../Minter.sol\";\nimport {Multicall} from \"../../utils/Multicall.sol\";\n\n/// @title BaseVault\n/// @author Fractional Art\n/// @notice Protoform contract for vault deployments with a fixed supply and buyout mechanism\ncontract BaseVault is IBaseVault, MerkleBase, Minter, Multicall {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n\n    /// @notice Initializes registry and supply contracts\n    /// @param _registry Address of the VaultRegistry contract\n    /// @param _supply Address of the Supply target contract\n    constructor(address _registry, address _supply) Minter(_supply) {\n        registry = _registry;\n    }\n\n    /// @notice Deploys a new Vault and mints initial supply of fractions\n    /// @param _fractionSupply Number of NFT Fractions minted to control the vault\n    /// @param _modules The list of modules to be installed on the vault\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @param _mintProof List of proofs to execute a mint function\n    function deployVault(\n        uint256 _fractionSupply,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        bytes32[] calldata _mintProof\n    ) external returns (address vault) {\n        bytes32[] memory leafNodes = generateMerkleTree(_modules);\n        bytes32 merkleRoot = getRoot(leafNodes);\n        vault = IVaultRegistry(registry).create(\n            merkleRoot,\n            _plugins,\n            _selectors\n        );\n        emit ActiveModules(vault, _modules);\n\n        _mintFractions(vault, msg.sender, _fractionSupply, _mintProof);\n    }\n\n    /// @notice Transfers ERC-20 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _amounts[] Transfer amounts\n    function batchDepositERC20(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC20(_tokens[i]).transferFrom(_from, _to, _amounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-721 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] IDs of the tokens\n    function batchDepositERC721(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids\n    ) external {\n        for (uint256 i = 0; i < _tokens.length; ) {\n            IERC721(_tokens[i]).safeTransferFrom(_from, _to, _ids[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Transfers ERC-1155 tokens\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokens[] Addresses of token contracts\n    /// @param _ids[] Ids of the token types\n    /// @param _amounts[] Transfer amounts\n    /// @param _datas[] Additional transaction data\n    function batchDepositERC1155(\n        address _from,\n        address _to,\n        address[] calldata _tokens,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes[] calldata _datas\n    ) external {\n        unchecked {\n            for (uint256 i = 0; i < _tokens.length; ++i) {\n                IERC1155(_tokens[i]).safeTransferFrom(\n                    _from,\n                    _to,\n                    _ids[i],\n                    _amounts[i],\n                    _datas[i]\n                );\n            }\n        }\n    }\n\n    /// @notice Generates a merkle tree from the hashed permission lists of the given modules\n    /// @param _modules List of module contracts\n    /// @return hashes A combined list of leaf nodes\n    function generateMerkleTree(address[] calldata _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 counter;\n        hashes = new bytes32[](6);\n        unchecked {\n            for (uint256 i; i < _modules.length; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                for (uint256 j; j < leaves.length; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n}"
    }
  ]
}