{
  "Title": "M-10: Quote that have already been liquidated can be liquidated again in some cases",
  "Content": "# Issue M-10: Quote that have already been liquidated can be liquidated again in some cases \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/206 \n\n## Found by \nnobody2018\n## Summary\n\n`LiquidationFacetImpl.liquidatePartyB` is used to liquidate PartyB, which directly adds `partyBAllocatedBalances[partyB][partyA]` to `allocatedBalances[partyA]` [[here](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L294-L296)](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L294-L296). In this way, the liquidation against PartyB has been completed. The main purpose of `LiquidationFacetImpl.liquidatePositionsPartyB` is to remove the [[OpenPositions](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L369)](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L369) of both parties. **If this function is not called, the OpenPosition of both parties will always exist**. The reasons for not calling it maybe:\n\n1.  [[partyBPositionLiquidatorsShare](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L373)](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L373) is 0, there is no incentive for liquidator.\n2.  Liquidator (bot) is not working due to downtime/network issues.\n3.  Intentionally not called.\n4. tx is deferred processing (pending in mempool), resulting in [[here](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L318-L322)](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L318-L322) revert.\n\nAfterwards, if PartyA is liquidated due to quote with other PartyB, `LiquidationFacetImpl.liquidatePositionsPartyA` will process the quotes with the original PartyB. These quotes should have been removed.\n\n## Vulnerability Detail\n\n**For simplicity, the numbers mentioned below will not be exact values, it is just to describe the issue**. Suppose the following scenario:\n\nThere are 3 users: PartyA(A1), PartyB(B1), PartyB(B2). The symbol is ETH/USDT.\n\nallocatedBalances[A1]=1000\n\npartyBAllocatedBalances[B1][A1]=1000\n\npartyBAllocatedBalances[B2][A1]=1000\n\n1.  A1 created a short quote1 via `PartyAFacet.sendQuote`. pendingLockedBalances[A1]=500. The current symbol price is 100.\n2.  B1 opens quote1 via `PartyBFacet.lockAndOpenQuote`. lockedBalances[A1]=500, partyBLockedBalances[B1][A1]=500. [[LibQuote.addToOpenPositions](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L253)](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L253) will add quote1 to the OpenPositions array of both parties. The status of quote1 is `QuoteStatus.OPENED`.\n3.  As time goes by, the price dumps to 50. B1 can be liquidated.\n5.  The liquidator initiates liquidation against B1 via `LiquidationFacet.liquidatePartyB`. allocatedBalances[A1]=1000+partyBAllocatedBalances[B1][A1]=2000, partyBAllocatedBalances[B1][A1]=0.\n6.  `liquidatePositionsPartyB` is not called, so the OpenPositions array of both parties still contains quote1, and its status is still `QuoteStatus.OPENED`.\n7.  A1 thinks that the price will continue to dump, and creates a short quote2. pendingLockedBalances[A1]=500. The current price is 50. Because allocatedBalances[A1]=2000 at this time, when the price pump to 200, A1 will be liquidated.\n8.  B2 opens quote2. lockedBalances[A1]=500, partyBLockedBalances[B2][A1]=500. The OpenPositions array of A1 contains quote1 and quote2. The OpenPositions array of B2 only has quote2.\n9.  As time goes by, the price pumps to 200. A1 can be liquidated.\n10.  The liquidator initiates liquidation of A1. This process requires 3 calls: `LiquidationFacet.liquidatePartyA`/`setSymbolsPrice`/`liquidatePositionsPartyA`. The [[priceSig](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacet.sol#L28)](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacet.sol#L28) of `setSymbolsPrice` is calculated off-chain. From the flow of the [[uPnlPartyA](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/muon/crypto_v3.js#L238-L267)](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/muon/crypto_v3.js#L238-L267) function in crypto_v3.js, all quotes in the OpenPositions array of A1 will be calculated into upnl. Because quote1 was opened when the price was 100, and the current price is 200, so B1 is profitable. This means that B1 that has been liquidated can also be allocated part of allocatedBalances[A1]. This is obviously unreasonable. This is a loss of part of the funds for B2.\n\n## Impact\n\nQuotes that have already been liquidated can be liquidated again in some cases.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L294-L301\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/muon/crypto_v3.js#L238-L267\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L52-L88\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L152-L197\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe logic of `liquidatePartyB` and `liquidatePositionsPartyB` should be merged. But this maybe trigger OOG because the OpenPosition array is large.\n\n\n\n\n## Discussion\n\n**securitygrid**\n\nEscalate for 10 usdc\nThis issue is not dup of #113. please review it.\n\n**sherlock-admin2**\n\n > Escalate for 10 usdc\n> This issue is not dup of #113. please review it.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**panprog**\n\nEscalate\n\nThis issue is invalid (will underflow), because it assumes that `liquidatePositionsPartyA` can be called after `liquidatePartyB` but before `liquidatePositionsPartyB` removes all quotes, but it's impossible, because:\n\n1. `liquidatePartyB` zeroes out partyB locked balances:\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L300\n\n2. `liquidatePositionsPartyA` will underflow when trying to reduce partyB locked balances (because locked balances are 0):\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L198\n\nThis is probably duplicate of #142 which is also invalid.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This issue is invalid (will underflow), because it assumes that `liquidatePositionsPartyA` can be called after `liquidatePartyB` but before `liquidatePositionsPartyB` removes all quotes, but it's impossible, because:\n> \n> 1. `liquidatePartyB` zeroes out partyB locked balances:\n> https://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L300\n> \n> 2. `liquidatePositionsPartyA` will underflow when trying to reduce partyB locked balances (because locked balances are 0):\n> https://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol#L198\n> \n> This is probably duplicate of #142 which is also invalid.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**securitygrid**\n\nI agree that this issue is invalid due to revert. What I'm trying to say is that another problem arises here. \nall quotes in the OpenPositions array of A1 will be calculated into upnl(from offchain). This is wrong, the correct upnl should exclude quote1.\n\n**hrishibhat**\n\n@securitygrid confirming that this is not a valid issue?\n\n**securitygrid**\n\nIf the scenario in the report discusses a problem with the calculation of `upnl` in step 9, it should be a valid issue. So, I suggest that sponsors take a look at this report.\n\n**panprog**\n\n> If the scenario in the report discusses a problem with the calculation of `upnl` in step 9, it should be a valid issue.\n\nI think that this report shows a valid problem (quotes still open after liquidation and some actions allowed), however it didn't demonstrate the valid scenario to show the impact: it demonstrates liquidation after liquidation which isn't valid as it will revert. Upnl in muon app still calculating the profit from these quotes is out of scope of this audit.\n\nI think this should be low. \n\n**securitygrid**\n\nLooking at this report again, Iâ€˜d like to argue that this issue should be a valid M.\nThe `liquidatePositionsPartyA` function can liquidate the specified quote due to the second parameter.\n1. It is no problem to liquidate quote2 via `liquidatePositionsPartyA`.\n2. Liquidating quote1 via `liquidatePositionsPartyA` will revert. But it doesn't matter anymore. Because this funds should be given to B2. B2 caused the loss. This is impact.\n3. The title of this report mentions \"liquidated again\". Although revert will occur, it has been counted into `unpl`. This can also be regarded as \"liquidated again\".\n\n**panprog**\n\n@securitygrid I agree that the impact is medium (although very very unlikely: the scenario presented assumes no partyB liquidation finalization for a very long time, enough for the price to grow significantly. And then again, in order for partyB2 to not receive its necessary funds from partyA liquidation - partyA should be liquidated as LATE or OVERDUE, which is unlikely by itself). However, the reason it happens is the muon app which is out of scope\n\n> 9\\. From the flow of the [[uPnlPartyA](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/muon/crypto_v3.js#L238-L267)](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/muon/crypto_v3.js#L238-L267) function in crypto_v3.js, all quotes in the OpenPositions array of A1 will be calculated into upnl.\n\nThat's exactly why it happens: quote1 shouldn't be included in upnl calculation (quotes with liquidated partyB must be excluded, because they're already accounted for right after liquidatePartyB). But this is the bug on the muon app side, not on the smart contract.\n\n**securitygrid**\n\n#160 also use meon app bug: `muon app doesn't check for liquidation of active position's parties, and smart contract code also ignores this`.  \nif this issue is not valid due to muon app, #160 should be not valid.\n\nI've also noticed that discussions in other issues mention code from crypto_v3.js. If its code doesn't need to be considered, then those discussions don't make sense.\n\n**panprog**\n\n#160 is about `deallocate` and some other functions (including `liquidatePartyA`) being allowed for partyA while some partyB is not finished liquidating. It's not about muon app bug specifically, it just uses muon app bug to demonstrate the impact, and as I said in comments, even if muon app bug is fixed or not used, there are the other fully in-scope ways (**multiple** ways) to exploit that bug.\n\nThis report talks about `liquidatePartyB` and `liquidatePositionsPartyB` being not atomic, which I don't think is a bug as this separation is to avoid out of gas when liquidating many positions. The scenario presented in this report reverts, and what you say about partyB2 not getting paid happens only because of muon app bug. So muon app is the main reason of this bug. Besides, the scenario is so unlikely that I'm not fully sure it can be medium impact.\n\nIt does use the `liquidatePartyA` mentioned in #160, so indirectly it does imply usage of partyA functionality while partyB is liquidated, so I'm not really sure how to treat this. Maybe it's a duplicate of #160 (overlaps some of it description). But #160 is definitely valid and in-scope as the reason is not muon app.\n\n**MoonKnightDev**\n\nFixed code PR link: \nhttps://github.com/SYMM-IO/symmio-core/pull/22\n\n**hrishibhat**\n\nSponsor comment:\n> the auditor has accurately pinpointed the problem. We were aware of a similar issue and have since addressed and resolved it.\nAdded the proper tags\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nAfter considering the comments and based on Sponsor comments, considering this issue a valid medium\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [securitygrid](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/206/#issuecomment-1651624031): accepted\n- [panprog](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/206/#issuecomment-1654217488): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary LiquidationFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function liquidatePartyA(address partyA, SingleUpnlSig memory upnlSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n\n        LibMuon.verifyPartyAUpnl(upnlSig, partyA);\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyA\n        );\n        require(availableBalance < 0, \"LiquidationFacet: PartyA is solvent\");\n        maLayout.liquidationStatus[partyA] = true;\n        maLayout.liquidationTimestamp[partyA] = upnlSig.timestamp;\n        AccountStorage.layout().liquidators[partyA].push(msg.sender);\n    }\n\n    function setSymbolsPrice(address partyA, PriceSig memory priceSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        LibMuon.verifyPrices(priceSig, partyA);\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        require(\n            priceSig.timestamp <=\n                maLayout.liquidationTimestamp[partyA] + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired signature\"\n        );\n        for (uint256 index = 0; index < priceSig.symbolIds.length; index++) {\n            accountLayout.symbolsPrices[partyA][priceSig.symbolIds[index]] = Price(\n                priceSig.prices[index],\n                maLayout.liquidationTimestamp[partyA]\n            );\n        }\n\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            priceSig.upnl,\n            partyA\n        );\n        if (accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NONE) {\n            accountLayout.liquidationDetails[partyA] = LiquidationDetail({\n                liquidationType: LiquidationType.NONE,\n                upnl: priceSig.upnl,\n                totalUnrealizedLoss: priceSig.totalUnrealizedLoss,\n                deficit: 0,\n                liquidationFee: 0\n            });\n            if (availableBalance >= 0) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (uint256(-availableBalance) < accountLayout.lockedBalances[partyA].lf) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf -\n                    uint256(-availableBalance);\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (\n                uint256(-availableBalance) <=\n                accountLayout.lockedBalances[partyA].lf + accountLayout.lockedBalances[partyA].cva\n            ) {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.LATE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            } else {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf -\n                    accountLayout.lockedBalances[partyA].cva;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.OVERDUE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            }\n            AccountStorage.layout().liquidators[partyA].push(msg.sender);\n        } else {\n            require(\n                accountLayout.liquidationDetails[partyA].upnl == priceSig.upnl &&\n                    accountLayout.liquidationDetails[partyA].totalUnrealizedLoss ==\n                    priceSig.totalUnrealizedLoss,\n                \"LiquidationFacet: Invalid upnl sig\"\n            );\n        }\n    }\n\n    function liquidatePendingPositionsPartyA(address partyA) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        require(\n            MAStorage.layout().liquidationStatus[partyA],\n            \"LiquidationFacet: PartyA is solvent\"\n        );\n        for (uint256 index = 0; index < quoteLayout.partyAPendingQuotes[partyA].length; index++) {\n            Quote storage quote = quoteLayout.quotes[\n                quoteLayout.partyAPendingQuotes[partyA][index]\n            ];\n            if (\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING) &&\n                quoteLayout.partyBPendingQuotes[quote.partyB][partyA].length > 0\n            ) {\n                delete quoteLayout.partyBPendingQuotes[quote.partyB][partyA];\n                AccountStorage\n                .layout()\n                .partyBPendingLockedBalances[quote.partyB][partyA].makeZero();\n            }\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n        }\n        AccountStorage.layout().pendingLockedBalances[partyA].makeZero();\n        delete quoteLayout.partyAPendingQuotes[partyA];\n    }\n\n    function liquidatePositionsPartyA(\n        address partyA,\n        uint256[] memory quoteIds\n    ) internal returns (bool) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        for (uint256 index = 0; index < quoteIds.length; index++) {\n            Quote storage quote = quoteLayout.quotes[quoteIds[index]];\n            require(\n                quote.quoteStatus == QuoteStatus.OPENED ||\n                    quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n                \"LiquidationFacet: Invalid state\"\n            );\n            require(quote.partyA == partyA, \"LiquidationFacet: Invalid party\");\n            require(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].timestamp ==\n                    maLayout.liquidationTimestamp[partyA],\n                \"LiquidationFacet: Price should be set\"\n            );\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n\n            (bool hasMadeProfit, uint256 amount) = LibQuote.getValueOfQuoteForPartyA(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].price,\n                LibQuote.quoteOpenAmount(quote),\n                quote\n            );\n            if (hasMadeProfit) {\n                accountLayout.totalUnplForLiquidation[partyA] += int256(amount);\n            } else {\n                accountLayout.totalUnplForLiquidation[partyA] -= int256(amount);\n            }\n\n            if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NORMAL\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += quote\n                    .lockedValues\n                    .cva;\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.LATE\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                    quote.lockedValues.cva -\n                    ((quote.lockedValues.cva * accountLayout.liquidationDetails[partyA].deficit) /\n                        accountLayout.lockedBalances[partyA].cva);\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.OVERDUE\n            ) {\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                        amount -\n                        ((amount * accountLayout.liquidationDetails[partyA].deficit) /\n                            uint256(-accountLayout.liquidationDetails[partyA].totalUnrealizedLoss));\n                }\n            }\n            accountLayout.partyBLockedBalances[quote.partyB][partyA].subQuote(quote);\n            quote.avgClosedPrice =\n                (quote.avgClosedPrice *\n                    quote.closedAmount +\n                    LibQuote.quoteOpenAmount(quote) *\n                    accountLayout.symbolsPrices[partyA][quote.symbolId].price) /\n                (quote.closedAmount + LibQuote.quoteOpenAmount(quote));\n            quote.closedAmount = quote.quantity;\n\n            LibQuote.removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][partyA] -= 1;\n        }\n        if (quoteLayout.partyAPositionsCount[partyA] == 0) {\n            require(\n                quoteLayout.partyAPendingQuotes[partyA].length == 0,\n                \"LiquidationFacet: Pending quotes should be liquidated first\"\n            );\n            accountLayout.allocatedBalances[partyA] = 0;\n            accountLayout.lockedBalances[partyA].makeZero();\n\n            uint256 lf = accountLayout.liquidationDetails[partyA].liquidationFee;\n            if (lf > 0) {\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][0]] += lf / 2;\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][1]] += lf / 2;\n            }\n            delete accountLayout.liquidators[partyA];\n            maLayout.liquidationStatus[partyA] = false;\n            maLayout.liquidationTimestamp[partyA] = 0;\n            accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NONE;\n            if (\n                accountLayout.totalUnplForLiquidation[partyA] !=\n                accountLayout.liquidationDetails[partyA].upnl\n            ) {\n                accountLayout.totalUnplForLiquidation[partyA] = 0;\n                return false;\n            }\n            accountLayout.totalUnplForLiquidation[partyA] = 0;\n        }\n        return true;\n    }\n\n    function liquidatePartyB(\n        address partyB,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyPartyBUpnl(upnlSig, partyB, partyA);\n        int256 availableBalance = LibAccount.partyBAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyB,\n            partyA\n        );\n\n        require(availableBalance < 0, \"LiquidationFacet: partyB is solvent\");\n        uint256 liquidatorShare;\n        uint256 remainingLf;\n        if (uint256(-availableBalance) < accountLayout.partyBLockedBalances[partyB][partyA].lf) {\n            remainingLf =\n                accountLayout.partyBLockedBalances[partyB][partyA].lf -\n                uint256(-availableBalance);\n            liquidatorShare = (remainingLf * maLayout.liquidatorShare) / 1e18;\n\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] =\n                (remainingLf - liquidatorShare) /\n                quoteLayout.partyBPositionsCount[partyB][partyA];\n        } else {\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] = 0;\n        }\n\n        maLayout.partyBLiquidationStatus[partyB][partyA] = true;\n        maLayout.partyBLiquidationTimestamp[partyB][partyA] = upnlSig.timestamp;\n\n        uint256[] storage pendingQuotes = quoteLayout.partyAPendingQuotes[partyA];\n\n        for (uint256 index = 0; index < pendingQuotes.length; ) {\n            Quote storage quote = quoteLayout.quotes[pendingQuotes[index]];\n            if (\n                quote.partyB == partyB &&\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING)\n            ) {\n                accountLayout.pendingLockedBalances[partyA].subQuote(quote);\n\n                pendingQuotes[index] = pendingQuotes[pendingQuotes.length - 1];\n                pendingQuotes.pop();\n                quote.quoteStatus = QuoteStatus.LIQUIDATED;\n                quote.modifyTimestamp = block.timestamp;\n            } else {\n                index++;\n            }\n        }\n        accountLayout.allocatedBalances[partyA] +=\n            accountLayout.partyBAllocatedBalances[partyB][partyA] -\n            remainingLf;\n\n        delete quoteLayout.partyBPendingQuotes[partyB][partyA];\n        accountLayout.partyBAllocatedBalances[partyB][partyA] = 0;\n        accountLayout.partyBLockedBalances[partyB][partyA].makeZero();\n        accountLayout.partyBPendingLockedBalances[partyB][partyA].makeZero();\n\n        if (liquidatorShare > 0) {\n            accountLayout.allocatedBalances[msg.sender] += liquidatorShare;\n        }\n    }\n\n    function liquidatePositionsPartyB(\n        address partyB,\n        address partyA,\n        QuotePriceSig memory priceSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyQuotePrices(priceSig);\n        require(\n            priceSig.timestamp <=\n                maLayout.partyBLiquidationTimestamp[partyB][partyA] + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired signature\"\n        );\n        require(\n            maLayout.partyBLiquidationStatus[partyB][partyA],\n            \"LiquidationFacet: PartyB is solvent\"\n        );\n        require(\n            block.timestamp <= priceSig.timestamp + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired price sig\"\n        );\n        for (uint256 index = 0; index < priceSig.quoteIds.length; index++) {\n            Quote storage quote = quoteLayout.quotes[priceSig.quoteIds[index]];\n            require(\n                quote.quoteStatus == QuoteStatus.OPENED ||\n                    quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n                \"LiquidationFacet: Invalid state\"\n            );\n            require(\n                quote.partyA == partyA && quote.partyB == partyB,\n                \"LiquidationFacet: Invalid party\"\n            );\n\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n\n            // accountLayout.allocatedBalances[partyA] += quote.lockedValues.cva;\n            accountLayout.lockedBalances[partyA].subQuote(quote);\n\n            // (bool hasMadeProfit, uint256 amount) = LibQuote.getValueOfQuoteForPartyA(\n            //     priceSig.prices[index],\n            //     LibQuote.quoteOpenAmount(quote),\n            //     quote\n            // );\n\n            // if (hasMadeProfit) {\n            //     accountLayout.allocatedBalances[partyA] += amount;\n            // } else {\n            //     accountLayout.allocatedBalances[partyA] -= amount;\n            // }\n            quote.avgClosedPrice =\n                (quote.avgClosedPrice *\n                    quote.closedAmount +\n                    LibQuote.quoteOpenAmount(quote) *\n                    priceSig.prices[index]) /\n                (quote.closedAmount + LibQuote.quoteOpenAmount(quote));\n            quote.closedAmount = quote.quantity;\n\n            LibQuote.removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[partyA] -= 1;\n            quoteLayout.partyBPositionsCount[partyB][partyA] -= 1;\n        }\n        if (maLayout.partyBPositionLiquidatorsShare[partyB][partyA] > 0) {\n            accountLayout.allocatedBalances[msg.sender] +=\n                maLayout.partyBPositionLiquidatorsShare[partyB][partyA] *\n                priceSig.quoteIds.length;\n        }\n\n        if (quoteLayout.partyBPositionsCount[partyB][partyA] == 0) {\n            maLayout.partyBLiquidationStatus[partyB][partyA] = false;\n            maLayout.partyBLiquidationTimestamp[partyB][partyA] = 0;\n        }\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/liquidation/LiquidationFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary LiquidationFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function liquidatePartyA(address partyA, SingleUpnlSig memory upnlSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n\n        LibMuon.verifyPartyAUpnl(upnlSig, partyA);\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyA\n        );\n        require(availableBalance < 0, \"LiquidationFacet: PartyA is solvent\");\n        maLayout.liquidationStatus[partyA] = true;\n        maLayout.liquidationTimestamp[partyA] = upnlSig.timestamp;\n        AccountStorage.layout().liquidators[partyA].push(msg.sender);\n    }\n\n    function setSymbolsPrice(address partyA, PriceSig memory priceSig) internal {\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        LibMuon.verifyPrices(priceSig, partyA);\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        require(\n            priceSig.timestamp <=\n                maLayout.liquidationTimestamp[partyA] + maLayout.liquidationTimeout,\n            \"LiquidationFacet: Expired signature\"\n        );\n        for (uint256 index = 0; index < priceSig.symbolIds.length; index++) {\n            accountLayout.symbolsPrices[partyA][priceSig.symbolIds[index]] = Price(\n                priceSig.prices[index],\n                maLayout.liquidationTimestamp[partyA]\n            );\n        }\n\n        int256 availableBalance = LibAccount.partyAAvailableBalanceForLiquidation(\n            priceSig.upnl,\n            partyA\n        );\n        if (accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NONE) {\n            accountLayout.liquidationDetails[partyA] = LiquidationDetail({\n                liquidationType: LiquidationType.NONE,\n                upnl: priceSig.upnl,\n                totalUnrealizedLoss: priceSig.totalUnrealizedLoss,\n                deficit: 0,\n                liquidationFee: 0\n            });\n            if (availableBalance >= 0) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (uint256(-availableBalance) < accountLayout.lockedBalances[partyA].lf) {\n                uint256 remainingLf = accountLayout.lockedBalances[partyA].lf -\n                    uint256(-availableBalance);\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NORMAL;\n                accountLayout.liquidationDetails[partyA].liquidationFee = remainingLf;\n            } else if (\n                uint256(-availableBalance) <=\n                accountLayout.lockedBalances[partyA].lf + accountLayout.lockedBalances[partyA].cva\n            ) {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.LATE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            } else {\n                uint256 deficit = uint256(-availableBalance) -\n                    accountLayout.lockedBalances[partyA].lf -\n                    accountLayout.lockedBalances[partyA].cva;\n                accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.OVERDUE;\n                accountLayout.liquidationDetails[partyA].deficit = deficit;\n            }\n            AccountStorage.layout().liquidators[partyA].push(msg.sender);\n        } else {\n            require(\n                accountLayout.liquidationDetails[partyA].upnl == priceSig.upnl &&\n                    accountLayout.liquidationDetails[partyA].totalUnrealizedLoss ==\n                    priceSig.totalUnrealizedLoss,\n                \"LiquidationFacet: Invalid upnl sig\"\n            );\n        }\n    }\n\n    function liquidatePendingPositionsPartyA(address partyA) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        require(\n            MAStorage.layout().liquidationStatus[partyA],\n            \"LiquidationFacet: PartyA is solvent\"\n        );\n        for (uint256 index = 0; index < quoteLayout.partyAPendingQuotes[partyA].length; index++) {\n            Quote storage quote = quoteLayout.quotes[\n                quoteLayout.partyAPendingQuotes[partyA][index]\n            ];\n            if (\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING) &&\n                quoteLayout.partyBPendingQuotes[quote.partyB][partyA].length > 0\n            ) {\n                delete quoteLayout.partyBPendingQuotes[quote.partyB][partyA];\n                AccountStorage\n                .layout()\n                .partyBPendingLockedBalances[quote.partyB][partyA].makeZero();\n            }\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n        }\n        AccountStorage.layout().pendingLockedBalances[partyA].makeZero();\n        delete quoteLayout.partyAPendingQuotes[partyA];\n    }\n\n    function liquidatePositionsPartyA(\n        address partyA,\n        uint256[] memory quoteIds\n    ) internal returns (bool) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        require(maLayout.liquidationStatus[partyA], \"LiquidationFacet: PartyA is solvent\");\n        for (uint256 index = 0; index < quoteIds.length; index++) {\n            Quote storage quote = quoteLayout.quotes[quoteIds[index]];\n            require(\n                quote.quoteStatus == QuoteStatus.OPENED ||\n                    quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n                \"LiquidationFacet: Invalid state\"\n            );\n            require(quote.partyA == partyA, \"LiquidationFacet: Invalid party\");\n            require(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].timestamp ==\n                    maLayout.liquidationTimestamp[partyA],\n                \"LiquidationFacet: Price should be set\"\n            );\n            quote.quoteStatus = QuoteStatus.LIQUIDATED;\n            quote.modifyTimestamp = block.timestamp;\n\n            (bool hasMadeProfit, uint256 amount) = LibQuote.getValueOfQuoteForPartyA(\n                accountLayout.symbolsPrices[partyA][quote.symbolId].price,\n                LibQuote.quoteOpenAmount(quote),\n                quote\n            );\n            if (hasMadeProfit) {\n                accountLayout.totalUnplForLiquidation[partyA] += int256(amount);\n            } else {\n                accountLayout.totalUnplForLiquidation[partyA] -= int256(amount);\n            }\n\n            if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.NORMAL\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += quote\n                    .lockedValues\n                    .cva;\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.LATE\n            ) {\n                accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                    quote.lockedValues.cva -\n                    ((quote.lockedValues.cva * accountLayout.liquidationDetails[partyA].deficit) /\n                        accountLayout.lockedBalances[partyA].cva);\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] += amount;\n                }\n            } else if (\n                accountLayout.liquidationDetails[partyA].liquidationType == LiquidationType.OVERDUE\n            ) {\n                if (hasMadeProfit) {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] -= amount;\n                } else {\n                    accountLayout.partyBAllocatedBalances[quote.partyB][partyA] +=\n                        amount -\n                        ((amount * accountLayout.liquidationDetails[partyA].deficit) /\n                            uint256(-accountLayout.liquidationDetails[partyA].totalUnrealizedLoss));\n                }\n            }\n            accountLayout.partyBLockedBalances[quote.partyB][partyA].subQuote(quote);\n            quote.avgClosedPrice =\n                (quote.avgClosedPrice *\n                    quote.closedAmount +\n                    LibQuote.quoteOpenAmount(quote) *\n                    accountLayout.symbolsPrices[partyA][quote.symbolId].price) /\n                (quote.closedAmount + LibQuote.quoteOpenAmount(quote));\n            quote.closedAmount = quote.quantity;\n\n            LibQuote.removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][partyA] -= 1;\n        }\n        if (quoteLayout.partyAPositionsCount[partyA] == 0) {\n            require(\n                quoteLayout.partyAPendingQuotes[partyA].length == 0,\n                \"LiquidationFacet: Pending quotes should be liquidated first\"\n            );\n            accountLayout.allocatedBalances[partyA] = 0;\n            accountLayout.lockedBalances[partyA].makeZero();\n\n            uint256 lf = accountLayout.liquidationDetails[partyA].liquidationFee;\n            if (lf > 0) {\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][0]] += lf / 2;\n                accountLayout.allocatedBalances[accountLayout.liquidators[partyA][1]] += lf / 2;\n            }\n            delete accountLayout.liquidators[partyA];\n            maLayout.liquidationStatus[partyA] = false;\n            maLayout.liquidationTimestamp[partyA] = 0;\n            accountLayout.liquidationDetails[partyA].liquidationType = LiquidationType.NONE;\n            if (\n                accountLayout.totalUnplForLiquidation[partyA] !=\n                accountLayout.liquidationDetails[partyA].upnl\n            ) {\n                accountLayout.totalUnplForLiquidation[partyA] = 0;\n                return false;\n            }\n            accountLayout.totalUnplForLiquidation[partyA] = 0;\n        }\n        return true;\n    }\n\n    function liquidatePartyB(\n        address partyB,\n        address partyA,\n        SingleUpnlSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyPartyBUpnl(upnlSig, partyB, partyA);\n        int256 availableBalance = LibAccount.partyBAvailableBalanceForLiquidation(\n            upnlSig.upnl,\n            partyB,\n            partyA\n        );\n\n        require(availableBalance < 0, \"LiquidationFacet: partyB is solvent\");\n        uint256 liquidatorShare;\n        uint256 remainingLf;\n        if (uint256(-availableBalance) < accountLayout.partyBLockedBalances[partyB][partyA].lf) {\n            remainingLf =\n                accountLayout.partyBLockedBalances[partyB][partyA].lf -\n                uint256(-availableBalance);\n            liquidatorShare = (remainingLf * maLayout.liquidatorShare) / 1e18;\n\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] =\n                (remainingLf - liquidatorShare) /\n                quoteLayout.partyBPositionsCount[partyB][partyA];\n        } else {\n            maLayout.partyBPositionLiquidatorsShare[partyB][partyA] = 0;\n        }\n\n        maLayout.partyBLiquidationStatus[partyB][partyA] = true;\n        maLayout.partyBLiquidationTimestamp[partyB][partyA] = upnlSig.timestamp;\n\n        uint256[] storage pendingQuotes = quoteLayout.partyAPendingQuotes[partyA];\n\n        for (uint256 index = 0; index < pendingQuotes.length; ) {\n            Quote storage quote = quoteLayout.quotes[pendingQuotes[index]];\n            if (\n                quote.partyB == partyB &&\n                (quote.quoteStatus == QuoteStatus.LOCKED ||\n                    quote.quoteStatus == QuoteStatus.CANCEL_PENDING)\n            ) {\n                accountLayout.pendingLockedBalances[partyA].subQuote(quote);\n\n                pendingQuotes[index] = pendingQuotes[pendingQuotes.length - 1];\n                pendingQuotes.pop();\n                quote.quoteStatus = QuoteStatus.LIQUIDATED;\n                quote.modifyTimestamp = block.timestamp;\n            } else {\n                index++;\n            }\n        }\n        accountLayout.allocatedBalances[partyA] +=\n            accountLayout.partyBAllocatedBalances[partyB][partyA] -\n            remainingLf;\n\n        delete quoteLayout.partyBPendingQuotes[partyB][partyA];\n        accountLayout.partyBAllocatedBalances[partyB][partyA] = 0;\n        accountLayout.partyBLockedBalances[partyB][partyA].makeZero();\n        accountLayout.partyBPendingLockedBalances[partyB][partyA].makeZero();\n\n        if (liquidatorShare > 0) {\n            accountLayout.allocatedBalances[msg.sender] += liquidatorShare;\n        }\n    }\n\n    function liquidatePositionsPartyB(\n        address partyB,\n        address partyA,\n        QuotePriceSig memory priceSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n\n        LibMuon.verifyQuotePrices(priceSig);\n        require(\n            priceSig.timestamp <=\n                maLayout.partyBLiquidationTimestamp[partyB][partyA] + maLayout.liquidationTimeout,"
    }
  ]
}