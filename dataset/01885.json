{
  "Title": "H-7: Not using slippage parameter or deadline while swapping on UniswapV3",
  "Content": "# Issue H-7: Not using slippage parameter or deadline while swapping on UniswapV3 \n\nSource: https://github.com/sherlock-audit/2023-05-USSD-judging/issues/673 \n\n## Found by \n0xPkhatri, 0xRan4212, 0xRobocop, 0xSmartContract, 0xStalin, 0xeix, 0xpinky, 0xyPhilic, Angry\\_Mustache\\_Man, Auditwolf, Bahurum, Bauchibred, Bauer, BlockChomper, Brenzee, BugBusters, BugHunter101, CodeFoxInc, Delvir0, Dug, Fanz, HonorLt, J4de, JohnnyTime, Juntao, Kodyvim, Kose, Lilyjjo, Madalad, MohammedRizwan, Nyx, PokemonAuditSimulator, Proxy, RaymondFam, Saeedalipoor01988, Schpiel, SensoYard, T1MOH, TheNaubit, Tricko, Viktor\\_Cortess, WATCHPUG, \\_\\_141345\\_\\_, anthony, ast3ros, berlin-101, blackhole, blockdev, carrotsmuggler, chaithanya\\_gali, chalex.eth, coincoin, ctf\\_sec, curiousapple, dacian, evilakela, eyexploit, immeas, innertia, jah, jprod15, juancito, kie, kiki\\_dev, kutugu, lil.eth, m4ttm, martin, n33k, ni8mare, nobody2018, peanuts, qbs, qckhp, qpzm, saidam017, sakshamguruji, sam\\_gmk, sashik\\_eth, shaka, shealtielanz, shogoki, simon135, slightscan, tallo, theOwl, toshii, twicek, warRoom\n## Summary\n\nWhile making a swap on UniswapV3 the caller should use the slippage parameter `amountOutMinimum` and `deadline` parameter to avoid losing funds.\n\n## Vulnerability Detail\n\n[`UniV3SwapInput()`](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L227-L240) in `USSD` contract does not use the slippage parameter [`amountOutMinimum`](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L237)  nor [`deadline`](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L235). \n\n`amountOutMinimum` is used to specify the minimum amount of tokens the caller wants to be returned from a swap. Using `amountOutMinimum = 0` tells the swap that the caller will accept a minimum amount of 0 output tokens from the swap, opening up the user to a catastrophic loss of funds viaÂ [MEV bot sandwich attacks](https://medium.com/coinmonks/defi-sandwich-attack-explain-776f6f43b2fd). \n\n`deadline` lets the caller specify a deadline parameter that enforces a time limit by which the transaction must be executed. Without a deadline parameter, the transaction may sit in the mempool and be executed at a much later time potentially resulting in a worse price for the user.\n\n## Impact\n\nLoss of funds and not getting the correct amount of tokens in return.\n\n## Code Snippet\n\n- Function [`UniV3SwapInput()`](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L227-L240)\n  - Not using [`amountOutMinimum`](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L237)\n  - Not using [`deadline`](https://github.com/sherlock-audit/2023-05-USSD/blob/main/ussd-contracts/contracts/USSD.sol#L235)\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse parameters `amountOutMinimum` and `deadline` correctly to avoid loss of funds.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/82",
  "Code": [
    {
      "filename": "ussd-contracts/contracts/USSD.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"./interfaces/IStableOracle.sol\";\nimport \"./interfaces/IUSSDRebalancer.sol\";\n\nimport \"@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol\";\n\n/**\n    @notice USSD: Autonomous on-chain stablecoin\n */\ncontract USSD is\n    IUSSD,\n    ERC20Upgradeable,\n    AccessControlUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n\n    IUSSDRebalancer public rebalancer;\n\n    // allowed to manage collateral, set tresholds and perform management tasks\n    bytes32 public constant STABLE_CONTROL_ROLE = keccak256(\"STABLECONTROL\");\n\n    function initialize(\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        // mint 10k USSD to create initial pool\n        _mint(msg.sender, 10_000 * 1e6);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n\n    /**\n        @dev restrict calls only by STABLE_CONTROL_ROLE role\n     */\n    modifier onlyControl() {\n        require(hasRole(STABLE_CONTROL_ROLE, msg.sender), \"control only\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                Events\n    //////////////////////////////////////////////////////////////*/\n\n    event Mint(\n        address indexed from,\n        address indexed to,\n        address token,\n        uint256 amountToken,\n        uint256 amountStable\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                          COLLATERAL MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    CollateralInfo[] private collateral;\n\n    function collateralList()\n        public\n        view\n        override\n        returns (CollateralInfo[] memory)\n    {\n        return collateral;\n    }\n\n    function addCollateral(\n        address _address,\n        address _oracle,\n        bool _mint,\n        bool _redeem,\n        uint256[] calldata _ratios,\n        bytes memory _pathbuy,\n        bytes memory _pathsell,\n        uint256 index\n    ) public onlyControl {\n        CollateralInfo memory newCollateral = CollateralInfo({\n            token: _address,\n            mint: _mint,\n            redeem: _redeem,\n            oracle: IStableOracle(_oracle),\n            pathbuy: _pathbuy,\n            pathsell: _pathsell,\n            ratios: _ratios\n        });\n        if (index < collateral.length) {\n            collateral[index] = newCollateral; // for editing\n        } else {\n            collateral.push(newCollateral); // for adding new collateral\n        }\n    }\n\n    function swapCollateralIndexes(\n        uint256 _index1,\n        uint256 _index2\n    ) public onlyControl {\n        // cannot use (a, b) = (b, a) for storage variables\n        CollateralInfo memory tmp = collateral[_index1];\n        collateral[_index1] = collateral[_index2];\n        collateral[_index2] = tmp;\n    }\n\n    function removeCollateral(uint256 _index) public onlyControl {\n        collateral[_index] = collateral[collateral.length - 1];\n        collateral.pop();\n    }\n\n    function getCollateralIndex(\n        address _token\n    ) public view returns (uint256 index) {\n        for (index = 0; index < collateral.length; index++) {\n            if (collateral[index].token == _token) {\n                return index;\n            }\n        }\n    }\n\n    function hasCollateralMint(\n        address _token\n    ) public view returns (bool present) {\n        for (uint256 i = 0; i < collateral.length; i++) {\n            if (collateral[i].token == _token && collateral[i].mint) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// Mint specific AMOUNT OF STABLE by giving token\n    function mintForToken(\n        address token,\n        uint256 tokenAmount,\n        address to\n    ) public returns (uint256 stableCoinAmount) {\n        require(hasCollateralMint(token), \"unsupported token\");\n\n        IERC20Upgradeable(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            tokenAmount\n        );\n        stableCoinAmount = calculateMint(token, tokenAmount);\n        _mint(to, stableCoinAmount);\n\n        emit Mint(msg.sender, to, token, tokenAmount, stableCoinAmount);\n    }\n\n    /// @dev Return how much STABLECOIN does user receive for AMOUNT of asset\n    function calculateMint(address _token, uint256 _amount) public view returns (uint256 stableCoinAmount) {\n        uint256 assetPrice = collateral[getCollateralIndex(_token)].oracle.getPriceUSD();\n        return (((assetPrice * _amount) / 1e18) * (10 ** decimals())) / (10 ** IERC20MetadataUpgradeable(_token).decimals());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function collateralFactor() public view override returns (uint256) {\n        uint256 totalAssetsUSD = 0;\n        for (uint256 i = 0; i < collateral.length; i++) {\n            totalAssetsUSD +=\n                (((IERC20Upgradeable(collateral[i].token).balanceOf(\n                    address(this)\n                ) * 1e18) /\n                    (10 **\n                        IERC20MetadataUpgradeable(collateral[i].token)\n                            .decimals())) *\n                    collateral[i].oracle.getPriceUSD()) /\n                1e18;\n        }\n\n        return (totalAssetsUSD * 1e6) / totalSupply();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               REBALANCER\n    //////////////////////////////////////////////////////////////*/\n\n    function setRebalancer(address _rebalancer) public onlyControl {\n        rebalancer = IUSSDRebalancer(_rebalancer);\n    }\n\n    function mintRebalancer(uint256 amount) public override {\n        _mint(address(this), amount);\n    }\n\n    function burnRebalancer(uint256 amount) public override {\n        _burn(address(this), amount);\n    }\n\n    modifier onlyBalancer() {\n        require(msg.sender == address(rebalancer), \"bal\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               UNISWAP\n    //////////////////////////////////////////////////////////////*/\n\n    IV3SwapRouter public uniRouter; // uniswap router to handle operations\n\n    function setUniswapRouter(address _router) public onlyControl {\n        uniRouter = IV3SwapRouter(_router);\n    }\n\n    function UniV3SwapInput(\n        bytes memory _path,\n        uint256 _sellAmount\n    ) public override onlyBalancer {\n        IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter\n            .ExactInputParams({\n                path: _path,\n                recipient: address(this),\n                //deadline: block.timestamp,\n                amountIn: _sellAmount,\n                amountOutMinimum: 0\n            });\n        uniRouter.exactInput(params);\n    }\n\n    function approveToRouter(address _token) public {\n        IERC20Upgradeable(_token).approve(\n            address(uniRouter),\n            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n        );\n    }\n}"
    },
    {
      "filename": "ussd-contracts/contracts/USSD.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"./interfaces/IStableOracle.sol\";\nimport \"./interfaces/IUSSDRebalancer.sol\";\n\nimport \"@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol\";\n\n/**\n    @notice USSD: Autonomous on-chain stablecoin\n */\ncontract USSD is\n    IUSSD,\n    ERC20Upgradeable,\n    AccessControlUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n\n    IUSSDRebalancer public rebalancer;\n\n    // allowed to manage collateral, set tresholds and perform management tasks\n    bytes32 public constant STABLE_CONTROL_ROLE = keccak256(\"STABLECONTROL\");\n\n    function initialize(\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        // mint 10k USSD to create initial pool\n        _mint(msg.sender, 10_000 * 1e6);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n\n    /**\n        @dev restrict calls only by STABLE_CONTROL_ROLE role\n     */\n    modifier onlyControl() {\n        require(hasRole(STABLE_CONTROL_ROLE, msg.sender), \"control only\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                Events\n    //////////////////////////////////////////////////////////////*/\n\n    event Mint(\n        address indexed from,\n        address indexed to,\n        address token,\n        uint256 amountToken,\n        uint256 amountStable\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                          COLLATERAL MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    CollateralInfo[] private collateral;\n\n    function collateralList()\n        public\n        view\n        override\n        returns (CollateralInfo[] memory)\n    {\n        return collateral;\n    }\n\n    function addCollateral(\n        address _address,\n        address _oracle,\n        bool _mint,\n        bool _redeem,\n        uint256[] calldata _ratios,\n        bytes memory _pathbuy,\n        bytes memory _pathsell,\n        uint256 index\n    ) public onlyControl {\n        CollateralInfo memory newCollateral = CollateralInfo({\n            token: _address,\n            mint: _mint,\n            redeem: _redeem,\n            oracle: IStableOracle(_oracle),\n            pathbuy: _pathbuy,\n            pathsell: _pathsell,\n            ratios: _ratios\n        });\n        if (index < collateral.length) {\n            collateral[index] = newCollateral; // for editing\n        } else {\n            collateral.push(newCollateral); // for adding new collateral\n        }\n    }\n\n    function swapCollateralIndexes(\n        uint256 _index1,\n        uint256 _index2\n    ) public onlyControl {\n        // cannot use (a, b) = (b, a) for storage variables\n        CollateralInfo memory tmp = collateral[_index1];\n        collateral[_index1] = collateral[_index2];\n        collateral[_index2] = tmp;\n    }\n\n    function removeCollateral(uint256 _index) public onlyControl {\n        collateral[_index] = collateral[collateral.length - 1];\n        collateral.pop();\n    }\n\n    function getCollateralIndex(\n        address _token\n    ) public view returns (uint256 index) {\n        for (index = 0; index < collateral.length; index++) {\n            if (collateral[index].token == _token) {\n                return index;\n            }\n        }\n    }\n\n    function hasCollateralMint(\n        address _token\n    ) public view returns (bool present) {\n        for (uint256 i = 0; i < collateral.length; i++) {\n            if (collateral[i].token == _token && collateral[i].mint) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// Mint specific AMOUNT OF STABLE by giving token\n    function mintForToken(\n        address token,\n        uint256 tokenAmount,\n        address to\n    ) public returns (uint256 stableCoinAmount) {\n        require(hasCollateralMint(token), \"unsupported token\");\n\n        IERC20Upgradeable(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            tokenAmount\n        );\n        stableCoinAmount = calculateMint(token, tokenAmount);\n        _mint(to, stableCoinAmount);\n\n        emit Mint(msg.sender, to, token, tokenAmount, stableCoinAmount);\n    }\n\n    /// @dev Return how much STABLECOIN does user receive for AMOUNT of asset\n    function calculateMint(address _token, uint256 _amount) public view returns (uint256 stableCoinAmount) {\n        uint256 assetPrice = collateral[getCollateralIndex(_token)].oracle.getPriceUSD();\n        return (((assetPrice * _amount) / 1e18) * (10 ** decimals())) / (10 ** IERC20MetadataUpgradeable(_token).decimals());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function collateralFactor() public view override returns (uint256) {\n        uint256 totalAssetsUSD = 0;\n        for (uint256 i = 0; i < collateral.length; i++) {\n            totalAssetsUSD +=\n                (((IERC20Upgradeable(collateral[i].token).balanceOf(\n                    address(this)\n                ) * 1e18) /\n                    (10 **\n                        IERC20MetadataUpgradeable(collateral[i].token)\n                            .decimals())) *\n                    collateral[i].oracle.getPriceUSD()) /\n                1e18;\n        }\n\n        return (totalAssetsUSD * 1e6) / totalSupply();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               REBALANCER\n    //////////////////////////////////////////////////////////////*/\n\n    function setRebalancer(address _rebalancer) public onlyControl {\n        rebalancer = IUSSDRebalancer(_rebalancer);\n    }\n\n    function mintRebalancer(uint256 amount) public override {\n        _mint(address(this), amount);\n    }\n\n    function burnRebalancer(uint256 amount) public override {\n        _burn(address(this), amount);\n    }\n\n    modifier onlyBalancer() {\n        require(msg.sender == address(rebalancer), \"bal\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               UNISWAP\n    //////////////////////////////////////////////////////////////*/\n\n    IV3SwapRouter public uniRouter; // uniswap router to handle operations\n\n    function setUniswapRouter(address _router) public onlyControl {\n        uniRouter = IV3SwapRouter(_router);\n    }\n\n    function UniV3SwapInput(\n        bytes memory _path,\n        uint256 _sellAmount\n    ) public override onlyBalancer {\n        IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter\n            .ExactInputParams({\n                path: _path,\n                recipient: address(this),\n                //deadline: block.timestamp,\n                amountIn: _sellAmount,\n                amountOutMinimum: 0\n            });\n        uniRouter.exactInput(params);\n    }\n\n    function approveToRouter(address _token) public {\n        IERC20Upgradeable(_token).approve(\n            address(uniRouter),\n            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n        );\n    }\n}"
    },
    {
      "filename": "ussd-contracts/contracts/USSD.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"./interfaces/IStableOracle.sol\";\nimport \"./interfaces/IUSSDRebalancer.sol\";\n\nimport \"@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol\";\n\n/**\n    @notice USSD: Autonomous on-chain stablecoin\n */\ncontract USSD is\n    IUSSD,\n    ERC20Upgradeable,\n    AccessControlUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n\n    IUSSDRebalancer public rebalancer;\n\n    // allowed to manage collateral, set tresholds and perform management tasks\n    bytes32 public constant STABLE_CONTROL_ROLE = keccak256(\"STABLECONTROL\");\n\n    function initialize(\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        // mint 10k USSD to create initial pool\n        _mint(msg.sender, 10_000 * 1e6);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n\n    /**\n        @dev restrict calls only by STABLE_CONTROL_ROLE role\n     */\n    modifier onlyControl() {\n        require(hasRole(STABLE_CONTROL_ROLE, msg.sender), \"control only\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                Events\n    //////////////////////////////////////////////////////////////*/\n\n    event Mint(\n        address indexed from,\n        address indexed to,\n        address token,\n        uint256 amountToken,\n        uint256 amountStable\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                          COLLATERAL MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    CollateralInfo[] private collateral;\n\n    function collateralList()\n        public\n        view\n        override\n        returns (CollateralInfo[] memory)\n    {\n        return collateral;\n    }\n\n    function addCollateral(\n        address _address,\n        address _oracle,\n        bool _mint,\n        bool _redeem,\n        uint256[] calldata _ratios,\n        bytes memory _pathbuy,\n        bytes memory _pathsell,\n        uint256 index\n    ) public onlyControl {\n        CollateralInfo memory newCollateral = CollateralInfo({\n            token: _address,\n            mint: _mint,\n            redeem: _redeem,\n            oracle: IStableOracle(_oracle),\n            pathbuy: _pathbuy,\n            pathsell: _pathsell,\n            ratios: _ratios\n        });\n        if (index < collateral.length) {\n            collateral[index] = newCollateral; // for editing\n        } else {\n            collateral.push(newCollateral); // for adding new collateral\n        }\n    }\n\n    function swapCollateralIndexes(\n        uint256 _index1,\n        uint256 _index2\n    ) public onlyControl {\n        // cannot use (a, b) = (b, a) for storage variables\n        CollateralInfo memory tmp = collateral[_index1];\n        collateral[_index1] = collateral[_index2];\n        collateral[_index2] = tmp;\n    }\n\n    function removeCollateral(uint256 _index) public onlyControl {\n        collateral[_index] = collateral[collateral.length - 1];\n        collateral.pop();\n    }\n\n    function getCollateralIndex(\n        address _token\n    ) public view returns (uint256 index) {\n        for (index = 0; index < collateral.length; index++) {\n            if (collateral[index].token == _token) {\n                return index;\n            }\n        }\n    }\n\n    function hasCollateralMint(\n        address _token\n    ) public view returns (bool present) {\n        for (uint256 i = 0; i < collateral.length; i++) {\n            if (collateral[i].token == _token && collateral[i].mint) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// Mint specific AMOUNT OF STABLE by giving token\n    function mintForToken(\n        address token,\n        uint256 tokenAmount,\n        address to\n    ) public returns (uint256 stableCoinAmount) {\n        require(hasCollateralMint(token), \"unsupported token\");\n\n        IERC20Upgradeable(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            tokenAmount\n        );\n        stableCoinAmount = calculateMint(token, tokenAmount);\n        _mint(to, stableCoinAmount);\n\n        emit Mint(msg.sender, to, token, tokenAmount, stableCoinAmount);\n    }\n\n    /// @dev Return how much STABLECOIN does user receive for AMOUNT of asset\n    function calculateMint(address _token, uint256 _amount) public view returns (uint256 stableCoinAmount) {\n        uint256 assetPrice = collateral[getCollateralIndex(_token)].oracle.getPriceUSD();\n        return (((assetPrice * _amount) / 1e18) * (10 ** decimals())) / (10 ** IERC20MetadataUpgradeable(_token).decimals());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function collateralFactor() public view override returns (uint256) {\n        uint256 totalAssetsUSD = 0;\n        for (uint256 i = 0; i < collateral.length; i++) {\n            totalAssetsUSD +=\n                (((IERC20Upgradeable(collateral[i].token).balanceOf(\n                    address(this)\n                ) * 1e18) /\n                    (10 **\n                        IERC20MetadataUpgradeable(collateral[i].token)\n                            .decimals())) *\n                    collateral[i].oracle.getPriceUSD()) /\n                1e18;\n        }\n\n        return (totalAssetsUSD * 1e6) / totalSupply();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               REBALANCER\n    //////////////////////////////////////////////////////////////*/\n\n    function setRebalancer(address _rebalancer) public onlyControl {\n        rebalancer = IUSSDRebalancer(_rebalancer);\n    }\n\n    function mintRebalancer(uint256 amount) public override {\n        _mint(address(this), amount);\n    }\n\n    function burnRebalancer(uint256 amount) public override {\n        _burn(address(this), amount);\n    }\n\n    modifier onlyBalancer() {\n        require(msg.sender == address(rebalancer), \"bal\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               UNISWAP\n    //////////////////////////////////////////////////////////////*/\n\n    IV3SwapRouter public uniRouter; // uniswap router to handle operations\n\n    function setUniswapRouter(address _router) public onlyControl {\n        uniRouter = IV3SwapRouter(_router);\n    }\n\n    function UniV3SwapInput(\n        bytes memory _path,\n        uint256 _sellAmount\n    ) public override onlyBalancer {\n        IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter\n            .ExactInputParams({\n                path: _path,\n                recipient: address(this),\n                //deadline: block.timestamp,\n                amountIn: _sellAmount,\n                amountOutMinimum: 0\n            });\n        uniRouter.exactInput(params);\n    }\n\n    function approveToRouter(address _token) public {\n        IERC20Upgradeable(_token).approve(\n            address(uniRouter),\n            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n        );\n    }\n}"
    },
    {
      "filename": "ussd-contracts/contracts/USSD.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\nimport \"./interfaces/IStableOracle.sol\";\nimport \"./interfaces/IUSSDRebalancer.sol\";\n\nimport \"@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol\";\n\n/**\n    @notice USSD: Autonomous on-chain stablecoin\n */\ncontract USSD is\n    IUSSD,\n    ERC20Upgradeable,\n    AccessControlUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n\n    IUSSDRebalancer public rebalancer;\n\n    // allowed to manage collateral, set tresholds and perform management tasks\n    bytes32 public constant STABLE_CONTROL_ROLE = keccak256(\"STABLECONTROL\");\n\n    function initialize(\n        string memory name,\n        string memory symbol\n    ) public initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        // mint 10k USSD to create initial pool\n        _mint(msg.sender, 10_000 * 1e6);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n\n    /**\n        @dev restrict calls only by STABLE_CONTROL_ROLE role\n     */\n    modifier onlyControl() {\n        require(hasRole(STABLE_CONTROL_ROLE, msg.sender), \"control only\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                Events\n    //////////////////////////////////////////////////////////////*/\n\n    event Mint(\n        address indexed from,\n        address indexed to,\n        address token,\n        uint256 amountToken,\n        uint256 amountStable\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                          COLLATERAL MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    CollateralInfo[] private collateral;\n\n    function collateralList()\n        public\n        view\n        override\n        returns (CollateralInfo[] memory)\n    {\n        return collateral;\n    }\n\n    function addCollateral(\n        address _address,\n        address _oracle,\n        bool _mint,\n        bool _redeem,\n        uint256[] calldata _ratios,\n        bytes memory _pathbuy,\n        bytes memory _pathsell,\n        uint256 index\n    ) public onlyControl {\n        CollateralInfo memory newCollateral = CollateralInfo({\n            token: _address,\n            mint: _mint,\n            redeem: _redeem,\n            oracle: IStableOracle(_oracle),\n            pathbuy: _pathbuy,\n            pathsell: _pathsell,\n            ratios: _ratios\n        });\n        if (index < collateral.length) {\n            collateral[index] = newCollateral; // for editing\n        } else {\n            collateral.push(newCollateral); // for adding new collateral\n        }\n    }\n\n    function swapCollateralIndexes(\n        uint256 _index1,\n        uint256 _index2\n    ) public onlyControl {\n        // cannot use (a, b) = (b, a) for storage variables\n        CollateralInfo memory tmp = collateral[_index1];\n        collateral[_index1] = collateral[_index2];\n        collateral[_index2] = tmp;\n    }\n\n    function removeCollateral(uint256 _index) public onlyControl {\n        collateral[_index] = collateral[collateral.length - 1];\n        collateral.pop();\n    }\n\n    function getCollateralIndex(\n        address _token\n    ) public view returns (uint256 index) {\n        for (index = 0; index < collateral.length; index++) {\n            if (collateral[index].token == _token) {\n                return index;\n            }\n        }\n    }\n\n    function hasCollateralMint(\n        address _token\n    ) public view returns (bool present) {\n        for (uint256 i = 0; i < collateral.length; i++) {\n            if (collateral[i].token == _token && collateral[i].mint) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// Mint specific AMOUNT OF STABLE by giving token\n    function mintForToken(\n        address token,\n        uint256 tokenAmount,\n        address to\n    ) public returns (uint256 stableCoinAmount) {\n        require(hasCollateralMint(token), \"unsupported token\");\n\n        IERC20Upgradeable(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            tokenAmount\n        );\n        stableCoinAmount = calculateMint(token, tokenAmount);\n        _mint(to, stableCoinAmount);\n\n        emit Mint(msg.sender, to, token, tokenAmount, stableCoinAmount);\n    }\n\n    /// @dev Return how much STABLECOIN does user receive for AMOUNT of asset\n    function calculateMint(address _token, uint256 _amount) public view returns (uint256 stableCoinAmount) {\n        uint256 assetPrice = collateral[getCollateralIndex(_token)].oracle.getPriceUSD();\n        return (((assetPrice * _amount) / 1e18) * (10 ** decimals())) / (10 ** IERC20MetadataUpgradeable(_token).decimals());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function collateralFactor() public view override returns (uint256) {\n        uint256 totalAssetsUSD = 0;\n        for (uint256 i = 0; i < collateral.length; i++) {\n            totalAssetsUSD +=\n                (((IERC20Upgradeable(collateral[i].token).balanceOf(\n                    address(this)\n                ) * 1e18) /\n                    (10 **\n                        IERC20MetadataUpgradeable(collateral[i].token)\n                            .decimals())) *\n                    collateral[i].oracle.getPriceUSD()) /\n                1e18;\n        }\n\n        return (totalAssetsUSD * 1e6) / totalSupply();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               REBALANCER\n    //////////////////////////////////////////////////////////////*/\n\n    function setRebalancer(address _rebalancer) public onlyControl {\n        rebalancer = IUSSDRebalancer(_rebalancer);\n    }\n\n    function mintRebalancer(uint256 amount) public override {\n        _mint(address(this), amount);\n    }\n\n    function burnRebalancer(uint256 amount) public override {\n        _burn(address(this), amount);\n    }\n\n    modifier onlyBalancer() {\n        require(msg.sender == address(rebalancer), \"bal\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               UNISWAP\n    //////////////////////////////////////////////////////////////*/\n\n    IV3SwapRouter public uniRouter; // uniswap router to handle operations\n\n    function setUniswapRouter(address _router) public onlyControl {\n        uniRouter = IV3SwapRouter(_router);\n    }\n\n    function UniV3SwapInput(\n        bytes memory _path,\n        uint256 _sellAmount\n    ) public override onlyBalancer {\n        IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter\n            .ExactInputParams({\n                path: _path,\n                recipient: address(this),\n                //deadline: block.timestamp,\n                amountIn: _sellAmount,\n                amountOutMinimum: 0\n            });\n        uniRouter.exactInput(params);\n    }\n\n    function approveToRouter(address _token) public {\n        IERC20Upgradeable(_token).approve(\n            address(uniRouter),\n            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n        );\n    }\n}"
    }
  ]
}