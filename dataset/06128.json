{
  "Title": "[M-06] Inconsistent encoding of arrays in `MetaTxLib`",
  "Content": "\n<https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/MetaTxLib.sol#L143-L153><br>\n<https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/MetaTxLib.sol#L100-L109>\n\nAccording to the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification, arrays are encoded by concatenating its elements and passing the result to `keccak256`:\n\n> The array values are encoded as the `keccak256` hash of the concatenated encodeData of their contents (i.e. the encoding of `SomeType[5]` is identical to that of a struct containing five members of type `SomeType`).\n\nAn example of a correct implementation can be seen in [`validateUnfollowSignature()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/MetaTxLib.sol#L357-L376), where the `idsOfProfilesToUnfollow` array is passed to `keccak256` after using `abi.encodePacked()`:\n\n[MetaTxLib.sol#L368](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/MetaTxLib.sol#L368)\n\n```solidity\n                        keccak256(abi.encodePacked(idsOfProfilesToUnfollow)),\n```\n\nHowever, some other functions in `MetaTxLib` encode arrays differently, which differs from the EIP-712 specification.\n\nSome functions do not encode the array at all, and pass the array to `abi.encode()` alongside other arguments in its struct. For example, in `validatePostSignature()`, the `postParams.actionModules` array is not encoded by itself:\n\n[MetaTxLib.sol#L143-L153](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/MetaTxLib.sol#L143-L153)\n\n```solidity\n                    abi.encode(\n                        Typehash.POST,\n                        postParams.profileId,\n                        keccak256(bytes(postParams.contentURI)),\n                        postParams.actionModules,\n                        _hashActionModulesInitDatas(postParams.actionModulesInitDatas),\n                        postParams.referenceModule,\n                        keccak256(postParams.referenceModuleInitData),\n                        _getAndIncrementNonce(signature.signer),\n                        signature.deadline\n                    )\n```\n\nOther instances of this include:\n\n*   `mirrorParams.referrerProfileIds` and `mirrorParams.referrerPubIds` in [`validateMirrorSignature()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/MetaTxLib.sol#L297-L298)\n*   `publicationActionParams.referrerProfileIds` and `publicationActionParams.referrerPubIds` in [`validateActSignature()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/MetaTxLib.sol#L437-L438)\n*   All functions that use [`_abiEncode()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/MetaTxLib.sol#L190-L223), namely [`validateCommentSignature()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/MetaTxLib.sol#L225-L254) and [`validateQuoteSignature()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/MetaTxLib.sol#L256-L284)\n\nSecondly, the `validateChangeDelegatedExecutorsConfigSignature()` function encodes the `delegatedExecutors` and `approvals` arrays using `abi.encodePacked()`, but do not pass it to `keccak256`:\n\n[MetaTxLib.sol#L100-L109](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/MetaTxLib.sol#L100-L109)\n\n```solidity\n                    abi.encode(\n                        Typehash.CHANGE_DELEGATED_EXECUTORS_CONFIG,\n                        delegatorProfileId,\n                        abi.encodePacked(delegatedExecutors),\n                        abi.encodePacked(approvals),\n                        configNumber,\n                        switchToGivenConfig,\n                        nonce,\n                        deadline\n                    )\n```\n\n### Impact\n\nAs arrays are encoded incorrectly, the signature verification in the functions listed above is not [EIP-712](https://eips.ethereum.org/EIPS/eip-712) compliant.\n\nContracts or dapps/backends that encode arrays according to the rules specified in [EIP-712](https://eips.ethereum.org/EIPS/eip-712) will end up with different signatures, causing any of the functions listed above to revert when called.\n\nMoreover, the inconsistent encoding of arrays might be extremely confusing to developers who wish to use these functions to implement meta-transactions.\n\n### Recommended Mitigation\n\nConsider encoding arrays correctly in the functions listed above, which can be achieved by calling `abi.encodePacked()` on the array and passing its results to `keccak256`.\n\n**[donosonaumczuk (Lens) disagreed with severity and commented](https://github.com/code-423n4/2023-07-lens-findings/issues/142#issuecomment-1669806824):**\n > We confirm it, but we think this should be Low instead.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-07-lens-findings/issues/142#issuecomment-1696111170):**\n > Following the same reasoning as in [M-07 (issue 141)](https://github.com/code-423n4/2023-07-lens-findings/issues/141), I'll keep Medium severity here as EIP compliance is of great importance for integrators and compatibility, so I consider this an instance of \"function of the protocol \\[is] impacted\", the function being the EIP712 compliance.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/libraries/MetaTxLib.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IERC1271} from '@openzeppelin/contracts/interfaces/IERC1271.sol';\nimport {ILensERC721} from 'contracts/interfaces/ILensERC721.sol';\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {Typehash} from 'contracts/libraries/constants/Typehash.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\n\n/**\n * @title MetaTxLib\n * @author Lens Protocol\n *\n * NOTE: the functions in this contract operate under the assumption that the passed signer is already validated\n * to either be the originator or one of their delegated executors.\n *\n * @dev User nonces are incremented from this library as well.\n */\nlibrary MetaTxLib {\n    string constant EIP712_DOMAIN_VERSION = '2';\n    bytes32 constant EIP712_DOMAIN_VERSION_HASH = keccak256(bytes(EIP712_DOMAIN_VERSION));\n    bytes4 constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n\n    /**\n     * @dev We store the domain separator and LensHub Proxy address as constants to save gas.\n     *\n     * keccak256(\n     *     abi.encode(\n     *         keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n     *         keccak256('Lens Protocol Profiles'), // Contract Name\n     *         keccak256('2'), // Version Hash\n     *         137, // Polygon Chain ID\n     *         address(0xDb46d1Dc155634FbC732f92E853b10B288AD5a1d) // Verifying Contract Address - LensHub Address\n     *     )\n     * );\n     */\n    bytes32 constant LENS_HUB_CACHED_POLYGON_DOMAIN_SEPARATOR =\n        0xbf9544cf7d7a0338fc4f071be35409a61e51e9caef559305410ad74e16a05f2d;\n\n    address constant LENS_HUB_ADDRESS = 0xDb46d1Dc155634FbC732f92E853b10B288AD5a1d;\n\n    function validateSetProfileMetadataURISignature(\n        Types.EIP712Signature calldata signature,\n        uint256 profileId,\n        string calldata metadataURI\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.SET_PROFILE_METADATA_URI,\n                        profileId,\n                        keccak256(bytes(metadataURI)),\n                        _getAndIncrementNonce(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateSetFollowModuleSignature(\n        Types.EIP712Signature calldata signature,\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.SET_FOLLOW_MODULE,\n                        profileId,\n                        followModule,\n                        keccak256(followModuleInitData),\n                        _getAndIncrementNonce(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateChangeDelegatedExecutorsConfigSignature(\n        Types.EIP712Signature calldata signature,\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) external {\n        uint256 nonce = _getAndIncrementNonce(signature.signer);\n        uint256 deadline = signature.deadline;\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.CHANGE_DELEGATED_EXECUTORS_CONFIG,\n                        delegatorProfileId,\n                        abi.encodePacked(delegatedExecutors),\n                        abi.encodePacked(approvals),\n                        configNumber,\n                        switchToGivenConfig,\n                        nonce,\n                        deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateSetProfileImageURISignature(\n        Types.EIP712Signature calldata signature,\n        uint256 profileId,\n        string calldata imageURI\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.SET_PROFILE_IMAGE_URI,\n                        profileId,\n                        keccak256(bytes(imageURI)),\n                        _getAndIncrementNonce(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validatePostSignature(Types.EIP712Signature calldata signature, Types.PostParams calldata postParams)\n        external\n    {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.POST,\n                        postParams.profileId,\n                        keccak256(bytes(postParams.contentURI)),\n                        postParams.actionModules,\n                        _hashActionModulesInitDatas(postParams.actionModulesInitDatas),\n                        postParams.referenceModule,\n                        keccak256(postParams.referenceModuleInitData),\n                        _getAndIncrementNonce(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function _hashActionModulesInitDatas(bytes[] memory actionModulesInitDatas) private pure returns (bytes32) {\n        bytes32[] memory actionModulesInitDatasHashes = new bytes32[](actionModulesInitDatas.length);\n        uint256 i;\n        while (i < actionModulesInitDatas.length) {\n            actionModulesInitDatasHashes[i] = keccak256(abi.encode(actionModulesInitDatas[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(actionModulesInitDatasHashes));\n    }\n\n    // We need this to deal with stack too deep:\n    struct ReferenceParamsForAbiEncode {\n        bytes32 typehash;\n        uint256 profileId;\n        bytes32 contentURIHash;\n        uint256 pointedProfileId;\n        uint256 pointedPubId;\n        uint256[] referrerProfileIds;\n        uint256[] referrerPubIds;\n        bytes32 referenceModuleDataHash;\n        address[] actionModules;\n        bytes32 actionModulesInitDataHash;\n        address referenceModule;\n        bytes32 referenceModuleInitDataHash;\n        uint256 nonce;\n        uint256 deadline;\n    }\n\n    function _abiEncode(ReferenceParamsForAbiEncode memory referenceParamsForAbiEncode)\n        private\n        pure\n        returns (bytes memory)\n    {\n        // This assembly workaround allows us to avoid Stack Too Deep error when encoding all the params of the struct.\n        // We remove the first 32 bytes of the encoded struct, which is the offset of the struct.\n        // The rest of the encoding is the same, so we can just return it.\n        bytes memory encodedStruct = abi.encode(referenceParamsForAbiEncode);\n        assembly {\n            let lengthWithoutOffset := sub(mload(encodedStruct), 32) // Calculates length without offset.\n            encodedStruct := add(encodedStruct, 32) // Skips the offset by shifting the memory pointer.\n            mstore(encodedStruct, lengthWithoutOffset) // Stores new length, which now excludes the offset.\n        }\n        return encodedStruct;\n        // The code above is the equivalent of:\n        //\n        // return abi.encode(\n        //     referenceParamsForAbiEncode.typehash,\n        //     referenceParamsForAbiEncode.profileId,\n        //     referenceParamsForAbiEncode.contentURIHash,\n        //     referenceParamsForAbiEncode.pointedProfileId,\n        //     referenceParamsForAbiEncode.pointedPubId,\n        //     referenceParamsForAbiEncode.referrerProfileIds,\n        //     referenceParamsForAbiEncode.referrerPubIds,\n        //     referenceParamsForAbiEncode.referenceModuleDataHash,\n        //     referenceParamsForAbiEncode.actionModules,\n        //     referenceParamsForAbiEncode.actionModulesInitDataHash,\n        //     referenceParamsForAbiEncode.referenceModule,\n        //     referenceParamsForAbiEncode.referenceModuleInitDataHash,\n        //     referenceParamsForAbiEncode.nonce,\n        //     referenceParamsForAbiEncode.deadline\n        // );\n    }\n\n    function validateCommentSignature(\n        Types.EIP712Signature calldata signature,\n        Types.CommentParams calldata commentParams\n    ) external {\n        bytes32 contentURIHash = keccak256(bytes(commentParams.contentURI));\n        bytes32 referenceModuleDataHash = keccak256(commentParams.referenceModuleData);\n        bytes32 actionModulesInitDataHash = _hashActionModulesInitDatas(commentParams.actionModulesInitDatas);\n        bytes32 referenceModuleInitDataHash = keccak256(commentParams.referenceModuleInitData);\n        uint256 nonce = _getAndIncrementNonce(signature.signer);\n        uint256 deadline = signature.deadline;\n        bytes memory encodedAbi = _abiEncode(\n            ReferenceParamsForAbiEncode(\n                Typehash.COMMENT,\n                commentParams.profileId,\n                contentURIHash,\n                commentParams.pointedProfileId,\n                commentParams.pointedPubId,\n                commentParams.referrerProfileIds,\n                commentParams.referrerPubIds,\n                referenceModuleDataHash,\n                commentParams.actionModules,\n                actionModulesInitDataHash,\n                commentParams.referenceModule,\n                referenceModuleInitDataHash,\n                nonce,\n                deadline\n            )\n        );\n        _validateRecoveredAddress(_calculateDigest(keccak256(encodedAbi)), signature);\n    }\n\n    function validateQuoteSignature(Types.EIP712Signature calldata signature, Types.QuoteParams calldata quoteParams)\n        external\n    {\n        bytes32 contentURIHash = keccak256(bytes(quoteParams.contentURI));\n        bytes32 referenceModuleDataHash = keccak256(quoteParams.referenceModuleData);\n        bytes32 actionModulesInitDataHash = _hashActionModulesInitDatas(quoteParams.actionModulesInitDatas);\n        bytes32 referenceModuleInitDataHash = keccak256(quoteParams.referenceModuleInitData);\n        uint256 nonce = _getAndIncrementNonce(signature.signer);\n        uint256 deadline = signature.deadline;\n        bytes memory encodedAbi = _abiEncode(\n            ReferenceParamsForAbiEncode(\n                Typehash.QUOTE,\n                quoteParams.profileId,\n                contentURIHash,\n                quoteParams.pointedProfileId,\n                quoteParams.pointedPubId,\n                quoteParams.referrerProfileIds,\n                quoteParams.referrerPubIds,\n                referenceModuleDataHash,\n                quoteParams.actionModules,\n                actionModulesInitDataHash,\n                quoteParams.referenceModule,\n                referenceModuleInitDataHash,\n                nonce,\n                deadline\n            )\n        );\n        _validateRecoveredAddress(_calculateDigest(keccak256(encodedAbi)), signature);\n    }\n\n    function validateMirrorSignature(Types.EIP712Signature calldata signature, Types.MirrorParams calldata mirrorParams)\n        external\n    {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.MIRROR,\n                        mirrorParams.profileId,\n                        mirrorParams.pointedProfileId,\n                        mirrorParams.pointedPubId,\n                        mirrorParams.referrerProfileIds,\n                        mirrorParams.referrerPubIds,\n                        keccak256(mirrorParams.referenceModuleData),\n                        _getAndIncrementNonce(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateBurnSignature(Types.EIP712Signature calldata signature, uint256 tokenId) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(Typehash.BURN, tokenId, _getAndIncrementNonce(signature.signer), signature.deadline)\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateFollowSignature(\n        Types.EIP712Signature calldata signature,\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas\n    ) external {\n        uint256 dataLength = datas.length;\n        bytes32[] memory dataHashes = new bytes32[](dataLength);\n        uint256 i;\n        while (i < dataLength) {\n            dataHashes[i] = keccak256(datas[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        uint256 nonce = _getAndIncrementNonce(signature.signer);\n        uint256 deadline = signature.deadline;\n\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.FOLLOW,\n                        followerProfileId,\n                        keccak256(abi.encodePacked(idsOfProfilesToFollow)),\n                        keccak256(abi.encodePacked(followTokenIds)),\n                        keccak256(abi.encodePacked(dataHashes)),\n                        nonce,\n                        deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateUnfollowSignature(\n        Types.EIP712Signature calldata signature,\n        uint256 unfollowerProfileId,\n        uint256[] calldata idsOfProfilesToUnfollow\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.UNFOLLOW,\n                        unfollowerProfileId,\n                        keccak256(abi.encodePacked(idsOfProfilesToUnfollow)),\n                        _getAndIncrementNonce(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateSetBlockStatusSignature(\n        Types.EIP712Signature calldata signature,\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.SET_BLOCK_STATUS,\n                        byProfileId,\n                        keccak256(abi.encodePacked(idsOfProfilesToSetBlockStatus)),\n                        keccak256(abi.encodePacked(blockStatus)),\n                        _getAndIncrementNonce(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateLegacyCollectSignature(\n        Types.EIP712Signature calldata signature,\n        Types.CollectParams calldata collectParams\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.LEGACY_COLLECT,\n                        collectParams.publicationCollectedProfileId,\n                        collectParams.publicationCollectedId,\n                        collectParams.collectorProfileId,\n                        collectParams.referrerProfileId,\n                        collectParams.referrerPubId,\n                        keccak256(collectParams.collectModuleData),\n                        _getAndIncrementNonce(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateActSignature(\n        Types.EIP712Signature calldata signature,\n        Types.PublicationActionParams calldata publicationActionParams\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.ACT,\n                        publicationActionParams.publicationActedProfileId,\n                        publicationActionParams.publicationActedId,\n                        publicationActionParams.actorProfileId,\n                        publicationActionParams.referrerProfileIds,\n                        publicationActionParams.referrerPubIds,\n                        publicationActionParams.actionModuleAddress,\n                        keccak256(publicationActionParams.actionModuleData),\n                        _getAndIncrementNonce(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function calculateDomainSeparator() internal view returns (bytes32) {\n        if (address(this) == LENS_HUB_ADDRESS) {\n            return LENS_HUB_CACHED_POLYGON_DOMAIN_SEPARATOR;\n        }\n        return\n            keccak256(\n                abi.encode(\n                    Typehash.EIP712_DOMAIN,\n                    keccak256(bytes(ILensERC721(address(this)).name())),\n                    EIP712_DOMAIN_VERSION_HASH,\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n     * @dev Wrapper for ecrecover to reduce code size, used in meta-tx specific functions.\n     */\n    function _validateRecoveredAddress(bytes32 digest, Types.EIP712Signature calldata signature) private view {\n        if (signature.deadline < block.timestamp) revert Errors.SignatureExpired();\n        // If the expected address is a contract, check the signature there.\n        if (signature.signer.code.length != 0) {\n            bytes memory concatenatedSig = abi.encodePacked(signature.r, signature.s, signature.v);\n            if (IERC1271(signature.signer).isValidSignature(digest, concatenatedSig) != EIP1271_MAGIC_VALUE) {\n                revert Errors.SignatureInvalid();\n            }\n        } else {\n            address recoveredAddress = ecrecover(digest, signature.v, signature.r, signature.s);\n            if (recoveredAddress == address(0) || recoveredAddress != signature.signer) {\n                revert Errors.SignatureInvalid();\n            }\n        }\n    }\n\n    /**\n     * @dev Calculates EIP712 digest based on the current DOMAIN_SEPARATOR.\n     *\n     * @param hashedMessage The message hash from which the digest should be calculated.\n     *\n     * @return bytes32 A 32-byte output representing the EIP712 digest.\n     */\n    function _calculateDigest(bytes32 hashedMessage) private view returns (bytes32) {\n        return keccak256(abi.encodePacked('\\x19\\x01', calculateDomainSeparator(), hashedMessage));\n    }\n\n    /**\n     * @dev This fetches a user's signing nonce and increments it, akin to `sigNonces++`.\n     *\n     * @param user The user address to fetch and post-increment the signing nonce for.\n     *\n     * @return uint256 The signing nonce for the given user prior to being incremented.\n     */\n    function _getAndIncrementNonce(address user) private returns (uint256) {\n        unchecked {\n            return StorageLib.nonces()[user]++;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/MetaTxLib.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IERC1271} from '@openzeppelin/contracts/interfaces/IERC1271.sol';\nimport {ILensERC721} from 'contracts/interfaces/ILensERC721.sol';\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {Typehash} from 'contracts/libraries/constants/Typehash.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\n\n/**\n * @title MetaTxLib\n * @author Lens Protocol\n *\n * NOTE: the functions in this contract operate under the assumption that the passed signer is already validated\n * to either be the originator or one of their delegated executors.\n *\n * @dev User nonces are incremented from this library as well.\n */\nlibrary MetaTxLib {\n    string constant EIP712_DOMAIN_VERSION = '2';\n    bytes32 constant EIP712_DOMAIN_VERSION_HASH = keccak256(bytes(EIP712_DOMAIN_VERSION));\n    bytes4 constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n\n    /**\n     * @dev We store the domain separator and LensHub Proxy address as constants to save gas.\n     *\n     * keccak256(\n     *     abi.encode(\n     *         keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n     *         keccak256('Lens Protocol Profiles'), // Contract Name\n     *         keccak256('2'), // Version Hash\n     *         137, // Polygon Chain ID\n     *         address(0xDb46d1Dc155634FbC732f92E853b10B288AD5a1d) // Verifying Contract Address - LensHub Address\n     *     )\n     * );\n     */\n    bytes32 constant LENS_HUB_CACHED_POLYGON_DOMAIN_SEPARATOR =\n        0xbf9544cf7d7a0338fc4f071be35409a61e51e9caef559305410ad74e16a05f2d;\n\n    address constant LENS_HUB_ADDRESS = 0xDb46d1Dc155634FbC732f92E853b10B288AD5a1d;\n\n    function validateSetProfileMetadataURISignature(\n        Types.EIP712Signature calldata signature,\n        uint256 profileId,\n        string calldata metadataURI\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.SET_PROFILE_METADATA_URI,\n                        profileId,\n                        keccak256(bytes(metadataURI)),\n                        _getAndIncrementNonce(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateSetFollowModuleSignature(\n        Types.EIP712Signature calldata signature,\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.SET_FOLLOW_MODULE,\n                        profileId,\n                        followModule,\n                        keccak256(followModuleInitData),\n                        _getAndIncrementNonce(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateChangeDelegatedExecutorsConfigSignature(\n        Types.EIP712Signature calldata signature,\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) external {\n        uint256 nonce = _getAndIncrementNonce(signature.signer);\n        uint256 deadline = signature.deadline;\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.CHANGE_DELEGATED_EXECUTORS_CONFIG,\n                        delegatorProfileId,\n                        abi.encodePacked(delegatedExecutors),\n                        abi.encodePacked(approvals),\n                        configNumber,\n                        switchToGivenConfig,\n                        nonce,\n                        deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateSetProfileImageURISignature(\n        Types.EIP712Signature calldata signature,\n        uint256 profileId,\n        string calldata imageURI\n    ) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.SET_PROFILE_IMAGE_URI,\n                        profileId,\n                        keccak256(bytes(imageURI)),\n                        _getAndIncrementNonce(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validatePostSignature(Types.EIP712Signature calldata signature, Types.PostParams calldata postParams)\n        external\n    {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.POST,\n                        postParams.profileId,\n                        keccak256(bytes(postParams.contentURI)),\n                        postParams.actionModules,\n                        _hashActionModulesInitDatas(postParams.actionModulesInitDatas),\n                        postParams.referenceModule,\n                        keccak256(postParams.referenceModuleInitData),\n                        _getAndIncrementNonce(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function _hashActionModulesInitDatas(bytes[] memory actionModulesInitDatas) private pure returns (bytes32) {\n        bytes32[] memory actionModulesInitDatasHashes = new bytes32[](actionModulesInitDatas.length);\n        uint256 i;\n        while (i < actionModulesInitDatas.length) {\n            actionModulesInitDatasHashes[i] = keccak256(abi.encode(actionModulesInitDatas[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(actionModulesInitDatasHashes));\n    }\n\n    // We need this to deal with stack too deep:\n    struct ReferenceParamsForAbiEncode {\n        bytes32 typehash;\n        uint256 profileId;\n        bytes32 contentURIHash;\n        uint256 pointedProfileId;\n        uint256 pointedPubId;\n        uint256[] referrerProfileIds;\n        uint256[] referrerPubIds;\n        bytes32 referenceModuleDataHash;\n        address[] actionModules;\n        bytes32 actionModulesInitDataHash;\n        address referenceModule;\n        bytes32 referenceModuleInitDataHash;\n        uint256 nonce;\n        uint256 deadline;\n    }\n\n    function _abiEncode(ReferenceParamsForAbiEncode memory referenceParamsForAbiEncode)\n        private\n        pure\n        returns (bytes memory)\n    {\n        // This assembly workaround allows us to avoid Stack Too Deep error when encoding all the params of the struct.\n        // We remove the first 32 bytes of the encoded struct, which is the offset of the struct.\n        // The rest of the encoding is the same, so we can just return it.\n        bytes memory encodedStruct = abi.encode(referenceParamsForAbiEncode);\n        assembly {\n            let lengthWithoutOffset := sub(mload(encodedStruct), 32) // Calculates length without offset.\n            encodedStruct := add(encodedStruct, 32) // Skips the offset by shifting the memory pointer.\n            mstore(encodedStruct, lengthWithoutOffset) // Stores new length, which now excludes the offset.\n        }\n        return encodedStruct;\n        // The code above is the equivalent of:\n        //\n        // return abi.encode(\n        //     referenceParamsForAbiEncode.typehash,\n        //     referenceParamsForAbiEncode.profileId,\n        //     referenceParamsForAbiEncode.contentURIHash,\n        //     referenceParamsForAbiEncode.pointedProfileId,\n        //     referenceParamsForAbiEncode.pointedPubId,\n        //     referenceParamsForAbiEncode.referrerProfileIds,\n        //     referenceParamsForAbiEncode.referrerPubIds,\n        //     referenceParamsForAbiEncode.referenceModuleDataHash,\n        //     referenceParamsForAbiEncode.actionModules,\n        //     referenceParamsForAbiEncode.actionModulesInitDataHash,\n        //     referenceParamsForAbiEncode.referenceModule,\n        //     referenceParamsForAbiEncode.referenceModuleInitDataHash,\n        //     referenceParamsForAbiEncode.nonce,\n        //     referenceParamsForAbiEncode.deadline\n        // );\n    }\n\n    function validateCommentSignature(\n        Types.EIP712Signature calldata signature,\n        Types.CommentParams calldata commentParams\n    ) external {\n        bytes32 contentURIHash = keccak256(bytes(commentParams.contentURI));\n        bytes32 referenceModuleDataHash = keccak256(commentParams.referenceModuleData);\n        bytes32 actionModulesInitDataHash = _hashActionModulesInitDatas(commentParams.actionModulesInitDatas);\n        bytes32 referenceModuleInitDataHash = keccak256(commentParams.referenceModuleInitData);\n        uint256 nonce = _getAndIncrementNonce(signature.signer);\n        uint256 deadline = signature.deadline;\n        bytes memory encodedAbi = _abiEncode(\n            ReferenceParamsForAbiEncode(\n                Typehash.COMMENT,\n                commentParams.profileId,\n                contentURIHash,\n                commentParams.pointedProfileId,\n                commentParams.pointedPubId,\n                commentParams.referrerProfileIds,\n                commentParams.referrerPubIds,\n                referenceModuleDataHash,\n                commentParams.actionModules,\n                actionModulesInitDataHash,\n                commentParams.referenceModule,\n                referenceModuleInitDataHash,\n                nonce,\n                deadline\n            )\n        );\n        _validateRecoveredAddress(_calculateDigest(keccak256(encodedAbi)), signature);\n    }\n\n    function validateQuoteSignature(Types.EIP712Signature calldata signature, Types.QuoteParams calldata quoteParams)\n        external\n    {\n        bytes32 contentURIHash = keccak256(bytes(quoteParams.contentURI));\n        bytes32 referenceModuleDataHash = keccak256(quoteParams.referenceModuleData);\n        bytes32 actionModulesInitDataHash = _hashActionModulesInitDatas(quoteParams.actionModulesInitDatas);\n        bytes32 referenceModuleInitDataHash = keccak256(quoteParams.referenceModuleInitData);\n        uint256 nonce = _getAndIncrementNonce(signature.signer);\n        uint256 deadline = signature.deadline;\n        bytes memory encodedAbi = _abiEncode(\n            ReferenceParamsForAbiEncode(\n                Typehash.QUOTE,\n                quoteParams.profileId,\n                contentURIHash,\n                quoteParams.pointedProfileId,\n                quoteParams.pointedPubId,\n                quoteParams.referrerProfileIds,\n                quoteParams.referrerPubIds,\n                referenceModuleDataHash,\n                quoteParams.actionModules,\n                actionModulesInitDataHash,\n                quoteParams.referenceModule,\n                referenceModuleInitDataHash,\n                nonce,\n                deadline\n            )\n        );\n        _validateRecoveredAddress(_calculateDigest(keccak256(encodedAbi)), signature);\n    }\n\n    function validateMirrorSignature(Types.EIP712Signature calldata signature, Types.MirrorParams calldata mirrorParams)\n        external\n    {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(\n                        Typehash.MIRROR,\n                        mirrorParams.profileId,\n                        mirrorParams.pointedProfileId,\n                        mirrorParams.pointedPubId,\n                        mirrorParams.referrerProfileIds,\n                        mirrorParams.referrerPubIds,\n                        keccak256(mirrorParams.referenceModuleData),\n                        _getAndIncrementNonce(signature.signer),\n                        signature.deadline\n                    )\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateBurnSignature(Types.EIP712Signature calldata signature, uint256 tokenId) external {\n        _validateRecoveredAddress(\n            _calculateDigest(\n                keccak256(\n                    abi.encode(Typehash.BURN, tokenId, _getAndIncrementNonce(signature.signer), signature.deadline)\n                )\n            ),\n            signature\n        );\n    }\n\n    function validateFollowSignature(\n        Types.EIP712Signature calldata signature,\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas\n    ) external {\n        uint256 dataLength = datas.length;"
    }
  ]
}