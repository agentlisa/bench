{
  "Title": "[L11] Missing validation",
  "Content": "There are currently some unvalidated assumptions in the codebase. For example:\n\n\n* The `VaultCore` contract [checks if the trustee is defined](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultCore.sol#L375) before sending it fees, but [assumes it is defined](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultCore.sol#L350) and has a `swap` function when triggering the buyback mechanism. If this assumption does not hold, the contract will be unable allocate funds.\n* The [`ThreePoolStrategy` contract](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/strategies/ThreePoolStrategy.sol) makes [assumptions that `assetsMapped` is of length 3](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/strategies/ThreePoolStrategy.sol#L116-L120), but thereâ€™s nothing [in the `_initialize` function](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/utils/InitializableAbstractStrategy.sol#L72-L75) that enforces that. The [`deposit`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/strategies/ThreePoolStrategy.sol#L90-L93) and [`depositAll`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/strategies/ThreePoolStrategy.sol#L124-L126) functions would revert if the `assetsMapped` were ever more than 3 elements long.\n* The [`startCampaign`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/liquidity/LiquidityReward.sol#L98) function from the `LiquidityReward` contract does not validate that `_numBlocks` is not zero. This could emit confusing events and update values such as `startBlock`, `endBlock`, and `pool.lastRewardBlock` without reason.\n\n\nConsider adding validation in these and all other places where assumptions are currently unchecked to reduce the chance of errors when interacting with and refactoring the contracts.\n\n\n**Update:** *Fixed in [PR#632](https://github.com/OriginProtocol/origin-dollar/pull/632), [PR#688](https://github.com/OriginProtocol/origin-dollar/pull/688), and [PR#715](https://github.com/OriginProtocol/origin-dollar/pull/715).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/vault/VaultCore.sol",
      "content": "pragma solidity 0.5.11;\n\n/**\n * @title OUSD Vault Contract\n * @notice The Vault contract stores assets. On a deposit, OUSD will be minted\n           and sent to the depositor. On a withdrawal, OUSD will be burned and\n           assets will be sent to the withdrawer. The Vault accepts deposits of\n           interest form yield bearing strategies which will modify the supply\n           of OUSD.\n * @author Origin Protocol Inc\n */\n\nimport \"./VaultStorage.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IVault } from \"../interfaces/IVault.sol\";\nimport { IBuyback } from \"../interfaces/IBuyback.sol\";\n\ncontract VaultCore is VaultStorage {\n    uint256 constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /**\n     * @dev Verifies that the rebasing is not paused.\n     */\n    modifier whenNotRebasePaused() {\n        require(!rebasePaused, \"Rebasing paused\");\n        _;\n    }\n\n    /**\n     * @dev Verifies that the deposits are not paused.\n     */\n    modifier whenNotCapitalPaused() {\n        require(!capitalPaused, \"Capital paused\");\n        _;\n    }\n\n    /**\n     * @dev Deposit a supported asset and mint OUSD.\n     * @param _asset Address of the asset being deposited\n     * @param _amount Amount of the asset being deposited\n     * @param _minimumOusdAmount Minimum OUSD to mint\n     */\n    function mint(\n        address _asset,\n        uint256 _amount,\n        uint256 _minimumOusdAmount\n    ) external whenNotCapitalPaused nonReentrant {\n        require(assets[_asset].isSupported, \"Asset is not supported\");\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        uint256 price = IOracle(priceProvider).price(_asset);\n        if (price > 1e8) {\n            price = 1e8;\n        }\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        uint256 unitAdjustedDeposit = _amount.scaleBy(int8(18 - assetDecimals));\n        uint256 priceAdjustedDeposit = _amount.mulTruncateScale(\n            price.scaleBy(int8(10)), // 18-8 because oracles have 8 decimals precision\n            10**assetDecimals\n        );\n\n        if (_minimumOusdAmount > 0) {\n            require(\n                priceAdjustedDeposit >= _minimumOusdAmount,\n                \"Mint amount lower than minimum\"\n            );\n        }\n\n        emit Mint(msg.sender, priceAdjustedDeposit);\n\n        // Rebase must happen before any transfers occur.\n        if (unitAdjustedDeposit >= rebaseThreshold && !rebasePaused) {\n            _rebase();\n        }\n\n        // Mint matching OUSD\n        oUSD.mint(msg.sender, priceAdjustedDeposit);\n\n        // Transfer the deposited coins to the vault\n        IERC20 asset = IERC20(_asset);\n        asset.safeTransferFrom(msg.sender, address(this), _amount);\n\n        if (unitAdjustedDeposit >= autoAllocateThreshold) {\n            _allocate();\n        }\n    }\n\n    /**\n     * @dev Mint for multiple assets in the same call.\n     * @param _assets Addresses of assets being deposited\n     * @param _amounts Amount of each asset at the same index in the _assets\n     *                 to deposit.\n     * @param _minimumOusdAmount Minimum OUSD to mint\n     */\n    function mintMultiple(\n        address[] calldata _assets,\n        uint256[] calldata _amounts,\n        uint256 _minimumOusdAmount\n    ) external whenNotCapitalPaused nonReentrant {\n        require(_assets.length == _amounts.length, \"Parameter length mismatch\");\n\n        uint256 unitAdjustedTotal = 0;\n        uint256 priceAdjustedTotal = 0;\n        uint256[] memory assetPrices = _getAssetPrices(false);\n        for (uint256 j = 0; j < _assets.length; j++) {\n            // In memoriam\n            require(assets[_assets[j]].isSupported, \"Asset is not supported\");\n            require(_amounts[j] > 0, \"Amount must be greater than 0\");\n            for (uint256 i = 0; i < allAssets.length; i++) {\n                if (_assets[j] == allAssets[i]) {\n                    uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);\n                    uint256 price = assetPrices[i];\n                    if (price > 1e18) {\n                        price = 1e18;\n                    }\n                    unitAdjustedTotal = unitAdjustedTotal.add(\n                        _amounts[j].scaleBy(int8(18 - assetDecimals))\n                    );\n                    priceAdjustedTotal = priceAdjustedTotal.add(\n                        _amounts[j].mulTruncateScale(price, 10**assetDecimals)\n                    );\n                }\n            }\n        }\n\n        if (_minimumOusdAmount > 0) {\n            require(\n                priceAdjustedTotal >= _minimumOusdAmount,\n                \"Mint amount lower than minimum\"\n            );\n        }\n\n        emit Mint(msg.sender, priceAdjustedTotal);\n\n        // Rebase must happen before any transfers occur.\n        if (unitAdjustedTotal >= rebaseThreshold && !rebasePaused) {\n            _rebase();\n        }\n\n        oUSD.mint(msg.sender, priceAdjustedTotal);\n\n        for (uint256 i = 0; i < _assets.length; i++) {\n            IERC20 asset = IERC20(_assets[i]);\n            asset.safeTransferFrom(msg.sender, address(this), _amounts[i]);\n        }\n\n        if (unitAdjustedTotal >= autoAllocateThreshold) {\n            _allocate();\n        }\n    }\n\n    /**\n     * @dev Withdraw a supported asset and burn OUSD.\n     * @param _amount Amount of OUSD to burn\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function redeem(uint256 _amount, uint256 _minimumUnitAmount)\n        public\n        whenNotCapitalPaused\n        nonReentrant\n    {\n        _redeem(_amount, _minimumUnitAmount);\n    }\n\n    /**\n     * @dev Withdraw a supported asset and burn OUSD.\n     * @param _amount Amount of OUSD to burn\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function _redeem(uint256 _amount, uint256 _minimumUnitAmount) internal {\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        // Calculate redemption outputs\n        (\n            uint256[] memory outputs,\n            uint256 _backingValue\n        ) = _calculateRedeemOutputs(_amount);\n\n        // Check that OUSD is backed by enough assets\n        uint256 _totalSupply = oUSD.totalSupply();\n        if (maxSupplyDiff > 0) {\n            // Allow a max difference of maxSupplyDiff% between\n            // backing assets value and OUSD total supply\n            uint256 diff = _totalSupply.divPrecisely(_backingValue);\n            require(\n                (diff > 1e18 ? diff.sub(1e18) : uint256(1e18).sub(diff)) <=\n                    maxSupplyDiff,\n                \"Backing supply liquidity error\"\n            );\n        }\n\n        emit Redeem(msg.sender, _amount);\n\n        // Send outputs\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            if (outputs[i] == 0) continue;\n\n            IERC20 asset = IERC20(allAssets[i]);\n\n            if (asset.balanceOf(address(this)) >= outputs[i]) {\n                // Use Vault funds first if sufficient\n                asset.safeTransfer(msg.sender, outputs[i]);\n            } else {\n                address strategyAddr = assetDefaultStrategies[allAssets[i]];\n                if (strategyAddr != address(0)) {\n                    // Nothing in Vault, but something in Strategy, send from there\n                    IStrategy strategy = IStrategy(strategyAddr);\n                    strategy.withdraw(msg.sender, allAssets[i], outputs[i]);\n                } else {\n                    // Cant find funds anywhere\n                    revert(\"Liquidity error\");\n                }\n            }\n        }\n\n        if (_minimumUnitAmount > 0) {\n            uint256 unitTotal = 0;\n            for (uint256 i = 0; i < outputs.length; i++) {\n                uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);\n                unitTotal = unitTotal.add(\n                    outputs[i].scaleBy(int8(18 - assetDecimals))\n                );\n            }\n            require(\n                unitTotal >= _minimumUnitAmount,\n                \"Redeem amount lower than minimum\"\n            );\n        }\n\n        oUSD.burn(msg.sender, _amount);\n\n        // Until we can prove that we won't affect the prices of our assets\n        // by withdrawing them, this should be here.\n        // It's possible that a strategy was off on its asset total, perhaps\n        // a reward token sold for more or for less than anticipated.\n        if (_amount > rebaseThreshold && !rebasePaused) {\n            _rebase();\n        }\n    }\n\n    /**\n     * @notice Withdraw a supported asset and burn all OUSD.\n     * @param _minimumUnitAmount Minimum stablecoin units to receive in return\n     */\n    function redeemAll(uint256 _minimumUnitAmount)\n        external\n        whenNotCapitalPaused\n        nonReentrant\n    {\n        _redeem(oUSD.balanceOf(msg.sender), _minimumUnitAmount);\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     * @dev Allocate unallocated funds on Vault to strategies.\n     **/\n    function allocate() public whenNotCapitalPaused nonReentrant {\n        _allocate();\n    }\n\n    /**\n     * @notice Allocate unallocated funds on Vault to strategies.\n     * @dev Allocate unallocated funds on Vault to strategies.\n     **/\n    function _allocate() internal {\n        uint256 vaultValue = _totalValueInVault();\n        // Nothing in vault to allocate\n        if (vaultValue == 0) return;\n        uint256 strategiesValue = _totalValueInStrategies();\n        // We have a method that does the same as this, gas optimisation\n        uint256 calculatedTotalValue = vaultValue.add(strategiesValue);\n\n        // We want to maintain a buffer on the Vault so calculate a percentage\n        // modifier to multiply each amount being allocated by to enforce the\n        // vault buffer\n        uint256 vaultBufferModifier;\n        if (strategiesValue == 0) {\n            // Nothing in Strategies, allocate 100% minus the vault buffer to\n            // strategies\n            vaultBufferModifier = uint256(1e18).sub(vaultBuffer);\n        } else {\n            vaultBufferModifier = vaultBuffer.mul(calculatedTotalValue).div(\n                vaultValue\n            );\n            if (1e18 > vaultBufferModifier) {\n                // E.g. 1e18 - (1e17 * 10e18)/5e18 = 8e17\n                // (5e18 * 8e17) / 1e18 = 4e18 allocated from Vault\n                vaultBufferModifier = uint256(1e18).sub(vaultBufferModifier);\n            } else {\n                // We need to let the buffer fill\n                return;\n            }\n        }\n        if (vaultBufferModifier == 0) return;\n\n        // Iterate over all assets in the Vault and allocate the the appropriate\n        // strategy\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            IERC20 asset = IERC20(allAssets[i]);\n            uint256 assetBalance = asset.balanceOf(address(this));\n            // No balance, nothing to do here\n            if (assetBalance == 0) continue;\n\n            // Multiply the balance by the vault buffer modifier and truncate\n            // to the scale of the asset decimals\n            uint256 allocateAmount = assetBalance.mulTruncate(\n                vaultBufferModifier\n            );\n\n            address depositStrategyAddr = assetDefaultStrategies[address(\n                asset\n            )];\n\n            if (depositStrategyAddr != address(0) && allocateAmount > 0) {\n                IStrategy strategy = IStrategy(depositStrategyAddr);\n                // Transfer asset to Strategy and call deposit method to\n                // mint or take required action\n                asset.safeTransfer(address(strategy), allocateAmount);\n                strategy.deposit(address(asset), allocateAmount);\n            }\n        }\n\n        // Harvest for all reward tokens above reward liquidation threshold\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            IStrategy strategy = IStrategy(allStrategies[i]);\n            address rewardTokenAddress = strategy.rewardTokenAddress();\n            if (rewardTokenAddress != address(0)) {\n                uint256 liquidationThreshold = strategy\n                    .rewardLiquidationThreshold();\n                if (liquidationThreshold == 0) {\n                    // No threshold set, always harvest from strategy\n                    IVault(address(this)).harvest(allStrategies[i]);\n                } else {\n                    // Check balance against liquidation threshold\n                    // Note some strategies don't hold the reward token balance\n                    // on their contract so the liquidation threshold should be\n                    // set to 0\n                    IERC20 rewardToken = IERC20(rewardTokenAddress);\n                    uint256 rewardTokenAmount = rewardToken.balanceOf(\n                        allStrategies[i]\n                    );\n                    if (rewardTokenAmount >= liquidationThreshold) {\n                        IVault(address(this)).harvest(allStrategies[i]);\n                    }\n                }\n            }\n        }\n\n        // Trigger OGN Buyback\n        IBuyback(trusteeAddress).swap();\n    }\n\n    /**\n     * @dev Calculate the total value of assets held by the Vault and all\n     *      strategies and update the supply of OUSD.\n     */\n    function rebase() public whenNotRebasePaused nonReentrant {\n        _rebase();\n    }\n\n    /**\n     * @dev Calculate the total value of assets held by the Vault and all\n     *      strategies and update the supply of OUSD, optionaly sending a\n     *      portion of the yield to the trustee.\n     */\n    function _rebase() internal whenNotRebasePaused {\n        uint256 ousdSupply = oUSD.totalSupply();\n        if (ousdSupply == 0) {\n            return;\n        }\n        uint256 vaultValue = _totalValue();\n\n        // Yield fee collection\n        address _trusteeAddress = trusteeAddress; // gas savings\n        if (_trusteeAddress != address(0) && (vaultValue > ousdSupply)) {\n            uint256 yield = vaultValue.sub(ousdSupply);\n            uint256 fee = yield.mul(trusteeFeeBps).div(10000);\n            require(yield > fee, \"Fee must not be greater than yield\");\n            if (fee > 0) {\n                oUSD.mint(_trusteeAddress, fee);\n            }\n            emit YieldDistribution(_trusteeAddress, yield, fee);\n        }\n\n        // Only rachet OUSD supply upwards\n        ousdSupply = oUSD.totalSupply(); // Final check should use latest value\n        if (vaultValue > ousdSupply) {\n            oUSD.changeSupply(vaultValue);\n        }\n    }\n\n    /**\n     * @dev Determine the total value of assets held by the vault and its\n     *         strategies.\n     * @return uint256 value Total value in USD (1e18)\n     */\n    function totalValue() external view returns (uint256 value) {\n        value = _totalValue();\n    }\n\n    /**\n     * @dev Internal Calculate the total value of the assets held by the\n     *         vault and its strategies.\n     * @return uint256 value Total value in USD (1e18)\n     */\n    function _totalValue() internal view returns (uint256 value) {\n        return _totalValueInVault().add(_totalValueInStrategies());\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held in Vault.\n     * @return uint256 Total value in ETH (1e18)\n     */\n    function _totalValueInVault() internal view returns (uint256 value) {\n        for (uint256 y = 0; y < allAssets.length; y++) {\n            IERC20 asset = IERC20(allAssets[y]);\n            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);\n            uint256 balance = asset.balanceOf(address(this));\n            if (balance > 0) {\n                value = value.add(balance.scaleBy(int8(18 - assetDecimals)));\n            }\n        }\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held in Strategies.\n     * @return uint256 Total value in ETH (1e18)\n     */\n    function _totalValueInStrategies() internal view returns (uint256 value) {\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            value = value.add(_totalValueInStrategy(allStrategies[i]));\n        }\n    }\n\n    /**\n     * @dev Internal to calculate total value of all assets held by strategy.\n     * @param _strategyAddr Address of the strategy\n     * @return uint256 Total value in ETH (1e18)\n     */\n    function _totalValueInStrategy(address _strategyAddr)\n        internal\n        view\n        returns (uint256 value)\n    {\n        IStrategy strategy = IStrategy(_strategyAddr);\n        for (uint256 y = 0; y < allAssets.length; y++) {\n            uint256 assetDecimals = Helpers.getDecimals(allAssets[y]);\n            if (strategy.supportsAsset(allAssets[y])) {\n                uint256 balance = strategy.checkBalance(allAssets[y]);\n                if (balance > 0) {\n                    value = value.add(\n                        balance.scaleBy(int8(18 - assetDecimals))\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @param _asset Address of asset\n     * @return uint256 Balance of asset in decimals of asset\n     */\n    function checkBalance(address _asset) external view returns (uint256) {\n        return _checkBalance(_asset);\n    }\n\n    /**\n     * @notice Get the balance of an asset held in Vault and all strategies.\n     * @param _asset Address of asset\n     * @return uint256 Balance of asset in decimals of asset\n     */\n    function _checkBalance(address _asset)\n        internal\n        view\n        returns (uint256 balance)\n    {\n        IERC20 asset = IERC20(_asset);\n        balance = asset.balanceOf(address(this));\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            IStrategy strategy = IStrategy(allStrategies[i]);\n            if (strategy.supportsAsset(_asset)) {\n                balance = balance.add(strategy.checkBalance(_asset));\n            }\n        }\n    }\n\n    /**\n     * @notice Get the balance of all assets held in Vault and all strategies.\n     * @return uint256 Balance of all assets (1e18)\n     */\n    function _checkBalance() internal view returns (uint256 balance) {\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            uint256 assetDecimals = Helpers.getDecimals(allAssets[i]);\n            balance = balance.add(\n                _checkBalance(allAssets[i]).scaleBy(int8(18 - assetDecimals))\n            );\n        }\n    }\n\n    /**\n     * @notice Calculate the outputs for a redeem function, i.e. the mix of\n     * coins that will be returned\n     */\n    function calculateRedeemOutputs(uint256 _amount)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        (\n            uint256[] memory outputs,\n            uint256 totalValue\n        ) = _calculateRedeemOutputs(_amount);\n        return outputs;\n    }\n\n    /**\n     * @notice Calculate the outputs for a redeem function, i.e. the mix of\n     * coins that will be returned.\n     * @return Array of amounts respective to the supported assets\n     */\n    function _calculateRedeemOutputs(uint256 _amount)\n        internal\n        view\n        returns (uint256[] memory outputs, uint256 totalBalance)\n    {\n        // We always give out coins in proportion to how many we have,\n        // Now if all coins were the same value, this math would easy,\n        // just take the percentage of each coin, and multiply by the\n        // value to be given out. But if coins are worth more than $1,\n        // then we would end up handing out too many coins. We need to\n        // adjust by the total value of coins.\n        //\n        // To do this, we total up the value of our coins, by their\n        // percentages. Then divide what we would otherwise give out by\n        // this number.\n        //\n        // Let say we have 100 DAI at $1.06  and 200 USDT at $1.00.\n        // So for every 1 DAI we give out, we'll be handing out 2 USDT\n        // Our total output ratio is: 33% * 1.06 + 66% * 1.00 = 1.02\n        //\n        // So when calculating the output, we take the percentage of\n        // each coin, times the desired output value, divided by the\n        // totalOutputRatio.\n        //\n        // For example, withdrawing: 30 OUSD:\n        // DAI 33% * 30 / 1.02 = 9.80 DAI\n        // USDT = 66 % * 30 / 1.02 = 19.60 USDT\n        //\n        // Checking these numbers:\n        // 9.80 DAI * 1.06 = $10.40\n        // 19.60 USDT * 1.00 = $19.60\n        //\n        // And so the user gets $10.40 + $19.60 = $30 worth of value.\n\n        uint256 assetCount = getAssetCount();\n        uint256[] memory assetPrices = _getAssetPrices(true);\n        uint256[] memory assetBalances = new uint256[](assetCount);\n        uint256[] memory assetDecimals = new uint256[](assetCount);\n        uint256 totalOutputRatio = 0;\n        outputs = new uint256[](assetCount);\n\n        // Calculate redeem fee\n        if (redeemFeeBps > 0) {\n            uint256 redeemFee = _amount.mul(redeemFeeBps).div(10000);\n            _amount = _amount.sub(redeemFee);\n        }\n\n        // Calculate assets balances and decimals once,\n        // for a large gas savings.\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            uint256 balance = _checkBalance(allAssets[i]);\n            uint256 decimals = Helpers.getDecimals(allAssets[i]);\n            assetBalances[i] = balance;\n            assetDecimals[i] = decimals;\n            totalBalance = totalBalance.add(\n                balance.scaleBy(int8(18 - decimals))\n            );\n        }\n        // Calculate totalOutputRatio\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            uint256 price = assetPrices[i];\n            // Never give out more than one\n            // stablecoin per dollar of OUSD\n            if (price < 1e18) {\n                price = 1e18;\n            }\n            uint256 ratio = assetBalances[i]\n                .scaleBy(int8(18 - assetDecimals[i]))\n                .mul(price)\n                .div(totalBalance);\n            totalOutputRatio = totalOutputRatio.add(ratio);\n        }\n        // Calculate final outputs\n        uint256 factor = _amount.divPrecisely(totalOutputRatio);\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            outputs[i] = assetBalances[i].mul(factor).div(totalBalance);\n        }\n    }\n\n    /**\n     * @notice Get an array of the supported asset prices in USD.\n     * @return uint256[] Array of asset prices in USD (1e18)\n     */\n    function _getAssetPrices(bool useMax)\n        internal\n        view\n        returns (uint256[] memory assetPrices)\n    {\n        assetPrices = new uint256[](getAssetCount());\n\n        IOracle oracle = IOracle(priceProvider);\n        // Price from Oracle is returned with 8 decimals\n        // _amount is in assetDecimals\n        for (uint256 i = 0; i < allAssets.length; i++) {\n            assetPrices[i] = oracle.price(allAssets[i]).scaleBy(int8(18 - 8));\n        }\n    }\n\n    /***************************************\n                    Utils\n    ****************************************/\n\n    /**\n     * @dev Return the number of assets suppported by the Vault.\n     */\n    function getAssetCount() public view returns (uint256) {\n        return allAssets.length;\n    }\n\n    /**\n     * @dev Return all asset addresses in order\n     */\n    function getAllAssets() external view returns (address[] memory) {\n        return allAssets;\n    }\n\n    /**\n     * @dev Return the number of strategies active on the Vault.\n     */\n    function getStrategyCount() external view returns (uint256) {\n        return allStrategies.length;\n    }\n\n    function isSupportedAsset(address _asset) external view returns (bool) {\n        return assets[_asset].isSupported;\n    }\n\n    /**\n     * @dev Falldown to the admin implementation\n     * @notice This is a catch all for all functions not declared in core\n     */\n    function() external payable {\n        bytes32 slot = adminImplPosition;\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize)\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas, sload(slot), 0, calldatasize, 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize)\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize)\n                }\n                default {\n                    return(0, returndatasize)\n                }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/contracts/liquidity/LiquidityReward.sol",
      "content": "pragma solidity 0.5.11;\n\nimport {\n    Initializable\n} from \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\n\n//\n// LiquidityReward contract doles out reward for liquidity\n//   base off of Sushiswap's MasterChef: https://github.com/sushiswap/sushiswap/blob/master/contracts/MasterChef.sol\n//\ncontract LiquidityReward is Initializable, Governable {\n    using SafeMath for uint256;\n    using StableMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount; // How many LP tokens the user has provided.\n        int256 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of Reward Tokens\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accRewardPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accRewardPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n        //\n        // NOTE: rewardDebt can go negative because we allow withdraws without claiming the reward\n        //       in that case we owe the account holder some reward.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken; // Address of LP token contract.\n        uint256 lastRewardBlock; // Last block number that Reward calculation occurs.\n        uint256 accRewardPerShare; // Accumulated Reward per share in reward precision. See below.\n    }\n\n    // The Reward token\n    IERC20 public reward;\n\n    // Reward tokens created per block in 1e18 precision.\n    uint256 public rewardPerBlock;\n\n    // Info on the LP.\n    PoolInfo public pool;\n    // total Reward debt, useful to calculate if we have enough to pay out all rewards\n    int256 public totalRewardDebt;\n    // Info of each user that stakes LP tokens.\n    mapping(address => UserInfo) public userInfo;\n    // The block number when Liquidity rewards ends.\n    uint256 public endBlock;\n\n    event CampaignStarted(\n        uint256 rewardRate,\n        uint256 startBlock,\n        uint256 endBlock\n    );\n    event CampaignStopped(uint256 endBlock);\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Claim(address indexed user, uint256 amount);\n\n    /**\n     * Initializer for setting up Liquidity Reward internal state.\n     * @param _reward Address of the reward token(OGN)\n     * @param _lpToken Address of the LP token(Uniswap Pair)\n     */\n    function initialize(IERC20 _reward, IERC20 _lpToken)\n        external\n        onlyGovernor\n        initializer\n    {\n        reward = _reward;\n        pool.lpToken = _lpToken;\n        pool.lastRewardBlock = block.number;\n    }\n\n    /**\n     * @dev start a new reward campaign.\n     *      This will calculate all rewards up to the current block at the old rate.\n     *      This ensures that we pay everyone at the promised rate before update to the new rate.\n     * @param _rewardPerBlock Amount rewarded per block\n     * @param _startBlock Block number that we want to start the rewards at (0 for current block)\n     * @param _numBlocks number of blocks that the campaign should last\n     */\n    function startCampaign(\n        uint256 _rewardPerBlock,\n        uint256 _startBlock,\n        uint256 _numBlocks\n    ) external onlyGovernor {\n        // Calculate up to the current block at the current rate for everyone.\n        updatePool();\n\n        // total Pending calculated at the current pool rate\n        uint256 totalPending = subDebt(\n            pool.accRewardPerShare.mulTruncate(\n                pool.lpToken.balanceOf(address(this))\n            ),\n            totalRewardDebt\n        );\n\n        require(\n            reward.balanceOf(address(this)) >=\n                _rewardPerBlock.mul(_numBlocks).add(totalPending),\n            \"startCampaign: insufficient rewards\"\n        );\n\n        uint256 startBlock = _startBlock;\n        if (startBlock == 0) {\n            // start block number isn't given so we start at the current\n            startBlock = block.number;\n        }\n        require(\n            startBlock >= block.number,\n            \"startCampaign: _startBlock can't be in the past\"\n        );\n        endBlock = startBlock.add(_numBlocks);\n        // we don't start accrue until the startBlock\n        pool.lastRewardBlock = startBlock;\n        // new blocks start at the new reward rate\n        rewardPerBlock = _rewardPerBlock;\n        emit CampaignStarted(rewardPerBlock, startBlock, endBlock);\n    }\n\n    function stopCampaign() external onlyGovernor {\n        //calculate until current pool\n        updatePool();\n        //end the block here (the CampaignMultiplier will be zero)\n        endBlock = block.number;\n        emit CampaignStopped(endBlock);\n    }\n\n    function campaignActive() external view returns (bool) {\n        return endBlock > block.number && block.number >= pool.lastRewardBlock;\n    }\n\n    function balanceOf(address _account) external view returns (uint256) {\n        return userInfo[_account].amount;\n    }\n\n    /**\n     * @dev calculate the number of blocks since we last updated\n     *       within start and end as constraints\n     * @param _to Block number of the ending point.\n     * @return multiplier Multiplier over the given _from to _to block.\n     */\n    function getCampaignMultiplier(uint256 _to)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 from = pool.lastRewardBlock;\n        if (from > endBlock) {\n            return 0;\n        } else {\n            return (_to < endBlock ? _to : endBlock).sub(from);\n        }\n    }\n\n    /**\n     * @dev View function to see pending rewards for each account on frontend.\n     * @param _user Address of the account we're looking up.\n     * @return reward Total rewards owed to this account.\n     */\n    function pendingRewards(address _user) external view returns (uint256) {\n        UserInfo storage user = userInfo[_user];\n        return _pendingRewards(user);\n    }\n\n    function _pendingRewards(UserInfo storage user)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        if (block.number > pool.lastRewardBlock) {\n            uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n            if (lpSupply != 0) {\n                uint256 multiplier = getCampaignMultiplier(block.number);\n                uint256 incReward = multiplier.mul(rewardPerBlock);\n                accRewardPerShare = accRewardPerShare.add(\n                    incReward.divPrecisely(lpSupply)\n                );\n            }\n        }\n        return\n            subDebt(\n                user.amount.mulTruncate(accRewardPerShare),\n                user.rewardDebt\n            );\n    }\n\n    /**\n     * @dev View function to see total outstanding rewards for the entire contract.\n     *      This is how much is owed when everyone pulls out.\n     * @return reward Total rewards owed to everyone.\n     */\n    function totalOutstandingRewards() external view returns (uint256) {\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint256 multiplier = getCampaignMultiplier(block.number);\n            uint256 incReward = multip"
    }
  ]
}