{
  "Title": "[H-02] Malicious Users Can Transfer Vault Collateral To Other Accounts To Extract Additional Yield From The Protocol",
  "Content": "_Submitted by leastwood_\n\n`ConvexYieldWrapper.sol` is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the `Ladle.sol` contract's `batch()` function which:\n\n*   Approves Ladle to move the tokens.\n*   Transfers the tokens to `ConvexYieldWrapper.sol`.\n*   Wraps/stakes these tokens.\n*   Updates accounting and produces debt tokens within `Ladle.sol`.\n\n`_getDepositedBalance()` takes into consideration the user's total collateral stored in all of their owned vaults. However, as a vault owner, you are allowed to give the vault to another user, move collateral between vaults and add/remove collateral. Therefore, it is possible to manipulate the result of this function by checkpointing one user's balance at a given time, transferring ownership to another user and then create a new checkpoint with this user.\n\nAs a result, a user is able to generate protocol yield multiple times over on a single collateral amount. This can be abused to effectively extract all protocol yield.\n\n#### Proof of Concept\n\nConsider the following exploit scenario:\n\n*   Alice owns a vault which has 100 tokens worth of collateral.\n*   At that point in time, `_getDepositedBalance()` returns 100 as its result. A checkpoint has also been made on this balance, giving Alice claim to her fair share of the rewards.\n*   Alice then calls `Ladle.give()`, transferring the ownership of the vault to Bob and calls `ConvexYieldWrapper.addVault()`.\n*   Bob is able to call `user_checkpoint()` and effectively update their checkpointed balance.\n*   At this point in time, both Alice and Bob have claim to any yield generated by the protocol, however, there is only one vault instance that holds the underlying collateral.\n\n<https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexYieldWrapper.sol#L100-L120>\n```solidity\nfunction _getDepositedBalance(address account_) internal view override returns (uint256) {\n    if (account_ == address(0) || account_ == collateralVault) {\n        return 0;\n    }\n\n    bytes12[] memory userVault = vaults[account_];\n\n    //add up all balances of all vaults registered in the wrapper and owned by the account\n    uint256 collateral;\n    DataTypes.Balances memory balance;\n    uint256 userVaultLength = userVault.length;\n    for (uint256 i = 0; i < userVaultLength; i++) {\n        if (cauldron.vaults(userVault[i]).owner == account_) {\n            balance = cauldron.balances(userVault[i]);\n            collateral = collateral + balance.ink;\n        }\n    }\n\n    //add to balance of this token\n    return _balanceOf[account_] + collateral;\n}\n```\n\n#### Tools Used\n\nManual code review.\nDiscussion/confirmation with the Yield Protocol team.\n\n#### Recommended Mitigation Steps\n\nEnsure that any change to a vault will correctly checkpoint the previous and new vault owner. The affected actions include but are not limited to; transferring ownership of a vault to a new account, transferring collateral to another vault and adding/removing collateral to/from a vault.\n\n**[iamsahu (Yield) confirmed](https://github.com/code-423n4/2022-01-yield-findings/issues/89)**\n\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-01-yield-findings/issues/89#issuecomment-1044656259):**\n > The warden identified a way to sidestep the accounting in the `ConvexYieldWrapper`.\n> \n> Because `ConvexYieldWrapper` takes lazy accounting, transferring vaults at the `Ladle` level allows to effectively register the same vault under multiple accounts, which ultimately allow to steal more yield than expected.\n> \n> While the loss of yield can be classified as a medium severity, the fact that the warden was able to break the accounting invariants of the `ConvexYieldWrapper` leads me to raise the severity to high\n> \n> Ultimately mitigation will require to `_checkpoint` also when vault operations happen (especially transfer), this may require a rethinking at the Ladle level as the reason why the warden was able to sidestep the checkpoint is because the `Ladle` doesn't notify the `Wrapper` of any vault transfers\n\n**[alcueca (Yield) commented](https://github.com/code-423n4/2022-01-yield-findings/issues/89#issuecomment-1046642319):**\n > Yes, that's right. To fix this issue we will deploy a separate Ladle to deal specifically with convex tokens. The fix will probably involve removing `stir` and `give` instead of notifying the wrapper, but we'll see.\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-01-yield-convex-contest",
  "Code": [
    {
      "filename": "contracts/ConvexYieldWrapper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/vault-interfaces/ICauldron.sol\";\nimport \"@yield-protocol/vault-interfaces/DataTypes.sol\";\nimport \"./ConvexStakingWrapper.sol\";\n\n/// @title Convex staking wrapper for Yield platform\n/// @notice Enables use of convex LP positions as collateral while still receiving rewards\ncontract ConvexYieldWrapper is ConvexStakingWrapper {\n    using TransferHelper for IERC20;\n\n    /// @notice Mapping to keep track of the user & their vaults\n    mapping(address => bytes12[]) public vaults;\n\n    ICauldron public cauldron;\n\n    /// @notice Event called when a vault is added for a user\n    /// @param account The account for which vault is added\n    /// @param vaultId The vaultId to be added\n    event VaultAdded(address indexed account, bytes12 indexed vaultId);\n\n    /// @notice Event called when a vault is removed for a user\n    /// @param account The account for which vault is removed\n    /// @param vaultId The vaultId to be removed\n    event VaultRemoved(address indexed account, bytes12 indexed vaultId);\n\n    /// @notice Event called when tokens are rescued from the contract\n    /// @param token Address of the token being rescued\n    /// @param amount Amount of the token being rescued\n    /// @param destination Address to which the rescued tokens have been sent\n    event Recovered(address indexed token, uint256 amount, address indexed destination);\n\n    constructor(\n        address curveToken_,\n        address convexToken_,\n        address convexPool_,\n        uint256 poolId_,\n        address join_,\n        ICauldron cauldron_,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) ConvexStakingWrapper(curveToken_, convexToken_, convexPool_, poolId_, join_, name, symbol, decimals) {\n        cauldron = cauldron_;\n    }\n\n    /// @notice Points the collateral vault to the join storing the wrappedConvex\n    /// @param join_ Join which will store the wrappedConvex of the user\n    function point(address join_) external auth {\n        collateralVault = join_;\n    }\n\n    /// @notice Adds a vault to the user's vault list\n    /// @param vaultId The id of the vault being added\n    function addVault(bytes12 vaultId) external {\n        address account = cauldron.vaults(vaultId).owner;\n        require(account != address(0), \"No owner for the vault\");\n        bytes12[] storage vaults_ = vaults[account];\n        uint256 vaultsLength = vaults_.length;\n\n        for (uint256 i = 0; i < vaultsLength; i++) {\n            require(vaults_[i] != vaultId, \"Vault already added\");\n        }\n        vaults_.push(vaultId);\n        vaults[account] = vaults_;\n        emit VaultAdded(account, vaultId);\n    }\n\n    /// @notice Remove a vault from the user's vault list\n    /// @param vaultId The id of the vault being removed\n    /// @param account The user from whom the vault needs to be removed\n    function removeVault(bytes12 vaultId, address account) public {\n        address owner = cauldron.vaults(vaultId).owner;\n        if (account != owner) {\n            bytes12[] storage vaults_ = vaults[account];\n            uint256 vaultsLength = vaults_.length;\n            bool found;\n            for (uint256 i = 0; i < vaultsLength; i++) {\n                if (vaults_[i] == vaultId) {\n                    bool isLast = i == vaultsLength - 1;\n                    if (!isLast) {\n                        vaults_[i] = vaults_[vaultsLength - 1];\n                    }\n                    vaults_.pop();\n                    found = true;\n                    emit VaultRemoved(account, vaultId);\n                    break;\n                }\n            }\n            require(found, \"Vault not found\");\n            vaults[account] = vaults_;\n        }\n    }\n\n    /// @notice Get user's balance of collateral deposited in various vaults\n    /// @param account_ User's address for which balance is requested\n    /// @return User's balance of collateral\n    function _getDepositedBalance(address account_) internal view override returns (uint256) {\n        if (account_ == address(0) || account_ == collateralVault) {\n            return 0;\n        }\n\n        bytes12[] memory userVault = vaults[account_];\n\n        //add up all balances of all vaults registered in the wrapper and owned by the account\n        uint256 collateral;\n        DataTypes.Balances memory balance;\n        uint256 userVaultLength = userVault.length;\n        for (uint256 i = 0; i < userVaultLength; i++) {\n            if (cauldron.vaults(userVault[i]).owner == account_) {\n                balance = cauldron.balances(userVault[i]);\n                collateral = collateral + balance.ink;\n            }\n        }\n\n        //add to balance of this token\n        return _balanceOf[account_] + collateral;\n    }\n\n    /// @dev Wrap convex token held by this contract and forward it to the `to` address\n    /// @param to_ Address to send the wrapped token to\n    /// @param from_ Address of the user whose token is being wrapped\n    function wrap(address to_, address from_) external {\n        require(!isShutdown, \"shutdown\");\n        uint256 amount_ = IERC20(convexToken).balanceOf(address(this));\n        require(amount_ > 0, \"No convex token to wrap\");\n\n        _checkpoint([address(0), from_]);\n        _mint(to_, amount_);\n        IRewardStaking(convexPool).stake(amount_);\n\n        emit Deposited(msg.sender, to_, amount_, false);\n    }\n\n    /// @dev Unwrap Wrapped convex token held by this contract, and send the unwrapped convex token to the `to` address\n    /// @param to_ Address to send the unwrapped convex token to\n    function unwrap(address to_) external {\n        require(!isShutdown, \"shutdown\");\n        uint256 amount_ = _balanceOf[address(this)];\n        require(amount_ > 0, \"No wrapped convex token\");\n\n        _checkpoint([address(0), to_]);\n        _burn(address(this), amount_);\n        IRewardStaking(convexPool).withdraw(amount_, false);\n        IERC20(convexToken).safeTransfer(to_, amount_);\n\n        emit Withdrawn(to_, amount_, false);\n    }\n\n    /// @notice A simple function to recover any ERC20 tokens\n    /// @param token_ Address of the token being rescued\n    /// @param amount_ Amount of the token being rescued\n    /// @param destination_ Address to which the rescued tokens have been sent\n    function recoverERC20(\n        address token_,\n        uint256 amount_,\n        address destination_\n    ) external auth {\n        require(amount_ != 0, \"amount is 0\");\n        IERC20(token_).safeTransfer(destination_, amount_);\n        emit Recovered(token_, amount_, destination_);\n    }\n\n    /// @notice A function to shutdown the contract & withdraw the staked convex tokens & transfer rewards\n    /// @param rescueAddress_ Address to which the rescued tokens would be sent to\n    function shutdownAndRescue(address rescueAddress_) external auth {\n        uint256 balance_ = IRewardStaking(convexPool).balanceOf(address(this));\n\n        if (balance_ != 0) {\n            // Withdraw the convex tokens from the convex pool\n            IRewardStaking(convexPool).withdraw(balance_, true);\n\n            // Transfer the withdrawn convex tokens to rescue address\n            IERC20(convexToken).safeTransfer(rescueAddress_, balance_);\n        }\n        // Shutdown the contract\n        isShutdown = true;\n    }\n}"
    }
  ]
}