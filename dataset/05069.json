{
  "Title": "[09] Link broken",
  "Content": "\n[`TWAML::sqrt`](https://github.com/Tapioca-DAO/tap-token/blob/20a83b1d2d5577653610a6c3879dff9df4968345/contracts/options/twAML.sol#L144):\n\n```solidity\nFile: tap-token/contracts/options/twAML.sol\n\n144:    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n```\n\nIt's renamed to [Heron's_method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Heron's_method).\n\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/options/twAML.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract FullMath {\n    // https://xn--2-umb.com/21/muldiv/\n    function muldiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // Handle division by zero\n            require(denominator > 0);\n\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Short circuit 256 by 256 division\n            // This saves gas when a * b is small, at the cost of making the\n            // large case a bit more expensive. Depending on your use case you\n            // may want to remove this short circuit and always go through the\n            // 512 bit path.\n            if (prod1 == 0) {\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Handle overflow, the result must be < 2**256\n            require(prod1 < denominator);\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            // Note mulmod(_, _, 0) == 0\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1 unless denominator is zero, then twos is zero.\n            uint256 twos = denominator & (~denominator + 1);\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            // If denominator is zero the inverse starts with 2\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson itteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n            // If denominator is zero, inv is now 128\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n}\n\nabstract contract TWAML is FullMath {\n    /// @notice Compute the minimum weight to participate in the twAML voting mechanism\n    /// @param _totalWeight The total weight of the twAML system\n    /// @param _minWeightFactor The minimum weight factor in BPS\n    function computeMinWeight(uint256 _totalWeight, uint256 _minWeightFactor) internal pure returns (uint256) {\n        uint256 mul = (_totalWeight * _minWeightFactor);\n        return mul >= 1e4 ? mul / 1e4 : _totalWeight;\n    }\n\n    function computeMagnitude(uint256 _timeWeight, uint256 _cumulative) internal pure returns (uint256) {\n        return sqrt(_timeWeight * _timeWeight + _cumulative * _cumulative) - _cumulative;\n    }\n\n    function computeTarget(uint256 _dMin, uint256 _dMax, uint256 _magnitude, uint256 _cumulative)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (_cumulative == 0) {\n            return _dMax;\n        }\n        uint256 target = (_magnitude * _dMax) / _cumulative;\n        target = target > _dMax ? _dMax : target < _dMin ? _dMin : target;\n        return target;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}"
    }
  ]
}