{
  "Title": "[H-01] Users will be able to purchase fewer NFTs than the project had anticipated",
  "Content": "\nUsers will be able to purchase fewer NFTs than the project had anticipated. The project had expected that users would be able to purchase a range of variations using both text and emoji characters. However, in reality, users will only be able to purchase a range of variations using emoji characters.\n\nFor example, the list of characters available for users to choose from is as follows\n![image](https://i.ibb.co/NjnD4Tf/Screenshot-from-2023-03-20-00-22-32.png)\n\nFor instance, if a user chooses to mint an NFT namespace using font class 2 and the single letter ð’¶, then theoretically all other users should be able to mint font class 0 using the first emoji in the list, font class 1 using the single letter \"a,\" font class 3 using the single letter ð“ª, and so on, the first letter on every class will be. However, in reality, they will not be able to do so.\n\nI consider this to be a critical issue because the project may not be able to sell as many NFTs as expected, potentially resulting in a loss of funds.\n\nHere is an how nft name and their svg will look like from what I described above. As you can see emoji replaced letters in the name.\n\n![image](https://i.ibb.co/L8NDWgy/Screenshot-from-2023-03-20-17-35-49.png)\n\nThis is a function that creates namespace out of tray.\n\n```solidity\ncanto-namespace-protocol/src/Namespace.sol#L110\n    function fuse(CharacterData[] calldata _characterList) external {\n        uint256 numCharacters = _characterList.length;\n        if (numCharacters > 13 || numCharacters == 0) revert InvalidNumberOfCharacters(numCharacters);\n        uint256 fusingCosts = 2**(13 - numCharacters) * 1e18;\n        SafeTransferLib.safeTransferFrom(note, msg.sender, revenueAddress, fusingCosts);\n        uint256 namespaceIDToMint = ++nextNamespaceIDToMint;\n        Tray.TileData[] storage nftToMintCharacters = nftCharacters[namespaceIDToMint];\n        bytes memory bName = new bytes(numCharacters * 33); // Used to convert into a string. Can be 33 times longer than the string at most (longest zalgo characters is 33 bytes)\n        uint256 numBytes;\n        // Extract unique trays for burning them later on\n        uint256 numUniqueTrays;\n        uint256[] memory uniqueTrays = new uint256[](_characterList.length);\n        for (uint256 i; i < numCharacters; ++i) {\n            bool isLastTrayEntry = true;\n            uint256 trayID = _characterList[i].trayID;\n            uint8 tileOffset = _characterList[i].tileOffset;\n            // Check for duplicate characters in the provided list. 1/2 * n^2 loop iterations, but n is bounded to 13 and we do not perform any storage operations\n            for (uint256 j = i + 1; j < numCharacters; ++j) {\n                if (_characterList[j].trayID == trayID) {\n                    isLastTrayEntry = false;\n                    if (_characterList[j].tileOffset == tileOffset) revert FusingDuplicateCharactersNotAllowed();\n                }\n            }\n            Tray.TileData memory tileData = tray.getTile(trayID, tileOffset); // Will revert if tileOffset is too high\n            uint8 characterModifier = tileData.characterModifier;\n\n            if (tileData.fontClass != 0 && _characterList[i].skinToneModifier != 0) {\n                revert CannotFuseCharacterWithSkinTone();\n            }\n            \n            if (tileData.fontClass == 0) {\n                // Emoji\n                characterModifier = _characterList[i].skinToneModifier;\n            }\n            bytes memory charAsBytes = Utils.characterToUnicodeBytes(0, tileData.characterIndex, characterModifier);\n... \n```\n\n[canto-namespace-protocol/src/Namespace.sol#L110](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-namespace-protocol/src/Namespace.sol#L110)\n\nThere is a bug in this line of code where a character is retrieved from tile data. Instead of passing `tileData.fontClass`, we are passing `0`.\n\n```solidity\n            bytes memory charAsBytes = Utils.characterToUnicodeBytes(0, tileData.characterIndex, characterModifier);\n```\n\nDue to this bug, the names for all four different font classes will be the same. As a result, they will point to an existing namespace, and later, there will be a check for the existence of that name (token) using NameAlreadyRegistered.\n\n```solidity\n        string memory nameToRegister = string(bName);\n        uint256 currentRegisteredID = nameToToken[nameToRegister];\n        if (currentRegisteredID != 0) revert NameAlreadyRegistered(currentRegisteredID);\n```\n\n### Proof of Concept\n\nHere is the test that you can run\n\n```solidity\n    function testFailMintSameCharacterIndex() public {\n        address user = user1;\n        note.mint(user, 10000e18);\n        endPrelaunchAndBuyOne(user);\n\n        uint256[] memory trayIds = buyTray(user, 3);\n        vm.startPrank(user);\n        note.approve(address(ns), type(uint256).max);\n        Namespace.CharacterData[] memory list = new Namespace.CharacterData[](\n            1\n        );\n//      fuse tile with fontClass=8,characterIndex=1\n        list[0] = Namespace.CharacterData(trayIds[1], 4, 0);\n        Tray.TileData memory tileData = tray.getTile(trayIds[1], 4);\n        console.log(tileData.characterIndex);//1\n        console.log(tileData.fontClass);//8\n        ns.fuse(list);\n\n//      fuse tile with fontClass=4,characterIndex=1\n        list[0] = Namespace.CharacterData(trayIds[2], 3, 0);\n        tileData = tray.getTile(trayIds[2], 3);\n        console.log(tileData.characterIndex);//1\n        console.log(tileData.fontClass);//4\n        vm.expectRevert(\n            abi.encodeWithSelector(Namespace.NameAlreadyRegistered.selector, 1)\n        );\n        ns.fuse(list);\n    }\n```\n\n### Tools Used\n\nManual review, forge tests\n\n### Recommended Mitigation Steps\n\nPass font class instead of 0\n\n```diff\n-            bytes memory charAsBytes = Utils.characterToUnicodeBytes(0, tileData.characterIndex, characterModifier);\n+            bytes memory charAsBytes = Utils.characterToUnicodeBytes(tileData.fontClass, tileData.characterIndex, characterModifier);\n```\n\n**[OpenCoreCH (Canto Identity) confirmed and commented](https://github.com/code-423n4/2023-03-canto-identity-findings/issues/117#issuecomment-1489210777):**\n > Agree, leftover from earlier, will be changed.\n\n\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2023-03-canto-identity-subprotocols-contest",
  "Code": [
    {
      "filename": "canto-namespace-protocol/src/Namespace.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\nimport \"./Tray.sol\";\nimport \"./Utils.sol\";\nimport \"../interface/Turnstile.sol\";\n\ncontract Namespace is ERC721, Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Reference to the Tray NFT\n    Tray public immutable tray;\n\n    /// @notice Reference to the $NOTE TOKEN\n    ERC20 public note;\n\n    /// @notice Wallet that receives the revenue\n    address private revenueAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice References the tile for fusing by specifying the tray ID and the index within the tray\n    struct CharacterData {\n        /// @notice ID of the Tray NFT\n        uint256 trayID;\n        /// @notice Offset of the tile within the tray. Valid values 0..TILES_PER_TRAY - 1\n        uint8 tileOffset;\n        /// @notice Emoji modifier for the skin tone. Can have values of 0 (yellow) and 1 - 5 (light to dark). Only supported by some emojis\n        uint8 skinToneModifier;\n    }\n\n    /// @notice Next Namespace ID to mint. We start with minting at ID 1\n    uint256 public nextNamespaceIDToMint;\n\n    /// @notice Maps names to NFT IDs\n    mapping(string => uint256) public nameToToken;\n\n    /// @notice Maps NFT IDs to (ASCII) names\n    mapping(uint256 => string) public tokenToName;\n\n    /// @notice Stores the character data of an NFT\n    mapping(uint256 => Tray.TileData[]) private nftCharacters;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event NamespaceFused(address indexed fuser, uint256 indexed namespaceId, string indexed name);\n    event RevenueAddressUpdated(address indexed oldRevenueAddress, address indexed newRevenueAddress);\n    event NoteAddressUpdate(address indexed oldNoteAddress, address indexed newNoteAddress);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error CallerNotAllowedToFuse();\n    error CallerNotAllowedToBurn();\n    error InvalidNumberOfCharacters(uint256 numCharacters);\n    error FusingDuplicateCharactersNotAllowed();\n    error NameAlreadyRegistered(uint256 nftID);\n    error TokenNotMinted(uint256 tokenID);\n    error CannotFuseCharacterWithSkinTone();\n\n    /// @notice Sets the reference to the tray\n    /// @param _tray Address of the tray contract\n    /// @param _note Address of the $NOTE token\n    /// @param _revenueAddress Adress to send the revenue to\n    constructor(\n        address _tray,\n        address _note,\n        address _revenueAddress\n    ) ERC721(\"Namespace\", \"NS\") Owned(msg.sender) {\n        tray = Tray(_tray);\n        note = ERC20(_note);\n        revenueAddress = _revenueAddress;\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @param _id ID to query for\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (_ownerOf[_id] == address(0)) revert TokenNotMinted(_id);\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"name\": \"',\n                        tokenToName[_id],\n                        '\", \"image\": \"data:image/svg+xml;base64,',\n                        Base64.encode(bytes(Utils.generateSVG(nftCharacters[_id], false))),\n                        '\"}'\n                    )\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice Fuse a new Namespace NFT with the referenced tiles\n    /// @param _characterList The tiles to use for the fusing\n    function fuse(CharacterData[] calldata _characterList) external {\n        uint256 numCharacters = _characterList.length;\n        if (numCharacters > 13 || numCharacters == 0) revert InvalidNumberOfCharacters(numCharacters);\n        uint256 fusingCosts = 2**(13 - numCharacters) * 1e18;\n        SafeTransferLib.safeTransferFrom(note, msg.sender, revenueAddress, fusingCosts);\n        uint256 namespaceIDToMint = ++nextNamespaceIDToMint;\n        Tray.TileData[] storage nftToMintCharacters = nftCharacters[namespaceIDToMint];\n        bytes memory bName = new bytes(numCharacters * 33); // Used to convert into a string. Can be 33 times longer than the string at most (longest zalgo characters is 33 bytes)\n        uint256 numBytes;\n        // Extract unique trays for burning them later on\n        uint256 numUniqueTrays;\n        uint256[] memory uniqueTrays = new uint256[](_characterList.length);\n        for (uint256 i; i < numCharacters; ++i) {\n            bool isLastTrayEntry = true;\n            uint256 trayID = _characterList[i].trayID;\n            uint8 tileOffset = _characterList[i].tileOffset;\n            // Check for duplicate characters in the provided list. 1/2 * n^2 loop iterations, but n is bounded to 13 and we do not perform any storage operations\n            for (uint256 j = i + 1; j < numCharacters; ++j) {\n                if (_characterList[j].trayID == trayID) {\n                    isLastTrayEntry = false;\n                    if (_characterList[j].tileOffset == tileOffset) revert FusingDuplicateCharactersNotAllowed();\n                }\n            }\n            Tray.TileData memory tileData = tray.getTile(trayID, tileOffset); // Will revert if tileOffset is too high\n            uint8 characterModifier = tileData.characterModifier;\n\n            if (tileData.fontClass != 0 && _characterList[i].skinToneModifier != 0) {\n                revert CannotFuseCharacterWithSkinTone();\n            }\n            \n            if (tileData.fontClass == 0) {\n                // Emoji\n                characterModifier = _characterList[i].skinToneModifier;\n            }\n            bytes memory charAsBytes = Utils.characterToUnicodeBytes(0, tileData.characterIndex, characterModifier);\n            tileData.characterModifier = characterModifier;\n            uint256 numBytesChar = charAsBytes.length;\n            for (uint256 j; j < numBytesChar; ++j) {\n                bName[numBytes + j] = charAsBytes[j];\n            }\n            numBytes += numBytesChar;\n            nftToMintCharacters.push(tileData);\n            // We keep track of the unique trays NFTs (for burning them) and only check the owner once for the last occurence of the tray\n            if (isLastTrayEntry) {\n                uniqueTrays[numUniqueTrays++] = trayID;\n                // Verify address is allowed to fuse\n                address trayOwner = tray.ownerOf(trayID);\n                if (\n                    trayOwner != msg.sender &&\n                    tray.getApproved(trayID) != msg.sender &&\n                    !tray.isApprovedForAll(trayOwner, msg.sender)\n                ) revert CallerNotAllowedToFuse();\n            }\n        }\n        // Set array to the real length (in bytes) to avoid zero bytes in the end when doing the string conversion\n        assembly {\n            mstore(bName, numBytes)\n        }\n        string memory nameToRegister = string(bName);\n        uint256 currentRegisteredID = nameToToken[nameToRegister];\n        if (currentRegisteredID != 0) revert NameAlreadyRegistered(currentRegisteredID);\n        nameToToken[nameToRegister] = namespaceIDToMint;\n        tokenToName[namespaceIDToMint] = nameToRegister;\n\n        for (uint256 i; i < numUniqueTrays; ++i) {\n            tray.burn(uniqueTrays[i]);\n        }\n        _mint(msg.sender, namespaceIDToMint);\n        // Although _mint already emits an event, we additionally emit one because of the name\n        emit NamespaceFused(msg.sender, namespaceIDToMint, nameToRegister);\n    }\n\n    /// @notice Burn a specified Namespace NFT\n    /// @param _id Namespace NFT ID\n    function burn(uint256 _id) external {\n        address nftOwner = ownerOf(_id);\n        if (nftOwner != msg.sender && getApproved[_id] != msg.sender && !isApprovedForAll[nftOwner][msg.sender])\n            revert CallerNotAllowedToBurn();\n        string memory associatedName = tokenToName[_id];\n        delete tokenToName[_id];\n        delete nameToToken[associatedName];\n        _burn(_id);\n    }\n\n    /// @notice Change the address of the $NOTE token\n    /// @param _newNoteAddress New address to use\n    function changeNoteAddress(address _newNoteAddress) external onlyOwner {\n        address currentNoteAddress = address(note);\n        note = ERC20(_newNoteAddress);\n        emit NoteAddressUpdate(currentNoteAddress, _newNoteAddress);\n    }\n\n    /// @notice Change the revenue address\n    /// @param _newRevenueAddress New address to use\n    function changeRevenueAddress(address _newRevenueAddress) external onlyOwner {\n        address currentRevenueAddress = revenueAddress;\n        revenueAddress = _newRevenueAddress;\n        emit RevenueAddressUpdated(currentRevenueAddress, _newRevenueAddress);\n    }\n}"
    }
  ]
}