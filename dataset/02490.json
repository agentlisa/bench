{
  "Title": "M-14: Interest rates can be raised above the market as a griefing, disabling the pool",
  "Content": "# Issue M-14: Interest rates can be raised above the market as a griefing, disabling the pool \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/100 \n\n## Found by \nhyh\n\n## Summary\n\nInterest rates algorithm is based on `MAU` to `TAU` dynamics, where TAU is 3.5 day EMA of total debt to LUP * total collateral. The latter value can be manipulated by a big collateral holder by becoming a borrower with insignificant debt and lots of collateral, so 3.5d EMA of `Debt / (LUP * Collateral)` will become depressed and rates will go up irrespective to the real debt supply/demand situation.\n\n## Vulnerability Detail\n\nLet's suppose Bob is a big WBTC holder and current market rate for its lending is insignificant, say base WBTC deposit APY on major platforms is below 5 basis points. Say Bob is a big lender of USDC-WBTC (quote-collateral) pool or Bob has interests in disturbing that pool operations for any reasons, for example Bob is a beneficiary of a rival lending protocol.\n\nBob can borrow a minimal loan, say `1000 USDC` with big, magnitudes excessive, WBTC collateral, say `1000 WBTC`. As the pool is permissionless it is safe, Bob can withdraw any time, market risk is close to zero as the loan is too small, interest rates risk is small too as Bob left near zero market interest rate for the strict zero income while the WBTC is used as collateral in the pool. I.e. it's low risk, low cost strategy for Bob to do so.\n\nPool, on the other hand, will experience gradual rise of the interest rate as while `MAU` will stay relatively constant, `TAU` will become low due to total collateral amount being big (and stable, so EMA will move to the corresponding value), while other parts of `Debt / (LUP * Collateral)` be relatively constant.\n\nObserving the rise of interest rates above market the borrowers will gradually leave. But not all, and Bob has achieved above market interest income from dormant part of the borrowers, who are slow to react to this dynamics. But, given borrowers being mostly rational and informed, this to be relatively short-term situation. More importantly, as the rate went up and borrowers has left, lenders will observe significantly decreased utilization and will leave pool as well, not receiving enough interest income for their deposits.\n\nThis way Bob essentially disturbed the USDC-WBTC pool, so he can leave some small part of WBTC collateral there so that the rate will stay elevated and pool remain to be unusable due to significantly elevated interest rate, as no borrower will enter there on such conditions.\n\n## Impact\n\nPool utility for market participants can be destroyed by manipulating the interest rate algorithm, so such pool becomes unusable and end up being abandoned. Since for a pair of quote-collateral there can be only one pool this effectively disturb the whole line of business, i.e. profit from say USDC quote, WBTC collateral operations will cease to exist for Ajna token holders.\n\nCurrent borrowers can experience losses from the manipulated above market interest rate. Dormant borrowers, i.e. ones who be slow to react, will be hit the hardest.\n\nAttack cost is proportional to the current risk-free market interest rate of the collateral as attacker gives it up for a while. This can be low enough for the majority of widely utilized collateral assets.\n\n## Code Snippet\n\nTarget utilization TAU is computed from average collateralization ratio, `Debt / Collateral`:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/PoolCommons.sol#L56-L124\n\n```solidity\n    function updateInterestRate(\n        InterestState storage interestParams_,\n        DepositsState storage deposits_,\n        PoolState memory poolState_,\n        uint256 lup_\n    ) external {\n\n        // current values of EMA samples\n        uint256 curDebtEma   = interestParams_.debtEma;\n        uint256 curLupColEma = interestParams_.lupColEma;\n\n        // meaningful actual utilization\n        int256 mau;\n        // meaningful actual utilization * 1.02\n        int256 mau102;\n\n        if (poolState_.debt != 0) {\n            // update pool EMAs for target utilization calculation\n\n            curDebtEma =\n                Maths.wmul(poolState_.debt,  EMA_7D_RATE_FACTOR) +\n                Maths.wmul(curDebtEma,       LAMBDA_EMA_7D\n            );\n\n            // lup * collateral EMA sample max value is 10 times current debt\n            uint256 maxLupColEma = Maths.wmul(poolState_.debt, Maths.wad(10));\n\n            // current lup * collateral value\n            uint256 lupCol = Maths.wmul(poolState_.collateral, lup_);\n\n            curLupColEma =\n                Maths.wmul(Maths.min(lupCol, maxLupColEma), EMA_7D_RATE_FACTOR) +\n                Maths.wmul(curLupColEma,                    LAMBDA_EMA_7D);\n\n            // save EMA samples in storage\n            interestParams_.debtEma   = curDebtEma;\n            interestParams_.lupColEma = curLupColEma;\n\n            // calculate meaningful actual utilization for interest rate update\n            mau    = int256(_utilization(deposits_, poolState_.debt, poolState_.collateral));\n            mau102 = mau * PERCENT_102 / 1e18;\n\n        }\n\n        // calculate target utilization\n        int256 tu = (curDebtEma != 0 && curLupColEma != 0) ? int256(Maths.wdiv(curDebtEma, curLupColEma)) : int(Maths.WAD);\n\n        if (!poolState_.isNewInterestAccrued) poolState_.rate = interestParams_.interestRate;\n\n        uint256 newInterestRate = poolState_.rate;\n\n        // raise rates if 4*(tu-1.02*mau) < (tu+1.02*mau-1)^2-1\n        if (4 * (tu - mau102) < ((tu + mau102 - 1e18) ** 2) / 1e18 - 1e18) {\n            newInterestRate = Maths.wmul(poolState_.rate, INCREASE_COEFFICIENT);\n        }\n        // decrease rates if 4*(tu-mau) > 1-(tu+mau-1)^2\n        else if (4 * (tu - mau) > 1e18 - ((tu + mau - 1e18) ** 2) / 1e18) {\n            newInterestRate = Maths.wmul(poolState_.rate, DECREASE_COEFFICIENT);\n        }\n\n        newInterestRate = Maths.min(500 * 1e18, Maths.max(0.001 * 1e18, newInterestRate));\n\n        if (poolState_.rate != newInterestRate) {\n            interestParams_.interestRate       = uint208(newInterestRate);\n            interestParams_.interestRateUpdate = uint48(block.timestamp);\n\n            emit UpdateInterestRate(poolState_.rate, newInterestRate);\n        }\n    }\n```\n\n_updateInterestState() and _accruePoolInterest() are called within all state changing operations of the pool:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/base/Pool.sol#L481-L488\n\n```solidity\n    function _updateInterestState(\n        PoolState memory poolState_,\n        uint256 lup_\n    ) internal {\n        // if it has been more than 12 hours since the last interest rate update, call updateInterestRate function\n        if (block.timestamp - interestState.interestRateUpdate > 12 hours) {\n            PoolCommons.updateInterestRate(interestState, deposits, poolState_, lup_);\n        }\n```\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/base/Pool.sol#L426-L431\n\n```solidity\n    function _accruePoolInterest() internal returns (PoolState memory poolState_) {\n        // retrieve t0Debt amount from poolBalances struct\n        uint256 t0Debt = poolBalances.t0Debt;\n\n        // initialize fields of poolState_ struct with initial values\n        poolState_.collateral     = poolBalances.pledgedCollateral;\n```\n\nPool collateral is updated on any borrowing:\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/BorrowerActions.sol#L100-L159\n\n```solidity\n    function drawDebt(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState    storage loans_,\n        PoolState calldata poolState_,\n        address borrowerAddress_,\n        uint256 amountToBorrow_,\n        uint256 limitIndex_,\n        uint256 collateralToPledge_\n    ) external returns (\n        DrawDebtResult memory result_\n    ) {\n        Borrower memory borrower = loans_.borrowers[borrowerAddress_];\n\n        result_.poolDebt       = poolState_.debt;\n        result_.newLup         = _lup(deposits_, result_.poolDebt);\n        result_.poolCollateral = poolState_.collateral;\n\n        ...\n\n        // pledge collateral to pool\n        if (collateralToPledge_ != 0) {\n            // add new amount of collateral to pledge to borrower balance\n            borrower.collateral  += collateralToPledge_;\n\n            ...\n\n            // add new amount of collateral to pledge to pool balance\n            result_.poolCollateral += collateralToPledge_;\n        }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nPer discussions so far the most effective approach, proposed by Matt, looks to be the weighting the collateral with the corresponding debt, i.e. instead of computing `sum(D_i) / sum(C_i)` (we omit `1 / LUP` term as it's constant here), which is the average collateralization ratio, the debt weighted version of it can be used, `sum(D_i ^ 2) / sum(C_i * D_i)`, which is the average collateralization ratio weighted by current debt.\n\nAs obtaining any significant debt brings in both market and interest rate risk, i.e. will raise the probability of attacker's borrow position liquidation and also ends up paying the elevated interest rate proportionally to the debt acquired, it will substantially raise the cost and diminish practical probability of the attack.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "contracts/src/libraries/external/PoolCommons.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { PRBMathUD60x18 } from \"@prb-math/contracts/PRBMathUD60x18.sol\";\n\nimport { InterestState, PoolState, DepositsState } from '../../interfaces/pool/commons/IPoolState.sol';\n\nimport { _indexOf, _ptp, MAX_FENWICK_INDEX, MIN_PRICE, MAX_PRICE } from '../helpers/PoolHelper.sol';\n\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  PoolCommons library\n    @notice External library containing logic for common pool functionality:\n            - interest rate accrual and interest rate params update\n            - pool utilization\n */\nlibrary PoolCommons {\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    uint256 internal constant CUBIC_ROOT_1000000 = 100 * 1e18;\n    uint256 internal constant ONE_THIRD          = 0.333333333333333334 * 1e18;\n\n    uint256 internal constant INCREASE_COEFFICIENT = 1.1 * 1e18;\n    uint256 internal constant DECREASE_COEFFICIENT = 0.9 * 1e18;\n    uint256 internal constant LAMBDA_EMA_7D        = 0.905723664263906671 * 1e18; // Lambda used for interest EMAs calculated as exp(-1/7   * ln2)\n    uint256 internal constant EMA_7D_RATE_FACTOR   = 1e18 - LAMBDA_EMA_7D;\n    int256  internal constant PERCENT_102          = 1.02 * 1e18;\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event UpdateInterestRate(uint256 oldRate,uint256 newRate);\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Calculates new pool interest rate params (EMAs and interest rate value) and saves new values in storage.\n     *  @dev    write state:\n     *              - interest debt and lup * collateral EMAs accumulators\n     *              - interest rate accumulator and interestRateUpdate state\n     *  @dev    emit events:\n     *              - UpdateInterestRate\n     */\n    function updateInterestRate(\n        InterestState storage interestParams_,\n        DepositsState storage deposits_,\n        PoolState memory poolState_,\n        uint256 lup_\n    ) external {\n\n        // current values of EMA samples\n        uint256 curDebtEma   = interestParams_.debtEma;\n        uint256 curLupColEma = interestParams_.lupColEma;\n\n        // meaningful actual utilization\n        int256 mau;\n        // meaningful actual utilization * 1.02\n        int256 mau102;\n\n        if (poolState_.debt != 0) {\n            // update pool EMAs for target utilization calculation\n\n            curDebtEma =\n                Maths.wmul(poolState_.debt,  EMA_7D_RATE_FACTOR) +\n                Maths.wmul(curDebtEma,       LAMBDA_EMA_7D\n            );\n\n            // lup * collateral EMA sample max value is 10 times current debt\n            uint256 maxLupColEma = Maths.wmul(poolState_.debt, Maths.wad(10));\n\n            // current lup * collateral value\n            uint256 lupCol = Maths.wmul(poolState_.collateral, lup_);\n\n            curLupColEma =\n                Maths.wmul(Maths.min(lupCol, maxLupColEma), EMA_7D_RATE_FACTOR) +\n                Maths.wmul(curLupColEma,                    LAMBDA_EMA_7D);\n\n            // save EMA samples in storage\n            interestParams_.debtEma   = curDebtEma;\n            interestParams_.lupColEma = curLupColEma;\n\n            // calculate meaningful actual utilization for interest rate update\n            mau    = int256(_utilization(deposits_, poolState_.debt, poolState_.collateral));\n            mau102 = mau * PERCENT_102 / 1e18;\n\n        }\n\n        // calculate target utilization\n        int256 tu = (curDebtEma != 0 && curLupColEma != 0) ? int256(Maths.wdiv(curDebtEma, curLupColEma)) : int(Maths.WAD);\n\n        if (!poolState_.isNewInterestAccrued) poolState_.rate = interestParams_.interestRate;\n\n        uint256 newInterestRate = poolState_.rate;\n\n        // raise rates if 4*(tu-1.02*mau) < (tu+1.02*mau-1)^2-1\n        if (4 * (tu - mau102) < ((tu + mau102 - 1e18) ** 2) / 1e18 - 1e18) {\n            newInterestRate = Maths.wmul(poolState_.rate, INCREASE_COEFFICIENT);\n        }\n        // decrease rates if 4*(tu-mau) > 1-(tu+mau-1)^2\n        else if (4 * (tu - mau) > 1e18 - ((tu + mau - 1e18) ** 2) / 1e18) {\n            newInterestRate = Maths.wmul(poolState_.rate, DECREASE_COEFFICIENT);\n        }\n\n        newInterestRate = Maths.min(500 * 1e18, Maths.max(0.001 * 1e18, newInterestRate));\n\n        if (poolState_.rate != newInterestRate) {\n            interestParams_.interestRate       = uint208(newInterestRate);\n            interestParams_.interestRateUpdate = uint48(block.timestamp);\n\n            emit UpdateInterestRate(poolState_.rate, newInterestRate);\n        }\n    }\n\n    /**\n     *  @notice Calculates new pool interest and scale the fenwick tree to update amount of debt owed to lenders (saved in storage).\n     *  @dev write state:\n     *       - Deposits.mult (scale Fenwick tree with new interest accrued):\n     *         - update scaling array state \n     *  @param  thresholdPrice_ Current Pool Threshold Price.\n     *  @param  elapsed_        Time elapsed since last inflator update.\n     *  @return newInflator_   The new value of pool inflator.\n     */\n    function accrueInterest(\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        uint256 thresholdPrice_,\n        uint256 elapsed_\n    ) external returns (uint256 newInflator_, uint256 newInterest_) {\n        // Scale the borrower inflator to update amount of interest owed by borrowers\n        uint256 pendingFactor = PRBMathUD60x18.exp((poolState_.rate * elapsed_) / 365 days);\n\n        // calculate the highest threshold price\n        newInflator_ = Maths.wmul(poolState_.inflator, pendingFactor);\n        uint256 htp = Maths.wmul(thresholdPrice_, newInflator_);\n\n        uint256 htpIndex;\n        if (htp > MAX_PRICE)\n            // if HTP is over the highest price bucket then no buckets earn interest\n            htpIndex = 1;\n        else if (htp < MIN_PRICE)\n            // if HTP is under the lowest price bucket then all buckets earn interest\n            htpIndex = MAX_FENWICK_INDEX;\n        else\n            htpIndex = _indexOf(htp);\n\n        // Scale the fenwick tree to update amount of debt owed to lenders\n        uint256 depositAboveHtp = Deposits.prefixSum(deposits_, htpIndex);\n\n        if (depositAboveHtp != 0) {\n            newInterest_ = Maths.wmul(\n                _lenderInterestMargin(_utilization(deposits_, poolState_.debt, poolState_.collateral)),\n                Maths.wmul(pendingFactor - Maths.WAD, poolState_.debt)\n            );\n\n            Deposits.mult(\n                deposits_,\n                htpIndex,\n                Maths.wdiv(newInterest_, depositAboveHtp) + Maths.WAD // lender factor\n            );\n        }\n    }\n\n    /**************************/\n    /*** View Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Calculates pool interest factor for a given interest rate and time elapsed since last inflator update.\n     *  @param  interestRate_   Current pool interest rate.\n     *  @param  elapsed_        Time elapsed since last inflator update.\n     *  @return The value of pool interest factor.\n     */\n    function pendingInterestFactor(\n        uint256 interestRate_,\n        uint256 elapsed_\n    ) external pure returns (uint256) {\n        return PRBMathUD60x18.exp((interestRate_ * elapsed_) / 365 days);\n    }\n\n    /**\n     *  @notice Calculates pool pending inflator given the current inflator, time of last update and current interest rate.\n     *  @param  inflatorSnapshot_ Current pool interest rate.\n     *  @param  inflatorUpdate    Timestamp when inflator was updated.\n     *  @param  interestRate_     The interest rate of the pool.\n     *  @return The pending value of pool inflator.\n     */\n    function pendingInflator(\n        uint256 inflatorSnapshot_,\n        uint256 inflatorUpdate,\n        uint256 interestRate_\n    ) external view returns (uint256) {\n        return Maths.wmul(\n            inflatorSnapshot_,\n            PRBMathUD60x18.exp((interestRate_ * (block.timestamp - inflatorUpdate)) / 365 days)\n        );\n    }\n\n    /**\n     *  @notice Calculates lender interest margin for a given meaningful actual utilization.\n     *  @dev Wrapper of the internal function.\n     */\n    function lenderInterestMargin(\n        uint256 mau_\n    ) external pure returns (uint256) {\n        return _lenderInterestMargin(mau_);\n    }\n\n    /**\n     *  @notice Calculates pool utilization based on pool size, accrued debt and collateral pledged in pool .\n     *  @dev Wrapper of the internal function.\n     */\n    function utilization(\n        DepositsState storage deposits,\n        uint256 poolDebt_,\n        uint256 collateral_\n    ) external view returns (uint256 utilization_) {\n        return _utilization(deposits, poolDebt_, collateral_);\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Calculates pool utilization based on pool size, accrued debt and collateral pledged in pool .\n     *  @param  poolDebt_    Pool accrued debt.\n     *  @param  collateral_  Amount of collateral pledged in pool.\n     *  @return utilization_ Pool utilization value.\n     */\n    function _utilization(\n        DepositsState storage deposits,\n        uint256 poolDebt_,\n        uint256 collateral_\n    ) internal view returns (uint256 utilization_) {\n        if (collateral_ != 0) {\n            uint256 ptp = _ptp(poolDebt_, collateral_);\n\n            if (ptp != 0) {\n                uint256 depositAbove;\n                if      (ptp >= MAX_PRICE) depositAbove = 0;\n                else if (ptp >= MIN_PRICE) depositAbove = Deposits.prefixSum(deposits, _indexOf(ptp));\n                else                       depositAbove = Deposits.treeSum(deposits);\n\n                if (depositAbove != 0) utilization_ = Maths.wdiv(\n                    poolDebt_,\n                    depositAbove\n                );\n            }\n        }\n    }\n\n    /**\n     *  @notice Calculates lender interest margin.\n     *  @param  mau_ Meaningful actual utilization.\n     *  @return The lender interest margin value.\n     */\n    function _lenderInterestMargin(\n        uint256 mau_\n    ) internal pure returns (uint256) {\n        uint256 base = 1_000_000 * 1e18 - Maths.wmul(Maths.min(mau_, 1e18), 1_000_000 * 1e18);\n        if (base < 1e18) {\n            return 1e18;\n        } else {\n            // cubic root of the percentage of meaningful unutilized deposit\n            uint256 crpud = PRBMathUD60x18.pow(base, ONE_THIRD);\n            return 1e18 - Maths.wmul(Maths.wdiv(crpud, CUBIC_ROOT_1000000), 0.15 * 1e18);\n        }\n    }\n\n}"
    },
    {
      "filename": "contracts/src/base/Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { Clone }           from '@clones/Clone.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { Multicall }       from '@openzeppelin/contracts/utils/Multicall.sol';\nimport { SafeERC20 }       from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 }          from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {\n    IPool,\n    IPoolImmutables,\n    IPoolLenderActions,\n    IPoolState,\n    IPoolLiquidationActions,\n    IPoolReserveAuctionActions,\n    IPoolDerivedState,\n    IERC20Token\n}                                    from '../interfaces/pool/IPool.sol';\nimport {\n    PoolState,\n    AuctionsState,\n    DepositsState,\n    LoansState,\n    InflatorState,\n    InterestState,\n    PoolBalancesState,\n    ReserveAuctionState,\n    Bucket,\n    BurnEvent,\n    Liquidation\n}                                    from '../interfaces/pool/commons/IPoolState.sol';\nimport {\n    KickResult,\n    RemoveQuoteParams,\n    MoveQuoteParams,\n    AddQuoteParams\n}                                    from '../interfaces/pool/commons/IPoolInternals.sol';\nimport { StartReserveAuctionParams } from '../interfaces/pool/commons/IPoolReserveAuctionActions.sol';\n\nimport {\n    _priceAt,\n    _roundToScale\n}                               from '../libraries/helpers/PoolHelper.sol';\nimport {\n    _revertIfAuctionDebtLocked,\n    _revertIfAuctionClearable\n}                               from '../libraries/helpers/RevertsHelper.sol';\n\nimport { Buckets }  from '../libraries/internal/Buckets.sol';\nimport { Deposits } from '../libraries/internal/Deposits.sol';\nimport { Loans }    from '../libraries/internal/Loans.sol';\nimport { Maths }    from '../libraries/internal/Maths.sol';\n\nimport { Auctions }        from '../libraries/external/Auctions.sol';\nimport { BorrowerActions } from '../libraries/external/BorrowerActions.sol';\nimport { LenderActions }   from '../libraries/external/LenderActions.sol';\nimport { PoolCommons }     from '../libraries/external/PoolCommons.sol';\n\n/**\n *  @title  Pool Contract\n *  @dev    Base contract and entrypoint for commong logic of both ERC20 and ERC721 pools.\n */\nabstract contract Pool is Clone, ReentrancyGuard, Multicall, IPool {\n\n    using SafeERC20 for IERC20;\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    // immutable args offset\n    uint256 internal constant POOL_TYPE          = 0;\n    uint256 internal constant AJNA_ADDRESS       = 1;\n    uint256 internal constant COLLATERAL_ADDRESS = 21;\n    uint256 internal constant QUOTE_ADDRESS      = 41;\n    uint256 internal constant QUOTE_SCALE        = 61;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    AuctionsState       internal auctions;\n    DepositsState       internal deposits;\n    LoansState          internal loans;\n    InflatorState       internal inflatorState;\n    InterestState       internal interestState;\n    PoolBalancesState   internal poolBalances;\n    ReserveAuctionState internal reserveAuction;\n\n    mapping(uint256 => Bucket) internal buckets;   // deposit index -> bucket\n\n    bool internal isPoolInitialized;\n\n    mapping(address => mapping(address => mapping(uint256 => uint256))) private _lpTokenAllowances; // owner address -> new owner address -> deposit index -> allowed amount\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IPoolImmutables\n    function poolType() external pure override returns (uint8) {\n        return _getArgUint8(POOL_TYPE);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function collateralAddress() external pure override returns (address) {\n        return _getArgAddress(COLLATERAL_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenAddress() external pure override returns (address) {\n        return _getArgAddress(QUOTE_ADDRESS);\n    }\n\n    /// @inheritdoc IPoolImmutables\n    function quoteTokenScale() external pure override returns (uint256) {\n        return _getArgUint256(QUOTE_SCALE);\n    }\n\n    function quoteTokenDust() external pure override returns (uint256) {\n        return _getArgUint256(QUOTE_SCALE);\n    }\n\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /// @inheritdoc IPoolLenderActions\n    function addQuoteToken(\n        uint256 quoteTokenAmountToAdd_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 bucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // round to token precision\n        quoteTokenAmountToAdd_ = _roundToScale(quoteTokenAmountToAdd_, poolState.quoteDustLimit);\n\n        uint256 newLup;\n        (bucketLPs_, newLup) = LenderActions.addQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            AddQuoteParams({\n                amount: quoteTokenAmountToAdd_,\n                index:  index_\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from lender to pool\n        _transferQuoteTokenFrom(msg.sender, quoteTokenAmountToAdd_);\n    }\n\n    /**\n     *  @inheritdoc IPoolLenderActions\n     *  @dev write state:\n     *          - _lpTokenAllowances mapping\n     */\n    function approveLpOwnership(\n        address allowedNewOwner_,\n        uint256 index_,\n        uint256 lpsAmountToApprove_\n    ) external nonReentrant {\n        _lpTokenAllowances[msg.sender][allowedNewOwner_][index_] = lpsAmountToApprove_;\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function moveQuoteToken(\n        uint256 maxAmountToMove_,\n        uint256 fromIndex_,\n        uint256 toIndex_\n    ) external override nonReentrant returns (uint256 fromBucketLPs_, uint256 toBucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolBalances, fromIndex_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            fromBucketLPs_,\n            toBucketLPs_,\n            newLup\n        ) = LenderActions.moveQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            MoveQuoteParams({\n                maxAmountToMove: maxAmountToMove_,\n                fromIndex:       fromIndex_,\n                toIndex:         toIndex_,\n                thresholdPrice:  Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function removeQuoteToken(\n        uint256 maxAmount_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 removedAmount_, uint256 redeemedLPs_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        _revertIfAuctionDebtLocked(deposits, poolBalances, index_, poolState.inflator);\n\n        uint256 newLup;\n        (\n            removedAmount_,\n            redeemedLPs_,\n            newLup\n        ) = LenderActions.removeQuoteToken(\n            buckets,\n            deposits,\n            poolState,\n            RemoveQuoteParams({\n                maxAmount:      maxAmount_,\n                index:          index_,\n                thresholdPrice: Loans.getMax(loans).thresholdPrice\n            })\n        );\n\n        // update pool interest rate state\n        _updateInterestState(poolState, newLup);\n\n        // move quote token amount from pool to lender\n        _transferQuoteToken(msg.sender, removedAmount_);\n    }\n\n    /// @inheritdoc IPoolLenderActions\n    function transferLPs(\n        address owner_,\n        address newOwner_,\n        uint256[] calldata indexes_\n    ) external override nonReentrant {\n        LenderActions.transferLPs(\n            buckets,\n            _lpTokenAllowances,\n            owner_,\n            newOwner_,\n            indexes_\n        );\n    }\n\n    /*****************************/\n    /*** Liquidation Functions ***/\n    /*****************************/\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *       - increment poolBalances.t0DebtInAuction and poolBalances.t0Debt accumulators\n     */\n    function kick(\n        address borrowerAddress_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auction\n        KickResult memory result = Auctions.kick(\n            auctions,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_\n        );\n\n        // update pool balances state\n        poolBalances.t0DebtInAuction += result.t0KickedDebt;\n        poolBalances.t0Debt          += result.t0KickPenalty;\n\n        // update pool interest rate state\n        poolState.debt += result.kickPenalty;\n        _updateInterestState(poolState, result.lup);\n\n        if(result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *       - increment poolBalances.t0DebtInAuction and poolBalances.t0Debt accumulators\n     */\n    function kickWithDeposit(\n        uint256 index_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        // kick auctions\n        KickResult memory result = Auctions.kickWithDeposit(\n            auctions,\n            deposits,\n            buckets,\n            loans,\n            poolState,\n            index_\n        );\n\n        // update pool balances state\n        poolBalances.t0Debt          += result.t0KickPenalty;\n        poolBalances.t0DebtInAuction += result.t0KickedDebt;\n\n        // update pool interest rate state\n        poolState.debt += result.kickPenalty;\n        _updateInterestState(poolState, result.lup);\n\n        // transfer from kicker to pool the difference to cover bond\n        if(result.amountToCoverBond != 0) _transferQuoteTokenFrom(msg.sender, result.amountToCoverBond);\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *       - reset kicker's claimable accumulator\n     */\n    function withdrawBonds() external {\n        uint256 claimable = auctions.kickers[msg.sender].claimable;\n        auctions.kickers[msg.sender].claimable = 0;\n        _transferQuoteToken(msg.sender, claimable);\n    }\n\n    /*********************************/\n    /*** Reserve Auction Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IPoolReserveAuctionActions\n     *  @dev  write state:\n     *          - increment latestBurnEpoch counter\n     *          - update reserveAuction.latestBurnEventEpoch and burn event timestamp state\n     *  @dev reverts on:\n     *          - 2 weeks not passed ReserveAuctionTooSoon()\n     *  @dev emit events:\n     *          - ReserveAuction\n     */\n    function startClaimableReserveAuction() external override nonReentrant {\n        // retrieve timestamp of latest burn event and last burn timestamp\n        uint256 latestBurnEpoch   = reserveAuction.latestBurnEventEpoch;\n        uint256 lastBurnTimestamp = reserveAuction.burnEvents[latestBurnEpoch].timestamp;\n\n        // check that at least two weeks have passed since the last reserve auction completed, and that the auction was not kicked within the past 72 hours\n        if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction.kicked <= 72 hours) {\n            revert ReserveAuctionTooSoon();\n        }\n\n        // start a new claimable reserve auction, passing in relevant parameters such as the current pool size, debt, balance, and inflator value\n        uint256 kickerAward = Auctions.startClaimableReserveAuction(\n            auctions,\n            reserveAuction,\n            StartReserveAuctionParams({\n                poolSize:    Deposits.treeSum(deposits),\n                poolDebt:    poolBalances.t0Debt,\n                poolBalance: _getPoolQuoteTokenBalance(),\n                inflator:    inflatorState.inflator\n            })\n        );\n\n        // increment latest burn event epoch and update burn event timestamp\n        latestBurnEpoch += 1;\n\n        reserveAuction.latestBurnEventEpoch = latestBurnEpoch;\n        reserveAuction.burnEvents[latestBurnEpoch].timestamp = block.timestamp;\n\n        // transfer kicker award to msg.sender\n        _transferQuoteToken(msg.sender, kickerAward);\n    }\n\n    /**\n     *  @inheritdoc IPoolReserveAuctionActions\n     *  @dev  write state:\n     *          - increment reserveAuction.totalAjnaBurned accumulator\n     *          - update burn event totalInterest and totalBurned accumulators\n     */\n    function takeReserves(\n        uint256 maxAmount_\n    ) external override nonReentrant returns (uint256 amount_) {\n        uint256 ajnaRequired;\n        (amount_, ajnaRequired) = Auctions.takeReserves(\n            reserveAuction,\n            maxAmount_\n        );\n\n        uint256 totalBurned = reserveAuction.totalAjnaBurned + ajnaRequired;\n        \n        // accumulate additional ajna burned\n        reserveAuction.totalAjnaBurned = totalBurned;\n\n        uint256 burnEventEpoch = reserveAuction.latestBurnEventEpoch;\n\n        // record burn event information to enable querying by staking rewards\n        BurnEvent storage burnEvent = reserveAuction.burnEvents[burnEventEpoch];\n        burnEvent.totalInterest = reserveAuction.totalInterestEarned;\n        burnEvent.totalBurned   = totalBurned;\n\n        // burn required number of ajna tokens to take quote from reserves\n        IERC20(_getArgAddress(AJNA_ADDRESS)).safeTransferFrom(msg.sender, address(this), ajnaRequired);\n\n        IERC20Token(_getArgAddress(AJNA_ADDRESS)).burn(ajnaRequired);\n\n        // transfer quote token to caller\n        _transferQuoteToken(msg.sender, amount_);\n    }\n\n    /*****************************/\n    /*** Pool Helper Functions ***/\n    /*****************************/\n\n    /**\n     *  @notice Accrues pool interest in current block and returns pool details.\n     *  @dev    external libraries call:\n     *              - PoolCommons.accrueInterest   \n     *  @dev    write state:\n     *              - PoolCommons.accrueInterest:\n     *                  - Deposits.mult (scale Fenwick tree with new interest accrued):\n     *                      - update scaling array state \n     *              - increment reserveAuction.totalInterestEarned accumulator\n     *  @return poolState_ Struct containing pool details.\n     */\n    function _accruePoolInterest() internal returns (PoolState memory poolState_) {\n\t    // retrieve t0Debt amount from poolBalances struct\n        uint256 t0Debt = poolBalances.t0Debt;\n\n\t    // initialize fields of poolState_ struct with initial values\n        poolState_.collateral     = poolBalances.pledgedCollateral;\n        poolState_.inflator       = inflatorState.inflator;\n        poolState_.rate           = interestState.interestRate;\n        poolState_.poolType       = _getArgUint8(POOL_TYPE);\n        poolState_.quoteDustLimit = _getArgUint256(QUOTE_SCALE);\n\n\t    // check if t0Debt is not equal to 0, indicating that there is debt to be tracked for the pool\n        if (t0Debt != 0) {\n            // Calculate prior pool debt\n            poolState_.debt = Maths.wmul(t0Debt, poolState_.inflator);\n\n\t        // calculate elapsed time since inflator was last updated\n            uint256 elapsed = block.timestamp - inflatorState.inflatorUpdate;\n\n\t        // set isNewInterestAccrued field to true if elapsed time is not 0, indicating that new interest may have accrued\n            poolState_.isNewInterestAccrued = elapsed != 0;\n\n            // if new interest may have accrued, call accrueInterest function and update inflator and debt fields of poolState_ struct\n            if (poolState_.isNewInterestAccrued) {\n                (uint256 newInflator, uint256 newInterest) = PoolCommons.accrueInterest(\n                    deposits,\n                    poolState_,\n                    Loans.getMax(loans).thresholdPrice,\n                    elapsed\n                );\n                poolState_.inflator = newInflator;\n                // After debt owed to lenders has accrued, calculate current debt owed by borrowers\n                poolState_.debt = Maths.wmul(t0Debt, poolState_.inflator);\n\n                // update total interest earned accumulator with the newly accrued interest\n                reserveAuction.totalInterestEarned += newInterest;\n            }\n        }\n    }\n\n    /**\n     *  @notice Update interest rate and inflator of the pool.\n     *  @dev    external libraries call:\n     *              - PoolCommons.updateInterestRate     \n     *  @dev    write state:\n     *              - PoolCommons.updateInterestRate \n     *                  - interest debt and lup * collateral EMAs accumulators\n     *                  - interest rate accumulator and interestRateUpdate state\n     *              - pool inflator and inflatorUpdate state\n     *  @dev    emit events:\n     *              - PoolCommons.updateInterestRate:\n     *                  - UpdateInterestRate\n     *  @param  poolState_ Struct containing pool details.\n     *  @param  lup_       Current LUP in pool.\n     */\n    function _updateInterestState(\n        PoolState memory poolState_,\n        uint256 lup_\n    ) internal {\n        // if it has been more than 12 hours since the last interest rate update, call updateInterestRate function\n        if (block.timestamp - interestState.interestRateUpdate > 12 hours) {\n            PoolCommons.updateInterestRate(interestState, deposits, poolState_, lup_);\n        }\n\n        // update pool inflator\n        if (poolState_.isNewInterestAccrued) {\n            inflatorState.inflator       = uint208(poolState_.inflator);\n            inflatorState.inflatorUpdate = uint48(block.timestamp);\n        // if the debt in the current pool state is 0, also update the inflator and inflatorUpdate fields in inflatorState\n        // slither-disable-next-line incorrect-equality\n        } else if (poolState_.debt == 0) {\n            inflatorState.inflator       = uint208(Maths.WAD);\n            inflatorState.inflatorUpdate = uint48(block.timestamp);\n        }\n    }\n\n    function _transferQuoteTokenFrom(address from_, uint256 amount_) internal {\n        IERC20(_getArgAddress(QUOTE_ADDRESS)).safeTransferFrom(from_, address(this), amount_ / _getArgUint256(QUOTE_SCALE));\n    }\n\n    function _transferQuoteToken(address to_, uint256 amount_) internal {\n        IERC20(_getArgAddress(QUOTE_ADDRESS)).safeTransfer(to_, amount_ / _getArgUint256(QUOTE_SCALE));\n    }\n\n    function _getPoolQuoteTokenBalance() internal view returns (uint256) {\n        return IERC20(_getArgAddress(QUOTE_ADDRESS)).balanceOf(address(this));\n    }\n\n    function _lup(uint256 debt_) internal view returns (uint256) {\n        return _priceAt(Deposits.findIndexOfSum(deposits, debt_));\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    /// @inheritdoc IPoolState\n    function auctionInfo(\n        address borrower_\n    ) external\n    view override returns (\n        address kicker,\n        uint256 bondFactor,\n        uint256 bondSize,\n        uint256 kickTime,\n        uint256 kickMomp,\n        uint256 neutralPrice,\n        address head,\n        address next,\n        address prev\n    ) {\n        Liquidation memory liquidation = auctions.liquidations[borrower_];\n        return (\n            liquidation.kicker,\n            liquidation.bondFactor,\n            liquidation.bondSize,\n            liquidation.kickTime,\n            liquidation.kickMomp,\n            liquidation.neutralPrice,\n            auctions.head,\n            liquidation.next,\n            liquidation.prev\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function borrowerInfo(\n        address borrower_\n    ) external view override returns (uint256, uint256, uint256) {\n        return (\n            loans.borrowers[borrower_].t0Debt,\n            loans.borrowers[borrower_].collateral,\n            loans.borrowers[borrower_].t0Np\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function bucketInfo(\n        uint256 index_\n    ) external view override returns (uint256, uint256, uint256, uint256, uint256) {\n        uint256 scale = Deposits.scale(deposits, index_);\n        return (\n            buckets[index_].lps,\n            buckets[index_].collateral,\n            buckets[index_].bankruptcyTime,\n            Maths.wmul(scale, Deposits.unscaledValueAt(deposits, index_)),\n            scale\n        );\n    }\n\n    /// @inheritdoc IPoolDerivedState\n    function bucketExchangeRate(\n        uint256 index_\n    ) external view returns (uint256 exchangeRate_) {\n        Bucket storage bucket = buckets[index_];\n\n        exchangeRate_ = Buckets.getExchangeRate(\n            bucket.collateral,\n            bucket.lps,\n            Deposits.valueAt(deposits, index_),\n            _priceAt(index_)\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function currentBurnEpoch() external view returns (uint256) {\n        return reserveAuction.latestBurnEventEpoch;\n    }\n\n    /// @inheritdoc IPoolState\n    function burnInfo(uint256 burnEventEpoch_) external view returns (uint256, uint256, uint256) {\n        BurnEvent memory burnEvent = reserveAuction.burnEvents[burnEventEpoch_];\n\n        return (\n            burnEvent.timestamp,\n            burnEvent.totalInterest,\n            burnEvent.totalBurned\n        );\n    }\n\n    /// @inheritdoc IPoolState\n    function debtInfo() external view returns (uint256, uint256, uint256) {\n        uint256 pendingInflator = PoolCommons.pendingInflator(\n            inflatorState.inflator,\n            inflatorState.inflatorUpdate,"
    }
  ]
}