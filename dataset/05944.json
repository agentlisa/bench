{
  "Title": "[H-03] When adding a gauge, its initial value has to be set by an admin or all voting power towards it will be lost",
  "Content": "\n<https://github.com/code-423n4/2023-08-verwa/blob/main/src/GaugeController.sol#L118> \n\n<https://github.com/code-423n4/2023-08-verwa/blob/main/src/GaugeController.sol#L204>\n\nVoting power towards gauges will be lost and project will not work properly\n\n### Proof of Concept\n\nThe mapping `time_weight` takes a gauge as a param and returns the most recent timestamp a gauge has had its weight recorded/ updated. There are 2 ways to set this value: through `_get_weight` and `_change_gauge_weight`.\n\n<details>\n\n```solidity\nfunction _get_weight(address _gauge_addr) private returns (uint256) {\n        uint256 t = time_weight[_gauge_addr];\n        if (t > 0) {\n            Point memory pt = points_weight[_gauge_addr][t];\n            for (uint256 i; i < 500; ++i) {\n                if (t > block.timestamp) break;\n                t += WEEK;\n                uint256 d_bias = pt.slope * WEEK;\n                if (pt.bias > d_bias) {\n                    pt.bias -= d_bias;\n                    uint256 d_slope = changes_weight[_gauge_addr][t];\n                    pt.slope -= d_slope;\n                } else {\n                    pt.bias = 0;\n                    pt.slope = 0;\n                }\n                points_weight[_gauge_addr][t] = pt;\n                if (t > block.timestamp) time_weight[_gauge_addr] = t;\n            }\n            return pt.bias;\n        } else {\n            return 0;\n        }\n    }\n```\n\nThe problem in `_get_weight` is that the initial value of any `time_weight[_gauge_addr]` will be 0. It will go through the entirety of the loop and `t` will increase +1 week for every iteration. The problem is that even after 500 iterations `t` will be `< block.timestamp` so the value of `time_weight[_gauge_addr]` will remain 0. Unless admins call manually `_change_gauge_weight` to set an initial value, `time_weight[_gauge_addr]` will remain 0. Any  time a user will use `_get_weight` to fill with recent data, the function will iterate over old values and will do nothing. Recent values won't be set and anything depending on it will receive 0 as a recent value.\n\n```solidity\n    function _change_gauge_weight(address _gauge, uint256 _weight) internal {\n        uint256 old_gauge_weight = _get_weight(_gauge);\n        uint256 old_sum = _get_sum();\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n        points_weight[_gauge][next_time].bias = _weight;\n        time_weight[_gauge] = next_time;\n\n        uint256 new_sum = old_sum + _weight - old_gauge_weight;\n        points_sum[next_time].bias = new_sum;\n        time_sum = next_time;\n    }\n```\n\nSince `_change_gauge_weight` is not called within `add_gauge`, even if we expect the owners to call it, any votes happening in the time between the adding of the gauge and the admin set function will be lost. The user will only be able to retrieve them by later removing their vote and voting again.\nHere are 3 written test-cases which prove the statements above:\n\n```solidity\n   function testWithoutManualSet() public {\n        vm.startPrank(gov);\n        gc.add_gauge(gauge1);\n        vm.stopPrank();\n\n        vm.startPrank(user1);\n        ve.createLock{value: 1 ether}(1 ether);\n        gc.vote_for_gauge_weights(gauge1, 10000);\n        uint weight = gc.get_gauge_weight(gauge1);\n        console.log(\"gauge's weight after voting: \", weight);\n        vm.stopPrank();\n    }\n\n    function testWithManualSet() public { \n        vm.startPrank(gov);\n        gc.add_gauge(gauge1);\n        gc.change_gauge_weight(gauge1, 0);\n        vm.stopPrank();\n\n        vm.startPrank(user1);\n        ve.createLock{value: 1 ether}(1 ether);\n        gc.vote_for_gauge_weights(gauge1, 10000);\n        uint weight = gc.get_gauge_weight(gauge1);\n        console.log(\"gauge's weight after voting: \", weight);\n        vm.stopPrank();\n    }\n\n    function testWithChangeMidway() public {\n        vm.startPrank(gov);\n        gc.add_gauge(gauge1);\n        vm.stopPrank();\n\n        vm.startPrank(user1);\n        ve.createLock{value: 1 ether}(1 ether);\n        gc.vote_for_gauge_weights(gauge1, 10000);\n        uint weight = gc.get_gauge_weight(gauge1);\n        console.log(\"gauge's weight after voting: \", weight);\n        vm.stopPrank();\n\n        vm.prank(gov);\n        gc.change_gauge_weight(gauge1, 0);\n\n        vm.startPrank(user1);\n        gc.vote_for_gauge_weights(gauge1, 10000);\n        weight = gc.get_gauge_weight(gauge1);\n        console.log(\"gauge's weight after voting after admin set\", weight);\n\n        gc.vote_for_gauge_weights(gauge1, 0);\n        gc.vote_for_gauge_weights(gauge1, 10000);\n        weight = gc.get_gauge_weight(gauge1);\n        console.log(\"gauge's weight after voting after admin set after vote reset\", weight);\n        \n    }\n```\n\nand the respective results:\n\n    [PASS] testWithoutManualSet() (gas: 645984)\n    Logs:\n      gauge's weight after voting:  0\n\n```\n\n    [PASS] testWithManualSet() (gas: 667994)\n    Logs:\n      gauge's weight after voting:  993424657416307200\n```\n\n```\n\n    [PASS] testWithChangeMidway() (gas: 744022)\n    Logs:\n      gauge's weight after voting:  0\n      gauge's weight after voting after admin set 0\n      gauge's weight after voting after admin set after vote reset 993424657416307200\n```\n\n</details>\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nUpon adding a gauge, make a call to `change_gauge_weight` and set its initial weight to 0.\n\n**[\\_\\_141345\\_\\_ (Lookout) commented](https://github.com/code-423n4/2023-08-verwa-findings/issues/288#issuecomment-1678351795):**\n > Forget to initialize `time_weight[]` when add new gauge.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-08-verwa",
  "Code": [
    {
      "filename": "src/GaugeController.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title  GaugeController\n/// @author Curve Finance (MIT) - original concept and implementation in Vyper\n///         mkt.market - Porting to Solidity with some modifications (this version)\n/// @notice Allows users to vote on distribution of CANTO that the contract receives from governance. Modifications from Curve:\n///         - Gauge types removed (resulting in the removal of the differentiation between tracking of total / sum)\n///         - Different whitelisting of gauge addresses because of removed types\n///         - Removal of gauges\ncontract GaugeController {\n    // Constants\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant MULTIPLIER = 10**18;\n\n    // Events\n    event NewGauge(address indexed gauge_address);\n    event GaugeRemoved(address indexed gauge_address);\n\n    // State\n    VotingEscrow public votingEscrow;\n    address public governance;\n    mapping(address => bool) public isValidGauge;\n    mapping(address => mapping(address => VotedSlope)) public vote_user_slopes;\n    mapping(address => uint256) public vote_user_power;\n    mapping(address => mapping(address => uint256)) public last_user_vote;\n\n    mapping(address => mapping(uint256 => Point)) public points_weight;\n    mapping(address => mapping(uint256 => uint256)) public changes_weight;\n    mapping(address => uint256) time_weight;\n\n    mapping(uint256 => Point) points_sum;\n    mapping(uint256 => uint256) changes_sum;\n    uint256 public time_sum;\n\n    struct Point {\n        uint256 bias;\n        uint256 slope;\n    }\n\n    struct VotedSlope {\n        uint256 slope;\n        uint256 power;\n        uint256 end;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    /// @notice Initializes state\n    /// @param _votingEscrow The voting escrow address\n    constructor(address _votingEscrow, address _governance) {\n        votingEscrow = VotingEscrow(_votingEscrow);\n        governance = _governance; // TODO: Maybe change to Oracle\n        uint256 last_epoch = (block.timestamp / WEEK) * WEEK;\n        time_sum = last_epoch;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins and return the sum for the future week\n    /// @return Sum of weights\n    function _get_sum() internal returns (uint256) {\n        uint256 t = time_sum;\n        Point memory pt = points_sum[t];\n        for (uint256 i; i < 500; ++i) {\n            if (t > block.timestamp) break;\n            t += WEEK;\n            uint256 d_bias = pt.slope * WEEK;\n            if (pt.bias > d_bias) {\n                pt.bias -= d_bias;\n                uint256 d_slope = changes_sum[t];\n                pt.slope -= d_slope;\n            } else {\n                pt.bias = 0;\n                pt.slope = 0;\n            }\n            points_sum[t] = pt;\n            if (t > block.timestamp) time_sum = t;\n        }\n        return pt.bias;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins\n    /// and return the total for the future week\n    /// @param _gauge_addr Address of the gauge\n    /// @return Gauge weight\n    function _get_weight(address _gauge_addr) private returns (uint256) {\n        uint256 t = time_weight[_gauge_addr];\n        if (t > 0) {\n            Point memory pt = points_weight[_gauge_addr][t];\n            for (uint256 i; i < 500; ++i) {\n                if (t > block.timestamp) break;\n                t += WEEK;\n                uint256 d_bias = pt.slope * WEEK;\n                if (pt.bias > d_bias) {\n                    pt.bias -= d_bias;\n                    uint256 d_slope = changes_weight[_gauge_addr][t];\n                    pt.slope -= d_slope;\n                } else {\n                    pt.bias = 0;\n                    pt.slope = 0;\n                }\n                points_weight[_gauge_addr][t] = pt;\n                if (t > block.timestamp) time_weight[_gauge_addr] = t;\n            }\n            return pt.bias;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Add a new gauge, only callable by governance\n    /// @param _gauge The gauge address\n    function add_gauge(address _gauge) external onlyGovernance {\n        require(!isValidGauge[_gauge], \"Gauge already exists\");\n        isValidGauge[_gauge] = true;\n        emit NewGauge(_gauge);\n    }\n\n    /// @notice Remove a gauge, only callable by governance\n    /// @dev Sets the gauge weight to 0\n    /// @param _gauge The gauge address\n    function remove_gauge(address _gauge) external onlyGovernance {\n        require(isValidGauge[_gauge], \"Invalid gauge address\");\n        isValidGauge[_gauge] = false;\n        _change_gauge_weight(_gauge, 0);\n        emit GaugeRemoved(_gauge);\n    }\n\n    /// @notice Checkpoint to fill data common for all gauges\n    function checkpoint() external {\n        _get_sum();\n    }\n\n    /// @notice Checkpoint to fill data for both a specific gauge and common for all gauges\n    /// @param _gauge The gauge address\n    function checkpoint_gauge(address _gauge) external {\n        _get_weight(_gauge);\n        _get_sum();\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function _gauge_relative_weight(address _gauge, uint256 _time) private view returns (uint256) {\n        uint256 t = (_time / WEEK) * WEEK;\n        uint256 total_weight = points_sum[t].bias;\n        if (total_weight > 0) {\n            uint256 gauge_weight = points_weight[_gauge][t].bias;\n            return (MULTIPLIER * gauge_weight) / total_weight;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight(address _gauge, uint256 _time) external view returns (uint256) {\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Get gauge weight normalized to 1e18 and also fill all the unfilled\n    ///     values for type and gauge records\n    /// @dev Any address can call, however nothing is recorded if the values are filled already\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight_write(address _gauge, uint256 _time) external returns (uint256) {\n        _get_weight(_gauge);\n        _get_sum();\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Overwrite gauge weight\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function _change_gauge_weight(address _gauge, uint256 _weight) internal {\n        uint256 old_gauge_weight = _get_weight(_gauge);\n        uint256 old_sum = _get_sum();\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n        points_weight[_gauge][next_time].bias = _weight;\n        time_weight[_gauge] = next_time;\n\n        uint256 new_sum = old_sum + _weight - old_gauge_weight;\n        points_sum[next_time].bias = new_sum;\n        time_sum = next_time;\n    }\n\n    /// @notice Allows governance to overwrite gauge weights\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function change_gauge_weight(address _gauge, uint256 _weight) public onlyGovernance {\n        _change_gauge_weight(_gauge, _weight);\n    }\n\n    /// @notice Allocate voting power for changing pool weights\n    /// @param _gauge_addr Gauge which `msg.sender` votes for\n    /// @param _user_weight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0\n    function vote_for_gauge_weights(address _gauge_addr, uint256 _user_weight) external {\n        require(_user_weight >= 0 && _user_weight <= 10_000, \"Invalid user weight\");\n        require(isValidGauge[_gauge_addr], \"Invalid gauge address\");\n        VotingEscrow ve = votingEscrow;\n        (\n            ,\n            /*int128 bias*/\n            int128 slope_, /*uint256 ts*/\n\n        ) = ve.getLastUserPoint(msg.sender);\n        require(slope_ >= 0, \"Invalid slope\");\n        uint256 slope = uint256(uint128(slope_));\n        uint256 lock_end = ve.lockEnd(msg.sender);\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n        require(lock_end > next_time, \"Lock expires too soon\");\n        VotedSlope memory old_slope = vote_user_slopes[msg.sender][_gauge_addr];\n        uint256 old_dt = 0;\n        if (old_slope.end > next_time) old_dt = old_slope.end - next_time;\n        uint256 old_bias = old_slope.slope * old_dt;\n        VotedSlope memory new_slope = VotedSlope({\n            slope: (slope * _user_weight) / 10_000,\n            end: lock_end,\n            power: _user_weight\n        });\n        uint256 new_dt = lock_end - next_time;\n        uint256 new_bias = new_slope.slope * new_dt;\n\n        // Check and update powers (weights) used\n        uint256 power_used = vote_user_power[msg.sender];\n        power_used = power_used + new_slope.power - old_slope.power;\n        require(power_used >= 0 && power_used <= 10_000, \"Used too much power\");\n        vote_user_power[msg.sender] = power_used;\n\n        // Remove old and schedule new slope changes\n        // Remove slope changes for old slopes\n        // Schedule recording of initial slope for next_time\n        uint256 old_weight_bias = _get_weight(_gauge_addr);\n        uint256 old_weight_slope = points_weight[_gauge_addr][next_time].slope;\n        uint256 old_sum_bias = _get_sum();\n        uint256 old_sum_slope = points_sum[next_time].slope;\n\n        points_weight[_gauge_addr][next_time].bias = Math.max(old_weight_bias + new_bias, old_bias) - old_bias;\n        points_sum[next_time].bias = Math.max(old_sum_bias + new_bias, old_bias) - old_bias;\n        if (old_slope.end > next_time) {\n            points_weight[_gauge_addr][next_time].slope =\n                Math.max(old_weight_slope + new_slope.slope, old_slope.slope) -\n                old_slope.slope;\n            points_sum[next_time].slope = Math.max(old_sum_slope + new_slope.slope, old_slope.slope) - old_slope.slope;\n        } else {\n            points_weight[_gauge_addr][next_time].slope += new_slope.slope;\n            points_sum[next_time].slope += new_slope.slope;\n        }\n        if (old_slope.end > block.timestamp) {\n            // Cancel old slope changes if they still didn't happen\n            changes_weight[_gauge_addr][old_slope.end] -= old_slope.slope;\n            changes_sum[old_slope.end] -= old_slope.slope;\n        }\n        // Add slope changes for new slopes\n        changes_weight[_gauge_addr][new_slope.end] += new_slope.slope;\n        changes_sum[new_slope.end] += new_slope.slope;\n\n        _get_sum();\n\n        vote_user_slopes[msg.sender][_gauge_addr] = new_slope;\n\n        // Record last action time\n        last_user_vote[msg.sender][_gauge_addr] = block.timestamp;\n    }\n\n    /// @notice Get current gauge weight\n    /// @param _gauge Gauge address\n    /// @return Gauge weight\n    function get_gauge_weight(address _gauge) external view returns (uint256) {\n        return points_weight[_gauge][time_weight[_gauge]].bias;\n    }\n\n    /// @notice Get total weight\n    /// @return Total weight\n    function get_total_weight() external view returns (uint256) {\n        return points_sum[time_sum].bias;\n    }\n}"
    },
    {
      "filename": "src/GaugeController.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title  GaugeController\n/// @author Curve Finance (MIT) - original concept and implementation in Vyper\n///         mkt.market - Porting to Solidity with some modifications (this version)\n/// @notice Allows users to vote on distribution of CANTO that the contract receives from governance. Modifications from Curve:\n///         - Gauge types removed (resulting in the removal of the differentiation between tracking of total / sum)\n///         - Different whitelisting of gauge addresses because of removed types\n///         - Removal of gauges\ncontract GaugeController {\n    // Constants\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant MULTIPLIER = 10**18;\n\n    // Events\n    event NewGauge(address indexed gauge_address);\n    event GaugeRemoved(address indexed gauge_address);\n\n    // State\n    VotingEscrow public votingEscrow;\n    address public governance;\n    mapping(address => bool) public isValidGauge;\n    mapping(address => mapping(address => VotedSlope)) public vote_user_slopes;\n    mapping(address => uint256) public vote_user_power;\n    mapping(address => mapping(address => uint256)) public last_user_vote;\n\n    mapping(address => mapping(uint256 => Point)) public points_weight;\n    mapping(address => mapping(uint256 => uint256)) public changes_weight;\n    mapping(address => uint256) time_weight;\n\n    mapping(uint256 => Point) points_sum;\n    mapping(uint256 => uint256) changes_sum;\n    uint256 public time_sum;\n\n    struct Point {\n        uint256 bias;\n        uint256 slope;\n    }\n\n    struct VotedSlope {\n        uint256 slope;\n        uint256 power;\n        uint256 end;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    /// @notice Initializes state\n    /// @param _votingEscrow The voting escrow address\n    constructor(address _votingEscrow, address _governance) {\n        votingEscrow = VotingEscrow(_votingEscrow);\n        governance = _governance; // TODO: Maybe change to Oracle\n        uint256 last_epoch = (block.timestamp / WEEK) * WEEK;\n        time_sum = last_epoch;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins and return the sum for the future week\n    /// @return Sum of weights\n    function _get_sum() internal returns (uint256) {\n        uint256 t = time_sum;\n        Point memory pt = points_sum[t];\n        for (uint256 i; i < 500; ++i) {\n            if (t > block.timestamp) break;\n            t += WEEK;\n            uint256 d_bias = pt.slope * WEEK;\n            if (pt.bias > d_bias) {\n                pt.bias -= d_bias;\n                uint256 d_slope = changes_sum[t];\n                pt.slope -= d_slope;\n            } else {\n                pt.bias = 0;\n                pt.slope = 0;\n            }\n            points_sum[t] = pt;\n            if (t > block.timestamp) time_sum = t;\n        }\n        return pt.bias;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins\n    /// and return the total for the future week\n    /// @param _gauge_addr Address of the gauge\n    /// @return Gauge weight\n    function _get_weight(address _gauge_addr) private returns (uint256) {\n        uint256 t = time_weight[_gauge_addr];\n        if (t > 0) {\n            Point memory pt = points_weight[_gauge_addr][t];\n            for (uint256 i; i < 500; ++i) {\n                if (t > block.timestamp) break;\n                t += WEEK;\n                uint256 d_bias = pt.slope * WEEK;\n                if (pt.bias > d_bias) {\n                    pt.bias -= d_bias;\n                    uint256 d_slope = changes_weight[_gauge_addr][t];\n                    pt.slope -= d_slope;\n                } else {\n                    pt.bias = 0;\n                    pt.slope = 0;\n                }\n                points_weight[_gauge_addr][t] = pt;\n                if (t > block.timestamp) time_weight[_gauge_addr] = t;\n            }\n            return pt.bias;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Add a new gauge, only callable by governance\n    /// @param _gauge The gauge address\n    function add_gauge(address _gauge) external onlyGovernance {\n        require(!isValidGauge[_gauge], \"Gauge already exists\");\n        isValidGauge[_gauge] = true;\n        emit NewGauge(_gauge);\n    }\n\n    /// @notice Remove a gauge, only callable by governance\n    /// @dev Sets the gauge weight to 0\n    /// @param _gauge The gauge address\n    function remove_gauge(address _gauge) external onlyGovernance {\n        require(isValidGauge[_gauge], \"Invalid gauge address\");\n        isValidGauge[_gauge] = false;\n        _change_gauge_weight(_gauge, 0);\n        emit GaugeRemoved(_gauge);\n    }\n\n    /// @notice Checkpoint to fill data common for all gauges\n    function checkpoint() external {\n        _get_sum();\n    }\n\n    /// @notice Checkpoint to fill data for both a specific gauge and common for all gauges\n    /// @param _gauge The gauge address\n    function checkpoint_gauge(address _gauge) external {\n        _get_weight(_gauge);\n        _get_sum();\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function _gauge_relative_weight(address _gauge, uint256 _time) private view returns (uint256) {\n        uint256 t = (_time / WEEK) * WEEK;\n        uint256 total_weight = points_sum[t].bias;\n        if (total_weight > 0) {\n            uint256 gauge_weight = points_weight[_gauge][t].bias;\n            return (MULTIPLIER * gauge_weight) / total_weight;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight(address _gauge, uint256 _time) external view returns (uint256) {\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Get gauge weight normalized to 1e18 and also fill all the unfilled\n    ///     values for type and gauge records\n    /// @dev Any address can call, however nothing is recorded if the values are filled already\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight_write(address _gauge, uint256 _time) external returns (uint256) {\n        _get_weight(_gauge);\n        _get_sum();\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Overwrite gauge weight\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function _change_gauge_weight(address _gauge, uint256 _weight) internal {\n        uint256 old_gauge_weight = _get_weight(_gauge);\n        uint256 old_sum = _get_sum();\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n        points_weight[_gauge][next_time].bias = _weight;\n        time_weight[_gauge] = next_time;\n\n        uint256 new_sum = old_sum + _weight - old_gauge_weight;\n        points_sum[next_time].bias = new_sum;\n        time_sum = next_time;\n    }\n\n    /// @notice Allows governance to overwrite gauge weights\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function change_gauge_weight(address _gauge, uint256 _weight) public onlyGovernance {\n        _change_gauge_weight(_gauge, _weight);\n    }\n\n    /// @notice Allocate voting power for changing pool weights\n    /// @param _gauge_addr Gauge which `msg.sender` votes for\n    /// @param _user_weight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0\n    function vote_for_gauge_weights(address _gauge_addr, uint256 _user_weight) external {\n        require(_user_weight >= 0 && _user_weight <= 10_000, \"Invalid user weight\");\n        require(isValidGauge[_gauge_addr], \"Invalid gauge address\");\n        VotingEscrow ve = votingEscrow;\n        (\n            ,\n            /*int128 bias*/\n            int128 slope_, /*uint256 ts*/\n\n        ) = ve.getLastUserPoint(msg.sender);\n        require(slope_ >= 0, \"Invalid slope\");\n        uint256 slope = uint256(uint128(slope_));\n        uint256 lock_end = ve.lockEnd(msg.sender);\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n        require(lock_end > next_time, \"Lock expires too soon\");\n        VotedSlope memory old_slope = vote_user_slopes[msg.sender][_gauge_addr];\n        uint256 old_dt = 0;\n        if (old_slope.end > next_time) old_dt = old_slope.end - next_time;\n        uint256 old_bias = old_slope.slope * old_dt;\n        VotedSlope memory new_slope = VotedSlope({\n            slope: (slope * _user_weight) / 10_000,\n            end: lock_end,\n            power: _user_weight\n        });\n        uint256 new_dt = lock_end - next_time;\n        uint256 new_bias = new_slope.slope * new_dt;\n\n        // Check and update powers (weights) used\n        uint256 power_used = vote_user_power[msg.sender];\n        power_used = power_used + new_slope.power - old_slope.power;\n        require(power_used >= 0 && power_used <= 10_000, \"Used too much power\");\n        vote_user_power[msg.sender] = power_used;\n\n        // Remove old and schedule new slope changes\n        // Remove slope changes for old slopes\n        // Schedule recording of initial slope for next_time\n        uint256 old_weight_bias = _get_weight(_gauge_addr);\n        uint256 old_weight_slope = points_weight[_gauge_addr][next_time].slope;\n        uint256 old_sum_bias = _get_sum();\n        uint256 old_sum_slope = points_sum[next_time].slope;\n\n        points_weight[_gauge_addr][next_time].bias = Math.max(old_weight_bias + new_bias, old_bias) - old_bias;\n        points_sum[next_time].bias = Math.max(old_sum_bias + new_bias, old_bias) - old_bias;\n        if (old_slope.end > next_time) {\n            points_weight[_gauge_addr][next_time].slope =\n                Math.max(old_weight_slope + new_slope.slope, old_slope.slope) -\n                old_slope.slope;\n            points_sum[next_time].slope = Math.max(old_sum_slope + new_slope.slope, old_slope.slope) - old_slope.slope;\n        } else {\n            points_weight[_gauge_addr][next_time].slope += new_slope.slope;\n            points_sum[next_time].slope += new_slope.slope;\n        }\n        if (old_slope.end > block.timestamp) {\n            // Cancel old slope changes if they still didn't happen\n            changes_weight[_gauge_addr][old_slope.end] -= old_slope.slope;\n            changes_sum[old_slope.end] -= old_slope.slope;\n        }\n        // Add slope changes for new slopes\n        changes_weight[_gauge_addr][new_slope.end] += new_slope.slope;\n        changes_sum[new_slope.end] += new_slope.slope;\n\n        _get_sum();\n\n        vote_user_slopes[msg.sender][_gauge_addr] = new_slope;\n\n        // Record last action time\n        last_user_vote[msg.sender][_gauge_addr] = block.timestamp;\n    }\n\n    /// @notice Get current gauge weight\n    /// @param _gauge Gauge address\n    /// @return Gauge weight\n    function get_gauge_weight(address _gauge) external view returns (uint256) {\n        return points_weight[_gauge][time_weight[_gauge]].bias;\n    }\n\n    /// @notice Get total weight\n    /// @return Total weight\n    function get_total_weight() external view returns (uint256) {\n        return points_sum[time_sum].bias;\n    }\n}"
    }
  ]
}