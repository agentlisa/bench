{
  "Title": "[L04] Not using the registry EIP",
  "Content": "The [Ethereum Improvement Proposal (EIP) 1820 defines a standard registry](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1820.md).\n\n\nInstead of using it, the cLabs team implemented its own [simplified version of the Registry](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/Registry.sol#L11).\n\n\nDeviating from the community accepted standards limits the opportunities to interoperate with other systems and to use shared implementations that are collectively maintained and already tested in mainnet by other projects.\n\n\nConsider using the [`OpenZeppelin` implementation of the EIP 1820 registry](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/release-v2.4.0/contracts/introspection).\n\n\nIf there are important reasons to not use the EIP 1820 registry, consider documenting them.\n\n\n***Update:** Not fixed. cLabs’ statement for this issue:*\n\n\n\n> \n> EIP 1820 serves a different purpose than the Celo Registry.  \n> \n> The Celo Registry is a central “address book” controlled by Governance that 1-1 maps component names to their implementations.  \n> \n> EIP 1820 allows the owner of any address to declare that that address implements a certain interface. There is only a “check if address A implements interface X” functionality.  \n> \n> There is no “lookup contract that is the implementation of X” functionality, which is what the Celo Registry implements.\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/Registry.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IRegistry.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @title Routes identifiers to addresses.\n */\ncontract Registry is IRegistry, Ownable, Initializable {\n  mapping(bytes32 => address) public registry;\n\n  event RegistryUpdated(string identifier, bytes32 indexed identifierHash, address addr);\n\n  function initialize() external initializer {\n    _transferOwnership(msg.sender);\n  }\n\n  /**\n   * @notice Associates the given address with the given identifier.\n   * @param identifier Identifier of contract whose address we want to set.\n   * @param addr Address of contract.\n   */\n  function setAddressFor(string calldata identifier, address addr) external onlyOwner {\n    bytes32 identifierHash = keccak256(abi.encodePacked(identifier));\n    registry[identifierHash] = addr;\n    emit RegistryUpdated(identifier, identifierHash, addr);\n  }\n\n  /**\n   * @notice Gets address associated with the given identifierHash.\n   * @param identifierHash Identifier hash of contract whose address we want to look up.\n   * @dev Throws if address not set.\n   */\n  function getAddressForOrDie(bytes32 identifierHash) external view returns (address) {\n    require(registry[identifierHash] != address(0), \"identifier has no registry entry\");\n    return registry[identifierHash];\n  }\n\n  /**\n   * @notice Gets address associated with the given identifierHash.\n   * @param identifierHash Identifier hash of contract whose address we want to look up.\n   */\n  function getAddressFor(bytes32 identifierHash) external view returns (address) {\n    return registry[identifierHash];\n  }\n\n  /**\n   * @notice Gets address associated with the given identifier.\n   * @param identifier Identifier of contract whose address we want to look up.\n   * @dev Throws if address not set.\n   */\n  function getAddressForStringOrDie(string calldata identifier) external view returns (address) {\n    bytes32 identifierHash = keccak256(abi.encodePacked(identifier));\n    require(registry[identifierHash] != address(0), \"identifier has no registry entry\");\n    return registry[identifierHash];\n  }\n\n  /**\n   * @notice Gets address associated with the given identifier.\n   * @param identifier Identifier of contract whose address we want to look up.\n   */\n  function getAddressForString(string calldata identifier) external view returns (address) {\n    bytes32 identifierHash = keccak256(abi.encodePacked(identifier));\n    return registry[identifierHash];\n  }\n}"
    }
  ]
}