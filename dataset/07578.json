{
  "Title": "[N-28]  Typos",
  "Content": "\n*There are 3 instances of this issue.*\n\n___\n\n## Excluded Findings\nThese findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness.\n\n### Low Risk Issues\n| |Issue|Instances|\n|-|:-|:-:|\n| [L&#x2011;10] | `safeApprove()` is deprecated | 1 |\n| [L&#x2011;11] | Missing checks for `address(0x0)` when assigning values to `address` state variables | 4 |\n\nTotal: 5 instances over 2 issues\n\n### Non-critical Issues\n| |Issue|Instances|\n|-|:-|:-:|\n| [N&#x2011;29] | Return values of `approve()` not checked | 2 |\n| [N&#x2011;30] | `public` functions not called by the contract should be declared `external` instead | 3 |\n| [N&#x2011;31] | `constant`s should be defined rather than using magic numbers | 2 |\n| [N&#x2011;32] | Event is missing `indexed` fields | 8 |\n\nTotal: 15 instances over 4 issues\n\n### [L&#x2011;10]  `safeApprove()` is deprecated\n[Deprecated](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/bfff03c0d2a59bcd8e2ead1da9aed9edf0080d05/contracts/token/ERC20/utils/SafeERC20.sol#L38-L45) in favor of `safeIncreaseAllowance()` and `safeDecreaseAllowance()`. If only setting the initial allowance to the value that means infinite, `safeIncreaseAllowance()` can be used instead. The function may currently work, but if a bug is found in this version of OpenZeppelin, and the version that you're forced to upgrade to no longer has this function, you'll encounter unnecessary delays in porting and testing replacement contracts.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol\n\n/// @audit (valid but excluded finding)\n555:              IERC20(token).safeApprove(operator, type(uint256).max);\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol#L555\n\n### [L&#x2011;11]  Missing checks for `address(0x0)` when assigning values to `address` state variables\n\n*There are 4 instances of this issue.*\n\n### [N&#x2011;29]  Return values of `approve()` not checked\nNot all `IERC20` implementations `revert()` when there's a failure in `approve()`. The function signature has a `boolean` return value and they indicate errors that way instead. By not checking the return value, operations that should have marked as failed, may potentially go through without actually approving anything\n\n*There are 2 instances of this issue.*\n\n### [N&#x2011;30]  `public` functions not called by the contract should be declared `external` instead\nContracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.\n\n*There are 3 instances of this issue.*\n\n### [N&#x2011;31]  `constant`s should be defined rather than using magic numbers\nEven [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals.\n\n*There are 2 instances of this issue.*\n\n### [N&#x2011;32]  Event is missing `indexed` fields\nIndex event fields make the field more quickly accessible [to off-chain tools](https://ethereum.stackexchange.com/questions/40396/can-somebody-please-explain-the-concept-of-event-indexing) that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each `event` should use three `indexed` fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.\n\n*There are 8 instances of this issue.*\n\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-11-paraspace",
  "Code": [
    {
      "filename": "contracts/token/ERC20/utils/SafeERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"
    },
    {
      "filename": "paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC721} from \"../../../dependencies/openzeppelin/contracts/IERC721.sol\";\nimport {INToken} from \"../../../interfaces/INToken.sol\";\nimport {IPoolAddressesProvider} from \"../../../interfaces/IPoolAddressesProvider.sol\";\nimport {XTokenType} from \"../../../interfaces/IXTokenType.sol\";\nimport {ICollateralizableERC721} from \"../../../interfaces/ICollateralizableERC721.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {IPToken} from \"../../../interfaces/IPToken.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\nimport {SupplyLogic} from \"./SupplyLogic.sol\";\nimport {BorrowLogic} from \"./BorrowLogic.sol\";\nimport {SeaportInterface} from \"../../../dependencies/seaport/contracts/interfaces/SeaportInterface.sol\";\nimport {SafeERC20} from \"../../../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport {IERC20} from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport {IERC721} from \"../../../dependencies/openzeppelin/contracts/IERC721.sol\";\nimport {ConsiderationItem, OfferItem} from \"../../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {ItemType} from \"../../../dependencies/seaport/contracts/lib/ConsiderationEnums.sol\";\nimport {AdvancedOrder, CriteriaResolver, Fulfillment} from \"../../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {IWETH} from \"../../../misc/interfaces/IWETH.sol\";\nimport {UserConfiguration} from \"../configuration/UserConfiguration.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {IMarketplace} from \"../../../interfaces/IMarketplace.sol\";\nimport {Address} from \"../../../dependencies/openzeppelin/contracts/Address.sol\";\n\n/**\n * @title Marketplace library\n *\n * @notice Implements the base logic for all the actions related to NFT buy/accept bid\n */\nlibrary MarketplaceLogic {\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using SafeERC20 for IERC20;\n\n    event BuyWithCredit(\n        bytes32 indexed marketplaceId,\n        DataTypes.OrderInfo orderInfo,\n        DataTypes.Credit credit\n    );\n\n    event AcceptBidWithCredit(\n        bytes32 indexed marketplaceId,\n        DataTypes.OrderInfo orderInfo,\n        DataTypes.Credit credit\n    );\n\n    struct MarketplaceLocalVars {\n        bool isETH;\n        address xTokenAddress;\n        address creditToken;\n        uint256 creditAmount;\n        address weth;\n        uint256 ethLeft;\n        bytes32 marketplaceId;\n        bytes payload;\n        DataTypes.Marketplace marketplace;\n        DataTypes.OrderInfo orderInfo;\n    }\n\n    function executeBuyWithCredit(\n        bytes32 marketplaceId,\n        bytes calldata payload,\n        DataTypes.Credit calldata credit,\n        DataTypes.PoolStorage storage ps,\n        IPoolAddressesProvider poolAddressProvider,\n        uint16 referralCode\n    ) external {\n        MarketplaceLocalVars memory vars;\n\n        vars.weth = poolAddressProvider.getWETH();\n        DataTypes.Marketplace memory marketplace = poolAddressProvider\n            .getMarketplace(marketplaceId);\n        DataTypes.OrderInfo memory orderInfo = IMarketplace(marketplace.adapter)\n            .getAskOrderInfo(payload, vars.weth);\n        orderInfo.taker = msg.sender;\n        vars.ethLeft = msg.value;\n\n        _depositETH(vars, orderInfo);\n\n        vars.ethLeft -= _buyWithCredit(\n            ps._reserves,\n            ps._reservesList,\n            ps._usersConfig[orderInfo.taker],\n            DataTypes.ExecuteMarketplaceParams({\n                marketplaceId: marketplaceId,\n                payload: payload,\n                credit: credit,\n                ethLeft: vars.ethLeft,\n                marketplace: marketplace,\n                orderInfo: orderInfo,\n                weth: vars.weth,\n                referralCode: referralCode,\n                reservesCount: ps._reservesCount,\n                oracle: poolAddressProvider.getPriceOracle(),\n                priceOracleSentinel: poolAddressProvider.getPriceOracleSentinel()\n            })\n        );\n\n        _refundETH(vars.ethLeft);\n    }\n\n    /**\n     * @notice Implements the buyWithCredit feature. BuyWithCredit allows users to buy NFT from various NFT marketplaces\n     * including OpenSea, LooksRare, X2Y2 etc. Users can use NFT's credit and will need to pay at most (1 - LTV) * $NFT\n     * @dev  Emits the `BuyWithCredit()` event\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the buyWithCredit function\n     */\n    function _buyWithCredit(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteMarketplaceParams memory params\n    ) internal returns (uint256) {\n        ValidationLogic.validateBuyWithCredit(params);\n\n        MarketplaceLocalVars memory vars = _cache(params);\n\n        _borrowTo(reservesData, params, vars, address(this));\n\n        (uint256 priceEth, uint256 downpaymentEth) = _delegateToPool(\n            params,\n            vars\n        );\n\n        // delegateCall to avoid extra token transfer\n        Address.functionDelegateCall(\n            params.marketplace.adapter,\n            abi.encodeWithSelector(\n                IMarketplace.matchAskWithTakerBid.selector,\n                params.marketplace.marketplace,\n                params.payload,\n                priceEth\n            )\n        );\n\n        _repay(\n            reservesData,\n            reservesList,\n            userConfig,\n            params,\n            vars,\n            params.orderInfo.taker\n        );\n\n        emit BuyWithCredit(\n            params.marketplaceId,\n            params.orderInfo,\n            params.credit\n        );\n\n        return downpaymentEth;\n    }\n\n    function executeBatchBuyWithCredit(\n        bytes32[] calldata marketplaceIds,\n        bytes[] calldata payloads,\n        DataTypes.Credit[] calldata credits,\n        DataTypes.PoolStorage storage ps,\n        IPoolAddressesProvider poolAddressProvider,\n        uint16 referralCode\n    ) external {\n        MarketplaceLocalVars memory vars;\n\n        vars.weth = poolAddressProvider.getWETH();\n        require(\n            marketplaceIds.length == payloads.length &&\n                payloads.length == credits.length,\n            Errors.INCONSISTENT_PARAMS_LENGTH\n        );\n        vars.ethLeft = msg.value;\n        for (uint256 i = 0; i < marketplaceIds.length; i++) {\n            vars.marketplaceId = marketplaceIds[i];\n            vars.payload = payloads[i];\n            DataTypes.Credit memory credit = credits[i];\n\n            DataTypes.Marketplace memory marketplace = poolAddressProvider\n                .getMarketplace(vars.marketplaceId);\n            DataTypes.OrderInfo memory orderInfo = IMarketplace(\n                marketplace.adapter\n            ).getAskOrderInfo(vars.payload, vars.weth);\n            orderInfo.taker = msg.sender;\n\n            // Once we encounter a listing using WETH, then we convert all our ethLeft to WETH\n            // this also means that the parameters order is very important\n            //\n            // frontend/sdk needs to guarantee that WETH orders will always be put after ALL\n            // ETH orders, all ETH orders after WETH orders will fail\n            //\n            // eg. The following example image that the `taker` owns only ETH and wants to\n            // batch buy bunch of NFTs which are listed using WETH and ETH\n            //\n            // batchBuyWithCredit([ETH, WETH, ETH]) => ko\n            //                            | -> convert all ethLeft to WETH, 3rd purchase will fail\n            // batchBuyWithCredit([ETH, ETH, ETH]) => ok\n            // batchBuyWithCredit([ETH, ETH, WETH]) => ok\n            //\n            _depositETH(vars, orderInfo);\n\n            vars.ethLeft -= _buyWithCredit(\n                ps._reserves,\n                ps._reservesList,\n                ps._usersConfig[orderInfo.taker],\n                DataTypes.ExecuteMarketplaceParams({\n                    marketplaceId: vars.marketplaceId,\n                    payload: vars.payload,\n                    credit: credit,\n                    ethLeft: vars.ethLeft,\n                    marketplace: marketplace,\n                    orderInfo: orderInfo,\n                    weth: vars.weth,\n                    referralCode: referralCode,\n                    reservesCount: ps._reservesCount,\n                    oracle: poolAddressProvider.getPriceOracle(),\n                    priceOracleSentinel: poolAddressProvider\n                        .getPriceOracleSentinel()\n                })\n            );\n        }\n\n        _refundETH(vars.ethLeft);\n    }\n\n    function executeAcceptBidWithCredit(\n        bytes32 marketplaceId,\n        bytes calldata payload,\n        DataTypes.Credit calldata credit,\n        address onBehalfOf,\n        DataTypes.PoolStorage storage ps,\n        IPoolAddressesProvider poolAddressProvider,\n        uint16 referralCode\n    ) external {\n        MarketplaceLocalVars memory vars;\n\n        vars.weth = poolAddressProvider.getWETH();\n        vars.marketplace = poolAddressProvider.getMarketplace(marketplaceId);\n        vars.orderInfo = IMarketplace(vars.marketplace.adapter).getBidOrderInfo(\n            payload\n        );\n        require(vars.orderInfo.taker == onBehalfOf, Errors.INVALID_ORDER_TAKER);\n\n        _acceptBidWithCredit(\n            ps._reserves,\n            ps._reservesList,\n            ps._usersConfig[vars.orderInfo.maker],\n            DataTypes.ExecuteMarketplaceParams({\n                marketplaceId: marketplaceId,\n                payload: payload,\n                credit: credit,\n                ethLeft: 0,\n                marketplace: vars.marketplace,\n                orderInfo: vars.orderInfo,\n                weth: vars.weth,\n                referralCode: referralCode,\n                reservesCount: ps._reservesCount,\n                oracle: poolAddressProvider.getPriceOracle(),\n                priceOracleSentinel: poolAddressProvider.getPriceOracleSentinel()\n            })\n        );\n    }\n\n    function executeBatchAcceptBidWithCredit(\n        bytes32[] calldata marketplaceIds,\n        bytes[] calldata payloads,\n        DataTypes.Credit[] calldata credits,\n        address onBehalfOf,\n        DataTypes.PoolStorage storage ps,\n        IPoolAddressesProvider poolAddressProvider,\n        uint16 referralCode\n    ) external {\n        MarketplaceLocalVars memory vars;\n\n        vars.weth = poolAddressProvider.getWETH();\n        require(\n            marketplaceIds.length == payloads.length &&\n                payloads.length == credits.length,\n            Errors.INCONSISTENT_PARAMS_LENGTH\n        );\n        for (uint256 i = 0; i < marketplaceIds.length; i++) {\n            vars.marketplaceId = marketplaceIds[i];\n            vars.payload = payloads[i];\n            DataTypes.Credit memory credit = credits[i];\n\n            vars.marketplace = poolAddressProvider.getMarketplace(\n                vars.marketplaceId\n            );\n            vars.orderInfo = IMarketplace(vars.marketplace.adapter)\n                .getBidOrderInfo(vars.payload);\n            require(\n                vars.orderInfo.taker == onBehalfOf,\n                Errors.INVALID_ORDER_TAKER\n            );\n\n            _acceptBidWithCredit(\n                ps._reserves,\n                ps._reservesList,\n                ps._usersConfig[vars.orderInfo.maker],\n                DataTypes.ExecuteMarketplaceParams({\n                    marketplaceId: vars.marketplaceId,\n                    payload: vars.payload,\n                    credit: credit,\n                    ethLeft: 0,\n                    marketplace: vars.marketplace,\n                    orderInfo: vars.orderInfo,\n                    weth: vars.weth,\n                    referralCode: referralCode,\n                    reservesCount: ps._reservesCount,\n                    oracle: poolAddressProvider.getPriceOracle(),\n                    priceOracleSentinel: poolAddressProvider\n                        .getPriceOracleSentinel()\n                })\n            );\n        }\n    }\n\n    /**\n     * @notice Implements the acceptBidWithCredit feature. AcceptBidWithCredit allows users to\n     * accept a leveraged bid on ParaSpace NFT marketplace. Users can submit leveraged bid and pay\n     * at most (1 - LTV) * $NFT\n     * @dev  Emits the `AcceptBidWithCredit()` event\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the acceptBidWithCredit function\n     */\n    function _acceptBidWithCredit(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteMarketplaceParams memory params\n    ) internal {\n        ValidationLogic.validateAcceptBidWithCredit(params);\n\n        MarketplaceLocalVars memory vars = _cache(params);\n\n        _borrowTo(reservesData, params, vars, params.orderInfo.maker);\n\n        // delegateCall to avoid extra token transfer\n        Address.functionDelegateCall(\n            params.marketplace.adapter,\n            abi.encodeWithSelector(\n                IMarketplace.matchBidWithTakerAsk.selector,\n                params.marketplace.marketplace,\n                params.payload\n            )\n        );\n\n        _repay(\n            reservesData,\n            reservesList,\n            userConfig,\n            params,\n            vars,\n            params.orderInfo.maker\n        );\n\n        emit AcceptBidWithCredit(\n            params.marketplaceId,\n            params.orderInfo,\n            params.credit\n        );\n    }\n\n    /**\n     * @notice Transfer payNow portion from taker to this contract. This is only useful\n     * in buyWithCredit.\n     * @dev\n     * @param params The additional parameters needed to execute the buyWithCredit/acceptBidWithCredit function\n     * @param vars The marketplace local vars for caching storage values for future reads\n     */\n    function _delegateToPool(\n        DataTypes.ExecuteMarketplaceParams memory params,\n        MarketplaceLocalVars memory vars\n    ) internal returns (uint256, uint256) {\n        uint256 price = 0;\n\n        for (uint256 i = 0; i < params.orderInfo.consideration.length; i++) {\n            ConsiderationItem memory item = params.orderInfo.consideration[i];\n            require(\n                item.startAmount == item.endAmount,\n                Errors.INVALID_MARKETPLACE_ORDER\n            );\n            require(\n                item.itemType == ItemType.ERC20 ||\n                    (vars.isETH && item.itemType == ItemType.NATIVE),\n                Errors.INVALID_ASSET_TYPE\n            );\n            require(\n                item.token == params.credit.token,\n                Errors.CREDIT_DOES_NOT_MATCH_ORDER\n            );\n            price += item.startAmount;\n        }\n\n        uint256 downpayment = price - vars.creditAmount;\n        if (!vars.isETH) {\n            IERC20(vars.creditToken).safeTransferFrom(\n                params.orderInfo.taker,\n                address(this),\n                downpayment\n            );\n            _checkAllowance(vars.creditToken, params.marketplace.operator);\n            // convert to (priceEth, downpaymentEth)\n            price = 0;\n            downpayment = 0;\n        } else {\n            require(params.ethLeft >= downpayment, Errors.PAYNOW_NOT_ENOUGH);\n        }\n\n        return (price, downpayment);\n    }\n\n    /**\n     * @notice Borrow credit.amount from `credit.token` reserve without collateral. The corresponding\n     * debt will be minted in the same block to the borrower.\n     * @dev\n     * @param reservesData The state of all the reserves\n     * @param params The additional parameters needed to execute the buyWithCredit/acceptBidWithCredit function\n     * @param vars The marketplace local vars for caching storage values for future reads\n     * @param to The receiver of borrowed tokens\n     */\n    function _borrowTo(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.ExecuteMarketplaceParams memory params,\n        MarketplaceLocalVars memory vars,\n        address to\n    ) internal {\n        if (vars.creditAmount == 0) {\n            return;\n        }\n\n        DataTypes.ReserveData storage reserve = reservesData[vars.creditToken];\n        vars.xTokenAddress = reserve.xTokenAddress;\n\n        require(vars.xTokenAddress != address(0), Errors.ASSET_NOT_LISTED);\n        ValidationLogic.validateFlashloanSimple(reserve);\n        // TODO: support PToken\n        IPToken(vars.xTokenAddress).transferUnderlyingTo(to, vars.creditAmount);\n\n        if (vars.isETH) {\n            // No re-entrancy because it sent to our contract address\n            IWETH(params.weth).withdraw(vars.creditAmount);\n        }\n    }\n\n    /**\n     * @notice Repay credit.amount by minting debt to the borrower. Borrower's received NFT\n     * will also need to be supplied to the pool to provide bigger borrow limit.\n     * @dev\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the buyWithCredit/acceptBidWithCredit function\n     * @param vars The marketplace local vars for caching storage values for future reads\n     * @param onBehalfOf The receiver of minted debt and NToken\n     */\n    function _repay(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteMarketplaceParams memory params,\n        MarketplaceLocalVars memory vars,\n        address onBehalfOf\n    ) internal {\n        for (uint256 i = 0; i < params.orderInfo.offer.length; i++) {\n            OfferItem memory item = params.orderInfo.offer[i];\n            require(\n                item.itemType == ItemType.ERC721,\n                Errors.INVALID_ASSET_TYPE\n            );\n\n            // underlyingAsset\n            address token = item.token;\n            uint256 tokenId = item.identifierOrCriteria;\n            // NToken\n            vars.xTokenAddress = reservesData[token].xTokenAddress;\n\n            // item.token == NToken\n            if (vars.xTokenAddress == address(0)) {\n                address underlyingAsset = INToken(token)\n                    .UNDERLYING_ASSET_ADDRESS();\n                bool isNToken = reservesData[underlyingAsset].xTokenAddress ==\n                    token;\n                require(isNToken, Errors.ASSET_NOT_LISTED);\n                vars.xTokenAddress = token;\n                token = underlyingAsset;\n            }\n\n            require(\n                INToken(vars.xTokenAddress).getXTokenType() !=\n                    XTokenType.NTokenUniswapV3,\n                Errors.UNIV3_NOT_ALLOWED\n            );\n\n            // item.token == underlyingAsset but supplied after listing/offering\n            // so NToken is transferred instead\n            if (INToken(vars.xTokenAddress).ownerOf(tokenId) == address(this)) {\n                _transferAndCollateralize(\n                    reservesData,\n                    userConfig,\n                    vars,\n                    token,\n                    tokenId,\n                    onBehalfOf\n                );\n                // item.token == underlyingAsset and underlyingAsset stays in wallet\n            } else {\n                DataTypes.ERC721SupplyParams[]\n                    memory tokenData = new DataTypes.ERC721SupplyParams[](1);\n                tokenData[0] = DataTypes.ERC721SupplyParams(tokenId, true);\n                SupplyLogic.executeSupplyERC721(\n                    reservesData,\n                    userConfig,\n                    DataTypes.ExecuteSupplyERC721Params({\n                        asset: token,\n                        tokenData: tokenData,\n                        onBehalfOf: onBehalfOf,\n                        payer: address(this),\n                        referralCode: params.referralCode\n                    })\n                );\n            }\n        }\n\n        if (vars.creditAmount == 0) {\n            return;\n        }\n\n        BorrowLogic.executeBorrow(\n            reservesData,\n            reservesList,\n            userConfig,\n            DataTypes.ExecuteBorrowParams({\n                asset: vars.creditToken,\n                user: onBehalfOf,\n                onBehalfOf: onBehalfOf,\n                amount: vars.creditAmount,\n                referralCode: params.referralCode,\n                releaseUnderlying: false,\n                reservesCount: params.reservesCount,\n                oracle: params.oracle,\n                priceOracleSentinel: params.priceOracleSentinel\n            })\n        );\n    }\n\n    function _checkAllowance(address token, address operator) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), operator);\n        if (allowance == 0) {\n            IERC20(token).safeApprove(operator, type(uint256).max);\n        }\n    }\n\n    function _cache(DataTypes.ExecuteMarketplaceParams memory params)\n        internal\n        pure\n        returns (MarketplaceLocalVars memory vars)\n    {\n        vars.isETH = params.credit.token == address(0);\n        vars.creditToken = vars.isETH ? params.weth : params.credit.token;\n        vars.creditAmount = params.credit.amount;\n    }\n\n    function _refundETH(uint256 ethLeft) internal {\n        if (ethLeft > 0) {\n            Address.sendValue(payable(msg.sender), ethLeft);\n        }\n    }\n\n    function _depositETH(\n        MarketplaceLocalVars memory vars,\n        DataTypes.OrderInfo memory orderInfo\n    ) internal {\n        if (\n            vars.ethLeft > 0 &&\n            orderInfo.consideration[0].itemType != ItemType.NATIVE\n        ) {\n            IWETH(vars.weth).deposit{value: vars.ethLeft}();\n            IERC20(vars.weth).safeTransferFrom(\n                address(this),\n                msg.sender,\n                vars.ethLeft\n            );\n            vars.ethLeft = 0;\n        }\n    }\n\n    function _transferAndCollateralize(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.UserConfigurationMap storage userConfig,\n        MarketplaceLocalVars memory vars,\n        address token,\n        uint256 tokenId,\n        address onBehalfOf\n    ) internal {\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = tokenId;\n\n        IERC721(vars.xTokenAddress).safeTransferFrom(\n            address(this),\n            onBehalfOf,\n            tokenId\n        );\n        SupplyLogic.executeCollateralizeERC721(\n            reservesData,\n            userConfig,\n            token,\n            tokenIds,\n            onBehalfOf\n        );\n    }\n}"
    },
    {
      "filename": "contracts/lib/TokenTransferrer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\nimport \"./TokenTransferrerConstants.sol\";\n\n// prettier-ignore\nimport {\n    TokenTransferrerErrors\n} from \"../interfaces/TokenTransferrerErrors.sol\";\n\nimport { ConduitBatch1155Transfer } from \"../conduit/lib/ConduitStructs.sol\";\n\ncontract TokenTransferrer is TokenTransferrerErrors {\n    /**\n     * @dev Internal function to transfer ERC20 tokens from a given originator\n     *      to a given recipient. Sufficient approvals must be set on the\n     *      contract performing the transfer.\n     *\n     * @param token      The ERC20 token to transfer.\n     * @param from       The originator of the transfer.\n     * @param to         The recipient of the transfer.\n     * @param amount     The amount to transfer.\n     */\n    function _performERC20Transfer(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        // Utilize assembly to perform an optimized ERC20 token transfer.\n        assembly {\n            // Write calldata to the free memory pointer, but restore it later.\n            let memPointer := mload(FreeMemoryPointerSlot)\n\n            // Write calldata into memory, starting with function selector.\n            mstore(ERC20_transferFrom_sig_ptr, ERC20_transferFrom_signature)\n            mstore(ERC20_transferFrom_from_ptr, from)\n            mstore(ERC20_transferFrom_to_ptr, to)\n            mstore(ERC20_transferFrom_amount_ptr, amount)\n\n            // Make call & copy up to 32 bytes of return data to scratch space.\n            let callStatus := call(\n                gas(),\n                token,\n                0,\n                ERC20_transferFrom_sig_ptr,\n                ERC20_transferFrom_length,\n                0,\n                OneWord\n            )\n\n            // Determine whether transfer was successful using status & result.\n            let success := and(\n                // Set success to whether the call reverted, if not check it\n                // either returned exactly 1 (can't just be non-zero data), or\n                // had no return data.\n                or(\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\n                    iszero(returndatasize())\n                ),\n                callStatus\n            )\n\n            // If the transfer failed or it returned nothing:\n            // Group these because they should be uncommon.\n            // Equivalent to `or(iszero(success), iszero(returndatasize()))`\n            // but after it's inverted for JUMPI this expression is cheaper.\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\n                // If the token has no code or the transfer failed:\n                // Equivalent to `or(iszero(success), iszero(extcodesize(token)))`\n                // but after it's inverted for JUMPI this expression is cheaper.\n                if iszero(and(iszero(iszero(extcodesize(token))), success)) {\n                    // If the transfer failed:\n                    if iszero(success) {\n                        // If it was due to a revert:\n                        if iszero(callStatus) {\n                            // If it returned a message, bubble it up as long as\n                            // sufficient gas remains to do so:\n                            if returndatasize() {\n                                // Ensure that sufficient gas is available to\n                                // copy returndata while expanding memory where\n                                // necessary. Start by computing the word size\n                                // of returndata and allocated memory.\n                                let returnDataWords := div(\n                                    returndatasize(),\n                                    OneWord\n                                )\n\n                                // Note: use the free memory pointer in place of\n                                // msize() to work around a Yul warning that\n                                // prevents accessing msize directly when the IR\n                                // pipeline is activated.\n                                let msizeWords := div(memPointer, OneWord)\n\n                                // Next, compute the cost of the returndatacopy.\n                                let cost := mul(CostPerWord, returnDataWords)\n\n                                // Then, compute cost of new memory allocation.\n                                if gt(returnDataWords, msizeWords) {\n                                    cost := add(\n                                        cost,\n                                        add(\n                                            mul(\n                                                sub(\n                                                    returnDataWords,\n                                                    msizeWords\n                                                ),\n                                                CostPerWord\n                                            ),\n                                            div(\n                                                sub("
    }
  ]
}