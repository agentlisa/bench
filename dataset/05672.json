{
  "Title": "[M-07] Wrong encoding of the data in the `sendCompressedBytecode` function",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1244-L1245><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1255-L1259><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1365><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1542><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/scripts/process.ts#L123><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/Compressor.sol#L54-L82>\n\n### Description\n\nThere is enforcement in the `bootloader::sendCompressedBytecode` function that the data to be used for the call of the `Compressor::publishCompressedBytecode` function is encoded in a standard way.\n\nBut this check contains bugs:\n1. There is no check that the `originalBytecodeOffset` is equal to `afterSelectorPtr + 64`. This leads to the possibility of passing a great number of unused bytes as calldata of the call of the `Compressor::publishCompressedBytecode` function. In this case, the calldata will have the following format:\n\n```\n4                               bytes : `publishCompressedBytecode` selector\n32                              bytes : offset for `_bytecode` parameter                                                  = V\n32                              bytes : offset for `_rawCompressedData` parameter                                         = V + 32 + rounded_len(_bytecode)\n(V - 64)                        bytes : any bytes that will be ignored in the `publishCompressedBytecode` function\n32                              bytes : length of `_bytecode` parameter                                                   = len(_bytecode)\nrounded_len(_bytecode)          bytes : `_bytecode` parameter                                                             = _bytecode \n32                              bytes : length of `_rawCompressedData` parameter                                          = len(_rawCompressedData)\nrounded_len(_rawCompressedData) bytes : `_rawCompressedData` parameter                                                    = _rawCompressedData\n```\n\n2. There are used unsafe \"raw\" arithmetic operations in the calculations of the offsets, while the `safe` analogs should be used. This leads to the possibility of passing absolutely wrong data so the call of the `Compressor::publishCompressedBytecode` function will revert. As this bug does not provide any strong attack vector, I will present only the idea of how to achieve this, not the whole calldata. The offset of the `_bytecode` parameter should be equal `(2**256) - 64` (so the `originalBytecodeOffset` will pass the `checkOffset` check), rest of the parameters is easy to determine over this. The same happens in the `bootloader::validateBytes` function, as in the `bootloader::lengthRoundedByWords` function the overflow happens, leading to the same outcome.\n\n### Impact\n\nThe ability of the operator to pass up to `~COMPRESSED_BYTECODES_SLOTS * 32 = ~1048576` additional bytes into the call of the `Compressor::publishCompressedBytecode` function. Such possibility of spending **part of the transaction gas limit** makes the operator able to actually decrease the L2 transaction gas limit, which leads to the possibility of manipulation of the amount of gas used for the transaction execution.\n\nThe ability of the operator to pass encoding-related checks of the `bootloader::sendCompressedBytecode` function, which leads to the possibility of forcing the `Compressor::publishCompressedBytecode` function call to revert.\n\n### Recommended Mitigation Steps\n\n1. You can add the following check into the `bootloader::sendCompressedBytecode` function:\n\n```solidity\nif iszero(eq(add(afterSelectorPtr, 64), originalBytecodeOffset)) {\n    assertionError(\"Compression calldata incorrect\")\n}\n```\n\n2. You can use `safeAdd` instead of `add` in the corresponding calculations in the `bootloader::sendCompressedBytecode` function.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/807#issuecomment-1845074348):**\n > The Warden has demonstrated how unsafe arithmetic could be used by the operator to pass incorrect data that \"checks\" down to the expected values. This could be used to pass incorrect compressed data as well as abuse gas costs as means to cause end users to be overcharged.\n\n**[vladbochok (zkSync) confirmed](https://github.com/code-423n4/2023-10-zksync-findings/issues/807#issuecomment-1845074348)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/bootloader/bootloader.yul",
      "content": "object \"Bootloader\" {\n    code {\n    }\n    object \"Bootloader_deployed\" {\n        code {\n            ////////////////////////////////////////////////////////////////////////////\n            //                      Function Declarations\n            ////////////////////////////////////////////////////////////////////////////\n\n            // While we definitely cannot control the gas price on L1,\n            // we need to check the operator does not provide any absurd numbers there\n            function MAX_ALLOWED_L1_GAS_PRICE() -> ret {\n                // 100k gwei\n                ret := 100000000000000\n            }\n\n            function MAX_ALLOWED_FAIR_L2_GAS_PRICE() -> ret {\n                // 10k gwei\n                ret := 10000000000000\n            }\n\n            /// @dev This method ensures that the prices provided by the operator\n            /// are not absurdly high\n            function validateOperatorProvidedPrices(l1GasPrice, fairL2GasPrice) {\n                if gt(l1GasPrice, MAX_ALLOWED_L1_GAS_PRICE()) {\n                    assertionError(\"L1 gas price too high\")\n                }\n\n                if gt(fairL2GasPrice, MAX_ALLOWED_FAIR_L2_GAS_PRICE()) {\n                    assertionError(\"L2 fair gas price too high\")\n                }\n            }\n\n            /// @dev Returns the baseFee for this batch based on the\n            /// L1 gas price and the fair L2 gas price.\n            function getBaseFee(l1GasPrice, fairL2GasPrice) -> baseFee, gasPricePerPubdata {\n                // By default, we want to provide the fair L2 gas price.\n                // That it means that the operator controls\n                // what the value of the baseFee will be. In the future, \n                // a better system, aided by EIP1559 should be added. \n\n                let pubdataBytePriceETH := safeMul(l1GasPrice, L1_GAS_PER_PUBDATA_BYTE(), \"aoa\")\n\n                baseFee := max(\n                    fairL2GasPrice,\n                    ceilDiv(pubdataBytePriceETH, MAX_L2_GAS_PER_PUBDATA())\n                )\n                gasPricePerPubdata := ceilDiv(pubdataBytePriceETH, baseFee)\n            }\n\n            /// @dev It should be always possible to submit a transaction \n            /// that consumes such amount of public data.\n            function GUARANTEED_PUBDATA_PER_TX() -> ret {\n                ret := {{GUARANTEED_PUBDATA_BYTES}}\n            }\n\n            /// @dev The maximal gasPerPubdata, which allows users to still be \n            /// able to send `GUARANTEED_PUBDATA_PER_TX` onchain.\n            function MAX_L2_GAS_PER_PUBDATA() -> ret {\n                ret := div(MAX_GAS_PER_TRANSACTION(), GUARANTEED_PUBDATA_PER_TX())\n            }\n\n            /// @dev The computational overhead for a batch.\n            /// It includes the combined price for 1 instance of all the circuits \n            /// (since they might be partially filled), the price for running\n            /// the common parts of the bootloader as well as general maintainance of the system.\n            function BATCH_OVERHEAD_L2_GAS() -> ret {\n                ret := {{BATCH_OVERHEAD_L2_GAS}}\n            }\n\n            /// @dev The overhead for the interaction with L1.\n            /// It should cover proof verification as well as other minor \n            /// overheads for committing/executing a transaction in a batch.\n            function BATCH_OVERHEAD_L1_GAS() -> ret {\n                ret := {{BATCH_OVERHEAD_L1_GAS}}\n            }\n\n            /// @dev The maximal number of gas available to the transaction\n            function MAX_GAS_PER_TRANSACTION() -> ret {\n                ret := {{MAX_GAS_PER_TRANSACTION}}\n            }\n\n            /// @dev The number of L1 gas needed to be spent for\n            /// L1 byte. While a single pubdata byte costs `16` gas, \n            /// we demand at least 17 to cover up for the costs of additional\n            /// hashing of it, etc.\n            function L1_GAS_PER_PUBDATA_BYTE() -> ret {\n                ret := 17\n            }\n\n            /// @dev The size of the bootloader memory that is to spent by the transaction's\n            /// encodings.\n            function BOOTLOADER_MEMORY_FOR_TXS() -> ret {\n                ret := {{BOOTLOADER_MEMORY_FOR_TXS}}\n            }\n\n            /// @dev Whether the batch is allowed to accept transactions with\n            /// gasPerPubdataByteLimit = 0. On mainnet, this is forbidden for safety reasons.\n            function FORBID_ZERO_GAS_PER_PUBDATA() -> ret {\n                ret := {{FORBID_ZERO_GAS_PER_PUBDATA}}\n            }\n            \n            /// @dev The maximum number of transactions per L1 batch.\n            function MAX_TRANSACTIONS_IN_BATCH() -> ret {\n                ret := {{MAX_TRANSACTIONS_IN_BATCH}}\n            }\n\n            /// @dev The slot from which the scratch space starts.\n            /// Scatch space is used for various temporary values\n            function SCRATCH_SPACE_BEGIN_SLOT() -> ret {\n                ret := 8\n            }\n\n            /// @dev The byte from which the scratch space starts.\n            /// Scratch space is used for various temporary values\n            function SCRATCH_SPACE_BEGIN_BYTE() -> ret {\n                ret := mul(SCRATCH_SPACE_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The first 32 slots are reserved for event emitting for the \n            /// debugging purposes\n            function SCRATCH_SPACE_SLOTS() -> ret {\n                ret := 32\n            }\n\n            /// @dev Slots reserved for saving the paymaster context\n            /// @dev The paymasters are allowed to consume at most \n            /// 32 slots (1024 bytes) for their context.\n            /// The 33 slots are required since the first one stores the length of the calldata.\n            function PAYMASTER_CONTEXT_SLOTS() -> ret {\n                ret := 33\n            }\n        \n            /// @dev Bytes reserved for saving the paymaster context\n            function PAYMASTER_CONTEXT_BYTES() -> ret {\n                ret := mul(PAYMASTER_CONTEXT_SLOTS(), 32)\n            }\n\n            /// @dev Slot from which the paymaster context starts\n            function PAYMASTER_CONTEXT_BEGIN_SLOT() -> ret {\n                ret := add(SCRATCH_SPACE_BEGIN_SLOT(), SCRATCH_SPACE_SLOTS())\n            }\n\n            /// @dev The byte from which the paymaster context starts\n            function PAYMASTER_CONTEXT_BEGIN_BYTE() -> ret {\n                ret := mul(PAYMASTER_CONTEXT_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev Each tx must have at least this amount of unused bytes before them to be able to \n            /// encode the postOp operation correctly.\n            function MAX_POSTOP_SLOTS() -> ret {\n                // Before the actual transaction encoding, the postOp contains 6 slots:\n                // 1. Context offset\n                // 2. Transaction offset\n                // 3. Transaction hash\n                // 4. Suggested signed hash\n                // 5. Transaction result\n                // 6. Maximum refunded gas\n                // And one more slot for the padding selector\n                ret := add(PAYMASTER_CONTEXT_SLOTS(), 7)\n            }\n\n            /// @dev Slots needed to store the canonical and signed hash for the current L2 transaction.\n            function CURRENT_L2_TX_HASHES_RESERVED_SLOTS() -> ret {\n                ret := 2\n            }\n\n            /// @dev Slot from which storing of the current canonical and signed hashes begins\n            function CURRENT_L2_TX_HASHES_BEGIN_SLOT() -> ret {\n                ret := add(PAYMASTER_CONTEXT_BEGIN_SLOT(), PAYMASTER_CONTEXT_SLOTS())\n            }\n\n            /// @dev The byte from which storing of the current canonical and signed hashes begins\n            function CURRENT_L2_TX_HASHES_BEGIN_BYTE() -> ret {\n                ret := mul(CURRENT_L2_TX_HASHES_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The maximum number of new factory deps that are allowed in a transaction\n            function MAX_NEW_FACTORY_DEPS() -> ret {\n                ret := 32\n            }\n\n            /// @dev Besides the factory deps themselves, we also need another 4 slots for: \n            /// selector, marker of whether the user should pay for the pubdata,\n            /// the offset for the encoding of the array as well as the length of the array.\n            function NEW_FACTORY_DEPS_RESERVED_SLOTS() -> ret {\n                ret := add(MAX_NEW_FACTORY_DEPS(), 4)\n            }\n\n            /// @dev The slot starting from which the factory dependencies are stored\n            function NEW_FACTORY_DEPS_BEGIN_SLOT() -> ret {\n                ret := add(CURRENT_L2_TX_HASHES_BEGIN_SLOT(), CURRENT_L2_TX_HASHES_RESERVED_SLOTS())\n            }\n\n            /// @dev The byte starting from which the factory dependencies are stored\n            function NEW_FACTORY_DEPS_BEGIN_BYTE() -> ret {\n                ret := mul(NEW_FACTORY_DEPS_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The slot starting from which the refunds provided by the operator are stored\n            function TX_OPERATOR_REFUND_BEGIN_SLOT() -> ret {\n                ret := add(NEW_FACTORY_DEPS_BEGIN_SLOT(), NEW_FACTORY_DEPS_RESERVED_SLOTS())\n            }\n\n            /// @dev The byte starting from which the refunds provided by the operator are stored\n            function TX_OPERATOR_REFUND_BEGIN_BYTE() -> ret {\n                ret := mul(TX_OPERATOR_REFUND_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the refunds for the transactions.\n            /// It is equal to the number of transactions in the batch.\n            function TX_OPERATOR_REFUNDS_SLOTS() -> ret {\n                ret := MAX_TRANSACTIONS_IN_BATCH()\n            }\n\n            /// @dev The slot starting from which the overheads proposed by the operator will be stored\n            function TX_SUGGESTED_OVERHEAD_BEGIN_SLOT() -> ret {\n                ret := add(TX_OPERATOR_REFUND_BEGIN_SLOT(), TX_OPERATOR_REFUNDS_SLOTS())\n            }\n\n            /// @dev The byte starting from which the overheads proposed by the operator will be stored\n            function TX_SUGGESTED_OVERHEAD_BEGIN_BYTE() -> ret {\n                ret := mul(TX_SUGGESTED_OVERHEAD_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the overheads for the transactions.\n            /// It is equal to the number of transactions in the batch.\n            function TX_SUGGESTED_OVERHEAD_SLOTS() -> ret {\n                ret := MAX_TRANSACTIONS_IN_BATCH()\n            }\n\n            /// @dev The slot starting from which the maximum number of gas that the operator \"trusts\"\n            /// the transaction to use for its execution is stored. Sometimes, the operator may know that\n            /// a certain transaction can be allowed more gas that what the protocol-level worst-case allows.\n            function TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT() -> ret {\n                ret := add(TX_SUGGESTED_OVERHEAD_BEGIN_SLOT(), TX_SUGGESTED_OVERHEAD_SLOTS())\n            }\n\n            /// @dev byte starting from which the maximum number of gas that the operator \"trusts\"\n            /// the transaction to use for its execution is stored. \n            function TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_BYTE() -> ret {\n                ret := mul(TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the trusted gas limits for the transactions.\n            /// It is equal to the number of transactions in the batch.\n            function TX_OPERATOR_TRUSTED_GAS_LIMIT_SLOTS() -> ret {\n                ret := MAX_TRANSACTIONS_IN_BATCH()\n            }\n\n            /// @dev The slot starting from the L2 block information for transactions is stored.\n            function TX_OPERATOR_L2_BLOCK_INFO_BEGIN_SLOT() -> ret {\n                ret := add(TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT(), TX_OPERATOR_TRUSTED_GAS_LIMIT_SLOTS())\n            }\n\n            /// @dev The byte starting from which the L2 block information for transactions is stored.\n            function TX_OPERATOR_L2_BLOCK_INFO_BEGIN_BYTE() -> ret {\n                ret := mul(TX_OPERATOR_L2_BLOCK_INFO_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The size of each of the L2 block information. Each L2 block information contains four fields:\n            /// - number of the block\n            /// - timestamp of the block\n            /// - hash of the previous block\n            /// - the maximal number of virtual blocks to create\n            function TX_OPERATOR_L2_BLOCK_INFO_SLOT_SIZE() -> ret {\n                ret := 4\n            }\n\n            /// @dev The size of each of the L2 block information in bytes.\n            function TX_OPERATOR_L2_BLOCK_INFO_SIZE_BYTES() -> ret {\n                ret := mul(TX_OPERATOR_L2_BLOCK_INFO_SLOT_SIZE(), 32)\n            }\n\n            /// @dev The number of slots dedicated for the L2 block information for the transactions.\n            /// Note, that an additional slot is required for the fictive L2 block at the end of the batch. \n            /// For technical reasons inside the sequencer implementation, \n            /// each batch ends with a fictive block with no transactions.\n            function TX_OPERATOR_L2_BLOCK_INFO_SLOTS() -> ret {\n                ret := mul(add(MAX_TRANSACTIONS_IN_BATCH(), 1), TX_OPERATOR_L2_BLOCK_INFO_SLOT_SIZE())\n            }\n\n            /// @dev The slot starting from which the compressed bytecodes are located in the bootloader's memory.\n            /// Each compressed bytecode is provided in the following format:\n            /// - 32 byte formatted bytecode hash\n            /// - 32 byte of zero (it will be replaced within the code with left-padded selector of the `publishCompressedBytecode`).\n            /// - ABI-encoding of the parameters of the `publishCompressedBytecode` method. \n            /// \n            /// At the slot `TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT()` the pointer to the currently processed compressed bytecode\n            /// is stored, i.e. this pointer will be increased once the current bytecode which the pointer points to is published.\n            /// At the start of the bootloader, the value stored at the `TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT` is equal to \n            /// `TX_OPERATOR_TRUSTED_GAS_LIMIT_BEGIN_SLOT + 32`, where the hash of the first compressed bytecode to publish should be stored.\n            function COMPRESSED_BYTECODES_BEGIN_SLOT() -> ret {\n                ret := add(TX_OPERATOR_L2_BLOCK_INFO_BEGIN_SLOT(), TX_OPERATOR_L2_BLOCK_INFO_SLOTS())\n            }\n\n            /// @dev The byte starting from which the compressed bytecodes are located in the bootloader's memory.\n            function COMPRESSED_BYTECODES_BEGIN_BYTE() -> ret {\n                ret := mul(COMPRESSED_BYTECODES_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev The number of slots dedicated to the compressed bytecodes.\n            function COMPRESSED_BYTECODES_SLOTS() -> ret {\n                ret := {{COMPRESSED_BYTECODES_SLOTS}}\n            }\n\n            /// @dev The slot right after the last slot of the compressed bytecodes memory area.\n            function COMPRESSED_BYTECODES_END_SLOT() -> ret {\n                ret := add(COMPRESSED_BYTECODES_BEGIN_SLOT(), COMPRESSED_BYTECODES_SLOTS())\n            }\n\n            /// @dev The first byte in memory right after the compressed bytecodes memory area.\n            function COMPRESSED_BYTECODES_END_BYTE() -> ret {\n                ret := mul(COMPRESSED_BYTECODES_END_SLOT(), 32)\n            }\n\n            /// @dev Slots needed to store priority txs L1 data (`chainedPriorityTxsHash` and `numberOfLayer1Txs`).\n            function PRIORITY_TXS_L1_DATA_RESERVED_SLOTS() -> ret {\n                ret := 2\n            }\n\n            /// @dev Slot from which storing of the priority txs L1 data begins.\n            function PRIORITY_TXS_L1_DATA_BEGIN_SLOT() -> ret {\n                ret := add(COMPRESSED_BYTECODES_BEGIN_SLOT(), COMPRESSED_BYTECODES_SLOTS())\n            }\n\n            /// @dev The byte from which storing of the priority txs L1 data begins.\n            function PRIORITY_TXS_L1_DATA_BEGIN_BYTE() -> ret {\n                ret := mul(PRIORITY_TXS_L1_DATA_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev Slot from which storing of the L1 Messenger pubdata begins.\n            function OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_BEGIN_SLOT() -> ret {\n                ret := add(PRIORITY_TXS_L1_DATA_BEGIN_SLOT(), PRIORITY_TXS_L1_DATA_RESERVED_SLOTS())\n            }\n\n            /// @dev The byte storing of the L1 Messenger pubdata begins.\n            function OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_BEGIN_BYTE() -> ret {\n                ret := mul(OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_BEGIN_SLOT(), 32)\n            }\n\n            /// @dev Slots needed to store L1 Messenger pubdata.\n            /// @dev Note that are many more these than the maximal pubdata in batch, since \n            /// it needs to also accomodate uncompressed state diffs that are required for the state diff\n            /// compression verification.\n            function OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_SLOTS() -> ret {\n                ret := {{OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_SLOTS}}\n            }\n\n            /// @dev The slot right after the last slot of the L1 Messenger pubdata memory area.\n            function OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_END_SLOT() -> ret {\n                ret := add(OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_BEGIN_SLOT(), OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_SLOTS())\n            }\n\n            /// @dev The slot from which the bootloader transactions' descriptions begin\n            function TX_DESCRIPTION_BEGIN_SLOT() -> ret {\n                ret := OPERATOR_PROVIDED_L1_MESSENGER_PUBDATA_END_SLOT()\n            }\n\n            /// @dev The byte from which the bootloader transactions' descriptions begin\n            function TX_DESCRIPTION_BEGIN_BYTE() -> ret {\n                ret := mul(TX_DESCRIPTION_BEGIN_SLOT(), 32)\n            }\n\n            // Each tx description has the following structure\n            // \n            // struct BootloaderTxDescription {\n            //     uint256 txMeta;\n            //     uint256 txDataOffset;\n            // }\n            //\n            // `txMeta` contains flags to manipulate the transaction execution flow.\n            // For playground batches:\n            //      It can have the following information (0 byte is LSB and 31 byte is MSB):\n            //      0 byte: `execute`, bool. Denotes whether transaction should be executed by the bootloader.\n            //      31 byte: server-side tx execution mode\n            // For proved batches:\n            //      It can simply denotes whether to execute the transaction (0 to stop executing the batch, 1 to continue) \n            //\n            // Each such encoded struct consumes 2 words\n            function TX_DESCRIPTION_SIZE() -> ret {\n                ret := 64\n            }\n\n            /// @dev The byte right after the basic description of bootloader transactions\n            function TXS_IN_BATCH_LAST_PTR() -> ret {\n                ret := add(TX_DESCRIPTION_BEGIN_BYTE(), mul(MAX_TRANSACTIONS_IN_BATCH(), TX_DESCRIPTION_SIZE()))\n            }\n\n            /// @dev The memory page consists of 2^19 VM words.\n            /// Each execution result is a single boolean, but \n            /// for the sake of simplicity we will spend 32 bytes on each\n            /// of those for now. \n            function MAX_MEM_SIZE() -> ret {\n                ret := 0x1000000 // 2^24 bytes\n            }\n\n            function L1_TX_INTRINSIC_L2_GAS() -> ret {\n                ret := {{L1_TX_INTRINSIC_L2_GAS}}\n            }\n\n            function L1_TX_INTRINSIC_PUBDATA() -> ret {\n                ret := {{L1_TX_INTRINSIC_PUBDATA}}\n            }\n\n            function L2_TX_INTRINSIC_GAS() -> ret {\n                ret := {{L2_TX_INTRINSIC_GAS}}\n            }\n\n            function L2_TX_INTRINSIC_PUBDATA() -> ret {\n                ret := {{L2_TX_INTRINSIC_PUBDATA}}\n            }\n\n            /// @dev The byte from which the pointers on the result of transactions are stored\n            function RESULT_START_PTR() -> ret {\n                ret := sub(MAX_MEM_SIZE(), mul(MAX_TRANSACTIONS_IN_BATCH(), 32))\n            }\n\n            /// @dev The pointer writing to which invokes the VM hooks\n            function VM_HOOK_PTR() -> ret {\n                ret := sub(RESULT_START_PTR(), 32)\n            }\n\n            /// @dev The maximum number the VM hooks may accept\n            function VM_HOOK_PARAMS() -> ret {\n                ret := 2\n            }\n\n            /// @dev The offset starting from which the parameters for VM hooks are located\n            function VM_HOOK_PARAMS_OFFSET() -> ret {\n                ret := sub(VM_HOOK_PTR(), mul(VM_HOOK_PARAMS(), 32))\n            }\n\n            function LAST_FREE_SLOT() -> ret {\n                // The slot right before the vm hooks is the last slot that\n                // can be used for transaction's descriptions\n                ret := sub(VM_HOOK_PARAMS_OFFSET(), 32)\n            }\n\n            /// @dev The formal address of the bootloader\n            function BOOTLOADER_FORMAL_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008001\n            }\n\n            function MAX_SYSTEM_CONTRACT_ADDR() -> ret {\n                ret := 0x000000000000000000000000000000000000ffff\n            }\n\n            function ACCOUNT_CODE_STORAGE_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008002\n            }\n\n            function NONCE_HOLDER_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008003\n            }\n\n            function KNOWN_CODES_CONTRACT_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008004\n            }\n\n            function CONTRACT_DEPLOYER_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008006\n            }\n            \n            function FORCE_DEPLOYER() -> ret {\n                ret := 0x0000000000000000000000000000000000008007\n            }\n\n            function MSG_VALUE_SIMULATOR_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008009\n            }\n\n            function ETH_L2_TOKEN_ADDR() -> ret {\n                ret := 0x000000000000000000000000000000000000800a\n            }\n\n            function SYSTEM_CONTEXT_ADDR() -> ret {\n                ret := 0x000000000000000000000000000000000000800b\n            }\n\n            function BOOTLOADER_UTILITIES() -> ret {\n                ret := 0x000000000000000000000000000000000000800c\n            }\n\n            function BYTECODE_COMPRESSOR_ADDR() -> ret {\n                ret := 0x000000000000000000000000000000000000800e\n            }\n\n            function L1_MESSENGER_ADDR() -> ret {\n                ret := 0x0000000000000000000000000000000000008008\n            }\n\n            /// @dev The minimal allowed distance in bytes between the pointer to the compressed data\n            /// and the end of the area dedicated for the compressed bytecodes. \n            /// In fact, only distance of 192 should be sufficient: there it would be possible to insert\n            /// the hash of the bytecode, the 32 bytes buffer for selector and 2 offsets of the calldata,\n            /// but we keep it at 512 just in case.\n            function MIN_ALLOWED_OFFSET_FOR_COMPRESSED_BYTES_POINTER() -> ret {\n                ret := 512\n            }\n\n            /// @dev Whether the bootloader should enforce that accounts have returned the correct\n            /// magic value for signature. This value is enforced to be \"true\" on the main proved batch, but \n            /// we need the ability to ignore invalid signature results during fee estimation,\n            /// where the signature for the transaction is usually not known beforehand.\n            function SHOULD_ENSURE_CORRECT_RETURNED_MAGIC() -> ret {\n                ret := {{ENSURE_RETURNED_MAGIC}}\n            }\n\n            /// @notice The type of the transaction used for system upgrades.\n            function UPGRADE_TRANSACTION_TX_TYPE() -> ret {\n                ret := 254\n            }\n\n            /// @notice The type of every non-upgrade transaction that comes from L1.\n            function L1_TX_TYPE() -> ret {\n                ret := 255\n            }\n\n            /// @dev The overhead in gas that will be used when checking whether the context has enough gas, i.e. \n            /// when checking for X gas, the context should have at least X+CHECK_ENOUGH_GAS_OVERHEAD() gas.\n            function CHECK_ENOUGH_GAS_OVERHEAD() -> ret {\n                ret := 1000000\n            }\n\n            /// @dev Ceil division of integers\n            function ceilDiv(x, y) -> ret {\n                switch or(eq(x, 0), eq(y, 0))\n                case 0 {\n                    // (x + y - 1) / y can overflow on addition, so we distribute.\n                    ret := add(div(sub(x, 1), y), 1)\n                }\n                default {\n                    ret := 0\n                }\n            }\n            \n            /// @dev Calculates the length of a given number of bytes rounded up to the nearest multiple of 32.\n            function lengthRoundedByWords(len) -> ret {\n                let neededWords := div(add(len, 31), 32)\n                ret := safeMul(neededWords, 32, \"xv\")\n            }\n\n            /// @dev Function responsible for processing the transaction\n            /// @param txDataOffset The offset to the ABI-encoding of the structure\n            /// @param resultPtr The pointer at which the result of the transaction's execution should be stored\n            /// @param transactionIndex The index of the transaction in the batch\n            /// @param isETHCall Whether the call is an ethCall. \n            /// @param gasPerPubdata The number of L2 gas to charge users for each byte of pubdata \n            /// On proved batch this value should always be zero\n            function processTx(\n                txDataOffset, \n                resultPtr,\n                transactionIndex,\n                isETHCall,\n                gasPerPubdata\n            ) {\n                // We set the L2 block info for this particular transaction\n                setL2Block(transactionIndex)\n\n                let innerTxDataOffset := add(txDataOffset, 32)\n\n                // By default we assume that the transaction has failed.\n                mstore(resultPtr, 0)\n\n                let userProvidedPubdataPrice := getGasPerPubdataByteLimit(innerTxDataOffset)\n                debugLog(\"userProvidedPubdataPrice:\", userProvidedPubdataPrice)\n\n                debugLog(\"gasPerPubdata:\", gasPerPubdata)\n\n                switch getTxType(innerTxDataOffset) \n                    case 254 {\n                        // This is an upgrade transaction.\n                        // Protocol upgrade transactions are processed totally in the same manner as the normal L1->L2 transactions,\n                        // the only difference are:\n                        // - They must be the first one in the batch\n                        // - They have a different type to prevent tx hash collisions and preserve the expectation that the \n                        // L1->L2 transactions have priorityTxId inside them.\n                        if transactionIndex {    \n                            assertionError(\"Protocol upgrade tx not first\")\n                        }\n\n                        // This is to be called in the event that the L1 Transaction is a protocol upgrade txn.\n                        // Since this is upgrade transactions, we are okay that the gasUsed by the transaction will \n                        // not cover this additional hash computation\n                        let canonicalL1TxHash := getCanonicalL1TxHash(txDataOffset)\n                        sendToL1Native(true, protocolUpgradeTxHashKey(), canonicalL1TxHash)\n\n                        processL1Tx(txDataOffset, resultPtr, transactionIndex, userProvidedPubdataPrice, false)\n                    }\n                    case 255 {\n                        // This is an L1->L2 transaction.\n                        processL1Tx(txDataOffset, resultPtr, transactionIndex, userProvidedPubdataPrice, true)\n                    }\n                    default {\n                        // The user has not agreed to this pubdata price\n                        if lt(userProvidedPubdataPrice, gasPerPubdata) {\n                            revertWithReason(UNACCEPTABLE_GAS_PRICE_ERR_CODE(), 0)\n                        }\n                        \n                        setPricePerPubdataByte(gasPerPubdata)\n\n                        <!-- @if BOOTLOADER_TYPE=='proved_batch' -->\n                        processL2Tx(txDataOffset, resultPtr, transactionIndex, gasPerPubdata)\n                        <!-- @endif -->\n\n                        <!-- @if BOOTLOADER_TYPE=='playground_batch' -->\n                        switch isETHCall \n                            case 1 {\n                                let gasLimit := getGasLimit(innerTxDataOffset)\n                                let nearCallAbi := getNearCallABI(gasLimit)\n                                checkEnoughGas(gasLimit)\n\n                                if iszero(gasLimit) {\n                                    // If success is 0, we need to revert\n                                    revertWithReason(\n                                        ETH_CALL_ERR_CODE(),\n                                        0\n                                    )\n                                }\n\n                                ZKSYNC_NEAR_CALL_ethCall(\n                                    nearCallAbi,\n                                    txDataOffset,\n                                    resultPtr\n                                )\n                            }\n                            default { \n                                processL2Tx(txDataOffset, resultPtr, transactionIndex, gasPerPubdata)\n                            }\n                        <!-- @endif -->\n                    }\n            }\n\n            /// @dev Calculates the canonical hash of the L1->L2 transaction that will be\n            /// sent to L1 as a message to the L1 contract that a certain operation has been processed.\n            function getCanonicalL1TxHash(txDataOffset) -> ret {\n                // Putting the correct value at the `txDataOffset` just in case, since \n                // the correctness of this value is not part of the system invariants.\n                // Note, that the correct ABI encoding of the Transaction structure starts with 0x20\n                mstore(txDataOffset, 32)\n\n                let innerTxDataOffset := add(txDataOffset, 32)\n                let dataLength := safeAdd(32, getDataLength(innerTxDataOffset), \"qev\")\n\n                debugLog(\"HASH_OFFSET\", innerTxDataOffset)\n                debugLog(\"DATA_LENGTH\", dataLength)\n\n                ret := keccak256(txDataOffset, dataLength)\n            }\n\n            /// @dev The purpose of this function is to make sure that the operator\n            /// gets paid for the transaction. Note, that the beneficiary of the payment is \n            /// bootloader.\n            /// The operator will be paid at the end of the batch.\n            function ensurePayment(txDataOffset, gasPrice) {\n                // Skipping the first 0x20 byte in the encoding of the transaction.\n                let innerTxDataOffset := add(txDataOffset, 32)\n                let from := getFrom(innerTxDataOffset)\n                let requiredETH := safeMul(getGasLimit(innerTxDataOffset), gasPrice, \"lal\")\n\n                let bootloaderBalanceETH := balance(BOOTLOADER_FORMAL_ADDR())\n                let paymaster := getPaymaster(innerTxDataOffset)\n\n                let payer := 0\n\n                switch paymaster\n                case 0 {\n                    payer := from\n\n                    // There is no paymaster, the user should pay for the execution.\n                    // Calling for the `payForTransaction` method of the account.\n                    setHook(VM_HOOK_ACCOUNT_VALIDATION_ENTERED())\n                    let res := accountPayForTx(from, txDataOffset)\n                    setHook(VM_HOOK_NO_VALIDATION_ENTERED())\n\n\n                    if iszero(res) {\n                        revertWithReason(\n                            PAY_FOR_TX_FAILED_ERR_CODE(),\n                            1\n                        )\n                    }\n                }   \n                default {\n                    // There is some paymaster present."
    }
  ]
}