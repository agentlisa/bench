{
  "Title": "M-13: Vault account might not be able to exit after liquidation",
  "Content": "# Issue M-13: Vault account might not be able to exit after liquidation \n\nSource: https://github.com/sherlock-audit/2023-03-notional-judging/issues/192 \n\n## Found by \nxiaoming90\n## Summary\n\nThe vault exit might fail after a liquidation event, leading to users being unable to main their positions.\n\n## Vulnerability Detail\n\nAssume that a large portion of the vault account gets liquidated which results in a large amount of cash deposited into the vault account's cash balance. In addition, interest will also start accruing within the vault account's cash balance. \n\nLet $x$ be the `primaryCash` of a vault account after a liquidation event and interest accrual.\n\nThe owner of the vault account decided to exit the vault by calling `exitVault`. Within the `exitVault` function, the `vaultAccount.tempCashBalance` will be set to $x$. \n\nNext, the `lendToExitVault` function is called. Assume that the cost in prime cash terms to lend an offsetting fCash position is $-y$ (`primeCashCostToLend`). The `updateAccountDebt` function will be called, and the `vaultAccount.tempCashBalance` will be updated to $x + (-y) \\Rightarrow x - y$. If $x > y$, then the new `vaultAccount.tempCashBalance` will be more than zero.\n\nSubsequently, the `redeemWithDebtRepayment` function will be called. However, since `vaultAccount.tempCashBalance` is larger than zero, the transaction will revert, and the owner cannot exit the vault.\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/vaults/VaultConfiguration.sol#L429\n\n```solidity\nFile: VaultConfiguration.sol\n424:             if (vaultAccount.tempCashBalance < 0) {\n425:                 int256 x = vaultConfig.primeRate.convertToUnderlying(vaultAccount.tempCashBalance).neg();\n426:                 underlyingExternalToRepay = underlyingToken.convertToUnderlyingExternalWithAdjustment(x).toUint();\n427:             } else {\n428:                 // Otherwise require that cash balance is zero. Cannot have a positive cash balance in this method\n429:                 require(vaultAccount.tempCashBalance == 0);\n430:             }\n```\n\n## Impact\n\nThe owner of the vault account would not be able to exit the vault to main their position. As such, their assets are stuck within the protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/vaults/VaultConfiguration.sol#L429\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider refunding the excess positive `vaultAccount.tempCashBalance` to the users so that `vaultAccount.tempCashBalance` will be cleared (set to zero) before calling the `redeemWithDebtRepayment` function.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/59",
  "Code": [
    {
      "filename": "contracts-v2/contracts/internal/vaults/VaultConfiguration.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    VaultConfig,\n    VaultAccount,\n    VaultConfigStorage,\n    VaultBorrowCapacityStorage,\n    TradeActionType,\n    PrimeRate,\n    Token,\n    TokenType,\n    VaultState\n} from \"../../global/Types.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\n\nimport {Emitter} from \"../Emitter.sol\";\nimport {DateTime} from \"../markets/DateTime.sol\";\nimport {CashGroup} from \"../markets/CashGroup.sol\";\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\nimport {PrimeCashExchangeRate} from \"../pCash/PrimeCashExchangeRate.sol\";\nimport {TokenHandler} from \"../balances/TokenHandler.sol\";\nimport {GenericToken} from \"../balances/protocols/GenericToken.sol\";\nimport {BalanceHandler} from \"../balances/BalanceHandler.sol\";\nimport {VaultStateLib} from \"./VaultState.sol\";\n\nimport {TradingAction} from \"../../external/actions/TradingAction.sol\";\nimport {IStrategyVault} from \"../../../interfaces/notional/IStrategyVault.sol\";\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\n\n/// @notice Vault configuration holds per vault parameters and methods that interact\n/// with vault level parameters (such as fee assessments, collateral ratios, capacity\n/// limits, etc.)\nlibrary VaultConfiguration {\n    using TokenHandler for Token;\n    using VaultStateLib for VaultState;\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n    using PrimeRateLib for PrimeRate;\n\n    /// @notice Emitted when the borrow capacity on a vault changes\n    event VaultBorrowCapacityChange(address indexed vault, uint16 indexed currencyId, uint256 totalUsedBorrowCapacity);\n    /// @notice Emitted when a vault's status is updated\n    event VaultPauseStatus(address indexed vault, bool enabled);\n\n    uint16 internal constant ENABLED                         = 1 << 0;\n    uint16 internal constant ALLOW_ROLL_POSITION             = 1 << 1;\n    // These flags switch the authentication on the vault methods such that all\n    // calls must come from the vault itself.\n    uint16 internal constant ONLY_VAULT_ENTRY                = 1 << 2;\n    uint16 internal constant ONLY_VAULT_EXIT                 = 1 << 3;\n    uint16 internal constant ONLY_VAULT_ROLL                 = 1 << 4;\n    uint16 internal constant ONLY_VAULT_DELEVERAGE           = 1 << 5;\n    uint16 internal constant VAULT_MUST_SETTLE               = 1 << 6;\n    // External vault methods will have re-entrancy protection on by default, however, some\n    // vaults may need to call back into Notional so we can whitelist them for re-entrancy.\n    uint16 internal constant ALLOW_REENTRANCY                = 1 << 7;\n    uint16 internal constant DISABLE_DELEVERAGE              = 1 << 8;\n    // Enables fCash discounting during vault valuation. While this allows more leverage for\n    // accounts in the vault, it also exposes accounts to potential liquidation due to interest\n    // rate changes on Notional. While this is desireable in some vaults that explicitly target\n    // interest rate arbitrage, it may create UX issues for other vaults that are more passive.\n    // When this flag is set to false, fCash is not discounted to present value so that it holds\n    // zero interest rate risk.\n    uint16 internal constant ENABLE_FCASH_DISCOUNT           = 1 << 9;\n\n    function _getVaultConfig(\n        address vaultAddress\n    ) private view returns (VaultConfig memory vaultConfig) {\n        mapping(address => VaultConfigStorage) storage store = LibStorage.getVaultConfig();\n        VaultConfigStorage storage s = store[vaultAddress];\n\n        vaultConfig.vault = vaultAddress;\n        vaultConfig.flags = s.flags;\n        vaultConfig.borrowCurrencyId = s.borrowCurrencyId;\n        vaultConfig.minAccountBorrowSize = int256(s.minAccountBorrowSize).mul(Constants.INTERNAL_TOKEN_PRECISION);\n        vaultConfig.feeRate = int256(uint256(s.feeRate5BPS).mul(Constants.FIVE_BASIS_POINTS));\n        vaultConfig.minCollateralRatio = int256(uint256(s.minCollateralRatioBPS).mul(Constants.BASIS_POINT));\n        vaultConfig.maxDeleverageCollateralRatio = int256(uint256(s.maxDeleverageCollateralRatioBPS).mul(Constants.BASIS_POINT));\n        vaultConfig.maxRequiredAccountCollateralRatio = int256(uint256(s.maxRequiredAccountCollateralRatioBPS).mul(Constants.BASIS_POINT));\n        // This is used in 1e9 precision on the stack (no overflow possible)\n        vaultConfig.liquidationRate = (int256(uint256(s.liquidationRate)) * Constants.RATE_PRECISION) / Constants.PERCENTAGE_DECIMALS;\n        vaultConfig.reserveFeeShare = int256(uint256(s.reserveFeeShare));\n        vaultConfig.maxBorrowMarketIndex = s.maxBorrowMarketIndex;\n        vaultConfig.secondaryBorrowCurrencies = s.secondaryBorrowCurrencies;\n        vaultConfig.minAccountSecondaryBorrow[0] = int256(uint256(s.minAccountSecondaryBorrow[0])).mul(Constants.INTERNAL_TOKEN_PRECISION);\n        vaultConfig.minAccountSecondaryBorrow[1] = int256(uint256(s.minAccountSecondaryBorrow[1])).mul(Constants.INTERNAL_TOKEN_PRECISION);\n    }\n\n    function getVaultConfigNoPrimeRate(\n        address vaultAddress\n    ) internal view returns (VaultConfig memory vaultConfig) {\n        vaultConfig = _getVaultConfig(vaultAddress);\n    }\n\n    function getVaultConfigStateful(\n        address vaultAddress\n    ) internal returns (VaultConfig memory vaultConfig) {\n        vaultConfig = _getVaultConfig(vaultAddress);\n        vaultConfig.primeRate = PrimeRateLib.buildPrimeRateStateful(vaultConfig.borrowCurrencyId);\n    }\n\n    function getVaultConfigView(\n        address vaultAddress\n    ) internal view returns (VaultConfig memory vaultConfig) {\n        vaultConfig = _getVaultConfig(vaultAddress);\n        (vaultConfig.primeRate, /* */) = PrimeCashExchangeRate.getPrimeCashRateView(\n            vaultConfig.borrowCurrencyId, block.timestamp\n        );\n    }\n\n    function setVaultEnabledStatus(address vaultAddress, bool enable) internal {\n        mapping(address => VaultConfigStorage) storage store = LibStorage.getVaultConfig();\n        VaultConfigStorage storage s = store[vaultAddress];\n        uint16 flags = s.flags;\n\n        if (enable) {\n            s.flags = flags | VaultConfiguration.ENABLED;\n        } else {\n            s.flags = flags & ~VaultConfiguration.ENABLED;\n        }\n    }\n\n    function setVaultDeleverageStatus(address vaultAddress, bool disableDeleverage) internal {\n        mapping(address => VaultConfigStorage) storage store = LibStorage.getVaultConfig();\n        VaultConfigStorage storage s = store[vaultAddress];\n        uint16 flags = s.flags;\n\n        if (disableDeleverage) {\n            s.flags = flags | VaultConfiguration.DISABLE_DELEVERAGE;\n        } else {\n            s.flags = flags & ~VaultConfiguration.DISABLE_DELEVERAGE;\n        }\n    }\n\n    function setVaultConfig(\n        address vaultAddress,\n        VaultConfigStorage calldata vaultConfig\n    ) internal {\n        mapping(address => VaultConfigStorage) storage store = LibStorage.getVaultConfig();\n        VaultConfig memory existingVaultConfig = _getVaultConfig(vaultAddress);\n        // Cannot change borrow currency once set\n        require(vaultConfig.borrowCurrencyId != 0);\n        require(existingVaultConfig.borrowCurrencyId == 0 || existingVaultConfig.borrowCurrencyId == vaultConfig.borrowCurrencyId);\n\n        // Liquidation rate must be greater than or equal to 100\n        require(Constants.PERCENTAGE_DECIMALS <= vaultConfig.liquidationRate);\n        // minCollateralRatioBPS to RATE_PRECISION is minCollateralRatioBPS * BASIS_POINT (1e5)\n        // liquidationRate to RATE_PRECISION  is liquidationRate * RATE_PRECISION / PERCENTAGE_DECIMALS (net 1e7)\n        //    (liquidationRate - 100) * 1e9 / 1e2 < minCollateralRatioBPS * 1e5\n        //    (liquidationRate - 100) * 1e2 < minCollateralRatioBPS\n        uint16 liquidationRate = uint16(\n            uint256(vaultConfig.liquidationRate - uint256(Constants.PERCENTAGE_DECIMALS)) * uint256(1e2)\n        );\n        // Ensure that liquidation rate is less than minCollateralRatio so that liquidations are not locked\n        // up causing accounts to remain insolvent\n        require(liquidationRate < vaultConfig.minCollateralRatioBPS);\n\n        // Collateral ratio values must satisfy this inequality:\n        // insolvent < 0 < [liquidatable account] <  ...\n        //      minCollateralRatio < [account] < maxDeleverageCollateralRatio < ...\n        //      [account] < maxRequiredAccountCollateralRatio\n\n        // This must be true or else when deleveraging we could put an account further towards insolvency\n        require(vaultConfig.minCollateralRatioBPS < vaultConfig.maxDeleverageCollateralRatioBPS);\n        // This must be true or accounts cannot enter the vault\n        require(vaultConfig.maxDeleverageCollateralRatioBPS < vaultConfig.maxRequiredAccountCollateralRatioBPS);\n\n        // Reserve fee share must be less than or equal to 100\n        require(vaultConfig.reserveFeeShare <= Constants.PERCENTAGE_DECIMALS);\n\n        // Secondary borrow currencies cannot change once set\n        require(\n            existingVaultConfig.secondaryBorrowCurrencies[0] == 0 ||\n            existingVaultConfig.secondaryBorrowCurrencies[0] == vaultConfig.secondaryBorrowCurrencies[0]\n        );\n        require(\n            existingVaultConfig.secondaryBorrowCurrencies[1] == 0 ||\n            existingVaultConfig.secondaryBorrowCurrencies[1] == vaultConfig.secondaryBorrowCurrencies[1]\n        );\n\n        // The borrow currency cannot be duplicated as a secondary borrow currency\n        require(vaultConfig.borrowCurrencyId != vaultConfig.secondaryBorrowCurrencies[0]);\n        require(vaultConfig.borrowCurrencyId != vaultConfig.secondaryBorrowCurrencies[1]);\n        if (vaultConfig.secondaryBorrowCurrencies[0] != 0 && vaultConfig.secondaryBorrowCurrencies[1] != 0) {\n            // Check that these values are not duplicated if set\n            require(vaultConfig.secondaryBorrowCurrencies[0] != vaultConfig.secondaryBorrowCurrencies[1]);\n        }\n\n        // Tokens with transfer fees create lots of issues with vault mechanics, we prevent them\n        // from being listed here.\n        Token memory underlyingToken = TokenHandler.getUnderlyingToken(vaultConfig.borrowCurrencyId);\n        require(!underlyingToken.hasTransferFee); \n\n        store[vaultAddress] = vaultConfig;\n    }\n\n    function setMaxBorrowCapacity(\n        address vault,\n        uint16 currencyId,\n        uint80 maxBorrowCapacity\n    ) internal {\n        VaultBorrowCapacityStorage storage cap = LibStorage.getVaultBorrowCapacity()[vault][currencyId];\n        cap.maxBorrowCapacity = maxBorrowCapacity;\n    }\n\n    /// @notice Authorizes callers based on the vault flags set in the confiuration\n    function authorizeCaller(\n        VaultConfig memory vaultConfig,\n        address account,\n        uint16 onlyVaultFlag\n    ) internal view {\n        if (getFlag(vaultConfig, onlyVaultFlag)) {\n            // If the only vault method is flagged, then the sender must be the vault\n            require(msg.sender == vaultConfig.vault, \"Unauthorized\");\n        } else {\n            // The base case is that the account must be the msg.sender\n            require(account == msg.sender, \"Unauthorized\");\n        }\n    }\n\n    /// @notice Returns that status of a given flagID\n    function getFlag(VaultConfig memory vaultConfig, uint16 flagID) internal pure returns (bool) {\n        return (vaultConfig.flags & flagID) == flagID;\n    }\n\n    /// @notice Returns true if a vault config has secondary borrows\n    function hasSecondaryBorrows(VaultConfig memory vaultConfig) internal pure returns (bool) {\n        return vaultConfig.secondaryBorrowCurrencies[0] != 0 || vaultConfig.secondaryBorrowCurrencies[1] != 0;\n    }\n\n    function calculateVaultFees(\n        VaultConfig memory vaultConfig,\n        VaultAccount memory vaultAccount,\n        int256 primeCashBorrowed,\n        uint256 maturity,\n        uint256 blockTime\n    ) internal pure returns (int256 netTotalFee) {\n        int256 proratedFeeTime;\n        if (maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\n            // vaultAccount.maturity is set after assessVaultFees on the initial entry\n            // to the prime cash maturity, so if it is not set here then we do not\n            // assess a fee on the vault account. The fee for its initial period will\n            // be assessed on the next time it borrows more or exits the vaults.\n            if (vaultAccount.maturity != Constants.PRIME_CASH_VAULT_MATURITY) return 0;\n\n            // Prime cash vaults do not have a maturity, so accounts are assessed\n            // a fee based on how long they have borrowed from the vault.\n            // proratedFeeTime = (blockTime - lastUpdateBlockTime)\n            // NOTE: this means fees must be assessed on exit and entry\n            proratedFeeTime = blockTime.sub(vaultAccount.lastUpdateBlockTime).toInt();\n            // Set the timer here so that we do not double assess fees later\n            vaultAccount.lastUpdateBlockTime = blockTime;\n        } else {\n            proratedFeeTime = maturity.sub(blockTime).toInt();\n        }\n\n        // The fee rate is annualized, we prorate it linearly based on the time to maturity here\n        int256 proratedFeeRate = vaultConfig.feeRate\n            .mul(proratedFeeTime)\n            .div(int256(Constants.YEAR));\n\n        netTotalFee = primeCashBorrowed.mulInRatePrecision(proratedFeeRate);\n    }\n\n    /// @notice Assess fees to the vault account. The fee based on time to maturity and the amount of fCash. Fees\n    /// will be accrued to the nToken cash balance and the protocol cash reserve.\n    /// @param vaultConfig vault configuration\n    /// @param vaultAccount modifies the vault account temp cash balance in memory\n    /// @param primeCashBorrowed the amount of cash the account has borrowed\n    /// @param maturity maturity of fCash\n    /// @param blockTime current block time\n    function assessVaultFees(\n        VaultConfig memory vaultConfig,\n        VaultAccount memory vaultAccount,\n        int256 primeCashBorrowed,\n        uint256 maturity,\n        uint256 blockTime\n    ) internal returns (int256 netTotalFee) {\n        netTotalFee = calculateVaultFees(vaultConfig, vaultAccount, primeCashBorrowed, maturity, blockTime);\n\n        // Reserve fee share is restricted to less than 100\n        int256 reserveFee = netTotalFee.mul(vaultConfig.reserveFeeShare).div(Constants.PERCENTAGE_DECIMALS);\n        int256 nTokenFee = netTotalFee.sub(reserveFee);\n\n        BalanceHandler.incrementFeeToReserve(vaultConfig.borrowCurrencyId, reserveFee);\n        BalanceHandler.incrementVaultFeeToNToken(vaultConfig.borrowCurrencyId, nTokenFee);\n\n        if (maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\n            // When a prime cash fee is accrued, the vault is \"borrowing\" more and then transferring the cash\n            // side to the nToken and reserve.\n            Emitter.emitBorrowOrRepayPrimeDebt(\n                vaultConfig.vault, vaultConfig.borrowCurrencyId, netTotalFee, vaultConfig.primeRate.convertToStorageValue(netTotalFee)\n            );\n        }\n        Emitter.emitVaultFeeTransfers(vaultConfig.vault, vaultConfig.borrowCurrencyId, nTokenFee, reserveFee);\n\n        vaultAccount.tempCashBalance = vaultAccount.tempCashBalance.sub(netTotalFee);\n    }\n\n    /// @notice Updates the total fcash debt usage across all maturities as a single number even though\n    /// they are not strictly fungible with each other, this is just used as a heuristic for the total\n    /// vault risk exposure.\n    /// @param vault address of vault\n    /// @param currencyId relevant currency id, all vaults will borrow in a primary currency, some vaults also borrow\n    /// in secondary or perhaps even tertiary currencies.\n    /// @param netfCash the net amount of fCash change (borrowing < 0, lending > 0)\n    function updatefCashBorrowCapacity(\n        address vault,\n        uint16 currencyId,\n        int256 netfCash\n    ) internal {\n        VaultBorrowCapacityStorage storage cap = LibStorage.getVaultBorrowCapacity()[vault][currencyId];\n\n        // Update the total fcash debt, when borrowing this number will increase (netfCash < 0),\n        // when lending this number will decrease (netfCash > 0). \n        int256 totalfCashDebt = int256(uint256(cap.totalfCashDebt)).sub(netfCash);\n\n        // Total fcash debt can never go negative, this would suggest that we've lent past repayment\n        // of the total fCash borrowed.\n        cap.totalfCashDebt = totalfCashDebt.toUint().toUint80();\n        // overflow already checked above\n        emit VaultBorrowCapacityChange(vault, currencyId, uint256(totalfCashDebt));\n    }\n\n    /// @notice Checks the sum of the fcash and prime cash debt usage and reverts if it is above maximum\n    /// capacity. Must be called any time the total vault debt increases.\n    function checkBorrowCapacity(\n        address vault,\n        uint16 currencyId,\n        int256 totalPrimeDebtInUnderlying\n    ) internal view {\n        VaultBorrowCapacityStorage storage cap = LibStorage.getVaultBorrowCapacity()[vault][currencyId];\n        int256 totalUsedBorrowCapacity = int256(uint256(cap.totalfCashDebt)).sub(totalPrimeDebtInUnderlying);\n        require(totalUsedBorrowCapacity <= int256(uint256(cap.maxBorrowCapacity)), \"Max Capacity\");\n    }\n\n    /// @notice This will transfer borrowed asset tokens to the strategy vault and mint strategy tokens\n    /// in the vault account.\n    /// @param vaultConfig vault config\n    /// @param account account to pass to the vault\n    /// @param cashToTransferInternal amount of asset cash to  transfer in internal precision\n    /// @param maturity the maturity of the vault shares\n    /// the vault in enterVault\n    /// @param data arbitrary data to pass to the vault\n    /// @return vaultSharesMinted the amount of strategy tokens minted\n    function deposit(\n        VaultConfig memory vaultConfig,\n        address account,\n        int256 cashToTransferInternal,\n        uint256 maturity,\n        bytes calldata data\n    ) internal returns (uint256 vaultSharesMinted) {\n        // ETH transfers to the vault will be native ETH, not wrapped\n        uint256 underlyingTokensTransferred = transferFromNotional(\n            vaultConfig.vault, vaultConfig.borrowCurrencyId, cashToTransferInternal, vaultConfig.primeRate, false\n        );\n        vaultSharesMinted = IStrategyVault(vaultConfig.vault).depositFromNotional(\n            account, underlyingTokensTransferred, maturity, data\n        );\n    }\n\n    function depositMarginForVault(\n        VaultConfig memory vaultConfig,\n        VaultAccount memory vaultAccount,\n        uint256 depositAmountExternal\n    ) internal {\n        (/* */, int256 primeCashMinted) = TokenHandler.depositUnderlyingExternal(\n            vaultAccount.account,\n            vaultConfig.borrowCurrencyId,\n            depositAmountExternal.toInt(),\n            vaultConfig.primeRate,\n            false // excess ETH is returned natively, no excess ETH in this method\n        );\n        vaultAccount.tempCashBalance = vaultAccount.tempCashBalance.add(primeCashMinted);\n\n        // TokenHandler will emit a mint event and then the account will transfer that to the vault\n        Emitter.emitTransferPrimeCash(\n            vaultAccount.account, vaultConfig.vault, vaultConfig.borrowCurrencyId, primeCashMinted\n        );\n    }\n\n    /// @notice Redeems and transfers prime cash to the vault from Notional\n    /// @param vault address that receives the token\n    /// @param currencyId currency id to transfer\n    /// @param cashToTransferInternal amount of prime cash to transfer\n    /// @return underlyingTokensTransferred amount of underlying tokens transferred\n    function transferFromNotional(\n        address vault,\n        uint16 currencyId,\n        int256 cashToTransferInternal,\n        PrimeRate memory primeRate,\n        bool withdrawWrapped\n    ) internal returns (uint256) {\n        int256 underlyingExternalTransferred = TokenHandler.withdrawPrimeCash(\n            vault,\n            currencyId,\n            cashToTransferInternal.neg(), // represents a withdraw\n            primeRate,\n            withdrawWrapped\n        );\n\n        return underlyingExternalTransferred.neg().toUint();\n    }\n\n    /// @notice Redeems without any debt repayment and sends profits back to the receiver\n    function redeemWithDebtRepayment(\n        VaultConfig memory vaultConfig,\n        VaultAccount memory vaultAccount,\n        address receiver,\n        uint256 vaultShares,\n        bytes calldata data\n    ) internal returns (uint256 underlyingToReceiver) {\n        uint256 amountTransferred;\n        uint256 underlyingExternalToRepay;\n        {\n            Token memory underlyingToken = TokenHandler.getUnderlyingToken(vaultConfig.borrowCurrencyId);\n            // Calculates the amount of underlying tokens required to repay the debt, adjusting for potential\n            // dust values.\n            if (vaultAccount.tempCashBalance < 0) {\n                int256 x = vaultConfig.primeRate.convertToUnderlying(vaultAccount.tempCashBalance).neg();\n                underlyingExternalToRepay = underlyingToken.convertToUnderlyingExternalWithAdjustment(x).toUint();\n            } else {\n                // Otherwise require that cash balance is zero. Cannot have a positive cash balance in this method\n                require(vaultAccount.tempCashBalance == 0);\n            }\n\n            // Repayment checks operate entirely on the underlyingExternalToRepay, the amount of\n            // prime cash raised is irrelevant here since tempCashBalance is cleared to zero as\n            // long as sufficient underlying has been returned to the protocol.\n            (amountTransferred, underlyingToReceiver, /* primeCashRaised */) = _redeem(\n                vaultConfig,\n                underlyingToken,\n                vaultAccount.account,\n                receiver,\n                vaultShares,\n                vaultAccount.maturity,\n                underlyingExternalToRepay,\n                data\n            );\n        }\n\n        if (amountTransferred < underlyingExternalToRepay) {\n            // Recover any unpaid debt amount from the account directly\n            uint256 residualRequired = underlyingExternalToRepay - amountTransferred;\n\n            // actualTransferExternal is a positive number here to signify assets have entered\n            // the protocol, excess ETH payments will be returned to the account\n            (int256 actualTransferExternal, int256 primeCashDeposited) = TokenHandler.depositUnderlyingExternal(\n                vaultAccount.account,\n                vaultConfig.borrowCurrencyId,\n                residualRequired.toInt(),\n                vaultConfig.primeRate,\n                false // excess ETH payments returned natively\n            );\n            amountTransferred = amountTransferred.add(actualTransferExternal.toUint());\n\n            // Cash is held by the vault for debt repayment in this case.\n            Emitter.emitTransferPrimeCash(\n                vaultAccount.account, vaultConfig.vault, vaultConfig.borrowCurrencyId, primeCashDeposited\n            );\n        }\n\n        // amountTransferred should never be much more than underlyingExternalToRepay (it should\n        // be exactly equal) as long as the vault behaves according to spec. Any dust amounts will\n        // accrue to the protocol since vaultAccount.tempCashBalance is cleared\n        require(amountTransferred >= underlyingExternalToRepay, \"Insufficient repayment\");\n\n        // Clear tempCashBalance to remove the dust from internal accounting. tempCashBalance must be\n        // negative in this method (required at the top).\n        vaultAccount.tempCashBalance = 0;\n    }\n\n    /// @notice This will call the strategy vault and have it redeem the specified amount of strategy tokens\n    /// for underlying. \n    /// @return amountTransferred amount of underlying external transferred back to Notional\n    /// @return underlyingToReceiver the amount of underlying that was transferred to the receiver directly\n    /// from the vault. This is only used to emit events.\n    /// @return primeCashRaised the amount of prime cash added to the prime cash supply on Notional (related\n    /// to the amountTransferred figure)\n    function _redeem(\n        VaultConfig memory vaultConfig,\n        Token memory underlyingToken,\n        address account,\n        address receiver,\n        uint256 vaultShares,\n        uint256 maturity,\n        uint256 underlyingExternalToRepay,\n        bytes calldata data\n    ) private returns (\n        uint256 amountTransferred,\n        uint256 underlyingToReceiver,\n        int256 primeCashRaised\n    ) {\n            // There are four possibilities here during the transfer:\n            //   1. If the account == vaultConfig.vault then the strategy vault must always transfer\n            //      tokens back to Notional. underlyingToReceiver will equal 0, amountTransferred will\n            //      be the value of the redemption.\n            //   2. If the account has debt to repay and is redeeming sufficient tokens to repay the debt,\n            //      the vault will transfer back underlyingExternalToRepay and transfer underlyingToReceiver\n            //      directly to the receiver.\n            //   3. If the account has redeemed insufficient tokens to repay the debt, the vault will transfer\n            //      back as much as it can (less than underlyingExternalToRepay) and underlyingToReceiver will\n            //      be zero. If this occurs, then the next if block will be triggered where we attempt to recover\n            //      the shortfall from the account's wallet.\n            //   4. During liquidation, the liquidator will redeem their strategy token profits without any debt\n            //      to repay (underlyingExternalToRepay == 0). This means that all the profits will be returned\n            //      to the liquidator (params.receiver) from the vault (underlyingToReceiver will be the full value\n            //      of the redemption) and amountTransferred will equal 0. A similar scenario will occur when\n            //      accounts exit post maturity and have no debt associated with their account.\n        {\n            uint256 balanceBefore = underlyingToken.balanceOf(address(this));\n            underlyingToReceiver = IStrategyVault(vaultConfig.vault).redeemFromNotional(\n                account, receiver, vaultShares, maturity, underlyingExternalToRepay, data\n            );\n            uint256 balanceAfter = underlyingToken.balanceOf(address(this));\n            amountTransferred = balanceAfter.sub(balanceBefore);\n            TokenHandler.updateStoredTokenBalance(underlyingToken.tokenAddress, balanceBefore, balanceAfter);\n        }\n\n        // Convert to prime cash amount and update the total supply\n        int256 amountInternal = underlyingToken.convertToInternal(amountTransferred.toInt());\n        primeCashRaised = vaultConfig.primeRate.convertFromUnderlying(amountInternal);\n        PrimeCashExchangeRate.updateTotalPrimeSupply(vaultConfig.borrowCurrencyId, primeCashRaised, amountInternal);\n\n        _emitEvents(vaultConfig, underlyingToken, receiver, underlyingToReceiver, primeCashRaised);\n    }\n    \n    function _emitEvents(\n        VaultConfig memory vaultConfig,\n        Token memory underlyingToken,\n        address receiver,\n        uint256 underlyingToReceiver,\n        int256 primeCashRaised\n    ) private {\n        // Will emit:\n        // MINT PRIME (vault, underlyingToReceiver + primeCashRaised)\n        // TRANSFER PRIME (vault, account, underlyingToReceiver)\n        // BURN PRIME (account, underlyingToReceiver)\n        uint256 primeCashToReceiver = vaultConfig.primeRate.convertFromUnderlying(\n            underlyingToken.convertToInternal(underlyingToReceiver.toInt())\n        ).toUint();\n        Emitter.emitVaultMintTransferBurn(\n            vaultConfig.vault,\n            receiver,\n            vaultConfig.borrowCurrencyId,\n            primeCashRaised.toUint().add(primeCashToReceiver),\n            primeCashToReceiver\n        );\n    }\n\n    /// @notice Executes a trade on the AMM.\n    /// @param currencyId id of the vault borrow currency\n    /// @param maturity maturity to lend or borrow at\n    /// @param netfCashToAccount positive if lending, negative if borrowing\n    /// @param rateLimit 0 if there is no limit, otherwise is a slippage limit\n    /// @param blockTime current time\n    /// @return netPrimeCash amount of cash to credit to the account\n    function executeTrade(\n        uint16 currencyId,\n        address vault,\n        uint256 maturity,\n        int256 netfCashToAccount,\n        uint32 rateLimit,\n        uint256 maxBorrowMarketIndex,\n        uint256 blockTime\n    ) internal returns (int256 netPrimeCash) {\n        uint256 marketIndex = checkValidMaturity(currencyId, maturity, maxBorrowMarketIndex, blockTime);\n        // fCash is restricted from being larger than uint88 inside the trade module\n        uint256 fCashAmount = uint256(netfCashToAccount.abs());\n        require(fCashAmount < type(uint88).max);\n\n        // Encodes trade data for the TradingAction module\n        bytes32 trade = bytes32(\n            (uint256(uint8(netfCashToAccount > 0 ? TradeActionType.Lend : TradeActionType.Borrow)) << 248) |\n            (uint256(marketIndex) << 240) |\n            (uint256(fCashAmount) << 152) |\n            (uint256(rateLimit) << 120)\n        );\n\n        // Use the library here to reduce the deployed bytecode size\n        netPrimeCash = TradingAction.executeVaultTrade(currencyId, vault, trade);\n    }\n    \n    function checkValidMaturity(\n        uint16 currencyId,\n        uint256 maturity,\n        uint256 maxBorrowMarketIndex,\n        uint256 blockTime\n    ) internal view returns (uint256 marketIndex) {\n        bool isIdiosyncratic;\n        uint8 maxMarketIndex = CashGroup.getMaxMarketIndex(currencyId);\n        (marketIndex, isIdiosyncratic) = DateTime.getMarketIndex(maxMarketIndex, maturity, blockTime);\n        require(marketIndex <= maxBorrowMarketIndex); // dev: invalid maturity\n        require(!isIdiosyncratic); // dev: invalid maturity\n    }\n}"
    },
    {
      "filename": "contracts-v2/contracts/internal/vaults/VaultConfiguration.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    VaultConfig,\n    VaultAccount,\n    VaultConfigStorage,\n    VaultBorrowCapacityStorage,\n    TradeActionType,\n    PrimeRate,\n    Token,\n    TokenType,\n    VaultState\n} from \"../../global/Types.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\n\nimport {Emitter} from \"../Emitter.sol\";\nimport {DateTime} from \"../markets/DateTime.sol\";\nimport {CashGroup} from \"../markets/CashGroup.sol\";\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\nimport {PrimeCashExchangeRate} from \"../pCash/PrimeCashExchangeRate.sol\";\nimport {TokenHandler} from \"../balances/TokenHandler.sol\";\nimport {GenericToken} from \"../balances/protocols/GenericToken.sol\";\nimport {BalanceHandler} from \"../balances/BalanceHandler.sol\";\nimport {VaultStateLib} from \"./VaultState.sol\";\n\nimport {TradingAction} from \"../../external/actions/TradingAction.sol\";\nimport {IStrategyVault} from \"../../../interfaces/notional/IStrategyVault.sol\";\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\n\n/// @notice Vault configuration holds per vault parameters and methods that interact\n/// with vault level parameters (such as fee assessments, collateral ratios, capacity\n/// limits, etc.)\nlibrary VaultConfiguration {\n    using TokenHandler for Token;\n    using VaultStateLib for VaultState;\n    using SafeUint256 for uint256;\n    using SafeInt256 for int256;\n    using PrimeRateLib for PrimeRate;\n\n    /// @notice Emitted when the borrow capacity on a vault changes\n    event VaultBorrowCapacityChange(address indexed vault, uint16 indexed currencyId, uint256 totalUsedBorrowCapacity);\n    /// @notice Emitted when a vault's status is updated\n    event VaultPauseStatus(address indexed vault, bool enabled);\n\n    uint16 internal constant ENABLED                         = 1 << 0;\n    uint16 internal constant ALLOW_ROLL_POSITION             = 1 << 1;\n    // These flags switch the authentication on the vault methods such that all\n    // calls must come from the vault itself.\n    uint16 internal constant ONLY_VAULT_ENTRY                = 1 << 2;\n    uint16 internal constan"
    }
  ]
}