{
  "Title": "H-2: Incorrect ProtocolOwnedLiquidityOhm calculation due to inclusion of other user's reserves",
  "Content": "# Issue H-2: Incorrect ProtocolOwnedLiquidityOhm calculation due to inclusion of other user's reserves \n\nSource: https://github.com/sherlock-audit/2023-11-olympus-judging/issues/172 \n\n## Found by \nhash, tvdung94\n## Summary\nProtocolOwnedLiquidityOhm for Bunni can include the liquidity deposited by other users which is not protocol owned\n\n## Vulnerability Detail\nThe protocol owned liquidity in Bunni is calculated as the sum of reserves of all the BunniTokens\n```solidity\n    function getProtocolOwnedLiquidityOhm() external view override returns (uint256) {\n\n        uint256 len = bunniTokens.length;\n        uint256 total;\n        for (uint256 i; i < len; ) {\n            TokenData storage tokenData = bunniTokens[i];\n            BunniLens lens = tokenData.lens;\n            BunniKey memory key = _getBunniKey(tokenData.token);\n\n        .........\n\n            total += _getOhmReserves(key, lens);\n            unchecked {\n                ++i;\n            }\n        }\n\n\n        return total;\n    }\n```\n\nThe deposit function of Bunni allows any user to add liquidity to a token. Hence the returned reserve will contain amounts other than the reserves that actually belong to the protocol\n```solidity\n\n    // @audit callable by any user\n    function deposit(\n        DepositParams calldata params\n    )\n        external\n        payable\n        virtual\n        override\n        checkDeadline(params.deadline)\n        returns (uint256 shares, uint128 addedLiquidity, uint256 amount0, uint256 amount1)\n    {\n    }\n```  \n## Impact\nIncorrect assumption of the protocol owned liquidity and hence the supply. An attacker can inflate the liquidity reserves\nThe wider system relies on the supply calculation to be correct in order to perform actions of economical impact\n```text\nhttps://discord.com/channels/812037309376495636/1184355501258047488/1184397904551628831\nit will be determined to get backing\nso it will have an economical impact, as we could be exchanging ohm for treasury assets at a wrong price\n```\n\n## Code Snippet\nPOL liquidity is calculated as the sum of bunni token reserves\nhttps://github.com/sherlock-audit/2023-11-olympus/blob/9c8df76dc9820b4c6605d2e1e6d87dcfa9e50070/bophades/src/modules/SPPLY/submodules/BunniSupply.sol#L171-L191\n\nBunniHub allows any user to deposit\nhttps://github.com/sherlock-audit/2023-11-olympus/blob/9c8df76dc9820b4c6605d2e1e6d87dcfa9e50070/bophades/src/external/bunni/BunniHub.sol#L71-L106\n\n## Tool used\nManual Review\n\n## Recommendation\nGuard the deposit function in BunniHub or compute the liquidity using shares belonging to the protocol\n\n\n\n## Discussion\n\n**0xJem**\n\nThis is a good catch, and the high level is justified\n\n**0xrusowsky**\n\nhttps://github.com/OlympusDAO/bophades/pull/260\n\n**IAm0x52**\n\nFix looks good. OnlyOwner modifier has been added to deposits\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/128",
  "Code": [
    {
      "filename": "bophades/src/modules/SPPLY/submodules/BunniSupply.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\n// Bophades modules\nimport \"modules/SPPLY/SPPLY.v1.sol\";\n\n// Bunni contracts\nimport {BunniLens} from \"src/external/bunni/BunniLens.sol\";\nimport {BunniToken} from \"src/external/bunni/BunniToken.sol\";\nimport {BunniKey} from \"src/external/bunni/base/Structs.sol\";\nimport {IBunniHub} from \"src/external/bunni/interfaces/IBunniHub.sol\";\n\n// Standard libraries\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// Uniswap V3\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {OracleLibrary} from \"@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol\";\n\n// Libraries\nimport {FullMath} from \"libraries/FullMath.sol\";\nimport {Deviation} from \"libraries/Deviation.sol\";\nimport {UniswapV3OracleHelper} from \"libraries/UniswapV3/Oracle.sol\";\nimport {BunniHelper} from \"libraries/UniswapV3/BunniHelper.sol\";\n\n/// @title      BunniSupply\n/// @author     0xJem\n/// @notice     A SPPLY submodule that provides data on OHM deployed into Uniswap V3 pools that\n/// @notice     are managed by the BunniManager policy and its associated BunniHub.\ncontract BunniSupply is SupplySubmodule {\n    using FullMath for uint256;\n\n    // ========== ERRORS ========== //\n\n    /// @notice             The specified token is not a valid BunniToken\n    ///\n    /// @param token_       The address of the token\n    error BunniSupply_Params_InvalidBunniToken(address token_);\n\n    /// @notice             The specified lens is not a valid BunniLens\n    ///\n    /// @param lens_        The address of the lens\n    error BunniSupply_Params_InvalidBunniLens(address lens_);\n\n    /// @notice             The token and lens do not have the same BunniHub address\n    ///\n    /// @param tokenHub_    The BunniHub address of the token\n    /// @param lensHub_     The BunniHub address of the lens\n    error BunniSupply_Params_HubMismatch(address tokenHub_, address lensHub_);\n\n    /// @notice                     The specified maximum deviation from the TWAP is invalid\n    ///\n    /// @param token_               The address of the token\n    /// @param maximumDeviationBps_ The maximum allowed value\n    /// @param actualDeviationBps_  The maximum deviation from the TWAP in basis points\n    error BunniSupply_Params_InvalidTwapMaxDeviationBps(\n        address token_,\n        uint16 maximumDeviationBps_,\n        uint16 actualDeviationBps_\n    );\n\n    /// @notice                             The specified observation window for the TWAP is invalid\n    ///\n    /// @param token_                       The address of the token\n    /// @param minimumObservationWindow_    The minimum value of the observation window\n    /// @param actualObservationWindow_     The actual value of the observation window\n    error BunniSupply_Params_InvalidTwapObservationWindow(\n        address token_,\n        uint56 minimumObservationWindow_,\n        uint56 actualObservationWindow_\n    );\n\n    /// @notice                   The calculated pool price deviates from the TWAP by more than the maximum deviation.\n    ///\n    /// @param pool_              The address of the pool\n    /// @param baseInQuoteTWAP_   The calculated TWAP price in terms of the quote token\n    /// @param baseInQuotePrice_  The calculated current price in terms of the quote token\n    error BunniSupply_PriceMismatch(\n        address pool_,\n        uint256 baseInQuoteTWAP_,\n        uint256 baseInQuotePrice_\n    );\n\n    // ========== EVENTS ========== //\n\n    /// @notice             Emitted when a new BunniToken is added\n    /// @param token_       The address of the BunniToken contract\n    /// @param bunniLens_   The address of the BunniLens contract\n    event BunniTokenAdded(address token_, address bunniLens_);\n\n    /// @notice             Emitted when a BunniToken is removed\n    /// @param token_       The address of the BunniToken contract\n    event BunniTokenRemoved(address token_);\n\n    // ========== DATA STRUCTURES ========== //\n\n    struct TokenData {\n        BunniToken token;\n        BunniLens lens;\n        uint16 twapMaxDeviationBps;\n        uint32 twapObservationWindow;\n    }\n\n    // ========== STATE VARIABLES ========== //\n\n    /// @notice     The BunniTokens that are being monitored\n    TokenData[] public bunniTokens;\n\n    /// @notice     The number of BunniTokens that are being monitored\n    uint256 public bunniTokenCount;\n\n    /// @notice     The address of the OHM token\n    /// @dev        Set at deployment-time\n    address internal immutable ohm;\n\n    uint16 internal constant TWAP_MAX_DEVIATION_BASE = 10_000; // 100%\n\n    // ========== CONSTRUCTOR ========== //\n\n    /// @notice                 Initialize the submodule\n    ///\n    /// @param parent_          The parent module (SPPLY)\n    constructor(Module parent_) Submodule(parent_) {\n        ohm = address(SPPLYv1(address(parent_)).ohm());\n    }\n\n    // ========== SUBMODULE SETUP ========== //\n\n    /// @inheritdoc Submodule\n    function SUBKEYCODE() public pure override returns (SubKeycode) {\n        return toSubKeycode(\"SPPLY.BNI\");\n    }\n\n    /// @inheritdoc Submodule\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        major = 1;\n        minor = 0;\n    }\n\n    /// @inheritdoc Submodule\n    function INIT() external override onlyParent {}\n\n    // ========== DATA FUNCTIONS ========== //\n\n    /// @inheritdoc SupplySubmodule\n    function getSourceCount() external view override returns (uint256) {\n        return bunniTokens.length;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    /// @dev        Not applicable for Uniswap V3 pools managed by BunniHub\n    function getCollateralizedOhm() external pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    /// @dev        Not applicable for Uniswap V3 pools managed by BunniHub\n    function getProtocolOwnedBorrowableOhm() external pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    /// @dev        Returns the total of OHM in all of the registered tokens representing Uniswap V3 pools\n    ///\n    /// @dev        This function accesses the reserves of the registered\n    /// @dev        Uniswap V3 pools, and can be susceptible to re-entrancy attacks.\n    /// @dev        The BunniLens contract used by this Submodule performs a re-entrancy check.\n    ///\n    /// @dev        Additionally, the reserves and TWAP are compared to ensure that the reserves\n    /// @dev        have not been manipulated.\n    function getProtocolOwnedLiquidityOhm() external view override returns (uint256) {\n        // Iterate through tokens and total up the pool OHM reserves as the POL supply\n        uint256 len = bunniTokens.length;\n        uint256 total;\n        for (uint256 i; i < len; ) {\n            TokenData storage tokenData = bunniTokens[i];\n            BunniLens lens = tokenData.lens;\n            BunniKey memory key = _getBunniKey(tokenData.token);\n\n            // Validate reserves\n            _validateReserves(\n                key,\n                lens,\n                tokenData.twapMaxDeviationBps,\n                tokenData.twapObservationWindow\n            );\n\n            total += _getOhmReserves(key, lens);\n            unchecked {\n                ++i;\n            }\n        }\n\n        return total;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    function getProtocolOwnedTreasuryOhm() external pure override returns (uint256) {\n        // POTO is always zero for BunniTokens\n        return 0;\n    }\n\n    /// @inheritdoc SupplySubmodule\n    /// @dev        Returns the total of OHM and non-OHM reserves in the submodule\n    ///\n    /// @dev        This function accesses the reserves of the registered\n    /// @dev        Uniswap V3 pools, and can be susceptible to re-entrancy attacks.\n    /// @dev        The BunniLens contract used by this Submodule performs a re-entrancy check.\n    ///\n    /// @dev        Additionally, the reserves and TWAP are compared to ensure that the reserves\n    /// @dev        have not been manipulated.\n    function getProtocolOwnedLiquidityReserves()\n        external\n        view\n        override\n        returns (SPPLYv1.Reserves[] memory)\n    {\n        // Iterate through tokens and total up the reserves of each pool\n        uint256 len = bunniTokens.length;\n        SPPLYv1.Reserves[] memory reserves = new SPPLYv1.Reserves[](len);\n        for (uint256 i; i < len; ) {\n            TokenData storage tokenData = bunniTokens[i];\n            BunniToken token = tokenData.token;\n            BunniLens lens = tokenData.lens;\n            BunniKey memory key = _getBunniKey(token);\n            (\n                address token0,\n                address token1,\n                uint256 reserve0,\n                uint256 reserve1\n            ) = _getReservesWithFees(key, lens);\n\n            // Validate reserves\n            _validateReserves(\n                key,\n                lens,\n                tokenData.twapMaxDeviationBps,\n                tokenData.twapObservationWindow\n            );\n\n            address[] memory underlyingTokens = new address[](2);\n            underlyingTokens[0] = token0;\n            underlyingTokens[1] = token1;\n            uint256[] memory underlyingReserves = new uint256[](2);\n            underlyingReserves[0] = reserve0;\n            underlyingReserves[1] = reserve1;\n\n            reserves[i] = SPPLYv1.Reserves({\n                source: address(token),\n                tokens: underlyingTokens,\n                balances: underlyingReserves\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return reserves;\n    }\n\n    /// @notice         Determines whether `token_` has been registered\n    ///\n    /// @param token_   The address of the token\n    /// @return         True if the token has been registered, otherwise false\n    function hasBunniToken(address token_) external view returns (bool) {\n        if (token_ == address(0) || !_inTokenArray(token_)) return false;\n\n        return true;\n    }\n\n    // =========== ADMIN FUNCTIONS =========== //\n\n    /// @notice                         Adds a deployed BunniToken address to the list of monitored tokens\n    /// @dev                            Reverts if:\n    /// @dev                            - The address is the zero address\n    /// @dev                            - The address is already managed\n    /// @dev                            - The caller is not the parent module\n    /// @dev                            - `token_` does not adhere to the IBunniToken interface\n    /// @dev                            - `bunniLens_` does not adhere to the IBunniLens interface\n    /// @dev                            - `token_` and `bunniLens_` do not have the same BunniHub address\n    ///\n    /// @param token_                   The address of the BunniToken contract\n    /// @param bunniLens_               The address of the BunniLens contract\n    /// @param twapMaxDeviationBps_     The maximum deviation from the TWAP in basis points\n    /// @param twapObservationWindow_   The TWAP observation window in seconds\n    function addBunniToken(\n        address token_,\n        address bunniLens_,\n        uint16 twapMaxDeviationBps_,\n        uint32 twapObservationWindow_\n    ) external onlyParent {\n        if (token_ == address(0) || _inTokenArray(token_))\n            revert BunniSupply_Params_InvalidBunniToken(token_);\n\n        if (twapMaxDeviationBps_ > TWAP_MAX_DEVIATION_BASE)\n            revert BunniSupply_Params_InvalidTwapMaxDeviationBps(\n                token_,\n                TWAP_MAX_DEVIATION_BASE,\n                twapMaxDeviationBps_\n            );\n\n        if (twapObservationWindow_ < UniswapV3OracleHelper.TWAP_MIN_OBSERVATION_WINDOW)\n            revert BunniSupply_Params_InvalidTwapObservationWindow(\n                token_,\n                UniswapV3OracleHelper.TWAP_MIN_OBSERVATION_WINDOW,\n                twapObservationWindow_\n            );\n\n        if (bunniLens_ == address(0)) revert BunniSupply_Params_InvalidBunniLens(bunniLens_);\n\n        // Validate the token\n        BunniToken token = BunniToken(token_);\n        address tokenHub;\n        try token.hub() returns (IBunniHub tokenHub_) {\n            tokenHub = address(tokenHub_);\n        } catch (bytes memory) {\n            revert BunniSupply_Params_InvalidBunniToken(token_);\n        }\n\n        // Validate the lens\n        BunniLens lens = BunniLens(bunniLens_);\n        address lensHub;\n        try lens.hub() returns (IBunniHub lensHub_) {\n            lensHub = address(lensHub_);\n        } catch (bytes memory) {\n            revert BunniSupply_Params_InvalidBunniLens(bunniLens_);\n        }\n\n        // Check that the hub matches\n        if (tokenHub != lensHub) revert BunniSupply_Params_HubMismatch(tokenHub, lensHub);\n\n        bunniTokens.push(\n            TokenData({\n                token: token,\n                lens: lens,\n                twapMaxDeviationBps: twapMaxDeviationBps_,\n                twapObservationWindow: twapObservationWindow_\n            })\n        );\n        bunniTokenCount++;\n\n        emit BunniTokenAdded(token_, bunniLens_);\n    }\n\n    /// @notice                 Remove a deployed BunniToken address from the list of monitored tokens\n    /// @dev                    Reverts if:\n    /// @dev                    - The address is the zero address\n    /// @dev                    - The address is not managed\n    /// @dev                    - The caller is not the parent module\n    ///\n    /// @param token_           The address of the BunniToken contract\n    function removeBunniToken(address token_) external onlyParent {\n        if (token_ == address(0) || !_inTokenArray(token_))\n            revert BunniSupply_Params_InvalidBunniToken(token_);\n\n        uint256 len = bunniTokens.length;\n        uint256 bunniTokenIndex = type(uint256).max;\n        // Remove the token first\n        for (uint256 i; i < len; ) {\n            address tokenAddress = address(bunniTokens[i].token);\n            if (token_ == tokenAddress) {\n                bunniTokens[i] = bunniTokens[len - 1];\n                bunniTokens.pop();\n                bunniTokenIndex = i;\n                break;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        bunniTokenCount--;\n\n        emit BunniTokenRemoved(token_);\n    }\n\n    // =========== INTERNAL FUNCTIONS =========== //\n\n    /// @notice         Returns the BunniKey for the pool repesented by `token_` and the full-range ticks\n    ///\n    /// @param token_   The address of the BunniToken contract\n    /// @return         The BunniKey for the pool\n    function _getBunniKey(BunniToken token_) internal view returns (BunniKey memory) {\n        return\n            BunniKey({\n                pool: token_.pool(),\n                tickLower: token_.tickLower(),\n                tickUpper: token_.tickUpper()\n            });\n    }\n\n    /// @notice         Returns the OHM reserves for the pool represented by `key_`\n    ///\n    /// @param key_     The BunniKey for the pool\n    /// @param lens_    The BunniLens contract\n    /// @return         The OHM reserves for the pool\n    function _getOhmReserves(\n        BunniKey memory key_,\n        BunniLens lens_\n    ) internal view returns (uint256) {\n        (uint112 reserve0, uint112 reserve1) = lens_.getReserves(key_);\n        if (key_.pool.token0() == ohm) {\n            return reserve0;\n        } else {\n            return reserve1;\n        }\n    }\n\n    /// @notice         Returns the reserves for the pool represented by `key_`\n    /// @dev            Includes uncollected fees\n    ///\n    /// @param key_     The BunniKey for the pool\n    /// @param lens_    The BunniLens contract\n    /// @return         The reserves for the pool in the order of (token0, token1, reserve0, reserv1)\n    function _getReservesWithFees(\n        BunniKey memory key_,\n        BunniLens lens_\n    ) internal view returns (address, address, uint256, uint256) {\n        (uint112 reserve0, uint112 reserve1) = lens_.getReserves(key_);\n        (uint256 fee0, uint256 fee1) = lens_.getUncollectedFees(key_);\n\n        return (key_.pool.token0(), key_.pool.token1(), reserve0 + fee0, reserve1 + fee1);\n    }\n\n    /// @notice         Determines whether `token_` is in the `bunniTokens` array\n    ///\n    /// @param token_   The address of the token\n    /// @return         True if the token is in the array, otherwise false\n    function _inTokenArray(address token_) internal view returns (bool) {\n        uint256 len = bunniTokens.length;\n        for (uint256 i; i < len; ) {\n            address tokenAddress = address(bunniTokens[i].token);\n            if (token_ == tokenAddress) {\n                return true;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return false;\n    }\n\n    /// @notice                         Validates that the reserves of the pool represented by `key_` are within\n    /// @notice                         the maximum deviation from the pool's TWAP.\n    ///\n    /// @param key_                     The BunniKey for the pool\n    /// @param lens_                    The BunniLens contract\n    /// @param twapMaxDeviationBps_     The maximum deviation from the TWAP in basis points\n    /// @param twapObservationWindow_   The TWAP observation window in seconds\n    function _validateReserves(\n        BunniKey memory key_,\n        BunniLens lens_,\n        uint16 twapMaxDeviationBps_,\n        uint32 twapObservationWindow_\n    ) internal view {\n        uint256 reservesTokenRatio = BunniHelper.getReservesRatio(key_, lens_);\n        uint256 twapTokenRatio = UniswapV3OracleHelper.getTWAPRatio(\n            address(key_.pool),\n            twapObservationWindow_\n        );\n\n        // Revert if the relative deviation is greater than the maximum\n        if (\n            // Not necessary to use `isDeviatingWithBpsCheck()` as the checked is already performed in `addBunniToken`\n            Deviation.isDeviating(\n                reservesTokenRatio,\n                twapTokenRatio,\n                twapMaxDeviationBps_,\n                TWAP_MAX_DEVIATION_BASE\n            )\n        ) {\n            revert BunniSupply_PriceMismatch(\n                address(key_.pool),\n                twapTokenRatio,\n                reservesTokenRatio\n            );\n        }\n    }\n}"
    },
    {
      "filename": "bophades/src/external/bunni/BunniHub.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.15;\n\nimport {TickMath} from \"@uniswap/v3-core/contracts/libraries/TickMath.sol\";\nimport {FullMath} from \"@uniswap/v3-core/contracts/libraries/FullMath.sol\";\nimport {IUniswapV3Factory} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\n\nimport {Multicall} from \"@uniswap/v3-periphery/contracts/base/Multicall.sol\";\nimport {SelfPermit} from \"@uniswap/v3-periphery/contracts/base/SelfPermit.sol\";\nimport {LiquidityAmounts} from \"@uniswap/v3-periphery/contracts/libraries/LiquidityAmounts.sol\";\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {CREATE3} from \"solmate/utils/CREATE3.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport \"./base/Structs.sol\";\nimport {BunniToken} from \"./BunniToken.sol\";\nimport {IBunniHub} from \"./interfaces/IBunniHub.sol\";\nimport {IBunniToken} from \"./interfaces/IBunniToken.sol\";\nimport {LiquidityManagement} from \"./uniswap/LiquidityManagement.sol\";\n\n/// @title BunniHub\n/// @author zefram.eth\n/// @notice The main contract LPs interact with. Each BunniKey corresponds to a BunniToken,\n/// which is the ERC20 LP token for the Uniswap V3 position specified by the BunniKey.\n/// Use deposit()/withdraw() to mint/burn LP tokens, and use compound() to compound the swap fees\n/// back into the LP position.\n/// @dev    Imported at commit: https://github.com/ZeframLou/bunni/tree/fd65011c4e24660d0a63295cb3812c1821529842\n///\n/// @dev    The following changes were made from the original source code:\n/// @dev    - Use solmate ERC20 and SafeTransferLib instead of the local IERC20 and SafeTransferLib\n/// @dev    - updateSwapFees() function added\ncontract BunniHub is IBunniHub, Owned, Multicall, SelfPermit, LiquidityManagement {\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant MAX_PROTOCOL_FEE = 5e17;\n    uint256 internal constant MIN_INITIAL_SHARES = 1e9;\n\n    /// -----------------------------------------------------------\n    /// Storage variables\n    /// -----------------------------------------------------------\n\n    uint256 public override protocolFee;\n\n    /// -----------------------------------------------------------\n    /// Modifiers\n    /// -----------------------------------------------------------\n\n    modifier checkDeadline(uint256 deadline) {\n        require(block.timestamp <= deadline, \"OLD\");\n        _;\n    }\n\n    /// -----------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------\n\n    constructor(\n        IUniswapV3Factory factory_,\n        address owner_,\n        uint256 protocolFee_\n    ) Owned(owner_) LiquidityManagement(factory_) {\n        protocolFee = protocolFee_;\n    }\n\n    /// -----------------------------------------------------------\n    /// External functions\n    /// -----------------------------------------------------------\n\n    /// @inheritdoc IBunniHub\n    function deposit(\n        DepositParams calldata params\n    )\n        external\n        payable\n        virtual\n        override\n        checkDeadline(params.deadline)\n        returns (uint256 shares, uint128 addedLiquidity, uint256 amount0, uint256 amount1)\n    {\n        (uint128 existingLiquidity, , , , ) = params.key.pool.positions(\n            keccak256(abi.encodePacked(address(this), params.key.tickLower, params.key.tickUpper))\n        );\n        (addedLiquidity, amount0, amount1) = _addLiquidity(\n            LiquidityManagement.AddLiquidityParams({\n                key: params.key,\n                recipient: address(this),\n                payer: msg.sender,\n                amount0Desired: params.amount0Desired,\n                amount1Desired: params.amount1Desired,\n                amount0Min: params.amount0Min,\n                amount1Min: params.amount1Min\n            })\n        );\n        shares = _mintShares(params.key, params.recipient, addedLiquidity, existingLiquidity);\n\n        emit Deposit(\n            msg.sender,\n            params.recipient,\n            keccak256(abi.encode(params.key)),\n            addedLiquidity,\n            amount0,\n            amount1,\n            shares\n        );\n    }\n\n    /// @inheritdoc IBunniHub\n    function withdraw(\n        WithdrawParams calldata params\n    )\n        external\n        virtual\n        override\n        checkDeadline(params.deadline)\n        returns (uint128 removedLiquidity, uint256 amount0, uint256 amount1)\n    {\n        IBunniToken shareToken = getBunniToken(params.key);\n        require(address(shareToken) != address(0), \"WHAT\");\n\n        uint256 currentTotalSupply = shareToken.totalSupply();\n        (uint128 existingLiquidity, , , , ) = params.key.pool.positions(\n            keccak256(abi.encodePacked(address(this), params.key.tickLower, params.key.tickUpper))\n        );\n\n        // burn shares\n        require(params.shares > 0, \"0\");\n        shareToken.burn(msg.sender, params.shares);\n        // at this point of execution we know param.shares <= currentTotalSupply\n        // since otherwise the burn() call would've reverted\n\n        // burn liquidity from pool\n        // type cast is safe because we know removedLiquidity <= existingLiquidity\n        removedLiquidity = uint128(\n            FullMath.mulDiv(existingLiquidity, params.shares, currentTotalSupply)\n        );\n        // burn liquidity\n        // tokens are now collectable in the pool\n        (amount0, amount1) = params.key.pool.burn(\n            params.key.tickLower,\n            params.key.tickUpper,\n            removedLiquidity\n        );\n        // collect tokens and give to msg.sender\n        (amount0, amount1) = params.key.pool.collect(\n            params.recipient,\n            params.key.tickLower,\n            params.key.tickUpper,\n            uint128(amount0),\n            uint128(amount1)\n        );\n        require(amount0 >= params.amount0Min && amount1 >= params.amount1Min, \"SLIP\");\n\n        emit Withdraw(\n            msg.sender,\n            params.recipient,\n            keccak256(abi.encode(params.key)),\n            removedLiquidity,\n            amount0,\n            amount1,\n            params.shares\n        );\n    }\n\n    /// @inheritdoc IBunniHub\n    function updateSwapFees(\n        BunniKey calldata key\n    ) external virtual override returns (uint256 swapFee0, uint256 swapFee1) {\n        key.pool.burn(key.tickLower, key.tickUpper, 0);\n        (, , , uint128 cachedFeesOwed0, uint128 cachedFeesOwed1) = key.pool.positions(\n            keccak256(abi.encodePacked(address(this), key.tickLower, key.tickUpper))\n        );\n\n        return (cachedFeesOwed0, cachedFeesOwed1);\n    }\n\n    /// @inheritdoc IBunniHub\n    function compound(\n        BunniKey calldata key\n    ) external virtual override returns (uint128 addedLiquidity, uint256 amount0, uint256 amount1) {\n        uint256 protocolFee_ = protocolFee;\n\n        // trigger an update of the position fees owed snapshots if it has any liquidity\n        key.pool.burn(key.tickLower, key.tickUpper, 0);\n        (, , , uint128 cachedFeesOwed0, uint128 cachedFeesOwed1) = key.pool.positions(\n            keccak256(abi.encodePacked(address(this), key.tickLower, key.tickUpper))\n        );\n\n        /// -----------------------------------------------------------\n        /// amount0, amount1 are multi-purposed, see comments below\n        /// -----------------------------------------------------------\n        amount0 = cachedFeesOwed0;\n        amount1 = cachedFeesOwed1;\n\n        /// -----------------------------------------------------------\n        /// amount0, amount1 now store the updated amounts of fee owed\n        /// -----------------------------------------------------------\n\n        // the fee is likely not balanced (i.e. tokens will be left over after adding liquidity)\n        // so here we compute which token to fully claim and which token to partially claim\n        // so that we only claim the amounts we need\n\n        {\n            (uint160 sqrtRatioX96, , , , , , ) = key.pool.slot0();\n            uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(key.tickLower);\n            uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(key.tickUpper);\n\n            // compute the maximum liquidity addable using the accrued fees\n            uint128 maxAddLiquidity = LiquidityAmounts.getLiquidityForAmounts(\n                sqrtRatioX96,\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                amount0,\n                amount1\n            );\n\n            // compute the token amounts corresponding to the max addable liquidity\n            (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\n                sqrtRatioX96,\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                maxAddLiquidity\n            );\n        }\n\n        /// -----------------------------------------------------------\n        /// amount0, amount1 now store the amount of fees to claim\n        /// -----------------------------------------------------------\n\n        // the actual amounts collected are returned\n        // tokens are transferred to address(this)\n        (amount0, amount1) = key.pool.collect(\n            address(this),\n            key.tickLower,\n            key.tickUpper,\n            uint128(amount0),\n            uint128(amount1)\n        );\n\n        /// -----------------------------------------------------------\n        /// amount0, amount1 now store the fees claimed\n        /// -----------------------------------------------------------\n\n        if (protocolFee_ > 0) {\n            // take fee from amount0 and amount1 and transfer to factory\n            // amount0 uses 128 bits, protocolFee uses 60 bits\n            // so amount0 * protocolFee can't overflow 256 bits\n            uint256 fee0 = (amount0 * protocolFee_) / WAD;\n            uint256 fee1 = (amount1 * protocolFee_) / WAD;\n\n            // add fees (minus protocol fees) to Uniswap pool\n            (addedLiquidity, amount0, amount1) = _addLiquidity(\n                LiquidityManagement.AddLiquidityParams({\n                    key: key,\n                    recipient: address(this),\n                    payer: address(this),\n                    amount0Desired: amount0 - fee0,\n                    amount1Desired: amount1 - fee1,\n                    amount0Min: 0,\n                    amount1Min: 0\n                })\n            );\n\n            // the protocol fees are now stored in the factory itself\n            // and can be withdrawn by the owner via sweepTokens()\n\n            // emit event\n            emit PayProtocolFee(fee0, fee1);\n        } else {\n            // add fees to Uniswap pool\n            (addedLiquidity, amount0, amount1) = _addLiquidity(\n                LiquidityManagement.AddLiquidityParams({\n                    key: key,\n                    recipient: address(this),\n                    payer: address(this),\n                    amount0Desired: amount0,\n                    amount1Desired: amount1,\n                    amount0Min: 0,\n                    amount1Min: 0\n                })\n            );\n        }\n\n        /// -----------------------------------------------------------\n        /// amount0, amount1 now store the tokens added as liquidity\n        /// -----------------------------------------------------------\n\n        emit Compound(msg.sender, keccak256(abi.encode(key)), addedLiquidity, amount0, amount1);\n    }\n\n    /// @inheritdoc IBunniHub\n    function deployBunniToken(BunniKey calldata key) public override returns (IBunniToken token) {\n        bytes32 bunniKeyHash = keccak256(abi.encode(key));\n\n        token = IBunniToken(\n            CREATE3.deploy(\n                bunniKeyHash,\n                abi.encodePacked(type(BunniToken).creationCode, abi.encode(this, key)),\n                0\n            )\n        );\n\n        emit NewBunni(token, bunniKeyHash, key.pool, key.tickLower, key.tickUpper);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// View functions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IBunniHub\n    function getBunniToken(BunniKey calldata key) public view override returns (IBunniToken token) {\n        token = IBunniToken(CREATE3.getDeployed(keccak256(abi.encode(key))));\n\n        uint256 tokenCodeLength;\n        assembly {\n            tokenCodeLength := extcodesize(token)\n        }\n\n        if (tokenCodeLength == 0) {\n            return IBunniToken(address(0));\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Owner functions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IBunniHub\n    function sweepTokens(\n        ERC20[] calldata tokenList,\n        address recipient\n    ) external override onlyOwner {\n        uint256 tokenListLength = tokenList.length;\n        for (uint256 i; i < tokenListLength; ) {\n            SafeTransferLib.safeTransfer(\n                tokenList[i],\n                recipient,\n                tokenList[i].balanceOf(address(this))\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IBunniHub\n    function setProtocolFee(uint256 value) external override onlyOwner {\n        require(value <= MAX_PROTOCOL_FEE, \"MAX\");\n        protocolFee = value;\n        emit SetProtocolFee(value);\n    }\n\n    /// -----------------------------------------------------------\n    /// Internal functions\n    /// -----------------------------------------------------------\n\n    /// @notice Mints share tokens to the recipient based on the amount of liquidity added.\n    /// @param key The Bunni position's key\n    /// @param recipient The recipient of the share tokens\n    /// @param addedLiquidity The amount of liquidity added\n    /// @param existingLiquidity The amount of existing liquidity before the add\n    /// @return shares The amount of share tokens minted to the sender.\n    function _mintShares(\n        BunniKey calldata key,\n        address recipient,\n        uint128 addedLiquidity,\n        uint128 existingLiquidity\n    ) internal virtual returns (uint256 shares) {\n        IBunniToken shareToken = getBunniToken(key);\n        require(address(shareToken) != address(0), \"WHAT\");"
    }
  ]
}