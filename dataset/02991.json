{
  "Title": "M-13: Rely On Balancer Oracle Which Is Not Updated Frequently",
  "Content": "# Issue M-13: Rely On Balancer Oracle Which Is Not Updated Frequently \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/67 \n\n## Found by \nxiaoming90\n\n## Summary\n\nThe vault relies on Balancer Oracle which is not updated frequently.\n\n## Vulnerability Detail\n\n> Note: This issue affects the MetaStable2 balancer leverage vault\n\nWithin the `TwoTokenPoolUtils._getOraclePairPrice` function, it compute the pair price from the Balancer Oracle by calling the `BalancerUtils._getTimeWeightedOraclePrice` function which will in turn call the `IPriceOracle(pool).getTimeWeightedAverage` function to get the  time-weighted average pair prices (e.g. stETH/ETH). The Balancer pool that will be polled for the pair price can be found at https://etherscan.io/address/0x32296969Ef14EB0c6d29669C550D4a0449130230.\n\nThe issue is that this pool only handled ~1.5 transactions per day based on the last 5 days' data. In terms of average, the price will only be updated once every 16 hours. There are also many days that there is only 1 transaction. The following shows the number of transactions for each day within the audit period.\n\n- 5 Oct 2022 - 3 transactions\n- 4 Oct 2022 - 1 transaction\n- 3 Oct 2022 - 1 transaction\n- 2 Oct 2022 - 2 transactions\n- 1 Oct 2022 - 1 transaction\n\nNote that the price will only be updated whenever a transaction (e.g. swap) within the Balancer pool is triggered. Due to the lack of updates, the price provided by Balancer Oracle will not reflect the true value of the assets. Considering the stETH/ETH Balancer pool, the price of the stETH or ETH provided will not reflect the true value in the market.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L66\n\n```solidity\nFile: TwoTokenPoolUtils.sol\n066:     /// @notice Gets the oracle price pair price between two tokens using a weighted\n067:     /// average between a chainlink oracle and the balancer TWAP oracle.\n068:     /// @param poolContext oracle context variables\n069:     /// @param oracleContext oracle context variables\n070:     /// @param tradingModule address of the trading module\n071:     /// @return oraclePairPrice oracle price for the pair in 18 decimals\n072:     function _getOraclePairPrice(\n073:         TwoTokenPoolContext memory poolContext,\n074:         OracleContext memory oracleContext, \n075:         ITradingModule tradingModule\n076:     ) internal view returns (uint256 oraclePairPrice) {\n077:         // NOTE: this balancer price is denominated in 18 decimal places\n078:         uint256 balancerWeightedPrice;\n079:         if (oracleContext.balancerOracleWeight > 0) {\n080:             uint256 balancerPrice = BalancerUtils._getTimeWeightedOraclePrice(\n081:                 address(poolContext.basePool.pool),\n082:                 IPriceOracle.Variable.PAIR_PRICE,\n083:                 oracleContext.oracleWindowInSeconds\n084:             );\n085: \n086:             if (poolContext.primaryIndex == 1) {\n087:                 // If the primary index is the second token, we need to invert\n088:                 // the balancer price.\n089:                 balancerPrice = BalancerConstants.BALANCER_PRECISION_SQUARED / balancerPrice;\n090:             }\n091: \n092:             balancerWeightedPrice = balancerPrice * oracleContext.balancerOracleWeight;\n093:         }\n094: \n095:         uint256 chainlinkWeightedPrice;\n096:         if (oracleContext.balancerOracleWeight < BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION) {\n097:             (int256 rate, int256 decimals) = tradingModule.getOraclePrice(\n098:                 poolContext.primaryToken, poolContext.secondaryToken\n099:             );\n100:             require(rate > 0);\n101:             require(decimals >= 0);\n102: \n103:             if (uint256(decimals) != BalancerConstants.BALANCER_PRECISION) {\n104:                 rate = (rate * int256(BalancerConstants.BALANCER_PRECISION)) / decimals;\n105:             }\n106: \n107:             // No overflow in rate conversion, checked above\n108:             chainlinkWeightedPrice = uint256(rate) * \n109:                 (BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION - oracleContext.balancerOracleWeight);\n110:         }\n111: \n112:         oraclePairPrice = (balancerWeightedPrice + chainlinkWeightedPrice) / \n113:             BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION;\n114:     }\n```\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/BalancerUtils.sol#L21\n\n```solidity\nFile: BalancerUtils.sol\n21:     function _getTimeWeightedOraclePrice(\n22:         address pool,\n23:         IPriceOracle.Variable variable,\n24:         uint256 secs\n25:     ) internal view returns (uint256) {\n26:         IPriceOracle.OracleAverageQuery[]\n27:             memory queries = new IPriceOracle.OracleAverageQuery[](1);\n28: \n29:         queries[0].variable = variable;\n30:         queries[0].secs = secs;\n31:         queries[0].ago = 0; // now\n32: \n33:         // Gets the balancer time weighted average price denominated in the first token\n34:         return IPriceOracle(pool).getTimeWeightedAverage(queries)[0];\n35:     }\n```\n\n## Impact\n\nThe price provided by the function will not reflect the true value of the assets. It might be overvalued or undervalued. The affected function is being used in almost all functions within the vault. For instance, this function is part of the critical `_convertStrategyToUnderlying` function that computes the value of the strategy token in terms of its underlying assets. As a result, it might cause the following:\n\n  - Vault Settlement - Vault settlement requires computing the underlying value of the strategy tokens. It involves dealing with a large number of assets, and thus even a slight slippage in the price will be significantly amplified.\n  - Deleverage/Liquidation of Account - If the price provided does not reflect the true value, users whose debt ratio is close to the liquidation threshold might be pre-maturely deleveraged/liquidated since their total asset value might be undervalued.\n  - Borrowing - If the price provided does not reflect the true value, it might be possible that the assets of some users might be overvalued, and thus they are able to over-borrow from the vault.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol#L66\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/pool/BalancerUtils.sol#L21\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAlthough it is not possible to obtain a price pair that truly reflects the true value of an asset in the real world, the vault should attempt to minimize inaccuracy and slippage as much as possible. This can be done by choosing and using a more accurate Oracle that is updated more frequently instead of using the Balancer Oracle that is infrequently updated. \n\nChainlink should be used as the primary Oracle for price pair. If a secondary Oracle is needed for a price pair, consider using [Teller](https://tellor.io/) Oracle instead of Balancer Oracle. Some example of how Chainlink and Tellor works together in a live protocol can be found [here](https://www.liquity.org/blog/price-oracles-in-liquity)\n\nObtaining the time-weight average price of BTP LP token from Balancer Oracle is fine as the Balancer pool is the source of truth. However, getting the price of ETH or stETH from Balancer Oracle would not be a good option. \n\nOn a side note, it was observed that the weightage of the price pair is Balancer Oracle - 60% and Chainlink - 40%. Thus, this theoretically will reduce the impact of inaccurate prices provided by Balancer Oracle by around half. However, the team should still consider using a better Oracle as almost all the functions within the vault depends on the accurate price of underlying assets to operate.\n\nNote: For the stETH/ETH balancer leverage vault, the price pair is computed based on a weighted average of Balancer Oracle and Chainlink. Based on the test script, the weightage is Balancer Oracle - 60% and Chainlink - 40%.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/scripts/BalancerEnvironment.py#L45\n\n```python\nFile: BalancerEnvironment.py\n45:             \"maxRewardTradeSlippageLimitPercent\": 5e6,\n46:             \"balancerOracleWeight\": 0.6e4, # 60%\n47:             \"settlementCoolDownInMinutes\": 60 * 6, # 6 hour settlement cooldown\n```\n\n## Discussion\n\n**jeffywu**\n\n@T-Woodward \n\n**T-Woodward**\n\nYes, the threat you are talking about is potentially true however it depends on the time window you choose for the balancer price oracle and the particular pool. If it's a short time window and the pool is liquid and highly active, then the balancer pool is not a totally unreasonable source of truth.\n\nHaving said that, we do plan on removing the dependency to Balancer pool oracles entirely due to manipulation concerns so I will confirm this issue.\n\n**jeffywu**\n\nThis issue is not a duplicate of the Chainlink issues, it should be separate.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {\n    TwoTokenPoolContext, \n    OracleContext, \n    PoolParams,\n    DepositParams,\n    DynamicTradeParams,\n    DepositTradeParams,\n    RedeemParams,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {IAsset} from \"../../../../../interfaces/balancer/IBalancerVault.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {TwoTokenPoolUtils} from \"../pool/TwoTokenPoolUtils.sol\";\nimport {ITradingModule, Trade} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {IPriceOracle} from \"../../../../../interfaces/balancer/IPriceOracle.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\n\nlibrary TwoTokenPoolUtils {\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using TradeHandler for Trade;\n    using TypeConvert for uint256;\n    using StrategyUtils for StrategyContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n\n    /// @notice Returns parameters for joining and exiting Balancer pools\n    function _getPoolParams(\n        TwoTokenPoolContext memory context,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        bool isJoin\n    ) internal pure returns (PoolParams memory) {\n        IAsset[] memory assets = new IAsset[](2);\n        assets[context.primaryIndex] = IAsset(context.primaryToken);\n        assets[context.secondaryIndex] = IAsset(context.secondaryToken);\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[context.primaryIndex] = primaryAmount;\n        amounts[context.secondaryIndex] = secondaryAmount;\n\n        uint256 msgValue;\n        if (isJoin && assets[context.primaryIndex] == IAsset(Deployments.ETH_ADDRESS)) {\n            msgValue = amounts[context.primaryIndex];\n        }\n\n        return PoolParams(assets, amounts, msgValue);\n    }\n\n    /// @notice Gets the oracle price pair price between two tokens using a weighted\n    /// average between a chainlink oracle and the balancer TWAP oracle.\n    /// @param poolContext oracle context variables\n    /// @param oracleContext oracle context variables\n    /// @param tradingModule address of the trading module\n    /// @return oraclePairPrice oracle price for the pair in 18 decimals\n    function _getOraclePairPrice(\n        TwoTokenPoolContext memory poolContext,\n        OracleContext memory oracleContext, \n        ITradingModule tradingModule\n    ) internal view returns (uint256 oraclePairPrice) {\n        // NOTE: this balancer price is denominated in 18 decimal places\n        uint256 balancerWeightedPrice;\n        if (oracleContext.balancerOracleWeight > 0) {\n            uint256 balancerPrice = BalancerUtils._getTimeWeightedOraclePrice(\n                address(poolContext.basePool.pool),\n                IPriceOracle.Variable.PAIR_PRICE,\n                oracleContext.oracleWindowInSeconds\n            );\n\n            if (poolContext.primaryIndex == 1) {\n                // If the primary index is the second token, we need to invert\n                // the balancer price.\n                balancerPrice = BalancerConstants.BALANCER_PRECISION_SQUARED / balancerPrice;\n            }\n\n            balancerWeightedPrice = balancerPrice * oracleContext.balancerOracleWeight;\n        }\n\n        uint256 chainlinkWeightedPrice;\n        if (oracleContext.balancerOracleWeight < BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION) {\n            (int256 rate, int256 decimals) = tradingModule.getOraclePrice(\n                poolContext.primaryToken, poolContext.secondaryToken\n            );\n            require(rate > 0);\n            require(decimals >= 0);\n\n            if (uint256(decimals) != BalancerConstants.BALANCER_PRECISION) {\n                rate = (rate * int256(BalancerConstants.BALANCER_PRECISION)) / decimals;\n            }\n\n            // No overflow in rate conversion, checked above\n            chainlinkWeightedPrice = uint256(rate) * \n                (BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION - oracleContext.balancerOracleWeight);\n        }\n\n        oraclePairPrice = (balancerWeightedPrice + chainlinkWeightedPrice) / \n            BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION;\n    }\n\n    /// @notice Gets the time-weighted primary token balance for a given bptAmount\n    /// @dev Balancer pool needs to be fully initialized with at least 1024 trades\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param bptAmount amount of balancer pool lp tokens\n    /// @return primaryAmount primary token balance\n    function _getTimeWeightedPrimaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        OracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 primaryAmount) {\n        // Gets the BPT token price denominated in token index = 0\n        uint256 bptPrice = BalancerUtils._getTimeWeightedOraclePrice(\n            address(poolContext.basePool.pool),\n            IPriceOracle.Variable.BPT_PRICE,\n            oracleContext.oracleWindowInSeconds\n        );\n\n        uint256 pairPrice = _getOraclePairPrice(poolContext, oracleContext, strategyContext.tradingModule);\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n\n        if (poolContext.primaryIndex == 0) {\n            // Since bptPrice is always denominated in the first token, we can just multiply by\n            // the amount in this case. Both bptPrice and bptAmount are in 1e18 but we need to scale\n            // this back to the primary token's native precision.\n            // underlyingValue = (bptPrice * bptAmount * primaryPrecision) / (1e18 * 1e18)\n            primaryAmount = (bptPrice * bptAmount * primaryPrecision) / \n                BalancerConstants.BALANCER_PRECISION_SQUARED;\n        } else {\n            // The second token in the BPT pool is the price that we want to get. In this case, we need to\n            // convert secondaryTokenValue to underlyingValue using the pairPrice.\n            // Both bptPrice and bptAmount are in 1e18\n            uint256 secondaryAmount = (bptPrice * bptAmount) / BalancerConstants.BALANCER_PRECISION;\n\n            // And then normalizing to primary token precision we add:\n            // PrimaryAmount = (SecondaryAmount * primaryPrecision) / PairPrice\n            primaryAmount = (secondaryAmount * primaryPrecision) / pairPrice;\n        }\n    }\n\n    function _approveBalancerTokens(TwoTokenPoolContext memory poolContext, address bptSpender) internal {\n        IERC20(poolContext.primaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        IERC20(poolContext.secondaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        // Allow BPT spender to pull BALANCER_POOL_TOKEN\n        IERC20(address(poolContext.basePool.pool)).checkApprove(bptSpender, type(uint256).max);\n    }\n\n    /// @notice Trade primary currency for secondary if the trade is specified\n    function _tradePrimaryForSecondary(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        bytes memory data\n    ) private returns (uint256 primarySold, uint256 secondaryBought) {\n        (DepositTradeParams memory params) = abi.decode(data, (DepositTradeParams));\n\n        (primarySold, secondaryBought) = StrategyUtils._executeDynamicTradeExactIn({\n            params: params.tradeParams, \n            tradingModule: strategyContext.tradingModule, \n            sellToken: poolContext.primaryToken, \n            buyToken: poolContext.secondaryToken, \n            amount: params.tradeAmount\n        });\n    }\n\n    function _deposit(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 deposit,\n        DepositParams memory params\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 secondaryAmount;\n        if (params.tradeData.length != 0) {\n            // Allows users to trade on a different DEX instead of Balancer when joining\n            (uint256 primarySold, uint256 secondaryBought) = _tradePrimaryForSecondary({\n                poolContext: poolContext,\n                strategyContext: strategyContext,\n                data: params.tradeData\n            });\n            deposit -= primarySold;\n            secondaryAmount = secondaryBought;\n        }\n\n        uint256 bptMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            primaryAmount: deposit,\n            secondaryAmount: secondaryAmount,\n            minBPT: params.minBPT\n        });\n\n        strategyTokensMinted = strategyContext._convertBPTClaimToStrategyTokens(bptMinted);\n\n        // Update global supply count\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _sellSecondaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        RedeemParams memory params,\n        uint256 secondaryBalance\n    ) private returns (uint256 primaryPurchased) {\n        (DynamicTradeParams memory tradeParams) = abi.decode(\n            params.secondaryTradeParams, (DynamicTradeParams)\n        );\n\n        ( /*uint256 amountSold */, primaryPurchased) = \n            StrategyUtils._executeDynamicTradeExactIn({\n                params: tradeParams,\n                tradingModule: strategyContext.tradingModule,\n                sellToken: poolContext.secondaryToken,\n                buyToken: poolContext.primaryToken,\n                amount: secondaryBalance\n            });\n    }\n\n    function _redeem(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        RedeemParams memory params\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n        if (bptClaim == 0) return 0;\n\n        // Underlying token balances from exiting the pool\n        (uint256 primaryBalance, uint256 secondaryBalance)\n            = _unstakeAndExitPool(\n                poolContext, stakingContext, bptClaim, params.minPrimary, params.minSecondary\n            );\n\n        finalPrimaryBalance = primaryBalance;\n        if (secondaryBalance > 0) {\n            uint256 primaryPurchased = _sellSecondaryBalance(\n                poolContext, strategyContext, params, secondaryBalance\n            );\n\n            finalPrimaryBalance += primaryPurchased;\n        }\n\n        // Update global strategy token balance\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _joinPoolAndStake(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        uint256 minBPT\n    ) internal returns (uint256 bptMinted) {\n        // prettier-ignore\n        PoolParams memory poolParams = poolContext._getPoolParams( \n            primaryAmount, \n            secondaryAmount,\n            true // isJoin\n        );\n\n        bptMinted = BalancerUtils._joinPoolExactTokensIn({\n            context: poolContext.basePool,\n            params: poolParams,\n            minBPT: minBPT\n        });\n\n        // Check BPT threshold to make sure our share of the pool is\n        // below maxBalancerPoolShare\n        uint256 bptThreshold = strategyContext.vaultSettings._bptThreshold(\n            poolContext.basePool.pool.totalSupply()\n        );\n        uint256 bptHeldAfterJoin = strategyContext.totalBPTHeld + bptMinted;\n        if (bptHeldAfterJoin > bptThreshold)\n            revert Errors.BalancerPoolShareTooHigh(bptHeldAfterJoin, bptThreshold);\n\n        // Transfer token to Aura protocol for boosted staking\n        stakingContext.auraBooster.deposit(stakingContext.auraPoolId, bptMinted, true); // stake = true\n    }\n\n    function _unstakeAndExitPool(\n        TwoTokenPoolContext memory poolContext,\n        AuraStakingContext memory stakingContext,\n        uint256 bptClaim,\n        uint256 minPrimary,\n        uint256 minSecondary\n    ) internal returns (uint256 primaryBalance, uint256 secondaryBalance) {\n        // Withdraw BPT tokens back to the vault for redemption\n        stakingContext.auraRewardPool.withdrawAndUnwrap(bptClaim, false); // claimRewards = false\n\n        uint256[] memory exitBalances = BalancerUtils._exitPoolExactBPTIn({\n            context: poolContext.basePool,\n            params: poolContext._getPoolParams(minPrimary, minSecondary, false), // isJoin = false\n            bptExitAmount: bptClaim\n        });\n        \n        (primaryBalance, secondaryBalance) \n            = (exitBalances[poolContext.primaryIndex], exitBalances[poolContext.secondaryIndex]);\n    }\n\n    /// @notice We value strategy tokens in terms of the primary balance. The time weighted\n    /// primary balance is used in order to prevent pool manipulation.\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param strategyTokenAmount amount of strategy tokens\n    /// @return underlyingValue underlying value of strategy tokens\n    function _convertStrategyToUnderlying(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        OracleContext memory oracleContext,\n        uint256 strategyTokenAmount\n    ) internal view returns (int256 underlyingValue) {\n        \n        uint256 bptClaim \n            = strategyContext._convertStrategyTokensToBPTClaim(strategyTokenAmount);\n\n        underlyingValue \n            = poolContext._getTimeWeightedPrimaryBalance(oracleContext, strategyContext, bptClaim).toInt();\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/pool/BalancerUtils.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {IBalancerVault, IAsset} from \"../../../../../interfaces/balancer/IBalancerVault.sol\";\nimport {PoolContext, PoolParams} from \"../../BalancerVaultTypes.sol\";\nimport {IPriceOracle} from \"../../../../../interfaces/balancer/IPriceOracle.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\n\nlibrary BalancerUtils {\n    using TokenUtils for IERC20;\n\n    /// @notice Special handling for ETH because UNDERLYING_TOKEN == address(0)\n    /// and Balancer uses WETH\n    function getTokenAddress(address token) internal pure returns (address) {\n        return token == Deployments.ETH_ADDRESS ? address(Deployments.WETH) : address(token);\n    }\n\n    function _getTimeWeightedOraclePrice(\n        address pool,\n        IPriceOracle.Variable variable,\n        uint256 secs\n    ) internal view returns (uint256) {\n        IPriceOracle.OracleAverageQuery[]\n            memory queries = new IPriceOracle.OracleAverageQuery[](1);\n\n        queries[0].variable = variable;\n        queries[0].secs = secs;\n        queries[0].ago = 0; // now\n\n        // Gets the balancer time weighted average price denominated in the first token\n        return IPriceOracle(pool).getTimeWeightedAverage(queries)[0];\n    }\n\n    /// @notice Normalizes balances to 1e18 (used by Balancer price oracle functions)\n    function _normalizeBalances(\n        uint256 primaryBalance,\n        uint8 primaryDecimals,\n        uint256 secondaryBalance,\n        uint8 secondaryDecimals\n    ) internal pure returns (uint256 normalizedPrimary, uint256 normalizedSecondary) {\n        if (primaryDecimals == 18) {\n            normalizedPrimary = primaryBalance;\n        } else {\n            uint256 decimalAdjust;\n            unchecked {\n                decimalAdjust = 10**(18 - primaryDecimals);\n            }\n            normalizedPrimary = primaryBalance * decimalAdjust;\n        }\n\n        if (secondaryDecimals == 18) {\n            normalizedSecondary = secondaryBalance;\n        } else {\n            uint256 decimalAdjust;\n            unchecked {\n                decimalAdjust = 10**(18 - secondaryDecimals);\n            }\n            normalizedSecondary = secondaryBalance * decimalAdjust;\n        }\n    }\n\n    /// @notice Joins a balancer pool using exact tokens in\n    function _joinPoolExactTokensIn(\n        PoolContext memory context,\n        PoolParams memory params,\n        uint256 minBPT\n    ) internal returns (uint256 bptAmount) {\n        bptAmount = IERC20(address(context.pool)).balanceOf(address(this));\n        Deployments.BALANCER_VAULT.joinPool{value: params.msgValue}(\n            context.poolId,\n            address(this),\n            address(this),\n            IBalancerVault.JoinPoolRequest(\n                params.assets,\n                params.amounts,\n                abi.encode(\n                    IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n                    params.amounts,\n                    minBPT // Apply minBPT to prevent front running\n                ),\n                false // Don't use internal balances\n            )\n        );\n        bptAmount =\n            IERC20(address(context.pool)).balanceOf(address(this)) -\n            bptAmount;\n    }\n\n    /// @notice Exits a balancer pool using exact BPT in\n    function _exitPoolExactBPTIn(\n        PoolContext memory context,\n        PoolParams memory params,\n        uint256 bptExitAmount\n    ) internal returns (uint256[] memory exitBalances) {\n        uint256 numAssets = params.assets.length;\n        exitBalances = new uint256[](numAssets);\n\n        for (uint256 i; i < numAssets; i++) {\n            exitBalances[i] = TokenUtils.tokenBalance(address(params.assets[i]));\n        }\n\n        Deployments.BALANCER_VAULT.exitPool(\n            context.poolId,\n            address(this),\n            payable(address(this)), // Vault will receive the underlying assets\n            IBalancerVault.ExitPoolRequest(\n                params.assets,\n                params.amounts,\n                abi.encode(\n                    IBalancerVault.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,\n                    bptExitAmount\n                ),\n                false // Don't use internal balances\n            )\n        );\n\n        for (uint256 i; i < numAssets; i++) {\n            exitBalances[i] = TokenUtils.tokenBalance(address(params.assets[i])) - exitBalances[i];\n        }\n    }\n\n    function _swapGivenIn(\n        bytes32 poolId,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 limit\n    ) internal returns (uint256 amountOut) {\n        amountOut = IERC20(tokenOut).balanceOf(address(this));\n        Deployments.BALANCER_VAULT.swap({\n            singleSwap: IBalancerVault.SingleSwap({\n                poolId: poolId,\n                kind: IBalancerVault.SwapKind.GIVEN_IN,\n                assetIn: IAsset(tokenIn),\n                assetOut: IAsset(tokenOut),\n                amount: amountIn,\n                userData: new bytes(0)\n            }),\n            funds: IBalancerVault.FundManagement({\n                sender: address(this),\n                fromInternalBalance: false,\n                recipient: payable(address(this)),\n                toInternalBalance: false\n            }),\n            limit: limit,\n            deadline: block.timestamp\n        });\n        amountOut = IERC20(tokenOut).balanceOf(address(this)) - amountOut;\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/pool/TwoTokenPoolUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {\n    TwoTokenPoolContext, \n    OracleContext, \n    PoolParams,\n    DepositParams,\n    DynamicTradeParams,\n    DepositTradeParams,\n    RedeemParams,\n    AuraStakingContext,\n    StrategyContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../../BalancerVaultTypes.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {Errors} from \"../../../../global/Errors.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {TypeConvert} from \"../../../../global/TypeConvert.sol\";\nimport {IAsset} from \"../../../../../interfaces/balancer/IBalancerVault.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {AuraStakingUtils} from \"../staking/AuraStakingUtils.sol\";\nimport {BalancerVaultStorage} from \"../BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"../strategy/StrategyUtils.sol\";\nimport {TwoTokenPoolUtils} from \"../pool/TwoTokenPoolUtils.sol\";\nimport {ITradingModule, Trade} from \"../../../../../interfaces/trading/ITradingModule.sol\";\nimport {IPriceOracle} from \"../../../../../interfaces/balancer/IPriceOracle.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\n\nlibrary TwoTokenPoolUtils {\n    using TokenUtils for IERC20;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using TradeHandler for Trade;\n    using TypeConvert for uint256;\n    using StrategyUtils for StrategyContext;\n    using AuraStakingUtils for AuraStakingContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n    using BalancerVaultStorage for StrategyVaultState;\n\n    /// @notice Returns parameters for joining and exiting Balancer pools\n    function _getPoolParams(\n        TwoTokenPoolContext memory context,\n        uint256 primaryAmount,\n        uint256 secondaryAmount,\n        bool isJoin\n    ) internal pure returns (PoolParams memory) {\n        IAsset[] memory assets = new IAsset[](2);\n        assets[context.primaryIndex] = IAsset(context.primaryToken);\n        assets[context.secondaryIndex] = IAsset(context.secondaryToken);\n\n        uint256[] memory amounts = new uint256[](2);\n        amounts[context.primaryIndex] = primaryAmount;\n        amounts[context.secondaryIndex] = secondaryAmount;\n\n        uint256 msgValue;\n        if (isJoin && assets[context.primaryIndex] == IAsset(Deployments.ETH_ADDRESS)) {\n            msgValue = amounts[context.primaryIndex];\n        }\n\n        return PoolParams(assets, amounts, msgValue);\n    }\n\n    /// @notice Gets the oracle price pair price between two tokens using a weighted\n    /// average between a chainlink oracle and the balancer TWAP oracle.\n    /// @param poolContext oracle context variables\n    /// @param oracleContext oracle context variables\n    /// @param tradingModule address of the trading module\n    /// @return oraclePairPrice oracle price for the pair in 18 decimals\n    function _getOraclePairPrice(\n        TwoTokenPoolContext memory poolContext,\n        OracleContext memory oracleContext, \n        ITradingModule tradingModule\n    ) internal view returns (uint256 oraclePairPrice) {\n        // NOTE: this balancer price is denominated in 18 decimal places\n        uint256 balancerWeightedPrice;\n        if (oracleContext.balancerOracleWeight > 0) {\n            uint256 balancerPrice = BalancerUtils._getTimeWeightedOraclePrice(\n                address(poolContext.basePool.pool),\n                IPriceOracle.Variable.PAIR_PRICE,\n                oracleContext.oracleWindowInSeconds\n            );\n\n            if (poolContext.primaryIndex == 1) {\n                // If the primary index is the second token, we need to invert\n                // the balancer price.\n                balancerPrice = BalancerConstants.BALANCER_PRECISION_SQUARED / balancerPrice;\n            }\n\n            balancerWeightedPrice = balancerPrice * oracleContext.balancerOracleWeight;\n        }\n\n        uint256 chainlinkWeightedPrice;\n        if (oracleContext.balancerOracleWeight < BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION) {\n            (int256 rate, int256 decimals) = tradingModule.getOraclePrice(\n                poolContext.primaryToken, poolContext.secondaryToken\n            );\n            require(rate > 0);\n            require(decimals >= 0);\n\n            if (uint256(decimals) != BalancerConstants.BALANCER_PRECISION) {\n                rate = (rate * int256(BalancerConstants.BALANCER_PRECISION)) / decimals;\n            }\n\n            // No overflow in rate conversion, checked above\n            chainlinkWeightedPrice = uint256(rate) * \n                (BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION - oracleContext.balancerOracleWeight);\n        }\n\n        oraclePairPrice = (balancerWeightedPrice + chainlinkWeightedPrice) / \n            BalancerConstants.BALANCER_ORACLE_WEIGHT_PRECISION;\n    }\n\n    /// @notice Gets the time-weighted primary token balance for a given bptAmount\n    /// @dev Balancer pool needs to be fully initialized with at least 1024 trades\n    /// @param poolContext pool context variables\n    /// @param oracleContext oracle context variables\n    /// @param bptAmount amount of balancer pool lp tokens\n    /// @return primaryAmount primary token balance\n    function _getTimeWeightedPrimaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        OracleContext memory oracleContext,\n        StrategyContext memory strategyContext,\n        uint256 bptAmount\n    ) internal view returns (uint256 primaryAmount) {\n        // Gets the BPT token price denominated in token index = 0\n        uint256 bptPrice = BalancerUtils._getTimeWeightedOraclePrice(\n            address(poolContext.basePool.pool),\n            IPriceOracle.Variable.BPT_PRICE,\n            oracleContext.oracleWindowInSeconds\n        );\n\n        uint256 pairPrice = _getOraclePairPrice(poolContext, oracleContext, strategyContext.tradingModule);\n        uint256 primaryPrecision = 10 ** poolContext.primaryDecimals;\n\n        if (poolContext.primaryIndex == 0) {\n            // Since bptPrice is always denominated in the first token, we can just multiply by\n            // the amount in this case. Both bptPrice and bptAmount are in 1e18 but we need to scale\n            // this back to the primary token's native precision.\n            // underlyingValue = (bptPrice * bptAmount * primaryPrecision) / (1e18 * 1e18)\n            primaryAmount = (bptPrice * bptAmount * primaryPrecision) / \n                BalancerConstants.BALANCER_PRECISION_SQUARED;\n        } else {\n            // The second token in the BPT pool is the price that we want to get. In this case, we need to\n            // convert secondaryTokenValue to underlyingValue using the pairPrice.\n            // Both bptPrice and bptAmount are in 1e18\n            uint256 secondaryAmount = (bptPrice * bptAmount) / BalancerConstants.BALANCER_PRECISION;\n\n            // And then normalizing to primary token precision we add:\n            // PrimaryAmount = (SecondaryAmount * primaryPrecision) / PairPrice\n            primaryAmount = (secondaryAmount * primaryPrecision) / pairPrice;\n        }\n    }\n\n    function _approveBalancerTokens(TwoTokenPoolContext memory poolContext, address bptSpender) internal {\n        IERC20(poolContext.primaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        IERC20(poolContext.secondaryToken).checkApprove(address(Deployments.BALANCER_VAULT), type(uint256).max);\n        // Allow BPT spender to pull BALANCER_POOL_TOKEN\n        IERC20(address(poolContext.basePool.pool)).checkApprove(bptSpender, type(uint256).max);\n    }\n\n    /// @notice Trade primary currency for secondary if the trade is specified\n    function _tradePrimaryForSecondary(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        bytes memory data\n    ) private returns (uint256 primarySold, uint256 secondaryBought) {\n        (DepositTradeParams memory params) = abi.decode(data, (DepositTradeParams));\n\n        (primarySold, secondaryBought) = StrategyUtils._executeDynamicTradeExactIn({\n            params: params.tradeParams, \n            tradingModule: strategyContext.tradingModule, \n            sellToken: poolContext.primaryToken, \n            buyToken: poolContext.secondaryToken, \n            amount: params.tradeAmount\n        });\n    }\n\n    function _deposit(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        uint256 deposit,\n        DepositParams memory params\n    ) internal returns (uint256 strategyTokensMinted) {\n        uint256 secondaryAmount;\n        if (params.tradeData.length != 0) {\n            // Allows users to trade on a different DEX instead of Balancer when joining\n            (uint256 primarySold, uint256 secondaryBought) = _tradePrimaryForSecondary({\n                poolContext: poolContext,\n                strategyContext: strategyContext,\n                data: params.tradeData\n            });\n            deposit -= primarySold;\n            secondaryAmount = secondaryBought;\n        }\n\n        uint256 bptMinted = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            primaryAmount: deposit,\n            secondaryAmount: secondaryAmount,\n            minBPT: params.minBPT\n        });\n\n        strategyTokensMinted = strategyContext._convertBPTClaimToStrategyTokens(bptMinted);\n\n        // Update global supply count\n        strategyContext.vaultState.totalStrategyTokenGlobal += strategyTokensMinted.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _sellSecondaryBalance(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        RedeemParams memory params,\n        uint256 secondaryBalance\n    ) private returns (uint256 primaryPurchased) {\n        (DynamicTradeParams memory tradeParams) = abi.decode(\n            params.secondaryTradeParams, (DynamicTradeParams)\n        );\n\n        ( /*uint256 amountSold */, primaryPurchased) = \n            StrategyUtils._executeDynamicTradeExactIn({\n                params: tradeParams,\n                tradingModule: strategyContext.tradingModule,\n                sellToken: poolContext.secondaryToken,\n                buyToken: poolContext.primaryToken,\n                amount: secondaryBalance\n            });\n    }\n\n    function _redeem(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,\n        AuraStakingContext memory stakingContext,\n        address account,\n        uint256 strategyTokens,\n        uint256 maturity,\n        RedeemParams memory params\n    ) internal returns (uint256 finalPrimaryBalance) {\n        uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\n\n        if (bptClaim == 0) return 0;\n\n        // Underlying token balances from exiting the pool\n        (uint256 primaryBalance, uint256 secondaryBalance)\n            = _unstakeAndExitPool(\n                poolContext, stakingContext, bptClaim, params.minPrimary, params.minSecondary\n            );\n\n        finalPrimaryBalance = primaryBalance;\n        if (secondaryBalance > 0) {\n            uint256 primaryPurchased = _sellSecondaryBalance(\n                poolContext, strategyContext, params, secondaryBalance\n            );\n\n            finalPrimaryBalance += primaryPurchased;\n        }\n\n        // Update global strategy token balance\n        strategyContext.vaultState.totalStrategyTokenGlobal -= strategyTokens.toUint80();\n        strategyContext.vaultState.setStrategyVaultState(); \n    }\n\n    function _joinPoolAndStake(\n        TwoTokenPoolContext memory poolContext,\n        StrategyContext memory strategyContext,"
    }
  ]
}