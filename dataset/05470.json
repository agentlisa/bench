{
  "Title": "[M-01] No slippage protection for Market functions",
  "Content": "\n### Proof of Concept\n\nPrice for shares inside `Market` is calculated using bonding curve. Currently, `LinearBondingCurve` is supported. This bonging curve [increases each next shares with fixed amount](https://github.com/code-423n4/2023-11-canto/blob/main/1155tech-contracts/src/bonding_curve/LinearBondingCurve.sol#L21) and also [uses `10% / log2(shareIndex)` to calculate fee](https://github.com/code-423n4/2023-11-canto/blob/main/1155tech-contracts/src/bonding_curve/LinearBondingCurve.sol#L35) for the share.\n\nIn order to calculate price to [buy shares `getBuyPrice` is used](https://github.com/code-423n4/2023-11-canto/blob/main/1155tech-contracts/src/Market.sol#L152) and to calculate price to [`sell` shares `getSellPrice` is used](https://github.com/code-423n4/2023-11-canto/blob/main/1155tech-contracts/src/Market.sol#L175).\n\n<https://github.com/code-423n4/2023-11-canto/blob/main/1155tech-contracts/src/Market.sol#L132-L145>\n\n```solidity\n    function getBuyPrice(uint256 _id, uint256 _amount) public view returns (uint256 price, uint256 fee) {\n        // If id does not exist, this will return address(0), causing a revert in the next line\n        address bondingCurve = shareData[_id].bondingCurve;\n        (price, fee) = IBondingCurve(bondingCurve).getPriceAndFee(shareData[_id].tokenCount + 1, _amount);\n    }\n\n    function getSellPrice(uint256 _id, uint256 _amount) public view returns (uint256 price, uint256 fee) {\n        // If id does not exist, this will return address(0), causing a revert in the next line\n        address bondingCurve = shareData[_id].bondingCurve;\n        (price, fee) = IBondingCurve(bondingCurve).getPriceAndFee(shareData[_id].tokenCount - _amount + 1, _amount);\n    }\n```\n\nBoth functions use `IBondingCurve(bondingCurve).getPriceAndFee`, but `getBuyPrice` provides `current token index` as start index for curve, while `getSellPrice` provides `current token index - amount to sell` as start index for curve.\n\nIn the case when someone wants to buy shares, the price depends on current circulation supply. If this supply is increased right after a user's `buy` tx, then they will pay more for the shares. If someone sells shares right before the `buy` tx, then a user will pay a lesser amount (which is good of course).\n\nThe same we can say about `sell` function. If someone sells shares right before a user's `sell` execution, then the user receives a smaller amount. If someone buys shares, then the user gets a bigger amount.\n\nAs the price at the moment when user initiates `buy` or `sell` function can be changed before execution (with frontrunning or just innocent), this means that slippage protection should be introduced, so a user can be sure that they will not pay more than expected or receive less than expected.\n\nWhen a user expects to `buy` shares for 5 USD, then the attacker can sandwich a user's tx shares in order to make profit.\n\n- Attacker first frontruns and `buy`s shares that cost 5 USD.\n- Then, let a user's `buy` tx to be executed so a user buys shares more expensive (10 USD). \n- Then the attacker backruns with `sell` shares that cost now 10 USD and earn on this (5 USD).\n\nThe same thing can be done with `sell` sandwiching. When a user expects to `sell` their share for 20 USD:\n\n- Attacker can `sell` own share (and get 20 USD).\n- Then, let a user `sell` their share cheaper (and get 15 USD).\n- Then the attacker buys share cheaper (for 10 USD) and earn on this (10 USD).\n\nWhile `buy` sandwiching needs a user to give the full approval to `Market` as this price is then sent from user, `sell` sandwiching doesn't need that because it only sends tokens to the victim.\n\n### Impact\n\nUser can lose funds.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nMake a user provide slippage to `buy`, `sell`, `burnNFT` and `mintNFT` functions.\n\n### Assessed type\n\nError\n\n**[OpenCoreCH (Canto) confirmed](https://github.com/code-423n4/2023-11-canto-findings/issues/12#issuecomment-1827462251)**\n\n**[0xTheC0der (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-11-canto-findings/issues/12#issuecomment-1830907592):**\n > On the one hand, according to our [guidelines](https://docs.code4rena.com/roles/judges/how-to-judge-a-contest):\n> > Unless there is something uniquely novel created by combining vectors, most submissions regarding vulnerabilities that are inherent to a particular system or the Ethereum network as a whole **should be considered QA**. Examples of such vulnerabilities include front running, **sandwich attacks**, and MEV.\n> \n> But on the other hand, a slippage percentage parameter or expected amount has become state-of-the-art which also makes this a shortcoming of the protocol. \n> \n> Consequently, it seems appropriate to move forward with `Medium` severity.\n\n**[OpenCoreCH (Canto) commented](https://github.com/code-423n4/2023-11-canto-findings/issues/12#issuecomment-1833719090):**\n > Introduced params.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-11-canto",
  "Code": [
    {
      "filename": "1155tech-contracts/src/bonding_curve/LinearBondingCurve.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.19;\n\nimport {IBondingCurve} from \"../../interface/IBondingCurve.sol\";\n\ncontract LinearBondingCurve is IBondingCurve {\n    // By how much the price increases per share, provided in the token decimals\n    uint256 public immutable priceIncrease;\n\n    constructor(uint256 _priceIncrease) {\n        priceIncrease = _priceIncrease;\n    }\n\n    function getPriceAndFee(uint256 shareCount, uint256 amount)\n        external\n        view\n        override\n        returns (uint256 price, uint256 fee)\n    {\n        for (uint256 i = shareCount; i < shareCount + amount; i++) {\n            uint256 tokenPrice = priceIncrease * i;\n            price += tokenPrice;\n            fee += (getFee(i) * tokenPrice) / 1e18;\n        }\n    }\n\n    function getFee(uint256 shareCount) public pure override returns (uint256) {\n        uint256 divisor;\n        if (shareCount > 1) {\n            divisor = log2(shareCount);\n        } else {\n            divisor = 1;\n        }\n        // 0.1 / log2(shareCount)\n        return 1e17 / divisor;\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    /// @notice Copied from Solady: https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(\n                r,\n                byte(\n                    and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                    0x0706060506020504060203020504030106050205030304010505030400000000\n                )\n            )\n        }\n    }\n}"
    },
    {
      "filename": "1155tech-contracts/src/Market.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.19;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable, Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {IBondingCurve} from \"../interface/IBondingCurve.sol\";\nimport {Turnstile} from \"../interface/Turnstile.sol\";\n\ncontract Market is ERC1155, Ownable2Step {\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n    uint256 public constant NFT_FEE_BPS = 1_000; // 10%\n    uint256 public constant HOLDER_CUT_BPS = 3_300; // 33%\n    uint256 public constant CREATOR_CUT_BPS = 3_300; // 33%\n    // Platform cut: 100% - HOLDER_CUT_BPS - CREATOR_CUT_BPS\n\n    /// @notice Payment token\n    IERC20 public immutable token;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of shares created\n    uint256 public shareCount;\n\n    /// @notice Stores the share ID of a given share name\n    mapping(string => uint256) public shareIDs;\n\n    struct ShareData {\n        uint256 tokenCount; // Number of outstanding tokens\n        uint256 tokensInCirculation; // Number of outstanding tokens - tokens that are minted as NFT, i.e. the number of tokens that receive fees\n        uint256 shareHolderRewardsPerTokenScaled; // Accrued funds for the share holder per token, multiplied by 1e18 to avoid precision loss\n        uint256 shareCreatorPool; // Unclaimed funds for the share creators\n        address bondingCurve; // Bonding curve used for this share\n        address creator; // Creator of the share\n        string metadataURI; // URI of the metadata\n    }\n\n    /// @notice Stores the data for a given share ID\n    mapping(uint256 => ShareData) public shareData;\n\n    /// @notice Stores the bonding curve per share\n    mapping(uint256 => address) public shareBondingCurves;\n\n    /// @notice Bonding curves that can be used for shares\n    mapping(address => bool) public whitelistedBondingCurves;\n\n    /// @notice Stores the number of outstanding tokens per share and address\n    mapping(uint256 => mapping(address => uint256)) public tokensByAddress;\n\n    /// @notice Value of ShareData.shareHolderRewardsPerTokenScaled at the last time a user claimed their rewards\n    mapping(uint256 => mapping(address => uint256)) public rewardsLastClaimedValue;\n\n    /// @notice Unclaimed funds for the platform\n    uint256 public platformPool;\n\n    /// @notice If true, only the whitelisted addresses can create shares\n    bool public shareCreationRestricted = true;\n\n    /// @notice List of addresses that can add new shares when shareCreationRestricted is true\n    mapping(address => bool) public whitelistedShareCreators;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event BondingCurveStateChange(address indexed curve, bool isWhitelisted);\n    event ShareCreated(uint256 indexed id, string name, address indexed bondingCurve, address indexed creator);\n    event SharesBought(uint256 indexed id, address indexed buyer, uint256 amount, uint256 price, uint256 fee);\n    event SharesSold(uint256 indexed id, address indexed seller, uint256 amount, uint256 price, uint256 fee);\n    event NFTsCreated(uint256 indexed id, address indexed creator, uint256 amount, uint256 fee);\n    event NFTsBurned(uint256 indexed id, address indexed burner, uint256 amount, uint256 fee);\n    event PlatformFeeClaimed(address indexed claimer, uint256 amount);\n    event CreatorFeeClaimed(address indexed claimer, uint256 indexed id, uint256 amount);\n    event HolderFeeClaimed(address indexed claimer, uint256 indexed id, uint256 amount);\n    event ShareCreationRestricted(bool isRestricted);\n\n    modifier onlyShareCreator() {\n        require(\n            !shareCreationRestricted || whitelistedShareCreators[msg.sender] || msg.sender == owner(),\n            \"Not allowed\"\n        );\n        _;\n    }\n\n    /// @notice Initiates CSR on main- and testnet\n    /// @param _uri ERC1155 Base URI\n    /// @param _paymentToken Address of the payment token\n    constructor(string memory _uri, address _paymentToken) ERC1155(_uri) Ownable() {\n        token = IERC20(_paymentToken);\n        if (block.chainid == 7700 || block.chainid == 7701) {\n            // Register CSR on Canto main- and testnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Whitelist or remove whitelist for a bonding curve.\n    /// @dev Whitelisting status is only checked when adding a share\n    /// @param _bondingCurve Address of the bonding curve\n    /// @param _newState True if whitelisted, false if not\n    function changeBondingCurveAllowed(address _bondingCurve, bool _newState) external onlyOwner {\n        require(whitelistedBondingCurves[_bondingCurve] != _newState, \"State already set\");\n        whitelistedBondingCurves[_bondingCurve] = _newState;\n        emit BondingCurveStateChange(_bondingCurve, _newState);\n    }\n\n    /// @notice Creates a new share\n    /// @param _shareName Name of the share\n    /// @param _bondingCurve Address of the bonding curve, has to be whitelisted\n    /// @param _metadataURI URI of the metadata\n    function createNewShare(\n        string memory _shareName,\n        address _bondingCurve,\n        string memory _metadataURI\n    ) external onlyShareCreator returns (uint256 id) {\n        require(whitelistedBondingCurves[_bondingCurve], \"Bonding curve not whitelisted\");\n        require(shareIDs[_shareName] == 0, \"Share already exists\");\n        id = ++shareCount;\n        shareIDs[_shareName] = id;\n        shareData[id].bondingCurve = _bondingCurve;\n        shareData[id].creator = msg.sender;\n        shareData[id].metadataURI = _metadataURI;\n        emit ShareCreated(id, _shareName, _bondingCurve, msg.sender);\n    }\n\n    /// @notice Returns the price and fee for buying a given number of shares.\n    /// @param _id The ID of the share\n    /// @param _amount The number of shares to buy.\n    function getBuyPrice(uint256 _id, uint256 _amount) public view returns (uint256 price, uint256 fee) {\n        // If id does not exist, this will return address(0), causing a revert in the next line\n        address bondingCurve = shareData[_id].bondingCurve;\n        (price, fee) = IBondingCurve(bondingCurve).getPriceAndFee(shareData[_id].tokenCount + 1, _amount);\n    }\n\n    /// @notice Returns the price and fee for selling a given number of shares.\n    /// @param _id The ID of the share\n    /// @param _amount The number of shares to sell.\n    function getSellPrice(uint256 _id, uint256 _amount) public view returns (uint256 price, uint256 fee) {\n        // If id does not exist, this will return address(0), causing a revert in the next line\n        address bondingCurve = shareData[_id].bondingCurve;\n        (price, fee) = IBondingCurve(bondingCurve).getPriceAndFee(shareData[_id].tokenCount - _amount + 1, _amount);\n    }\n\n    /// @notice Buy amount of tokens for a given share ID\n    /// @param _id ID of the share\n    /// @param _amount Amount of shares to buy\n    function buy(uint256 _id, uint256 _amount) external {\n        require(shareData[_id].creator != msg.sender, \"Creator cannot buy\");\n        (uint256 price, uint256 fee) = getBuyPrice(_id, _amount); // Reverts for non-existing ID\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), price + fee);\n        // The reward calculation has to use the old rewards value (pre fee-split) to not include the fees of this buy\n        // The rewardsLastClaimedValue then needs to be updated with the new value such that the user cannot claim fees of this buy\n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        // Split the fee among holder, creator and platform\n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n\n        shareData[_id].tokenCount += _amount;\n        shareData[_id].tokensInCirculation += _amount;\n        tokensByAddress[_id][msg.sender] += _amount;\n\n        if (rewardsSinceLastClaim > 0) {\n            SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim);\n        }\n        emit SharesBought(_id, msg.sender, _amount, price, fee);\n    }\n\n    /// @notice Sell amount of tokens for a given share ID\n    /// @param _id ID of the share\n    /// @param _amount Amount of shares to sell\n    function sell(uint256 _id, uint256 _amount) external {\n        (uint256 price, uint256 fee) = getSellPrice(_id, _amount);\n        // Split the fee among holder, creator and platform\n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n        // The user also gets the rewards of his own sale (which is not the case for buys)\n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n\n        shareData[_id].tokenCount -= _amount;\n        shareData[_id].tokensInCirculation -= _amount;\n        tokensByAddress[_id][msg.sender] -= _amount; // Would underflow if user did not have enough tokens\n\n        // Send the funds to the user\n        SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim + price - fee);\n        emit SharesSold(_id, msg.sender, _amount, price, fee);\n    }\n\n    /// @notice Returns the price and fee for minting a given number of NFTs.\n    /// @param _id The ID of the share\n    /// @param _amount The number of NFTs to mint.\n    function getNFTMintingPrice(uint256 _id, uint256 _amount) public view returns (uint256 fee) {\n        address bondingCurve = shareData[_id].bondingCurve;\n        (uint256 priceForOne, ) = IBondingCurve(bondingCurve).getPriceAndFee(shareData[_id].tokenCount, 1);\n        fee = (priceForOne * _amount * NFT_FEE_BPS) / 10_000;\n    }\n\n    /// @notice Convert amount of tokens to NFTs for a given share ID\n    /// @param _id ID of the share\n    /// @param _amount Amount of tokens to convert. User needs to have this many tokens.\n    function mintNFT(uint256 _id, uint256 _amount) external {\n        uint256 fee = getNFTMintingPrice(_id, _amount);\n\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), fee);\n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n        // The user also gets the proportional rewards for the minting\n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n        tokensByAddress[_id][msg.sender] -= _amount;\n        shareData[_id].tokensInCirculation -= _amount;\n\n        _mint(msg.sender, _id, _amount, \"\");\n\n        if (rewardsSinceLastClaim > 0) {\n            SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim);\n        }\n        // ERC1155 already logs, but we add this to have the price information\n        emit NFTsCreated(_id, msg.sender, _amount, fee);\n    }\n\n    /// @notice Burn amount of NFTs for a given share ID to get back tokens\n    /// @param _id ID of the share\n    /// @param _amount Amount of NFTs to burn\n    function burnNFT(uint256 _id, uint256 _amount) external {\n        uint256 fee = getNFTMintingPrice(_id, _amount);\n\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), fee);\n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n        // The user does not get the proportional rewards for the burning (unless they have additional tokens that are not in the NFT)\n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n        tokensByAddress[_id][msg.sender] += _amount;\n        shareData[_id].tokensInCirculation += _amount;\n        _burn(msg.sender, _id, _amount);\n\n        SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim);\n        // ERC1155 already logs, but we add this to have the price information\n        emit NFTsBurned(_id, msg.sender, _amount, fee);\n    }\n\n    /// @notice Withdraws the accrued platform fee\n    function claimPlatformFee() external onlyOwner {\n        uint256 amount = platformPool;\n        platformPool = 0;\n        SafeERC20.safeTransfer(token, msg.sender, amount);\n        emit PlatformFeeClaimed(msg.sender, amount);\n    }\n\n    /// @notice Withdraws the accrued share creator fee\n    /// @param _id ID of the share\n    function claimCreatorFee(uint256 _id) external {\n        require(shareData[_id].creator == msg.sender, \"Not creator\");\n        uint256 amount = shareData[_id].shareCreatorPool;\n        shareData[_id].shareCreatorPool = 0;\n        SafeERC20.safeTransfer(token, msg.sender, amount);\n        emit CreatorFeeClaimed(msg.sender, _id, amount);\n    }\n\n    /// @notice Withdraws the accrued share holder fee\n    /// @param _id ID of the share\n    function claimHolderFee(uint256 _id) external {\n        uint256 amount = _getRewardsSinceLastClaim(_id);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n        if (amount > 0) {\n            SafeERC20.safeTransfer(token, msg.sender, amount);\n        }\n        emit HolderFeeClaimed(msg.sender, _id, amount);\n    }\n\n    function _getRewardsSinceLastClaim(uint256 _id) internal view returns (uint256 amount) {\n        uint256 lastClaimedValue = rewardsLastClaimedValue[_id][msg.sender];\n        amount =\n            ((shareData[_id].shareHolderRewardsPerTokenScaled - lastClaimedValue) * tokensByAddress[_id][msg.sender]) /\n            1e18;\n    }\n\n    /// @notice Splits the fee among the share holder, creator and platform\n    function _splitFees(\n        uint256 _id,\n        uint256 _fee,\n        uint256 _tokenCount\n    ) internal {\n        uint256 shareHolderFee = (_fee * HOLDER_CUT_BPS) / 10_000;\n        uint256 shareCreatorFee = (_fee * CREATOR_CUT_BPS) / 10_000;\n        uint256 platformFee = _fee - shareHolderFee - shareCreatorFee;\n        shareData[_id].shareCreatorPool += shareCreatorFee;\n        if (_tokenCount > 0) {\n            shareData[_id].shareHolderRewardsPerTokenScaled += (shareHolderFee * 1e18) / _tokenCount;\n        } else {\n            // If there are no tokens in circulation, the fee goes to the platform\n            platformFee += shareHolderFee;\n        }\n        platformPool += platformFee;\n    }\n\n    /// @notice Restricts or unrestricts share creation\n    /// @param _isRestricted True if restricted, false if not\n    function restrictShareCreation(bool _isRestricted) external onlyOwner {\n        require(shareCreationRestricted != _isRestricted, \"State already set\");\n        shareCreationRestricted = _isRestricted;\n        emit ShareCreationRestricted(_isRestricted);\n    }\n\n    /// @notice Adds or removes an address from the whitelist of share creators\n    /// @param _address Address to add or remove\n    /// @param _isWhitelisted True if whitelisted, false if not\n    function changeShareCreatorWhitelist(address _address, bool _isWhitelisted) external onlyOwner {\n        require(whitelistedShareCreators[_address] != _isWhitelisted, \"State already set\");\n        whitelistedShareCreators[_address] = _isWhitelisted;\n    }\n}"
    },
    {
      "filename": "1155tech-contracts/src/Market.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.19;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable, Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {IBondingCurve} from \"../interface/IBondingCurve.sol\";\nimport {Turnstile} from \"../interface/Turnstile.sol\";\n\ncontract Market is ERC1155, Ownable2Step {\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n    uint256 public constant NFT_FEE_BPS = 1_000; // 10%\n    uint256 public constant HOLDER_CUT_BPS = 3_300; // 33%\n    uint256 public constant CREATOR_CUT_BPS = 3_300; // 33%\n    // Platform cut: 100% - HOLDER_CUT_BPS - CREATOR_CUT_BPS\n\n    /// @notice Payment token\n    IERC20 public immutable token;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of shares created\n    uint256 public shareCount;\n\n    /// @notice Stores the share ID of a given share name\n    mapping(string => uint256) public shareIDs;\n\n    struct ShareData {\n        uint256 tokenCount; // Number of outstanding tokens\n        uint256 tokensInCirculation; // Number of outstanding tokens - tokens that are minted as NFT, i.e. the number of tokens that receive fees\n        uint256 shareHolderRewardsPerTokenScaled; // Accrued funds for the share holder per token, multiplied by 1e18 to avoid precision loss\n        uint256 shareCreatorPool; // Unclaimed funds for the share creators\n        address bondingCurve; // Bonding curve used for this share\n        address creator; // Creator of the share\n        string metadataURI; // URI of the metadata\n    }\n\n    /// @notice Stores the data for a given share ID\n    mapping(uint256 => ShareData) public shareData;\n\n    /// @notice Stores the bonding curve per share\n    mapping(uint256 => address) public shareBondingCurves;\n\n    /// @notice Bonding curves that can be used for shares\n    mapping(address => bool) public whitelistedBondingCurves;\n\n    /// @notice Stores the number of outstanding tokens per share and address\n    mapping(uint256 => mapping(address => uint256)) public tokensByAddress;\n\n    /// @notice Value of ShareData.shareHolderRewardsPerTokenScaled at the last time a user claimed their rewards\n    mapping(uint256 => mapping(address => uint256)) public rewardsLastClaimedValue;\n\n    /// @notice Unclaimed funds for the platform\n    uint256 public platformPool;\n\n    /// @notice If true, only the whitelisted addresses can create shares\n    bool public shareCreationRestricted = true;\n\n    /// @notice List of addresses that can add new shares when shareCreationRestricted is true\n    mapping(address => bool) public whitelistedShareCreators;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event BondingCurveStateChange(address indexed curve, bool isWhitelisted);\n    event ShareCreated(uint256 indexed id, string name, address indexed bondingCurve, address indexed creator);\n    event SharesBought(uint256 indexed id, address indexed buyer, uint256 amount, uint256 price, uint256 fee);\n    event SharesSold(uint256 indexed id, address indexed seller, uint256 amount, uint256 price, uint256 fee);\n    event NFTsCreated(uint256 indexed id, address indexed creator, uint256 amount, uint256 fee);\n    event NFTsBurned(uint256 indexed id, address indexed burner, uint256 amount, uint256 fee);\n    event PlatformFeeClaimed(address indexed claimer, uint256 amount);\n    event CreatorFeeClaimed(address indexed claimer, uint256 indexed id, uint256 amount);\n    event HolderFeeClaimed(address indexed claimer, uint256 indexed id, uint256 amount);\n    event ShareCreationRestricted(bool isRestricted);\n\n    modifier onlyShareCreator() {\n        require(\n            !shareCreationRestricted || whitelistedShareCreators[msg.sender] || msg.sender == owner(),\n            \"Not allowed\"\n        );\n        _;\n    }\n\n    /// @notice Initiates CSR on main- and testnet\n    /// @param _uri ERC1155 Base URI\n    /// @param _paymentToken Address of the payment token\n    constructor(string memory _uri, address _paymentToken) ERC1155(_uri) Ownable() {\n        token = IERC20(_paymentToken);\n        if (block.chainid == 7700 || block.chainid == 7701) {\n            // Register CSR on Canto main- and testnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Whitelist or remove whitelist for a bonding curve.\n    /// @dev Whitelisting status is only checked when adding a share\n    /// @param _bondingCurve Address of the bonding curve\n    /// @param _newState True if whitelisted, false if not\n    function changeBondingCurveAllowed(address _bondingCurve, bool _newState) external onlyOwner {\n        require(whitelistedBondingCurves[_bondingCurve] != _newState, \"State already set\");\n        whitelistedBondingCurves[_bondingCurve] = _newState;\n        emit BondingCurveStateChange(_bondingCurve, _newState);\n    }\n\n    /// @notice Creates a new share\n    /// @param _shareName Name of the share\n    /// @param _bondingCurve Address of the bonding curve, has to be whitelisted\n    /// @param _metadataURI URI of the metadata\n    function createNewShare(\n        string memory _shareName,\n        address _bondingCurve,\n        string memory _metadataURI\n    ) external onlyShareCreator returns (uint256 id) {\n        require(whitelistedBondingCurves[_bondingCurve], \"Bonding curve not whitelisted\");\n        require(shareIDs[_shareName] == 0, \"Share already exists\");\n        id = ++shareCount;\n        shareIDs[_shareName] = id;\n        shareData[id].bondingCurve = _bondingCurve;\n        shareData[id].creator = msg.sender;\n        shareData[id].metadataURI = _metadataURI;\n        emit ShareCreated(id, _shareName, _bondingCurve, msg.sender);\n    }\n\n    /// @notice Returns the price and fee for buying a given number of shares.\n    /// @param _id The ID of the share\n    /// @param _amount The number of shares to buy.\n    function getBuyPrice(uint256 _id, uint256 _amount) public view returns (uint256 price, uint256 fee) {\n        // If id does not exist, this will return address(0), causing a revert in the next line\n        address bondingCurve = shareData[_id].bondingCurve;\n        (price, fee) = IBondingCurve(bondingCurve).getPriceAndFee(shareData[_id].tokenCount + 1, _amount);\n    }\n\n    /// @notice Returns the price and fee for selling a given number of shares.\n    /// @param _id The ID of the share\n    /// @param _amount The number of shares to sell.\n    function getSellPrice(uint256 _id, uint256 _amount) public view returns (uint256 price, uint256 fee) {\n        // If id does not exist, this will return address(0), causing a revert in the next line\n        address bondingCurve = shareData[_id].bondingCurve;\n        (price, fee) = IBondingCurve(bondingCurve).getPriceAndFee(shareData[_id].tokenCount - _amount + 1, _amount);\n    }\n\n    /// @notice Buy amount of tokens for a given share ID\n    /// @param _id ID of the share\n    /// @param _amount Amount of shares to buy\n    function buy(uint256 _id, uint256 _amount) external {\n        require(shareData[_id].creator != msg.sender, \"Creator cannot buy\");\n        (uint256 price, uint256 fee) = getBuyPrice(_id, _amount); // Reverts for non-existing ID\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), price + fee);\n        // The reward calculation has to use the old rewards value (pre fee-split) to not include the fees of this buy\n        // The rewardsLastClaimedValue then needs to be updated with the new value such that the user cannot claim fees of this buy\n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        // Split the fee among holder, creator and platform\n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n\n        shareData[_id].tokenCount += _amount;\n        shareData[_id].tokensInCirculation += _amount;\n        tokensByAddress[_id][msg.sender] += _amount;\n\n        if (rewardsSinceLastClaim > 0) {\n            SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim);\n        }\n        emit SharesBought(_id, msg.sender, _amount, price, fee);\n    }\n\n    /// @notice Sell amount of tokens for a given share ID\n    /// @param _id ID of the share\n    /// @param _amount Amount of shares to sell\n    function sell(uint256 _id, uint256 _amount) external {\n        (uint256 price, uint256 fee) = getSellPrice(_id, _amount);\n        // Split the fee among holder, creator and platform\n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n        // The user also gets the rewards of his own sale (which is not the case for buys)\n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n\n        shareData[_id].tokenCount -= _amount;\n        shareData[_id].tokensInCirculation -= _amount;\n        tokensByAddress[_id][msg.sender] -= _amount; // Would underflow if user did not have enough tokens\n\n        // Send the funds to the user\n        SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim + price - fee);\n        emit SharesSold(_id, msg.sender, _amount, price, fee);\n    }\n\n    /// @notice Returns the price and fee for minting a given number of NFTs.\n    /// @param _id The ID of the share\n    /// @param _amount The number of NFTs to mint.\n    function getNFTMintingPrice(uint256 _id, uint256 _amount) public view returns (uint256 fee) {\n        address bondingCurve = shareData[_id].bondingCurve;\n        (uint256 priceForOne, ) = IBondingCurve(bondingCurve).getPriceAndFee(shareData[_id].tokenCount, 1);\n        fee = (priceForOne * _amount * NFT_FEE_BPS) / 10_000;\n    }\n\n    /// @notice Convert amount of tokens to NFTs for a given share ID\n    /// @param _id ID of the share\n    /// @param _amount Amount of tokens to convert. User needs to have this many tokens.\n    function mintNFT(uint256 _id, uint256 _amount) external {\n        uint256 fee = getNFTMintingPrice(_id, _amount);\n\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), fee);\n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n        // The user also gets the proportional rewards for the minting\n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n        tokensByAddress[_id][msg.sender] -= _amount;\n        shareData[_id].tokensInCirculation -= _amount;\n\n        _mint(msg.sender, _id, _amount, \"\");\n\n        if (rewardsSinceLastClaim > 0) {\n            SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim);\n        }\n        // ERC1155 already logs, but we add this to have the price information\n        emit NFTsCreated(_id, msg.sender, _amount, fee);\n    }\n\n    /// @notice Burn amount of NFTs for a given share ID to get back tokens\n    /// @param _id ID of the share\n    /// @param _amount Amount of NFTs to burn\n    function burnNFT(uint256 _id, uint256 _amount) external {\n        uint256 fee = getNFTMintingPrice(_id, _amount);\n\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), fee);\n        _splitFees(_id, fee, shareData[_id].tokensInCirculation);\n        // The user does not get the proportional rewards for the burning (unless they have additional tokens that are not in the NFT)\n        uint256 rewardsSinceLastClaim = _getRewardsSinceLastClaim(_id);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n        tokensByAddress[_id][msg.sender] += _amount;\n        shareData[_id].tokensInCirculation += _amount;\n        _burn(msg.sender, _id, _amount);\n\n        SafeERC20.safeTransfer(token, msg.sender, rewardsSinceLastClaim);\n        // ERC1155 already logs, but we add this to have the price information\n        emit NFTsBurned(_id, msg.sender, _amount, fee);\n    }\n\n    /// @notice Withdraws the accrued platform fee\n    function claimPlatformFee() external onlyOwner {\n        uint256 amount = platformPool;\n        platformPool = 0;\n        SafeERC20.safeTransfer(token, msg.sender, amount);\n        emit PlatformFeeClaimed(msg.sender, amount);\n    }\n\n    /// @notice Withdraws the accrued share creator fee\n    /// @param _id ID of the share\n    function claimCreatorFee(uint256 _id) external {\n        require(shareData[_id].creator == msg.sender, \"Not creator\");\n        uint256 amount = shareData[_id].shareCreatorPool;\n        shareData[_id].shareCreatorPool = 0;\n        SafeERC20.safeTransfer(token, msg.sender, amount);\n        emit CreatorFeeClaimed(msg.sender, _id, amount);\n    }\n\n    /// @notice Withdraws the accrued share holder fee\n    /// @param _id ID of the share\n    function claimHolderFee(uint256 _id) external {\n        uint256 amount = _getRewardsSinceLastClaim(_id);\n        rewardsLastClaimedValue[_id][msg.sender] = shareData[_id].shareHolderRewardsPerTokenScaled;\n        if (amount > 0) {\n            SafeERC20.safeTransfer(token, msg.sender, amount);\n        }\n        emit HolderFeeClaimed(msg.sender, _id, amount);\n    }\n\n    function _getRewardsSinceLastClaim(uint256 _id) internal view returns (uint256 amount) {\n        uint256 lastClaimedValue = rewardsLastClaimedValue[_id][msg.sender];\n        amount =\n            ((shareData[_id].shareHolderRewardsPerTokenScaled - lastClaimedValue) * tokensByAddress[_id][msg.sender]) /\n            1e18;\n    }\n\n    /// @notice Splits the fee among the share holder, creator and platform\n    function _splitFees(\n        uint256 _id,\n        uint256 _fee,\n        uint256 _tokenCount\n    ) internal {\n        uint256 shareHolderFee = (_fee * HOLDER_CUT_BPS) / 10_000;\n        uint256 shareCreatorFee = (_fee * CREATOR_CUT_BPS) / 10_000;\n        uint256 platformFee = _fee - shareHolderFee - shareCreatorFee;\n        shareData[_id].shareCreatorPool += shareCreatorFee;\n        if (_tokenCount > 0) {\n            shareData[_id].shareHolderRewardsPerTokenScaled += (shareHolderFee * 1e18) / _tokenCount;\n        } else {\n            // If there are no tokens in circulation, the fee goes to the platform\n            platformFee += shareHolderFee;\n        }\n        platformPool += platformFee;\n    }\n\n    /// @notice Restricts or unrestricts share creation\n    /// @param _isRestricted"
    }
  ]
}