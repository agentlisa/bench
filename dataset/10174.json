{
  "Title": "[H-01] implicit underflows",
  "Content": "_Submitted by gpersoon, also found by cmichel_\n\nThere are a few underflows that are converted via a typecast afterwards to the expected value. If solidity 0.8.x would be used, then the code would revert.\n* `int256(a-b)` where a and b are uint: For example, if `a=1` and `b=2`, then the intermediate result would be `uint(-1) == 2**256-1`\n* `int256(-x)` where x is a uint. For example, if `x=1`, then the intermediate result would be `uint(-1) == 2**256-1`\n\nIt's better not to have underflows by using the appropriate typecasts. This is especially relevant when moving to solidity 0.8.x.\n\nFrom `Exposure.sol` [L178](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/insurance/Exposure.sol#L178):\n```solidity\nfunction sortVaultsByDelta(..)\n..\n    for (uint256 i = 0; i < N_COINS; i++) {\n        // Get difference between vault current assets and vault target\n        int256 delta = int256(unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)); // underflow in intermediate result\n```\n\nFrom `PnL.sol` [L112](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pnl/PnL.sol#L112):\n```solidity\n function decreaseGTokenLastAmount(bool pwrd, uint256 dollarAmount, uint256 bonus)...\n..\n emit LogNewGtokenChange(pwrd, int256(-dollarAmount)); // underflow in intermediate result\n```\n\nFrom `Buoy3Pool.sol` [L87](https://github.com/code-423n4/2021-06-gro/blob/main/contracts/pools/oracle/Buoy3Pool.sol#L87):\n```solidity\nfunction safetyCheck() external view override returns (bool) {\n    ...\n        _ratio = abs(int256(_ratio - lastRatio[i])); // underflow in intermediate result\n```\n\nRecommend replacing `int256(a-b)` with `int256(a)-int256(b)`, and replacing `int256(-x)` with `-int256(x)`\n\n**[kristian-gro (Gro) confirmed but disagreed with severity](https://github.com/code-423n4/2021-06-gro-findings/issues/6#issuecomment-886260551):**\n> Confirmed and We've mitigated this issue in our release version.\n\n**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-06-gro-findings/issues/6#issuecomment-886260551):**\n > Majority of overflow listed above seems low risk with one exception of `safetyCheck`. Underflow is a real risk here.`safetyCheck` is run every time a deposit is made. Ratios can change and the change does not need to be substantial for it to overflow. For that reason it's a high risk.\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2021-07-gro-protocol-contest",
  "Code": [
    {
      "filename": "contracts/insurance/Exposure.sol",
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../common/StructDefinitions.sol\";\nimport \"../common/Constants.sol\";\nimport \"../common/Controllable.sol\";\nimport \"../common/Whitelist.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\nimport \"../interfaces/ILifeGuard.sol\";\nimport \"../interfaces/IExposure.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IBuoy.sol\";\n\n/// @notice Contract for calculating current protocol exposures on a stablecoin and\n///     protocol level. This contract can be upgraded if the systems underlying protocols\n///     or tokens have changed. Protocol exposure are calculated at a high level, as any\n///     additional exposures from underlying protocol exposures should at most be equal to\n///     the high level exposure.\n///     For example: harvest finance stablecoin vaults (fTokens)\n///         - High level exposure\n///             - Harvest finance\n///         - Low level exposures (from fToken investments):\n///             - Compound\n///             - Idle finance\n///     Neither of these two low level exposures should matter as long as there arent\n///     additional exposure to these protocol elsewhere. So by desing, the protocols\n///     are given indexes based on the strategies in the stablecoin vaults, which need\n///     to be symetrical for this to work - e.g. all vaults needs to have the same exposure\n///     profile, and non of these exposure profiles can overlap. In the case where the\n///     additional exposure needs to be taken into account (maker has USDC collateral,\n///     Curve adds exposure to all stablecoins in a liquidity pool), they will be calculated\n///     and added ontop of the base exposure from vaults and strategies.\n///\n///     --------------------------------------------------------\n///     Current protocol setup:\n///     --------------------------------------------------------\n///     Stablecoins: DAI, USDC, USDT\n///     LP tokens: 3Crv\n///     Vaults: DAIVault, USDCVault, USDTVault, 3Crv vault\n///     Strategy (exposures):\n///         - Compound\n///         - Idle finance\n///         - Yearn Generic Lender:\n///             - Cream\n///         - CurveXpool:\n///             - Curve3Pool\n///             - CurveMetaPool\n///             - Yearn\ncontract Exposure is Constants, Controllable, Whitelist, IExposure {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public protocolCount;\n    uint256 public makerUSDCExposure;\n\n    event LogNewProtocolCount(uint256 count);\n    event LogNewMakerExposure(uint256 exposure);\n\n    /// @notice Add protocol for the exposure calculations\n    /// @dev Currently set to:\n    ///     1 - Harvest finance\n    ///     2 - Cream\n    ///     Curve exposure is calculated separately as it has wider system impact\n    function setProtocolCount(uint256 _protocolCount) external onlyOwner {\n        protocolCount = _protocolCount;\n        emit LogNewProtocolCount(_protocolCount);\n    }\n\n    /// @notice Specify additional USDC exposure to Maker\n    /// @param _makerUSDCExposure Exposure amount to Maker\n    function setMakerUSDCExposure(uint256 _makerUSDCExposure) external onlyOwner {\n        makerUSDCExposure = _makerUSDCExposure;\n        emit LogNewMakerExposure(_makerUSDCExposure);\n    }\n\n    function getExactRiskExposure(SystemState calldata sysState)\n        external\n        view\n        override\n        returns (ExposureState memory expState)\n    {\n        expState = _calcRiskExposure(sysState, false);\n        ILifeGuard lifeguard = ILifeGuard(_controller().lifeGuard());\n        IBuoy buoy = IBuoy(_controller().buoy());\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 assets = lifeguard.assets(i);\n            uint256 assetsUsd = buoy.singleStableToUsd(assets, i);\n            expState.stablecoinExposure[i] = expState.stablecoinExposure[i].add(\n                assetsUsd.mul(PERCENTAGE_DECIMAL_FACTOR).div(sysState.totalCurrentAssetsUsd)\n            );\n        }\n    }\n\n    /// @notice Calculate stablecoin and protocol level risk exposure\n    /// @param sysState Struct holding info about systems current state\n    /// @dev This loops through all the vaults, checks the amount of assets in them\n    ///     and their underlying strategies to understand stablecoin exposure\n    ///     - Any assets invested in Curve or similar AMM will have additional stablecoin exposure.\n    ///     The protocol exposure is calculated by assessing the amount of assets each\n    ///     vault has invested in a strategy.\n    function calcRiskExposure(SystemState calldata sysState)\n        external\n        view\n        override\n        returns (ExposureState memory expState)\n    {\n        expState = _calcRiskExposure(sysState, true);\n\n        // Establish if any stablecoin/protocol is over exposed\n        (expState.stablecoinExposed, expState.protocolExposed) = isExposed(\n            sysState.rebalanceThreshold,\n            expState.stablecoinExposure,\n            expState.protocolExposure,\n            expState.curveExposure\n        );\n    }\n\n    /// @notice Do a rough USD dollar calculation by treating every stablecoin as\n    ///     worth 1 USD and set all Decimals to 18\n    function getUnifiedAssets(address[N_COINS] calldata vaults)\n        public\n        view\n        override\n        returns (uint256 unifiedTotalAssets, uint256[N_COINS] memory unifiedAssets)\n    {\n        // unify all assets to 18 decimals, treat each stablecoin as being worth 1 USD\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 assets = IVault(vaults[i]).totalAssets();\n            unifiedAssets[i] = assets.mul(DEFAULT_DECIMALS_FACTOR).div(\n                uint256(10)**IERC20Detailed(IVault(vaults[i]).token()).decimals()\n            );\n            unifiedTotalAssets = unifiedTotalAssets.add(unifiedAssets[i]);\n        }\n    }\n\n    /// @notice Rough delta calculation - assumes each stablecoin is priced at 1 USD,\n    ///     and looks at differences between current allocations and target allocations\n    /// @param targets Stable coin allocation targest\n    /// @param vaults Stablecoin vaults\n    /// @param withdrawUsd USD value of withdrawals\n    function calcRoughDelta(\n        uint256[N_COINS] calldata targets,\n        address[N_COINS] calldata vaults,\n        uint256 withdrawUsd\n    ) external view override returns (uint256[N_COINS] memory delta) {\n        (uint256 totalAssets, uint256[N_COINS] memory vaultTotalAssets) = getUnifiedAssets(vaults);\n\n        require(totalAssets > withdrawUsd, \"totalAssets < withdrawalUsd\");\n        totalAssets = totalAssets.sub(withdrawUsd);\n        uint256 totalDelta;\n        for (uint256 i; i < N_COINS; i++) {\n            uint256 target = totalAssets.mul(targets[i]).div(PERCENTAGE_DECIMAL_FACTOR);\n            if (vaultTotalAssets[i] > target) {\n                delta[i] = vaultTotalAssets[i].sub(target);\n                totalDelta = totalDelta.add(delta[i]);\n            }\n        }\n        uint256 percent = PERCENTAGE_DECIMAL_FACTOR;\n        for (uint256 i; i < N_COINS - 1; i++) {\n            if (delta[i] > 0) {\n                delta[i] = delta[i].mul(PERCENTAGE_DECIMAL_FACTOR).div(totalDelta);\n                percent = percent.sub(delta[i]);\n            }\n        }\n        delta[N_COINS - 1] = percent;\n        return delta;\n    }\n\n    /// @notice Sort vaults by the delta of target asset - current asset,\n    ///     only support 3 vaults now\n    /// @param bigFirst Return array order most exposed -> least exposed\n    /// @param unifiedTotalAssets Estimated system USD assets\n    /// @param unifiedAssets Estimated vault USD assets\n    /// @param targetPercents Vault target percent array\n    function sortVaultsByDelta(\n        bool bigFirst,\n        uint256 unifiedTotalAssets,\n        uint256[N_COINS] calldata unifiedAssets,\n        uint256[N_COINS] calldata targetPercents\n    ) external pure override returns (uint256[N_COINS] memory vaultIndexes) {\n        uint256 maxIndex;\n        uint256 minIndex;\n        int256 maxDelta;\n        int256 minDelta;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            // Get difference between vault current assets and vault target\n            int256 delta = int256(\n                unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)\n            );\n            // Establish order\n            if (delta > maxDelta) {\n                maxDelta = delta;\n                maxIndex = i;\n            } else if (delta < minDelta) {\n                minDelta = delta;\n                minIndex = i;\n            }\n        }\n        if (bigFirst) {\n            vaultIndexes[0] = maxIndex;\n            vaultIndexes[2] = minIndex;\n        } else {\n            vaultIndexes[0] = minIndex;\n            vaultIndexes[2] = maxIndex;\n        }\n        vaultIndexes[1] = N_COINS - maxIndex - minIndex;\n    }\n\n    /// @notice Calculate what percentage of system total assets the assets in a strategy make up\n    /// @param vault Address of target vault that holds the strategy\n    /// @param index Index of strategy\n    /// @param vaultAssetsPercent Percentage of system assets\n    /// @param vaultAssets Total assets in vaults\n    function calculatePercentOfSystem(\n        address vault,\n        uint256 index,\n        uint256 vaultAssetsPercent,\n        uint256 vaultAssets\n    ) private view returns (uint256 percentOfSystem) {\n        if (vaultAssets == 0) return 0;\n        uint256 strategyAssetsPercent = IVault(vault).getStrategyAssets(index).mul(PERCENTAGE_DECIMAL_FACTOR).div(\n            vaultAssets\n        );\n\n        percentOfSystem = vaultAssetsPercent.mul(strategyAssetsPercent).div(PERCENTAGE_DECIMAL_FACTOR);\n    }\n\n    /// @notice Calculate the net stablecoin exposure\n    /// @param directlyExposure Amount of stablecoin in vault+strategies\n    /// @param curveExposure Percent of assets in Curve\n    function calculateStableCoinExposure(uint256[N_COINS] memory directlyExposure, uint256 curveExposure)\n        private\n        view\n        returns (uint256[N_COINS] memory stableCoinExposure)\n    {\n        uint256 maker = directlyExposure[0].mul(makerUSDCExposure).div(PERCENTAGE_DECIMAL_FACTOR);\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 indirectExposure = curveExposure;\n            if (i == 1) {\n                indirectExposure = indirectExposure.add(maker);\n            }\n            stableCoinExposure[i] = directlyExposure[i].add(indirectExposure);\n        }\n    }\n\n    /// @notice Determine if an assets or protocol is overexposed\n    /// @param rebalanceThreshold Threshold for triggering a rebalance due to overexposure\n    /// @param stableCoinExposure Current stable coin exposures\n    /// @param protocolExposure Current prtocol exposures\n    /// @param curveExposure Current Curve exposure\n    function isExposed(\n        uint256 rebalanceThreshold,\n        uint256[N_COINS] memory stableCoinExposure,\n        uint256[] memory protocolExposure,\n        uint256 curveExposure\n    ) private pure returns (bool stablecoinExposed, bool protocolExposed) {\n        for (uint256 i = 0; i < N_COINS; i++) {\n            if (stableCoinExposure[i] > rebalanceThreshold) {\n                stablecoinExposed = true;\n                break;\n            }\n        }\n        for (uint256 i = 0; i < protocolExposure.length; i++) {\n            if (protocolExposure[i] > rebalanceThreshold) {\n                protocolExposed = true;\n                break;\n            }\n        }\n        if (!protocolExposed && curveExposure > rebalanceThreshold) protocolExposed = true;\n        return (stablecoinExposed, protocolExposed);\n    }\n\n    function _calcRiskExposure(SystemState memory sysState, bool treatLifeguardAsCurve)\n        private\n        view\n        returns (ExposureState memory expState)\n    {\n        address[N_COINS] memory vaults = _controller().vaults();\n        uint256 pCount = protocolCount;\n        expState.protocolExposure = new uint256[](pCount);\n        if (sysState.totalCurrentAssetsUsd == 0) {\n            return expState;\n        }\n        // Stablecoin exposure\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 vaultAssetsPercent = sysState.vaultCurrentAssetsUsd[i].mul(PERCENTAGE_DECIMAL_FACTOR).div(\n                sysState.totalCurrentAssetsUsd\n            );\n            expState.stablecoinExposure[i] = vaultAssetsPercent;\n            // Protocol exposure\n            for (uint256 j = 0; j < pCount; j++) {\n                uint256 percentOfSystem = calculatePercentOfSystem(\n                    vaults[i],\n                    j,\n                    vaultAssetsPercent,\n                    sysState.vaultCurrentAssets[i]\n                );\n                expState.protocolExposure[j] = expState.protocolExposure[j].add(percentOfSystem);\n            }\n        }\n        if (treatLifeguardAsCurve) {\n            // Curve exposure is calculated by adding the Curve vaults total assets and any\n            // assets in the lifeguard which are poised to be invested into the Curve vault\n            expState.curveExposure = sysState.curveCurrentAssetsUsd.add(sysState.lifeguardCurrentAssetsUsd);\n        } else {\n            expState.curveExposure = sysState.curveCurrentAssetsUsd;\n        }\n        expState.curveExposure = expState.curveExposure.mul(PERCENTAGE_DECIMAL_FACTOR).div(\n            sysState.totalCurrentAssetsUsd\n        );\n\n        // Calculate stablecoin exposures\n        expState.stablecoinExposure = calculateStableCoinExposure(expState.stablecoinExposure, expState.curveExposure);\n    }\n}"
    },
    {
      "filename": "contracts/pnl/PnL.sol",
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IPnL.sol\";\nimport \"../common/Controllable.sol\";\nimport \"../interfaces/IPnL.sol\";\nimport \"../common/Constants.sol\";\nimport {FixedGTokens} from \"../common/FixedContracts.sol\";\n\n/// @notice Contract for calculating protocol profit and loss. The PnL contract stores snapshots\n///     of total assets in pwrd and gvt, which are used to calculate utilisation ratio and establish\n///     changes in underling pwrd and gvt factors. The protocol will allow these values to drift as long\n///     as they stay within a certain threshold of protocol actuals, or large amounts of assets are being\n///     deposited or withdrawn from the protocol. The PnL contract ensures that any profits are distributed\n///     between pwrd and gvt based on the utilisation ratio - as this ratio movese towards 1, a larger\n///     amount of the pwrd profit is shifted to gvt. Protocol losses are on the other hand soaked up\n///     by gvt, ensuring that pwrd never lose value.\n///\n///     ###############################################\n///     PnL variables and calculations\n///     ###############################################\n///\n///     yield - system gains and losses from assets invested into strategies are realised once\n///         a harvest is run. Yield is ditributed to pwrd and gvt based on the utilisation ratio of the\n///         two tokens (see _calcProfit).\n///\n///     PerformanceFee - The performance fee is deducted from any yield profits, and is used to\n///         buy back and distribute governance tokens to users.\n///\n///     hodler Fee - Withdrawals experience a hodler fee that is socialized to all other holders.\n///         Like other gains, this isn't realised on withdrawal, but rather when a critical amount\n///         has amassed in the system (totalAssetsPercentThreshold).\n///\n///     ###############################################\n///     PnL Actions\n///     ###############################################\n///\n///     Pnl has two trigger mechanisms:\n///         - Harvest:\n///             - It will realize any loss/profit from the strategy\n///             - It will atempt to update lastest cached curve stable coin dy\n///                 - if successfull, it will try to realize any price changes (pre tvl vs current)\n///         - Withdrawals\n///             - Any user withdrawals are distributing the holder fee to the other users\ncontract PnL is Controllable, Constants, FixedGTokens, IPnL {\n    using SafeMath for uint256;\n\n    uint256 public override lastGvtAssets;\n    uint256 public override lastPwrdAssets;\n    bool public rebase = true;\n\n    uint256 public performanceFee; // Amount of gains to use to buy back and distribute gov tokens\n\n    event LogRebaseSwitch(bool status);\n    event LogNewPerfromanceFee(uint256 fee);\n    event LogNewGtokenChange(bool pwrd, int256 change);\n    event LogPnLExecution(\n        uint256 deductedAssets,\n        int256 totalPnL,\n        int256 investPnL,\n        int256 pricePnL,\n        uint256 withdrawalBonus,\n        uint256 performanceBonus,\n        uint256 beforeGvtAssets,\n        uint256 beforePwrdAssets,\n        uint256 afterGvtAssets,\n        uint256 afterPwrdAssets\n    );\n\n    constructor(\n        address pwrd,\n        address gvt,\n        uint256 pwrdAssets,\n        uint256 gvtAssets\n    ) public FixedGTokens(pwrd, gvt) {\n        lastPwrdAssets = pwrdAssets;\n        lastGvtAssets = gvtAssets;\n    }\n\n    /// @notice Turn pwrd rebasing on/off - This stops yield/ hodler bonuses to be distributed to the pwrd\n    ///     token, which effectively stops it from rebasing any further.\n    function setRebase(bool _rebase) external onlyOwner {\n        rebase = _rebase;\n        emit LogRebaseSwitch(_rebase);\n    }\n\n    /// @notice Fee taken from gains to be redistributed to users who stake their tokens\n    /// @param _performanceFee Amount to remove from gains (%BP)\n    function setPerformanceFee(uint256 _performanceFee) external onlyOwner {\n        performanceFee = _performanceFee;\n        emit LogNewPerfromanceFee(_performanceFee);\n    }\n\n    /// @notice Increase previously recorded GToken assets by specific amount\n    /// @param pwrd pwrd/gvt\n    /// @param dollarAmount Amount to increase by\n    function increaseGTokenLastAmount(bool pwrd, uint256 dollarAmount) external override {\n        require(msg.sender == controller, \"increaseGTokenLastAmount: !controller\");\n        if (!pwrd) {\n            lastGvtAssets = lastGvtAssets.add(dollarAmount);\n        } else {\n            lastPwrdAssets = lastPwrdAssets.add(dollarAmount);\n        }\n        emit LogNewGtokenChange(pwrd, int256(dollarAmount));\n    }\n\n    /// @notice Decrease previously recorded GToken assets by specific amount\n    /// @param pwrd pwrd/gvt\n    /// @param dollarAmount Amount to decrease by\n    /// @param bonus hodler bonus\n    function decreaseGTokenLastAmount(\n        bool pwrd,\n        uint256 dollarAmount,\n        uint256 bonus\n    ) external override {\n        require(msg.sender == controller, \"decreaseGTokenLastAmount: !controller\");\n        uint256 lastGA = lastGvtAssets;\n        uint256 lastPA = lastPwrdAssets;\n        if (!pwrd) {\n            lastGA = dollarAmount > lastGA ? 0 : lastGA.sub(dollarAmount);\n        } else {\n            lastPA = dollarAmount > lastPA ? 0 : lastPA.sub(dollarAmount);\n        }\n        if (bonus > 0) {\n            uint256 preGABeforeBonus = lastGA;\n            uint256 prePABeforeBonus = lastPA;\n            uint256 preTABeforeBonus = preGABeforeBonus.add(prePABeforeBonus);\n            if (rebase) {\n                lastGA = preGABeforeBonus.add(bonus.mul(preGABeforeBonus).div(preTABeforeBonus));\n                lastPA = prePABeforeBonus.add(bonus.mul(prePABeforeBonus).div(preTABeforeBonus));\n            } else {\n                lastGA = preGABeforeBonus.add(bonus);\n            }\n            emit LogPnLExecution(0, int256(bonus), 0, 0, bonus, 0, preGABeforeBonus, prePABeforeBonus, lastGA, lastPA);\n        }\n\n        lastGvtAssets = lastGA;\n        lastPwrdAssets = lastPA;\n        emit LogNewGtokenChange(pwrd, int256(-dollarAmount));\n    }\n\n    /// @notice Return latest system asset states\n    function calcPnL() external view override returns (uint256, uint256) {\n        return (lastGvtAssets, lastPwrdAssets);\n    }\n\n    /// @notice Calculate utilisation ratio between gvt and pwrd\n    function utilisationRatio() external view override returns (uint256) {\n        return lastGvtAssets != 0 ? lastPwrdAssets.mul(PERCENTAGE_DECIMAL_FACTOR).div(lastGvtAssets) : 0;\n    }\n\n    /// @notice Update assets after entering emergency state\n    function emergencyPnL() external override {\n        require(msg.sender == controller, \"emergencyPnL: !controller\");\n        forceDistribute();\n    }\n\n    /// @notice Recover system from emergency state\n    function recover() external override {\n        require(msg.sender == controller, \"recover: !controller\");\n        forceDistribute();\n    }\n\n    /// @notice Distribute yield based on utilisation ratio\n    /// @param gvtAssets Total gvt assets\n    /// @param pwrdAssets Total pwrd assets\n    /// @param profit Amount of profit to distribute\n    /// @param reward Rewards contract\n    function handleInvestGain(\n        uint256 gvtAssets,\n        uint256 pwrdAssets,\n        uint256 profit,\n        address reward\n    )\n        private\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 performanceBonus;\n        if (performanceFee > 0 && reward != address(0)) {\n            performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR);\n            profit = profit.sub(performanceBonus);\n        }\n        if (rebase) {\n            uint256 totalAssets = gvtAssets.add(pwrdAssets);\n            uint256 gvtProfit = profit.mul(gvtAssets).div(totalAssets);\n            uint256 pwrdProfit = profit.mul(pwrdAssets).div(totalAssets);\n\n            uint256 factor = pwrdAssets.mul(10000).div(gvtAssets);\n            if (factor > 10000) factor = 10000;\n            if (factor < 8000) {\n                factor = factor.mul(3).div(8).add(3000);\n            } else {\n                factor = factor.sub(8000).mul(2).add(6000);\n            }\n\n            uint256 portionFromPwrdProfit = pwrdProfit.mul(factor).div(10000);\n            gvtAssets = gvtAssets.add(gvtProfit.add(portionFromPwrdProfit));\n            pwrdAssets = pwrdAssets.add(pwrdProfit.sub(portionFromPwrdProfit));\n        } else {\n            gvtAssets = gvtAssets.add(profit);\n        }\n        return (gvtAssets, pwrdAssets, performanceBonus);\n    }\n\n    /// @notice Distribute losses\n    /// @param gvtAssets Total gvt assets\n    /// @param pwrdAssets Total pwrd assets\n    /// @param loss Amount of loss to distribute\n    function handleLoss(\n        uint256 gvtAssets,\n        uint256 pwrdAssets,\n        uint256 loss\n    ) private pure returns (uint256, uint256) {\n        uint256 maxGvtLoss = gvtAssets.sub(DEFAULT_DECIMALS_FACTOR);\n        if (loss > maxGvtLoss) {\n            gvtAssets = DEFAULT_DECIMALS_FACTOR;\n            pwrdAssets = pwrdAssets.sub(loss.sub(maxGvtLoss));\n        } else {\n            gvtAssets = gvtAssets - loss;\n        }\n        return (gvtAssets, pwrdAssets);\n    }\n\n    function forceDistribute() private {\n        uint256 total = _controller().totalAssets();\n\n        if (total > lastPwrdAssets.add(DEFAULT_DECIMALS_FACTOR)) {\n            lastGvtAssets = total - lastPwrdAssets;\n        } else {\n            lastGvtAssets = DEFAULT_DECIMALS_FACTOR;\n            lastPwrdAssets = total.sub(DEFAULT_DECIMALS_FACTOR);\n        }\n    }\n\n    function distributeStrategyGainLoss(\n        uint256 gain,\n        uint256 loss,\n        address reward\n    ) external override {\n        require(msg.sender == controller, \"!Controller\");\n        uint256 lastGA = lastGvtAssets;\n        uint256 lastPA = lastPwrdAssets;\n        uint256 performanceBonus;\n        uint256 gvtAssets;\n        uint256 pwrdAssets;\n        int256 investPnL;\n        if (gain > 0) {\n            (gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward);\n            if (performanceBonus > 0) {\n                gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus);\n                gvtAssets = gvtAssets.add(performanceBonus);\n            }\n\n            lastGvtAssets = gvtAssets;\n            lastPwrdAssets = pwrdAssets;\n            investPnL = int256(gain);\n        } else if (loss > 0) {\n            (lastGvtAssets, lastPwrdAssets) = handleLoss(lastGA, lastPA, loss);\n            investPnL = -int256(loss);\n        }\n\n        emit LogPnLExecution(\n            0,\n            investPnL,\n            investPnL,\n            0,\n            0,\n            performanceBonus,\n            lastGA,\n            lastPA,\n            lastGvtAssets,\n            lastPwrdAssets\n        );\n    }\n\n    function distributePriceChange(uint256 currentTotalAssets) external override {\n        require(msg.sender == controller, \"!Controller\");\n        uint256 gvtAssets = lastGvtAssets;\n        uint256 pwrdAssets = lastPwrdAssets;\n        uint256 totalAssets = gvtAssets.add(pwrdAssets);\n\n        if (currentTotalAssets > totalAssets) {\n            lastGvtAssets = gvtAssets.add(currentTotalAssets.sub(totalAssets));\n        } else if (currentTotalAssets < totalAssets) {\n            (lastGvtAssets, lastPwrdAssets) = handleLoss(gvtAssets, pwrdAssets, totalAssets.sub(currentTotalAssets));\n        }\n        int256 priceChange = int256(currentTotalAssets) - int256(totalAssets);\n\n        emit LogPnLExecution(\n            0,\n            priceChange,\n            0,\n            priceChange,\n            0,\n            0,\n            gvtAssets,\n            pwrdAssets,\n            lastGvtAssets,\n            lastPwrdAssets\n        );\n    }\n}"
    },
    {
      "filename": "contracts/pools/oracle/Buoy3Pool.sol",
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {FixedStablecoins} from \"contracts/common/FixedContracts.sol\";\nimport {ICurve3Pool} from \"contracts/interfaces/ICurve.sol\";\n\nimport \"contracts/common/Controllable.sol\";\n\nimport \"contracts/interfaces/IBuoy.sol\";\nimport \"contracts/interfaces/IChainPrice.sol\";\nimport \"contracts/interfaces/IChainlinkAggregator.sol\";\nimport \"contracts/interfaces/IERC20Detailed.sol\";\n\n/// @notice Contract for calculating prices of underlying assets and LP tokens in Curve pool. Also\n///     used to sanity check pool against external oracle, to ensure that pools underlying coin ratios\n///     are within a specific range (measued in BP) of the external oracles coin price ratios.\n///     Sanity check:\n///         The Buoy checks previously recorded (cached) curve coin dy, which it compares against current curve dy,\n///         blocking any interaction that is outside a certain tolerance (BASIS_POINTS). When updting the cached\n///         value, the buoy uses chainlink to ensure that curves prices arent off peg.\ncontract Buoy3Pool is FixedStablecoins, Controllable, IBuoy, IChainPrice {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 TIME_LIMIT = 3000;\n    uint256 public BASIS_POINTS = 20;\n    uint256 constant CHAIN_FACTOR = 100;\n\n    ICurve3Pool public immutable override curvePool;\n    IERC20 public immutable lpToken;\n\n    mapping(uint256 => uint256) lastRatio;\n\n    // Chianlink price feed\n    address public immutable daiUsdAgg;\n    address public immutable usdcUsdAgg;\n    address public immutable usdtUsdAgg;\n\n    mapping(address => mapping(address => uint256)) public tokenRatios;\n\n    event LogNewBasisPointLimit(uint256 oldLimit, uint256 newLimit);\n\n    constructor(\n        address _crv3pool,\n        address poolToken,\n        address[N_COINS] memory _tokens,\n        uint256[N_COINS] memory _decimals,\n        address[N_COINS] memory aggregators\n    ) public FixedStablecoins(_tokens, _decimals) {\n        curvePool = ICurve3Pool(_crv3pool);\n        lpToken = IERC20(poolToken);\n        daiUsdAgg = aggregators[0];\n        usdcUsdAgg = aggregators[1];\n        usdtUsdAgg = aggregators[2];\n    }\n\n    /// @notice Set limit for how much Curve pool and external oracle is allowed\n    ///     to deviate before failing transactions\n    /// @param newLimit New limit in BP\n    function setBasisPointsLmit(uint256 newLimit) external onlyOwner {\n        uint256 oldLimit = BASIS_POINTS;\n        BASIS_POINTS = newLimit;\n        emit LogNewBasisPointLimit(oldLimit, newLimit);\n    }\n\n    /// @notice Check the health of the Curve pool:\n    ///     Ratios are checked by the following heuristic:\n    ///     Orcale A - Curve\n    ///     Oracle B - External oracle\n    ///     Both oracles establish ratios for a set of stable coins\n    ///         (a, b, c)\n    ///     and product the following set of ratios:\n    ///         (a/a, a/b, a/c), (b/b, b/a, b/c), (c/c, c/a, c/b)\n    ///     It's simply to reduce the number of comparisons to be made\n    ///     in order to have complete coverage of the system ratios:\n    ///         1) ratios between a stable coin and itself can be discarded\n    ///         2) inverted ratios, a/b bs b/a, while producing different results\n    ///             should both reflect the same change in any one of the two\n    ///             underlying assets, but in opposite directions\n    ///     This mean that the following set should provide the necessary coverage checks\n    ///     to establish that the coins pricing is healthy:\n    ///         (a/b, a/c)\n    function safetyCheck() external view override returns (bool) {\n        for (uint256 i = 1; i < N_COINS; i++) {\n            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));\n            _ratio = abs(int256(_ratio - lastRatio[i]));\n            if (_ratio.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > BASIS_POINTS) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Updated cached curve value with a custom tolerance towards chainlink\n    /// @param tolerance How much difference between curve and chainlink can be tolerated\n    function updateRatiosWithTolerance(uint256 tolerance) external override returns (bool) {\n        require(msg.sender == controller || msg.sender == owner(), \"updateRatiosWithTolerance: !authorized\");\n        return _updateRatios(tolerance);\n    }\n\n    /// @notice Updated cached curve values\n    function updateRatios() external override returns (bool) {\n        require(msg.sender == controller || msg.sender == owner(), \"updateRatios: !authorized\");\n        return _updateRatios(BASIS_POINTS);\n    }\n\n    /// @notice Get USD value for a specific input amount of tokens, slippage included\n    function stableToUsd(uint256[N_COINS] calldata inAmounts, bool deposit) external view override returns (uint256) {\n        return _stableToUsd(inAmounts, deposit);\n    }\n\n    /// @notice Get estimate USD price of a stablecoin amount\n    /// @param inAmount Token amount\n    /// @param i Index of token\n    function singleStableToUsd(uint256 inAmount, uint256 i) external view override returns (uint256) {\n        uint256[N_COINS] memory inAmounts;\n        inAmounts[i] = inAmount;\n        return _stableToUsd(inAmounts, true);\n    }\n\n    /// @notice Get LP token value of input amount of tokens\n    function stableToLp(uint256[N_COINS] calldata tokenAmounts, bool deposit) external view override returns (uint256) {\n        return _stableToLp(tokenAmounts, deposit);\n    }\n\n    /// @notice Get LP token value of input amount of single token\n    function singleStableFromUsd(uint256 inAmount, int128 i) external view override returns (uint256) {\n        return _singleStableFromLp(_usdToLp(inAmount), i);\n    }\n\n    /// @notice Get LP token value of input amount of single token\n    function singleStableFromLp(uint256 inAmount, int128 i) external view override returns (uint256) {\n        return _singleStableFromLp(inAmount, i);\n    }\n\n    /// @notice Get USD price of LP tokens you receive for a specific input amount of tokens, slippage included\n    function lpToUsd(uint256 inAmount) external view override returns (uint256) {\n        return _lpToUsd(inAmount);\n    }\n\n    /// @notice Convert USD amount to LP tokens\n    function usdToLp(uint256 inAmount) external view override returns (uint256) {\n        return _usdToLp(inAmount);\n    }\n\n    /// @notice Split LP token amount to balance of pool tokens\n    /// @param inAmount Amount of LP tokens\n    /// @param totalBalance Total balance of pool\n    function poolBalances(uint256 inAmount, uint256 totalBalance)\n        internal\n        view\n        returns (uint256[N_COINS] memory balances)\n    {\n        uint256[N_COINS] memory _balances;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            _balances[i] = (IERC2"
    }
  ]
}