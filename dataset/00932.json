{
  "Title": "Code Repetition",
  "Content": "Throughout the codebase, there are instances of similar or identical code being used that could be consolidated. For example:\n\n\n#### In the [`PSP22PalletMetadataImpl`](https://github.com/Brushfam/openbrush-contracts/blob/cd304109eab1c85a50d4cdccccb5f3b77905e700/contracts/src/token/psp22_pallet/extensions/metadata.rs#L44) Trait\n\n\nThe `token_name`, `token_symbol`, and `token_decimals` functions access the pallet assets in the following manner:\n\n\n\n\n```\nÂ fn X(&self) -> Option<String> {\n        let self_ = self.data();\n        let name = self_\n            .pallet_assets\n            .get_or_default()\n        ...\n        ...\n}\n\n```\n\n\nThis code is repeated in each function. Consider centralizing this logic by creating `metadata_symbol`, `metadata_name`, and `metadata_decimals` functions and calling them in each corresponding function.\n\n\n#### In `accessors.rs`\n\n\n* The [`generate_struct`](https://github.com/Brushfam/openbrush-contracts/blob/cd304109eab1c85a50d4cdccccb5f3b77905e700/lang/codegen/src/accessors.rs#L70) is nearly identical to the one used in [`storage_item`](https://github.com/Brushfam/openbrush-contracts/blob/cd304109eab1c85a50d4cdccccb5f3b77905e700/lang/codegen/src/storage_item.rs#L122). Consider reusing it as much as possible.\n* The only difference between the `extract_get_fields` and `extract_set_fields` functions is the parameter passed to `is_ident` (\"get\" for the former and \"set\" for the latter). Consider consolidating both functions in one single function and adding one parameter to distinguish between \"set\" and \"get\".\n\n\n#### In `implementation.rs` / `contract.rs`\n\n\nBoth [`implementation`](https://github.com/Brushfam/openbrush-contracts/blob/cd304109eab1c85a50d4cdccccb5f3b77905e700/lang/codegen/src/implementation.rs#L62) and [`contract`](https://github.com/Brushfam/openbrush-contracts/blob/cd304109eab1c85a50d4cdccccb5f3b77905e700/lang/codegen/src/contract.rs#L47) macros check that the module is not an out-of-line module declaration, which will be passed twice during code generation. Consider doing this check a single time.\n\n\n***Update:** Partially resolved in [pull request #150](https://github.com/Brushfam/openbrush-contracts/pull/150) at commit [dc91955](https://github.com/Brushfam/openbrush-contracts/pull/150/commits/dc919555d8aa636d3b6fc7e7ff2ac8e97aa3d621). The client resolved code repetition in `PSP22PalletMetadataImpl` and part of `accessors.rs` but did not take any action on `implementation.rs` / `contract.rs`. The Brushfam team stated:*\n\n\n\n> *Out of module declaration is more extracting values, not a check. Generating structs differs for working with fields, so we left them as they are for now.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/token/psp22_pallet/extensions/metadata.rs",
      "content": "// Copyright (c) 2012-2022 Supercolony\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\"Software\"),\n// to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npub use crate::{\n    psp22_pallet,\n    psp22_pallet::extensions::metadata,\n    traits::psp22::{\n        extensions::metadata::*,\n        *,\n    },\n};\npub use ink::env::DefaultEnvironment;\nuse openbrush::traits::Storage;\npub use openbrush::traits::String;\npub use pallet_assets_chain_extension::traits::{\n    Error,\n    Origin,\n    PalletAssets,\n};\npub use psp22_pallet::{\n    Internal as _,\n    InternalImpl as _,\n    PSP22PalletImpl,\n};\n\npub trait PSP22PalletMetadataImpl: Storage<psp22_pallet::Data> {\n    fn token_name(&self) -> Option<String> {\n        let self_ = self.data();\n        let name = self_\n            .pallet_assets\n            .get_or_default()\n            .metadata_name(self_.asset_id.get_or_default());\n\n        if name.is_empty() {\n            None\n        } else {\n            Some(String::from_utf8(name).expect(\"Invalid UTF-8 string for token\"))\n        }\n    }\n\n    fn token_symbol(&self) -> Option<String> {\n        let self_ = self.data();\n        let symbol = self_\n            .pallet_assets\n            .get_or_default()\n            .metadata_symbol(self_.asset_id.get_or_default());\n\n        if symbol.is_empty() {\n            None\n        } else {\n            Some(String::from_utf8(symbol).expect(\"Invalid UTF-8 string for token\"))\n        }\n    }\n\n    fn token_decimals(&self) -> u8 {\n        let self_ = self.data();\n        self_\n            .pallet_assets\n            .get_or_default()\n            .metadata_decimals(self_.asset_id.get_or_default())\n    }\n}"
    },
    {
      "filename": "lang/codegen/src/accessors.rs",
      "content": "use proc_macro2::TokenStream;\nuse quote::{\n    format_ident,\n    quote,\n    quote_spanned,\n};\nuse syn::{\n    spanned::Spanned,\n    Data,\n    DataStruct,\n    Field,\n    Fields,\n};\n\npub fn accessors(attrs: TokenStream, s: synstructure::Structure) -> TokenStream {\n    let trait_ident = attrs;\n\n    let struct_ident = s.ast().ident.clone();\n\n    let item = match s.ast().data.clone() {\n        Data::Struct(struct_item) => generate_struct(&s, struct_item),\n        _ => panic!(\"Only structs are supported\"),\n    };\n\n    let fields: Vec<_> = extract_get_fields(s.clone());\n\n    let get_impls = fields.iter().map(|field| {\n        let field_ident = field.ident.clone().unwrap();\n        let method_ident = format_ident!(\"get_{}\", field_ident);\n        let field_type = field.ty.clone();\n        let span = field.span();\n\n        quote_spanned! {span =>\n            #[ink(message)]\n            fn #method_ident(&self) -> #field_type {\n                self.data().#field_ident\n            }\n        }\n    });\n\n    let fields: Vec<_> = extract_set_fields(s.clone());\n\n    let set_impls = fields.iter().map(|field| {\n        let field_ident = field.ident.clone().unwrap();\n        let method_ident = format_ident!(\"set_{}\", field_ident);\n        let field_type = field.ty.clone();\n        let span = field.span();\n\n        quote_spanned! {span =>\n            #[ink(message)]\n            fn #method_ident(&mut self, value: #field_type) {\n                self.data().#field_ident = value;\n            }\n        }\n    });\n\n    let result = quote! {\n        #item\n\n        #[openbrush::trait_definition]\n        pub trait #trait_ident : Storage<#struct_ident>{\n            #(#get_impls)*\n            #(#set_impls)*\n        }\n    };\n\n    result\n}\n\nfn generate_struct(s: &synstructure::Structure, struct_item: DataStruct) -> TokenStream {\n    let struct_ident = s.ast().ident.clone();\n    let vis = s.ast().vis.clone();\n    let attrs = s.ast().attrs.clone();\n    let types = s.ast().generics.clone();\n    let (_, _, where_closure) = s.ast().generics.split_for_impl();\n\n    let fields = struct_item\n        .clone()\n        .fields\n        .into_iter()\n        .map(|mut field| consume_attrs(&mut field));\n\n    match struct_item.fields {\n        Fields::Unnamed(_) => {\n            quote! {\n                #(#attrs)*\n                #vis struct #struct_ident #types #where_closure (\n                    #(#fields),*\n                );\n            }\n        }\n        _ => {\n            quote! {\n                #(#attrs)*\n                #vis struct #struct_ident #types #where_closure {\n                    #(#fields),*\n                }\n            }\n        }\n    }\n}\n\nfn consume_attrs(field: &mut syn::Field) -> Field {\n    let attr = field\n        .attrs\n        .iter()\n        .filter(|a| !a.path.is_ident(\"get\") && !a.path.is_ident(\"set\"))\n        .cloned()\n        .collect();\n\n    field.attrs = attr;\n\n    field.clone()\n}\n\nfn extract_get_fields(s: synstructure::Structure) -> Vec<Field> {\n    let struct_item = match s.ast().data.clone() {\n        Data::Struct(struct_item) => struct_item,\n        _ => panic!(\"Only structs are supported\"),\n    };\n\n    struct_item\n        .fields\n        .iter()\n        .filter(|field| field.attrs.iter().any(|a| a.path.is_ident(\"get\")))\n        .cloned()\n        .collect::<Vec<_>>()\n}\n\nfn extract_set_fields(s: synstructure::Structure) -> Vec<Field> {\n    let struct_item = match s.ast().data.clone() {\n        Data::Struct(struct_item) => struct_item,\n        _ => panic!(\"Only structs are supported\"),\n    };\n\n    struct_item\n        .fields\n        .iter()\n        .filter(|field| field.attrs.iter().any(|a| a.path.is_ident(\"set\")))\n        .cloned()\n        .collect::<Vec<_>>()\n}"
    },
    {
      "filename": "lang/codegen/src/implementation.rs",
      "content": "// Copyright (c) 2012-2022 Supercolony\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\"Software\"),\n// to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nuse crate::{\n    implementations::*,\n    internal,\n    internal::*,\n};\nuse proc_macro2::TokenStream;\nuse quote::{\n    quote,\n    ToTokens,\n};\nuse std::collections::HashMap;\nuse syn::{\n    Item,\n    Path,\n};\n\npub fn generate(attrs: TokenStream, ink_module: TokenStream) -> TokenStream {\n    if internal::skip() {\n        return quote! {}\n    }\n    let input: TokenStream = ink_module;\n\n    // map attribute args to default contract names\n    let args = syn::parse2::<AttributeArgs>(attrs)\n        .expect(\"No default contracts to implement provided\")\n        .iter()\n        .map(|arg| {\n            match arg {\n                NestedMeta::Path(method) => method.to_token_stream().to_string().replace(' ', \"\"),\n                _ => panic!(\"Expected names of OpenBrush traits to implement in the contract!\"),\n            }\n        })\n        .collect::<Vec<String>>();\n\n    let mut module = syn::parse2::<syn::ItemMod>(input).expect(\"Can't parse contract module\");\n    let (braces, items) = match module.clone().content {\n        Some((brace, items)) => (brace, items),\n        None => {\n            panic!(\n                \"{}\",\n                \"out-of-line openbrush modules are not supported, use `#[implementation] mod name {{ ... }}`\",\n            )\n        }\n    };\n\n    // name of struct for which we will implement the traits\n    let ident = extract_storage_struct_name(&items);\n    // we will look for overriden functions and remove them from the mod\n    let (map, mut items) = consume_overriders(items);\n\n    // to save importing of stuff by users\n    let mut imports = HashMap::<&str, syn::ItemUse>::default();\n    // if multiple contracts are using the same trait implemented differently we override it this way\n    let mut overriden_traits = HashMap::<&str, syn::Item>::default();\n\n    let mut impl_args = ImplArgs::new(&map, &mut items, &mut imports, &mut overriden_traits, ident);\n\n    for to_implement in args {\n        match to_implement.as_str() {\n            \"PSP22\" => impl_psp22(&mut impl_args),\n            \"PSP22Mintable\" => impl_psp22_mintable(&mut impl_args),\n            \"PSP22Burnable\" => impl_psp22_burnable(&mut impl_args),\n            \"PSP22Metadata\" => impl_psp22_metadata(&mut impl_args),\n            \"PSP22Capped\" => impl_psp22_capped(&mut impl_args),\n            \"PSP22Wrapper\" => impl_psp22_wrapper(&mut impl_args),\n            \"Flashmint\" => impl_flashmint(&mut impl_args),\n            \"PSP22TokenTimelock\" => impl_token_timelock(&mut impl_args),\n            \"PSP22Pallet\" => impl_psp22_pallet(&mut impl_args),\n            \"PSP22PalletBurnable\" => impl_psp22_pallet_burnable(&mut impl_args),\n            \"PSP22PalletMetadata\" => impl_psp22_pallet_metadata(&mut impl_args),\n            \"PSP22PalletMintable\" => impl_psp22_pallet_mintable(&mut impl_args),\n            \"PSP34\" => impl_psp34(&mut impl_args),\n            \"PSP34Burnable\" => impl_psp34_burnable(&mut impl_args),\n            \"PSP34Mintable\" => impl_psp34_mintable(&mut impl_args),\n            \"PSP34Metadata\" => impl_psp34_metadata(&mut impl_args),\n            \"PSP34Enumerable\" => impl_psp34_enumerable(&mut impl_args),\n            \"PSP37\" => impl_psp37(&mut impl_args),\n            \"PSP37Batch\" => impl_psp37_batch(&mut impl_args),\n            \"PSP37Burnable\" => impl_psp37_burnable(&mut impl_args),\n            \"PSP37Metadata\" => impl_psp37_metadata(&mut impl_args),\n            \"PSP37Mintable\" => impl_psp37_mintable(&mut impl_args),\n            \"PSP37Enumerable\" => impl_psp37_enumerable(&mut impl_args),\n            \"Ownable\" => impl_ownable(&mut impl_args),\n            \"PaymentSplitter\" => impl_payment_splitter(&mut impl_args),\n            \"AccessControl\" => impl_access_control(&mut impl_args),\n            \"AccessControlEnumerable\" => impl_access_control_enumerable(&mut impl_args),\n            \"Pausable\" => impl_pausable(&mut impl_args),\n            \"TimelockController\" => impl_timelock_controller(&mut impl_args),\n            \"Proxy\" => impl_proxy(&mut impl_args),\n            \"Diamond\" => impl_diamond(&mut impl_args),\n            \"DiamondLoupe\" => impl_diamond_loupe(&mut impl_args),\n            \"Upgradeable\" => impl_upgradeable(&mut impl_args),\n            _ => panic!(\"openbrush::implementation({to_implement}) not implemented!\"),\n        }\n    }\n\n    cleanup_imports(impl_args.imports);\n\n    // add the imports\n    impl_args\n        .items\n        .append(&mut impl_args.imports.values().cloned().map(syn::Item::Use).collect());\n\n    // add overriden traits\n    impl_args\n        .items\n        .append(&mut impl_args.overriden_traits.values().cloned().collect());\n\n    module.content = Some((braces, items));\n\n    quote! {\n        #module\n    }\n}\n\nfn cleanup_imports(imports: &mut HashMap<&str, syn::ItemUse>) {\n    // we will remove unnecessary imports\n    let psp22_impls = vec![\n        \"PSP22Mintable\",\n        \"PSP22Burnable\",\n        \"PSP22Capped\",\n        \"PSP22Metadata\",\n        \"PSP22Wrapper\",\n        \"Flashmint\",\n    ];\n    check_and_remove_import(\"PSP22\", psp22_impls, imports);\n\n    let psp22_pallet_impls = vec![\"PSP22PalletMintable\", \"PSP22PalletBurnable\", \"PSP22PalletMetadata\"];\n    check_and_remove_import(\"PSP22Pallet\", psp22_pallet_impls, imports);\n\n    let psp34_impls = vec![\"PSP34Mintable\", \"PSP34Burnable\", \"PSP34Metadata\", \"PSP34Enumerable\"];\n    check_and_remove_import(\"PSP34\", psp34_impls, imports);\n\n    let psp37_impls = vec![\n        \"PSP37Batch\",\n        \"PSP37Burnable\",\n        \"PSP37Metadata\",\n        \"PSP37Mintable\",\n        \"PSP37Enumerable\",\n    ];\n    check_and_remove_import(\"PSP37\", psp37_impls, imports);\n\n    let access_impls = vec![\"AccessControlEnumerable\", \"TimelockController\"];\n    check_and_remove_import(\"AccessControl\", access_impls, imports);\n\n    check_and_remove_import(\"Diamond\", vec![\"DiamondLoupe\"], imports);\n}\n\nfn check_and_remove_import(name_to_check: &str, to_check: Vec<&str>, imports: &mut HashMap<&str, syn::ItemUse>) {\n    if to_check.iter().any(|name| imports.contains_key(name)) {\n        imports.remove(name_to_check);\n    }\n}\n\n// this method consumes override annotated methods and returns them mapped to code and the mod without them\n// we will later override the methods\nfn consume_overriders(items: Vec<syn::Item>) -> (OverridenFnMap, Vec<syn::Item>) {\n    let mut map = HashMap::new();\n    let mut result: Vec<syn::Item> = vec![];\n    items.into_iter().for_each(|mut item| {\n        if let Item::Fn(item_fn) = &mut item {\n            if is_attr(&item_fn.attrs, \"overrider\") || is_attr(&item_fn.attrs, \"default_impl\") {\n                let attr_name = if is_attr(&item_fn.attrs, \"overrider\") {\n                    \"overrider\"\n                } else {\n                    \"default_impl\"\n                };\n                let fn_name = item_fn.sig.ident.to_string();\n                let code = item_fn.block.clone();\n                let mut attributes = item_fn.attrs.clone();\n\n                // we will remove the overrider attribute since some other attributes might be interesting to us\n                let to_remove_idx = attributes\n                    .iter()\n                    .position(|attr| is_attr(&[attr.clone()], attr_name))\n                    .expect(\"No {attr_name} attribute found!\");\n                let overrider_attribute = attributes.remove(to_remove_idx);\n\n                let trait_name = overrider_attribute\n                    .parse_args::<Path>()\n                    .expect(\"Expected overriden trait identifier\")\n                    .to_token_stream()\n                    .to_string()\n                    .replace(' ', \"\");\n\n                let mut vec = map.get(&trait_name).unwrap_or(&vec![]).clone();\n                vec.push((fn_name, (code, attributes, attr_name == \"default_impl\")));\n                map.insert(trait_name, vec.to_vec());\n            } else {\n                result.push(item);\n            }\n        } else {\n            result.push(item);\n        }\n    });\n\n    (map, result)\n}\n\nfn extract_storage_struct_name(items: &[syn::Item]) -> String {\n    let contract_storage_struct = items\n        .iter()\n        .find(|item| {\n            if let Item::Struct(structure) = item {\n                let ink_attr_maybe = structure\n                    .attrs\n                    .iter()\n                    .cloned()\n                    .find(|attr| is_attr(&[attr.clone()], \"ink\"));\n\n                if let Some(ink_attr) = ink_attr_maybe {\n                    if let Ok(path) = ink_attr.parse_args::<Path>() {\n                        return path.to_token_stream().to_string() == \"storage\"\n                    }\n                }\n                false\n            } else {\n                false\n            }\n        })\n        .expect(\"Contract storage struct not found!\");\n    match contract_storage_struct {\n        Item::Struct(structure) => structure.ident.to_string(),\n        _ => unreachable!(\"Only Item::Struct allowed here\"),\n    }\n}"
    }
  ]
}