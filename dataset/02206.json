{
  "Title": "M-41: Wrong type casting leads to unsigned integer underflow exception when current price is < last price",
  "Content": "# Issue M-41: Wrong type casting leads to unsigned integer underflow exception when current price is < last price \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/334 \n\n## Found by \nsayan\\_, gogo\n\n## Summary\n\nWhen the current price of a locked token is lower than the last price, the Vault.storePriceAndRewards will revert because of the wrong integer casting.\n\n## Vulnerability Detail\n\nThe following line appears in Vault.storePriceAndRewards:\n\n```solidity\nint256 priceDiff = int256(currentPrice - lastPrices[_protocolId]);\n```\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L233\n\nIf lastPrices[_protocolId] is higher than the currentPrice, the solidity compiler will revert due the underflow of subtracting unsigned integers because it will first try to calculate the result of `currentPrice - lastPrices[_protocolId]` and __then__ try to cast it to int256.\n\n## Impact\n\nThe rebalance will fail when the current token price is less than the last one stored.\n\n## Code Snippet\n\n```solidity\nint256 priceDiff = int256(currentPrice - lastPrices[_protocolId]);\n```\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L233\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCasting should be performed in the following way to avoid underflow and to allow the priceDiff being negative:\n\n```solidity\nint256 priceDiff = int256(currentPrice) - int256(lastPrices[_protocolId]));\n```\n\n## Discussion\n\n**gogotheauditor**\n\nEscalate for 10 USDC\nAlthough I didn't have much time for this contest and may be missing some knowledge about the whole flow, I believe this finding is incorrectly downgraded from High to Medium. As mentioned in the docs for the `rebalance()` function (which calls `rebalanceCheckProtocols()` which calls the problematic `storePriceAndRewards()` for each protocol), \"This is the most important function of the vault.\" This finding shows that the vault rebalancing will not work when the current price of any of the protocols' LP tokens reaches a high price and the new price has not increased since then. During a bear market, this could mean that the vault rebalancing won't work for a long time, while the docs say it should be \"triggered once per two weeks.\" Please review and provide feedback, @sjoerdsommen @judge.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> Although I didn't have much time for this contest and may be missing some knowledge about the whole flow, I believe this finding is incorrectly downgraded from High to Medium. As mentioned in the docs for the `rebalance()` function (which calls `rebalanceCheckProtocols()` which calls the problematic `storePriceAndRewards()` for each protocol), \"This is the most important function of the vault.\" This finding shows that the vault rebalancing will not work when the current price of any of the protocols' LP tokens reaches a high price and the new price has not increased since then. During a bear market, this could mean that the vault rebalancing won't work for a long time, while the docs say it should be \"triggered once per two weeks.\" Please review and provide feedback, @sjoerdsommen @judge.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n\n\n\n\n## Discussion\n\n**gogotheauditor**\n\nEscalate for 10 USDC\nAlthough I didn't have much time for this contest and may be missing some knowledge about the whole flow, I believe this finding is incorrectly downgraded from High to Medium. As mentioned in the docs for the `rebalance()` function (which calls `rebalanceCheckProtocols()` which calls the problematic `storePriceAndRewards()` for each protocol), \"This is the most important function of the vault.\" This finding shows that the vault rebalancing will not work when the current price of any of the protocols' LP tokens reaches a high price and the new price has not increased since then. During a bear market, this could mean that the vault rebalancing won't work for a long time, while the docs say it should be \"triggered once per two weeks.\" Please review and provide feedback, @sjoerdsommen @judge.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> Although I didn't have much time for this contest and may be missing some knowledge about the whole flow, I believe this finding is incorrectly downgraded from High to Medium. As mentioned in the docs for the `rebalance()` function (which calls `rebalanceCheckProtocols()` which calls the problematic `storePriceAndRewards()` for each protocol), \"This is the most important function of the vault.\" This finding shows that the vault rebalancing will not work when the current price of any of the protocols' LP tokens reaches a high price and the new price has not increased since then. During a bear market, this could mean that the vault rebalancing won't work for a long time, while the docs say it should be \"triggered once per two weeks.\" Please review and provide feedback, @sjoerdsommen @judge.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Theezr**\n\nFix:\nhttps://github.com/derbyfinance/derby-yield-optimiser/pull/195\n\n**hrishibhat**\n\nEscalation accepted\n\nConsidering this issue a valid high because rebalance is important and currentprice can be less than the last price regularly resulting in not being able to rebalance. \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Considering this issue a valid high because rebalance is important and currentprice can be less than the last price regularly resulting in not being able to rebalance. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./Interfaces/IController.sol\";\nimport \"./Interfaces/IProvider.sol\";\n\nimport \"./VaultToken.sol\";\nimport \"./libraries/Swap.sol\";\n\ncontract Vault is ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  // state 0 Rebalance done and ready for xController to rebalance again\n  // state 1 Allocation amount received and ready to send funds over to xController\n  // state 2 Allocation amount 0 received => will receive funds from xController\n  // state 3 Allocation amount sent or received and ready to rebalance the vault itself\n  enum State {\n    Idle,\n    PushedUnderlying,\n    SendingFundsXChain,\n    WaitingForFunds,\n    RebalanceVault,\n    SendRewardsPerToken\n  }\n\n  IERC20 internal vaultCurrency;\n  IController internal controller;\n  State public state;\n\n  bool public deltaAllocationsReceived;\n\n  address private dao;\n  address private guardian;\n  address public vaultCurrencyAddr;\n  address public xController;\n\n  uint256 public vaultNumber;\n  uint256 public liquidityPerc;\n  uint256 public performanceFee;\n  uint256 public rebalancingPeriod;\n  uint256 public uScale;\n  uint256 public minimumPull;\n  int256 public marginScale;\n\n  // UNIX timestamp\n  uint256 public rebalanceInterval;\n  uint256 public lastTimeStamp;\n\n  // total underlying of all protocols in vault, excluding vault balance\n  uint256 public savedTotalUnderlying;\n\n  // total amount of funds the vault reserved for users that made a withdrawalRequest\n  uint256 internal reservedFunds;\n\n  // total number of allocated Derby tokens currently\n  int256 public totalAllocatedTokens;\n  // delta of the total number of Derby tokens allocated on next rebalancing\n  int256 private deltaAllocatedTokens;\n\n  string internal stateError = \"Wrong state\";\n\n  // (protocolNumber => currentAllocation): current allocations over the protocols\n  mapping(uint256 => int256) internal currentAllocations;\n\n  // (protocolNumber => deltaAllocation): delta of the portfolio on next rebalancing\n  mapping(uint256 => int256) internal deltaAllocations;\n\n  // historical reward per protocol per token, formula: TVL * yield * perfFee / totalLockedTokens\n  // (rebalancingPeriod => protocolId => rewardPerLockedToken)\n  mapping(uint256 => mapping(uint256 => int256)) public rewardPerLockedToken;\n\n  // (protocolNumber => lastPrice): last price of underlying protocol vault\n  mapping(uint256 => uint256) public lastPrices;\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"Vault: only DAO\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"only Guardian\");\n    _;\n  }\n\n  constructor(\n    uint256 _vaultNumber,\n    address _dao,\n    address _controller,\n    address _vaultCurrency,\n    uint256 _uScale\n  ) {\n    controller = IController(_controller);\n    vaultCurrency = IERC20(_vaultCurrency);\n\n    vaultNumber = _vaultNumber;\n    dao = _dao;\n    uScale = _uScale;\n    lastTimeStamp = block.timestamp;\n    minimumPull = 1_000_000;\n  }\n\n  /// @notice Withdraw from protocols on shortage in Vault\n  /// @dev Keeps on withdrawing until the Vault balance > _value\n  /// @param _value The total value of vaultCurrency an user is trying to withdraw.\n  /// @param _value The (value - current underlying value of this vault) is withdrawn from the underlying protocols.\n  function pullFunds(uint256 _value) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n\n      uint256 shortage = _value - vaultCurrency.balanceOf(address(this));\n      uint256 balanceProtocol = balanceUnderlying(i);\n\n      uint256 amountToWithdraw = shortage > balanceProtocol ? balanceProtocol : shortage;\n      savedTotalUnderlying -= amountToWithdraw;\n\n      if (amountToWithdraw < minimumPull) break;\n      withdrawFromProtocol(i, amountToWithdraw);\n\n      if (_value <= vaultCurrency.balanceOf(address(this))) break;\n    }\n  }\n\n  /// @notice Step 7 trigger, end; Vaults rebalance\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\n  /// @dev amountToProtocol = totalAmount * currentAllocation / totalAllocatedTokens\n  /// @dev amountToDeposit = amountToProtocol - currentBalanceProtocol\n  /// @dev if amountToDeposit < 0 => withdraw\n  /// @dev Execute all withdrawals before deposits\n  function rebalance() external nonReentrant {\n    require(state == State.RebalanceVault, stateError);\n    require(deltaAllocationsReceived, \"!Delta allocations\");\n\n    rebalancingPeriod++;\n\n    claimTokens();\n    settleDeltaAllocation();\n\n    uint256 underlyingIncBalance = calcUnderlyingIncBalance();\n    uint256[] memory protocolToDeposit = rebalanceCheckProtocols(underlyingIncBalance);\n\n    executeDeposits(protocolToDeposit);\n    setTotalUnderlying();\n\n    if (reservedFunds > vaultCurrency.balanceOf(address(this))) pullFunds(reservedFunds);\n\n    state = State.SendRewardsPerToken;\n    deltaAllocationsReceived = false;\n  }\n\n  /// @notice Helper to return underlying balance plus totalUnderlying - liquidty for the vault\n  /// @return underlying totalUnderlying - liquidityVault\n  function calcUnderlyingIncBalance() internal view returns (uint256) {\n    uint256 totalUnderlyingInclVaultBalance = savedTotalUnderlying +\n      getVaultBalance() -\n      reservedFunds;\n    uint256 liquidityVault = (totalUnderlyingInclVaultBalance * liquidityPerc) / 100;\n    return totalUnderlyingInclVaultBalance - liquidityVault;\n  }\n\n  /// @notice Adds deltaAllocatedTokens to totalAllocatedTokens\n  function settleDeltaAllocation() internal {\n    totalAllocatedTokens += deltaAllocatedTokens;\n    deltaAllocatedTokens = 0;\n  }\n\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\n  /// @dev Loops over all protocols in ETF, calculate new currentAllocation based on deltaAllocation\n  /// @dev Also calculate the performance fee here. This is an amount, based on the current TVL (before the rebalance),\n  /// @dev the performanceFee and difference between the current exchangeRate and the exchangeRate of the last rebalance of the vault.\n  /// @param _newTotalUnderlying this will be the new total underlying: Totalunderlying = TotalUnderlyingInProtocols - BalanceVault\n  /// @return uint256[] with amounts to deposit in protocols, the index being the protocol number.\n  function rebalanceCheckProtocols(\n    uint256 _newTotalUnderlying\n  ) internal returns (uint256[] memory) {\n    uint256[] memory protocolToDeposit = new uint[](controller.latestProtocolId(vaultNumber));\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      bool isBlacklisted = controller.getProtocolBlacklist(vaultNumber, i);\n\n      storePriceAndRewards(_newTotalUnderlying, i);\n\n      if (isBlacklisted) continue;\n      setAllocation(i);\n\n      int256 amountToProtocol = calcAmountToProtocol(_newTotalUnderlying, i);\n      uint256 currentBalance = balanceUnderlying(i);\n\n      int256 amountToDeposit = amountToProtocol - int(currentBalance);\n      uint256 amountToWithdraw = amountToDeposit < 0 ? currentBalance - uint(amountToProtocol) : 0;\n\n      if (amountToDeposit > marginScale) protocolToDeposit[i] = uint256(amountToDeposit);\n      if (amountToWithdraw > uint(marginScale) || currentAllocations[i] == 0)\n        withdrawFromProtocol(i, amountToWithdraw);\n    }\n\n    return protocolToDeposit;\n  }\n\n  /// @notice Calculates the amount to deposit or withdraw to protocol during a vault rebalance\n  /// @param _totalUnderlying Totalunderlying = TotalUnderlyingInProtocols - BalanceVault\n  /// @param _protocol Protocol id number\n  /// @return amountToProtocol amount to deposit or withdraw to protocol\n  function calcAmountToProtocol(\n    uint256 _totalUnderlying,\n    uint256 _protocol\n  ) internal view returns (int256 amountToProtocol) {\n    if (totalAllocatedTokens == 0) amountToProtocol = 0;\n    else\n      amountToProtocol =\n        (int(_totalUnderlying) * currentAllocations[_protocol]) /\n        totalAllocatedTokens;\n  }\n\n  /// @notice Stores the historical price and the reward per rounded locked token, ignoring decimals.\n  /// @dev formula yield protocol i at time t: y(it) = (P(it) - P(it-1)) / P(it-1).\n  /// @dev formula rewardPerLockedToken for protocol i at time t: r(it) = y(it) * TVL(t) * perfFee(t) / totalLockedTokens(t)\n  /// @dev later, when the total rewards are calculated for a game player we multiply this (r(it)) by the locked tokens on protocol i at time t\n  /// @param _totalUnderlying Totalunderlying = TotalUnderlyingInProtocols - BalanceVault.\n  /// @param _protocolId Protocol id number.\n  function storePriceAndRewards(uint256 _totalUnderlying, uint256 _protocolId) internal {\n    uint256 currentPrice = price(_protocolId);\n    if (lastPrices[_protocolId] == 0) {\n      lastPrices[_protocolId] = currentPrice;\n      return;\n    }\n\n    int256 priceDiff = int256(currentPrice - lastPrices[_protocolId]);\n    int256 nominator = (int256(_totalUnderlying * performanceFee) * priceDiff);\n    int256 totalAllocatedTokensRounded = totalAllocatedTokens / 1E18;\n    int256 denominator = totalAllocatedTokensRounded * int256(lastPrices[_protocolId]) * 100; // * 100 cause perfFee is in percentages\n\n    if (totalAllocatedTokensRounded == 0) {\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = 0;\n    } else {\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = nominator / denominator;\n    }\n\n    lastPrices[_protocolId] = currentPrice;\n  }\n\n  /// @notice Creates array out of the rewardsPerLockedToken mapping to send to the game\n  /// @return rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\n  function rewardsToArray() internal view returns (int256[] memory rewards) {\n    uint256 latestId = controller.latestProtocolId(vaultNumber);\n\n    rewards = new int[](latestId);\n    for (uint256 i = 0; i < latestId; i++) {\n      rewards[i] = rewardPerLockedToken[rebalancingPeriod][i];\n    }\n  }\n\n  /// @notice Helper function to set allocations\n  /// @param _i Protocol number linked to an underlying protocol e.g compound_usdc_01\n  function setAllocation(uint256 _i) internal {\n    currentAllocations[_i] += deltaAllocations[_i];\n    deltaAllocations[_i] = 0;\n    require(currentAllocations[_i] >= 0, \"Allocation underflow\");\n  }\n\n  /// @notice Helper function so the rebalance will execute all withdrawals first\n  /// @dev Executes and resets all deposits set in mapping(protocolToDeposit) by rebalanceETF\n  /// @param protocolToDeposit array with amounts to deposit in protocols, the index being the protocol number.\n  function executeDeposits(uint256[] memory protocolToDeposit) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      uint256 amount = protocolToDeposit[i];\n      if (amount == 0) continue;\n      depositInProtocol(i, amount);\n    }\n  }\n\n  /// @notice Deposit amount to underlying protocol\n  /// @dev Deposits VaultCurrency in Protocol e.g USDC\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount in VaultCurrency to deposit\n  function depositInProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    if (getVaultBalance() < _amount) _amount = getVaultBalance();\n\n    if (protocol.underlying != address(vaultCurrency)) {\n      _amount = Swap.swapStableCoins(\n        Swap.SwapInOut(_amount, address(vaultCurrency), protocol.underlying),\n        uScale,\n        controller.underlyingUScale(protocol.underlying),\n        controller.getCurveParams(address(vaultCurrency), protocol.underlying)\n      );\n    }\n\n    IERC20(protocol.underlying).safeIncreaseAllowance(protocol.provider, _amount);\n    IProvider(protocol.provider).deposit(_amount, protocol.LPToken, protocol.underlying);\n  }\n\n  /// @notice Withdraw amount from underlying protocol\n  /// @dev shares = amount / PricePerShare\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount in VaultCurrency to withdraw\n  function withdrawFromProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    if (_amount <= 0) return;\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    _amount = (_amount * protocol.uScale) / uScale;\n    uint256 shares = IProvider(protocol.provider).calcShares(_amount, protocol.LPToken);\n    uint256 balance = IProvider(protocol.provider).balance(address(this), protocol.LPToken);\n\n    if (shares == 0) return;\n    if (balance < shares) shares = balance;\n\n    IERC20(protocol.LPToken).safeIncreaseAllowance(protocol.provider, shares);\n    uint256 amountReceived = IProvider(protocol.provider).withdraw(\n      shares,\n      protocol.LPToken,\n      protocol.underlying\n    );\n\n    if (protocol.underlying != address(vaultCurrency)) {\n      _amount = Swap.swapStableCoins(\n        Swap.SwapInOut(amountReceived, protocol.underlying, address(vaultCurrency)),\n        controller.underlyingUScale(protocol.underlying),\n        uScale,\n        controller.getCurveParams(protocol.underlying, address(vaultCurrency))\n      );\n    }\n  }\n\n  /// @notice Set total balance in VaultCurrency in all underlying protocols\n  function setTotalUnderlying() public {\n    uint totalUnderlying;\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n      totalUnderlying += balanceUnderlying(i);\n    }\n    savedTotalUnderlying = totalUnderlying;\n  }\n\n  /// @notice Get balance in VaultCurrency in underlying protocol\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @return Balance in VaultCurrency e.g USDC\n  function balanceUnderlying(uint256 _protocolNum) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    uint256 underlyingBalance = (IProvider(protocol.provider).balanceUnderlying(\n      address(this),\n      protocol.LPToken\n    ) * uScale) / protocol.uScale;\n    return underlyingBalance;\n  }\n\n  /// @notice Calculates how many shares are equal to the amount in vault currency\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _protocolNum, uint256 _amount) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    uint256 shares = IProvider(protocol.provider).calcShares(\n      (_amount * protocol.uScale) / uScale,\n      protocol.LPToken\n    );\n\n    return shares;\n  }\n\n  /// @notice Get price for underlying protocol\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @return protocolPrice Price per lp token\n  function price(uint256 _protocolNum) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    return IProvider(protocol.provider).exchangeRate(protocol.LPToken);\n  }\n\n  /// @notice Set the delta allocated tokens by game contract\n  /// @dev Allocation can be negative\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\n  /// @param _allocation Delta allocation in tokens\n  function setDeltaAllocationsInt(uint256 _protocolNum, int256 _allocation) internal {\n    require(!controller.getProtocolBlacklist(vaultNumber, _protocolNum), \"Protocol on blacklist\");\n    deltaAllocations[_protocolNum] += _allocation;\n    deltaAllocatedTokens += _allocation;\n  }\n\n  /// @notice Harvest extra tokens from underlying protocols\n  /// @dev Loops over protocols in ETF and check if they are claimable in controller contract\n  function claimTokens() public {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n      bool claim = controller.claim(vaultNumber, i);\n      if (claim) {\n        address govToken = controller.getGovToken(vaultNumber, i);\n        uint256 tokenBalance = IERC20(govToken).balanceOf(address(this));\n        Swap.swapTokensMulti(\n          Swap.SwapInOut(tokenBalance, govToken, address(vaultCurrency)),\n          controller.getUniswapParams(),\n          false\n        );\n      }\n    }\n  }\n\n  function getVaultBalance() public view returns (uint256) {\n    return vaultCurrency.balanceOf(address(this));\n  }\n\n  /// @notice Checks if a rebalance is needed based on the set interval\n  /// @return bool True of rebalance is needed, false if not\n  function rebalanceNeeded() public view returns (bool) {\n    return (block.timestamp - lastTimeStamp) > rebalanceInterval || msg.sender == guardian;\n  }\n\n  /// @notice Getter for dao address\n  function getDao() public view returns (address) {\n    return dao;\n  }\n\n  /// @notice Getter for guardian address\n  function getGuardian() public view returns (address) {\n    return guardian;\n  }\n\n  /*\n  Only Dao functions\n  */\n\n  /// @notice Set the performanceFee, the percentage of the yield that goes to the game players.\n  /// @dev The actual performanceFee could be a bit more or a bit less than the performanceFee set here due to approximations in the game.\n  /// @param _performanceFee Value at which to set the performanceFee.\n  function setPerformanceFee(uint256 _performanceFee) external onlyDao {\n    require(_performanceFee <= 100);\n    performanceFee = _performanceFee;\n  }\n\n  /// @notice Set the governance address\n  /// @param _dao New address of the governance / DAO\n  function setDao(address _dao) external onlyDao {\n    dao = _dao;\n  }\n\n  /// @notice Setter for guardian address\n  /// @param _guardian new address of the guardian\n  function setGuardian(address _guardian) external onlyDao {\n    guardian = _guardian;\n  }\n\n  /*\n  Only Guardian functions\n  */\n\n  /// @notice Set minimum interval for the rebalance function\n  /// @param _timestampInternal UNIX timestamp\n  function setRebalanceInterval(uint256 _timestampInternal) external onlyGuardian {\n    rebalanceInterval = _timestampInternal;\n  }\n\n  /// @notice The DAO should be able to blacklist protocols, the funds should be sent to the vault.\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\n  function blacklistProtocol(uint256 _protocolNum) external onlyGuardian {\n    uint256 balanceProtocol = balanceUnderlying(_protocolNum);\n    currentAllocations[_protocolNum] = 0;\n    controller.setProtocolBlacklist(vaultNumber, _protocolNum);\n    savedTotalUnderlying -= balanceProtocol;\n    withdrawFromProtocol(_protocolNum, balanceProtocol);\n  }\n\n  /// @notice Set the marginScale, the threshold used for deposits and withdrawals.\n  /// @notice If the threshold is not met the deposit/ withdrawal is not executed.\n  /// @dev Take into account the uScale (scale of the underlying).\n  /// @param _marginScale Value at which to set the marginScale.\n  function setMarginScale(int256 _marginScale) external onlyGuardian {\n    marginScale = _marginScale;\n  }\n\n  /// @notice Set the liquidityPerc, the amount of liquidity which should be held in the vault after rebalancing.\n  /// @dev The actual liquidityPerc could be a bit more or a bit less than the liquidityPerc set here.\n  /// @dev This is because some deposits or withdrawals might not execute because they don't meet the marginScale.\n  /// @param _liquidityPerc Value at which to set the liquidityPerc.\n  function setLiquidityPerc(uint256 _liquidityPerc) external onlyGuardian {\n    require(_liquidityPerc <= 100);\n    liquidityPerc = _liquidityPerc;\n  }\n\n  /// @notice callback to receive Ether from unwrapping WETH\n  receive() external payable {\n    require(msg.sender == Swap.WETH, \"Not WETH\");\n  }\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./Interfaces/IController.sol\";\nimport \"./Interfaces/IProvider.sol\";\n\nimport \"./VaultToken.sol\";\nimport \"./libraries/Swap.sol\";\n\ncontract Vault is ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  // state 0 Rebalance done and ready for xController to rebalance again\n  // state 1 Allocation amount received and ready to send funds over to xController\n  // state 2 Allocation amount 0 received => will receive funds from xController\n  // state 3 Allocation amount sent or received and ready to rebalance the vault itself\n  enum State {\n    Idle,\n    PushedUnderlying,\n    SendingFundsXChain,\n    WaitingForFunds,\n    RebalanceVault,\n    SendRewardsPerToken\n  }\n\n  IERC20 internal vaultCurrency;\n  IController internal controller;\n  State public state;\n\n  bool public deltaAllocationsReceived;\n\n  address private dao;\n  address private guardian;\n  address public vaultCurrencyAddr;\n  address public xController;\n\n  uint256 public vaultNumber;\n  uint256 public liquidityPerc;\n  uint256 public performanceFee;\n  uint256 public rebalancingPeriod;\n  uint256 public uScale;\n  uint256 public minimumPull;\n  int256 public marginScale;\n\n  // UNIX timestamp\n  uint256 public rebalanceInterval;\n  uint256 public lastTimeStamp;\n\n  // total underlying of all protocols in vault, excluding vault balance\n  uint256 public savedTotalUnderlying;\n\n  // total amount of funds the vault reserved for users that made a withdrawalRequest\n  uint256 internal reservedFunds;\n\n  // total number of allocated Derby tokens currently\n  int256 public totalAllocatedTokens;\n  // delta of the total number of Derby tokens allocated on next rebalancing\n  int256 private deltaAllocatedTokens;\n\n  string internal stateError = \"Wrong state\";\n\n  // (protocolNumber => currentAllocation): current allocations over the protocols\n  mapping(uint256 => int256) internal currentAllocations;\n\n  // (protocolNumber => deltaAllocation): delta of the portfolio on next rebalancing\n  mapping(uint256 => int256) internal deltaAllocations;\n\n  // historical reward per protocol per token, formula: TVL * yield * perfFee / totalLockedTokens\n  // (rebalancingPeriod => protocolId => rewardPerLockedToken)\n  mapping(uint256 => mapping(uint256 => int256)) public rewardPerLockedToken;\n\n  // (protocolNumber => lastPrice): last price of underlying protocol vault\n  mapping(uint256 => uint256) public lastPrices;\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"Vault: only DAO\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"only Guardian\");\n    _;\n  }\n\n  constructor(\n    uint256 _vaultNumber,\n    address _dao,\n    address _controller,\n    address _vaultCurrency,\n    uint256 _uScale\n  ) {\n    controller = IController(_controller);\n    vaultCurrency = IERC20(_vaultCurrency);\n\n    vaultNumber = _vaultNumber;\n    dao = _dao;\n    uScale = _uScale;\n    lastTimeStamp = block.timestamp;\n    minimumPull = 1_000_000;\n  }\n\n  /// @notice Withdraw from protocols on shortage in Vault\n  /// @dev Keeps on withdrawing until the Vault balance > _value\n  /// @param _value The total value of vaultCurrency an user is trying to withdraw.\n  /// @param _value The (value - current underlying value of this vault) is withdrawn from the underlying protocols.\n  function pullFunds(uint256 _value) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n\n      uint256 shortage = _value - vaultCurrency.balanceOf(address(this));\n      uint256 balanceProtocol = balanceUnderlying(i);\n\n      uint256 amountToWithdraw = shortage > balanceProtocol ? balanceProtocol : shortage;\n      savedTotalUnderlying -= amountToWithdraw;\n\n      if (amountToWithdraw < minimumPull) break;\n      withdrawFromProtocol(i, amountToWithdraw);\n\n      if (_value <= vaultCurrency.balanceOf(address(this))) break;\n    }\n  }\n\n  /// @notice Step 7 trigger, end; Vaults rebalance\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\n  /// @dev amountToProtocol = totalAmount * currentAllocation / totalAllocatedTokens\n  /// @dev amountToDeposit = amountToProtocol - currentBalanceProtocol\n  /// @dev if amountToDeposit < 0 => withdraw\n  /// @dev Execute all withdrawals before deposits\n  function rebalance() external nonReentrant {\n    require(state == State.RebalanceVault, stateError);\n    require(deltaAllocationsReceived, \"!Delta allocations\");\n\n    rebalancingPeriod++;\n\n    claimTokens();\n    settleDeltaAllocation();\n\n    uint256 underlyingIncBalance = calcUnderlyingIncBalance();\n    uint256[] memory protocolToDeposit = rebalanceCheckProtocols(underlyingIncBalance);\n\n    executeDeposits(protocolToDeposit);\n    setTotalUnderlying();\n\n    if (reservedFunds > vaultCurrency.balanceOf(address(this))) pullFunds(reservedFunds);\n\n    state = State.SendRewardsPerToken;\n    deltaAllocationsReceived = false;\n  }\n\n  /// @notice Helper to return underlying balance plus totalUnderlying - liquidty for the vault\n  /// @return underlying totalUnderlying - liquidityVault\n  function calcUnderlyingIncBalance() internal view returns (uint256) {\n    uint256 totalUnderlyingInclVaultBalance = savedTotalUnderlying +\n      getVaultBalance() -\n      reservedFunds;\n    uint256 liquidityVault = (totalUnderlyingInclVaultBalance * liquidityPerc) / 100;\n    return totalUnderlyingInclVaultBalance - liquidityVault;\n  }\n\n  /// @notice Adds deltaAllocatedTokens to totalAllocatedTokens\n  function settleDeltaAllocation() internal {\n    totalAllocatedTokens += deltaAllocatedTokens;\n    deltaAllocatedTokens = 0;\n  }\n\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\n  /// @dev Loops over all protocols in ETF, calculate new currentAllocation based on deltaAllocation\n  /// @dev Also calculate the performance fee here. This is an amount, based on the current TVL (before the rebalance),\n  /// @dev the performanceFee and difference between the current exchangeRate and the exchangeRate of the last rebalance of the vault.\n  /// @param _newTotalUnderlying this will be the new total underlying: Totalunderlying = TotalUnderlyingInProtocols - BalanceVault\n  /// @return uint256[] with amounts to deposit in protocols, the index being the protocol number.\n  function rebalanceCheckProtocols(\n    uint256 _newTotalUnderlying\n  ) internal returns (uint256[] memory) {\n    uint256[] memory protocolToDeposit = new uint[](controller.latestProtocolId(vaultNumber));\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      bool isBlacklisted = controller.getProtocolBlacklist(vaultNumber, i);\n\n      storePriceAndRewards(_newTotalUnderlying, i);\n\n      if (isBlacklisted) continue;\n      setAllocation(i);\n\n      int256 amountToProtocol = calcAmountToProtocol(_newTotalUnderlying, i);\n      uint256 currentBalance = balanceUnderlying(i);\n\n      int256 amountToDeposit = amountToProtocol - int(currentBalance);\n      uint256 amountToWithdraw = amountToDeposit < 0 ? currentBalance - uint(amountToProtocol) : 0;\n\n      if (amountToDeposit > marginScale) protocolToDeposit[i] = uint256(amountToDeposit);\n      if (amountToWithdraw > uint(marginScale) || currentAllocations[i] == 0)\n        withdrawFromProtocol(i, amountToWithdraw);\n    }\n\n    return protocolToDeposit;\n  }\n\n  /// @notice Calculates the amount to deposit or withdraw to protocol during a vault rebalance\n  /// @param _totalUnderlying Totalunderlying = TotalUnderlyingInProtocols - BalanceVault\n  /// @param _protocol Protocol id number\n  /// @return amountToProtocol amount to deposit or withdraw to protocol\n  function calcAmountToProtocol(\n    uint256 _totalUnderlying,\n    uint256 _protocol\n  ) internal view returns (int256 amountToProtocol) {\n    if (totalAllocatedTokens == 0) amountToProtocol = 0;\n    else\n      amountToProtocol =\n        (int(_totalUnderlying) * currentAllocations[_protocol]) /\n        totalAllocatedTokens;\n  }\n\n  /// @notice Stores the historical price and the reward per rounded locked token, ignoring decimals.\n  /// @dev formula yield protocol i at time t: y(it) = (P(it) - P(it-1)) / P(it-1).\n  /// @dev formula rewardPerLockedToken for protocol i at time t: r(it) = y(it) * TVL(t) * perfFee(t) / totalLockedTokens(t)\n  /// @dev later, when the total rewards are calculated for a game player we multiply this (r(it)) by the locked tokens on protocol i at time t\n  /// @param _totalUnderlying Totalunderlying = TotalUnderlyingInProtocols - BalanceVault.\n  /// @param _protocolId Protocol id number.\n  function storePriceAndRewards(uint256 _totalUnderlying, uint256 _protocolId) internal {\n    uint256 currentPrice = price(_protocolId);\n    if (lastPrices[_protocolId] == 0) {\n      lastPrices[_protocolId] = currentPrice;\n      return;\n    }\n\n    int256 priceDiff = int256(currentPrice - lastPrices[_protocolId]);\n    int256 nominator = (int256(_totalUnderlying * performanceFee) * priceDiff);\n    int256 totalAllocatedTokensRounded = totalAllocatedTokens / 1E18;\n    int256 denominator = totalAllocatedTokensRounded * int256(lastPrices[_protocolId]) * 100; // * 100 cause perfFee is in percentages\n\n    if (totalAllocatedTokensRounded == 0) {\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = 0;\n    } else {\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = nominator / denominator;\n    }\n\n    lastPrices[_protocolId] = currentPrice;\n  }\n\n  /// @notice Creates array out of the rewardsPerLockedToken mapping to send to the game\n  /// @return rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\n  function rewardsToArray() internal view returns (int256[] memory rewards) {\n    uint256 latestId = controller.latestProtocolId(vaultNumber);\n\n    rewards = new int[](latestId);\n    for (uint256 i = 0; i < latestId; i++) {\n      rewards[i] = rewardPerLockedToken[rebalancingPeriod][i];\n    }\n  }\n\n  /// @notice Helper function to set allocations\n  /// @param _i Protocol number linked to an underlying protocol e.g compound_usdc_01\n  function setAllocation(uint256 _i) internal {\n    currentAllocations[_i] += deltaAllocations[_i];\n    deltaAllocations[_i] = 0;\n    require(currentAllocations[_i] >= 0, \"Allocation underflow\");\n  }\n\n  /// @notice Helper function so the rebalance will execute all withdrawals first\n  /// @dev Executes and resets all deposits set in mapping(protocolToDeposit) by rebalanceETF\n  /// @param protocolToDeposit array with amounts to deposit in protocols, the index being the protocol number.\n  function executeDeposits(uint256[] memory protocolToDeposit) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      uint256 amount = protocolToDeposit[i];\n      if (amount == 0) continue;\n      depositInProtocol(i, amount);\n    }\n  }\n\n  /// @notice Deposit amount to underlying protocol\n  /// @dev Deposits VaultCurrency in Protocol e.g USDC\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount in VaultCurrency to deposit\n  function depositInProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    if (getVaultBalance() < _amount) _amount = getVaultBalance();\n\n    if (protocol.underlying != address(vaultCurrency)) {\n      _amount = Swap.swapStableCoins(\n        Swap.SwapInOut(_amount, address(vaultCurrency), protocol.underlying),\n        uScale,\n        controller.underlyingUScale(protocol.underlying),\n        controller.getCurveParams(address(vaultCurrency), protocol.underlying)\n      );\n    }\n\n    IERC20(protocol.underlying).safeIncreaseAllowance(protocol.provider, _amount);\n    IProvider(protocol.provider).deposit(_amount, protocol.LPToken, protocol.underlying);\n  }\n\n  /// @notice Withdraw amount from underlying protocol\n  /// @dev shares = amount / PricePerShare\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  //"
    }
  ]
}