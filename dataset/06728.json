{
  "Title": "[M-09] Unable to adjust position in some cases",
  "Content": "\nThe `adjust` function in `Position.sol` is designed to adjust the outstanding amount of ZCHF, the collateral amount, and the price in a single transaction.\nHowever, there are certain cases where this function always reverts.\nAssuming the new price is greater than the current price, if the value of `newCollateral` is less than `colbal` or the value of `newMinted` is greater than `minted`, the `adjust` function will always revert with a customized error message reading `Hot`.\n\n### Proof of Concept\n\nIf the value of `newPrice` is great than value of `price`, the `restrictMinting` function is triggered.\nIn this case, if the value of `cooldown` exceeds `block.timestamp` + 3 days, `cooldown` will be update to `block.timestamp + 3 days`, therefore, both the `withdrawCollateral` and `mint` functions will be reverted with custom error because of `noCooldown` modifier. <br><https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Position.sol#L132-L152> <br><https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Position.sol#L159-L167>\n\nI will share the test code\n\n    it(\"Will revert adjest tx when newPrice is greater than prevPrice\", async () => {\n        let collateral = mockVOL.address;\n        let fliqPrice = floatToDec18(1000);\n        let minCollateral = floatToDec18(1);\n        let fInitialCollateral = floatToDec18(initialCollateral);\n        let duration = BN.from(14*86_400);\n        let fFees = BN.from(fee * 1000_000);\n        let fReserve = BN.from(reserve * 1000_000);\n        let openingFeeZCHF = await mintingHubContract.OPENING_FEE();\n        let challengePeriod = BN.from(7 * 86400); // 7 days\n        await mockVOL.connect(accounts[0]).approve(mintingHubContract.address, fInitialCollateral);\n        let balBefore = await ZCHFContract.balanceOf(owner);\n        let balBeforeVOL = await mockVOL.balanceOf(owner);\n        let tx = await mintingHubContract[\"openPosition(address,uint256,uint256,uint256,uint256,uint256,uint32,uint256,uint32)\"]\n            (collateral, minCollateral, fInitialCollateral, initialLimit, duration, challengePeriod, fFees, fliqPrice, fReserve);\n        let rc = await tx.wait();\n        const topic = '0x591ede549d7e337ac63249acd2d7849532b0a686377bbf0b0cca6c8abd9552f2'; // PositionOpened\n        const log = rc.logs.find(x => x.topics.indexOf(topic) >= 0);\n        positionAddr = log.address;\n        let balAfter = await ZCHFContract.balanceOf(owner);\n        let balAfterVOL = await mockVOL.balanceOf(owner);\n        let dZCHF = dec18ToFloat(balAfter.sub(balBefore));\n        let dVOL = dec18ToFloat(balAfterVOL.sub(balBeforeVOL));\n        expect(dVOL).to.be.equal(-initialCollateral);\n        expect(dZCHF).to.be.equal(-dec18ToFloat(openingFeeZCHF));\n        positionContract = await ethers.getContractAt('Position', positionAddr, accounts[0]);\n\n        console.log(\"price:\",await positionContract.price());\n        console.log(\"minted:\",await positionContract.minted());\n        await ethers.provider.send('evm_increaseTime', [7 * 86_400 + 60]); \n        await ethers.provider.send(\"evm_mine\");\n\n        let erx = positionContract.adjust(1, floatToDec18(8), floatToDec18(1200))\n        await expect(erx).to.be.revertedWithCustomError(positionContract, \"Hot\");\n\n        console.log(\"price:\",await positionContract.price());\n        console.log(\"minted:\",await positionContract.minted());\n    });\n\n### Recommended Mitigation Steps\n\nTo solve this problem, we can modify the \"adjust\" function like this;\n\n    function adjust(uint256 newMinted, uint256 newCollateral, uint256 newPrice) public onlyOwner {\n        uint256 colbal = collateralBalance();\n        if (newCollateral > colbal){\n            collateral.transferFrom(msg.sender, address(this), newCollateral - colbal);\n        }\n        // Must be called after collateral deposit, but before withdrawal\n        if (newMinted < minted){\n            zchf.burnFrom(msg.sender, minted - newMinted, reserveContribution);\n            minted = newMinted;\n        }\n        if (newCollateral < colbal){\n            withdrawCollateral(msg.sender, colbal - newCollateral);\n        }\n        // Must be called after collateral withdrawal\n        if (newMinted > minted){\n            mint(msg.sender, newMinted - minted);\n        }\n\n        if (newPrice != price){\n            adjustPrice(newPrice);\n        }\n    }\n\n**[0xA5DF (lookout) commented](https://github.com/code-423n4/2023-04-frankencoin-findings/issues/454#issuecomment-1518734040):**\n > Might be a design choice, need sponsor's input on this one.\n\n**[luziusmeisser (Frankencoin) confirmed and commented](https://github.com/code-423n4/2023-04-frankencoin-findings/issues/454#issuecomment-1532504703):**\n > I wouldn't call this a 'vulnerability' but convenience is definitely improved by the recommended mitigation.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-frankencoin",
  "Code": [
    {
      "filename": "contracts/Position.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IPosition.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\nimport \"./Ownable.sol\";\nimport \"./MathUtil.sol\";\n\n/**\n * A collateralized minting position.\n */\ncontract Position is Ownable, IPosition, MathUtil {\n\n    /**\n     * Note that this contract is intended to be cloned. All clones will share the same values for\n     * the constant and immutable fields, but have their own values for the other fields.\n     */\n\n    uint256 public price; // the zchf price per unit of the collateral below which challenges succeed, (36 - collateral.decimals) decimals\n    uint256 public minted; // net minted amount, including reserve\n    uint256 public challengedAmount; // amount of the collateral that is currently under a challenge\n    uint256 public immutable challengePeriod; // challenge period in seconds\n\n    uint256 public cooldown; // timestamp of the end of the latest cooldown\n    uint256 public limit; // the minted amount must never exceed the limit\n\n    uint256 public immutable start; // timestamp when minting can start\n    uint256 public immutable expiration; // timestamp at which the position expires\n\n    address public immutable original; // originals point to themselves, clone to their origin\n    address public immutable hub; // the hub this position was created by\n    IFrankencoin public immutable zchf; // currency\n    IERC20 public override immutable collateral; // collateral\n    uint256 public override immutable minimumCollateral; // prevent dust amounts\n\n    uint32 public immutable mintingFeePPM;\n    uint32 public immutable reserveContribution; // in ppm\n\n    event PositionOpened(address indexed owner, address original, address zchf, address collateral, uint256 price);\n    event MintingUpdate(uint256 collateral, uint256 price, uint256 minted, uint256 limit);\n    event PositionDenied(address indexed sender, string message); // emitted if closed by governance\n\n    error InsufficientCollateral();\n\n    /**\n    * See MintingHub.openPosition\n    */\n    constructor(address _owner, address _hub, address _zchf, address _collateral, \n        uint256 _minCollateral, uint256 _initialLimit, uint256 initPeriod, uint256 _duration,\n        uint256 _challengePeriod, uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reservePPM) {\n        require(initPeriod >= 3 days); // must be at least three days, recommended to use higher values\n        setOwner(_owner);\n        original = address(this);\n        hub = _hub;\n        price = _liqPrice;\n        zchf = IFrankencoin(_zchf);\n        collateral = IERC20(_collateral);\n        mintingFeePPM = _mintingFeePPM;\n        reserveContribution = _reservePPM;\n        minimumCollateral = _minCollateral;\n        challengePeriod = _challengePeriod;\n        start = block.timestamp + initPeriod; // one week time to deny the position\n        cooldown = start;\n        expiration = start + _duration;\n        limit = _initialLimit;\n        \n        emit PositionOpened(_owner, original, _zchf, address(collateral), _liqPrice);\n    }\n\n    /**\n     * Method to initialize a freshly created clone. It is the responsibility of the creator to make sure this is only\n     * called once and to call reduceLimitForClone on the original position before initializing the clone.\n     */\n    function initializeClone(address owner, uint256 _price, uint256 _limit, uint256 _coll, uint256 _mint) external onlyHub {\n        if(_coll < minimumCollateral) revert InsufficientCollateral();\n        setOwner(owner);\n        \n        price = _mint * ONE_DEC18 / _coll;\n        if (price > _price) revert InsufficientCollateral();\n        limit = _limit;\n        mintInternal(owner, _mint, _coll);\n\n        emit PositionOpened(owner, original, address(zchf), address(collateral), _price);\n    }\n\n    /**\n     * Adjust this position's limit to give away half of the remaining limit to the clone.\n     * Invariant: global limit stays the same.\n     *\n     * Cloning a position is only allowed if the position is not challenged, not expired and not in cooldown.\n     *\n     * @param _minimum amount that clone wants to mint initially\n     * @return limit for the clone\n     */\n    function reduceLimitForClone(uint256 _minimum) external noChallenge noCooldown alive onlyHub returns (uint256) {\n        uint256 reduction = (limit - minted - _minimum)/2; // this will fail with an underflow if minimum is too high\n        limit -= reduction + _minimum;\n        return reduction + _minimum;\n    }\n\n    error TooLate();\n    error NotQualified();\n\n    /**\n     * Qualified pool share holders can call this method to immediately expire a freshly proposed position.\n     */ \n    function deny(address[] calldata helpers, string calldata message) public {\n        if (block.timestamp >= start) revert TooLate();\n        IReserve(zchf.reserve()).checkQualified(msg.sender, helpers);\n        cooldown = expiration; // since expiration is immutable, we put it under cooldown until the end\n        emit PositionDenied(msg.sender, message);\n    }\n\n    /**\n     * This is how much the minter can actually use when minting ZCHF, with the rest being used\n     * to buy reserve pool shares.\n     */\n    function getUsableMint(uint256 totalMint, bool afterFees) public view returns (uint256){\n        if (afterFees){\n            return totalMint * (1000_000 - reserveContribution - calculateCurrentFee()) / 1000_000;\n        } else {\n            return totalMint * (1000_000 - reserveContribution) / 1000_000;\n        }\n    }\n\n    /**\n     * \"All in one\" function to adjust the outstanding amount of ZCHF, the collateral amount, \n     * and the price in one transaction.\n     */\n    function adjust(uint256 newMinted, uint256 newCollateral, uint256 newPrice) public onlyOwner {\n        if (newPrice != price){\n            adjustPrice(newPrice);\n        }\n        uint256 colbal = collateralBalance();\n        if (newCollateral > colbal){\n            collateral.transferFrom(msg.sender, address(this), newCollateral - colbal);\n        }\n        // Must be called after collateral deposit, but before withdrawal\n        if (newMinted < minted){\n            zchf.burnFrom(msg.sender, minted - newMinted, reserveContribution);\n            minted = newMinted;\n        }\n        if (newCollateral < colbal){\n            withdrawCollateral(msg.sender, colbal - newCollateral);\n        }\n        // Must be called after collateral withdrawal\n        if (newMinted > minted){\n            mint(msg.sender, newMinted - minted);\n        }\n    }\n\n    /**\n     * Allows the position owner to adjust the liquidation price as long as there is no pending challenge.\n     * Lowering the liquidation price can be done with immediate effect, given that there is enough collateral.\n     * Increasing the liquidation price triggers a cooldown period of 3 days, during which minting is suspended.\n     */\n    function adjustPrice(uint256 newPrice) public onlyOwner noChallenge {\n        if (newPrice > price) {\n            restrictMinting(3 days);\n        } else {\n            checkCollateral(collateralBalance(), newPrice);\n        }\n        price = newPrice;\n        emitUpdate();\n    }\n\n    function collateralBalance() internal view returns (uint256){\n        return IERC20(collateral).balanceOf(address(this));\n    }\n\n    /**\n     * Mint ZCHF as long as there is no open challenge, the position is not subject to a cooldown,\n     * and there is sufficient collateral.\n     */\n    function mint(address target, uint256 amount) public onlyOwner noChallenge noCooldown alive {\n       mintInternal(target, amount, collateralBalance());\n    }\n\n    function calculateCurrentFee() public view returns (uint32) {\n        uint256 exp = expiration;\n        uint256 time = block.timestamp;\n        if (time >= exp){\n            return 0;\n        } else {\n            return uint32(mintingFeePPM - mintingFeePPM * (time - start) / (exp - start));\n        }\n    }\n\n    error LimitExceeded();\n\n    function mintInternal(address target, uint256 amount, uint256 collateral_) internal {\n        if (minted + amount > limit) revert LimitExceeded();\n        zchf.mint(target, amount, reserveContribution, calculateCurrentFee());\n        minted += amount;\n\n        checkCollateral(collateral_, price);\n        emitUpdate();\n    }\n\n    function restrictMinting(uint256 period) internal {\n        uint256 horizon = block.timestamp + period;\n        if (horizon > cooldown){\n            cooldown = horizon;\n        }\n    }\n    \n    /**\n     * Repay some ZCHF. Requires an allowance to be in place. If too much is repaid, the call fails.\n     * It is possible to repay while there are challenges, but the collateral is locked until all is clear again.\n     *\n     * The repaid amount should fulfill the following equation in order to close the position, i.e. bring the minted amount to 0:\n     * minted = amount + zchf.calculateAssignedReserve(amount, reservePPM)\n     *\n     * Under normal circumstances, this implies:\n     * amount = minted * (1000000 - reservePPM)\n     *\n     * For example, if minted is 50 and reservePPM is 200000, it is necessary to repay 40 to be able to close the position.\n     *\n     * Only the owner is allowed to repay a position. This is necessary to prevent a 'limit stealing attack': if a popular position\n     * has reached its limit, an attacker could try to repay the position, clone it, and take a loan himself. This is prevented by\n     * requiring the owner to do the repayment. Other restrictions are not necessary. In particular, it must be possible to repay\n     * the position once it is expired or subject to cooldown. Also, repaying it during a challenge is no problem as the collateral\n     * remains present.\n     */\n    function repay(uint256 amount) public onlyOwner {\n        IERC20(zchf).transferFrom(msg.sender, address(this), amount);\n        repayInternal(amount);\n    }\n\n    function repayInternal(uint256 burnable) internal {\n        uint256 actuallyBurned = IFrankencoin(zchf).burnWithReserve(burnable, reserveContribution);\n        notifyRepaidInternal(actuallyBurned);\n        emitUpdate();\n    }\n\n    error RepaidTooMuch(uint256 excess);\n\n    function notifyRepaidInternal(uint256 amount) internal {\n        if (amount > minted) revert RepaidTooMuch(amount - minted);\n        minted -= amount;\n    }\n\n    /**\n     * Withdraw any ERC20 token that might have ended up on this address.\n     * Withdrawing collateral is subject to the same restrictions as withdrawCollateral(...).\n     */\n    function withdraw(address token, address target, uint256 amount) external onlyOwner {\n        if (token == address(collateral)){\n            withdrawCollateral(target, amount);\n        } else {\n            IERC20(token).transfer(target, amount);\n        }\n    }\n\n    /**\n     * Withdraw collateral from the position up to the extent that it is still well collateralized afterwards.\n     * Not possible as long as there is an open challenge or the contract is subject to a cooldown.\n     *\n     * Withdrawing collateral below the minimum collateral amount formally closes the position.\n     */\n    function withdrawCollateral(address target, uint256 amount) public onlyOwner noChallenge noCooldown {\n        uint256 balance = internalWithdrawCollateral(target, amount);\n        checkCollateral(balance, price);\n    }\n\n    function internalWithdrawCollateral(address target, uint256 amount) internal returns (uint256) {\n        IERC20(collateral).transfer(target, amount);\n        uint256 balance = collateralBalance();\n        if (balance < minimumCollateral){\n            cooldown = expiration;\n        }\n        emitUpdate();\n        return balance;\n    }\n\n    /**\n     * This invariant must always hold and must always be checked when any of the three\n     * variables change in an adverse way.\n     */\n    function checkCollateral(uint256 collateralReserve, uint256 atPrice) internal view {\n        if (collateralReserve * atPrice < minted * ONE_DEC18) revert InsufficientCollateral();\n    }\n\n    function emitUpdate() internal {\n        emit MintingUpdate(collateralBalance(), price, minted, limit);\n    }\n\n    error ChallengeTooSmall();\n\n    function notifyChallengeStarted(uint256 size) external onlyHub {\n        // require minimum size, note that collateral balance can be below minimum if it was partially challenged before\n        if (size < minimumCollateral && size < collateralBalance()) revert ChallengeTooSmall();\n        challengedAmount += size;\n    }\n\n    /**\n     * @notice check whether challenge can be averted\n     * @param _collateralAmount   amount of collateral challenged (dec18)\n     * @param _bidAmountZCHF      bid amount in ZCHF (dec18)\n     * @return true if challenge can be averted\n     */\n    function tryAvertChallenge(uint256 _collateralAmount, uint256 _bidAmountZCHF) external onlyHub returns (bool) {\n        if (block.timestamp >= expiration){\n            return false; // position expired, let every challenge succeed\n        } else if (_bidAmountZCHF * ONE_DEC18 >= price * _collateralAmount){\n            // challenge averted, bid is high enough\n            challengedAmount -= _collateralAmount;\n            // Don't allow minter to close the position immediately so challenge can be repeated before\n            // the owner has a chance to mint more on an undercollateralized position\n            restrictMinting(1 days);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Notifies the position that a challenge was successful.\n     * Triggers the payout of the challenged part of the collateral.\n     * Everything else is assumed to be handled by the hub.\n     *\n     * @param _bidder   address of the bidder that receives the collateral\n     * @param _bid      bid amount in ZCHF (dec18)\n     * @param _size     size of the collateral bid for (dec 18)\n     * @return (position owner, effective bid size in ZCHF, effective challenge size in ZCHF, repaid amount, reserve ppm)\n     */\n    function notifyChallengeSucceeded(address _bidder, uint256 _bid, uint256 _size) external onlyHub returns (address, uint256, uint256, uint256, uint32) {\n        challengedAmount -= _size;\n        uint256 colBal = collateralBalance();\n        if (_size > colBal){\n            // Challenge is larger than the position. This can for example happen if there are multiple concurrent\n            // challenges that exceed the collateral balance in size. In this case, we need to redimension the bid and\n            // tell the caller that a part of the bid needs to be returned to the bidder.\n            _bid = _divD18(_mulD18(_bid, colBal), _size);\n            _size = colBal;\n        }\n\n        // Note that thanks to the collateral invariant, we know that\n        //    colBal * price >= minted * ONE_DEC18\n        // and that therefore\n        //    price >= minted / colbal * E18\n        // such that\n        //    volumeZCHF = price * size / E18 >= minted * size / colbal\n        // So the owner cannot maliciously decrease the price to make volume fall below the proportionate repayment.\n        uint256 volumeZCHF = _mulD18(price, _size); // How much could have minted with the challenged amount of the collateral\n        // The owner does not have to repay (and burn) more than the owner actually minted.  \n        uint256 repayment = minted < volumeZCHF ? minted : volumeZCHF; // how much must be burned to make things even\n\n        notifyRepaidInternal(repayment); // we assume the caller takes care of the actual repayment\n        internalWithdrawCollateral(_bidder, _size); // transfer collateral to the bidder and emit update\n        return (owner, _bid, volumeZCHF, repayment, reserveContribution);\n    }\n\n    /**\n     * A position should only be considered 'closed', once its collateral has been withdrawn.\n     * This is also a good creterion when deciding whether it should be shown in a frontend.\n     */\n    function isClosed() public view returns (bool) {\n        return collateralBalance() < minimumCollateral;\n    }\n\n    error Expired();\n\n    modifier alive() {\n        if (block.timestamp > expiration) revert Expired();\n        _;\n    }\n\n    error Hot();\n\n    modifier noCooldown() {\n        if (block.timestamp <= cooldown) revert Hot();\n        _;\n    }\n\n    error Challenged();\n\n    modifier noChallenge() {\n        if (challengedAmount > 0) revert Challenged();\n        _;\n    }\n\n    error NotHub();\n\n    modifier onlyHub() {\n        if (msg.sender != address(hub)) revert NotHub();\n        _;\n    }\n\n}"
    }
  ]
}