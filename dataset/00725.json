{
  "Title": "[L-10] Do not hardcode `_payInZRO` to false when estimating layerZero fees",
  "Content": "The [LayerZero integration checklist](https://layerzero.gitbook.io/docs/troubleshooting/layerzero-integration-checklist) says:\n\n> \"Do not hardcode useZro to false when estimating fees and sending messages. Pass it as a parameter instead.\"\n\nBut in [`StargateLbpHelper.sol`](https://github.com/Tapioca-DAO/tapioca-periph/blob/73313d5ff9241f7a584284eb6c006339b7f70314/contracts/StargateLbpHelper.sol#L111), `_payInZRO` is hardcoded to `false`:\n\n```solidity\n endpoint.estimateFees(\n                _dstChainId,\n                address(bridge),\n                payload,\n                false,\n                _txParamBuilder(_dstChainId, _functionType, _lzTxParams)\n            );\n```\n\nRemove the hardcoded `false` and pass it as a parameter instead, even if the intended usage is to always use `false`\n\n```diff\n endpoint.estimateFees(\n                _dstChainId,\n                address(bridge),\n                payload,\n+                _payInZRO,\n-                false,\n                _txParamBuilder(_dstChainId, _functionType, _lzTxParams)\n            );\n```",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/StargateLbpHelper.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport \"./interfaces/IBalancerVault.sol\";\nimport \"./interfaces/IStargateRouter.sol\";\nimport \"./interfaces/ILiquidityBootstrappingPool.sol\";\nimport \"./interfaces/IStargateLbpHelper.sol\";\n\n//OZ\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract StargateLbpHelper is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    struct StargateData {\n        address srcToken;\n        address targetToken;\n        uint16 dstChainId;\n        address peer; // StargateLbpHelper address on destination\n        address receiver; // Receiver address on destination\n        uint256 amount;\n        uint256 slippage;\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        bool getDust;\n        uint256 dstAirdropAmount;\n        uint256 dstGasLimit;\n    }\n    struct ParticipateData {\n        address assetIn;\n        address assetOut;\n        uint256 deadline;\n        uint256 minAmountOut;\n    }\n\n    /// @notice Stargate router address\n    IStargateRouter public immutable router;\n    /// @notice LBP pool address\n    ILiquidityBootstrappingPool public immutable lbpPool;\n    /// @notice LBP vault address\n    IBalancerVault public immutable lbpVault;\n\n    uint256 private constant SLIPPAGE_PRECISION = 1e5;\n\n    uint8 internal constant PARTICIPATE_FN = 1;\n    event ReceiveFailed(\n        uint16 indexed srcChainId,\n        address indexed token,\n        uint256 indexed nonce,\n        uint256 amountLD,\n        bytes payload\n    );\n    event ReceiveSuccess(\n        uint16 indexed srcChainId,\n        address indexed token,\n        uint256 indexed nonce,\n        uint256 amountLD,\n        bytes payload\n    );\n\n    // ************************ //\n    // *** ERRORS FUNCTIONS *** //\n    // ************************ //\n    error NoContract();\n    error RouterNotValid();\n    error NotAuthorized();\n    error BalanceTooLow();\n    error TokensMismatch();\n    error UnsupportedFunctionType();\n\n    constructor(address _router, address _lbpPool, address _vault) {\n        if (_router == address(0)) revert RouterNotValid();\n        router = IStargateRouter(_router);\n        lbpPool = ILiquidityBootstrappingPool(_lbpPool); // address(0) for non-host chains\n        lbpVault = IBalancerVault(_vault); // address(0) for non-host chains\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    function quoteLayerZeroFee(\n        uint16 _dstChainId,\n        uint8 _functionType,\n        bytes calldata _toAddress,\n        bytes calldata,\n        IStargateRouter.lzTxObj memory _lzTxParams\n    ) external view returns (uint256, uint256) {\n        bytes memory payload = \"\";\n        if (_functionType == PARTICIPATE_FN) {\n            ParticipateData memory participateData = ParticipateData({\n                assetIn: address(0),\n                assetOut: address(0),\n                deadline: block.timestamp,\n                minAmountOut: 0\n            });\n            payload = abi.encode(participateData, _toAddress);\n        } else {\n            revert UnsupportedFunctionType();\n        }\n\n        IStargateBridge bridge = router.bridge();\n        ILayerZeroEndpoint endpoint = bridge.layerZeroEndpoint();\n        return\n            endpoint.estimateFees(\n                _dstChainId,\n                address(bridge),\n                payload,\n                false,\n                _txParamBuilder(_dstChainId, _functionType, _lzTxParams)\n            );\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice sends token to another layer using Stargate to participate in the LBP\n    /// @param stargateData Stargate operation related data; see `StargateData` struct\n    /// @param lbpData LBP related data; see 'ParticipateData' struct\n    function participate(\n        StargateData calldata stargateData,\n        ParticipateData calldata lbpData\n    ) external payable nonReentrant {\n        IERC20 erc20 = IERC20(stargateData.srcToken);\n\n        // retrieve source token from sender\n        erc20.safeTransferFrom(msg.sender, address(this), stargateData.amount);\n\n        // compute min amount to be received on destination\n        uint256 amountWithSlippage = stargateData.amount -\n            ((stargateData.amount * stargateData.slippage) /\n                SLIPPAGE_PRECISION);\n\n        // approve token for Stargate router\n        _safeApprove(address(erc20), address(router), stargateData.amount);\n\n        // send over to another layer using the Stargate router\n        uint256 balanceBefore = IERC20(stargateData.srcToken).balanceOf(\n            address(this)\n        );\n        router.swap{value: msg.value}(\n            stargateData.dstChainId,\n            stargateData.srcPoolId,\n            stargateData.dstPoolId,\n            payable(msg.sender), //refund address\n            stargateData.amount,\n            amountWithSlippage,\n            IStargateRouterBase.lzTxObj({\n                dstGasForCall: stargateData.dstGasLimit,\n                dstNativeAmount: stargateData.dstAirdropAmount,\n                dstNativeAddr: abi.encodePacked(stargateData.peer)\n            }),\n            abi.encodePacked(stargateData.peer), // StargateLbpHelper.sol destination address\n            abi.encode(lbpData, stargateData.receiver)\n        );\n\n        // check dust and send it back to the user\n        uint256 balanceAfter = IERC20(stargateData.srcToken).balanceOf(\n            address(this)\n        );\n        uint256 transferred = balanceAfter - balanceBefore;\n        if (transferred < stargateData.amount && stargateData.getDust) {\n            IERC20(stargateData.srcToken).transfer(\n                msg.sender,\n                stargateData.amount - transferred\n            );\n        }\n    }\n\n    /// @notice receive call for Stargate\n    function sgReceive(\n        uint16 srcChainId, // the remote chainId sending the tokens\n        bytes memory, // the remote Bridge address\n        uint256 nonce,\n        address token, // the token contract on the local chain\n        uint256 amountLD, // the qty of local _token contract tokens\n        bytes memory payload\n    ) external {\n        if (msg.sender != address(router)) revert NotAuthorized();\n        // will just ignore the payload in some invalid configuration\n        if (payload.length <= 40) return; // 20 + 20 + payload\n\n        try\n            IStargateLbpHelper(address(this))._sgReceive(\n                token,\n                amountLD,\n                payload\n            )\n        {\n            emit ReceiveSuccess(srcChainId, token, nonce, amountLD, payload);\n        } catch {\n            emit ReceiveFailed(srcChainId, token, nonce, amountLD, payload);\n            // decode payload\n            (, address receiver) = abi.decode(\n                payload,\n                (ParticipateData, address)\n            );\n            IERC20(token).safeTransfer(receiver, amountLD);\n        }\n    }\n\n    function _sgReceive(\n        address token, // the token contract on the local chain\n        uint256 amountLD, // the qty of local _token contract tokens\n        bytes memory payload\n    ) external {\n        if (msg.sender != address(this)) revert NotAuthorized();\n\n        // decode payload\n        (ParticipateData memory data, address receiver) = abi.decode(\n            payload,\n            (ParticipateData, address)\n        );\n        if (token != data.assetIn) revert TokensMismatch();\n\n        // check token's balance\n        uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n        if (tokenBalance < amountLD) revert BalanceTooLow();\n\n        // create lbp join params\n        IBalancerVault.SingleSwap memory singleSwap = IBalancerVault\n            .SingleSwap({\n                poolId: lbpPool.getPoolId(),\n                kind: IBalancerVault.SwapKind.GIVEN_IN, //0\n                assetIn: IAsset(data.assetIn),\n                assetOut: IAsset(data.assetOut),\n                amount: amountLD,\n                userData: \"0x\"\n            });\n\n        IBalancerVault.FundManagement memory fundManagement = IBalancerVault\n            .FundManagement({\n                sender: address(this),\n                recipient: payable(receiver),\n                fromInternalBalance: false,\n                toInternalBalance: false\n            });\n\n        // participate in the lbp\n        _safeApprove(data.assetIn, address(lbpVault), amountLD);\n        lbpVault.swap(\n            singleSwap,\n            fundManagement,\n            data.minAmountOut,\n            (data.deadline != 0 ? data.deadline : block.timestamp)\n        );\n    }\n\n    receive() external payable {}\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    function retryRevert(\n        uint16 srcChainId,\n        bytes calldata srcAddress,\n        uint256 nonce\n    ) external payable onlyOwner {\n        router.retryRevert{value: msg.value}(srcChainId, srcAddress, nonce);\n    }\n\n    function instantRedeemLocal(\n        uint16 _srcPoolId,\n        uint256 _amountLP,\n        address _to\n    ) external onlyOwner returns (uint256 amountSD) {\n        amountSD = router.instantRedeemLocal(_srcPoolId, _amountLP, _to);\n    }\n\n    function redeemLocal(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        uint256 _amountLP,\n        bytes calldata _to,\n        IStargateRouter.lzTxObj memory _lzTxParams\n    ) external payable onlyOwner {\n        router.redeemLocal{value: msg.value}(\n            _dstChainId,\n            _srcPoolId,\n            _dstPoolId,\n            _refundAddress,\n            _amountLP,\n            _to,\n            _lzTxParams\n        );\n    }\n\n    function redeemRemote(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        uint256 _amountLP,\n        uint256 _minAmountLD,\n        bytes calldata _to,\n        IStargateRouter.lzTxObj memory _lzTxParams\n    ) external payable onlyOwner {\n        router.redeemRemote{value: msg.value}(\n            _dstChainId,\n            _srcPoolId,\n            _dstPoolId,\n            _refundAddress,\n            _amountLP,\n            _minAmountLD,\n            _to,\n            _lzTxParams\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _safeApprove(address token, address to, uint256 value) internal {\n        if (token.code.length == 0) revert NoContract();\n        bool success;\n        bytes memory data;\n        (success, data) = token.call(abi.encodeCall(IERC20.approve, (to, 0)));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"StargateLbpHelper::safeApprove: approve failed\"\n        );\n\n        (success, data) = token.call(\n            abi.encodeCall(IERC20.approve, (to, value))\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"StargateLbpHelper::safeApprove: approve failed\"\n        );\n    }\n\n    function _txParamBuilder(\n        uint16 _chainId,\n        uint8 _type,\n        IStargateRouter.lzTxObj memory _lzTxParams\n    ) private view returns (bytes memory) {\n        bytes memory lzTxParam;\n        address dstNativeAddr;\n        {\n            bytes memory dstNativeAddrBytes = _lzTxParams.dstNativeAddr;\n            assembly {\n                dstNativeAddr := mload(add(dstNativeAddrBytes, 20))\n            }\n        }\n\n        uint256 totalGas = router.bridge().gasLookup(_chainId, _type) +\n            _lzTxParams.dstGasForCall;\n        if (_lzTxParams.dstNativeAmount > 0 && dstNativeAddr != address(0x0)) {\n            lzTxParam = abi.encodePacked(\n                uint16(2),\n                totalGas,\n                _lzTxParams.dstNativeAmount,\n                _lzTxParams.dstNativeAddr\n            );\n        } else {\n            lzTxParam = abi.encodePacked(uint16(1), totalGas);\n        }\n\n        return lzTxParam;\n    }\n}"
    }
  ]
}