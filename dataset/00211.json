{
  "Title": "Incomplete Docstrings",
  "Content": "Throughout the [codebase](https://github.com/Ion-Protocol/ion-protocol/tree/0a8c0d22106c4c4b9c3528cd5d4bdf55d08d7fbf) there are several parts that have incomplete docstrings. For instance:\n\n\n* The [`getPrice` function](https://github.com/Ion-Protocol/ion-protocol/blob/0a8c0d22106c4c4b9c3528cd5d4bdf55d08d7fbf/src/oracles/spot/lrt/EzEthWstEthSpotOracle.sol#L45-L64) in [`EzEthWstEthSpotOracle.sol`](https://github.com/Ion-Protocol/ion-protocol/blob/0a8c0d22106c4c4b9c3528cd5d4bdf55d08d7fbf/src/oracles/spot/lrt/EzEthWstEthSpotOracle.sol) the return value is partially documented\n* The [`flashswapAndMint` function](https://github.com/Ion-Protocol/ion-protocol/blob/0a8c0d22106c4c4b9c3528cd5d4bdf55d08d7fbf/src/flash/UniswapFlashswapDirectMintHandlerWithDust.sol#L99-L112) in [`UniswapFlashswapDirectMintHandlerWithDust.sol`](https://github.com/Ion-Protocol/ion-protocol/blob/0a8c0d22106c4c4b9c3528cd5d4bdf55d08d7fbf/src/flash/UniswapFlashswapDirectMintHandlerWithDust.sol) the `deadline` parameter is not documented.\n\n\nConsider thoroughly documenting all functions/events (and their parameters or return values) that are part of any contract's public API. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/latest/natspec-format.html) (NatSpec).\n\n\n***Update:** Resolved in [pull request #76](https://github.com/Ion-Protocol/ion-protocol/pull/76).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/oracles/spot/lrt/EzEthWstEthSpotOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { SpotOracle } from \"../SpotOracle.sol\";\nimport { WadRayMath } from \"../../../libraries/math/WadRayMath.sol\";\nimport {\n    WSTETH_ADDRESS,\n    REDSTONE_EZETH_ETH_PRICE_FEED,\n    ETH_PER_STETH_CHAINLINK,\n    REDSTONE_DECIMALS\n} from \"../../../Constants.sol\";\nimport { IWstEth } from \"../../../interfaces/ProviderInterfaces.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * @notice The ezETH spot oracle denominated in wstETH\n *\n * @custom:security-contact security@molecularlabs.io\n */\ncontract EzEthWstEthSpotOracle is SpotOracle {\n    using WadRayMath for uint256;\n    using SafeCast for int256;\n\n    uint256 public immutable MAX_TIME_FROM_LAST_UPDATE; // seconds\n\n    /**\n     * @notice Creates a new `EzEthWstEthSpotOracle` instance.\n     * @param _ltv The loan to value ratio for ezETH <> wstETH\n     * @param _reserveOracle The associated reserve oracle.\n     */\n    constructor(\n        uint256 _ltv,\n        address _reserveOracle,\n        uint256 _maxTimeFromLastUpdate\n    )\n        SpotOracle(_ltv, _reserveOracle)\n    {\n        MAX_TIME_FROM_LAST_UPDATE = _maxTimeFromLastUpdate;\n    }\n\n    /**\n     * @notice Gets the price of ezETH in wstETH\n     * (ETH / ezETH) / (ETH / stETH) * (wstETH / stETH) = wstETH / ezETH\n     */\n    function getPrice() public view override returns (uint256) {\n        // ETH / ezETH [8 decimals]\n        (, int256 ethPerEzEth,, uint256 ethPerEzEthUpdatedAt,) = REDSTONE_EZETH_ETH_PRICE_FEED.latestRoundData();\n        // ETH / stETH [18 decimals]\n        (, int256 ethPerStEth,, uint256 ethPerStEthUpdatedAt,) = ETH_PER_STETH_CHAINLINK.latestRoundData();\n        if (\n            block.timestamp - ethPerEzEthUpdatedAt > MAX_TIME_FROM_LAST_UPDATE\n                || block.timestamp - ethPerStEthUpdatedAt > MAX_TIME_FROM_LAST_UPDATE\n        ) {\n            return 0; // collateral valuation is zero if oracle data is stale\n        } else {\n            // (ETH / ezETH) / (ETH / stETH) = stETH / ezETH\n            uint256 stEthPerEzEth =\n                ethPerEzEth.toUint256().scaleUpToWad(REDSTONE_DECIMALS).wadDivDown(ethPerStEth.toUint256()); // [wad]\n\n            uint256 wstEthPerStEth = IWstEth(WSTETH_ADDRESS).tokensPerStEth(); // [wad]\n            // (wstETH / ezETH) = (stETH / ezETH) * (wstETH / stETH)\n            return stEthPerEzEth.wadMulDown(wstEthPerStEth); // [wad]\n        }\n    }\n}"
    },
    {
      "filename": "src/flash/UniswapFlashswapDirectMintHandlerWithDust.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { IonHandlerBase } from \"./IonHandlerBase.sol\";\nimport { IWETH9 } from \"../interfaces/IWETH9.sol\";\n\nimport { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport { IUniswapV3SwapCallback } from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { console2 } from \"forge-std/console2.sol\";\n\n/**\n * @notice This contract is forked off of the UniswapFlashswapDirectMintHandler,\n * with one distinction that it handles potential dust collateral amounts that\n * can accrue when the contract ends up minting more collateral than originally\n * intended. This situation can occur when the user has a desired leverage\n * amount and thus an exact resulting collateral amount, but due to rounding\n * errors in the minting contract, the handler is forced to mint a dust amount\n * more than the desired collateral amount. In this contract, the dust is added\n * to the total final deposit amount and ends up in the user's vault as\n * additional collateral.\n *\n * The key difference between this contract and\n * `UniswapFlashswapDirectMintHandler` is a relaxed bound in comparing the sum\n * of initial user deposit and additionally minted collateral to the caller's\n * requested resulting additional collateral amount.\n *\n * This contract allows for easy creation of leverge positions through a Uniswap\n * flashswap and direct mint of the collateral from the provider. This will be\n * used when the collateral cannot be minted directly with the base asset but\n * can be directly minted by a token that the base asset has a UniswapV3 pool\n * with.\n *\n * This contract is to be used when there exists a UniswapV3 pool between the\n * base asset and the mint asset.\n *\n * @custom:security-contact security@molecularlabs.io\n */\nabstract contract UniswapFlashswapDirectMintHandlerWithDust is IonHandlerBase, IUniswapV3SwapCallback {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH9;\n    using SafeCast for uint256;\n\n    error InvalidUniswapPool();\n    error InvalidZeroLiquidityRegionSwap();\n    error CallbackOnlyCallableByPool(address unauthorizedCaller);\n    error OutputAmountNotReceived(uint256 amountReceived, uint256 amountRequired);\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4_295_128_739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1_461_446_703_485_210_103_287_273_052_203_988_822_378_723_970_342;\n\n    IUniswapV3Pool public immutable UNISWAP_POOL;\n    IERC20 public immutable MINT_ASSET;\n    bool private immutable MINT_IS_TOKEN0;\n\n    /**\n     * @notice Creates a new `UniswapFlashswapDirectMintHandler` instance.\n     * @param _uniswapPool Pool to perform the flashswap on.\n     * @param _mintAsset The asset used to mint the collateral.\n     */\n    constructor(IUniswapV3Pool _uniswapPool, IERC20 _mintAsset) {\n        if (address(_uniswapPool) == address(0)) revert InvalidUniswapPool();\n\n        MINT_ASSET = _mintAsset;\n\n        address token0 = _uniswapPool.token0();\n        address token1 = _uniswapPool.token1();\n\n        if (token0 != address(MINT_ASSET) && token1 != address(MINT_ASSET)) {\n            revert InvalidUniswapPool();\n        }\n        if (token0 == address(MINT_ASSET) && token1 == address(MINT_ASSET)) {\n            revert InvalidUniswapPool();\n        }\n\n        UNISWAP_POOL = _uniswapPool;\n        MINT_IS_TOKEN0 = token0 == address(MINT_ASSET) ? true : false;\n\n        address baseAsset = MINT_IS_TOKEN0 ? token1 : token0;\n\n        if (baseAsset != address(BASE)) revert InvalidUniswapPool();\n    }\n\n    /**\n     * @notice Transfer collateral from user -> Initiate flashswap between from\n     * base asset to mint asset -> Use the mint asset to mint the collateral ->\n     * Deposit all collateral into `IonPool` -> Borrow the base asset -> Close\n     * the flashswap by sending the base asset to the Uniswap pool.\n     * @param initialDeposit in collateral terms. [WAD]\n     * @param resultingAdditionalCollateral in collateral terms. [WAD]\n     * @param maxResultingDebt in base asset terms. [WAD]\n     * @param proof used to validate the user is whitelisted.\n     */\n    function flashswapAndMint(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt,\n        uint256 deadline,\n        bytes32[] memory proof\n    )\n        external\n        onlyWhitelistedBorrowers(proof)\n        checkDeadline(deadline)\n    {\n        LST_TOKEN.safeTransferFrom(msg.sender, address(this), initialDeposit);\n        _flashswapAndMint(initialDeposit, resultingAdditionalCollateral, maxResultingDebt);\n    }\n\n    function _flashswapAndMint(\n        uint256 initialDeposit,\n        uint256 resultingAdditionalCollateral,\n        uint256 maxResultingDebt\n    )\n        internal\n    {\n        uint256 amountLrt = resultingAdditionalCollateral - initialDeposit; // in collateral terms\n        uint256 amountWethToFlashloan = _getAmountInForCollateralAmountOut(amountLrt);\n\n        if (amountWethToFlashloan == 0) {\n            // AmountToBorrow.IS_MAX because we don't want to create any new debt here\n            _depositAndBorrow(msg.sender, address(this), resultingAdditionalCollateral, 0, AmountToBorrow.IS_MAX);\n            return;\n        }\n\n        // We want to swap for ETH here\n        bool zeroForOne = MINT_IS_TOKEN0 ? false : true;\n        uint256 baseAssetSwappedIn = _initiateFlashSwap({\n            zeroForOne: zeroForOne,\n            amountOut: amountWethToFlashloan,\n            recipient: address(this),\n            data: abi.encode(msg.sender, resultingAdditionalCollateral, initialDeposit)\n        });\n\n        if (baseAssetSwappedIn > maxResultingDebt) {\n            revert FlashloanRepaymentTooExpensive(amountWethToFlashloan, maxResultingDebt);\n        }\n    }\n\n    /**\n     * @notice Handles swap initiation logic. This function can only initiate\n     * exact output swaps.\n     * @param zeroForOne Direction of the swap.\n     * @param amountOut Desired amount of output.\n     * @param recipient of output tokens.\n     * @param data Arbitrary data to be passed through swap callback.\n     */\n    function _initiateFlashSwap(\n        bool zeroForOne,\n        uint256 amountOut,\n        address recipient,\n        bytes memory data\n    )\n        private\n        returns (uint256 amountIn)\n    {\n        (int256 amount0Delta, int256 amount1Delta) = UNISWAP_POOL.swap(\n            recipient, zeroForOne, -amountOut.toInt256(), zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1, data\n        );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n\n        // it's technically possible to not receive the full output amount,\n        if (amountOutReceived != amountOut) revert OutputAmountNotReceived(amountOutReceived, amountOut);\n    }\n\n    /**\n     * @notice From the perspective of the pool i.e. Negative amount means pool is\n     * sending. This function is intended to never be called directly. It should\n     * only be called by the Uniswap pool during a swap initiated by this\n     * contract.\n     *\n     * @dev One thing to note from a security perspective is that the pool only calls\n     * the callback on `msg.sender`. So a theoretical attacker cannot call this\n     * function by directing where to call the callback.\n     *\n     * @param amount0Delta change in token0\n     * @param amount1Delta change in token1\n     * @param _data arbitrary data\n     */\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external override {\n        if (msg.sender != address(UNISWAP_POOL)) revert CallbackOnlyCallableByPool(msg.sender);\n\n        // swaps entirely within 0-liquidity regions are not supported\n        if (amount0Delta == 0 && amount1Delta == 0) revert InvalidZeroLiquidityRegionSwap();\n        (address user, uint256 resultingAdditionalCollateral, uint256 initialDeposit) =\n            abi.decode(_data, (address, uint256, uint256));\n\n        // Code below this if statement will always assume token0 is MINT_ASSET. If it\n        // is not actually the case, we will flip the vars\n        if (!MINT_IS_TOKEN0) {\n            (amount0Delta, amount1Delta) = (amount1Delta, amount0Delta);\n        }\n\n        address tokenIn = address(BASE);\n\n        // Sanity check that Uniswap is sending MINT_ASSET\n        assert(amount0Delta < 0 && amount1Delta > 0);\n\n        // MINT_ASSET needs to be converted into collateral asset\n        uint256 collateralFromDeposit = _mintCollateralAsset(uint256(-amount0Delta));\n\n        // Sanity check\n        // Greater than and not equal to if extra dust collateral was minted due to\n        // rounding errors. Guarantees minimum bound for the leveraged collateral amount.\n        uint256 depositAmount = initialDeposit + collateralFromDeposit;\n        assert(depositAmount >= resultingAdditionalCollateral);\n\n        // AmountToBorrow.IS_MIN because we want to make sure enough is borrowed\n        // to cover the amount owed back to Uniswap\n        _depositAndBorrow(user, address(this), depositAmount, uint256(amount1Delta), AmountToBorrow.IS_MIN);\n\n        IERC20(tokenIn).safeTransfer(msg.sender, uint256(amount1Delta));\n    }\n\n    /**\n     * @notice Deposits the mint asset into the provider's collateral-asset\n     * deposit contract.\n     * @param amountMintAsset amount of \"mint asset\" to deposit. [WAD]\n     * @return Amount of collateral asset received. [WAD]\n     */\n    function _mintCollateralAsset(uint256 amountMintAsset) internal virtual returns (uint256);\n\n    /**\n     * @notice Calculates the amount of mint asset required to receive\n     * `amountLrt`.\n     * @dev Calculates the amount of mint asset required to receive `amountLrt`.\n     * @param amountLrt Desired output amount. [WAD]\n     * @return Amount mint asset required for desired output. [WAD]\n     */\n    function _getAmountInForCollateralAmountOut(uint256 amountLrt) internal view virtual returns (uint256);\n}"
    }
  ]
}