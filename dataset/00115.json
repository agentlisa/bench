{
  "Title": "Gauge point constants in `InitBipSeedGauge` should be scaled by the ratio of deposited BDV",
  "Content": "**Description:** The [current initial Gauge Point (GP) distribution](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/init/InitBipSeedGauge.sol#L68-L69) is based solely on the grown stalk per season per BDV for each LP, whereas it should be determined by considering the deposited BDV per LP.\n\nConsidering the following math which underlies the behavior of the gauge system:\n$$depositedBDVRatio(LP) = \\frac{silo.totalDepositedBDV(LP)}{\\sum_{wlpt}^{wlpt \\in Whitelisted \\ LP \\ Tokens} silo.totalDepositedBDV} $$\n$GP_{s}(LP) =$\n1. $depositedBDVRatio(LP) > LP.optimalDepositedBDVRatio \\land GP_{s-1}(LP) \\leq 1gp \\Rightarrow GP_{s}(LP) = 0$\n2. $depositedBDVRatio(LP) > LP.optimalDepositedBDVRatio \\land GP_{s-1}(LP) > 1gp \\Rightarrow GP_{s}(LP) = GP_{s-1}(LP)- 1gp$\n3. $depositedBDVRatio(LP) \\leq LP.optimalDepositedBDVRatio \\Rightarrow GP_{s}(LP) = GP_{s-1}(LP) + 1gp$\n\nIt can be seen that the formula relies on the previous $GP_{s-1}(LP)$, where $s$ indicates the current season number and deposited BDV ratio. Moreover, it is evident that the intention of this mechanism is to incentivize the Beanstalk protocol to have a pre-defined optimal deposited BDV ratio for each LP. Consequently, the initial assignment of GP should consider this intention.\n\n**Impact:** An incorrect initial GP distribution can result in unintended initial behavior, which can take a significant amount of time to rectify given that gauge points can only increase/decrease by one point per season as defined in [`GaugePointFacet::defaultGaugePointFunction`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/beanstalk/sun/GaugePointFacet.sol#L26-L38).\n\n**Proof of Concept:**\n```solidity\n// InitBipSeedGauge.sol\nuint128 beanEthGp = uint128(s.ss[C.BEAN_ETH_WELL].stalkEarnedPerSeason) * 500 * 1e12;\nuint128 bean3crvGp = uint128(s.ss[C.CURVE_BEAN_METAPOOL].stalkEarnedPerSeason) * 500 * 1e12\n```\n\nAs observed, the initial GP assignment is determined by the stalk earned per season before BIP-39, with the following values:\n* BEAN:3CRV Curve LP: `3.25e6`\n* BEAN:ETH Well LP: `4.5e6`\n\nThese values are not correlated with the total BDV deposited per LP. Consequently, the initial assignment of GP is made with incorrect values.\n\n**Recommended Mitigation:** Considering that [one gauge point is equal to 1e18](https://github.com/BeanstalkFarms/Beanstalk/blob/08ca0d7d495c94f2a4366fb7f99da561b74cc1c0/protocol/contracts/beanstalk/sun/GaugePointFacet.sol#L19), the following modification should be made:\n\n```diff\n//  InitBipSeedGauge.sol\n+   // BDV has 6 decimals\n+   uint256 beanEthBDV = s.siloBalances[C.BEAN_ETH_WELL].depositedBdv\n+   uint256 bean3crvBDV = s.siloBalances[C.CURVE_BEAN_METAPOOL].depositedBdv\n+   uint256 lpTotalBDV = beanEthBDV + bean3crvGp\n-   uint128 beanEthGp = uint128(s.ss[C.BEAN_ETH_WELL].stalkEarnedPerSeason) * 500 * 1e12;\n-   uint128 bean3crvGp = uint128(beanEthBDV) * 500 * 1e12\n+   // Assume 1 BDV = 1GP for initialization\n+   uint128 beanEthGp = uint128(beanEthBDV * 10e6).div(lpTotalBDV) * 1e12;\n+   uint128 bean3crvGp = uint128(bean3crvBDV * 10e6).div(lpTotalBDV) * 1e12\n```",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/init/InitBipSeedGauge.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\nimport {AppStorage, Storage} from \"contracts/beanstalk/AppStorage.sol\";\nimport {C} from \"../../C.sol\";\nimport {LibWhitelistedTokens} from \"contracts/libraries/Silo/LibWhitelistedTokens.sol\";\nimport {LibTokenSilo} from \"contracts/libraries/Silo/LibTokenSilo.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {LibCases} from \"contracts/libraries/LibCases.sol\";\nimport {LibWhitelist} from \"contracts/libraries/Silo/LibWhitelist.sol\";\nimport {LibGauge} from \"contracts/libraries/LibGauge.sol\";\nimport {Weather} from \"contracts/beanstalk/sun/SeasonFacet/Weather.sol\";\n\n/**\n * @author Brean\n * @title InitBipSeedGauge initalizes the seed gauge, updates siloSetting Struct\n **/\ninterface IGaugePointFacet {\n    function defaultGaugePointFunction(\n        uint256 currentGaugePoints,\n        uint256 optimalPercentDepositedBdv,\n        uint256 percentOfDepositedBdv\n    ) external pure returns (uint256 newGaugePoints);\n}\n\ncontract InitBipSeedGauge is Weather {\n    using SafeMath for uint256;\n\n    uint256 private constant TARGET_SEASONS_TO_CATCHUP = 4320;\n    uint256 private constant PRECISION = 1e6;\n\n    // TODO : update these values, once the beanEthMigration BIP has executed.\n    uint256 internal constant BEAN_UNMIGRATED_BDV = 816_105_148629; // 816k BDV\n    uint256 internal constant BEAN_3CRV_UNMIGRATED_BDV = 53_419_468565; // 53k BDV\n    uint256 internal constant UNRIPE_BEAN_UNMIGRATED_BDV = 4_946_644_852785; // 4.9m BDV\n    uint256 internal constant UNRIPE_LP_UNMIGRATED_BDV = 7_774_709_273192; // 7.7m BDV\n\n    // assumption is that unripe assets has been migrated to the bean-eth Wells.\n    function init() external {\n        // update depositedBDV for bean, bean3crv, urBean, and urBeanETH:\n        LibTokenSilo.incrementTotalDepositedBdv(\n            C.BEAN,\n            BEAN_UNMIGRATED_BDV - s.migratedBdvs[C.BEAN]\n        );\n        LibTokenSilo.incrementTotalDepositedBdv(\n            C.CURVE_BEAN_METAPOOL,\n            BEAN_3CRV_UNMIGRATED_BDV - s.migratedBdvs[C.CURVE_BEAN_METAPOOL]\n        );\n        LibTokenSilo.incrementTotalDepositedBdv(\n            C.UNRIPE_BEAN,\n            UNRIPE_BEAN_UNMIGRATED_BDV - s.migratedBdvs[C.UNRIPE_BEAN]\n        );\n        LibTokenSilo.incrementTotalDepositedBdv(\n            C.UNRIPE_LP,\n            UNRIPE_LP_UNMIGRATED_BDV - s.migratedBdvs[C.UNRIPE_LP]\n        );\n\n        uint128 totalBdv;\n        // only lp assets need to be updated.\n        // unripeAssets are not in the seed gauge,\n        // and bean does not have a gauge point function.\n        // (it is based on the max gauge points of LP)\n        // order: bean, beanETH, bean3CRV, urBEAN, urBEANETH\n        address[] memory siloTokens = LibWhitelistedTokens.getWhitelistedTokens();\n        uint128 beanEthGp = uint128(s.ss[C.BEAN_ETH_WELL].stalkEarnedPerSeason) * 500 * 1e12;\n        uint128 bean3crvGp = uint128(s.ss[C.CURVE_BEAN_METAPOOL].stalkEarnedPerSeason) * 500 * 1e12;\n        uint128[5] memory gaugePoints = [uint128(0), beanEthGp, bean3crvGp, 0, 0];\n        bytes4[5] memory gpSelectors = [\n            bytes4(0x00000000),\n            IGaugePointFacet.defaultGaugePointFunction.selector,\n            IGaugePointFacet.defaultGaugePointFunction.selector,\n            0x00000000,\n            0x00000000\n        ];\n        uint96[5] memory optimalPercentDepositedBdv = [uint96(0), 99e6, 1e6, 0, 0];\n        for (uint i = 0; i < siloTokens.length; i++) {\n            // update gaugePoints and gpSelectors\n            s.ss[siloTokens[i]].gaugePoints = gaugePoints[i];\n            s.ss[siloTokens[i]].gpSelector = gpSelectors[i];\n            s.ss[siloTokens[i]].optimalPercentDepositedBdv = optimalPercentDepositedBdv[i];\n\n            // get depositedBDV to use later:\n            totalBdv += s.siloBalances[siloTokens[i]].depositedBdv;\n            \n            // emit event\n            emit LibWhitelist.updateGaugeSettings(siloTokens[i], gpSelectors[i], optimalPercentDepositedBdv[i]);\n        }\n        // initalize seed gauge and emit events.\n        s.seedGauge.beanToMaxLpGpPerBdvRatio = 33_333_333_333_333_333_333; // 33% (50% + 50%* (1/3) = 66%)\n        s.seedGauge.averageGrownStalkPerBdvPerSeason = initializeAverageGrownStalkPerBdv(totalBdv);\n\n        emit BeanToMaxLpGpPerBdvRatioChange(s.season.current, type(uint256).max, int80(s.seedGauge.beanToMaxLpGpPerBdvRatio));\n        emit LibGauge.UpdateStalkPerBdvPerSeason(s.seedGauge.averageGrownStalkPerBdvPerSeason);\n\n        // initalize s.usdTokenPrice for the bean eth well.\n        s.usdTokenPrice[C.BEAN_ETH_WELL] = 1;\n\n        // set s.twaReserves for the bean eth well, and the bean:3crv pool.\n        s.twaReserves[C.BEAN_ETH_WELL].reserve0 = 1;\n        s.twaReserves[C.BEAN_ETH_WELL].reserve1 = 1;\n\n        // Even though it is not used, still initialize.\n        s.usdTokenPrice[C.CURVE_BEAN_METAPOOL] = 1;\n        s.twaReserves[C.CURVE_BEAN_METAPOOL].reserve0 = 1;\n        s.twaReserves[C.CURVE_BEAN_METAPOOL].reserve1 = 1;\n\n        // initalize V2 cases.\n        LibCases.setCasesV2();\n    }\n\n    function initializeAverageGrownStalkPerBdv(uint256 totalBdv) internal view returns (uint128) {\n        uint256 averageGrownStalkPerBdv = s.s.stalk.div(totalBdv).sub(10000);\n        return uint128(averageGrownStalkPerBdv.mul(PRECISION).div(TARGET_SEASONS_TO_CATCHUP));\n    }\n}"
    },
    {
      "filename": "protocol/contracts/beanstalk/sun/GaugePointFacet.sol",
      "content": "/*\n * SPDX-License-Identifier: MIT\n */\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {LibGauge} from \"contracts/libraries/LibGauge.sol\";\n\n/**\n * @title GaugePointFacet\n * @author Brean\n * @notice Calculates the gaugePoints for whitelisted Silo LP tokens.\n */\ncontract GaugePointFacet {\n    using SafeMath for uint256;\n\n    uint256 private constant ONE_POINT = 1e18;\n\n    /**\n     * @notice DefaultGaugePointFunction\n     * is the default function to calculate the gauge points\n     * of an LP asset.\n     */\n    function defaultGaugePointFunction(\n        uint256 currentGaugePoints,\n        uint256 optimalPercentDepositedBdv,\n        uint256 percentOfDepositedBdv\n    ) external pure returns (uint256 newGaugePoints) {\n        if (percentOfDepositedBdv > optimalPercentDepositedBdv) {\n            // gauge points cannot go below 0.\n            if (currentGaugePoints <= ONE_POINT) return 0;\n            newGaugePoints = currentGaugePoints.sub(ONE_POINT);\n        } else {\n            newGaugePoints = currentGaugePoints.add(ONE_POINT);\n        }\n    }\n}"
    }
  ]
}