{
  "Title": "[H01] Large stablecoin amounts may get stuck",
  "Content": "Within the flow of executing or cancelling a proposal to sell a stablecoin for CELO, the [`getSellTokenAndSellAmount`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L384) function is used to call the stable token’s [`unitsToValue`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L399) function to convert the underlying stored number of “units” of stable token to a “value” of the stable token. This mechanism exists so that stored funds in the GrandaMento contract experience inflation as they wait for their respective proposals to be executed.\n\n\nHowever, when dealing with large amounts of stable token, which is what GrandaMento is intended for, the `unitsToValue` function may overflow. The [calculation in `unitsToValue`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/stability/StableToken.sol#L435) utilizes the “inflation factor”, which is currently `1e24` (see [function `getInflationParameters` in the cUSD contract](https://explorer.celo.org/tokens/0x765DE816845861e75A25fCA122bb6898B8B1282a/read-contract)). It also casts the `units` parameter to `newFixed`, which [multiplies it by `FIXED1_UINT`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/common/FixidityLib.sol#L83), where [`FIXED1_UINT` is also `1e24`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/common/FixidityLib.sol#L29). Finally, the `divide` function also used in the calculation multiplies the already scaled value by [an additional `1e24`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/common/FixidityLib.sol#L245). This final multiplication, within the `divide` function, may potentially cause the calculation to [overflow and revert](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/common/FixidityLib.sol#L246).\n\n\nConsider the case where a user is attempting to execute a sale of 200 billion cUSD for CELO. When the `unitsToValue` function is hit, the `units` will be on the order of `200000000000*1e18`, or `2e29`. Then, casting it to `newFixed` will make the value `2e29*1e24`, or `2e53`. Then, within the `divide` function, the value will be again multiplied by `1e24`, bringing it to `2e77`. The maximum value of a `uint256` is roughly `1.158e77`, so this value of `2e77` will overflow, causing the [overflow check in `divide` to be triggered](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/common/FixidityLib.sol#L246).\n\n\nNote that this issue becomes more likely when considering the [CXOF token](https://explorer.celo.org/tokens/0x832F03bCeE999a577cb592948983E35C048B5Aa4/token-transfers), which also has 18 decimals but is worth roughly 1/500 of cUSD. Thus, 200 billion CXOF is roughly 400 million cUSD, a much more likely number to be exchanged. This issue may worsen as currencies worth substantially less than 1 USD are added. For example, the Vietnamese Dong is worth roughly 1/23000 USD, so roughly 5 million USD worth would trigger the overflow.\n\n\nNote also that as the inflation factor increases over time, this issue becomes slightly more likely.\n\n\nFinally, note that this issue does not exist for creating a proposal, as proposal creation [utilizes the `valueToUnits` function](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L246). This is the crux of the issue, which is that funds will be locked inside the GrandaMento contract in the event a user attempts to exchange too much. This applies both when attempting to execute a proposal, and when attempting to cancel it.\n\n\nConsider paying close attention to these limits when setting maximum exchange amounts, and warning users that if they attempt to exchange too much, their funds may be locked in the GrandaMento contract. We understand that inflation is currently not being applied to stablecoins, but in the event that it is in the future, any limits set here should be re-evaluated for long term health of GrandaMento.\n\n\n***Update:** Fixed in [pull request #8500](https://github.com/celo-org/celo-monorepo/pull/8500/files).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/liquidity/GrandaMento.sol",
      "content": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\nimport \"../stability/interfaces/IStableToken.sol\";\n\n/**\n * @title Facilitates large exchanges between CELO stable tokens.\n */\ncontract GrandaMento is\n  ICeloVersionedContract,\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  ReentrancyGuard\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  // Emitted when a new exchange proposal is created.\n  event ExchangeProposalCreated(\n    uint256 indexed proposalId,\n    address indexed exchanger,\n    string stableTokenRegistryId,\n    uint256 sellAmount,\n    uint256 buyAmount,\n    bool sellCelo\n  );\n\n  // Emitted when an exchange proposal is approved by the approver.\n  event ExchangeProposalApproved(uint256 indexed proposalId);\n\n  // Emitted when an exchange proposal is cancelled.\n  event ExchangeProposalCancelled(uint256 indexed proposalId);\n\n  // Emitted when an exchange proposal is executed.\n  event ExchangeProposalExecuted(uint256 indexed proposalId);\n\n  // Emitted when the approver is set.\n  event ApproverSet(address approver);\n\n  // Emitted when maxApprovalExchangeRateChange is set.\n  event MaxApprovalExchangeRateChangeSet(uint256 maxApprovalExchangeRateChange);\n\n  // Emitted when the spread is set.\n  event SpreadSet(uint256 spread);\n\n  // Emitted when the veto period in seconds is set.\n  event VetoPeriodSecondsSet(uint256 vetoPeriodSeconds);\n\n  // Emitted when the exchange limits for a stable token are set.\n  event StableTokenExchangeLimitsSet(\n    string stableTokenRegistryId,\n    uint256 minExchangeAmount,\n    uint256 maxExchangeAmount\n  );\n\n  enum ExchangeProposalState { None, Proposed, Approved, Executed, Cancelled }\n\n  struct ExchangeLimits {\n    // The minimum amount of an asset that can be exchanged in a single proposal.\n    uint256 minExchangeAmount;\n    // The maximum amount of an asset that can be exchanged in a single proposal.\n    uint256 maxExchangeAmount;\n  }\n\n  struct ExchangeProposal {\n    // The exchanger/proposer of the exchange proposal.\n    address payable exchanger;\n    // The stable token involved in this proposal. This is stored rather than\n    // the stable token's registry ID in case the contract address is changed\n    // while a stable token deposit\n    address stableToken;\n    // The state of the exchange proposal.\n    ExchangeProposalState state;\n    // Whether CELO is being sold and stableToken is being bought.\n    bool sellCelo;\n    // The amount of the sell token being sold. If a stable token is being sold,\n    // the amount of stable token in \"units\" is stored rather than the \"value.\"\n    // This is because stable tokens may experience demurrage/inflation, where\n    // the amount of stable token \"units\" doesn't change with time, but the \"value\"\n    // does. This is important to ensure the correct inflation-adjusted amount\n    // of the stable token is transferred out of this contract when a deposit is\n    // refunded or an exchange selling the stable token is executed.\n    // See StableToken.sol for more details on what \"units\" vs \"values\" are.\n    uint256 sellAmount;\n    // The amount of the buy token being bought. For stable tokens, this is\n    // kept track of as the value, not units.\n    uint256 buyAmount;\n    // The price of CELO quoted in stableToken at the time of the exchange proposal\n    // creation. This is the price used to calculate the buyAmount. Used for a\n    // safety check when an approval is being made that the price isn't wildly\n    // different. Recalculating buyAmount is not sufficient because if a stable token\n    // is being sold that has demurrage enabled, the original value when the stable\n    // tokens were deposited cannot be calculated.\n    uint256 celoStableTokenExchangeRate;\n    // The timestamp (`block.timestamp`) at which the exchange proposal was approved\n    // in seconds. If the exchange proposal has not ever been approved, is 0.\n    uint256 approvalTimestamp;\n  }\n\n  // The address with the authority to approve exchange proposals.\n  address public approver;\n\n  // The maximum allowed change in the CELO/stable token price when an exchange proposal\n  // is being approved relative to the rate when the exchange proposal was created.\n  FixidityLib.Fraction public maxApprovalExchangeRateChange;\n\n  // The percent fee imposed upon an exchange execution.\n  FixidityLib.Fraction public spread;\n\n  // The period in seconds after an approval during which an exchange proposal can be vetoed.\n  uint256 public vetoPeriodSeconds;\n\n  // The minimum and maximum amount of the stable token that can be minted or\n  // burned in a single exchange. Indexed by the stable token registry identifier string.\n  mapping(string => ExchangeLimits) public stableTokenExchangeLimits;\n\n  // State for all exchange proposals. Indexed by the exchange proposal ID.\n  mapping(uint256 => ExchangeProposal) public exchangeProposals;\n\n  // An array containing a superset of the IDs of exchange proposals that are currently\n  // in the Proposed or Approved state. Intended to allow easy viewing of all active\n  // exchange proposals. It's possible for a proposal ID in this array to no longer be\n  // active, so filtering is required to find the true set of active proposal IDs.\n  // A superset is kept because exchange proposal vetoes, intended to be done\n  // by Governance, effectively go through a multi-day timelock. If the veto\n  // call was required to provide the index in an array of activeProposalIds to\n  // remove corresponding to the vetoed exchange proposal, the timelock could result\n  // in the provided index being stale by the time the veto would be executed.\n  // Alternative approaches exist, like maintaining a linkedlist of active proposal\n  // IDs, but this approach was chosen for its low implementation complexity.\n  uint256[] public activeProposalIdsSuperset;\n\n  // Number of exchange proposals that have ever been created. Used for assigning\n  // an exchange proposal ID to a new proposal.\n  uint256 public exchangeProposalCount;\n\n  /**\n   * @notice Reverts if the sender is not the approver.\n   */\n  modifier onlyApprover() {\n    require(msg.sender == approver, \"Sender must be approver\");\n    _;\n  }\n\n  /**\n   * @notice Sets initialized == true on implementation contracts.\n   * @param test Set to true to skip implementation initialization.\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return The storage, major, minor, and patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 0, 0);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param _registry The address of the registry.\n   * @param _approver The approver that has the ability to approve exchange proposals.\n   * @param _maxApprovalExchangeRateChange The maximum allowed change in CELO price\n   * between an exchange proposal's creation and approval.\n   * @param _spread The spread charged on exchanges.\n   * @param _vetoPeriodSeconds The length of the veto period in seconds.\n   */\n  function initialize(\n    address _registry,\n    address _approver,\n    uint256 _maxApprovalExchangeRateChange,\n    uint256 _spread,\n    uint256 _vetoPeriodSeconds\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(_registry);\n    setApprover(_approver);\n    setMaxApprovalExchangeRateChange(_maxApprovalExchangeRateChange);\n    setSpread(_spread);\n    setVetoPeriodSeconds(_vetoPeriodSeconds);\n  }\n\n  /**\n   * @notice Creates a new exchange proposal and deposits the tokens being sold.\n   * @dev Stable token value amounts are used for the sellAmount, not unit amounts.\n   * @param stableTokenRegistryId The string registry ID for the stable token\n   * involved in the exchange.\n   * @param sellAmount The amount of the sell token being sold.\n   * @param sellCelo Whether CELO is being sold.\n   * @return The proposal identifier for the newly created exchange proposal.\n   */\n  function createExchangeProposal(\n    string calldata stableTokenRegistryId,\n    uint256 sellAmount,\n    bool sellCelo\n  ) external nonReentrant returns (uint256) {\n    address stableToken = registry.getAddressForStringOrDie(stableTokenRegistryId);\n\n    // Gets the price of CELO quoted in stableToken.\n    uint256 celoStableTokenExchangeRate = getOracleExchangeRate(stableToken).unwrap();\n\n    // Using the current oracle exchange rate, calculate what the buy amount is.\n    // This takes the spread into consideration.\n    uint256 buyAmount = getBuyAmount(celoStableTokenExchangeRate, sellAmount, sellCelo);\n\n    // Create new scope to prevent a stack too deep error.\n    {\n      // Get the minimum and maximum amount of stable token than can be involved\n      // in the exchange. This reverts if exchange limits for the stable token have\n      // not been set.\n      (uint256 minExchangeAmount, uint256 maxExchangeAmount) = getStableTokenExchangeLimits(\n        stableTokenRegistryId\n      );\n      // Ensure that the amount of stableToken being bought or sold is within\n      // the configurable exchange limits.\n      uint256 stableTokenExchangeAmount = sellCelo ? buyAmount : sellAmount;\n      require(\n        stableTokenExchangeAmount <= maxExchangeAmount &&\n          stableTokenExchangeAmount >= minExchangeAmount,\n        \"Stable token exchange amount not within limits\"\n      );\n    }\n\n    // Deposit the assets being sold.\n    IERC20 sellToken = sellCelo ? getGoldToken() : IERC20(stableToken);\n    require(\n      sellToken.transferFrom(msg.sender, address(this), sellAmount),\n      \"Transfer in of sell token failed\"\n    );\n\n    // Record the proposal.\n    // Add 1 to the running proposal count, and use the updated proposal count as\n    // the proposal ID. Proposal IDs intentionally start at 1.\n    exchangeProposalCount = exchangeProposalCount.add(1);\n    // For stable tokens, the amount is stored in units to deal with demurrage.\n    uint256 storedSellAmount = sellCelo\n      ? sellAmount\n      : IStableToken(stableToken).valueToUnits(sellAmount);\n    exchangeProposals[exchangeProposalCount] = ExchangeProposal({\n      exchanger: msg.sender,\n      stableToken: stableToken,\n      state: ExchangeProposalState.Proposed,\n      sellCelo: sellCelo,\n      sellAmount: storedSellAmount,\n      buyAmount: buyAmount,\n      celoStableTokenExchangeRate: celoStableTokenExchangeRate,\n      approvalTimestamp: 0 // initial value when not approved yet\n    });\n    // Push it into the array of active proposals.\n    activeProposalIdsSuperset.push(exchangeProposalCount);\n    // Even if stable tokens are being sold, the sellAmount emitted is the \"value.\"\n    emit ExchangeProposalCreated(\n      exchangeProposalCount,\n      msg.sender,\n      stableTokenRegistryId,\n      sellAmount,\n      buyAmount,\n      sellCelo\n    );\n    return exchangeProposalCount;\n  }\n\n  /**\n   * @notice Approves an existing exchange proposal.\n   * @dev Sender must be the approver. Exchange proposal must be in the Proposed state.\n   * @param proposalId The identifier of the proposal to approve.\n   */\n  function approveExchangeProposal(uint256 proposalId) external nonReentrant onlyApprover {\n    ExchangeProposal storage proposal = exchangeProposals[proposalId];\n    // Ensure the proposal is in the Proposed state.\n    require(proposal.state == ExchangeProposalState.Proposed, \"Proposal must be in Proposed state\");\n    // Ensure the change in the current price of CELO quoted in the stable token\n    // relative to the value when the proposal was created is within the allowed limit.\n    FixidityLib.Fraction memory currentRate = getOracleExchangeRate(proposal.stableToken);\n    FixidityLib.Fraction memory proposalRate = FixidityLib.wrap(\n      proposal.celoStableTokenExchangeRate\n    );\n    (FixidityLib.Fraction memory lesserRate, FixidityLib.Fraction memory greaterRate) = currentRate\n      .lt(proposalRate)\n      ? (currentRate, proposalRate)\n      : (proposalRate, currentRate);\n    FixidityLib.Fraction memory rateChange = greaterRate.subtract(lesserRate).divide(proposalRate);\n    require(\n      rateChange.lte(maxApprovalExchangeRateChange),\n      \"CELO exchange rate is too different from the proposed price\"\n    );\n\n    // Set the time the approval occurred and change the state.\n    proposal.approvalTimestamp = block.timestamp;\n    proposal.state = ExchangeProposalState.Approved;\n    emit ExchangeProposalApproved(proposalId);\n  }\n\n  /**\n   * @notice Cancels an exchange proposal.\n   * @dev Only callable by the exchanger if the proposal is in the Proposed state\n   * or the owner if the proposal is in the Approved state.\n   * @param proposalId The identifier of the proposal to cancel.\n   */\n  function cancelExchangeProposal(uint256 proposalId) external nonReentrant {\n    ExchangeProposal storage proposal = exchangeProposals[proposalId];\n    // Require the appropriate state and sender.\n    // This will also revert if a proposalId is given that does not correspond\n    // to a previously created exchange proposal.\n    require(\n      (proposal.state == ExchangeProposalState.Proposed && proposal.exchanger == msg.sender) ||\n        (proposal.state == ExchangeProposalState.Approved && isOwner()),\n      \"Sender cannot cancel the exchange proposal\"\n    );\n    // Mark the proposal as cancelled. Do so prior to refunding as a measure against reentrancy.\n    proposal.state = ExchangeProposalState.Cancelled;\n    // Get the token and amount that will be refunded to the proposer.\n    (IERC20 refundToken, uint256 refundAmount) = getSellTokenAndSellAmount(proposal);\n    // Finally, transfer out the deposited funds.\n    require(\n      refundToken.transfer(proposal.exchanger, refundAmount),\n      \"Transfer out of refund token failed\"\n    );\n    emit ExchangeProposalCancelled(proposalId);\n  }\n\n  /**\n   * @notice Executes an exchange proposal that's been approved and not vetoed.\n   * @dev Callable by anyone. Reverts if the proposal is not in the Approved state\n   * or vetoPeriodSeconds has not elapsed since approval.\n   * @param proposalId The identifier of the proposal to execute.\n   */\n  function executeExchangeProposal(uint256 proposalId) external nonReentrant {\n    ExchangeProposal storage proposal = exchangeProposals[proposalId];\n    // Require that the proposal is in the Approved state.\n    require(proposal.state == ExchangeProposalState.Approved, \"Proposal must be in Approved state\");\n    // Require that the veto period has elapsed since the approval time.\n    require(\n      proposal.approvalTimestamp.add(vetoPeriodSeconds) <= block.timestamp,\n      \"Veto period not elapsed\"\n    );\n    // Mark the proposal as executed. Do so prior to exchanging as a measure against reentrancy.\n    proposal.state = ExchangeProposalState.Executed;\n    // Perform the exchange.\n    (IERC20 sellToken, uint256 sellAmount) = getSellTokenAndSellAmount(proposal);\n    // If the exchange sells CELO, the CELO is sent to the Reserve from this contract\n    // and stable token is minted to the exchanger.\n    if (proposal.sellCelo) {\n      // Send the CELO from this contract to the reserve.\n      require(\n        sellToken.transfer(address(getReserve()), sellAmount),\n        \"Transfer out of CELO to Reserve failed\"\n      );\n      // Mint stable token to the exchanger.\n      require(\n        IStableToken(proposal.stableToken).mint(proposal.exchanger, proposal.buyAmount),\n        \"Stable token mint failed\"\n      );\n    } else {\n      // If the exchange is selling stable token, the stable token is burned from\n      // this contract and CELO is transferred from the Reserve to the exchanger.\n\n      // Burn the stable token from this contract.\n      require(IStableToken(proposal.stableToken).burn(sellAmount), \"Stable token burn failed\");\n      // Transfer the CELO from the Reserve to the exchanger.\n      require(\n        getReserve().transferExchangeGold(proposal.exchanger, proposal.buyAmount),\n        \"Transfer out of CELO from Reserve failed\"\n      );\n    }\n    emit ExchangeProposalExecuted(proposalId);\n  }\n\n  /**\n   * @notice Gets the sell token and the sell amount for a proposal.\n   * @dev For stable token sell amounts that are stored as units, the value\n   * is returned. Ensures sell amount is not greater than this contract's balance.\n   * @param proposal The proposal to get the sell token and sell amount for.\n   * @return (the IERC20 sell token, the value sell amount).\n   */\n  function getSellTokenAndSellAmount(ExchangeProposal memory proposal)\n    private\n    view\n    returns (IERC20, uint256)\n  {\n    IERC20 sellToken;\n    uint256 sellAmount;\n    if (proposal.sellCelo) {\n      sellToken = getGoldToken();\n      sellAmount = proposal.sellAmount;\n    } else {\n      address stableToken = proposal.stableToken;\n      sellToken = IERC20(stableToken);\n      // When selling stableToken, the sell amount is stored in units.\n      // Units must be converted to value when refunding.\n      sellAmount = IStableToken(stableToken).unitsToValue(proposal.sellAmount);\n    }\n    // In the event a precision issue from the unit <-> value calculations results\n    // in sellAmount being greater than this contract's balance, set the sellAmount\n    // to the entire balance.\n    // This check should not be necessary for CELO, but is done so regardless\n    // for extra certainty that cancelling an exchange proposal can never fail\n    // if for some reason the CELO balance of this contract is less than the\n    // recorded sell amount.\n    uint256 totalBalance = sellToken.balanceOf(address(this));\n    if (totalBalance < sellAmount) {\n      sellAmount = totalBalance;\n    }\n    return (sellToken, sellAmount);\n  }\n\n  /**\n   * @notice Using the oracle price, charges the spread and calculates the amount of\n   * the asset being bought.\n   * @dev Stable token value amounts are used for the sellAmount, not unit amounts.\n   * Assumes both CELO and the stable token have 18 decimals.\n   * @param celoStableTokenExchangeRate The unwrapped fraction exchange rate of CELO\n   * quoted in the stable token.\n   * @param sellAmount The amount of the sell token being sold.\n   * @param sellCelo Whether CELO is being sold.\n   * @return The amount of the asset being bought.\n   */\n  function getBuyAmount(uint256 celoStableTokenExchangeRate, uint256 sellAmount, bool sellCelo)\n    public\n    view\n    returns (uint256)\n  {\n    FixidityLib.Fraction memory exchangeRate = FixidityLib.wrap(celoStableTokenExchangeRate);\n    // If stableToken is being sold, instead use the price of stableToken\n    // quoted in CELO.\n    if (!sellCelo) {\n      exchangeRate = exchangeRate.reciprocal();\n    }\n    // The sell amount taking the spread into account, ie:\n    // (1 - spread) * sellAmount\n    FixidityLib.Fraction memory adjustedSellAmount = FixidityLib.fixed1().subtract(spread).multiply(\n      FixidityLib.newFixed(sellAmount)\n    );\n    // Calculate the buy amount:\n    // exchangeRate * adjustedSellAmount\n    return exchangeRate.multiply(adjustedSellAmount).fromFixed();\n  }\n\n  /**\n   * @notice Removes the proposal ID found at the provided index of activeProposalIdsSuperset\n   * if the exchange proposal is not active.\n   * @dev Anyone can call. Reverts if the exchange proposal is active.\n   * @param index The index of the proposal ID to remove from activeProposalIdsSuperset.\n   */\n  function removeFromActiveProposalIdsSuperset(uint256 index) external {\n    require(index < activeProposalIdsSuperset.length, \"Index out of bounds\");\n    uint256 proposalId = activeProposalIdsSuperset[index];\n    // Require the exchange proposal to be inactive.\n    require(\n      exchangeProposals[proposalId].state != ExchangeProposalState.Proposed &&\n        exchangeProposals[proposalId].state != ExchangeProposalState.Approved,\n      \"Exchange proposal not inactive\"\n    );\n    // If not removing the last element, overwrite the index with the value of\n    // the last element.\n    uint256 lastIndex = activeProposalIdsSuperset.length.sub(1);\n    if (index < lastIndex) {\n      activeProposalIdsSuperset[index] = activeProposalIdsSuperset[lastIndex];\n    }\n    // Delete the last element.\n    activeProposalIdsSuperset.length--;\n  }\n\n  /**\n   * @notice Gets the proposal identifiers of exchange proposals in the\n   * Proposed or Approved state. Returns a version of activeProposalIdsSuperset\n   * with inactive proposal IDs set as 0.\n   * @dev Elements with a proposal ID of 0 should be filtered out by the consumer.\n   * @return An array of active exchange proposals IDs.\n   */\n  function getActiveProposalIds() external view returns (uint256[] memory) {\n    // Solidity doesn't play well with dynamically sized memory arrays.\n    // Instead, this array is created with the same length as activeProposalIdsSuperset,\n    // and will replace elements that are inactive proposal IDs with the value 0.\n    uint256[] memory activeProposalIds = new uint256[](activeProposalIdsSuperset.length);\n\n    for (uint256 i = 0; i < activeProposalIdsSuperset.length; i = i.add(1)) {\n      uint256 proposalId = activeProposalIdsSuperset[i];\n      if (\n        exchangeProposals[proposalId].state == ExchangeProposalState.Proposed ||\n        exchangeProposals[proposalId].state == ExchangeProposalState.Approved\n      ) {\n        activeProposalIds[i] = proposalId;\n      }\n    }\n    return activeProposalIds;\n  }\n\n  /**\n   * @notice Gets the oracle CELO price quoted in the stable token.\n   * @dev Reverts if there is not a rate for the provided stable token.\n   * @param stableToken The stable token to get the oracle price for.\n   * @return The oracle CELO price quoted in the stable token.\n   */\n  function getOracleExchangeRate(address stableToken)\n    private\n    view\n    returns (FixidityLib.Fraction memory)\n  {\n    uint256 rateNumerator;\n    uint256 rateDenominator;\n    (rateNumerator, rateDenominator) = getSortedOracles().medianRate(stableToken);\n    // When rateDenominator is 0, it means there are no rates known to SortedOracles.\n    require(rateDenominator > 0, \"No oracle rates present for token\");\n    return FixidityLib.wrap(rateNumerator).divide(FixidityLib.wrap(rateDenominator));\n  }\n\n  /**\n   * @notice Gets the minimum and maximum amount of a stable token that can be\n   * involved in a single exchange.\n   * @dev Reverts if there is no explicit exchange limit for the stable token.\n   * @param stableTokenRegistryId The string registry ID for the stable token.\n   * @return (minimum exchange amount, maximum exchange amount).\n   */\n  function getStableTokenExchangeLimits(string memory stableTokenRegistryId)\n    public\n    view\n    returns (uint256, uint256)\n  {\n    ExchangeLimits memory exchangeLimits = stableTokenExchangeLimits[stableTokenRegistryId];\n    // Require the configurable stableToken max exchange amount to be > 0.\n    // This covers the case where a stableToken has never been explicitly permitted.\n    require(\n      exchangeLimits.maxExchangeAmount > 0,\n      \"Max stable token exchange amount must be defined\"\n    );\n    return (exchangeLimits.minExchangeAmount, exchangeLimits.maxExchangeAmount);\n  }\n\n  /**\n   * @notice Sets the approver.\n   * @dev Sender must be owner. New approver is allowed to be address(0).\n   * @param newApprover The new value for the approver.\n   */\n  function setApprover(address newApprover) public onlyOwner {\n    approver = newApprover;\n    emit ApproverSet(newApprover);\n  }\n\n  /**\n   * @notice Sets the maximum allowed change in the CELO/stable token price when\n   * an exchange proposal is being approved relative to the price when the proposal\n   * was created.\n   * @dev Sender must be owner.\n   * @param newMaxApprovalExchangeRateChange The new value for maxApprovalExchangeRateChange\n   * to be wrapped.\n   */\n  function setMaxApprovalExchangeRateChange(uint256 newMaxApprovalExchangeRateChange)\n    public\n    onlyOwner\n  {\n    maxApprovalExchangeRateChange = FixidityLib.wrap(newMaxApprovalExchangeRateChange);\n    emit MaxApprovalExchangeRateChangeSet(newMaxApprovalExchangeRateChange);\n  }\n\n  /**\n   * @notice Sets the spread.\n   * @dev Sender must be owner.\n   * @param newSpread The new value for the spread to be wrapped. Must be <= fixed 1.\n   */\n  function setSpread(uint256 newSpread) public onlyOwner {\n    require(newSpread <= FixidityLib.fixed1().unwrap(), \"Spread must be smaller than 1\");\n    spread = FixidityLib.wrap(newSpread);\n    emit SpreadSet(newSpread);\n  }\n\n  /**\n   * @notice Sets the minimum and maximum amount of the stable token an exchange can involve.\n   * @dev Sender must be owner. Setting the maxExchangeAmount to 0 effectively disables new\n   * exchange proposals for the token.\n   * @param stableTokenRegistryId The registry ID string for the stable token to set limits for.\n   * @param minExchangeAmount The new minimum exchange amount for the stable token.\n   * @param maxExchangeAmount The new maximum exchange amount for the stable token.\n   */\n  function setStableTokenExchangeLimits(\n    string calldata stableTokenRegistryId,\n    uint256 minExchangeAmount,\n    uint256 maxExchangeAmount\n  ) external onlyOwner {\n    require(\n      minExchangeAmount <= maxExchangeAmount,\n      \"Min exchange amount must not be greater than max\"\n    );\n    stableTokenExchangeLimits[stableTokenRegistryId] = ExchangeLimits({\n      minExchangeAmount: minExchangeAmount,\n      maxExchangeAmount: maxExchangeAmount\n    });\n    emit StableTokenExchangeLimitsSet(stableTokenRegistryId, minExchangeAmount, maxExchangeAmount);\n  }\n\n  /**\n   * @notice Sets the veto period in seconds.\n   * @dev Sender must be owner.\n   * @param newVetoPeriodSeconds The new value for the veto period in seconds.\n   */\n  function setVetoPeriodSeconds(uint256 newVetoPeriodSeconds) public onlyOwner {\n    vetoPeriodSeconds = newVetoPeriodSeconds;\n    emit VetoPeriodSecondsSet(newVetoPeriodSeconds);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/stability/StableToken.sol",
      "content": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IStableToken.sol\";\nimport \"../common/interfaces/ICeloToken.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/CalledByVm.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Freezable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\n/**\n * @title An ERC20 compliant token with adjustable supply.\n */\n// solhint-disable-next-line max-line-length\ncontract StableToken is\n  ICeloVersionedContract,\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  UsingPrecompiles,\n  Freezable,\n  CalledByVm,\n  IStableToken,\n  IERC20,\n  ICeloToken\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  event InflationFactorUpdated(uint256 factor, uint256 lastUpdated);\n\n  event InflationParametersUpdated(uint256 rate, uint256 updatePeriod, uint256 lastUpdated);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event TransferComment(string comment);\n\n  bytes32 constant GRANDA_MENTO_REGISTRY_ID = keccak256(abi.encodePacked(\"GrandaMento\"));\n\n  string internal name_;\n  string internal symbol_;\n  uint8 internal decimals_;\n\n  // Stored as units. Value can be found using unitsToValue().\n  mapping(address => uint256) internal balances;\n  uint256 internal totalSupply_;\n\n  // Stored as values. Units can be found using valueToUnits().\n  mapping(address => mapping(address => uint256)) internal allowed;\n\n  // STABILITY FEE PARAMETERS\n\n  // The `rate` is how much the `factor` is adjusted by per `updatePeriod`.\n  // The `factor` describes units/value of StableToken, and is greater than or equal to 1.\n  // The `updatePeriod` governs how often the `factor` is updated.\n  // `factorLastUpdated` indicates when the inflation factor was last updated.\n  struct InflationState {\n    FixidityLib.Fraction rate;\n    FixidityLib.Fraction factor;\n    uint256 updatePeriod;\n    uint256 factorLastUpdated;\n  }\n\n  InflationState inflationState;\n\n  // The registry ID of the exchange contract with permission to mint and burn this token.\n  // Unique per StableToken instance.\n  bytes32 exchangeRegistryId;\n\n  /**\n   * @notice Recomputes and updates inflation factor if more than `updatePeriod`\n   * has passed since last update.\n   */\n  modifier updateInflationFactor() {\n    FixidityLib.Fraction memory updatedInflationFactor;\n    uint256 lastUpdated;\n\n    (updatedInflationFactor, lastUpdated) = getUpdatedInflationFactor();\n\n    if (lastUpdated != inflationState.factorLastUpdated) {\n      inflationState.factor = updatedInflationFactor;\n      inflationState.factorLastUpdated = lastUpdated;\n      emit InflationFactorUpdated(inflationState.factor.unwrap(), inflationState.factorLastUpdated);\n    }\n    _;\n  }\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return The storage, major, minor, and patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 2, 0, 1);\n  }\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @param _name The name of the stable token (English)\n   * @param _symbol A short symbol identifying the token (e.g. \"cUSD\")\n   * @param _decimals Tokens are divisible to this many decimal places.\n   * @param registryAddress Address of the Registry contract.\n   * @param inflationRate Weekly inflation rate.\n   * @param inflationFactorUpdatePeriod How often the inflation factor is updated, in seconds.\n   * @param initialBalanceAddresses Array of addresses with an initial balance.\n   * @param initialBalanceValues Array of balance values corresponding to initialBalanceAddresses.\n   * @param exchangeIdentifier String identifier of exchange in registry (for specific fiat pairs)\n   */\n  function initialize(\n    string calldata _name,\n    string calldata _symbol,\n    uint8 _decimals,\n    address registryAddress,\n    uint256 inflationRate,\n    uint256 inflationFactorUpdatePeriod,\n    address[] calldata initialBalanceAddresses,\n    uint256[] calldata initialBalanceValues,\n    string calldata exchangeIdentifier\n  ) external initializer {\n    require(inflationRate != 0, \"Must provide a non-zero inflation rate\");\n    require(inflationFactorUpdatePeriod > 0, \"inflationFactorUpdatePeriod must be > 0\");\n\n    _transferOwnership(msg.sender);\n\n    totalSupply_ = 0;\n    name_ = _name;\n    symbol_ = _symbol;\n    decimals_ = _decimals;\n\n    inflationState.rate = FixidityLib.wrap(inflationRate);\n    inflationState.factor = FixidityLib.fixed1();\n    inflationState.updatePeriod = inflationFactorUpdatePeriod;\n    // solhint-disable-next-line not-rely-on-time\n    inflationState.factorLastUpdated = now;\n\n    require(initialBalanceAddresses.length == initialBalanceValues.length, \"Array length mismatch\");\n    for (uint256 i = 0; i < initialBalanceAddresses.length; i = i.add(1)) {\n      _mint(initialBalanceAddresses[i], initialBalanceValues[i]);\n    }\n    setRegistry(registryAddress);\n    exchangeRegistryId = keccak256(abi.encodePacked(exchangeIdentifier));\n  }\n\n  /**\n   * @notice Updates Inflation Parameters.\n   * @param rate New rate.\n   * @param updatePeriod How often inflationFactor is updated.\n   */\n  function setInflationParameters(uint256 rate, uint256 updatePeriod)\n    external\n    onlyOwner\n    updateInflationFactor\n  {\n    require(rate != 0, \"Must provide a non-zero inflation rate.\");\n    require(updatePeriod > 0, \"updatePeriod must be > 0\");\n    inflationState.rate = FixidityLib.wrap(rate);\n    inflationState.updatePeriod = updatePeriod;\n\n    emit InflationParametersUpdated(\n      rate,\n      updatePeriod,\n      // solhint-disable-next-line not-rely-on-time\n      now\n    );\n  }\n\n  /**\n   * @notice Increase the allowance of another user.\n   * @param spender The address which is being approved to spend StableToken.\n   * @param value The increment of the amount of StableToken approved to the spender.\n   * @return True if the transaction succeeds.\n   */\n  function increaseAllowance(address spender, uint256 value)\n    external\n    updateInflationFactor\n    r"
    }
  ]
}