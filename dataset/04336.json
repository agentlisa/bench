{
  "Title": "[H03] Affiliate keys can be stolen",
  "Content": "The [`addKey` function of the `AffiliateValidator` contract](https://github.com/AugurProject/augur/blob/67c0fec95e65fca8d27751f28a6c06e5247978c6/packages/augur-core/source/contracts/AffiliateValidator.sol#L23) is used to associate a `key` with a user account. The `key` is expected to be derived from the user’s KYC information. The function first confirms that a given key-salt pair was signed by an operator and that the salt has not been used already. Then it associates the key with the sender’s account.\n\n\nHowever, the signature is not cryptographically tied to the caller’s address (i.e., the `msg.sender` address). This means that an attacker can obtain the signature before it is confirmed (e.g., by reading it in a node’s public pool of pending transactions), and later call the `addKey` function to associate the stolen key with the attacker’s account. This will allow the attacker to register a valid key without going through the mandatory KYC process. Furthermore, it will also prevent the victim from using the signature.\n\n\nConsider modifying the `addKey` function of the `AffiliateValidator` contract to include the user’s address within the key hash, so as to ensure the signature can only be redeemed by the intended account.\n\n\n**Update**: *Fixed in [PR #5564](https://github.com/AugurProject/augur/pull/5564/files). The user’s address is included within the key hash.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/augur-core/source/contracts/AffiliateValidator.sol",
      "content": "pragma solidity 0.5.10;\n\nimport 'ROOT/libraries/Ownable.sol';\nimport 'ROOT/external/IAffiliateValidator.sol';\n\n\ncontract AffiliateValidator is Ownable, IAffiliateValidator {\n    // Mapping of affiliate address to their key\n    mapping (address => bytes32) keys;\n\n    mapping (address => bool) operators;\n\n    mapping (uint256 => bool) usedSalts;\n\n    function addOperator(address _operator) external onlyOwner {\n        operators[_operator] = true;\n    }\n\n    function removeOperator(address _operator) external onlyOwner {\n        operators[_operator] = false;\n    }\n\n    function addKey(bytes32 _key, uint256 _salt, bytes32 _r, bytes32 _s, uint8 _v) external {\n        require(!usedSalts[_salt], \"Salt already used\");\n        bytes32 _hash = getKeyHash(_key, _salt);\n        require(isValidSignature(_hash, _r, _s, _v), \"Signature invalid\");\n        usedSalts[_salt] = true;\n        keys[msg.sender] = _key;\n    }\n\n    function getKeyHash(bytes32 _key, uint256 _salt) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_key, _salt));\n    }\n\n    function isValidSignature(bytes32 _hash, bytes32 _r, bytes32 _s, uint8 _v) public view returns (bool) {\n        address recovered = ecrecover(\n            keccak256(abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                _hash\n            )),\n            _v,\n            _r,\n            _s\n        );\n        return operators[recovered];\n    }\n\n    function validateReference(address _account, address _referrer) external view {\n        bytes32 _accountKey = keys[_account];\n        bytes32 _referralKey = keys[_referrer];\n        if (_accountKey == bytes32(0) || _referralKey == bytes32(0)) {\n            revert(\"Key must be registered for both accounts\");\n        }\n        require(_accountKey != _referralKey, \"Key must not be equal for both accounts\");\n    }\n\n    function onTransferOwnership(address, address) internal {}\n}"
    }
  ]
}