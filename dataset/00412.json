{
  "Title": "H-8: Malicious MarketHelper contract can be used in TOFTMarketReceiverModule's leverageUpReceiver and marketRemoveCollateralReceiver functions",
  "Content": "# Issue H-8: Malicious MarketHelper contract can be used in TOFTMarketReceiverModule's leverageUpReceiver and marketRemoveCollateralReceiver functions \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/90 \n\n## Found by \nbin2chen, cergyk, ctf\\_sec, hyh\n## Summary\n\nUser-supplied `marketHelper` contract is called for building market's `execute()` call, but in `leverageUpReceiver()` and `marketRemoveCollateralReceiver()` it's not whitelisted.\n\n## Vulnerability Detail\n\nAn attacker can craft any logic and provide it as `marketHelper`, placing arbitrary `modules` and `calls` for `market` `execute()`, not corresponding for `buyCollateral` or `removeCollateral` operations.\n\nFor example, `removeCollateral` operation can have both `msg_.withdrawParams.withdraw == true` and `to = msg_.user` instead of `to = msg_.removeParams.magnetar`, stealing the corresponding assets from `magnetar` balance (i.e. instead of forwarding the user assets received it will use assets from the own balance instead as user both received assets directly and called `withdraw` via `magnetar`).\n\n## Impact\n\nIn the example above `magnetar`, being a helper contract itself, has to have assets on the balance to steal. But there might be different sequences of operations allowing other loss making manipulations. Placing to medium the cumulative probability of reaching the state when crafted `marketHelper` produced call sequence can trick the desired logic to gain a material benefit.\n\nLikelihood: Medium + Impact: High = Severity: High.\n\n## Code Snippet\n\n`marketHelper` isn't checked to be whitelisted in `leverageUpReceiver()`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol#L74-L79\n\n```solidity\n    function leverageUpReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        LeverageUpActionMsg memory msg_ = TOFTMsgCodec.decodeLeverageUpMsg(_data);\n\n        /// @dev 'market'\n        _checkWhitelistStatus(msg_.market);\n```\n\nIt is used to craft call sequence for `market`, that can be arbitrary this way (which, even having `modules` fixed and sound, still can have a variety of unintended impacts similar to misplacing `to` as mentioned above):\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol#L88-L93\n\n```solidity\n        {\n>>          (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.marketHelper).buyCollateral(\n                msg_.user, msg_.borrowAmount, msg_.supplyAmount, msg_.executorData\n            );\n            IMarket(msg_.market).execute(modules, calls, true);\n        }\n```\n\nAnd in `marketRemoveCollateralReceiver()`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol#L161-L165\n\n```solidity\n    function marketRemoveCollateralReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketRemoveCollateralMsg memory msg_ = TOFTMsgCodec.decodeMarketRemoveCollateralMsg(_data);\n\n        _checkWhitelistStatus(msg_.removeParams.market);\n```\n\nWhere it can, as an example, place `msg_.user` as `to`, still calling `withdraw` from `magnetar`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol#L172-L197\n\n```solidity\n        {\n            uint256 share = IYieldBox(ybAddress).toShare(assetId, msg_.removeParams.amount, false);\n            approve(msg_.removeParams.market, share);\n\n>>          (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.removeParams.marketHelper)\n                .removeCollateral(msg_.user, msg_.withdrawParams.withdraw ? msg_.removeParams.magnetar : msg_.user, share);\n            IMarket(msg_.removeParams.market).execute(modules, calls, true);\n        }\n\n        {\n>>          if (msg_.withdrawParams.withdraw) {\n                _checkWhitelistStatus(msg_.removeParams.magnetar);\n\n                bytes memory call =\n                    abi.encodeWithSelector(MagnetarYieldBoxModule.withdrawToChain.selector, msg_.withdrawParams);\n                MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n                magnetarCall[0] = MagnetarCall({\n                    id: MagnetarAction.YieldBoxModule,\n                    target: address(this),\n                    value: msg.value,\n                    allowFailure: false,\n                    call: call\n                });\n                IMagnetar(payable(msg_.removeParams.magnetar)).burst{value: msg.value}(magnetarCall);\n            }\n        }\n```\n\nI.e. the assumption that the calls is constructed by regular white-listed `MarketHelper` to follow the operation logic is broken:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/MarketHelper.sol#L119-L128\n\n```solidity\n>>  function removeCollateral(address from, address to, uint256 share)\n        external\n        pure\n        returns (Module[] memory modules, bytes[] memory calls)\n    {\n        modules = new Module[](1);\n        calls = new bytes[](1);\n        modules[0] = Module.Collateral;\n>>      calls[0] = abi.encodeWithSelector(SGLCollateral.removeCollateral.selector, from, to, share);\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSince the contract is known and already included to white lists in the system, consider checking it in `leverageUpReceiver()` and `marketRemoveCollateralReceiver()`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol#L74-L79\n\n```diff\n    function leverageUpReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        LeverageUpActionMsg memory msg_ = TOFTMsgCodec.decodeLeverageUpMsg(_data);\n\n        /// @dev 'market'\n        _checkWhitelistStatus(msg_.market);\n+       _checkWhitelistStatus(msg_.marketHelper);\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol#L161-L165\n\n```diff\n    function marketRemoveCollateralReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketRemoveCollateralMsg memory msg_ = TOFTMsgCodec.decodeMarketRemoveCollateralMsg(_data);\n\n        _checkWhitelistStatus(msg_.removeParams.market);\n+       _checkWhitelistStatus(msg_.removeParams.marketHelper);\n```\n\n\n\n## Discussion\n\n**cryptotechmaker**\n\nMedium\n\n**nevillehuang**\n\n@cryptotechmaker This could be high severity given the impact highlighted\n\n> For example, removeCollateral operation can have both msg_.withdrawParams.withdraw == true and to = msg_.user instead of to = msg_.removeParams.magnetar, stealing the corresponding assets from magnetar balance (i.e. instead of forwarding the user assets received it will use assets from the own balance instead as user both received assets directly and called withdraw via magnetar).\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/TapiocaZ/pull/180.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {\n    TOFTInitStruct,\n    MarketBorrowMsg,\n    MarketRemoveCollateralMsg,\n    LeverageUpActionMsg\n} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {\n    IMagnetar,\n    MagnetarCall,\n    DepositAddCollateralAndBorrowFromMarketData,\n    MagnetarAction\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {MagnetarCollateralModule} from \"tapioca-periph/Magnetar/modules/MagnetarCollateralModule.sol\";\nimport {MagnetarYieldBoxModule} from \"tapioca-periph/Magnetar/modules/MagnetarYieldBoxModule.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {TOFTMsgCodec} from \"contracts/tOFT/libraries/TOFTMsgCodec.sol\";\nimport {BaseTOFT} from \"contracts/tOFT/BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFTMarketReceiverModule\n * @author TapiocaDAO\n * @notice TOFT Market module\n */\ncontract TOFTMarketReceiverModule is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n\n    error TOFTMarketReceiverModule_NotAuthorized(address invalidAddress);\n\n    event BorrowReceived(\n        address indexed user, address indexed market, uint256 indexed amount, bool deposit, bool withdraw\n    );\n\n    event RemoveCollateralReceived(address indexed user, address indexed market, uint256 indexed amount, bool withdraw);\n\n    event LeverageUpReceived(\n        address indexed user, address indexed market, uint256 indexed amount, uint256 supplyAmount\n    );\n\n    constructor(TOFTInitStruct memory _data) BaseTOFT(_data) {}\n\n    /**\n     * @notice Calls `buyCollateral` on a market\n     * @param _data The call data containing info about the operation.\n     *      - user::address: Address to leverage for.\n     *      - market::address: Address of the market.\n     *      - borrowAmount::address: Borrow amount to leverage with.\n     *      - supplyAmount::address: Extra asset amount used for the leverage operation.\n     *      - executorData::bytes: Leverage executor data.\n     */\n    function leverageUpReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        LeverageUpActionMsg memory msg_ = TOFTMsgCodec.decodeLeverageUpMsg(_data);\n\n        /// @dev 'market'\n        _checkWhitelistStatus(msg_.market);\n\n        msg_.borrowAmount = _toLD(msg_.borrowAmount.toUint64());\n        if (msg_.supplyAmount > 0) {\n            msg_.supplyAmount = _toLD(msg_.supplyAmount.toUint64());\n        }\n\n        approve(address(msg_.market), type(uint256).max);\n\n        {\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.marketHelper).buyCollateral(\n                msg_.user, msg_.borrowAmount, msg_.supplyAmount, msg_.executorData\n            );\n            IMarket(msg_.market).execute(modules, calls, true);\n        }\n\n        approve(address(msg_.market), 0);\n\n        emit LeverageUpReceived(msg_.user, msg_.market, msg_.borrowAmount, msg_.supplyAmount);\n    }\n\n    /**\n     * @notice Calls depositAddCollateralAndBorrowFromMarket on Magnetar\n     * @param _data The call data containing info about the operation.\n     *      - from::address: Address to debit tokens from.\n     *      - to::address: Address to execute operations on.\n     *      - borrowParams::struct: Borrow operation related params.\n     *      - withdrawParams::struct: Withdraw related params.\n     */\n    function marketBorrowReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketBorrowMsg memory msg_ = TOFTMsgCodec.decodeMarketBorrowMsg(_data);\n\n        _checkWhitelistStatus(msg_.borrowParams.marketHelper);\n        _checkWhitelistStatus(msg_.borrowParams.magnetar);\n        _checkWhitelistStatus(msg_.borrowParams.market);\n\n        msg_.borrowParams.amount = _toLD(msg_.borrowParams.amount.toUint64());\n        msg_.borrowParams.borrowAmount = _toLD(msg_.borrowParams.borrowAmount.toUint64());\n\n        /// @dev use market helper to deposit, add collateral to market and withdrawTo\n        approve(address(msg_.borrowParams.magnetar), msg_.borrowParams.amount);\n\n        bytes memory call = abi.encodeWithSelector(\n            MagnetarCollateralModule.depositAddCollateralAndBorrowFromMarket.selector,\n            DepositAddCollateralAndBorrowFromMarketData(\n                msg_.borrowParams.market,\n                msg_.borrowParams.marketHelper,\n                msg_.user,\n                msg_.borrowParams.amount,\n                msg_.borrowParams.borrowAmount,\n                msg_.borrowParams.deposit,\n                msg_.withdrawParams\n            )\n        );\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.CollateralModule,\n            target: msg_.borrowParams.market,\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.borrowParams.magnetar)).burst{value: msg.value}(magnetarCall);\n\n        emit BorrowReceived(\n            msg_.user,\n            msg_.borrowParams.market,\n            msg_.borrowParams.amount,\n            msg_.borrowParams.deposit,\n            msg_.withdrawParams.withdraw\n        );\n    }\n\n    /**\n     * @notice Performs market.removeCollateral()\n     * @param _data The call data containing info about the operation.\n     *      - from::address: Address to debit tokens from.\n     *      - to::address: Address to execute operations on.\n     *      - removeParams::struct: Remove collateral operation related params.\n     *      - withdrawParams::struct: Withdraw related params.\n     */\n    function marketRemoveCollateralReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketRemoveCollateralMsg memory msg_ = TOFTMsgCodec.decodeMarketRemoveCollateralMsg(_data);\n\n        _checkWhitelistStatus(msg_.removeParams.market);\n\n        address ybAddress = IMarket(msg_.removeParams.market).yieldBox();\n        uint256 assetId = IMarket(msg_.removeParams.market).collateralId();\n\n        msg_.removeParams.amount = _toLD(msg_.removeParams.amount.toUint64());\n\n        {\n            uint256 share = IYieldBox(ybAddress).toShare(assetId, msg_.removeParams.amount, false);\n            approve(msg_.removeParams.market, share);\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.removeParams.marketHelper)\n                .removeCollateral(msg_.user, msg_.withdrawParams.withdraw ? msg_.removeParams.magnetar : msg_.user, share);\n            IMarket(msg_.removeParams.market).execute(modules, calls, true);\n        }\n\n        {\n            if (msg_.withdrawParams.withdraw) {\n                _checkWhitelistStatus(msg_.removeParams.magnetar);\n\n                bytes memory call =\n                    abi.encodeWithSelector(MagnetarYieldBoxModule.withdrawToChain.selector, msg_.withdrawParams);\n                MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n                magnetarCall[0] = MagnetarCall({\n                    id: MagnetarAction.YieldBoxModule,\n                    target: address(this),\n                    value: msg.value,\n                    allowFailure: false,\n                    call: call\n                });\n                IMagnetar(payable(msg_.removeParams.magnetar)).burst{value: msg.value}(magnetarCall);\n            }\n        }\n\n        emit RemoveCollateralReceived(\n            msg_.user, msg_.removeParams.market, msg_.removeParams.amount, msg_.withdrawParams.withdraw\n        );\n    }\n\n    function _checkWhitelistStatus(address _addr) private view {\n        if (_addr != address(0)) {\n            if (!cluster.isWhitelisted(0, _addr)) {\n                revert TOFTMarketReceiverModule_NotAuthorized(_addr);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {\n    TOFTInitStruct,\n    MarketBorrowMsg,\n    MarketRemoveCollateralMsg,\n    LeverageUpActionMsg\n} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {\n    IMagnetar,\n    MagnetarCall,\n    DepositAddCollateralAndBorrowFromMarketData,\n    MagnetarAction\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {MagnetarCollateralModule} from \"tapioca-periph/Magnetar/modules/MagnetarCollateralModule.sol\";\nimport {MagnetarYieldBoxModule} from \"tapioca-periph/Magnetar/modules/MagnetarYieldBoxModule.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {TOFTMsgCodec} from \"contracts/tOFT/libraries/TOFTMsgCodec.sol\";\nimport {BaseTOFT} from \"contracts/tOFT/BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFTMarketReceiverModule\n * @author TapiocaDAO\n * @notice TOFT Market module\n */\ncontract TOFTMarketReceiverModule is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n\n    error TOFTMarketReceiverModule_NotAuthorized(address invalidAddress);\n\n    event BorrowReceived(\n        address indexed user, address indexed market, uint256 indexed amount, bool deposit, bool withdraw\n    );\n\n    event RemoveCollateralReceived(address indexed user, address indexed market, uint256 indexed amount, bool withdraw);\n\n    event LeverageUpReceived(\n        address indexed user, address indexed market, uint256 indexed amount, uint256 supplyAmount\n    );\n\n    constructor(TOFTInitStruct memory _data) BaseTOFT(_data) {}\n\n    /**\n     * @notice Calls `buyCollateral` on a market\n     * @param _data The call data containing info about the operation.\n     *      - user::address: Address to leverage for.\n     *      - market::address: Address of the market.\n     *      - borrowAmount::address: Borrow amount to leverage with.\n     *      - supplyAmount::address: Extra asset amount used for the leverage operation.\n     *      - executorData::bytes: Leverage executor data.\n     */\n    function leverageUpReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        LeverageUpActionMsg memory msg_ = TOFTMsgCodec.decodeLeverageUpMsg(_data);\n\n        /// @dev 'market'\n        _checkWhitelistStatus(msg_.market);\n\n        msg_.borrowAmount = _toLD(msg_.borrowAmount.toUint64());\n        if (msg_.supplyAmount > 0) {\n            msg_.supplyAmount = _toLD(msg_.supplyAmount.toUint64());\n        }\n\n        approve(address(msg_.market), type(uint256).max);\n\n        {\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.marketHelper).buyCollateral(\n                msg_.user, msg_.borrowAmount, msg_.supplyAmount, msg_.executorData\n            );\n            IMarket(msg_.market).execute(modules, calls, true);\n        }\n\n        approve(address(msg_.market), 0);\n\n        emit LeverageUpReceived(msg_.user, msg_.market, msg_.borrowAmount, msg_.supplyAmount);\n    }\n\n    /**\n     * @notice Calls depositAddCollateralAndBorrowFromMarket on Magnetar\n     * @param _data The call data containing info about the operation.\n     *      - from::address: Address to debit tokens from.\n     *      - to::address: Address to execute operations on.\n     *      - borrowParams::struct: Borrow operation related params.\n     *      - withdrawParams::struct: Withdraw related params.\n     */\n    function marketBorrowReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketBorrowMsg memory msg_ = TOFTMsgCodec.decodeMarketBorrowMsg(_data);\n\n        _checkWhitelistStatus(msg_.borrowParams.marketHelper);\n        _checkWhitelistStatus(msg_.borrowParams.magnetar);\n        _checkWhitelistStatus(msg_.borrowParams.market);\n\n        msg_.borrowParams.amount = _toLD(msg_.borrowParams.amount.toUint64());\n        msg_.borrowParams.borrowAmount = _toLD(msg_.borrowParams.borrowAmount.toUint64());\n\n        /// @dev use market helper to deposit, add collateral to market and withdrawTo\n        approve(address(msg_.borrowParams.magnetar), msg_.borrowParams.amount);\n\n        bytes memory call = abi.encodeWithSelector(\n            MagnetarCollateralModule.depositAddCollateralAndBorrowFromMarket.selector,\n            DepositAddCollateralAndBorrowFromMarketData(\n                msg_.borrowParams.market,\n                msg_.borrowParams.marketHelper,\n                msg_.user,\n                msg_.borrowParams.amount,\n                msg_.borrowParams.borrowAmount,\n                msg_.borrowParams.deposit,\n                msg_.withdrawParams\n            )\n        );\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.CollateralModule,\n            target: msg_.borrowParams.market,\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.borrowParams.magnetar)).burst{value: msg.value}(magnetarCall);\n\n        emit BorrowReceived(\n            msg_.user,\n            msg_.borrowParams.market,\n            msg_.borrowParams.amount,\n            msg_.borrowParams.deposit,\n            msg_.withdrawParams.withdraw\n        );\n    }\n\n    /**\n     * @notice Performs market.removeCollateral()\n     * @param _data The call data containing info about the operation.\n     *      - from::address: Address to debit tokens from.\n     *      - to::address: Address to execute operations on.\n     *      - removeParams::struct: Remove collateral operation related params.\n     *      - withdrawParams::struct: Withdraw related params.\n     */\n    function marketRemoveCollateralReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketRemoveCollateralMsg memory msg_ = TOFTMsgCodec.decodeMarketRemoveCollateralMsg(_data);\n\n        _checkWhitelistStatus(msg_.removeParams.market);\n\n        address ybAddress = IMarket(msg_.removeParams.market).yieldBox();\n        uint256 assetId = IMarket(msg_.removeParams.market).collateralId();\n\n        msg_.removeParams.amount = _toLD(msg_.removeParams.amount.toUint64());\n\n        {\n            uint256 share = IYieldBox(ybAddress).toShare(assetId, msg_.removeParams.amount, false);\n            approve(msg_.removeParams.market, share);\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.removeParams.marketHelper)\n                .removeCollateral(msg_.user, msg_.withdrawParams.withdraw ? msg_.removeParams.magnetar : msg_.user, share);\n            IMarket(msg_.removeParams.market).execute(modules, calls, true);\n        }\n\n        {\n            if (msg_.withdrawParams.withdraw) {\n                _checkWhitelistStatus(msg_.removeParams.magnetar);\n\n                bytes memory call =\n                    abi.encodeWithSelector(MagnetarYieldBoxModule.withdrawToChain.selector, msg_.withdrawParams);\n                MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n                magnetarCall[0] = MagnetarCall({\n                    id: MagnetarAction.YieldBoxModule,\n                    target: address(this),\n                    value: msg.value,\n                    allowFailure: false,\n                    call: call\n                });\n                IMagnetar(payable(msg_.removeParams.magnetar)).burst{value: msg.value}(magnetarCall);\n            }\n        }\n\n        emit RemoveCollateralReceived(\n            msg_.user, msg_.removeParams.market, msg_.removeParams.amount, msg_.withdrawParams.withdraw\n        );\n    }\n\n    function _checkWhitelistStatus(address _addr) private view {\n        if (_addr != address(0)) {\n            if (!cluster.isWhitelisted(0, _addr)) {\n                revert TOFTMarketReceiverModule_NotAuthorized(_addr);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {\n    TOFTInitStruct,\n    MarketBorrowMsg,\n    MarketRemoveCollateralMsg,\n    LeverageUpActionMsg\n} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {\n    IMagnetar,\n    MagnetarCall,\n    DepositAddCollateralAndBorrowFromMarketData,\n    MagnetarAction\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {MagnetarCollateralModule} from \"tapioca-periph/Magnetar/modules/MagnetarCollateralModule.sol\";\nimport {MagnetarYieldBoxModule} from \"tapioca-periph/Magnetar/modules/MagnetarYieldBoxModule.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {TOFTMsgCodec} from \"contracts/tOFT/libraries/TOFTMsgCodec.sol\";\nimport {BaseTOFT} from \"contracts/tOFT/BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFTMarketReceiverModule\n * @author TapiocaDAO\n * @notice TOFT Market module\n */\ncontract TOFTMarketReceiverModule is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n\n    error TOFTMarketReceiverModule_NotAuthorized(address invalidAddress);\n\n    event BorrowReceived(\n        address indexed user, address indexed market, uint256 indexed amount, bool deposit, bool withdraw\n    );\n\n    event RemoveCollateralReceived(address indexed user, address indexed market, uint256 indexed amount, bool withdraw);\n\n    event LeverageUpReceived(\n        address indexed user, address indexed market, uint256 indexed amount, uint256 supplyAmount\n    );\n\n    constructor(TOFTInitStruct memory _data) BaseTOFT(_data) {}\n\n    /**\n     * @notice Calls `buyCollateral` on a market\n     * @param _data The call data containing info about the operation.\n     *      - user::address: Address to leverage for.\n     *      - market::address: Address of the market.\n     *      - borrowAmount::address: Borrow amount to leverage with.\n     *      - supplyAmount::address: Extra asset amount used for the leverage operation.\n     *      - executorData::bytes: Leverage executor data.\n     */\n    function leverageUpReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        LeverageUpActionMsg memory msg_ = TOFTMsgCodec.decodeLeverageUpMsg(_data);\n\n        /// @dev 'market'\n        _checkWhitelistStatus(msg_.market);\n\n        msg_.borrowAmount = _toLD(msg_.borrowAmount.toUint64());\n        if (msg_.supplyAmount > 0) {\n            msg_.supplyAmount = _toLD(msg_.supplyAmount.toUint64());\n        }\n\n        approve(address(msg_.market), type(uint256).max);\n\n        {\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.marketHelper).buyCollateral(\n                msg_.user, msg_.borrowAmount, msg_.supplyAmount, msg_.executorData\n            );\n            IMarket(msg_.market).execute(modules, calls, true);\n        }\n\n        approve(address(msg_.market), 0);\n\n        emit LeverageUpReceived(msg_.user, msg_.market, msg_.borrowAmount, msg_.supplyAmount);\n    }\n\n    /**\n     * @notice Calls depositAddCollateralAndBorrowFromMarket on Magnetar\n     * @param _data The call data containing info about the operation.\n     *      - from::address: Address to debit tokens from.\n     *      - to::address: Address to execute operations on.\n     *      - borrowParams::struct: Borrow operation related params.\n     *      - withdrawParams::struct: Withdraw related params.\n     */\n    function marketBorrowReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketBorrowMsg memory msg_ = TOFTMsgCodec.decodeMarketBorrowMsg(_data);\n\n        _checkWhitelistStatus(msg_.borrowParams.marketHelper);\n        _checkWhitelistStatus(msg_.borrowParams.magnetar);\n        _checkWhitelistStatus(msg_.borrowParams.market);\n\n        msg_.borrowParams.amount = _toLD(msg_.borrowParams.amount.toUint64());\n        msg_.borrowParams.borrowAmount = _toLD(msg_.borrowParams.borrowAmount.toUint64());\n\n        /// @dev use market helper to deposit, add collateral to market and withdrawTo\n        approve(address(msg_.borrowParams.magnetar), msg_.borrowParams.amount);\n\n        bytes memory call = abi.encodeWithSelector(\n            MagnetarCollateralModule.depositAddCollateralAndBorrowFromMarket.selector,\n            DepositAddCollateralAndBorrowFromMarketData(\n                msg_.borrowParams.market,\n                msg_.borrowParams.marketHelper,\n                msg_.user,\n                msg_.borrowParams.amount,\n                msg_.borrowParams.borrowAmount,\n                msg_.borrowParams.deposit,\n                msg_.withdrawParams\n            )\n        );\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.CollateralModule,\n            target: msg_.borrowParams.market,\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.borrowParams.magnetar)).burst{value: msg.value}(magnetarCall);\n\n        emit BorrowReceived(\n            msg_.user,\n            msg_.borrowParams.market,\n            msg_.borrowParams.amount,\n            msg_.borrowParams.deposit,\n            msg_.withdrawParams.withdraw\n        );\n    }\n\n    /**\n     * @notice Performs market.removeCollateral()\n     * @param _data The call data containing info about the operation.\n     *      - from::address: Address to debit tokens from.\n     *      - to::address: Address to execute operations on.\n     *      - removeParams::struct: Remove collateral operation related params.\n     *      - withdrawParams::struct: Withdraw related params.\n     */\n    function marketRemoveCollateralReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketRemoveCollateralMsg memory msg_ = TOFTMsgCodec.decodeMarketRemoveCollateralMsg(_data);\n\n        _checkWhitelistStatus(msg_.removeParams.market);\n\n        address ybAddress = IMarket(msg_.removeParams.market).yieldBox();\n        uint256 assetId = IMarket(msg_.removeParams.market).collateralId();\n\n        msg_.removeParams.amount = _toLD(msg_.removeParams.amount.toUint64());\n\n        {\n            uint256 share = IYieldBox(ybAddress).toShare(assetId, msg_.removeParams.amount, false);\n            approve(msg_.removeParams.market, share);\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.removeParams.marketHelper)\n                .removeCollateral(msg_.user, msg_.withdrawParams.withdraw ? msg_.removeParams.magnetar : msg_.user, share);\n            IMarket(msg_.removeParams.market).execute(modules, calls, true);\n        }\n\n        {\n            if (msg_.withdrawParams.withdraw) {\n                _checkWhitelistStatus(msg_.removeParams.magnetar);\n\n                bytes memory call =\n                    abi.encodeWithSelector(MagnetarYieldBoxModule.withdrawToChain.selector, msg_.withdrawParams);\n                MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n                magnetarCall[0] = MagnetarCall({\n                    id: MagnetarAction.YieldBoxModule,\n                    target: address(this),\n                    value: msg.value,\n                    allowFailure: false,\n                    call: call\n                });\n                IMagnetar(payable(msg_.removeParams.magnetar)).burst{value: msg.value}(magnetarCall);\n            }\n        }\n\n        emit RemoveCollateralReceived(\n            msg_.user, msg_.removeParams.market, msg_.removeParams.amount, msg_.withdrawParams.withdraw\n        );\n    }\n\n    function _checkWhitelistStatus(address _addr) private view {\n        if (_addr != address(0)) {\n            if (!cluster.isWhitelisted(0, _addr)) {\n                revert TOFTMarketReceiverModule_NotAuthorized(_addr);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {\n    TOFTInitStruct,\n    MarketBorrowMsg,\n    MarketRemoveCollateralMsg,\n    LeverageUpActionMsg\n} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {\n    IMagnetar,\n    MagnetarCall,\n    DepositAddCollateralAndBorrowFromMarketData,\n    MagnetarAction\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {MagnetarCollateralModule} from \"tapioca-periph/Magnetar/modules/MagnetarCollateralModule.sol\";\nimport {MagnetarYieldBoxModule} from \"tapioca-periph/Magnetar/modules/MagnetarYieldBoxModule.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {TOFTMsgCodec} from \"contracts/tOFT/libraries/TOFTMsgCodec.sol\";\nimport {BaseTOFT} from \"contracts/tOFT/BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFTMarketReceiverModule\n * @author TapiocaDAO\n * @notice TOFT Market module\n */\ncontract TOFTMarketReceiverModule is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n\n    error TOFTMarketReceiverModule_NotAuthorized(address invalidAddress);\n\n    event BorrowReceived(\n        address indexed user, address indexed market, uint256 indexed amount, bool deposit, bool withdraw\n    );\n\n    event RemoveCollateralReceived(address indexed user, address indexed market, uint256 indexed amount, bool withdraw);\n\n    event LeverageUpReceived(\n        address indexed user, address indexed market, uint256 indexed amount, uint256 supplyAmount\n    );\n\n    constructor(TOFTInitStruct memory _data) BaseTOFT(_data) {}\n\n    /**\n     * @notice Calls `buyCollateral` on a market\n     * @param _data The call data containing info about the operation.\n     *      - user::address: Address to leverage for.\n     *      - market::address: Address of the market.\n     *      - borrowAmount::address: Borrow amount to leverage with.\n     *      - supplyAmount::address: Extra asset amount used for the leverage operation.\n     *      - executorData::bytes: Leverage executor data.\n     */\n    function leverageUpReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        LeverageUpActionMsg memory msg_ = TOFTMsgCodec.decodeLeverageUpMsg(_data);\n\n        /// @dev 'market'\n        _checkWhitelistStatus(msg_.market);\n\n        msg_.borrowAmount = _toLD(msg_.borrowAmount.toUint64());\n        if (msg_.supplyAmount > 0) {\n            msg_.supplyAmount = _toLD(msg_.supplyAmount.toUint64());\n        }\n\n        approve(address(msg_.market), type(uint256).max);\n\n        {\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.marketHelper).buyCollateral(\n                msg_.user, msg_.borrowAmount, msg_.supplyAmount, msg_.executorData\n            );\n            IMarket(msg_.market).execute(modules, calls, true);\n        }\n\n        approve(address(msg_.market), 0);\n\n        emit LeverageUpReceived(msg_.user, msg_.market, msg_.borrowAmount, msg_.supplyAmount);\n    }\n\n    /**\n     * @notice Calls depositAddCollateralAndBorrowFromMarket on Magnetar\n     * @param _data The call data containing info about the operation.\n     *      - from::address: Address to debit tokens from.\n     *      - to::address: Address to execute operations on.\n     *      - borrowParams::struct: Borrow operation related params.\n     *      - withdrawParams::struct: Withdraw related params.\n     */\n    function marketBorrowReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketBorrowMsg memory msg_ = TOFTMsgCodec.decodeMarketBorrowMsg(_data);\n\n        _checkWhitelistStatus(msg_.borrowParams.marketHelper);\n        _checkWhitelistStatus(msg_.borrowParams.magnetar);\n        _checkWhitelistStatus(msg_.borrowParams.market);\n\n        msg_.borrowParams.amount = _toLD(msg_.borrowParams.amount.toUint64());\n        msg_.borrowParams.borrowAmount = _toLD(msg_.borrowParams.borrowAmount.toUint64());\n\n        /// @dev use market helper to deposit, add collateral to market and withdrawTo\n        approve(address(msg_.borrowParams.magnetar), msg_.borrowParams.amount);\n\n        bytes memory call = abi.encodeWithSelector(\n            MagnetarCollateralModule.depositAddCollateralAndBorrowFromMarket.selector,\n            DepositAddCollateralAndBorrowFromMarketData(\n                msg_.borrowParams.market,\n                msg_.borrowParams.marketHelper,\n                msg_.user,\n                msg_.borrowParams.amount,\n                msg_.borrowParams.borrowAmount,\n                msg_.borrowParams.deposit,\n                msg_.withdrawParams\n            )\n        );\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.CollateralModule,\n            target: msg_.borrowParams.market,\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.borrowParams.magnetar)).burst{value: msg.value}(magnetarCall);\n\n        emit BorrowReceived(\n            msg_.user,\n            msg_.borrowParams.market,\n            msg_.borrowParams.amount,\n            msg_.borrowParams.deposit,\n            msg_.withdrawParams.withdraw\n        );\n    }\n\n    /**\n     * @notice Performs market.removeCollateral()\n     * @param _data The call data containing info about the operation.\n     *      - from::address: Address to debit tokens from.\n     *      - to::address: Address to execute operations on.\n     *      - removeParams::struct: Remove collateral operation related params.\n     *      - withdrawParams::struct: Withdraw related params.\n     */\n    function marketRemoveCollateralReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketRemoveCollateralMsg memory msg_ = TOFTMsgCodec.decodeMarketRemoveCollateralMsg(_data);\n\n        _checkWhitelistStatus(msg_.removeParams.market);\n\n        address ybAddress = IMarket(msg_.removeParams.market).yieldBox();\n        uint256 assetId = IMarket(msg_.removeParams.market).collateralId();\n\n        msg_.removeParams.amount = _toLD("
    }
  ]
}