{
  "Title": "[N-04]  Inconsistent safe transfer library used",
  "Content": "Most places in the code use `GPv2SafeERC20`, but this one uses `SafeERC20`. All areas should use the same libraries.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol\n\n16:  import {SafeERC20} from \"../../../dependencies/openzeppelin/contracts/SafeERC20.sol\";\n\n```\nhttps://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol#L16\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-11-paraspace",
  "Code": [
    {
      "filename": "paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC721} from \"../../../dependencies/openzeppelin/contracts/IERC721.sol\";\nimport {INToken} from \"../../../interfaces/INToken.sol\";\nimport {IPoolAddressesProvider} from \"../../../interfaces/IPoolAddressesProvider.sol\";\nimport {XTokenType} from \"../../../interfaces/IXTokenType.sol\";\nimport {ICollateralizableERC721} from \"../../../interfaces/ICollateralizableERC721.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {IPToken} from \"../../../interfaces/IPToken.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {ValidationLogic} from \"./ValidationLogic.sol\";\nimport {SupplyLogic} from \"./SupplyLogic.sol\";\nimport {BorrowLogic} from \"./BorrowLogic.sol\";\nimport {SeaportInterface} from \"../../../dependencies/seaport/contracts/interfaces/SeaportInterface.sol\";\nimport {SafeERC20} from \"../../../dependencies/openzeppelin/contracts/SafeERC20.sol\";\nimport {IERC20} from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport {IERC721} from \"../../../dependencies/openzeppelin/contracts/IERC721.sol\";\nimport {ConsiderationItem, OfferItem} from \"../../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {ItemType} from \"../../../dependencies/seaport/contracts/lib/ConsiderationEnums.sol\";\nimport {AdvancedOrder, CriteriaResolver, Fulfillment} from \"../../../dependencies/seaport/contracts/lib/ConsiderationStructs.sol\";\nimport {IWETH} from \"../../../misc/interfaces/IWETH.sol\";\nimport {UserConfiguration} from \"../configuration/UserConfiguration.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {IMarketplace} from \"../../../interfaces/IMarketplace.sol\";\nimport {Address} from \"../../../dependencies/openzeppelin/contracts/Address.sol\";\n\n/**\n * @title Marketplace library\n *\n * @notice Implements the base logic for all the actions related to NFT buy/accept bid\n */\nlibrary MarketplaceLogic {\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using SafeERC20 for IERC20;\n\n    event BuyWithCredit(\n        bytes32 indexed marketplaceId,\n        DataTypes.OrderInfo orderInfo,\n        DataTypes.Credit credit\n    );\n\n    event AcceptBidWithCredit(\n        bytes32 indexed marketplaceId,\n        DataTypes.OrderInfo orderInfo,\n        DataTypes.Credit credit\n    );\n\n    struct MarketplaceLocalVars {\n        bool isETH;\n        address xTokenAddress;\n        address creditToken;\n        uint256 creditAmount;\n        address weth;\n        uint256 ethLeft;\n        bytes32 marketplaceId;\n        bytes payload;\n        DataTypes.Marketplace marketplace;\n        DataTypes.OrderInfo orderInfo;\n    }\n\n    function executeBuyWithCredit(\n        bytes32 marketplaceId,\n        bytes calldata payload,\n        DataTypes.Credit calldata credit,\n        DataTypes.PoolStorage storage ps,\n        IPoolAddressesProvider poolAddressProvider,\n        uint16 referralCode\n    ) external {\n        MarketplaceLocalVars memory vars;\n\n        vars.weth = poolAddressProvider.getWETH();\n        DataTypes.Marketplace memory marketplace = poolAddressProvider\n            .getMarketplace(marketplaceId);\n        DataTypes.OrderInfo memory orderInfo = IMarketplace(marketplace.adapter)\n            .getAskOrderInfo(payload, vars.weth);\n        orderInfo.taker = msg.sender;\n        vars.ethLeft = msg.value;\n\n        _depositETH(vars, orderInfo);\n\n        vars.ethLeft -= _buyWithCredit(\n            ps._reserves,\n            ps._reservesList,\n            ps._usersConfig[orderInfo.taker],\n            DataTypes.ExecuteMarketplaceParams({\n                marketplaceId: marketplaceId,\n                payload: payload,\n                credit: credit,\n                ethLeft: vars.ethLeft,\n                marketplace: marketplace,\n                orderInfo: orderInfo,\n                weth: vars.weth,\n                referralCode: referralCode,\n                reservesCount: ps._reservesCount,\n                oracle: poolAddressProvider.getPriceOracle(),\n                priceOracleSentinel: poolAddressProvider.getPriceOracleSentinel()\n            })\n        );\n\n        _refundETH(vars.ethLeft);\n    }\n\n    /**\n     * @notice Implements the buyWithCredit feature. BuyWithCredit allows users to buy NFT from various NFT marketplaces\n     * including OpenSea, LooksRare, X2Y2 etc. Users can use NFT's credit and will need to pay at most (1 - LTV) * $NFT\n     * @dev  Emits the `BuyWithCredit()` event\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the buyWithCredit function\n     */\n    function _buyWithCredit(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteMarketplaceParams memory params\n    ) internal returns (uint256) {\n        ValidationLogic.validateBuyWithCredit(params);\n\n        MarketplaceLocalVars memory vars = _cache(params);\n\n        _borrowTo(reservesData, params, vars, address(this));\n\n        (uint256 priceEth, uint256 downpaymentEth) = _delegateToPool(\n            params,\n            vars\n        );\n\n        // delegateCall to avoid extra token transfer\n        Address.functionDelegateCall(\n            params.marketplace.adapter,\n            abi.encodeWithSelector(\n                IMarketplace.matchAskWithTakerBid.selector,\n                params.marketplace.marketplace,\n                params.payload,\n                priceEth\n            )\n        );\n\n        _repay(\n            reservesData,\n            reservesList,\n            userConfig,\n            params,\n            vars,\n            params.orderInfo.taker\n        );\n\n        emit BuyWithCredit(\n            params.marketplaceId,\n            params.orderInfo,\n            params.credit\n        );\n\n        return downpaymentEth;\n    }\n\n    function executeBatchBuyWithCredit(\n        bytes32[] calldata marketplaceIds,\n        bytes[] calldata payloads,\n        DataTypes.Credit[] calldata credits,\n        DataTypes.PoolStorage storage ps,\n        IPoolAddressesProvider poolAddressProvider,\n        uint16 referralCode\n    ) external {\n        MarketplaceLocalVars memory vars;\n\n        vars.weth = poolAddressProvider.getWETH();\n        require(\n            marketplaceIds.length == payloads.length &&\n                payloads.length == credits.length,\n            Errors.INCONSISTENT_PARAMS_LENGTH\n        );\n        vars.ethLeft = msg.value;\n        for (uint256 i = 0; i < marketplaceIds.length; i++) {\n            vars.marketplaceId = marketplaceIds[i];\n            vars.payload = payloads[i];\n            DataTypes.Credit memory credit = credits[i];\n\n            DataTypes.Marketplace memory marketplace = poolAddressProvider\n                .getMarketplace(vars.marketplaceId);\n            DataTypes.OrderInfo memory orderInfo = IMarketplace(\n                marketplace.adapter\n            ).getAskOrderInfo(vars.payload, vars.weth);\n            orderInfo.taker = msg.sender;\n\n            // Once we encounter a listing using WETH, then we convert all our ethLeft to WETH\n            // this also means that the parameters order is very important\n            //\n            // frontend/sdk needs to guarantee that WETH orders will always be put after ALL\n            // ETH orders, all ETH orders after WETH orders will fail\n            //\n            // eg. The following example image that the `taker` owns only ETH and wants to\n            // batch buy bunch of NFTs which are listed using WETH and ETH\n            //\n            // batchBuyWithCredit([ETH, WETH, ETH]) => ko\n            //                            | -> convert all ethLeft to WETH, 3rd purchase will fail\n            // batchBuyWithCredit([ETH, ETH, ETH]) => ok\n            // batchBuyWithCredit([ETH, ETH, WETH]) => ok\n            //\n            _depositETH(vars, orderInfo);\n\n            vars.ethLeft -= _buyWithCredit(\n                ps._reserves,\n                ps._reservesList,\n                ps._usersConfig[orderInfo.taker],\n                DataTypes.ExecuteMarketplaceParams({\n                    marketplaceId: vars.marketplaceId,\n                    payload: vars.payload,\n                    credit: credit,\n                    ethLeft: vars.ethLeft,\n                    marketplace: marketplace,\n                    orderInfo: orderInfo,\n                    weth: vars.weth,\n                    referralCode: referralCode,\n                    reservesCount: ps._reservesCount,\n                    oracle: poolAddressProvider.getPriceOracle(),\n                    priceOracleSentinel: poolAddressProvider\n                        .getPriceOracleSentinel()\n                })\n            );\n        }\n\n        _refundETH(vars.ethLeft);\n    }\n\n    function executeAcceptBidWithCredit(\n        bytes32 marketplaceId,\n        bytes calldata payload,\n        DataTypes.Credit calldata credit,\n        address onBehalfOf,\n        DataTypes.PoolStorage storage ps,\n        IPoolAddressesProvider poolAddressProvider,\n        uint16 referralCode\n    ) external {\n        MarketplaceLocalVars memory vars;\n\n        vars.weth = poolAddressProvider.getWETH();\n        vars.marketplace = poolAddressProvider.getMarketplace(marketplaceId);\n        vars.orderInfo = IMarketplace(vars.marketplace.adapter).getBidOrderInfo(\n            payload\n        );\n        require(vars.orderInfo.taker == onBehalfOf, Errors.INVALID_ORDER_TAKER);\n\n        _acceptBidWithCredit(\n            ps._reserves,\n            ps._reservesList,\n            ps._usersConfig[vars.orderInfo.maker],\n            DataTypes.ExecuteMarketplaceParams({\n                marketplaceId: marketplaceId,\n                payload: payload,\n                credit: credit,\n                ethLeft: 0,\n                marketplace: vars.marketplace,\n                orderInfo: vars.orderInfo,\n                weth: vars.weth,\n                referralCode: referralCode,\n                reservesCount: ps._reservesCount,\n                oracle: poolAddressProvider.getPriceOracle(),\n                priceOracleSentinel: poolAddressProvider.getPriceOracleSentinel()\n            })\n        );\n    }\n\n    function executeBatchAcceptBidWithCredit(\n        bytes32[] calldata marketplaceIds,\n        bytes[] calldata payloads,\n        DataTypes.Credit[] calldata credits,\n        address onBehalfOf,\n        DataTypes.PoolStorage storage ps,\n        IPoolAddressesProvider poolAddressProvider,\n        uint16 referralCode\n    ) external {\n        MarketplaceLocalVars memory vars;\n\n        vars.weth = poolAddressProvider.getWETH();\n        require(\n            marketplaceIds.length == payloads.length &&\n                payloads.length == credits.length,\n            Errors.INCONSISTENT_PARAMS_LENGTH\n        );\n        for (uint256 i = 0; i < marketplaceIds.length; i++) {\n            vars.marketplaceId = marketplaceIds[i];\n            vars.payload = payloads[i];\n            DataTypes.Credit memory credit = credits[i];\n\n            vars.marketplace = poolAddressProvider.getMarketplace(\n                vars.marketplaceId\n            );\n            vars.orderInfo = IMarketplace(vars.marketplace.adapter)\n                .getBidOrderInfo(vars.payload);\n            require(\n                vars.orderInfo.taker == onBehalfOf,\n                Errors.INVALID_ORDER_TAKER\n            );\n\n            _acceptBidWithCredit(\n                ps._reserves,\n                ps._reservesList,\n                ps._usersConfig[vars.orderInfo.maker],\n                DataTypes.ExecuteMarketplaceParams({\n                    marketplaceId: vars.marketplaceId,\n                    payload: vars.payload,\n                    credit: credit,\n                    ethLeft: 0,\n                    marketplace: vars.marketplace,\n                    orderInfo: vars.orderInfo,\n                    weth: vars.weth,\n                    referralCode: referralCode,\n                    reservesCount: ps._reservesCount,\n                    oracle: poolAddressProvider.getPriceOracle(),\n                    priceOracleSentinel: poolAddressProvider\n                        .getPriceOracleSentinel()\n                })\n            );\n        }\n    }\n\n    /**\n     * @notice Implements the acceptBidWithCredit feature. AcceptBidWithCredit allows users to\n     * accept a leveraged bid on ParaSpace NFT marketplace. Users can submit leveraged bid and pay\n     * at most (1 - LTV) * $NFT\n     * @dev  Emits the `AcceptBidWithCredit()` event\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the acceptBidWithCredit function\n     */\n    function _acceptBidWithCredit(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteMarketplaceParams memory params\n    ) internal {\n        ValidationLogic.validateAcceptBidWithCredit(params);\n\n        MarketplaceLocalVars memory vars = _cache(params);\n\n        _borrowTo(reservesData, params, vars, params.orderInfo.maker);\n\n        // delegateCall to avoid extra token transfer\n        Address.functionDelegateCall(\n            params.marketplace.adapter,\n            abi.encodeWithSelector(\n                IMarketplace.matchBidWithTakerAsk.selector,\n                params.marketplace.marketplace,\n                params.payload\n            )\n        );\n\n        _repay(\n            reservesData,\n            reservesList,\n            userConfig,\n            params,\n            vars,\n            params.orderInfo.maker\n        );\n\n        emit AcceptBidWithCredit(\n            params.marketplaceId,\n            params.orderInfo,\n            params.credit\n        );\n    }\n\n    /**\n     * @notice Transfer payNow portion from taker to this contract. This is only useful\n     * in buyWithCredit.\n     * @dev\n     * @param params The additional parameters needed to execute the buyWithCredit/acceptBidWithCredit function\n     * @param vars The marketplace local vars for caching storage values for future reads\n     */\n    function _delegateToPool(\n        DataTypes.ExecuteMarketplaceParams memory params,\n        MarketplaceLocalVars memory vars\n    ) internal returns (uint256, uint256) {\n        uint256 price = 0;\n\n        for (uint256 i = 0; i < params.orderInfo.consideration.length; i++) {\n            ConsiderationItem memory item = params.orderInfo.consideration[i];\n            require(\n                item.startAmount == item.endAmount,\n                Errors.INVALID_MARKETPLACE_ORDER\n            );\n            require(\n                item.itemType == ItemType.ERC20 ||\n                    (vars.isETH && item.itemType == ItemType.NATIVE),\n                Errors.INVALID_ASSET_TYPE\n            );\n            require(\n                item.token == params.credit.token,\n                Errors.CREDIT_DOES_NOT_MATCH_ORDER\n            );\n            price += item.startAmount;\n        }\n\n        uint256 downpayment = price - vars.creditAmount;\n        if (!vars.isETH) {\n            IERC20(vars.creditToken).safeTransferFrom(\n                params.orderInfo.taker,\n                address(this),\n                downpayment\n            );\n            _checkAllowance(vars.creditToken, params.marketplace.operator);\n            // convert to (priceEth, downpaymentEth)\n            price = 0;\n            downpayment = 0;\n        } else {\n            require(params.ethLeft >= downpayment, Errors.PAYNOW_NOT_ENOUGH);\n        }\n\n        return (price, downpayment);\n    }\n\n    /**\n     * @notice Borrow credit.amount from `credit.token` reserve without collateral. The corresponding\n     * debt will be minted in the same block to the borrower.\n     * @dev\n     * @param reservesData The state of all the reserves\n     * @param params The additional parameters needed to execute the buyWithCredit/acceptBidWithCredit function\n     * @param vars The marketplace local vars for caching storage values for future reads\n     * @param to The receiver of borrowed tokens\n     */\n    function _borrowTo(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.ExecuteMarketplaceParams memory params,\n        MarketplaceLocalVars memory vars,\n        address to\n    ) internal {\n        if (vars.creditAmount == 0) {\n            return;\n        }\n\n        DataTypes.ReserveData storage reserve = reservesData[vars.creditToken];\n        vars.xTokenAddress = reserve.xTokenAddress;\n\n        require(vars.xTokenAddress != address(0), Errors.ASSET_NOT_LISTED);\n        ValidationLogic.validateFlashloanSimple(reserve);\n        // TODO: support PToken\n        IPToken(vars.xTokenAddress).transferUnderlyingTo(to, vars.creditAmount);\n\n        if (vars.isETH) {\n            // No re-entrancy because it sent to our contract address\n            IWETH(params.weth).withdraw(vars.creditAmount);\n        }\n    }\n\n    /**\n     * @notice Repay credit.amount by minting debt to the borrower. Borrower's received NFT\n     * will also need to be supplied to the pool to provide bigger borrow limit.\n     * @dev\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param userConfig The user configuration mapping that tracks the supplied/borrowed assets\n     * @param params The additional parameters needed to execute the buyWithCredit/acceptBidWithCredit function\n     * @param vars The marketplace local vars for caching storage values for future reads\n     * @param onBehalfOf The receiver of minted debt and NToken\n     */\n    function _repay(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.UserConfigurationMap storage userConfig,\n        DataTypes.ExecuteMarketplaceParams memory params,\n        MarketplaceLocalVars memory vars,\n        address onBehalfOf\n    ) internal {\n        for (uint256 i = 0; i < params.orderInfo.offer.length; i++) {\n            OfferItem memory item = params.orderInfo.offer[i];\n            require(\n                item.itemType == ItemType.ERC721,\n                Errors.INVALID_ASSET_TYPE\n            );\n\n            // underlyingAsset\n            address token = item.token;\n            uint256 tokenId = item.identifierOrCriteria;\n            // NToken\n            vars.xTokenAddress = reservesData[token].xTokenAddress;\n\n            // item.token == NToken\n            if (vars.xTokenAddress == address(0)) {\n                address underlyingAsset = INToken(token)\n                    .UNDERLYING_ASSET_ADDRESS();\n                bool isNToken = reservesData[underlyingAsset].xTokenAddress ==\n                    token;\n                require(isNToken, Errors.ASSET_NOT_LISTED);\n                vars.xTokenAddress = token;\n                token = underlyingAsset;\n            }\n\n            require(\n                INToken(vars.xTokenAddress).getXTokenType() !=\n                    XTokenType.NTokenUniswapV3,\n                Errors.UNIV3_NOT_ALLOWED\n            );\n\n            // item.token == underlyingAsset but supplied after listing/offering\n            // so NToken is transferred instead\n            if (INToken(vars.xTokenAddress).ownerOf(tokenId) == address(this)) {\n                _transferAndCollateralize(\n                    reservesData,\n                    userConfig,\n                    vars,\n                    token,\n                    tokenId,\n                    onBehalfOf\n                );\n                // item.token == underlyingAsset and underlyingAsset stays in wallet\n            } else {\n                DataTypes.ERC721SupplyParams[]\n                    memory tokenData = new DataTypes.ERC721SupplyParams[](1);\n                tokenData[0] = DataTypes.ERC721SupplyParams(tokenId, true);\n                SupplyLogic.executeSupplyERC721(\n                    reservesData,\n                    userConfig,\n                    DataTypes.ExecuteSupplyERC721Params({\n                        asset: token,\n                        tokenData: tokenData,\n                        onBehalfOf: onBehalfOf,\n                        payer: address(this),\n                        referralCode: params.referralCode\n                    })\n                );\n            }\n        }\n\n        if (vars.creditAmount == 0) {\n            return;\n        }\n\n        BorrowLogic.executeBorrow(\n            reservesData,\n            reservesList,\n            userConfig,\n            DataTypes.ExecuteBorrowParams({\n                asset: vars.creditToken,\n                user: onBehalfOf,\n                onBehalfOf: onBehalfOf,\n                amount: vars.creditAmount,\n                referralCode: params.referralCode,\n                releaseUnderlying: false,\n                reservesCount: params.reservesCount,\n                oracle: params.oracle,\n                priceOracleSentinel: params.priceOracleSentinel\n            })\n        );\n    }\n\n    function _checkAllowance(address token, address operator) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), operator);\n        if (allowance == 0) {\n            IERC20(token).safeApprove(operator, type(uint256).max);\n        }\n    }\n\n    function _cache(DataTypes.ExecuteMarketplaceParams memory params)\n        internal\n        pure\n        returns (MarketplaceLocalVars memory vars)\n    {\n        vars.isETH = params.credit.token == address(0);\n        vars.creditToken = vars.isETH ? params.weth : params.credit.token;\n        vars.creditAmount = params.credit.amount;\n    }\n\n    function _refundETH(uint256 ethLeft) internal {\n        if (ethLeft > 0) {\n            Address.sendValue(payable(msg.sender), ethLeft);\n        }\n    }\n\n    function _depositETH(\n        MarketplaceLocalVars memory vars,\n        DataTypes.OrderInfo memory orderInfo\n    ) internal {\n        if (\n            vars.ethLeft > 0 &&\n            orderInfo.consideration[0].itemType != ItemType.NATIVE\n        ) {\n            IWETH(vars.weth).deposit{value: vars.ethLeft}();\n            IERC20(vars.weth).safeTransferFrom(\n                address(this),\n                msg.sender,\n                vars.ethLeft\n            );\n            vars.ethLeft = 0;\n        }\n    }\n\n    function _transferAndCollateralize(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.UserConfigurationMap storage userConfig,\n        MarketplaceLocalVars memory vars,\n        address token,\n        uint256 tokenId,\n        address onBehalfOf\n    ) internal {\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = tokenId;\n\n        IERC721(vars.xTokenAddress).safeTransferFrom(\n            address(this),\n            onBehalfOf,\n            tokenId\n        );\n        SupplyLogic.executeCollateralizeERC721(\n            reservesData,\n            userConfig,\n            token,\n            tokenIds,\n            onBehalfOf\n        );\n    }\n}"
    }
  ]
}