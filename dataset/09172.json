{
  "Title": "[G-23] Don't compare boolean expressions to boolean literals",
  "Content": "\n`if (<x> == true)` => `if (<x>)`, `if (<x> == false)` => `if (!<x>)`\n\n*There are 9 instances of this issue:*\n\n```solidity\nFile: contracts/AuraMerkleDrop.sol\n\n123:          require(hasClaimed[msg.sender] == false, \"already claimed\");\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraMerkleDrop.sol#L123>\n\n```solidity\nFile: convex-platform/contracts/contracts/ArbitartorVault.sol\n\n54:           require(shutdown==false,\"pool closed\");\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ArbitartorVault.sol#L54>\n\n```solidity\nFile: convex-platform/contracts/contracts/VoterProxy.sol\n\n107:          require(operator == address(0) || IDeposit(operator).isShutdown() == true, \"needs shutdown\");\n\n168:          if(protectedTokens[_token] == false){\n\n171:          if(protectedTokens[_gauge] == false){\n\n190:          require(protectedTokens[address(_asset)] == false, \"protected\");\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/VoterProxy.sol#L107>\n\n```solidity\nFile: convex-platform/contracts/contracts/Booster.sol\n\n400:          require(pool.shutdown == false, \"pool is closed\");\n\n574:          require(pool.shutdown == false, \"pool is closed\");\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/Booster.sol#L400>\n\n```solidity\nFile: convex-platform/contracts/contracts/RewardFactory.sol\n\n72:           require(msg.sender == operator || rewardAccess[msg.sender] == true, \"!auth\");\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/RewardFactory.sol#L72>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "contracts/AuraMerkleDrop.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { MerkleProof } from \"@openzeppelin/contracts-0.8/utils/cryptography/MerkleProof.sol\";\nimport { IAuraLocker } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\n\n/**\n * @title   AuraMerkleDrop\n * @dev     Forked from convex-platform/contracts/contracts/MerkleAirdrop.sol. Changes:\n *            - solc 0.8.11 & OpenZeppelin MerkleDrop\n *            - Delayed start w/ trigger\n *            - EndTime for withdrawal to treasuryDAO\n *            - Penalty on claim & AuraLocker lock (only if address(auraLocker) != 0)\n *            - Non custodial (cannot change root)\n */\ncontract AuraMerkleDrop {\n    using SafeERC20 for IERC20;\n\n    address public dao;\n    bytes32 public merkleRoot;\n\n    IERC20 public immutable aura;\n    IAuraLocker public auraLocker;\n\n    address public immutable penaltyForwarder;\n    uint256 public pendingPenalty = 0;\n\n    uint256 public startTime;\n    uint256 public immutable expiryTime;\n\n    mapping(address => bool) public hasClaimed;\n\n    event DaoSet(address newDao);\n    event RootSet(bytes32 newRoot);\n    event StartedEarly();\n    event ExpiredWithdrawn(uint256 amount);\n    event LockerSet(address newLocker);\n    event Claimed(address addr, uint256 amt, bool locked);\n    event PenaltyForwarded(uint256 amount);\n\n    /**\n     * @param _dao              The Aura Dao\n     * @param _merkleRoot       Merkle root\n     * @param _aura             Aura token\n     * @param _auraLocker       Aura locker contract\n     * @param _penaltyForwarder PenaltyForwarded contract\n     * @param _startDelay       Delay until claim is live\n     * @param _expiresAfter     Timestamp claim expires\n     */\n    constructor(\n        address _dao,\n        bytes32 _merkleRoot,\n        address _aura,\n        address _auraLocker,\n        address _penaltyForwarder,\n        uint256 _startDelay,\n        uint256 _expiresAfter\n    ) {\n        dao = _dao;\n        merkleRoot = _merkleRoot;\n        aura = IERC20(_aura);\n        auraLocker = IAuraLocker(_auraLocker);\n        penaltyForwarder = _penaltyForwarder;\n        startTime = block.timestamp + _startDelay;\n\n        require(_expiresAfter > 2 weeks, \"!expiry\");\n        expiryTime = startTime + _expiresAfter;\n    }\n\n    /***************************************\n                    CONFIG\n    ****************************************/\n\n    function setDao(address _newDao) external {\n        require(msg.sender == dao, \"!auth\");\n        dao = _newDao;\n        emit DaoSet(_newDao);\n    }\n\n    function setRoot(bytes32 _merkleRoot) external {\n        require(msg.sender == dao, \"!auth\");\n        require(merkleRoot == bytes32(0), \"already set\");\n        merkleRoot = _merkleRoot;\n        emit RootSet(_merkleRoot);\n    }\n\n    function startEarly() external {\n        require(msg.sender == dao, \"!auth\");\n        startTime = block.timestamp;\n        emit StartedEarly();\n    }\n\n    function withdrawExpired() external {\n        require(msg.sender == dao, \"!auth\");\n        require(block.timestamp > expiryTime, \"!expired\");\n        uint256 amt = aura.balanceOf(address(this));\n        aura.safeTransfer(dao, amt);\n        emit ExpiredWithdrawn(amt);\n    }\n\n    function setLocker(address _newLocker) external {\n        require(msg.sender == dao, \"!auth\");\n        auraLocker = IAuraLocker(_newLocker);\n        emit LockerSet(_newLocker);\n    }\n\n    /***************************************\n                    CLAIM\n    ****************************************/\n\n    function claim(\n        bytes32[] calldata _proof,\n        uint256 _amount,\n        bool _lock\n    ) public returns (bool) {\n        require(merkleRoot != bytes32(0), \"!root\");\n        require(block.timestamp > startTime, \"!started\");\n        require(block.timestamp < expiryTime, \"!active\");\n        require(_amount > 0, \"!amount\");\n        require(hasClaimed[msg.sender] == false, \"already claimed\");\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _amount));\n        require(MerkleProof.verify(_proof, merkleRoot, leaf), \"invalid proof\");\n\n        hasClaimed[msg.sender] = true;\n\n        if (_lock) {\n            aura.safeApprove(address(auraLocker), 0);\n            aura.safeApprove(address(auraLocker), _amount);\n            auraLocker.lock(msg.sender, _amount);\n        } else {\n            // If there is an address for auraLocker, and not locking, apply 20% penalty\n            uint256 penalty = address(auraLocker) == address(0) ? 0 : (_amount * 2) / 10;\n            pendingPenalty += penalty;\n            aura.safeTransfer(msg.sender, _amount - penalty);\n        }\n\n        emit Claimed(msg.sender, _amount, _lock);\n        return true;\n    }\n\n    /***************************************\n                    FORWARD\n    ****************************************/\n\n    function forwardPenalty() public {\n        uint256 toForward = pendingPenalty;\n        pendingPenalty = 0;\n        require(penaltyForwarder != address(0), \"!forwarder\");\n        aura.safeTransfer(penaltyForwarder, toForward);\n        emit PenaltyForwarded(toForward);\n    }\n}"
    },
    {
      "filename": "convex-platform/contracts/contracts/ArbitartorVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n/**\n * @title   ArbitratorVault\n * @author  ConvexFinance\n * @notice  Hold extra reward tokens on behalf of pools that have the same token as a reward (e.g. stkAAVE fro multiple aave pools)\n * @dev     Sits on top of the STASH to basically handle the re-distribution of rewards to multiple stashes.\n *          Because anyone can call gauge.claim_rewards(address) for the convex staking contract, rewards\n *          could be forced to the wrong pool. Hold tokens here and distribute fairly(or at least more fairly),\n *          to both pools at a later timing.\n */\ncontract ArbitratorVault{\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public operator;\n    address public immutable depositor;\n\n\n    /**\n     * @param  _depositor Booster address\n     */\n    constructor(address _depositor)public\n    {\n        operator = msg.sender;\n        depositor = _depositor;\n    }\n\n    function setOperator(address _op) external {\n        require(msg.sender == operator, \"!auth\");\n        operator = _op;\n    }\n\n    /**\n    * @notice  Permissioned fn to distribute any accrued rewards to a relevant stash\n    * @dev     Only called by operator: ConvexMultisig\n    */\n    function distribute(address _token, uint256[] calldata _toPids, uint256[] calldata _amounts) external {\n       require(msg.sender == operator, \"!auth\");\n\n       for(uint256 i = 0; i < _toPids.length; i++){\n        //get stash from pid\n        (,,,,address stashAddress,bool shutdown) = IDeposit(depositor).poolInfo(_toPids[i]);\n\n        //if sent to a shutdown pool, could get trapped\n        require(shutdown==false,\"pool closed\");\n\n        //transfer\n        IERC20(_token).safeTransfer(stashAddress, _amounts[i]);\n       }\n    }\n\n}"
    },
    {
      "filename": "convex-platform/contracts/contracts/VoterProxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n/**\n * @title   VoterProxy\n * @author  ConvexFinance\n * @notice  VoterProxy whitelisted in the curve SmartWalletWhitelist that\n *          participates in Curve governance. Also handles all deposits since this is \n *          the address that has the voting power.\n */\ncontract VoterProxy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public mintr;\n    address public immutable crv;\n    address public immutable crvBpt;\n\n    address public immutable escrow;\n    address public gaugeController;\n    address public rewardDeposit;\n    address public withdrawer;\n\n    address public owner;\n    address public operator;\n    address public depositor;\n    \n    mapping (address => bool) private stashPool;\n    mapping (address => bool) private protectedTokens;\n    mapping (bytes32 => bool) private votes;\n\n    bytes4 constant internal EIP1271_MAGIC_VALUE = 0x1626ba7e;\n\n    event VoteSet(bytes32 hash, bool valid);\n\n    /**\n     * @param _mintr            CRV minter\n     * @param _crv              CRV Token address\n     * @param _crvBpt           CRV:ETH 80-20 BPT Token address\n     * @param _escrow           Curve Voting escrow contract\n     * @param _gaugeController  Curve Gauge Controller\n     *                          Controls liquidity gauges and the issuance of coins through the gauges\n     */\n    constructor(\n        address _mintr,\n        address _crv,\n        address _crvBpt,\n        address _escrow,\n        address _gaugeController\n    ) public {\n        mintr = _mintr; \n        crv = _crv;\n        crvBpt = _crvBpt;\n        escrow = _escrow;\n        gaugeController = _gaugeController;\n        owner = msg.sender;\n\n        protectedTokens[_crv] = true;\n        protectedTokens[_crvBpt] = true;\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"BalancerVoterProxy\";\n    }\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n    }\n\n    /**\n     * @notice Allows dao to set the reward withdrawal address\n     * @param _withdrawer Whitelisted withdrawer\n     * @param _rewardDeposit Distributor address\n     */\n    function setRewardDeposit(address _withdrawer, address _rewardDeposit) external {\n        require(msg.sender == owner, \"!auth\");\n        withdrawer = _withdrawer;\n        rewardDeposit = _rewardDeposit;\n    }\n\n    /**\n     * @notice Allows dao to set the external system config, should it change in the future\n     * @param _gaugeController External gauge controller address\n     * @param _mintr Token minter address for claiming rewards\n     */\n    function setSystemConfig(address _gaugeController, address _mintr) external returns (bool) {\n        require(msg.sender == owner, \"!auth\");\n        gaugeController = _gaugeController;\n        mintr = _mintr;\n        return true;\n    }\n\n    /**\n     * @notice Set the operator of the VoterProxy\n     * @param _operator Address of the operator (Booster)\n     */\n    function setOperator(address _operator) external {\n        require(msg.sender == owner, \"!auth\");\n        require(operator == address(0) || IDeposit(operator).isShutdown() == true, \"needs shutdown\");\n        \n        operator = _operator;\n    }\n\n    /**\n     * @notice Set the depositor of the VoterProxy\n     * @param _depositor Address of the depositor (CrvDepositor)\n     */\n    function setDepositor(address _depositor) external {\n        require(msg.sender == owner, \"!auth\");\n\n        depositor = _depositor;\n    }\n\n    function setStashAccess(address _stash, bool _status) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        if(_stash != address(0)){\n            stashPool[_stash] = _status;\n        }\n        return true;\n    }\n\n    /**\n     * @notice Save a vote hash so when snapshot.org asks this contract if \n     *          a vote signature is valid we are able to check for a valid hash\n     *          and return the appropriate response inline with EIP 1721\n     * @param _hash  Hash of vote signature that was sent to snapshot.org\n     * @param _valid Is the hash valid\n     */\n    function setVote(bytes32 _hash, bool _valid) external {\n        require(msg.sender == operator, \"!auth\");\n        votes[_hash] = _valid;\n        emit VoteSet(_hash, _valid);\n    }\n\n    /**\n     * @notice  Verifies that the hash is valid\n     * @dev     Snapshot Hub will call this function when a vote is submitted using\n     *          snapshot.js on behalf of this contract. Snapshot Hub will call this\n     *          function with the hash and the signature of the vote that was cast.\n     * @param _hash Hash of the message that was sent to Snapshot Hub to cast a vote\n     * @return EIP1271 magic value if the signature is value \n     */\n    function isValidSignature(bytes32 _hash, bytes memory) public view returns (bytes4) {\n        if(votes[_hash]) {\n            return EIP1271_MAGIC_VALUE;\n        } else {\n            return 0xffffffff;\n        }  \n    }\n\n    /**\n     * @notice  Deposit tokens into the Curve Gauge\n     * @dev     Only can be called by the operator (Booster) once this contract has been\n     *          whitelisted by the Curve DAO\n     * @param _token  Deposit LP token address\n     * @param _gauge  Gauge contract to deposit to \n     */ \n    function deposit(address _token, address _gauge) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        if(protectedTokens[_token] == false){\n            protectedTokens[_token] = true;\n        }\n        if(protectedTokens[_gauge] == false){\n            protectedTokens[_gauge] = true;\n        }\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        if (balance > 0) {\n            IERC20(_token).safeApprove(_gauge, 0);\n            IERC20(_token).safeApprove(_gauge, balance);\n            ICurveGauge(_gauge).deposit(balance);\n        }\n        return true;\n    }\n\n    /**\n     * @notice  Withdraw ERC20 tokens that have been distributed as extra rewards\n     * @dev     Tokens shouldn't end up here if they can help it. However, dao can\n     *          set a withdrawer that can process these to some ExtraRewardDistribution.\n     */\n    function withdraw(IERC20 _asset) external returns (uint256 balance) {\n        require(msg.sender == withdrawer, \"!auth\");\n        require(protectedTokens[address(_asset)] == false, \"protected\");\n\n        balance = _asset.balanceOf(address(this));\n        _asset.safeApprove(rewardDeposit, 0);\n        _asset.safeApprove(rewardDeposit, balance);\n        IRewardDeposit(rewardDeposit).addReward(address(_asset), balance);\n        return balance;\n    }\n\n    /**\n     * @notice  Withdraw LP tokens from a gauge \n     * @dev     Only callable by the operator \n     * @param _token    LP token address\n     * @param _gauge    Gauge for this LP token\n     * @param _amount   Amount of LP token to withdraw\n     */\n    function withdraw(address _token, address _gauge, uint256 _amount) public returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_gauge, _amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice  Withdraw all LP tokens from a gauge \n     * @dev     Only callable by the operator \n     * @param _token  LP token address\n     * @param _gauge  Gauge for this LP token\n     */\n    function withdrawAll(address _token, address _gauge) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        uint256 amount = balanceOfPool(_gauge).add(IERC20(_token).balanceOf(address(this)));\n        withdraw(_token, _gauge, amount);\n        return true;\n    }\n\n    function _withdrawSome(address _gauge, uint256 _amount) internal returns (uint256) {\n        ICurveGauge(_gauge).withdraw(_amount);\n        return _amount;\n    }\n    \n    \n    /**\n     * @notice  Lock CRV in curves voting escrow contract\n     * @dev     Called by the CrvDepositor contract\n     * @param _value      Amount of crv to lock\n     * @param _unlockTime Timestamp to unlock (max is 4 years)\n     */\n    function createLock(uint256 _value, uint256 _unlockTime) external returns(bool){\n        require(msg.sender == depositor, \"!auth\");\n        IERC20(crvBpt).safeApprove(escrow, 0);\n        IERC20(crvBpt).safeApprove(escrow, _value);\n        ICurveVoteEscrow(escrow).create_lock(_value, _unlockTime);\n        return true;\n    }\n  \n    /**\n     * @notice Called by the CrvDepositor to increase amount of locked curve\n     */\n    function increaseAmount(uint256 _value) external returns(bool){\n        require(msg.sender == depositor, \"!auth\");\n        IERC20(crvBpt).safeApprove(escrow, 0);\n        IERC20(crvBpt).safeApprove(escrow, _value);\n        ICurveVoteEscrow(escrow).increase_amount(_value);\n        return true;\n    }\n\n    /**\n     * @notice Called by the CrvDepositor to increase unlocked time of curve\n     * @param _value Timestamp to increase locking to\n     */\n    function increaseTime(uint256 _value) external returns(bool){\n        require(msg.sender == depositor, \"!auth\");\n        ICurveVoteEscrow(escrow).increase_unlock_time(_value);\n        return true;\n    }\n\n    /**\n     * @notice  Withdraw all CRV from Curve's voting escrow contract\n     * @dev     Only callable by CrvDepositor and can only withdraw if lock has expired\n     */\n    function release() external returns(bool){\n        require(msg.sender == depositor, \"!auth\");\n        ICurveVoteEscrow(escrow).withdraw();\n        return true;\n    }\n\n    /**\n     * @notice Vote on CRV DAO for proposal\n     */\n    function vote(uint256 _voteId, address _votingAddress, bool _support) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        IVoting(_votingAddress).vote(_voteId,_support,false);\n        return true;\n    }\n\n    /**\n     * @notice Vote for a single gauge weight via the controller\n     */\n    function voteGaugeWeight(address _gauge, uint256 _weight) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n\n        //vote\n        IVoting(gaugeController).vote_for_gauge_weights(_gauge, _weight);\n        return true;\n    }\n\n    /**\n     * @notice  Claim CRV from Curve\n     * @dev     Claim CRV for LP token staking from the CRV minter contract\n     */\n    function claimCrv(address _gauge) external returns (uint256){\n        require(msg.sender == operator, \"!auth\");\n        \n        uint256 _balance = 0;\n        try IMinter(mintr).mint(_gauge){\n            _balance = IERC20(crv).balanceOf(address(this));\n            IERC20(crv).safeTransfer(operator, _balance);\n        }catch{}\n\n        return _balance;\n    }\n\n    /**\n     * @notice  Claim extra rewards from gauge\n     * @dev     Called by operator (Booster) to claim extra rewards \n     */\n    function claimRewards(address _gauge) external returns(bool){\n        require(msg.sender == operator, \"!auth\");\n        ICurveGauge(_gauge).claim_rewards();\n        return true;\n    }\n\n    /**\n     * @notice  Claim fees (3crv) from staking lp tokens\n     * @dev     Only callable by the operator Booster\n     * @param _distroContract   Fee distribution contract\n     * @param _token            LP token to claim fees for\n     */\n    function claimFees(address _distroContract, address _token) external returns (uint256){\n        require(msg.sender == operator, \"!auth\");\n        IFeeDistributor(_distroContract).claimToken(address(this), _token);\n        uint256 _balance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(operator, _balance);\n        return _balance;\n    }    \n\n    function balanceOfPool(address _gauge) public view returns (uint256) {\n        return ICurveGauge(_gauge).balanceOf(address(this));\n    }\n\n    function execute(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bool, bytes memory) {\n        require(msg.sender == operator,\"!auth\");\n\n        (bool success, bytes memory result) = _to.call{value:_value}(_data);\n        require(success, \"!success\");\n\n        return (success, result);\n    }\n\n}"
    },
    {
      "filename": "convex-platform/contracts/contracts/Booster.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Address.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\n\n/**\n * @title   Booster\n * @author  ConvexFinance\n * @notice  Main deposit contract; keeps track of pool info & user deposits; distributes rewards.\n * @dev     They say all paths lead to Rome, and the cvxBooster is no different. This is where it all goes down.\n *          It is responsible for tracking all the pools, it collects rewards from all pools and redirects it.\n */\ncontract Booster{\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public immutable crv;\n    address public immutable voteOwnership;\n    address public immutable voteParameter;\n\n    uint256 public lockIncentive = 825; //incentive to crv stakers\n    uint256 public stakerIncentive = 825; //incentive to native token stakers\n    uint256 public earmarkIncentive = 50; //incentive to users who spend gas to make calls\n    uint256 public platformFee = 0; //possible fee to build treasury\n    uint256 public constant MaxFees = 2500;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public owner;\n    address public feeManager;\n    address public poolManager;\n    address public immutable staker;\n    address public immutable minter;\n    address public rewardFactory;\n    address public stashFactory;\n    address public tokenFactory;\n    address public rewardArbitrator;\n    address public voteDelegate;\n    address public treasury;\n    address public stakerRewards; //cvx rewards\n    address public lockRewards; //cvxCrv rewards(crv)\n\n    mapping(address => FeeDistro) public feeTokens;\n    struct FeeDistro {\n        address distro;\n        address rewards;\n        bool active;\n    }\n\n    bool public isShutdown;\n\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address gauge;\n        address crvRewards;\n        address stash;\n        bool shutdown;\n    }\n\n    //index(pid) -> pool\n    PoolInfo[] public poolInfo;\n    mapping(address => bool) public gaugeMap;\n\n    event Deposited(address indexed user, uint256 indexed poolid, uint256 amount);\n    event Withdrawn(address indexed user, uint256 indexed poolid, uint256 amount);\n\n    event PoolAdded(address lpToken, address gauge, address token, address rewardPool, address stash, uint256 pid);\n    event PoolShutdown(uint256 poolId);\n\n    event OwnerUpdated(address newOwner);\n    event FeeManagerUpdated(address newFeeManager);\n    event PoolManagerUpdated(address newPoolManager);\n    event FactoriesUpdated(address rewardFactory, address stashFactory, address tokenFactory);\n    event ArbitratorUpdated(address newArbitrator);\n    event VoteDelegateUpdated(address newVoteDelegate);\n    event RewardContractsUpdated(address lockRewards, address stakerRewards);\n    event FeesUpdated(uint256 lockIncentive, uint256 stakerIncentive, uint256 earmarkIncentive, uint256 platformFee);\n    event TreasuryUpdated(address newTreasury);\n    event FeeInfoUpdated(address feeDistro, address lockFees, address feeToken);\n    event FeeInfoChanged(address feeDistro, bool active);\n\n    /**\n     * @dev Constructor doing what constructors do. It is noteworthy that\n     *      a lot of basic config is set to 0 - expecting subsequent calls to setFeeInfo etc.\n     * @param _staker                 VoterProxy (locks the crv and adds to all gauges)\n     * @param _minter                 CVX token, or the thing that mints it\n     * @param _crv                    CRV\n     * @param _voteOwnership          Address of the Curve DAO responsible for ownership stuff\n     * @param _voteParameter          Address of the Curve DAO responsible for param updates\n     */\n    constructor(\n        address _staker,\n        address _minter,\n        address _crv,\n        address _voteOwnership,\n        address _voteParameter\n    ) public {\n        staker = _staker;\n        minter = _minter;\n        crv = _crv;\n        voteOwnership = _voteOwnership;\n        voteParameter = _voteParameter;\n        isShutdown = false;\n\n        owner = msg.sender;\n        voteDelegate = msg.sender;\n        feeManager = msg.sender;\n        poolManager = msg.sender;\n        treasury = address(0);\n\n        emit OwnerUpdated(msg.sender);\n        emit VoteDelegateUpdated(msg.sender);\n        emit FeeManagerUpdated(msg.sender);\n        emit PoolManagerUpdated(msg.sender);\n    }\n\n\n    /// SETTER SECTION ///\n\n    /**\n     * @notice Owner is responsible for setting initial config, updating vote delegate and shutting system\n     */\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n\n        emit OwnerUpdated(_owner);\n    }\n\n    /**\n     * @notice Fee Manager can update the fees (lockIncentive, stakeIncentive, earmarkIncentive, platformFee)\n     */\n    function setFeeManager(address _feeM) external {\n        require(msg.sender == feeManager, \"!auth\");\n        feeManager = _feeM;\n\n        emit FeeManagerUpdated(_feeM);\n    }\n\n    /**\n     * @notice Pool manager is responsible for adding new pools\n     */\n    function setPoolManager(address _poolM) external {\n        require(msg.sender == poolManager, \"!auth\");\n        poolManager = _poolM;\n\n        emit PoolManagerUpdated(_poolM);\n    }\n\n    /**\n     * @notice Factories are used when deploying new pools. Only the stash factory is mutable after init\n     */\n    function setFactories(address _rfactory, address _sfactory, address _tfactory) external {\n        require(msg.sender == owner, \"!auth\");\n\n        //stash factory should be considered more safe to change\n        //updating may be required to handle new types of gauges\n        stashFactory = _sfactory;\n\n        //reward factory only allow this to be called once even if owner\n        //removes ability to inject malicious staking contracts\n        //token factory can also be immutable\n        if(rewardFactory == address(0)){\n            rewardFactory = _rfactory;\n            tokenFactory = _tfactory;\n\n            emit FactoriesUpdated(_rfactory, _sfactory, _tfactory);\n        } else {\n            emit FactoriesUpdated(address(0), _sfactory, address(0));\n        }\n    }\n\n    /**\n     * @notice Arbitrator handles tokens that are used as secondary rewards across multiple pools\n     */\n    function setArbitrator(address _arb) external {\n        require(msg.sender==owner, \"!auth\");\n        rewardArbitrator = _arb;\n\n        emit ArbitratorUpdated(_arb);\n    }\n\n    /**\n     * @notice Vote Delegate has the rights to cast votes on the VoterProxy via the Booster\n     */\n    function setVoteDelegate(address _voteDelegate) external {\n        require(msg.sender==voteDelegate, \"!auth\");\n        voteDelegate = _voteDelegate;\n\n        emit VoteDelegateUpdated(_voteDelegate);\n    }\n\n    /**\n     * @notice Only called once, to set the addresses of cvxCrv (lockRewards) and cvx staking (stakerRewards)\n     */\n    function setRewardContracts(address _rewards, address _stakerRewards) external {\n        require(msg.sender == owner, \"!auth\");\n        \n        //reward contracts are immutable or else the owner\n        //has a means to redeploy and mint cvx via rewardClaimed()\n        if(lockRewards == address(0)){\n            lockRewards = _rewards;\n            stakerRewards = _stakerRewards;\n            emit RewardContractsUpdated(_rewards, _stakerRewards);\n        }\n    }\n\n    /**\n     * @notice Set reward token and claim contract\n     * @dev    This creates a secondary (VirtualRewardsPool) rewards contract for the vcxCrv staking contract\n     */\n    function setFeeInfo(address _feeToken, address _feeDistro) external {\n        require(msg.sender == owner, \"!auth\");\n        require(!isShutdown, \"shutdown\");\n        require(lockRewards != address(0) && rewardFactory != address(0), \"!initialised\");\n\n        require(_feeToken != address(0) && _feeDistro != address(0), \"!addresses\");\n        require(IFeeDistributor(_feeDistro).getTokenTimeCursor(_feeToken) > 0, \"!distro\");\n\n        if(feeTokens[_feeToken].distro == address(0)){\n            require(!gaugeMap[_feeToken], \"!token\");\n\n            // Distributed directly\n            if(_feeToken == crv){\n                feeTokens[crv] = FeeDistro({\n                    distro: _feeDistro,\n                    rewards: lockRewards,\n                    active: true\n                });\n                emit FeeInfoUpdated(_feeDistro, lockRewards, crv);\n            } else {\n                //create a new reward contract for the new token\n                address rewards = IRewardFactory(rewardFactory).CreateTokenRewards(_feeToken, lockRewards, address(this));\n                feeTokens[_feeToken] = FeeDistro({\n                    distro: _feeDistro,\n                    rewards: rewards,\n                    active: true\n                });\n                emit FeeInfoUpdated(_feeDistro, rewards, _feeToken);\n            }\n        } else {\n            feeTokens[_feeToken].distro = _feeDistro;\n            emit FeeInfoUpdated(_feeDistro, address(0), _feeToken);\n        }\n    }\n\n    /**\n     * @notice Allows turning off or on for fee distro\n     */\n    function updateFeeInfo(address _feeToken, bool _active) external {\n        require(msg.sender==owner, \"!auth\");\n\n        require(feeTokens[_feeToken].distro != address(0), \"Fee doesn't exist\");\n\n        feeTokens[_feeToken].active = _active;\n\n        emit FeeInfoChanged(_feeToken, _active);\n    }\n\n    /**\n     * @notice Fee manager can set all the relevant fees\n     * @param _lockFees     % for cvxCrv stakers where 1% == 100\n     * @param _stakerFees   % for CVX stakers where 1% == 100\n     * @param _callerFees   % for whoever calls the claim where 1% == 100\n     * @param _platform     % for \"treasury\" or vlCVX where 1% == 100\n     */\n    function setFees(uint256 _lockFees, uint256 _stakerFees, uint256 _callerFees, uint256 _platform) external{\n        require(msg.sender==feeManager, \"!auth\");\n\n        uint256 total = _lockFees.add(_stakerFees).add(_callerFees).add(_platform);\n        require(total <= MaxFees, \">MaxFees\");\n\n        require(_lockFees >= 300 && _lockFees <= 1500, \"!lockFees\");\n        require(_stakerFees >= 300 && _stakerFees <= 1500, \"!stakerFees\");\n        require(_callerFees >= 10 && _callerFees <= 100, \"!callerFees\");\n        require(_platform <= 200, \"!platform\");\n\n        lockIncentive = _lockFees;\n        stakerIncentive = _stakerFees;\n        earmarkIncentive = _callerFees;\n        platformFee = _platform;\n\n        emit FeesUpdated(_lockFees, _stakerFees, _callerFees, _platform);\n    }\n\n    /**\n     * @notice Set the address of the treasury (i.e. vlCVX)\n     */\n    function setTreasury(address _treasury) external {\n        require(msg.sender==feeManager, \"!auth\");\n        treasury = _treasury;\n\n        emit TreasuryUpdated(_treasury);\n    }\n\n    /// END SETTER SECTION ///\n\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    /**\n     * @notice Called by the PoolManager (i.e. PoolManagerProxy) to add a new pool - creates all the required\n     *         contracts (DepositToken, RewardPool, Stash) and then adds to the list!\n     */\n    function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external returns(bool){\n        require(msg.sender==poolManager && !isShutdown, \"!add\");\n        require(_gauge != address(0) && _lptoken != address(0),\"!param\");\n        require(feeTokens[_gauge].distro == address(0), \"!gauge\");\n\n        //the next pool's pid\n        uint256 pid = poolInfo.length;\n\n        //create a tokenized deposit\n        address token = ITokenFactory(tokenFactory).CreateDepositToken(_lptoken);\n        //create a reward contract for crv rewards\n        address newRewardPool = IRewardFactory(rewardFactory).CreateCrvRewards(pid,token,_lptoken);\n        //create a stash to handle extra incentives\n        address stash = IStashFactory(stashFactory).CreateStash(pid,_gauge,staker,_stashVersion);\n\n        //add the new pool\n        poolInfo.push(\n            PoolInfo({\n                lptoken: _lptoken,\n                token: token,\n                gauge: _gauge,\n                crvRewards: newRewardPool,\n                stash: stash,\n                shutdown: false\n            })\n        );\n        gaugeMap[_gauge] = true;\n        //give stashes access to rewardfactory and voteproxy\n        //   voteproxy so it can gra"
    }
  ]
}