{
  "Title": "[M-04] Improper adjustment of Lending Ledger configuration",
  "Content": "\n<https://github.com/code-423n4/2024-03-neobase/blob/main/src/LendingLedger.sol#L136-L149> \n\n<https://github.com/code-423n4/2024-03-neobase/blob/main/src/LendingLedger.sol#L173-L185>\n\n### Description\n\nThe `LendingLedger` utilizes an approximation system (to evaluate the time that has elapsed between two block numbers) which contains adjustable values. Additionally, it permits the governance to adjust the `cantoPerBlock` value of multiple epochs at any time.\n\nThe way these values are adjusted is insecure and thus can cause them to retroactively apply to markets that have not yet been updated.\n\nIn the case of the `LendingLedger::setBlockTimeParameters`, a notice exists within the `LendingLedger::update_market` function that warns that:\n\n> If this ever drifts significantly, the average block time and/or reference block time & number can be updated. However, `update_market` needs to be called for all markets beforehand.\n\nI do not consider the warning sufficient, as the `LendingLedger::setRewards` function illustrates that the problem is not understood accurately.\n\nAny market that was not updated on the exact same block that either rewards or the block time parameters are adjusted will have these adjustments retroactively applied, leading to over-estimations or under-estimations of the rewards that should be attributed to the market.\n\n### Impact\n\nReward measurements for markets that were not updated **in the exact same block** that rewards and/or block-time parameters were re-configured will result in over- or under-estimations, depending on the direction of these configurations.\n\n### Severity Rationalization\n\nAdministrator mistakes usually fall under QA/Analysis reports; however, in this circumstance, the mistake is not based on input but rather on the state of the contract. Additionally, there are cases whereby the change cannot be performed securely (i.e. if the number of markets introduced would reach the gas limit if all are attempted to be updated at the same block).\n\nBased on the above, I believe this constitutes a valid operational vulnerability that stems from an improperly coded configuration procedure for both rewards and block time parameters.\n\nWhile there is a warning for the `LendingLedger::setBlockTimeParameters` function, it is located in an entirely different function and is insufficient, in my opinion. Even if considered sufficient, there is absolutely no warning or indication that the same restriction applies for the `LendingLedger::setRewards` function.\n\nThis submission may be split into two distinct ones if the reward-related and block-time-related impacts are considered distinct; however, I grouped them under the same submission as they pertain to the same operation (update of all markets) being absent albeit from two different code segments.\n\n### Proof of Concept\n\nI have coded the following PoC in `foundry` for completeness. Please add the following segment after `LendingLedger.t.sol::setupStateBeforeClaim`:\n\n```solidity\nfunction testInsecureRewardUpdate() public {\n    setupStateBeforeClaim();\n\n    // Based on `LendingLedger.t.sol::testClaimValidLenderOneBlock`, the reward of the `lender` should be `amountPerBlock - 1` at this time point\n    vm.roll(BLOCK_EPOCH * 5 + 1);\n\n    // We update the rewards of the epochs without updating the markets\n    vm.prank(governance);\n    uint256 newRewardPerBlock = amountPerBlock * 2;\n    ledger.setRewards(fromEpoch, toEpoch, newRewardPerBlock);\n\n    // We claim the `lender` rewards, should be `amountPerBlock` based on `LendingLedger.t.sol::testClaimValidLenderOneBlock`\n    uint256 balanceBefore = address(lender).balance;\n    vm.prank(lender);\n    vm.roll(BLOCK_EPOCH * 5 + 1);\n    ledger.claim(lendingMarket);\n    uint256 balanceAfter = address(lender).balance;\n\n    // Assertion will fail\n    assertEq(balanceAfter - balanceBefore, amountPerBlock - 1);\n}\n```\n\nTo execute the above test, I recommend the following CLI instruction:\n\n```\nforge test --match-test testInsecureRewardUpdate -vv \n```\n\n### Recommended Mitigation Steps\n\nI advise all markets added to a `LendingLedger` to be tracked and iterated whenever either of the submission's referenced functions is executed, ensuring that all markets are indeed updated in the same block.\n\nAs a gas-optimal alternative, the total markets of the `LendingLedger` could be tracked as a number. The aforementioned adjustment functions could then accept an input array that would contain all markets, permitting a `for` loop to iterate them, ensure they are distinct (i.e. in strictly ascending order), and ensure that the total number of input markets is equal to the total number of registered markets.\n\nAlternatively, and as a solution solely for the `LendingLedger::setRewards` function, the epochs that are mutated could be restricted to be future ones and thus never result in a retroactive application.\n\n### Assessed type\n\nGovernance\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-03-neobase-findings/issues/16#issuecomment-2035626708):**\n > Referring to README:  \n> > **Publicly Known Issues**\n> > **Mistakes by Governance:**\n> > We assume that all calls that are performed by the governance address are performed with the correct parameters.\n> \n> However, it's not just about correct call parameters but also about correct call timing (`reward-related and block-time-related impacts`); therefore, leaving this for sponsor review.\n>\n> The current duplicate [#19](https://github.com/code-423n4/2024-03-neobase-findings/issues/19) is more affected by the README; will reconsider during judging.\n\n**[OpenCoreCH (Neobase) confirmed](https://github.com/code-423n4/2024-03-neobase-findings/issues/16#issuecomment-2041163016)**\n\n**[0xTheC0der (judge) commented](https://github.com/code-423n4/2024-03-neobase-findings/issues/16#issuecomment-2043832907):**\n > > Administrator mistakes usually fall under QA/Analysis reports; however, in this circumstance, the mistake is not based on input but rather on the state of the contract.\n> \n> I agree with this assessment in the report.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-neobase",
  "Code": [
    {
      "filename": "src/LendingLedger.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {GaugeController} from \"./GaugeController.sol\";\nimport {LiquidityGauge} from \"./LiquidityGauge.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract LendingLedger {\n    // Constants\n    uint256 public constant BLOCK_EPOCH = 100_000; // 100000 blocks, roughly 1 week\n    uint256 public averageBlockTime = 5700; // Average block time in milliseconds\n    uint256 public referenceBlockNumber;\n    uint256 public referenceBlockTime; // Used to convert block numbers to timestamps together with averageBlockTime\n\n    // State\n    address public governance;\n    GaugeController public gaugeController;\n    mapping(address => bool) public lendingMarketWhitelist;\n\n    /// @dev Info for each user.\n    struct UserInfo {\n        uint256 amount; // Amount of cNOTE that the user has provided.\n        int256 rewardDebt; // Amount of CANTO entitled to the user.\n        int256 secRewardDebt; // Amount of secondary rewards entitled to the user.\n    }\n\n    /// @dev Info of each lending market.\n    struct MarketInfo {\n        uint128 accCantoPerShare;\n        uint128 secRewardsPerShare;\n        uint64 lastRewardBlock;\n    }\n\n    mapping(address => mapping(address => UserInfo)) public userInfo; // Info of each user for the different lending markets\n    mapping(address => MarketInfo) public marketInfo; // Info of each lending market\n\n    mapping(uint256 => uint256) public cantoPerBlock; // CANTO per block for each epoch\n\n    /// @dev Lending Market => Epoch => Balance\n    mapping(address => uint256) public lendingMarketTotalBalance; // Total balance locked within the market\n\n    mapping(address => address) public liquidityGauges; // Two way mapping for markets with liquidity gauge enabled\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    constructor(address _gaugeController, address _governance) {\n        gaugeController = GaugeController(_gaugeController);\n        governance = _governance;\n        referenceBlockNumber = block.number;\n        referenceBlockTime = block.timestamp;\n    }\n\n    /// @notice Set governance address\n    /// @param _governance New governance address\n    function setGovernance(address _governance) external onlyGovernance {\n        governance = _governance;\n    }\n\n    function update_market(address _market) public {\n        require(lendingMarketWhitelist[_market], \"Market not whitelisted\");\n        MarketInfo storage market = marketInfo[_market];\n        if (block.number > market.lastRewardBlock) {\n            uint256 marketSupply = lendingMarketTotalBalance[_market];\n            if (marketSupply > 0) {\n                uint256 i = market.lastRewardBlock;\n                while (i < block.number) {\n                    uint256 epoch = (i / BLOCK_EPOCH) * BLOCK_EPOCH; // Rewards and voting weights are aligned on a weekly basis\n                    uint256 nextEpoch = epoch + BLOCK_EPOCH;\n                    uint256 blockDelta = Math.min(nextEpoch, block.number) - i;\n                    // May not be the exact time, but will ensure that it is equal for all users and epochs.\n                    // If this ever drifts significantly, the average block time and / or reference block time & number can be updated. However, update_market needs to be called for all markets beforehand.\n                    uint256 epochTime = referenceBlockTime +\n                        ((block.number - referenceBlockNumber) * averageBlockTime) /\n                        1000;\n                    market.accCantoPerShare += uint128(\n                        (blockDelta *\n                            cantoPerBlock[epoch] *\n                            gaugeController.gauge_relative_weight_write(_market, epochTime)) / marketSupply\n                    );\n                    market.secRewardsPerShare += uint128((blockDelta * 1e36) / marketSupply); // Scale by 1e18, consumers need to divide by it\n                    i += blockDelta;\n                }\n            }\n            market.lastRewardBlock = uint64(block.number);\n        }\n    }\n\n    /// @notice Function that is called by the lending market on cNOTE deposits / withdrawals\n    /// @param _lender The address of the lender\n    /// @param _delta The amount of cNote deposited (positive) or withdrawn (negative)\n    function sync_ledger(address _lender, int256 _delta) external {\n        address lendingMarket = msg.sender;\n        // check if liquidity gauge is being used for the market\n        if (liquidityGauges[lendingMarket] != address(0)) lendingMarket = liquidityGauges[lendingMarket];\n\n        update_market(lendingMarket); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[lendingMarket];\n        UserInfo storage user = userInfo[lendingMarket][_lender];\n\n        if (_delta >= 0) {\n            user.amount += uint256(_delta);\n            user.rewardDebt += int256((uint256(_delta) * market.accCantoPerShare) / 1e18);\n            user.secRewardDebt += int256((uint256(_delta) * market.secRewardsPerShare) / 1e18);\n        } else {\n            user.amount -= uint256(-_delta);\n            user.rewardDebt -= int256((uint256(-_delta) * market.accCantoPerShare) / 1e18);\n            user.secRewardDebt -= int256((uint256(-_delta) * market.secRewardsPerShare) / 1e18);\n        }\n        int256 updatedMarketBalance = int256(lendingMarketTotalBalance[lendingMarket]) + _delta;\n        require(updatedMarketBalance >= 0, \"Market balance underflow\"); // Sanity check performed here, but the market should ensure that this never happens\n        lendingMarketTotalBalance[lendingMarket] = uint256(updatedMarketBalance);\n    }\n\n    /// @notice Claim the CANTO for a given market. Can only be performed for prior (i.e. finished) epochs, not the current one\n    /// @param _market Address of the market\n    function claim(address _market) external {\n        update_market(_market); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[_market];\n        UserInfo storage user = userInfo[_market][msg.sender];\n        int256 accumulatedCanto = int256((uint256(user.amount) * market.accCantoPerShare) / 1e18);\n        int256 cantoToSend = accumulatedCanto - user.rewardDebt;\n\n        user.rewardDebt = accumulatedCanto;\n\n        if (cantoToSend > 0) {\n            (bool success, ) = msg.sender.call{value: uint256(cantoToSend)}(\"\");\n            require(success, \"Failed to send CANTO\");\n        }\n    }\n\n    /// @notice Used by governance to set the overall CANTO rewards per epoch\n    /// @param _fromEpoch From which epoch (provided as block number) to set the rewards from\n    /// @param _toEpoch Until which epoch (provided as block number) to set the rewards to\n    /// @param _amountPerBlock The amount per block\n    function setRewards(\n        uint256 _fromEpoch,\n        uint256 _toEpoch,\n        uint256 _amountPerBlock\n    ) external onlyGovernance {\n        require(_fromEpoch % BLOCK_EPOCH == 0 && _toEpoch % BLOCK_EPOCH == 0, \"Invalid block number\");\n        for (uint256 i = _fromEpoch; i <= _toEpoch; i += BLOCK_EPOCH) {\n            cantoPerBlock[i] = _amountPerBlock;\n        }\n    }\n\n    /// @notice Used by governance to whitelist a lending market\n    /// @param _market Address of the market to whitelist\n    /// @param _isWhiteListed Whether the market is whitelisted or not\n    function whiteListLendingMarket(\n        address _market,\n        bool _isWhiteListed,\n        bool _hasGauge\n    ) external onlyGovernance {\n        require(lendingMarketWhitelist[_market] != _isWhiteListed, \"No change\");\n        if (_hasGauge && liquidityGauges[_market] == address(0)) {\n            LiquidityGauge liquidityGauge = new LiquidityGauge(_market, address(this));\n            liquidityGauges[_market] = address(liquidityGauge);\n            // add reverse also for reference in sync_ledger\n            liquidityGauges[address(liquidityGauge)] = _market;\n        }\n\n        lendingMarketWhitelist[_market] = _isWhiteListed;\n        if (_isWhiteListed) {\n            marketInfo[_market].lastRewardBlock = uint64(block.number);\n        }\n    }\n\n    /// @notice Used by governance to set the block time parameters if the drift is too large\n    /// @param _averageBlockTime The average block time in milliseconds\n    /// @param _referenceBlockTime The reference block time\n    /// @param _referenceBlockNumber The reference block number\n    function setBlockTimeParameters(\n        uint256 _averageBlockTime,\n        uint256 _referenceBlockTime,\n        uint256 _referenceBlockNumber\n    ) external onlyGovernance {\n        averageBlockTime = _averageBlockTime;\n        referenceBlockTime = _referenceBlockTime;\n        referenceBlockNumber = _referenceBlockNumber;\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "src/LendingLedger.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {GaugeController} from \"./GaugeController.sol\";\nimport {LiquidityGauge} from \"./LiquidityGauge.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract LendingLedger {\n    // Constants\n    uint256 public constant BLOCK_EPOCH = 100_000; // 100000 blocks, roughly 1 week\n    uint256 public averageBlockTime = 5700; // Average block time in milliseconds\n    uint256 public referenceBlockNumber;\n    uint256 public referenceBlockTime; // Used to convert block numbers to timestamps together with averageBlockTime\n\n    // State\n    address public governance;\n    GaugeController public gaugeController;\n    mapping(address => bool) public lendingMarketWhitelist;\n\n    /// @dev Info for each user.\n    struct UserInfo {\n        uint256 amount; // Amount of cNOTE that the user has provided.\n        int256 rewardDebt; // Amount of CANTO entitled to the user.\n        int256 secRewardDebt; // Amount of secondary rewards entitled to the user.\n    }\n\n    /// @dev Info of each lending market.\n    struct MarketInfo {\n        uint128 accCantoPerShare;\n        uint128 secRewardsPerShare;\n        uint64 lastRewardBlock;\n    }\n\n    mapping(address => mapping(address => UserInfo)) public userInfo; // Info of each user for the different lending markets\n    mapping(address => MarketInfo) public marketInfo; // Info of each lending market\n\n    mapping(uint256 => uint256) public cantoPerBlock; // CANTO per block for each epoch\n\n    /// @dev Lending Market => Epoch => Balance\n    mapping(address => uint256) public lendingMarketTotalBalance; // Total balance locked within the market\n\n    mapping(address => address) public liquidityGauges; // Two way mapping for markets with liquidity gauge enabled\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    constructor(address _gaugeController, address _governance) {\n        gaugeController = GaugeController(_gaugeController);\n        governance = _governance;\n        referenceBlockNumber = block.number;\n        referenceBlockTime = block.timestamp;\n    }\n\n    /// @notice Set governance address\n    /// @param _governance New governance address\n    function setGovernance(address _governance) external onlyGovernance {\n        governance = _governance;\n    }\n\n    function update_market(address _market) public {\n        require(lendingMarketWhitelist[_market], \"Market not whitelisted\");\n        MarketInfo storage market = marketInfo[_market];\n        if (block.number > market.lastRewardBlock) {\n            uint256 marketSupply = lendingMarketTotalBalance[_market];\n            if (marketSupply > 0) {\n                uint256 i = market.lastRewardBlock;\n                while (i < block.number) {\n                    uint256 epoch = (i / BLOCK_EPOCH) * BLOCK_EPOCH; // Rewards and voting weights are aligned on a weekly basis\n                    uint256 nextEpoch = epoch + BLOCK_EPOCH;\n                    uint256 blockDelta = Math.min(nextEpoch, block.number) - i;\n                    // May not be the exact time, but will ensure that it is equal for all users and epochs.\n                    // If this ever drifts significantly, the average block time and / or reference block time & number can be updated. However, update_market needs to be called for all markets beforehand.\n                    uint256 epochTime = referenceBlockTime +\n                        ((block.number - referenceBlockNumber) * averageBlockTime) /\n                        1000;\n                    market.accCantoPerShare += uint128(\n                        (blockDelta *\n                            cantoPerBlock[epoch] *\n                            gaugeController.gauge_relative_weight_write(_market, epochTime)) / marketSupply\n                    );\n                    market.secRewardsPerShare += uint128((blockDelta * 1e36) / marketSupply); // Scale by 1e18, consumers need to divide by it\n                    i += blockDelta;\n                }\n            }\n            market.lastRewardBlock = uint64(block.number);\n        }\n    }\n\n    /// @notice Function that is called by the lending market on cNOTE deposits / withdrawals\n    /// @param _lender The address of the lender\n    /// @param _delta The amount of cNote deposited (positive) or withdrawn (negative)\n    function sync_ledger(address _lender, int256 _delta) external {\n        address lendingMarket = msg.sender;\n        // check if liquidity gauge is being used for the market\n        if (liquidityGauges[lendingMarket] != address(0)) lendingMarket = liquidityGauges[lendingMarket];\n\n        update_market(lendingMarket); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[lendingMarket];\n        UserInfo storage user = userInfo[lendingMarket][_lender];\n\n        if (_delta >= 0) {\n            user.amount += uint256(_delta);\n            user.rewardDebt += int256((uint256(_delta) * market.accCantoPerShare) / 1e18);\n            user.secRewardDebt += int256((uint256(_delta) * market.secRewardsPerShare) / 1e18);\n        } else {\n            user.amount -= uint256(-_delta);\n            user.rewardDebt -= int256((uint256(-_delta) * market.accCantoPerShare) / 1e18);\n            user.secRewardDebt -= int256((uint256(-_delta) * market.secRewardsPerShare) / 1e18);\n        }\n        int256 updatedMarketBalance = int256(lendingMarketTotalBalance[lendingMarket]) + _delta;\n        require(updatedMarketBalance >= 0, \"Market balance underflow\"); // Sanity check performed here, but the market should ensure that this never happens\n        lendingMarketTotalBalance[lendingMarket] = uint256(updatedMarketBalance);\n    }\n\n    /// @notice Claim the CANTO for a given market. Can only be performed for prior (i.e. finished) epochs, not the current one\n    /// @param _market Address of the market\n    function claim(address _market) external {\n        update_market(_market); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[_market];\n        UserInfo storage user = userInfo[_market][msg.sender];\n        int256 accumulatedCanto = int256((uint256(user.amount) * market.accCantoPerShare) / 1e18);\n        int256 cantoToSend = accumulatedCanto - user.rewardDebt;\n\n        user.rewardDebt = accumulatedCanto;\n\n        if (cantoToSend > 0) {\n            (bool success, ) = msg.sender.call{value: uint256(cantoToSend)}(\"\");\n            require(success, \"Failed to send CANTO\");\n        }\n    }\n\n    /// @notice Used by governance to set the overall CANTO rewards per epoch\n    /// @param _fromEpoch From which epoch (provided as block number) to set the rewards from\n    /// @param _toEpoch Until which epoch (provided as block number) to set the rewards to\n    /// @param _amountPerBlock The amount per block\n    function setRewards(\n        uint256 _fromEpoch,\n        uint256 _toEpoch,\n        uint256 _amountPerBlock\n    ) external onlyGovernance {\n        require(_fromEpoch % BLOCK_EPOCH == 0 && _toEpoch % BLOCK_EPOCH == 0, \"Invalid block number\");\n        for (uint256 i = _fromEpoch; i <= _toEpoch; i += BLOCK_EPOCH) {\n            cantoPerBlock[i] = _amountPerBlock;\n        }\n    }\n\n    /// @notice Used by governance to whitelist a lending market\n    /// @param _market Address of the market to whitelist\n    /// @param _isWhiteListed Whether the market is whitelisted or not\n    function whiteListLendingMarket(\n        address _market,\n        bool _isWhiteListed,\n        bool _hasGauge\n    ) external onlyGovernance {\n        require(lendingMarketWhitelist[_market] != _isWhiteListed, \"No change\");\n        if (_hasGauge && liquidityGauges[_market] == address(0)) {\n            LiquidityGauge liquidityGauge = new LiquidityGauge(_market, address(this));\n            liquidityGauges[_market] = address(liquidityGauge);\n            // add reverse also for reference in sync_ledger\n            liquidityGauges[address(liquidityGauge)] = _market;\n        }\n\n        lendingMarketWhitelist[_market] = _isWhiteListed;\n        if (_isWhiteListed) {\n            marketInfo[_market].lastRewardBlock = uint64(block.number);\n        }\n    }\n\n    /// @notice Used by governance to set the block time parameters if the drift is too large\n    /// @param _averageBlockTime The average block time in milliseconds\n    /// @param _referenceBlockTime The reference block time\n    /// @param _referenceBlockNumber The reference block number\n    function setBlockTimeParameters(\n        uint256 _averageBlockTime,\n        uint256 _referenceBlockTime,\n        uint256 _referenceBlockNumber\n    ) external onlyGovernance {\n        averageBlockTime = _averageBlockTime;\n        referenceBlockTime = _referenceBlockTime;\n        referenceBlockNumber = _referenceBlockNumber;\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}