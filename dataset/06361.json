{
  "Title": "[M-05] Invalid implementation of prioritized token rewards distribution",
  "Content": "\n### Lines of code\n<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L190-L218> \n\n### Vulnerability details\n\nThe `getReward` external function can't calculate and distribute rewards correctly for an account because of the reasons below:\n\n*   Transferring EUSD while the contract EUSD balance is insufficient and reverting\n*   Bad implementation of prioritized token rewards distribution when converting reward decimal for transfer stablecoin\n\n### Impact\n\nUsers can't get rewards and rewards freeze.\n\n### Proof of Concept\n\n```solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {Test, console} from \"forge-std/Test.sol\";\nimport {GovernanceTimelock} from \"contracts/lybra/governance/GovernanceTimelock.sol\";\nimport {mockCurve} from \"contracts/mocks/mockCurve.sol\";\nimport {Configurator} from \"contracts/lybra/configuration/LybraConfigurator.sol\";\nimport {LybraWBETHVault} from \"contracts/lybra/pools/LybraWbETHVault.sol\";\nimport {PeUSDMainnet} from \"contracts/lybra/token/PeUSDMainnetStableVision.sol\";\nimport {ProtocolRewardsPool} from \"contracts/lybra/miner/ProtocolRewardsPool.sol\";\nimport {EUSDMock} from \"contracts/mocks/MockEUSD.sol\";\nimport {LBR} from \"contracts/lybra/token/LBR.sol\";\nimport {esLBR} from \"contracts/lybra/token/esLBR.sol\";\nimport {esLBRBoost} from \"contracts/lybra/miner/esLBRBoost.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// 6 decimal USDC mock\ncontract mockUSDC is ERC20 {\n    constructor() ERC20(\"USDC\", \"USDC\") {\n        _mint(msg.sender, 1000000 * 1e6);\n    }\n\n    function claim() external returns (uint256) {\n        _mint(msg.sender, 10000 * 1e6);\n        return 10000 * 1e6;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n}\n\ncontract ProtocolRewardsPoolTest is Test {\n    address goerliEndPoint = 0xbfD2135BFfbb0B5378b56643c2Df8a87552Bfa23;\n    address wbETH = 0xbfD2135BFfbb0B5378b56643c2Df8a87552Bfa23;\n    address deployer;\n    address attacker;\n    address alice;\n\n    address[] proposers;\n    address[] executors;\n    address[] minerContracts;\n    bool[] minerContractsBools;\n\n    GovernanceTimelock governance;\n    mockCurve curvePool;\n    Configurator configurator;\n    PeUSDMainnet peUsdMainnet;\n    EUSDMock eUSD;\n    mockUSDC usdc;\n    LBR lbr;\n    esLBR eslbr;\n    esLBRBoost boost;\n    LybraWBETHVault wbETHVault;\n    ProtocolRewardsPool rewardsPool;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        attacker = makeAddr(\"attacker\");\n        alice = makeAddr(\"alice\");\n        vm.startPrank(deployer);\n        proposers.push(deployer);\n        executors.push(deployer);\n        governance = new GovernanceTimelock(2, proposers, executors, deployer);\n        curvePool = new mockCurve();\n        configurator = new Configurator(address(governance), address(curvePool));\n        peUsdMainnet = new PeUSDMainnet(\n            address(configurator),\n            8,\n            goerliEndPoint\n        );\n        eUSD = new EUSDMock(address(configurator));\n        // 6 decimal USDC token\n        usdc = new mockUSDC();\n        lbr = new LBR(address(configurator), 8, goerliEndPoint);\n        eslbr = new esLBR(address(configurator));\n        boost = new esLBRBoost();\n        rewardsPool = new ProtocolRewardsPool(address(configurator));\n        rewardsPool.setTokenAddress(address(eslbr), address(lbr), address(boost));\n        // Ether oracle has no impact on this test\n        wbETHVault =\n        new LybraWBETHVault(address(peUsdMainnet), makeAddr(\"NonImportantMockForEtherOracle\"), wbETH, address(configurator));\n        configurator.setMintVault(deployer, true);\n        configurator.initToken(address(eUSD), address(peUsdMainnet));\n        configurator.setProtocolRewardsPool(address(rewardsPool));\n        configurator.setProtocolRewardsToken(address(usdc));\n        curvePool.setToken(address(eUSD), address(usdc));\n\n        // Set minters\n        minerContracts.push(address(deployer));\n        minerContracts.push(address(rewardsPool));\n        minerContractsBools.push(true);\n        minerContractsBools.push(true);\n        configurator.setTokenMiner(minerContracts, minerContractsBools);\n\n        // Fund curve pool eusd/usdc\n        eUSD.mint(address(curvePool), 10000 * 1e18);\n        usdc.transfer(address(curvePool), 10000 * 1e6);\n\n        // Fund ALice\n        lbr.mint(address(alice), 100 * 1e18);\n        vm.stopPrank();\n    }\n\n    function test_canGetReward() public {\n        // Alice stake LBR\n        vm.startPrank(alice);\n        rewardsPool.stake(100 * 1e18);\n        assertEq(eslbr.balanceOf(alice), 100 * 1e18);\n        vm.stopPrank();\n\n        // Notify reward amount\n        vm.startPrank(deployer);\n        eUSD.mint(address(configurator), 3000 * 1e18);\n        configurator.setPremiumTradingEnabled(true);\n\n        uint256 eusdPreBalance = eUSD.balanceOf(address(configurator));\n        configurator.distributeRewards();\n        curvePool.setPrice(1010000);\n        uint256 price = curvePool.get_dy_underlying(0, 2, 1e18);\n        uint256 outUSDC = eusdPreBalance * price * 998 / 1e21;\n        assertEq(eUSD.sharesOf(address(rewardsPool)), 0);\n        assertEq(usdc.balanceOf(address(rewardsPool)), outUSDC);\n\n        configurator.distributeRewards();\n        vm.stopPrank();\n\n        uint256 newRewardPerTokenstored =\n            outUSDC * 1e36 / (10 ** ERC20(configurator.stableToken()).decimals()) / eslbr.totalSupply();\n\n        assertEq(rewardsPool.rewardPerTokenStored(), newRewardPerTokenstored);\n        assertEq(rewardsPool.earned(alice), eslbr.balanceOf(alice) * (newRewardPerTokenstored - 0) / 1e18);\n        uint256 earnedUSDC = rewardsPool.earned(alice);\n\n        vm.startPrank(alice);\n        rewardsPool.getReward();\n        // earnedUSDC / 1e12 -> Because rewardsPool.earned output has 18 decimal and USDC has 6 decimals\n        assertEq(usdc.balanceOf(alice), earnedUSDC / 1e12);\n        vm.stopPrank();\n    }\n}\n\n```\n\n### Tools Used\n\nFoundry\n\n### Assessed type\n\nMath\n\n**[0xean (judge) decreased severity to Medium](https://github.com/code-423n4/2023-06-lybra-findings/issues/828#issuecomment-1656233155)**\n\n**[LybraFinance confirmed](https://github.com/code-423n4/2023-06-lybra-findings/issues/828#issuecomment-1656654858)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/miner/ProtocolRewardsPool.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title ProtocolRewardsPool is a derivative version of Synthetix StakingRewards.sol, distributing Protocol revenue to esLBR stakers.\n * Converting esLBR to LBR.\n * Differences from the original contract,\n * - Get `totalStaked` from totalSupply() in contract esLBR.\n * - Get `stakedOf(user)` from balanceOf(user) in contract esLBR.\n * - When an address esLBR balance changes, call the refreshReward method to update rewards to be claimed.\n */\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IEUSD.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\nimport \"../interfaces/IesLBR.sol\";\n\ninterface IesLBRBoost {\n    function getUnlockTime(\n        address user\n    ) external view returns (uint256 unlockTime);\n}\n\ncontract ProtocolRewardsPool is Ownable {\n    Iconfigurator public immutable configurator;\n    IesLBR public esLBR;\n    IesLBR public LBR;\n    IesLBRBoost public esLBRBoost;\n\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint) public rewards;\n    mapping(address => uint) public time2fullRedemption;\n    mapping(address => uint) public unstakeRatio;\n    mapping(address => uint) public lastWithdrawTime;\n    uint256 immutable exitCycle = 90 days;\n    uint256 public grabableAmount;\n    uint256 public grabFeeRatio = 3000;\n    event Restake(address indexed user, uint256 amount, uint256 time);\n    event StakeLBR(address indexed user, uint256 amount, uint256 time);\n    event UnstakeLBR(address indexed user, uint256 amount, uint256 time);\n    event WithdrawLBR(address indexed user, uint256 amount, uint256 time);\n    event ClaimReward(address indexed user, uint256 eUSDAmount, address token, uint256 tokenAmount, uint256 time);\n\n    constructor(address _config) {\n        configurator = Iconfigurator(_config);\n    }\n\n    function setTokenAddress(address _eslbr, address _lbr, address _boost) external onlyOwner {\n        esLBR = IesLBR(_eslbr);\n        LBR = IesLBR(_lbr);\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    function setGrabCost(uint256 _ratio) external onlyOwner {\n        require(_ratio <= 8000, \"BCE\");\n        grabFeeRatio = _ratio;\n    }\n\n    // Total staked\n    function totalStaked() internal view returns (uint256) {\n        return esLBR.totalSupply();\n    }\n\n    // User address => esLBR balance\n    function stakedOf(address staker) internal view returns (uint256) {\n        return esLBR.balanceOf(staker);\n    }\n\n    function stake(uint256 amount) external {\n        LBR.burn(msg.sender, amount);\n        esLBR.mint(msg.sender, amount);\n        emit StakeLBR(msg.sender, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Unlocks esLBR and converts it to LBR.\n     * @param amount The amount to convert.\n     * Requirements:\n     * The current time must be greater than the unlock time retrieved from the boost contract for the user.\n     * Effects:\n     * Resets the user's vesting data, entering a new vesting period, when converting to LBR.\n     */\n    function unstake(uint256 amount) external {\n        require(block.timestamp >= esLBRBoost.getUnlockTime(msg.sender), \"Your lock-in period has not ended. You can't convert your esLBR now.\");\n        esLBR.burn(msg.sender, amount);\n        withdraw(msg.sender);\n        uint256 total = amount;\n        if (time2fullRedemption[msg.sender] > block.timestamp) {\n            total += unstakeRatio[msg.sender] * (time2fullRedemption[msg.sender] - block.timestamp);\n        }\n        unstakeRatio[msg.sender] = total / exitCycle;\n        time2fullRedemption[msg.sender] = block.timestamp + exitCycle;\n        emit UnstakeLBR(msg.sender, amount, block.timestamp);\n    }\n\n    function withdraw(address user) public {\n        uint256 amount = getClaimAbleLBR(user);\n        if (amount > 0) {\n            LBR.mint(user, amount);\n        }\n        lastWithdrawTime[user] = block.timestamp;\n        emit WithdrawLBR(user, amount, block.timestamp);\n    }\n\n    /**\n     * @dev Redeems and converts the ESLBR being claimed in advance,\n     * with the lost portion being recorded in the contract and available for others to purchase in LBR at a certain ratio.\n     */\n    function unlockPrematurely() external {\n        require(block.timestamp + exitCycle - 3 days > time2fullRedemption[msg.sender], \"ENW\");\n        uint256 burnAmount = getReservedLBRForVesting(msg.sender) - getPreUnlockableAmount(msg.sender);\n        uint256 amount = getPreUnlockableAmount(msg.sender) + getClaimAbleLBR(msg.sender);\n        if (amount > 0) {\n            LBR.mint(msg.sender, amount);\n        }\n        unstakeRatio[msg.sender] = 0;\n        time2fullRedemption[msg.sender] = 0;\n        grabableAmount += burnAmount;\n    }\n\n    /**\n     * @dev Purchase the accumulated amount of pre-claimed lost ESLBR in the contract using LBR.\n     * @param amount The amount of ESLBR to be purchased.\n     * Requirements:\n     * The amount must be greater than 0.\n     */\n    function grabEsLBR(uint256 amount) external {\n        require(amount > 0, \"QMG\");\n        grabableAmount -= amount;\n        LBR.burn(msg.sender, (amount * grabFeeRatio) / 10000);\n        esLBR.mint(msg.sender, amount);\n    }\n\n    /**\n     * @dev Convert unredeemed and converting ESLBR tokens back to LBR.\n     */\n    function reStake() external {\n        uint256 amount = getReservedLBRForVesting(msg.sender) + getClaimAbleLBR(msg.sender);\n        esLBR.mint(msg.sender, amount);\n        unstakeRatio[msg.sender] = 0;\n        time2fullRedemption[msg.sender] = 0;\n        emit Restake(msg.sender, amount, block.timestamp);\n    }\n\n    function getPreUnlockableAmount(address user) public view returns (uint256 amount) {\n        uint256 a = getReservedLBRForVesting(user);\n        if (a == 0) return 0;\n        amount = (a * (75e18 - ((time2fullRedemption[user] - block.timestamp) * 70e18) / (exitCycle / 1 days - 3) / 1 days)) / 100e18;\n    }\n\n    function getClaimAbleLBR(address user) public view returns (uint256 amount) {\n        if (time2fullRedemption[user] > lastWithdrawTime[user]) {\n            amount = block.timestamp > time2fullRedemption[user] ? unstakeRatio[user] * (time2fullRedemption[user] - lastWithdrawTime[user]) : unstakeRatio[user] * (block.timestamp - lastWithdrawTime[user]);\n        }\n    }\n\n    function getReservedLBRForVesting(address user) public view returns (uint256 amount) {\n        if (time2fullRedemption[user] > block.timestamp) {\n            amount = unstakeRatio[user] * (time2fullRedemption[user] - block.timestamp);\n        }\n    }\n\n    function earned(address _account) public view returns (uint) {\n        return ((stakedOf(_account) * (rewardPerTokenStored - userRewardPerTokenPaid[_account])) / 1e18) + rewards[_account];\n    }\n\n    function getClaimAbleUSD(address user) external view returns (uint256 amount) {\n        amount = IEUSD(configurator.getEUSDAddress()).getMintedEUSDByShares(earned(user));\n    }\n\n    /**\n     * @dev Call this function when deposit or withdraw ETH on Lybra and update the status of corresponding user.\n     */\n    modifier updateReward(address account) {\n        rewards[account] = earned(account);\n        userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        _;\n    }\n\n    function refreshReward(address _account) external updateReward(_account) {}\n\n    /**\n     * @notice When claiming protocol rewards earnings, if there is a sufficient amount of eUSD in the ProtocolRewards Pool,\n     * the eUSD will be prioritized for distribution. Distributes earnings in the order of peUSD and other stablecoins if the eUSD balance is insufficient..\n     */\n    function getReward() external updateReward(msg.sender) {\n        uint reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IEUSD EUSD = IEUSD(configurator.getEUSDAddress());\n            uint256 balance = EUSD.sharesOf(address(this));\n            uint256 eUSDShare = balance >= reward ? reward : reward - balance;\n            EUSD.transferShares(msg.sender, eUSDShare);\n            if(reward > eUSDShare) {\n                ERC20 peUSD = ERC20(configurator.peUSD());\n                uint256 peUSDBalance = peUSD.balanceOf(address(this));\n                if(peUSDBalance >= reward - eUSDShare) {\n                    peUSD.transfer(msg.sender, reward - eUSDShare);\n                    emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(peUSD), reward - eUSDShare, block.timestamp);\n                } else {\n                    if(peUSDBalance > 0) {\n                        peUSD.transfer(msg.sender, peUSDBalance);\n                    }\n                    ERC20 token = ERC20(configurator.stableToken());\n                    uint256 tokenAmount = (reward - eUSDShare - peUSDBalance) * token.decimals() / 1e18;\n                    token.transfer(msg.sender, tokenAmount);\n                    emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(token), reward - eUSDShare, block.timestamp);\n                }\n            } else {\n                emit ClaimReward(msg.sender, EUSD.getMintedEUSDByShares(eUSDShare), address(0), 0, block.timestamp);\n            }\n           \n        }\n    }\n\n    /**\n     * @dev Receives stablecoin tokens sent by the configurator contract and records the protocol rewards accumulation per esLBR held.\n     * @param amount The amount of rewards to be distributed.\n     * @param tokenType The type of token (0 for eUSD, 1 for other stablecoins, 2 for peUSD).\n     * @dev This function is called by the configurator contract to distribute rewards.\n     * @dev When receiving stablecoin tokens other than eUSD, the decimals of the token are converted to 18 for consistent calculations.\n     */\n    function notifyRewardAmount(uint amount, uint tokenType) external {\n        require(msg.sender == address(configurator));\n        if (totalStaked() == 0) return;\n        require(amount > 0, \"amount = 0\");\n        if(tokenType == 0) {\n            uint256 share = IEUSD(configurator.getEUSDAddress()).getSharesByMintedEUSD(amount);\n            rewardPerTokenStored = rewardPerTokenStored + (share * 1e18) / totalStaked();\n        } else if(tokenType == 1) {\n            ERC20 token = ERC20(configurator.stableToken());\n            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e36 / token.decimals()) / totalStaked();\n        } else {\n            rewardPerTokenStored = rewardPerTokenStored + (amount * 1e18) / totalStaked();\n        }\n    }\n}"
    }
  ]
}