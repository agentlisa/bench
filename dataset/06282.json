{
  "Title": "[M-06] There is a large precision error in sqrt calculation of lp",
  "Content": "\nCompared with div, there is a larger precision error in calculating lp through sqrt, so there should be a way to check whether there are excess tokens left when adding liquidity.\n\n### Proof of Concept\n\n```solidity\n    function testCalcLpTokenSupplyDiff() public {\n        uint256[] memory reserves = new uint256[](2);\n        reserves[0] = 1e24 + 1e4;\n        reserves[1] = 10000;\n        uint256 lp1 = this.calcLpTokenSupply(reserves, bytes(\"\"));\n        reserves[0] = 1e24;\n        reserves[1] = 10000;\n        uint256 lp2 = this.calcLpTokenSupply(reserves, bytes(\"\"));\n        assert(lp1 == lp2);\n    }\n```\n\nWhen reserve\\[0] is larger relative to reserve\\[1], the accuracy error is larger, and unlike div, the accuracy error is only 1, the accuracy error of sqrt is larger.\nWhen the user input the imbalance the amount will left excess reserve, searchers will monitor the contract after the excess reserve accumulation to a certain degree, will withdraw them by removeLiquidityImbalanced.\n\n### Recommended Mitigation Steps\n\nExcess reserve tokens should be returned when the user adds liquidity\n\n**[publiuss (Basin) acknowledged and commented](https://github.com/code-423n4/2023-07-basin-findings/issues/190#issuecomment-1689108454):**\n\n> This is a known issue. The documentation should be updated.\n>\n> This was appended to the documentation [here](https://github.com/BeanstalkFarms/Basin/blob/91233a22005986aa7c9f3b0c67393842cd8a8e4d/src/functions/ConstantProduct2.sol#L49).\n> \n> \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-basin",
  "Code": [
    {
      "filename": "src/functions/ConstantProduct2.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {IBeanstalkWellFunction} from \"src/interfaces/IBeanstalkWellFunction.sol\";\nimport {ProportionalLPToken2} from \"src/functions/ProportionalLPToken2.sol\";\nimport {LibMath} from \"src/libraries/LibMath.sol\";\n\n/**\n * @title ConstantProduct2\n * @author Publius\n * @notice Gas efficient Constant Product pricing function for Wells with 2 tokens.\n * @dev Constant Product Wells with 2 tokens use the formula:\n *  `b_0 * b_1 = s^2`\n *\n * Where:\n *  `s` is the supply of LP tokens\n *  `b_i` is the reserve at index `i`\n */\ncontract ConstantProduct2 is ProportionalLPToken2, IBeanstalkWellFunction {\n    using LibMath for uint256;\n\n    uint256 constant EXP_PRECISION = 1e12;\n\n    /**\n     * @dev `s = (b_0 * b_1)^(1/2)`\n     *\n     * When does this function overflow?\n     * ---------------------------------\n     *\n     * Let N be the length of the reserves array, and P be the precision multiplier\n     * defined in `EXP_PRECISION`.\n     *\n     * Assuming all tokens in reserves are at their maximum value simultaneously,\n     * this function will overflow when:\n     *\n     *  (10^X)^N * P >= MAX_UINT256 (~10^77)\n     *  10^(X*N) >= 10^77/P\n     *  (X*N)*ln(10) >= 77*ln(10) - ln(P)\n     *\n     *  âˆ´ X >= (1/N) * (77 - ln(P)/ln(10))\n     *\n     * ConstantProduct2 sets the constraints `N = 2` and `EXP_PRECISION = 1e12`,\n     * resulting in an upper bound of X = 32.5.\n     *\n     * In other words, {calcLpTokenSupply} overflows if all reserves are simultaneously\n     * >= 10^32.5, or about 100 trillion if tokens are measured to 18 decimal precision.\n     *\n     * The further apart the reserve values, the greater the loss of precision in the `sqrt` function.\n     */\n    function calcLpTokenSupply(\n        uint256[] calldata reserves,\n        bytes calldata\n    ) external pure override returns (uint256 lpTokenSupply) {\n        lpTokenSupply = (reserves[0] * reserves[1] * EXP_PRECISION).sqrt();\n    }\n\n    /// @dev `b_j = s^2 / b_{i | i != j}`\n    /// @dev rounds up\n    function calcReserve(\n        uint256[] calldata reserves,\n        uint256 j,\n        uint256 lpTokenSupply,\n        bytes calldata\n    ) external pure override returns (uint256 reserve) {\n        if (j >= 2) {\n            revert InvalidJArgument();\n        }\n        // Note: potential optimization is to use unchecked math here\n        reserve = lpTokenSupply ** 2;\n        reserve = LibMath.roundUpDiv(reserve, reserves[j == 1 ? 0 : 1] * EXP_PRECISION);\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Constant Product 2\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"CP2\";\n    }\n\n    /// @dev `b_j = (b_0 * b_1 * r_j / r_i)^(1/2)`\n    /// Note: Always rounds down\n    function calcReserveAtRatioSwap(\n        uint256[] calldata reserves,\n        uint256 j,\n        uint256[] calldata ratios,\n        bytes calldata\n    ) external pure override returns (uint256 reserve) {\n        uint256 i = j == 1 ? 0 : 1;\n        // use 512 muldiv for last mul to avoid overflow\n        reserve = (reserves[i] * reserves[j]).mulDiv(ratios[j], ratios[i]).sqrt();\n    }\n\n    /// @dev `b_j = b_i * r_j / r_i`\n    /// Note: Always rounds down\n    function calcReserveAtRatioLiquidity(\n        uint256[] calldata reserves,\n        uint256 j,\n        uint256[] calldata ratios,\n        bytes calldata\n    ) external pure override returns (uint256 reserve) {\n        uint256 i = j == 1 ? 0 : 1;\n        reserve = reserves[i] * ratios[j] / ratios[i];\n    }\n}"
    }
  ]
}