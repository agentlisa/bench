{
  "Title": "[M-03] Rewards cannot be transferred when calling protocol command",
  "Content": "\nRewards are set up using protocol commands, but its entry point is not payable.\n\nRewards can be set up by protocol authorities using the functions `setConcRewards()` and `setAmbRewards()` present in the LiquidityMiningPath contracts. These two are part of the \"command\" pattern used in the protocol: the main entry point receives *commands* which are then routed to the proper place using *codes*.\n\nThe protocol command flow starts at the `CrocSwapDex` contract:\n\n<https://github.com/code-423n4/2023-10-canto/blob/main/canto_ambient/contracts/CrocSwapDex.sol#L103-L106>\n\n```solidity\n103:     function protocolCmd (uint16 callpath, bytes calldata cmd, bool sudo)\n104:         protocolOnly(sudo) public payable override {\n105:         callProtocolCmd(callpath, cmd);\n106:     }\n```\n\n<https://github.com/code-423n4/2023-10-canto/blob/main/canto_ambient/contracts/mixins/ProxyCaller.sol#L22-L28>\n\n```solidity\n22:     function callProtocolCmd (uint16 proxyIdx, bytes calldata input) internal\n23:         returns (bytes memory) {\n24:         assertProxy(proxyIdx);\n25:         (bool success, bytes memory output) = proxyPaths_[proxyIdx].delegatecall(\n26:             abi.encodeWithSignature(\"protocolCmd(bytes)\", input));\n27:         return verifyCallResult(success, output);\n28:     }\n```\n\nThe `protocolCmd()` function checks the call is properly authorized and calls `callProtocolCmd()`, which then executes a `delegatecall` to the corresponding implementation, in this case the `LiquidityMiningPath` contract:\n\n<https://github.com/code-423n4/2023-10-canto/blob/main/canto_ambient/contracts/callpaths/LiquidityMiningPath.sol#L26-L37>\n\n```solidity\n26:     function protocolCmd(bytes calldata cmd) public virtual {\n27:         (uint8 code, bytes32 poolHash, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) =\n28:             abi.decode(cmd, (uint8, bytes32, uint32, uint32, uint64));\n29: \n30:         if (code == ProtocolCmd.SET_CONC_REWARDS_CODE) {\n31:             setConcRewards(poolHash, weekFrom, weekTo, weeklyReward);\n32:         } else if (code == ProtocolCmd.SET_AMB_REWARDS_CODE) {\n33:             setAmbRewards(poolHash, weekFrom, weekTo, weeklyReward);\n34:         } else {\n35:             revert(\"Invalid protocol command\");\n36:         }\n37:     }\n```\n\nWhile `CrocSwapDex::protocolCmd()` is payable, its counterpart in `LiquidityMiningPath` is not. This means that rewards cannot be transferred while setting them up, rejecting any command that has positive `callvalue`.\n\n### Recommendation\n\nMake `LiquidityMiningPath::protocolCmd()` payable.\n\n```diff\n-   function protocolCmd(bytes calldata cmd) public virtual {\n+   function protocolCmd(bytes calldata cmd) public virtual payable {\n        (uint8 code, bytes32 poolHash, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) =\n            abi.decode(cmd, (uint8, bytes32, uint32, uint32, uint64));\n\n        if (code == ProtocolCmd.SET_CONC_REWARDS_CODE) {\n            setConcRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else if (code == ProtocolCmd.SET_AMB_REWARDS_CODE) {\n            setAmbRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else {\n            revert(\"Invalid protocol command\");\n        }\n    }\n```\n\n### Assessed type\n\nPayable\n\n**[141345 (lookout) commented](https://github.com/code-423n4/2023-10-canto-findings/issues/239#issuecomment-1752014651):**\n > `protocolCmd()` should be payable.\n> \n> One walk around is to call `setAmbRewards()`/`setConcRewards()`directly to send funds. But seems the expected way is to use this contract through `delegatecall`, if the contract is deployed without this option, the described issue could be some problem.\n\n**[OpenCoreCH (Canto) confirmed](https://github.com/code-423n4/2023-10-canto-findings/issues/239#issuecomment-1757450727)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-canto",
  "Code": [
    {
      "filename": "canto_ambient/contracts/CrocSwapDex.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport './libraries/Directives.sol';\nimport './libraries/Encoding.sol';\nimport './libraries/TokenFlow.sol';\nimport './libraries/PriceGrid.sol';\nimport './mixins/MarketSequencer.sol';\nimport './mixins/SettleLayer.sol';\nimport './mixins/PoolRegistry.sol';\nimport './mixins/MarketSequencer.sol';\nimport './interfaces/ICrocMinion.sol';\nimport './callpaths/ColdPath.sol';\nimport './callpaths/BootPath.sol';\nimport './callpaths/WarmPath.sol';\nimport './callpaths/HotPath.sol';\nimport './callpaths/LongPath.sol';\nimport './callpaths/KnockoutPath.sol';\nimport './callpaths/MicroPaths.sol';\nimport './callpaths/SafeModePath.sol';\n\n/* @title CrocSwap exchange contract\n * @notice Top-level CrocSwap contract. Contains all public facing methods and state\n *         for the entire dex across every pool.\n *\n * @dev    Sidecar proxy contracts exist to contain code that doesn't fit in the Ethereum\n *         limit, but this is the only contract that users need to directly interface \n *         with. */\ncontract CrocSwapDex is HotPath, ICrocMinion {\n\n    using SafeCast for uint128;\n    using TokenFlow for TokenFlow.PairSeq;\n    using CurveMath for CurveMath.CurveState;\n    using Chaining for Chaining.PairFlow;\n\n    constructor() {\n        // Authority is originally set to deployer address, which can then transfer to\n        // proper governance contract (if deployer already isn't)\n        authority_ = msg.sender;\n        hotPathOpen_ = true;\n        proxyPaths_[CrocSlots.BOOT_PROXY_IDX] = address(new BootPath());\n    }\n\n    /* @notice Swaps between two tokens within a single liquidity pool.\n     *\n     * @dev This is the most gas optimized swap call, since it avoids calling out to any\n     *      proxy contract. However there's a possibility in the future that this call \n     *      path could be disabled to support upgraded logic. In which case the caller \n     *      should be able to swap through using a userCmd() call on the HOT_PATH proxy\n     *      call path.\n     * \n     * @param base The base-side token of the pair. (For native Ethereum use 0x0)\n     * @param quote The quote-side token of the pair.\n     * @param poolIdx The index of the pool type to execute on.\n     * @param isBuy If true the direction of the swap is for the user to send base tokens\n     *              and receive back quote tokens.\n     * @param inBaseQty If true the quantity is denominated in base-side tokens. If not\n     *                  use quote-side tokens.\n     * @param qty The quantity of tokens to swap. End result could be less if the pool \n     *            price reaches limitPrice before exhausting.\n     * @param tip A user-designated liquidity fee paid to the LPs in the pool. If set to\n     *            0, just defaults to the standard pool rate. Otherwise represents the\n     *            proposed LP fee in units of 1/1,000,000. Not used in standard swap \n     *            calls, but may be used in certain permissioned or dynamic fee pools.\n     * @param limitPrice The worse price the user is willing to pay on the margin. Swap\n     *                   will execute up to this price, but not any worse. Average fill \n     *                   price will always be equal or better, because this is calculated\n     *                   at the marginal unit of quantity.\n     * @param minOut The minimum output the user expects from the swap. If less is \n     *               returned, the transaction will revert. (Alternatively if the swap\n     *               is fixed in terms of output, this is the maximum input.)\n     * @param reserveFlags Bitwise flags to indicate if the user wants to pay/receive in\n     *                     terms of surplus collateral balance held at the dex contract.\n     *                          0x1 - Base token is paid/received from surplus collateral\n     *                          0x2 - Quote token is paid/received from surplus collateral\n     * @return The token base and quote token flows associated with this swap action. \n     *         (Negative indicates a credit paid to the user, positive a debit collected\n     *         from the user) */\n    function swap (address base, address quote,\n                   uint256 poolIdx, bool isBuy, bool inBaseQty, uint128 qty, uint16 tip,\n                   uint128 limitPrice, uint128 minOut,\n                   uint8 reserveFlags) reEntrantLock public payable\n        returns (int128 baseQuote, int128 quoteFlow) {\n        // By default the embedded hot-path is enabled, but protocol governance can\n        // disable by toggling the force proxy flag. If so, users should point to\n        // swapProxy.\n        require(hotPathOpen_);\n        return swapExecute(base, quote, poolIdx, isBuy, inBaseQty, qty, tip,\n                           limitPrice, minOut, reserveFlags);\n    }\n\n    /* @notice Consolidated method for protocol control related commands.\n     * @dev    We consolidate multiple protocol control types into a single method to \n     *         reduce the contract size in the main contract by paring down methods.\n     * \n     * @param callpath The proxy sidecar callpath called into. (Calls into proxyCmd() on\n     *                 the respective sidecare contract)\n     * @param cmd      The arbitrary byte calldata corresponding to the command. Format\n     *                 dependent on the specific callpath.\n     * @param sudo     If true, indicates that the command should be called with elevated\n     *                 privileges. */\n    function protocolCmd (uint16 callpath, bytes calldata cmd, bool sudo)\n        protocolOnly(sudo) public payable override {\n        callProtocolCmd(callpath, cmd);\n    }\n\n    /* @notice Calls an arbitrary command on one of the sidecar proxy contracts at a specific\n     *         index. Not all proxy slots may have a contract attached. If so, this call will\n     *         fail.\n     *\n     * @param callpath The index of the proxy sidecar the command is being called on.\n     * @param cmd The arbitrary call data the client is calling the proxy sidecar.\n     * @return Arbitrary byte data (if any) returned by the command. */\n    function userCmd (uint16 callpath, bytes calldata cmd) reEntrantLock\n        public payable returns (bytes memory) {\n        return callUserCmd(callpath, cmd);\n    }\n\n    /* @notice Calls an arbitrary command on behalf of another user who has signed an \n     *         EIP-712 off-chain transaction. Same general call logic as userCmd(), but\n     *         with additional args for conditions, and relayer payment.\n     *\n     * @param callpath The index of the proxy sidecar the command is being called on.\n     * @param cmd The arbitrary call data the client is calling the proxy sidecar.\n     * @param conds An ABI encoded list of evaluation conditions that are required for \n     *              this command to execute. See AgentMask.sol for format of this data.\n     * @param relayerTip An ABI encoded directive for tipping the relayer on behalf of\n     *                   the underlying client, for having mined the transaction. If this\n     *                   byte array is empty no calldata. See AgentMask.sol for format \n     *                   details.\n     * @param signature The ERC-712 signature of the above parameters signed by the \n     *                  private key of the public address the command is being executed \n     *                  for.\n     * @return Arbitrary byte data (if any) returned by the command. */\n    function userCmdRelayer (uint16 callpath, bytes calldata cmd,\n                             bytes calldata conds, bytes calldata relayerTip, \n                             bytes calldata signature)\n        reEntrantAgent(CrocRelayerCall(callpath, cmd, conds, relayerTip), signature)\n        public payable returns (bytes memory output) {\n        output = callUserCmd(callpath, cmd);\n        tipRelayer(relayerTip);\n    }\n\n    /* @notice Calls an arbitrary command on behalf of a user from a (pre-approved) \n     *         external router contract acting as an agent on the user's behalf.\n     *\n     * @dev This can only be called when the underlying user has previously approved the\n     *      msg.sender address as a router on its behalf.\n     *\n     * @param callpath The index of the proxy sidecar the command is being called on.\n     * @param cmd The arbitrary call data the client is calling the proxy sidecar.\n     * @param client The address of the client the router is calling on behalf of.\n     * @return Arbitrary byte data (if any) returned by the command. */\n    function userCmdRouter (uint16 callpath, bytes calldata cmd, address client)\n        reEntrantApproved(client, callpath) public payable\n        returns (bytes memory) {\n        return callUserCmd(callpath, cmd);\n    }\n\n    /* @notice General purpose query fuction for reading arbitrary data from the dex.\n     * @dev    This function is bare bones, because we're trying to keep the size \n     *         footprint of CrocSwapDex down. See SlotLocations.sol and QueryHelper.sol \n     *         for syntactic sugar around accessing/parsing specific data. */\n    function readSlot (uint256 slot) public view returns (uint256 data) {\n        assembly {\n        data := sload(slot)\n        }\n    }\n\n    /* @notice Validation function used by external contracts to verify an address is\n     *         a valid CrocSwapDex contract. */\n    function acceptCrocDex() pure public returns (bool) { return true; }\n}\n\n\n/* @notice Alternative constructor to CrocSwapDex that's more convenient. However\n *     the deploy transaction is several hundred kilobytes and will get droppped by \n *     geth. Useful for testing environments though. */\ncontract CrocSwapDexSeed  is CrocSwapDex {\n    \n    constructor() {\n        proxyPaths_[CrocSlots.LP_PROXY_IDX] = address(new WarmPath());\n        proxyPaths_[CrocSlots.COLD_PROXY_IDX] = address(new ColdPath());\n        proxyPaths_[CrocSlots.LONG_PROXY_IDX] = address(new LongPath());\n        proxyPaths_[CrocSlots.MICRO_PROXY_IDX] = address(new MicroPaths());\n        proxyPaths_[CrocSlots.FLAG_CROSS_PROXY_IDX] = address(new KnockoutFlagPath());\n        proxyPaths_[CrocSlots.KNOCKOUT_LP_PROXY_IDX] = address(new KnockoutLiqPath());\n        proxyPaths_[CrocSlots.SAFE_MODE_PROXY_PATH] = address(new SafeModePath());\n    }\n}"
    },
    {
      "filename": "canto_ambient/contracts/mixins/ProxyCaller.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport './StorageLayout.sol';\nimport '../libraries/CurveCache.sol';\nimport '../libraries/Chaining.sol';\nimport '../libraries/Directives.sol';\n\n/* @title Proxy Caller\n * @notice Because of the Ethereum contract limit, much of the CrocSwap code is pushed\n *         into sidecar proxy contracts, which is involed with DELEGATECALLs. The code\n *         moved to these sidecars is less gas critical than the code in the core contract. \n *         This provides a facility for invoking proxy conjtracts in a consistent way by\n*          setting up the DELEGATECALLs in a standard and safe manner. */\ncontract ProxyCaller is StorageLayout {\n    using CurveCache for CurveCache.Cache;\n    using CurveMath for CurveMath.CurveState;\n    using Chaining for Chaining.PairFlow;\n\n    /* @notice Passes through the protocolCmd call to a sidecar proxy. */\n    function callProtocolCmd (uint16 proxyIdx, bytes calldata input) internal\n        returns (bytes memory) {\n        assertProxy(proxyIdx);\n        (bool success, bytes memory output) = proxyPaths_[proxyIdx].delegatecall(\n            abi.encodeWithSignature(\"protocolCmd(bytes)\", input));\n        return verifyCallResult(success, output);\n    }\n\n    /* @notice Passes through the userCmd call to a sidecar proxy. */\n    function callUserCmd (uint16 proxyIdx, bytes calldata input)\n        internal returns (bytes memory) {\n        assertProxy(proxyIdx);\n        (bool success, bytes memory output) = proxyPaths_[proxyIdx].delegatecall(\n            abi.encodeWithSignature(\"userCmd(bytes)\", input));\n        return verifyCallResult(success, output);\n    }\n\n    function callUserCmdMem (uint16 proxyIdx, bytes memory input)\n        internal returns (bytes memory) {\n        assertProxy(proxyIdx);\n        (bool success, bytes memory output) = proxyPaths_[proxyIdx].delegatecall(\n            abi.encodeWithSignature(\"userCmd(bytes)\", input));\n        return verifyCallResult(success, output);\n    }\n\n    function assertProxy (uint16 proxyIdx) private view {\n        require(proxyPaths_[proxyIdx] != address(0));\n        require(!inSafeMode_ || proxyIdx == CrocSlots.SAFE_MODE_PROXY_PATH || proxyIdx == CrocSlots.BOOT_PROXY_IDX);\n    }\n\n    function verifyCallResult (bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        // On success pass through the return data\n        if (success) {\n            return returndata;\n        } else if (returndata.length > 0) {\n            // If DELEGATECALL failed bubble up the error message\n            assembly {\n                 let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            // If failed with no  error, then bubble up the empty revert\n            revert();\n        }\n    }\n\n    /* @notice Invokes mintAmbient() call in MicroPaths sidecar and relays the result. */\n    function callMintAmbient (CurveCache.Cache memory curve, uint128 liq,\n                              bytes32 poolHash) internal\n        returns (int128 basePaid, int128 quotePaid) {\n        (bool success, bytes memory output) =\n            proxyPaths_[CrocSlots.MICRO_PROXY_IDX].delegatecall\n            (abi.encodeWithSignature\n             (\"mintAmbient(uint128,uint128,uint128,uint64,uint64,uint128,bytes32)\",\n              curve.curve_.priceRoot_, \n              curve.curve_.ambientSeeds_,\n              curve.curve_.concLiq_,\n              curve.curve_.seedDeflator_,\n              curve.curve_.concGrowth_,\n              liq, poolHash));\n        require(success);\n        \n        (basePaid, quotePaid,\n         curve.curve_.ambientSeeds_) = \n            abi.decode(output, (int128, int128, uint128));\n    }\n\n    /* @notice Invokes burnAmbient() call in MicroPaths sidecar and relays the result. */\n    function callBurnAmbient (CurveCache.Cache memory curve, uint128 liq,\n                              bytes32 poolHash) internal\n        returns (int128 basePaid, int128 quotePaid) {\n\n        (bool success, bytes memory output) =\n            proxyPaths_[CrocSlots.MICRO_PROXY_IDX].delegatecall\n            (abi.encodeWithSignature\n             (\"burnAmbient(uint128,uint128,uint128,uint64,uint64,uint128,bytes32)\",\n              curve.curve_.priceRoot_, \n              curve.curve_.ambientSeeds_,\n              curve.curve_.concLiq_,\n              curve.curve_.seedDeflator_,\n              curve.curve_.concGrowth_,\n              liq, poolHash));\n        require(success);\n        \n        (basePaid, quotePaid,\n         curve.curve_.ambientSeeds_) = \n            abi.decode(output, (int128, int128, uint128));\n    }\n\n    /* @notice Invokes mintRange() call in MicroPaths sidecar and relays the result. */\n    function callMintRange (CurveCache.Cache memory curve,\n                            int24 bidTick, int24 askTick, uint128 liq,\n                            bytes32 poolHash) internal\n        returns (int128 basePaid, int128 quotePaid) {\n\n        (bool success, bytes memory output) =\n            proxyPaths_[CrocSlots.MICRO_PROXY_IDX].delegatecall\n            (abi.encodeWithSignature\n             (\"mintRange(uint128,int24,uint128,uint128,uint64,uint64,int24,int24,uint128,bytes32)\",\n              curve.curve_.priceRoot_, curve.pullPriceTick(),\n              curve.curve_.ambientSeeds_,\n              curve.curve_.concLiq_,\n              curve.curve_.seedDeflator_,\n              curve.curve_.concGrowth_,\n              bidTick, askTick, liq, poolHash));\n        require(success);\n\n        (basePaid, quotePaid,\n         curve.curve_.ambientSeeds_,\n         curve.curve_.concLiq_) = \n            abi.decode(output, (int128, int128, uint128, uint128));\n    }\n    \n    /* @notice Invokes burnRange() call in MicroPaths sidecar and relays the result. */\n    function callBurnRange (CurveCache.Cache memory curve,\n                            int24 bidTick, int24 askTick, uint128 liq,\n                            bytes32 poolHash) internal\n        returns (int128 basePaid, int128 quotePaid) {\n        \n        (bool success, bytes memory output) =\n            proxyPaths_[CrocSlots.MICRO_PROXY_IDX].delegatecall\n            (abi.encodeWithSignature\n             (\"burnRange(uint128,int24,uint128,uint128,uint64,uint64,int24,int24,uint128,bytes32)\",\n              curve.curve_.priceRoot_, curve.pullPriceTick(),\n              curve.curve_.ambientSeeds_, curve.curve_.concLiq_,\n              curve.curve_.seedDeflator_, curve.curve_.concGrowth_,\n              bidTick, askTick, liq, poolHash));\n        require(success);\n        \n        (basePaid, quotePaid,\n         curve.curve_.ambientSeeds_,\n         curve.curve_.concLiq_) = \n            abi.decode(output, (int128, int128, uint128, uint128));\n    }\n\n    /* @notice Invokes sweepSwap() call in MicroPaths sidecar and relays the result. */\n    function callSwap (Chaining.PairFlow memory accum,\n                       CurveCache.Cache memory curve,\n                       Directives.SwapDirective memory swap,\n                       PoolSpecs.PoolCursor memory pool) internal {\n        (bool success, bytes memory output) =\n            proxyPaths_[CrocSlots.MICRO_PROXY_IDX].delegatecall\n            (abi.encodeWithSignature\n             (\"sweepSwap((uint128,uint128,uint128,uint64,uint64),int24,(bool,bool,uint8,uint128,uint128),((uint8,uint16,uint8,uint16,uint8,uint8,uint8),bytes32,address))\",\n              curve.curve_, curve.pullPriceTick(), swap, pool));\n        require(success);\n\n        Chaining.PairFlow memory swapFlow;\n        (swapFlow, curve.curve_.priceRoot_,\n         curve.curve_.ambientSeeds_,\n         curve.curve_.concLiq_,\n         curve.curve_.seedDeflator_,\n         curve.curve_.concGrowth_) = \n            abi.decode(output, (Chaining.PairFlow, uint128, uint128, uint128,\n                                uint64, uint64));\n\n        // swap() is the only operation that can change curve price, so have to mark\n        // the tick cache as dirty.\n        curve.dirtyPrice();\n        accum.foldFlow(swapFlow);\n    }\n\n    function callCrossFlag (bytes32 poolHash, int24 tick,\n                            bool isBuy, uint64 feeGlobal)\n        internal returns (int128 concLiqDelta) {\n        require(proxyPaths_[CrocSlots.FLAG_CROSS_PROXY_IDX] != address(0));\n        \n        (bool success, bytes memory cmd) =\n            proxyPaths_[CrocSlots.FLAG_CROSS_PROXY_IDX].delegatecall\n            (abi.encodeWithSignature\n             (\"crossCurveFlag(bytes32,int24,bool,uint64)\",\n              poolHash, tick, isBuy, feeGlobal));\n        require(success);\n\n        concLiqDelta = abi.decode(cmd, (int128));\n    }\n}"
    },
    {
      "filename": "canto_ambient/contracts/callpaths/LiquidityMiningPath.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"../mixins/StorageLayout.sol\";\nimport \"../mixins/LiquidityMining.sol\";\nimport \"../libraries/ProtocolCmd.sol\";\n\n/* @title Liquidity mining callpath sidecar.\n * @notice Defines a proxy sidecar contract that's used to move code outside the \n *         main contract to avoid Ethereum's contract code size limit. Contains\n *         components related to CANTO liquidity mining.\n * \n * @dev    This exists as a standalone contract but will only ever contain proxy code,\n *         not state. As such it should never be called directly or externally, and should\n *         only be invoked with DELEGATECALL so that it operates on the contract state\n *         within the primary CrocSwap contract.\n * @dev Since this contract is a proxy sidecar, entrypoints need to be marked\n *      payable even though it doesn't directly handle msg.value. Otherwise it will\n *      fail on any. Because of this, this contract should never be used in any other\n *      context besides a proxy sidecar to CrocSwapDex. */\ncontract LiquidityMiningPath is LiquidityMining {\n    /* @notice Consolidated method for protocol control related commands. \n     *         Used to set reward rates */\n    function protocolCmd(bytes calldata cmd) public virtual {\n        (uint8 code, bytes32 poolHash, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) =\n            abi.decode(cmd, (uint8, bytes32, uint32, uint32, uint64));\n\n        if (code == ProtocolCmd.SET_CONC_REWARDS_CODE) {\n            setConcRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else if (code == ProtocolCmd.SET_AMB_REWARDS_CODE) {\n            setAmbRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else {\n            revert(\"Invalid protocol command\");\n        }\n    }\n\n    /* @notice Consolidated method for user commands.\n     *         Used for claiming liquidity mining rewards. */\n    function userCmd(bytes calldata input) public payable {\n        (uint8 code, bytes32 poolHash, int24 lowerTick, int24 upperTick, uint32[] memory weeksToClaim) =\n            abi.decode(input, (uint8, bytes32, int24, int24, uint32[]));\n\n        if (code == UserCmd.CLAIM_CONC_REWARDS_CODE) {\n            claimConcentratedRewards(poolHash, lowerTick, upperTick, weeksToClaim);\n        } else if (code == UserCmd.CLAIM_AMB_REWARDS_CODE) {\n            claimAmbientRewards(poolHash, weeksToClaim);\n        } else {\n            revert(\"Invalid user command\");\n        }\n    }\n\n    function claimConcentratedRewards(bytes32 poolIdx, int24 lowerTick, int24 upperTick, uint32[] memory weeksToClaim)\n        public\n        payable\n    {\n        claimConcentratedRewards(payable(msg.sender), poolIdx, lowerTick, upperTick, weeksToClaim);\n    }\n\n    function claimAmbientRewards(bytes32 poolIdx, uint32[] memory weeksToClaim) public payable {\n        claimAmbientRewards(payable(msg.sender), poolIdx, weeksToClaim);\n    }\n\n    function setConcRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            concRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n\n    function setAmbRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            ambRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n\n    /* @notice Used at upgrade time to verify that the contract is a valid Croc sidecar proxy and used\n     *         in the correct slot. */\n    function acceptCrocProxyRole(address, uint16 slot) public pure returns (bool) {\n        return slot == CrocSlots.LIQUIDITY_MINING_PROXY_IDX;\n    }\n}"
    }
  ]
}