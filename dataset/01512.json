{
  "Title": "Lack of input validation",
  "Content": "Throughout the codebase, there are several functions that lack input validation when changing privileged roles, allowing these roles to be set to the zero address. In particular:\n\n\n* The `newAdmin` argument of the [`changeAdmin` function](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.5/contracts_common/BaseWithStorage/AdminV2.sol#L17) in the `AdminV2` contract for both implementations\n* The [`batchTransferQuadToL2` function](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/root/land/LandTunnelV2.sol#L71) in the `LandTunnelV2` contract can be called with zero-length arrays for the `sizes`, `xs`, and `ys` arguments. Consider validating that the input arrays have a length of at least 1.\n* The [`batchTransferQuadToL1` function](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandTunnelV2.sol#L95) in the `PolygonLandTunnelV2` contract can be called with zero-length arrays for the `sizes`, `xs`, and `ys` arguments. Consider validating that the input arrays have a length of at least 1.\n* The [`setLimit`](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandTunnelV2.sol#L51) function in the `PolygonLandTunnelV2` contract accepts a quad `size` and the gas limit for that size. The `size` argument is never validated to ensure it corresponds to a valid quad size of 1, 3, 6, 12, or 24.\n* The [`setMaxLimitOnL1` function](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandTunnelV2.sol#L35) in the `PolygonLandTunnelV2` contract does not validate that the input gas limit is non-zero. If the `maxGasOnLimitOnL1` variable is set to zero it would prevent tokens from being transferred to L1 as the [gas check within the `batchTransferQuadToL1` function](https://github.com/thesandboxgame/sandbox-smart-contracts/blob/8430ea5fdb0f4905b9678689ce0cbc2f74a704b6/src/solc_0.8/polygon/child/land/PolygonLandTunnelV2.sol#L116) will always fail.\n\n\nConsider adding a check that prevents setting these roles to the zero address and including a separate function for revoking role rights.\n\n\n***Update:** Partially resolved in [pull request #954](https://github.com/thesandboxgame/sandbox-smart-contracts/pull/954) at commit [0f7f68d](https://github.com/thesandboxgame/sandbox-smart-contracts/pull/954/commits/0f7f68dc482241151811de8ce27fa3839c1a45ab). The Sandbox team stated:*\n\n\n\n> *We decided not to fix the issue on AdminV2 as we want to be able to give up on the admin role.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/solc_0.5/contracts_common/BaseWithStorage/AdminV2.sol",
      "content": "pragma solidity 0.5.9;\n\ncontract AdminV2 {\n\n    address internal _admin;\n\n    event AdminChanged(address oldAdmin, address newAdmin);\n\n    /// @notice gives the current administrator of this contract.\n    /// @return the current administrator of this contract.\n    function getAdmin() external view returns (address) {\n        return _admin;\n    }\n\n    /// @notice change the administrator to be `newAdmin`.\n    /// @param newAdmin address of the new administrator.\n    function changeAdmin(address newAdmin) external {\n        address admin = _admin;\n        require(msg.sender == admin, \"only admin can change admin\");\n        require(newAdmin != admin, \"it can be only changed to a new admin\");\n        emit AdminChanged(admin, newAdmin);\n        _admin = newAdmin;\n    }\n\n    modifier onlyAdmin() {\n        require (msg.sender == _admin, \"only admin allowed\");\n        _;\n    }\n\n}"
    },
    {
      "filename": "src/solc_0.8/polygon/root/land/LandTunnelV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"../../../common/fx-portal/FxBaseRootTunnelUpgradeable.sol\";\nimport \"../../../common/BaseWithStorage/ERC2771Handler.sol\";\nimport \"../../../common/interfaces/ILandTokenV2.sol\";\nimport \"../../../common/interfaces/IERC721MandatoryTokenReceiver.sol\";\n\n/// @title LAND bridge on L1\ncontract LandTunnelV2 is\n    FxBaseRootTunnelUpgradeable,\n    IERC721MandatoryTokenReceiver,\n    ERC2771Handler,\n    OwnableUpgradeable,\n    PausableUpgradeable\n{\n    ILandTokenV2 public rootToken;\n    bool internal transferringToL2;\n\n    event Deposit(address indexed user, uint256 size, uint256 x, uint256 y, bytes data);\n    event Withdraw(address indexed user, uint256 size, uint256 x, uint256 y, bytes data);\n\n    function initialize(\n        address _checkpointManager,\n        address _fxRoot,\n        ILandTokenV2 _rootToken,\n        address _trustedForwarder\n    ) public initializer {\n        rootToken = _rootToken;\n        __Ownable_init();\n        __Pausable_init();\n        __FxBaseRootTunnelUpgradeable_initialize(_checkpointManager, _fxRoot);\n        __ERC2771Handler_initialize(_trustedForwarder);\n    }\n\n    /// @dev called on ERC721 trasnfer to this contract\n    /// @param operator address of the one sending the ERC721 Token\n    /// @return onERC721Received function selector\n    function onERC721Received(\n        address operator,\n        address, /* from */\n        uint256, /* tokenId */\n        bytes calldata /* data */\n    ) external view override returns (bytes4) {\n        require(transferringToL2 || rootToken.isSuperOperator(operator), \"LandTunnelV2: !BRIDGING\");\n        return this.onERC721Received.selector;\n    }\n\n    /// @dev called on ERC721 batch trasnfer to this contract\n    /// @param operator address of the one sending the ERC721 Token\n    /// @return onERC721BatchReceived function selector\n    function onERC721BatchReceived(\n        address operator,\n        address, /* from */\n        uint256[] calldata, /* ids */\n        bytes calldata /* data */\n    ) external view override returns (bytes4) {\n        require(transferringToL2 || rootToken.isSuperOperator(operator), \"LandTunnelV2: !BRIDGING\");\n        return this.onERC721BatchReceived.selector;\n    }\n\n    /// @dev to be called by external contact to check if this contract supports ERC721 token and batch token receive\n    /// @param interfaceId the interface to be checked if supported by the contract\n    /// 0x5e8bf644 is the interface of IERC721MandatoryTokenReceiver and 0x01ffc9a7 for the Eip 165 supports interface's interface id\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == 0x5e8bf644 || interfaceId == 0x01ffc9a7;\n    }\n\n    function batchTransferQuadToL2(\n        address to,\n        uint256[] memory sizes,\n        uint256[] memory xs,\n        uint256[] memory ys,\n        bytes memory data\n    ) public whenNotPaused() {\n        require(to != address(0), \"LandTunnelV2: can't send to zero address\");\n        require(sizes.length == xs.length && xs.length == ys.length, \"LandTunnelV2: invalid data\");\n        transferringToL2 = true;\n        rootToken.batchTransferQuad(_msgSender(), address(this), sizes, xs, ys, data);\n        transferringToL2 = false;\n        for (uint256 index = 0; index < sizes.length; index++) {\n            bytes memory message = abi.encode(to, sizes[index], xs[index], ys[index], data);\n            _sendMessageToChild(message);\n            emit Deposit(to, sizes[index], xs[index], ys[index], data);\n        }\n    }\n\n    /// @dev Change the address of the trusted forwarder for meta-TX\n    /// @param trustedForwarder The new trustedForwarder\n    function setTrustedForwarder(address trustedForwarder) external onlyOwner {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    /// @dev Pauses all token transfers across bridge\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @dev Unpauses all token transfers across bridge\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function _processMessageFromChild(bytes memory message) internal override {\n        (address to, uint256[] memory size, uint256[] memory x, uint256[] memory y, bytes memory data) =\n            abi.decode(message, (address, uint256[], uint256[], uint256[], bytes));\n        for (uint256 index = 0; index < x.length; index++) {\n            rootToken.mintAndTransferQuad(to, size[index], x[index], y[index], data);\n            emit Withdraw(to, size[index], x[index], y[index], data);\n        }\n    }\n\n    function _msgSender() internal view override(ContextUpgradeable, ERC2771Handler) returns (address sender) {\n        return ERC2771Handler._msgSender();\n    }\n\n    function _msgData() internal view override(ContextUpgradeable, ERC2771Handler) returns (bytes calldata) {\n        return ERC2771Handler._msgData();\n    }\n\n    uint256[50] private __gap;\n}"
    },
    {
      "filename": "src/solc_0.8/polygon/child/land/PolygonLandTunnelV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../../../common/fx-portal/FxBaseChildTunnelUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"../../../common/interfaces/IPolygonLandV2.sol\";\nimport \"../../../common/interfaces/IERC721MandatoryTokenReceiver.sol\";\nimport \"../../../common/BaseWithStorage/ERC2771Handler.sol\";\nimport \"./PolygonLandBaseToken.sol\";\n\ncontract PolygonLandTunnelV2 is\n    FxBaseChildTunnelUpgradeable,\n    IERC721MandatoryTokenReceiver,\n    ERC2771Handler,\n    OwnableUpgradeable,\n    PausableUpgradeable\n{\n    IPolygonLandV2 public childToken;\n    uint32 public maxGasLimitOnL1;\n    uint256 public maxAllowedQuads;\n    bool internal transferringToL1;\n\n    mapping(uint8 => uint32) public gasLimits;\n\n    event SetGasLimit(uint8 size, uint32 limit);\n    event SetMaxGasLimit(uint32 maxGasLimit);\n    event SetMaxAllowedQuads(uint256 maxQuads);\n    event Deposit(address indexed user, uint256 size, uint256 x, uint256 y, bytes data);\n    event Withdraw(address indexed user, uint256 size, uint256 x, uint256 y, bytes data);\n\n    /// @notice set the limit of estimated gas we accept when sending a batch of quads to L1\n    /// @param _maxGasLimit maximum accepted gas limit\n    function setMaxLimitOnL1(uint32 _maxGasLimit) external onlyOwner {\n        maxGasLimitOnL1 = _maxGasLimit;\n        emit SetMaxGasLimit(_maxGasLimit);\n    }\n\n    /// @notice set the limit of quads we can send in one tx to L1\n    /// @param _maxAllowedQuads maximum number of quads accepted\n    function setMaxAllowedQuads(uint256 _maxAllowedQuads) external onlyOwner {\n        require(_maxAllowedQuads > 0, \"PolygonLandTunnelV2: max allowed value cannot be zero\");\n        maxAllowedQuads = _maxAllowedQuads;\n        emit SetMaxAllowedQuads(_maxAllowedQuads);\n    }\n\n    /// @notice set the estimate of gas that the L1 transaction will use per quad size\n    /// @param  size the size of the quad\n    /// @param  limit the estimated gas that the L1 tx will use\n    function setLimit(uint8 size, uint32 limit) external onlyOwner {\n        _setLimit(size, limit);\n    }\n\n    /// @notice set the estimate of gas that the L1 transaction will use per quad size\n    /// @param  limits the estimated gas that the L1 tx will use per quad size\n    function setupLimits(uint32[5] memory limits) public onlyOwner {\n        _setLimit(1, limits[0]);\n        _setLimit(3, limits[1]);\n        _setLimit(6, limits[2]);\n        _setLimit(12, limits[3]);\n        _setLimit(24, limits[4]);\n    }\n\n    /// @notice initialize the contract\n    /// @param  _fxChild fx child tunnel contract address\n    /// @param  _trustedForwarder address of an ERC2771 meta transaction sender contract\n    /// @param _maxGasLimit maximum accepted gas limit\n    /// @param _maxAllowedQuads maximum number of quads accepted\n    /// @param  limits the estimated gas that the L1 tx will use per quad size\n    function initialize(\n        address _fxChild,\n        IPolygonLandV2 _childToken,\n        address _trustedForwarder,\n        uint32 _maxGasLimit,\n        uint256 _maxAllowedQuads,\n        uint32[5] memory limits\n    ) public initializer {\n        __Ownable_init();\n        __Pausable_init();\n        childToken = _childToken;\n        maxGasLimitOnL1 = _maxGasLimit;\n        maxAllowedQuads = _maxAllowedQuads;\n        setupLimits(limits);\n        __FxBaseChildTunnelUpgradeable_initialize(_fxChild);\n        __ERC2771Handler_initialize(_trustedForwarder);\n    }\n\n    /// @notice send a batch of quads to L1\n    /// @param  to address of the receiver on L1\n    /// @param  sizes sizes of quad\n    /// @param  xs x coordinates of quads\n    /// @param  ys y coordinates of quads\n    /// @param  data data send to the receiver onERC721BatchReceived on L1\n    function batchTransferQuadToL1(\n        address to,\n        uint256[] calldata sizes,\n        uint256[] calldata xs,\n        uint256[] calldata ys,\n        bytes memory data\n    ) external whenNotPaused() {\n        require(to != address(0), \"PolygonLandTunnelV2: can't send to zero address\");\n        require(\n            sizes.length == xs.length && sizes.length == ys.length,\n            \"PolygonLandTunnelV2: sizes, xs, ys must be same length\"\n        );\n\n        uint32 gasLimit = 0;\n        uint256 quads = 0;\n        for (uint256 i = 0; i < sizes.length; i++) {\n            gasLimit += gasLimits[uint8(sizes[i])];\n            quads += sizes[i] * sizes[i];\n        }\n\n        require(quads <= maxAllowedQuads, \"PolygonLandTunnelV2: Exceeds max allowed quads.\");\n        require(gasLimit < maxGasLimitOnL1, \"PolygonLandTunnelV2: Exceeds gas limit on L1.\");\n        transferringToL1 = true;\n        for (uint256 i = 0; i < sizes.length; i++) {\n            childToken.transferQuad(_msgSender(), address(this), sizes[i], xs[i], ys[i], data);\n            emit Withdraw(to, sizes[i], xs[i], ys[i], data);\n        }\n        _sendMessageToRoot(abi.encode(to, sizes, xs, ys, data));\n        transferringToL1 = false;\n    }\n\n    /// @dev Change the address of the trusted forwarder for meta-TX\n    /// @param trustedForwarder The new trustedForwarder\n    function setTrustedForwarder(address trustedForwarder) external onlyOwner {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    /// @dev Pauses all token transfers across bridge\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @dev Unpauses all token transfers across bridge\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /// @dev called on ERC721 trasnfer to this contract\n    /// @param operator address of the one sending the ERC721 Token\n    /// @return onERC721Received function selector\n    function onERC721Received(\n        address operator,\n        address,\n        uint256,\n        bytes calldata\n    ) external view override returns (bytes4) {\n        require(transferringToL1 || childToken.isSuperOperator(operator), \"PolygonLandTunnelV2: !BRIDGING\");\n        return this.onERC721Received.selector;\n    }\n\n    /// @dev called on ERC721 batch trasnfer to this contract\n    /// @param operator address of the one sending the ERC721 Token\n    /// @return onERC721BatchReceived function selector\n    function onERC721BatchReceived(\n        address operator,\n        address,\n        uint256[] calldata,\n        bytes calldata\n    ) external view override returns (bytes4) {\n        require(transferringToL1 || childToken.isSuperOperator(operator), \"PolygonLandTunnelV2: !BRIDGING\");\n        return this.onERC721BatchReceived.selector;\n    }\n\n    /// @dev to be called by external contact to check if this contract supports ERC721 token and batch token receive\n    /// @param interfaceId the interface to be checked if supported by the contract\n    /// 0x5e8bf644 is the interface of IERC721MandatoryTokenReceiver and 0x01ffc9a7 for the Eip 165 supports interface's interface id\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == 0x5e8bf644 || interfaceId == 0x01ffc9a7;\n    }\n\n    function _processMessageFromRoot(\n        uint256,\n        address sender,\n        bytes memory data\n    ) internal override validateSender(sender) {\n        _syncDeposit(data);\n    }\n\n    function _syncDeposit(bytes memory syncData) internal {\n        (address to, uint256 size, uint256 x, uint256 y, bytes memory data) =\n            abi.decode(syncData, (address, uint256, uint256, uint256, bytes));\n        childToken.mintAndTransferQuad(to, size, x, y, data);\n        emit Deposit(to, size, x, y, data);\n    }\n\n    function _msgSender() internal view override(ContextUpgradeable, ERC2771Handler) returns (address sender) {\n        return ERC2771Handler._msgSender();\n    }\n\n    function _msgData() internal view override(ContextUpgradeable, ERC2771Handler) returns (bytes calldata) {\n        return ERC2771Handler._msgData();\n    }\n\n    function _setLimit(uint8 size, uint32 limit) internal {\n        gasLimits[size] = limit;\n        emit SetGasLimit(size, limit);\n    }\n\n    uint256[50] private __gap;\n}"
    },
    {
      "filename": "src/solc_0.8/polygon/child/land/PolygonLandTunnelV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../../../common/fx-portal/FxBaseChildTunnelUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"../../../common/interfaces/IPolygonLandV2.sol\";\nimport \"../../../common/interfaces/IERC721MandatoryTokenReceiver.sol\";\nimport \"../../../common/BaseWithStorage/ERC2771Handler.sol\";\nimport \"./PolygonLandBaseToken.sol\";\n\ncontract PolygonLandTunnelV2 is\n    FxBaseChildTunnelUpgradeable,\n    IERC721MandatoryTokenReceiver,\n    ERC2771Handler,\n    OwnableUpgradeable,\n    PausableUpgradeable\n{\n    IPolygonLandV2 public childToken;\n    uint32 public maxGasLimitOnL1;\n    uint256 public maxAllowedQuads;\n    bool internal transferringToL1;\n\n    mapping(uint8 => uint32) public gasLimits;\n\n    event SetGasLimit(uint8 size, uint32 limit);\n    event SetMaxGasLimit(uint32 maxGasLimit);\n    event SetMaxAllowedQuads(uint256 maxQuads);\n    event Deposit(address indexed user, uint256 size, uint256 x, uint256 y, bytes data);\n    event Withdraw(address indexed user, uint256 size, uint256 x, uint256 y, bytes data);\n\n    /// @notice set the limit of estimated gas we accept when sending a batch of quads to L1\n    /// @param _maxGasLimit maximum accepted gas limit\n    function setMaxLimitOnL1(uint32 _maxGasLimit) external onlyOwner {\n        maxGasLimitOnL1 = _maxGasLimit;\n        emit SetMaxGasLimit(_maxGasLimit);\n    }\n\n    /// @notice set the limit of quads we can send in one tx to L1\n    /// @param _maxAllowedQuads maximum number of quads accepted\n    function setMaxAllowedQuads(uint256 _maxAllowedQuads) external onlyOwner {\n        require(_maxAllowedQuads > 0, \"PolygonLandTunnelV2: max allowed value cannot be zero\");\n        maxAllowedQuads = _maxAllowedQuads;\n        emit SetMaxAllowedQuads(_maxAllowedQuads);\n    }\n\n    /// @notice set the estimate of gas that the L1 transaction will use per quad size\n    /// @param  size the size of the quad\n    /// @param  limit the estimated gas that the L1 tx will use\n    function setLimit(uint8 size, uint32 limit) external onlyOwner {\n        _setLimit(size, limit);\n    }\n\n    /// @notice set the estimate of gas that the L1 transaction will use per quad size\n    /// @param  limits the estimated gas that the L1 tx will use per quad size\n    function setupLimits(uint32[5] memory limits) public onlyOwner {\n        _setLimit(1, limits[0]);\n        _setLimit(3, limits[1]);\n        _setLimit(6, limits[2]);\n        _setLimit(12, limits[3]);\n        _setLimit(24, limits[4]);\n    }\n\n    /// @notice initialize the contract\n    /// @param  _fxChild fx child tunnel contract address\n    /// @param  _trustedForwarder address of an ERC2771 meta transaction sender contract\n    /// @param _maxGasLimit maximum accepted gas limit\n    /// @param _maxAllowedQuads maximum number of quads accepted\n    /// @param  limits the estimated gas that the L1 tx will use per quad size\n    function initialize(\n        address _fxChild,\n        IPolygonLandV2 _childToken,\n        address _trustedForwarder,\n        uint32 _maxGasLimit,\n        uint256 _maxAllowedQuads,\n        uint32[5] memory limits\n    ) public initializer {\n        __Ownable_init();\n        __Pausable_init();\n        childToken = _childToken;\n        maxGasLimitOnL1 = _maxGasLimit;\n        maxAllowedQuads = _maxAllowedQuads;\n        setupLimits(limits);\n        __FxBaseChildTunnelUpgradeable_initialize(_fxChild);\n        __ERC2771Handler_initialize(_trustedForwarder);\n    }\n\n    /// @notice send a batch of quads to L1\n    /// @param  to address of the receiver on L1\n    /// @param  sizes sizes of quad\n    /// @param  xs x coordinates of quads\n    /// @param  ys y coordinates of quads\n    /// @param  data data send to the receiver onERC721BatchReceived on L1\n    function batchTransferQuadToL1(\n        address to,\n        uint256[] calldata sizes,\n        uint256[] calldata xs,\n        uint256[] calldata ys,\n        bytes memory data\n    ) external whenNotPaused() {\n        require(to != address(0), \"PolygonLandTunnelV2: can't send to zero address\");\n        require(\n            sizes.length == xs.length && sizes.length == ys.length,\n            \"PolygonLandTunnelV2: sizes, xs, ys must be same length\"\n        );\n\n        uint32 gasLimit = 0;\n        uint256 quads = 0;\n        for (uint256 i = 0; i < sizes.length; i++) {\n            gasLimit += gasLimits[uint8(sizes[i])];\n            quads += sizes[i] * sizes[i];\n        }\n\n        require(quads <= maxAllowedQuads, \"PolygonLandTunnelV2: Exceeds max allowed quads.\");\n        require(gasLimit < maxGasLimitOnL1, \"PolygonLandTunnelV2: Exceeds gas limit on L1.\");\n        transferringToL1 = true;\n        for (uint256 i = 0; i < sizes.length; i++) {\n            childToken.transferQuad(_msgSender(), address(this), sizes[i], xs[i], ys[i], data);\n            emit Withdraw(to, sizes[i], xs[i], ys[i], data);\n        }\n        _sendMessageToRoot(abi.encode(to, sizes, xs, ys, data));\n        transferringToL1 = false;\n    }\n\n    /// @dev Change the address of the trusted forwarder for meta-TX\n    /// @param trustedForwarder The new trustedForwarder\n    function setTrustedForwarder(address trustedForwarder) external onlyOwner {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    /// @dev Pauses all token transfers across bridge\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @dev Unpauses all token transfers across bridge\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /// @dev called on ERC721 trasnfer to this contract\n    /// @param operator address of the one sending the ERC721 Token\n    /// @return onERC721Received function selector\n    function onERC721Received(\n        address operator,\n        address,\n        uint256,\n        bytes calldata\n    ) external view override returns (bytes4) {\n        require(transferringToL1 || childToken.isSuperOperator(operator), \"PolygonLandTunnelV2: !BRIDGING\");\n        return this.onERC721Received.selector;\n    }\n\n    /// @dev called on ERC721 batch trasnfer to this contract\n    /// @param operator address of the one sending the ERC721 Token\n    /// @return onERC721BatchReceived function selector\n    function onERC721BatchReceived(\n        address operator,\n        address,\n        uint256[] calldata,\n        bytes calldata\n    ) external view override returns (bytes4) {\n        require(transferringToL1 || childToken.isSuperOperator(operator), \"PolygonLandTunnelV2: !BRIDGING\");\n        return this.onERC721BatchReceived.selector;\n    }\n\n    /// @dev to be called by external contact to check if this contract supports ERC721 token and batch token receive\n    /// @param interfaceId the interface to be checked if supported by the contract\n    /// 0x5e8bf644 is the interface of IERC721MandatoryTokenReceiver and 0x01ffc9a7 for the Eip 165 supports interface's interface id\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == 0x5e8bf644 || interfaceId == 0x01ffc9a7;\n    }\n\n    function _processMessageFromRoot(\n        uint256,\n        address sender,\n        bytes memory data\n    ) internal override validateSender(sender) {\n        _syncDeposit(data);\n    }\n\n    function _syncDeposit(bytes memory syncData) internal {\n        (address to, uint256 size, uint256 x, uint256 y, bytes memory data) =\n            abi.decode(syncData, (address, uint256, uint256, uint256, bytes));\n        childToken.mintAndTransferQuad(to, size, x, y, data);\n        emit Deposit(to, size, x, y, data);\n    }\n\n    function _msgSender() internal view override(ContextUpgradeable, ERC2771Handler) returns (address sender) {\n        return ERC2771Handler._msgSender();\n    }\n\n    function _msgData() internal view override(ContextUpgradeable, ERC2771Handler) returns (bytes calldata) {\n        return ERC2771Handler._msgData();\n    }\n\n    function _setLimit(uint8 size, uint32 limit) internal {\n        gasLimits[size] = limit;\n        emit SetGasLimit(size, limit);\n    }\n\n    uint256[50] private __gap;\n}"
    },
    {
      "filename": "src/solc_0.8/polygon/child/land/PolygonLandTunnelV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../../../common/fx-portal/FxBaseChildTunnelUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"../../../common/interfaces/IPolygonLandV2.sol\";\nimport \"../../../common/interfaces/IERC721MandatoryTokenReceiver.sol\";\nimport \"../../../common/BaseWithStorage/ERC2771Handler.sol\";\nimport \"./PolygonLandBaseToken.sol\";\n\ncontract PolygonLandTunnelV2 is\n    FxBaseChildTunnelUpgradeable,\n    IERC721MandatoryTokenReceiver,\n    ERC2771Handler,\n    OwnableUpgradeable,\n    PausableUpgradeable\n{\n    IPolygonLandV2 public childToken;\n    uint32 public maxGasLimitOnL1;\n    uint256 public maxAllowedQuads;\n    bool internal transferringToL1;\n\n    mapping(uint8 => uint32) public gasLimits;\n\n    event SetGasLimit(uint8 size, uint32 limit);\n    event SetMaxGasLimit(uint32 maxGasLimit);\n    event SetMaxAllowedQuads(uint256 maxQuads);\n    event Deposit(address indexed user, uint256 size, uint256 x, uint256 y, bytes data);\n    event Withdraw(address indexed user, uint256 size, uint256 x, uint256 y, bytes data);\n\n    /// @notice set the limit of estimated gas we accept when sending a batch of quads to L1\n    /// @param _maxGasLimit maximum accepted gas limit\n    function setMaxLimitOnL1(uint32 _maxGasLimit) external onlyOwner {\n        maxGasLimitOnL1 = _maxGasLimit;\n        emit SetMaxGasLimit(_maxGasLimit);\n    }\n\n    /// @notice set the limit of quads we can send in one tx to L1\n    /// @param _maxAllowedQuads maximum number of quads accepted\n    function setMaxAllowedQuads(uint256 _maxAllowedQuads) external onlyOwner {\n        require(_maxAllowedQuads > 0, \"PolygonLandTunnelV2: max allowed value cannot be zero\");\n        maxAllowedQuads = _maxAllowedQuads;\n        emit SetMaxAllowedQuads(_maxAllowedQuads);\n    }\n\n    /// @notice set the estimate of gas that the L1 transaction will use per quad size\n    /// @param  size the size of the quad\n    /// @param  limit the estimated gas that the L1 tx will use\n    function setLimit(uint8 size, uint32 limit) external onlyOwner {\n        _setLimit(size, limit);\n    }\n\n    /// @notice set the estimate of gas that the L1 transaction will use per quad size\n    /// @param  limits the estimated gas that the L1 tx will use per quad size\n    function setupLimits(uint32[5] memory limits) public onlyOwner {\n        _setLimit(1, limits[0]);\n        _setLimit(3, limits[1]);\n        _setLimit(6, limits[2]);\n        _setLimit(12, limits[3]);\n        _setLimit(24, limits[4]);\n    }\n\n    /// @notice initialize the contract\n    /// @param  _fxChild fx child tunnel contract address\n    /// @param  _trustedForwarder address of an ERC2771 meta transaction sender contract\n    /// @param _maxGasLimit maximum accepted gas limit\n    /// @param _maxAllowedQuads maximum number of quads accepted\n    /// @param  limits the estimated gas that the L1 tx will use per quad size\n    function initialize(\n        address _fxChild,\n        IPolygonLandV2 _childToken,\n        address _trustedForwarder,\n        uint32 _maxGasLimit,\n        uint256 _maxAllowedQuads,\n        uint32[5] memory limits\n    ) public initializer {\n        __Ownable_init();\n        __Pausable_init();\n        childToken = _childToken;\n        maxGasLimitOnL1 = _maxGasLimit;\n        maxAllowedQuads = _maxAllowedQuads;\n        setupLimits(limits);\n        __FxBaseChildTunnelUpgradeable_initialize(_fxChild);\n        __ERC2771Handler_initialize(_trustedForwarder);\n    }\n\n    /// @notice send a batch of quads to L1\n    /// @param  to address of the receiver on L1\n    /// @param  sizes sizes of quad\n    /// @param  xs x coordinates of quads\n    /// @param  ys y coordinates of quads\n    /// @param  data data send to the receiver onERC721BatchReceived on L1\n    function batchTransferQuadToL1(\n        address to,\n        uint256[] calldata sizes,\n        uint256[] calldata xs,\n        uint256[] calldata ys,\n        bytes memory data\n    ) external whenNotPaused() {\n        require(to != address(0), \"PolygonLandTunnelV2: can't send to zero address\");\n        require(\n            sizes.length == xs.length && sizes.length == ys.length,\n            \"PolygonLandTunnelV2: sizes, xs, ys must be same length\"\n        );\n\n        uint32 gasLimit = 0;\n        uint256 quads = 0;\n        for (uint256 i = 0; i < sizes.length; i++) {\n            gasLimit += gasLimits[uint8(sizes[i])];\n            quads += sizes[i] * sizes[i];\n        }\n\n        require(quads <= maxAllowedQuads, \"PolygonLandTunnelV2: Exceeds max allowed quads.\");\n        require(gasLimit < maxGasLimitOnL1, \"PolygonLandTunnelV2: Exceeds gas limit on L1.\");\n        transferringToL1 = true;\n        for (uint256 i = 0; i < sizes.length; i++) {\n            childToken.transferQuad(_msgSender(), address(this), sizes[i], xs[i], ys[i], data);\n            emit Withdraw(to, sizes[i], xs[i], ys[i], data);\n        }\n        _sendMessageToRoot(abi.encode(to, sizes, xs, ys, data));\n        transferringToL1 = false;\n    }\n\n    /// @dev Change the address of the trusted forwarder for meta-TX\n    /// @param trustedForwarder The new trustedForwarder\n    function setTrustedForwarder(address trustedForwarder) external onlyOwner {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    /// @dev Pauses all token transfers across bridge\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @dev Unpauses all token transfers across bridge\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /// @dev called on ERC721 trasnfer to this contract\n    /// @param operator address of the one sending the ERC721 Token\n    /// @return onERC721Received function selector\n    function onERC721Received(\n        address operator,\n        address,\n        uint256,\n        bytes calldata\n    ) external view override returns (bytes4) {\n        require(transferringToL1 || childToken.isSuperOperator(operator), \"PolygonLandTunnelV2: !BRIDGING\");\n        return this.onERC721Received.selector;\n    }\n\n    /// @dev called on ERC721 batch trasnfer to this contract\n    /// @param operator address of the one sending the ERC721 Token\n    /// @return onERC721BatchReceived function selector\n    function onERC721BatchReceived(\n        address operator,\n        address,\n        uint256[] calldata,\n        bytes calldata\n    ) external view override returns (bytes4) {\n        require(transferringToL1 || childToken.isSuperOperator(operator), \"PolygonLandTunnelV2: !BRIDGING\");\n        return this.onERC721BatchReceived.selector;\n    }\n\n    /// @dev to be called by external contact to check if this contract supports ERC721 token and batch token receive\n    /// @param interfaceId the interface to be checked if supported by the contract\n    /// 0x5e8bf644 is the interface of IERC721MandatoryTokenReceiver and 0x01ffc9a7 for the Eip 165 supports interface's interface id\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == 0x5e8bf644 || interfaceId == 0x01ffc9a7;\n    }\n\n    function _processMessageFromRoot(\n        uint256,\n        address sender,\n        bytes memory data\n    ) internal override validateSender(sender) {\n        _syncDeposit(data);\n    }\n\n    function _syncDeposit(bytes memory syncData) internal {\n        (address to, uint256 size, uint256 x, uint256 y, bytes memory data) =\n            abi.decode(syncData, (address, uint256, uint256, uint256, bytes));\n        childToken.mintAndTransferQuad(to, size, x, y, data);\n        emit Deposit(to, size, x, y, data);\n    }\n\n    function _msgSender() internal view override(ContextUpgradeable, ERC2771Handler) returns (address sender) {\n        return ERC2771Handler._msgSender();\n    }\n\n    function _msgData() internal view override(ContextUpgradeable, ERC2771Handler) returns (bytes calldata) {\n        return ERC2771Handler._msgData();\n    }\n\n    function _setLimit(uint8 size, uint32 limit) internal {\n        gasLimits[size] = limit;\n        emit SetGasLimit(size, limit);\n    }\n\n    uint256[50] private __gap;\n}"
    }
  ]
}