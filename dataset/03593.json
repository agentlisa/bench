{
  "Title": "[L05] Inconsistent upper bounds on optionAllocationPct",
  "Content": "The `optionAllocationPct` state variable in [`RibbonDeltaVault`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol) is required to be [less than 100%](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol#L121) upon initialization. However, the [`setOptionAllocation`](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol#L172) function requires the `optionAllocationPct` variable to be [less than 10%](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol#L172).\n\n\n[Misleading comments about the number of decimals](https://github.com/ribbon-finance/ribbon-v2/blob/3fa3bec15ad1e2b18ad87f979b87a68368497f13/contracts/vaults/RibbonDeltaVault.sol#L169) this variable should use makes the inconsistent `require` statements even more confusing.\n\n\nConsider clarifying the documentation around this value and either using a consistent range for associated require statements or adding additional inline comments explaining the intentionality of the different upper bounds.\n\n\n**Update**: *Fixed in [commit `1bcdedeb197d0c270e1a7888ef4ad7729468fe2d` of PR#94](https://github.com/ribbon-finance/ribbon-v2/pull/94/commits/1bcdedeb197d0c270e1a7888ef4ad7729468fe2d).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/RibbonDeltaVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {DSMath} from \"../vendor/DSMath.sol\";\nimport {GnosisAuction} from \"../libraries/GnosisAuction.sol\";\nimport {OptionsDeltaVaultStorage} from \"../storage/OptionsVaultStorage.sol\";\nimport {Vault} from \"../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../libraries/ShareMath.sol\";\nimport {RibbonVault} from \"./base/RibbonVault.sol\";\nimport {IRibbonThetaVault} from \"../interfaces/IRibbonThetaVault.sol\";\nimport {IGnosisAuction} from \"../interfaces/IGnosisAuction.sol\";\n\ncontract RibbonDeltaVault is RibbonVault, DSMath, OptionsDeltaVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event OpenLong(\n        address indexed options,\n        uint256 purchaseAmount,\n        uint256 premium,\n        address manager\n    );\n\n    event CloseLong(\n        address indexed options,\n        uint256 profitAmount,\n        address manager\n    );\n\n    event NewOptionAllocationSet(\n        uint256 optionAllocationPct,\n        uint256 newOptionAllocationPct\n    );\n\n    event InstantWithdraw(address indexed account, uint256 share, uint16 round);\n\n    event PlaceAuctionBid(\n        uint256 auctionId,\n        address auctioningToken,\n        uint256 sellAmount,\n        uint256 buyAmount,\n        address bidder\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction\n    )\n        RibbonVault(\n            _weth,\n            _usdc,\n            _gammaController,\n            _marginPool,\n            _gnosisEasyAuction\n        )\n    {}\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function initialize(\n        address _owner,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory tokenName,\n        string memory tokenSymbol,\n        address _counterpartyThetaVault,\n        uint256 _optionAllocationPct,\n        Vault.VaultParams calldata _vaultParams\n    ) external initializer {\n        baseInitialize(\n            _owner,\n            _feeRecipient,\n            _managementFee,\n            _performanceFee,\n            tokenName,\n            tokenSymbol,\n            _vaultParams\n        );\n        require(\n            _counterpartyThetaVault != address(0),\n            \"!_counterpartyThetaVault\"\n        );\n        require(\n            IRibbonThetaVault(_counterpartyThetaVault).vaultParams().asset ==\n                vaultParams.asset,\n            \"!_counterpartyThetaVault: asset\"\n        );\n        require(\n            _optionAllocationPct > 0 && _optionAllocationPct < 10000,\n            \"!_optionAllocationPct\"\n        );\n        counterpartyThetaVault = IRibbonThetaVault(_counterpartyThetaVault);\n        optionAllocationPct = _optionAllocationPct;\n    }\n\n    /**\n     * @notice Updates the price per share of the current round. The current round\n     * pps will change right after call rollToNextOption as the gnosis auction contract\n     * takes custody of a % of `asset` tokens, and right after we claim the tokens from\n     * the action as we may recieve some of `asset` tokens back alongside the oToken,\n     * depending on the gnosis auction outcome. Finally it will change at the end of the week\n     * if the oTokens are ITM\n     */\n    modifier updatePPS(bool isWithdraw) {\n        if (!isWithdraw) {\n            _;\n        }\n\n        if (\n            !isWithdraw ||\n            roundPricePerShare[vaultState.round] <= PLACEHOLDER_UINT\n        ) {\n            uint256 pendingAmount = uint256(vaultState.totalPending);\n            uint256 currentBalance =\n                IERC20(vaultParams.asset).balanceOf(address(this));\n            uint256 roundStartBalance = currentBalance.sub(pendingAmount);\n\n            uint256 singleShare = 10**uint256(vaultParams.decimals);\n            roundPricePerShare[vaultState.round] = VaultLifecycle.getPPS(\n                totalSupply(),\n                roundStartBalance,\n                singleShare,\n                vaultParams.initialSharePrice\n            );\n        }\n\n        if (isWithdraw) {\n            _;\n        }\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new % allocation of funds towards options purchases ( 3 decimals. ex: 55 * 10 ** 2 is 55%)\n     * @param newOptionAllocationPct is the option % allocation\n     */\n    function setOptionAllocation(uint16 newOptionAllocationPct)\n        external\n        onlyOwner\n    {\n        // Needs to be less than 10%\n        require(\n            newOptionAllocationPct > 0 && newOptionAllocationPct < 1000,\n            \"Invalid allocation\"\n        );\n\n        emit NewOptionAllocationSet(\n            optionAllocationPct,\n            newOptionAllocationPct\n        );\n\n        optionAllocationPct = newOptionAllocationPct;\n    }\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `DepositReceipt.amount`\n     * @param share is the amount of shares to withdraw\n     */\n    function withdrawInstantly(uint256 share)\n        external\n        updatePPS(true)\n        nonReentrant\n    {\n        require(share > 0, \"!shares\");\n\n        uint256 sharesLeftForWithdrawal = _withdrawFromNewDeposit(share);\n\n        uint16 currentRound = vaultState.round;\n\n        // If we need to withdraw beyond current round deposit\n        if (sharesLeftForWithdrawal > 0) {\n            (uint256 heldByAccount, uint256 heldByVault) =\n                shareBalances(msg.sender);\n\n            require(\n                sharesLeftForWithdrawal <= heldByAccount.add(heldByVault),\n                \"Insufficient balance\"\n            );\n\n            if (heldByAccount < sharesLeftForWithdrawal) {\n                // Redeem all shares custodied by vault to user\n                _redeem(0, true);\n            }\n\n            // Burn shares\n            _burn(msg.sender, sharesLeftForWithdrawal);\n        }\n\n        emit InstantWithdraw(msg.sender, share, currentRound);\n\n        uint256 sharesToUnderlying =\n            ShareMath.sharesToUnderlying(\n                share,\n                roundPricePerShare[vaultState.round],\n                vaultParams.decimals\n            );\n        transferAsset(msg.sender, sharesToUnderlying);\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice Closes the existing long position for the vault.\n     *         This allows all the users to withdraw if the next option is malicious.\n     */\n    function commitAndClose() external onlyOwner updatePPS(true) nonReentrant {\n        address oldOption = optionState.currentOption;\n\n        address counterpartyNextOption =\n            counterpartyThetaVault.optionState().nextOption;\n        require(counterpartyNextOption != address(0), \"!thetavaultclosed\");\n        optionState.nextOption = counterpartyNextOption;\n        optionState.nextOptionReadyAt = uint32(block.timestamp.add(delay));\n\n        optionState.currentOption = address(0);\n        vaultState.lastLockedAmount = balanceBeforePremium;\n\n        // redeem\n        if (oldOption != address(0)) {\n            uint256 profitAmount =\n                VaultLifecycle.settleLong(\n                    GAMMA_CONTROLLER,\n                    oldOption,\n                    vaultParams.asset\n                );\n            emit CloseLong(oldOption, profitAmount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Rolls the vault's funds into a new long position.\n     * @param optionPremium is the premium per token to pay in `asset`.\n       Same decimals as `asset` (ex: 1 * 10 ** 8 means 1 WBTC per oToken)\n     */\n    function rollToNextOption(uint256 optionPremium)\n        external\n        onlyOwner\n        updatePPS(false)\n        nonReentrant\n    {\n        (address newOption, uint256 lockedBalance) = _rollToNextOption();\n\n        balanceBeforePremium = uint104(lockedBalance);\n\n        GnosisAuction.BidDetails memory bidDetails;\n\n        bidDetails.auctionId = counterpartyThetaVault.optionAuctionID();\n        bidDetails.gnosisEasyAuction = GNOSIS_EASY_AUCTION;\n        bidDetails.oTokenAddress = newOption;\n        bidDetails.asset = vaultParams.asset;\n        bidDetails.assetDecimals = vaultParams.decimals;\n        bidDetails.lockedBalance = lockedBalance;\n        bidDetails.optionAllocationPct = optionAllocationPct;\n        bidDetails.optionPremium = optionPremium;\n        bidDetails.bidder = msg.sender;\n\n        // place bid\n        (uint256 sellAmount, uint256 buyAmount, uint64 userId) =\n            VaultLifecycle.placeBid(bidDetails);\n\n        auctionSellOrder.sellAmount = uint96(sellAmount);\n        auctionSellOrder.buyAmount = uint96(buyAmount);\n        auctionSellOrder.userId = userId;\n\n        emit OpenLong(newOption, buyAmount, sellAmount, msg.sender);\n    }\n\n    /**\n     * @notice Claims the delta vault's oTokens from latest auction\n     */\n    function claimAuctionOtokens() external updatePPS(false) nonReentrant {\n        VaultLifecycle.claimAuctionOtokens(\n            auctionSellOrder,\n            GNOSIS_EASY_AUCTION,\n            address(counterpartyThetaVault)\n        );\n    }\n\n    /**\n     * @notice Withdraws from the most recent deposit which has not been processed\n     * @param share is how many shares to withdraw in total\n     * @return the shares left to withdraw\n     */\n    function _withdrawFromNewDeposit(uint256 share) private returns (uint256) {\n        Vault.DepositReceipt storage depositReceipt =\n            depositReceipts[msg.sender];\n\n        // Immediately get what is in the pending deposits, without need for checking pps\n        if (\n            depositReceipt.round == vaultState.round &&\n            depositReceipt.amount > 0\n        ) {\n            uint256 receiptShares =\n                ShareMath.underlyingToShares(\n                    depositReceipt.amount,\n                    roundPricePerShare[depositReceipt.round],\n                    vaultParams.decimals\n                );\n            uint256 sharesWithdrawn = min(receiptShares, share);\n            // Subtraction underflow checks already ensure it is smaller than uint104\n            depositReceipt.amount = uint104(\n                ShareMath.sharesToUnderlying(\n                    uint256(receiptShares).sub(sharesWithdrawn),\n                    roundPricePerShare[depositReceipt.round],\n                    vaultParams.decimals\n                )\n            );\n            return share.sub(sharesWithdrawn);\n        }\n\n        return share;\n    }\n}"
    }
  ]
}