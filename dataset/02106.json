{
  "Title": "M-21: Trades in blocks where the bid or ask drops to zero will be priced using the previous block's price",
  "Content": "# Issue M-21: Trades in blocks where the bid or ask drops to zero will be priced using the previous block's price \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/155 \n\n## Found by \nIllIllI\n\n## Summary\n\nThe oracle prices used for traces allow multiple oracles and their last prices to be provided. The oldest block's price becomes the primary price, and the newer price becomes the secondary price. Trades in blocks where the primary price is non-zero, but the secondary price is zero, will be priced incorrectly\n\n\n## Vulnerability Detail\n\nFor position [increase](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/position/IncreasePositionUtils.sol#L61)/[decrease](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/position/DecreasePositionUtils.sol#L73) orders, the price used is either the primary or the secondary price, but a value of zero for the secondary price is considered to be a sentinel value indicating ['empty'](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/price/Price.sol#L18-L20\n), or 'no price has been set'. In such cases, the secondary price is ignored, and the primary price is used instead.\n\n\n## Impact\n\nUsers exiting their positions in the first block where the price touches zero, are able to exit their positions at the primary (older) price rather than the secondary (newer) price of zero. This is pricing difference is at the expense of the pool and the other side of the trade.\n\n\n## Code Snippet\n\nThe secondary price is only used when it's [non-zero](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/price/Price.sol#L18-L20):\n```solidity\n// File: gmx-synthetics/contracts/oracle/Oracle.sol : Oracle.getLatestPrice()   #1\n\n341        function getLatestPrice(address token) external view returns (Price.Props memory) {\n342            if (token == address(0)) { return Price.Props(0, 0); }\n343    \n344            Price.Props memory secondaryPrice = secondaryPrices[token];\n345    \n346 @>         if (!secondaryPrice.isEmpty()) {\n347                return secondaryPrice;\n348            }\n349    \n350            Price.Props memory primaryPrice = primaryPrices[token];\n351            if (!primaryPrice.isEmpty()) {\n352                return primaryPrice;\n353            }\n354    \n355            revert OracleUtils.EmptyLatestPrice(token);\n356:       }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/oracle/Oracle.sol#L341-L356\n\nNote that even if just the bid touches zero, that's enough to disqualify the secondary price.\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nUse an actual sentinel flag rather than overloading the meaning of a 'zero' price.\n\n\n\n\n## Discussion\n\n**xvi10**\n\noracles should report the minimum possible price instead of zero\n\n**IllIllI000**\n\n@xvi10 same question as for #156\n\n**xvi10**\n\nreplied in [156](https://github.com/sherlock-audit/2023-02-gmx-judging/issues/156)\n\n**IllIllI000**\n\nthe readme states that `Oracle signers are expected to accurately report the price of tokens`, so any misreporting would be a separate bug, and reporting a price of 100 seems much more dangerous than an unidentified bug. As is described above, using a sentinel value would be safer\n\n**xvi10**\n\nreplied in https://github.com/sherlock-audit/2023-02-gmx-judging/issues/156\n\n**hack3r-0m**\n\nEscalate for 10 USDC\n\nshould be dup of https://github.com/sherlock-audit/2023-02-gmx-judging/issues/156 instead of seperate issue\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> should be dup of https://github.com/sherlock-audit/2023-02-gmx-judging/issues/156 instead of seperate issue\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IllIllI000**\n\nlooks like I missed this one. The fix for this one does not resolve the other. One is about using the wrong price, and the other is about an unhandled revert case\n\n**hrishibhat**\n\nEscalation rejected\n\nAlthough related to the similar topic but Not a duplicate of #156 \n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Although related to the similar topic but Not a duplicate of #156 \n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n**xvi10**\n\nno code changed, similar reason to https://github.com/sherlock-audit/2023-02-gmx-judging/issues/156\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/position/IncreasePositionUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Precision.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../pricing/PositionPricingUtils.sol\";\n\nimport \"./Position.sol\";\nimport \"./PositionStoreUtils.sol\";\nimport \"./PositionUtils.sol\";\nimport \"./PositionEventUtils.sol\";\nimport \"../order/BaseOrderUtils.sol\";\n\n// @title IncreasePositionUtils\n// @dev Library for functions to help with increasing a position\nlibrary IncreasePositionUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    // @dev IncreasePositionCache struct used in increasePosition to\n    // avoid stack too deep errors\n    // @param collateralDeltaAmount the change in collateral amount\n    // @param executionPrice the execution price\n    // @param priceImpactAmount the price impact of the position increase in tokens\n    // @param sizeDeltaInTokens the change in position size in tokens\n    // @param nextPositionSizeInUsd the new position size in USD\n    // @param nextPositionBorrowingFactor the new position borrowing factor\n    struct IncreasePositionCache {\n        int256 collateralDeltaAmount;\n        uint256 executionPrice;\n        int256 priceImpactAmount;\n        uint256 sizeDeltaInTokens;\n        uint256 nextPositionSizeInUsd;\n        uint256 nextPositionBorrowingFactor;\n    }\n\n    error InsufficientCollateralAmount();\n    error InsufficientCollateralForOpenInterestLeverage(int256 remainingCollateralUsd);\n\n    // @dev increase a position\n    // The increasePosition function is used to increase the size of a position\n    // in a market. This involves updating the position's collateral amount,\n    // calculating the price impact of the size increase, and updating the position's\n    // size and borrowing factor. This function also applies fees to the position\n    // and updates the market's liquidity pool based on the new position size.\n    // @param params PositionUtils.UpdatePositionParams\n    function increasePosition(\n        PositionUtils.UpdatePositionParams memory params,\n        uint256 collateralIncrementAmount\n    ) external {\n        // get the market prices for the given position\n        MarketUtils.MarketPrices memory prices = MarketUtils.getMarketPricesForPosition(\n            params.contracts.oracle,\n            params.market\n        );\n\n        PositionUtils.updateFundingAndBorrowingState(params, prices);\n\n        // create a new cache for holding intermediate results\n        IncreasePositionCache memory cache;\n\n        if (params.position.sizeInUsd() == 0) {\n            params.position.setLongTokenFundingAmountPerSize(\n                MarketUtils.getFundingAmountPerSize(params.contracts.dataStore, params.market.marketToken, params.market.longToken, params.position.isLong())\n            );\n            params.position.setShortTokenFundingAmountPerSize(\n                MarketUtils.getFundingAmountPerSize(params.contracts.dataStore, params.market.marketToken, params.market.shortToken, params.position.isLong())\n            );\n        }\n\n        // process the collateral for the given position and order\n        PositionPricingUtils.PositionFees memory fees;\n        (cache.collateralDeltaAmount, fees) = processCollateral(\n            params,\n            prices,\n            collateralIncrementAmount.toInt256()\n        );\n\n        // check if there is sufficient collateral for the position\n        if (\n            cache.collateralDeltaAmount < 0 &&\n            params.position.collateralAmount() < SafeCast.toUint256(-cache.collateralDeltaAmount)\n        ) {\n            revert InsufficientCollateralAmount();\n        }\n        params.position.setCollateralAmount(Calc.sumReturnUint256(params.position.collateralAmount(), cache.collateralDeltaAmount));\n\n        (cache.executionPrice, cache.priceImpactAmount) = getExecutionPrice(params, prices);\n\n        // if there is a positive impact, the impact pool amount should be reduced\n        // if there is a negative impact, the impact pool amount should be increased\n        MarketUtils.applyDeltaToPositionImpactPool(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            -cache.priceImpactAmount\n        );\n\n        if (params.position.isLong()) {\n            // round the number of tokens for long positions down\n            cache.sizeDeltaInTokens = params.order.sizeDeltaUsd() / cache.executionPrice;\n        } else {\n            // round the number of tokens for short positions up\n            cache.sizeDeltaInTokens = Calc.roundUpDivision(params.order.sizeDeltaUsd(), cache.executionPrice);\n        }\n\n        cache.nextPositionSizeInUsd = params.position.sizeInUsd() + params.order.sizeDeltaUsd();\n        cache.nextPositionBorrowingFactor = MarketUtils.getCumulativeBorrowingFactor(\n            params.contracts.dataStore,\n            params.market.marketToken,\n            params.position.isLong()\n        );\n\n        PositionUtils.updateTotalBorrowing(\n            params,\n            cache.nextPositionSizeInUsd,\n            cache.nextPositionBorrowingFactor\n        );\n\n        params.position.setSizeInUsd(cache.nextPositionSizeInUsd);\n        params.position.setSizeInTokens(params.position.sizeInTokens() + cache.sizeDeltaInTokens);\n        if (!fees.funding.hasPendingLongTokenFundingFee) {\n            params.position.setLongTokenFundingAmountPerSize(fees.funding.latestLongTokenFundingAmountPerSize);\n        }\n        if (!fees.funding.hasPendingShortTokenFundingFee) {\n            params.position.setShortTokenFundingAmountPerSize(fees.funding.latestShortTokenFundingAmountPerSize);\n        }\n\n        PositionUtils.incrementClaimableFundingAmount(params, fees);\n\n        params.position.setBorrowingFactor(cache.nextPositionBorrowingFactor);\n        params.position.setIncreasedAtBlock(Chain.currentBlockNumber());\n\n        PositionStoreUtils.set(params.contracts.dataStore, params.positionKey, params.position);\n\n        PositionUtils.updateOpenInterest(\n            params,\n            params.order.sizeDeltaUsd().toInt256(),\n            cache.sizeDeltaInTokens.toInt256()\n        );\n\n        if (params.order.sizeDeltaUsd() > 0) {\n            MarketUtils.validateOpenInterest(\n                params.contracts.dataStore,\n                params.market.marketToken,\n                params.market.longToken,\n                params.market.shortToken,\n                params.order.isLong()\n            );\n        }\n\n        MarketUtils.validateReserve(\n            params.contracts.dataStore,\n            params.market,\n            prices,\n            params.order.isLong()\n        );\n\n        PositionUtils.validatePosition(\n            params.contracts.dataStore,\n            params.contracts.referralStorage,\n            params.position,\n            params.market,\n            prices,\n            true\n        );\n\n        if (params.order.sizeDeltaUsd() > 0) {\n            (int256 positionPnlUsd, /* uint256 sizeDeltaInTokens */) = PositionUtils.getPositionPnlUsd(\n                params.contracts.dataStore,\n                params.market,\n                prices,\n                params.position,\n                cache.executionPrice,\n                params.position.sizeInUsd()\n            );\n\n            PositionUtils.WillPositionCollateralBeSufficientValues memory positionValues = PositionUtils.WillPositionCollateralBeSufficientValues(\n                params.position.sizeInUsd(), // positionSizeInUsd\n                params.position.collateralAmount(), // positionCollateralAmount\n                positionPnlUsd, // positionPnlUsd\n                0,  // realizedPnlUsd\n                0 // openInterestDelta\n            );\n\n            (bool willBeSufficient, int256 remainingCollateralUsd) = PositionUtils.willPositionCollateralBeSufficient(\n                params.contracts.dataStore,\n                params.market,\n                prices,\n                params.position.collateralToken(),\n                params.position.isLong(),\n                positionValues\n            );\n\n            if (!willBeSufficient) {\n                revert InsufficientCollateralForOpenInterestLeverage(remainingCollateralUsd);\n            }\n        }\n\n        PositionUtils.handleReferral(params, fees);\n\n        PositionPricingUtils.emitPositionFeesCollected(\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            params.position.collateralToken(),\n            true,\n            fees\n        );\n\n        PositionEventUtils.emitPositionIncrease(\n            params.contracts.eventEmitter,\n            params.positionKey,\n            params.position,\n            cache.executionPrice,\n            params.order.sizeDeltaUsd(),\n            cache.sizeDeltaInTokens,\n            cache.collateralDeltaAmount,\n            cache.priceImpactAmount,\n            params.order.orderType()\n        );\n    }\n\n    // @dev handle the collateral changes of the position\n    // @param params PositionUtils.UpdatePositionParams\n    // @param prices the prices of the tokens in the market\n    // @param position the position to process collateral for\n    // @param collateralDeltaAmount the change in the position's collateral\n    function processCollateral(\n        PositionUtils.UpdatePositionParams memory params,\n        MarketUtils.MarketPrices memory prices,\n        int256 collateralDeltaAmount\n    ) internal returns (int256, PositionPricingUtils.PositionFees memory) {\n        Price.Props memory collateralTokenPrice = MarketUtils.getCachedTokenPrice(\n            params.position.collateralToken(),\n            params.market,\n            prices\n        );\n\n        PositionPricingUtils.PositionFees memory fees = PositionPricingUtils.getPositionFees(\n            params.contracts.dataStore,\n            params.contracts.referralStorage,\n            params.position,\n            collateralTokenPrice,\n            params.market.longToken,\n            params.market.shortToken,\n            params.order.sizeDeltaUsd()\n        );\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            params.position.collateralToken(),\n            fees.feeReceiverAmount,\n            Keys.POSITION_FEE\n        );\n\n        collateralDeltaAmount -= fees.totalNetCostAmount.toInt256();\n\n        MarketUtils.applyDeltaToCollateralSum(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.order.market(),\n            params.position.collateralToken(),\n            params.order.isLong(),\n            collateralDeltaAmount\n        );\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.contracts.dataStore,\n            params.contracts.eventEmitter,\n            params.market.marketToken,\n            params.position.collateralToken(),\n            fees.feeAmountForPool.toInt256()\n        );\n\n        return (collateralDeltaAmount, fees);\n    }\n\n    function getExecutionPrice(\n        PositionUtils.UpdatePositionParams memory params,\n        MarketUtils.MarketPrices memory prices\n    ) internal view returns (uint256, int256) {\n        int256 priceImpactUsd = PositionPricingUtils.getPriceImpactUsd(\n            PositionPricingUtils.GetPriceImpactUsdParams(\n                params.contracts.dataStore,\n                params.market.marketToken,\n                params.market.indexToken,\n                params.market.longToken,\n                params.market.shortToken,\n                params.order.sizeDeltaUsd().toInt256(),\n                params.order.isLong()\n            )\n        );\n\n        // cap price impact usd based on the amount available in the position impact pool\n        priceImpactUsd = MarketUtils.getCappedPositionImpactUsd(\n            params.contracts.dataStore,\n            params.market.marketToken,\n            prices.indexTokenPrice,\n            priceImpactUsd,\n            params.order.sizeDeltaUsd()\n        );\n\n        uint256 executionPrice = BaseOrderUtils.getExecutionPrice(\n            params.contracts.oracle.getCustomPrice(params.market.indexToken),\n            params.order.sizeDeltaUsd(),\n            priceImpactUsd,\n            params.order.acceptablePrice(),\n            params.order.isLong(),\n            true\n        );\n\n        int256 priceImpactAmount = PositionPricingUtils.getPriceImpactAmount(\n            params.order.sizeDeltaUsd(),\n            executionPrice,\n            prices.indexTokenPrice,\n            params.order.isLong(),\n            true\n        );\n\n        return (executionPrice, priceImpactAmount);\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/price/Price.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n// @title Price\n// @dev Struct for prices\nlibrary Price {\n    // @param min the min price\n    // @param max the max price\n    struct Props {\n        uint256 min;\n        uint256 max;\n    }\n\n    // @dev check if a price is empty\n    // @param props Props\n    // @return whether a price is empty\n    function isEmpty(Props memory props) internal pure returns (bool) {\n        return props.min == 0 || props.max == 0;\n    }\n\n    // @dev get the average of the min and max values\n    // @param props Props\n    // @return the average of the min and max values\n    function midPrice(Props memory props) internal pure returns (uint256) {\n        return (props.max + props.min) / 2;\n    }\n\n    // @dev pick either the min or max value\n    // @param props Props\n    // @param maximize whether to pick the min or max value\n    // @return either the min or max value\n    function pickPrice(Props memory props, bool maximize) internal pure returns (uint256) {\n        return maximize ? props.max : props.min;\n    }\n\n    // @dev pick the min or max price depending on whether it is for a long or short position\n    // and whether the pending pnl should be maximized or not\n    // @param props Props\n    // @param isLong whether it is for a long or short position\n    // @param maximize whether the pnl should be maximized or not\n    // @return the min or max price\n    function pickPriceForPnl(Props memory props, bool isLong, bool maximize) internal pure returns (uint256) {\n        // for long positions, pick the larger price to maximize pnl\n        // for short positions, pick the smaller price to maximize pnl\n        if (isLong) {\n            return maximize ? props.max : props.min;\n        }\n\n        return maximize ? props.min : props.max;\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/oracle/Oracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../role/RoleModule.sol\";\n\nimport \"./OracleStore.sol\";\nimport \"./OracleUtils.sol\";\nimport \"./IPriceFeed.sol\";\nimport \"../price/Price.sol\";\n\nimport \"../chain/Chain.sol\";\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../event/EventUtils.sol\";\n\nimport \"../utils/Bits.sol\";\nimport \"../utils/Array.sol\";\nimport \"../utils/Precision.sol\";\nimport \"../utils/Cast.sol\";\n\n// @title Oracle\n// @dev Contract to validate and store signed values\ncontract Oracle is RoleModule {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableValues for EnumerableSet.AddressSet;\n    using Price for Price.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    // @dev SetPricesCache struct used in setPrices to avoid stack too deep errors\n    // @param prevMinOracleBlockNumber the previous oracle block number of the loop\n    // @param priceIndex the current price index to retrieve from compactedMinPrices and compactedMaxPrices\n    // to construct the minPrices and maxPrices array\n    // @param signatureIndex the current signature index to retrieve from the signatures array\n    // @param maxPriceAge the max allowed age of price values\n    // @param minPriceIndex the index of the min price in minPrices for the current signer\n    // @param maxPriceIndex the index of the max price in maxPrices for the current signer\n    // @param minPrices the min prices\n    // @param maxPrices the max prices\n    struct SetPricesCache {\n        OracleUtils.ReportInfo info;\n        uint256 minBlockConfirmations;\n        uint256 maxPriceAge;\n        uint256 prevMinOracleBlockNumber;\n        uint256 priceIndex;\n        uint256 signatureIndex;\n        uint256 minPriceIndex;\n        uint256 maxPriceIndex;\n        uint256[] minPrices;\n        uint256[] maxPrices;\n    }\n\n    bytes32 public immutable SALT;\n\n    uint256 public constant SIGNER_INDEX_LENGTH = 16;\n    // subtract 1 as the first slot is used to store number of signers\n    uint256 public constant MAX_SIGNERS = 256 / SIGNER_INDEX_LENGTH - 1;\n    // signer indexes are recorded in a signerIndexFlags uint256 value to check for uniqueness\n    uint256 public constant MAX_SIGNER_INDEX = 256;\n\n    OracleStore public oracleStore;\n\n    // tokensWithPrices stores the tokens with prices that have been set\n    // this is used in clearAllPrices to help ensure that all token prices\n    // set in setPrices are cleared after use\n    EnumerableSet.AddressSet internal tokensWithPrices;\n    // prices for the same token can be sent multiple times in one txn\n    // the prices can be for different block numbers\n    // the first occurrence of the token's price will be stored in primaryPrices\n    // the second occurrence will be stored in secondaryPrices\n    mapping(address => Price.Props) public primaryPrices;\n    mapping(address => Price.Props) public secondaryPrices;\n    // customPrices can be used to store custom price values\n    // these prices will be cleared in clearAllPrices\n    mapping(address => Price.Props) public customPrices;\n\n    error EmptyTokens();\n    error InvalidBlockNumber(uint256 blockNumber);\n    error InvalidMinMaxBlockNumber(uint256 minOracleBlockNumber, uint256 maxOracleBlockNumber);\n    error MaxPriceAgeExceeded(uint256 oracleTimestamp);\n    error MinOracleSigners(uint256 oracleSigners, uint256 minOracleSigners);\n    error MaxOracleSigners(uint256 oracleSigners, uint256 maxOracleSigners);\n    error BlockNumbersNotSorted(uint256 minOracleBlockNumber, uint256 prevMinOracleBlockNumber);\n    error MinPricesNotSorted(address token, uint256 price, uint256 prevPrice);\n    error MaxPricesNotSorted(address token, uint256 price, uint256 prevPrice);\n    error EmptyPriceFeedMultiplier(address token);\n    error EmptyFeedPrice(address token);\n    error MaxSignerIndex(uint256 signerIndex, uint256 maxSignerIndex);\n    error DuplicateSigner(uint256 signerIndex);\n    error InvalidOraclePrice(address token);\n    error InvalidSignerMinMaxPrice(uint256 minPrice, uint256 maxPrice);\n    error InvalidMedianMinMaxPrice(uint256 minPrice, uint256 maxPrice);\n    error NonEmptyTokensWithPrices(uint256 tokensWithPricesLength);\n    error EmptyPriceFeed(address token);\n    error PriceAlreadySet(address token, uint256 minPrice, uint256 maxPrice);\n\n    constructor(\n        RoleStore _roleStore,\n        OracleStore _oracleStore\n    ) RoleModule(_roleStore) {\n        oracleStore = _oracleStore;\n\n        // sign prices with only the chainid and oracle name so that there is\n        // less config required in the oracle nodes\n        SALT = keccak256(abi.encode(block.chainid, \"xget-oracle-v1\"));\n    }\n\n    // @dev validate and store signed prices\n    //\n    // The setPrices function is used to set the prices of tokens in the Oracle contract.\n    // It accepts an array of tokens and a signerInfo parameter. The signerInfo parameter\n    // contains information about the signers that have signed the transaction to set the prices.\n    // The first 16 bits of the signerInfo parameter contain the number of signers, and the following\n    // bits contain the index of each signer in the oracleStore. The function checks that the number\n    // of signers is greater than or equal to the minimum number of signers required, and that\n    // the signer indices are unique and within the maximum signer index. The function then calls\n    // _setPrices and _setPricesFromPriceFeeds to set the prices of the tokens.\n    //\n    // Oracle prices are signed as a value together with a precision, this allows\n    // prices to be compacted as uint32 values.\n    //\n    // The signed prices represent the price of one unit of the token using a value\n    // with 30 decimals of precision.\n    //\n    // Representing the prices in this way allows for conversions between token amounts\n    // and fiat values to be simplified, e.g. to calculate the fiat value of a given\n    // number of tokens the calculation would just be: `token amount * oracle price`,\n    // to calculate the token amount for a fiat value it would be: `fiat value / oracle price`.\n    //\n    // The trade-off of this simplicity in calculation is that tokens with a small USD\n    // price and a lot of decimals may have precision issues it is also possible that\n    // a token's price changes significantly and results in requiring higher precision.\n    //\n    // ## Example 1\n    //\n    // The price of ETH is 5000, and ETH has 18 decimals.\n    //\n    // The price of one unit of ETH is `5000 / (10 ^ 18), 5 * (10 ^ -15)`.\n    //\n    // To handle the decimals, multiply the value by `(10 ^ 30)`.\n    //\n    // Price would be stored as `5000 / (10 ^ 18) * (10 ^ 30) => 5000 * (10 ^ 12)`.\n    //\n    // For gas optimization, these prices are sent to the oracle in the form of a uint8\n    // decimal multiplier value and uint32 price value.\n    //\n    // If the decimal multiplier value is set to 8, the uint32 value would be `5000 * (10 ^ 12) / (10 ^ 8) => 5000 * (10 ^ 4)`.\n    //\n    // With this config, ETH prices can have a maximum value of `(2 ^ 32) / (10 ^ 4) => 4,294,967,296 / (10 ^ 4) => 429,496.7296` with 4 decimals of precision.\n    //\n    // ## Example 2\n    //\n    // The price of BTC is 60,000, and BTC has 8 decimals.\n    //\n    // The price of one unit of BTC is `60,000 / (10 ^ 8), 6 * (10 ^ -4)`.\n    //\n    // Price would be stored as `60,000 / (10 ^ 8) * (10 ^ 30) => 6 * (10 ^ 26) => 60,000 * (10 ^ 22)`.\n    //\n    // BTC prices maximum value: `(2 ^ 64) / (10 ^ 2) => 4,294,967,296 / (10 ^ 2) => 42,949,672.96`.\n    //\n    // Decimals of precision: 2.\n    //\n    // ## Example 3\n    //\n    // The price of USDC is 1, and USDC has 6 decimals.\n    //\n    // The price of one unit of USDC is `1 / (10 ^ 6), 1 * (10 ^ -6)`.\n    //\n    // Price would be stored as `1 / (10 ^ 6) * (10 ^ 30) => 1 * (10 ^ 24)`.\n    //\n    // USDC prices maximum value: `(2 ^ 64) / (10 ^ 6) => 4,294,967,296 / (10 ^ 6) => 4294.967296`.\n    //\n    // Decimals of precision: 6.\n    //\n    // ## Example 4\n    //\n    // The price of DG is 0.00000001, and DG has 18 decimals.\n    //\n    // The price of one unit of DG is `0.00000001 / (10 ^ 18), 1 * (10 ^ -26)`.\n    //\n    // Price would be stored as `1 * (10 ^ -26) * (10 ^ 30) => 1 * (10 ^ 3)`.\n    //\n    // DG prices maximum value: `(2 ^ 64) / (10 ^ 11) => 4,294,967,296 / (10 ^ 11) => 0.04294967296`.\n    //\n    // Decimals of precision: 11.\n    //\n    // ## Decimal Multiplier\n    //\n    // The formula to calculate what the decimal multiplier value should be set to:\n    //\n    // Decimals: 30 - (token decimals) - (number of decimals desired for precision)\n    //\n    // - ETH: 30 - 18 - 4 => 8\n    // - BTC: 30 - 8 - 2 => 20\n    // - USDC: 30 - 6 - 6 => 18\n    // - DG: 30 - 18 - 11 => 1\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param params OracleUtils.SetPricesParams\n    function setPrices(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        OracleUtils.SetPricesParams memory params\n    ) external onlyController {\n        if (tokensWithPrices.length() != 0) {\n            revert NonEmptyTokensWithPrices(tokensWithPrices.length());\n        }\n\n        if (params.tokens.length == 0) { revert EmptyTokens(); }\n\n        // first 16 bits of signer info contains the number of signers\n        address[] memory signers = new address[](params.signerInfo & Bits.BITMASK_16);\n\n        if (signers.length < dataStore.getUint(Keys.MIN_ORACLE_SIGNERS)) {\n            revert MinOracleSigners(signers.length, dataStore.getUint(Keys.MIN_ORACLE_SIGNERS));\n        }\n\n        if (signers.length > MAX_SIGNERS) {\n            revert MaxOracleSigners(signers.length, MAX_SIGNERS);\n        }\n\n        uint256 signerIndexFlags;\n\n        for (uint256 i = 0; i < signers.length; i++) {\n            uint256 signerIndex = params.signerInfo >> (16 + 16 * i) & Bits.BITMASK_16;\n\n            if (signerIndex >= MAX_SIGNER_INDEX) {\n                revert MaxSignerIndex(signerIndex, MAX_SIGNER_INDEX);\n            }\n\n            uint256 signerIndexBit = 1 << signerIndex;\n\n            if (signerIndexFlags & signerIndexBit != 0) {\n                revert DuplicateSigner(signerIndex);\n            }\n\n            signerIndexFlags = signerIndexFlags | signerIndexBit;\n\n            signers[i] = oracleStore.getSigner(signerIndex);\n        }\n\n        _setPrices(\n            dataStore,\n            eventEmitter,\n            signers,\n            params\n        );\n\n        _setPricesFromPriceFeeds(dataStore, eventEmitter, params.priceFeedTokens);\n    }\n\n    // @dev set the primary price\n    // @param token the token to set the price for\n    // @param price the price value to set to\n    function setPrimaryPrice(address token, Price.Props memory price) external onlyController {\n        primaryPrices[token] = price;\n    }\n\n    // @dev set the secondary price\n    // @param token the token to set the price for\n    // @param price the price value to set to\n    function setSecondaryPrice(address token, Price.Props memory price) external onlyController {\n        secondaryPrices[token] = price;\n    }\n\n    // @dev set a custom price\n    // @param token the token to set the price for\n    // @param price the price value to set to\n    function setCustomPrice(address token, Price.Props memory price) external onlyController {\n        customPrices[token] = price;\n    }\n\n    // @dev clear all prices\n    function clearAllPrices() external onlyController {\n        uint256 length = tokensWithPrices.length();\n        for (uint256 i = 0; i < length; i++) {\n            address token = tokensWithPrices.at(0);\n            delete primaryPrices[token];\n            delete secondaryPrices[token];\n            delete customPrices[token];\n            tokensWithPrices.remove(token);\n        }\n    }\n\n    // @dev get the length of tokensWithPrices\n    // @return the length of tokensWithPrices\n    function getTokensWithPricesCount() external view returns (uint256) {\n        return tokensWithPrices.length();\n    }\n\n    // @dev get the tokens of tokensWithPrices for the specified indexes\n    // @param start the start index, the value for this index will be included\n    // @param end the end index, the value for this index will not be included\n    // @return the tokens of tokensWithPrices for the specified indexes\n    function getTokensWithPrices(uint256 start, uint256 end) external view returns (address[] memory) {\n        return tokensWithPrices.valuesAt(start, end);\n    }\n\n    // @dev get the primary price of a token\n    // @param token the token to get the price for\n    // @return the primary price of a token\n    function getPrimaryPrice(address token) external view returns (Price.Props memory) {\n        if (token == address(0)) { return Price.Props(0, 0); }\n\n        Price.Props memory price = primaryPrices[token];\n        if (price.isEmpty()) {\n            revert OracleUtils.EmptyPrimaryPrice(token);\n        }\n\n        return price;\n    }\n\n    // @dev get the secondary price of a token\n    // @param token the token to get the price for\n    // @return the secondary price of a token\n    function getSecondaryPrice(address token) external view returns (Price.Props memory) {\n        if (token == address(0)) { return Price.Props(0, 0); }\n\n        Price.Props memory price = secondaryPrices[token];\n        if (price.isEmpty()) {\n            revert OracleUtils.EmptySecondaryPrice(token);\n        }\n\n        return price;\n    }\n\n    // @dev get the latest price of a token\n    // @param token the token to get the price for\n    // @return the latest price of a token\n    function getLatestPrice(address token) external view returns (Price.Props memory) {\n        if (token == address(0)) { return Price.Props(0, 0); }\n\n        Price.Props memory secondaryPrice = secondaryPrices[token];\n\n        if (!secondaryPrice.isEmpty()) {\n            return secondaryPrice;\n        }\n\n        Price.Props memory primaryPrice = primaryPrices[token];\n        if (!primaryPrice.isEmpty()) {\n            return primaryPrice;\n        }\n\n        revert OracleUtils.EmptyLatestPrice(token);\n    }\n\n    // @dev get the custom price of a token\n    // @param token the token to get the price for\n    // @return the custom price of a token\n    function getCustomPrice(address token) external view returns (Price.Props memory) {\n        Price.Props memory price = customPrices[token];\n        if (price.isEmpty()) {\n            revert OracleUtils.EmptyCustomPrice(token);\n        }\n        return price;\n    }\n\n    // @dev get the price feed address for a token\n    // @param dataStore DataStore\n    // @param token the token to get the price feed for\n    // @return the price feed for the token\n    function getPriceFeed(DataStore dataStore, address token) public view returns (IPriceFeed) {\n        address priceFeedAddress = dataStore.getAddress(Keys.priceFeedKey(token));\n        if (priceFeedAddress == address(0)) {\n            revert EmptyPriceFeed(token);\n        }\n\n        return IPriceFeed(priceFeedAddress);\n    }\n\n    // @dev get the stable price of a token\n    // @param dataStore DataStore\n    // @param token the token to get the price for\n    // @return the stable price of the token\n    function getStablePrice(DataStore dataStore, address token) public view returns (uint256) {\n        return dataStore.getUint(Keys.stablePriceKey(token));\n    }\n\n    // @dev get the multiplier value to convert the external price feed price to the price of 1 unit of the token\n    // represented with 30 decimals\n    // for example, if USDC has 6 decimals and a price of 1 USD, one unit of USDC would have a price of\n    // 1 / (10 ^ 6) * (10 ^ 30) => 1 * (10 ^ 24)\n    // if the external price feed has 8 decimals, the price feed price would be 1 * (10 ^ 8)\n    // in this case the priceFeedMultiplier should be 10 ^ 46\n    // the conversion of the price feed price would be 1 * (10 ^ 8) * (10 ^ 46) / (10 ^ 30) => 1 * (10 ^ 24)\n    // formula for decimals for price feed multiplier: 60 - (external price feed decimals) - (token decimals)\n    //\n    // @param dataStore DataStore\n    // @param token the token to get the price feed multiplier for\n    // @return the price feed multipler\n    function getPriceFeedMultiplier(DataStore dataStore, address token) public view returns (uint256) {\n        uint256 multiplier = dataStore.getUint(Keys.priceFeedMultiplierKey(token));\n\n        if (multiplier == 0) {\n            revert EmptyPriceFeedMultiplier(token);\n        }\n\n        return multiplier;\n    }\n\n    // @dev validate and set prices\n    // The _setPrices() function is a helper function that is called by the\n    // setPrices() function. It takes in several parameters: a DataStore contract\n    // instance, an EventEmitter contract instance, an array of signers, and an\n    // OracleUtils.SetPricesParams struct containing information about the tokens\n    // and their prices.\n    // The function first initializes a SetPricesCache struct to store some temporary\n    // values that will be used later in the function. It then loops through the array\n    // of tokens and sets the corresponding values in the cache struct. For each token,\n    // the function also loops through the array of signers and validates the signatures\n    // for the min and max prices for that token. If the signatures are valid, the\n    // function calculates the median min and max prices and sets them in the DataStore\n    // contract.\n    // Finally, the function emits an event to signal that the prices have been set.\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmit"
    }
  ]
}