{
  "Title": "[M-04] Malicious `emissionToken` could poison rewards for a market",
  "Content": "\nWhen distributing rewards for a market, each `emissionConfig` is looped over and sent rewards for. `disburseBorrowerRewardsInternal` as an example, the same holds true for `disburseSupplierRewardsInternal`:\n\n<https://github.com/code-423n4/2023-07-moonwell/blob/main/src/core/MultiRewardDistributor/MultiRewardDistributor.sol#L1147-L1247>\n\n```solidity\nFile: MultiRewardDistributor/MultiRewardDistributor.sol\n\n1147:    function disburseBorrowerRewardsInternal(\n1148:        MToken _mToken,\n1149:        address _borrower,\n1150:        bool _sendTokens\n1151:    ) internal {\n1152:        MarketEmissionConfig[] storage configs = marketConfigs[\n1153:            address(_mToken)\n1154:        ];\n\n             // ... mToken balance and borrow index\n\n1162:        // Iterate over all market configs and update their indexes + timestamps\n1163:        for (uint256 index = 0; index < configs.length; index++) {\n1164:            MarketEmissionConfig storage emissionConfig = configs[index];\n\n                 // ... index updates\n\n1192:            if (_sendTokens) {\n1193:                // Emit rewards for this token/pair\n1194:                uint256 pendingRewards = sendReward( // <-- will trigger transfer on `emissionToken`\n1195:                    payable(_borrower),\n1196:                    emissionConfig.borrowerRewardsAccrued[_borrower],\n1197:                    emissionConfig.config.emissionToken\n1198:                );\n1199:\n1200:                emissionConfig.borrowerRewardsAccrued[\n1201:                    _borrower\n1202:                ] = pendingRewards;\n1203:            }\n1204:        }\n1205:    }\n\n...\n\n1214:    function sendReward(\n1215:        address payable _user,\n1216:        uint256 _amount,\n1217:        address _rewardToken\n1218:    ) internal nonReentrant returns (uint256) {\n\n             // ... short circuits breakers\n\n1232:        uint256 currentTokenHoldings = token.balanceOf(address(this));\n1233:\n1234:        // Only transfer out if we have enough of a balance to cover it (otherwise just accrue without sending)\n1235:        if (_amount > 0 && _amount <= currentTokenHoldings) {\n1236:            // Ensure we use SafeERC20 to revert even if the reward token isn't ERC20 compliant\n1237:            token.safeTransfer(_user, _amount); // <-- if this reverts all emissions fail\n1238:            return 0;\n1239:        } else {\n                 // .. default return _amount\n1245:            return _amount;\n1246:        }\n1247:    }\n```\n\nIf one transfer reverts the whole transaction fails and no rewards will be paid out for this user. Hence if there is a malicious token that would revert on transfer it would cause no rewards to paid out. As long as there is some rewards accrued for the malicious `emissionConfig`.\nThe users with already unclaimed rewards for this `emissionConfig` would have their rewards permanently locked.\n\nThe `admin` (`TemporalGovernor`) of `MultiRewardsDistributor` could update the reward speed for the token to `0` but that would just prevent further damage from being done.\n\nUpgradeable tokens aren't unusual and hence the token might seem harmless to begin with but be upgraded to a malicious implementation that reverts on transfer.\n\n### Proof of Concept\n\nTest in `MultiRewardDistributor.t.sol`, `MultiRewardSupplySideDistributorUnitTest`, most of the test is copied from `testSupplierHappyPath` with the addition of `MaliciousToken`:\n\n```solidity\ncontract MaliciousToken {\n    function balanceOf(address) public pure returns(uint256) {\n        return type(uint256).max;\n    }\n\n    function transfer(address, uint256) public pure {\n        revert(\"No transfer for you\");\n    }\n}\n```\n\n```solidity\n    function testAddMaliciousEmissionToken() public {\n        uint256 startTime = 1678340000;\n        vm.warp(startTime);\n\n        MultiRewardDistributor distributor = createDistributorWithRoundValuesAndConfig(2e18, 0.5e18, 0.5e18);\n\n        // malicious token added\n        MaliciousToken token = new MaliciousToken();\n        distributor._addEmissionConfig(\n            mToken,\n            address(this),\n            address(token),\n            1e18,\n            1e18,\n            block.timestamp + 365 days\n        );\n\n        comptroller._setRewardDistributor(distributor);\n\n        emissionToken.allocateTo(address(distributor), 10000e18);\n\n        vm.warp(block.timestamp + 1);\n\n        mToken.mint(2e18);\n        assertEq(MTokenInterface(mToken).totalSupply(), 2e18);\n\n        // Wait 12345 seconds after depositing\n        vm.warp(block.timestamp + 12345);\n\n        // claim fails as the malicious token reverts on transfer\n        vm.expectRevert(\"No transfer for you\");\n        comptroller.claimReward();\n\n        // no rewards handed out\n        assertEq(emissionToken.balanceOf(address(this)), 0);\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider adding a way for `admin` to remove an `emissionConfig`.\n\nAlternatively, the reward transfer could be wrapped in a `try`/`catch` and returning `_amount` in `catch`. Be mindful to only allow a certain amount of gas to the transfer then as otherwise the same attack works with consuming all gas available.\n\n**[ElliotFriedman (Moonwell) disputed and commented](https://github.com/code-423n4/2023-07-moonwell-findings/issues/320#issuecomment-1664718290):**\n > Emission creator (comptroller admin) and emission owners are trusted, it is assumed they will not add any poison reward tokens.\n\n**[alcueca (Judge) commented](https://github.com/code-423n4/2023-07-moonwell-findings/issues/320#issuecomment-1676115974):**\n > @ElliotFriedman, I'm not sure yet if anyone else has reported this, but the emissions token doesn't need to be even suspicious. USDC and USDT can blacklist users. If you use those tokens as emissions and **any** of your rewards holders get blacklisted, this issue will get triggered.\n\n**[lyoungblood (Warden) commented](https://github.com/code-423n4/2023-07-moonwell-findings/issues/320#issuecomment-1676115974):**\n >Since tokens (EmissionConfig) cannot be added except by admin (the DAO), I still dispute the validity of the finding, or at least the severity. We have to be reasonable in our assumptions and the assumption that the admin will add a malicious/censorable token can't really be a precursor to a valid finding. The admin can directly remove funds from the contract with removeReserves, but we wouldn't consider a finding like that valid.\n\n**[alcueca (Judge) commented](https://github.com/code-423n4/2023-07-moonwell-findings/issues/320#issuecomment-1676115974):**\n >@lyoungblood, USDC and USDT are both censorable, and it sounds pretty reasonable that would be used as emission tokens.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-moonwell",
  "Code": [
    {
      "filename": "src/core/MultiRewardDistributor/MultiRewardDistributor.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {MToken} from \"@protocol/core/MToken.sol\";\nimport {Comptroller} from \"@protocol/core/Comptroller.sol\";\nimport {MTokenInterface} from \"@protocol/core/MTokenInterfaces.sol\";\nimport {ExponentialNoError} from \"@protocol/core/ExponentialNoError.sol\";\nimport {MultiRewardDistributorCommon} from \"@protocol/core/MultiRewardDistributor/MultiRewardDistributorCommon.sol\";\n\n/**\n    @title A multi-asset distributor that tracks mTokens supply/borrows\n    @author Octavius - octavius@moonwell.fi\n\n    This contract integrates with the Moonwell Comptroller and manages all reward disbursal and index\n    calculations both for the global market indices as well as individual user indices on those markets.\n    It is largely the same logic that compound uses, just generalized (meaning that transfers will not\n    fail if things can't be sent out, but the excess is accrued on the books to be sent later).\n\n    Each market has an array of configs, each with a unique emission token owned by a specific team/user.\n    That owner can adjust supply and borrow emissions, end times, and\n\n    This emitter also supports native assets, but keep in mind that things get complicated with multiple\n    owners managing a native asset emitter - one owner can drain the contract by increasing their own\n\n    Delegates admin control to the comptroller's admin (no internal admin controls).\n\n    There is a hard rule that each market should only have 1 config with a specific emission token.\n\n    Emission configs are non-removable because they hold the supplier/borrower indices and that would\n    cause rewards to not be disbursed properly when a config is removed.\n\n    There is a pause guardian in this contract that can immediately stop all token emissions. Accruals\n    still happen but no tokens will be sent out when the circuit breaker is popped. Much like the pause\n    guardians on the Comptroller, only the comptroller's admin can actually unpause things.\n*/\n\ncontract MultiRewardDistributor is\n    Pausable,\n    ReentrancyGuard,\n    Initializable,\n    MultiRewardDistributorCommon,\n    ExponentialNoError\n{\n    using SafeERC20 for IERC20;\n\n    /// @notice The main data storage for this contract, holds a mapping of mToken to array\n    //          of market configs\n    mapping(address => MarketEmissionConfig[]) public marketConfigs;\n\n    /// @notice Comptroller this distributor is bound to\n    Comptroller public comptroller; /// we can't make this immutable because we are using proxies\n\n    /// @notice The pause guardian for this contract\n    address public pauseGuardian;\n\n    /// @notice The initialIndexConstant, used to initialize indexes, and taken from the Comptroller\n    uint224 public constant initialIndexConstant = 1e36;\n\n    /// @notice The emission cap dictates an upper limit for reward speed emission speed configs\n    /// @dev By default, is set to 100 1e18 token emissions / sec to avoid unbounded\n    ///  computation/multiplication overflows\n    uint256 public emissionCap;\n\n    // Some structs we can't move to the interface\n    struct CurrentMarketData {\n        uint256 totalMTokens;\n        uint256 totalBorrows;\n        Exp marketBorrowIndex;\n    }\n\n    struct CalculatedData {\n        CurrentMarketData marketData;\n        MTokenData mTokenInfo;\n    }\n\n    /// construct the logic contract and initialize so that the initialize function is uncallable\n    /// from the implementation and only callable from the proxy\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _comptroller,\n        address _pauseGuardian\n    ) external initializer {\n        // Sanity check the params\n        require(\n            _comptroller != address(0),\n            \"Comptroller can't be the 0 address!\"\n        );\n        require(\n            _pauseGuardian != address(0),\n            \"Pause Guardian can't be the 0 address!\"\n        );\n\n        comptroller = Comptroller(payable(_comptroller));\n\n        require(\n            comptroller.isComptroller(),\n            \"Can't bind to something that's not a comptroller!\"\n        );\n\n        pauseGuardian = _pauseGuardian;\n        emissionCap = 100e18;\n    }\n\n    /*\n    ====================================================================================================\n     ACL Modifiers\n\n     all modifiers allow for the admin to call in to take actions within this contract, the idea being that\n     the timelock can act like an owner of the config to set parameters, and act like the comptroller to\n     kick the reward index updates, and act like a pause guardian to pause things.\n    ====================================================================================================\n    */\n\n    /// @notice Only allow the comptroller's admin to take an action, usually the timelock\n    modifier onlyComptrollersAdmin() {\n        require(\n            msg.sender == address(comptroller.admin()),\n            \"Only the comptroller's administrator can do this!\"\n        );\n        _;\n    }\n\n    /// @notice Only allow the comptroller OR the comptroller's admin to take an action\n    modifier onlyComptrollerOrAdmin() {\n        require(\n            msg.sender == address(comptroller) ||\n                msg.sender == comptroller.admin(),\n            \"Only the comptroller or comptroller admin can call this function\"\n        );\n        _;\n    }\n\n    /// @notice Only allow the emission config owner OR the comptroller's admin to take an action\n    modifier onlyEmissionConfigOwnerOrAdmin(\n        MToken _mToken,\n        address emissionToken\n    ) {\n        MarketEmissionConfig\n            storage emissionConfig = fetchConfigByEmissionToken(\n                _mToken,\n                emissionToken\n            );\n        require(\n            msg.sender == emissionConfig.config.owner ||\n                msg.sender == comptroller.admin(),\n            \"Only the config owner or comptroller admin can call this function\"\n        );\n        _;\n    }\n\n    /// @notice Only allow the pause guardian OR the comptroller's admin to take an action\n    modifier onlyPauseGuardianOrAdmin() {\n        require(\n            msg.sender == pauseGuardian || msg.sender == comptroller.admin(),\n            \"Only the pause guardian or comptroller admin can call this function\"\n        );\n        _;\n    }\n\n    /*\n    ====================================================================================================\n     External/publicly accessible API\n\n     The main public API for the contract, generally focused on getting a user's outstanding rewards or\n     pulling down specific configs. Users should call `claimRewards` on the comptroller as usual to recv\n     their rewards.\n    ====================================================================================================\n    */\n\n    /**\n     * @notice Get the current owner of a config\n     * @param _mToken The market to get a config for\n     * @param _emissionToken The reward token address\n     */\n    function getCurrentOwner(\n        MToken _mToken,\n        address _emissionToken\n    ) external view returns (address) {\n        MarketEmissionConfig\n            storage emissionConfig = fetchConfigByEmissionToken(\n                _mToken,\n                _emissionToken\n            );\n        return emissionConfig.config.owner;\n    }\n\n    /// @notice A view to enumerate all configs for a given market, does not include index data\n    function getAllMarketConfigs(\n        MToken _mToken\n    ) external view returns (MarketConfig[] memory) {\n        MarketEmissionConfig[] storage configs = marketConfigs[\n            address(_mToken)\n        ];\n\n        MarketConfig[] memory outputMarketConfigs = new MarketConfig[](\n            configs.length\n        );\n\n        // Pop out the MarketConfigs to return them\n        for (uint256 index = 0; index < configs.length; index++) {\n            MarketEmissionConfig storage emissionConfig = configs[index];\n            outputMarketConfigs[index] = emissionConfig.config;\n        }\n\n        return outputMarketConfigs;\n    }\n\n    /// @notice A view to get a config for a specific market/emission token pair\n    function getConfigForMarket(\n        MToken _mToken,\n        address _emissionToken\n    ) external view returns (MarketConfig memory) {\n        MarketEmissionConfig\n            storage emissionConfig = fetchConfigByEmissionToken(\n                _mToken,\n                _emissionToken\n            );\n        return emissionConfig.config;\n    }\n\n    /// @notice A view to enumerate a user's rewards across all markets and all emission tokens\n    function getOutstandingRewardsForUser(\n        address _user\n    ) external view returns (RewardWithMToken[] memory) {\n        MToken[] memory markets = comptroller.getAllMarkets();\n\n        RewardWithMToken[] memory outputData = new RewardWithMToken[](\n            markets.length\n        );\n\n        for (uint256 index = 0; index < markets.length; index++) {\n            RewardInfo[] memory rewardInfo = getOutstandingRewardsForUser(\n                markets[index],\n                _user\n            );\n\n            outputData[index] = RewardWithMToken(\n                address(markets[index]),\n                rewardInfo\n            );\n        }\n\n        return outputData;\n    }\n\n    /// @notice A view to enumerate a user's rewards across a specified market and all emission tokens for that market\n    function getOutstandingRewardsForUser(\n        MToken _mToken,\n        address _user\n    ) public view returns (RewardInfo[] memory) {\n        // Global config for this mToken\n        MarketEmissionConfig[] storage configs = marketConfigs[\n            address(_mToken)\n        ];\n\n        // Output var\n        RewardInfo[] memory outputRewardData = new RewardInfo[](configs.length);\n\n        // Code golf to avoid too many local vars :rolling-eyes:\n        CalculatedData memory calcData = CalculatedData({\n            marketData: CurrentMarketData({\n                totalMTokens: _mToken.totalSupply(),\n                totalBorrows: _mToken.totalBorrows(),\n                marketBorrowIndex: Exp({mantissa: _mToken.borrowIndex()})\n            }),\n            mTokenInfo: MTokenData({\n                mTokenBalance: _mToken.balanceOf(_user),\n                borrowBalanceStored: _mToken.borrowBalanceStored(_user)\n            })\n        });\n\n        for (uint256 index = 0; index < configs.length; index++) {\n            MarketEmissionConfig storage emissionConfig = configs[index];\n\n            // Calculate our new global supply index\n            IndexUpdate memory supplyUpdate = calculateNewIndex(\n                emissionConfig.config.supplyEmissionsPerSec,\n                emissionConfig.config.supplyGlobalTimestamp,\n                emissionConfig.config.supplyGlobalIndex,\n                emissionConfig.config.endTime,\n                calcData.marketData.totalMTokens\n            );\n\n            // Calculate our new global borrow index\n            IndexUpdate memory borrowUpdate = calculateNewIndex(\n                emissionConfig.config.borrowEmissionsPerSec,\n                emissionConfig.config.borrowGlobalTimestamp,\n                emissionConfig.config.borrowGlobalIndex,\n                emissionConfig.config.endTime,\n                div_(\n                    calcData.marketData.totalBorrows,\n                    calcData.marketData.marketBorrowIndex\n                )\n            );\n\n            // Calculate outstanding supplier side rewards\n            uint256 supplierRewardsAccrued = calculateSupplyRewardsForUser(\n                emissionConfig,\n                supplyUpdate.newIndex,\n                calcData.mTokenInfo.mTokenBalance,\n                _user\n            );\n\n            uint256 borrowerRewardsAccrued = calculateBorrowRewardsForUser(\n                emissionConfig,\n                borrowUpdate.newIndex,\n                calcData.marketData.marketBorrowIndex,\n                calcData.mTokenInfo,\n                _user\n            );\n\n            outputRewardData[index] = RewardInfo({\n                emissionToken: emissionConfig.config.emissionToken,\n                totalAmount: borrowerRewardsAccrued + supplierRewardsAccrued,\n                supplySide: supplierRewardsAccrued,\n                borrowSide: borrowerRewardsAccrued\n            });\n        }\n\n        return outputRewardData;\n    }\n\n    /// @notice A view to get the current emission caps\n    function getCurrentEmissionCap() external view returns (uint256) {\n        return emissionCap;\n    }\n\n    /// @notice view to get the cached global supply index for an mToken and emission index\n    /// @param mToken The market to get a config for\n    /// @param index The index of the config to get\n    function getGlobalSupplyIndex(\n        address mToken,\n        uint256 index\n    ) public view returns (uint256) {\n        MarketEmissionConfig storage emissionConfig = marketConfigs[mToken][\n            index\n        ];\n\n        // Set the new values in storage\n        return emissionConfig.config.supplyGlobalIndex;\n    }\n\n    /// @notice view to get the cached global borrow index for an mToken and emission index\n    /// @param mToken The market to get a config for\n    /// @param index The index of the config to get\n    function getGlobalBorrowIndex(\n        address mToken,\n        uint256 index\n    ) public view returns (uint256) {\n        MarketEmissionConfig storage emissionConfig = marketConfigs[mToken][\n            index\n        ];\n\n        // Set the new values in storage\n        return emissionConfig.config.borrowGlobalIndex;\n    }\n\n    /*\n    ====================================================================================================\n     Administrative API\n\n     Should be only callable by the comptroller's admin (usually the timelock), this is the only way\n     to add new configurations to the markets. There's also a rescue assets function that will sweep\n     tokens out of this contract and to the timelock, the thought being that rescuing accidentally sent\n     funds or sweeping existing tokens to a new distributor is possible.\n    ====================================================================================================\n    */\n\n    /**\n     * @notice Add a new emission configuration for a specific market\n     * @dev Emission config must not already exist for the specified market (unique to the emission token)\n     */\n    function _addEmissionConfig(\n        MToken _mToken,\n        address _owner,\n        address _emissionToken,\n        uint256 _supplyEmissionPerSec,\n        uint256 _borrowEmissionsPerSec,\n        uint256 _endTime\n    ) external onlyComptrollersAdmin {\n        // Ensure market is listed in the comptroller before accepting a config for it (should always be checked\n        // in the comptroller first, but never hurts to codify that assertion/requirement here.\n        (bool tokenIsListed, ) = comptroller.markets(address(_mToken));\n        require(\n            tokenIsListed,\n            \"The market requested to be added is un-listed!\"\n        );\n\n        // Sanity check emission speeds are below emissionCap\n        require(\n            _supplyEmissionPerSec < emissionCap,\n            \"Cannot set a supply reward speed higher than the emission cap!\"\n        );\n        require(\n            _borrowEmissionsPerSec < emissionCap,\n            \"Cannot set a borrow reward speed higher than the emission cap!\"\n        );\n\n        // Sanity check end time is some time in the future\n        require(\n            _endTime > block.timestamp + 1,\n            \"The _endTime parameter must be in the future!\"\n        );\n\n        MarketEmissionConfig[] storage configs = marketConfigs[\n            address(_mToken)\n        ];\n\n        // Sanity check to ensure that the emission token doesn't already exist in a config\n        for (uint256 index = 0; index < configs.length; index++) {\n            MarketEmissionConfig storage mTokenConfig = configs[index];\n            require(\n                mTokenConfig.config.emissionToken != _emissionToken,\n                \"Emission token already listed!\"\n            );\n        }\n\n        // Things look good, create a config\n        MarketConfig memory config = MarketConfig({\n            // Set the owner of the reward distributor config\n            owner: _owner,\n            // Set the emission token address\n            emissionToken: _emissionToken,\n            // Set the time that the emission campaign should end at\n            endTime: _endTime,\n            // Initialize the global supply\n            supplyGlobalTimestamp: safe32(\n                block.timestamp,\n                \"block timestamp exceeds 32 bits\"\n            ),\n            supplyGlobalIndex: initialIndexConstant,\n            // Initialize the global borrow index + timestamp\n            borrowGlobalTimestamp: safe32(\n                block.timestamp,\n                \"block timestamp exceeds 32 bits\"\n            ),\n            borrowGlobalIndex: initialIndexConstant,\n            // Set supply and reward borrow speeds\n            supplyEmissionsPerSec: _supplyEmissionPerSec,\n            borrowEmissionsPerSec: _borrowEmissionsPerSec\n        });\n\n        emit NewConfigCreated(\n            _mToken,\n            _owner,\n            _emissionToken,\n            _supplyEmissionPerSec,\n            _borrowEmissionsPerSec,\n            _endTime\n        );\n\n        // Go push in our new config\n        MarketEmissionConfig storage newConfig = configs.push();\n        newConfig.config = config;\n    }\n\n    /**\n     * @notice Sweep ERC-20 tokens from the comptroller to the admin\n     * @param _tokenAddress The address of the token to transfer\n     * @param _amount The amount of tokens to sweep, uint256.max means everything\n     */\n    function _rescueFunds(\n        address _tokenAddress,\n        uint256 _amount\n    ) external onlyComptrollersAdmin {\n        IERC20 token = IERC20(_tokenAddress);\n        // Similar to mTokens, if this is uint256.max that means \"transfer everything\"\n        if (_amount == type(uint256).max) {\n            token.safeTransfer(\n                comptroller.admin(),\n                token.balanceOf(address(this))\n            );\n        } else {\n            token.safeTransfer(comptroller.admin(), _amount);\n        }\n\n        emit FundsRescued(_tokenAddress, _amount);\n    }\n\n    /**\n     * @notice Sets a new pause guardian, callable by the CURRENT pause guardian or comptroller's admin\n     * @param _newPauseGuardian The new pause guardian\n     */\n    function _setPauseGuardian(\n        address _newPauseGuardian\n    ) external onlyPauseGuardianOrAdmin {\n        require(\n            _newPauseGuardian != address(0),\n            \"Pause Guardian can't be the 0 address!\"\n        );\n\n        address currentPauseGuardian = pauseGuardian;\n\n        pauseGuardian = _newPauseGuardian;\n\n        emit NewPauseGuardian(currentPauseGuardian, _newPauseGuardian);\n    }\n\n    /**\n     * @notice Sets a new emission cap for supply/borrow speeds\n     * @param _newEmissionCap The new emission cap\n     */\n    function _setEmissionCap(\n        uint256 _newEmissionCap\n    ) external onlyComptrollersAdmin {\n        uint256 oldEmissionCap = emissionCap;\n\n        emissionCap = _newEmissionCap;\n\n        emit NewEmissionCap(oldEmissionCap, _newEmissionCap);\n    }\n\n    /*\n    ====================================================================================================\n     Comptroller specific API\n\n     This is the main integration points with the Moonwell Comptroller. Within the `allowMint`/`allowBorrow`/etc\n     hooks, the comptroller will reach out to kick the global index update (updateMarketIndex) as well as update\n     the supplier's/borrower's token specific distribution indices for that market\n    ====================================================================================================\n    */\n\n    /**\n     * @notice Updates the supply indices for a given market\n     * @param _mToken The market to update\n     */\n    function updateMarketSupplyIndex(\n        MToken _mToken\n    ) external onlyComptrollerOrAdmin {\n        updateMarketSupplyIndexInternal(_mToken);\n    }\n\n    /**\n     * @notice Calculate the deltas in indices between this user's index and the global supplier index for all configs,\n     *         and accrue any owed emissions to their supplierRewardsAccrued for this market's configs\n     * @param _mToken The market to update\n     * @param _supplier The supplier whose index will be updated\n     * @param _sendTokens Whether to send tokens as part of calculating owed rewards\n     */\n    function disburseSupplierRewards(\n        MToken _mToken,\n        address _supplier,\n        bool _sendTokens\n    ) external onlyComptrollerOrAdmin {\n        disburseSupplierRewardsInternal(_mToken, _supplier, _sendTokens);\n    }\n\n    /**\n     * @notice Combine the above 2 functions into one that will update the global and user supplier indexes and\n     *         disburse rewards\n     * @param _mToken The market to update\n     * @param _supplier The supplier whose index will be updated\n     * @param _sendTokens Whether to send tokens as part of calculating owed rewards\n     */\n    function updateMarketSupplyIndexAndDisburseSupplierRewards(\n        MToken _mToken,\n        address _supplier,\n        bool _sendTokens\n    ) external onlyComptrollerOrAdmin {\n        updateMarketSupplyIndexInternal(_mToken);\n        disburseSupplierRewardsInternal(_mToken, _supplier, _sendTokens);\n    }\n\n    /**\n     * @notice Updates the borrow indices for a given market\n     * @param _mToken The market to update\n     */\n    function updateMarketBorrowIndex(\n        MToken _mToken\n    ) external onlyComptrollerOrAdmin {\n        updateMarketBorrowIndexInternal(_mToken);\n    }\n\n    /**\n     * @notice Calculate the deltas in indices between this user's index and the global borrower index for all configs,\n     *         and accrue any owed emissions to their borrowerRewardsAccrued for this market's configs\n     * @param _mToken The market to update\n     * @param _borrower The borrower whose index will be updated\n     * @param _sendTokens Whether to send tokens as part of calculating owed rewards\n     */\n    function disburseBorrowerRewards(\n        MToken _mToken,\n        address _borrower,\n        bool _sendTokens\n    ) external onlyComptrollerOrAdmin {\n        disburseBorrowerRewardsInternal(_mToken, _borrower, _sendTokens);\n    }\n\n    /**\n     * @notice Combine the above 2 functions into one that will update the global and user borrower indexes and\n     *         disburse rewards\n     * @param _mToken The market to update\n     * @param _borrower The borrower whose index will be updated\n     * @param _sendTokens Whether to send tokens as part of calculating owed rewards\n     */\n    function updateMarketBorrowIndexAndDisburseBorrowerRewards(\n        MToken _mToken,\n        address _borrower,\n        bool _sendTokens\n    ) external onlyComptrollerOrAdmin {\n        updateMarketBorrowIndexInternal(_mToken);\n        disburseBorrowerRewardsInternal(_mToken, _borrower, _sendTokens);\n    }\n\n    /*\n    ====================================================================================================\n     Pause Guardian API\n\n     The pause guardian tooling is responsible for toggling on and off actual reward emissions. Things\n     will still be accrued as normal, but the `sendRewards` function will simply not attempt to transfer\n     any tokens out.\n\n     Similarly to the pause guardians in the Comptroller, when the pause guardian pops this circuit\n     breaker, only the comptroller's admin is able to unpause things and get tokens emitting again.\n    ====================================================================================================\n     */\n\n    /// @notice Pauses reward sending *but not accrual*\n    function _pauseRewards() external onlyPauseGuardianOrAdmin {\n        _pause();\n\n        emit RewardsPaused();\n    }\n\n    /// @notice Unpauses and allows reward sending once again\n    function _unpauseRewards() external onlyComptrollersAdmin {\n        _unpause();\n\n        emit RewardsUnpaused();\n    }\n\n    /*\n    ====================================================================================================\n     Configuration Owner API\n\n     This is a set of APIs for external parties/emission config owners to update their configs. They're\n     able to transfer ownership, update emission speeds, and update the end time for a campaign. Worth\n     noting, if the endTime is hit, no more rewards will be accrued, BUT you can call `_updateEndTime`\n     to extend the specified campaign - if the campaign has ended already, then rewards will start\n     accruing from the time of reactivation.\n    ====================================================================================================\n     */\n\n    /**\n     * @notice Update the supply emissions for a given mToken + emission token pair.\n     * @param _mToken The market to change a config for\n     * @param _emissionToken The underlying reward token address\n     * @param _newSupplySpeed The supply side emission speed denoted in the underlying emission token's decimals\n     */\n    function _updateSupplySpeed(\n        MToken _mToken,\n        address _emissionToken,\n        uint256 _newSupplySpeed\n    ) external onlyEmissionConfigOwnerOrAdmin(_mToken, _emissionToken) {\n        MarketEmissionConfig\n            storage emissionConfig = fetchConfigByEmissionToken(\n                _mToken,\n                _emissionToken\n            );\n\n        uint256 currentSupplySpeed = emissionConfig\n            .config\n            .supplyEmissionsPerSec;\n\n        require(\n            _newSupplySpeed != currentSupplySpeed,\n            \"Can't set new supply emissions to be equal to current!\"\n        );\n        require(\n            _newSupplySpeed < emissionCap,\n            \"Cannot set a supply reward speed higher than the emission cap!\"\n        );\n\n        // Make sure we update our indices before setting the new speed\n        updateMarketSupplyIndexInternal(_mToken);\n\n        // Update supply speed\n        emissionConfig.config.supplyEmissionsPerSec = _newSupplySpeed;\n\n        emit NewSupplyRewardSpeed(\n            _mToken,\n            _emissionToken,\n            currentSupplySpeed,\n            _newSupplySpeed\n        );\n    }\n\n    /**\n     * @notice Update the borrow emissions for a given mToken + emission token pair.\n     * @param _mToken The market to change a config for\n     * @param _emissionToken The underlying reward token address\n     * @param _newBorrowSpeed The borrow side emission speed denoted in the underlying emission token's decimals\n     */\n    function _updateBorrowSpeed(\n        MToken _mToken,\n        address _emissionToken,\n        uint256 _newBorrowSpeed\n    ) external onlyEmissionConfigOwnerOrAdmin(_mToken, _emissionToken) {\n        MarketEmissionConfig\n            storage emissionConfig = fetchConfigByEmissionToken(\n                _mToken,\n                _emissionToken\n            );\n\n        uint256 currentBorrowSpeed = emissionConfig\n            .config\n            .borrowEmissionsPerSec;\n\n        require(\n            _newBorrowSpeed != currentBorrowSpeed,\n            \"Can't set new borrow emissions to be equal to current!\"\n        );\n        require(\n            _newBorrowSpeed < emissionCap,\n            \"Cannot set a borrow reward speed higher than the emission cap!\"\n        );\n\n        // Make sure we update our indices before setting the new speed\n        updateMarketBorrowIndexInternal(_mToken);\n\n        // Update borrow speed\n        emissionConfig.config.borrowEmissionsPerSec = _newBorrowSpeed;\n\n        emit NewBorrowRewardSpeed(\n            _mToken,\n            _emissionToken,\n            currentBorrowSpeed,\n            _newBorrowSpeed\n        );\n    }\n\n    /**\n     * @notice Update the owner of a config\n     * @param _mToken The market to change a config for\n     * @param _emissionToken The underlying reward token address\n     * @param _newOwner The new owner for this config\n     */\n    function _updateOwner(\n        MToken _mToken,\n        address _emissionToken,\n        address _newOwner\n    ) external onlyEmissionConfigOwnerOrAdmin(_mToken, _emissionToken) {\n        MarketEmissionConfig\n            storage emissionConfig = fetchConfigByEmissionToken(\n                _mToken,\n                _emissionToken\n            );\n\n        address currentOwner = emissionConfig.config.owner;\n\n        emissionConfig.config.owner = _newOwner;\n        emit NewEmissionConfigOwner(\n            _mToken,\n            _emissionToken,\n            currentOwner,\n            _newOwner\n        );\n    }\n\n    /**\n     * @notice Update the end time for an emission campaign, must be in the future\n     * @param _mToken The market to change a config for\n     * @param _emissionToken The underlying reward token address\n     * @param _newEndTime The new desired end time\n     */\n    function _updateEndTime(\n        MToken _mToken,\n        address _emissionToken,\n        uint256 _newEndTime\n    ) external onlyEmissionConfigOwnerOrAdmin(_mToken, _emissionToken) {\n        MarketEmissionConfig\n            storage emissionConfig = fetchConfigByEmissionToken(\n                _mToken,\n                _emissionToken\n            );\n\n        uint256 currentEndTime = emissionConfig.config.endTime;\n\n        // Must be older than our existing end time AND the current block\n        require(\n            _newEndTime > currentEndTime,\n            \"_newEndTime MUST be > currentEndTime\"\n        );\n        require(\n            _newEndTime > block.timestamp,\n            \"_newEndTime MUST be > block.timestamp\"\n        );\n\n        // Update both global indices before setting the new end time. If rewards are off this just updates the\n        // global block timestamp to the current second\n        updateMarketBorrowIndexInternal(_mToken);\n        updateMarketSupplyIndexInternal(_mToken);\n\n        emissionConfig.config.endTime = _newEndTime;\n        emit NewRewardEndTime(\n            _mToken,\n            _emissionToken,\n            currentEndTime,\n            _newEndTime\n        );\n    }\n\n    /*\n    ====================================================================================================\n     Internal functions\n\n     Internal functions used by other parts of this contract, views first then mutation functions\n    ====================================================================================================\n    */\n\n    /**\n     * @notice An internal view to calculate the total owed supplier rewards for a given supplier address\n     * @param _emissionConfig The emission config to read index data from\n     * @param _globalSupplyIndex The global supply index for a market\n     * @param _supplierTokens The amount of this market's mTokens owned by a user\n     * @param _supplier The address of the supplier\n     */\n    function calculateSupplyRewardsForUser(\n        MarketEmissionConfig storage _emissionConfig,\n        uint224 _globalSupplyIndex,\n        uint256 _supplierTokens,\n        address _supplier\n    ) internal view returns (uint256) {\n        uint256 userSupplyIndex = _emissionConfig.supplierIndices[_supplier];\n\n        // If our user's index isn't set yet, set to the current global supply index\n        if (\n            userSupplyIndex == 0 && _globalSupplyIndex >= initialIndexConstant\n        ) {\n            userSupplyIndex = initialIndexConstant; //_globalSupplyIndex;\n        }\n\n        // Calculate change in the cumulative sum of the reward per cToken accrued\n        Double memory deltaIndex = Double({\n            mantissa: sub_(_globalSupplyIndex, userSupplyIndex)\n        });\n\n        // Calculate reward accrued: cTokenAmount * accruedPerCToken\n        uint256 supplierDelta = mul_(_supplierTokens, deltaIndex);\n\n        return\n            add_(\n                _emissionConfig.supplierRewardsAccrued[_supplier],\n                supplierDelta\n            );\n    }\n\n    /**\n     * @notice An internal view to calculate the total owed borrower rewards for a given borrower address\n     * @param _emissionConfig The emission config to read index data from\n     * @param _globalBorrowIndex The global borrow index for a market\n     * @param _marketBorrowIndex The mToken's borrowIndex"
    }
  ]
}