{
  "Title": "[M-03] `onlyOwner` Role Can Unintentionally Influence `settleAuction()`",
  "Content": "_Submitted by leastwood_\n\n#### Impact\n\nThe `onlyOwner` role is able to make changes to the protocol with an immediate affect, while other changes made in `Basket.sol` and `Auction.sol` incur a one day timelock. As a result, an `onlyOwner` role may unintentionally frontrun a `settleAuction()` transaction by making changes to `auctionDecrement` and `auctionMultiplier`, potentially causing the auction bonder to over compensate during a rebalance. Additionally, there is no way for an auction bonder to recover their tokens in the event this does happen.\n\n#### Proof of Concept\n\n- <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L39-L59>\n- <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L99>\n\n#### Tools Used\n\nManual code review\n\n#### Recommended Mitigation Steps\n\nConsider adding a timelock delay to all functions affecting protocol execution. Alternatively, `bondForRebalance()` can set state variables for any external calls made to `Factory.sol` (i.e. `factory.auctionMultiplier()` and `factory.auctionDecrement()`), ensuring that `settleAuction()` is called according to these expected results.\n\n**[frank-beard (Kuiper) acknowledged](https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/192#issuecomment-931571215):**\n> it is assumed the owner is trustworthy in this version of the protocol, however we will add mitigations and further decentralization in future updates\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/192#issuecomment-997205975):**\n> Agree with the finding, users are taking \"owner privileges\" risks while interacting with the protocol.\n> The warden has identified a specific grief / DOS that the owner can cause\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-09-defiProtocol",
  "Code": [
    {
      "filename": "contracts/contracts/Factory.sol",
      "content": "pragma solidity =0.8.7;\n\nimport \"hardhat/console.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\n\ncontract Factory is IFactory, Ownable {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n\n    constructor (IAuction _auctionImpl, IBasket _basketImpl) {\n        auctionImpl = _auctionImpl;\n        basketImpl = _basketImpl;\n        ownerSplit = 0;\n    }\n\n    Proposal[] private _proposals;\n\n    IAuction public override auctionImpl;\n    IBasket public override basketImpl;\n\n    uint256 public override minLicenseFee = 1e15; // 1e15 0.1%\n    uint256 public override auctionDecrement = 10000;\n    uint256 public override auctionMultiplier = 2;\n    uint256 public override bondPercentDiv = 400;\n    uint256 public override ownerSplit;\n\n    function proposal(uint256 proposalId) external override view returns (Proposal memory) {\n        return _proposals[proposalId];\n    }\n\n    function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {\n        minLicenseFee = newMinLicenseFee;\n    }\n\n    function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {\n        auctionDecrement = newAuctionDecrement;\n    }\n\n    function setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {\n        auctionMultiplier = newAuctionMultiplier;\n    }\n\n    function setBondPercentDiv(uint256 newBondPercentDiv) public override onlyOwner {\n        bondPercentDiv = newBondPercentDiv;\n    }\n\n    function setOwnerSplit(uint256 newOwnerSplit) public override onlyOwner {\n        require(newOwnerSplit <= 2e17); // 20%\n\n        ownerSplit = newOwnerSplit;\n    }\n\n    function getProposalWeights(uint256 id) external override view returns (address[] memory, uint256[] memory) {\n        return (_proposals[id].tokens, _proposals[id].weights);\n    }\n\n    function proposeBasketLicense(\n        uint256 licenseFee, \n        string memory tokenName, \n        string memory tokenSymbol, \n        address[] memory tokens,\n        uint256[] memory weights\n    ) public override returns (uint256 id) {\n        basketImpl.validateWeights(tokens, weights);\n\n        require(licenseFee >= minLicenseFee);\n\n        // create proposal object\n        Proposal memory proposal = Proposal({\n            licenseFee: licenseFee,\n            tokenName: tokenName,\n            tokenSymbol: tokenSymbol,\n            proposer: address(msg.sender),\n            tokens: tokens,\n            weights: weights,\n            basket: address(0)\n        });\n\n        emit BasketLicenseProposed(msg.sender, tokenName);\n        _proposals.push(proposal);\n\n        return _proposals.length - 1;\n    }\n\n    function createBasket(uint256 idNumber) external override returns (IBasket) {\n        Proposal memory bProposal = _proposals[idNumber];\n        require(bProposal.basket == address(0));\n\n        IAuction newAuction = IAuction(Clones.clone(address(auctionImpl)));\n        IBasket newBasket = IBasket(Clones.clone(address(basketImpl)));\n\n        newAuction.initialize(address(newBasket), address(this));\n        newBasket.initialize(bProposal, newAuction);\n\n        for (uint256 i = 0; i < bProposal.weights.length; i++) {\n            IERC20 token = IERC20(bProposal.tokens[i]);\n            token.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);\n            token.safeApprove(address(newBasket), bProposal.weights[i]);\n        }\n\n        newBasket.mintTo(BASE, msg.sender);\n\n        _proposals[idNumber].basket = address(newBasket);\n\n        emit BasketCreated(address(newBasket));\n\n        return newBasket;\n    }\n}"
    },
    {
      "filename": "contracts/contracts/Auction.sol",
      "content": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport './interfaces/IFactory.sol';\nimport './interfaces/IBasket.sol';\nimport \"./interfaces/IAuction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Auction is IAuction {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n    uint256 private constant ONE_DAY = 4 * 60 * 24;\n    uint256 private constant BLOCK_DECREMENT = 10000;\n    \n    bool public override auctionOngoing;\n    uint256 public override auctionStart;\n    bool public override hasBonded;\n    uint256 public override bondAmount;\n    uint256 public override bondTimestamp;\n    bool public override initialized;\n\n    IBasket public override basket;\n    IFactory public override factory;\n    address public override auctionBonder;\n\n    Bounty[] private _bounties;\n\n    modifier onlyBasket() {\n        require(msg.sender == address(basket), 'not basket');\n        _;\n    }\n\n    function startAuction() onlyBasket public override {\n        require(auctionOngoing == false, 'ongoing auction');\n\n        auctionOngoing = true;\n        auctionStart = block.number;\n\n        emit AuctionStarted();\n    }\n\n    function killAuction() onlyBasket public override {\n        auctionOngoing = false;\n    }\n\n    function initialize(address basket_, address factory_) public override {\n        require(!initialized);\n        basket = IBasket(basket_);\n        factory = IFactory(factory_);\n        initialized = true;\n    }\n\n    function bondForRebalance() public override {\n        require(auctionOngoing);\n        require(!hasBonded);\n\n        bondTimestamp = block.number;\n\n        IERC20 basketToken = IERC20(address(basket));\n        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        hasBonded = true;\n        auctionBonder = msg.sender;\n\n        emit Bonded(msg.sender, bondAmount);\n    }\n\n    function settleAuction(\n        uint256[] memory bountyIDs,\n        address[] memory inputTokens,\n        uint256[] memory inputWeights,\n        address[] memory outputTokens,\n        uint256[] memory outputWeights\n    ) public override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY > block.number);\n        require(msg.sender == auctionBonder);\n\n        for (uint256 i = 0; i < inputTokens.length; i++) {\n            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);\n        }\n\n        for (uint256 i = 0; i < outputTokens.length; i++) {\n            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n        }\n\n        uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n        uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();\n        uint256 newRatio = a - b;\n\n        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();\n        IERC20 basketAsERC20 = IERC20(address(basket));\n\n        for (uint256 i = 0; i < pendingWeights.length; i++) {\n            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n        }\n\n        basketAsERC20.transfer(msg.sender, bondAmount);\n        withdrawBounty(bountyIDs);\n        basket.setNewWeights();\n        basket.updateIBRatio(newRatio);\n        auctionOngoing = false;\n        hasBonded = false;\n\n        emit AuctionSettled(msg.sender);\n    }\n\n    function bondBurn() external override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY <= block.number);\n\n        basket.auctionBurn(bondAmount);\n        hasBonded = false;\n        auctionOngoing = false;\n        basket.deleteNewIndex();\n\n        emit BondBurned(msg.sender, auctionBonder, bondAmount);\n\n        auctionBonder = address(0);\n    }\n\n    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n        // add bounty to basket\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _bounties.push(Bounty({\n            token: address(token),\n            amount: amount,\n            active: true\n        }));\n\n        uint256 id = _bounties.length - 1;\n        emit BountyAdded(token, amount, id);\n        return id;\n    }\n\n    function withdrawBounty(uint256[] memory bountyIds) internal {\n        // withdraw bounties\n        for (uint256 i = 0; i < bountyIds.length; i++) {\n            Bounty memory bounty = _bounties[bountyIds[i]];\n            require(bounty.active);\n\n            IERC20(bounty.token).transfer(msg.sender, bounty.amount);\n            bounty.active = false;\n\n            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n        }\n    }\n }"
    }
  ]
}