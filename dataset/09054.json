{
  "Title": "[07] Inconsistent way to return values in `_verifyTime()` and `_verifyOrderStatus`",
  "Content": "\nThe functions `_verifyTime()` and `_verifyOrderStatus` use two different ways to return a value. For consistency its better to use the same way every time.\n\n### Proof of Concept\n**Context:** [Verifiers.sol#L37-L55](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/Verifiers.sol#L37-L55), [Verifiers.sol#L102-L139](https://github.com/ProjectOpenSea/seaport/blob/49799ce156d979132c9924a739ae45a38b39ecdd/contracts/lib/Verifiers.sol#L102-L139)\n\n```solidity\nfunction _verifyTime( ... ) internal view returns (bool valid) {\n    ...\n    if ( ... ) { \n        ...\n        // Return false as the order is invalid.\n        return false; // method 1\n    }\n    // Return true as the order time is valid.\n    valid = true; // method 2\n}\n```\n```solidity\nfunction _verifyOrderStatus( ... ) internal pure returns (bool valid) {\n    ...\n    if ( ... ) {\n        // Return false as the order status is invalid.\n        return false; // method 1\n    }\n    // Return true as the order status is valid.\n    valid = true; // method 1\n}\n```\n\n### Recommended Mitigation Steps\nConsider changing the code in the functions `_verifyTime()` and `_verifyOrderStatus` in the following way:\n```diff\n- valid = true;\n+ return true;\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-opensea-seaport",
  "Code": [
    {
      "filename": "contracts/lib/Verifiers.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { OrderStatus } from \"./ConsiderationStructs.sol\";\n\nimport { Assertions } from \"./Assertions.sol\";\n\nimport { SignatureVerification } from \"./SignatureVerification.sol\";\n\n/**\n * @title Verifiers\n * @author 0age\n * @notice Verifiers contains functions for performing verifications.\n */\ncontract Verifiers is Assertions, SignatureVerification {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) Assertions(conduitController) {}\n\n    /**\n     * @dev Internal view function to ensure that the current time falls within\n     *      an order's valid timespan.\n     *\n     * @param startTime       The time at which the order becomes active.\n     * @param endTime         The time at which the order becomes inactive.\n     * @param revertOnInvalid A boolean indicating whether to revert if the\n     *                        order is not active.\n     *\n     * @return valid A boolean indicating whether the order is active.\n     */\n    function _verifyTime(\n        uint256 startTime,\n        uint256 endTime,\n        bool revertOnInvalid\n    ) internal view returns (bool valid) {\n        // Revert if order's timespan hasn't started yet or has already ended.\n        if (startTime > block.timestamp || endTime <= block.timestamp) {\n            // Only revert if revertOnInvalid has been supplied as true.\n            if (revertOnInvalid) {\n                revert InvalidTime();\n            }\n\n            // Return false as the order is invalid.\n            return false;\n        }\n\n        // Return true as the order time is valid.\n        valid = true;\n    }\n\n    /**\n     * @dev Internal view function to verify the signature of an order. An\n     *      ERC-1271 fallback will be attempted if either the signature length\n     *      is not 32 or 33 bytes or if the recovered signer does not match the\n     *      supplied offerer. Note that in cases where a 32 or 33 byte signature\n     *      is supplied, only standard ECDSA signatures that recover to a\n     *      non-zero address are supported.\n     *\n     * @param offerer   The offerer for the order.\n     * @param orderHash The order hash.\n     * @param signature A signature from the offerer indicating that the order\n     *                  has been approved.\n     */\n    function _verifySignature(\n        address offerer,\n        bytes32 orderHash,\n        bytes memory signature\n    ) internal view {\n        // Skip signature verification if the offerer is the caller.\n        if (offerer == msg.sender) {\n            return;\n        }\n\n        // Derive EIP-712 digest using the domain separator and the order hash.\n        bytes32 digest = _deriveEIP712Digest(_domainSeparator(), orderHash);\n\n        // Ensure that the signature for the digest is valid for the offerer.\n        _assertValidSignature(offerer, digest, signature);\n    }\n\n    /**\n     * @dev Internal pure function to validate that a given order is fillable\n     *      and not cancelled based on the order status.\n     *\n     * @param orderHash       The order hash.\n     * @param orderStatus     The status of the order, including whether it has\n     *                        been cancelled and the fraction filled.\n     * @param onlyAllowUnused A boolean flag indicating whether partial fills\n     *                        are supported by the calling function.\n     * @param revertOnInvalid A boolean indicating whether to revert if the\n     *                        order has been cancelled or filled beyond the\n     *                        allowable amount.\n     *\n     * @return valid A boolean indicating whether the order is valid.\n     */\n    function _verifyOrderStatus(\n        bytes32 orderHash,\n        OrderStatus memory orderStatus,\n        bool onlyAllowUnused,\n        bool revertOnInvalid\n    ) internal pure returns (bool valid) {\n        // Ensure that the order has not been cancelled.\n        if (orderStatus.isCancelled) {\n            // Only revert if revertOnInvalid has been supplied as true.\n            if (revertOnInvalid) {\n                revert OrderIsCancelled(orderHash);\n            }\n\n            // Return false as the order status is invalid.\n            return false;\n        }\n\n        // If the order is not entirely unused...\n        if (orderStatus.numerator != 0) {\n            // ensure the order has not been partially filled when not allowed.\n            if (onlyAllowUnused) {\n                // Always revert on partial fills when onlyAllowUnused is true.\n                revert OrderPartiallyFilled(orderHash);\n                // Otherwise, ensure that order has not been entirely filled.\n            } else if (orderStatus.numerator >= orderStatus.denominator) {\n                // Only revert if revertOnInvalid has been supplied as true.\n                if (revertOnInvalid) {\n                    revert OrderAlreadyFilled(orderHash);\n                }\n\n                // Return false as the order status is invalid.\n                return false;\n            }\n        }\n\n        // Return true as the order status is valid.\n        valid = true;\n    }\n}"
    }
  ]
}