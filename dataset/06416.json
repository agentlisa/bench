{
  "Title": "[M-02] `pause/unpause` functionalities not implemented in many pausable contracts",
  "Content": "\n<https://github.com/code-423n4/2023-06-stader/blob/main/contracts/SocializingPool.sol#L21> <br><https://github.com/code-423n4/2023-06-stader/blob/main/contracts/Auction.sol#L14> <br><https://github.com/code-423n4/2023-06-stader/blob/main/contracts/StaderOracle.sol#L17><br><https://github.com/code-423n4/2023-06-stader/blob/main/contracts/OperatorRewardsCollector.sol#L16>\n\nThe following contracts: `SocializingPool`, `StaderOracle`, `OperatorRewardsCollector` and `Auction` are supposed to be pausable (as they all inherit from `PausableUpgradeable`), but they don't implement the external `pause/unpause` functionalities which means it will never be possible to pause them.\n\n### Proof of Concept\n\nAll the following contracts `SocializingPool`, `StaderOracle`, `OperatorRewardsCollector` and `Auction` inherit from the openzeppelin `PausableUpgradeable` extension which means that they contain internal functions `_pause` and `_unpause`.\n\nBecause those functions are internal, the contract must implement two other public/external `pause` and `unpause` functions to allow the manager to pause and unpause the contracts when necessary. None of the aforementioned contracts implement those functions, which means even if those contracts are supposed to be pausable (and have the `pause/unpause` functionalities), none of them can be paused.\n\n### Recommended Mitigation Steps\n\nAdd public/external `pause` and `unpause` functions in the aforementioned contracts to allow them to be pausable, this can be done as in the `UserWithdrawalManager` contract. For example:\n\n```solidity\n/**\n * @dev Triggers stopped state.\n * Contract must not be paused\n */\nfunction pause() external {\n    UtilLib.onlyManagerRole(msg.sender, staderConfig);\n    _pause();\n}\n\n/**\n * @dev Returns to normal state.\n * Contract must be paused\n */\nfunction unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n}\n```\n\n**[Picodes (judge) decreased severity to Medium](https://github.com/code-423n4/2022-06-stader-findings/issues/383#issuecomment-1591842271)**\n\n**[manoj9april (Stader) confirmed and commented](https://github.com/code-423n4/2022-06-stader-findings/issues/383#issuecomment-1598354461):**\n > Thanks!\n> We will fix this.\n\n**[sanjay-staderlabs (Stader) commented](https://github.com/code-423n4/2023-06-stader-findings/issues/383#issuecomment-1633520592):**\n>This is fixed.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-stader",
  "Code": [
    {
      "filename": "contracts/SocializingPool.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\n\nimport './interfaces/ISocializingPool.sol';\nimport './interfaces/IStaderStakePoolManager.sol';\nimport './interfaces/IPermissionlessNodeRegistry.sol';\n\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ncontract SocializingPool is\n    ISocializingPool,\n    Initializable,\n    AccessControlUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    IStaderConfig public override staderConfig;\n    uint256 public override totalOperatorETHRewardsRemaining;\n    uint256 public override totalOperatorSDRewardsRemaining;\n    uint256 public override initialBlock;\n\n    mapping(address => mapping(uint256 => bool)) public override claimedRewards;\n    mapping(uint256 => bool) public handledRewards;\n    RewardsData public lastReportedRewardsData;\n    mapping(uint256 => RewardsData) public rewardsDataMap;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _admin, address _staderConfig) public initializer {\n        UtilLib.checkNonZeroAddress(_admin);\n        UtilLib.checkNonZeroAddress(_staderConfig);\n\n        __AccessControl_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        staderConfig = IStaderConfig(_staderConfig);\n        initialBlock = block.number;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n\n    /**\n     * @notice Allows the contract to receive ETH\n     * @dev execution layer rewards may be sent as plain ETH transfers\n     */\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n\n    function handleRewards(RewardsData calldata _rewardsData) external override nonReentrant {\n        UtilLib.onlyStaderContract(msg.sender, staderConfig, staderConfig.STADER_ORACLE());\n\n        if (handledRewards[_rewardsData.index]) {\n            revert RewardAlreadyHandled();\n        }\n        if (\n            _rewardsData.operatorETHRewards + _rewardsData.userETHRewards + _rewardsData.protocolETHRewards >\n            address(this).balance - totalOperatorETHRewardsRemaining\n        ) {\n            revert InsufficientETHRewards();\n        }\n        if (\n            _rewardsData.operatorSDRewards >\n            IERC20(staderConfig.getStaderToken()).balanceOf(address(this)) - totalOperatorSDRewardsRemaining\n        ) {\n            revert InsufficientSDRewards();\n        }\n\n        handledRewards[_rewardsData.index] = true;\n        totalOperatorETHRewardsRemaining += _rewardsData.operatorETHRewards;\n        totalOperatorSDRewardsRemaining += _rewardsData.operatorSDRewards;\n\n        lastReportedRewardsData = _rewardsData;\n        rewardsDataMap[_rewardsData.index] = _rewardsData;\n\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveExecutionLayerRewards{\n            value: _rewardsData.userETHRewards\n        }();\n\n        (bool success, ) = payable(staderConfig.getStaderTreasury()).call{value: _rewardsData.protocolETHRewards}('');\n        if (!success) {\n            revert ETHTransferFailed(staderConfig.getStaderTreasury(), _rewardsData.protocolETHRewards);\n        }\n\n        emit OperatorRewardsUpdated(\n            _rewardsData.operatorETHRewards,\n            totalOperatorETHRewardsRemaining,\n            _rewardsData.operatorSDRewards,\n            totalOperatorSDRewardsRemaining\n        );\n\n        emit UserETHRewardsTransferred(_rewardsData.userETHRewards);\n        emit ProtocolETHRewardsTransferred(_rewardsData.protocolETHRewards);\n    }\n\n    function claim(\n        uint256[] calldata _index,\n        uint256[] calldata _amountSD,\n        uint256[] calldata _amountETH,\n        bytes32[][] calldata _merkleProof\n    ) external override nonReentrant whenNotPaused {\n        address operator = msg.sender;\n        (uint256 totalAmountSD, uint256 totalAmountETH) = _claim(_index, operator, _amountSD, _amountETH, _merkleProof);\n\n        address operatorRewardsAddr = UtilLib.getOperatorRewardAddress(operator, staderConfig);\n\n        bool success;\n        if (totalAmountETH > 0) {\n            totalOperatorETHRewardsRemaining -= totalAmountETH;\n            (success, ) = payable(operatorRewardsAddr).call{value: totalAmountETH}('');\n            if (!success) {\n                revert ETHTransferFailed(operatorRewardsAddr, totalAmountETH);\n            }\n        }\n\n        if (totalAmountSD > 0) {\n            totalOperatorSDRewardsRemaining -= totalAmountSD;\n            if (!IERC20(staderConfig.getStaderToken()).transfer(operatorRewardsAddr, totalAmountSD)) {\n                revert SDTransferFailed();\n            }\n        }\n\n        emit OperatorRewardsClaimed(operatorRewardsAddr, totalAmountETH, totalAmountSD);\n    }\n\n    function _claim(\n        uint256[] calldata _index,\n        address _operator,\n        uint256[] calldata _amountSD,\n        uint256[] calldata _amountETH,\n        bytes32[][] calldata _merkleProof\n    ) internal returns (uint256 _totalAmountSD, uint256 _totalAmountETH) {\n        uint256 indexLength = _index.length;\n        for (uint256 i = 0; i < indexLength; i++) {\n            if (_amountSD[i] == 0 && _amountETH[i] == 0) {\n                revert InvalidAmount();\n            }\n            if (claimedRewards[_operator][_index[i]]) {\n                revert RewardAlreadyClaimed(_operator, _index[i]);\n            }\n\n            _totalAmountSD += _amountSD[i];\n            _totalAmountETH += _amountETH[i];\n            claimedRewards[_operator][_index[i]] = true;\n\n            if (!verifyProof(_index[i], _operator, _amountSD[i], _amountETH[i], _merkleProof[i])) {\n                revert InvalidProof(_index[i], _operator);\n            }\n        }\n    }\n\n    function verifyProof(\n        uint256 _index,\n        address _operator,\n        uint256 _amountSD,\n        uint256 _amountETH,\n        bytes32[] calldata _merkleProof\n    ) public view returns (bool) {\n        if (_index == 0 || _index > lastReportedRewardsData.index) {\n            revert InvalidCycleIndex();\n        }\n        bytes32 merkleRoot = rewardsDataMap[_index].merkleRoot;\n        bytes32 node = keccak256(abi.encodePacked(_operator, _amountSD, _amountETH));\n        return MerkleProofUpgradeable.verify(_merkleProof, merkleRoot, node);\n    }\n\n    // SETTERS\n    function updateStaderConfig(address _staderConfig) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        UtilLib.checkNonZeroAddress(_staderConfig);\n        staderConfig = IStaderConfig(_staderConfig);\n        emit UpdatedStaderConfig(_staderConfig);\n    }\n\n    // GETTERS\n\n    function getCurrentRewardsIndex() public view returns (uint256 index) {\n        index = lastReportedRewardsData.index + 1;\n    }\n\n    function getRewardDetails()\n        external\n        view\n        override\n        returns (\n            uint256 currentIndex,\n            uint256 currentStartBlock,\n            uint256 currentEndBlock\n        )\n    {\n        currentIndex = getCurrentRewardsIndex();\n        (currentStartBlock, currentEndBlock) = getRewardCycleDetails(currentIndex);\n    }\n\n    /// @param _index reward cycle index for which details is required\n    function getRewardCycleDetails(uint256 _index) public view returns (uint256 _startBlock, uint256 _endBlock) {\n        if (_index == 0) {\n            revert InvalidCycleIndex();\n        }\n        uint256 cycleDuration = staderConfig.getSocializingPoolCycleDuration();\n        // for 1st cycle\n        if (_index == 1) {\n            return (initialBlock, initialBlock + cycleDuration);\n        }\n\n        // for past cycles\n        _startBlock = rewardsDataMap[_index - 1].reportingBlockNumber + 1;\n        _endBlock = rewardsDataMap[_index].reportingBlockNumber;\n\n        // for current cycle\n        if (rewardsDataMap[_index].reportingBlockNumber == 0) {\n            if (rewardsDataMap[_index - 1].reportingBlockNumber == 0) {\n                revert FutureCycleIndex();\n            }\n            _endBlock = rewardsDataMap[_index - 1].reportingBlockNumber + cycleDuration;\n        }\n    }\n}"
    }
  ]
}