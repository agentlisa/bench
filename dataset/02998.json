{
  "Title": "M-12: Vault Share/Strategy Token Calculation Can Be Broken By First User/Attacker",
  "Content": "# Issue M-12: Vault Share/Strategy Token Calculation Can Be Broken By First User/Attacker \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/70 \n\n## Found by \nxiaoming90\n\n## Summary\n\nA well-known attack vector for almost all shares-based liquidity pool contracts, where an early user can manipulate the price per share and profit from late users' deposits because of the precision loss caused by the rather large value of price per share.\n\n## Vulnerability Detail\n\n> Note: This issue affects MetaStable2 and Boosted3 balancer leverage vaults\n\nFor simplicity's sake, we will simplify the strategy token minting formula as follows. Also, assume that the 1 vault share is equivalent to 1 strategy token for this particular strategy vault, therefore, we will use the term `vault share` and `strategy token` interchangeably here.\n\n```solidity\nstrategyToken = (totalBPTHeld == 0) ?  bptClaim : (bptClaim * totalStrategyToken) / totalBPTHeld\n```\n\nThe vault minting formula is taken from the following:\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/strategy/StrategyUtils.sol#L27\n\n```solidity\nFile: StrategyUtils.sol\n26:     /// @notice Converts BPT to strategy tokens\n27:     function _convertBPTClaimToStrategyTokens(StrategyContext memory context, uint256 bptClaim)\n28:         internal pure returns (uint256 strategyTokenAmount) {\n29:         if (context.totalBPTHeld == 0) {\n30:             // Strategy tokens are in 8 decimal precision, BPT is in 18. Scale the minted amount down.\n31:             return (bptClaim * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / \n32:                 BalancerConstants.BALANCER_PRECISION;\n33:         }\n34: \n35:         // BPT held in maturity is calculated before the new BPT tokens are minted, so this calculation\n36:         // is the tokens minted that will give the account a corresponding share of the new bpt balance held.\n37:         // The precision here will be the same as strategy token supply.\n38:         strategyTokenAmount = (bptClaim * context.vaultState.totalStrategyTokenGlobal) / context.totalBPTHeld;\n39:     }\n```\n\nIf the attacker who is the first depositor claims 1 BPT, he will receive 1 Strategy Token. So 1 BPT per Strategy Token. At this point in time, `totalBPTHeld = 1` and `totalStrategyToken = 1`.\n\nThe attacker obtains 9999 BPT can be obtained from the open market. He proceeds to deposit the 9999 BPT into the Aura reward pool on behalf of the vault. At this point in time, `totalBPTHeld = 10000` and `totalStrategyToken = 1`. So 10000 BPT per Strategy Token. Refer to the \"How to increase the total BPT held?\" section below for more details.\n\nTwo issues can occur from here.\n\n#### Issue 1 - If bptClaim >= totalBPTHeld\n\nThe following describes a scenario in which a user's assets are lost and stolen by an attacker. Assume that Alice deposits/borrow some assets and received 19999 BPT. Based on the formula, Alice will only receive 1 Strategy Token. She immediately loses 9999 BPT or half of her assets if she exits the vault or redeems the strategy tokens right after the deposit.\n\n```solidity\nstrategyToken = (bptClaim * totalStrategyToken) / totalBPTHeld\nstrategyToken = (19999 * 1) / 10000 = 1\n```\n\n If the attacker exits the vault right after Alice's deposit, the attacker will receive 14999 BPT. He profited 4999 BPT from this attack\n\n```solidity\nbptReceived = (strategyToken * totalBPTHeld) / totalStrategyToken\nbptReceived = (1 * 29999) / 2 = 14999\n```\n\n#### Issue 2 - If bptClaim < totalBPTHeld\n\nThe following describes a scenario in which a user's assets are lost entirely. Assume that Alice deposits/borrow some assets and received 9999 BPT\n\n```solidity\nstrategyToken = (bptClaim * totalStrategyToken) / totalBPTHeld\nstrategyToken = (9999  * 1) / 10000 = 0\n```\n\nAs such,  she deposited 9999 BPT but did not receive any strategy tokens in return.\n\n#### How to increase the total BPT held?\n\nUnlike the vault design seen in other protocols, Notional's leverage vault does not compute the total BPT held by the vault directly via `BTP.balanceOf(address(vault))`. The vault deposit its BPT to the Aura Reward Pool. Therefore, it is not possible to increase the total BPT held by the vault simply by performing a direct BPT token transfer to the vault or Aura Reward Pool in an attempt to increase it.\n\nHowever, there is a workaround to increase the total BPT held by the vault, and this can be executed by anyone.\n\nThe `totalBPTHeld` within the vault is obtained by calling the `PoolMixin._bptHeld` function.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/PoolMixin.sol#L41\n\n```solidity\nFile: PoolMixin.sol\n41:     function _baseStrategyContext() internal view returns(StrategyContext memory) {\n42:         return StrategyContext({\n43:             totalBPTHeld: _bptHeld(),\n44:             settlementPeriodInSeconds: SETTLEMENT_PERIOD_IN_SECONDS,\n45:             tradingModule: TRADING_MODULE,\n46:             vaultSettings: BalancerVaultStorage.getStrategyVaultSettings(),\n47:             vaultState: BalancerVaultStorage.getStrategyVaultState(),\n48:             feeReceiver: FEE_RECEIVER\n49:         });\n50:     }\n```\n\nWithin the `PoolMixin._bptHeld` function, it will call the `AURA_REWARD_POOL.balanceOf(address(this))` to retrieve the number of BPT that the vault has deposited into the Aura Reward Pool.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/PoolMixin.sol#L37\n\n```solidity\nFile: PoolMixin.sol\n36:     /// @dev Gets the total BPT held by the aura reward pool\n37:     function _bptHeld() internal view returns (uint256) {\n38:         return AURA_REWARD_POOL.balanceOf(address(this));\n39:     }\n```\n\nThe following is the contract of the AURA_REWARD_POOL taken from the Etherscan. Note that the `AURA_REWARD_POOL.balanceOf` will retrieve the number of BPT tokens held by an account. In this example, the account will be the vault's address.\n\nhttps://etherscan.io/address/0xdcee1c640cc270121faf145f231fd8ff1d8d5cd4#code\n\n```solidity\nFile: BaseRewardPool4626.sol\n/**\n * @dev Returns the amount of tokens owned by `account`.\n */\nfunction balanceOf(address account) public view override(BaseRewardPool, IERC20) returns (uint256) {\n    return BaseRewardPool.balanceOf(account);\n}\n```\n\n```solidity\nFile: BaseRewardPool.sol\nfunction balanceOf(address account) public view virtual returns (uint256) {\n\treturn _balances[account];\n}\n```\n\nTo increase the balance, the `deposit(uint256 _pid, uint256 _amount, bool _stake)` function of Aura's Booster contract can be called. However, the problem is that this function will deposit to the `msg.sender` and there is no way to spoof the vault's address. Thus, using this function will not work.\n\nHowever, there is a second method that can be used to perform a deposit. The `AURA_REWARD_POOL ` point to the `BaseRewardPool4626`, thus the reward pool is an ERC4626 vault. The Aura's ERC4626 vault supports an alternative deposit function called `BaseRewardPool4626.deposit` that allows anyone to deposit on behalf of another account. An attacker can leverage the `BaseRewardPool4626.deposit` function by specifying the `receiver` parameter to be the `vault.address` in an attempt to increase the total BPT tokens held by the vault.\n\nhttps://etherscan.io/address/0xdcee1c640cc270121faf145f231fd8ff1d8d5cd4#code\n\n```solidity\nFile: BaseRewardPool4626.sol\n/**\n * @notice Mints `shares` Vault shares to `receiver`.\n * @dev Because `asset` is not actually what is collected here, first wrap to required token in the booster.\n */\nfunction deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {\n    // Transfer \"asset\" (crvLP) from sender\n    IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n    // Convert crvLP to cvxLP through normal booster deposit process, but don't stake\n    uint256 balBefore = stakingToken.balanceOf(address(this));\n    IDeposit(operator).deposit(pid, assets, false);\n    uint256 balAfter = stakingToken.balanceOf(address(this));\n\n    require(balAfter.sub(balBefore) >= assets, \"!deposit\");\n\n    // Perform stake manually, now that the funds have been received\n    _processStake(assets, receiver);\n\n    emit Deposit(msg.sender, receiver, assets, assets);\n    emit Staked(receiver, assets);\n    return assets;\n}\n```\n\n```solidity\nFile: BaseRewardPool.sol \n/**\n* @dev Generic internal staking function that basically does 3 things: update rewards based\n*      on previous balance, trigger also on any child contracts, then update balances.\n* @param _amount    Units to add to the users balance\n* @param _receiver  Address of user who will receive the stake\n*/\nfunction _processStake(uint256 _amount, address _receiver) internal updateReward(_receiver) {\n    require(_amount > 0, 'RewardPool : Cannot stake 0');\n\n    //also stake to linked rewards\n    for(uint i=0; i < extraRewards.length; i++){\n    IRewards(extraRewards[i]).stake(_receiver, _amount);\n    }\n\n    _totalSupply = _totalSupply.add(_amount);\n    _balances[_receiver] = _balances[_receiver].add(_amount);\n}\n```\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/strategy/StrategyUtils.sol#L27\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/PoolMixin.sol#L41\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/PoolMixin.sol#L37\n\n## Tool used\n\nManual Review\n\n## Impact\n\nThe attacker can profit from future users' deposits while the late users will lose part of their funds to the attacker. Additionally, it is also possible for users to get no share in return for their deposited funds.\n\n## Recommendation\n\nConsider requiring a minimal amount of strategy tokens to be minted for the first minter, and send a portion of the initial mints as a reserve to the Notional Treasury so that the pricePerShare/pricePerStrategyToken can be more resistant to manipulation.\n\n#### Reference\n\nA similar issue was found in a past Sherlock audit\n\n- https://github.com/sherlock-audit/2022-08-sentiment-judging#issue-h-1-a-malicious-early-userattacker-can-manipulate-the-ltokens-pricepershare-to-take-an-unfair-share-of-future-users-deposits\n\n## Discussion\n\n**jeffywu**\n\n@T-Woodward / @weitianjie2000 \n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/strategy/StrategyUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport { StrategyContext, DynamicTradeParams } from \"../../BalancerVaultTypes.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {ITradingModule, Trade, TradeType} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary StrategyUtils {\n    using TradeHandler for Trade;\n    using TokenUtils for IERC20;\n\n    /// @notice Converts strategy tokens to BPT\n    function _convertStrategyTokensToBPTClaim(StrategyContext memory context, uint256 strategyTokenAmount)\n        internal pure returns (uint256 bptClaim) {\n        require(strategyTokenAmount <= context.vaultState.totalStrategyTokenGlobal);\n        if (context.vaultState.totalStrategyTokenGlobal > 0) {\n            bptClaim = (strategyTokenAmount * context.totalBPTHeld) / context.vaultState.totalStrategyTokenGlobal;\n        }\n    }\n\n    /// @notice Converts BPT to strategy tokens\n    function _convertBPTClaimToStrategyTokens(StrategyContext memory context, uint256 bptClaim)\n        internal pure returns (uint256 strategyTokenAmount) {\n        if (context.totalBPTHeld == 0) {\n            // Strategy tokens are in 8 decimal precision, BPT is in 18. Scale the minted amount down.\n            return (bptClaim * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / \n                BalancerConstants.BALANCER_PRECISION;\n        }\n\n        // BPT held in maturity is calculated before the new BPT tokens are minted, so this calculation\n        // is the tokens minted that will give the account a corresponding share of the new bpt balance held.\n        // The precision here will be the same as strategy token supply.\n        strategyTokenAmount = (bptClaim * context.vaultState.totalStrategyTokenGlobal) / context.totalBPTHeld;\n    }\n\n    function _executeDynamicTradeExactIn(\n        DynamicTradeParams memory params,\n        ITradingModule tradingModule,\n        address sellToken,\n        address buyToken,\n        uint256 amount\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        require(\n            params.tradeType == TradeType.EXACT_IN_SINGLE || params.tradeType == TradeType.EXACT_IN_BATCH\n        );\n\n        // stETH generally has deeper liquidity than wstETH, setting tradeUnwrapped\n        // to lets the contract trade in stETH instead of wstETH\n        if (params.tradeUnwrapped && sellToken == address(Deployments.WRAPPED_STETH)) {\n            sellToken = Deployments.WRAPPED_STETH.stETH();\n            uint256 unwrappedAmount = IERC20(sellToken).balanceOf(address(this));\n            // NOTE: the amount returned by unwrap is not always accurate for some reason\n            Deployments.WRAPPED_STETH.unwrap(amount);\n            amount = IERC20(sellToken).balanceOf(address(this)) - unwrappedAmount;\n        }\n        if (params.tradeUnwrapped && buyToken == address(Deployments.WRAPPED_STETH)) {\n            buyToken = Deployments.WRAPPED_STETH.stETH();\n        }\n\n        // Sell residual secondary balance\n        Trade memory trade = Trade(\n            params.tradeType,\n            sellToken,\n            buyToken,\n            amount,\n            0,\n            block.timestamp, // deadline\n            params.exchangeData\n        );\n\n        (amountSold, amountBought) = trade._executeTradeWithDynamicSlippage(\n            params.dexId, tradingModule, params.oracleSlippagePercent\n        );\n\n        if (\n            params.tradeUnwrapped && \n            buyToken == address(Deployments.WRAPPED_STETH) && \n            amountBought > 0\n        ) {\n            IERC20(buyToken).checkApprove(address(Deployments.WRAPPED_STETH), amountBought);\n            uint256 wrappedAmount = Deployments.WRAPPED_STETH.balanceOf(address(this));\n            /// @notice the amount returned by wrap is not always accurate for some reason\n            Deployments.WRAPPED_STETH.wrap(amountBought);\n            amountBought = Deployments.WRAPPED_STETH.balanceOf(address(this)) - wrappedAmount;\n        }\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/mixins/PoolMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\nimport {PoolContext, AuraVaultDeploymentParams, StrategyContext} from \"../BalancerVaultTypes.sol\";\nimport {Deployments} from \"../../../global/Deployments.sol\";\nimport {BalancerStrategyBase} from \"../BalancerStrategyBase.sol\";\nimport {NotionalProxy} from \"../../../../interfaces/notional/NotionalProxy.sol\";\nimport {AuraStakingMixin} from \"./AuraStakingMixin.sol\";\nimport {BalancerVaultStorage} from \"../internal/BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"../internal/strategy/StrategyUtils.sol\";\n\nabstract contract PoolMixin is AuraStakingMixin, BalancerStrategyBase {\n    using StrategyUtils for StrategyContext;\n\n    bytes32 internal immutable BALANCER_POOL_ID;\n    IERC20 internal immutable BALANCER_POOL_TOKEN;\n\n    constructor(NotionalProxy notional_, AuraVaultDeploymentParams memory params) \n        AuraStakingMixin(\n            params.baseParams.liquidityGauge, params.auraRewardPool, params.baseParams.feeReceiver\n        )\n        BalancerStrategyBase(notional_, params.baseParams) {\n        BALANCER_POOL_ID = params.baseParams.balancerPoolId;\n        (address pool, /* */) = Deployments.BALANCER_VAULT.getPool(params.baseParams.balancerPoolId);\n        BALANCER_POOL_TOKEN = IERC20(pool);\n    }\n\n    function _poolContext() internal view returns (PoolContext memory) {\n        return PoolContext({\n            pool: BALANCER_POOL_TOKEN,\n            poolId: BALANCER_POOL_ID\n        });\n    }\n\n    /// @dev Gets the total BPT held by the aura reward pool\n    function _bptHeld() internal view returns (uint256) {\n        return AURA_REWARD_POOL.balanceOf(address(this));\n    }\n\n    function _baseStrategyContext() internal view returns(StrategyContext memory) {\n        return StrategyContext({\n            totalBPTHeld: _bptHeld(),\n            settlementPeriodInSeconds: SETTLEMENT_PERIOD_IN_SECONDS,\n            tradingModule: TRADING_MODULE,\n            vaultSettings: BalancerVaultStorage.getStrategyVaultSettings(),\n            vaultState: BalancerVaultStorage.getStrategyVaultState(),\n            feeReceiver: FEE_RECEIVER\n        });\n    }\n\n    /// @notice Converts BPT to strategy tokens\n    function convertBPTClaimToStrategyTokens(uint256 bptClaim)\n        external view returns (uint256 strategyTokenAmount) {\n        return _baseStrategyContext()._convertBPTClaimToStrategyTokens(bptClaim);\n    }\n\n    /// @notice Converts strategy tokens to BPT\n    function convertStrategyTokensToBPTClaim(uint256 strategyTokenAmount) \n        external view returns (uint256 bptClaim) {\n        return _baseStrategyContext()._convertStrategyTokensToBPTClaim(strategyTokenAmount);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/mixins/PoolMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\nimport {PoolContext, AuraVaultDeploymentParams, StrategyContext} from \"../BalancerVaultTypes.sol\";\nimport {Deployments} from \"../../../global/Deployments.sol\";\nimport {BalancerStrategyBase} from \"../BalancerStrategyBase.sol\";\nimport {NotionalProxy} from \"../../../../interfaces/notional/NotionalProxy.sol\";\nimport {AuraStakingMixin} from \"./AuraStakingMixin.sol\";\nimport {BalancerVaultStorage} from \"../internal/BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"../internal/strategy/StrategyUtils.sol\";\n\nabstract contract PoolMixin is AuraStakingMixin, BalancerStrategyBase {\n    using StrategyUtils for StrategyContext;\n\n    bytes32 internal immutable BALANCER_POOL_ID;\n    IERC20 internal immutable BALANCER_POOL_TOKEN;\n\n    constructor(NotionalProxy notional_, AuraVaultDeploymentParams memory params) \n        AuraStakingMixin(\n            params.baseParams.liquidityGauge, params.auraRewardPool, params.baseParams.feeReceiver\n        )\n        BalancerStrategyBase(notional_, params.baseParams) {\n        BALANCER_POOL_ID = params.baseParams.balancerPoolId;\n        (address pool, /* */) = Deployments.BALANCER_VAULT.getPool(params.baseParams.balancerPoolId);\n        BALANCER_POOL_TOKEN = IERC20(pool);\n    }\n\n    function _poolContext() internal view returns (PoolContext memory) {\n        return PoolContext({\n            pool: BALANCER_POOL_TOKEN,\n            poolId: BALANCER_POOL_ID\n        });\n    }\n\n    /// @dev Gets the total BPT held by the aura reward pool\n    function _bptHeld() internal view returns (uint256) {\n        return AURA_REWARD_POOL.balanceOf(address(this));\n    }\n\n    function _baseStrategyContext() internal view returns(StrategyContext memory) {\n        return StrategyContext({\n            totalBPTHeld: _bptHeld(),\n            settlementPeriodInSeconds: SETTLEMENT_PERIOD_IN_SECONDS,\n            tradingModule: TRADING_MODULE,\n            vaultSettings: BalancerVaultStorage.getStrategyVaultSettings(),\n            vaultState: BalancerVaultStorage.getStrategyVaultState(),\n            feeReceiver: FEE_RECEIVER\n        });\n    }\n\n    /// @notice Converts BPT to strategy tokens\n    function convertBPTClaimToStrategyTokens(uint256 bptClaim)\n        external view returns (uint256 strategyTokenAmount) {\n        return _baseStrategyContext()._convertBPTClaimToStrategyTokens(bptClaim);\n    }\n\n    /// @notice Converts strategy tokens to BPT\n    function convertStrategyTokensToBPTClaim(uint256 strategyTokenAmount) \n        external view returns (uint256 bptClaim) {\n        return _baseStrategyContext()._convertStrategyTokensToBPTClaim(strategyTokenAmount);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/strategy/StrategyUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport { StrategyContext, DynamicTradeParams } from \"../../BalancerVaultTypes.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {ITradingModule, Trade, TradeType} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary StrategyUtils {\n    using TradeHandler for Trade;\n    using TokenUtils for IERC20;\n\n    /// @notice Converts strategy tokens to BPT\n    function _convertStrategyTokensToBPTClaim(StrategyContext memory context, uint256 strategyTokenAmount)\n        internal pure returns (uint256 bptClaim) {\n        require(strategyTokenAmount <= context.vaultState.totalStrategyTokenGlobal);\n        if (context.vaultState.totalStrategyTokenGlobal > 0) {\n            bptClaim = (strategyTokenAmount * context.totalBPTHeld) / context.vaultState.totalStrategyTokenGlobal;\n        }\n    }\n\n    /// @notice Converts BPT to strategy tokens\n    function _convertBPTClaimToStrategyTokens(StrategyContext memory context, uint256 bptClaim)\n        internal pure returns (uint256 strategyTokenAmount) {\n        if (context.totalBPTHeld == 0) {\n            // Strategy tokens are in 8 decimal precision, BPT is in 18. Scale the minted amount down.\n            return (bptClaim * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / \n                BalancerConstants.BALANCER_PRECISION;\n        }\n\n        // BPT held in maturity is calculated before the new BPT tokens are minted, so this calculation\n        // is the tokens minted that will give the account a corresponding share of the new bpt balance held.\n        // The precision here will be the same as strategy token supply.\n        strategyTokenAmount = (bptClaim * context.vaultState.totalStrategyTokenGlobal) / context.totalBPTHeld;\n    }\n\n    function _executeDynamicTradeExactIn(\n        DynamicTradeParams memory params,\n        ITradingModule tradingModule,\n        address sellToken,\n        address buyToken,\n        uint256 amount\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        require(\n            params.tradeType == TradeType.EXACT_IN_SINGLE || params.tradeType == TradeType.EXACT_IN_BATCH\n        );\n\n        // stETH generally has deeper liquidity than wstETH, setting tradeUnwrapped\n        // to lets the contract trade in stETH instead of wstETH\n        if (params.tradeUnwrapped && sellToken == address(Deployments.WRAPPED_STETH)) {\n            sellToken = Deployments.WRAPPED_STETH.stETH();\n            uint256 unwrappedAmount = IERC20(sellToken).balanceOf(address(this));\n            // NOTE: the amount returned by unwrap is not always accurate for some reason\n            Deployments.WRAPPED_STETH.unwrap(amount);\n            amount = IERC20(sellToken).balanceOf(address(this)) - unwrappedAmount;\n        }\n        if (params.tradeUnwrapped && buyToken == address(Deployments.WRAPPED_STETH)) {\n            buyToken = Deployments.WRAPPED_STETH.stETH();\n        }\n\n        // Sell residual secondary balance\n        Trade memory trade = Trade(\n            params.tradeType,\n            sellToken,\n            buyToken,\n            amount,\n            0,\n            block.timestamp, // deadline\n            params.exchangeData\n        );\n\n        (amountSold, amountBought) = trade._executeTradeWithDynamicSlippage(\n            params.dexId, tradingModule, params.oracleSlippagePercent\n        );\n\n        if (\n            params.tradeUnwrapped && \n            buyToken == address(Deployments.WRAPPED_STETH) && \n            amountBought > 0\n        ) {\n            IERC20(buyToken).checkApprove(address(Deployments.WRAPPED_STETH), amountBought);\n            uint256 wrappedAmount = Deployments.WRAPPED_STETH.balanceOf(address(this));\n            /// @notice the amount returned by wrap is not always accurate for some reason\n            Deployments.WRAPPED_STETH.wrap(amountBought);\n            amountBought = Deployments.WRAPPED_STETH.balanceOf(address(this)) - wrappedAmount;\n        }\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/mixins/PoolMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\nimport {PoolContext, AuraVaultDeploymentParams, StrategyContext} from \"../BalancerVaultTypes.sol\";\nimport {Deployments} from \"../../../global/Deployments.sol\";\nimport {BalancerStrategyBase} from \"../BalancerStrategyBase.sol\";\nimport {NotionalProxy} from \"../../../../interfaces/notional/NotionalProxy.sol\";\nimport {AuraStakingMixin} from \"./AuraStakingMixin.sol\";\nimport {BalancerVaultStorage} from \"../internal/BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"../internal/strategy/StrategyUtils.sol\";\n\nabstract contract PoolMixin is AuraStakingMixin, BalancerStrategyBase {\n    using StrategyUtils for StrategyContext;\n\n    bytes32 internal immutable BALANCER_POOL_ID;\n    IERC20 internal immutable BALANCER_POOL_TOKEN;\n\n    constructor(NotionalProxy notional_, AuraVaultDeploymentParams memory params) \n        AuraStakingMixin(\n            params.baseParams.liquidityGauge, params.auraRewardPool, params.baseParams.feeReceiver\n        )\n        BalancerStrategyBase(notional_, params.baseParams) {\n        BALANCER_POOL_ID = params.baseParams.balancerPoolId;\n        (address pool, /* */) = Deployments.BALANCER_VAULT.getPool(params.baseParams.balancerPoolId);\n        BALANCER_POOL_TOKEN = IERC20(pool);\n    }\n\n    function _poolContext() internal view returns (PoolContext memory) {\n        return PoolContext({\n            pool: BALANCER_POOL_TOKEN,\n            poolId: BALANCER_POOL_ID\n        });\n    }\n\n    /// @dev Gets the total BPT held by the aura reward pool\n    function _bptHeld() internal view returns (uint256) {\n        return AURA_REWARD_POOL.balanceOf(address(this));\n    }\n\n    function _baseStrategyContext() internal view returns(StrategyContext memory) {\n        return StrategyContext({\n            totalBPTHeld: _bptHeld(),\n            settlementPeriodInSeconds: SETTLEMENT_PERIOD_IN_SECONDS,\n            tradingModule: TRADING_MODULE,\n            vaultSettings: BalancerVaultStorage.getStrategyVaultSettings(),\n            vaultState: BalancerVaultStorage.getStrategyVaultState(),\n            feeReceiver: FEE_RECEIVER\n        });\n    }\n\n    /// @notice Converts BPT to strategy tokens\n    function convertBPTClaimToStrategyTokens(uint256 bptClaim)\n        external view returns (uint256 strategyTokenAmount) {\n        return _baseStrategyContext()._convertBPTClaimToStrategyTokens(bptClaim);\n    }\n\n    /// @notice Converts strategy tokens to BPT\n    function convertStrategyTokensToBPTClaim(uint256 strategyTokenAmount) \n        external view returns (uint256 bptClaim) {\n        return _baseStrategyContext()._convertStrategyTokensToBPTClaim(strategyTokenAmount);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/mixins/PoolMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\nimport {PoolContext, AuraVaultDeploymentParams, StrategyContext} from \"../BalancerVaultTypes.sol\";\nimport {Deployments} from \"../../../global/Deployments.sol\";\nimport {BalancerStrategyBase} from \"../BalancerStrategyBase.sol\";\nimport {NotionalProxy} from \"../../../../interfaces/notional/NotionalProxy.sol\";\nimport {AuraStakingMixin} from \"./AuraStakingMixin.sol\";\nimport {BalancerVaultStorage} from \"../internal/BalancerVaultStorage.sol\";\nimport {StrategyUtils} from \"../internal/strategy/StrategyUtils.sol\";\n\nabstract contract PoolMixin is AuraStakingMixin, BalancerStrategyBase {\n    using StrategyUtils for StrategyContext;\n\n    bytes32 internal immutable BALANCER_POOL_ID;\n    IERC20 internal immutable BALANCER_POOL_TOKEN;\n\n    constructor(NotionalProxy notional_, AuraVaultDeploymentParams memory params) \n        AuraStakingMixin(\n            params.baseParams.liquidityGauge, params.auraRewardPool, params.baseParams.feeReceiver\n        )\n        BalancerStrategyBase(notional_, params.baseParams) {\n        BALANCER_POOL_ID = params.baseParams.balancerPoolId;\n        (address pool, /* */) = Deployments.BALANCER_VAULT.getPool(params.baseParams.balancerPoolId);\n        BALANCER_POOL_TOKEN = IERC20(pool);\n    }\n\n    function _poolContext() internal view returns (PoolContext memory) {\n        return PoolContext({\n            pool: BALANCER_POOL_TOKEN,\n            poolId: BALANCER_POOL_ID\n        });\n    }\n\n    /// @dev Gets the total BPT held by the aura reward pool\n    function _bptHeld() internal view returns (uint256) {\n        return AURA_REWARD_POOL.balanceOf(address(this));\n    }\n\n    function _baseStrategyContext() internal view returns(StrategyContext memory) {\n        return StrategyContext({\n            totalBPTHeld: _bptHeld(),\n            settlementPeriodInSeconds: SETTLEMENT_PERIOD_IN_SECONDS,\n            tradingModule: TRADING_MODULE,\n            vaultSettings: BalancerVaultStorage.getStrategyVaultSettings(),\n            vaultState: BalancerVaultStorage.getStrategyVaultState(),\n            feeReceiver: FEE_RECEIVER\n        });\n    }\n\n    /// @notice Converts BPT to strategy tokens\n    function convertBPTClaimToStrategyTokens(uint256 bptClaim)\n        external view returns (uint256 strategyTokenAmount) {\n        return _baseStrategyContext()._convertBPTClaimToStrategyTokens(bptClaim);\n    }\n\n    /// @notice Converts strategy tokens to BPT\n    function convertStrategyTokensToBPTClaim(uint256 strategyTokenAmount) \n        external view returns (uint256 bptClaim) {\n        return _baseStrategyContext()._convertStrategyTokensToBPTClaim(strategyTokenAmount);\n    }\n}"
    }
  ]
}