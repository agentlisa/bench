{
  "Title": "H-4: Settlement can be called when auction period isn't concluded, allowing HPB depositors to game bad debt settlements",
  "Content": "# Issue H-4: Settlement can be called when auction period isn't concluded, allowing HPB depositors to game bad debt settlements \n\nSource: https://github.com/sherlock-audit/2023-04-ajna-judging/issues/106 \n\n## Found by \nhyh\n## Summary\n\nThe end of auction period is included to it across the logic, but settlePoolDebt() treats the last moment as if it is beyond the period.\n\n## Vulnerability Detail\n\nIn settlePoolDebt() SettlerActions.sol#L113 the end of period control do not revert at `block.timestamp == kickTime + 72 hours`, allowing to run the settlement at the very last moment of the period.\n\n## Impact\n\nPool manipulations become possible at this point of time as both quote and collateral removal operations (guarded by `_revertIfAuctionClearable`) and settlePoolDebt() are available at this point of time.\n\nAs an example, HPB depositor can monitor pool state and upon the calculation that their bucket can be used for bad debt settlement, atomically run `removeQuoteToken() -> settlePoolDebt() -> addQuoteToken()` at `block.timestamp == kickTime + 72 hours`, retaining yield generating HPB position, while settling bad debt with funds of other depositors in nearby buckets.\n\nWhile the probability looks to be medium, catching the exact moment is cumbersome, but achievable operation, the impact is one depositors profiting off others in a risk-free manner, so placing the overall severity to be medium.\n\n## Code Snippet\n\nsettlePoolDebt() can be run at `block.timestamp == kickTime + 72 hours`:\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/SettlerActions.sol#L100-L113\n\n```solidity\n    function settlePoolDebt(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        ReserveAuctionState storage reserveAuction_,\n        PoolState calldata poolState_,\n        SettleParams memory params_\n    ) external returns (SettleResult memory result_) {\n        uint256 kickTime = auctions_.liquidations[params_.borrower].kickTime;\n        if (kickTime == 0) revert NoAuction();\n\n        Borrower memory borrower = loans_.borrowers[params_.borrower];\n>>      if ((block.timestamp - kickTime < 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();\n```\n\nWhile `AuctionNotCleared()` is `block.timestamp - kickTime > 72 hours`, i.e. clearable auction is `[0, 72 hours]` period:\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/helpers/RevertsHelper.sol#L50-L57\n\n```solidity\n    function _revertIfAuctionClearable(\n        AuctionsState storage auctions_,\n        LoansState    storage loans_\n    ) view {\n        address head     = auctions_.head;\n        uint256 kickTime = auctions_.liquidations[head].kickTime;\n        if (kickTime != 0) {\n>>         if (block.timestamp - kickTime > 72 hours) revert AuctionNotCleared();\n```\n\nReserves take also includes the last timestamp to the period, proceeding with take:\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/TakerActions.sol#L282-L291\n\n```solidity\n    function takeReserves(\n        ReserveAuctionState storage reserveAuction_,\n        uint256 maxAmount_\n    ) external returns (uint256 amount_, uint256 ajnaRequired_) {\n        // revert if no amount to be taken\n        if (maxAmount_ == 0) revert InvalidAmount();\n\n        uint256 kicked = reserveAuction_.kicked;\n\n>>      if (kicked != 0 && block.timestamp - kicked <= 72 hours) {\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider having settlePoolDebt() wait for the whole period to pass:\n\nhttps://github.com/sherlock-audit/2023-04-ajna/blob/main/ajna-core/src/libraries/external/SettlerActions.sol#L100-L113\n\n```diff\n    function settlePoolDebt(\n        ...\n    ) external returns (SettleResult memory result_) {\n        ...\n-       if ((block.timestamp - kickTime < 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();\n+       if ((block.timestamp - kickTime <= 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();\n```\n\n\n\n## Discussion\n\n**grandizzy**\n\nhttps://github.com/ajna-finance/contracts/pull/902\n\n**dmitriia**\n\n> [ajna-finance/contracts#902](https://github.com/ajna-finance/contracts/pull/902)\n\nLooks ok\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/75",
  "Code": [
    {
      "filename": "ajna-core/src/libraries/external/SettlerActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    DepositsState,\n    Kicker,\n    Liquidation,\n    LoansState,\n    PoolState,\n    ReserveAuctionState\n}                       from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    SettleParams,\n    SettleResult\n}                       from '../../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    _auctionPrice,\n    _indexOf,\n    _priceAt,\n    MAX_FENWICK_INDEX,\n    MIN_PRICE,\n    DEPOSIT_BUFFER   \n}  from '../helpers/PoolHelper.sol';\n\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  Auction settler library\n    @notice External library containing actions involving auctions within pool:\n            - `settle` auctions\n */\nlibrary SettlerActions {\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `_settlePoolDebtWithDeposit` function local vars.\n    struct SettleLocalVars {\n        uint256 collateralUsed;     // [WAD] collateral used to settle debt\n        uint256 debt;               // [WAD] debt to settle\n        uint256 hpbCollateral;      // [WAD] amount of collateral in HPB bucket\n        uint256 hpbUnscaledDeposit; // [WAD] unscaled amount of of quote tokens in HPB bucket before settle\n        uint256 hpbLP;              // [WAD] amount of LP in HPB bucket\n        uint256 index;              // index of settling bucket\n        uint256 maxSettleableDebt;  // [WAD] max amount that can be settled with existing collateral\n        uint256 price;              // [WAD] price of settling bucket\n        uint256 scaledDeposit;      // [WAD] scaled amount of quote tokens in bucket\n        uint256 scale;              // [WAD] scale of settling bucket\n        uint256 unscaledDeposit;    // [WAD] unscaled amount of quote tokens in bucket\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event AuctionSettle(address indexed borrower, uint256 collateral);\n    event AuctionNFTSettle(address indexed borrower, uint256 collateral, uint256 lp, uint256 index);\n    event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);\n    event Settle(address indexed borrower, uint256 settledDebt);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error AuctionNotClearable();\n    error NoAuction();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IPoolSettlerActions` for descriptions.\n     *  @notice Settles the debt of the given loan / borrower by performing following steps:\n     *          1. settle debt with `HPB`s deposit, up to specified buckets depth.\n     *          2. settle debt with pool reserves (if there's still debt and no collateral left after step 1).\n     *          3. forgive bad debt from next `HPB`, up to remaining buckets depth (and if there's still debt after step 2).\n     *  @dev    === Write state ===\n     *  @dev    update borrower state\n     *  @dev    === Reverts on ===\n     *  @dev    loan is not in auction `NoAuction()`\n     *  @dev    `72` hours didn't pass and auction still has collateral `AuctionNotClearable()`\n     *  @dev    === Emit events ===\n     *  @dev    - `Settle`\n     *  @return result_ The `SettleResult` struct result of settle action.\n     */\n    function settlePoolDebt(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        LoansState storage loans_,\n        ReserveAuctionState storage reserveAuction_,\n        PoolState calldata poolState_,\n        SettleParams memory params_\n    ) external returns (SettleResult memory result_) {\n        uint256 kickTime = auctions_.liquidations[params_.borrower].kickTime;\n        if (kickTime == 0) revert NoAuction();\n\n        Borrower memory borrower = loans_.borrowers[params_.borrower];\n        if ((block.timestamp - kickTime < 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();\n\n        result_.debtPreAction       = borrower.t0Debt;\n        result_.collateralPreAction = borrower.collateral;\n        result_.t0DebtSettled       = borrower.t0Debt;\n        result_.collateralSettled   = borrower.collateral;\n\n        // 1. settle debt with HPB deposit\n        (\n            borrower.t0Debt,\n            borrower.collateral,\n            params_.bucketDepth\n        ) = _settlePoolDebtWithDeposit(\n            buckets_,\n            deposits_,\n            params_,\n            borrower,\n            poolState_.inflator\n        );\n\n        if (borrower.t0Debt != 0 && borrower.collateral == 0) {\n            // 2. settle debt with pool reserves\n            uint256 assets = Maths.floorWmul(poolState_.t0Debt - result_.t0DebtSettled + borrower.t0Debt, poolState_.inflator) + params_.poolBalance;\n\n            uint256 liabilities =\n                // require 1.0 + 1e-9 deposit buffer (extra margin) for deposits\n                Maths.wmul(DEPOSIT_BUFFER, Deposits.treeSum(deposits_)) +\n                auctions_.totalBondEscrowed +\n                reserveAuction_.unclaimed;\n\n            // settle debt from reserves (assets - liabilities) if reserves positive, round reserves down however\n            if (assets > liabilities) {\n                borrower.t0Debt -= Maths.min(borrower.t0Debt, Maths.floorWdiv(assets - liabilities, poolState_.inflator));\n            }\n\n            // 3. forgive bad debt from next HPB\n            if (borrower.t0Debt != 0) {\n                borrower.t0Debt = _forgiveBadDebt(\n                    buckets_,\n                    deposits_,\n                    params_,\n                    borrower,\n                    poolState_.inflator\n                );\n            }\n        }\n\n        // complete result struct with debt settled\n        result_.t0DebtSettled -= borrower.t0Debt;\n\n        emit Settle(\n            params_.borrower,\n            result_.t0DebtSettled\n        );\n\n        // if entire debt was settled then settle auction\n        if (borrower.t0Debt == 0) {\n            (borrower.collateral, ) = _settleAuction(\n                auctions_,\n                buckets_,\n                deposits_,\n                params_.borrower,\n                borrower.collateral,\n                poolState_.poolType\n            );\n        }\n\n        // complete result struct with debt and collateral post action and collateral settled\n        result_.debtPostAction      = borrower.t0Debt;\n        result_.collateralRemaining = borrower.collateral;\n        result_.collateralSettled   -= result_.collateralRemaining;\n\n        // update borrower state\n        loans_.borrowers[params_.borrower] = borrower;\n    }\n\n    /***************************/\n    /***  Internal Functions ***/\n    /***************************/\n\n    /**\n     *  @notice Performs auction settle based on pool type, emits settle event and removes auction from auctions queue.\n     *  @dev    === Emit events ===\n     *  @dev    - `AuctionNFTSettle` or `AuctionSettle`\n     *  @param  auctions_              Struct for pool auctions state.\n     *  @param  buckets_               Struct for pool buckets state.\n     *  @param  deposits_              Struct for pool deposits state.\n     *  @param  borrowerAddress_       Address of the borrower that exits auction.\n     *  @param  borrowerCollateral_    Borrower collateral amount before auction exit (in `NFT` could be fragmented as result of partial takes).\n     *  @param  poolType_              Type of the pool (can be `ERC20` or `ERC721`).\n     *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for `ERC20` pool, rounded collateral for `ERC721` pool).\n     *  @return compensatedCollateral_ Amount of collateral compensated (`ERC721` settle only), to be deducted from pool pledged collateral accumulator. Always `0` for `ERC20` pools.\n     */\n    function _settleAuction(\n        AuctionsState storage auctions_,\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        address borrowerAddress_,\n        uint256 borrowerCollateral_,\n        uint256 poolType_\n    ) internal returns (uint256 remainingCollateral_, uint256 compensatedCollateral_) {\n\n        if (poolType_ == uint8(PoolType.ERC721)) {\n            uint256 lp;\n            uint256 bucketIndex;\n\n            // floor collateral of borrower\n            remainingCollateral_ = (borrowerCollateral_ / Maths.WAD) * Maths.WAD;\n\n            // if there's fraction of NFTs remaining then reward difference to borrower as LP in auction price bucket\n            if (remainingCollateral_ != borrowerCollateral_) {\n\n                // calculate the amount of collateral that should be compensated with LP\n                compensatedCollateral_ = borrowerCollateral_ - remainingCollateral_;\n\n                uint256 auctionPrice = _auctionPrice(\n                    auctions_.liquidations[borrowerAddress_].kickMomp,\n                    auctions_.liquidations[borrowerAddress_].neutralPrice,\n                    auctions_.liquidations[borrowerAddress_].kickTime\n                );\n\n                // determine the bucket index to compensate fractional collateral\n                bucketIndex = auctionPrice > MIN_PRICE ? _indexOf(auctionPrice) : MAX_FENWICK_INDEX;\n\n                // deposit collateral in bucket and reward LP to compensate fractional collateral\n                lp = Buckets.addCollateral(\n                    buckets_[bucketIndex],\n                    borrowerAddress_,\n                    Deposits.valueAt(deposits_, bucketIndex),\n                    compensatedCollateral_,\n                    _priceAt(bucketIndex)\n                );\n            }\n\n            emit AuctionNFTSettle(\n                borrowerAddress_,\n                remainingCollateral_,\n                lp,\n                bucketIndex\n            );\n\n        } else {\n            remainingCollateral_ = borrowerCollateral_;\n\n            emit AuctionSettle(\n                borrowerAddress_,\n                remainingCollateral_\n            );\n        }\n\n        _removeAuction(auctions_, borrowerAddress_);\n    }\n\n    /**\n     *  @notice Removes auction and repairs the queue order.\n     *  @notice Updates kicker's claimable balance with bond size awarded and subtracts bond size awarded from `liquidationBondEscrowed`.\n     *  @dev    === Write state ===\n     *  @dev    decrement kicker locked accumulator, increment kicker claimable accumumlator\n     *  @dev    decrement auctions count accumulator\n     *  @dev    update auction queue state\n     *  @param  auctions_ Struct for pool auctions state.\n     *  @param  borrower_ Auctioned borrower address.\n     */\n    function _removeAuction(\n        AuctionsState storage auctions_,\n        address borrower_\n    ) internal {\n        Liquidation memory liquidation = auctions_.liquidations[borrower_];\n        // update kicker balances\n        Kicker storage kicker = auctions_.kickers[liquidation.kicker];\n\n        kicker.locked    -= liquidation.bondSize;\n        kicker.claimable += liquidation.bondSize;\n\n        // decrement number of active auctions\n        -- auctions_.noOfAuctions;\n\n        // update auctions queue\n        if (auctions_.head == borrower_ && auctions_.tail == borrower_) {\n            // liquidation is the head and tail\n            auctions_.head = address(0);\n            auctions_.tail = address(0);\n        }\n        else if(auctions_.head == borrower_) {\n            // liquidation is the head\n            auctions_.liquidations[liquidation.next].prev = address(0);\n            auctions_.head = liquidation.next;\n        }\n        else if(auctions_.tail == borrower_) {\n            // liquidation is the tail\n            auctions_.liquidations[liquidation.prev].next = address(0);\n            auctions_.tail = liquidation.prev;\n        }\n        else {\n            // liquidation is in the middle\n            auctions_.liquidations[liquidation.prev].next = liquidation.next;\n            auctions_.liquidations[liquidation.next].prev = liquidation.prev;\n        }\n        // delete liquidation\n        delete auctions_.liquidations[borrower_];\n    }\n\n    /**\n     *  @notice Called to settle debt using `HPB` deposits, up to the number of specified buckets depth.\n     *  @dev    === Write state ===\n     *  @dev    - `Deposits.unscaledRemove()` (remove amount in `Fenwick` tree, from index):\n     *  @dev      update `values` array state\n     *  @dev    - `Buckets.addCollateral`:\n     *  @dev      increment `bucket.collateral` and `bucket.lps` accumulator\n     *  @dev      increment `lender.lps` accumulator and `lender.depositTime` state\n     *  @dev    === Emit events ===\n     *  @dev    - `BucketBankruptcy`\n     *  @param  buckets_             Struct for pool buckets state.\n     *  @param  deposits_            Struct for pool deposits state.\n     *  @param  params_              Struct containing params for settle action.\n     *  @param  borrower_            Struct containing borrower details.\n     *  @param  inflator_            Current pool inflator.\n     *  @return remainingt0Debt_     Remaining borrower `t0` debt after settle with `HPB`.\n     *  @return remainingCollateral_ Remaining borrower collateral after settle with `HPB`.\n     *  @return bucketDepth_         Number of buckets to use for forgiving debt in case there's more remaining.\n     */\n    function _settlePoolDebtWithDeposit(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        SettleParams memory params_,\n        Borrower memory borrower_,\n        uint256 inflator_\n    ) internal returns (uint256 remainingt0Debt_, uint256 remainingCollateral_, uint256 bucketDepth_) {\n        remainingt0Debt_     = borrower_.t0Debt;\n        remainingCollateral_ = borrower_.collateral;\n        bucketDepth_         = params_.bucketDepth;\n\n        while (bucketDepth_ != 0 && remainingt0Debt_ != 0 && remainingCollateral_ != 0) {\n            SettleLocalVars memory vars;\n\n            (vars.index, , vars.scale) = Deposits.findIndexAndSumOfSum(deposits_, 1);\n            vars.hpbUnscaledDeposit    = Deposits.unscaledValueAt(deposits_, vars.index);\n            vars.unscaledDeposit       = vars.hpbUnscaledDeposit;\n            vars.price                 = _priceAt(vars.index);\n\n            if (vars.unscaledDeposit != 0) {\n                vars.debt              = Maths.wmul(remainingt0Debt_, inflator_);           // current debt to be settled\n                vars.maxSettleableDebt = Maths.floorWmul(remainingCollateral_, vars.price); // max debt that can be settled with existing collateral\n                vars.scaledDeposit     = Maths.wmul(vars.scale, vars.unscaledDeposit);\n\n                // 1) bucket deposit covers remaining loan debt to settle, loan's collateral can cover remaining loan debt to settle\n                if (vars.scaledDeposit >= vars.debt && vars.maxSettleableDebt >= vars.debt) {\n                    // remove only what's needed to settle the debt\n                    vars.unscaledDeposit = Maths.wdiv(vars.debt, vars.scale);\n                    vars.collateralUsed  = Maths.ceilWdiv(vars.debt, vars.price);\n\n                    // settle the entire debt\n                    remainingt0Debt_ = 0;\n                }\n                // 2) bucket deposit can not cover all of loan's remaining debt, bucket deposit is the constraint\n                else if (vars.maxSettleableDebt >= vars.scaledDeposit) {\n                    vars.collateralUsed = Maths.ceilWdiv(vars.scaledDeposit, vars.price);\n\n                    // subtract from debt the corresponding t0 amount of deposit\n                    remainingt0Debt_ -= Maths.floorWdiv(vars.scaledDeposit, inflator_);\n                }\n                // 3) loan's collateral can not cover remaining loan debt to settle, loan collateral is the constraint\n                else {\n                    vars.unscaledDeposit = Maths.wdiv(vars.maxSettleableDebt, vars.scale);\n                    vars.collateralUsed  = remainingCollateral_;\n\n                    remainingt0Debt_ -= Maths.floorWdiv(vars.maxSettleableDebt, inflator_);\n                }\n\n                // remove settled collateral from loan\n                remainingCollateral_ -= vars.collateralUsed;\n\n                // use HPB bucket to swap loan collateral for loan debt\n                Bucket storage hpb = buckets_[vars.index];\n                vars.hpbLP         = hpb.lps;\n                vars.hpbCollateral = hpb.collateral + vars.collateralUsed;\n\n                // set amount to remove as min of calculated amount and available deposit (to prevent rounding issues)\n                vars.unscaledDeposit    = Maths.min(vars.hpbUnscaledDeposit, vars.unscaledDeposit);\n                vars.hpbUnscaledDeposit -= vars.unscaledDeposit;\n\n                // remove amount to settle debt from bucket (could be entire deposit or only the settled debt)\n                Deposits.unscaledRemove(deposits_, vars.index, vars.unscaledDeposit);\n\n                // check if bucket healthy - set bankruptcy if collateral is 0 and entire deposit was used to settle and there's still LP\n                if (vars.hpbCollateral == 0 && vars.hpbUnscaledDeposit == 0 && vars.hpbLP != 0) {\n                    hpb.lps            = 0;\n                    hpb.bankruptcyTime = block.timestamp;\n\n                    emit BucketBankruptcy(\n                        vars.index,\n                        vars.hpbLP\n                    );\n                } else {\n                    // add settled collateral into bucket\n                    hpb.collateral = vars.hpbCollateral;\n                }\n\n            } else {\n                // Deposits in the tree is zero, insert entire collateral into lowest bucket 7388\n                Buckets.addCollateral(\n                    buckets_[vars.index],\n                    params_.borrower,\n                    0,  // zero deposit in bucket\n                    remainingCollateral_,\n                    vars.price\n                );\n                // entire collateral added into bucket, no borrower pledged collateral remaining\n                remainingCollateral_ = 0;\n            }\n\n            --bucketDepth_;\n        }\n    }\n\n    /**\n     *  @notice Called to forgive bad debt starting from next `HPB`, up to the number of remaining buckets depth.\n     *  @dev    === Write state ===\n     *  @dev    - `Deposits.unscaledRemove()` (remove amount in `Fenwick` tree, from index):\n     *  @dev      update `values` array state\n     *  @dev      reset `bucket.lps` accumulator and update `bucket.bankruptcyTime`\n     *  @dev    === Emit events ===\n     *  @dev    - `BucketBankruptcy`\n     *  @param  buckets_         Struct for pool buckets state.\n     *  @param  deposits_        Struct for pool deposits state.\n     *  @param  params_          Struct containing params for settle action.\n     *  @param  borrower_        Struct containing borrower details.\n     *  @param  inflator_        Current pool inflator.\n     *  @return remainingt0Debt_ Remaining borrower `t0` debt after forgiving bad debt in case not enough buckets used.\n     */\n    function _forgiveBadDebt(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        SettleParams memory params_,\n        Borrower memory borrower_,\n        uint256 inflator_\n    ) internal returns (uint256 remainingt0Debt_) {\n        remainingt0Debt_ = borrower_.t0Debt;\n\n        // loop through remaining buckets if there's still debt to forgive\n        while (params_.bucketDepth != 0 && remainingt0Debt_ != 0) {\n\n            (uint256 index, , uint256 scale) = Deposits.findIndexAndSumOfSum(deposits_, 1);\n            uint256 unscaledDeposit          = Deposits.unscaledValueAt(deposits_, index);\n            uint256 depositToRemove          = Maths.wmul(scale, unscaledDeposit);\n            uint256 debt                     = Maths.wmul(remainingt0Debt_, inflator_);\n            uint256 depositRemaining;\n\n            // 1) bucket deposit covers entire loan debt to settle, no constraints needed\n            if (depositToRemove >= debt) {\n                // no remaining debt to forgive\n                remainingt0Debt_ = 0;\n\n                uint256 depositUsed = Maths.wdiv(debt, scale);\n                depositRemaining = unscaledDeposit - depositUsed;\n\n                // Remove deposit used to forgive bad debt from bucket\n                Deposits.unscaledRemove(deposits_, index, depositUsed);\n\n            // 2) loan debt to settle exceeds bucket deposit, bucket deposit is the constraint\n            } else {\n                // subtract from remaining debt the corresponding t0 amount of deposit\n                remainingt0Debt_ -= Maths.floorWdiv(depositToRemove, inflator_);\n\n                // Remove all deposit from bucket\n                Deposits.unscaledRemove(deposits_, index, unscaledDeposit);\n            }\n\n            Bucket storage hpbBucket = buckets_[index];\n            uint256 bucketLP = hpbBucket.lps;\n            // If the remaining deposit and resulting bucket collateral is so small that the exchange rate\n            // rounds to 0, then bankrupt the bucket.  Note that lhs are WADs, so the\n            // quantity is naturally 1e18 times larger than the actual product\n            if (depositRemaining * Maths.WAD + hpbBucket.collateral * _priceAt(index) <= bucketLP) {\n                // existing LP for the bucket shall become unclaimable\n                hpbBucket.lps            = 0;\n                hpbBucket.bankruptcyTime = block.timestamp;\n\n                emit BucketBankruptcy(\n                    index,\n                    bucketLP\n                );\n            }\n\n            --params_.bucketDepth;\n        }\n    }\n\n}"
    },
    {
      "filename": "ajna-core/src/libraries/helpers/RevertsHelper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport {\n    AuctionsState,\n    Borrower,\n    DepositsState,\n    LoansState,\n    PoolBalancesState\n} from '../../interfaces/pool/commons/IPoolState.sol';\n\nimport { _minDebtAmount, _priceAt } from './PoolHelper.sol';\n\nimport { Loans }    from '../internal/Loans.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n    // See `IPoolErrors` for descriptions\n    error AuctionNotCleared();\n    error AmountLTMinDebt();\n    error DustAmountNotExceeded();\n    error LimitIndexExceeded();\n    error RemoveDepositLockedByAuctionDebt();\n    error TransactionExpired();\n\n    /**\n     *  @notice Called by `LP` removal functions assess whether or not `LP` is locked.\n     *  @dev    Reverts with `RemoveDepositLockedByAuctionDebt` if debt locked.\n     *  @param  t0DebtInAuction_ Pool's t0 debt currently in auction.\n     *  @param  index_           The deposit index from which `LP` is attempting to be removed.\n     *  @param  inflator_        The pool inflator used to properly assess t0 debt in auctions.\n     */\n    function _revertIfAuctionDebtLocked(\n        DepositsState storage deposits_,\n        uint256 t0DebtInAuction_,\n        uint256 index_,\n        uint256 inflator_\n    ) view {\n        if (t0DebtInAuction_ != 0 ) {\n            // deposit in buckets within liquidation debt from the top-of-book down are frozen.\n            if (index_ <= Deposits.findIndexOfSum(deposits_, Maths.wmul(t0DebtInAuction_, inflator_))) revert RemoveDepositLockedByAuctionDebt();\n        } \n    }\n\n    /**\n     *  @notice Check if head auction is clearable (auction is kicked and `72` hours passed since kick time or auction still has debt but no remaining collateral).\n     *  @dev    Reverts with `AuctionNotCleared` if auction is clearable.\n     */\n    function _revertIfAuctionClearable(\n        AuctionsState storage auctions_,\n        LoansState    storage loans_\n    ) view {\n        address head     = auctions_.head;\n        uint256 kickTime = auctions_.liquidations[head].kickTime;\n        if (kickTime != 0) {\n            if (block.timestamp - kickTime > 72 hours) revert AuctionNotCleared();\n\n            Borrower storage borrower = loans_.borrowers[head];\n            if (borrower.t0Debt != 0 && borrower.collateral == 0) revert AuctionNotCleared();\n        }\n    }\n\n    /**\n     *  @notice  Check if provided price is at or above index limit provided by borrower.\n     *  @notice  Prevents stale transactions and certain `MEV` manipulations.\n     *  @dev     Reverts with `LimitIndexExceeded` if index limit provided exceeded.\n     *  @param newPrice_   New price to be compared with given limit price (can be `LUP`, `NP`).\n     *  @param limitIndex_ Limit price index provided by user creating the transaction.\n     */\n    function _revertIfPriceDroppedBelowLimit(\n        uint256 newPrice_,\n        uint256 limitIndex_\n    ) pure {\n        if (newPrice_ < _priceAt(limitIndex_)) revert LimitIndexExceeded();\n    }\n\n    /**\n     *  @notice Check if expiration provided by user has met or exceeded current block height timestamp.\n     *  @notice Prevents stale transactions interacting with the pool at potentially unfavorable prices.\n     *  @dev    Reverts with `TransactionExpired` if expired.\n     *  @param  expiry_ Expiration provided by user when creating the transaction.\n     */\n    function _revertAfterExpiry(\n        uint256 expiry_\n    ) view {\n        if (block.timestamp > expiry_) revert TransactionExpired();\n    }\n\n    /**\n     *  @notice Called when borrower debt changes, ensuring minimum debt rules are honored.\n     *  @dev    Reverts with `DustAmountNotExceeded` if under dust amount or with `AmountLTMinDebt` if amount under min debt value.\n     *  @param  loans_        Loans heap, used to determine loan count.\n     *  @param  poolDebt_     Total pool debt, used to calculate average debt.\n     *  @param  borrowerDebt_ New debt for the borrower, assuming the current transaction succeeds.\n     *  @param  quoteDust_    Smallest amount of quote token when can be transferred, determined by token scale.\n     */\n    function _revertOnMinDebt(\n        LoansState storage loans_,\n        uint256 poolDebt_,\n        uint256 borrowerDebt_,\n        uint256 quoteDust_\n    ) view {\n        if (borrowerDebt_ != 0) {\n            if (borrowerDebt_ < quoteDust_) revert DustAmountNotExceeded();\n            uint256 loansCount = Loans.noOfLoans(loans_);\n            if (loansCount >= 10)\n                if (borrowerDebt_ < _minDebtAmount(poolDebt_, loansCount)) revert AmountLTMinDebt();\n        }\n    }"
    },
    {
      "filename": "ajna-core/src/libraries/external/TakerActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.18;\n\nimport { PRBMathSD59x18 } from \"@prb-math/contracts/PRBMathSD59x18.sol\";\nimport { Math }           from '@openzeppelin/contracts/utils/math/Math.sol';\n\nimport { PoolType } from '../../interfaces/pool/IPool.sol';\n\nimport {\n    AuctionsState,\n    Borrower,\n    Bucket,\n    BurnEvent,\n    DepositsState,\n    Liquidation,\n    LoansState,\n    PoolState,\n    ReserveAuctionState\n}                        from '../../interfaces/pool/commons/IPoolState.sol';\nimport {\n    TakeResult\n}                        from '../../interfaces/pool/commons/IPoolInternals.sol';\n\nimport {\n    _auctionPrice,\n    _bpf,\n    _isCollateralized,\n    _priceAt,\n    _reserveAuctionPrice,\n    _roundToScale\n}                           from '../helpers/PoolHelper.sol';\nimport { _revertOnMinDebt } from '../helpers/RevertsHelper.sol';\n\nimport { SettlerActions } from './SettlerActions.sol';\n\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Loans }    from '../internal/Loans.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n/**\n    @title  Auction Taker Actions library\n    @notice External library containing actions involving taking auctions within pool:\n            - `take` and `bucketTake` auctioned collateral; take reserves\n */\nlibrary TakerActions {\n\n    /*******************************/\n    /*** Function Params Structs ***/\n    /*******************************/\n\n    /// @dev Struct used to hold `bucketTake` function params.\n    struct BucketTakeParams {\n        address borrower;        // borrower address to take from\n        bool    depositTake;     // deposit or arb take, used by bucket take\n        uint256 index;           // bucket index, used by bucket take\n        uint256 inflator;        // [WAD] current pool inflator\n        uint256 collateralScale; // precision of collateral token based on decimals\n    }\n\n    /// @dev Struct used to hold `take` function params.\n    struct TakeParams {\n        address borrower;        // borrower address to take from\n        uint256 takeCollateral;  // [WAD] desired amount to take\n        uint256 inflator;        // [WAD] current pool inflator\n        uint256 poolType;        // pool type (ERC20 or NFT)\n        uint256 collateralScale; // precision of collateral token based on decimals\n    }\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    /// @dev Struct used for `take` function local vars.\n    struct TakeLocalVars {\n        uint256 auctionPrice;             // [WAD] The price of auction.\n        uint256 bondChange;               // [WAD] The change made on the bond size (beeing reward or penalty).\n        uint256 borrowerDebt;             // [WAD] The accrued debt of auctioned borrower.\n        int256  bpf;                      // The bond penalty factor.\n        uint256 bucketPrice;              // [WAD] The bucket price.\n        uint256 bucketScale;              // [WAD] The bucket scale.\n        uint256 collateralAmount;         // [WAD] The amount of collateral taken.\n        uint256 excessQuoteToken;         // [WAD] Difference of quote token that borrower receives after take (for fractional NFT only)\n        uint256 factor;                   // The take factor, calculated based on bond penalty factor.\n        bool    isRewarded;               // True if kicker is rewarded (auction price lower than neutral price), false if penalized (auction price greater than neutral price).\n        address kicker;                   // Address of auction kicker.\n        uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral\n        uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t0 terms.\n        uint256 t0BorrowerDebt;           // [WAD] Borrower's t0 debt.\n        uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.\n        uint256 unscaledDeposit;          // [WAD] Unscaled bucket quantity\n        uint256 unscaledQuoteTokenAmount; // [WAD] The unscaled token amount that taker should pay for collateral taken.\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event BucketTake(address indexed borrower, uint256 index, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);\n    event BucketTakeLPAwarded(address indexed taker, address indexed kicker, uint256 lpAwardedTaker, uint256 lpAwardedKicker);\n    event Take(address indexed borrower, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);\n    event ReserveAuction(uint256 claimableReservesRemaining, uint256 auctionPrice, uint256 currentBurnEpoch);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error AuctionPriceGtBucketPrice();\n    error CollateralRoundingNeededButNotPossible();\n    error InsufficientLiquidity();\n    error InsufficientCollateral();\n    error InvalidAmount();\n    error NoAuction();\n    error NoReserves();\n    error NoReservesAuction();\n    error ReserveAuctionTooSoon();\n    error TakeNotPastCooldown();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IPoolTakerActions` for descriptions.\n     *  @notice Performs bucket take collateral on an auction, rewards taker and kicker (if case) and updates loan info (settles auction if case).\n     *  @dev    === Reverts on ===\n     *  @dev    not enough collateral to take `InsufficientCollateral()`\n     *  @return result_ `TakeResult` struct containing details of bucket take result.\n    */\n    function bucketTake(\n        AuctionsState sto"
    }
  ]
}