{
  "Title": "Zero Token",
  "Content": "##### Description\nThere is no address checking for tokens params in constructor:\nhttps://github.com/1inch/farming/blob/7a007ec7784cca2899889e99e46cf06d5788a7d9/contracts/FarmingPool.sol#L35-L36\n##### Recommendation\nIt is recommended to add a check for non-zero address.\n\n***\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/FarmingPool.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./interfaces/IFarmingPool.sol\";\nimport \"./accounting/FarmAccounting.sol\";\nimport \"./accounting/UserAccounting.sol\";\n\ncontract FarmingPool is IFarmingPool, Ownable, ERC20 {\n    using SafeERC20 for IERC20;\n    using FarmAccounting for FarmAccounting.Info;\n    using UserAccounting for UserAccounting.Info;\n\n    event DistributorChanged(address oldDistributor, address newDistributor);\n    event RewardAdded(uint256 reward, uint256 duration);\n\n    IERC20 public immutable stakingToken;\n    IERC20 public immutable rewardsToken;\n\n    address public distributor;\n    FarmAccounting.Info public farmInfo;\n    UserAccounting.Info public userInfo;\n\n    constructor(IERC20Metadata stakingToken_, IERC20 rewardsToken_)\n        ERC20(\n            string(abi.encodePacked(\"Farming of \", stakingToken_.name())),\n            string(abi.encodePacked(\"farm\", stakingToken_.symbol()))\n        )\n    {\n        stakingToken = stakingToken_;\n        rewardsToken = rewardsToken_;\n    }\n\n    function setDistributor(address distributor_) external onlyOwner {\n        address oldDistributor = distributor;\n        require(distributor_ != oldDistributor, \"FP: distributor is already set\");\n        emit DistributorChanged(oldDistributor, distributor_);\n        distributor = distributor_;\n    }\n\n    function startFarming(uint256 amount, uint256 period) external {\n        require(msg.sender == distributor, \"FP: access denied\");\n        rewardsToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        uint256 reward = farmInfo.startFarming(amount, period, _updateCheckpoint);\n        emit RewardAdded(reward, period);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return IERC20Metadata(address(stakingToken)).decimals();\n    }\n\n    function farmedPerToken() public view override returns (uint256) {\n        return userInfo.farmedPerToken(address(0), _lazyGetSupply, _lazyGetFarmed);\n    }\n\n    function farmed(address account) external view override returns (uint256) {\n        return userInfo.farmed(account, balanceOf(account), farmedPerToken());\n    }\n\n    function deposit(uint256 amount) external override {\n        require(amount > 0, \"FP: zero deposit\");\n        _mint(msg.sender, amount);\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public override {\n        require(amount > 0, \"FP: zero withdraw\");\n        _burn(msg.sender, amount);\n        stakingToken.safeTransfer(msg.sender, amount);\n    }\n\n    function claim() public override {\n        uint256 fpt = farmedPerToken();\n        uint256 balance = balanceOf(msg.sender);\n        uint256 amount = userInfo.farmed(msg.sender, balance, fpt);\n        if (amount > 0) {\n            userInfo.eraseFarmed(msg.sender, balance, fpt);\n            rewardsToken.safeTransfer(msg.sender, amount);\n        }\n    }\n\n    function exit() external override {\n        withdraw(balanceOf(msg.sender));\n        claim();\n    }\n\n    // ERC20 overrides\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (amount > 0 && from != to) {\n            userInfo.updateBalances(farmedPerToken(), from, to, amount, from != address(0), to != address(0));\n        }\n    }\n\n    // UserAccounting bindings\n\n    function _lazyGetSupply(address /* context */) private view returns(uint256) {\n        return totalSupply();\n    }\n\n    function _lazyGetFarmed(address /* context */, uint256 checkpoint) private view returns(uint256) {\n        return farmInfo.farmedSinceCheckpointScaled(checkpoint);\n    }\n\n    // FarmAccounting bindings\n\n    function _updateCheckpoint() private {\n        userInfo.updateCheckpoint(farmedPerToken());\n    }\n}"
    }
  ]
}