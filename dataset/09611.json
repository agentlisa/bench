{
  "Title": "[G-15] `require()` or `revert()` statements that check input arguments should be at the top of the function",
  "Content": "\nChecks that involve constants should come before checks that involve state variables\n\n1.  File: contracts/utils/MultiRateLimited.sol (lines [270-273](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/MultiRateLimited.sol#L270-L273))\n\n```solidity\n        require(\n            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: rateLimitPerSecond too high\"\n        );\n```\n\n2.  File: contracts/utils/MultiRateLimited.sol (lines [305-308](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/MultiRateLimited.sol#L305-L308))\n\n```solidity\n        require(\n            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: rateLimitPerSecond too high\"\n        );\n```\n\n3.  File: contracts/utils/RateLimited.sol (lines [46-49](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/RateLimited.sol#L46-L49))\n\n```solidity\n        require(\n            _rateLimitPerSecond <= _maxRateLimitPerSecond,\n            \"RateLimited: rateLimitPerSecond too high\"\n        );\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-03-volt-protocol-contest",
  "Code": [
    {
      "filename": "contracts/utils/MultiRateLimited.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {CoreRef} from \"../refs/CoreRef.sol\";\nimport {TribeRoles} from \"./../core/TribeRoles.sol\";\nimport {RateLimited} from \"./RateLimited.sol\";\nimport {IMultiRateLimited} from \"./IMultiRateLimited.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/// @title abstract contract for putting a rate limit on how fast an address can perform an action e.g. Minting\n/// there are two buffers, one buffer which is each individual addresses's current buffer,\n/// and then there is a global buffer which is the buffer that each individual address must respect as well\n/// @author Elliot Friedman, Fei Protocol\n/// this contract was made abstract so that other contracts that already construct an instance of CoreRef\n/// do not collide with this one\nabstract contract MultiRateLimited is RateLimited, IMultiRateLimited {\n    using SafeCast for *;\n\n    /// @notice the struct containing all information per rate limited address\n    struct RateLimitData {\n        uint32 lastBufferUsedTime;\n        uint112 bufferCap;\n        uint112 bufferStored;\n        uint112 rateLimitPerSecond;\n    }\n\n    /// @notice rate limited address information\n    mapping(address => RateLimitData) public rateLimitPerAddress;\n\n    /// @notice max rate limit per second allowable by non governor per contract\n    uint256 public individualMaxRateLimitPerSecond;\n\n    /// @notice max buffer cap allowable by non governor per contract\n    uint256 public individualMaxBufferCap;\n\n    /// @param _maxRateLimitPerSecond maximum amount of fei that can replenish per second ever, this amount cannot be changed by governance\n    /// @param _rateLimitPerSecond maximum rate limit per second per address\n    /// @param _individualMaxRateLimitPerSecond maximum rate limit per second per address in multi rate limited\n    /// @param _individualMaxBufferCap maximum buffer cap in multi rate limited\n    /// @param _globalBufferCap maximum global buffer cap\n    constructor(\n        uint256 _maxRateLimitPerSecond,\n        uint256 _rateLimitPerSecond,\n        uint256 _individualMaxRateLimitPerSecond,\n        uint256 _individualMaxBufferCap,\n        uint256 _globalBufferCap\n    )\n        RateLimited(\n            _maxRateLimitPerSecond,\n            _rateLimitPerSecond,\n            _globalBufferCap,\n            false\n        )\n    {\n        require(\n            _individualMaxBufferCap < _globalBufferCap,\n            \"MultiRateLimited: max buffer cap invalid\"\n        );\n\n        individualMaxRateLimitPerSecond = _individualMaxRateLimitPerSecond;\n        individualMaxBufferCap = _individualMaxBufferCap;\n    }\n\n    modifier addressIsRegistered(address rateLimitedAddress) {\n        require(\n            rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime != 0,\n            \"MultiRateLimited: rate limit address does not exist\"\n        );\n        _;\n    }\n\n    // ----------- Governor and Admin only state changing api -----------\n\n    /// @notice update the ADD_MINTER_ROLE rate limit per second\n    /// @param newRateLimitPerSecond new maximum rate limit per second for add minter role\n    function updateMaxRateLimitPerSecond(uint256 newRateLimitPerSecond)\n        external\n        virtual\n        override\n        onlyGovernor\n    {\n        require(\n            newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: exceeds global max rate limit per second\"\n        );\n\n        uint256 oldMaxRateLimitPerSecond = individualMaxRateLimitPerSecond;\n        individualMaxRateLimitPerSecond = newRateLimitPerSecond;\n\n        emit MultiMaxRateLimitPerSecondUpdate(\n            oldMaxRateLimitPerSecond,\n            newRateLimitPerSecond\n        );\n    }\n\n    /// @notice update the ADD_MINTER_ROLE max buffer cap\n    /// @param newBufferCap new buffer cap for ADD_MINTER_ROLE added addresses\n    function updateMaxBufferCap(uint256 newBufferCap)\n        external\n        virtual\n        override\n        onlyGovernor\n    {\n        require(\n            newBufferCap <= bufferCap,\n            \"MultiRateLimited: exceeds global buffer cap\"\n        );\n\n        uint256 oldBufferCap = individualMaxBufferCap;\n        individualMaxBufferCap = newBufferCap;\n\n        emit MultiBufferCapUpdate(oldBufferCap, newBufferCap);\n    }\n\n    /// @notice add an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress\n    /// @param _rateLimitPerSecond the rate limit per second for this rateLimitedAddress\n    /// @param _bufferCap  the buffer cap for this rateLimitedAddress\n    function addAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    ) external virtual override onlyGovernor {\n        _addAddress(rateLimitedAddress, _rateLimitPerSecond, _bufferCap);\n    }\n\n    /// @notice add an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the address whose buffer and rate limit per second will be set\n    /// @param _rateLimitPerSecond the new rate limit per second for this rateLimitedAddress\n    /// @param _bufferCap  the new buffer cap for this rateLimitedAddress\n    function updateAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    )\n        external\n        virtual\n        override\n        addressIsRegistered(rateLimitedAddress)\n        hasAnyOfTwoRoles(TribeRoles.ADD_MINTER_ROLE, TribeRoles.GOVERNOR)\n    {\n        if (core().hasRole(TribeRoles.ADD_MINTER_ROLE, msg.sender)) {\n            require(\n                _rateLimitPerSecond <= individualMaxRateLimitPerSecond,\n                \"MultiRateLimited: rate limit per second exceeds non governor allowable amount\"\n            );\n            require(\n                _bufferCap <= individualMaxBufferCap,\n                \"MultiRateLimited: max buffer cap exceeds non governor allowable amount\"\n            );\n        }\n        require(\n            _bufferCap <= bufferCap,\n            \"MultiRateLimited: buffercap too high\"\n        );\n\n        _updateAddress(rateLimitedAddress, _rateLimitPerSecond, _bufferCap);\n    }\n\n    /// @notice add an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress\n    /// gives the newly added contract the maximum allowable rate limit per second and buffer cap\n    function addAddressWithCaps(address rateLimitedAddress)\n        external\n        virtual\n        override\n        onlyTribeRole(TribeRoles.ADD_MINTER_ROLE)\n    {\n        _addAddress(\n            rateLimitedAddress,\n            uint112(individualMaxRateLimitPerSecond),\n            uint112(individualMaxBufferCap)\n        );\n    }\n\n    /// @notice remove an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the address to remove from the whitelist of addresses\n    function removeAddress(address rateLimitedAddress)\n        external\n        virtual\n        override\n        addressIsRegistered(rateLimitedAddress)\n        onlyGuardianOrGovernor\n    {\n        uint256 oldRateLimitPerSecond = rateLimitPerAddress[rateLimitedAddress]\n            .rateLimitPerSecond;\n\n        delete rateLimitPerAddress[rateLimitedAddress];\n\n        emit IndividualRateLimitPerSecondUpdate(\n            rateLimitedAddress,\n            oldRateLimitPerSecond,\n            0\n        );\n    }\n\n    // ----------- Getters -----------\n\n    /// @notice the amount of action used before hitting limit\n    /// @dev replenishes at rateLimitPerSecond per second up to bufferCap\n    /// @param rateLimitedAddress the address whose buffer will be returned\n    /// @return the buffer of the specified rate limited address\n    function individualBuffer(address rateLimitedAddress)\n        public\n        view\n        override\n        returns (uint112)\n    {\n        RateLimitData memory rateLimitData = rateLimitPerAddress[\n            rateLimitedAddress\n        ];\n\n        uint256 elapsed = block.timestamp - rateLimitData.lastBufferUsedTime;\n        return\n            uint112(\n                Math.min(\n                    rateLimitData.bufferStored +\n                        (rateLimitData.rateLimitPerSecond * elapsed),\n                    rateLimitData.bufferCap\n                )\n            );\n    }\n\n    /// @notice the rate per second for each address\n    function getRateLimitPerSecond(address limiter)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rateLimitPerAddress[limiter].rateLimitPerSecond;\n    }\n\n    /// @notice the last time the buffer was used by each address\n    function getLastBufferUsedTime(address limiter)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rateLimitPerAddress[limiter].lastBufferUsedTime;\n    }\n\n    /// @notice the cap of the buffer that can be used at once\n    function getBufferCap(address limiter)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rateLimitPerAddress[limiter].bufferCap;\n    }\n\n    // ----------- Helper Methods -----------\n\n    function _updateAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    ) internal {\n        RateLimitData storage rateLimitData = rateLimitPerAddress[\n            rateLimitedAddress\n        ];\n\n        require(\n            rateLimitData.lastBufferUsedTime != 0,\n            \"MultiRateLimited: rate limit address does not exist\"\n        );\n        require(\n            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: rateLimitPerSecond too high\"\n        );\n\n        uint112 oldRateLimitPerSecond = rateLimitData.rateLimitPerSecond;\n\n        rateLimitData.lastBufferUsedTime = block.timestamp.toUint32();\n        rateLimitData.bufferCap = _bufferCap;\n        rateLimitData.rateLimitPerSecond = _rateLimitPerSecond;\n        rateLimitData.bufferStored = _bufferCap;\n\n        emit IndividualRateLimitPerSecondUpdate(\n            rateLimitedAddress,\n            oldRateLimitPerSecond,\n            _rateLimitPerSecond\n        );\n    }\n\n    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress\n    /// @param _rateLimitPerSecond the rate limit per second for this rateLimitedAddress\n    /// @param _bufferCap  the buffer cap for this rateLimitedAddress\n    function _addAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    ) internal {\n        require(\n            _bufferCap <= bufferCap,\n            \"MultiRateLimited: new buffercap too high\"\n        );\n        require(\n            rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime == 0,\n            \"MultiRateLimited: address already added\"\n        );\n        require(\n            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: rateLimitPerSecond too high\"\n        );\n\n        RateLimitData memory rateLimitData = RateLimitData({\n            lastBufferUsedTime: block.timestamp.toUint32(),\n            bufferCap: _bufferCap,\n            rateLimitPerSecond: _rateLimitPerSecond,\n            bufferStored: _bufferCap\n        });\n\n        rateLimitPerAddress[rateLimitedAddress] = rateLimitData;\n\n        emit IndividualRateLimitPerSecondUpdate(\n            rateLimitedAddress,\n            0,\n            _rateLimitPerSecond\n        );\n    }\n\n    /// @notice the method that enforces the rate limit. Decreases buffer by \"amount\".\n    /// @param rateLimitedAddress the address whose buffer will be depleted\n    /// @param amount the amount to remove from the rateLimitedAddress's buffer\n    function _depleteIndividualBuffer(\n        address rateLimitedAddress,\n        uint256 amount\n    ) internal returns (uint256) {\n        _depleteBuffer(amount);\n\n        uint256 newBuffer = individualBuffer(rateLimitedAddress);\n\n        require(newBuffer != 0, \"MultiRateLimited: no rate limit buffer\");\n        require(amount <= newBuffer, \"MultiRateLimited: rate limit hit\");\n\n        rateLimitPerAddress[rateLimitedAddress].bufferStored = uint112(\n            newBuffer - amount\n        );\n\n        rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime = block\n            .timestamp\n            .toUint32();\n\n        emit IndividualBufferUsed(\n            rateLimitedAddress,\n            amount,\n            newBuffer - amount\n        );\n\n        return amount;\n    }\n}"
    },
    {
      "filename": "contracts/utils/MultiRateLimited.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {CoreRef} from \"../refs/CoreRef.sol\";\nimport {TribeRoles} from \"./../core/TribeRoles.sol\";\nimport {RateLimited} from \"./RateLimited.sol\";\nimport {IMultiRateLimited} from \"./IMultiRateLimited.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/// @title abstract contract for putting a rate limit on how fast an address can perform an action e.g. Minting\n/// there are two buffers, one buffer which is each individual addresses's current buffer,\n/// and then there is a global buffer which is the buffer that each individual address must respect as well\n/// @author Elliot Friedman, Fei Protocol\n/// this contract was made abstract so that other contracts that already construct an instance of CoreRef\n/// do not collide with this one\nabstract contract MultiRateLimited is RateLimited, IMultiRateLimited {\n    using SafeCast for *;\n\n    /// @notice the struct containing all information per rate limited address\n    struct RateLimitData {\n        uint32 lastBufferUsedTime;\n        uint112 bufferCap;\n        uint112 bufferStored;\n        uint112 rateLimitPerSecond;\n    }\n\n    /// @notice rate limited address information\n    mapping(address => RateLimitData) public rateLimitPerAddress;\n\n    /// @notice max rate limit per second allowable by non governor per contract\n    uint256 public individualMaxRateLimitPerSecond;\n\n    /// @notice max buffer cap allowable by non governor per contract\n    uint256 public individualMaxBufferCap;\n\n    /// @param _maxRateLimitPerSecond maximum amount of fei that can replenish per second ever, this amount cannot be changed by governance\n    /// @param _rateLimitPerSecond maximum rate limit per second per address\n    /// @param _individualMaxRateLimitPerSecond maximum rate limit per second per address in multi rate limited\n    /// @param _individualMaxBufferCap maximum buffer cap in multi rate limited\n    /// @param _globalBufferCap maximum global buffer cap\n    constructor(\n        uint256 _maxRateLimitPerSecond,\n        uint256 _rateLimitPerSecond,\n        uint256 _individualMaxRateLimitPerSecond,\n        uint256 _individualMaxBufferCap,\n        uint256 _globalBufferCap\n    )\n        RateLimited(\n            _maxRateLimitPerSecond,\n            _rateLimitPerSecond,\n            _globalBufferCap,\n            false\n        )\n    {\n        require(\n            _individualMaxBufferCap < _globalBufferCap,\n            \"MultiRateLimited: max buffer cap invalid\"\n        );\n\n        individualMaxRateLimitPerSecond = _individualMaxRateLimitPerSecond;\n        individualMaxBufferCap = _individualMaxBufferCap;\n    }\n\n    modifier addressIsRegistered(address rateLimitedAddress) {\n        require(\n            rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime != 0,\n            \"MultiRateLimited: rate limit address does not exist\"\n        );\n        _;\n    }\n\n    // ----------- Governor and Admin only state changing api -----------\n\n    /// @notice update the ADD_MINTER_ROLE rate limit per second\n    /// @param newRateLimitPerSecond new maximum rate limit per second for add minter role\n    function updateMaxRateLimitPerSecond(uint256 newRateLimitPerSecond)\n        external\n        virtual\n        override\n        onlyGovernor\n    {\n        require(\n            newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: exceeds global max rate limit per second\"\n        );\n\n        uint256 oldMaxRateLimitPerSecond = individualMaxRateLimitPerSecond;\n        individualMaxRateLimitPerSecond = newRateLimitPerSecond;\n\n        emit MultiMaxRateLimitPerSecondUpdate(\n            oldMaxRateLimitPerSecond,\n            newRateLimitPerSecond\n        );\n    }\n\n    /// @notice update the ADD_MINTER_ROLE max buffer cap\n    /// @param newBufferCap new buffer cap for ADD_MINTER_ROLE added addresses\n    function updateMaxBufferCap(uint256 newBufferCap)\n        external\n        virtual\n        override\n        onlyGovernor\n    {\n        require(\n            newBufferCap <= bufferCap,\n            \"MultiRateLimited: exceeds global buffer cap\"\n        );\n\n        uint256 oldBufferCap = individualMaxBufferCap;\n        individualMaxBufferCap = newBufferCap;\n\n        emit MultiBufferCapUpdate(oldBufferCap, newBufferCap);\n    }\n\n    /// @notice add an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress\n    /// @param _rateLimitPerSecond the rate limit per second for this rateLimitedAddress\n    /// @param _bufferCap  the buffer cap for this rateLimitedAddress\n    function addAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    ) external virtual override onlyGovernor {\n        _addAddress(rateLimitedAddress, _rateLimitPerSecond, _bufferCap);\n    }\n\n    /// @notice add an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the address whose buffer and rate limit per second will be set\n    /// @param _rateLimitPerSecond the new rate limit per second for this rateLimitedAddress\n    /// @param _bufferCap  the new buffer cap for this rateLimitedAddress\n    function updateAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    )\n        external\n        virtual\n        override\n        addressIsRegistered(rateLimitedAddress)\n        hasAnyOfTwoRoles(TribeRoles.ADD_MINTER_ROLE, TribeRoles.GOVERNOR)\n    {\n        if (core().hasRole(TribeRoles.ADD_MINTER_ROLE, msg.sender)) {\n            require(\n                _rateLimitPerSecond <= individualMaxRateLimitPerSecond,\n                \"MultiRateLimited: rate limit per second exceeds non governor allowable amount\"\n            );\n            require(\n                _bufferCap <= individualMaxBufferCap,\n                \"MultiRateLimited: max buffer cap exceeds non governor allowable amount\"\n            );\n        }\n        require(\n            _bufferCap <= bufferCap,\n            \"MultiRateLimited: buffercap too high\"\n        );\n\n        _updateAddress(rateLimitedAddress, _rateLimitPerSecond, _bufferCap);\n    }\n\n    /// @notice add an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress\n    /// gives the newly added contract the maximum allowable rate limit per second and buffer cap\n    function addAddressWithCaps(address rateLimitedAddress)\n        external\n        virtual\n        override\n        onlyTribeRole(TribeRoles.ADD_MINTER_ROLE)\n    {\n        _addAddress(\n            rateLimitedAddress,\n            uint112(individualMaxRateLimitPerSecond),\n            uint112(individualMaxBufferCap)\n        );\n    }\n\n    /// @notice remove an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the address to remove from the whitelist of addresses\n    function removeAddress(address rateLimitedAddress)\n        external\n        virtual\n        override\n        addressIsRegistered(rateLimitedAddress)\n        onlyGuardianOrGovernor\n    {\n        uint256 oldRateLimitPerSecond = rateLimitPerAddress[rateLimitedAddress]\n            .rateLimitPerSecond;\n\n        delete rateLimitPerAddress[rateLimitedAddress];\n\n        emit IndividualRateLimitPerSecondUpdate(\n            rateLimitedAddress,\n            oldRateLimitPerSecond,\n            0\n        );\n    }\n\n    // ----------- Getters -----------\n\n    /// @notice the amount of action used before hitting limit\n    /// @dev replenishes at rateLimitPerSecond per second up to bufferCap\n    /// @param rateLimitedAddress the address whose buffer will be returned\n    /// @return the buffer of the specified rate limited address\n    function individualBuffer(address rateLimitedAddress)\n        public\n        view\n        override\n        returns (uint112)\n    {\n        RateLimitData memory rateLimitData = rateLimitPerAddress[\n            rateLimitedAddress\n        ];\n\n        uint256 elapsed = block.timestamp - rateLimitData.lastBufferUsedTime;\n        return\n            uint112(\n                Math.min(\n                    rateLimitData.bufferStored +\n                        (rateLimitData.rateLimitPerSecond * elapsed),\n                    rateLimitData.bufferCap\n                )\n            );\n    }\n\n    /// @notice the rate per second for each address\n    function getRateLimitPerSecond(address limiter)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rateLimitPerAddress[limiter].rateLimitPerSecond;\n    }\n\n    /// @notice the last time the buffer was used by each address\n    function getLastBufferUsedTime(address limiter)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rateLimitPerAddress[limiter].lastBufferUsedTime;\n    }\n\n    /// @notice the cap of the buffer that can be used at once\n    function getBufferCap(address limiter)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rateLimitPerAddress[limiter].bufferCap;\n    }\n\n    // ----------- Helper Methods -----------\n\n    function _updateAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    ) internal {\n        RateLimitData storage rateLimitData = rateLimitPerAddress[\n            rateLimitedAddress\n        ];\n\n        require(\n            rateLimitData.lastBufferUsedTime != 0,\n            \"MultiRateLimited: rate limit address does not exist\"\n        );\n        require(\n            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: rateLimitPerSecond too high\"\n        );\n\n        uint112 oldRateLimitPerSecond = rateLimitData.rateLimitPerSecond;\n\n        rateLimitData.lastBufferUsedTime = block.timestamp.toUint32();\n        rateLimitData.bufferCap = _bufferCap;\n        rateLimitData.rateLimitPerSecond = _rateLimitPerSecond;\n        rateLimitData.bufferStored = _bufferCap;\n\n        emit IndividualRateLimitPerSecondUpdate(\n            rateLimitedAddress,\n            oldRateLimitPerSecond,\n            _rateLimitPerSecond\n        );\n    }\n\n    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress\n    /// @param _rateLimitPerSecond the rate limit per second for this rateLimitedAddress\n    /// @param _bufferCap  the buffer cap for this rateLimitedAddress\n    function _addAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    ) internal {\n        require(\n            _bufferCap <= bufferCap,\n            \"MultiRateLimited: new buffercap too high\"\n        );\n        require(\n            rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime == 0,\n            \"MultiRateLimited: address already added\"\n        );\n        require(\n            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: rateLimitPerSecond too high\"\n        );\n\n        RateLimitData memory rateLimitData = RateLimitData({\n            lastBufferUsedTime: block.timestamp.toUint32(),\n            bufferCap: _bufferCap,\n            rateLimitPerSecond: _rateLimitPerSecond,\n            bufferStored: _bufferCap\n        });\n\n        rateLimitPerAddress[rateLimitedAddress] = rateLimitData;\n\n        emit IndividualRateLimitPerSecondUpdate(\n            rateLimitedAddress,\n            0,\n            _rateLimitPerSecond\n        );\n    }\n\n    /// @notice the method that enforces the rate limit. Decreases buffer by \"amount\".\n    /// @param rateLimitedAddress the address whose buffer will be depleted\n    /// @param amount the amount to remove from the rateLimitedAddress's buffer\n    function _depleteIndividualBuffer(\n        address rateLimitedAddress,\n        uint256 amount\n    ) internal returns (uint256) {\n        _depleteBuffer(amount);\n\n        uint256 newBuffer = individualBuffer(rateLimitedAddress);\n\n        require(newBuffer != 0, \"MultiRateLimited: no rate limit buffer\");\n        require(amount <= newBuffer, \"MultiRateLimited: rate limit hit\");\n\n        rateLimitPerAddress[rateLimitedAddress].bufferStored = uint112(\n            newBuffer - amount\n        );\n\n        rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime = block\n            .timestamp\n            .toUint32();\n\n        emit IndividualBufferUsed(\n            rateLimitedAddress,\n            amount,\n            newBuffer - amount\n        );\n\n        return amount;\n    }\n}"
    },
    {
      "filename": "contracts/utils/RateLimited.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../refs/CoreRef.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title abstract contract for putting a rate limit on how fast a contract can perform an action e.g. Minting\n/// @author Fei Protocol\nabstract contract RateLimited is CoreRef {\n    /// @notice maximum rate limit per second governance can set for this contract\n    uint256 public immutable MAX_RATE_LIMIT_PER_SECOND;\n\n    /// @notice the rate per second for this contract\n    uint256 public rateLimitPerSecond;\n\n    /// @notice the last time the buffer was used by the contract\n    uint256 public lastBufferUsedTime;\n\n    /// @notice the cap of the buffer that can be used at once\n    uint256 public bufferCap;\n\n    /// @notice a flag for whether to allow partial actions to complete if the buffer is less than amount\n    bool public doPartialAction;\n\n    /// @notice the buffer at the timestamp of lastBufferUsedTime\n    uint256 public bufferStored;\n\n    event BufferUsed(uint256 amountUsed, uint256 bufferRemaining);\n    event BufferCapUpdate(uint256 oldBufferCap, uint256 newBufferCap);\n    event RateLimitPerSecondUpdate(\n        uint256 oldRateLimitPerSecond,\n        uint256 newRateLimitPerSecond\n    );\n\n    constructor(\n        uint256 _maxRateLimitPerSecond,\n        uint256 _rateLimitPerSecond,\n        uint256 _bufferCap,\n        bool _doPartialAction\n    ) {\n        lastBufferUsedTime = block.timestamp;\n\n        _setBufferCap(_bufferCap);\n        bufferStored = _bufferCap;\n\n        require(\n            _rateLimitPerSecond <= _maxRateLimitPerSecond,\n            \"RateLimited: rateLimitPerSecond too high\"\n        );\n        _setRateLimitPerSecond(_rateLimitPerSecond);\n\n        MAX_RATE_LIMIT_PER_SECOND = _maxRateLimitPerSecond;\n        doPartialAction = _doPartialAction;\n    }\n\n    /// @notice set the rate limit per second\n    function setRateLimitPerSecond(uint256 newRateLimitPerSecond)\n        external\n        virtual\n        onlyGovernorOrAdmin\n    {\n        require(\n            newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"RateLimited: rateLimitPerSecond too high\"\n        );\n        _updateBufferStored();\n\n        _setRateLimitPerSecond(newRateLimitPerSecond);\n    }\n\n    /// @notice set the buffer cap\n    function setBufferCap(uint256 newBufferCap)\n        external\n        virtual\n        onlyGovernorOrAdmin\n    {\n        _setBufferCap(newBufferCap);\n    }\n\n    /// @notice the amount of action used before hitting limit\n    /// @dev replenishes at rateLimitPerSecond per second up to bufferCap\n    function buffer() public view returns (uint256) {\n        uint256 elapsed = block.timestamp - lastBufferUsedTime;\n        return\n            Math.min(bufferStored + (rateLimitPerSecond * elapsed), bufferCap);\n    }\n\n    /** \n        @notice the method that enforces the rate limit. Decreases buffer by \"amount\". \n        If buffer is <= amount either\n        1. Does a partial mint by the amount remaining in the buffer or\n        2. Reverts\n        Depending on whether doPartialAction is true or false\n    */\n    function _depleteBuffer(uint256 amount) internal virtual returns (uint256) {\n        uint256 newBuffer = buffer();\n\n        uint256 usedAmount = amount;\n        if (doPartialAction && usedAmount > newBuffer) {\n            usedAmount = newBuffer;\n        }\n\n        require(newBuffer != 0, \"RateLimited: no rate limit buffer\");\n        require(usedAmount <= newBuffer, \"RateLimited: rate limit hit\");\n\n        bufferStored = newBuffer - usedAmount;\n\n        lastBufferUsedTime = block.timestamp;\n\n        emit BufferUsed(usedAmount, bufferStored);\n\n        return usedAmount;\n    }\n\n    /// @notice function to replenish buffer\n    /// @param amount to increase buffer by if under buffer cap\n    function _replenishBuffer(uint256 amount) internal {\n        uint256 newBuffer = buffer();\n\n        uint256 _bufferCap = bufferCap; /// gas opti, save an SLOAD\n\n        /// cannot replenish any further if already at buffer cap\n        if (newBuffer == _bufferCap) {\n            return;\n        }\n\n        /// ensure that bufferStored cannot be gt buffer cap\n        bufferStored = Math.min(newBuffer + amount, _bufferCap);\n    }\n\n    function _setRateLimitPerSecond(uint256 newRateLimitPerSecond) internal {\n        uint256 oldRateLimitPerSecond = rateLimitPerSecond;\n        rateLimitPerSecond = newRateLimitPerSecond;\n\n        emit RateLimitPerSecondUpdate(\n            oldRateLimitPerSecond,\n            newRateLimitPerSecond\n        );\n    }\n\n    function _setBufferCap(uint256 newBufferCap) internal {\n        _updateBufferStored();\n\n        uint256 oldBufferCap = bufferCap;\n        bufferCap = newBufferCap;\n\n        emit BufferCapUpdate(oldBufferCap, newBufferCap);\n    }\n\n    function _resetBuffer() internal {\n        bufferStored = bufferCap;\n    }\n\n    function _updateBufferStored() internal {\n        bufferStored = buffer();\n        lastBufferUsedTime = block.timestamp;\n    }\n}"
    }
  ]
}