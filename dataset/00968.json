{
  "Title": "Positions may be liquidated due to incorrect implementation of Oracle logic",
  "Content": "# Positions may be liquidated due to incorrect implementation of Oracle logic\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/oracles/ChainlinkARBOracle.sol#L210\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/oracles/ChainlinkARBOracle.sol#L210</a>\n\n\n## Summary\n\nSteadefi checks for historical data to make sure that last price update are within maximum delya allowed and in the range of maximum % deviation allowed.\n\nBut checking the historical data is incorrect according to the chainlink docs which can damage some serious logic with in the protcol\n\n## Vulnerability Details\n\nVault calls [ChainlinkARBOracle.consult(token)]() to get the fair price from chainlink oracle\n\n```solidity\nFile:\n\n  function consult(address token) public view whenNotPaused returns (int256, uint8) {\n    address _feed = feeds[token];\n\n    if (_feed == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n\n    ChainlinkResponse memory chainlinkResponse = _getChainlinkResponse(_feed);\n    ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(_feed, chainlinkResponse.roundId);//@audit incorrect way to get historical data\n    if (_chainlinkIsFrozen(chainlinkResponse, token)) revert Errors.FrozenTokenPriceFeed();\n    if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse, token)) revert Errors.BrokenTokenPriceFeed();\n\n return (chainlinkResponse.answer, chainlinkResponse.decimals);\n  }\n\n```\nhttps://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/oracles/ChainlinkARBOracle.sol#L62\n\nwhich calls an interval function `_getPrevChainlinkResponse()` and try to fetch previous roundId price and other details\n\n```solidity\n  function _getPrevChainlinkResponse(address _feed, uint80 _currentRoundId) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _prevChainlinkResponse;\n\n    (\n      uint80 _roundId,\n      int256 _answer,\n      /* uint256 _startedAt */,\n      uint256 _timestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).getRoundData(_currentRoundId - 1);\n\n    _prevChainlinkResponse.roundId = _roundId;\n    _prevChainlinkResponse.answer = _answer;\n    _prevChainlinkResponse.timestamp = _timestamp;\n    _prevChainlinkResponse.success = true;\n\n    return _prevChainlinkResponse;\n  }\n\n```\nhttps://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/oracles/ChainlinkARBOracle.sol#L210\n\nBut this is incorrect way of fetching historical data. \nchainlink docs say: `Oracles provide periodic data updates to the aggregators. Data feeds are updated in rounds. Rounds are identified by their roundId, which increases with each new round. This increase may not be monotonic. Knowing the roundId of a previous round allows contracts to consume historical data.\n\nThe examples in this document name the aggregator roundId as aggregatorRoundId to differentiate it from the proxy roundId.` [check here](https://docs.chain.link/data-feeds/historical-data#roundid-in-aggregator-aggregatorroundid)\n\nso it is not mendatory that there will be valid data for currentRoundID-1.\nif there is not data for currentRooundId-1 then `_badPriceDeviation(currChainlinkResponse,PrevResponse)` [check here](https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/oracles/ChainlinkARBOracle.sol#L142) will return true. Hence vault won't able to get the price of token at some specific times\n## Impact\n1. In worse case keeper won't able to get the price of token so rebalancing , debt repay won't be possible leading to liquidation breaking the main important factor of protocol\n2. Almost 70% of vault action is dependent on price of a token and not getting price will make them inactive affecting net APR \n\n## Tools Used\nManual Review\n## Recommendations\n\nAs chainlink docs says. Increase in roundId may not be monotonic so loop through the previous roundID and fetch the previoous roundId data\n\npseudo  code\n```solidity\n iterate (from roundId-1 to untill we get previous first data corressponding to roundID){\n    if(data present for roundID){\n        fetch the data and return\n    }else{\n        again iterate to get the data\n    }\n }\n\n```\n",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/oracles/ChainlinkARBOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\n\ncontract ChainlinkARBOracle is Ownable2Step, Pausable {\n  using SafeCast for int256;\n\n  /* ======================= STRUCTS ========================= */\n\n  struct ChainlinkResponse {\n    uint80 roundId;\n    int256 answer;\n    uint256 timestamp;\n    bool success;\n    uint8 decimals;\n  }\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant SEQUENCER_GRACE_PERIOD_TIME = 1 hours;\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // Chainlink Arbitrum sequencer feed address\n  AggregatorV3Interface internal sequencerUptimeFeed;\n\n  /* ======================= MAPPINGS ======================== */\n\n  // Mapping of token to Chainlink USD price feed\n  mapping(address => address) public feeds;\n  // Mapping of token to maximum delay allowed (in seconds) of last price update\n  mapping(address => uint256) public maxDelays;\n  // Mapping of token to maximum % deviation allowed (in 1e18) of last price update\n  mapping(address => uint256) public maxDeviations;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @param sequencerFeed  Chainlink Arbitrum sequencer feed address\n  */\n  constructor(address sequencerFeed) Ownable(msg.sender) {\n    if (sequencerFeed == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    sequencerUptimeFeed = AggregatorV3Interface(sequencerFeed);\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Get token price from Chainlink feed\n    * @param token Token address\n    * @return price Asset price in int256\n    * @return decimals Price decimals in uint8\n  */\n  function consult(address token) public view whenNotPaused returns (int256, uint8) {\n    address _feed = feeds[token];\n\n    if (_feed == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n\n    ChainlinkResponse memory chainlinkResponse = _getChainlinkResponse(_feed);\n    ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(_feed, chainlinkResponse.roundId);\n\n    if (_chainlinkIsFrozen(chainlinkResponse, token)) revert Errors.FrozenTokenPriceFeed();\n    if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse, token)) revert Errors.BrokenTokenPriceFeed();\n\n    return (chainlinkResponse.answer, chainlinkResponse.decimals);\n  }\n\n  /**\n    * @notice Get token price from Chainlink feed returned in 1e18\n    * @param token Token address\n    * @return price in 1e18\n  */\n  function consultIn18Decimals(address token) external view whenNotPaused returns (uint256) {\n    (int256 _answer, uint8 _decimals) = consult(token);\n\n    return _answer.toUint256() * 1e18 / (10 ** _decimals);\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Check if Chainlink oracle is not working as expected\n    * @param currentResponse Current Chainlink response\n    * @param prevResponse Previous Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _chainlinkIsBroken(\n    ChainlinkResponse memory currentResponse,\n    ChainlinkResponse memory prevResponse,\n    address token\n  ) internal view returns (bool) {\n    return _badChainlinkResponse(currentResponse) ||\n           _badChainlinkResponse(prevResponse) ||\n           _badPriceDeviation(currentResponse, prevResponse, token);\n  }\n\n  /**\n    * @notice Checks to see if Chainlink oracle is returning a bad response\n    * @param response Chainlink response\n    * @return Status of check in boolean\n  */\n  function _badChainlinkResponse(ChainlinkResponse memory response) internal view returns (bool) {\n    // Check for response call reverted\n    if (!response.success) { return true; }\n    // Check for an invalid roundId that is 0\n    if (response.roundId == 0) { return true; }\n    // Check for an invalid timeStamp that is 0, or in the future\n    if (response.timestamp == 0 || response.timestamp > block.timestamp) { return true; }\n    // Check for non-positive price\n    if (response.answer == 0) { return true; }\n\n    return false;\n  }\n\n  /**\n    * @notice Check to see if Chainlink oracle response is frozen/too stale\n    * @param response Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _chainlinkIsFrozen(ChainlinkResponse memory response, address token) internal view returns (bool) {\n    return (block.timestamp - response.timestamp) > maxDelays[token];\n  }\n\n  /**\n    * @notice Check to see if Chainlink oracle current response's price price deviation\n    * is too large compared to previous response's price\n    * @param currentResponse Current Chainlink response\n    * @param prevResponse Previous Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _badPriceDeviation(\n    ChainlinkResponse memory currentResponse,\n    ChainlinkResponse memory prevResponse,\n    address token\n  ) internal view returns (bool) {\n    // Check for a deviation that is too large\n    uint256 _deviation;\n\n    if (currentResponse.answer > prevResponse.answer) {\n      _deviation = uint256(currentResponse.answer - prevResponse.answer) * SAFE_MULTIPLIER / uint256(prevResponse.answer);\n    } else {\n      _deviation = uint256(prevResponse.answer - currentResponse.answer) * SAFE_MULTIPLIER / uint256(prevResponse.answer);\n    }\n\n    return _deviation > maxDeviations[token];\n  }\n\n  /**\n    * @notice Get latest Chainlink response\n    * @param _feed Chainlink oracle feed address\n    * @return ChainlinkResponse\n  */\n  function _getChainlinkResponse(address _feed) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _chainlinkResponse;\n\n    _chainlinkResponse.decimals = AggregatorV3Interface(_feed).decimals();\n\n    // Arbitrum sequencer uptime feed\n    (\n      /* uint80 _roundID*/,\n      int256 _answer,\n      uint256 _startedAt,\n      /* uint256 _updatedAt */,\n      /* uint80 _answeredInRound */\n    ) = sequencerUptimeFeed.latestRoundData();\n\n    // Answer == 0: Sequencer is up\n    // Answer == 1: Sequencer is down\n    bool _isSequencerUp = _answer == 0;\n    if (!_isSequencerUp) revert Errors.SequencerDown();\n\n    // Make sure the grace period has passed after the\n    // sequencer is back up.\n    uint256 _timeSinceUp = block.timestamp - _startedAt;\n    if (_timeSinceUp <= SEQUENCER_GRACE_PERIOD_TIME) revert Errors.GracePeriodNotOver();\n\n    (\n      uint80 _latestRoundId,\n      int256 _latestAnswer,\n      /* uint256 _startedAt */,\n      uint256 _latestTimestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).latestRoundData();\n\n    _chainlinkResponse.roundId = _latestRoundId;\n    _chainlinkResponse.answer = _latestAnswer;\n    _chainlinkResponse.timestamp = _latestTimestamp;\n    _chainlinkResponse.success = true;\n\n    return _chainlinkResponse;\n  }\n\n  /**\n    * @notice Get previous round's Chainlink response from current round\n    * @param _feed Chainlink oracle feed address\n    * @param _currentRoundId Current roundId from current Chainlink response\n    * @return ChainlinkResponse\n  */\n  function _getPrevChainlinkResponse(address _feed, uint80 _currentRoundId) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _prevChainlinkResponse;\n\n    (\n      uint80 _roundId,\n      int256 _answer,\n      /* uint256 _startedAt */,\n      uint256 _timestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).getRoundData(_currentRoundId - 1);\n\n    _prevChainlinkResponse.roundId = _roundId;\n    _prevChainlinkResponse.answer = _answer;\n    _prevChainlinkResponse.timestamp = _timestamp;\n    _prevChainlinkResponse.success = true;\n\n    return _prevChainlinkResponse;\n  }\n\n  /* ================= RESTRICTED FUNCTIONS ================== */\n\n  /**\n    * @notice Add Chainlink price feed for token\n    * @param token Token address\n    * @param feed Chainlink price feed address\n  */\n  function addTokenPriceFeed(address token, address feed) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feed == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] != address(0)) revert Errors.TokenPriceFeedAlreadySet();\n\n    feeds[token] = feed;\n  }\n\n  /**\n    * @notice Add Chainlink max delay for token\n    * @param token Token address\n    * @param maxDelay  Max delay allowed in seconds\n  */\n  function addTokenMaxDelay(address token, uint256 maxDelay) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n    if (maxDelay < 0) revert Errors.TokenPriceFeedMaxDelayMustBeGreaterOrEqualToZero();\n\n    maxDelays[token] = maxDelay;\n  }\n\n  /**\n    * @notice Add Chainlink max deviation for token\n    * @param token Token address\n    * @param maxDeviation  Max deviation allowed in seconds\n  */\n  function addTokenMaxDeviation(address token, uint256 maxDeviation) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n    if (maxDeviation < 0) revert Errors.TokenPriceFeedMaxDeviationMustBeGreaterOrEqualToZero();\n\n    maxDeviations[token] = maxDeviation;\n  }\n\n  /**\n    * @notice Emergency pause of this oracle\n  */\n  function emergencyPause() external onlyOwner whenNotPaused {\n    _pause();\n  }\n\n  /**\n    * @notice Emergency resume of this oracle\n  */\n  function emergencyResume() external onlyOwner whenPaused {\n    _unpause();\n  }\n}"
    },
    {
      "filename": "contracts/oracles/ChainlinkARBOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\n\ncontract ChainlinkARBOracle is Ownable2Step, Pausable {\n  using SafeCast for int256;\n\n  /* ======================= STRUCTS ========================= */\n\n  struct ChainlinkResponse {\n    uint80 roundId;\n    int256 answer;\n    uint256 timestamp;\n    bool success;\n    uint8 decimals;\n  }\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant SEQUENCER_GRACE_PERIOD_TIME = 1 hours;\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // Chainlink Arbitrum sequencer feed address\n  AggregatorV3Interface internal sequencerUptimeFeed;\n\n  /* ======================= MAPPINGS ======================== */\n\n  // Mapping of token to Chainlink USD price feed\n  mapping(address => address) public feeds;\n  // Mapping of token to maximum delay allowed (in seconds) of last price update\n  mapping(address => uint256) public maxDelays;\n  // Mapping of token to maximum % deviation allowed (in 1e18) of last price update\n  mapping(address => uint256) public maxDeviations;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @param sequencerFeed  Chainlink Arbitrum sequencer feed address\n  */\n  constructor(address sequencerFeed) Ownable(msg.sender) {\n    if (sequencerFeed == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    sequencerUptimeFeed = AggregatorV3Interface(sequencerFeed);\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Get token price from Chainlink feed\n    * @param token Token address\n    * @return price Asset price in int256\n    * @return decimals Price decimals in uint8\n  */\n  function consult(address token) public view whenNotPaused returns (int256, uint8) {\n    address _feed = feeds[token];\n\n    if (_feed == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n\n    ChainlinkResponse memory chainlinkResponse = _getChainlinkResponse(_feed);\n    ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(_feed, chainlinkResponse.roundId);\n\n    if (_chainlinkIsFrozen(chainlinkResponse, token)) revert Errors.FrozenTokenPriceFeed();\n    if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse, token)) revert Errors.BrokenTokenPriceFeed();\n\n    return (chainlinkResponse.answer, chainlinkResponse.decimals);\n  }\n\n  /**\n    * @notice Get token price from Chainlink feed returned in 1e18\n    * @param token Token address\n    * @return price in 1e18\n  */\n  function consultIn18Decimals(address token) external view whenNotPaused returns (uint256) {\n    (int256 _answer, uint8 _decimals) = consult(token);\n\n    return _answer.toUint256() * 1e18 / (10 ** _decimals);\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Check if Chainlink oracle is not working as expected\n    * @param currentResponse Current Chainlink response\n    * @param prevResponse Previous Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _chainlinkIsBroken(\n    ChainlinkResponse memory currentResponse,\n    ChainlinkResponse memory prevResponse,\n    address token\n  ) internal view returns (bool) {\n    return _badChainlinkResponse(currentResponse) ||\n           _badChainlinkResponse(prevResponse) ||\n           _badPriceDeviation(currentResponse, prevResponse, token);\n  }\n\n  /**\n    * @notice Checks to see if Chainlink oracle is returning a bad response\n    * @param response Chainlink response\n    * @return Status of check in boolean\n  */\n  function _badChainlinkResponse(ChainlinkResponse memory response) internal view returns (bool) {\n    // Check for response call reverted\n    if (!response.success) { return true; }\n    // Check for an invalid roundId that is 0\n    if (response.roundId == 0) { return true; }\n    // Check for an invalid timeStamp that is 0, or in the future\n    if (response.timestamp == 0 || response.timestamp > block.timestamp) { return true; }\n    // Check for non-positive price\n    if (response.answer == 0) { return true; }\n\n    return false;\n  }\n\n  /**\n    * @notice Check to see if Chainlink oracle response is frozen/too stale\n    * @param response Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _chainlinkIsFrozen(ChainlinkResponse memory response, address token) internal view returns (bool) {\n    return (block.timestamp - response.timestamp) > maxDelays[token];\n  }\n\n  /**\n    * @notice Check to see if Chainlink oracle current response's price price deviation\n    * is too large compared to previous response's price\n    * @param currentResponse Current Chainlink response\n    * @param prevResponse Previous Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _badPriceDeviation(\n    ChainlinkResponse memory currentResponse,\n    ChainlinkResponse memory prevResponse,\n    address token\n  ) internal view returns (bool) {\n    // Check for a deviation that is too large\n    uint256 _deviation;\n\n    if (currentResponse.answer > prevResponse.answer) {\n      _deviation = uint256(currentResponse.answer - prevResponse.answer) * SAFE_MULTIPLIER / uint256(prevResponse.answer);\n    } else {\n      _deviation = uint256(prevResponse.answer - currentResponse.answer) * SAFE_MULTIPLIER / uint256(prevResponse.answer);\n    }\n\n    return _deviation > maxDeviations[token];\n  }\n\n  /**\n    * @notice Get latest Chainlink response\n    * @param _feed Chainlink oracle feed address\n    * @return ChainlinkResponse\n  */\n  function _getChainlinkResponse(address _feed) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _chainlinkResponse;\n\n    _chainlinkResponse.decimals = AggregatorV3Interface(_feed).decimals();\n\n    // Arbitrum sequencer uptime feed\n    (\n      /* uint80 _roundID*/,\n      int256 _answer,\n      uint256 _startedAt,\n      /* uint256 _updatedAt */,\n      /* uint80 _answeredInRound */\n    ) = sequencerUptimeFeed.latestRoundData();\n\n    // Answer == 0: Sequencer is up\n    // Answer == 1: Sequencer is down\n    bool _isSequencerUp = _answer == 0;\n    if (!_isSequencerUp) revert Errors.SequencerDown();\n\n    // Make sure the grace period has passed after the\n    // sequencer is back up.\n    uint256 _timeSinceUp = block.timestamp - _startedAt;\n    if (_timeSinceUp <= SEQUENCER_GRACE_PERIOD_TIME) revert Errors.GracePeriodNotOver();\n\n    (\n      uint80 _latestRoundId,\n      int256 _latestAnswer,\n      /* uint256 _startedAt */,\n      uint256 _latestTimestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).latestRoundData();\n\n    _chainlinkResponse.roundId = _latestRoundId;\n    _chainlinkResponse.answer = _latestAnswer;\n    _chainlinkResponse.timestamp = _latestTimestamp;\n    _chainlinkResponse.success = true;\n\n    return _chainlinkResponse;\n  }\n\n  /**\n    * @notice Get previous round's Chainlink response from current round\n    * @param _feed Chainlink oracle feed address\n    * @param _currentRoundId Current roundId from current Chainlink response\n    * @return ChainlinkResponse\n  */\n  function _getPrevChainlinkResponse(address _feed, uint80 _currentRoundId) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _prevChainlinkResponse;\n\n    (\n      uint80 _roundId,\n      int256 _answer,\n      /* uint256 _startedAt */,\n      uint256 _timestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).getRoundData(_currentRoundId - 1);\n\n    _prevChainlinkResponse.roundId = _roundId;\n    _prevChainlinkResponse.answer = _answer;\n    _prevChainlinkResponse.timestamp = _timestamp;\n    _prevChainlinkResponse.success = true;\n\n    return _prevChainlinkResponse;\n  }\n\n  /* ================= RESTRICTED FUNCTIONS ================== */\n\n  /**\n    * @notice Add Chainlink price feed for token\n    * @param token Token address\n    * @param feed Chainlink price feed address\n  */\n  function addTokenPriceFeed(address token, address feed) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feed == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] != address(0)) revert Errors.TokenPriceFeedAlreadySet();\n\n    feeds[token] = feed;\n  }\n\n  /**\n    * @notice Add Chainlink max delay for token\n    * @param token Token address\n    * @param maxDelay  Max delay allowed in seconds\n  */\n  function addTokenMaxDelay(address token, uint256 maxDelay) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n    if (maxDelay < 0) revert Errors.TokenPriceFeedMaxDelayMustBeGreaterOrEqualToZero();\n\n    maxDelays[token] = maxDelay;\n  }\n\n  /**\n    * @notice Add Chainlink max deviation for token\n    * @param token Token address\n    * @param maxDeviation  Max deviation allowed in seconds\n  */\n  function addTokenMaxDeviation(address token, uint256 maxDeviation) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n    if (maxDeviation < 0) revert Errors.TokenPriceFeedMaxDeviationMustBeGreaterOrEqualToZero();\n\n    maxDeviations[token] = maxDeviation;\n  }\n\n  /**\n    * @notice Emergency pause of this oracle\n  */\n  function emergencyPause() external onlyOwner whenNotPaused {\n    _pause();\n  }\n\n  /**\n    * @notice Emergency resume of this oracle\n  */\n  function emergencyResume() external onlyOwner whenPaused {\n    _unpause();\n  }\n}"
    },
    {
      "filename": "contracts/oracles/ChainlinkARBOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\n\ncontract ChainlinkARBOracle is Ownable2Step, Pausable {\n  using SafeCast for int256;\n\n  /* ======================= STRUCTS ========================= */\n\n  struct ChainlinkResponse {\n    uint80 roundId;\n    int256 answer;\n    uint256 timestamp;\n    bool success;\n    uint8 decimals;\n  }\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant SEQUENCER_GRACE_PERIOD_TIME = 1 hours;\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // Chainlink Arbitrum sequencer feed address\n  AggregatorV3Interface internal sequencerUptimeFeed;\n\n  /* ======================= MAPPINGS ======================== */\n\n  // Mapping of token to Chainlink USD price feed\n  mapping(address => address) public feeds;\n  // Mapping of token to maximum delay allowed (in seconds) of last price update\n  mapping(address => uint256) public maxDelays;\n  // Mapping of token to maximum % deviation allowed (in 1e18) of last price update\n  mapping(address => uint256) public maxDeviations;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @param sequencerFeed  Chainlink Arbitrum sequencer feed address\n  */\n  constructor(address sequencerFeed) Ownable(msg.sender) {\n    if (sequencerFeed == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    sequencerUptimeFeed = AggregatorV3Interface(sequencerFeed);\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Get token price from Chainlink feed\n    * @param token Token address\n    * @return price Asset price in int256\n    * @return decimals Price decimals in uint8\n  */\n  function consult(address token) public view whenNotPaused returns (int256, uint8) {\n    address _feed = feeds[token];\n\n    if (_feed == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n\n    ChainlinkResponse memory chainlinkResponse = _getChainlinkResponse(_feed);\n    ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(_feed, chainlinkResponse.roundId);\n\n    if (_chainlinkIsFrozen(chainlinkResponse, token)) revert Errors.FrozenTokenPriceFeed();\n    if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse, token)) revert Errors.BrokenTokenPriceFeed();\n\n    return (chainlinkResponse.answer, chainlinkResponse.decimals);\n  }\n\n  /**\n    * @notice Get token price from Chainlink feed returned in 1e18\n    * @param token Token address\n    * @return price in 1e18\n  */\n  function consultIn18Decimals(address token) external view whenNotPaused returns (uint256) {\n    (int256 _answer, uint8 _decimals) = consult(token);\n\n    return _answer.toUint256() * 1e18 / (10 ** _decimals);\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Check if Chainlink oracle is not working as expected\n    * @param currentResponse Current Chainlink response\n    * @param prevResponse Previous Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _chainlinkIsBroken(\n    ChainlinkResponse memory currentResponse,\n    ChainlinkResponse memory prevResponse,\n    address token\n  ) internal view returns (bool) {\n    return _badChainlinkResponse(currentResponse) ||\n           _badChainlinkResponse(prevResponse) ||\n           _badPriceDeviation(currentResponse, prevResponse, token);\n  }\n\n  /**\n    * @notice Checks to see if Chainlink oracle is returning a bad response\n    * @param response Chainlink response\n    * @return Status of check in boolean\n  */\n  function _badChainlinkResponse(ChainlinkResponse memory response) internal view returns (bool) {\n    // Check for response call reverted\n    if (!response.success) { return true; }\n    // Check for an invalid roundId that is 0\n    if (response.roundId == 0) { return true; }\n    // Check for an invalid timeStamp that is 0, or in the future\n    if (response.timestamp == 0 || response.timestamp > block.timestamp) { return true; }\n    // Check for non-positive price\n    if (response.answer == 0) { return true; }\n\n    return false;\n  }\n\n  /**\n    * @notice Check to see if Chainlink oracle response is frozen/too stale\n    * @param response Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _chainlinkIsFrozen(ChainlinkResponse memory response, address token) internal view returns (bool) {\n    return (block.timestamp - response.timestamp) > maxDelays[token];\n  }\n\n  /**\n    * @notice Check to see if Chainlink oracle current response's price price deviation\n    * is too large compared to previous response's price\n    * @param currentResponse Current Chainlink response\n    * @param prevResponse Previous Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _badPriceDeviation(\n    ChainlinkResponse memory currentResponse,\n    ChainlinkResponse memory prevResponse,\n    address token\n  ) internal view returns (bool) {\n    // Check for a deviation that is too large\n    uint256 _deviation;\n\n    if (currentResponse.answer > prevResponse.answer) {\n      _deviation = uint256(currentResponse.answer - prevResponse.answer) * SAFE_MULTIPLIER / uint256(prevResponse.answer);\n    } else {\n      _deviation = uint256(prevResponse.answer - currentResponse.answer) * SAFE_MULTIPLIER / uint256(prevResponse.answer);\n    }\n\n    return _deviation > maxDeviations[token];\n  }\n\n  /**\n    * @notice Get latest Chainlink response\n    * @param _feed Chainlink oracle feed address\n    * @return ChainlinkResponse\n  */\n  function _getChainlinkResponse(address _feed) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _chainlinkResponse;\n\n    _chainlinkResponse.decimals = AggregatorV3Interface(_feed).decimals();\n\n    // Arbitrum sequencer uptime feed\n    (\n      /* uint80 _roundID*/,\n      int256 _answer,\n      uint256 _startedAt,\n      /* uint256 _updatedAt */,\n      /* uint80 _answeredInRound */\n    ) = sequencerUptimeFeed.latestRoundData();\n\n    // Answer == 0: Sequencer is up\n    // Answer == 1: Sequencer is down\n    bool _isSequencerUp = _answer == 0;\n    if (!_isSequencerUp) revert Errors.SequencerDown();\n\n    // Make sure the grace period has passed after the\n    // sequencer is back up.\n    uint256 _timeSinceUp = block.timestamp - _startedAt;\n    if (_timeSinceUp <= SEQUENCER_GRACE_PERIOD_TIME) revert Errors.GracePeriodNotOver();\n\n    (\n      uint80 _latestRoundId,\n      int256 _latestAnswer,\n      /* uint256 _startedAt */,\n      uint256 _latestTimestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).latestRoundData();\n\n    _chainlinkResponse.roundId = _latestRoundId;\n    _chainlinkResponse.answer = _latestAnswer;\n    _chainlinkResponse.timestamp = _latestTimestamp;\n    _chainlinkResponse.success = true;\n\n    return _chainlinkResponse;\n  }\n\n  /**\n    * @notice Get previous round's Chainlink response from current round\n    * @param _feed Chainlink oracle feed address\n    * @param _currentRoundId Current roundId from current Chainlink response\n    * @return ChainlinkResponse\n  */\n  function _getPrevChainlinkResponse(address _feed, uint80 _currentRoundId) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _prevChainlinkResponse;\n\n    (\n      uint80 _roundId,\n      int256 _answer,\n      /* uint256 _startedAt */,\n      uint256 _timestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).getRoundData(_currentRoundId - 1);\n\n    _prevChainlinkResponse.roundId = _roundId;\n    _prevChainlinkResponse.answer = _answer;\n    _prevChainlinkResponse.timestamp = _timestamp;\n    _prevChainlinkResponse.success = true;\n\n    return _prevChainlinkResponse;\n  }\n\n  /* ================= RESTRICTED FUNCTIONS ================== */\n\n  /**\n    * @notice Add Chainlink price feed for token\n    * @param token Token address\n    * @param feed Chainlink price feed address\n  */\n  function addTokenPriceFeed(address token, address feed) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feed == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] != address(0)) revert Errors.TokenPriceFeedAlreadySet();\n\n    feeds[token] = feed;\n  }\n\n  /**\n    * @notice Add Chainlink max delay for token\n    * @param token Token address\n    * @param maxDelay  Max delay allowed in seconds\n  */\n  function addTokenMaxDelay(address token, uint256 maxDelay) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n    if (maxDelay < 0) revert Errors.TokenPriceFeedMaxDelayMustBeGreaterOrEqualToZero();\n\n    maxDelays[token] = maxDelay;\n  }\n\n  /**\n    * @notice Add Chainlink max deviation for token\n    * @param token Token address\n    * @param maxDeviation  Max deviation allowed in seconds\n  */\n  function addTokenMaxDeviation(address token, uint256 maxDeviation) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n    if (maxDeviation < 0) revert Errors.TokenPriceFeedMaxDeviationMustBeGreaterOrEqualToZero();\n\n    maxDeviations[token] = maxDeviation;\n  }\n\n  /**\n    * @notice Emergency pause of this oracle\n  */\n  function emergencyPause() external onlyOwner whenNotPaused {\n    _pause();\n  }\n\n  /**\n    * @notice Emergency resume of this oracle\n  */\n  function emergencyResume() external onlyOwner whenPaused {\n    _unpause();\n  }\n}"
    },
    {
      "filename": "contracts/oracles/ChainlinkARBOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\n\ncontract ChainlinkARBOracle is Ownable2Step, Pausable {\n  using SafeCast for int256;\n\n  /* ======================= STRUCTS ========================= */\n\n  struct ChainlinkResponse {\n    uint80 roundId;\n    int256 answer;\n    uint256 timestamp;\n    bool success;\n    uint8 decimals;\n  }\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant SEQUENCER_GRACE_PERIOD_TIME = 1 hours;\n\n  /* ==================== STATE VARIABLES ==================== */\n\n  // Chainlink Arbitrum sequencer feed address\n  AggregatorV3Interface internal sequencerUptimeFeed;\n\n  /* ======================= MAPPINGS ======================== */\n\n  // Mapping of token to Chainlink USD price feed\n  mapping(address => address) public feeds;\n  // Mapping of token to maximum delay allowed (in seconds) of last price update\n  mapping(address => uint256) public maxDelays;\n  // Mapping of token to maximum % deviation allowed (in 1e18) of last price update\n  mapping(address => uint256) public maxDeviations;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  /**\n    * @param sequencerFeed  Chainlink Arbitrum sequencer feed address\n  */\n  constructor(address sequencerFeed) Ownable(msg.sender) {\n    if (sequencerFeed == address(0)) revert Errors.ZeroAddressNotAllowed();\n\n    sequencerUptimeFeed = AggregatorV3Interface(sequencerFeed);\n  }\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Get token price from Chainlink feed\n    * @param token Token address\n    * @return price Asset price in int256\n    * @return decimals Price decimals in uint8\n  */\n  function consult(address token) public view whenNotPaused returns (int256, uint8) {\n    address _feed = feeds[token];"
    }
  ]
}