{
  "Title": "M-12: interfaceFee Incorrectly converted  uint40 when stored",
  "Content": "# Issue M-12: interfaceFee Incorrectly converted  uint40 when stored \n\nSource: https://github.com/sherlock-audit/2023-10-perennial-judging/issues/43 \n\n## Found by \nbin2chen\n## Summary\nThe `interfaceFee.amount` is currently defined as `uint48` , with a maximum value of approximately `281m`.\nHowever, it is incorrectly converted to `uint40` when saved, `uint40(UFixed6.unwrap(newValue.interfaceFee.amount))`, which means the maximum value can only be approximately `1.1M`. \nIf a user sets an order where `interfaceFee.amount` is greater than `1.1M`, the order can be saved successfully\nbut the actual stored value may be truncated to `0`. \nThis is not what the user expects, and the user may think that the order has been set, but in reality, it is an incorrect order. Although a fee of `1.1M` is large, it is not impossible.\n\n## Vulnerability Detail\n\n`interfaceFee.amount` is defined as `uint48`\nthe legality check also uses `type(uint48).max`, but `uint40` is used when saving.\n\n```solidity\nstruct StoredTriggerOrder {\n    /* slot 0 */\n    uint8 side;                // 0 = maker, 1 = long, 2 = short, 3 = collateral\n    int8 comparison;           // -2 = lt, -1 = lte, 0 = eq, 1 = gte, 2 = gt\n    uint64 fee;                // <= 18.44tb\n    int64 price;               // <= 9.22t\n    int64 delta;               // <= 9.22t\n@>  uint48 interfaceFeeAmount; // <= 281m\n\n    /* slot 1 */\n    address interfaceFeeReceiver;\n    bool interfaceFeeUnwrap;\n    bytes11 __unallocated0__;\n}\n\nlibrary TriggerOrderLib {\n    function store(TriggerOrderStorage storage self, TriggerOrder memory newValue) internal {\n        if (newValue.side > type(uint8).max) revert TriggerOrderStorageInvalidError();\n        if (newValue.comparison > type(int8).max) revert TriggerOrderStorageInvalidError();\n        if (newValue.comparison < type(int8).min) revert TriggerOrderStorageInvalidError();\n        if (newValue.fee.gt(UFixed6.wrap(type(uint64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.price.gt(Fixed6.wrap(type(int64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.price.lt(Fixed6.wrap(type(int64).min))) revert TriggerOrderStorageInvalidError();\n        if (newValue.delta.gt(Fixed6.wrap(type(int64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.delta.lt(Fixed6.wrap(type(int64).min))) revert TriggerOrderStorageInvalidError();\n@>      if (newValue.interfaceFee.amount.gt(UFixed6.wrap(type(uint48).max))) revert TriggerOrderStorageInvalidError();\n\n        self.value = StoredTriggerOrder(\n            uint8(newValue.side),\n            int8(newValue.comparison),\n            uint64(UFixed6.unwrap(newValue.fee)),\n            int64(Fixed6.unwrap(newValue.price)),\n            int64(Fixed6.unwrap(newValue.delta)),\n@>          uint40(UFixed6.unwrap(newValue.interfaceFee.amount)),\n            newValue.interfaceFee.receiver,\n            newValue.interfaceFee.unwrap,\n            bytes11(0)\n        );\n    }\n```\n\nWe can see that when saving, it is forcibly converted to `uint40`, as in `uint40(UFixed6.unwrap(newValue.interfaceFee.amount))`. The order can be saved successfully, but the actual storage may be truncated to `0`.\n\n## Impact\nFor orders where `interfaceFee.amount` is greater than `1.1M`, the order can be saved successfully, but the actual storage may be truncated to `0`. \nThis is not what users expect and may lead to incorrect fee payments when the order is executed. \nAlthough a fee of `1.1M` is large, it is not impossible.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-10-perennial/blob/main/perennial-v2/packages/perennial-extensions/contracts/types/TriggerOrder.sol#L106\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```diff\nlibrary TriggerOrderLib {\n    function store(TriggerOrderStorage storage self, TriggerOrder memory newValue) internal {\n        if (newValue.side > type(uint8).max) revert TriggerOrderStorageInvalidError();\n        if (newValue.comparison > type(int8).max) revert TriggerOrderStorageInvalidError();\n        if (newValue.comparison < type(int8).min) revert TriggerOrderStorageInvalidError();\n        if (newValue.fee.gt(UFixed6.wrap(type(uint64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.price.gt(Fixed6.wrap(type(int64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.price.lt(Fixed6.wrap(type(int64).min))) revert TriggerOrderStorageInvalidError();\n        if (newValue.delta.gt(Fixed6.wrap(type(int64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.delta.lt(Fixed6.wrap(type(int64).min))) revert TriggerOrderStorageInvalidError();\n        if (newValue.interfaceFee.amount.gt(UFixed6.wrap(type(uint48).max))) revert TriggerOrderStorageInvalidError();\n\n        self.value = StoredTriggerOrder(\n            uint8(newValue.side),\n            int8(newValue.comparison),\n            uint64(UFixed6.unwrap(newValue.fee)),\n            int64(Fixed6.unwrap(newValue.price)),\n            int64(Fixed6.unwrap(newValue.delta)),\n-          uint40(UFixed6.unwrap(newValue.interfaceFee.amount)),\n+          uint48(UFixed6.unwrap(newValue.interfaceFee.amount)),\n            newValue.interfaceFee.receiver,\n            newValue.interfaceFee.unwrap,\n            bytes11(0)\n        );\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> medium, because there seems to really be an incorrect cast to uint40 instead of uint48, so the fee might be stored incorrectly and incorrect (smaller) fee will be charged, losing funds for the interface\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/123",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-extensions/contracts/types/TriggerOrder.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport \"@equilibria/perennial-v2/contracts/types/Position.sol\";\nimport \"./InterfaceFee.sol\";\n\nstruct TriggerOrder {\n    uint8 side;\n    int8 comparison;\n    UFixed6 fee;\n    Fixed6 price;\n    Fixed6 delta;\n    InterfaceFee interfaceFee;\n}\nusing TriggerOrderLib for TriggerOrder global;\nstruct StoredTriggerOrder {\n    /* slot 0 */\n    uint8 side;                // 0 = maker, 1 = long, 2 = short, 3 = collateral\n    int8 comparison;           // -2 = lt, -1 = lte, 0 = eq, 1 = gte, 2 = gt\n    uint64 fee;                // <= 18.44tb\n    int64 price;               // <= 9.22t\n    int64 delta;               // <= 9.22t\n    uint48 interfaceFeeAmount; // <= 281m\n\n    /* slot 1 */\n    address interfaceFeeReceiver;\n    bool interfaceFeeUnwrap;\n    bytes11 __unallocated0__;\n}\nstruct TriggerOrderStorage { StoredTriggerOrder value; }\nusing TriggerOrderStorageLib for TriggerOrderStorage global;\n\n/**\n * @title TriggerOrderLib\n * @notice\n */\nlibrary TriggerOrderLib {\n    function fillable(TriggerOrder memory self, Fixed6 latestPrice) internal pure returns (bool) {\n        if (self.comparison == 1) return latestPrice.gte(self.price);\n        if (self.comparison == -1) return latestPrice.lte(self.price);\n        return false;\n    }\n\n    function execute(TriggerOrder memory self, Position memory currentPosition) internal pure {\n        // update position\n        if (self.side == 0)\n            currentPosition.maker = self.delta.isZero() ?\n                UFixed6Lib.ZERO :\n                UFixed6Lib.from(Fixed6Lib.from(currentPosition.maker).add(self.delta));\n        if (self.side == 1)\n            currentPosition.long = self.delta.isZero() ?\n                UFixed6Lib.ZERO :\n                UFixed6Lib.from(Fixed6Lib.from(currentPosition.long).add(self.delta));\n        if (self.side == 2)\n            currentPosition.short = self.delta.isZero() ?\n                UFixed6Lib.ZERO :\n                UFixed6Lib.from(Fixed6Lib.from(currentPosition.short).add(self.delta));\n\n        // update collateral (override collateral field in position since it is not used in this context)\n        // Handles collateral withdrawal magic value\n        currentPosition.collateral = (self.side == 3) ?\n            (self.delta.eq(Fixed6.wrap(type(int64).min)) ? Fixed6Lib.MIN : self.delta) :\n            Fixed6Lib.ZERO;\n    }\n}\n\nlibrary TriggerOrderStorageLib {\n    // sig: 0xf3469aa7\n    error TriggerOrderStorageInvalidError();\n\n    function read(TriggerOrderStorage storage self) internal view returns (TriggerOrder memory) {\n        StoredTriggerOrder memory storedValue = self.value;\n        return TriggerOrder(\n            uint8(storedValue.side),\n            int8(storedValue.comparison),\n            UFixed6.wrap(uint256(storedValue.fee)),\n            Fixed6.wrap(int256(storedValue.price)),\n            Fixed6.wrap(int256(storedValue.delta)),\n            InterfaceFee(\n                UFixed6.wrap(uint256(storedValue.interfaceFeeAmount)),\n                storedValue.interfaceFeeReceiver,\n                storedValue.interfaceFeeUnwrap\n            )\n        );\n    }\n\n    function store(TriggerOrderStorage storage self, TriggerOrder memory newValue) internal {\n        if (newValue.side > type(uint8).max) revert TriggerOrderStorageInvalidError();\n        if (newValue.comparison > type(int8).max) revert TriggerOrderStorageInvalidError();\n        if (newValue.comparison < type(int8).min) revert TriggerOrderStorageInvalidError();\n        if (newValue.fee.gt(UFixed6.wrap(type(uint64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.price.gt(Fixed6.wrap(type(int64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.price.lt(Fixed6.wrap(type(int64).min))) revert TriggerOrderStorageInvalidError();\n        if (newValue.delta.gt(Fixed6.wrap(type(int64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.delta.lt(Fixed6.wrap(type(int64).min))) revert TriggerOrderStorageInvalidError();\n        if (newValue.interfaceFee.amount.gt(UFixed6.wrap(type(uint48).max))) revert TriggerOrderStorageInvalidError();\n\n        self.value = StoredTriggerOrder(\n            uint8(newValue.side),\n            int8(newValue.comparison),\n            uint64(UFixed6.unwrap(newValue.fee)),\n            int64(Fixed6.unwrap(newValue.price)),\n            int64(Fixed6.unwrap(newValue.delta)),\n            uint40(UFixed6.unwrap(newValue.interfaceFee.amount)),\n            newValue.interfaceFee.receiver,\n            newValue.interfaceFee.unwrap,\n            bytes11(0)\n        );\n    }\n}"
    }
  ]
}