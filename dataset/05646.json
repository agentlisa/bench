{
  "Title": "[G-09] Use modifiers rather than invoking functions to perform checks",
  "Content": "\nBy using modifiers in place of functions to perform checks, we could reduce the gas cost by up to `40` units. In using modifiers, the solidity compiler would inline the operations of the modifier in the called function. Using functions to perform checks would incur two `JUMPI` instructions, plus the stack setup, which could cost up to `40` gas units. Implementing this change would increase deployment cost, but would reduce the gas cost of the called functions. In the long run, using modifiers would be cheaper. The functions below can also be made more gas efficient by making them  `payable` functions:\n\n*There are 2 instances of this issue.*\n\n1. Convert `_onlyDelegateCall()` function into a modifier.\n\n    https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/SafeEnabler.sol#L81-#L83\n\n```\nfile: contracts/src/core/SafeEnabler.sol\n\n43:    function enableModule(address module) public {\n44:        _onlyDelegateCall();     @audit use a modifier instead\n45:\n.\n.\n.\n56:    }\n.\n.\n.\n66:    function setGuard(address guard) public {\n67:        _onlyDelegateCall();     @audit use a modifier instead\n68:\n.\n.\n.\n75:    }\n.\n.\n.\n81:    function _onlyDelegateCall() private view {    @audit convert to a modifier\n82:        if (address(this) == _self) revert OnlyDelegateCall();\n83:    }\n```\n\nThe code could be refactored as shown in the diff below:\n\n```diff\ndiff --git a/contracts/src/core/SafeEnabler.sol b/contracts/src/core/SafeEnabler.sol\nindex 02137cc..8f4b6de 100644\n--- a/contracts/src/core/SafeEnabler.sol\n+++ b/contracts/src/core/SafeEnabler.sol\n@@ -29,6 +29,14 @@ contract SafeEnabler is GnosisSafeStorage {\n     /// @dev keccak256(\"guard_manager.guard.address\")\n     bytes32 internal constant _GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n+    /**\n+     * @notice Validates if the current call being made is DELEGATECALL\n+     * @dev reverts if not DELEGATECALL\n+     */\n+    modifier onlyDelegateCall {\n+        if (address(this) == _self) revert OnlyDelegateCall();\n+        _;\n+    }\n     constructor() {\n         _self = address(this);\n     }\n@@ -40,8 +48,7 @@ contract SafeEnabler is GnosisSafeStorage {\n      *  Refer https://github.com/safe-global/safe-contracts/blob/186a21a74b327f17fc41217a927dea7064f74604/contracts/base/ModuleManager.sol#L32C5-L32C5\n      * @param module Module to be whitelisted.\n      */\n-    function enableModule(address module) public {\n-        _onlyDelegateCall();\n+    function enableModule(address module) public payable onlyDelegateCall {\n\n         // Module address cannot be null or sentinel.\n         // solhint-disable-next-line custom-errors\n@@ -63,8 +70,7 @@ contract SafeEnabler is GnosisSafeStorage {\n      * @param guard address of the guard\n      * @dev delegatecalled during initialization to bypass authorization modifier and set guard on safe\n      */\n-    function setGuard(address guard) public {\n-        _onlyDelegateCall();\n+    function setGuard(address guard) public payable onlyDelegateCall {\n\n         bytes32 slot = _GUARD_STORAGE_SLOT;\n         // solhint-disable-next-line no-inline-assembly\n@@ -74,11 +80,4 @@ contract SafeEnabler is GnosisSafeStorage {\n         emit ChangedGuard(guard);\n     }\n-    /**                                                                          \n-     * @notice Validates if the current call being made is DELEGATECALL          \n-     * @dev reverts if not DELEGATECALL                                          \n-     */                                                                          \n-    function _onlyDelegateCall() private view {                                  \n-        if (address(this) == _self) revert OnlyDelegateCall();                   \n-    }                                                                            \n }                                                                                     \n```\n\n2. Convert `_onlyGov()` function into a modifier.\n\n    https://github.com/code-423n4/2023-10-brahma/blob/main/contracts/src/core/AddressProvider.sol#L139-#L141\n\n```solidity\nfile: contracts/src/core/AddressProvider.sol\n\n52:     function setGovernance(address _newGovernance) external {\n53:         _notNull(_newGovernance);\n54:         _onlyGov();     @audit use a modifier instead\n55:         emit GovernanceTransferRequested(governance, _newGovernance);\n56:         pendingGovernance = _newGovernance;\n57:     }\n.\n.\n.\n77:     function setAuthorizedAddress(bytes32 _key, address _authorizedAddress, bool _overrideCheck) external {\n78:         _onlyGov();     @audit use a modifier instead\n79:         _notNull(_authorizedAddress);\n80:\n81:         /// @dev skips checks for supported `addressProvider()` if `_overrideCheck` is true\n82:         if (!_overrideCheck) {\n83:             /// @dev skips checks for supported `addressProvider()` if `_authorizedAddress` is an EOA\n84:             if (_authorizedAddress.code.length != 0) _ensureAddressProvider(_authorizedAddress);\n85:         }\n86:\n87:         authorizedAddresses[_key] = _authorizedAddress;\n88:\n89:         emit AuthorizedAddressInitialised(_authorizedAddress, _key);\n90:     }\n.\n.\n.\n97:     function setRegistry(bytes32 _key, address _registry) external {\n98:         _onlyGov();     @audit use a modifier instead\n99:         _ensureAddressProvider(_registry);\n100:\n101:        if (registries[_key] != address(0)) revert RegistryAlreadyExists();\n102:        registries[_key] = _registry;\n103:\n104:        emit RegistryInitialised(_registry, _key);\n105:    }\n.\n.\n.\n139:    function _onlyGov() internal view {    @audit convert to a modifier\n140:        if (msg.sender != governance) revert NotGovernance(msg.sender);\n141:    }\n```\n\nThe code could be refactored as shown in the diff below:\n\n```diff\ndiff --git a/contracts/src/core/AddressProvider.sol b/contracts/src/core/AddressProvider.sol\nindex 5ec51f9..6327ab1 100644\n--- a/contracts/src/core/AddressProvider.sol\n+++ b/contracts/src/core/AddressProvider.sol\n@@ -40,6 +40,14 @@ contract AddressProvider {\n      */\n     mapping(bytes32 => address) public registries;\n\n+    /**\n+     * @notice Checks if msg.sender is governance\n+     */\n+    modifier onlyGov {\n+        if (msg.sender != governance) revert NotGovernance(msg.sender);\n+        _;\n+    }\n+\n     constructor(address _governance) {\n         _notNull(_governance);\n         governance = _governance;\n@@ -49,9 +57,8 @@ contract AddressProvider {\n      * @notice Governance setter\n      * @param _newGovernance address of new governance\n      */\n-    function setGovernance(address _newGovernance) external {\n+    function setGovernance(address _newGovernance) external payable onlyGov {\n         _notNull(_newGovernance);\n-        _onlyGov();\n         emit GovernanceTransferRequested(governance, _newGovernance);\n         pendingGovernance = _newGovernance;\n     }\n@@ -74,8 +81,7 @@ contract AddressProvider {\n      * @param _authorizedAddress address to set\n      * @param _overrideCheck overrides check for supported address provider\n      */\n-    function setAuthorizedAddress(bytes32 _key, address _authorizedAddress, bool _overrideCheck) external {\n-        _onlyGov();\n+    function setAuthorizedAddress(bytes32 _key, address _authorizedAddress, bool _overrideCheck) external payable onlyGov {\n         _notNull(_authorizedAddress);\n\n         /// @dev skips checks for supported `addressProvider()` if `_overrideCheck` is true\n@@ -94,8 +100,7 @@ contract AddressProvider {\n      * @param _key key of registry address\n      * @param _registry address to set\n```\n\n## Conclusion\n\nAs you embark on incorporating the recommended optimizations, we want to emphasize the utmost importance of proceeding with vigilance and dedicating thorough efforts to comprehensive testing. It is of paramount significance to ensure that the proposed alterations do not inadvertently introduce fresh vulnerabilities, while also successfully achieving the anticipated enhancements in performance.\n\nWe strongly advise conducting a meticulous and exhaustive evaluation of the modifications made to the codebase. This rigorous scrutiny and exhaustive assessment will play a pivotal role in affirming both the security and efficacy of the refactored code. Your careful attention to detail, coupled with the implementation of a robust testing framework, will provide the necessary assurance that the refined code aligns with your security objectives and effectively fulfill the intended performance optimizations.\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2023-10-brahma-findings/issues/449#issuecomment-1782873094):**\n > All findings are valid and the report layout is great.\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-brahma",
  "Code": [
    {
      "filename": "contracts/src/core/SafeEnabler.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\nimport {GnosisSafeStorage} from \"safe-contracts/examples/libraries/GnosisSafeStorage.sol\";\n\n/**\n * @title SafeEnabler\n * @author Brahma.fi\n * @notice Contract which holds bytecode to enable modules and guards for a Gnosis Safe\n * @dev Bytecode in methods is kept as close as possible to the original Safe 1.3.0 to\n *  avoid any discrepancies in delegatecall behavior, except ignoring SelfAuthorized check\n */\ncontract SafeEnabler is GnosisSafeStorage {\n    error OnlyDelegateCall();\n\n    event EnabledModule(address module);\n    event ChangedGuard(address guard);\n\n    /// @notice self address\n    address internal immutable _self;\n\n    /// @notice address of sentinel modules\n    address internal constant _SENTINEL_MODULES = address(0x1);\n\n    /// @notice guard storage slot\n    /// @dev keccak256(\"guard_manager.guard.address\")\n    bytes32 internal constant _GUARD_STORAGE_SLOT = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\n\n    constructor() {\n        _self = address(this);\n    }\n\n    /**\n     * @notice Enables the module `module` for the Safe.\n     * @dev Delegatecall into this during initialization to set up the initial modules\n     *  bypasses Safe selfAuthorized check which disallows setting up guard during initialization\n     *  Refer https://github.com/safe-global/safe-contracts/blob/186a21a74b327f17fc41217a927dea7064f74604/contracts/base/ModuleManager.sol#L32C5-L32C5\n     * @param module Module to be whitelisted.\n     */\n    function enableModule(address module) public {\n        _onlyDelegateCall();\n\n        // Module address cannot be null or sentinel.\n        // solhint-disable-next-line custom-errors\n        require(module != address(0) && module != _SENTINEL_MODULES, \"GS101\");\n\n        // Module cannot be added twice.\n        // solhint-disable-next-line custom-errors\n        require(modules[module] == address(0), \"GS102\");\n        modules[module] = modules[_SENTINEL_MODULES];\n        modules[_SENTINEL_MODULES] = module;\n        emit EnabledModule(module);\n    }\n\n    /**\n     * @notice Sets the guard for a safe\n     * @dev Delegatecall into this during initialization to set up the guard,\n     *  bypasses Safe selfAuthorized check which disallows setting up guard during initialization\n     *  Refer https://github.com/safe-global/safe-contracts/blob/186a21a74b327f17fc41217a927dea7064f74604/contracts/base/GuardManager.sol#L34\n     * @param guard address of the guard\n     * @dev delegatecalled during initialization to bypass authorization modifier and set guard on safe\n     */\n    function setGuard(address guard) public {\n        _onlyDelegateCall();\n\n        bytes32 slot = _GUARD_STORAGE_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, guard)\n        }\n        emit ChangedGuard(guard);\n    }\n\n    /**\n     * @notice Validates if the current call being made is DELEGATECALL\n     * @dev reverts if not DELEGATECALL\n     */\n    function _onlyDelegateCall() private view {\n        if (address(this) == _self) revert OnlyDelegateCall();\n    }\n}"
    },
    {
      "filename": "contracts/base/ModuleManager.sol",
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\nimport \"../common/Enum.sol\";\nimport \"../common/SelfAuthorized.sol\";\nimport \"./Executor.sol\";\n\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract ModuleManager is SelfAuthorized, Executor {\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    address internal constant SENTINEL_MODULES = address(0x1);\n\n    mapping(address => address) internal modules;\n\n    function setupModules(address to, bytes memory data) internal {\n        require(modules[SENTINEL_MODULES] == address(0), \"GS100\");\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\n        if (to != address(0))\n            // Setup has to complete successfully or transaction fails.\n            require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), \"GS000\");\n    }\n\n    /// @dev Allows to add a module to the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Enables the module `module` for the Safe.\n    /// @param module Module to be whitelisted.\n    function enableModule(address module) public authorized {\n        // Module address cannot be null or sentinel.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        // Module cannot be added twice.\n        require(modules[module] == address(0), \"GS102\");\n        modules[module] = modules[SENTINEL_MODULES];\n        modules[SENTINEL_MODULES] = module;\n        emit EnabledModule(module);\n    }\n\n    /// @dev Allows to remove a module from the whitelist.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Disables the module `module` for the Safe.\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(address prevModule, address module) public authorized {\n        // Validate module address and check that it corresponds to module index.\n        require(module != address(0) && module != SENTINEL_MODULES, \"GS101\");\n        require(modules[prevModule] == module, \"GS103\");\n        modules[prevModule] = modules[module];\n        modules[module] = address(0);\n        emit DisabledModule(module);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public virtual returns (bool success) {\n        // Only whitelisted modules are allowed.\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"GS104\");\n        // Execute transaction without further confirmations.\n        success = execute(to, value, data, operation, gasleft());\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\n        else emit ExecutionFromModuleFailure(msg.sender);\n    }\n\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) public returns (bool success, bytes memory returnData) {\n        success = execTransactionFromModule(to, value, data, operation);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Load free memory location\n            let ptr := mload(0x40)\n            // We allocate memory for the return data by setting the free memory location to\n            // current free memory location + data size + 32 bytes for data size value\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\n            // Store the size\n            mstore(ptr, returndatasize())\n            // Store the data\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\n            // Point the return data to the correct memory location\n            returnData := ptr\n        }\n    }\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) public view returns (bool) {\n        return SENTINEL_MODULES != module && modules[module] != address(0);\n    }\n\n    /// @dev Returns array of modules.\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) {\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 moduleCount = 0;\n        address currentModule = modules[start];\n        while (currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\n            array[moduleCount] = currentModule;\n            currentModule = modules[currentModule];\n            moduleCount++;\n        }\n        next = currentModule;\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(array, moduleCount)\n        }\n    }\n}"
    },
    {
      "filename": "contracts/src/core/AddressProvider.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\n\n/// Copyright (C) 2023 Brahma.fi\n\npragma solidity 0.8.19;\n\nimport {IAddressProviderService} from \"interfaces/IAddressProviderService.sol\";\n\n/**\n * @title AddressProvider\n * @author Brahma.fi\n * @notice Single source of truth for resolving addresses of core components and external contracts\n */\ncontract AddressProvider {\n    error RegistryAlreadyExists();\n    error AddressProviderUnsupported();\n    error NotGovernance(address);\n    error NotPendingGovernance(address);\n    error NullAddress();\n\n    event RegistryInitialised(address indexed registry, bytes32 indexed key);\n    event AuthorizedAddressInitialised(address indexed authorizedAddress, bytes32 indexed key);\n    event GovernanceTransferRequested(address indexed previousGovernance, address indexed newGovernance);\n    event GovernanceTransferred(address indexed previousGovernance, address indexed newGovernance);\n\n    /// @notice address of governance\n    address public governance;\n    /// @notice address of pending governance before accepting\n    address public pendingGovernance;\n\n    /**\n     * @notice keccak256 hash of authorizedAddress keys mapped to their addresses\n     * @dev authorizedAddresses are updatable by governance\n     */\n    mapping(bytes32 => address) public authorizedAddresses;\n\n    /**\n     * @notice keccak256 hash of registry keys mapped to their addresses\n     * @dev registries are only set once by governance and immutable\n     */\n    mapping(bytes32 => address) public registries;\n\n    constructor(address _governance) {\n        _notNull(_governance);\n        governance = _governance;\n    }\n\n    /**\n     * @notice Governance setter\n     * @param _newGovernance address of new governance\n     */\n    function setGovernance(address _newGovernance) external {\n        _notNull(_newGovernance);\n        _onlyGov();\n        emit GovernanceTransferRequested(governance, _newGovernance);\n        pendingGovernance = _newGovernance;\n    }\n\n    /**\n     * @notice Governance accepter\n     */\n    function acceptGovernance() external {\n        if (msg.sender != pendingGovernance) {\n            revert NotPendingGovernance(msg.sender);\n        }\n        emit GovernanceTransferred(governance, msg.sender);\n        governance = msg.sender;\n        delete pendingGovernance;\n    }\n\n    /**\n     * @notice Authorized address setter\n     * @param _key key of authorizedAddress\n     * @param _authorizedAddress address to set\n     * @param _overrideCheck overrides check for supported address provider\n     */\n    function setAuthorizedAddress(bytes32 _key, address _authorizedAddress, bool _overrideCheck) external {\n        _onlyGov();\n        _notNull(_authorizedAddress);\n\n        /// @dev skips checks for supported `addressProvider()` if `_overrideCheck` is true\n        if (!_overrideCheck) {\n            /// @dev skips checks for supported `addressProvider()` if `_authorizedAddress` is an EOA\n            if (_authorizedAddress.code.length != 0) _ensureAddressProvider(_authorizedAddress);\n        }\n\n        authorizedAddresses[_key] = _authorizedAddress;\n\n        emit AuthorizedAddressInitialised(_authorizedAddress, _key);\n    }\n\n    /**\n     * @notice Registry address setter\n     * @param _key key of registry address\n     * @param _registry address to set\n     */\n    function setRegistry(bytes32 _key, address _registry) external {\n        _onlyGov();\n        _ensureAddressProvider(_registry);\n\n        if (registries[_key] != address(0)) revert RegistryAlreadyExists();\n        registries[_key] = _registry;\n\n        emit RegistryInitialised(_registry, _key);\n    }\n\n    /**\n     * @notice Authorized address getter\n     * @param _key key of authorized address\n     * @return address of authorized address\n     */\n    function getAuthorizedAddress(bytes32 _key) external view returns (address) {\n        return authorizedAddresses[_key];\n    }\n\n    /**\n     * @notice Registry address getter\n     * @param _key key of registry address\n     * @return address of registry address\n     */\n    function getRegistry(bytes32 _key) external view returns (address) {\n        return registries[_key];\n    }\n\n    /**\n     * @notice Ensures that the new address supports the AddressProviderService interface\n     * and is pointing to this AddressProvider\n     * @param _newAddress address to check\n     */\n    function _ensureAddressProvider(address _newAddress) internal view {\n        if (IAddressProviderService(_newAddress).addressProviderTarget() != address(this)) {\n            revert AddressProviderUnsupported();\n        }\n    }\n\n    /**\n     * @notice Checks if msg.sender is governance\n     */\n    function _onlyGov() internal view {\n        if (msg.sender != governance) revert NotGovernance(msg.sender);\n    }\n\n    /**\n     * @notice Checks and reverts if address is null\n     * @param addr address to check if null\n     */\n    function _notNull(address addr) internal pure {\n        if (addr == address(0)) revert NullAddress();\n    }\n}"
    }
  ]
}