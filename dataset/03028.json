{
  "Title": "M-16: `originationFee` may result in the borrower account becoming liquidatable immediately",
  "Content": "# Issue M-16: `originationFee` may result in the borrower account becoming liquidatable immediately \nSource: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/501-M \n## Found by \nWATCHPUG\n\n## Summary\n\nNote: This issue is a part of the extra scope added by Sentiment AFTER the audit contest. This scope was only reviewed by WatchPug and relates to these three PRs:\n\n1. [Lending deposit cap](https://github.com/sentimentxyz/protocol/pull/234)\n2. [Fee accrual modification](https://github.com/sentimentxyz/protocol/pull/233)\n3. [CRV staking](https://github.com/sentimentxyz/controller/pull/41)\n\n`originationFee` may result in the borrower account becoming liquidatable immediately.\n\n## Vulnerability Detail\n\nWhen checking `riskEngine.isBorrowAllowed()`, the `originationFee` of the borrow is not considered. Thus, when `originationFee` is large enough, the borrower account becomes liquidatable immediately.\n\nFor example:\n\nLet's say USDC's `originationFee` is 30%;\n\nAlice has `100 USDC`, and 0 debt in her account;\nAlice borrowed `400 USDC`, received only `280 USDC` after the `originationFee`;\nAlice's account is now liquidatable.\nActually, in the case above, Alice's account won't even get liquidated as all the assets are worth (380 USDC) less than the total debt (`400 USDC`).\n\n## Impact\n\n`originationFee` may result in the borrower account becoming liquidatable immediately.\n\n## Code Snippet\nhttps://github.com/sentimentxyz/protocol/blob/f5a9089e87752986af522cc952f95beb037491c8/src/tokens/LToken.sol#L243-L245\n\n```solidity\nfunction updateOriginationFee(uint _originationFee) external adminOnly {\n    originationFee = _originationFee;\n}\n```\n\nhttps://github.com/sentimentxyz/protocol/blob/f5a9089e87752986af522cc952f95beb037491c8/src/core/AccountManager.sol#L203-L217\n\n```solidity\nfunction borrow(address account, address token, uint amt)\n    external\n    whenNotPaused\n    onlyOwner(account)\n{\n    if (registry.LTokenFor(token) == address(0))\n        revert Errors.LTokenUnavailable();\n    if (!riskEngine.isBorrowAllowed(account, token, amt))\n        revert Errors.RiskThresholdBreached();\n    if (IAccount(account).hasAsset(token) == false)\n        IAccount(account).addAsset(token);\n    if (ILToken(registry.LTokenFor(token)).lendTo(account, amt))\n        IAccount(account).addBorrow(token);\n    emit Borrow(account, msg.sender, token, amt);\n}\n```\n\nhttps://github.com/sentimentxyz/protocol/blob/f5a9089e87752986af522cc952f95beb037491c8/src/core/RiskEngine.sol#L72-L86\n\n```solidity\nfunction isBorrowAllowed(\n    address account,\n    address token,\n    uint amt\n)\n    external\n    view\n    returns (bool)\n{\n    uint borrowValue = _valueInWei(token, amt);\n    return _isAccountHealthy(\n        _getBalance(account) + borrowValue,\n        _getBorrows(account) + borrowValue\n    );\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider asserting riskEngine.isAccountHealthy() after the borrow:\n\n```solidity\nfunction borrow(address account, address token, uint amt)\n    external\n    whenNotPaused\n    onlyOwner(account)\n{\n    if (registry.LTokenFor(token) == address(0))\n        revert Errors.LTokenUnavailable();\n    if (IAccount(account).hasAsset(token) == false)\n        IAccount(account).addAsset(token);\n    if (ILToken(registry.LTokenFor(token)).lendTo(account, amt))\n        IAccount(account).addBorrow(token);\n    if (!riskEngine.isAccountHealthy(account))\n        revert Errors.RiskThresholdBreached();\n    emit Borrow(account, msg.sender, token, amt);\n}\n```\n\n## Sentiment Team\nFixed as recommended. PR [here](https://github.com/sentimentxyz/protocol/pull/236).\n\n## Lead Senior Watson\n`riskEngine.isBorrowAllowed` should be removed as it's no longer needed.\n\n## Sentiment Team\nPushed a commit to remove the redundant call to riskEngine, you can find it [here](https://github.com/sentimentxyz/protocol/pull/236/commits/bfc445b02784f8130181641ce0054382b4cc3ec5).\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/1",
  "Code": [
    {
      "filename": "src/tokens/LToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Pausable} from \"../utils/Pausable.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"./utils/ERC4626.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRateModel} from \"../interface/core/IRateModel.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\n\n/**\n    @title Lending Token\n    @notice Lending token with ERC4626 implementation\n*/\ncontract LToken is Pausable, ERC4626, ILToken {\n    using FixedPointMathLib for uint;\n    using SafeTransferLib for ERC20;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice Registry\n    IRegistry public registry;\n\n    /// @notice Rate Model\n    IRateModel public rateModel;\n\n    /// @notice Account Manager\n    address public accountManager;\n\n    /// @notice Protocol treasury\n    address public treasury;\n\n    /// @notice Total amount of borrows\n    uint public borrows;\n\n    /// @notice Timestamp of when the state of the LToken was last updated\n    uint public lastUpdated;\n\n    /// @notice Origination Fee\n    uint public originationFee;\n\n    /// @notice Total borrow shares minted\n    uint public totalBorrowShares;\n\n    /// @notice Mapping of account to borrow in terms of shares\n    mapping (address => uint) public borrowsOf;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   EVENTS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event ReservesRedeemed(address indexed treasury, uint amt);\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier accountManagerOnly() {\n        if (msg.sender != accountManager) revert Errors.AccountManagerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract initialization function\n        @dev Can only be invoked once\n        @param _asset Underlying ERC20 token\n        @param _name Name of LToken\n        @param _symbol Symbol of LToken\n        @param _registry Address of Registry\n        @param _originationFee origination fee\n        @param _treasury Protocol treasury\n        @param _reserveShares Minimum amount of shares minted to zero address\n    */\n    function init(\n        ERC20 _asset,\n        string calldata _name,\n        string calldata _symbol,\n        IRegistry _registry,\n        uint _originationFee,\n        address _treasury,\n        uint _reserveShares\n    ) external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n\n        if (\n            address(_asset) == address(0) ||\n            address(_registry) == address(0) ||\n            _treasury == address(0)\n        ) revert Errors.ZeroAddress();\n\n        initialized = true;\n        initPausable(msg.sender);\n        initERC4626(_asset, _name, _symbol, _reserveShares);\n        registry = _registry;\n        originationFee = _originationFee;\n        treasury = _treasury;\n    }\n\n    /**\n        @notice Initializes external dependencies\n        @param _rateModel Name of rate model contract\n    */\n    function initDep(string calldata _rateModel) external adminOnly {\n        rateModel = IRateModel(registry.getAddress(_rateModel));\n        accountManager = registry.getAddress('ACCOUNT_MANAGER');\n    }\n\n    /**\n        @notice Lends a specified amount of underlying asset to an account\n        @param account Address of account\n        @param amt Amount of token to lend\n        @return isFirstBorrow Returns if the account is borrowing the asset for\n            the first time\n    */\n    function lendTo(address account, uint amt)\n        external\n        whenNotPaused\n        accountManagerOnly\n        returns (bool isFirstBorrow)\n    {\n        updateState();\n        isFirstBorrow = (borrowsOf[account] == 0);\n\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        totalBorrowShares += borrowShares;\n        borrowsOf[account] += borrowShares;\n\n        borrows += amt;\n\n        uint fee = amt.mulDivDown(originationFee, 10 ** decimals);\n        asset.safeTransfer(treasury, fee);\n        asset.safeTransfer(account, amt - fee);\n\n        return isFirstBorrow;\n    }\n\n    /**\n        @notice Collects a specified amount of underlying asset from an account\n        @param account Address of account\n        @param amt Amount of token to collect\n        @return bool Returns true if account has no debt\n    */\n    function collectFrom(address account, uint amt)\n        external\n        accountManagerOnly\n        returns (bool)\n    {\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        borrowsOf[account] -= borrowShares;\n        totalBorrowShares -= borrowShares;\n\n        borrows -= amt;\n        return (borrowsOf[account] == 0);\n    }\n\n    /**\n        @notice Returns Borrow balance of given account\n        @param account Address of account\n        @return borrowBalance Amount of underlying tokens borrowed\n    */\n    function getBorrowBalance(address account) external view returns (uint) {\n        return convertBorrowSharesToAsset(borrowsOf[account]);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Returns total amount of underlying assets\n            totalAssets = underlying balance + totalBorrows + delta\n            delta = totalBorrows * RateFactor\n        @return totalAssets Total amount of underlying assets\n    */\n    function totalAssets() public view override returns (uint) {\n        return asset.balanceOf(address(this)) + getBorrows();\n    }\n\n    function getBorrows() public view returns (uint) {\n        return borrows + borrows.mulWadUp(getRateFactor());\n    }\n\n    /// @notice Updates state of the lending pool\n    function updateState() public {\n        if (lastUpdated == block.timestamp) return;\n        uint rateFactor = getRateFactor();\n        uint interestAccrued = borrows.mulWadUp(rateFactor);\n        borrows += interestAccrued;\n        lastUpdated = block.timestamp;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @dev Rate Factor = Timestamp Delta * 1e18 (Scales timestamp delta to 18 decimals) * Interest Rate Per Block\n            Timestamp Delta = Number of seconds since last update\n    */\n    function getRateFactor() internal view returns (uint) {\n        return (block.timestamp == lastUpdated) ?\n            0 :\n            ((block.timestamp - lastUpdated)*1e18)\n            .mulWadUp(\n                rateModel.getBorrowRatePerSecond(\n                    asset.balanceOf(address(this)),\n                    borrows\n                )\n            );\n    }\n\n    function convertAssetToBorrowShares(uint amt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? amt : amt.mulDivUp(supply, getBorrows());\n    }\n\n    function convertBorrowSharesToAsset(uint debt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? debt : debt.mulDivDown(getBorrows(), supply);\n    }\n\n    function beforeDeposit(uint, uint) internal override { updateState(); }\n    function beforeWithdraw(uint, uint) internal override { updateState(); }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               ADMIN FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    function updateOriginationFee(uint _originationFee) external adminOnly {\n        originationFee = _originationFee;\n    }\n}"
    },
    {
      "filename": "src/core/AccountManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Helpers} from \"../utils/Helpers.sol\";\nimport {Pausable} from \"../utils/Pausable.sol\";\nimport {IERC20} from \"../interface/tokens/IERC20.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\nimport {IAccount} from \"../interface/core/IAccount.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRiskEngine} from \"../interface/core/IRiskEngine.sol\";\nimport {IAccountFactory} from \"../interface/core/IAccountFactory.sol\";\nimport {IAccountManager} from \"../interface/core/IAccountManager.sol\";\nimport {IControllerFacade} from \"controller/core/IControllerFacade.sol\";\n\n/**\n    @title Account Manager\n    @notice Sentiment Account Manager,\n        All account interactions go via the account manager\n*/\ncontract AccountManager is Pausable, IAccountManager {\n    using Helpers for address;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE_VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice Registry\n    IRegistry public registry;\n\n    /// @notice Risk Engine\n    IRiskEngine public riskEngine;\n\n    /// @notice Controller Facade\n    IControllerFacade public controller;\n\n    /// @notice Account Factory\n    IAccountFactory public accountFactory;\n\n    /// @notice List of inactive accounts per user\n    mapping(address => address[]) public inactiveAccountsOf;\n\n    /// @notice Mapping of collateral enabled tokens\n    mapping(address => bool) public isCollateralAllowed;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier onlyOwner(address account) {\n        if (registry.ownerFor(account) != msg.sender)\n            revert Errors.AccountOwnerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Initializes contract\n        @dev Can only be invoked once\n        @param _registry Address of Registry\n    */\n    function init(IRegistry _registry) external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n        initialized = true;\n        initPausable(msg.sender);\n        registry = _registry;\n    }\n\n    /// @notice Initializes external dependencies\n    function initDep() external adminOnly {\n        riskEngine = IRiskEngine(registry.getAddress('RISK_ENGINE'));\n        controller = IControllerFacade(registry.getAddress('CONTROLLER'));\n        accountFactory =\n            IAccountFactory(registry.getAddress('ACCOUNT_FACTORY'));\n    }\n\n    /**\n        @notice Opens a new account for a user\n        @dev Creates a new account if there are no inactive accounts otherwise\n            reuses an already inactive account\n            Emits AccountAssigned(account, owner) event\n        @param owner Owner of the newly opened account\n    */\n    function openAccount(address owner) external whenNotPaused {\n        if (owner == address(0)) revert Errors.ZeroAddress();\n        address account;\n        uint length = inactiveAccountsOf[owner].length;\n        if (length == 0) {\n            account = accountFactory.create(address(this));\n            IAccount(account).init(address(this));\n            registry.addAccount(account, owner);\n        } else {\n            account = inactiveAccountsOf[owner][length - 1];\n            inactiveAccountsOf[owner].pop();\n            registry.updateAccount(account, owner);\n        }\n        IAccount(account).activate();\n        emit AccountAssigned(account, owner);\n    }\n\n    /**\n        @notice Closes a specified account for a user\n        @dev Account can only be closed when the account has no debt\n            Emits AccountClosed(account, owner) event\n        @param _account Address of account to be closed\n    */\n    function closeAccount(address _account) public onlyOwner(_account) {\n        IAccount account = IAccount(_account);\n        if (account.activationBlock() == block.number)\n            revert Errors.AccountDeactivationFailure();\n        if (!account.hasNoDebt()) revert Errors.OutstandingDebt();\n        account.deactivate();\n        registry.closeAccount(_account);\n        inactiveAccountsOf[msg.sender].push(_account);\n        account.sweepTo(msg.sender);\n        emit AccountClosed(_account, msg.sender);\n    }\n\n    /**\n        @notice Transfers Eth from owner to account\n        @param account Address of account\n    */\n    function depositEth(address account)\n        external\n        payable\n        whenNotPaused\n        onlyOwner(account)\n    {\n        account.safeTransferEth(msg.value);\n    }\n\n    /**\n        @notice Transfers Eth from the account to owner\n        @dev Eth can only be withdrawn if the account remains healthy\n            after withdrawal\n        @param account Address of account\n        @param amt Amount of Eth to withdraw\n    */\n    function withdrawEth(address account, uint amt)\n        external\n        onlyOwner(account)\n    {\n        if(!riskEngine.isWithdrawAllowed(account, address(0), amt))\n            revert Errors.RiskThresholdBreached();\n        account.withdrawEth(msg.sender, amt);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the owner\n            to the account\n        @dev Token must be accepted as collateral by the protocol\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to deposit\n    */\n    function deposit(address account, address token, uint amt)\n        external\n        whenNotPaused\n        onlyOwner(account)\n    {\n        if (!isCollateralAllowed[token])\n            revert Errors.CollateralTypeRestricted();\n        if (IAccount(account).hasAsset(token) == false)\n            IAccount(account).addAsset(token);\n        token.safeTransferFrom(msg.sender, account, amt);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the account\n            to the owner of the account\n        @dev Amount of token can only be withdrawn if the account remains healthy\n            after withdrawal\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to withdraw\n    */\n    function withdraw(address account, address token, uint amt)\n        external\n        onlyOwner(account)\n    {\n        if (!riskEngine.isWithdrawAllowed(account, token, amt))\n            revert Errors.RiskThresholdBreached();\n        account.withdraw(msg.sender, token, amt);\n        if (token.balanceOf(account) == 0)\n            IAccount(account).removeAsset(token);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the LP to the account\n        @dev Specified token must have a LP\n            Account must remain healthy after the borrow, otherwise tx is reverted\n            Emits Borrow(account, msg.sender, token, amount) event\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to borrow\n    */\n    function borrow(address account, address token, uint amt)\n        external\n        whenNotPaused\n        onlyOwner(account)\n    {\n        if (registry.LTokenFor(token) == address(0))\n            revert Errors.LTokenUnavailable();\n        if (!riskEngine.isBorrowAllowed(account, token, amt))\n            revert Errors.RiskThresholdBreached();\n        if (IAccount(account).hasAsset(token) == false)\n            IAccount(account).addAsset(token);\n        if (ILToken(registry.LTokenFor(token)).lendTo(account, amt))\n            IAccount(account).addBorrow(token);\n        emit Borrow(account, msg.sender, token, amt);\n    }\n\n    /**\n        @notice Transfers a specified amount of token from the account to the LP\n        @dev Specified token must have a LP\n            Emits Repay(account, msg.sender, token, amount) event\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to borrow\n    */\n    function repay(address account, address token, uint amt)\n        public\n        onlyOwner(account)\n    {\n        ILToken LToken = ILToken(registry.LTokenFor(token));\n        if (address(LToken) == address(0))\n            revert Errors.LTokenUnavailable();\n        LToken.updateState();\n        if (amt == type(uint256).max) amt = LToken.getBorrowBalance(account);\n        account.withdraw(address(LToken), token, amt);\n        if (LToken.collectFrom(account, amt))\n            IAccount(account).removeBorrow(token);\n        if (IERC20(token).balanceOf(account) == 0)\n            IAccount(account).removeAsset(token);\n        emit Repay(account, msg.sender, token, amt);\n    }\n\n    /**\n        @notice Liquidates an account\n        @dev Account can only be liquidated when it's unhealthy\n            Emits AccountLiquidated(account, owner) event\n        @param account Address of account\n    */\n    function liquidate(address account) external {\n        if (riskEngine.isAccountHealthy(account))\n            revert Errors.AccountNotLiquidatable();\n        _liquidate(account);\n        emit AccountLiquidated(account, registry.ownerFor(account));\n    }\n\n    /**\n        @notice Gives a spender approval to spend a given amount of token from\n            the account\n        @dev Spender must have a controller in controller facade\n        @param account Address of account\n        @param token Address of token\n        @param spender Address of spender\n        @param amt Amount of token\n    */\n    function approve(\n        address account,\n        address token,\n        address spender,\n        uint amt\n    )\n        external\n        onlyOwner(account)\n    {\n        if(address(controller.controllerFor(spender)) == address(0))\n            revert Errors.FunctionCallRestricted();\n        account.safeApprove(token, spender, amt);\n    }\n\n    /**\n        @notice A general function that allows the owner to perform specific interactions\n            with external protocols for their account\n        @dev Target must have a controller in controller facade\n        @param account Address of account\n        @param target Address of contract to transact with\n        @param amt Amount of Eth to send to the target contract\n        @param data Encoded sig + params of the function to transact with in the\n            target contract\n    */\n    function exec(\n        address account,\n        address target,\n        uint amt,\n        bytes calldata data\n    )\n        external\n        onlyOwner(account)\n    {\n        bool isAllowed;\n        address[] memory tokensIn;\n        address[] memory tokensOut;\n        (isAllowed, tokensIn, tokensOut) =\n            controller.canCall(target, (amt > 0), data);\n        if (!isAllowed) revert Errors.FunctionCallRestricted();\n        _updateTokensIn(account, tokensIn);\n        (bool success,) = IAccount(account).exec(target, amt, data);\n        if (!success)\n            revert Errors.AccountInteractionFailure(account, target, amt, data);\n        _updateTokensOut(account, tokensOut);\n        if (!riskEngine.isAccountHealthy(account))\n            revert Errors.RiskThresholdBreached();\n    }\n\n    /**\n        @notice Settles an account by repaying all the loans\n        @param account Address of account\n    */\n    function settle(address account) external onlyOwner(account) {\n        address[] memory borrows = IAccount(account).getBorrows();\n        for (uint i; i < borrows.length; i++) {\n            repay(account, borrows[i], type(uint).max);\n        }\n    }\n\n    /**\n        @notice Fetches inactive accounts of a user\n        @param user Address of user\n        @return address[] List of inactive accounts\n    */\n    function getInactiveAccountsOf(\n        address user\n    )\n        external\n        view\n        returns (address[] memory)\n    {\n        return inactiveAccountsOf[user];\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             Internal Functions                             */\n    /* -------------------------------------------------------------------------- */\n\n    function _updateTokensIn(address account, address[] memory tokensIn)\n        internal\n    {\n        uint tokensInLen = tokensIn.length;\n        for(uint i; i < tokensInLen; ++i) {\n            if (IAccount(account).hasAsset(tokensIn[i]) == false)\n                IAccount(account).addAsset(tokensIn[i]);\n        }\n    }\n\n    function _updateTokensOut(address account, address[] memory tokensOut)\n        internal\n    {\n        uint tokensOutLen = tokensOut.length;\n        for(uint i; i < tokensOutLen; ++i) {\n            if (tokensOut[i].balanceOf(account) == 0)\n                IAccount(account).removeAsset(tokensOut[i]);\n        }\n    }\n\n    function _liquidate(address _account) internal {\n        IAccount account = IAccount(_account);\n        address[] memory accountBorrows = account.getBorrows();\n        uint borrowLen = accountBorrows.length;\n\n        ILToken LToken;\n        uint amt;\n\n        for(uint i; i < borrowLen; ++i) {\n            address token = accountBorrows[i];\n            LToken = ILToken(registry.LTokenFor(token));\n            LToken.updateState();\n            amt = LToken.getBorrowBalance(_account);\n            token.safeTransferFrom(msg.sender, address(LToken), amt);\n            LToken.collectFrom(_account, amt);\n            account.removeBorrow(token);\n        }\n        account.sweepTo(msg.sender);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               ADMIN FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Toggle collateral status of a token\n        @param token Address of token\n    */\n    function toggleCollateralStatus(address token) external adminOnly {\n        isCollateralAllowed[token] = !isCollateralAllowed[token];\n    }\n}"
    },
    {
      "filename": "src/core/RiskEngine.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Ownable} from \"../utils/Ownable.sol\";\nimport {IOracle} from \"oracle/core/IOracle.sol\";\nimport {IERC20} from \"../interface/tokens/IERC20.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\nimport {IAccount} from \"../interface/core/IAccount.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRiskEngine} from \"../interface/core/IRiskEngine.sol\";\nimport {IAccountManager} from \"../interface/core/IAccountManager.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\n/**\n    @title Risk Engine\n    @notice Risk engine is a sentiment utility contract used by the protocol to\n    analyze the health factor of a given account.\n*/\ncontract RiskEngine is Ownable, IRiskEngine {\n    using FixedPointMathLib for uint;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Registry\n    IRegistry public immutable registry;\n\n    /// @notice Oracle Facade\n    IOracle public oracle;\n\n    /// @notice Account Manager\n    IAccountManager public accountManager;\n\n    /// @notice Balance:Borrow, Default = 1.2\n    uint public constant balanceToBorrowThreshold = 1.2e18;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract constructor\n        @param _registry Address of registry contract\n    */\n    constructor(IRegistry _registry) {\n        initOwnable(msg.sender);\n        registry = _registry;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Initializes external dependencies\n    function initDep() external adminOnly {\n        oracle = IOracle(registry.getAddress('ORACLE'));\n        accountManager = IAccountManager(registry.getAddress('ACCOUNT_MANAGER'));\n    }\n\n    /**\n        @notice Utility function to determine if an account can borrow a\n        specified amount of a token\n            isBorrowAllowed = (currentAccountBalance + borrowValue) /\n                (currentAccountBorrows + borrowValue) > balanceToBorrowThreshold\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to borrow\n        @return isBorrowAllowed Returns whether a borrow is allowed or not\n    */\n    function isBorrowAllowed(\n        address account,\n        address token,\n        uint amt\n    )\n        external\n        view\n        returns (bool)\n    {\n        uint borrowValue = _valueInWei(token, amt);\n        return _isAccountHealthy(\n            _getBalance(account) + borrowValue,\n            _getBorrows(account) + borrowValue\n        );\n    }\n\n    /**\n        @notice Utility function to determine if an account can withdraw a\n        specified amount of a token\n            isWithdrawAllowed = (currentAccountBalance - withdrawValue) /\n                currentAccountBorrows > balanceToBorrowThreshold\n        @param account Address of account\n        @param token Address of token\n        @param amt Amount of token to withdraw\n        @return isWithdrawAllowed Returns whether a withdraw is allowed or not\n    */\n    function isWithdrawAllowed(\n        address account,\n        address token,\n        uint amt\n    )\n        external\n        view\n        returns (bool)\n    {\n        if (IAccount(account).hasNoDebt()) return true;\n        return _isAccountHealthy(\n            _getBalance(account) - _valueInWei(token, amt),\n            _getBorrows(account)\n        );\n    }\n\n    /**\n        @notice Utility function to determine if an account is healthy or not\n            isAccountHealthy = currentAccountBalance / currentAccountBorrows >\n                balanceToBorrowThreshold\n         @param account Address of account\n        @return isAccountHealthy Returns whether an account is healthy or not.\n    */\n    function isAccountHealthy(address account) external view returns (bool) {\n        return _isAccountHealthy(\n            _getBalance(account),\n            _getBorrows(account)\n        );\n    }\n\n    /**\n        @notice Returns total account Balance\n        @param account Address of account\n        @return balance Total account balance\n    */\n    function getBalance(address account) external view returns (uint) {\n        return _getBalance(account);\n    }\n\n    /**\n        @notice Returns total account Borrows\n        @param account Address of account\n        @return borrows Total account borrows\n    */\n    function getBorrows(address account) external view returns (uint) {\n        return _getBorrows(account);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             Internal Functions                             */\n    /* -------------------------------------------------------------------------- */\n\n    function _getBalance(address account) internal view returns (uint) {\n        address[] memory assets = IAccount(account).getAssets();\n        uint assetsLen = assets.length;\n        uint totalBalance;\n        for(uint i; i < assetsLen; ++i) {\n            totalBalance += _valueInWei(\n                assets[i],\n                IERC20(assets[i]).balanceOf(account)\n            );\n        }\n        return totalBalance + account.balance;\n    }\n\n    function _getBorrows(address account) internal view returns (uint) {\n        if (IAccount(account).hasNoDebt()) return 0;\n        address[] memory borrows = IAccount(account).getBorrows();\n        uint borrowsLen = borrows.length;\n        uint totalBorrows;\n        for(uint i; i < borrowsLen; ++i) {\n            address LTokenAddr = registry.LTokenFor(borrows[i]);\n            totalBorrows += _valueInWei(\n                borrows[i],\n                ILToken(LTokenAddr).getBorrowBalance(account)\n            );\n        }\n        return totalBorrows;\n    }\n\n    function _valueInWei(address token, uint amt)\n        internal\n        view\n        returns (uint)\n    {\n        return oracle.getPrice(token)\n        .mulDivDown(\n            amt,\n            10 ** ((token == address(0)) ? 18 : IERC20(token).decimals())\n        );\n    }\n\n    function _isAccountHealthy(uint accountBalance, uint accountBorrows)\n        internal\n        pure\n        returns (bool)\n    {\n        return (accountBorrows == 0) ? true :\n            (accountBalance.divWadDown(accountBorrows) > balanceToBorrowThreshold);\n    }\n}"
    }
  ]
}