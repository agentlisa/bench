{
  "Title": "H-1: `StakingRewardsManager::topUp(...)` Misallocates Funds to `StakingRewards` Contracts",
  "Content": "# Issue H-1: `StakingRewardsManager::topUp(...)` Misallocates Funds to `StakingRewards` Contracts \n\nSource: https://github.com/sherlock-audit/2024-01-telcoin-judging/issues/16 \n\n## Found by \nAamirusmani1552, Arz, DMoore, IvanFitro, VAD37, fibonacci, ggg\\_ttt\\_hhh, ravikiran.web3, sakshamguruji, zzykxx\n## Summary\n\nThe `StakingRewardsManager::topUp(...)` contract exhibits an issue where the specified `StakingRewards` contracts are not topped up at the correct indices, resulting in an incorrect distribution to different contracts.\n\n## Vulnerability Detail\n\nThe `StakingRewardsManager::topUp(...)` function is designed to top up multiple `StakingRewards` contracts simultaneously by taking the indices of the contract's addresses in the `StakingRewardsManager::stakingContracts` array. However, the flaw lies in the distribution process: \n\n```solidity\n    function topUp(\n        address source,\n@>        uint256[] memory indices\n    ) external onlyRole(EXECUTOR_ROLE) {\n@>        for (uint i = 0; i < indices.length; i++) {\n            // get staking contract and config\n            StakingRewards staking = stakingContracts[i];\n            StakingConfig memory config = stakingConfigs[staking];\n\n            // will revert if block.timestamp <= periodFinish\n            staking.setRewardsDuration(config.rewardsDuration);\n\n            // pull tokens from owner of this contract to fund the staking contract\n            rewardToken.transferFrom(\n                source,\n                address(staking),\n                config.rewardAmount\n            );\n\n            // start periods\n            staking.notifyRewardAmount(config.rewardAmount);\n\n            emit ToppedUp(staking, config);\n        }\n    }\n```\nGitHub: [[254-278](https://github.com/sherlock-audit/2024-01-telcoin/blob/main/telcoin-audit/contracts/telx/core/StakingRewardsManager.sol#L254C1-L278C6)]\n\n\nThe rewards are not appropriately distributed to the `StakingRewards` contracts at the specified indices. Instead, they are transferred to the contracts at the loop indices. For instance, if intending to top up contracts at indices `[1, 2]`, the actual top-up occurs at indices `[0, 1]`.\n\n## Impact\n\nThe consequence of this vulnerability is that rewards will be distributed to the incorrect staking contract, leading to potential misallocation and unintended outcomes\n\n## Code Snippet\n\n**_Here is a test for PoC:_**\n\nAdd the below given test in `StakingRewardsManager.test.ts` File. And use the following command to run the test\n\n```bash\nnpx hardhat test --grep \"TopUp is not done to intended staking rewards contracts\"\n```\n\n**_TEST:_**\n\n```Javascript\n        it(\"TopUp is not done to intended staking rewards contracts\", async function () {\n            // add index 2 to indices\n            // so topup should be done to index 0 and 2\n            indices = [0, 2];\n\n            await rewardToken.connect(deployer).approve(await stakingRewardsManager.getAddress(), tokenAmount * indices.length);\n            \n            // create 3 staking contracts\n            await stakingRewardsManager.createNewStakingRewardsContract(await stakingToken.getAddress(), newStakingConfig);\n            await stakingRewardsManager.createNewStakingRewardsContract(await stakingToken.getAddress(), newStakingConfig);\n            await stakingRewardsManager.createNewStakingRewardsContract(await stakingToken.getAddress(), newStakingConfig);\n\n            // topup index 0 and 2\n            await expect(stakingRewardsManager.connect(deployer).topUp(await deployer.address, indices))\n                .to.emit(stakingRewardsManager, \"ToppedUp\");\n\n\n            // getting the staking contract at index 0, 1 and 2\n            let stakingContract0 = await stakingRewardsManager.stakingContracts(0);\n            let stakingContract1 = await stakingRewardsManager.stakingContracts(1);\n            let stakingContract2 = await stakingRewardsManager.stakingContracts(2);\n\n            // Staking contract at index 2 should be empty\n            expect(await rewardToken.balanceOf(stakingContract2)).to.equal(0);\n\n            // Staking contract at index 0 and 1 should have 100 tokens\n            expect(await rewardToken.balanceOf(stakingContract0)).to.equal(100);\n            expect(await rewardToken.balanceOf(stakingContract1)).to.equal(100);\n\n        });\n```\n\n**_Output:_**\n\n```bash\nAAMIR@Victus MINGW64 /d/telcoin-audit/telcoin-audit (main)\n$ npx hardhat test --grep \"TopUp is not done to intended staking rewards contracts\"\n\n\n  StakingRewards and StakingRewardsFactory\n    topUp\n      âœ” TopUp is not done to intended staking rewards contracts (112ms)\n\n\n  1 passing (2s)\n\n```\n\n\n## Tool used\n\n- Manual Review\n\n## Recommendation\n\nIt is recommended to do the following changes:\n\n```diff\n    function topUp(\n        address source,\n        uint256[] memory indices\n    ) external onlyRole(EXECUTOR_ROLE) {\n        for (uint i = 0; i < indices.length; i++) {\n            // get staking contract and config\n-            StakingRewards staking = stakingContracts[i];\n+           StakingRewards staking = stakingContracts[indices[i]];\n            StakingConfig memory config = stakingConfigs[staking];\n\n            // will revert if block.timestamp <= periodFinish\n            staking.setRewardsDuration(config.rewardsDuration);\n\n            // pull tokens from owner of this contract to fund the staking contract\n            rewardToken.transferFrom(\n                source,\n                address(staking),\n                config.rewardAmount\n            );\n\n            // start periods\n            staking.notifyRewardAmount(config.rewardAmount);\n\n            emit ToppedUp(staking, config);\n        }\n    }\n```\n\n\n\n## Discussion\n\n**amshirif**\n\nhttps://github.com/telcoin/telcoin-audit/pull/27\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because { I consider this a high severity and  avalid issues; the watson was able to explain how the topUp function will perform an unintended actions by topping up from the 0 index of the array always due to lack of good implementation of the indices that was supposed to be added before the (i) }\n\n\n\n**nevillehuang**\n\n@amshirif Will this allow the stakers of the wrong contract funded to retrieve unintended rewards? If yes I will remain as high severity.\n\n**amshirif**\n\n@nevillehuang Yes this would potentially cause those who should have gotten rewards to have received less or non at all, and those who were not intended to get any or less than their desired amount to get more than they should have. \n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/telcoin/telcoin-audit/pull/27.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/156",
  "Code": [
    {
      "filename": "telcoin-audit/contracts/telx/core/StakingRewardsManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./StakingRewardsFactory.sol\";\nimport \"./StakingRewards.sol\";\n\n/**\n * @title StakingRewardsManager\n * @notice A Telcoin Contract\n * @dev Implements Openzeppelin Audited Contracts\n *\n * @notice This contract can manage multiple Synthetix StakingRewards contracts.\n * Staking contracts managed my multisigs can avoid having to coordinate to top up contracts every staking period.\n * Instead, add staking contracts to this manager contract, approve this contract to spend the rewardToken and then topUp() can be called permissionlessly.\n */\ncontract StakingRewardsManager is AccessControlUpgradeable {\n    using SafeERC20 for IERC20;\n\n    /// @notice This role grants the ability to rescue ERC20 tokens that do not rightfully belong to this contract\n    bytes32 public constant BUILDER_ROLE = keccak256(\"BUILDER_ROLE\");\n    bytes32 public constant MAINTAINER_ROLE = keccak256(\"MAINTAINER_ROLE\");\n    bytes32 public constant SUPPORT_ROLE = keccak256(\"SUPPORT_ROLE\");\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n\n    /// @dev StakingRewards config\n    struct StakingConfig {\n        uint256 rewardsDuration;\n        uint256 rewardAmount;\n    }\n\n    /// @dev Reward token for all StakingRewards contracts managed by this contract\n    IERC20 public rewardToken;\n    /// @dev Optional factory contract for creating new StakingRewards contracts\n    StakingRewardsFactory public stakingRewardsFactory;\n    /// @dev Array of managed StakingRewards contracts\n    StakingRewards[] public stakingContracts;\n\n    /// @dev Maps a StakingReward contract to boolean indicating its existence in the stakingContracts array\n    mapping(StakingRewards => bool) public stakingExists;\n    /// @dev Maps a StakingReward contract to its configuration (rewardsDuration and rewardAmount)\n    mapping(StakingRewards => StakingConfig) public stakingConfigs;\n\n    /// @dev Emitted when an existing StakingRewards contract is added to the stakingContracts array\n    event StakingAdded(StakingRewards indexed staking, StakingConfig config);\n    /// @dev Emitted when a StakingRewards contract is removed from the stakingContracts array\n    event StakingRemoved(StakingRewards indexed staking);\n    /// @dev Emitted when configuration for a StakingRewards contract is changed\n    event StakingConfigChanged(\n        StakingRewards indexed staking,\n        StakingConfig config\n    );\n    /// @dev Emitted when the StakingRewards Factory contract is changed\n    event StakingRewardsFactoryChanged(\n        StakingRewardsFactory indexed stakingFactory\n    );\n    /// @dev Emitted when updatePeriodFinish is called on a StakingRewards contract\n    event PeriodFinishUpdated(\n        StakingRewards indexed staking,\n        uint256 newPeriodFinish\n    );\n    /// @dev Emitted when a StakingRewards contract is topped up\n    event ToppedUp(StakingRewards indexed staking, StakingConfig config);\n\n    /// @notice initialize the contract\n    /// @param reward The reward token of all the managed staking contracts\n    function initialize(\n        IERC20 reward,\n        StakingRewardsFactory factory\n    ) external initializer {\n        //check for zero values\n        require(\n            address(factory) != address(0) && address(reward) != address(0),\n            \"StakingRewardsManager: cannot intialize to zero\"\n        );\n\n        // set up default\n        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        // set values\n        rewardToken = reward;\n        stakingRewardsFactory = factory;\n        emit StakingRewardsFactoryChanged(factory);\n    }\n\n    /// @return length uint256 of stakingContracts array\n    function stakingContractsLength() external view returns (uint256) {\n        return stakingContracts.length;\n    }\n\n    /// @return length uint256 of stakingContracts array\n    function getStakingContract(\n        uint256 i\n    ) external view returns (StakingRewards) {\n        return stakingContracts[i];\n    }\n\n    /// @notice Create a new StakingRewards contract via the factory and add it to the stakingContracts array of managed contracts\n    /// @param stakingToken Staking token for the new StakingRewards contract\n    /// @param config Staking configuration\n    function createNewStakingRewardsContract(\n        IERC20 stakingToken,\n        StakingConfig calldata config\n    ) external onlyRole(BUILDER_ROLE) {\n        // create the new staking contract\n        // new staking will have owner and rewardsDistribution set to address(this)\n        StakingRewards staking = StakingRewards(\n            address(\n                stakingRewardsFactory.createStakingRewards(\n                    address(this),\n                    IERC20(address(rewardToken)),\n                    IERC20(stakingToken)\n                )\n            )\n        );\n        //internal call to add new contract\n        _addStakingRewardsContract(staking, config);\n    }\n\n    /// @notice Add a StakingRewards contract\n    /// @dev This contract must be nominated for ownership before the staking contract can be added\n    /// If this contract cannot acceptOwnership of the staking contract this function will revert\n    /// This function WILL NOT REVERT if `staking` does not have the right rewardToken.\n    /// Do not add staking contracts with rewardToken other than the one passed to initialize this contract.\n    /// @param staking Address of the StakingRewards contract to add\n    /// @param config Configuration of the staking contracts\n    function addStakingRewardsContract(\n        StakingRewards staking,\n        StakingConfig calldata config\n    ) external onlyRole(BUILDER_ROLE) {\n        //checking if already exists\n        require(\n            !stakingExists[staking],\n            \"StakingRewardsManager: Staking contract already exists\"\n        );\n        //internal call to add new contract\n        _addStakingRewardsContract(staking, config);\n    }\n\n    /// @notice Add a StakingRewards contract\n    /// @param staking Address of the StakingRewards contract to add\n    /// @param config Configuration of the staking contracts\n    function _addStakingRewardsContract(\n        StakingRewards staking,\n        StakingConfig calldata config\n    ) internal {\n        // in order to manage this contract we have to own it\n        // staking.acceptOwnership();\n        // in order to top up rewards, we have to be rewardsDistribution. this is an onlyOwner function\n        staking.setRewardsDistribution(address(this));\n\n        // push staking onto stakingContracts array\n        stakingContracts.push(staking);\n        // set staking config\n        stakingConfigs[staking] = config;\n        // mark inclusion in the stakingContracts array\n        stakingExists[staking] = true;\n\n        emit StakingAdded(staking, config);\n    }\n\n    /// @notice Remove a StakingRewards contract from the stakingContracts array. This will remove this contract's ability to manage it\n    /// @dev This function WILL NOT transfer ownership of the staking contract. To do this, call `nominateOwnerForStaking`\n    /// @param i Index of staking contract to remove\n    function removeStakingRewardsContract(\n        uint256 i\n    ) external onlyRole(BUILDER_ROLE) {\n        StakingRewards staking = stakingContracts[i];\n\n        // un-mark this staking contract as included in stakingContracts\n        stakingExists[staking] = false;\n        // replace the removed staking contract with the last item in the stakingContracts array\n        stakingContracts[i] = stakingContracts[stakingContracts.length - 1];\n        // pop the last staking contract off the array\n        stakingContracts.pop();\n\n        emit StakingRemoved(staking);\n    }\n\n    /// @notice Set the configuration for a StakingRewards contract\n    /// @dev `staking` does not need to be included in `stakingContracts` for this function to succeed\n    /// @param staking Address of StakingRewards contract\n    /// @param config Staking config\n    function setStakingConfig(\n        StakingRewards staking,\n        StakingConfig calldata config\n    ) external onlyRole(MAINTAINER_ROLE) {\n        // replacing old value\n        stakingConfigs[staking] = config;\n        emit StakingConfigChanged(staking, config);\n    }\n\n    /// @notice Set the StakingRewards Factory contract\n    /// @dev Factory AND StakingRewards contracts must maintain their ABI\n    /// @param factory Address of StakingRewards Factory contract\n    function setStakingRewardsFactory(\n        StakingRewardsFactory factory\n    ) external onlyRole(MAINTAINER_ROLE) {\n        //check for zero values\n        require(\n            address(factory) != address(0),\n            \"StakingRewardsManager: Factory cannot be set to zero\"\n        );\n        //set new value\n        stakingRewardsFactory = factory;\n        emit StakingRewardsFactoryChanged(factory);\n    }\n\n    /// @notice Recover ERC20 tokens from a StakingRewards contract\n    /// @dev This contract must own the staking contract\n    /// @param staking The staking contract to recover tokens from\n    /// @param tokenAddress Address of the ERC20 token contract\n    /// @param tokenAmount Amount of tokens to recover\n    /// @param to The account to send the recovered tokens to\n    function recoverERC20FromStaking(\n        StakingRewards staking,\n        IERC20 tokenAddress,\n        uint256 tokenAmount,\n        address to\n    ) external onlyRole(SUPPORT_ROLE) {\n        // grab the tokens from the staking contract\n        staking.recoverERC20(to, tokenAddress, tokenAmount);\n    }\n\n    /// @notice Recover ERC20 tokens from THIS contract\n    /// @param tokenAddress Address of the ERC20 token contract\n    /// @param tokenAmount Amount of tokens to recover\n    /// @param to The account to send the recovered tokens to\n    function recoverERC20(\n        IERC20 tokenAddress,\n        uint256 tokenAmount,\n        address to\n    ) external onlyRole(SUPPORT_ROLE) {\n        //move funds\n        tokenAddress.safeTransfer(to, tokenAmount);\n    }\n\n    /// @notice change ownership for a staking contract\n    /// @dev This contract must currently own the staking contract\n    /// @param staking The staking contract to transfer ownership of\n    /// @param newOwner Account of new owner\n    function transferStakingOwnership(\n        StakingRewards staking,\n        address newOwner\n    ) external onlyRole(ADMIN_ROLE) {\n        //internal emit is called\n        staking.transferOwnership(newOwner);\n    }\n\n    /// @notice Top up multiple staking contracts\n    /// @param source address from which tokens are taken\n    /// @param indices array of staking contract indices\n    function topUp(\n        address source,\n        uint256[] memory indices\n    ) external onlyRole(EXECUTOR_ROLE) {\n        for (uint i = 0; i < indices.length; i++) {\n            // get staking contract and config\n            StakingRewards staking = stakingContracts[i];\n            StakingConfig memory config = stakingConfigs[staking];\n\n            // will revert if block.timestamp <= periodFinish\n            staking.setRewardsDuration(config.rewardsDuration);\n\n            // pull tokens from owner of this contract to fund the staking contract\n            rewardToken.transferFrom(\n                source,\n                address(staking),\n                config.rewardAmount\n            );\n\n            // start periods\n            staking.notifyRewardAmount(config.rewardAmount);\n\n            emit ToppedUp(staking, config);\n        }\n    }\n}"
    }
  ]
}